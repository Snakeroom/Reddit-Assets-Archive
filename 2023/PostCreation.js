// https://www.redditstatic.com/desktop2x/PostCreation.773a0a9e2804cdcd7a06.js
// Retrieved at 7/20/2023, 4:40:03 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["PostCreation", "Reddit~RichTextEditor~reddit-components-MediumPost~reddit-components-NotificationUnit-Button~removal~87f825ba", "ChatMessageInput~MembershipPaywallPage~RichTextEditor", "ModListing~Reddit~StandalonePostPage", "ContributorRequestButton"], {
		"./src/higherOrderComponents/asModal/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			var o = n("./src/reddit/constants/elementIds.ts");
			const r = () => {
					const e = document.getElementById(o.a);
					e && (e.style.filter = "blur(10px)")
				},
				s = () => {
					const e = document.getElementById(o.a);
					e && e.style.removeProperty("filter")
				}
		},
		"./src/higherOrderComponents/asModal/index.m.less": function(e, t, n) {
			e.exports = {
				overlay: "_1DK52RbaamLOWw5UPaht_S",
				mIsVisible: "_1acwN_tUhJ8w-n7oCp-Aw3",
				mIsBlurred: "_3Tq-_9917Q-o0iyzcNAeZn",
				modal: "_2Bejocqb-InO8686E2ehf"
			}
		},
		"./src/higherOrderComponents/asModal/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return f
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/higherOrderComponents/asModal/helpers.ts"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/FocusTrap/index.ts"),
				c = n("./src/lib/portal/index.tsx"),
				d = n("./src/reddit/actions/shortcuts/utils.ts"),
				l = n("./src/reddit/constants/shortcuts.ts"),
				u = n("./src/reddit/helpers/toggleBodyScroll/index.ts"),
				m = n("./src/higherOrderComponents/asModal/index.m.less"),
				p = n.n(m);

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const b = e => {
				let {
					className: t,
					shouldBlurBackground: n,
					isVisible: o,
					...s
				} = e;
				return r.a.createElement("div", h({
					className: Object(i.a)(p.a.overlay, t, {
						[p.a.mIsVisible]: o,
						[p.a.mIsBlurred]: n
					})
				}, s))
			};

			function f(e) {
				class t extends o.Component {
					constructor(e) {
						super(e), this.getRef = e => this.ref = e, this.onClick = e => e.stopPropagation(), this.onOverlayClick = e => {
							this.props.onOverlayClick && this.props.onOverlayClick(), e.stopPropagation()
						}, this.state = {
							mounted: !1
						}
					}
					componentDidMount() {
						this.props.ignoreDefaultFocus || this.ref && this.ref.focus(), this.setState({
							mounted: !0
						}), Object(u.a)(), this.ref && (this.focusTrap = new a.b(this.ref), this.focusTrap.activate()), this.props.shouldBlurBackground && Object(s.a)()
					}
					componentWillUnmount() {
						this.setState({
							mounted: !1
						}), Object(u.b)(), Object(d.d)(), this.focusTrap && this.focusTrap.deactivate(), this.props.shouldBlurBackground && Object(s.b)()
					}
					render() {
						const {
							props: t
						} = this, {
							className: n,
							ignoreDefaultFocus: o,
							onOverlayClick: s,
							overlayClassName: a,
							overlayCustomStyles: d,
							shouldBlurBackground: u,
							withOverlay: m,
							...h
						} = t, f = h;
						return r.a.createElement(c.a, {
							container: document.getElementById(l.b)
						}, r.a.createElement(b, {
							className: a,
							isVisible: m,
							onClick: this.onOverlayClick,
							shouldBlurBackground: u,
							style: d
						}, r.a.createElement("div", {
							"aria-modal": !0,
							className: Object(i.a)(p.a.modal, n),
							onClick: this.onClick,
							ref: this.getRef,
							role: "dialog",
							tabIndex: -1
						}, r.a.createElement(e, f))))
					}
				}
				return t
			}
		},
		"./src/higherOrderComponents/warnOnChildrenCount/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			n("./src/lib/logs/console.ts");
			t.a = function(e, t) {
				return t => r.a.createElement(e, t)
			}
		},
		"./src/higherOrderComponents/withAdClickLocation/Locations.ts": function(e, t, n) {
			"use strict";
			var o, r;
			n.d(t, "a", (function() {
					return o
				})), n.d(t, "b", (function() {
					return r
				})),
				function(e) {
					e.UNKNOWN = "unknown", e.TITLE = "title", e.TOP_BAR = "top_bar", e.MEDIA = "media", e.BODY = "body", e.BACKGROUND = "background", e.CTA_URL = "cta_url", e.CTA_BUTTON = "cta_button", e.CTA_WHITESPACE = "cta_whitespace", e.CTA_CAPTION = "cta_caption", e.SUBREDDIT = "subreddit", e.TIMESTAMP = "timestamp", e.USER = "user"
				}(o || (o = {})),
				function(e) {
					e.COMMENTS = "comments", e.FLATLIST_SHARE = "fl_share", e.FLATLIST_AWARD = "fl_award", e.FLATLIST_SAVE = "fl_save", e.FLATLIST_GENERAL = "fl_unknown", e.OVERFLOW_MENU = "overflow_menu", e.UPVOTE = "upvote", e.DOWNVOTE = "downvote"
				}(r || (r = {}))
		},
		"./src/lib/FocusTrap/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			}));
			const o = ['input:not([type="hidden"]):not([disabled])', "select:not([disabled])", "textarea:not([disabled])", "a[href]", "button:not([disabled])", '[tabindex]:not([tabindex="-1"]):not([disabled])', "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join();
			class r {
				constructor(e) {
					this.active = !1, this.onKeyDown = e => {
						if ("Tab" === e.key || 9 === e.keyCode) {
							const [t, n] = this.getTabbableNodes();
							if (!t || !n) return;
							e.shiftKey && e.target === t ? (e.preventDefault(), this.tryToFocusNode(n)) : e.shiftKey || e.target !== n || (e.preventDefault(), this.tryToFocusNode(t))
						}
					}, this.container = e
				}
				activate() {
					this.active || (this.active = !0, document.addEventListener("keydown", this.onKeyDown, !0))
				}
				deactivate() {
					this.active && (document.removeEventListener("keydown", this.onKeyDown, !0), this.active = !1)
				}
				getTabbableNodes() {
					const e = this.container.querySelectorAll(o);
					return [e[0], e[e.length - 1]]
				}
				tryToFocusNode(e) {
					e !== document.activeElement && e.focus && e.focus()
				}
			}
		},
		"./src/lib/LinkedListMap/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			class o {
				constructor(e) {
					this.value = e, this.next = void 0, this.prev = void 0
				}
			}
			class r {
				constructor(e) {
					this.key = e, this.tail = void 0, this.head = void 0, this.length = 0, this.itemsByKey = {}
				}
				static fromArray(e, t) {
					const n = new r(t);
					return e.forEach(e => n.push(e)), n
				}
				first() {
					if (this.tail) return this.tail.value
				}
				firstNode() {
					if (this.tail) return this.tail
				}
				forEach(e) {
					let t = this.tail;
					for (; t;) e(t.value), t = t.next
				}
				get(e) {
					const t = this.getNode(e);
					if (t) return t.value
				}
				getNode(e) {
					return this.itemsByKey[e]
				}
				has(e) {
					return e in this.itemsByKey
				}
				insertAfter(e, t) {
					const n = t instanceof o ? t : new o(t),
						r = this.getNode(e);
					if (!r) throw new Error(`Cannot find item with key ${e}`);
					n.prev = r, n.next = r.next, r.next = n, n.next && (n.next.prev = n);
					const s = t instanceof o ? t.value[this.key] : t[this.key];
					this.itemsByKey[s] = n, this.length++
				}
				insertBefore(e, t) {
					const n = t instanceof o ? t : new o(t),
						r = this.getNode(e);
					if (!r) throw new Error(`Cannot find item with key ${e}`);
					n.next = r, n.prev = r.prev, r.prev = n, n.prev && (n.prev.next = n);
					const s = t instanceof o ? t.value[this.key] : t[this.key];
					this.itemsByKey[s] = n, this.length++
				}
				last() {
					if (this.head) return this.head.value
				}
				lastNode() {
					if (this.head) return this.head
				}
				pop() {
					if (!this.head) return;
					return this.removeNode(this.head).value
				}
				push(e) {
					const t = e instanceof o ? e : new o(e);
					t.prev = this.head, this.head ? this.head.next = t : this.tail = t, this.head = t;
					const n = e instanceof o ? t.value[this.key] : e[this.key];
					this.itemsByKey[n] = t, this.length++
				}
				remove(e) {
					const t = this.getNode(e);
					if (t) return this.removeNode(t).value
				}
				removeNode(e) {
					return e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), e === this.tail && (this.tail = e.next), e === this.head && (this.head = e.prev), e.next = void 0, e.prev = void 0, this.itemsByKey[e.value[this.key]] = void 0, this.length--, e
				}
				shift() {
					if (!this.tail) return;
					return this.removeNode(this.tail).value
				}
				toArray() {
					const e = [];
					return this.forEach(t => e.push(t)), e
				}
				unshift(e) {
					const t = e instanceof o ? e : new o(e);
					t.next = this.tail, this.tail ? this.tail.prev = t : this.head = t, this.tail = t;
					const n = e instanceof o ? t.value[this.key] : e[this.key];
					this.itemsByKey[n] = t, this.length++
				}
			}
		},
		"./src/lib/asyncActions/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			}));
			var o = n("./src/lib/makeActionCreator/index.ts");
			const r = e => `${e}_REQUESTED`,
				s = e => `${e}_SUCCEEDED`,
				i = e => `${e}_FAILED`;

			function a(e) {
				const t = r(e),
					n = s(e),
					a = i(e);
				return {
					requestedActionType: t,
					requested: Object(o.a)(t),
					succeededActionType: n,
					succeeded: Object(o.a)(n),
					failedActionType: a,
					failed: Object(o.a)(a)
				}
			}
			var c;
			! function(e) {
				e[e.New = 0] = "New", e[e.Pending = 1] = "Pending", e[e.Succeeded = 2] = "Succeeded", e[e.Failed = 3] = "Failed"
			}(c || (c = {}));
			const d = (e, t, n) => (function() {
				let o = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : c.New,
					r = arguments.length > 1 ? arguments[1] : void 0;
				switch (r.type) {
					case e:
						return o === c.New ? c.Pending : o;
					case t:
						return o === c.Pending ? c.Succeeded : o;
					case n:
						return o === c.Pending ? c.Failed : o;
					default:
						return o
				}
			})
		},
		"./src/lib/avatarShareImages.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			const o = 16765092,
				r = "https://i.redd.it/snoovatar",
				s = "snoovatars",
				i = "avatars";

			function a(e) {
				return `${r}/${+e>=o?i:s}/shared/${e}.png`
			}
		},
		"./src/lib/bigNumberUtils/percent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var o = n("./node_modules/bignumber.js/bignumber.js");

			function r(e, t) {
				const n = new o.BigNumber(e),
					r = new o.BigNumber(t),
					s = new o.BigNumber(n.dividedBy(r)),
					i = new o.BigNumber("100").multipliedBy(s);
				return new o.BigNumber(i).toNumber()
			}
		},
		"./src/lib/colors/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "g", (function() {
				return d
			}));
			const o = "#000",
				r = "#FFF",
				s = "#FF4500",
				i = "#0079D3",
				a = "#46D160",
				c = {
					black: o,
					white: r,
					orangered: s,
					alienblue: i,
					tone1: "#1A1A1B",
					tone2: "#6A6D6F",
					tone3: "#878A8C",
					tone4: "#D3D6DA",
					tone5: "#EDEFF1",
					tone6: "#F6F7F8",
					tone7: "#FFFFFF",
					primary: "#24A0ED",
					secondary: "#006CBF",
					upvote: s,
					downvote: "#7193FF",
					positive: a,
					negative: "#EA0027",
					caution: "#FFB000",
					admin: s,
					moderator: "#46D160",
					self: "#0DD3BB",
					coins: "#DDBD37",
					live: s,
					nsfw: "#FF585B",
					spoiler: "#1A1A1B"
				},
				d = {
					...c,
					tone1: "#D7DADC",
					tone2: "#818384",
					tone3: "#565758",
					tone4: "#3A3A3C",
					tone5: "#272729",
					tone6: "#1A1A1B",
					tone7: "#121213",
					primary: "#006CBF",
					secondary: "#24A0ED",
					coins: "#FFE600",
					spoiler: "#D7DADC"
				}
		},
		"./src/lib/combineRefs/index.tsx": function(e, t, n) {
			"use strict";
			t.a = function() {
				for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
				return e => {
					t.forEach(t => {
						if (t) return "function" == typeof t ? t(e) : void(t.current = e)
					})
				}
			}
		},
		"./src/lib/constants/specialMembership.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			const o = "custom"
		},
		"./src/lib/forEachGroup/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			const o = e => e;

			function r(e, t, n) {
				const [r, s] = Array.isArray(e) ? [e.length, t => e[t]] : [e.size, t => e.get(t)], {
					keyFn: i = o
				} = t || {};
				let {
					start: a = 0,
					end: c = r
				} = t || {};
				if ((a = a < 0 ? 0 : a) >= (c = c > r ? r : c)) return;
				let d = s(a),
					l = i(d, a),
					u = a;
				for (let o = a + 1; o < c; o++) {
					const e = s(o),
						t = i(e, o);
					if (t !== l) {
						if (!1 === n(d, l, u, o)) return;
						l = t, u = o, d = e
					}
				}
				n(d, l, u, c)
			}
		},
		"./src/lib/forceHttps/index.ts": function(e, t, n) {
			"use strict";
			t.a = function(e) {
				return e.startsWith("http") || e.startsWith("blob") ? e.replace(/^http:\/\//i, "https://") : `https://${e}`
			}
		},
		"./src/lib/getShortenedLink.ts": function(e, t, n) {
			"use strict";
			var o = n("./src/reddit/models/Media/index.ts"),
				r = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				s = n.n(r);
			t.a = function(e) {
				var t;
				const {
					source: n,
					isSponsored: r,
					domainOverride: i,
					callToAction: a
				} = e;
				let c = "";
				if (r) {
					if (n && n.displayText) {
						const e = 36 - (null !== (t = null == a ? void 0 : a.length) && void 0 !== t ? t : 0);
						return n.displayText.length > e ? n.displayText.substring(0, e - 3) + "..." : n.displayText
					}
					c = i || Object(o.E)(e)
				} else c = Object(o.E)(e);
				const d = s.a.parse(c),
					l = d.path || "",
					u = l.length > 7 ? l.substring(0, 7) + "..." : l;
				return (d.hostname ? d.hostname.replace("www.", "") : "") + u
			}
		},
		"./src/lib/hooks/usePrevious.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var o = n("./node_modules/react/index.js");

			function r(e) {
				const t = Object(o.useRef)();
				return Object(o.useEffect)(() => {
					t.current = e
				}), t.current
			}
		},
		"./src/lib/hooks/useTooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return c
			}));
			var o = n("./node_modules/icepick/icepick.js"),
				r = n("./node_modules/react/index.js"),
				s = n("./node_modules/react-popper/lib/esm/usePopper.js");
			const i = Object(o.freeze)({
				modifiers: []
			});

			function a(e) {
				let t = "object" == typeof e ? e : i;
				return Array.isArray(t.modifiers) || (t = Object(o.assoc)(t, "modifiers", i.modifiers)), t
			}

			function c(e) {
				const [t, n] = Object(r.useState)(null), [i, c] = Object(r.useState)(null), [d, l] = Object(r.useState)(null), [u, m] = Object(r.useState)(!1), p = Object(r.useCallback)(async () => m(!0), []), h = Object(r.useCallback)(() => m(!1), []), b = Object(r.useCallback)(() => m(!u), [u]), f = Object(r.useMemo)(() => {
					const t = a(e);
					return d ? Object(o.updateIn)(t, ["modifiers"], e => Object(o.push)(e, {
						name: "arrow",
						options: {
							element: d
						}
					})) : t
				}, [d, e]), {
					attributes: g,
					styles: v,
					update: C
				} = Object(s.a)(t, i, f);
				return Object(r.useMemo)(() => ({
					arrowProps: {
						ref: l,
						style: v.arrow,
						...g.arrow
					},
					hide: h,
					popperProps: {
						ref: c,
						style: v.popper,
						...g.popper
					},
					show: p,
					target: {
						element: t,
						ref: n
					},
					toggle: b,
					visible: u,
					update: C
				}), [l, g, c, h, p, v, t, n, b, u, C])
			}
		},
		"./src/lib/humanizeDate/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var o = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				r = n("./src/lib/constants/index.ts"),
				s = n("./src/reddit/constants/intlSupport.ts");

			function i(e) {
				let {
					showDay: t,
					useUtc: n,
					shortMonths: i,
					locale: a = o.DEFAULT_LOCALE
				} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
				const c = new Date(e * r.Xb);
				return s.a ? new Intl.DateTimeFormat(a, {
					month: i ? "short" : "long",
					day: t ? "numeric" : void 0,
					year: "numeric",
					timeZone: n ? "UTC" : void 0
				}).format(c) : c.toLocaleString()
			}
		},
		"./src/lib/humanizeUTCDate/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js");
			t.a = function(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o.DEFAULT_LOCALE;
				const n = e.toString().length > 10,
					r = new Date(e * (n ? 1 : 1e3));
				return r.toLocaleString(t, {
					weekday: "short",
					month: "short",
					year: "numeric",
					day: "2-digit",
					hour: "2-digit",
					minute: "2-digit",
					second: "2-digit",
					timeZoneName: "short",
					timeZone: "UTC"
				})
			}
		},
		"./src/lib/linkMatchers/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return p
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "c", (function() {
				return y
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "i", (function() {
				return O
			}));
			var o = n("./node_modules/linkify-it/index.js"),
				r = n.n(o),
				s = n("./node_modules/tlds/index.js"),
				i = n.n(s),
				a = n("./src/lib/linkMatchers/customLinks.ts"),
				c = n("./node_modules/lodash/values.js"),
				d = n.n(c);
			const l = e => d()(a.b).includes(e.substring(1)),
				u = ["//", "ftp:", "http:", "https:", "mailto:"],
				m = e => ((e, t) => (t.forEach(t => e.add(t, null)), e))(e, u),
				p = r()().tlds(i.a).set({
					fuzzyIP: !0
				}),
				h = r()().set({
					fuzzyIP: !0,
					fuzzyEmail: !1
				}).add(a.g.mention.prefix, a.g.mention.config),
				b = m(r()()).set({
					fuzzyLink: !1,
					fuzzyEmail: !1
				}).add(a.g.subreddit.prefix, a.g.subreddit.config).add(a.g.subredditFull.prefix, a.g.subreddit.config),
				f = m(r()()).set({
					fuzzyLink: !1,
					fuzzyEmail: !1
				}).add(a.g.profile.prefix, a.g.profile.config).add(a.g.profileFull.prefix, a.g.profile.config),
				g = r()().tlds(i.a).set({
					fuzzyIP: !0
				}).add(a.g.subreddit.prefix, a.g.subreddit.config).add(a.g.subredditFull.prefix, a.g.subreddit.config).add(a.g.profile.prefix, a.g.profile.config).add(a.g.profileFull.prefix, a.g.profile.config).add(a.g.mention.prefix, a.g.mention.config),
				v = r()().tlds(i.a).set({
					fuzzyIP: !0,
					fuzzyEmail: !1
				}).add(a.g.subreddit.prefix, a.g.subredditFullUrl.config).add(a.g.subredditFull.prefix, a.g.subredditFullUrl.config),
				C = p.normalize;
			p.normalize = e => {
				C.call(p, e), !e.schema && e.url.startsWith("http:") && (e.url = `https:${e.url.slice(5)}`)
			};
			const y = (e, t) => {
					return (g.match(e) || []).filter(e => {
						const n = l(e.text);
						return !n || n && t
					})
				},
				E = e => {
					return [...f.match(e) || [], ...h.match(e) || []].map(e => !l(e.text) && e.text.replace(a.a, "")).filter(e => e)
				},
				x = (e, t) => {
					const n = e.match(t);
					if (n && 1 === n.length && 0 === n[0].index && n[0].lastIndex === t.length) return n[0]
				},
				O = e => {
					const t = p.match(e);
					if (t && 1 === t.length && 0 === t[0].index) {
						const n = t[0];
						return n.lastIndex === e.length ? n : ((e, t) => {
							const n = e.substring(t.lastIndex);
							if (/.*\/\/.*\/.*/.test(t.url) && /^(\?|\!)+$/.test(n)) return t.lastIndex += n.length, t.url += n, t
						})(e, n)
					}
				}
		},
		"./src/lib/memoizeByReference/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var o = n("./node_modules/lodash/every.js"),
				r = n.n(o);

			function s(e) {
				let t = null,
					n = null;
				return function() {
					for (var o = arguments.length, s = new Array(o), i = 0; i < o; i++) s[i] = arguments[i];
					return null !== t && s.length === t.length && r()(s, (e, n) => e === t[n]) || (t = s, n = e(...s)), n
				}
			}
		},
		"./src/lib/reCaptchaEnterprise/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			}));
			n("./src/lib/reCaptchaEnterprise/reCaptcha.css");
			var o = n("./src/config.ts"),
				r = n("./src/reddit/helpers/loadThirdPartyScript.ts");
			const s = e => "object" == typeof e && null !== e,
				i = () => "undefined" != typeof window && s(window) && s(window.grecaptcha) && s(window.grecaptcha.enterprise),
				a = () => i() ? window.grecaptcha.enterprise : void 0,
				c = e => `https://www.google.com/recaptcha/enterprise.js?render=${e}`,
				d = e => Object(r.a)(c(e), i),
				l = e => new Promise(t => e.ready(t));
			var u, m = n("./node_modules/ts-error/lib/cjs.js"),
				p = n.n(m);
			class MissingReCaptchaEnterpriseSiteKeyError_MissingReCaptchaEnterpriseSiteKeyError extends p.a {
				constructor() {
					super("reCaptcha Enterprise site key is not set")
				}
			}
			class ReCaptchaEnterpriseClientIsNotReadyError_ReCaptchaEnterpriseClientIsNotReadyError extends p.a {
				constructor() {
					super("reCaptcha Enterprise client is not ready")
				}
			}
			class ReCaptchaEnterpriseClientNotAvailableError_ReCaptchaEnterpriseClientNotAvailableError extends p.a {
				constructor() {
					super("reCaptcha Enterprise client is not available")
				}
			}! function(e) {
				e.PageLoad = "PAGE_LOAD", e.PostSubmit = "post_submit"
			}(u || (u = {}));
			var h = u;
			const b = new class {
				constructor() {
					var e = this;
					let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o.a.reCaptchaEnterprise.siteKey,
						n = arguments.length > 1 ? arguments[1] : void 0;
					this.siteKey = t, this.isReady = !1, this.hasSiteKey = () => !!this.siteKey, this.hasClient = () => !!this.instance, this.setInstance = e => {
						e && (this.instance = e, this.isReady = !1)
					}, this.scriptUrl = () => c(this.siteKey), this.ensureSiteKey = () => {
						if (!this.hasSiteKey) throw new MissingReCaptchaEnterpriseSiteKeyError_MissingReCaptchaEnterpriseSiteKeyError
					}, this.ensureClient = () => {
						const e = this.instance;
						if (!e) throw new ReCaptchaEnterpriseClientNotAvailableError_ReCaptchaEnterpriseClientNotAvailableError;
						return e
					}, this.waitUntilClientIsReady = async () => {
						const e = this.ensureClient();
						return await l(e), this.isReady = !0, e
					}, this.ensureClientIsReady = () => {
						const e = this.ensureClient();
						if (!this.isReady) throw new ReCaptchaEnterpriseClientIsNotReadyError_ReCaptchaEnterpriseClientIsNotReadyError;
						return e
					}, this.loadScript = async function() {
						let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						if (!e.instance || t) {
							e.ensureSiteKey(), await d(e.siteKey);
							const t = a();
							if (!t) throw new ReCaptchaEnterpriseClientNotAvailableError_ReCaptchaEnterpriseClientNotAvailableError;
							e.setInstance(t)
						}
						e.isReady || await e.waitUntilClientIsReady()
					}, this.execute = async e => {
						this.ensureSiteKey();
						const t = this.ensureClientIsReady(),
							n = await t.execute(this.siteKey, e);
						if (e.fast) {
							return JSON.parse(n)[1]
						}
						return n
					}, this.setInstance(n || a())
				}
			};
			t.b = b
		},
		"./src/lib/reCaptchaEnterprise/reCaptcha.css": function(e, t, n) {},
		"./src/lib/scroll/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			}));
			var o = n("./src/lib/domUtils/index.ts"),
				r = n("./src/lib/fastdom/index.ts"),
				s = n("./src/reddit/components/CommentSort/index.tsx"),
				i = n("./src/reddit/constants/elementIds.ts");
			const a = () => {
					r.a.write(() => {
						const e = document.getElementById(i.e);
						e ? Object(o.c)(e, 0) : Object(o.c)(document, 0)
					})
				},
				c = e => {
					r.a.read(() => {
						const t = e ? document.getElementById(i.e) : window,
							n = document.getElementById(s.a);
						if (t && n) {
							const o = e ? n.offsetTop : n.offsetTop - 50;
							r.a.write(() => t.scrollTo({
								top: o,
								behavior: "smooth"
							}))
						}
					})
				}
		},
		"./src/lib/timeUntil/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts");
			const s = [r.yc, r.ub, r.D, r.U, r.pb, r.Xb],
				i = {
					[r.Xb]: e => o.fbt._({
						"*": "{number} seconds",
						_1: "1 second"
					}, [o.fbt._plural(e, "number")], {
						hk: "3pTp9Z"
					}),
					[r.pb]: e => o.fbt._({
						"*": "{number} minutes",
						_1: "1 minute"
					}, [o.fbt._plural(e, "number")], {
						hk: "2gB3sf"
					}),
					[r.U]: e => o.fbt._({
						"*": "{number} hours",
						_1: "1 hour"
					}, [o.fbt._plural(e, "number")], {
						hk: "2w4n8B"
					}),
					[r.D]: e => o.fbt._({
						"*": "{number} days",
						_1: "1 day"
					}, [o.fbt._plural(e, "number")], {
						hk: "3zIGRH"
					}),
					[r.ub]: e => o.fbt._({
						"*": "{number} months",
						_1: "1 month"
					}, [o.fbt._plural(e, "number")], {
						hk: "28DQqD"
					}),
					[r.yc]: e => o.fbt._({
						"*": "{number} years",
						_1: "1 year"
					}, [o.fbt._plural(e, "number")], {
						hk: "Gqzh3"
					})
				},
				a = {
					[r.Xb]: e => o.fbt._("{amount}s", [o.fbt._param("amount", String(e))], {
						hk: "F4qog"
					}),
					[r.pb]: e => o.fbt._("{amount}m", [o.fbt._param("amount", String(e))], {
						hk: "43tM5H"
					}),
					[r.U]: e => o.fbt._("{amount}h", [o.fbt._param("amount", String(e))], {
						hk: "19NsxU"
					}),
					[r.D]: e => o.fbt._("{amount}d", [o.fbt._param("amount", String(e))], {
						hk: "39MDc9"
					}),
					[r.ub]: e => o.fbt._("{amount}m", [o.fbt._param("amount", String(e))], {
						hk: "28feBj"
					}),
					[r.yc]: e => o.fbt._("{amount}y", [o.fbt._param("amount", String(e))], {
						hk: "10bv8G"
					}),
					[r.ub]: e => o.fbt._("{amount}m", [o.fbt._param("amount", String(e))], {
						hk: "28feBj"
					}),
					[r.yc]: e => o.fbt._("{amount}y", [o.fbt._param("amount", String(e))], {
						hk: "10bv8G"
					})
				};

			function c(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
					n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
				const c = Date.now(),
					d = new Date(e).getTime(),
					l = {
						[r.yc]: "",
						[r.ub]: "",
						[r.D]: "",
						[r.U]: "",
						[r.pb]: "",
						[r.Xb]: ""
					};
				let u = d - c;
				if (u <= 0) return o.fbt._("a moment", null, {
					hk: "3QLaye"
				}).toString();
				for (const o of s) {
					const e = Math.floor(u / o);
					e && (l[o] = (t ? a : i)[o](e).toString()), u -= e * o
				}
				const m = s.map(e => l[e]).filter(Boolean).slice(0, 2).join(" ");
				return t || n ? m : o.fbt._("{amount of time left} left", [o.fbt._param("amount of time left", m)], {
					hk: "7VjAI"
				}).toString()
			}
		},
		"./src/reddit/actions/comment/authoring.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return he
			})), n.d(t, "r", (function() {
				return ge
			})), n.d(t, "p", (function() {
				return ve
			})), n.d(t, "t", (function() {
				return Ee
			})), n.d(t, "w", (function() {
				return xe
			})), n.d(t, "q", (function() {
				return Oe
			})), n.d(t, "v", (function() {
				return je
			})), n.d(t, "o", (function() {
				return Se
			})), n.d(t, "m", (function() {
				return we
			})), n.d(t, "b", (function() {
				return Pe
			})), n.d(t, "c", (function() {
				return Me
			})), n.d(t, "s", (function() {
				return De
			})), n.d(t, "g", (function() {
				return Le
			})), n.d(t, "h", (function() {
				return Ae
			})), n.d(t, "k", (function() {
				return Fe
			})), n.d(t, "e", (function() {
				return Ue
			})), n.d(t, "d", (function() {
				return He
			})), n.d(t, "a", (function() {
				return Ve
			})), n.d(t, "j", (function() {
				return ze
			})), n.d(t, "i", (function() {
				return Je
			})), n.d(t, "l", (function() {
				return Xe
			})), n.d(t, "u", (function() {
				return Ze
			})), n.d(t, "n", (function() {
				return $e
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/makeDraftKey/index.ts"),
				i = n("./src/lib/scroll/index.ts"),
				a = n("./src/reddit/actions/changeUsername.ts"),
				c = n("./src/reddit/actions/login.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				l = n("./src/reddit/actions/onboarding/index.ts"),
				u = n("./src/reddit/actions/post.ts"),
				m = n("./src/reddit/actions/postCreation/editorContent.ts"),
				p = n("./src/reddit/actions/shortcuts/utils.ts"),
				h = n("./src/reddit/actions/toaster.ts"),
				b = n("./src/reddit/constants/adEvents.ts"),
				f = n("./src/reddit/constants/localStorage.ts"),
				g = n("./src/redditGQL/operations/CommentToxicity.json"),
				v = n("./src/lib/constants/index.ts"),
				C = n("./src/lib/makeApiRequest/index.ts"),
				y = n("./src/lib/makeGqlRequest/index.ts"),
				E = n("./src/lib/omitHeaders/index.ts"),
				x = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				O = n("./src/reddit/constants/headers.ts"),
				_ = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				k = n("./src/reddit/helpers/genericServerError/index.ts"),
				j = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				S = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				T = n("./src/reddit/models/PostCreationForm/index.ts"),
				w = n("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				I = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				P = n("./src/reddit/helpers/graphql/helpers.ts"),
				N = n("./src/reddit/helpers/graphql/normalizeCommentFromGql/index.ts"),
				R = n("./src/redditGQL/operations/CreateComment.json");
			const M = (e, t, n, o) => {
					let r, s;
					if (o === T.i.MARKDOWN) r = n.text, s = null;
					else {
						r = null;
						let e = null;
						n.rteState && (e = x.a.toRichTextJSON(n.rteState).document), s = JSON.stringify({
							document: e
						})
					}
					return Object(y.a)(e, {
						...g,
						variables: {
							subredditName: t,
							markdown: r,
							richText: s
						}
					}).then(e => !e.ok || e.body.data.isValidComment)
				},
				D = async (e, t, n, o) => {
					const r = {
						api_type: "json",
						return_rtjson: !0,
						thing_id: t
					};
					return n.commentMode === T.i.MARKDOWN ? r.text = n.text : (r.text = null, r.richtext_json = o), Object(C.a)(Object(E.a)(e, [O.a]), {
						method: v.ob.POST,
						endpoint: Object(_.a)(Object(w.a)(Object(I.a)(`${e.apiUrl}/api/comment.json`))),
						data: r
					}).then(e => e.ok ? e.body.json ? e.body.json.errors.length ? {
						...e,
						ok: !1,
						error: Object(S.a)(e)
					} : {
						...e,
						body: {
							comment: Object(j.a)(e.body.json.data.things[0].data)
						}
					} : {
						...e,
						body: {
							comment: Object(j.a)(e.body)
						}
					} : {
						...e,
						error: e.error || Object(k.a)()
					})
				}, L = async (e, t, n, o, r) => {
					const s = o.commentMode === T.i.MARKDOWN,
						i = {
							postId: t || null,
							parentId: n || null,
							content: {
								markdown: s ? o.text : null,
								richText: s ? null : r
							}
						};
					return Object(y.a)(e, {
						...R,
						variables: {
							input: i
						}
					}).then(e => {
						if (e.ok) {
							const t = e.body.data.createComment;
							if ((null == t ? void 0 : t.fieldErrors) && t.fieldErrors.length > 0) return {
								...e,
								ok: !1,
								error: Object(P.e)(t.fieldErrors)
							};
							if ((null == t ? void 0 : t.errors) && t.errors.length > 0) return {
								...e,
								ok: !1,
								error: Object(P.f)(t.errors)
							};
							if (t.ok) return {
								...e,
								body: {
									comment: Object(N.a)(t.commentInfo)
								}
							}
						}
						return {
							...e,
							ok: !1,
							error: e.error || Object(k.a)()
						}
					})
				};
			var A = n("./src/redditGQL/operations/UpdateComment.json");
			var F = n("./src/redditGQL/operations/UpdateCommentFollowState.json");
			var B = n("./src/reddit/endpoints/post/index.tsx"),
				U = n("./src/reddit/endpoints/post/convert.ts"),
				K = n("./src/reddit/featureFlags/index.ts"),
				W = n("./src/reddit/helpers/comment/index.ts"),
				G = n("./src/reddit/helpers/correlationIdTracker.ts"),
				H = n("./src/reddit/helpers/dom/index.ts"),
				V = n("./src/reddit/helpers/localStorage/index.ts"),
				z = n("./src/reddit/helpers/sessionStorage/index.ts"),
				q = n("./src/reddit/helpers/trackers/commentsPage.ts"),
				Q = n("./src/reddit/models/Comment/index.ts"),
				Y = n("./src/reddit/models/PostDraft/index.ts"),
				J = n("./src/reddit/models/RichTextJson/index.ts"),
				X = n("./src/reddit/models/RichTextJson/nodeMakers.ts"),
				Z = n("./src/reddit/models/Toast/index.ts"),
				$ = n("./src/reddit/selectors/chatPost.ts"),
				ee = n("./src/reddit/selectors/comments.ts"),
				te = n("./src/reddit/selectors/commentSelector.ts"),
				ne = n("./src/reddit/selectors/experiments/chat.ts"),
				oe = n("./src/reddit/constants/experiments.ts"),
				re = n("./src/reddit/helpers/chooseVariant/index.ts"),
				se = n("./node_modules/reselect/es/index.js");
			const ie = Object(se.a)(e => Object(re.c)(e, {
				experimentEligibilitySelector: re.a,
				experimentName: oe.Lb
			}), e => e === oe.Yd);
			var ae = n("./src/reddit/selectors/experiments/contributeBeforeSignUp.ts"),
				ce = n("./src/reddit/selectors/platform.ts"),
				de = n("./src/reddit/selectors/posts.ts"),
				le = n("./src/reddit/selectors/user.ts"),
				ue = n("./src/reddit/actions/comment/index.ts"),
				me = n("./src/reddit/actions/comment/constants.ts");
			const pe = Object(r.a)(me.m),
				he = e => {
					let {
						hasFocus: t,
						draftKey: n
					} = e;
					return async (e, o) => {
						const r = o();
						if (!!r.features.comments.drafts[n])
							if (Object(le.U)(r) && t) {
								const o = pe({
									hasFocus: t,
									draftKey: n
								});
								e(Object(a.startChangeUsernameFlow)(o))
							} else e(pe({
								hasFocus: t,
								draftKey: n
							}))
					}
				},
				be = Object(r.a)(me.L),
				fe = Object(r.a)(me.H),
				ge = Object(r.a)(me.N),
				ve = Object(r.a)(me.M),
				Ce = Object(r.a)(me.K),
				ye = async (e, t, n, o, r) => {
					const s = o.ok && o.body,
						i = s && s.comment && s.comment.id;
					await q.g(e, n, t, r, i)
				}, Ee = "Toxicity_Warning__Modal", xe = e => async (t, n, o) => {
					let {
						gqlContext: r
					} = o;
					const s = n(),
						i = Object(ce.e)(s);
					let a = "";
					i && (a = i.name);
					const {
						formData: c,
						editorMode: l
					} = e;
					if (K.d.enableToxicityWarning(s)) {
						if (!(await M(r(), a, c, l))) return void t(Object(d.i)(Ee))
					}
					t(Oe(e))
				}, Oe = e => async (t, n) => {
					t(Object(d.g)(Ee));
					const o = n(),
						r = Object(ae.a)(o),
						s = Object(ae.c)(o);
					if (!o.user.account && r) {
						const n = Object(W.e)(e.formData, o.uploads),
							r = Object(W.d)(e.formData, o.uploads);
						t(Object(d.k)({
							actionSource: d.a.Reply
						})), t(Object(c.openRegisterModal)()), Object(z.d)({
							comment: {
								...e,
								richTextJSONData: n,
								commentBodyText: r
							},
							isSkipOnboarding: s
						})
					} else t(ke(e, !1))
				};

			function _e(e, t) {
				return e === T.i.MARKDOWN && ie(t)
			}
			const ke = (e, t, n, r) => {
					let {
						postId: s,
						commentsPageKey: a,
						draftKey: c,
						formData: d,
						editorMode: l,
						disableAutofocus: m
					} = e;
					return async (e, f, g) => {
						let {
							apiContext: v,
							gqlContext: C
						} = g;
						var y;
						const E = f(),
							x = Object($.d)(E, {
								postId: s
							}),
							O = x ? Object(W.b)() : c,
							_ = Object(te.f)(E, {
								commentId: O
							}),
							k = Object(le.m)(E);
						if (!k) return;
						if (_ && !x) return;
						t || e(be({
							draftKey: O,
							draft: d,
							commentsPageKey: a,
							optimisticComment: x ? Object(W.c)({
								temporalId: O,
								draft: d,
								post: Object(de.F)(E, {
									postId: s
								}),
								author: k,
								subredditId: (null === (y = Object(ce.e)(E)) || void 0 === y ? void 0 : y.id) || ""
							}) : void 0
						}));
						const j = d.commentMode;
						let S;
						const w = t && n ? n : Object(W.e)(d, E.uploads),
							I = Object(W.f)(w, E.uploads);
						if ((S = _e(j, E) ? await L(C(), s, null, d, w) : await D(v(), s, d, w)).ok) {
							const n = S.body;
							if (e(ge({
									...n,
									headCommentId: Object(ee.w)(E, {
										commentsPageKey: a
									}),
									commentsPageKey: a,
									draftKey: O,
									upload: I
								})), t) {
								const e = Object(ce.i)(E);
								Object(i.a)(!!e)
							}
							const o = Object(de.F)(f(), {
								postId: s
							});
							e(Object(u.y)(o, b.a.CommentSubmitted))
						} else {
							if (S.error) {
								const e = t && r ? r : Object(W.d)(d, E.uploads);
								q.f({
									state: E,
									bodyText: e,
									postId: s,
									error: S.error,
									uploadMetadata: null == I ? void 0 : I.metadata
								})
							}
							const n = S.error && S.error.fields && S.error.fields[0] ? S.error.fields[0].msg : o.fbt._("Something went wrong", null, {
								hk: "LWFS0"
							});
							e(Ce({
								draftKey: O,
								error: S.error
							})), x || e(Object(h.f)({
								duration: h.a,
								kind: Z.b.Error,
								text: n
							}))
						}
						ye(f(), a, l, S, null == I ? void 0 : I.metadata).then(() => S.ok && l === T.i.RICH_TEXT ? Object(G.b)(G.a.CommentComposer) : void 0), m || Object(p.d)(), t && Object(z.a)()
					}
				},
				je = e => async (t, n, o) => {
					let {
						gqlContext: r
					} = o;
					const {
						parentCommentId: s,
						commentsPageKey: i,
						parentCommentDepth: a,
						draftKey: c,
						formData: l,
						editorMode: u
					} = e, m = n(), p = Object(ce.e)(m);
					let h = "";
					if (p && (h = p.name), K.d.enableToxicityWarning(m)) {
						if (!(await M(r(), h, l, u))) return void t(Object(d.i)(Ee))
					}
					t(Se({
						commentsPageKey: i,
						draftKey: c,
						parentCommentDepth: a,
						parentCommentId: s,
						formData: l,
						editorMode: u
					}))
				}, Se = e => async (t, n) => {
					t(Object(d.g)(Ee));
					const o = n(),
						r = Object(ae.a)(o),
						s = Object(ae.c)(o);
					if (!o.user.account && r) {
						const n = Object(W.e)(e.formData, o.uploads),
							r = Object(W.d)(e.formData, o.uploads);
						t(Object(d.k)({
							actionSource: d.a.Reply
						})), t(Object(c.openRegisterModal)()), Object(z.d)({
							comment: {
								...e,
								richTextJSONData: n,
								commentBodyText: r
							},
							isSkipOnboarding: s
						})
					} else t(Te(e, !1))
				}, Te = (e, t, n, o) => async (r, s, a) => {
					let {
						apiContext: c,
						gqlContext: d
					} = a;
					var l;
					const {
						parentCommentId: u,
						commentsPageKey: m,
						parentCommentDepth: h,
						draftKey: b,
						formData: f,
						editorMode: g
					} = e, v = s(), C = Object(te.c)(v, {
						commentId: u
					}), y = C && Object($.d)(v, {
						postId: C.postId
					}) && Object(ne.e)(v), E = C && Object($.d)(v, {
						postId: C.postId
					}), x = E ? Object(W.b)() : b, O = Object(te.f)(v, {
						commentId: x
					}), _ = Object(le.m)(v);
					if (!_) return;
					if (O && !E) return;
					t || r(be({
						draftKey: x,
						draft: f,
						commentsPageKey: m,
						optimisticComment: E && C ? Object(W.c)({
							temporalId: x,
							draft: f,
							post: Object(de.F)(v, {
								postId: C.postId
							}),
							author: _,
							subredditId: (null === (l = Object(ce.e)(v)) || void 0 === l ? void 0 : l.id) || "",
							parentId: C.id
						}) : void 0
					})), y || r(Pe({
						parentCommentId: u,
						commentsPageKey: m
					}));
					const k = f.commentMode,
						j = t && n ? n : Object(W.e)(f, v.uploads),
						S = Object(W.f)(j, v.uploads);
					let T;
					if ((T = _e(k, v) ? await L(d(), null, u, f, j) : await D(c(), u, f, j)).ok) {
						if (r(ve({
								...T.body,
								parentCommentId: u,
								commentsPageKey: m,
								draftKey: x,
								depth: h + 1,
								upload: S
							})), t) {
							const e = Object(ce.i)(v);
							Object(i.a)(!!e)
						}
					} else {
						if (T.error) {
							if (!C) return;
							const e = t && o ? o : Object(W.d)(f, v.uploads);
							q.f({
								state: v,
								bodyText: e,
								postId: C.postId,
								parentId: u,
								error: T.error,
								uploadMetadata: null == S ? void 0 : S.metadata
							})
						}
						r(Ce({
							draftKey: x,
							error: T.error
						}))
					}
					ye(s(), m, g, T, null == S ? void 0 : S.metadata), y || Object(p.d)(), t && Object(z.a)()
				}, we = () => async e => {
					const t = Object(z.b)();
					if (t) {
						const {
							comment: {
								parentCommentDepth: n,
								parentCommentId: o,
								postId: r,
								richTextJSONData: s,
								commentBodyText: i
							},
							isSkipOnboarding: a
						} = t;
						a && e(Object(l.skipOnboardingModal)()), r ? await e(ke({
							...t.comment,
							postId: r
						}, !0, s, i)) : o && void 0 !== n && await e(Te({
							...t.comment,
							parentCommentId: o,
							parentCommentDepth: n
						}, !0, s, i))
					}
				}, Ie = Object(r.a)(me.s), Pe = Object(r.a)(me.r), Ne = Object(r.a)(me.n), Re = (Object(r.a)(me.i), Object(r.a)(me.o)), Me = (Object(r.a)(me.v), (e, t, n) => async (r, s, i) => {
					let {
						apiContext: a
					} = i;
					const c = e === T.i.RICH_TEXT;
					if (!t || "object" == typeof t && Object(J.I)(t)) r(Re({
						editorMode: e,
						draftKey: n,
						content: c ? J.j : ""
					})), r(Object(m.c)(e));
					else {
						r(Object(m.b)(n));
						const s = await Object(U.a)(a(), e, c ? t : JSON.stringify(t));
						if (s.ok) {
							const t = s.body.output;
							r(Object(m.a)(n)), r(Re({
								editorMode: e,
								draftKey: n,
								content: t
							})), r(Object(m.c)(e))
						} else r(Object(m.a)(n)), r(Object(h.f)({
							duration: h.a,
							kind: Z.b.Error,
							text: o.fbt._("Something went wrong", null, {
								hk: "LWFS0"
							})
						}))
					}
				}), De = e => {
					let {
						commentsPageKey: t,
						parentCommentId: n,
						singleOpen: o
					} = e;
					return async (e, r) => {
						const i = r(),
							l = Object(s.a)(Y.c.replyToComment, n);
						if (!Object(le.S)(r()) && !Object(ae.a)(i)) return e(Object(c.openRegisterModal)()), void e(Object(d.k)({
							actionSource: d.a.Reply,
							redirectUrl: Object(ee.m)(r(), {
								commentId: n
							})
						}));
						const u = i.features.comments.replyFormOpen[t],
							m = u && u[n];
						if ((m || u && o) && (Object.keys(u).forEach(n => u[n] && e(Pe({
								parentCommentId: n,
								commentsPageKey: t
							}))), m)) return;
						let p = "",
							h = null;
						const b = i.user.prefs.commentMode,
							f = Object(H.d)();
						if (f) {
							const e = f.filter(e => !!e && 10 !== e.charCodeAt(0));
							if (b === T.i.MARKDOWN) p = e.map(e => `> ${e}\n`).join("");
							else {
								const t = e.map(e => X.s(e, null)).map(e => X.l([e])),
									n = X.s("", null),
									o = X.l([n]);
								h = {
									document: [X.c(t), o]
								}
							}
						}
						const g = i.features.comments.drafts[l];
						let v;
						if (v = f ? {
								commentMode: b,
								draftType: Y.c.replyToComment,
								rtJson: h,
								text: `${p}\n`
							} : g || {
								commentMode: b,
								draftType: Y.c.replyToComment,
								rtJson: h,
								text: ""
							}, Object(le.U)(i)) {
							const o = Ie({
								parentCommentId: n,
								commentsPageKey: t,
								draftKey: l,
								formData: v
							});
							e(Object(a.startChangeUsernameFlow)(o))
						} else e(Ie({
							parentCommentId: n,
							commentsPageKey: t,
							draftKey: l,
							formData: v
						}))
					}
				}, Le = e => async t => {
					t(Object(ue.r)(e)), t(Ue(e))
				}, Ae = e => {
					let {
						parentCommentId: t,
						commentsPageKey: n
					} = e;
					return async e => {
						e(Pe({
							parentCommentId: t,
							commentsPageKey: n
						})), e(De({
							parentCommentId: t,
							commentsPageKey: n
						})), e(Object(ue.r)({
							commentId: t,
							commentsPageKey: n
						}))
					}
				}, Fe = (e, t) => n => n(Ne({
					draftKey: e,
					formData: t
				})), Be = Object(r.a)(me.u), Ue = e => {
					let {
						commentId: t,
						commentMode: n,
						commentsPageKey: o,
						draftKey: r,
						text: s
					} = e;
					return async (e, i) => {
						const a = i();
						a.user.account && (q.c(a), e(Be({
							commentId: t,
							commentsPageKey: o,
							draftKey: r,
							formData: {
								text: s,
								commentMode: n,
								rteState: null,
								draftType: Y.c.edit,
								hasFocus: !0
							}
						})))
					}
				}, Ke = Object(r.a)(me.F), We = Object(r.a)(me.E), Ge = Object(r.a)(me.G), He = Object(r.a)(me.j), Ve = Object(r.a)(me.f), ze = e => {
					let {
						id: t,
						commentsPageKey: n,
						draftKey: o,
						formData: r
					} = e;
					return async (e, s, i) => {
						let {
							apiContext: a,
							gqlContext: c
						} = i;
						const d = s();
						if (!d.user.account) return;
						e(Ke({
							draftKey: o
						})), q.d(d);
						const l = Object(W.e)(r, d.uploads),
							u = r.commentMode;
						let m;
						if ((m = _e(u, d) ? await (async (e, t, n, o, r) => {
								const s = r === T.i.MARKDOWN,
									i = {
										commentId: t,
										content: {
											markdown: s ? n.text : null,
											richText: s ? null : o
										}
									};
								return Object(y.a)(e, {
									...A,
									variables: {
										input: i
									}
								}).then(e => {
									if (e.ok) {
										const t = e.body.data.updateComment;
										if ((null == t ? void 0 : t.fieldErrors) && t.fieldErrors.length > 0) return {
											...e,
											ok: !1,
											error: Object(P.e)(t.fieldErrors)
										};
										if ((null == t ? void 0 : t.errors) && t.errors.length > 0) return {
											...e,
											ok: !1,
											error: Object(P.f)(t.errors)
										};
										if (t.ok) return {
											...e,
											body: {
												comment: {
													...Object(N.c)(t.content)
												}
											}
										}
									}
									return {
										...e,
										ok: !1,
										error: e.error || Object(k.a)()
									}
								})
							})(c(), t, r, l, u) : await (async (e, t, n, o, r) => {
								const s = {
									api_type: "json",
									return_rtjson: !0,
									thing_id: t
								};
								return r === T.i.MARKDOWN ? s.text = n.text : (s.text = null, s.richtext_json = o), Object(C.a)(Object(E.a)(e, [O.a]), {
									endpoint: Object(_.a)(Object(I.a)(Object(w.a)(`${e.apiUrl}/api/editusertext`))),
									method: v.ob.POST,
									data: s
								}).then(e => e.ok ? e.body.json ? e.body.json.errors.length ? {
									...e,
									ok: !1,
									error: Object(S.a)(e)
								} : {
									...e,
									body: {
										comment: Object(j.a)(e.body.json.data.things[0].data)
									}
								} : {
									...e,
									body: {
										comment: Object(j.a)(e.body)
									}
								} : {
									...e,
									error: e.error || Object(k.a)()
								})
							})(a(), t, r, l, u)).ok) {
							const r = m.body;
							e(Ge({
								commentId: t,
								commentsPageKey: n,
								draftKey: o
							})), e(Object(ue.j)({
								[t]: {
									...r.comment
								}
							}))
						} else e(We({
							draftKey: o,
							error: m.error
						}))
					}
				}, qe = Object(r.a)(me.C), Qe = Object(r.a)(me.B), Ye = Object(r.a)(me.D), Je = (e, t) => async (n, o, r) => {
					let {
						apiContext: s
					} = r;
					const i = o();
					n(qe({
						id: e
					})), q.a(e, i);
					const a = await ((e, t) => Object(C.a)(Object(E.a)(e, [O.a]), {
						endpoint: Object(_.a)(`${e.apiUrl}/api/del`),
						method: v.ob.POST,
						data: {
							id: t
						}
					}).then(e => e.ok ? e.body.json && e.body.json.errors.length ? {
						...e,
						ok: !1,
						error: Object(S.a)(e)
					} : {
						...e,
						body: {}
					} : {
						...e,
						error: e.error || Object(k.a)()
					}))(s(), e);
					a.ok ? n(Ye({
						id: e,
						postId: t
					})) : n(Qe({
						id: e,
						error: a.error
					}))
				}, Xe = e => async (t, n, o) => {
					let {
						apiContext: r
					} = o;
					const s = !n().features.comments.models[e].sendReplies;
					t(Object(ue.j)({
						[e]: {
							sendReplies: s
						}
					})), (await Object(B.p)(r(), e, s)).ok || t(Object(ue.j)({
						[e]: {
							sendReplies: !s
						}
					}))
				}, Ze = (e, t) => async (n, r, s) => {
					let {
						gqlContext: i
					} = s;
					var a, c, d, l, u, m;
					n(Object(ue.c)());
					const p = e => Object(h.f)(Object(h.e)(e, Z.b.Error));
					if (((null === (c = null === (a = r().pages) || void 0 === a ? void 0 : a.comments) || void 0 === c ? void 0 : c.followed) || []).length === f.a) n(p(o.fbt._("You've reached your post follow limit", null, {
						hk: "3ebRql"
					})));
					else {
						const s = t === Q.a.FOLLOWED,
							a = {
								id: e,
								expiresAt: Date.now() + 6048e5
							};
						if (n(Object(ue.p)(a)), (await ((e, t) => Object(y.a)(e, {
								...F,
								variables: {
									input: t
								}
							}))(i(), {
								commentId: e,
								followState: t
							})).ok) {
							Object(V.yb)(null !== (u = null === (l = null === (d = r().pages) || void 0 === d ? void 0 : d.comments) || void 0 === l ? void 0 : l.followed) && void 0 !== u ? u : [], null === (m = r().user.account) || void 0 === m ? void 0 : m.id);
							const e = s ? o.fbt._("Followed! Youll get updates when theres new activity.", null, {
								hk: "2O1Ou3"
							}) : o.fbt._("Unfollowed. You wont get updates on this comment anymore.", null, {
								hk: "4EAz6O"
							});
							n(Object(h.f)({
								kind: Z.b.SuccessCommunityGreen,
								text: e
							}))
						} else n(Object(ue.p)(a)), n(p(o.fbt._("Sorry, we had trouble doing that. Please try again.", null, {
							hk: "2N0vVk"
						})))
					}
				};

			function $e(e) {
				let {
					commentId: t,
					commentsPageKey: n
				} = e;
				return async (e, o) => {
					const r = o(),
						s = Object(te.c)(r, {
							commentId: t
						});
					if (!s) return;
					e(fe({
						commentId: t,
						commentsPageKey: n
					}));
					const i = {
						commentMode: s.media.rteMode,
						draftType: s.parentId ? Y.c.replyToComment : Y.c.replyToPost,
						rtJson: s.media.richtextContent,
						hasFocus: !0,
						text: ""
					};
					if (s.parentId) {
						const t = Object(te.c)(r, {
								commentId: s.parentId
							}),
							o = Object(ee.j)(r, {
								commentId: s.parentId,
								commentLink: void 0,
								commentsPageKey: n
							});
						if (!t || null === o) return;
						await e(Se({
							commentsPageKey: n,
							draftKey: s.id,
							parentCommentDepth: o,
							parentCommentId: t.id,
							formData: i,
							editorMode: s.media.rteMode
						}))
					} else await e(Oe({
						postId: s.postId,
						commentsPageKey: n,
						draftKey: s.id,
						formData: i,
						editorMode: s.media.rteMode,
						disableAutofocus: !0
					}))
				}
			}
		},
		"./src/reddit/actions/crosspostSubredditRec/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return l
			}));
			var o = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/postCreation/general.ts"),
				s = n("./src/reddit/selectors/experiments/crosspostRecommendations.ts");
			var i = n("./src/lib/initializeClient/installReducer.ts");
			var a = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "CROSSPOST_RECOMMENDATIONS__SHOULD_TRY_TO_RENDER":
						return !0;
					case "CROSSPOST_RECOMMENDATIONS__STOP_TRYING_TO_RENDER":
						return !1;
					default:
						return e
				}
			};
			Object(i.a)({
				features: {
					shouldTryToShowCrosspostModal: a
				}
			});
			const c = Object(o.a)("CROSSPOST_RECOMMENDATIONS__SHOULD_TRY_TO_RENDER"),
				d = Object(o.a)("CROSSPOST_RECOMMENDATIONS__STOP_TRYING_TO_RENDER"),
				l = e => async (t, n) => {
					const o = n();
					if (!Object(s.b)(o)) return;
					const i = e.title,
						a = Object(s.d)(e),
						c = Object(s.c)(e);
					t(Object(r.j)(i, a, c, t => {
						const n = e.belongsTo.id === t.id,
							o = "isCrosspostDestination" in t && t.isCrosspostDestination;
						return n || !o
					}))
				}
		},
		"./src/reddit/actions/economics/claims/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return r
			}));
			const o = "ECONOMICS__CLAIMS__CLAIM_PENDING",
				r = "ECONOMICS__CLAIMS__CLAIM_COMPLETED"
		},
		"./src/reddit/actions/economics/me/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			}));
			const o = "ECONOMICS__ME__ME_DATA_SUCCESS",
				r = "ECONOMICS__ME__POINTS_COPY_REQUESTED",
				s = "ECONOMICS__ME__POINTS_COPY_SUCCESS"
		},
		"./src/reddit/actions/economics/me/thunkedActions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			}));
			var o = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeRequest/index.ts"),
				s = n("./src/config.ts"),
				i = n("./src/reddit/endpoints/governance/requester.ts");
			var a = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/reddit/actions/economics/me/constants.ts");
			const d = Object(a.a)(c.a),
				l = Object(a.a)(c.b),
				u = Object(a.a)(c.c),
				m = e => async (t, n, o) => {
					let {
						apiContext: r
					} = o;
					const a = e && e.includeMemberships || !1,
						c = e && e.forceFetch || !1,
						l = n();
					if (!l.economics.me.fetched || a && !l.economics.me.data.specialMemberships || c) {
						const e = await
						function(e, t) {
							return Object(i.a)(e, {
								method: "get",
								endpoint: `${s.a.metaUrl}/users/me${t?"?fields=specialMemberships":""}`
							})
						}(r(), a);
						if (e.ok) {
							const n = e.body;
							a && !n.specialMemberships && (n.specialMemberships = {}), t(d(n))
						}
					}
				}, p = () => async (e, t) => {
					const n = t(),
						s = n.economics.me.data;
					if (!s) throw new Error("me data required for copy to be fetched");
					if (!n.economics.pointsCopy.fetched) {
						e(l());
						const t = `https://${s.pointsDocsBaseUrl}v1.json?web`,
							n = await Object(r.b)({
								endpoint: t,
								method: o.ob.GET
							});
						n.ok && n.body && e(u(n.body))
					}
				}
		},
		"./src/reddit/actions/economics/paymentSystems/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			}));
			const o = "ECONOMICS__PAYMENT_SYSTEM__CARD_DELETE_SUCCESS",
				r = "ECONOMICS__PAYMENT_SYSTEM__PAYPAL_DELETE_SUCCESS",
				s = "ECONOMICS__PAYMENT_SYSTEM__INFO_FAILURE",
				i = "ECONOMICS__PAYMENT_SYSTEM__INFO_FETCHED",
				a = "ECONOMICS__PAYMENT_SYSTEM__INFO_PENDING"
		},
		"./src/reddit/actions/economics/subredditPremium/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			}));
			const o = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_APPLIED",
				r = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_BADGE_TYPE_CHANGED",
				s = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_MODAL_OPENED",
				i = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_VIEW_CHANGED",
				a = "ECONOMICS__SUBREDDIT_PREMIUM__EDITOR_PRODUCTS_FETCH_SUCCESS",
				c = "ECONOMICS__SUBREDDIT_PREMIUM__ORDER_SUCCESS",
				d = "ECONOMICS__SUBREDDIT_PREMIUM__SUBREDDIT_INFO_SUCCESS",
				l = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_CANCEL_SUCCESS",
				u = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_DATA_SUCCESS"
		},
		"./src/reddit/actions/economics/subredditPremium/thunkedActions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return O
			})), n.d(t, "g", (function() {
				return _
			})), n.d(t, "b", (function() {
				return k
			})), n.d(t, "d", (function() {
				return j
			})), n.d(t, "e", (function() {
				return S
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "f", (function() {
				return w
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/lodash/forOwn.js"),
				r = n.n(o),
				s = n("./src/reddit/actions/governance/errorToast.ts"),
				i = n("./src/reddit/endpoints/economics/emojis.ts"),
				a = n("./src/reddit/endpoints/economics/specialMembership.ts"),
				c = n("./src/reddit/endpoints/economics/subredditPremium.ts"),
				d = n("./src/reddit/endpoints/governance/badges.ts"),
				l = n("./src/config.ts"),
				u = n("./src/reddit/endpoints/governance/requester.ts");

			function m(e, t, n) {
				return Object(u.a)(e, {
					method: "get",
					endpoint: `${l.a.metaUrl}/products/${t}?owners=${n}` + "&types=emotes_pack,giphy"
				})
			}
			var p = n("./src/reddit/models/Badge/index.ts"),
				h = n("./src/reddit/models/Badge/managementPage.ts"),
				b = n("./src/reddit/models/Product/index.ts"),
				f = n("./src/reddit/reducers/economics/subredditPremium/index.ts"),
				g = n("./src/reddit/selectors/economics.ts"),
				v = n("./src/reddit/selectors/products.ts"),
				C = n("./src/reddit/actions/economics/me/thunkedActions.ts"),
				y = n("./src/reddit/actions/economics/subredditPremium/actionCreators.ts");

			function E(e) {
				return !!e && "removeBadge" === e.type
			}

			function x(e) {
				if (!E(e)) return e
			}
			const O = () => async (e, t, n) => {
				let {
					apiContext: o
				} = n;
				if (!t().user.account) return;
				await e(Object(C.b)({
					includeMemberships: !0
				}));
				const r = t().economics.me.data.specialMemberships || {},
					s = Object.keys(r);
				if (s.length) {
					const t = await Object(a.e)(o(), s);
					t.ok && e(Object(y.g)(t.body))
				}
			}, _ = (e, t) => async (n, o, r) => {
				let {
					apiContext: s
				} = r;
				const i = o().user.account,
					a = o().economics.subredditPremium[e],
					d = !a || a.status !== f.a.Fetched || t;
				if (i && d) {
					const t = await Object(c.a)(s(), e, i.id);
					n(Object(y.i)(t))
				}
			}, k = e => async (t, n, o) => {
				let {
					apiContext: r
				} = o;
				const i = n(),
					a = i.user.account,
					c = Object(g.f)(i, e.subredditId),
					l = Object.keys(c).map(e => c[e]).filter(Boolean);
				if (a && e.badge) {
					let n, o;
					n = e.placement === p.a.First ? c[h.a.Loyalty] : e.placement === p.a.Second ? c[h.a.Achievement] : c[h.a.Cosmetic], t(Object(y.a)({
						...e,
						badge: x(e.badge),
						currentAppliedBadges: l,
						userId: a.id
					})), E(e.badge) && n ? o = await Object(d.a)(r(), e.subredditId, n.id, !1) : E(e.badge) || (o = await Object(d.a)(r(), e.subredditId, e.badge.id)), o && !o.ok && (t(Object(y.a)({
						...e,
						badge: n,
						currentAppliedBadges: l,
						userId: a.id
					})), Object(s.a)(t, o.error))
				}
			}, j = (e, t) => async (n, o, r) => {
				let {
					apiContext: s
				} = r;
				await n(_(e, !0));
				const i = o().economics.subredditPremium[e];
				if (i && i.status === f.a.Fetched) {
					const o = i.data.userOwnedBadges.find(e => e.type === t.id);
					o && (n(k({
						badge: o,
						subredditId: e,
						placement: o.placement
					})), n(Object(y.d)(h.c.MyBadges)))
				}
			}, S = e => async (t, n, o) => {
				let {
					apiContext: a
				} = o;
				const c = n().user.account,
					d = !n().economics.emotes[e],
					l = !n().economics.gifs[e];
				if (c && (d || l)) {
					const [n, o] = await Promise.all([Object(i.b)(a(), e), m(a(), e, c.id)]);
					if (!o.ok) return void Object(s.a)(t, o.error);
					const d = {
						emotes: [],
						emoteCollections: n.ok ? n.body : {},
						giphy: []
					};
					r()(o.body, e => {
						e.type === b.a.EmotesPack ? d.emotes.push(e) : e.type === b.a.Giphy && d.giphy.push(e)
					}), t(Object(y.e)({
						subredditId: e,
						products: d
					}))
				}
			}, T = (e, t, n) => async (o, r, s) => {
				let {
					apiContext: i
				} = s;
				if (await o(_(e, !0)), n && t) {
					const n = r(),
						s = Object(g.f)(n, e),
						i = Object(v.a)(n, t);
					if (!s[Object(h.d)(i.placement)] && i) {
						const t = Object(g.l)(n, {
							subredditId: e,
							badge: i
						});
						t && await o(k({
							badge: t,
							subredditId: e
						}))
					}
					o(Object(y.c)({
						subredditId: e,
						initialView: h.c.MyBadges
					}))
				}
			}, w = e => async (t, n, o) => {
				let {
					apiContext: r
				} = o;
				const {
					wallet: s
				} = await Object(a.c)(r(), e);
				t(Object(y.f)({
					wallet: s
				})), await t(_(e.subredditId, !0))
			}
		},
		"./src/reddit/actions/gold/communityAwards/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "h", (function() {
				return h
			}));
			var o = n("./src/lib/loadableAction/index.ts");
			const r = e => () => n.e("CommunityAwards").then(n.bind(null, "./src/reddit/actions/gold/communityAwards/communityAwards.ts")).then(t => t[e]),
				s = Object(o.a)(r("awardSheetInfoRequested")),
				i = Object(o.a)(r("manageableAwardsRequested")),
				a = Object(o.a)(r("createCommunityAward")),
				c = Object(o.a)(r("createGlobalAward")),
				d = Object(o.a)(r("createModAward")),
				l = Object(o.a)(r("createAwardFailed")),
				u = Object(o.a)(r("createAwardSuccessful")),
				m = Object(o.a)(r("removeCommunityAward")),
				p = Object(o.a)(r("disableAwardinCommunity")),
				h = Object(o.a)(r("enableAwardinCommunity"))
		},
		"./src/reddit/actions/gold/modals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return f
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "f", (function() {
				return _
			}));
			var o = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/postParentMessage/index.ts"),
				s = n("./src/reddit/helpers/isPost.ts"),
				i = n("./src/reddit/constants/modals.ts"),
				a = n("./src/reddit/selectors/gild.ts"),
				c = n("./src/reddit/helpers/correlationIdTracker.ts"),
				d = n("./src/reddit/actions/gold/communityAwards/index.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/selectors/communityAwards.ts"),
				m = n("./src/reddit/selectors/posts.ts"),
				p = n("./src/reddit/selectors/subreddit.ts"),
				h = n("./src/telemetry/index.ts"),
				b = n("./src/reddit/actions/gold/constants.ts");
			const f = Object(o.a)(b.J),
				g = Object(o.a)(b.f),
				v = () => async (e, t) => {
					const o = t();
					e(g()), Object(c.b)(c.a.GiftPremiumFlow);
					const {
						clickCloseModalEvent: r
					} = await n.e("givePremiumTrackers").then(n.bind(null, "./src/reddit/helpers/trackers/givePremium.ts"));
					Object(h.a)(r()(o))
				}, C = Object(o.a)(b.I), y = e => {
					let {
						awardId: t,
						correlationId: n,
						thingId: o
					} = e;
					return async (e, r) => {
						const a = r(),
							c = t ? Object(u.a)(a, t) : void 0;
						e(C({
							award: c && c.isEnabled ? c : void 0,
							thingId: o,
							correlationId: n
						})), e(Object(l.h)(i.a.GOLD_GILD_MODAL));
						const h = Object(p.O)(a, {
							thingId: o
						});
						let b = null;
						if (h) b = h.id;
						else if (Object(s.a)(o)) {
							const e = Object(m.F)(a, {
								postId: o
							});
							e && (b = e.belongsTo.id)
						}
						b && Object(d.a)(b, o)
					}
				}, E = Object(o.a)(b.e), x = Object(o.a)(b.H), O = () => async (e, t) => {
					const o = t(),
						s = Object(a.d)(o);
					if (Object(a.g)(o)) {
						const e = "close.gild";
						Object(r.a)({
							type: e
						})
					}
					e(E()), e(Object(l.g)(i.a.GOLD_GILD_MODAL));
					const {
						clickCloseGildModalEvent: d
					} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
					Object(h.a)(d(s)(o)), Object(c.b)(c.a.GildingFlow)
				}, _ = () => async () => {
					Object(r.a)({
						type: "login.gild"
					})
				}
		},
		"./src/reddit/actions/governance/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "l", (function() {
				return h
			})), n.d(t, "m", (function() {
				return b
			})), n.d(t, "n", (function() {
				return f
			})), n.d(t, "o", (function() {
				return g
			})), n.d(t, "p", (function() {
				return v
			})), n.d(t, "q", (function() {
				return C
			})), n.d(t, "r", (function() {
				return y
			})), n.d(t, "s", (function() {
				return E
			})), n.d(t, "t", (function() {
				return x
			})), n.d(t, "u", (function() {
				return O
			})), n.d(t, "v", (function() {
				return _
			})), n.d(t, "w", (function() {
				return k
			})), n.d(t, "x", (function() {
				return j
			}));
			const o = "GOVERNANCE__COMMUNITY_DETAILS_SUCCESS",
				r = "GOVERNANCE__NEW_SUBREDDIT_SUGGESTED",
				s = "GOVERNANCE__NEW_TOP_MOD_SUGGESTED",
				i = "GOVERNANCE__OPT_OUT_MODAL_OPENED",
				a = "POLL_VOTE_SUCCESS",
				c = "GOVERNANCE__PROPOSAL_CREATION_FAILURE",
				d = "GOVERNANCE__PROPOSAL_CREATION_PENDING",
				l = "GOVERNANCE__PROPOSAL_CREATION_SUCCESS",
				u = "GOVERNANCE__PROPOSAL_OPTION_VOTE_FAILURE",
				m = "GOVERNANCE__PROPOSAL_OPTION_VOTE_PENDING",
				p = "GOVERNANCE__PROPOSAL_OPTION_VOTE_SUCCESS",
				h = "GOVERNANCE__PUBLIC_WALLET_INFO_FAILURE",
				b = "GOVERNANCE__PUBLIC_WALLET_INFO_PENDING",
				f = "GOVERNANCE__PUBLIC_WALLET_INFO_SUCCESS",
				g = "GOVERNANCE__RELEASE_NOTES_MODAL_OPENED",
				v = "GOVERNANCE__RELEASE_NOTES_SUCCESS",
				C = "GOVERNANCE__TRANSFER_FAILURE",
				y = "GOVERNANCE__TRANSFER_MODAL_OPENED",
				E = "GOVERNANCE__TRANSFER_PENDING",
				x = "GOVERNANCE__TRANSFER_SUCCESS",
				O = "GOVERNANCE__WALLETS_FETCH_FAILURE",
				_ = "GOVERNANCE__WALLETS_FETCH_PENDING",
				k = "GOVERNANCE__WALLETS_FETCH_SUCCESS",
				j = "GOVERNANCE__WALLET_REGISTRATION_MODAL_OPENED"
		},
		"./src/reddit/actions/governance/errorToast.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var o = n("./src/reddit/actions/toaster.ts"),
				r = n("./src/reddit/helpers/governanceErrorText/index.ts"),
				s = n("./src/reddit/models/Toast/index.ts");

			function i(e, t) {
				e(Object(o.f)({
					duration: 5e3,
					kind: s.b.Error,
					text: Object(r.a)(t)
				}))
			}
		},
		"./src/reddit/actions/governance/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return y
			})), n.d(t, "b", (function() {
				return E
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "f", (function() {
				return T
			})), n.d(t, "g", (function() {
				return M
			})), n.d(t, "d", (function() {
				return D
			})), n.d(t, "e", (function() {
				return L
			})), n.d(t, "h", (function() {
				return A
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/prettyPrintNumber/index.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				a = n("./src/reddit/actions/post.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/config.ts"),
				l = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/reddit/models/Poll/index.ts"),
				m = n("./src/redditGQL/operations/PollVote.json"),
				p = n("./src/reddit/endpoints/governance/requester.ts");
			var h = n("./src/reddit/endpoints/governance/wallet.ts"),
				b = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/models/Vote/index.ts"),
				g = n("./src/reddit/selectors/crypto/points.ts"),
				v = n("./src/reddit/actions/governance/constants.ts"),
				C = n("./src/reddit/actions/governance/errorToast.ts");
			const y = Object(r.a)(v.b),
				E = Object(r.a)(v.c),
				x = Object(r.a)(v.e),
				O = (Object(r.a)(v.f), Object(r.a)(v.g), Object(r.a)(v.h)),
				_ = Object(r.a)(v.i),
				k = Object(r.a)(v.j),
				j = Object(r.a)(v.k),
				S = Object(r.a)(v.q),
				T = Object(r.a)(v.r),
				w = Object(r.a)(v.s),
				I = Object(r.a)(v.t),
				P = Object(r.a)(v.u),
				N = Object(r.a)(v.v),
				R = Object(r.a)(v.w),
				M = Object(r.a)(v.x),
				D = (e, t) => async (n, o, r) => {
					let s, {
							apiContext: i,
							gqlContext: c
						} = r,
						h = o().polls.models[e];
					if (n(k({
							pollId: e
						})), (s = h.type === u.a.GA ? await ((e, t, n) => Object(l.a)(e, {
								...m,
								variables: {
									input: {
										postId: t,
										optionId: n
									}
								}
							}))(c(), e, t) : await
							function(e, t, n, o) {
								return Object(p.a)(e, {
									method: "put",
									endpoint: `${d.a.metaUrl}/polls/${t}/${n}/votes/me/${o}`
								})
							}(i(), h.subredditId, e, t)).ok) {
						if (h.type === u.a.GA) {
							const {
								options: e
							} = s.body.data.updatePostPollVoteState.poll;
							n(x({
								pollId: h.id,
								optionId: t,
								options: e
							}))
						} else n(j(s.body));
						const r = o();
						if ((h = r.polls.models[e]) && Object(u.d)(h)) {
							const {
								postId: e
							} = h, t = r.posts.models[e];
							t && t.voteState === f.a.notVoted && n(Object(a.ib)(e))
						}
					} else n(_({
						pollId: e,
						error: s.error || s.errors[0].message
					})), Object(C.a)(n, s.error || s.errors[0].messsage)
				}, L = (e, t) => async (n, r, a) => {
					let {
						apiContext: l
					} = a;
					var u;
					n(w());
					const m = r().transfers.communityPoints.contentId || void 0,
						h = await
					function(e, t) {
						return Object(p.a)(e, {
							data: {
								amount: t.amount,
								contentId: t.contentId,
								description: t.message,
								receiveUserName: t.recipient
							},
							endpoint: `${d.a.metaUrl}/wallets/me/${t.subredditId}/transfers`,
							method: "post"
						})
					}(l(), {
						...e,
						contentId: m
					});
					h.ok ? (n(I({
						...h.body,
						subredditId: e.subredditId
					})), n(Object(c.f)({
						kind: b.b.SuccessCommunity,
						text: o.fbt._("Success! You just transferred {amount} {tokenName} to {recipient}", [o.fbt._param("amount", Object(s.a)(e.amount)), o.fbt._param("tokenName", (null === (u = Object(g.b)(r(), e.subredditId)) || void 0 === u ? void 0 : u.name) || ""), o.fbt._param("recipient", e.recipient)], {
							hk: "3klrhq"
						})
					})), t && n(Object(i.f)())) : (n(S({
						error: h.error
					})), Object(C.a)(n, h.error))
				}, A = e => async (t, n, o) => {
					let {
						apiContext: r
					} = o;
					t(N());
					const s = await Object(h.a)(r(), e);
					s.ok ? t(R(s.body)) : t(P({
						error: s.error
					}))
				}
		},
		"./src/reddit/actions/inContextModeration.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			}));
			var o = n("./src/lib/makeActionCreator/index.ts");
			const r = "INCONTEXT__BANNED",
				s = "INCONTEXT__MUTED",
				i = Object(o.a)(r),
				a = Object(o.a)(s)
		},
		"./src/reddit/actions/jsApi.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			var o = n("./src/lib/makeActionCreator/index.ts");
			const r = "JSAPI__CONSUMER_SUBSCRIBED",
				s = Object(o.a)(r)
		},
		"./src/reddit/actions/moderationLog/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const o = "SUBREDDIT__MODERATION_LOG_LOADED",
				r = "SUBREDDIT__ALL_MODERATORS_LOADED",
				s = "SUBREDDIT__MODERATION_CATEGORY_ACTIONS_LOADED"
		},
		"./src/reddit/actions/polls.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			var o = n("./src/lib/makeActionCreator/index.ts");
			const r = "POLLS__POLL_CREATION_UPDATED",
				s = Object(o.a)(r)
		},
		"./src/reddit/actions/postCollection/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "t", (function() {
				return d
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "r", (function() {
				return u
			})), n.d(t, "s", (function() {
				return m
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "l", (function() {
				return h
			})), n.d(t, "m", (function() {
				return b
			})), n.d(t, "k", (function() {
				return f
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "j", (function() {
				return v
			})), n.d(t, "h", (function() {
				return C
			})), n.d(t, "p", (function() {
				return y
			})), n.d(t, "q", (function() {
				return E
			})), n.d(t, "o", (function() {
				return x
			}));
			const o = "CREATE_COLLECTION_PENDING",
				r = "CREATE_COLLECTION_SUCCESS",
				s = "CREATE_COLLECTION_FAILED",
				i = "GET_SUBREDDIT_COLLECTION_SUCCESS",
				a = "REMOVE_POST_FROM_COLLECTION_SUCCESS",
				c = "ADD_POST_TO_COLLECTION_SUCCESS",
				d = "UPDATE_POST_WITH_COLLECTION_ID",
				l = "DELETE_COLLECTION_SUCCESS",
				u = "UPDATE_COLLECTION_PENDING",
				m = "UPDATE_COLLECTION_SUCCESS",
				p = "UPDATE_COLLECTION_FAILED",
				h = "UPDATE_COLLECTION_DESCRIPTION_PENDING",
				b = "UPDATE_COLLECTION_DESCRIPTION_SUCCESS",
				f = "UPDATE_COLLECTION_DESCRIPTION_FAILED",
				g = "REORDER_COLLECTION_PENDING",
				v = "REORDER_COLLECTION_SUCCESS",
				C = "REORDER_COLLECTION_FAILED",
				y = "UPDATE_COLLECTION_LAYOUT_PENDING",
				E = "UPDATE_COLLECTION_LAYOUT_SUCCESS",
				x = "UPDATE_COLLECTION_LAYOUT_FAILED"
		},
		"./src/reddit/actions/postCollection/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return D
			})), n.d(t, "e", (function() {
				return A
			})), n.d(t, "g", (function() {
				return B
			})), n.d(t, "a", (function() {
				return W
			})), n.d(t, "c", (function() {
				return H
			})), n.d(t, "h", (function() {
				return Q
			})), n.d(t, "f", (function() {
				return Z
			})), n.d(t, "d", (function() {
				return se
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react-router-redux/es/index.js"),
				s = n("./src/lib/filterQueryParams/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/post.ts"),
				c = n("./src/reddit/actions/postCollection/constants.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/history.ts"),
				u = n("./src/lib/constants/index.ts"),
				m = n("./src/lib/makeApiRequest/index.ts"),
				p = n("./src/lib/omitHeaders/index.ts"),
				h = n("./src/reddit/constants/headers.ts");
			var b = (e, t, n) => Object(m.a)(Object(p.a)(e, [h.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/add_post_to_collection.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					link_fullname: n
				}
			});
			var f = (e, t, n) => Object(m.a)(Object(p.a)(e, [h.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/create_collection.json`,
				method: u.ob.POST,
				data: {
					title: t,
					sr_fullname: n
				}
			});
			var g = (e, t) => Object(m.a)(Object(p.a)(e, [h.a]), {
					endpoint: `${e.apiUrl}/api/v1/collections/delete_collection.json`,
					method: u.ob.POST,
					data: {
						collection_id: t
					}
				}),
				v = n("./src/config.ts");
			var C = (e, t) => Object(m.a)(Object(p.a)(e, [h.a]), {
				endpoint: `${v.a.gatewayUrl}/desktopapi/v1/subreddit_collections/${t}`,
				method: u.ob.GET
			});
			var y = (e, t, n) => Object(m.a)(Object(p.a)(e, [h.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/remove_post_in_collection.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					link_fullname: n
				}
			});
			var E = (e, t, n) => Object(m.a)(Object(p.a)(e, [h.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/update_collection_title.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					title: n
				}
			});
			var x = (e, t, n) => Object(m.a)(Object(p.a)(e, [h.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/reorder_collection.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					link_ids: n.join(",")
				}
			});
			var O = (e, t, n) => Object(m.a)(Object(p.a)(e, [h.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/update_collection_description.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					description: n
				}
			});
			var _ = (e, t, n) => Object(m.a)(Object(p.a)(e, [h.a]), {
					endpoint: `${e.apiUrl}/api/v1/collections/update_collection_display_layout.json`,
					method: u.ob.POST,
					data: {
						collection_id: t,
						display_layout: n
					}
				}),
				k = n("./src/reddit/helpers/overlay/index.ts"),
				j = n("./src/reddit/helpers/path/index.ts"),
				S = n("./src/reddit/models/Toast/index.ts"),
				T = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				w = n("./src/reddit/selectors/postCollection.ts"),
				I = n("./src/reddit/selectors/posts.ts"),
				P = n("./src/reddit/selectors/subreddit.ts");
			const N = Object(i.a)(c.c),
				R = Object(i.a)(c.b),
				M = Object(i.a)(c.d),
				D = (e, t) => async (n, o, r) => {
					let {
						apiContext: s
					} = r;
					n(N());
					const i = await f(s(), e, t);
					let a;
					if (i.ok) {
						const e = o().meta,
							t = (e => ({
								author: e.author_name || void 0,
								createdAtUTC: e.created_at_utc,
								description: e.description,
								displayLayout: e.display_layout,
								id: e.collection_id,
								lastUpdateUTC: e.last_update_utc,
								permalink: e.permalink,
								postIds: e.link_ids,
								primaryPostId: e.primary_link_id || void 0,
								subredditId: e.subreddit_id,
								title: e.title
							}))(i.body);
						n(M({
							collection: t,
							meta: e
						})), a = t
					} else {
						const e = i.error;
						n(R(e))
					}
					return a
				}, L = Object(i.a)(c.f), A = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const i = n().postCollection.subredditToIds || {};
					if (Object.keys(i).length > 0) return;
					const a = await C(s(), e);
					a.ok ? t(L(a.body)) : t(Object(d.f)({
						kind: S.b.Error,
						text: o.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, F = Object(i.a)(c.g), B = (e, t, n) => async (r, s, i) => {
					let {
						apiContext: a
					} = i;
					if ((await y(a(), e, t)).ok) {
						const i = s(),
							a = Object(I.F)(i, {
								postId: t
							}),
							c = a && a.title || "",
							l = Object(w.q)(i, {
								collectionId: e
							}),
							u = (l && l.postIds && l.postIds.indexOf(t) || -1) - 1;
						if (r(F({
								collectionId: e,
								postId: t
							})), n && u >= 0) {
							const t = s(),
								n = Object(w.q)(t, {
									collectionId: e
								}),
								o = n && n.postIds && n.postIds[u] || "",
								i = Object(I.F)(t, {
									postId: o
								});
							i && i.permalink && r(Object(k.a)(i.permalink))
						}
						r(Object(d.f)({
							kind: S.b.SuccessMod,
							text: o.fbt._("Following post removed from collection successfully: {postTitle}", [o.fbt._param("postTitle", c)], {
								hk: "8e1lV"
							}),
							buttonText: o.fbt._("UNDO", null, {
								hk: "3KPLib"
							}),
							buttonAction: W(e, t)
						}))
					} else r(Object(d.f)({
						kind: S.b.Error,
						text: o.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, U = Object(i.a)(c.a), K = Object(i.a)(c.t), W = (e, t) => async (n, r, s) => {
					let {
						apiContext: i
					} = s;
					const a = r();
					if ((await b(i(), e, t)).ok) {
						n(U({
							collectionId: e,
							postId: t
						})), n(K({
							collectionId: e,
							postId: t
						}));
						const r = Object(I.F)(a, {
								postId: t
							}),
							s = Object(w.q)(a, {
								collectionId: e
							}),
							i = s && s.title || "";
						n(Object(d.f)({
							kind: S.b.SuccessMod,
							text: o.fbt._("Success! You added a post to the collection: {title}", [o.fbt._param("title", i)], {
								hk: "3KNJWi"
							}),
							buttonText: o.fbt._("VIEW", null, {
								hk: "1SSkgL"
							}),
							buttonAction: Object(k.a)(r.permalink)
						}))
					} else n(Object(d.f)({
						kind: S.b.Error,
						text: o.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, G = Object(i.a)(c.e), H = (e, t) => async (n, i, a) => {
					let {
						apiContext: c
					} = a;
					const l = i();
					if ((await g(c(), e)).ok) {
						const {
							url: i
						} = l.platform.currentPage, a = Object(w.q)(l, {
							collectionId: e
						}), c = a && a.title || "", u = a && a.subredditId, m = u ? Object(P.c)(l, u) : "/";
						n(G({
							collectionId: e,
							collection: a
						})), n(t ? Object(r.c)(Object(s.a)(i, ["collection"])) : Object(r.b)(m)), n(Object(d.f)({
							kind: S.b.SuccessMod,
							text: o.fbt._("Collection deleted successfully: {title}", [o.fbt._param("title", c)], {
								hk: "4tcOKB"
							})
						}))
					} else n(Object(d.f)({
						kind: S.b.Error,
						text: o.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, V = Object(i.a)(c.r), z = Object(i.a)(c.n), q = Object(i.a)(c.s), Q = (e, t) => async (n, r, s) => {
					let {
						apiContext: i
					} = s;
					n(V());
					const a = await E(i(), e, t);
					let c = !1;
					if (a.ok) n(q({
						collectionId: e,
						newTitle: t
					})), n(Object(d.f)({
						kind: S.b.SuccessMod,
						text: o.fbt._("Collection title updated successfully", null, {
							hk: "2hKzKl"
						})
					})), c = !0;
					else {
						const e = a.error;
						n(z(e)), n(Object(d.f)({
							kind: S.b.Error,
							text: o.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							})
						}))
					}
					return c
				}, Y = Object(i.a)(c.l), J = Object(i.a)(c.m), X = Object(i.a)(c.k), Z = e => async (t, n) => {
					const o = n();
					if (Object(T.b)(o) || Object(T.c)(o)) return void t(Object(a.Z)(Object(j.b)(e.permalink), e.id));
					const s = o.platform.currentPage.locationState;
					t(!(!s || !s[l.b.IsOverlay]) ? Object(k.a)(e.permalink) : Object(r.b)(Object(j.b)(e.permalink)))
				}, $ = Object(i.a)(c.i), ee = Object(i.a)(c.j), te = Object(i.a)(c.h), ne = Object(i.a)(c.p), oe = Object(i.a)(c.o), re = Object(i.a)(c.q), se = e => async t => {
					const n = [],
						{
							collectionId: r,
							description: s,
							displayLayout: i,
							postIds: a,
							title: c
						} = e;
					a && n.push(t(((e, t) => async (n, r, s) => {
						let {
							apiContext: i
						} = s;
						n($());
						const a = await x(i(), e, t);
						let c = !1;
						return a.ok ? (n(ee({
							collectionId: e,
							postIds: t
						})), n(Object(d.f)({
							kind: S.b.SuccessMod,
							text: o.fbt._("Collection order updated successfully", null, {
								hk: "4ccHEL"
							})
						})), c = !0) : (n(te({
							error: a.error
						})), n(Object(d.f)({
							kind: S.b.Error,
							text: o.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							})
						}))), c
					})(r, a))), c && n.push(t(Q(r, c))), void 0 !== s && n.push(t(((e, t) => async (n, r, s) => {
						let {
							apiContext: i
						} = s;
						n(Y());
						const a = await O(i(), e, t);
						let c = !1;
						if (a.ok) n(J({
							collectionId: e,
							newDescription: t
						})), n(Object(d.f)({
							kind: S.b.SuccessMod,
							text: o.fbt._("Collection description updated successfully", null, {
								hk: "1rIDCC"
							})
						})), c = !0;
						else {
							const e = a.error;
							n(X(e)), n(Object(d.f)({
								kind: S.b.Error,
								text: o.fbt._("Something went wrong. Just don't panic.", null, {
									hk: "4Ck6Cm"
								})
							}))
						}
						return c
					})(r, s))), i && n.push(t(((e, t) => async (n, r, s) => {
						let {
							apiContext: i
						} = s;
						n(ne());
						const a = await _(i(), e, t);
						let c = !1;
						if (a.ok) n(re({
							collectionId: e,
							newLayout: t
						})), n(Object(d.f)({
							kind: S.b.SuccessMod,
							text: o.fbt._("Collection layout updated successfully", null, {
								hk: "1Rs19j"
							})
						})), c = !0;
						else {
							const e = a.error;
							n(oe(e)), n(Object(d.f)({
								kind: S.b.Error,
								text: o.fbt._("Something went wrong. Just don't panic.", null, {
									hk: "4Ck6Cm"
								})
							}))
						}
						return c
					})(r, i)));
					let l = !0;
					return await Promise.all(n).then(e => {
						e.forEach(e => {
							e || (l = !1)
						})
					}), l
				}
		},
		"./src/reddit/actions/postCreation/editorContent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "c", (function() {
				return g
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/endpoints/post/convert.ts"),
				a = n("./src/reddit/helpers/localStorage/index.ts"),
				c = n("./src/reddit/helpers/trackers/postComposer.ts"),
				d = n("./src/reddit/models/PostCreationForm/index.ts"),
				l = n("./src/reddit/models/RichTextJson/index.ts"),
				u = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/reddit/actions/postCreation/constants.ts");
			const p = Object(r.a)(m.H),
				h = Object(r.a)(m.p),
				b = Object(r.a)(m.R),
				f = (e, t, n) => async (r, a, f) => {
					let {
						apiContext: v
					} = f;
					c.m(a(), t);
					const C = t === d.i.MARKDOWN,
						y = t === d.i.RICH_TEXT,
						E = m.k;
					if (C && Object(l.I)(n)) return r(b({
						editorKey: e,
						editorMode: d.i.MARKDOWN,
						content: ""
					})), void r(g(t));
					if (y && !n) return r(b({
						editorKey: e,
						editorMode: d.i.RICH_TEXT,
						content: l.j
					})), void r(g(t));
					r(p(E));
					const x = await Object(i.a)(v(), t, C ? JSON.stringify(n) : n);
					x.ok ? (r(h(E)), r(b({
						editorKey: e,
						editorMode: t,
						content: x.body.output
					})), r(g(t))) : (r(h(E)), r(Object(s.f)({
						duration: s.a,
						kind: u.b.Error,
						text: o.fbt._("Something went wrong", null, {
							hk: "3UtpxU"
						})
					})))
				}, g = e => async (t, n) => {
					const r = Object(a.l)();
					if (r >= 3) return;
					const i = n().user.prefs.useMarkdown ? d.i.MARKDOWN : d.i.RICH_TEXT;
					if (e === i) return;
					const c = e === d.i.MARKDOWN ? o.fbt._("You can set Markdown as the default editor mode in the settings", null, {
						hk: "yvN18"
					}) : o.fbt._("You can set Fancy Pants as the default editor mode in the settings", null, {
						hk: "4kQi5k"
					});
					t(Object(s.f)({
						buttonAction: async () => {
							window.open("/settings/feed")
						},
						buttonText: o.fbt._("Open Settings", null, {
							hk: "1CKz9o"
						}),
						kind: u.b.SuccessCommunity,
						text: c
					})), Object(a.wb)(r + 1)
				}
		},
		"./src/reddit/actions/postCreation/mediaUpload.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return R
			})), n.d(t, "b", (function() {
				return D
			})), n.d(t, "a", (function() {
				return L
			})), n.d(t, "c", (function() {
				return F
			})), n.d(t, "e", (function() {
				return B
			})), n.d(t, "d", (function() {
				return U
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				s = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/formatApiError/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/actions/upload.ts"),
				l = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/constants.ts"),
				u = n("./src/lib/makeApiRequest/index.ts"),
				m = n("./src/lib/makeGqlRequest/index.ts"),
				p = n("./src/lib/omitHeaders/index.ts"),
				h = n("./src/reddit/constants/headers.ts"),
				b = n("./src/redditGQL/operations/CreateMediaUploadLease.json");
			var f = n("./src/reddit/helpers/correlationIdTracker.ts"),
				g = n("./src/reddit/helpers/imagePreview/index.ts"),
				v = n("./src/reddit/helpers/media/index.ts"),
				C = n("./src/reddit/models/Upload/index.ts"),
				y = n("./src/reddit/selectors/telemetry.ts"),
				E = n("./src/telemetry/index.ts");
			const x = e => ({
				...y.p(e),
				screen: y.db(e),
				profile: y.U(e),
				subreddit: y.mb(e)
			});
			var O = n("./src/reddit/helpers/trackers/postComposer.ts"),
				_ = n("./src/reddit/models/PostCreationForm/index.ts"),
				k = n("./src/reddit/models/Toast/index.ts"),
				j = n("./src/reddit/selectors/postCreations.ts"),
				S = n("./src/reddit/helpers/graphql/normalizeUploadLeaseFromGql/index.ts"),
				T = n("./src/reddit/actions/postCreation/constants.ts"),
				w = n("./src/reddit/actions/postCreation/general.ts");
			const I = Object(a.a)(T.u),
				P = Object(a.a)(T.v),
				N = Object(a.a)(T.t),
				R = e => async (t, n) => {
					t(I());
					const o = e.map(e => {
						let {
							url: n,
							uploadKey: o
						} = e;
						const r = Object(v.b)(Object(v.d)(n), "poster.png");
						return t(A(r, o, !0, !1))
					});
					await Promise.all(o);
					const r = n().uploads,
						s = e.map(e => {
							let {
								uploadKey: t
							} = e;
							return r[t]
						}).find(e => e.status !== C.a.SUCCESS);
					t(s ? N(s.error) : P())
				}, M = (e, t) => ({
					error: t ? {
						type: e,
						fields: [{
							field: "",
							msg: t
						}]
					} : {
						type: e
					}
				});
			const D = "RTE",
				L = "GALLERY",
				A = (e, t, n, r, i, a, l, _) => async (T, w, I) => {
					let {
						apiContext: P,
						gqlContext: N
					} = I;
					const R = Object(j.h)(w()),
						D = Date.now();
					let L = null,
						A = !1,
						F = !1,
						B = !1;
					const U = e => {
						if (!B && i && A) {
							B = !0;
							const n = w(),
								o = Date.now() - D,
								r = Object(f.c)(f.a.PostComposer);
							F ? (async e => {
								let {
									state: t,
									uploadKey: n,
									assetId: o,
									isCanceled: r,
									fileSource: s,
									uploadDuration: i,
									correlationId: a
								} = e;
								const c = t.uploads[n],
									d = r || c.status === C.a.CANCELED,
									{
										file: l,
										url: u,
										metadata: m,
										error: p
									} = c,
									h = m.mimetype || l.type,
									b = h.startsWith("video/"),
									f = c.status === C.a.SUCCESS;
								let g = "";
								p ? g = JSON.stringify(p) : d && (g = "canceled");
								const v = {
									width: m.width,
									height: m.height,
									duration: m.videoDuration && Math.round(1e3 * m.videoDuration)
								};
								Object(E.a)({
									source: "post_composer",
									action: "upload",
									correlationId: a,
									noun: b ? "video" : "image",
									...x(t),
									actionInfo: {
										...y.d(t),
										success: f,
										...g ? {
											reason: g
										} : {}
									},
									media: {
										mimetype: h,
										uploadDuration: i,
										source: s,
										fileName: l.name,
										size: l.size,
										type: b ? "video" : "image",
										...o ? {
											id: o
										} : {},
										...u ? {
											url: u
										} : {},
										...v
									}
								})
							})({
								state: n,
								uploadKey: t,
								assetId: L,
								isCanceled: e,
								fileSource: i,
								uploadDuration: o,
								correlationId: r
							}) : O.E(n, t)
						}
					};
					return await T(Object(d.l)(e, t, async f => {
						var C, y, E, x;
						A = !0, Object(d.k)(f.id, () => {
							U(!0)
						});
						const {
							error: O,
							metadata: j
						} = await async function(e, t, n, r, i) {
							const a = r && r.allowedPostTypes,
								c = r && r.name,
								d = await Object(v.h)(e) || e.type,
								l = Object(v.c)(e) || void 0;
							if (!l) return M("UNSUPPORTED_BROWSER");
							const u = {
								localUrl: l,
								mimetype: d,
								size: e.size
							};
							if (!d || !Object(v.k)(d)) return {
								error: {
									type: s.Y
								}
							};
							if (d.startsWith("image/")) {
								if (t && n && a && !a.images) {
									const e = o.fbt._("Images are not allowed in r/{subredditName}", [o.fbt._param("subredditName", c)], {
										hk: "3C2E7Q"
									});
									return M(s.Y, e)
								}
								if ("image/gif" === d) {
									if (e.size > s.eb) return M(s.N)
								} else if (e.size > s.gb) return M(s.W);
								const r = await Object(g.a)(l);
								if (i && (r.width < i || r.height < i)) {
									const e = o.fbt._("Image must be {min_image_width}x{min_image_height} pixels or larger.", [o.fbt._param("min_image_width", i.toString()), o.fbt._param("min_image_height", i.toString())], {
										hk: "2WFKgs"
									});
									return M(s.V, e)
								}
								u.width = r.width, u.height = r.height
							} else if (d.startsWith("video/")) {
								if (e.size > s.kb) return M(s.vc);
								let t;
								try {
									t = await Object(v.j)(l, !0)
								} catch (m) {
									return M(s.Y)
								}
								if (a) {
									const {
										videos: e,
										images: n
									} = a;
									if (n && !e && t.duration > s.lb) {
										const e = o.fbt._("Sorry, r/{subredditName} doesn't allow videos. Please upload a video less than 60 seconds to convert to animated GIF.", [o.fbt._param("subredditName", c)], {
											hk: "46ULiz"
										});
										return M(s.Y, e)
									}
									if (!n && !e) {
										const e = o.fbt._("Videos are not allowed in r/{subredditName}", [o.fbt._param("subredditName", c)], {
											hk: "4uTUZb"
										});
										return M(s.Y, e)
									}
								}
								if (t.duration > s.jb) {
									const e = o.fbt._("Video is too long. Maximum video length is {duration} minutes.", [o.fbt._param("duration", (s.jb / 60).toString())], {
										hk: "20nB6Q"
									});
									return M(s.Y, e)
								}
								if (t.duration < s.rb) {
									const e = o.fbt._("Video is too short. Minimum video length is {duration} seconds.", [o.fbt._param("duration", s.rb.toString())], {
										hk: "49PSW8"
									});
									return M(s.Y, e)
								}
								if (0 === t.height || 0 === t.width) {
									const e = o.fbt._("Your browser does not support the video codec used for this video. Please try using a different video codec.", null, {
										hk: "1AC0mg"
									});
									return M(s.Y, e)
								}
								if (t.height < s.sb || t.width < s.tb) {
									const e = o.fbt._("Videos must be {min_video_width}x{min_video_height} pixels or larger.", [o.fbt._param("min_video_width", s.tb.toString()), o.fbt._param("min_video_height", s.sb.toString())], {
										hk: "2HSUGl"
									});
									return M(s.Y, e)
								}
								if (e.size / t.duration < s.qb) {
									const e = o.fbt._("Videos must have a bitrate of {min_bitrate}KB/s or larger.", [o.fbt._param("min_bitrate", (s.qb / s.Z).toString())], {
										hk: "1ehgDE"
									});
									return M(s.Y, e)
								}
								u.height = t.height, u.width = t.width, u.videoDuration = t.duration, u.videoFirstFrameUrl = t.firstFrame.dataUrl
							}
							return {
								metadata: u
							}
						}(e, n, r, R, _);
						if (O || !j) return {
							error: O
						};
						if (T(Object(d.m)({
								key: t,
								metadata: {
									fileSource: i,
									...j
								}
							})), F = !0, a && a(), l) {
							const e = j.mimetype,
								t = e && s.T[e];
							if (e && t) {
								const e = await (async (e, t) => {
									return await Object(m.a)(e, {
										...b,
										variables: {
											input: {
												mimetype: t
											}
										}
									})
								})(N(), t);
								if (e.ok) {
									const t = e.body,
										n = (null === (C = t.data.createMediaUploadLease) || void 0 === C ? void 0 : C.uploadLease.uploadLeaseUrl) || "",
										o = Object(S.a)({
											uploadLeaseUrl: n,
											uploadLeaseHeaders: null === (y = t.data.createMediaUploadLease) || void 0 === y ? void 0 : y.uploadLease.uploadLeaseHeaders
										});
									return L = (null === (E = t.data.createMediaUploadLease) || void 0 === E ? void 0 : E.mediaId) || null, {
										uploadLease: o
									}
								} {
									const t = null === (x = e.body.data.createMediaUploadLease) || void 0 === x ? void 0 : x.errors;
									let n = null;
									return t && (n = {
										fields: [{
											field: t[0].__typename || "",
											msg: t[0].message
										}],
										type: t[0].__typename || ""
									}), {
										error: n || void 0
									}
								}
							}
							return T(Object(c.f)({
								kind: k.b.Error,
								text: o.fbt._("Only .jpeg and .png image types are are allowed", null, {
									hk: "30Ms4V"
								}),
								duration: 6e3
							})), {
								error: void 0
							}
						}
						const w = e.name,
							I = await (async (e, t, n) => Object(u.a)(Object(p.a)(e, [h.a]), {
								endpoint: `${e.apiUrl}/api/media/asset.json`,
								method: s.ob.POST,
								data: {
									filepath: t,
									mimetype: n
								}
							}))(P(), w, j.mimetype);
						return I.ok ? (L = I.body.asset.asset_id, {
							uploadLease: I.body.args
						}) : {
							error: I.error || void 0
						}
					}, !0)), U(!1), w().uploads[t] || null
				}, F = (e, t) => async (n, o) => {
					const r = o().uploads[e];
					r && !Object(C.c)(r) && await n(A(r.file, r.key, t, !1, r.metadata.fileSource, void 0))
				}, B = (e, t, n, s, a, d) => async (l, u) => {
					const m = e.map((e, o) => new Promise(async o => {
							const i = Object(C.d)(n, Object(r.a)().slice(-6));
							await l(A(e, i, s, !0, t, () => o({
								uploadKey: i,
								isValid: !0
							}), a, d)), o({
								uploadKey: i,
								isValid: !1
							})
						})),
						p = await Promise.all(m),
						h = p.map(e => e.uploadKey);
					return l(function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3;
						return async (n, r) => {
							const {
								uploads: s
							} = r(), a = e.map(e => s[e]).filter(e => e.status === C.a.FAILED && !e.metadata.mimetype).map(e => e.error), d = a.length > t ? t - 1 : a.length, l = a.length - d;
							a.slice(0, d).forEach(e => n(Object(c.f)({
								duration: c.a,
								kind: k.b.Error,
								text: Object(i.a)(e)
							}))), l > 0 && n(Object(c.f)({
								duration: c.a,
								kind: k.b.Error,
								text: o.fbt._({
									"*": "Couldn't add {number} more files",
									_1: "Couldn't add 1 more file"
								}, [o.fbt._plural(l, "number")], {
									hk: "2fQwvl"
								})
							}))
						}
					}(h)), p.filter(e => e.isValid).map(e => e.uploadKey)
				}, U = (e, t) => async (n, r) => {
					const s = r(),
						i = Object(j.Z)(s),
						{
							items: a
						} = i,
						u = !a.length && 1 === e.length,
						m = Object(j.P)(s) && !u;
					let p = !1,
						h = e;
					if (m) {
						if (Object(_.x)(i)) return void n(Object(c.f)({
							kind: k.b.Error,
							text: o.fbt._("Please remove the existing video first. Videos aren't supported within galleries yet.", null, {
								hk: "3lGxp4"
							})
						}));
						h.some(e => Object(v.n)(e.type)) && n(Object(c.f)({
							duration: c.a,
							kind: k.b.Error,
							text: o.fbt._("Videos arent supported within galleries...yet", null, {
								hk: "9Cl20"
							})
						})), h = h.filter(e => Object(v.m)(e.type));
						const e = Math.max(0, l.b - a.length);
						h.length > e && (n(Object(c.f)({
							kind: k.b.Error,
							text: o.fbt._("You have hit the limit of {images_limit} images", [o.fbt._param("images_limit", `${l.b}`)], {
								hk: "6M4kX"
							})
						})), h = h.slice(0, e))
					} else h = h.slice(0, 1), p = !0, n(Object(d.j)(L, !0));
					const b = await n(B(h, t, L, !0));
					if (!b.length) return;
					const f = b.map(e => ({
							uploadKey: e,
							caption: "",
							url: ""
						})),
						g = 0 === a.length;
					n(Object(w.d)({
						...i,
						items: p ? f : [...a, ...f],
						selectedKey: g ? b[0] : b[b.length - 1]
					}))
				}
		},
		"./src/reddit/actions/postCreation/postGuidance.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			}));
			var o = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				i = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/PostGuidanceValidation.json"),
				d = (e, t) => Object(a.a)(e, {
					...c,
					variables: t
				}).then(e => {
					var t, n;
					if (e.ok) {
						const o = null === (n = null === (t = e.body) || void 0 === t ? void 0 : t.data) || void 0 === n ? void 0 : n.validatePostGuidanceRules;
						return {
							...e,
							body: {
								data: {
									...o || {}
								}
							}
						}
					}
					return e
				}),
				l = n("./src/reddit/endpoints/subreddit/about.ts"),
				u = n("./src/reddit/models/PostCreationForm/index.ts"),
				m = n("./src/reddit/selectors/postCreations.ts"),
				p = n("./src/reddit/selectors/subreddit.ts"),
				h = n("./src/reddit/actions/postCreation/constants.ts");
			const b = Object(r.a)(h.D),
				f = e => async (t, n, r) => {
					let {
						gqlContext: a
					} = r;
					const c = n(),
						h = Object(i.u)(c, {
							pageLayer: e
						});
					if (!h) return;
					let f = Object(p.I)(n(), h.name);
					if (!f) {
						const e = await Object(l.a)(a(), h.name, !1);
						if (e.ok) {
							f = e.body.data.subreddit.id
						}
						if (!f) return
					}
					const g = Object(m.q)(c, {
							field: o.Cb.TITLE
						}),
						v = Object(m.n)(c),
						C = Object(m.lb)(c),
						y = v === u.i.RICH_TEXT ? s.a.getRawText(C, " ") : Object(m.Y)(c),
						E = await d(a(), {
							input: {
								subredditId: f,
								postTitle: (null == g ? void 0 : g.title) || "",
								postBody: y
							}
						});
					if (E.ok) {
						const e = E.body;
						t(b(null == e ? void 0 : e.data))
					}
				}, g = (e, t, n) => async (o, r, s) => {
					let {
						gqlContext: i
					} = s;
					const a = await d(i(), {
						input: {
							subredditId: e,
							postTitle: t,
							postBody: n
						}
					});
					if (a.ok) {
						const e = a.body;
						o(b(null == e ? void 0 : e.data))
					}
				}
		},
		"./src/reddit/actions/postCreation/submit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return U
			})), n.d(t, "f", (function() {
				return K
			})), n.d(t, "e", (function() {
				return V
			})), n.d(t, "c", (function() {
				return X
			})), n.d(t, "d", (function() {
				return ee
			})), n.d(t, "a", (function() {
				return te
			}));
			var o = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/reCaptchaEnterprise/index.ts"),
				i = n("./src/telemetry/index.ts"),
				a = n("./src/reddit/actions/crosspostSubredditRec/index.ts"),
				c = n("./src/reddit/actions/governance/index.ts"),
				d = n("./src/reddit/actions/pages/subreddit/index.ts"),
				l = n("./src/reddit/actions/postDraft.ts"),
				u = n("./src/reddit/actions/reCaptchaEnterprise.ts"),
				m = n("./src/reddit/actions/scheduledPosts/index.ts"),
				p = n("./src/reddit/actions/urlRequested.ts"),
				h = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				b = n("./src/config.ts"),
				f = n("./src/lib/convertToCamelCase/index.ts"),
				g = n("./src/lib/makeApiRequest/index.ts"),
				v = n("./src/reddit/endpoints/post/create.ts");
			var C = n("./src/reddit/endpoints/scheduledPosts/index.ts"),
				y = n("./src/reddit/endpoints/scheduledPosts/update.ts"),
				E = n("./src/reddit/featureFlags/index.ts"),
				x = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				O = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				_ = n("./src/reddit/helpers/trackers/postComposer.ts"),
				k = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				j = n("./src/reddit/models/Poll/index.ts"),
				S = n("./src/reddit/models/Post/index.ts"),
				T = n("./src/reddit/models/PostCreationForm/index.ts"),
				w = n("./src/reddit/models/ScheduledPost/index.ts"),
				I = n("./src/reddit/models/User/index.ts"),
				P = n("./src/reddit/selectors/experiments/crosspostRecommendations.ts"),
				N = n("./src/reddit/selectors/postCreations.ts"),
				R = n("./src/reddit/selectors/postDraft.ts"),
				M = n("./src/reddit/selectors/postGuidance.ts"),
				D = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				L = n("./src/reddit/selectors/user.ts"),
				A = n("./src/reddit/actions/postCreation/constants.ts"),
				F = n("./src/reddit/actions/postCreation/general.ts"),
				B = n("./src/reddit/actions/postCreation/mediaUpload.ts");
			const U = Object(r.a)(A.w),
				K = Object(r.a)(A.Q),
				W = Object(r.a)(A.o),
				G = Object(r.a)(A.y),
				H = Object(r.a)(A.eb),
				V = Object(r.a)(A.K),
				z = Object(r.a)(A.a),
				q = Object(r.a)(A.G),
				Q = e => `/r/${e}/about/${w.s}`,
				Y = (e, t) => {
					const n = e || {
							duration: o.D,
							options: []
						},
						{
							govType: r,
							newSubreddit: s,
							newTopMod: i
						} = Object(N.u)(t),
						a = {
							...n
						};
					return r && (a.type = r), a.type === j.a.ReplaceTopMod ? (a.params = {
						userName: i
					}, a.options = j.f[j.a.ReplaceTopMod]()) : a.type === j.a.Spinoff ? (a.params = {
						subreddit: s
					}, a.options = j.f[j.a.Spinoff](s)) : a.options = a.options.map(e => ({
						text: e.text.trim()
					})).filter(e => !!e.text), a
				},
				J = e => {
					const t = e.uploads,
						n = Object(N.Z)(e),
						r = Object(N.a)(e),
						s = Object(N.lb)(e);
					if (r === o.bc.POST) return h.a.getPendingThumbnailUploads(s, t);
					if (r === o.bc.MEDIA && n && n.items.length) {
						const {
							video: e
						} = n.items[0];
						if (e && e.thumbnail && !t[T.n]) return [{
							...e.thumbnail,
							uploadKey: T.n
						}]
					}
				},
				X = (e, t) => async (n, r, s) => {
					let {
						apiContext: i
					} = s, a = r();
					const {
						pending: c
					} = a.creations.api.post.submit, d = Object(R.g)(a);
					if (c || d) return;
					n(q(e)), a = r();
					const u = Object(N.a)(a),
						m = E.d.rteVideoPoster(a),
						p = J(a),
						h = u === o.bc.MEDIA;
					p && (m || h) && (await n(B.f(p)), J(r())) || (e === T.r.Draft ? await n(Object(l.r)(t.draftId)) : e === T.r.ScheduledPost && Object(D.r)(a) ? await n(Z(t)) : e === T.r.ScheduledPost ? await n($(t)) : await n(ee(t)))
				}, Z = e => async (t, n, o) => {
					let {
						gqlContext: r
					} = o;
					const s = n(),
						a = Object(N.gb)(s),
						c = Object(N.hb)(s, e),
						d = Object(N.h)(s),
						l = Object(D.r)(s);
					if (!(c && d.id && a && Object(O.f)(l))) return;
					const u = d.id,
						h = Object(D.a)(s, {
							subredditId: u,
							scheduledPostId: l
						});
					if (h && Object(i.a)(Object(k.r)(h)(s)), t(U(c)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(N.x)(n()))) return;
					if (e.postGuidanceValidationPending && (await e.postGuidanceValidationPending, Object(M.c)(n()))) return;
					const {
						isPoll: b,
						polls: f
					} = Object(N.u)(s), g = Y(f, s), v = {
						...Object(C.e)({
							poll: b ? g : void 0,
							submission: c,
							schedule: a,
							subredditId: d.id,
							scheduledPostId: l
						})
					}, E = await Object(y.a)(r(), v);
					if (E.ok) return t(Object(m.e)({
						subredditId: d.id
					})), void t(Object(p.a)(Q(d.name), !1));
					const x = E.error;
					t(W(x))
				}, $ = e => async (t, n, o) => {
					let {
						gqlContext: r
					} = o;
					const s = n(),
						a = Object(N.gb)(s),
						c = Object(N.hb)(s, e),
						d = Object(N.h)(s),
						l = Object(D.b)(s);
					if (!c || !d.id || !a) return;
					if (t(U(c)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(N.x)(n()))) return;
					if (e.postGuidanceValidationPending && (await e.postGuidanceValidationPending, Object(M.c)(n()))) return;
					const {
						isPoll: u,
						polls: h
					} = Object(N.u)(s), b = Y(h, s), f = {
						duration: b.duration,
						options: b.options
					}, g = {
						...Object(C.d)({
							poll: u ? f : void 0,
							submission: c,
							schedule: a,
							subredditId: d.id
						}),
						creationToken: l
					}, v = await Object(C.a)(r(), g);
					if (v.ok) {
						t(Object(m.e)({
							subredditId: d.id
						}));
						const e = v.body.data.createScheduledPost.scheduledPost;
						return e && Object(i.a)(Object(k.o)(Object(x.d)(e))(s)), void t(Object(p.a)(Q(d.name), !1))
					}
					const y = v.error;
					t(W(y))
				}, ee = e => async (t, n, r) => {
					let {
						apiContext: i
					} = r;
					await t(Object(u.b)({
						action: s.a.PostSubmit,
						catchAndLogError: !0
					}));
					const l = n(),
						m = Object(N.hb)(l, e),
						{
							isPoll: h,
							polls: C
						} = Object(N.u)(l),
						y = Y(C, l);
					if (!m) return;
					if (t(U(m)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(N.x)(n()))) return;
					if (e.postGuidanceValidationPending && (await e.postGuidanceValidationPending, Object(M.c)(n()))) return;
					let x;
					const O = h && E.d.spPolls(l);
					if ((x = O ? await
							function(e, t, n) {
								const r = t.destSubreddit.id;
								return Object(g.a)(e, {
									method: o.ob.POST,
									endpoint: `${b.a.metaUrl}/polls/${r}`,
									type: "json",
									data: {
										poll: n,
										subredditId: r,
										...Object(f.a)(Object(v.d)(t))
									}
								}).then(async e => {
									const n = e.ok ? {
											...e,
											body: {
												json: {
													data: e.body
												}
											}
										} : e,
										o = await Object(v.e)(n, t);
									if (o.ok) {
										return {
											body: {
												...o.body,
												poll: e.body.poll
											},
											ok: !0,
											status: e.status
										}
									}
									return {
										error: o.body,
										ok: !1,
										status: e.status
									}
								})
							}(i(), m, y) : h ? await Object(v.b)(i(), {
								...m,
								kind: T.p.POLL,
								poll: y
							}) : m.kind === T.p.GALLERY ? await Object(v.a)(i(), m) : await Object(v.c)(i(), m)).ok) {
						const e = Object(L.m)(l),
							n = x.body;
						t(K({
							draftId: m.draftId,
							response: n
						})), O && t(Object(c.c)({
							poll: n.poll
						}));
						const o = Object(P.b)(l);
						m.kind !== T.p.LINK && m.kind !== T.p.RICH_TEXT && m.kind !== T.p.MARKDOWN || h || !o || t(Object(a.c)());
						const r = (n.path || `/user/${Object(I.e)(e)}/submitted`).replace(/^\/r\/u_/, "/user/");
						t(Object(d.subredditInvalidateListing)(m.destSubreddit.name)), t(Object(p.a)(r, !1))
					} else {
						if (h) {
							const e = x.error;
							t(G(e))
						}
						const e = x.error;
						te(t, e)
					}
					const k = Object(F.o)(m.kind),
						j = x.ok && x.body && x.body.id && Object(S.y)(x.body.id),
						w = n();
					_.C(w, k, j, e.correlationId)
				}, te = (e, t) => {
					t.type === o.K.BAD_CAPTCHA_ERROR ? e(z()) : t.type === o.K.VALIDATION_ERROR ? e(H(t)) : t.type === o.K.SUBMIT_VALIDATION_ERROR ? e(V(t)) : e(W(t))
				}
		},
		"./src/reddit/actions/reCaptchaEnterprise.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "b", (function() {
				return C
			})), n.d(t, "e", (function() {
				return y
			}));
			var o = n("./src/lib/asyncActions/index.ts"),
				r = n("./src/lib/constants/euCookiePolicy.ts"),
				s = n("./src/lib/reCaptchaEnterprise/index.ts"),
				i = n("./src/lib/sentry/index.ts");

			function a(e) {
				return t => async (n, o, r) => {
					const s = o();
					if (e(s)) return t(n, o, r)
				}
			}
			var c = n("./node_modules/lodash/every.js"),
				d = n.n(c),
				l = n("./src/reddit/constants/experiments.ts"),
				u = n("./src/reddit/featureFlags/index.ts"),
				m = n("./src/reddit/featureFlags/utils.ts"),
				p = n("./src/reddit/helpers/chooseVariant/index.ts");
			const h = e => u.d.reCaptchaEnterprise(e),
				b = e => !!Object(p.c)(e, {
					experimentEligibilitySelector: Object(m.d)(Object(m.b)(...r.c)),
					experimentName: l.qf
				}),
				f = Object(o.b)("LOAD_RECAPTCHA_ENTERPRISE"),
				g = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
					return a(e => d()([h, b, e => e.tracking.reCaptchaEnterprise.load === o.a.New], t => t(e)))(async t => {
						t(f.requested());
						try {
							await s.b.loadScript(), t(f.succeeded())
						} catch (n) {
							if (t(f.failed()), !e) throw n;
							i.c.withScope(e => {
								Object(i.a)(e, {
									serverLogging: !1
								}), i.c.captureException(n)
							})
						}
					})
				},
				v = Object(o.b)("EXECUTE_RECAPTCHA_ENTERPRISE"),
				C = e => a(e => d()([h, b, e => e.tracking.reCaptchaEnterprise.load === o.a.Succeeded], t => t(e)))(async t => {
					t(v.requested());
					try {
						const n = await s.b.execute({
							action: e.action,
							fast: e.fast
						});
						return t(v.succeeded({
							token: n
						})), n
					} catch (n) {
						if (t(v.failed()), e.catchAndLogError) return i.c.withScope(e => {
							Object(i.a)(e, {
								serverLogging: !1
							}), i.c.captureException(n)
						}), "";
						throw n
					}
				}),
				y = Object(o.b)("SEND_RECAPTCHA_TOKEN")
		},
		"./src/reddit/actions/scheduledPosts/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return r
			})), n.d(t, "f", (function() {
				return s
			})), n.d(t, "m", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "l", (function() {
				return l
			})), n.d(t, "k", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "o", (function() {
				return p
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "n", (function() {
				return g
			})), n.d(t, "i", (function() {
				return v
			})), n.d(t, "r", (function() {
				return C
			})), n.d(t, "u", (function() {
				return y
			})), n.d(t, "p", (function() {
				return E
			})), n.d(t, "q", (function() {
				return x
			})), n.d(t, "v", (function() {
				return O
			})), n.d(t, "s", (function() {
				return _
			})), n.d(t, "x", (function() {
				return k
			})), n.d(t, "w", (function() {
				return j
			})), n.d(t, "t", (function() {
				return S
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js");
			const r = "SCHEDULED_POSTS_REQUESTED",
				s = "SCHEDULED_POSTS_LOADED",
				i = "STANDALONE_SCHEDULED_POSTS_LOADED",
				a = "RECURRING_SCHEDULED_POSTS_LOADED",
				c = "SCHEDULED_POSTS_FAILED",
				d = "SCHEDULED_POST_CREATION_SUCCEEDED",
				l = "SCHEDULED_POST_SUBMIT_NOW_SUCCESS",
				u = "SCHEDULED_POST_MUTATE_REQUESTED",
				m = "SCHEDULED_POST_MUTATE_FAILED",
				p = "STANDALONE_POST_MUTATE_SUCCESS",
				h = "RECURRING_POST_MUTATE_SUCCESS",
				b = "RECURRING_POST__EDIT_MODAL_LOAD",
				f = "RECURRING_POST__EDIT_LOAD",
				g = "STANDALONE_POST__EDIT_LOAD",
				v = "SCHEDULED_POST__DELETE_SUCCESS",
				C = () => o.fbt._("Failed to load scheduled posts", null, {
					hk: "1fhkq4"
				}),
				y = () => o.fbt._("Whoops! Invalid scheduled post", null, {
					hk: "35jBb6"
				}),
				E = () => o.fbt._("Unable to delete scheduled post", null, {
					hk: "23nWms"
				}),
				x = () => o.fbt._("Successfully deleted scheduled post", null, {
					hk: "1Lk7r2"
				}),
				O = () => o.fbt._("Unable to submit scheduled post", null, {
					hk: "vCW43"
				}),
				_ = () => o.fbt._("Retry", null, {
					hk: "4bCZ7M"
				}),
				k = () => o.fbt._("Successfully submitted scheduled post!", null, {
					hk: "ONo6q"
				}),
				j = () => o.fbt._("Successfully edited scheduled post!", null, {
					hk: "HfGcT"
				}),
				S = () => o.fbt._("Failed to update scheduled post", null, {
					hk: "2zBuRu"
				})
		},
		"./src/reddit/actions/scheduledPosts/edit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return C
			})), n.d(t, "a", (function() {
				return E
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react-router-redux/es/index.js"),
				s = n("./src/telemetry/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/scheduledPosts/index.ts"),
				c = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/endpoints/scheduledPosts/update.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				m = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				p = n("./src/reddit/models/ScheduledPost/index.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				b = n("./src/reddit/routes/postCreation/index.ts"),
				f = n("./src/reddit/selectors/scheduledPosts/index.ts");
			const g = Object(i.a)(c.n),
				v = Object(i.a)(c.b),
				C = (e, t) => async (n, o, s) => {
					const i = Object(f.a)(o(), {
						scheduledPostId: t,
						subredditId: e
					});
					i && (await n(Object(r.b)(Object(b.c)(i.subreddit.name, i.collectionId))), n((Object(p.q)(i) ? v : g)(i)))
				}, y = (e, t) => {
					Object(p.q)(t) ? e(Object(a.d)({
						scheduledPost: t
					})) : e(Object(a.h)({
						scheduledPost: t
					}))
				}, E = (e, t, n) => async (r, i, b) => {
					let {
						gqlContext: g
					} = b;
					r(Object(a.g)());
					const v = Object(f.a)(i(), {
						subredditId: e,
						scheduledPostId: t
					});
					if (v && Object(p.q)(v) && Object(s.a)(Object(m.u)()(i(), v)), !v) return void r(Object(a.f)({
						message: o.fbt._("Scheduled post not found", null, {
							hk: "2zjM55"
						})
					}));
					if (!Object.keys(n).length) return void y(r, v);
					const C = await Object(l.a)(g(), {
							...n,
							id: t
						}),
						x = C.body;
					if (!(C.ok && x && x.data && x.data.updateScheduledPost && x.data.updateScheduledPost.ok && x.data.updateScheduledPost.scheduledPost)) return r(Object(a.f)({
						message: C.error && C.error.fields && C.error.fields.length && C.error.fields[0].msg || o.fbt._("Unknown error", null, {
							hk: "fXs5s"
						})
					})), void r(Object(d.f)(Object(d.e)(c.t(), h.b.Error, c.s(), E(e, t, n))));
					r(Object(d.f)(Object(d.e)(c.w(), h.b.SuccessCommunity))), y(r, Object(u.d)(x.data.updateScheduledPost.scheduledPost))
				}
		},
		"./src/reddit/actions/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return v
			})), n.d(t, "f", (function() {
				return C
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "c", (function() {
				return k
			})), n.d(t, "e", (function() {
				return S
			})), n.d(t, "i", (function() {
				return w
			})), n.d(t, "a", (function() {
				return I
			})), n.d(t, "b", (function() {
				return N
			}));
			var o = n("./src/lib/assertNever.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				i = n("./src/reddit/actions/scheduledPosts/edit.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/endpoints/scheduledPosts/index.ts"),
				d = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				l = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				u = n("./src/reddit/models/ScheduledPost/index.ts"),
				m = n("./src/reddit/models/Toast/index.ts"),
				p = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				h = n("./src/telemetry/index.ts");
			const b = 25,
				f = 1e4,
				g = Object(r.a)(s.g),
				v = Object(r.a)(s.k),
				C = Object(r.a)(s.j),
				y = Object(r.a)(s.o),
				E = Object(r.a)(s.d),
				x = Object(r.a)(s.f),
				O = Object(r.a)(s.m),
				_ = Object(r.a)(s.a),
				k = Object(r.a)(s.c),
				j = Object(r.a)(s.e),
				S = Object(r.a)(s.h),
				T = (e, t) => {
					e(j()), e(Object(a.f)(Object(a.e)(s.r(), m.b.Error, s.s(), w(t))))
				},
				w = e => {
					let {
						subredditId: t,
						includeStandalone: n = {
							standaloneFirst: b
						},
						includeRecurring: o = {
							recurringFirst: f
						},
						...r
					} = e;
					return async (e, s, i) => {
						let {
							gqlContext: a
						} = i;
						if (Object(p.h)(s(), {
								subredditId: t
							})) return;
						e(g());
						const l = {
								subredditId: t,
								includeRecurring: o,
								includeStandalone: n,
								...r
							},
							u = await Object(c.b)(a(), l);
						Object(c.f)(u, l) ? P(e, Object(d.e)(u.body.data), l) : T(e, l)
					}
				},
				I = e => async (t, n, o) => {
					let {
						gqlContext: r
					} = o;
					const s = n();
					if (!Object(p.h)(s, {
							subredditId: e
						})) return t(w({
						subredditId: e
					}));
					if (!Object(p.g)(s, {
							subredditId: e,
							type: u.g.standalonePosts
						})) return;
					const i = Object(p.c)(s, {
						subredditId: e,
						type: u.g.standalonePosts
					});
					if (!i) return;
					t(g());
					const a = {
							subredditId: e,
							includeStandalone: {
								standaloneFirst: b,
								standaloneAfter: i
							}
						},
						l = await Object(c.b)(r(), a);
					l.ok ? P(t, Object(d.e)(l.body.data), a) : t(j())
				}, P = (e, t, n) => {
					Object(d.b)(t) ? e(x(t)) : Object(d.a)(t) ? e(_(t)) : Object(d.c)(t) ? e(O(t)) : T(e, n)
				}, N = (e, t) => async (n, r, s) => {
					const a = {},
						c = r();
					switch (e) {
						case "isModDistinguished":
						case "isNsfw":
						case "isOriginalContent":
						case "isContestMode":
						case "isPostAsMetaMod":
						case "isSpoiler":
							a[e] = !t[e];
							break;
						case "isSticky":
							const n = !!t.sticky && "NONE" !== t.sticky;
							a.sticky = n ? "NONE" : "SECOND";
							break;
						default:
							return Object(o.a)(e)
					}
					Object(h.a)(Object(l.t)(e, a[e], Object(u.q)(t))(c)), n(Object(i.a)(t.subreddit.id, t.id, a))
				}
		},
		"./src/reddit/actions/snoovatar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return h
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "e", (function() {
				return v
			})), n.d(t, "c", (function() {
				return C
			})), n.d(t, "d", (function() {
				return y
			}));
			var o = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/sentry/index.ts"),
				i = n("./src/config.ts"),
				a = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts");
			var u = n("./src/reddit/reducers/features/avatar/index.ts"),
				m = n("./src/reddit/selectors/avatar.ts"),
				p = n("./src/reddit/actions/users.ts");
			Object(o.a)({
				features: {
					avatar: u.a
				}
			});
			const h = "SET_AVATAR_USER",
				b = Object(r.a)(h),
				f = "RANDOM_AVATAR_LOADED",
				g = Object(r.a)(f),
				v = (e, t, n) => async (o, r, s) => {
					let {
						apiContext: u
					} = s;
					var h, b, f, g;
					const v = Object(m.b)(r()),
						C = await (async (e, t, n, o, r) => Object(c.a)(Object(d.a)(e, [l.a]), {
							endpoint: `${i.a.snoovatarUrl}/api/snoovatar?skip_telemetry=true`,
							method: a.ob.POST,
							headers: {
								"Content-Type": "application/json ",
								"X-CSRF-Token": r || ""
							},
							data: {
								accessory_ids: t,
								styles: n,
								...o
							}
						}))(u(), e, t, n, v);
					if (!C.ok) throw new Error("User avatar failed to save");
					return o(Object(p.y)(C.body)), {
						accountIcon: null === (b = null === (h = C.body) || void 0 === h ? void 0 : h.avatar) || void 0 === b ? void 0 : b.headshot_image_url,
						fullBodySnoovatar: null === (g = null === (f = C.body) || void 0 === f ? void 0 : f.avatar) || void 0 === g ? void 0 : g.image_url
					}
				}, C = () => async (e, t, n) => {
					let {
						apiContext: o
					} = n;
					try {
						const t = await (async e => Object(c.a)(Object(d.a)(e, [l.a]), {
							endpoint: `${i.a.snoovatarUrl}/api/account`,
							method: a.ob.GET
						}))(o());
						t.ok && e(b(t.body))
					} catch (r) {
						s.c.captureException(r)
					}
				}, y = () => async (e, t, n) => {
					let {
						apiContext: o
					} = n;
					try {
						const t = await (async e => Object(c.a)(Object(d.a)(e, [l.a]), {
							endpoint: `${i.a.snoovatarUrl}/api/snoovatars/random:byId`,
							method: a.ob.GET
						}))(o());
						t.ok && e(g(t.body))
					} catch (r) {
						s.c.captureException(r)
					}
				}
		},
		"./src/reddit/actions/snoovatarModal.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			}));
			var o = n("./src/lib/pageTitle/index.ts"),
				r = n("./src/reddit/actions/login.ts"),
				s = n("./src/reddit/actions/modal.ts"),
				i = n("./src/reddit/actions/platform.ts"),
				a = n("./src/reddit/actions/users.ts"),
				c = n("./src/reddit/constants/modals.ts"),
				d = n("./src/reddit/helpers/trackers/snoovatar.ts"),
				l = n("./src/reddit/selectors/user.ts"),
				u = n("./src/telemetry/index.ts");
			const m = () => async (e, t) => {
				const n = t();
				Object(u.a)(Object(d.l)(n)), e(Object(a.s)({
					forceFetch: !0
				})), await e(Object(s.g)(c.a.SNOOVATAR_MODAL))
			};

			function p() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
				return async (t, n) => {
					const {
						clickSource: a,
						share: m,
						source: p,
						activeTab: h,
						activeMeSubpage: b,
						activeDetails: f,
						shopTabState: g
					} = e, v = n();
					a && Object(u.a)(Object(d.g)(a)(v)), Object(l.S)(v) ? (await t(Object(s.h)(c.a.SNOOVATAR_MODAL, {
						share: m,
						source: p,
						activeTab: h,
						activeMeSubpage: b,
						activeDetails: f,
						shopTabState: g
					})), t(Object(i.n)({
						title: Object(o.n)()
					}))) : await t(Object(r.openLoginModal)())
				}
			}
		},
		"./src/reddit/actions/subreddit/muting.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return j
			})), n.d(t, "d", (function() {
				return T
			})), n.d(t, "e", (function() {
				return w
			})), n.d(t, "g", (function() {
				return I
			})), n.d(t, "a", (function() {
				return P
			})), n.d(t, "f", (function() {
				return N
			})), n.d(t, "b", (function() {
				return R
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/redditGQL/operations/DeleteSubredditMuteSettings.json"),
				c = n("./src/redditGQL/operations/MutedSubreddits.json"),
				d = n("./src/redditGQL/operations/UpdateSubredditMuteAndNotificationLevelSettings.json"),
				l = n("./src/redditGQL/operations/UpdateSubredditMuteSettings.json");
			const u = (e, t) => Object(i.a)(e, {
					...l,
					variables: {
						input: {
							subredditId: t
						}
					}
				}),
				m = (e, t) => Object(i.a)(e, {
					...a,
					variables: {
						input: {
							subredditId: t
						}
					}
				});
			var p = n("./src/reddit/models/Toast/index.ts"),
				h = n("./src/reddit/actions/subreddit/constants.ts"),
				b = n("./src/reddit/actions/subreddit/notifications.ts"),
				f = n("./src/reddit/selectors/subreddit.ts");
			const g = e => Object(s.f)({
					id: e,
					kind: p.b.Error,
					duration: s.a,
					text: o.fbt._("An error has occured. Please try again later", null, {
						hk: "2FpsLy"
					})
				}),
				v = (e, t) => Object(s.f)({
					kind: p.b.SuccessCommunityGreen,
					text: o.fbt._("Muted r/{subreddit name}", [o.fbt._param("subreddit name", e)], {
						hk: "Mg9mO"
					}),
					...t ? {
						buttonText: o.fbt._("Undo", null, {
							hk: "2siioQ"
						}),
						buttonAction: t
					} : {}
				}),
				C = (e, t) => Object(s.f)({
					kind: p.b.SuccessCommunityGreen,
					text: o.fbt._("Unmuted r/{subreddit name}", [o.fbt._param("subreddit name", e)], {
						hk: "Fhnht"
					}),
					...t ? {
						buttonText: o.fbt._("Undo", null, {
							hk: "2siioQ"
						}),
						buttonAction: t
					} : {}
				});
			var y = n("./src/reddit/endpoints/subreddit/about.ts");
			const E = Object(r.a)(h.i),
				x = Object(r.a)(h.h),
				O = Object(r.a)(h.G),
				_ = (Object(r.a)(h.j), Object(r.a)(h.F), Object(r.a)(h.g)),
				k = Object(r.a)(h.f),
				j = e => {
					let {
						subredditId: t,
						subredditName: n,
						successCallback: o
					} = e;
					return async (e, r, s) => {
						let {
							gqlContext: i
						} = s;
						var a, c;
						const d = await u(i(), t);
						if (d.ok && d.body && (null === (c = null === (a = d.body) || void 0 === a ? void 0 : a.data.updateSubredditMuteSettings) || void 0 === c ? void 0 : c.ok)) o && o(), e(v(n, S({
							subredditId: t,
							subredditName: n
						})));
						else {
							e(g(`error-muting-${t}`))
						}
					}
				},
				S = e => {
					let {
						subredditId: t,
						subredditName: n,
						successCallback: o
					} = e;
					return async (e, r, s) => {
						let {
							gqlContext: i
						} = s;
						var a, c;
						const d = await m(i(), t);
						if (d.ok && d.body && (null === (c = null === (a = d.body) || void 0 === a ? void 0 : a.data.deleteSubredditMuteSettings) || void 0 === c ? void 0 : c.ok)) o && o(), e(C(n, j({
							subredditId: t,
							subredditName: n
						})));
						else {
							e(g(`error-muting-${t}`))
						}
					}
				},
				T = e => {
					let {
						subredditId: t,
						subredditName: n,
						successCallback: o
					} = e;
					return async (e, r, s) => {
						let {
							gqlContext: i
						} = s;
						var a, c;
						const d = await u(i(), t);
						if (d.ok && d.body && (null === (c = null === (a = d.body) || void 0 === a ? void 0 : a.data.updateSubredditMuteSettings) || void 0 === c ? void 0 : c.ok)) o && o(), e(Object(b.c)({
							subredditAboutInfo: {
								[t]: {
									isMuted: !0
								}
							}
						})), e(v(n, w({
							subredditId: t,
							subredditName: n
						})));
						else {
							e(g(`error-muting-${t}`))
						}
					}
				},
				w = e => {
					let {
						subredditId: t,
						subredditName: n,
						successCallback: o
					} = e;
					return async (e, r, s) => {
						let {
							gqlContext: i
						} = s;
						var a, c;
						const d = await m(i(), t);
						if (d.ok && d.body && (null === (c = null === (a = d.body) || void 0 === a ? void 0 : a.data.deleteSubredditMuteSettings) || void 0 === c ? void 0 : c.ok)) o && o(), e(Object(b.c)({
							subredditAboutInfo: {
								[t]: {
									isMuted: !1
								}
							}
						})), e(C(n, T({
							subredditId: t,
							subredditName: n
						})));
						else {
							e(g(`error-muting-${t}`))
						}
					}
				},
				I = e => {
					let {
						subredditId: t,
						notificationLevel: n
					} = e;
					return async (e, r, a) => {
						let {
							gqlContext: c
						} = a;
						var l, u;
						const m = Object(b.a)(n),
							h = await ((e, t, n) => Object(i.a)(e, {
								...d,
								variables: {
									input: {
										...n,
										subredditId: t
									}
								}
							}))(c(), t, m);
						h.ok && h.body && (null === (u = null === (l = h.body) || void 0 === l ? void 0 : l.data.updateSubredditMuteAndNotificationLevelSettings) || void 0 === u ? void 0 : u.ok) ? (e(O({
							subredditId: t,
							notificationLevel: n
						})), e(Object(s.f)({
							kind: p.b.SuccessCommunityGreen,
							text: Object(b.b)(n)
						}))) : e(Object(s.f)({
							kind: p.b.Error,
							text: o.fbt._("Failed to change the frequency of notifications from this community, please try again.", null, {
								hk: "4avFFV"
							})
						}))
					}
				},
				P = () => async (e, t, n) => {
					let {
						gqlContext: r
					} = n;
					const a = await (e => Object(i.a)(e, c))(r());
					if (a.ok && a.body && a.body.data) {
						const {
							data: t
						} = a.body, n = (t && t.identity.mutedSubreddits).edges.map(e => e.node);
						e(E({
							nodes: n
						}))
					} else e(x()), e(Object(s.f)({
						duration: s.a,
						kind: p.b.Error,
						text: o.fbt._("Failed to get muted subreddits, please try again.", null, {
							hk: "2dCj3Q"
						})
					}))
				}, N = e => {
					let {
						subredditId: t,
						subredditName: n
					} = e;
					return async (e, o, r) => {
						let {
							gqlContext: s
						} = r;
						var i, a;
						const c = await m(s(), t);
						if (c.ok && c.body && (null === (a = null === (i = c.body) || void 0 === i ? void 0 : i.data.deleteSubredditMuteSettings) || void 0 === a ? void 0 : a.ok)) e(_(t)), e(C(n));
						else {
							e(g(`error-unmuting-${t}`))
						}
					}
				}, R = e => {
					let {
						subredditName: t
					} = e;
					return async (e, n, r) => {
						let {
							gqlContext: i
						} = r;
						var a, c;
						const d = n(),
							l = Object(f.t)(d).find(e => e.name.toLowerCase() === t.toLowerCase());
						if (l) {
							const t = l.name,
								n = `error-muting-duplicate-${t}`;
							return e(Object(s.f)({
								id: n,
								kind: p.b.Error,
								duration: s.a,
								text: o.fbt._("Sorry, r/{subreddit name} is already muted.", [o.fbt._param("subreddit name", t)], {
									hk: "4n64wl"
								})
							}))
						}
						const m = await Object(y.a)(i(), t, !0),
							{
								data: h
							} = m.body,
							b = h && h.subreddit;
						if (!m.ok || null === b) {
							return e(((e, t) => Object(s.f)({
								id: e,
								kind: p.b.Error,
								duration: s.a,
								text: o.fbt._("Sorry, r/{subreddit name} isn't a community.", [o.fbt._param("subreddit name", t)], {
									hk: "3UtglL"
								})
							}))(`error-muting-${t}`, t))
						}
						const C = b.id,
							E = await u(i(), C);
						if (E.ok && E.body && (null === (c = null === (a = E.body) || void 0 === a ? void 0 : a.data.updateSubredditMuteSettings) || void 0 === c ? void 0 : c.ok)) e(k([b])), e(v(b.name));
						else {
							e(g(`error-muting-${C}`))
						}
					}
				}
		},
		"./src/reddit/actions/subreddit/notifications.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/notificationSettingsLayout/index.ts"),
				i = n("./src/reddit/actions/notificationsInbox/index.ts"),
				a = n("./src/reddit/actions/subreddit/constants.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/endpoints/subreddit/notificationSettings.ts"),
				l = n("./src/reddit/models/Subreddit/index.ts"),
				u = n("./src/reddit/models/Toast/index.ts");
			const m = Object(r.a)(a.z),
				p = Object(r.a)(a.y),
				h = Object(r.a)(a.x),
				b = e => {
					switch (e) {
						case l.c.FREQUENT:
							return {
								isSubredditUpdatesInterestingPostEnabled: !0, isUpdateFromSubredditEnabled: !0
							};
						case l.c.LOW:
							return {
								isSubredditUpdatesInterestingPostEnabled: !1, isUpdateFromSubredditEnabled: !0
							};
						case l.c.OFF:
						default:
							return {
								isSubredditUpdatesInterestingPostEnabled: !1, isUpdateFromSubredditEnabled: !1
							}
					}
				},
				f = e => {
					switch (e) {
						case l.c.OFF:
							return o.fbt._("Unfollowed. You wont get updates on new activity anymore.", null, {
								hk: "3e1CJR"
							});
						case l.c.FREQUENT:
							return o.fbt._("Followed! Now youll get updates on new activity.", null, {
								hk: "3JzOOa"
							});
						case l.c.LOW:
							return o.fbt._("Success! You will see fewer notifications from this community in the future.", null, {
								hk: "4x3TS8"
							});
						default:
							return null
					}
				};
			const g = e => {
				let {
					subredditId: t,
					notificationLevel: n,
					successCallback: r,
					undoCallback: a
				} = e;
				return async (e, l, g) => {
					let {
						gqlContext: v
					} = g;
					var C, y, E;
					e(p());
					const x = b(n),
						O = await Object(d.b)(v(), t, x);
					if ((null === (y = null === (C = O.error) || void 0 === C ? void 0 : C.fields) || void 0 === y ? void 0 : y.length) || function(e) {
							return Boolean(e && e.data && e.data.updateSubredditNotificationSettings)
						}(O.body) && (null === (E = O.body.data.updateSubredditNotificationSettings.errors) || void 0 === E ? void 0 : E.length)) return e(h()), e(Object(c.f)({
						kind: u.b.Error,
						text: o.fbt._("Failed to change the frequency of notifications from this community, please try again.", null, {
							hk: "4avFFV"
						})
					}));
					O.ok && (e(Object(s.c)({
						subredditId: t,
						notificationLevel: n
					})), e(m({
						subredditAboutInfo: {
							[t]: {
								notificationLevel: n
							}
						}
					})), r && r(), e(a ? Object(c.f)(Object(c.e)(f(n), u.b.Undo, o.fbt._("Undo", null, {
						hk: "46OwLP"
					}), Object(i.i)(t, a))) : Object(c.f)(Object(c.e)(f(n), u.b.SuccessCommunityGreen))))
				}
			}
		},
		"./src/reddit/actions/subredditAutocomplete/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return s
			}));
			const o = "SUBREDDIT_AUTOCOMPLETE__PENDING",
				r = "SUBREDDIT_AUTOCOMPLETE__LOADED",
				s = "SUBREDDIT_AUTOCOMPLETE__FAILED"
		},
		"./src/reddit/actions/subredditAutocomplete/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var o = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/makeGqlRequest/index.ts"),
				s = n("./src/redditGQL/operations/SubredditTypeaheadSearch.json"),
				i = (e, t) => Object(r.a)(e, {
					...s,
					variables: t
				}),
				a = n("./src/reddit/helpers/graphql/normalizeAllowedPostTypesFromGql/index.ts"),
				c = e => {
					let {
						allowedPostTypes: t,
						id: n,
						isCrosspostDestination: o,
						isNsfw: r,
						name: s,
						styles: i,
						subscribersCount: c
					} = e;
					return {
						allowedPostTypes: Object(a.a)(t),
						communityIcon: i && i.icon || "",
						icon: i && i.legacyIcon && i.legacyIcon.url || "",
						id: n,
						isCrosspostDestination: o,
						isNsfw: r,
						name: s,
						primaryColor: i && i.primaryColor || "",
						subscribers: c
					}
				},
				d = n("./src/reddit/helpers/name/index.ts"),
				l = n("./src/reddit/selectors/subredditAutocomplete.ts"),
				u = n("./src/reddit/actions/subredditAutocomplete/constants.ts");
			const m = Object(o.a)(u.c),
				p = Object(o.a)(u.b),
				h = Object(o.a)(u.a),
				b = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (n, o, r) => {
						let {
							gqlContext: s
						} = r;
						const a = Object(d.i)(e);
						if (!a) return;
						const u = o(),
							b = u.subredditAutocomplete;
						if (b.api.pending[a] || b.models[a]) return;
						if (Object(l.b)(u, {
								substring: a
							})) return;
						n(m({
							key: a
						}));
						const f = await i(s(), {
							query: a,
							includeNsfw: t
						});
						if (f.ok) {
							const e = f.body.data.subredditTypeahead.subreddits.edges.map(e => c(e.node));
							n(p({
								key: a,
								subreddits: e
							}))
						} else n(h({
							key: a,
							error: f.error
						}))
					}
				}
		},
		"./src/reddit/actions/subredditCrosspostable.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "d", (function() {
				return b
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/subscription/index.ts"),
				s = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts"),
				d = n("./src/reddit/selectors/subreddit.ts");
			const l = "SUBREDDIT_CROSSPOSTABLE__PENDING",
				u = "SUBREDDIT_CROSSPOSTABLE__LOADED",
				m = "SUBREDDIT_CROSSPOSTABLE__FAILED",
				p = (Object(o.a)(l), Object(o.a)(u)),
				h = Object(o.a)(m),
				b = () => async (e, t, n) => {
					let {
						apiContext: o
					} = n;
					await e(r.e());
					const {
						api: l,
						ids: u
					} = t().subreddits.crosspostable;
					if (l.pending || Object.keys(u).length) return;
					const m = await ((e, t) => Object(i.a)(Object(a.a)(e, [c.a]), {
						data: t,
						endpoint: `${e.apiUrl}/api/crosspostable_subreddits.json`,
						method: s.ob.GET
					}))(o(), {
						sr_detail: !1
					});
					if (m.ok) {
						const n = t(),
							o = m.body && m.body.length ? m.body.map(e => Object(d.I)(n, e)).filter(e => !!e).reduce((e, t) => (e[t] = !0, e), {}) : {};
						e(p({
							subredditIds: o
						}))
					} else e(h({
						error: m.error
					}))
				}
		},
		"./src/reddit/actions/subscription/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return s
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			}));
			const o = "SUBSCRIPTION__FETCH_DATA_PENDING",
				r = "SUBSCRIPTION__FETCH_DATA_SUCCESS",
				s = "SUBSCRIPTION__FETCH_DATA_FAILURE",
				i = "SUBSCRIPTION__SUBSCRIPTION_TOGGLED",
				a = "SUBSCRIPTION__SUBSCIPTION_TOGGLE_FAILED",
				c = "SUBSCRIPTION__ORDER_LOADED",
				d = "SUBSCRIPTION__SUBREDDIT_FAVORITE_TOGGLED",
				l = "SUBSCRIPTION__MULTI_FAVORITE_TOGGLED",
				u = "SUBSCRIPTION__MULTI_FOLLOW_TOGGLED"
		},
		"./src/reddit/actions/subscription/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return P
			})), n.d(t, "d", (function() {
				return R
			})), n.d(t, "c", (function() {
				return D
			})), n.d(t, "a", (function() {
				return A
			})), n.d(t, "b", (function() {
				return B
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/linkMatchers/customLinks.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/login.ts"),
				c = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/actions/subscription/constants.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/constants/posts.ts"),
				m = n("./src/lib/makeApiRequest/index.ts"),
				p = n("./src/lib/omitHeaders/index.ts"),
				h = n("./src/reddit/constants/headers.ts");
			var b = n("./src/reddit/endpoints/subreddit/subscriptions.ts"),
				f = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				g = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				v = n("./src/reddit/models/GqlTopLevelField.ts"),
				C = n("./src/reddit/models/User/index.ts");

			function y(e) {
				const t = [],
					n = [],
					o = {},
					r = {},
					{
						followedRedditorsInfo: s
					} = e.identity;
				for (const a of s.edges) {
					if (a.node.__typename !== C.c.AvailableRedditor || !a.node.profile) continue;
					const e = Object(f.a)(a.node.profile);
					o[e.id] = e;
					const {
						isFavorite: n
					} = a.node.profile;
					n && t.push(e.id)
				}
				const {
					subscribedSubreddits: i
				} = e.identity;
				for (const a of i.edges) {
					if (a.node.__typename !== v.a.Subreddit) continue;
					const e = Object(g.a)(a.node);
					r[e.id] = e;
					const {
						isFavorite: t
					} = a.node;
					t && n.push(e.id)
				}
				return {
					favoriteProfileIds: t,
					favoriteSubredditIds: n,
					profiles: o,
					subreddits: r
				}
			}
			var E = n("./src/reddit/models/Toast/index.ts"),
				x = n("./src/reddit/selectors/profile.ts"),
				O = n("./src/reddit/selectors/subreddit.ts"),
				_ = n("./src/reddit/selectors/subscriptions.ts"),
				k = n("./src/reddit/selectors/user.ts");
			const j = () => o.fbt._("Sorry, failed to update favorites.", null, {
					hk: "40XHkp"
				}),
				S = Object(i.a)(d.c),
				T = Object(i.a)(d.b),
				w = Object(i.a)(d.a),
				I = Object(i.a)(d.h),
				P = (Object(i.a)(d.i), Object(i.a)(d.g), () => async (e, t, n) => {
					let {
						gqlContext: o
					} = n;
					const r = t();
					if (!r.user.account || r.subscriptions.api.fetched) return;
					e(T());
					const s = await Object(b.a)(o());
					if (s.ok) {
						const t = y(s.body.data);
						e(S(t))
					} else e(w({
						error: s.error
					}))
				}),
				N = (e, t) => t.type === u.a.PROFILE && e.displayText === t.name.replace("u_", ""),
				R = (e, t, n) => async (i, d, m) => {
					let {
						apiContext: p
					} = m, h = e.map(e => e.type === u.a.SUBREDDIT ? {
						id: Object(O.I)(d(), e.name),
						name: e.name,
						type: e.type
					} : {
						id: Object(x.o)(d(), e.name),
						name: `${r.qc}${e.name}`,
						type: e.type
					});
					if (!Object(k.S)(d())) return i(Object(c.k)({
						actionSource: c.a.Subscribe
					})), void i(Object(a.openRegisterModal)());
					const f = Object(k.m)(d());
					if (f) {
						const t = h.length,
							n = e.length;
						if (h = h.filter(e => !N(f, e)), (e = e.filter(e => !N(f, e))).length !== n || h.length !== t) {
							const e = o.fbt._("You cannot follow yourself!", null, {
								hk: "3tfSaq"
							});
							i(Object(l.f)(Object(l.e)(e, E.b.Error)))
						}
						if (!e.length && !h.length) return
					}
					i(I({
						identifiers: h,
						nameIdentifiers: e,
						profileModels: d().profiles.models,
						subredditModels: d().subreddits.models,
						subscriptionsCount: Object(_.b)(d()),
						userIsSubscriber: t,
						widgetId: n
					}));
					const g = await Object(b.c)(p(), {
						subredditNames: h.map(e => {
							let {
								name: t
							} = e;
							return t
						}),
						subscribe: t
					});
					if (g.ok) {
						const n = 1 === e.length ? `${"subreddit"===e[0].type?s.d.subreddit:s.d.profile}${e[0].name}` : o.fbt._({
								"*": "{communities} communities",
								_1: "1 community"
							}, [o.fbt._plural(e.length, "communities")], {
								hk: "IgDzJ"
							}),
							r = o.fbt._("Successfully followed {communityname}", [o.fbt._param("communityname", n)], {
								hk: "23Snyg"
							}),
							a = o.fbt._("Successfully unfollowed {communityname}", [o.fbt._param("communityname", n)], {
								hk: "jfC0S"
							}),
							c = o.fbt._("Successfully joined {communityname}", [o.fbt._param("communityname", n)], {
								hk: "1W9UY3"
							}),
							d = o.fbt._("Successfully left {communityname}", [o.fbt._param("communityname", n)], {
								hk: "1saMW"
							});
						i(Object(l.f)({
							text: 1 === e.length && "profile" === e[0].type ? t ? r : a : t ? c : d
						}))
					} else {
						i(I({
							identifiers: h,
							nameIdentifiers: e,
							profileModels: d().profiles.models,
							subredditModels: d().subreddits.models,
							subscriptionsCount: Object(_.b)(d()),
							userIsSubscriber: !t,
							widgetId: n
						}));
						const r = o.fbt._("Something went wrong. Please try again!", null, {
							hk: "1zlDeq"
						});
						i(Object(l.f)(Object(l.e)(r, E.b.Error)))
					}
					return g.ok
				}, M = Object(i.a)(d.f), D = e => async (t, n, o) => {
					let {
						apiContext: r
					} = o;
					const s = n(),
						i = Object(O.Q)(s, {
							identifier: e
						});
					if (!i) throw new Error(`actions.subscription -- No subreddit or profile found with id ${e.id}`);
					const a = e.type === u.a.SUBREDDIT ? i.name : `u_${i.name}`,
						c = s.subscriptions.favoriteSubredditOrder || [],
						d = s.subscriptions.favoriteProfileOrder || [],
						m = c.indexOf(e.id),
						p = d.indexOf(e.id),
						h = -1 === m && -1 === p,
						f = s.subreddits.models,
						g = s.profiles.models,
						v = {
							type: e.type,
							name: i.name
						},
						C = () => Object(O.jb)(n(), {
							identifier: v
						});
					(C() || (await t(R([v], !0)), C())) && (t(M({
						makeFavorite: h,
						identifier: e,
						subredditModels: f,
						profileModels: g
					})), (await Object(b.b)(r(), a, h)).ok || (t(M({
						makeFavorite: !h,
						identifier: e,
						subredditModels: f,
						profileModels: g
					})), t(Object(l.f)({
						text: j(),
						kind: E.b.Error
					}))))
				}, L = Object(i.a)(d.d), A = e => async (t, n, o) => {
					let {
						apiContext: s
					} = o;
					const i = n().multireddits.models,
						a = () => {
							t(Object(l.f)({
								text: j(),
								kind: E.b.Error
							}))
						},
						c = i[e];
					if (!c) return void a();
					const d = !c.isFavorited;
					t(L({
						makeFavorite: d,
						multiredditPath: e,
						multiredditsModelsState: i
					})), (await ((e, t, n) => Object(m.a)(Object(p.a)(e, [h.a]), {
						method: r.ob.POST,
						endpoint: `${e.apiUrl}/api/multi/favorite`,
						data: {
							make_favorite: n ? "true" : "false",
							multipath: t,
							api_type: "json"
						}
					}))(s(), e, d)).ok || (t(L({
						makeFavorite: !d,
						multiredditPath: e,
						multiredditsModelsState: i
					})), a())
				}, F = Object(i.a)(d.e), B = e => async (t, n, s) => {
					let {
						apiContext: i
					} = s;
					const a = n(),
						c = a.multireddits.models;
					if (!Object(k.S)(a)) return;
					const d = function() {
							let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
							t(Object(l.f)({
								text: o.fbt._("Sorry, failed to {followAction}", [o.fbt._param("followAction", e ? o.fbt._("follow", null, {
									hk: "3YMYJK"
								}) : o.fbt._("unfollow", null, {
									hk: "24IYxj"
								}))], {
									hk: "1ufRSl"
								}),
								kind: E.b.Error
							}))
						},
						u = c[e];
					if (!u) return void d();
					const b = !u.isFollowed;
					t(F({
						follow: b,
						multiredditPath: e,
						multiredditsModelsState: c
					})), (await ((e, t, n) => Object(m.a)(Object(p.a)(e, [h.a]), {
						method: r.ob.POST,
						endpoint: `${e.apiUrl}/api/multi/subscribe`,
						data: {
							action: n ? "sub" : "unsub",
							path: t,
							api_type: "json"
						},
						type: "json"
					}))(i(), e, b)).ok || (t(F({
						follow: !b,
						multiredditPath: e,
						multiredditsModelsState: c
					})), d(b))
				}
		},
		"./src/reddit/actions/upload.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return d
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "m", (function() {
				return C
			})), n.d(t, "k", (function() {
				return j
			})), n.d(t, "l", (function() {
				return T
			})), n.d(t, "i", (function() {
				return w
			})), n.d(t, "j", (function() {
				return I
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/lodash/get.js"),
				r = n.n(o),
				s = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/uploadToS3/index.ts"),
				c = n("./src/reddit/models/Upload/index.ts");
			const d = "UPLOAD_PENDING",
				l = "UPLOAD_UPLOADING",
				u = "UPLOAD_METADATA_CHANGED",
				m = "UPLOAD_PROGRESS",
				p = "UPLOAD_SUCCESS",
				h = "UPLOAD_FAILED",
				b = "UPLOAD_CANCELED",
				f = "UPLOAD_REMOVED",
				g = Object(i.a)(d),
				v = Object(i.a)(l),
				C = Object(i.a)(u),
				y = Object(i.a)(m),
				E = Object(i.a)(p),
				x = Object(i.a)(h),
				O = Object(i.a)(b),
				_ = Object(i.a)(f),
				k = new Map,
				j = (e, t) => {
					const n = k.get(e) || [];
					n.push(t), k.set(e, n)
				},
				S = (e, t) => {
					const n = k.get(e);
					n && n.forEach(n => n(e, t)), k.delete(e)
				},
				T = function(e, t, n) {
					let o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					return async (i, d) => {
						const l = t;
						if (d().uploads[l] && Object(c.c)(d().uploads[l])) return;
						const u = Object(s.a)(),
							m = () => {
								const e = d().uploads[l];
								return !e || e.id !== u || e.status === c.a.CANCELED
							};
						i(g({
							key: l,
							id: u,
							file: e
						}));
						const {
							uploadLease: p,
							error: h
						} = await n(d().uploads[l]);
						if (m()) return;
						if (h || !p) return void i(x({
							key: l,
							error: h
						}));
						let b;
						j(u, () => {
							b && b.abort()
						}), i(v({
							key: l
						}));
						const f = await Object(a.a)(e, p, e => (b = e, o && e.on("progress", e => {
							if (!m() && "upload" === e.direction) {
								const t = {
									percent: e.percent,
									total: e.total,
									uploaded: e.loaded
								};
								i(y({
									key: l,
									progress: t
								}))
							}
						}), e));
						if (b = null, !m())
							if (f.ok) {
								const e = decodeURIComponent(f.body.PostResponse.Location);
								i(E({
									key: l,
									url: e
								}))
							} else {
								const e = r()(f, "body.Error.Message.0"),
									t = {
										type: "ERROR",
										...e ? {
											fields: [{
												field: "0",
												msg: e
											}]
										} : {}
									};
								i(x({
									key: l,
									error: t
								}))
							}
					}
				},
				w = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return (n, o) => {
						const r = o().uploads[e];
						r && (S(r.id, t), n(t ? _({
							key: e
						}) : O({
							key: e
						})))
					}
				},
				I = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return (n, o) => {
						Object.keys(o().uploads).forEach(o => {
							o.startsWith(e) && n(w(o, t))
						})
					}
				}
		},
		"./src/reddit/actions/urlRequested.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var o = n("./src/lib/matchRoute/index.ts"),
				r = n("./src/lib/opener/index.ts"),
				s = n("./node_modules/react-router-redux/es/index.js");
			const i = function(e) {
				let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
				return async (n, i, a) => {
					let {
						routes: c
					} = a;
					const d = i();
					Object(o.a)(e, c, d) ? n(Object(s.b)(e)) : t ? Object(r.e)(e, "_blank") : window.location.assign(e)
				}
			}
		},
		"./src/reddit/components/AvatarPost/index.m.less": function(e, t, n) {
			e.exports = {
				avatarPostContainer: "_2nck8non0VYnkIkyUpuvpw",
				avatarPostImage: "_2yQLdTnHA0y3hZ3I588oUM"
			}
		},
		"./src/reddit/components/BackToSubreddit/index.m.less": function(e, t, n) {
			e.exports = {
				backToSubreddit: "_3aAvvioBKBNnlJqKytAVAd",
				innerContainer: "_3aVffPeM6Nkqs7D0RJ5FBs",
				back: "_17MxNCYEMmDof9NnT6ffxl",
				title: "_2VB8YvVdvxx0h0VGYVrpBX",
				subredditIcon: "_2Aw3HO2EUDcP7F481ZxyYl",
				content: "uhMLc-O1VODjzminrp8py"
			}
		},
		"./src/reddit/components/CCM/AddModNoteCTA/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/hooks/useTracking.ts"),
				c = n("./src/reddit/helpers/trackers/modTools.ts"),
				d = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/contexts/PageLayer/index.tsx"),
				u = n("./src/reddit/actions/tooltip.ts"),
				m = n("./src/reddit/components/Hovercards/AuthorHovercard/ModIdCard/async.tsx"),
				p = n("./src/reddit/components/Hovercards/helpers.ts"),
				h = n("./src/reddit/components/PostTopMeta/index.tsx"),
				b = n("./src/reddit/hooks/useIsOverlay.ts"),
				f = n("./src/reddit/models/Post/index.ts"),
				g = n("./src/redditGQL/types.ts");
			const v = Object(l.v)();
			t.a = v(e => {
				let {
					pageLayer: t,
					postOrComment: n,
					className: l
				} = e;
				var v;
				const C = Object(b.a)(),
					y = Object(i.d)(),
					E = Object(a.a)(),
					x = (null === (v = null == t ? void 0 : t.urlParams) || void 0 === v ? void 0 : v.pageName) === d.wb.Modqueue,
					O = Object(r.useCallback)(() => {
						const e = Object(p.b)({
							itemId: n.id,
							tooltipIdPrefix: m.a,
							tooltipType: C ? h.f.Lightbox : void 0
						});
						y(Object(u.h)({
							tooltipId: e,
							args: {
								isModNotesView: !0,
								modNotesFilter: g.A.Note
							}
						})), E(Object(c.a)(n.id, n.authorId))
					}, [n, y, C, E]);
				return !x || Object(f.p)(n.author) ? null : s.a.createElement("button", {
					className: l,
					onClick: O
				}, o.fbt._("Add a note", null, {
					hk: "1dmmma"
				}))
			})
		},
		"./src/reddit/components/CollapseIntoOverflow/index.m.less": function(e, t, n) {
			e.exports = {
				hidden: "_2x_bJPl7Q970NCRxOS36QB",
				innerWrapper: "_3oLr47tuKGv2mNpavCZ2X0",
				outerWrapper: "_1wi_3uF8fUynqe5reIop-G",
				overflowMenu: "_2aOuodBenLHlceR3j0AlIM",
				overflowMenuWrapper: "_3nQ7w1VIzZvzFawddOYgBC",
				row: "_2IirhjIkZ7hgWGtpr087xZ",
				postWrap: "WaTxGJXojt1RbZOH3q6eC"
			}
		},
		"./src/reddit/components/CollapseIntoOverflow/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			}));
			var o = n("./src/lib/fastdom/index.ts"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/OverflowMenu/index.tsx"),
				c = n("./src/reddit/helpers/richTextEditor/index.ts"),
				d = n("./src/reddit/components/CollapseIntoOverflow/index.m.less"),
				l = n.n(d);
			const u = 33,
				m = e => e.preventDefault(),
				p = (e, t) => `${e===c.a.Post?"Post":"Comment"}--Overflow-Dropdown__${t}`;
			class h extends s.a.Component {
				constructor(e) {
					super(e), this.breakpoints = [], this.updateCurrentBreakpoint = () => {
						o.a.read(() => {
							if (!this.container) return;
							const {
								indexOfCurrentBreakpoint: e,
								totalNumCollapsibleItems: t
							} = this.state, n = this.container.clientWidth;
							let r = this.breakpoints.findIndex((e, o) => {
								const r = o + 1 < t - 1,
									s = this.breakpoints[o + 1] + (r ? u : 0);
								return n < s
							});
							r < 0 && (r = t - 1), r !== e && o.a.write(() => {
								this.setState({
									indexOfCurrentBreakpoint: r,
									shouldShowOverflow: r < t - 1
								})
							})
						})
					};
					const t = this.getTotalNumCollapsibleItems();
					this.state = this.calculateOverflowState(t)
				}
				calculateOverflowState(e) {
					return {
						indexOfCurrentBreakpoint: e - 1,
						shouldShowOverflow: !1,
						totalNumCollapsibleItems: e
					}
				}
				componentDidMount() {
					window.addEventListener("resize", this.updateCurrentBreakpoint)
				}
				componentWillUnmount() {
					window.removeEventListener("resize", this.updateCurrentBreakpoint)
				}
				componentDidUpdate() {
					const e = this.getTotalNumCollapsibleItems();
					e !== this.state.totalNumCollapsibleItems && o.a.write(() => {
						this.breakpoints = [], this.setState(this.calculateOverflowState(e))
					})
				}
				getTotalNumCollapsibleItems() {
					return Array.isArray(this.props.children) ? this.props.children.reduce((e, t) => (Array.isArray(t) ? e += t.length : t && e++, e), 0) : 1
				}
				registerBreakpoint(e, t) {
					this.breakpoints[t] = 0, o.a.read(() => {
						if (e && e.clientWidth) {
							const n = e.clientWidth;
							this.breakpoints[t] = 0 === t ? n : this.breakpoints[t - 1] + n, this.breakpoints[this.state.totalNumCollapsibleItems - 1] && this.updateCurrentBreakpoint()
						}
					})
				}
				render() {
					const {
						children: e,
						className: t,
						oveflowMenuDropdownId: n,
						onOverflowMenuClick: o,
						renderOverflowMenuTooltip: r,
						editorType: d
					} = this.props, {
						indexOfCurrentBreakpoint: u,
						shouldShowOverflow: h
					} = this.state, b = s.a.Children.toArray(e).filter(Boolean);
					return s.a.createElement("div", {
						className: Object(i.a)(l.a.outerWrapper, t),
						ref: e => this.container = e
					}, s.a.createElement("div", {
						className: l.a.innerWrapper
					}, b.map((e, t) => s.a.createElement("span", {
						className: t > u ? l.a.hidden : void 0,
						key: t,
						ref: e => this.registerBreakpoint(e, t)
					}, e)), h && s.a.createElement("div", {
						className: l.a.overflowMenuWrapper,
						key: "overflowMenuWrapper"
					}, r && r(), s.a.createElement(a.b, {
						className: l.a.overflowMenu,
						dropdownId: p(d, n),
						isFixed: !1,
						handleMouseDown: m,
						onClick: o
					}, s.a.createElement("div", {
						className: Object(i.a)(l.a.row, {
							[l.a.postWrap]: d === c.a.Post
						})
					}, b.map((e, t) => s.a.createElement("span", {
						className: t <= u ? l.a.hidden : void 0,
						key: t
					}, e)))))))
				}
			}
		},
		"./src/reddit/components/CommentCreation/ExpandingFormDiv.m.less": function(e, t, n) {
			e.exports = {
				breakout: "_1VBLErIxAjOke05q8yLOyf"
			}
		},
		"./src/reddit/components/CommentCreation/ExpandingFormDiv.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/CommentCreation/ExpandingFormDiv.m.less"),
				a = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const d = (e, t) => 21 * e + 33 + (t ? 10 : 0);
			t.a = e => {
				let {
					breakOut: t,
					depth: n,
					isEditing: o,
					...i
				} = e;
				return r.a.createElement("div", c({
					className: Object(s.a)({
						[a.a.breakout]: t
					}),
					style: {
						left: d(n, o)
					}
				}, i))
			}
		},
		"./src/reddit/components/CommentCreation/FormFooter/index.m.less": function(e, t, n) {
			e.exports = {
				BaseFooterButton: "_2vw1scWo_wiHUpczRL3dho",
				baseFooterButton: "_2vw1scWo_wiHUpczRL3dho",
				SubmitButton: "_22S4OsoDdOqiM-hPTeOURa",
				submitButton: "_22S4OsoDdOqiM-hPTeOURa",
				LoadingIcon: "_2qsMO_C_HwxgUgktaOeqZ2",
				loadingIcon: "_2qsMO_C_HwxgUgktaOeqZ2",
				CancelButton: "cZz52cPDbNgzrR1Oo1k27",
				cancelButton: "cZz52cPDbNgzrR1Oo1k27",
				ButtonWrapper: "_3SNMf5ZJL_5F1qxcZkD0Cp",
				buttonWrapper: "_3SNMf5ZJL_5F1qxcZkD0Cp",
				FormFooterWrapper: "_17TqawK-44tH0psnHPIhzS",
				formFooterWrapper: "_17TqawK-44tH0psnHPIhzS",
				pending: "_5p2VqxvUAZTtPIXr7XU5p"
			}
		},
		"./src/reddit/components/CommentCreation/FormFooter/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/controls/Button/index.tsx"),
				c = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				d = n("./src/reddit/components/CommentCreation/FormFooter/index.m.less"),
				l = n.n(d);
			const {
				fbt: u
			} = n("./node_modules/fbt/lib/FbtPublic.js"), m = i.a.wrapped(c.a, "LoadingIcon", l.a), p = i.a.wrapped(a.t, "CancelButton", l.a), h = e => e.preventDefault();
			t.a = e => {
				let {
					pending: t,
					cancelButtonEnabled: n = !0,
					children: o,
					className: i,
					submitButtonText: c,
					canSubmit: d,
					onSubmit: b,
					onCancel: f
				} = e;
				return r.a.createElement("div", {
					className: Object(s.a)(l.a.FormFooterWrapper, i, {
						[l.a.pending]: t
					})
				}, r.a.createElement("div", {
					className: l.a.ButtonWrapper
				}, r.a.createElement(a.t, {
					className: l.a.SubmitButton,
					size: a.d.XS,
					type: "submit",
					disabled: !d,
					onClick: e => {
						b && b(e)
					},
					onMouseDown: h
				}, t ? r.a.createElement(m, {
					sizePx: 10
				}) : c), n && r.a.createElement(p, {
					priority: a.c.Secondary,
					size: a.d.XS,
					type: "reset",
					disabled: t,
					onClick: f,
					onMouseDown: h
				}, u._("Cancel", null, {
					hk: "2TSLl5"
				}))), o)
			}
		},
		"./src/reddit/components/CommentCreation/MarkdownCommentForm/MarkdownModeButton.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_3oZ5XBWSc3x7cXsvdt3fJ",
				wrapper: "_3oZ5XBWSc3x7cXsvdt3fJ",
				MarkdownModeIcon: "_1EifMLRAKpii4eqciAhY4q",
				markdownModeIcon: "_1EifMLRAKpii4eqciAhY4q",
				Button: "_1Q2Vq3gesOWZA73NbspEiQ",
				button: "_1Q2Vq3gesOWZA73NbspEiQ"
			}
		},
		"./src/reddit/components/CommentCreation/MarkdownCommentForm/index.m.less": function(e, t, n) {
			e.exports = {
				LoadingIcon: "_2izw1tRcQRvnfuR1E05Cy4",
				loadingIcon: "_2izw1tRcQRvnfuR1E05Cy4",
				CommentHeader: "PN-j_b1WdWATQha3fOgkV",
				commentHeader: "PN-j_b1WdWATQha3fOgkV",
				HelpButton: "MQruKnjMvMoDlmee_nF40",
				helpButton: "MQruKnjMvMoDlmee_nF40",
				SwitchModeButton: "_2UH-_HmB6X-2cCsOZVDtC5",
				switchModeButton: "_2UH-_HmB6X-2cCsOZVDtC5",
				FormHeaderText: "_1EQf9w-o91arfThHA8fn-N",
				formHeaderText: "_1EQf9w-o91arfThHA8fn-N",
				HelpIcon: "_3TI2tdRj3loY834ns393zu",
				helpIcon: "_3TI2tdRj3loY834ns393zu",
				Wrapper: "B0932G-wzdOKwoaSaKsKU",
				wrapper: "B0932G-wzdOKwoaSaKsKU",
				isTopLevelComment: "_3-O087Fe8Gpv51vkui03iG",
				mRedesign: "dDb_knwHdpaUGniyi2rvM",
				FormWrapper: "_2LoNYeXgOQfq1adQ3jWSbi",
				formWrapper: "_2LoNYeXgOQfq1adQ3jWSbi",
				ResizableAutosizeTextarea: "AISc5olsWsxMr-ZvG8ywU",
				resizableAutosizeTextarea: "AISc5olsWsxMr-ZvG8ywU",
				mExpanded: "_2FiN5dLqiHVqs1l1NeoU-W",
				FormFooter: "OQubMtSYxy2qH2Q1upQvp",
				formFooter: "OQubMtSYxy2qH2Q1upQvp",
				userIcon: "_1LJWM5yPEtZv26nvbB_mvr",
				CurrentUserIcon: "_6R8kWvljXn9F_7IAh1RG4",
				currentUserIcon: "_6R8kWvljXn9F_7IAh1RG4",
				pending: "_1N53zdZlGyvjHMUoXkJa42",
				focused: "_2sPOgUISlhUYTMcHhUPCTP"
			}
		},
		"./src/reddit/components/CommentCreation/MarkdownCommentForm/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return be
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/debounce.js"),
				s = n.n(r),
				i = n("./node_modules/lodash/noop.js"),
				a = n.n(i),
				c = n("./node_modules/react/index.js"),
				d = n.n(c),
				l = n("./node_modules/react-dom/index.js"),
				u = n("./node_modules/react-redux/es/index.js"),
				m = n("./node_modules/reselect/es/index.js"),
				p = n("./src/reddit/actions/comment/authoring.ts"),
				h = n("./src/reddit/components/AuthorLink/index.tsx"),
				b = n("./src/reddit/components/CommentCreation/NavigationModule/index.ts"),
				f = n("./src/reddit/components/CommentCreation/ToxicityWarningModal.tsx"),
				g = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				v = n("./src/reddit/components/MarkdownHelp/index.tsx"),
				C = n("./src/reddit/components/UserIcon/CurrentUserIcon.tsx"),
				y = n("./src/reddit/controls/ErrorText/index.tsx"),
				E = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				x = n("./src/reddit/icons/svgs/Help/index.tsx"),
				O = n("./src/reddit/components/CommentCreation/ExpandingFormDiv.tsx"),
				_ = n("./src/reddit/components/CommentCreation/FormFooter/index.tsx"),
				k = n("./src/lib/fastdom/index.ts"),
				j = n("./src/reddit/components/CommentCreation/ToolbarSelector.m.less"),
				S = n.n(j),
				T = n("./src/lib/lessComponent.tsx");
			const w = 310,
				I = T.a.div("Container", S.a);
			class P extends d.a.Component {
				constructor() {
					super(...arguments), this.state = {
						toolbarType: null
					}, this.setContainerRef = e => this.container = e, this.selectToolbar = () => {
						const e = this.container && this.container.parentElement;
						if (!e) return;
						const {
							width: t
						} = e.getBoundingClientRect(), n = t < w ? "compact" : "full";
						n !== this.state.toolbarType && k.a.write(() => {
							this.setState({
								toolbarType: n
							})
						})
					}
				}
				componentDidMount() {
					k.a.read(this.selectToolbar), window.addEventListener("resize", this.selectToolbar)
				}
				componentWillUnmount() {
					window.removeEventListener("resize", this.selectToolbar)
				}
				render() {
					return d.a.createElement(I, {
						innerRef: this.setContainerRef
					}, this.state.toolbarType ? this.props.children(this.state.toolbarType) : null)
				}
			}
			var N = n("./src/reddit/icons/svgs/MarkdownMode/index.tsx"),
				R = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				M = n("./src/reddit/components/CommentCreation/MarkdownCommentForm/MarkdownModeButton.m.less"),
				D = n.n(M),
				L = n("./src/reddit/controls/Button/index.tsx");
			const A = T.a.wrapped(E.a, "LoadingIcon", D.a),
				F = e => {
					let {
						isFilled: t,
						...n
					} = e;
					return d.a.createElement(A, n)
				},
				B = T.a.div("Wrapper", D.a),
				U = T.a.wrapped(N.a, "MarkdownModeIcon", D.a),
				K = e => {
					let {
						isFilled: t,
						...n
					} = e;
					return d.a.createElement(U, n)
				};
			var W = d.a.memo((function(e) {
					const t = o.fbt._("Switch to fancy pants editor", null, {
						hk: "1XOb4H"
					});
					return d.a.createElement(B, null, d.a.createElement(L.t, {
						priority: L.c.Plain,
						size: L.d.XS,
						"aria-label": t,
						innerRef: e.buttonRef,
						className: e.className,
						onClick: e.onClick,
						Icon: e.isConverting ? F : K
					}, d.a.createElement(R.a, {
						text: t
					})))
				})),
				G = n("./src/lib/classNames/index.ts"),
				H = n("./src/reddit/constants/keycodes.ts"),
				V = n("./src/reddit/components/CommentCreation/getCancelModalId.ts"),
				z = n("./src/realtime/GQLSubscription/async.tsx"),
				q = n("./src/reddit/components/UsersCountIndicator/constants.ts"),
				Q = n("./src/reddit/constants/componentSizes.ts"),
				Y = n("./src/reddit/constants/componentTestIds.ts"),
				J = n("./src/reddit/selectors/activeModalId.ts"),
				X = n("./src/reddit/selectors/comments.ts"),
				Z = n("./src/reddit/selectors/editorContent.ts"),
				$ = n("./src/reddit/selectors/experiments/typingIndicators.ts"),
				ee = n("./src/reddit/actions/modal.ts"),
				te = n("./src/reddit/components/ResizableAutosizeTextarea/index.tsx"),
				ne = n("./src/reddit/models/PostCreationForm/index.ts"),
				oe = n("./src/reddit/models/PostDraft/index.ts"),
				re = n("./src/reddit/models/User/index.ts"),
				se = n("./src/reddit/components/CommentCreation/MarkdownCommentForm/index.m.less"),
				ie = n.n(se);
			const ae = T.a.button("SwitchModeButton", ie.a),
				ce = T.a.wrapped(E.a, "LoadingIcon", ie.a),
				de = T.a.div("CommentHeader", ie.a),
				le = T.a.span("FormHeaderText", ie.a),
				ue = T.a.button("HelpButton", ie.a),
				me = T.a.wrapped(x.a, "HelpIcon", ie.a),
				pe = T.a.wrapped(te.a, "ResizableAutosizeTextarea", ie.a),
				he = T.a.wrapped(C.a, "CurrentUserIcon", ie.a),
				be = e => d.a.createElement(ue, {
					className: e.className,
					onClick: e.onClick
				}, d.a.createElement(me, null)),
				fe = 8,
				ge = 16,
				ve = Object(u.b)(() => Object(m.c)({
					activeModalId: J.a,
					userName: e => e.user.account ? Object(re.e)(e.user.account) : "",
					pending: (e, t) => e.features.comments.submit.pending[t.draftKey],
					draft: X.i,
					isConverting: (e, t) => Object(Z.a)(e, t.draftKey),
					isTypingIndicatorsWriteTestEnabled: (e, t) => !!t.isTopLevelComment && Object($.d)(e)
				}), (e, t) => ({
					cancelModalToggled: () => e(Object(ee.i)(Object(V.a)(t.draftKey))),
					helpModalToggled: () => e(Object(ee.i)(v.b))
				}));
			class Ce extends d.a.Component {
				constructor(e) {
					super(e), this.textAreaRef = null, this.realtimeGQLVariables = void 0, this.cancelForm = () => {
						this.props.onCancel(), this.onBlur()
					}, this.setUserStoppedTyping = s()(() => this.setState({
						isUserTyping: !1
					}), q.c), this.detectBreakout = () => {
						if (!this.wrapperEl || !this.wrapperEl.parentElement || this.props.isTopLevelComment) return;
						const e = this.wrapperEl.parentElement.getBoundingClientRect().width < Q.c,
							t = this.getWrapperHeight();
						e === this.state.breakOut && t === this.state.wrapperHeight || k.a.write(() => {
							this.setState({
								breakOut: e,
								wrapperHeight: t
							})
						})
					}, this.focus = () => {
						this.textAreaRef && this.textAreaRef.focus()
					}, this.onChange = e => {
						const {
							value: t
						} = e.currentTarget;
						this.props.onChange && this.props.onChange({
							text: t,
							editorState: null
						}), this.setState(() => ({
							text: t,
							hasChanged: !0,
							showError: !1
						}), () => {
							k.a.read(this.detectBreakout)
						}), this.props.isTypingIndicatorsWriteTestEnabled && (this.state.isUserTyping || this.setState({
							isUserTyping: !0
						}), this.setUserStoppedTyping())
					}, this.shouldConfirmCancel = () => this.userHasEnteredText() && this.state.hasChanged && this.props.draftType === oe.c.edit, this.onCancel = () => {
						this.shouldConfirmCancel() ? this.props.cancelModalToggled() : this.cancelForm()
					}, this.onBlur = e => {
						(!e || e && e.relatedTarget !== this.switchModeBtn) && (this.textAreaRef && this.textAreaRef.blur(), this.props.onFocusChanged(!1))
					}, this.onFocus = () => {
						this.props.onFocus(), this.props.onFocusChanged(!0)
					}, this.handleKeyDown = e => {
						const {
							ctrlKey: t,
							metaKey: n,
							keyCode: o
						} = e;
						(t || n) && o === H.a.Enter && this.onSubmit()
					}, this.onSubmit = () => {
						this.props.onSubmit({
							commentMode: ne.i.MARKDOWN,
							draftType: this.props.draftType,
							editorState: null,
							text: this.getCurrentText(),
							validate: this.props.showWarningModal
						}), this.onBlur()
					}, this.userHasEnteredText = () => {
						const {
							text: e
						} = this.state;
						return !!e.trim()
					}, this.setWrapperRef = e => {
						this.wrapperEl = e, this.props.editorElementRef && this.props.editorElementRef(e)
					}, this.setTextAreaRef = e => this.textAreaRef = e;
					const {
						postId: t,
						isTypingIndicatorsWriteTestEnabled: n
					} = e;
					n && (this.realtimeGQLVariables = {
						input: {
							channel: {
								teamOwner: "CONTENT_AND_COMMUNITIES",
								category: "USER_IS_TYPING_ON_POST",
								postID: t
							}
						}
					});
					const {
						draftType: r,
						hasError: i,
						initialText: a
					} = e;
					this.state = {
						text: a || "",
						autofocusDisabled: !1,
						hasChanged: !1,
						showError: i,
						breakOut: !1,
						wrapperHeight: void 0,
						formHeight: null,
						cancelModalText: r === oe.c.edit ? o.fbt._("Are you sure that you want to discard your edits?", null, {
							hk: "3RHatI"
						}) : o.fbt._("Are you sure that you want to discard your comment?", null, {
							hk: "38Df9h"
						}),
						isUserTyping: !1
					}
				}
				componentDidMount() {
					this.props.onMount(), window.addEventListener("resize", this.detectBreakout), k.a.read(this.detectBreakout), k.a.write(() => {
						this.props.draft.hasFocus && this.textAreaRef && this.textAreaRef.focus()
					}), this.props.instanceRef && this.props.instanceRef(this)
				}
				componentWillUnmount() {
					this.props.onUnmount({
						text: this.getCurrentText()
					}), window.removeEventListener("resize", this.detectBreakout), this.props.instanceRef && this.props.instanceRef(null), this.props.isTypingIndicatorsWriteTestEnabled && this.setUserStoppedTyping.cancel()
				}
				componentDidUpdate(e) {
					const t = e.pending,
						{
							hasError: n,
							pending: o
						} = this.props;
					t && !o && !n ? this.setState({
						text: "",
						showError: !1
					}) : e.hasError !== this.props.hasError && this.setState({
						showError: this.props.hasError
					})
				}
				getCurrentText() {
					const {
						draft: e
					} = this.props, t = e && e.text;
					return this.state.text || t
				}
				getWrapperHeight() {
					if (!this.textAreaRef) return;
					const e = Object(l.findDOMNode)(this.textAreaRef);
					return e instanceof Element ? e.getBoundingClientRect().height + fe + ge + Q.n : void 0
				}
				render() {
					const {
						activeModalId: e,
						autofocus: t,
						cancelModalToggled: n,
						className: r,
						disableAutofocus: s,
						depth: i,
						draft: c,
						draftKey: l,
						draftType: u,
						errorMsgs: m,
						pending: C,
						modalSeen: E,
						submitButtonText: x,
						isCommentBoxDesignEnabled: k,
						isExpanded: j,
						isTopLevelComment: S,
						isTypingIndicatorsWriteTestEnabled: T,
						onSwitchMode: w,
						userName: I
					} = this.props, {
						cancelModalText: N,
						showError: R,
						text: M,
						breakOut: D,
						wrapperHeight: L,
						isUserTyping: A
					} = this.state, F = Object(V.a)(l), B = c.draftType === oe.c.edit;
					return d.a.createElement("div", {
						"data-test-id": Y.b,
						className: Object(G.a)(ie.a.Wrapper, r, {
							[ie.a.isTopLevelComment]: S,
							[ie.a.mExpanded]: j,
							[ie.a.mRedesign]: k
						}),
						ref: this.setWrapperRef,
						style: {
							height: D ? L : void 0
						}
					}, T && A && d.a.createElement(z.a, {
						variables: this.realtimeGQLVariables,
						onData: a.a,
						queryKey: "userIsTypingOnPost"
					}), !k && S && I && d.a.createElement(de, null, d.a.createElement(le, null, o.fbt._("Comment as {authorLink}", [o.fbt._param("authorLink", d.a.createElement(h.a, {
						author: I,
						isAuthorDeleted: !1
					}, I))], {
						hk: "4pMWAk"
					}))), d.a.createElement(O.a, {
						breakOut: D,
						depth: i,
						isEditing: B
					}, k && d.a.createElement("div", {
						className: ie.a.userIcon
					}, d.a.createElement(he, null)), d.a.createElement("div", {
						className: Object(G.a)(ie.a.FormWrapper, {
							[ie.a.pending]: C,
							[ie.a.focused]: c.hasFocus
						})
					}, d.a.createElement(pe, {
						innerRef: this.setTextAreaRef,
						autoFocus: t && !s,
						disabled: C,
						initialHeight: this.props.initialHeight,
						onBlur: this.onBlur,
						onChange: this.onChange,
						onEditorResize: this.props.onEditorResize,
						onFocus: this.onFocus,
						onKeyDown: this.handleKeyDown,
						placeholder: k ? o.fbt._("Add a comment", null, {
							hk: "39ZBm0"
						}) : o.fbt._("What are your thoughts?", null, {
							hk: "4or1AH"
						}),
						value: M
					}), (!k || j) && d.a.createElement(_.a, {
						className: ie.a.FormFooter,
						cancelButtonEnabled: u !== oe.c.replyToPost,
						onSubmit: this.onSubmit,
						onCancel: this.onCancel,
						pending: C,
						submitButtonText: x,
						canSubmit: this.userHasEnteredText()
					}, d.a.createElement(P, null, e => "compact" === e ? d.a.createElement(W, {
						buttonRef: e => this.switchModeBtn = e,
						onClick: () => w(ne.i.RICH_TEXT, M, l),
						isConverting: this.props.isConverting
					}) : d.a.createElement("div", null, d.a.createElement(ae, {
						innerRef: e => this.switchModeBtn = e,
						onClick: () => w(ne.i.RICH_TEXT, M, l)
					}, o.fbt._("Switch to Fancy Pants Editor", null, {
						hk: "ousUG"
					}), this.props.isConverting && d.a.createElement(ce, {
						sizePx: 12
					})))), d.a.createElement(be, {
						onClick: this.props.helpModalToggled
					})))), R && Object(y.c)(m), e === F && d.a.createElement(g.a, {
						actionText: o.fbt._("Discard", null, {
							hk: "1kJ5PR"
						}),
						cancelActionText: o.fbt._("keep", null, {
							hk: "J0ER1"
						}),
						modalText: N,
						onConfirm: () => this.cancelForm(),
						toggleModal: n,
						trackClick: () => {}
					}), e === v.b && d.a.createElement(v.a, {
						withOverlay: !0
					}), e === p.t && d.a.createElement(f.a, {
						onSubmit: this.onSubmit,
						modalSeen: E,
						withOverlay: !0
					}), d.a.createElement(b.a, {
						editKey: l,
						hasValue: !!M
					}))
				}
			}
			t.b = ve(Ce)
		},
		"./src/reddit/components/CommentCreation/NavigationModule/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-router/esm/react-router.js");
			let a = null;
			class c extends s.a.PureComponent {
				constructor() {
					super(...arguments), this.unblock = e => {
						c.blockers.delete(e), c.blockers.size || (a && a(), a = null, window.removeEventListener("beforeunload", c.navigationBlocker))
					}
				}
				componentDidUpdate(e) {
					this.props.skipBlockingOnPageReload ? this.unblock(this.props.editKey) : !e.hasValue && this.props.hasValue ? this.block(this.props.editKey) : e.hasValue && !this.props.hasValue && this.unblock(this.props.editKey)
				}
				componentWillUnmount() {
					this.unblock(this.props.editKey)
				}
				componentDidMount() {
					this.props.hasValue && this.block(this.props.editKey)
				}
				block(e) {
					c.blockers.add(e), a || (window.addEventListener("beforeunload", c.navigationBlocker), a = this.props.history.block(() => {
						const e = this.props.isPostEdit ? o.fbt._("You have a post edit in progress, are you sure you want to discard it?", null, {
							hk: "4u5L7p"
						}) : o.fbt._("You have a comment in progress, are you sure you want to discard it?", null, {
							hk: "rgscd"
						});
						return !!window.confirm(e) && void 0
					}))
				}
				render() {
					return null
				}
			}
			c.blockers = new Set, c.navigationBlocker = e => {
				const t = "Are you sure you want to leave?";
				return e.returnValue = t, t
			}, t.a = Object(i.i)(c)
		},
		"./src/reddit/components/CommentCreation/ToolbarSelector.m.less": function(e, t, n) {
			e.exports = {
				Container: "_1XC-wMQsKPqfaPcfWQCZdW",
				container: "_1XC-wMQsKPqfaPcfWQCZdW"
			}
		},
		"./src/reddit/components/CommentCreation/ToxicityWarningModal.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				a = n("./src/higherOrderComponents/asModal/index.tsx"),
				c = n("./src/reddit/actions/comment/authoring.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				l = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				u = n("./src/reddit/components/TrackingHelper/index.tsx"),
				m = n("./src/reddit/controls/TextButton/index.tsx"),
				p = n("./src/reddit/constants/tracking.ts"),
				h = n("./src/reddit/selectors/telemetry.ts");
			const b = e => ({
					source: "toxicity_modal",
					...h.p(e),
					screen: h.db(e),
					subreddit: h.mb(e)
				}),
				f = e => t => ({
					action: p.c.VIEW,
					noun: "modal",
					correlationId: e,
					...b(t)
				}),
				g = e => t => ({
					action: p.c.CLICK,
					noun: "submit",
					correlationId: e,
					...b(t)
				}),
				v = e => t => ({
					action: p.c.CLICK,
					noun: "edit",
					correlationId: e,
					...b(t)
				}),
				C = e => t => ({
					action: p.c.CLICK,
					noun: "close",
					correlationId: e,
					...b(t)
				});
			var y = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx");
			const {
				fbt: E
			} = n("./node_modules/fbt/lib/FbtPublic.js"), x = Object(s.b)(null, (e, t) => ({
				closeModal: () => {
					e(Object(d.g)(c.t))
				},
				continue: () => {
					t.onSubmit()
				}
			}));
			class O extends r.a.Component {
				constructor(e) {
					super(e), this.state = {
						correlationId: Object(i.a)()
					}
				}
				componentDidMount() {
					this.props.modalSeen(), this.props.sendEvent(f(this.state.correlationId))
				}
				render() {
					return r.a.createElement(l.e, null, r.a.createElement(l.i, null, r.a.createElement(y.a, null, r.a.createElement(l.q, null, E._("Are you sure you want to post that?", null, {
						hk: "4yXqtu"
					})), r.a.createElement(m.a, {
						onClick: () => {
							this.props.sendEvent(C(this.state.correlationId)), this.props.closeModal()
						}
					}, r.a.createElement(l.b, null)))), r.a.createElement(l.l, null, r.a.createElement(l.p, null, E._("A reminder from the mods: Please follow community rules when commenting.", null, {
						hk: "Hdi9f"
					}))), r.a.createElement(l.g, null, r.a.createElement(l.a, {
						onClick: () => {
							this.props.sendEvent(v(this.state.correlationId)), this.props.closeModal()
						},
						"data-redditstyle": !0
					}, E._("Go back and edit", null, {
						hk: "3nGNI7"
					})), r.a.createElement(l.r, {
						onClick: () => {
							this.props.sendEvent(g(this.state.correlationId)), this.props.continue()
						},
						"data-redditstyle": !0
					}, E._("Comment", null, {
						hk: "1leYg7"
					}))))
				}
			}
			t.a = Object(a.a)(x(Object(u.c)(O)))
		},
		"./src/reddit/components/CommentCreation/getCancelModalId.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			const o = e => `Comment-cancelModal__${e}`
		},
		"./src/reddit/components/CommentSort/CommentSort.m.less": function(e, t, n) {
			e.exports = {
				container: "_2ulKn_zs7Y3LWsOqoFLHPo",
				mHasOtherDiscussions: "_3iO3U_i4YUx-2qahK_BTu1",
				HighlightPicker: "_1n6gZPmNQU56UBglU718cx",
				highlightPicker: "_1n6gZPmNQU56UBglU718cx",
				Row: "zW82EsY6Pakxpq4WWvsUG",
				row: "zW82EsY6Pakxpq4WWvsUG",
				SortPicker: "_1nMYOibX9neGRqvcaCrPDz",
				sortPicker: "_1nMYOibX9neGRqvcaCrPDz",
				containerRow: "_1avwNy0RnwlEwVEW-fwKCI",
				DropdownContainer: "_3N0NZT0gc58Hq7p0XRUjsH",
				dropdownContainer: "_3N0NZT0gc58Hq7p0XRUjsH",
				ContestMode: "_3dAMO_XZMVp2K1JSO53ohA",
				contestMode: "_3dAMO_XZMVp2K1JSO53ohA",
				SortOptionDropdownText: "_3LRBCA71BwLLXBNsSlY7HW",
				sortOptionDropdownText: "_3LRBCA71BwLLXBNsSlY7HW",
				commentSearchMargin: "_2_QzTCgd5SYB-X8CTqZf9T",
				ToggleSwitch: "JVPG0c9TNru5TLSq9sdUG",
				toggleSwitch: "JVPG0c9TNru5TLSq9sdUG",
				DropdownTriangle: "_2MGxQvIhmM2I5CzPdSJTtM",
				dropdownTriangle: "_2MGxQvIhmM2I5CzPdSJTtM",
				hideCommentSort: "uAIheeoxWlq57lu5ghv43",
				HighlightWrapper: "_201SpO3todaXvcWUHaLymN",
				highlightWrapper: "_201SpO3todaXvcWUHaLymN",
				Info: "_1urK6AxAk9Sl76RgLUHOqh",
				info: "_1urK6AxAk9Sl76RgLUHOqh",
				paddingBottom: "_233thT4kQqtwrHDoMY0Dbv",
				SetSort: "_1Pn7_008tGFVitpaAxNI9b",
				setSort: "_1Pn7_008tGFVitpaAxNI9b",
				SingleCommentText: "_2iOrDLLjWlyPdmGh4fQMuE",
				singleCommentText: "_2iOrDLLjWlyPdmGh4fQMuE",
				SortLink: "_2C0TYCrsi0B3m8sQW0hmFv",
				sortLink: "_2C0TYCrsi0B3m8sQW0hmFv",
				Title: "_1MfL8RlT7Bsr76qYvR-nqM",
				title: "_1MfL8RlT7Bsr76qYvR-nqM",
				Tooltip: "_2PA6P-upB6MB4B4I4WgZGA",
				tooltip: "_2PA6P-upB6MB4B4I4WgZGA",
				ViewFullLinkContainer: "_2Cjk95J3a3LyPUHsLEhO37",
				viewFullLinkContainer: "_2Cjk95J3a3LyPUHsLEhO37",
				ViewFullLinkOrOverlayLink: "_3P3T6fdpdL6GGPyCM7zs9q",
				viewFullLinkOrOverlayLink: "_3P3T6fdpdL6GGPyCM7zs9q",
				verticalDivider: "_3v-KNQB_UvJqSbWcQZmc0U"
			}
		},
		"./src/reddit/components/CommentSort/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return $
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/actions/comment/index.ts"),
				m = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/actions/post.ts"),
				h = n("./src/reddit/actions/toaster.ts"),
				b = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				g = n("./src/reddit/constants/headers.ts"),
				v = n("./src/reddit/models/Toast/index.ts");
			const C = (e, t) => async (n, r, s) => {
				let {
					apiContext: i
				} = s;
				const a = await (async (e, t, n) => Object(b.a)(Object(f.a)(e, [g.a]), {
						endpoint: `${e.apiUrl}/api/set_suggested_sort/`,
						method: d.ob.POST,
						data: {
							api_type: "json",
							id: t,
							sort: n
						}
					}))(i(), e, t),
					c = `error-block-${t}`,
					l = `success-block-${t}`;
				if (a.ok) {
					n(Object(p.Q)({
						[e]: {
							suggestedSort: t
						}
					}));
					const r = t ? o.fbt._("Suggested sort is on.", null, {
						hk: "tW1Rb"
					}) : o.fbt._("Suggested sort is off.", null, {
						hk: "4fwvgj"
					});
					n(h.f({
						id: l,
						kind: v.b.SuccessCommunityGreen,
						text: r
					}))
				} else n(h.f({
					id: c,
					kind: v.b.Error,
					text: o.fbt._("Try again later", null, {
						hk: "1Lqlj2"
					}),
					buttonText: o.fbt._("Retry", null, {
						hk: "44HF9e"
					}),
					buttonAction: C(e, t)
				}))
			};
			var y = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				E = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				x = n("./src/reddit/components/LinkOrOverlayLink/index.tsx"),
				O = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				_ = n("./src/reddit/components/SearchResultsContent/helpers/isCommentSearchRoute.ts"),
				k = n("./src/reddit/components/TrackingHelper/index.tsx"),
				j = n("./src/reddit/contexts/PageLayer/index.tsx"),
				S = n("./src/reddit/controls/Dropdown/index.tsx"),
				T = n("./src/reddit/controls/Dropdown/Row.tsx"),
				w = n("./src/reddit/controls/Search/CommentSearch/index.tsx"),
				I = n("./src/reddit/controls/ToggleSwitch/index.tsx"),
				P = n("./src/reddit/helpers/path/index.ts"),
				N = n("./src/reddit/selectors/telemetry.ts");
			n("./src/telemetry/models/Event.ts");
			const R = (e, t, n, o, r) => s => ({
					source: "comment_sort",
					action: "click",
					noun: e,
					actionInfo: {
						pageType: t ? "post_detail" : "home"
					},
					listing: Object(N.A)(s, void 0, {
						oldSort: n,
						sort: o,
						source: r
					}),
					userSubreddit: Object(N.vb)(s)
				}),
				M = (e, t) => n => ({
					source: "comment_highlighting",
					action: t,
					noun: e
				}),
				D = e => ({
					subreddit: Object(N.mb)(e),
					userSubreddit: Object(N.vb)(e)
				}),
				L = e => t => ({
					source: "contest_mode",
					action: "click",
					noun: e ? "enable" : "disable",
					...D
				});
			var A = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				F = n("./src/reddit/icons/svgs/Info/index.tsx"),
				B = n("./src/reddit/selectors/activeModalId.ts"),
				U = n("./src/reddit/selectors/comments.ts"),
				K = n("./src/reddit/selectors/experiments/commentSearchPdp.ts"),
				W = n("./src/reddit/selectors/moderatorPermissions.ts"),
				G = n("./src/reddit/selectors/posts.ts"),
				H = n("./src/reddit/selectors/tooltip.ts"),
				V = n("./src/reddit/selectors/user.ts"),
				z = n("./src/reddit/components/CommentSort/CommentSort.m.less"),
				q = n.n(z),
				Q = n("./src/reddit/reducers/features/comments/visitHighlightingFilter/index.ts");
			const Y = Object(O.a)(S.a),
				J = e => e === Q.a.First ? o.fbt._("First Visit", null, {
					hk: "HdDSr"
				}) : e === Q.a.Last ? o.fbt._("Last Visit", null, {
					hk: "3ubIq3"
				}) : o.fbt._("None", null, {
					hk: "4jwXNg"
				});
			class X extends s.a.Component {
				constructor() {
					super(...arguments), this.track = () => {
						const {
							trackHighlight: e,
							selectedSort: t
						} = this.props;
						if (t !== Q.a.None) {
							e(t === Q.a.Last ? "since_last_visit" : "since_first_visit", "view")
						}
					}, this.onDropdownClick = (e, t) => {
						this.props.trackHighlight(e, "click"), this.props.changeHighlightSort(t)
					}, this.onDropdownClickFirst = () => {
						this.onDropdownClick("since_first_visit", Q.a.First)
					}, this.onDropdownClickLast = () => {
						this.onDropdownClick("since_last_visit", Q.a.Last)
					}, this.onDropdownClickNone = () => {
						this.onDropdownClick("do_not_highlight", Q.a.None)
					}
				}
				componentDidMount() {
					this.track()
				}
				componentDidUpdate(e) {
					e.selectedSort !== this.props.selectedSort && this.track()
				}
				render() {
					const {
						highlightIsOpen: e,
						id: t,
						onOpen: n,
						selectedSort: r
					} = this.props;
					return s.a.createElement("div", {
						className: q.a.HighlightWrapper
					}, s.a.createElement(T.b, {
						className: Object(c.a)(q.a.HighlightPicker, q.a.Row),
						textClassName: q.a.SortOptionDropdownText,
						displayText: `${o.fbt._("Highlight",null,{hk:"2ZiUE8"})}: ${J(r)}`,
						id: t,
						noHover: !0,
						onClick: n
					}), s.a.createElement(A.b, {
						className: q.a.DropdownTriangle,
						onClick: n
					}), s.a.createElement(Y, {
						isOpen: e,
						renderContentsHidden: !0,
						tooltipId: t
					}, s.a.createElement(T.b, {
						displayText: J(Q.a.First),
						isSelected: r === Q.a.First,
						onClick: this.onDropdownClickFirst
					}), s.a.createElement(T.b, {
						displayText: J(Q.a.Last),
						isSelected: r === Q.a.Last,
						onClick: this.onDropdownClickLast
					}), s.a.createElement(T.b, {
						displayText: J(Q.a.None),
						isSelected: r === Q.a.None,
						onClick: this.onDropdownClickNone
					})))
				}
			}
			var Z = X;
			const $ = "CommentSort--SortPicker",
				ee = "CommentSort--HighlightPicker",
				te = "CommentSort--Tooltip",
				ne = Object(O.a)(S.a),
				oe = Object(j.v)(),
				re = Object(a.c)({
					commentPermalink: (e, t) => {
						let {
							commentId: n
						} = t;
						return n && Object(U.m)(e, {
							commentId: n
						})
					},
					commentSearchPdp: e => Object(K.a)(e),
					contestModeModalIsOpen: Object(B.b)("CommentSort--ContestMode--Modal"),
					dropdownIsOpen: Object(H.b)($),
					highlightIsOpen: Object(H.b)(ee),
					hasModeratorPostPermissions: (e, t) => {
						let {
							postId: n
						} = t;
						const o = Object(W.m)(e, {
							postId: n
						});
						return !!o && o.posts
					},
					post: G.F,
					postPermalink: G.E,
					showCommentHighlighter: (e, t) => {
						let {
							postId: n
						} = t;
						const o = Object(V.x)(e),
							r = !!Object(W.m)(e, {
								postId: n
							}),
							s = Object(G.F)(e, {
								postId: n
							});
						return (r || o) && !!s && !!s.previousVisits && s.previousVisits.length > 0
					},
					selectedHighlightSort: U.p
				}),
				se = Object(i.b)(re, (e, t) => {
					let {
						postId: n
					} = t;
					return {
						changeHighlightSort: t => e(Object(u.b)({
							sort: t
						})),
						onOpenDropdown: () => e(Object(l.h)({
							tooltipId: $
						})),
						onOpenHighlightDropdown: t => {
							e(Object(l.h)({
								tooltipId: ee
							})), t()
						},
						onSetSuggestedSort: t => e(C(n, t)),
						hideTooltip: () => e(Object(l.i)()),
						setContestMode: t => e(Object(p.V)(t, n)),
						showTooltip: () => e(Object(l.h)({
							tooltipId: te
						})),
						toggleContestModeModal: () => e(Object(m.i)("CommentSort--ContestMode--Modal"))
					}
				});
			class ie extends s.a.Component {
				constructor() {
					super(...arguments), this.tooltipTargetElement = null, this.sendCommentSortEvent = (e, t, n, o) => this.props.sendEvent(R(e, this.props.isOverlay, t, n, o)), this.onOpenDropdownClick = () => {
						this.props.onOpenDropdown(), this.sendCommentSortEvent("sorting", void 0, this.props.sort, "post_detail")
					}, this.onSortOptionClick = e => this.sendCommentSortEvent("sort_by", this.props.sort, e, "post_detail"), this.clearSortOnClick = () => {
						this.props.onSetSuggestedSort(null), this.sendCommentSortEvent("clear_suggested_sort", this.props.sort)
					}, this.setSortOnClick = () => {
						const e = this.props.suggestedSort || void 0;
						this.props.onSetSuggestedSort(this.props.sort), this.sendCommentSortEvent("set_suggested_sort", e, this.props.sort)
					}, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onOpenHighlightSelector = () => {
						this.props.onOpenHighlightDropdown(M("dropdown", "click"))
					}, this.setContestMode = () => {
						this.props.sendEvent(L(!this.props.post.contestMode)), this.props.setContestMode(!this.props.post.contestMode)
					}
				}
				addSuggestedLabel(e) {
					return o.fbt._("{sort name} (suggested)", [o.fbt._param("sort name", e)], {
						hk: "3pDfQ9"
					})
				}
				render() {
					var e;
					const {
						changeHighlightSort: t,
						className: n,
						commentId: r,
						commentPermalink: i,
						commentSearchPdp: a,
						contestModeModalIsOpen: l,
						dropdownIsOpen: u,
						elementRef: m,
						hideTooltip: p,
						highlightIsOpen: h,
						hasModeratorPostPermissions: b,
						isOverlay: f,
						location: g,
						pageLayer: v,
						post: C,
						postPermalink: O,
						selectedHighlightSort: k,
						showCommentHighlighter: j,
						sort: S,
						suggestedSort: N,
						showTooltip: R,
						toggleContestModeModal: D
					} = this.props, L = C.contestMode, B = null == r, U = a.bucketed && Object(_.a)(v) && Object(_.b)(C), K = a.bucketed && Object(_.b)(C) && B, W = !(null === (e = g.search) || void 0 === e ? void 0 : e.includes(d.v.CONFIDENCE)), G = S === d.v.CONFIDENCE && W, H = b && !G, V = d.x[S], z = V ? V() : "", Q = N && S === N && !G ? this.addSuggestedLabel(z) : z, Y = L ? o.fbt._("End contest mode?", null, {
						hk: "2AkJRZ"
					}) : o.fbt._("Start contest?", null, {
						hk: "2PQPOu"
					}), J = L ? o.fbt._("End", null, {
						hk: "1Q8KqM"
					}) : o.fbt._("Start", null, {
						hk: "Mjvpj"
					}), X = L ? o.fbt._("Ending contest mode will make comment vote scores visible and disable random comment ordering.", null, {
						hk: "3PXrGq"
					}) : o.fbt._("Starting a contest will hide comment vote scores and randomize the order of the comments for non-mods.", null, {
						hk: "EDqlf"
					}), oe = L && !b, re = s.a.createElement(s.a.Fragment, null, s.a.createElement("div", {
						className: q.a.DropdownContainer
					}, s.a.createElement(T.b, {
						className: Object(c.a)(q.a.SortPicker, q.a.Row),
						textClassName: q.a.SortOptionDropdownText,
						displayText: `${o.fbt._("Sort by",null,{hk:"E6T9r"})}: ${Q}`,
						id: $,
						noHover: !0,
						skipRoleAttr: !0,
						onClick: this.onOpenDropdownClick
					}), s.a.createElement(A.b, {
						className: q.a.DropdownTriangle,
						onClick: this.onOpenDropdownClick
					})), s.a.createElement(ne, {
						isOpen: u,
						tooltipId: $
					}, [d.v.CONFIDENCE, d.v.TOP, d.v.NEW, d.v.CONTROVERSIAL, d.v.OLD, d.v.QA].map(e => {
						const t = i || O,
							n = Object(P.b)(t),
							o = d.x[e],
							r = o ? o() : "";
						return s.a.createElement(x.a, {
							className: q.a.ViewFullLinkOrOverlayLink,
							isOverlay: f,
							key: e,
							onClick: () => this.onSortOptionClick(e),
							role: "menuitem",
							tabIndex: -1,
							to: `${n}?sort=${e}`
						}, s.a.createElement(T.b, {
							displayText: r,
							isSelected: S === e,
							skipRoleAttr: !0
						}))
					})));
					return s.a.createElement("div", {
						className: Object(c.a)(n, q.a.container, {
							[q.a.hideCommentSort]: !j && oe,
							[q.a.paddingBottom]: U
						}),
						ref: m
					}, s.a.createElement(s.a.Fragment, null, s.a.createElement("div", {
						className: q.a.containerRow
					}, !oe && !U && re, H && !oe && !U && (N ? s.a.createElement("button", {
						className: q.a.SortLink,
						onClick: S !== N ? this.setSortOnClick : this.clearSortOnClick
					}, S !== N ? o.fbt._("Set new suggested sort", null, {
						hk: "13BpoB"
					}) : o.fbt._("Clear suggested sort", null, {
						hk: "3WWQBy"
					})) : s.a.createElement("button", {
						className: q.a.SetSort
					}, s.a.createElement("button", {
						className: q.a.SortLink,
						onClick: this.setSortOnClick
					}, o.fbt._("Set as suggested sort", null, {
						hk: "3qLzxp"
					})), s.a.createElement("span", {
						id: te,
						onMouseEnter: R,
						onMouseLeave: p
					}, s.a.createElement(E.c, {
						className: q.a.Tooltip,
						text: o.fbt._("Suggested sort defaults Redditors to a specific way of sorting comments within this post", null, {
							hk: "3KM0ma"
						}),
						tooltipId: te
					}), s.a.createElement(F.a, {
						className: q.a.Info
					})))), b && s.a.createElement("button", {
						className: Object(c.a)(q.a.ContestMode, U && q.a.commentSearchMargin),
						onClick: this.props.toggleContestModeModal
					}, o.fbt._("Contest", null, {
						hk: "1KrhdJ"
					}), s.a.createElement(I.a, {
						className: q.a.ToggleSwitch,
						on: L
					})), U || K ? s.a.createElement("div", {
						className: q.a.containerRow
					}, !U && s.a.createElement(s.a.Fragment, null, s.a.createElement("span", {
						className: q.a.verticalDivider
					}, "|")), s.a.createElement("div", null, s.a.createElement(w.c, {
						experiment: a,
						commentId: r,
						prevLocation: g,
						postId: this.props.postId
					}))) : null), j && s.a.createElement("div", {
						className: q.a.containerRow
					}, s.a.createElement(Z, {
						changeHighlightSort: t,
						highlightIsOpen: h,
						id: ee,
						onOpen: this.onOpenHighlightSelector,
						selectedSort: k,
						trackHighlight: M
					})), l && s.a.createElement(y.a, {
						actionText: J,
						headerText: Y,
						modalText: X,
						onConfirm: this.setContestMode,
						toggleModal: D,
						withOverlay: !0
					})))
				}
			}
			t.b = oe(se(Object(k.c)(ie)))
		},
		"./src/reddit/components/ConfirmUserActionModal/index.m.less": function(e, t, n) {
			e.exports = {
				buttonWidth: "ogOEj4x-0BpDZWeccJwxx",
				ModalText: "_2YxEi97B6Nm7NCgLG6pCud",
				modalText: "_2YxEi97B6Nm7NCgLG6pCud"
			}
		},
		"./src/reddit/components/ConfirmUserActionModal/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./src/higherOrderComponents/asModal/index.tsx"),
				a = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				c = n("./src/reddit/controls/TextButton/index.tsx"),
				d = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				l = n("./src/reddit/components/ConfirmUserActionModal/index.m.less"),
				u = n.n(l);
			const m = e => e.preventDefault();
			t.a = Object(i.a)(e => s.a.createElement(a.e, null, s.a.createElement(a.i, null, s.a.createElement(d.a, null, s.a.createElement(a.q, null, e.headerText || o.fbt._("Confirm", null, {
				hk: "2zlvKa"
			})), s.a.createElement(c.a, {
				onClick: t => {
					e.onClose && e.onClose(t), e.toggleModal && e.toggleModal()
				}
			}, s.a.createElement(a.b, null)))), s.a.createElement(a.l, null, s.a.createElement(a.p, {
				className: u.a.ModalText
			}, e.modalText)), s.a.createElement(a.g, null, !e.hideCancelButton && s.a.createElement(a.a, {
				className: u.a.buttonWidth,
				onMouseDown: m,
				onClick: () => {
					e.onCancel && e.onCancel(), e.toggleModal && e.toggleModal()
				},
				"data-redditstyle": !e.disableRedditStyle
			}, e.cancelActionText || o.fbt._("Cancel", null, {
				hk: "2TSLl5"
			})), s.a.createElement(a.u, {
				className: u.a.buttonWidth,
				onMouseDown: m,
				onClick: t => {
					e.onConfirm(t), e.toggleModal && e.toggleModal(), e.trackClick && e.trackClick()
				},
				"data-redditstyle": !e.disableRedditStyle,
				disabled: e.isDisabled
			}, e.actionText))))
		},
		"./src/reddit/components/ContentTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				StyledTooltipContainer: "_2uSuNRa3OeptFDJCKQ3vU6",
				styledTooltipContainer: "_2uSuNRa3OeptFDJCKQ3vU6",
				fadeIn: "_2bkYZH_kJx5pIHW0Ts5P6e",
				caretOnBottom: "_1rF-A55THyDL-rQ9ZUDQ4_",
				caretOnTop: "_1MHCyMQAMeqRqf5DPWWeq3",
				hideCaret: "dExJJiXRwxVrKsDJRWSQl",
				caretOnLeft: "nVD-oexLbZI_4QjhrkLFz",
				caretOnRight: "KRVDnoE1RIC5qyqQLXxGG"
			}
		},
		"./src/reddit/components/ContentTooltip/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./src/higherOrderComponents/addOverlayEvents.tsx"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				l = n("./src/lib/fastdom/index.ts"),
				u = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				m = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				p = n("./src/reddit/selectors/tooltip.ts"),
				h = n("./src/reddit/components/ContentTooltip/index.m.less"),
				b = n.n(h);

			function f() {
				return (f = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const g = {
					height: 200,
					width: 200
				},
				v = e => {
					switch (e) {
						case "top":
							return "bottom";
						case "right":
							return "left";
						case "left":
							return "right";
						case "bottom":
						default:
							return "top"
					}
				},
				C = Object(d.a)(e => {
					const {
						children: t,
						className: n,
						style: o,
						caretPosition: r,
						caretColor: i,
						onClick: a,
						hideCaret: d
					} = e;
					return s.a.createElement("div", {
						onClick: a,
						className: Object(c.a)(n, b.a.StyledTooltipContainer, {
							[b.a.caretOnTop]: "top" === r,
							[b.a.caretOnLeft]: "left" === r,
							[b.a.caretOnRight]: "right" === r,
							[b.a.caretOnBottom]: "bottom" === r,
							[b.a.hideCaret]: d
						}),
						style: {
							...o,
							"--contentTooltip-caretColor": i && i[r] ? i[r] : Object(m.a)(e).body
						}
					}, t)
				}),
				y = Object(a.c)({
					isOpen: (e, t) => {
						let {
							tooltipId: n
						} = t;
						return Object(p.b)(n)(e)
					}
				}),
				E = Object(u.a)(C, [o.a.Click, o.a.Keydown]),
				x = Object(i.b)(y);
			class O extends s.a.Component {
				constructor(e) {
					super(e), this.checkAndSetPosition = () => {
						const {
							tooltipId: e,
							tooltipSizeEstimate: t = g
						} = this.props;
						l.a.read(() => {
							const n = document.getElementById(e);
							if (!n) return;
							const o = n.getBoundingClientRect();
							if (!("undefined" != typeof window)) return void this.setState({
								position: this.props.defaultTooltipPosition
							});
							let r = !0;
							switch (this.props.defaultTooltipPosition) {
								case "bottom":
									r = window.innerHeight - o.bottom > t.height;
									break;
								case "left":
									r = o.left > t.width;
									break;
								case "right":
									r = o.right <= window.innerWidth - t.width;
									break;
								case "top":
								default:
									r = o.top > t.height
							}
							this.setState({
								position: r ? this.props.defaultTooltipPosition : v(this.props.defaultTooltipPosition)
							})
						})
					}, this.state = {
						position: null
					}
				}
				componentDidUpdate(e) {
					!e.isOpen && this.props.isOpen && this.checkAndSetPosition(), e.isOpen && !this.props.isOpen && this.setState({
						position: null
					})
				}
				getPositions(e) {
					switch (e || this.props.defaultTooltipPosition) {
						case "bottom":
							return {
								tooltipPosition: ["center", "top"], targetPosition: ["center", "bottom"], caretPosition: "top"
							};
						case "left":
							return {
								tooltipPosition: ["right", "center"], targetPosition: ["left", "center"], caretPosition: "right"
							};
						case "right":
							return {
								tooltipPosition: ["left", "center"], targetPosition: ["right", "center"], caretPosition: "left"
							};
						case "top":
						default:
							return {
								tooltipPosition: ["center", "bottom"], targetPosition: ["center", "top"], caretPosition: "bottom"
							}
					}
				}
				render() {
					const {
						position: e
					} = this.state, {
						targetPosition: t,
						tooltipPosition: n,
						caretPosition: o
					} = this.getPositions(e);
					return s.a.createElement(E, f({}, this.props, {
						caretPosition: o,
						targetPosition: t,
						tooltipPosition: n
					}))
				}
			}
			t.a = x(O)
		},
		"./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/index.m.less": function(e, t, n) {
			e.exports = {
				RequestButton: "_3K2ydhts9_ES4s9UpcXqBi",
				requestButton: "_3K2ydhts9_ES4s9UpcXqBi"
			}
		},
		"./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/components/TrackingHelper/index.tsx"),
				l = n("./src/reddit/constants/modals.ts"),
				u = n("./src/reddit/controls/Button/index.tsx"),
				m = n("./src/reddit/helpers/trackers/privateCommunity.ts"),
				p = n("./src/reddit/helpers/trackers/restrictedCommunity.ts"),
				h = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				b = n("./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/index.m.less"),
				f = n.n(b);
			const g = () => ({
				[h.b.Comment]: o.fbt._("Request to Comment", null, {
					hk: "3KRhw5"
				}),
				[h.b.IdCard]: o.fbt._("Request to Post", null, {
					hk: "2xsrGd"
				}),
				[h.b.PostSubmission]: o.fbt._("Request to Post", null, {
					hk: "2xsrGd"
				}),
				[h.b.ContentGate]: o.fbt._("Request to Join", null, {
					hk: "1nK8Vv"
				})
			});
			class v extends s.a.Component {
				constructor() {
					super(...arguments), this.onRequest = () => {
						const {
							sendEvent: e,
							eventSource: t,
							openRequestToJoinSubredditModal: n,
							openContributorRequestModal: o
						} = this.props;
						t === h.b.ContentGate ? (e(Object(m.a)(t)), n()) : (e(Object(p.a)(t)), o())
					}
				}
				render() {
					const {
						eventSource: e,
						smallButton: t,
						className: n,
						isContributorRequestPending: r
					} = this.props;
					return s.a.createElement(u.t, {
						priority: e === h.b.ContentGate ? u.c.Secondary : u.c.Primary,
						className: Object(a.a)(t ? null : f.a.RequestButton, n),
						onClick: this.onRequest,
						size: t ? u.d.S : u.d.M,
						disabled: r
					}, r ? o.fbt._("Request Pending", null, {
						hk: "hVswi"
					}) : g()[e])
				}
			}
			t.default = Object(i.b)(null, e => ({
				openContributorRequestModal: () => e(Object(c.i)(l.a.CONTRIBUTOR_REQUEST)),
				openRequestToJoinSubredditModal: () => e(Object(c.i)(l.a.CONTRIBUTOR_REQUEST_PRIVATE_SUREDDIT))
			}))(Object(d.c)(v))
		},
		"./src/reddit/components/CrosspostBox/index.m.less": function(e, t, n) {
			e.exports = {
				mediaContainer: "P8p9Nku0-ZbYCsaCOSE2t",
				Container: "_2ED-O3JtIcOqp8iIL1G5cg",
				container: "_2ED-O3JtIcOqp8iIL1G5cg",
				PostMetaWrapper: "_1u_4ufj_H3WJW2TXEZ6a3n",
				postMetaWrapper: "_1u_4ufj_H3WJW2TXEZ6a3n",
				PostTitle: "_2akYJO5RtMK_ptA408seyG",
				postTitle: "_2akYJO5RtMK_ptA408seyG",
				FlatList: "_3Dd3XvAr-WcOJyMTx4y35x",
				flatList: "_3Dd3XvAr-WcOJyMTx4y35x",
				FlatItem: "_2Pkdj4FrQFtK8COeODi_kK",
				flatItem: "_2Pkdj4FrQFtK8COeODi_kK",
				FlatListDotSpacer: "_3w73P89exX_1mpdhQCURo6",
				flatListDotSpacer: "_3w73P89exX_1mpdhQCURo6",
				LinkContainer: "CsZ0mP84ULF0bBJJa0PFy",
				linkContainer: "CsZ0mP84ULF0bBJJa0PFy",
				Content: "_379A_08LTBsR4c8POTldR_",
				content: "_379A_08LTBsR4c8POTldR_",
				ThumbnailContainer: "_7bo--rwqP4Z7K1s_8dGPX",
				thumbnailContainer: "_7bo--rwqP4Z7K1s_8dGPX"
			}
		},
		"./src/reddit/components/CrosspostBox/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return _
			})), n.d(t, "a", (function() {
				return k
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				c = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				l = n("./src/lib/prettyPrintNumber/index.ts"),
				u = n("./src/reddit/components/Media/index.tsx"),
				m = n("./src/reddit/components/PostMeta/index.tsx"),
				p = n("./src/reddit/components/PostTitle/index.tsx"),
				h = n("./src/reddit/components/SourceLink/index.tsx"),
				b = n("./src/reddit/components/Thumbnail/index.tsx"),
				f = n("./src/lib/constants/index.ts"),
				g = n("./src/reddit/contexts/Post/index.tsx"),
				v = n("./src/reddit/selectors/posts.ts"),
				C = n("./src/reddit/selectors/user.ts"),
				y = n("./src/reddit/components/CrosspostBox/index.m.less"),
				E = n.n(y),
				x = n("./src/lib/lessComponent.tsx");

			function O() {
				return (O = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const _ = 8,
				k = 1,
				j = x.a.div("Container", E.a),
				S = x.a.div("PostMetaWrapper", E.a),
				T = x.a.wrapped(p.c, "PostTitle", E.a),
				w = x.a.div("FlatList", E.a),
				I = x.a.div("FlatItem", E.a),
				P = x.a.span("FlatListDotSpacer", E.a),
				N = x.a.wrapped(j, "LinkContainer", E.a),
				R = x.a.div("Content", E.a),
				M = x.a.div("ThumbnailContainer", E.a),
				D = Object(c.c)({
					isCurrentUserProfilePost: v.l,
					isTopicPage: e => !(!e.platform.currentPage || !e.platform.currentPage.meta || e.platform.currentPage.meta.name !== f.Tb.TOPIC),
					shouldOpenPostInNewTab: C.lb
				}),
				L = Object(i.b)(D);
			t.c = Object(g.b)(L(e => {
				const {
					className: t,
					isCurrentUserProfilePost: n,
					isTopicPage: o,
					mediaProps: r,
					post: i,
					subredditOrProfile: a
				} = e;
				if (!i) return null;
				const c = {
						post: i,
						hideGildCta: !0,
						inSubredditOrProfile: !1,
						isCurrentUserProfilePost: n,
						isTopicPage: o,
						shouldShowSubscribeButton: !1,
						subredditOrProfile: a,
						tooltipType: `CrosspostBox--${r.isListing}`
					},
					d = t;
				return i && !i.media ? s.a.createElement(N, {
					className: d
				}, s.a.createElement(R, null, s.a.createElement(S, null, s.a.createElement(m.a, c)), A(i), i.source && s.a.createElement(h.a, {
					post: i
				}), B(e)), K(e)) : s.a.createElement(j, {
					className: d
				}, s.a.createElement(S, null, s.a.createElement(m.a, c)), A(i), F(e), B(e))
			}));
			const A = e => s.a.createElement(T, {
					isCrosspost: !0,
					post: e,
					shouldLinkWrap: !0,
					size: p.b.Small
				}),
				F = e => {
					const {
						mediaProps: t,
						post: n
					} = e, o = {
						...t,
						post: n,
						crosspost: t.post
					};
					return s.a.createElement("div", null, s.a.createElement(u.a, O({}, o, {
						className: E.a.mediaContainer,
						scrollerItemRef: t.scrollerItemRef
					})))
				},
				B = e => {
					const {
						post: t
					} = e, {
						score: n
					} = t;
					return s.a.createElement(w, null, s.a.createElement(I, null, o.fbt._({
						"*": "{point count} points",
						_1: "1 point"
					}, [o.fbt._plural(n, "point count", Object(l.b)(n))], {
						hk: "PNZhd"
					})), s.a.createElement(P, null), s.a.createElement(I, null, U(e)))
				},
				U = e => {
					const {
						post: t,
						shouldOpenPostInNewTab: n
					} = e, {
						numComments: r
					} = t;
					return s.a.createElement(a.a, {
						"data-click-id": "comments",
						to: Object(d.a)(t.permalink, !0),
						target: n ? "_blank" : void 0
					}, o.fbt._({
						"*": "{comment count} comments",
						_1: "1 comment"
					}, [o.fbt._plural(r, "comment count", Object(l.b)(r))], {
						hk: "xPYWL"
					}))
				},
				K = e => s.a.createElement(M, null, s.a.createElement(b.b, {
					post: e.post
				}))
		},
		"./src/reddit/components/Econ/Prediction/PredictionEducationMessage/EducationMessage/constants.ts": function(e, t, n) {
			"use strict";
			var o;
			n.d(t, "a", (function() {
					return o
				})),
				function(e) {
					e.nonDismissable = "predictionEducationNonDismissable", e.creation = "predictionEducationCreation", e.feature = "predictionEducationFeature"
				}(o || (o = {}))
		},
		"./src/reddit/components/Econ/Prediction/PredictionEducationMessage/EducationMessage/index.m.less": function(e, t, n) {
			e.exports = {
				educationMessage: "_3fy4maW8GQWdzcWGdeMbsa",
				isShortWidth: "_28YkWXOPICkzcS5IobwdZx",
				titleRow: "_1OeK7ZGX2fnKzdqjn-5gQD",
				header: "_1Y7_NWRItnxdsOq9DSlCDi",
				title: "_2ZZDhQ9qffZd-pGxZE6R4I",
				newBadge: "_1cHmK8KSQMLT0mELC910oM",
				closeButton: "_1C2XLQWgnLb_MVlB0fwAc_"
			}
		},
		"./src/reddit/components/Econ/Prediction/PredictionEducationMessage/EducationMessage/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/hooks/useLocalStorage.ts"),
				a = n("./src/reddit/controls/Button/index.tsx"),
				c = n("./src/reddit/icons/fonts/index.tsx"),
				d = n("./src/reddit/components/Econ/Prediction/PredictionEducationMessage/EducationMessage/constants.ts"),
				l = n("./src/reddit/components/Econ/Prediction/PredictionEducationMessage/EducationMessage/index.m.less"),
				u = n.n(l);
			const {
				fbt: m
			} = n("./node_modules/fbt/lib/FbtPublic.js");

			function p(e) {
				let {
					message: t,
					newBadge: n,
					onClose: l,
					onView: p,
					storageKey: h = d.a.nonDismissable,
					title: b,
					isFullWidth: f
				} = e;
				const g = h !== d.a.nonDismissable,
					[v, C] = Object(i.a)(h, !g || !1),
					[y, E] = Object(o.useState)(!1);
				return Object(o.useEffect)(() => {
					v || y || !p || (p(), E(!0))
				}, [v, y, p]), g && v ? null : r.a.createElement("div", {
					className: Object(s.a)(u.a.educationMessage, {
						[u.a.isShortWidth]: !f
					})
				}, r.a.createElement("div", {
					className: u.a.titleRow
				}, r.a.createElement("div", {
					className: u.a.header
				}, r.a.createElement("h3", {
					className: u.a.title
				}, b), n && r.a.createElement("div", {
					className: u.a.newBadge
				}, m._("New", null, {
					hk: "2N0EBb"
				}))), g && r.a.createElement(a.t, {
					"aria-label": m._("Close", null, {
						hk: "2UjnU"
					}),
					className: u.a.closeButton,
					Icon: Object(c.b)("close"),
					onClick: () => {
						C(!0), l && l()
					},
					priority: a.c.Plain
				})), t)
			}
		},
		"./src/reddit/components/Econ/Prediction/TournamentTokenIcon/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/components/Econ/Prediction/UnicornIcon/index.tsx"),
				c = n("./src/reddit/selectors/features/predictions/tournaments/index.ts");
			const d = e => {
				let {
					tournamentId: t,
					className: n
				} = e;
				const r = Object(i.e)(e => Object(c.a)(e, t));
				return r && r.tokenIconUrl ? s.a.createElement("img", {
					className: n,
					alt: o.fbt._("Tournament token", null, {
						hk: "3cgDZy"
					}),
					src: r.tokenIconUrl
				}) : s.a.createElement(a.a, {
					className: n
				})
			}
		},
		"./src/reddit/components/Econ/Prediction/UnicornIcon/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/selectors/experiments/econ/index.ts");
			const a = e => {
					let {
						className: t
					} = e;
					return r.a.createElement("svg", {
						className: t,
						fill: "none",
						height: "20",
						viewBox: "0 0 20 20",
						width: "20",
						xmlns: "http://www.w3.org/2000/svg"
					}, r.a.createElement("path", {
						d: "m11.8373 7.17254c-.0381-2.14805-1.2066-4.26563-3.12608-5.6611-.7001 1.14224-1.0571 2.46166-1.02847 3.80108.02863 1.33941.44168 2.64237 1.18995 3.75365",
						fill: "#ffc2dd"
					}), r.a.createElement("path", {
						d: "m8.87285 9.06578c-.03047.01981-.17672-.13254-.39609-.43722-.29757-.44864-.53424-.93481-.70383-1.44575-.25319-.76597-.37124-1.57014-.34887-2.37656.0185-.47751.08381-.95205.195-1.4168.12075-.49951.29704-.98393.52559-1.44421.04547-.10166.09632-.20083.15234-.29708l.16453-.28792c.0182-.03202.04253-.06014.07159-.08276.02907-.02261.06231-.03928.09782-.04904s.0726-.01243.10914-.00785c.03655.00458.07183.01631.10384.03453l.02742.01828c.38016.28079.73681.5921 1.0664.93082.30177.31806.57737.65991.82417 1.02223.4117.60733.7253 1.27566.9293 1.98046.1388.46809.2126.95301.2194 1.44118 0 .34277-.0396.52863-.0731.52863-.0336 0-.0762-.18281-.1402-.50731-.0876-.45579-.214-.90328-.3778-1.33757-.2445-.64356-.5745-1.25128-.9811-1.8068-.2427-.32728-.50846-.63681-.79524-.92625-.31294-.30838-.64797-.59352-1.00242-.85313l.41742-.08226-.15234.2666c-.05268.08874-.10048.18028-.1432.27422-.20887.42313-.37327.8668-.49055 1.32387-.10969.42749-.18107.8639-.21328 1.30406-.04198.75145.02993 1.50493.21328 2.23488.31535 1.25684.78762 1.94696.70078 1.99875z",
						fill: "#000"
					}), r.a.createElement("path", {
						d: "m15.6001 5.87727c-.8963-.80295-1.9238-1.44605-3.0378-1.90125-.8516-.34734-1.7854-.585-2.69037-.41742-1.00242.18586-1.84945.84246-2.58984 1.55086-.89883.86988-1.70321 1.87383-2.14196 3.04687-.34277.91407-.45703 1.93177-1.02984 2.72697-.44789.6292-1.12582 1.0481-1.73672 1.5234s-1.19894 1.0664-1.32691 1.8281c-.134064.7983.2666 1.5905.76172 2.2349.43629.6039.99546 1.1085 1.64074 1.4808.65104.3698 1.41006.5028 2.14805.3763 1.28273-.2544 2.18918-1.3711 3.33937-2.0018.91406-.4966 1.98046-.6657 2.93876-1.0664 1.7105-.7343 3.0622-2.1139 3.7613-3.8391.6813-1.72672.7474-3.63533.1874-5.40512",
						fill: "#ffc2dd"
					}), r.a.createElement("path", {
						d: "m11.9928 5.88635c-.9902.47227-2.10078.77238-3.13214.36105-.44942-.17824-.91407-.48597-.99633-.96281-.08836-.53777.35648-1.01156.81047-1.31472 1.4823-.98567 3.3333-1.06641 5.0669-.66422 1.7337.40218 3.2663 2.19375 3.4842 3.95941 1.1699.23309 1.6178 1.90582 1.4396 3.08494-.0975.649-.4647 1.2416-.5027 1.8967-.0595 1.042.7175 1.9591.8302 2.9966.0424.4433-.0361.8899-.2271 1.2922-.1909.4024-.4873.7455-.8576.993-.7449.4829-2.1998.8653-2.9661.4174-.5408.5408-1.0664.8531-1.953.5621-.4365-.1597-.8123-.4516-1.075-.835s-.3992-.8392-.3906-1.3039c.0251-.4645.1826-.9122.4539-1.2901.2713-.378.645-.6704 1.0772-.8427-.118-.6928-.0689-1.4038.143-2.0739.212-.6701.5808-1.2799 1.0757-1.7789.4357-.4311.6475-1.2568.8623-1.82809.3184-.84551.0792-1.3589-.7115-1.79461-.7906-.4357-.6322-.91406-1.5356-.93234",
						fill: "#7e53c1"
					}), r.a.createElement("path", {
						d: "m2.93455 11.5232c-.76172.5652-1.73063 2.1861-1.73063 2.1861-.335154.9887-.09293 2.174.67184 2.8839.30469.2803.66879.4814.97347.7617.24375.2209.4479.489.72973.6581.29688.1598.6324.2336.96891.2133 1.02679-.0183 1.96523-.5515 2.83207-1.1014.52711-.3337.74496-.3748 1.08469-.8973.33972-.5226.44179-1.2508.08074-1.7596-.10551-.1489-.24341-.2718-.40332-.3597s-.33766-.1383-.51989-.1476c.14706-.1759.25646-.3801.32145-.5999.06499-.2199.08417-.4507.05637-.6783-.03221-.2274-.1238-.4424-.26556-.6232-.14175-.1808-.32865-.321-.54187-.4066-.21517-.0769-.44922-.0833-.66831-.0184s-.41185.1978-.55044.3795c-.12035-.4571-.26812-.9415-.66117-1.1929-.39304-.2514-.95672-.1706-1.36043.0899s-.73429.2133-1.01156.6094",
						fill: "#ff85c6"
					}), r.a.createElement("g", {
						fill: "#000"
					}, r.a.createElement("path", {
						d: "m12.0369 5.96144c.0076.01828-.0975.08074-.3047.18129-.1051.04875-.2422.09598-.4022.15234-.1874.06167-.3781.11253-.5713.15235l-.1691.03351-.1813.01524-.1904.02133-.2011.00761c-.29982.01193-.59992-.01521-.89273-.08074-.34868-.0711-.67773-.21717-.96434-.42809-.33198-.24583-.57949-.58862-.7084-.98109-.00992-.03112-.01206-.0642-.00622-.09634.00585-.03215.01949-.06236.03974-.088l.18129-.22699.09293-.11578c.03351-.03656.06855-.0716.10359-.10816l.21176-.21633.23613-.20109c.33521-.27221.70445-.49959 1.0984-.67641.86515-.37673 1.79855-.5717 2.74215-.57281.2458 0 .4946.00761.7465.02285.1249.01066.2514.02437.3778.03656l.3885.06703c.5231.11861 1.0247.31749 1.4869.58957.4807.27702.916.62643 1.2903 1.03594.3946.42526.6993.9258.8958 1.47164.1606.44653.2128.92481.1524 1.39547l-.2225-.32449c.3024.07237.582.21897.8136.42656.2182.19639.3962.43337.524.69773.2368.4925.3602 1.03182.3611 1.57828.0036.26324-.0198.52618-.0701.78458-.0515.2498-.1265.4941-.224.7297-.1751.4479-.3458.8471-.3351 1.231.0236.4021.1338.7945.323 1.1502.1736.3762.3762.748.5149 1.1486.0732.1995.1243.4064.1523.617.025.2054.025.4131 0 .6185-.049.3813-.1783.7479-.3793 1.0756-.1803.2992-.4198.5584-.7038.7617-.2515.1695-.5267.3009-.8166.39-.4515.1462-.9263.2072-1.4.1798-.2998-.0157-.5927-.0952-.8593-.2331-.0441-.0259-.0837-.0472-.1142-.0701l-.0747-.064c-.0381-.035-.0548-.0564-.0487-.064s.0335 0 .0792.0168l.0838.0366c.0335.0137.0746.0259.1203.0426.265.0859.5427.1261.8212.1188.4422-.0126.879-.1002 1.2919-.2589.253-.0934.4915-.2222.7083-.3824.2336-.1832.4283-.4111.5729-.6703.1596-.2843.2582-.5987.2894-.9232.0316-.3501-.0206-.7025-.1523-1.0284-.131-.3519-.3321-.7038-.5256-1.0953-.2303-.4174-.366-.8802-.3976-1.3559-.0049-.2555.0316-.5102.1081-.7541.0701-.2376.1524-.457.2407-.6779.083-.2069.1462-.4211.1889-.6399.0401-.2216.0575-.44666.0518-.67179-.0025-.45984-.1065-.91345-.3046-1.32843-.089-.19841-.2208-.37466-.386-.5161-.1651-.14144-.3595-.24457-.5692-.30199-.0707-.01706-.1324-.05965-.1735-.11957s-.0585-.13291-.049-.20492c.0449-.37936.0001-.76396-.131-1.12278-.1711-.47191-.4347-.90491-.7754-1.27359-.3334-.36724-.7207-.68161-1.1487-.93234-.4116-.24365-.858-.42295-1.3238-.53168l-.3504-.06704-.352-.0396c-.2346-.0193-.4671-.02946-.6977-.03047-.8711-.0115-1.7356.15167-2.5426.47988-.69944.29292-1.31358.75772-1.78547 1.35129l.03199-.18738c.09268.31809.28096.59997.5393.80742.23935.19093.5167.32857.81351.40371.26464.07357.53739.114.81197.12035h.1874l.1798-.00762.1721-.00761.163-.01981c.2118-.01828.3976-.06246.5607-.08988.163-.02742.3046-.06856.4082-.0975.2194-.05942.3398-.08379.3474-.06551z"
					}), r.a.createElement("path", {
						d: "m15.1617 6.80064c.032-.01066.16.18738.2529.60938.0533.25693.0661.52062.0381.78152-.0428.34276-.1325.678-.2666.99633-.159.38683-.3724.749-.6338 1.07553-.2727.3504-.5713.684-.8318 1.0664-.1345.1968-.2591.4001-.3732.6094-.1109.2057-.1964.4241-.2544.6505-.126.4741-.116.9741.0289 1.4427l.0549.1523.0655.1524v.0107c.0153.035.0235.0728.0241.1111s-.0063.0763-.0205.1118c-.0142.0356-.0352.068-.062.0954-.0268.0273-.0587.0491-.094.064l-.0228.0092c-.4112.1591-.7588.4486-.9897.8242s-.3322.8166-.2885 1.2553c.0443.3877.1928.7562.4296 1.0664.21.2635.5015.4499.8288.5301.0736.0194.1484.0342.2239.0442.0792.0102.1564.0183.2316.0244.1384.0097.2774.0097.4159 0 .2139-.0066.4231-.0652.6093-.1706.3047-.1874.4007-.3977.4434-.3702.0167.0076.0091.0655-.029.166-.0649.1473-.1623.2781-.2849.3824-.2014.1636-.4437.2689-.7007.3047-.1541.0256-.31.0389-.4662.0396-.0823 0-.1656 0-.2499 0-.0935-.0045-.1866-.0152-.2787-.032-.4244-.0768-.8101-.2954-1.0939-.62-.3157-.3695-.521-.8204-.5926-1.3011-.0783-.5443.0291-1.0992.3047-1.5752.2866-.522.7517-.9233 1.3101-1.1304l-.1645.4022-.0838-.1858c-.0228-.064-.0487-.1265-.0701-.192-.1795-.573-.1895-1.1856-.0289-1.7641.0739-.272.1819-.5336.3215-.7785.1288-.2228.2697-.4385.4219-.646.2956-.4067.6231-.7464.8943-1.06636.2517-.28403.4648-.60009.6337-.93996.1414-.27918.2488-.57429.32-.87903.0485-.23077.0679-.4667.0579-.7023-.0198-.38695-.0732-.6109-.0305-.62461z"
					}), r.a.createElement("path", {
						d: "m11.7475 15.5359c.0397.0198-.0121.1751-.0487.457-.0497.3816-.0079.7696.1219 1.1319.0832.2572.2266.4908.4181.6816.1916.1907.4258.3331.6833.4153.2964.1041.6157.1251.9232.0609.3275-.0754.6263-.2436.8608-.4844.0439-.0439.1008-.0725.1623-.0816.0614-.009.1242.0019.1789.0313l.0229.0122.131.0716c.3301.1294.6855.1815 1.039.1523.3483-.0224.6927-.0874 1.0252-.1935.2948-.0892.572-.2283.8196-.4113.2096-.1663.3885-.3678.5287-.5957.2115-.3484.3397-.741.3747-1.1471.0275-.2879.0153-.457.0595-.4677.0441-.0107.1233.1523.1675.457.0501.4566-.033.918-.2392 1.3285-.1429.2883-.3393.5468-.5789.7617-.2813.2401-.6046.426-.9536.5484-.3748.137-.7663.2231-1.1639.256-.4489.0469-.9024-.017-1.3209-.1859-.07-.0335-.1371-.0746-.2056-.1112l.3626-.0381c-.3113.3274-.7135.554-1.1548.6505-.409.0775-.8316.0374-1.2188-.1158-.1777-.0673-.3469-.1553-.5042-.262-.1473-.1097-.279-.2388-.3915-.3839-.2342-.2994-.39-.6525-.4534-1.0273-.0633-.3748-.0321-.7595.0908-1.1192.1112-.291.2346-.4083.2635-.3915z"
					}), r.a.createElement("path", {
						d: "m12.5288 4.12384c.0335.12188-.6551.38696-1.2964.98567-.6414.59871-.9766 1.24922-1.0939 1.20504-.0533-.01981-.0411-.2209.0792-.51797.1677-.38261.4134-.72603.7214-1.00828.3079-.28226.6714-.49715 1.0672-.63094.3062-.09902.5073-.08836.5225-.03352z"
					}), r.a.createElement("path", {
						d: "m11.1488 3.92917c.0243.12492-.6734.33058-1.32543.89273s-.98262 1.20199-1.10145 1.15781c-.05332-.0198-.04265-.21937.07922-.51187.171-.37717.42374-.71159.73992-.97903.31619-.26744.68794-.4612 1.08824-.56726.3107-.0716.5088-.04723.5195.00762z"
					}), r.a.createElement("path", {
						d: "m16.3803 10.1901c-.1097-.067.3915-.97041.5347-2.19678s-.1005-2.22269.0229-2.26078c.0533-.01676.1935.2148.3047.63223.0647.24543.1066.49635.1249.74953.0464.62313-.0318 1.24927-.23 1.84183-.0799.24049-.1819.47305-.3047.69469-.2118.37938-.4053.56978-.4525.53928z"
					}), r.a.createElement("path", {
						d: "m18.9885 16.1546c-.064-.0137-.0412-.2773-.1036-.6749-.0645-.5111-.2722-.9936-.5992-1.3918-.327-.3981-.7599-.6957-1.2488-.8583-.3793-.1356-.6413-.163-.6429-.23-.0015-.0671.2697-.1402.7191-.0686.5932.102 1.1302.4135 1.5132.8779.383.4643.5866 1.0507.5739 1.6525-.0167.4555-.1538.7069-.2117.6932z"
					}), r.a.createElement("path", {
						d: "m14.8916 15.5424c0 .0549-.2575.0945-.6475-.0213-.5113-.1635-.9518-.4959-1.2494-.9426-.2976-.4468-.4345-.9814-.3882-1.5162.0426-.4038.1767-.6216.2285-.6094s.0411.2513.0792.6094c.0371.4555.1895.8941.443 1.2745.2535.3803.5996.6898 1.0058.8994.3138.1721.5377.2483.5286.3062z"
					}), r.a.createElement("path", {
						d: "m17.5289 17.9844c.0198.0518-.1813.1919-.5546.3047-.2195.0627-.4453.1005-.6733.1127-.2821.0127-.5646-.0104-.841-.0685-.5039-.1057-.972-.3398-1.3589-.6795-.2879-.2651-.4021-.4799-.3625-.5164.0396-.0366.2376.0883.5454.2681.3936.2324.8213.4016 1.2675.5012.2454.051.4945.082.7449.0929.2078.0059.4158.0008.6231-.0152.358-.029.5896-.0625.6094 0z"
					}), r.a.createElement("path", {
						d: "m2.90817 17.6644c.02743-.0336.16758.0441.422.1447.35517.1372.73285.207 1.11363.2056.2607-.0006.52062-.0286.77543-.0837.29447-.0691.58245-.1634.86074-.2819.6451-.2903 1.25785-.6478 1.82813-1.0664.3184-.2194.63527-.4357.95215-.6337.16005-.1033.32643-.1964.49816-.2788.16632-.0783.33786-.145.5134-.1996.33819-.1066.66119-.1691.94909-.2316.2657-.0562.5281-.1269.7861-.2117.9461-.291 1.3894-.7419 1.4503-.6856.0274.0229-.0411.1783-.2529.39-.3054.2895-.6618.5198-1.0511.6795-.2631.1148-.5339.2111-.8105.2879-.2925.0838-.5957.1615-.8943.2712-.1517.0544-.29977.1185-.44329.1919-.15014.0784-.29562.1654-.43571.2605-.30468.1966-.60937.4114-.92929.6323-.60607.446-1.26645.8131-1.96524 1.0923-.31459.118-.64019.2042-.97195.2574-.29262.0427-.58936.0493-.8836.0198-.42771-.0359-.83949-.1789-1.19742-.4159-.24527-.1751-.33668-.3168-.31383-.3442z"
					}), r.a.createElement("path", {
						d: "m6.225 5.96731c.03504.03047-.11882.24832-.27269.70688-.15387.45855-.32906 1.14257-.64289 1.98046-.35795 1.00905-.94757 1.92005-1.72149 2.65995-.44789.4128-.98261.7419-1.41984 1.1365-.22006.1952-.41046.4216-.5652.6718-.15641.2581-.27396.5379-.34886.8303-.1496.5767-.109 1.1864.11578 1.7382.2033.5106.57035.9393 1.04355 1.2188.43841.246.94.3563 1.44117.3168.4522-.035.89467-.1495 1.30711-.3382.62316-.2632 1.19822-.6282 1.70168-1.0801.36106-.3214.55149-.521.585-.4921.03352.029-.09902.2682-.42351.6521-.46912.5411-1.04342.9812-1.68797 1.2934-.4486.2367-.93728.3881-1.44117.4463-.60087.0697-1.20871-.0451-1.74282-.329-.59015-.3284-1.05149-.8472-1.308628-1.4717-.279975-.664-.334037-1.4015-.153867-2.0993.089401-.3498.231157-.6842.420465-.9917.18513-.296.41307-.563.67641-.7922.24386-.2077.49809-.403.76172-.585.24527-.1767.47683-.3473.68707-.5286.39554-.3476.74199-.7474 1.02984-1.18832.25632-.38967.48001-.79986.66879-1.22636.34278-.78153.57586-1.46707.81199-1.91344.23614-.44637.45551-.63984.47836-.61547z"
					}), r.a.createElement("path", {
						d: "m7.61001 17.0368c-.01371-.0229.07312-.096.22852-.227.21967-.1779.4162-.3826.585-.6094.11178-.1553.19769-.3276.25441-.5103.06503-.2047.08222-.4215.05027-.6338-.0336-.226-.14711-.4325-.31992-.5819-.08594-.0808-.18875-.1414-.30099-.1775-.11225-.0361-.23111-.0467-.34799-.0312-.04085.0077-.08309.0029-.12121-.0136-.03812-.0166-.07037-.0443-.09255-.0795-.02219-.0351-.03328-.0762-.03183-.1177.00144-.0416.01535-.0817.03992-.1153.15099-.206.25783-.4409.31383-.6901.0588-.2522.04721-.5157-.03352-.7617-.06006-.1925-.16964-.3659-.31775-.5028s-.32957-.2325-.52623-.2772c-.18409-.0295-.37273-.0078-.54539.0625-.16009.0641-.29709.1751-.39305.3184v.0076c-.02289.0359-.05711.0632-.09724.0776-.04014.0144-.08391.0149-.12442.0017-.0405-.0133-.07544-.0397-.0993-.075s-.03529-.0776-.03247-.1201c.00897-.1905-.02689-.3804-.10468-.5545s-.19534-.3275-.34321-.4479c-.2408-.1906-.54594-.2806-.85161-.2514-.20637.0174-.40675.0781-.58804.1783-.12797.07-.195.1203-.21176.1035-.01676-.0167.02437-.0914.14168-.2026.17711-.1566.39359-.2619.62613-.3047.16814-.034.3411-.0371.51035-.0091.2035.0334.39676.1126.5652.2316.2034.1439.36838.3356.48046.5582.11209.2226.16786.4693.16243.7184l-.35801-.1097c.1399-.2193.34103-.3927.5785-.4989.23747-.1061.50086-.1403.75756-.0983.27463.053.52991.1791.73901.3648.2091.1858.36429.4245.44927.691.10765.3236.12191.671.04113 1.0024-.07296.3061-.21004.5932-.40219.8425l-.20109-.3306c.17731-.0238.3577-.0071.52763.0488s.32497.1497.45346.2741c.2323.2134.37995.5033.4159.8166.02715.2664-.00994.5354-.10816.7846-.08209.2088-.20017.4017-.34887.5697-.20103.2307-.44204.4232-.71145.5683-.18586.099-.29707.131-.30773.1112z"
					}), r.a.createElement("path", {
						d: "m1.63036 14.9239c-.05028-.0671.02742-.2026.10054-.4037.0973-.242.14496-.501.14016-.7618-.00623-.1382-.03082-.275-.07313-.4067-.02438-.0824-.06591-.1587-.12187-.224-.04305-.0401-.0954-.0689-.15235-.0837-.05179-.0153-.10207-.0122-.13253-.0381-.03047-.0259-.03657-.0899.03503-.1646.05278-.0478.11654-.0819.18564-.0991.06909-.0173.14139-.0173.21046.0001.09781.0283.18881.0762.26741.1409s.14313.1448.18962.2354c.14254.2601.1987.5588.16036.8529-.03833.2941-.16918.5684-.37364.7833-.20414.2026-.39305.23-.4357.1691z"
					}), r.a.createElement("path", {
						d: "m3.30922 14.9463c.00761-.0838.2148-.1218.47836-.2529.15103-.0716.29108-.1645.41589-.2757.14195-.126.25387-.2821.32754-.457.02539-.0616.03666-.1281.033-.1946-.00367-.0666-.02218-.1314-.05417-.1899-.03199-.0584-.07666-.1089-.13073-.1479-.05407-.0389-.11616-.0652-.18173-.077-.24375-.0457-.42504.0685-.48598.0152-.02894-.0243-.02742-.0959.04266-.1889.10853-.1306.26266-.215.43113-.2361.1238-.0188.25029-.0073.36868.0335.13848.0489.26222.1322.35953.2422.10996.1238.18329.2757.21175.4388.02862.1723.0102.3491-.05332.5119-.09984.2397-.25932.45-.4633.6108-.20397.1607-.44567.2667-.70213.3078-.15219.0271-.30857.0187-.45703-.0244-.09445-.035-.1432-.0777-.14015-.1158z"
					})), r.a.createElement("path", {
						d: "m3.53778 4.27334c.35264.00703.70225-.06643 1.02223-.2148.5652-.30469.58653-1.05879.69317-1.70473l-.68707-.57586-.29098-.29097c-.40265-.06883-.81671-.01302-1.18676.15996-.11314.03509-.21026.109-.27422.20871-.04419.13436-.03491.28058.0259.40828.20871.67336.43723 1.34824.69773 2.00941z",
						fill: "#fcff78"
					}), r.a.createElement("path", {
						d: "m6.92588 3.76312-1.45336-1.21875c-.08836.62309-.10817 1.28121-.66879 1.66207-.31535.21481-.73582.28793-1.16848.30469.28754.71505.63298 1.40543 1.03289 2.06426.56368.13254 1.12582.15234 1.6636-.21176.81047-.54691.7084-1.71844.59414-2.60051z",
						fill: "#34e2ac"
					}), r.a.createElement("path", {
						d: "m8.74027 5.59247c-.30468-.5591-.8059-.98262-1.2934-1.39242l-.24832-.20719c.0975.87293.10665 1.89668-.59871 2.47558-.54843.45704-1.14867.49665-1.75804.39.19381.29675.40386.58258.62918.85618.30468.35953.64593.70839 1.0923.8455.39305.12036.81809.06246 1.21875 0 .23991-.04098.4642-.14628.64899-.30468.23423-.14822.41471-.36769.51492-.62614.19905-.67984.12528-1.4105-.20567-2.03683z",
						fill: "#4ab6ff"
					}), r.a.createElement("path", {
						d: "m3.63372 1.50807c-.00915.02133-.07922 0-.20262.01066-.17338.01719-.33517.09486-.45703.21938-.08963.10119-.15545.22118-.19262.35115s-.04475.26662-.02219.3999c.03199.32297.21176.66727.45703 1.05117.47989.78 1.04203 1.71387 1.65903 2.75438l.47226.79828c.14562.26333.3215.50874.52407.73125.09393.10008.20166.18626.31992.25594.12269.06894.2545.12023.39152.15234.29024.05902.59075.04276.87293-.04723.14265-.04381.27929-.10522.40676-.18281.12585-.08503.24364-.18141.35191-.28793.21371-.19425.37641-.43804.47379-.70992.18434-.52102 0-1.09231-.33515-1.52344-.33516-.43113-.79067-.79371-1.1959-1.13648l-1.15782-.94149c-1.42593-1.13953-2.32629-1.82812-2.28515-1.89668.04113-.06855 1.02832.50578 2.52586 1.56914.37324.26661.78.56368 1.20961.89121.42961.32754.91406.67336 1.32082 1.18981.21796.26961.37913.58054.47379.91406.0477.17942.07177.36431.0716.54996-.00338.19142-.03469.38131-.09293.56368-.12117.36293-.33056.6901-.60938.95214-.1406.13226-.29366.25062-.45703.35344-.16878.10363-.34998.18553-.53929.24375-.37848.12012-.78173.13955-1.17001.05637-.19307-.04362-.37883-.11494-.55148-.21176-.16901-.097-.32297-.21811-.45703-.35953-.23145-.25682-.43095-.54072-.59414-.84551l-.45703-.81047c-.5911-1.05574-1.11668-2.01093-1.55086-2.81683-.2209-.40067-.41438-.82266-.42047-1.23551-.0138-.17693.01449-.35461.08254-.51851.06804-.16391.17393-.30937.30898-.4245.08602-.06939.18569-.1199.29251-.14825.10683-.02835.21842-.03389.32753-.01628.15844.03047.21328.09141.20567.10512z",
						fill: "#000"
					}), r.a.createElement("path", {
						d: "m4.46393 6.19913c-.07008.03961-.40371-.44332-.88664-1.25836-.24223-.40675-.52102-.8973-.82266-1.44574-.07617-.13558-.15234-.27879-.22395-.43722-.07862-.16703-.13841-.34229-.17824-.52254-.04674-.20918-.04674-.4261 0-.63528.05176-.237.17898-.45082.36258-.60937.19251-.15305.43201-.23486.67793-.23156.21542.00414.42722.05618.62004.15234.16671.07743.32497.17188.47226.28184.13711.10359.25747.20261.38086.30468.4875.38848.91407.74496 1.27969 1.05117.71906.60938 1.13801 1.02223 1.09078 1.08622-.04722.06398-.55605-.23157-1.3391-.76172-.39152-.26356-.85008-.58653-1.35586-.95215-.23758-.19065-.49262-.35846-.76172-.50121-.24527-.11426-.53929-.11578-.69164.01676-.08628.07832-.14594.18165-.17062.29554-.02806.12849-.02806.26152 0 .39.07188.29274.18147.5749.32601.83942.2727.55757.51188 1.0664.70535 1.49144.38086.85617.585 1.40766.51493 1.44574z",
						fill: "#000"
					}), r.a.createElement("path", {
						d: "m3.32259 4.185c.04265-.05027.22089.06856.50425.05637.17023-.01048.33705-.05232.49207-.1234.09475-.04162.18639-.08999.27422-.14473.08767-.05455.16761-.12065.23766-.19652.24239-.29049.364-.66295.33973-1.04051-.00975-.12051-.03484-.23928-.07465-.35343-.02743-.08836-.03809-.15235-.01371-.16454.02437-.01218.07921 0 .15234.07161.11052.10274.19152.23319.23461.37781.06054.21354.072.43801.03351.6566-.04331.27667-.16671.53459-.35496.74191-.09867.10747-.21387.1985-.34125.26965-.11202.0622-.22989.11323-.35191.15235-.21234.07339-.43982.09174-.66117.05332-.1515-.02712-.29151-.09872-.40219-.20567-.07008-.07008-.09445-.12492-.06855-.15082z",
						fill: "#000"
					}), r.a.createElement("path", {
						d: "m4.604 6.28436c.03047-.00914.0716.05637.13864.15234.03548.05467.08035.10264.13253.14168.06723.04371.1441.07037.22395.0777.05049.00737.10135.01195.15234.01371.05353.00107.10705-.00249.15996-.01067.12363-.02073.24399-.05761.35801-.10968.26973-.11881.50848-.29813.69774-.52407.18908-.22808.32585-.49485.40066-.78152.06123-.2426.09295-.49171.09445-.74191 0-.42047-.15234-.67184-.09445-.7084.02285-.01523.09141.02437.1752.13406.11597.16041.19315.34554.22546.54082.04641.28689.0428.57965-.01066.86531-.06644.35874-.2238.69444-.45703.975-.23468.28133-.54026.49486-.88512.61852-.15255.05626-.31288.08863-.47531.09598-.077.00278-.15408-.00232-.23004-.01524-.06368-.0138-.1263-.03213-.18738-.05484-.12349-.03615-.23401-.10701-.3184-.20414-.05878-.07254-.09904-.15829-.11731-.24985-.02742-.13254-.01066-.20718.01676-.2148z",
						fill: "#000"
					}), r.a.createElement("path", {
						d: "m14.8962 8.86965c.8394-1.7809.3564-5.85914-2.2502-7.58672-.6194.71264-1.0159 1.59151-1.1402 2.5275s.029 1.88788.441 2.7375",
						fill: "#ffc2dd"
					}), r.a.createElement("path", {
						d: "m11.9471 6.54651c-.0289.01371-.1264-.10816-.2575-.35953-.178-.36602-.3017-.75607-.3671-1.15781-.1063-.61415-.0898-1.24329.0487-1.85098.1786-.77188.5449-1.48774 1.0664-2.08406v-.00762c.0445-.05081.1065-.08307.1736-.090408.0672-.007334.1346.010798.189.050798l.2956.21937c.1024.07061.1991.14905.2894.23461.1902.16824.367.3511.5287.54692.0807.09902.1675.19347.2391.29707l.2103.30469c.0335.05179.07.10207.102.15234l.0884.16148.1691.32602c.099.21633.195.43113.2773.64441l.1081.32145c.0376.10373.0691.20953.0945.31687.2039.74383.2933 1.5144.2651 2.28516-.0097.52011-.106 1.03497-.2849 1.52344-.0465.13373-.1094.26116-.1874.37933-.0518.08227-.0884.11883-.1066.11121-.0183-.00761-.0183-.06246 0-.15234.0182-.08988.0563-.2209.0777-.39609.0863-.48239.117-.97311.0914-1.4625-.0309-.72382-.1548-1.44065-.3687-2.13282-.0269-.09929-.0594-.19695-.0975-.2925l-.1097-.29554c-.0807-.19653-.1737-.39153-.2681-.58957l-.163-.28946-.0823-.15234c-.0289-.04723-.0625-.09293-.0945-.14016l-.1843-.28031c-.0655-.09293-.1523-.17672-.2163-.2666-.1443-.1766-.3017-.34211-.4708-.49512-.0811-.07598-.1682-.14527-.2605-.20718l-.2589-.19957.3762-.05028c-.4697.52458-.8126 1.15003-1.0024 1.82813-.1534.54814-.2101 1.11883-.1676 1.68644.0747.97196.3382 1.52953.2575 1.56305z",
						fill: "#000"
					}), r.a.createElement("path", {
						d: "m12.4756 10.9713c.6932-.9314.556-2.20692-.3066-2.84893-.8626-.642-2.1238-.40739-2.81708.52403-.69325.93142-.55598 2.2069.30659 2.8489.86259.6421 2.12379.4074 2.81709-.524z",
						fill: "#b8e7ff"
					}), r.a.createElement("path", {
						d: "m12.6477 11.0997c-.3495.475-.8556.8112-1.429.9491-.2925.0698-.596.0806-.8927.032-.3037-.0513-.59239-.1689-.84553-.3443-.256-.1803-.47062-.4131-.62955-.6829s-.25852-.5704-.29213-.8817c-.0368-.31289-.01301-.62995.07008-.93385.16819-.60576.55597-1.12715 1.08773-1.4625.26428-.1668.558-.28159.8653-.33821.308-.05723.6247-.04811.9289.02676s.589.21377.8353.40742c.2408.1922.4364.43511.5728.71145.1316.27014.2083.56376.2254.86379.036.59244-.1401 1.17834-.4966 1.65294zm-.3458-.2575c.1408-.1938.2465-.4109.3123-.6413.0626-.22856.0807-.46699.0533-.70234-.0262-.22746-.1011-.4466-.2197-.64247-.1185-.19586-.278-.36385-.4674-.4925-.1832-.12067-.39-.20124-.6066-.23642s-.4382-.02418-.6502.03228c-.4264.11149-.80187.3653-1.06425.71939s-.39591.7872-.37845 1.22756c.00711.2192.06045.4345.15654.6316.09609.1972.23275.3718.40104.5125.17772.143.38412.2461.60512.3023.2211.0562.4516.0643.6761.0237.2336-.0413.457-.1271.6581-.2529.2016-.1291.379-.2925.5241-.4829z",
						fill: "#000"
					}), r.a.createElement("path", {
						d: "m11.734 10.3357c.3564-.72954.0761-1.59909-.6262-1.94222-.7023-.34314-1.56058-.02993-1.91701.69958-.35643.7295-.07606 1.59904.62623 1.94214.70228.3432 1.56058.03 1.91698-.6995z",
						fill: "#000"
					}), r.a.createElement("path", {
						d: "m10.6281 9.66417c.0662-.43647-.2192-.84166-.63736-.90502-.41814-.06335-.81073.23912-.87686.67559s.21923.84166.63738.90506c.41814.0633.81074-.2392.87684-.67563z",
						fill: "#fff"
					}), r.a.createElement("path", {
						d: "m11.5831 11.1074c.3374 0 .6109-.2851.6109-.6368s-.2735-.6368-.6109-.6368-.6109.2851-.6109.6368.2735.6368.6109.6368z",
						fill: "#fff"
					}), r.a.createElement("path", {
						d: "m12.8948 6.65901c-.0594-.02894.0366-.31687.1158-.78304l.0305-.18282.0228-.20109c.0214-.13711.0244-.28793.0366-.44332.0143-.33972.0097-.67997-.0137-1.01918-.0458-.61737-.1478-1.22927-.3047-1.82812-.1204-.45704-.2224-.74801-.1661-.78.0564-.032.2529.2148.4571.67793.2577.60474.4122 1.24843.457 1.90429.0235.35959.0148.72055-.0259 1.0786-.0259.16605-.0427.32449-.0807.46922l-.0503.21023-.061.19043c-.1706.48293-.3732.73277-.4174.70687z",
						fill: "#000"
					}), r.a.createElement("path", {
						d: "m1.41844 16.2901c.07617-.0472.30469.2834.83789.5652.30658.1598.63944.263.98262.3047.42089.046.8467.0098 1.25379-.1066.88359-.2438 1.57828-.7617 2.06425-1.1639.48598-.4022.7861-.6734.85008-.6201.06399.0534-.12797.4129-.56519.9141-.26033.2951-.55316.5598-.87293.7891-.40061.2889-.84865.5054-1.32387.6399-.48542.1386-.99614.1641-1.49297.0746-.40609-.0764-.78949-.2442-1.12125-.4905-.222-.1628-.40729-.3704-.54387-.6094-.08836-.1676-.10054-.2773-.06855-.2971z",
						fill: "#000"
					}), r.a.createElement("path", {
						d: "m1.2085 15.8394c.70843.486 1.55388.7323 2.4125.703s1.68528-.3328 2.3589-.8661c.23004-.2064.4744-.3963.73125-.5682.12943-.0849.27578-.1405.42889-.1632.15311-.0226.30931-.0116.45775.0322.15254.0661.2835.1737.37801.3105s.14881.2973.15672.4634c.00895.3331-.1037.658-.31688.9141-.21295.2544-.46491.4734-.74648.6489-.83941.5637-1.8525.9933-2.84426.7998-.54082-.1051-1.02984-.3884-1.50515-.6657-.21368-.1179-.41747-.2529-.60938-.4037-.3144-.2606-.5528-.6011-.69012-.9857",
						fill: "#ff85c6"
					}), r.a.createElement("path", {
						d: "m13.3224 5.51322c-.0032.29968-.0637.59597-.1782.87293-.0542.13337-.1411.25098-.2526.34202-.1116.09103-.2442.15259-.3857.179-.3321.03351-.6445-.22242-.7983-.54082-.134-.3332-.1968-.69074-.1844-1.04965-.0259-.98719.061-2.0216.4571-2.92348.1523-.35496.457-1.05422.7845-.45703.2514.45703.3596 1.10754.4479 1.62856.1099.64328.1467 1.29692.1097 1.94847z",
						fill: "#ffc2dd"
					}), r.a.createElement("path", {
						d: "m2.43311 1.8313c.4357-.66727 5.62605 6.34054 5.62605 6.34054l-.4677.41742-1.76566-.26507z",
						fill: "#fff"
					}), r.a.createElement("path", {
						d: "m15.2968 5.96724c1.0832.9293 1.5783 2.68734 1.1944 4.06296 1.4335-1.13034 1.0999 1.88 0 2.9631.2803-.1081.844.2057 1.0222.4479.163.2547.2526.5493.259.8516.0566.6477-.0536 1.2991-.3199 1.8921-.6414 1.4062-2.9829 1.4808-3.6776.972-.1356.5332-.5698.9658-1.3071 1.106.9262.5225 1.7184.4951 2.4253-.3047.8805.2544 2.3628 0 3.1337-.4875s1.2584-1.4579 1.0664-2.3522c-.1341-.6093-.55-1.1197-.7389-1.7154-.227-.7145-.1112-1.4899.0336-2.2257.1447-.7358.3168-1.4884.195-2.22879-.1219-.74039-.6201-1.47622-1.3559-1.62094.0186-.79515-.2157-1.57567-.6691-2.22917-.4533-.6535-1.1024-1.14624-1.8537-1.40728l.5515 2.145",
						fill: "#7e53c1",
						opacity: ".67"
					}), r.a.createElement("path", {
						d: "m14.8307 4.86442c.113 1.0501.0543 2.11159-.1737 3.14285-.2483 1.02375-.7724 1.69559-1.5889 2.96003-1.3666 2.1145-4.16206 4.2123-4.16206 4.2123l-.21024 1.106s3.0012-.914 3.9229-1.5539c.1995-.361.2909-1.2187.3382-1.6316.0895-.7608.3635-1.4883.7982-2.1191.3443-.4997.7298-.8927 1.0375-1.41678.4246-.75116.6314-1.60579.5972-2.46797-.0544-.8398-.2078-1.67024-.457-2.47406",
						fill: "#ffc2dd"
					}), r.a.createElement("path", {
						d: "m13.8086 14.0707c-.0274 0-.0761-.0807-.1173-.2514-.0508-.2446-.058-.4963-.0213-.7434.0512-.3631.1538-.717.3047-1.0512.1823-.399.3931-.7844.6307-1.1532.2422-.387.4677-.7511.6444-1.09233.1603-.2979.29-.61131.387-.93539.1523-.55148.1173-.9232.1858-.93387.0274 0 .0731.08227.1097.25442.0428.24545.0428.49646 0 .74191-.0594.36166-.1686.71336-.3245 1.04508-.1865.39658-.3992.78038-.6368 1.14868-.2422.3854-.457.751-.6368 1.0938-.156.299-.2801.6135-.3702.9385-.1417.5545-.0883.9262-.1554.9384z",
						fill: "#c676ff"
					}), r.a.createElement("path", {
						d: "m14.9072 14.0231c-.0564 0-.1326-.1752-.1524-.4829-.0454-.8133.2322-1.6116.7724-2.2212.2102-.2255.3824-.3199.4235-.2803.0914.0868-.3458.652-.6185 1.4579s-.3047 1.5143-.425 1.5265z",
						fill: "#c676ff"
					}), r.a.createElement("path", {
						d: "m6.19165 7.1707c-.01219-.06246.12949-.13559.32297-.2666.24618-.1607.45882-.36765.62613-.60938.15866-.24732.26783-.52308.32144-.81199.04723-.22852.05942-.38848.12036-.40067.06093-.01218.15234.13407.18738.41133.03174.3671-.06183.73413-.26546 1.04123-.20362.30709-.50528.53614-.85579.64979-.27117.07312-.44637.04266-.45703-.01371z",
						fill: "#fff"
					}), r.a.createElement("path", {
						d: "m4.43023 4.76671c0-.12035.43114-.18434.76172-.50273.33059-.3184.43571-.72821.55758-.72668.05789 0 .11731.1234.10207.33058-.03163.27398-.1599.52771-.36178.71562-.20187.18791-.46413.2977-.73966.30966-.20567 0-.32297-.07313-.31993-.12645z",
						fill: "#fff"
					}), r.a.createElement("path", {
						d: "m3.40812 2.70883c.30037 0 .54387-.2435.54387-.54387s-.2435-.54387-.54387-.54387c-.30036 0-.54386.2435-.54386.54387s.2435.54387.54386.54387z",
						fill: "#fff"
					}), r.a.createElement("path", {
						d: "m16.4716 14.2914c.0168-.0213.0915-.0076.192.0808.1373.1344.2244.3119.2468.5027.0418.2872-.0268.5795-.192.8181-.202.2785-.4875.4856-.815.5911-.5639.1875-1.1772.1593-1.7215-.0792-.4067-.1844-.585-.4037-.5515-.4464.0336-.0427.2682.0625.6521.1523.2215.0538.4484.082.6764.0838.2721.0041.543-.0376.8013-.1234.2476-.0783.4686-.2238.6383-.4204.1276-.1591.2003-.3553.2072-.5591.0152-.3641-.1782-.5515-.1341-.6003z",
						fill: "#c676ff"
					}), r.a.createElement("path", {
						d: "m12.6798 17.3567c-.0442.0365-.1813-.0305-.3199-.2255-.1735-.264-.2528-.5787-.2251-.8933.0276-.3146.1606-.6107.3774-.8404.1691-.1691.3169-.2117.3535-.1691.0365.0427-.0229.1676-.1021.3458-.2153.4435-.2582.9512-.1204 1.4245.0412.1904.0854.3138.0366.358z",
						fill: "#c676ff"
					}), r.a.createElement("path", {
						d: "m12.6432.993331c.0549.001261.1081.019339.1524.051799l.2955.21937c.1024.0706.1992.14904.2895.23461.1902.16823.3669.3511.5286.54692.0807.09902.1676.19347.2392.29707l.2102.30468c.0335.0518.0701.10207.1021.15235l.0883.16148.1311.24223c.1523.0716.3123.15234.457.23613.4808.277.916.62641 1.2903 1.03594.3946.42526.6993.9258.8958 1.47164.1365.37028.2007.76334.1889 1.15781.2065.0822.3969.20031.5622.34887.2183.19639.3963.43337.524.69773.2368.4925.3602 1.03182.3611 1.57829.0037.26323-.0198.52615-.0701.78455-.0515.2498-.1264.4941-.2239.7297-.1752.4479-.3459.8471-.3352 1.231.0236.4022.1338.7945.323 1.1502.1737.3763.3763.748.5149 1.1486.0732.1995.1243.4064.1523.617.0251.2055.0251.4131 0 .6186-.049.3813-.1782.7478-.3793 1.0755-.1265.2034-.2802.3884-.457.55-.032.032-.0625.0655-.096.0959-.2813.2401-.6047.4261-.9537.5485-.3748.1369-.7662.223-1.1639.2559-.096 0-.1935.0107-.2925.0107-.3527.0071-.703-.0598-1.0283-.1965-.2835.2425-.6235.4096-.9887.4859-.1309.0263-.2641.0396-.3976.0396-.1308 0-.2613-.0118-.39-.035-.0691-.0034-.1379-.0121-.2057-.0259-.4243-.0768-.81-.2954-1.0938-.62-.3157-.3695-.5211-.8204-.5926-1.3011-.0692-.4618-.0031-.9338.1904-1.3589-.1661.0625-.3413.1219-.5256.1737-.2925.0838-.5957.1615-.8942.2712-.15177.0544-.29985.1185-.44337.1919-.15013.0784-.29561.1654-.4357.2605-.30469.1966-.60938.4114-.9293.6323-.60606.446-1.26645.8131-1.96523 1.0923-.31459.118-.6402.2042-.97196.2574-.1751.0251-.35174.0378-.52863.0381-.11856.0001-.23704-.006-.35496-.0183-.42771-.0359-.8395-.1789-1.19742-.4159-.24527-.1736-.3382-.3168-.31535-.3427.0035-.0009.00716-.0009.01066 0-.26616-.056-.52276-.1504-.76172-.2803-.59015-.3284-1.05149-.8472-1.308629-1.4717-.285418-.6678-.341666-1.4113-.159961-2.1145.089401-.3499.231157-.6843.42047-.9918.18512-.296.41306-.5629.6764-.7922.24386-.2077.49809-.403.76172-.585.24528-.1767.47684-.3473.68707-.5286.39554-.3476.742-.7473 1.02985-1.18827.25631-.38968.48-.79987.66879-1.22637.09293-.21023.17672-.41133.25593-.60937-.11902-.16844-.22936-.34285-.33058-.52254l-.45703-.81047c-.5911-1.05574-1.11668-2.01094-1.55086-2.81684-.12458-.21556-.23059-.44134-.31688-.67488-.08052-.16829-.14184-.3451-.18281-.52711-.04675-.20918-.04675-.4261 0-.63527.05176-.237.17898-.45082.36258-.60938.19129-.15206.429-.2338.67336-.23156h.00914c.2118.00575.41978.05775.60937.15234.16882.07706.32914.17152.47836.28184.13711.10359.25746.20262.38086.30469.4875.38847.91406.74496 1.27969 1.05117.40066.34125.7084.62004.89273.81047l.41743.30773.04418.03352c.02807-.2051.06723-.40852.1173-.60938.12074-.49951.29704-.98394.52559-1.44422.04547-.10165.09632-.20082.15234-.29707l.16453-.28793c.0182-.03202.04252-.06014.07159-.08275.02907-.02262.06231-.03928.09782-.04904s.0726-.01243.10914-.00785c.03654.00457.07183.01631.10383.03453l.02743.01828c.38016.28079.7368.59209 1.0664.93082.21773.22749.42123.46813.60933.72058.3091-.0716.6226-.12249.9385-.15234.2026-.61813.5268-1.18947.9537-1.68035v-.00762c.0251-.02912.0562-.05248.0911-.06852.035-.01603.073-.024358.1115-.024409zm-7.59736 2.437499c.06405-.15644.10312-.32197.11578-.49055-.02525.16638-.06397.33044-.11578.49055zm-.73125 7.08097.03351-.0076c.02133-.0397.04114-.0808.06094-.1204l-.09293.128zm-.28793.3565c.04937-.0282.10023-.0536.15234-.0762l.02285-.0351c-.03808.0092-.07312.0183-.10664.029l-.07008.0807zm-1.00395 6.8143h-.00761zm9.62049-16.910168c-.0696-.000201-.1385.014672-.2019.043598s-.1197.07122-.1652.123981v.007617c-.4115.478212-.7312 1.028242-.943 1.622462-.2316.02742-.4571.06551-.6902.11426-.1682-.21931-.3483-.42934-.5392-.62918-.33831-.34598-.70412-.6639-1.09388-.95063l-.05027-.03199c-.05671-.03237-.11923-.05323-.18401-.06141-.06478-.00817-.13053-.00349-.1935.01377-.06296.01726-.12191.04677-.17346.08684-.05155.04006-.09469.0899-.12696.14666l-.1691.28336c-.06001.09869-.11492.20038-.16453.30469-.2348.4748-.4152.97461-.53778 1.48992-.02285.08988-.04418.18129-.06246.27726l-.16301-.12187c-.19195-.195-.49359-.4677-.8973-.80438-.36715-.30468-.79981-.66726-1.28578-1.05574l-.09598-.07617c-.08531-.08684-.18586-.15539-.28945-.23918-.15921-.11881-.33023-.22091-.51035-.30469-.22066-.10615-.46202-.162328-.70688-.164529l-.00914.216329v-.223946c-.29523-.003494-.58241.096186-.81199.281836-.21874.18764-.37103.44092-.43418.72211-.0536.24029-.0536.48944 0 .72973.04217.19688.10603.38848.19043.57128.08802.24388.19657.47984.32449.70536.44027.81808.96281 1.76414 1.55238 2.81683l.45704.81199c.0716.12493.16453.28184.27421.44333-.07464.18281-.14168.33972-.20871.48902-.18354.41537-.40112.81486-.65051 1.19437-.2769.42478-.61058.80968-.99175 1.14408-.21328.1844-.44942.358-.67184.518l-.0716.0518c-.24432.1701-.47974.3527-.70535.5469-.27965.2431-.52148.5265-.717541.8409-.201003.3259-.351499.6803-.446367 1.0512-.191573.7431-.132671 1.5287.167578 2.2349.277385.6687.77228 1.2242 1.40461 1.5768.21839.1184.45074.2089.69164.2696.09693.1355.21773.2521.35648.3443.38841.2581.83506.4151 1.2995.457.1255.0132.25161.0198.37781.0198.18655-.0002.37287-.0134.55758-.0396.34488-.0565.68324-.1473 1.01004-.2711.7161-.2867 1.39326-.6624 2.0155-1.1182l.18586-.128c.25594-.1767.49817-.3443.73887-.5012.13372-.0908.27259-.1737.4159-.2483.1356-.0694.27554-.13.41896-.1813.227-.0823.457-.1524.6871-.2118l.1934-.0548.1173-.0351c-.0901.3419-.1088.6987-.0548 1.0481.0765.5219.3 1.0113.6444 1.4107.3166.3609.7463.6037 1.2188.6886.0723.015.1456.0246.2193.029.1379.0242.2775.0364.4175.0366.1478.0002.2952-.0141.4402-.0427.3588-.0709.6965-.2231.9872-.4448.3197.1159.6578.1727.9979.1675.0959 0 .1965 0 .3047-.0106.4164-.0353.8263-.126 1.2187-.2697.375-.1317.7222-.3322 1.0238-.5911.0289-.0259.0533-.0518.0776-.0777l.0244-.0259c.1885-.174.3525-.3729.4875-.5911.2169-.3543.3565-.7504.4098-1.1623.0271-.2227.0271-.4477 0-.6704-.0266-.2257-.0777-.4479-.1523-.6627-.107-.2909-.2312-.5753-.3717-.8516-.0518-.1066-.1036-.2117-.1524-.3184-.176-.3298-.2798-.6933-.3047-1.0664-.0091-.3184.125-.6596.2819-1.0542l.0396-.099c.1028-.2484.1819-.506.2361-.7693.0531-.2709.0776-.54668.0731-.8227-.0008-.5803-.132-1.153-.3839-1.67578-.1406-.28852-.3356-.54716-.5743-.76172-.1482-.13199-.3144-.24227-.4936-.32753-.0056-.36454-.0704-.72574-.192-1.06946-.2059-.57305-.5256-1.09851-.9399-1.54476-.3892-.42647-.8419-.79028-1.3422-1.0786-.1249-.0716-.2589-.14168-.4159-.2148l-.0304-.05789-.0655-.12035-.0884-.16149c-.0228-.03808-.0472-.07465-.0716-.11121l-.0396-.06246-.2118-.31383c-.0548-.07922-.1127-.15234-.1706-.2148l-.0807-.09598c-.139-.17453-.2919-.33755-.4571-.4875l-.0807-.0777c-.0754-.07432-.1569-.14211-.2438-.20261l-.067-.05028-.2437-.176714-.0579-.042657c-.0834-.06156-.1843-.094675-.288-.094453z",
						fill: "#fff"
					}))
				},
				c = e => {
					let {
						className: t
					} = e;
					return Object(s.e)(i.j) ? r.a.createElement(d, {
						className: t
					}) : r.a.createElement(a, {
						className: t
					})
				},
				d = e => {
					let {
						className: t
					} = e;
					return r.a.createElement("svg", {
						className: t,
						fill: "#000",
						xmlns: "http://www.w3.org/2000/svg",
						viewBox: "0 0 40 40",
						height: "40",
						width: "40"
					}, r.a.createElement("path", {
						fill: "#ffdce2",
						d: "M11.76,15.15c.91-19.36,7.94-9.23,8-.71"
					}), r.a.createElement("path", {
						d: "M19.8,14.44a8.73,8.73,0,0,1-.45-2.07,14,14,0,0,0-.79-2.82,20,20,0,0,0-1.71-3.19,5.07,5.07,0,0,0-1.11-1.18,1.22,1.22,0,0,0-.47-.2c-.11,0-.17,0-.28.11a2.27,2.27,0,0,0-.65.88,8.65,8.65,0,0,0-.53,1.32c-.29.94-.53,1.91-.72,2.85-.4,1.87-.71,3.62-1.06,5a8.26,8.26,0,0,1-.83-4.73A30,30,0,0,1,13,5.56a6.5,6.5,0,0,1,.68-1c.13-.16.32-.3.47-.45a2.23,2.23,0,0,1,.62-.3A1.73,1.73,0,0,1,16,3.89a3.23,3.23,0,0,1,.95.69A10.88,10.88,0,0,1,19.1,8a13.48,13.48,0,0,1,.9,3.33A9.87,9.87,0,0,1,19.8,14.44Z"
					}), r.a.createElement("path", {
						fill: "#ffdce2",
						d: "M31.58,11.79c-3.31-3.6-8.69-4.11-13.65-2.9-5.63,1.4-7.87,6.7-10.6,10.93C5.6,21.92,3.57,23.67,2.11,26c-2.82,4.11.11,10.29,5.22,11.11,4.86.78,6.84-2.16,9.1-2.71,7.74-1.87,14.39-5.19,16-9.73C33.35,20.6,32.16,15.94,31.58,11.79Z"
					}), r.a.createElement("path", {
						d: "M31.59,11.78a19.39,19.39,0,0,1,.6,2.63A45.81,45.81,0,0,1,33,20a18.12,18.12,0,0,1,0,3.29,9.38,9.38,0,0,1-.31,1.67c-.11.26-.21.52-.32.77l-.41.72a14.17,14.17,0,0,1-3.83,3.82,29.56,29.56,0,0,1-6.61,3.36c-1.18.46-2.4.84-3.64,1.2a17.58,17.58,0,0,0-1.72.51,12.05,12.05,0,0,0-1.56.88,11.7,11.7,0,0,1-3.72,1.68,9.47,9.47,0,0,1-4.17,0A8.55,8.55,0,0,1,.63,32.57,8.24,8.24,0,0,1,.06,29a7,7,0,0,1,1.13-3.45,32.4,32.4,0,0,1,4.12-5c.35-.37.69-.75,1-1.12l.21-.25L6.7,19l.4-.64c.54-.86,1.07-1.73,1.6-2.58A22.63,22.63,0,0,1,12.5,11a11.46,11.46,0,0,1,5.28-2.83,20.36,20.36,0,0,1,5.45-.45,14.1,14.1,0,0,1,4.92,1.18,10.62,10.62,0,0,1,3.64,2.74,12.11,12.11,0,0,0-3.94-2.05,15,15,0,0,0-5-.52,22,22,0,0,0-4.59.76,12.15,12.15,0,0,0-3,1.28,12.59,12.59,0,0,0-3.54,3.18,44.59,44.59,0,0,0-2.77,4l-.66,1-.33.51L7.88,20s-.07.11-.12.17l-.11.12c-.54.61-1.1,1.2-1.65,1.76a34.28,34.28,0,0,0-3,3.43,8.73,8.73,0,0,0-.62.92,4.17,4.17,0,0,0-.48.94,5.91,5.91,0,0,0-.44,2,7.32,7.32,0,0,0,4,6.63,7.71,7.71,0,0,0,3.78.76,8.15,8.15,0,0,0,3.59-1,19.91,19.91,0,0,1,3.47-1.83,50.13,50.13,0,0,0,6.86-2.26,24.52,24.52,0,0,0,5.74-3.3A10.83,10.83,0,0,0,31,26.17a4.09,4.09,0,0,0,.4-.62,2.84,2.84,0,0,0,.33-.65l.15-.33a.34.34,0,0,0,0-.12l0-.18c0-.24.11-.48.14-.72C32.79,19.85,31.58,13.09,31.59,11.78Z"
					}), r.a.createElement("path", {
						fill: "#f9a",
						d: "M15,33.5c-.06-.16.39-.71,1.08-1.17a15.64,15.64,0,0,1,2-1c1.64-.84,3.65-1.16,5.09-1.87a12.34,12.34,0,0,0,3.33-2.36,7.84,7.84,0,0,0,2-2.77,2.59,2.59,0,0,1,.44,2,2.84,2.84,0,0,1-.7,1.6,16.44,16.44,0,0,1-6.26,3.36c-1.95.55-3.56,1-4.89,1.48-.31.13-.76.25-1.16.39S15.07,33.45,15,33.5Z"
					}), r.a.createElement("path", {
						fill: "#6a5cff",
						d: "M16.82,8.12c9.76-1.89,17.3,3.72,16.34,8,5,0,8.71,6.76,4.08,11.49,4.43,5.08,1.94,10.32-4.3,11.6-4.37.89-8.32-.76-9.83-4-1.71-3.65,1.08-7.29,5.78-7.42-5.56-5.2,3.42-8.34-.58-16.55"
					}), r.a.createElement("path", {
						d: "M28.32,11.28a2.88,2.88,0,0,1,.36.62,5.92,5.92,0,0,1,.57,1.41A8.27,8.27,0,0,1,29.32,18c-.43,1.8-1.46,3.56-1.82,5.3a4,4,0,0,0,.31,2.41c.09.17.21.33.31.5a5.45,5.45,0,0,0,.57.72l1.22,1.28c-.94.08-1.81.19-2.58.33a6.13,6.13,0,0,0-2.77,1.56,4,4,0,0,0-1.2,2.74,4.69,4.69,0,0,0,1,2.92,6.42,6.42,0,0,0,2.53,2,9.53,9.53,0,0,0,6.62.3c2.16-.61,4.1-2,4.68-3.84a5.58,5.58,0,0,0-1-4.93,9,9,0,0,0-.59-.77l-.47-.6-.23-.3c-.08-.05,0-.1.05-.15l.12-.14L37,26.28a3.29,3.29,0,0,0,.38-.54,5.5,5.5,0,0,0,.87-2.38A5.24,5.24,0,0,0,38,20.88a5.67,5.67,0,0,0-1.29-2.13,5.58,5.58,0,0,0-2-1.35A5.68,5.68,0,0,0,33,17.09L32.32,17l-.17,0a.92.92,0,0,1,0-.16l0-.34a12.4,12.4,0,0,0,.1-1.27,5.77,5.77,0,0,0-2.43-3.86,13.29,13.29,0,0,0-4.27-2.25,19.73,19.73,0,0,0-8.71-.71,16.24,16.24,0,0,1,9.39-.59,13.49,13.49,0,0,1,4.61,2,7.82,7.82,0,0,1,2.62,2.84l.28.58.2.64a5.36,5.36,0,0,1,.2,1.34s-.08.11,0,.11a2.28,2.28,0,0,0,.49.15,7.13,7.13,0,0,1,3.83,2.69,7.49,7.49,0,0,1,1.45,4.22,7.13,7.13,0,0,1-1.18,4.13l-.29.44a3.51,3.51,0,0,1-.3.36l-.19.21-.09.1s.05.07.07.11l.43.57.53.86a7.58,7.58,0,0,1,1,3.88,5.83,5.83,0,0,1-1.44,3.62,8.16,8.16,0,0,1-3,2.2,11.93,11.93,0,0,1-7,.82,8,8,0,0,1-5.53-3.76,5.77,5.77,0,0,1-.81-3.25,5.11,5.11,0,0,1,1.27-3,6.56,6.56,0,0,1,2.58-1.81,6.13,6.13,0,0,1,.72-.25L27,27.5l.15,0a3.27,3.27,0,0,1,.62-.07,4,4,0,0,1-.46-.55l-.18-.28a2.77,2.77,0,0,1-.22-.37l-.29-.82a5.64,5.64,0,0,1,.23-3.18c.64-1.87,2.06-4,2.21-6.23a8.74,8.74,0,0,0-.19-3C28.66,12.2,28.41,11.59,28.32,11.28Z"
					}), r.a.createElement("path", {
						d: "M21.44,26c4.39-2,1-8.4-3.18-5.83C15,22.4,17.62,27.75,21.44,26Z"
					}), r.a.createElement("path", {
						d: "M21.44,26a2.7,2.7,0,0,1-1.81.47A3.26,3.26,0,0,1,18.2,26a4.74,4.74,0,0,1-.94-.83,3.7,3.7,0,0,1-.74-3.43,3.84,3.84,0,0,1,2.65-2.54,3.49,3.49,0,0,1,3.12.51,4.05,4.05,0,0,1,1.58,2.53,3.41,3.41,0,0,1-.58,2.61,3.64,3.64,0,0,1-1.79,1.27,5.15,5.15,0,0,0,1.21-1.71,4.21,4.21,0,0,0,.23-1.55A3.07,3.07,0,0,0,22.4,21a2.89,2.89,0,0,0-1.53-1.1A3.08,3.08,0,0,0,17.68,21,3,3,0,0,0,17.22,24,3.49,3.49,0,0,0,19,25.89a3.7,3.7,0,0,0,1.39.27h.37L21,26.1Z"
					}), r.a.createElement("path", {
						fill: "#f9a",
						d: "M10.33,26.53c-2.77-.86-3.6-1.91-2.94-3.47C.11,25.47.07,33.88,7.18,36.34,13,38.34,17.35,28.69,10.33,26.53Z"
					}), r.a.createElement("path", {
						fill: "#f9a",
						d: "M10.33,26.52a6,6,0,0,1,1.09.35,7.15,7.15,0,0,1,.93.56,6.61,6.61,0,0,1,.93.91A4.92,4.92,0,0,1,14.13,31,7,7,0,0,1,14,32.23c-.11.37-.17.72-.28,1a6.35,6.35,0,0,1-1.83,2.6A4.9,4.9,0,0,1,8.76,37,5.92,5.92,0,0,1,7,36.75c-.51-.22-1-.39-1.54-.66a8.58,8.58,0,0,1-1.39-.92A7.55,7.55,0,0,1,2.94,34a6.86,6.86,0,0,1-1.51-3.62,6.46,6.46,0,0,1,.74-3.72A7.73,7.73,0,0,1,4.53,24a14.66,14.66,0,0,1,1.41-.82l1-.36.58-.22A1.88,1.88,0,0,1,8,22.47a8.28,8.28,0,0,0-.48,1.43,1.39,1.39,0,0,0,.07.59,2.1,2.1,0,0,0,.76.89,8.54,8.54,0,0,0,2,1A6.6,6.6,0,0,1,8,25.7a2.26,2.26,0,0,1-1-1.14,1.91,1.91,0,0,1-.11-.41c0-.11,0-.31,0-.28s0-.06,0-.07-.07.05-.07.06h0L6.41,24c-.34.18-.61.36-.83.46A6.81,6.81,0,0,0,2.8,27.22a5.82,5.82,0,0,0-.57,3.67A6,6,0,0,0,3.86,34a7.78,7.78,0,0,0,2.82,1.87,4.54,4.54,0,0,0,5.47-1.18,5.69,5.69,0,0,0,1.3-2.36,6.17,6.17,0,0,0,.22-1.26,4.91,4.91,0,0,0-.14-1.22,4.13,4.13,0,0,0-1.43-2.31l-.54-.42a3.12,3.12,0,0,0-.53-.29Z"
					}), r.a.createElement("path", {
						d: "M33,34.05c-.07-.07,0-.48.1-.95a3.82,3.82,0,0,0-.05-1.3,4.28,4.28,0,0,0-1.77-2.53,5.16,5.16,0,0,0-2.41-.83,8.67,8.67,0,0,0-2.22.13,2.56,2.56,0,0,1,2-1.06,6.24,6.24,0,0,1,3.93,2,4.58,4.58,0,0,1,.9,1.6,4.07,4.07,0,0,1,.11,1.61A3.53,3.53,0,0,1,33,34.05Z"
					}), r.a.createElement("path", {
						d: "M11.6,31.34a1.52,1.52,0,0,1-.23,1.17,3.33,3.33,0,0,1-.61.73c-.24.18-.45.38-.61.48a7.05,7.05,0,0,1-4.23,1,6.93,6.93,0,0,1-3.47-1.08A4.36,4.36,0,0,1,.63,31.32c.42.19.81.51,1.24.7s.77.38.9.56A5.23,5.23,0,0,0,5,33.78a6.76,6.76,0,0,0,2.3.15,5.93,5.93,0,0,0,3.37-1.35,4.62,4.62,0,0,0,.61-.63C11.43,31.69,11.55,31.43,11.6,31.34Z"
					}), r.a.createElement("path", {
						fill: "#ffdce2",
						d: "M19.92,15.9c.32-15.81,8.82-12.13,9.16-.18"
					}), r.a.createElement("path", {
						d: "M29.07,15.72a6.88,6.88,0,0,1-.46-2.09,13.82,13.82,0,0,0-.76-2.86,14.36,14.36,0,0,0-1.77-3.13c-.71-.94-1.71-1.52-2.28-1.24a3.32,3.32,0,0,0-1.53,1.77,15,15,0,0,0-.95,2.71c-.49,1.85-.78,3.61-1.1,5a7.42,7.42,0,0,1-.89-4.82,16,16,0,0,1,2.33-4.8A3.25,3.25,0,0,1,23.87,5a3.11,3.11,0,0,1,2.25.82,8.85,8.85,0,0,1,2.32,3.38,12.2,12.2,0,0,1,.87,3.39A11.14,11.14,0,0,1,29.07,15.72Z"
					}), r.a.createElement("path", {
						d: "M6.75,30.09a1,1,0,1,0,.06-2C5.64,28.27,5.51,30,6.75,30.09Z"
					}), r.a.createElement("path", {
						d: "M6.75,30.1A.74.74,0,0,1,6.19,30a1,1,0,0,1-.41-.73,1.19,1.19,0,0,1,.36-1,1.24,1.24,0,0,1,1.12-.3,1.08,1.08,0,0,1,.75.67,1.32,1.32,0,0,1,0,.94,1,1,0,0,1-.58.6,1.06,1.06,0,0,1-.68,0,1.6,1.6,0,0,0,.57-.28,1.6,1.6,0,0,0,.28-.36.93.93,0,0,0,0-1.08.85.85,0,0,0-1-.19,1,1,0,0,0-.45,1.45C6.23,29.91,6.65,30.08,6.75,30.1Z"
					}), r.a.createElement("path", {
						d: "M2.09,28.69c1.06-.05,1.47-2.36.39-2C1.59,27.11,1.2,28.85,2.09,28.69Z"
					}), r.a.createElement("path", {
						d: "M2.09,28.69a.32.32,0,0,1-.16,0,.37.37,0,0,1-.3-.17,1.1,1.1,0,0,1-.06-.7A1.82,1.82,0,0,1,1.94,27a1,1,0,0,1,.85-.44.47.47,0,0,1,.37.29.88.88,0,0,1,.08.41,1.92,1.92,0,0,1-.19.73,1.13,1.13,0,0,1-1,.72A1.46,1.46,0,0,0,2.78,28,1.34,1.34,0,0,0,3,27c-.08-.38-.54-.28-.74-.08a1.73,1.73,0,0,0-.62,1.4.37.37,0,0,0,.16.31A.45.45,0,0,0,2.09,28.69Z"
					}), r.a.createElement("circle", {
						fill: "#19f2c8",
						cx: "20.51",
						cy: "23.28",
						r: "2.04"
					}), r.a.createElement("path", {
						fill: "#19f2c8",
						d: "M22.55,23.28a2.72,2.72,0,0,0-.35-1A1.89,1.89,0,0,0,21,21.4a2,2,0,0,0-1.74.49,1.87,1.87,0,0,0-.56,1.69,1.91,1.91,0,0,0,2.25,1.51,2,2,0,0,0,1.56-1.81,1.81,1.81,0,0,1-.23,1.29,1.84,1.84,0,0,1-.94.78,2.22,2.22,0,0,1-2.5-.78,2.14,2.14,0,0,1,1.49-3.43,2.1,2.1,0,0,1,1.7.61,2,2,0,0,1,.47.85A2.09,2.09,0,0,1,22.55,23.28Z"
					}), r.a.createElement("circle", {
						fill: "#fff",
						cx: "18.9",
						cy: "21.87",
						r: "1.31"
					}), r.a.createElement("path", {
						fill: "#fff",
						d: "M20.21,21.87a2.75,2.75,0,0,0-.25-.65,1.17,1.17,0,0,0-.77-.52,1.22,1.22,0,0,0-1.06.32,1.15,1.15,0,0,0-.34,1,1.18,1.18,0,0,0,1.37.92,1.28,1.28,0,0,0,1-1.11,1.05,1.05,0,0,1-.08.87,1.21,1.21,0,0,1-.62.54,1.52,1.52,0,0,1-1.66-.55,1.44,1.44,0,0,1-.13-1.5,1.42,1.42,0,0,1,1.11-.77,1.34,1.34,0,0,1,1.12.41,1.26,1.26,0,0,1,.3.56A1.41,1.41,0,0,1,20.21,21.87Z"
					}), r.a.createElement("path", {
						fill: "#f9a",
						d: "M26,16.18c-1.46,1-4.82.41-5.26-1.56s.44-6.22,1.55-6.74C23.78,7.2,27.18,15.35,26,16.18Z"
					}), r.a.createElement("path", {
						d: "M26,16.17a1.08,1.08,0,0,0,.13-.59A5.5,5.5,0,0,0,26,14.27a13.67,13.67,0,0,0-1-2.63,14.42,14.42,0,0,0-1.87-3,1.41,1.41,0,0,0-.54-.41s0,0-.08,0-.14.14-.21.23a5.79,5.79,0,0,0-.64,1.52A13.35,13.35,0,0,0,21.16,13a6.94,6.94,0,0,0,.05,1.38,1.75,1.75,0,0,0,.51,1,3.86,3.86,0,0,0,2.16.95A3.71,3.71,0,0,0,26,16.06a3,3,0,0,1-2.21.92,3.5,3.5,0,0,1-2.17-.56,3.09,3.09,0,0,1-.94-1.09A3.12,3.12,0,0,1,20.37,14a11.14,11.14,0,0,1,.19-2.35,13.82,13.82,0,0,1,.53-2.13,6.53,6.53,0,0,1,.41-1,2.11,2.11,0,0,1,.72-.84.75.75,0,0,1,.64,0,1.88,1.88,0,0,1,.45.31,4.87,4.87,0,0,1,.65.73,12.72,12.72,0,0,1,.94,1.54,15.23,15.23,0,0,1,1.21,3,6.67,6.67,0,0,1,.26,1.7,2.64,2.64,0,0,1-.08.78A.63.63,0,0,1,26,16.17Z"
					}), r.a.createElement("path", {
						fill: "#94b3ff",
						d: "M33.47,23.09a.89.89,0,0,1-.11-.3l-.06-.26,0-.14,0-.08-.07.05a6.76,6.76,0,0,0-.63.52,6.62,6.62,0,0,0-.72.77l-.13.16-.13-.17a1.25,1.25,0,0,1-.19-1.07l.08-.32,0-.17s0-.18-.06-.16l-.23.15-.26.2a6.3,6.3,0,0,0-.83.72,2.56,2.56,0,0,0-.58.83c-.1.3-.08.46.11.63L29,25a2.77,2.77,0,0,1-.61-2.35,12.57,12.57,0,0,1,1.14-3,14,14,0,0,0,1-2.64,5.72,5.72,0,0,0,0-2.47c-.1-.38-.24-.73-.36-1.08l-.51-.93a8.88,8.88,0,0,1,.82.76,5.83,5.83,0,0,1,.68,1.14,4.33,4.33,0,0,1,.31,1.24,2.53,2.53,0,0,1,0,.94A17.5,17.5,0,0,1,29.71,21,7.05,7.05,0,0,0,29,22.94a2.13,2.13,0,0,0,.48,1.69l-.27.27a1.13,1.13,0,0,1-.35-.66,1.21,1.21,0,0,1,.12-.71,3.69,3.69,0,0,1,.75-1,7.86,7.86,0,0,1,.91-.75,5.41,5.41,0,0,1,.64-.38c.24-.13.45-.21.7-.32.07,0,0,.25.06.34a2.16,2.16,0,0,1,0,.36,4.34,4.34,0,0,1-.2.79.94.94,0,0,0,0,.83h-.39l.17-.19a6.25,6.25,0,0,1,1.49-1.12l.21-.11c0-.05,0,.05,0,.08v.12l0,.43Z"
					}), r.a.createElement("path", {
						fill: "#94b3ff",
						d: "M27.44,35.4a1.55,1.55,0,0,1-.47-.64,3,3,0,0,1-.23-.68,2.52,2.52,0,0,1-.06-.52l0-.25s0-.11,0-.08l-.1.1a1.38,1.38,0,0,0-.26.39,1.3,1.3,0,0,0-.12.4,2.49,2.49,0,0,0-.08.72,2.42,2.42,0,0,0,.44,1.36l-.56.55a3.74,3.74,0,0,1-1.55-2.34,4.67,4.67,0,0,1,2.14-4.55,4,4,0,0,1,4-.37c-.28,0-.59,0-.9.05a4.93,4.93,0,0,0-.94.21,8.29,8.29,0,0,0-1.35.61,4.13,4.13,0,0,0-2.34,3,3,3,0,0,0,1.28,2.95l-.28.28a3,3,0,0,1-.36-2.69,2.88,2.88,0,0,1,.88-1.29l.26-.22.14-.11c.05,0,.1-.08.08,0s0,.13.14.13h.05a3.9,3.9,0,0,0-.16,2.21A3.41,3.41,0,0,0,27.44,35.4Z"
					}), r.a.createElement("path", {
						fill: "#493ac1",
						d: "M28.06,37.14a11.11,11.11,0,0,0,1.27.18,10.21,10.21,0,0,0,1.84-.17,11.56,11.56,0,0,0,2.17-.61,6.25,6.25,0,0,0,1.79-1.22,4.49,4.49,0,0,0,1.16-3,5.57,5.57,0,0,0-.53-2.88,2.17,2.17,0,0,1,1.47,1,2.51,2.51,0,0,1,.52,1.45,7.52,7.52,0,0,1-1,3.29,4.4,4.4,0,0,1-1.05,1.13,9.61,9.61,0,0,1-1.16.8,6.9,6.9,0,0,1-2.43.81A11.52,11.52,0,0,1,29.9,38a3,3,0,0,1-1.16-.31A1.74,1.74,0,0,1,28.06,37.14Z"
					}), r.a.createElement("path", {
						fill: "#493ac1",
						d: "M33.09,26.76c0-.13.41-.15.79-.21a2,2,0,0,0,1-.34,3.49,3.49,0,0,0,.44-.41c.12-.13.21-.31.34-.48a3.58,3.58,0,0,0,.46-1.1,8.75,8.75,0,0,0-.18-3.77c.82,0,1.72.82,1.68,1.24a8.14,8.14,0,0,1-.88,3.8,3.82,3.82,0,0,1-1.05,1.24,2.52,2.52,0,0,1-1.37.44A2.49,2.49,0,0,1,33.09,26.76Z"
					}), r.a.createElement("path", {
						fill: "#fff8b8",
						d: "M2.29.57C0,2,5.89,16.92,8,19.08c2.8,1.55,7.52-.47,7.38-3.83S3.9-2.36,2.29.57Z"
					}), r.a.createElement("path", {
						d: "M2.27.56A.46.46,0,0,1,2.33.4.49.49,0,0,1,2.56.15a1.27,1.27,0,0,1,1.07,0A8.53,8.53,0,0,1,6.2,1.76a48.61,48.61,0,0,1,4.41,4.49,35.05,35.05,0,0,1,4.79,6.5,7.42,7.42,0,0,1,.83,2.15,4.29,4.29,0,0,1-.42,2.51,6,6,0,0,1-3.61,2.86,6.27,6.27,0,0,1-4,0L7.73,20a1.74,1.74,0,0,1-.35-.19l-.27-.3a8.55,8.55,0,0,1-.57-.79c-.33-.51-.6-1-.87-1.53a47.33,47.33,0,0,1-2.5-6A40,40,0,0,1,1.63,5.49a16.66,16.66,0,0,1-.3-2.67,5.66,5.66,0,0,1,.1-1.3A1.65,1.65,0,0,1,2.14.32a1.41,1.41,0,0,0-.31,1.21,6.29,6.29,0,0,0,.26,1.23c.24.84.56,1.72.89,2.57C3.63,7,4.29,8.6,4.52,9.47a46.46,46.46,0,0,0,1.64,5c.31.79.65,1.57,1,2.31.18.37.37.72.57,1.07.1.16.2.34.31.49s.11.16.17.22.06.1.11.13c2.53,1.36,6.38-.38,6.65-3V15.3a1.75,1.75,0,0,0-.07-.44,5.61,5.61,0,0,0-.34-.91,16.41,16.41,0,0,0-.95-1.75C13,11.08,12.2,10,11.46,9,10,7.06,8.48,5.29,7,3.69A32.32,32.32,0,0,0,4.48,1.12,4,4,0,0,0,3.13.3.77.77,0,0,0,2.27.56Z"
					}), r.a.createElement("path", {
						fill: "#ccffef",
						d: "M10.69,11.08a4.78,4.78,0,0,1-5,2.21c.85,2.93,2.21,5.84,3.6,6.41,2,.82,6.16-.77,6.05-4.37-.05-1.53-2.15-4.85-4-6.41a3.06,3.06,0,0,1-1.36,3"
					}), r.a.createElement("path", {
						d: "M10,11.89a4,4,0,0,0,.7-.78,3.28,3.28,0,0,0,.46-2.47c0-.16.22.08.38.21l.5.46c.37.36.54.56.77.82.43.49.79,1,1.06,1.31a13.15,13.15,0,0,1,1.36,2.22A5.79,5.79,0,0,1,15.66,15a3.73,3.73,0,0,1,0,.74,3.55,3.55,0,0,1-.08.73A4.5,4.5,0,0,1,14.15,19a5.93,5.93,0,0,1-2.51,1.3A4.13,4.13,0,0,1,8.71,20a5.88,5.88,0,0,1-1.77-2.14,15.31,15.31,0,0,1-1-2.29c-.14-.38-.26-.75-.37-1.12l-.23-.78-.26-.94c.27.06.53.13.8.17l.39.07a.58.58,0,0,0,.18,0h.1a3.55,3.55,0,0,0,.73,0,4.65,4.65,0,0,0,1.36-.39,5.37,5.37,0,0,0,2-1.6,4.48,4.48,0,0,1-2,2.32A4.31,4.31,0,0,1,7,13.86a2.56,2.56,0,0,1-.39,0H6.36s0,0,0,.08l.11.43c.08.28.16.56.25.83q.27.83.6,1.59a6.17,6.17,0,0,0,1.8,2.54,3.65,3.65,0,0,0,2.83.07,4.85,4.85,0,0,0,2.28-1.55,3.81,3.81,0,0,0,.81-2.38,5.26,5.26,0,0,0-.75-2.28,17.47,17.47,0,0,0-1.26-2c-.22-.3-.45-.6-.68-.88s-.23-.27-.35-.41l-.2-.23-.17-.17-.1-.11s0,0,0,.07a1.84,1.84,0,0,1-.14.64,2.93,2.93,0,0,1-.46.9A2.48,2.48,0,0,1,10,11.89Z"
					}), r.a.createElement("path", {
						fill: "#19f2c8",
						d: "M8.57,5.17c.14,2.42-2.75,3.95-4.8,3.76.61,1.47,1.56,6,3.36,5.89,2.38,0,5.54-1.7,5.25-4.6A17.52,17.52,0,0,0,8.44,5.46"
					}), r.a.createElement("path", {
						d: "M8.45,5.46A6.8,6.8,0,0,1,10.32,7,23.61,23.61,0,0,1,12.46,9.8c.06.1.27.33.23.56a3.26,3.26,0,0,1,0,.54,4,4,0,0,1-.2,1.08,4.35,4.35,0,0,1-1.29,1.84,6.37,6.37,0,0,1-4.11,1.54h.06a3,3,0,0,1-.53,0,3.14,3.14,0,0,1-.46-.18,3.81,3.81,0,0,1-1.27-1.48,11.83,11.83,0,0,1-.68-1.57c-.19-.52-.35-1-.51-1.54L3.5,9.77,3,8.37c.33,0,.68.05,1,0h.45c.18,0,.17,0,.27,0a4.7,4.7,0,0,0,.83-.17A4.79,4.79,0,0,0,7,7.54,3.1,3.1,0,0,0,8.41,5.18a2.4,2.4,0,0,1,.08,1.33A3.33,3.33,0,0,1,7.72,8,4.42,4.42,0,0,1,5.4,9.34c-.15,0-.29.05-.44.06H4.61L4.4,9.37s0,.05,0,.09a1.75,1.75,0,0,0,0,.25l.25.91a17.49,17.49,0,0,0,.54,1.73A6.71,6.71,0,0,0,6,13.84a1.42,1.42,0,0,0,1.12.76h0a5.26,5.26,0,0,0,4.57-2.48A3.1,3.1,0,0,0,12.05,11a2.72,2.72,0,0,0,0-.57c0-.1,0-.12,0-.17L11.9,10c-.4-.67-.83-1.29-1.25-1.87A27.49,27.49,0,0,0,8.45,5.46Z"
					}), r.a.createElement("path", {
						fill: "#fff",
						d: "M3.3,2.08A31.85,31.85,0,0,1,4.72,5.57c.7,1.64,1.36,3.56,2,5.26a47.44,47.44,0,0,0,3.47,7.56A5.89,5.89,0,0,1,7.76,15.9c-1-2.49-1.65-4.65-2.35-6.56s-1.28-3.56-1.69-5A19.92,19.92,0,0,1,3.3,2.08Z"
					}), r.a.createElement("path", {
						fill: "#6a5cff",
						d: "M20.72,8c-12.86-4.26-7.25,10.38.19,7.55-1.23-1.74-.58-5.59-.18-7.17"
					}), r.a.createElement("path", {
						d: "M20.74,8.4a16.52,16.52,0,0,1-.19,2.41,9.2,9.2,0,0,0,.22,3.3,2.47,2.47,0,0,0,.1.29l.06.14a1.76,1.76,0,0,0,.09.21,12.51,12.51,0,0,0,.67,1.1,10.52,10.52,0,0,1-1.3.49c-.11,0-.25.06-.37.09l-.27.06a4,4,0,0,1-.5.06,5.26,5.26,0,0,1-2.08-.2,7,7,0,0,1-3.39-2.27,6.31,6.31,0,0,1-1.55-3.87,3.51,3.51,0,0,1,.66-2.16,3.44,3.44,0,0,1,1.78-1.23,6.69,6.69,0,0,1,3.48,0,12.83,12.83,0,0,1,2.64,1c-.81.11-1.91.07-2.89.14s-1.81.15-2.21.2a2.36,2.36,0,0,0-1.61.62,2.2,2.2,0,0,0-.58,1.62A5.25,5.25,0,0,0,15,13.73a5.46,5.46,0,0,0,2.89,1.7,4.79,4.79,0,0,0,1.55.08,2.29,2.29,0,0,0,.36-.07l.21,0c.1-.06.28-.07.29-.15a2.12,2.12,0,0,1-.12-.2,1.34,1.34,0,0,1-.11-.31,5.39,5.39,0,0,1-.22-1,9.32,9.32,0,0,1,0-1.9A11.43,11.43,0,0,1,20.74,8.4Z"
					}), r.a.createElement("path", {
						fill: "#94b3ff",
						d: "M17.76,12.22c-.08,0-.17-.4-.36-.73,0-.05-.07,0,0-.08s0,.05,0,.07a2.47,2.47,0,0,0-.21.36l-.41.85-.08,0a1.77,1.77,0,0,1-.58-1,2.63,2.63,0,0,1,.05-1.39l.49.51a1.81,1.81,0,0,0-.41.23l0,0a.36.36,0,0,0-.11.1,1,1,0,0,0-.2.27,11.84,11.84,0,0,0-.49,1.4l-.18-.33-.08-.14h0L15,12.27,14.93,12a2.4,2.4,0,0,1-.29-1,1.92,1.92,0,0,1,.06-.62,1.81,1.81,0,0,1,.2-.54,2.45,2.45,0,0,1,.52-.62,3.09,3.09,0,0,1,2.39-.62c-.28.21-.67.4-1,.62s-.55.4-.69.48a1.51,1.51,0,0,0-.57.46c-.08.12-.1.13-.14.2a.77.77,0,0,0-.07.2,1,1,0,0,0,.05.5c0,.07,0,0,0,0l0-.09a1.18,1.18,0,0,1,.11-.19,1.11,1.11,0,0,1,.29-.28,2.53,2.53,0,0,1,.54-.28l.37-.14-.13.39a1.94,1.94,0,0,0-.06.86,1.13,1.13,0,0,0,.08.22.41.41,0,0,0,0,.09s0,0,.06-.07a1.67,1.67,0,0,1,.18-.28.46.46,0,0,1,.11-.12.56.56,0,0,1,.14-.1.32.32,0,0,1,.27,0c.24.21.19.35.23.49A3.65,3.65,0,0,1,17.76,12.22Z"
					}))
				}
		},
		"./src/reddit/components/Econ/Prediction/hooks/useTournamentsQuery.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/actions/economics/predictions/index.ts"),
				a = n("./src/reddit/selectors/features/predictions/tournaments/index.ts"),
				c = n("./src/reddit/selectors/subreddit.ts");

			function d(e) {
				const t = Object(s.d)(),
					n = Object(s.e)(t => Object(c.X)(t, {
						subredditId: e
					})),
					o = Object(s.e)(t => Object(a.i)(t, {
						subredditId: e
					})),
					d = Object(s.e)(t => Object(a.k)(t, {
						subredditId: e
					})),
					l = r.a.useCallback(() => {
						n.name && t(Object(i.l)(n.name))
					}, [n.name, t]);
				return r.a.useEffect(() => {
					d || o || l()
				}, [d, o, l]), {
					isFetching: d,
					isFetched: o,
					fetch: l
				}
			}
		},
		"./src/reddit/components/Econ/Prediction/themes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var o = n("./src/config.ts");
			const r = {
				theme_1: `url(${o.a.assetPath}/img/econ/predictions/theme1.png)`,
				theme_2: `url(${o.a.assetPath}/img/econ/predictions/theme2.png)`,
				theme_3: "linear-gradient(104.49deg, #279A63 7.96%, #B6C048 119.75%)",
				theme_4: "linear-gradient(91.64deg, #F5AC1F -10.49%, #FC7519 52.61%)",
				theme_5: `url(${o.a.assetPath}/img/econ/predictions/theme5.png)`,
				theme_6: `url(${o.a.assetPath}/img/econ/predictions/theme6.png)`,
				theme_7: `url(${o.a.assetPath}/img/econ/predictions/theme7.png)`,
				theme_8: `url(${o.a.assetPath}/img/econ/predictions/theme8.png)`
			}
		},
		"./src/reddit/components/Econ/Tournament/Sidebar/HowItWorks/Content.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			var o = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/components/Econ/Tournament/Sidebar/HowItWorks/index.m.less"),
				d = n.n(c);
			const l = e => {
				let {
					steps: t,
					withModalStyles: n
				} = e;
				return i.a.createElement(i.a.Fragment, null, i.a.createElement("div", {
					className: Object(a.a)(d.a.banner, {
						[d.a.withModalStyles]: n
					})
				}, i.a.createElement("div", {
					className: d.a.header
				}, i.a.createElement("h2", null, i.a.createElement("span", {
					className: d.a.subHeader
				}, r.fbt._("Predictions", null, {
					hk: "ACRaq"
				})), r.fbt._("How It Works", null, {
					hk: "3QW4EZ"
				})), i.a.createElement("img", {
					alt: r.fbt._("Snoos gathered around a dark ball", null, {
						hk: "2sN6dD"
					}),
					className: d.a.bannerImage,
					src: `${o.a.assetPath}/img/econ/predictions/predictor_snoos_small.png`
				})), i.a.createElement("div", {
					className: d.a.innerCircle
				}), i.a.createElement("div", {
					className: d.a.middleCircle
				}), i.a.createElement("div", {
					className: d.a.outerCircle
				})), i.a.createElement("div", {
					className: Object(a.a)(d.a.stepsWrapper, {
						[d.a.withModalStyles]: n
					})
				}, t.map((e, n) => {
					let {
						title: o,
						description: r
					} = e;
					return i.a.createElement("div", {
						key: o,
						className: d.a.step
					}, i.a.createElement("div", {
						className: Object(a.a)(d.a.stepCount, {
							[d.a.showConnectingLine]: n !== t.length - 1
						})
					}, i.a.createElement("span", {
						className: d.a.stepNumber
					}, n + 1)), i.a.createElement("div", null, i.a.createElement("h3", {
						className: d.a.stepTitle
					}, o), i.a.createElement("p", {
						className: d.a.stepDescription
					}, r)))
				})))
			}
		},
		"./src/reddit/components/Econ/Tournament/Sidebar/HowItWorks/index.m.less": function(e, t, n) {
			e.exports = {
				widget: "_2skejWRT1rfgG6BplBSilb",
				banner: "_3Vuq-pvkzBHvhhc3OpN8CM",
				bannerImage: "_2GFV0XwSqv5Tr7PgZrRhVJ",
				withModalStyles: "_1RCK5xRisccYHWg1jiIoGb",
				circle: "_2016VIWG6bI8Nj8dsE4ypu",
				innerCircle: "_3j7kvNb-J6NJvKhocXhFpj",
				middleCircle: "_2m_eeq88Ifrg139rZyFFXk",
				outerCircle: "_3Ylo3qve0XxZ8mD9a2f841",
				header: "_2uBF46oc23WTMTLsgZkvHK",
				subHeader: "_2B5e_YXlIHTvceClBKv1h7",
				stepsWrapper: "_1A39M70HpOpbB2VfD7JRbq",
				step: "_1Z2_r-1ZgxI_OPxZQClct5",
				stepCount: "_2HWLDJDxl7OJmP4RsXqD9G",
				showConnectingLine: "_2XjaqnXdYZD-Z3ebpnuijI",
				stepNumber: "_39kWugzptUpQdvLWvfg7p6",
				stepTitle: "_1sgBe74lmm4Ril3sKb2nVU",
				stepDescription: "Utf73H7YpNoys-kCKEC6r",
				learnMoreWrapper: "_2KfRiOpMkVmGl6pasDgDj",
				learnMoreButton: "_3sIJNS0bEKk48Q-RSRYaUB"
			}
		},
		"./src/reddit/components/Emoji/index.m.less": function(e, t, n) {
			e.exports = {
				EmojiDisplay: "_2Gt13AX94UlLxkluAMsZqP",
				emojiDisplay: "_2Gt13AX94UlLxkluAMsZqP"
			}
		},
		"./src/reddit/components/Flair/index.m.less": function(e, t, n) {
			e.exports = {
				FlairEmojiDisplay: "_1QwShihKKlyRXyQSlqYaWW",
				flairEmojiDisplay: "_1QwShihKKlyRXyQSlqYaWW",
				FlairWrapper: "_2X6EB3ZhEeXCh1eIVA64XM",
				flairWrapper: "_2X6EB3ZhEeXCh1eIVA64XM",
				TextFlair: "_1jNPl3YUk6zbpLWdjaJT1r",
				textFlair: "_1jNPl3YUk6zbpLWdjaJT1r",
				transparentBackgroundColor: "_39BEcWjOlYi1QGcJil6-yl",
				RichTextFlair: "_2hSecp_zkPm_s5ddV2htoj",
				richTextFlair: "_2hSecp_zkPm_s5ddV2htoj",
				MetaFlair: "_1wzhGvvafQFOWAyA157okr",
				metaFlair: "_1wzhGvvafQFOWAyA157okr",
				CloseButton: "_3BPVpMSn5b1vb1yTQuqCRH",
				closeButton: "_3BPVpMSn5b1vb1yTQuqCRH",
				CloseIcon: "_2cvySYWkqJfynvXFOpNc5L",
				closeIcon: "_2cvySYWkqJfynvXFOpNc5L",
				small: "aJrgrewN9C8x1Fusdx4hh",
				large: "_1wj6zoMi6hRP5YhJ8nXWXE",
				flairVariant: "_2VqfzH0dZ9dIl3XWNxs42y"
			}
		},
		"./src/reddit/components/Flair/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return U
			})), n.d(t, "b", (function() {
				return K
			})), n.d(t, "a", (function() {
				return H
			})), n.d(t, "c", (function() {
				return V
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				s = n.n(r),
				i = n("./node_modules/polished/dist/polished.es.js"),
				a = n("./node_modules/react/index.js"),
				c = n.n(a),
				d = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				l = n("./src/lib/addQueryParams/index.ts"),
				u = n("./src/lib/classNames/index.ts"),
				m = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				p = n("./src/lib/lessComponent.tsx"),
				h = n("./src/reddit/components/Emoji/index.m.less"),
				b = n.n(h);

			function f() {
				return (f = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const g = p.a.wrapped(e => {
				let {
					backgroundImage: t,
					style: n,
					...o
				} = e;
				return c.a.createElement("div", f({
					style: {
						...n || {},
						backgroundImage: `url('${t}')`
					}
				}, o))
			}, "EmojiDisplay", b.a);
			var v = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				C = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				y = n("./src/reddit/constants/colors.ts"),
				E = n("./src/reddit/constants/parameters.ts"),
				x = n("./src/reddit/controls/InternalLink/index.tsx"),
				O = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				_ = n("./src/reddit/icons/svgs/Close/index.tsx"),
				k = n("./src/reddit/models/Flair/index.ts"),
				j = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				S = n("./src/reddit/components/Flair/index.m.less"),
				T = n.n(S);

			function w() {
				return (w = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const I = Object(C.a)(v.b),
				P = p.a.div("FlairWrapper", T.a),
				N = p.a.wrapped(d.a, "CloseButton", T.a),
				R = p.a.wrapped(Object(m.a)(e => {
					let {
						forceSmallEmojis: t,
						theme: n,
						...o
					} = e;
					const r = n;
					return c.a.createElement(g, w({
						style: {
							...M(!!t, r) || {}
						}
					}, o))
				}), "FlairEmojiDisplay", T.a),
				M = (e, t) => {
					if (!e && !!t.subredditContext.emojiHeight && !!t.subredditContext.emojiWidth) return {
						height: `${t.subredditContext.emojiHeight}px`,
						width: `${t.subredditContext.emojiWidth}px`
					}
				},
				D = (e, t) => {
					const n = t ? `/r/${t}/search` : "/search",
						o = `${t?"flair_name":"flair"}:"${e}"`;
					return Object(l.a)(n, {
						[E.w]: o,
						[E.x]: t ? "1" : ""
					})
				},
				L = e => e.isFlairFilter ? c.a.createElement(x.default, {
					onMouseDown: e.onMouseDown,
					to: e.to || ""
				}, e.flair) : e.onClick ? c.a.createElement(x.default, {
					onClick: () => e.onClick(e.searchableTerm),
					to: D(e.searchableTerm, e.subredditName)
				}, e.flair) : e.flair;
			class A extends c.a.Component {
				constructor() {
					super(...arguments), this.tooltipTargetElement = null, this.state = {
						isTooltipOpen: !1
					}, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							isTooltipOpen: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							isTooltipOpen: !1
						})
					}
				}
				render() {
					const e = c.a.createElement("span", {
						className: Object(u.a)(this.props.className, {
							[T.a.transparentBackgroundColor]: "transparent" === this.props.backgroundColor
						}),
						onMouseEnter: this.props.tooltip ? this.onShowTooltip : void 0,
						onMouseLeave: this.props.tooltip ? this.onHideTooltip : void 0,
						ref: this.setTooltipTargetRef,
						style: {
							backgroundColor: this.props.backgroundColor || Object(j.a)(this.props).flair,
							color: `${U(this.props)}`
						}
					}, this.props.text, this.props.isSelected && c.a.createElement(N, {
						to: "./",
						onClick: this.props.onCloseClick
					}, c.a.createElement(_.a, {
						className: T.a.CloseIcon,
						style: {
							fill: this.props.backgroundColor || Object(j.a)(this.props).flair
						}
					})), !!this.props.tooltip && c.a.createElement(I, {
						text: this.props.tooltip,
						isOpen: this.state.isTooltipOpen,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: ["center", "top"],
						tooltipPosition: ["center", "bottom"]
					}));
					return c.a.createElement(L, {
						flair: e,
						isFlairFilter: this.props.isFlairFilter,
						onClick: this.props.onClick,
						onMouseDown: this.props.onMouseDown,
						searchableTerm: this.props.text,
						subredditName: this.props.subredditName,
						to: this.props.to
					})
				}
			}
			const F = Object(m.a)(A),
				B = Object(m.a)(e => {
					let t = "",
						n = !1;
					const o = e.richtext.map((o, r) => {
						if (o.e === k.c.Emoji) {
							const s = o;
							return t += s.a, n = !0, c.a.createElement(R, {
								forceSmallEmojis: e.forceSmallEmojis,
								backgroundImage: s.u,
								key: r,
								title: s.a
							})
						} {
							const e = o;
							return t += e.t, c.a.createElement("span", {
								key: r
							}, e.t)
						}
					});
					let r;
					n && !e.forceSmallEmojis && e.theme && e.theme.subredditContext.emojiWidth && e.theme.subredditContext.emojiHeight && e.theme.subredditContext.emojiHeight > 16 && (r = {
						marginTop: `-${e.theme.subredditContext.emojiHeight-16}px`
					});
					const s = c.a.createElement(P, {
						className: Object(u.a)(e.className, {
							[T.a.transparentBackgroundColor]: "transparent" === e.backgroundColor
						}),
						style: {
							...r,
							backgroundColor: e.backgroundColor || Object(j.a)(e).flair,
							color: `${U(e)}`
						}
					}, o, e.isSelected && c.a.createElement(N, {
						to: "./",
						onClick: e.onCloseClick
					}, c.a.createElement(_.a, {
						className: T.a.CloseIcon,
						style: {
							fill: e.backgroundColor || Object(j.a)(e).flair
						}
					})));
					return c.a.createElement(L, {
						flair: s,
						isFlairFilter: e.isFlairFilter,
						onClick: e.onClick ? () => {
							e.onClick(t)
						} : void 0,
						onMouseDown: e.onMouseDown,
						searchableTerm: t,
						subredditName: e.subredditName,
						to: e.to
					})
				}),
				U = e => !e.textColor || e.textColor && !e.backgroundColor ? Object(j.a)(e).postFlairText : "transparent" === e.backgroundColor ? Object(O.a)(Object(j.a)(e).post, y.a.black, y.a.white) : e.textColor === k.e.Dark ? y.a.black : y.a.white,
				K = p.a.wrapped(F, "TextFlair", T.a),
				W = p.a.wrapped(B, "RichTextFlair", T.a),
				G = e => {
					switch (e.type) {
						case "spoiler":
							return "#A4A7A8";
						case "nsfw":
							return "#FF585B";
						default:
							return Object(i.i)(.1, Object(j.a)(s()(e, "theme", "redditStyle", "data-redditstyle")).button)
					}
				},
				H = p.a.wrapped(e => {
					const t = G(e),
						n = c.a.createElement("span", {
							className: e.className,
							style: {
								border: `1px solid ${t}`,
								color: t
							}
						}, e.text);
					return c.a.createElement(L, {
						flair: n,
						searchableTerm: e.text
					})
				}, "MetaFlair", T.a);

			function V(e) {
				const {
					className: t,
					disabled: n = !1,
					flair: r,
					isFlairFilter: s,
					isSelected: i,
					onClick: a,
					onCloseClick: d,
					onMouseDown: l,
					subredditName: m,
					usesCommunityStyles: p,
					forceSmallEmojis: h,
					to: b
				} = e, f = Object(u.a)({
					[T.a.flairVariant]: s,
					[T.a.small]: s && !e.large,
					[T.a.large]: s && e.large
				}, t);
				switch (r.type) {
					case k.f.Richtext:
						return n || !r.richtext ? null : c.a.createElement(W, {
							backgroundColor: r.backgroundColor,
							className: f,
							forceSmallEmojis: h,
							isFlairFilter: s,
							isSelected: i,
							onClick: a,
							onCloseClick: d,
							onMouseDown: l,
							redditStyle: !p,
							richtext: r.richtext,
							subredditName: m,
							textColor: r.textColor,
							to: b
						});
					case k.f.Text:
						return n || !r.text ? null : c.a.createElement(K, {
							backgroundColor: r.backgroundColor,
							className: f,
							isFlairFilter: s,
							isSelected: i,
							onClick: a,
							onCloseClick: d,
							onMouseDown: l,
							subredditName: m,
							text: r.text,
							textColor: r.textColor,
							redditStyle: !p,
							to: b
						});
					case k.f.Meta:
						return c.a.createElement(K, {
							backgroundColor: r.backgroundColor,
							className: t,
							isFlairFilter: s,
							subredditName: m,
							text: r.text,
							textColor: r.textColor,
							redditStyle: !p,
							to: b
						});
					case k.f.Nsfw:
					case k.f.Spoiler:
						return c.a.createElement(H, {
							className: t,
							text: r.text,
							type: r.type
						});
					case k.f.Quarantined:
						return null;
					case k.f.Oc:
						return c.a.createElement(K, {
							backgroundColor: y.a.alienblue,
							text: r.text,
							textColor: k.e.Light,
							tooltip: o.fbt._("This post is marked as Original Content [OC]", null, {
								hk: "h7je6"
							})
						});
					default:
						return r.text ? c.a.createElement(K, {
							backgroundColor: r.backgroundColor,
							className: f,
							isFlairFilter: s,
							onClick: a,
							onCloseClick: d,
							onMouseDown: l,
							subredditName: m,
							text: r.text,
							redditStyle: !p,
							to: b
						}) : null
				}
			}
		},
		"./src/reddit/components/FlairList/index.m.less": function(e, t, n) {
			e.exports = {
				flairVariantInList: "_1Dl-kvSxyJMWO9nuoTof8N"
			}
		},
		"./src/reddit/components/FlairList/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/lodash/noop.js"),
				r = n.n(o),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/components/Flair/index.tsx"),
				l = n("./src/reddit/helpers/flair.ts"),
				u = n("./src/reddit/models/Flair/index.ts"),
				m = n("./src/reddit/selectors/user.ts"),
				p = n("./src/reddit/components/FlairList/index.m.less"),
				h = n.n(p);
			const b = Object(c.c)({
					labelNSFW: m.cb
				}),
				f = Object(a.b)(b),
				g = e => {
					if (e.type === u.f.Richtext && e.richtext) {
						const t = e.richtext.map(e => e.e === u.c.Emoji ? e.u : e.t).join("-");
						return `${e.type}--${t}`
					}
					return `${e.type}--${e.text}`
				};
			t.a = f(e => {
				let {
					className: t,
					isFlairFilter: n,
					onClick: o,
					onMouseDown: s,
					disabled: a = !1,
					flair: c,
					labelNSFW: m,
					subredditName: p
				} = e;
				const b = !!c.find(e => e.type === u.f.Richtext),
					f = c.map(e => {
						if (e.type === u.f.Text && b) return null;
						if (!m && e.type === u.f.Nsfw) return null;
						const t = Object(l.j)(e),
							c = `/r/${p}/`,
							f = s ? () => s(e) : r.a,
							v = n && (e.type === u.f.Richtext || e.type === u.f.Text);
						return i.a.createElement(d.c, {
							className: v ? h.a.flairVariantInList : void 0,
							isFlairFilter: n,
							key: g(e),
							onClick: o,
							onMouseDown: f,
							disabled: a,
							flair: e,
							forceSmallEmojis: !0,
							subredditName: p,
							to: Object(l.e)(c, t)
						})
					});
				return i.a.createElement("div", {
					className: t
				}, f)
			})
		},
		"./src/reddit/components/FlairPickerTitle/index.m.less": function(e, t, n) {
			e.exports = {
				modalHeader: "_26bOTAKvGixX5tMC3vGfTv"
			}
		},
		"./src/reddit/components/FlairPickerTitle/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/lodash/noop.js"),
				r = n.n(o),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				c = n("./src/reddit/controls/TextButton/index.tsx"),
				d = n("./src/reddit/components/FlairPickerTitle/index.m.less"),
				l = n.n(d);
			t.a = e => i.a.createElement(a.i, {
				className: l.a.modalHeader
			}, i.a.createElement(a.q, null, e.title), i.a.createElement(c.a, {
				onClick: e.onClosePressed || r.a
			}, i.a.createElement(a.b, null)))
		},
		"./src/reddit/components/FlairPickerWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_3nRJIwLuth2pKYrXnr2jPN",
				wrapper: "_3nRJIwLuth2pKYrXnr2jPN"
			}
		},
		"./src/reddit/components/FlairPickerWrapper/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/components/FlairPickerWrapper/index.m.less"),
				s = n.n(r);
			const i = o.a.div("Wrapper", s.a);
			t.a = i
		},
		"./src/reddit/components/FlairPreview/index.m.less": function(e, t, n) {
			e.exports = {
				Placeholder: "_30zvTaAcvBFmwfelq6Bvwg",
				placeholder: "_30zvTaAcvBFmwfelq6Bvwg",
				SelectedFlair: "BzonfS85jX2JTiu_i0Jyd",
				selectedFlair: "BzonfS85jX2JTiu_i0Jyd",
				FlairComponent: "vynkb69RQyUY-PA6bCaW0",
				flairComponent: "vynkb69RQyUY-PA6bCaW0"
			}
		},
		"./src/reddit/components/FlairPreview/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/Flair/index.tsx"),
				c = n("./src/reddit/components/FlairPreview/index.m.less"),
				d = n.n(c);
			const l = i.a.span("Placeholder", d.a),
				u = i.a.div("SelectedFlair", d.a),
				m = i.a.wrapped(a.c, "FlairComponent", d.a);
			t.a = e => e.flair ? s.a.createElement(u, null, s.a.createElement(l, null, o.fbt._("{placeholder}", [o.fbt._param("placeholder", e.placeholderText)], {
				hk: "4G6VRy"
			})), s.a.createElement(m, {
				flair: e.flair,
				forceSmallEmojis: !0
			})) : s.a.createElement(u, null, o.fbt._("No flair selected", null, {
				hk: "1XPXbv"
			}))
		},
		"./src/reddit/components/FlairSearch/FlairEdit/helper.m.less": function(e, t, n) {
			e.exports = {
				FlairEditStub: "Z7x0t_45z9vZGN2zw6US6",
				flairEditStub: "Z7x0t_45z9vZGN2zw6US6",
				isCompact: "_3YjPWOd9tK9O_DN50RI_FN"
			}
		},
		"./src/reddit/components/FlairSearch/FlairEdit/helper.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			}));
			var o = n("./node_modules/lodash/once.js"),
				r = n.n(o),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./src/higherOrderComponents/makeAsync.tsx"),
				c = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/lessComponent.tsx"),
				l = n("./src/lib/loadWithRetries/index.ts"),
				u = n("./src/reddit/components/FlairSearch/FlairEdit/helper.m.less"),
				m = n.n(u);
			const p = d.a.wrapped(e => i.a.createElement("div", {
					className: Object(c.a)(e.className, {
						[m.a.isCompact]: e.isCompact
					})
				}), "FlairEditStub", m.a),
				h = r()((function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : p;
					return Object(a.a)({
						getComponent: () => Object(l.a)(() => Promise.all([n.e("vendors~ChatMessageInput~CommentRichUnit~FlairEdit~MembershipPaywallPage~PostCreation~PostRichUnit~R~9deab1a0"), n.e("FlairEdit")]).then(n.bind(null, "./src/reddit/components/FlairSearch/FlairEdit/index.tsx")).then(e => e.default)),
						ErrorComponent: e,
						LoadingComponent: e
					})
				}))
		},
		"./src/reddit/components/FlairSearch/FlairTemplateList/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1bdAduczElF9-gLoCvHz-p",
				flairComponent: "_2leID3tMN8hpvVd4XhEqTl",
				radioOption: "FJIE5E2gciCA8q3Jzvcyg",
				pencil: "_3H_wwe03-Fkrm6oWGakXI8",
				searchBoxWrapper: "_18cuM8Uu7RcIFu1bCT0r4t",
				searchIcon: "_2bECVWL_WJ9RGBx7-RnzfO",
				searchInput: "_1nQbRaoAvb6Uy0oI-OfDtZ"
			}
		},
		"./src/reddit/components/FlairSearch/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2AKP6aCod0Z6TuXXfc1ZqL",
				buttonsRow: "_3w7b_fPwMuVD17J7epjTXi",
				clearButton: "_3WykjMvdVO5xibqd5xlfTC",
				flairEditSection: "SVd7IxchgiWetdYbftTHx",
				editLabel: "KTa3kg9lzGPUeLuhAHMT_",
				restrictionHintText: "_1fV9kJfKnED9qQ2AF8f3iT"
			}
		},
		"./src/reddit/components/FlairSearch/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/memoizeByReference/index.ts"),
				l = n("./src/reddit/featureFlags/index.ts"),
				u = n("./src/reddit/helpers/flair.ts"),
				m = n("./src/reddit/helpers/trackers/userFlair.ts"),
				p = n("./src/reddit/hooks/useTracking.ts"),
				h = n("./src/reddit/selectors/moderatorPermissions.ts"),
				b = n("./src/reddit/components/FlairSearch/FlairEdit/helper.tsx"),
				f = n("./src/reddit/components/Flair/index.tsx"),
				g = n("./src/reddit/components/TrackingHelper/index.tsx"),
				v = n("./src/reddit/controls/RadioInput/index.tsx"),
				C = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				y = n("./src/reddit/helpers/trackers/postComposer.ts"),
				E = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				x = n("./src/reddit/icons/svgs/Search/index.tsx"),
				O = n("./src/reddit/components/FlairSearch/FlairTemplateList/index.m.less"),
				_ = n.n(O);
			class k extends s.a.Component {
				constructor() {
					super(...arguments), this.state = {
						searchQuery: ""
					}, this.onSearchChange = e => {
						this.setState({
							searchQuery: e.target.value
						})
					}, this.onSearchClick = () => {
						this.props.sendEvent(Object(y.n)())
					}
				}
				render() {
					const {
						templates: e,
						templateIds: t,
						selectedTemplateId: n
					} = this.props, {
						searchQuery: r
					} = this.state, i = t.map(t => e[t]).filter(e => e.text.toLowerCase().includes(r)), a = !!n && i.some(e => e.id === n);
					return s.a.createElement("div", {
						className: _.a.container
					}, s.a.createElement("div", {
						className: _.a.searchBoxWrapper
					}, s.a.createElement("input", {
						className: _.a.searchInput,
						onChange: this.onSearchChange,
						onClick: this.onSearchClick,
						type: "text",
						placeholder: o.fbt._("Search for flair", null, {
							hk: "jQdqA"
						}),
						value: r
					}), s.a.createElement(x.a, {
						className: _.a.searchIcon
					})), s.a.createElement(v.a, {
						name: "flair_picker",
						onChange: this.props.onChange,
						value: n
					}, i.map((e, t) => {
						const o = Object(u.c)(e),
							r = n === e.id || !a && 0 === t;
						return s.a.createElement(C.a, {
							className: _.a.radioOption,
							key: e.id,
							showButton: !0,
							tabIndex: r ? 0 : -1,
							value: e.id
						}, s.a.createElement(f.c, {
							className: _.a.flairComponent,
							flair: o,
							forceSmallEmojis: !0
						}), e.textEditable && s.a.createElement(E.a, {
							className: _.a.pencil
						}))
					})))
				}
			}
			var j = Object(g.c)(k),
				S = n("./src/reddit/components/FlairSearch/index.m.less"),
				T = n.n(S);
			const w = Object(d.a)(e => e && Object(u.c)(e)),
				I = Object(a.c)({
					areFlairRestrictionsEnabled: l.d.flairRestrictions,
					isModerator: h.g
				}),
				P = Object(i.b)(I);
			t.a = P(e => {
				const {
					flairTemplateType: t,
					flair: n,
					className: r,
					onChange: i,
					subredditId: a,
					templates: d,
					templateIds: l,
					areFlairRestrictionsEnabled: h,
					isModerator: f
				} = e, g = Object(p.a)(), v = d && n && n.templateId && d[n.templateId] || void 0, C = Object(b.a)(), y = n || w(v);
				return s.a.createElement("div", {
					className: Object(c.a)(r, T.a.container)
				}, d && l && s.a.createElement(j, {
					flairTemplateType: t,
					onChange: e => {
						if (d) {
							const t = d[e],
								n = Object(u.c)(t);
							g(Object(m.b)({
								userFlair: t
							})), i(n)
						}
					},
					selectedTemplateId: v ? v.id : "",
					templateIds: l,
					templates: d
				}), y && v && (f || v.textEditable) && s.a.createElement("div", {
					className: T.a.flairEditSection
				}, s.a.createElement("div", {
					className: T.a.editLabel
				}, o.fbt._("Edit flair", null, {
					hk: "1APWWu"
				})), h && s.a.createElement("div", {
					className: T.a.restrictionHintText
				}, Object(u.k)(v)), s.a.createElement(C, {
					autofocus: !0,
					emojiPickerId: "FlairSearch-EmojiPicker-DropdownId",
					flair: y,
					flairTemplate: v,
					flairTemplateType: t,
					isFlairModOnly: v.modOnly,
					onChange: e => {
						const t = d && e.templateId ? d[e.templateId] : void 0;
						let n = e;
						t && (n = Object(u.d)({
							flair: e,
							template: t,
							ignoreTextAllowance: !0
						})), i(n)
					},
					subredditId: a
				})))
			})
		},
		"./src/reddit/components/FlairWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				flairList: "lrzZ8b0L6AzLkQj5Ww7H1",
				flairWrapper: "_2fiIRtMpITeCAzXc4cANKp",
				flairNoWrap: "_2xu1HuBz1Yx6SP10AGVx_I"
			}
		},
		"./src/reddit/components/FlairWrapper/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return E
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/components/FlairList/index.tsx"),
				l = n("./src/reddit/components/PostTitle/getLeftAndRightFlair.ts"),
				u = n("./src/reddit/components/SearchResultsContent/searchResultsPageTreatment/searchIgnoreClickContext.ts"),
				m = n("./src/reddit/contexts/PageLayer/index.tsx"),
				p = n("./src/reddit/helpers/correlationIdTracker.ts"),
				h = n("./src/reddit/helpers/trackers/postFlair.ts"),
				b = n("./src/reddit/models/Flair/index.ts"),
				f = n("./src/reddit/selectors/postFlair.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				v = n("./src/reddit/components/FlairWrapper/index.m.less"),
				C = n.n(v);
			const y = Object(i.b)(() => Object(a.c)({
					flairPosition: (e, t) => {
						let {
							pageLayer: n
						} = t;
						return Object(m.r)(e, {
							pageLayer: n
						})
					},
					isPostFlairEnabled: (e, t) => Object(f.c)(e, {
						subredditId: t.post.belongsTo.id
					}),
					subredditName: (e, t) => {
						let {
							post: n
						} = t;
						return Object(g.X)(e, {
							subredditId: n.belongsTo.id
						}).name
					}
				})),
				E = e => {
					const t = [];
					return e.isOriginalContent && t.push({
						text: o.fbt._("OC", null, {
							hk: "1i721p"
						}),
						type: b.f.Oc
					}), e.isMeta && t.push({
						text: o.fbt._("Poll", null, {
							hk: "1scdU1"
						}),
						type: b.f.Meta
					}), t.push(...e.flair), t
				};
			t.a = y(e => {
				let {
					className: t,
					disableFlair: n,
					flairPosition: o,
					isFlairFilter: r,
					isPostFlairEnabled: i,
					nowrap: a,
					post: m,
					sendEvent: f,
					subredditName: g,
					titleFlair: v
				} = e;
				const y = Object(u.a)(),
					x = o === b.b.Left,
					O = v || E(m),
					{
						leftFlair: _,
						rightFlair: k
					} = Object(l.a)({
						flair: O,
						isFlairPositionedLeft: x
					}),
					j = a ? C.a.flairNoWrap : _.length > 0 || k.length > 0 ? C.a.flairWrapper : null,
					S = e => {
						const t = {
							id: m.belongsTo.id,
							eventType: m.belongsTo.type,
							originElement: "post_flair",
							postFlairName: e
						};
						Object(p.d)(p.a.SearchResults), f && f(Object(h.a)(m.id, t))
					},
					T = e => {
						Object(p.d)(p.a.SearchResults), f && f(Object(h.e)(e, m.id))
					},
					w = !(n || !O || !O.length);
				return w ? s.a.createElement("div", {
					className: Object(c.a)(j, t),
					"data-ignore-click": y
				}, w && _ && s.a.createElement(d.a, {
					className: C.a.flairList,
					isFlairFilter: r,
					key: "leftFlair",
					onClick: S,
					onMouseDown: T,
					flair: _,
					disabled: !i,
					subredditName: g
				}), w && s.a.createElement(d.a, {
					className: C.a.flairList,
					isFlairFilter: r,
					key: "rightFlair",
					onClick: S,
					onMouseDown: T,
					flair: k,
					disabled: !i,
					subredditName: g
				})) : null
			})
		},
		"./src/reddit/components/FocusableContent/index.m.less": function(e, t, n) {
			e.exports = {
				FocusableContent: "_3MknXZVbkWU8JL9XGlzASi",
				focusableContent: "_3MknXZVbkWU8JL9XGlzASi",
				isFocused: "_3F2J0fSnCI3ZvF_tBSaV0s",
				noBorder: "_1CpUVAt2tGEwaaBV3nZNJs"
			}
		},
		"./src/reddit/components/FocusableContent/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/FocusableContent/index.m.less"),
				c = n.n(a);
			t.a = i.a.wrapped(e => r.a.createElement("div", {
				className: Object(s.a)(e.className, {
					[c.a.isFocused]: e.isFocused,
					[c.a.noBorder]: e.noBorder
				})
			}, e.children), "FocusableContent", c.a)
		},
		"./src/reddit/components/Governance/PollHelpText/index.m.less": function(e, t, n) {
			e.exports = {
				pollHelpText: "_13USlqK0GlZqaPCBL0zKGR",
				decisionThreholdAmount: "_2c1NZvJKkI6yBivC77FPD4",
				decisionThresholdTitle: "_3awYIQIHL4ztIb5nZDL46P",
				decisionThresholdExplanation: "_1GSbrVpv76_yXM2VcUM3zK"
			}
		},
		"./src/reddit/components/Governance/ProposalTemplates/Generic/index.m.less": function(e, t, n) {
			e.exports = {
				hintText: "_1iTDa11Wj-8Ogp0kHlXhus",
				text: "_3Q86vH6B2mMSV8rHtZq4H9",
				topline: "_12_7Q434C71LJVJC_6GX71"
			}
		},
		"./src/reddit/components/Governance/ProposalTemplates/Spinoff/index.m.less": function(e, t, n) {
			e.exports = {
				input: "_2clkG943bEk_52p-4FBzwJ"
			}
		},
		"./src/reddit/components/Governance/ProposalTemplates/TopModReplacement/index.m.less": function(e, t, n) {
			e.exports = {
				input: "AyMlaMkumG28uV6ZIz9ed"
			}
		},
		"./src/reddit/components/Governance/Token/index.m.less": function(e, t, n) {
			e.exports = {
				grey: "_3oUx7R2UEz3llZLsIONH4x"
			}
		},
		"./src/reddit/components/Governance/Token/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/config.ts"),
				c = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/selectors/crypto/points.ts"),
				l = n("./src/reddit/components/Governance/Token/index.m.less"),
				u = n.n(l);
			const m = Object(i.c)({
				pointsDetails: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(d.b)(e, n)
				}
			});
			t.a = Object(s.b)(m)((function(e) {
				var t;
				const n = null === (t = e.pointsDetails) || void 0 === t ? void 0 : t.images;
				if (!n) return null;
				const o = e.grey ? n.greyVector || n.grey : n.filledVector || n.filled,
					s = `${a.a.assetPath}/${o}`;
				if (e.grey && s.endsWith(".svg")) {
					const t = `url(${s}) center/cover`;
					return r.a.createElement("div", {
						className: Object(c.a)(u.a.grey, e.className),
						style: {
							mask: t,
							WebkitMask: t
						}
					})
				}
				return r.a.createElement("img", {
					className: e.className,
					src: s
				})
			}))
		},
		"./src/reddit/components/Governance/TokenAmount/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1_TXyD8cel36iFhXWbXulM",
				small: "_1MnpXAw_e6q3FjPvZfRITL",
				token: "_3ugCwJ_lmINM5PwXoNm8XD"
			}
		},
		"./src/reddit/components/Governance/TokenAmount/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/prettyPrintNumber/index.ts"),
				d = n("./src/reddit/components/Governance/Token/index.tsx"),
				l = n("./src/reddit/helpers/governance/tokens.ts"),
				u = n("./src/reddit/selectors/crypto/points.ts"),
				m = n("./src/reddit/components/Governance/TokenAmount/index.m.less"),
				p = n.n(m);
			const h = Object(i.c)({
				pointsDetails: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(u.b)(e, n)
				}
			});
			t.a = Object(s.b)(h)((function(e) {
				var t;
				return r.a.createElement("div", {
					className: Object(a.a)(p.a.container, e.className, {
						[p.a.small]: e.small
					})
				}, r.a.createElement(d.a, {
					className: Object(a.a)(p.a.token, {
						[p.a.small]: e.small
					}),
					grey: e.grey,
					subredditId: e.subredditId
				}), Object(c.a)(Object(l.c)(e.amount, null === (t = e.pointsDetails) || void 0 === t ? void 0 : t.displayConversion)), e.additionalText || null)
			}))
		},
		"./src/reddit/components/Hovercards/SubredditHovercard/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./src/higherOrderComponents/makeAsync.tsx"),
				r = n("./src/lib/loadWithRetries/index.ts");
			const s = () => null;
			t.a = Object(o.a)({
				ErrorComponent: s,
				getComponent: () => Object(r.a)(() => n.e("SubredditHovercard").then(n.bind(null, "./src/reddit/components/Hovercards/SubredditHovercard/_SubredditHovercard.tsx"))).then(e => e.default),
				LoadingComponent: s
			})
		},
		"./src/reddit/components/HumanDate/HumanDate.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/humanizeDate/index.ts"),
				i = n("./src/reddit/hooks/useLocale.ts");
			t.a = function(e) {
				let {
					seconds: t,
					...n
				} = e;
				var o;
				const a = Object(i.a)(),
					c = {
						...n,
						locale: null !== (o = n.locale) && void 0 !== o ? o : a
					};
				return r.a.createElement(r.a.Fragment, null, Object(s.a)(t, c))
			}
		},
		"./src/reddit/components/HumanDate/HumanDateTime.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				i = n("./src/lib/constants/index.ts");
			var a = n("./src/reddit/hooks/useLocale.ts");
			t.a = function(e) {
				let {
					seconds: t,
					locale: n
				} = e;
				const o = Object(a.a)(),
					c = null != n ? n : o;
				return r.a.createElement(r.a.Fragment, null, function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : s.DEFAULT_LOCALE;
					const n = e * i.Xb;
					return new Date(n).toLocaleString(t, {
						weekday: "short",
						month: "short",
						year: "numeric",
						day: "2-digit",
						hour: "2-digit",
						minute: "2-digit",
						second: "2-digit",
						timeZoneName: "long"
					})
				}(t, c))
			}
		},
		"./src/reddit/components/HumanDate/TimeAgo.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/timeAgo/index.ts"),
				i = n("./src/reddit/hooks/useLocale.ts");
			t.a = function(e) {
				let {
					seconds: t,
					...n
				} = e;
				var o;
				const a = Object(i.a)(),
					c = {
						...n,
						locale: null !== (o = n.locale) && void 0 !== o ? o : a
					};
				return r.a.createElement(r.a.Fragment, null, Object(s.d)(t, c))
			}
		},
		"./src/reddit/components/HumanDate/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return o.a
			})), n.d(t, "a", (function() {
				return r.a
			})), n.d(t, "b", (function() {
				return s.a
			})), n.d(t, "c", (function() {
				return b
			}));
			var o = n("./src/reddit/components/HumanDate/TimeAgo.tsx"),
				r = n("./src/reddit/components/HumanDate/HumanDate.tsx"),
				s = n("./src/reddit/components/HumanDate/HumanDateTime.tsx"),
				i = n("./node_modules/react/index.js"),
				a = n.n(i),
				c = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				d = n("./node_modules/fbt/lib/FbtPublic.js"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/lib/eventTools/index.ts");

			function m(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : c.DEFAULT_LOCALE;
				return e.toLocaleDateString(t, {
					month: "numeric",
					day: "numeric"
				})
			}

			function p(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
					o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : c.DEFAULT_LOCALE;
				const r = Object(u.e)(e, t),
					s = new Date(e * l.Xb);
				let i;
				if (r === u.a.Live || n) return d.fbt._("Now", null, {
					hk: "Prpcg"
				});
				return r === u.a.Future ? i = Object(u.d)(e) ? d.fbt._("Today", null, {
					hk: "1sZpnp"
				}).toString() : Object(u.b)(e) >= 5 ? m(s, o) : function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : c.DEFAULT_LOCALE;
					return e.toLocaleDateString(t, {
						weekday: "long"
					})
				}(s, o) : r === u.a.Past && (i = Object(u.d)(e) ? d.fbt._("Today", null, {
					hk: "1sZpnp"
				}).toString() : m(s, o)), `${i} @ ${function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.DEFAULT_LOCALE;return e.toLocaleTimeString(t,{hour12:!0,hour:"numeric",minute:"2-digit"}).replace(/ /g,"").toUpperCase()}(s,o)}`
			}
			var h = n("./src/reddit/hooks/useLocale.ts");
			var b = function(e) {
				let {
					startTime: t,
					endTime: n,
					isLive: o,
					locale: r
				} = e;
				const s = Object(h.a)(),
					i = null != r ? r : s;
				return a.a.createElement(a.a.Fragment, null, p(t, n, o, i))
			};
			n("./src/lib/humanizeUTCDate/index.tsx")
		},
		"./src/reddit/components/IdCard/async.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(o.a)({
				resolved: {},
				chunkName: () => "IdCard",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("IdCard").then(n.bind(null, "./src/reddit/components/IdCard/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/IdCard/index.tsx"
				}
			})
		},
		"./src/reddit/components/InfoBanners/BannerBase/index.m.less": function(e, t, n) {
			e.exports = {
				IconWrapper: "_2p07tPrx9WpxDTQJ5cmVNe",
				iconWrapper: "_2p07tPrx9WpxDTQJ5cmVNe",
				TextWrapper: "_2jpm-rNr0Hniw6BX3NWMVe",
				textWrapper: "_2jpm-rNr0Hniw6BX3NWMVe",
				leftSideRectangle: "_3TLlMYjrPH9Kl9522LpSxb",
				wrapper: "_1DUKbp8va6vxOv9zemBDBi",
				subtitle: "_2J85dtk0HKQBLk8HTSWduv",
				title: "Nt8TnDvJ2BsL8KWcFQKy5"
			}
		},
		"./src/reddit/components/InfoBanners/BannerBase/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/InfoBanners/BannerBase/index.m.less"),
				a = n.n(i),
				c = n("./src/lib/lessComponent.tsx");
			const d = c.a.div("IconWrapper", a.a),
				l = c.a.div("TextWrapper", a.a);

			function u(e) {
				const {
					className: t,
					color: n,
					icon: o,
					subtitle: i,
					title: c,
					textWrapperClassName: u
				} = e;
				return r.a.createElement("div", {
					className: Object(s.a)(t, a.a.wrapper),
					style: n && {
						borderColor: n
					} || {}
				}, r.a.createElement("div", {
					className: a.a.leftSideRectangle,
					style: n && {
						backgroundColor: n
					} || {}
				}), o ? r.a.createElement(d, null, o) : r.a.createElement(d, null), r.a.createElement(l, {
					className: u
				}, r.a.createElement("div", {
					className: a.a.title
				}, c), i && r.a.createElement("div", {
					className: a.a.subtitle
				}, i)))
			}
		},
		"./src/reddit/components/InfoTextTooltip/Hooked.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/InfoTextTooltip/hooked.m.less"),
				a = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = r.a.memo((function(e) {
				let {
					visible: t,
					...n
				} = e;
				const [i, d] = Object(o.useState)(t);
				return Object(o.useEffect)(() => {
					let e = window.setTimeout(() => {
						e = void 0, d(t)
					}, 0);
					return () => {
						e && window.clearTimeout(e), d(!1)
					}
				}, [t]), t ? r.a.createElement("div", c({
					className: Object(s.a)(a.a.tooltip, n.className, {
						[a.a.visible]: i
					})
				}, n.popperProps), n.children, i && r.a.createElement("div", c({
					className: a.a.arrow
				}, n.arrowProps))) : null
			}))
		},
		"./src/reddit/components/InfoTextTooltip/hooked.m.less": function(e, t, n) {
			e.exports = {
				arrow: "_1jsc29CjRXZWjd2tr0Ji0Y",
				tooltip: "_2J_zB4R1FH2EjGMkQjedwc",
				visible: "u6HtAZu8_LKL721-EnKuR"
			}
		},
		"./src/reddit/components/InfoTextTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				BottomText: "_3uK2I0hi3JFTKnMUFHD2Pd",
				bottomText: "_3uK2I0hi3JFTKnMUFHD2Pd",
				Text: "HQ2VJViRjokXpRbJzPvvc",
				text: "HQ2VJViRjokXpRbJzPvvc",
				"fade-in": "_1tIZttmhLdrIGrB-6VvZcT",
				fadeIn: "_1tIZttmhLdrIGrB-6VvZcT"
			}
		},
		"./src/reddit/components/InfoTextTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/higherOrderComponents/addOverlayEvents.tsx"),
				c = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				d = n("./src/reddit/selectors/tooltip.ts"),
				l = n("./src/reddit/components/InfoTextTooltip/index.m.less"),
				u = n.n(l),
				m = n("./src/lib/lessComponent.tsx");

			function p() {
				return (p = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const h = m.a.div("Text", u.a),
				b = m.a.div("BottomText", u.a),
				f = e => r.a.createElement(h, {
					className: e.className,
					style: e.style
				}, e.text, e.children),
				g = e => {
					const t = e.overflow ? e.overflow.left : 0;
					return r.a.createElement(b, {
						className: e.className,
						style: {
							...e.style,
							"--infoTextTooltip-overflow-left": `${t}px`
						}
					}, e.text, e.children)
				},
				v = Object(i.c)({
					isOpen: (e, t) => {
						let {
							tooltipId: n
						} = t;
						return Object(d.b)(n)(e)
					}
				}),
				C = Object(c.a)(g, [a.a.Click, a.a.Keydown]),
				y = Object(c.a)(f, [a.a.Click, a.a.Keydown]),
				E = Object(s.b)(v);
			t.c = E(e => {
				const {
					caretOnTop: t
				} = e;
				return t ? r.a.createElement(C, p({}, e, {
					targetPosition: ["center", "bottom"],
					tooltipPosition: ["center", "top"]
				})) : r.a.createElement(y, p({}, e, {
					targetPosition: ["center", "top"],
					tooltipPosition: ["center", "bottom"]
				}))
			})
		},
		"./src/reddit/components/JumpToContent/index.m.less": function(e, t, n) {
			e.exports = {
				button: "_3KaTO_3YaHK3SMocnu8jV9",
				rightBorder: "_1Bt_cwKVUG30M9eNB-9rU4",
				rightBorderExp: "d2l2sN1D4PNVkzMmwALA2",
				wrapper: "_32Xa3voy05uAFz3ZnopP_S",
				wrapperExp: "_1C67uwkUf95iJOZ63vDJOZ"
			}
		},
		"./src/reddit/components/JumpToContent/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return h
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/constants/componentSizes.ts"),
				c = n("./src/reddit/contexts/NavbarExp.ts"),
				d = n("./src/reddit/controls/Button/index.tsx"),
				l = n("./src/reddit/components/JumpToContent/index.m.less"),
				u = n.n(l);
			const m = Object(r.createContext)(null),
				p = Object(r.createContext)(null);
			class h extends s.a.Component {
				constructor() {
					super(...arguments), this.state = {
						handleRef: null
					}, this.setHandleRef = e => {
						this.state.handleRef !== e && this.setState({
							handleRef: e
						})
					}
				}
				render() {
					return s.a.createElement(m.Provider, {
						value: this.props.isOverlayOpen ? null : this.state.handleRef
					}, s.a.createElement(p.Provider, {
						value: this.setHandleRef
					}, this.props.children))
				}
			}
			const b = a.f + 10,
				f = s.a.memo(() => {
					const [e, t] = Object(r.useState)("-500px"), n = Object(r.useContext)(c.a);
					return s.a.createElement(m.Consumer, null, r => r && s.a.createElement("div", {
						className: Object(i.a)(u.a.wrapper, {
							[u.a.wrapperExp]: n
						}),
						"data-testid": "jump-to-content"
					}, s.a.createElement(d.t, {
						kind: d.b.Button,
						priority: d.c.Plain,
						className: u.a.button,
						style: {
							marginLeft: e
						},
						onBlur: e => {
							const n = e.currentTarget.clientWidth + 55;
							t(`-${n}px`)
						},
						onFocus: () => {
							t("0")
						},
						onClick: () => {
							r.focus(), r.scrollIntoView(), window.scrollBy(0, -b)
						}
					}, o.fbt._("Jump to content", null, {
						hk: "2zWOmQ"
					})), s.a.createElement("div", {
						className: Object(i.a)(u.a.rightBorder, {
							[u.a.rightBorderExp]: n
						})
					})))
				}),
				g = s.a.memo(() => s.a.createElement(p.Consumer, null, e => s.a.createElement("div", {
					ref: e,
					tabIndex: 0
				})))
		},
		"./src/reddit/components/LinkOrOverlayLink/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				i = n("./src/reddit/controls/UnstyledInternalLink/index.tsx"),
				a = n("./src/reddit/helpers/overlay/index.ts");

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}

			function d(e) {
				const {
					children: t,
					className: n,
					to: o,
					...s
				} = e, d = Object(a.b)(o);
				return r.a.createElement(i.a, c({
					className: n,
					to: d
				}, s), t)
			}

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				const {
					isOverlay: t,
					...n
				} = e, o = t ? d : s.a;
				return r.a.createElement(o, l({}, n, {
					className: n.className,
					onClick: n.onClick,
					to: n.to
				}), n.children)
			}
		},
		"./src/reddit/components/MakeGifToggle/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1iRy5EPCLqSx8I0k9OT0wW",
				content: "NfjQg3srQXRhyOxLBwXrS",
				toggleSwitch: "_1fUmirx6e9tUDs04TQq6A1",
				mCompactSwitch: "_3Cx_YBpXo1s1iy7oA-4s6R",
				mDisabled: "_1M5N6DrrQQCQJs3JctDSu8",
				hoverTooltip: "_9qS60cx9uxyt1k4eZF_0w",
				tooltipContentClass: "_21DP8j-B-UkVKGJONbrTmX"
			}
		},
		"./src/reddit/components/MakeGifToggle/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				c = n("./src/reddit/controls/ToggleSwitch/index.tsx"),
				d = n("./src/reddit/layout/row/Inline/index.tsx"),
				l = n("./src/reddit/components/MakeGifToggle/index.m.less"),
				u = n.n(l);
			t.a = e => s.a.createElement(d.a, {
				className: Object(i.a)(u.a.container, e.disabled ? u.a.mDisabled : null, e.isCompact ? u.a.mCompactSwitch : null),
				onMouseDown: e => e.preventDefault(),
				onClick: t => {
					t.stopPropagation(), !e.disabled && e.onClick()
				}
			}, s.a.createElement(d.a, {
				className: u.a.content
			}, s.a.createElement(c.a, {
				className: u.a.toggleSwitch,
				on: e.on
			}), s.a.createElement("label", null, o.fbt._("Make GIF", null, {
				hk: "2ig2GG"
			}))), e.tooltip ? s.a.createElement(a.a, {
				className: u.a.hoverTooltip,
				tooltipContentClass: u.a.tooltipContentClass,
				text: e.tooltip
			}) : null)
		},
		"./src/reddit/components/MarkdownHelp/index.m.less": function(e, t, n) {
			e.exports = {
				Section: "_1gF-JM2Md5QrEmUiEkRvLZ",
				section: "_1gF-JM2Md5QrEmUiEkRvLZ",
				Container: "C8uCM4XqGMA6xiIu7zfJl",
				container: "C8uCM4XqGMA6xiIu7zfJl",
				helpTable: "_3E7k-M4lVIYGW6Z7QoiPc9",
				Table: "_1t5z5ubOp-UUzTGLJr43d0",
				table: "_1t5z5ubOp-UUzTGLJr43d0",
				P: "_3MhMubukVABghyvZNN2X65",
				p: "_3MhMubukVABghyvZNN2X65"
			}
		},
		"./src/reddit/components/MarkdownHelp/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return y
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/components/FlairPickerTitle/index.tsx"),
				c = n("./src/reddit/components/FlairPickerWrapper/index.tsx"),
				d = n("./src/reddit/components/RichTextJson/elements.tsx"),
				l = n("./src/reddit/components/RichTextJson/SpoilerText.tsx"),
				u = n("./src/reddit/components/TrackingHelper/index.tsx"),
				m = n("./src/higherOrderComponents/asModal/index.tsx"),
				p = n("./src/reddit/actions/modal.ts"),
				h = n("./src/reddit/controls/Button/index.tsx"),
				b = n("./src/reddit/layout/row/Inline/index.tsx"),
				f = n("./src/reddit/layout/row/RightAlign/index.tsx"),
				g = n("./src/reddit/components/MarkdownHelp/index.m.less"),
				v = n.n(g),
				C = n("./src/lib/lessComponent.tsx");
			const y = "Markdown_Help__Modal",
				E = C.a.wrapped(b.a, "Section", v.a),
				x = C.a.div("Container", v.a),
				O = C.a.table("Table", v.a),
				_ = C.a.p("P", v.a);
			class k extends s.a.Component {
				render() {
					const e = o.fbt._("italics", null, {
							hk: "9wBJ9"
						}),
						t = o.fbt._("bold", null, {
							hk: "yoD2u"
						}),
						n = o.fbt._("item", null, {
							hk: "20ZnoS"
						}),
						r = o.fbt._("quoted text", null, {
							hk: "1Lvb4b"
						}),
						i = o.fbt._("strikethrough", null, {
							hk: "UcaLr"
						}),
						u = o.fbt._("spoilers", null, {
							hk: "372XyC"
						});
					return s.a.createElement(c.a, null, s.a.createElement(a.a, {
						onClosePressed: this.props.closeModal,
						title: o.fbt._("Markdown Help", null, {
							hk: "w08E2"
						})
					}), s.a.createElement(x, null, s.a.createElement(O, {
						className: v.a.helpTable
					}, s.a.createElement("tr", null, s.a.createElement(d.s, null, s.a.createElement(d.j, null, o.fbt._("Type this:", null, {
						hk: "VDjXQ"
					}))), s.a.createElement(d.s, null, s.a.createElement(d.j, null, o.fbt._("to get this:", null, {
						hk: "4zlZi9"
					})))), s.a.createElement("tr", null, s.a.createElement(d.p, null, s.a.createElement(d.j, null, "*", e, "*")), s.a.createElement(d.p, null, s.a.createElement(d.f, null, e))), s.a.createElement("tr", null, s.a.createElement(d.p, null, s.a.createElement(d.j, null, "**", t, "**")), s.a.createElement(d.p, null, s.a.createElement(d.b, null, t))), s.a.createElement("tr", null, s.a.createElement(d.p, null, s.a.createElement(d.j, null, "[reddit!](https://reddit.com)")), s.a.createElement(d.p, null, s.a.createElement(d.a, {
						href: "https://www.reddit.com"
					}, "reddit!"))), s.a.createElement("tr", null, s.a.createElement(d.p, null, s.a.createElement(d.j, null, "* ", n, " 1"), s.a.createElement(d.j, null, "* ", n, " 2"), s.a.createElement(d.j, null, "* ", n, " 3")), s.a.createElement(d.p, null, s.a.createElement(d.v, null, s.a.createElement(d.g, null, n, " 1"), s.a.createElement(d.g, null, n, " 2"), s.a.createElement(d.g, null, n, " 3")))), s.a.createElement("tr", null, s.a.createElement(d.p, null, s.a.createElement(d.j, null, "> ", r)), s.a.createElement(d.p, null, s.a.createElement(d.c, null, r))), s.a.createElement("tr", null, s.a.createElement(d.p, null, s.a.createElement(d.j, null, "~~", i, "~~")), s.a.createElement(d.p, null, s.a.createElement(d.d, null, i))), s.a.createElement("tr", null, s.a.createElement(d.p, null, s.a.createElement(d.j, null, o.fbt._("super^script", null, {
						hk: "2WteOp"
					}))), s.a.createElement(d.p, null, o.fbt._("super{=script}", [o.fbt._param("=script", s.a.createElement(d.m, null, o.fbt._("script", null, {
						hk: "4a2qMi"
					})))], {
						hk: "1VvC4z"
					}))), s.a.createElement("tr", null, s.a.createElement(d.p, null, s.a.createElement(d.j, null, `>!${u}!<`)), s.a.createElement(d.p, null, s.a.createElement(l.a, null, u)))), s.a.createElement(_, null, o.fbt._("Check the {=commenting wiki page} for more help", [o.fbt._param("=commenting wiki page", s.a.createElement(d.a, {
						href: "https://www.reddit.com/wiki/commenting"
					}, o.fbt._("commenting wiki page", null, {
						hk: "25UBE"
					})))], {
						hk: "1J9oBy"
					}))), s.a.createElement(E, null, s.a.createElement(f.a, null, s.a.createElement(h.l, {
						onClick: this.props.closeModal,
						"data-redditstyle": !0
					}, o.fbt._("Close", null, {
						hk: "4gbyAA"
					})))))
				}
			}
			const j = Object(i.b)(null, (e, t) => ({
				closeModal: () => e(Object(p.i)(y))
			}))(k);
			t.a = Object(m.a)(Object(u.c)(j))
		},
		"./src/reddit/components/ModalStyledComponents/index.m.less": function(e, t, n) {
			e.exports = {
				CloseIcon: "_3XSQHPxjCTSWWZh_u-d0Xf",
				closeIcon: "_3XSQHPxjCTSWWZh_u-d0Xf",
				ModalBody: "_2R3RlhymCOkPrz9TusvcPq",
				modalBody: "_2R3RlhymCOkPrz9TusvcPq",
				ModalPostPreview: "HydQQ-TD4TUsVnxkYk_5F",
				modalPostPreview: "HydQQ-TD4TUsVnxkYk_5F",
				ModalText: "mFTHPdbEAklUs8yhT4Xm7",
				modalText: "mFTHPdbEAklUs8yhT4Xm7",
				ModalSmallText: "_3cwQrg-XvocnoG0U22wT8t",
				modalSmallText: "_3cwQrg-XvocnoG0U22wT8t",
				ModalDescriptionText: "_12g_PUGHD-w7T1w4Q3oTsq",
				modalDescriptionText: "_12g_PUGHD-w7T1w4Q3oTsq",
				ModalMetaText: "_27eskYssCs-urVW1uHI4YI",
				modalMetaText: "_27eskYssCs-urVW1uHI4YI",
				ModalFormItem: "_3xiY8nTCVp16qSb6CGW2Kv",
				modalFormItem: "_3xiY8nTCVp16qSb6CGW2Kv",
				ModalInput: "_20ZSV7ktyDYzPcd1UMQWZT",
				modalInput: "_20ZSV7ktyDYzPcd1UMQWZT",
				ModalInputLabel: "HVADn-LHFLaS8r6IBJWeq",
				modalInputLabel: "HVADn-LHFLaS8r6IBJWeq",
				ModalFooter: "_-0i7atRJ5NBsrRM5wuPpX",
				modalFooter: "_-0i7atRJ5NBsrRM5wuPpX",
				ModalHeader: "_1Fa5Xv7f16v5IC2Tq1m2Fy",
				modalHeader: "_1Fa5Xv7f16v5IC2Tq1m2Fy",
				ModalTitle: "eLnlHLGCDxjFf3jfGTcZu",
				modalTitle: "eLnlHLGCDxjFf3jfGTcZu",
				ModalMain: "_1uaasV6RaxBfRyVgQJdiKs",
				modalMain: "_1uaasV6RaxBfRyVgQJdiKs",
				ModalAnnotation: "gLlWG7Oj89Ost4_twUu8w",
				modalAnnotation: "gLlWG7Oj89Ost4_twUu8w",
				TextArea: "_2h8O7PjrCXfaJJWKrAxJPL",
				textArea: "_2h8O7PjrCXfaJJWKrAxJPL",
				WarningButton: "_17UyTSs2atqnKg9dIq5ERg",
				warningButton: "_17UyTSs2atqnKg9dIq5ERg",
				PrimaryButton: "_2X1FFYUx3jzlnbcegBC_Sr",
				primaryButton: "_2X1FFYUx3jzlnbcegBC_Sr",
				CancelButton: "_1QUX9-zZuGtifS6jJBUyh-",
				cancelButton: "_1QUX9-zZuGtifS6jJBUyh-",
				RemoveButton: "_2ulRgczjI5SWCMgSA1CNLj",
				removeButton: "_2ulRgczjI5SWCMgSA1CNLj",
				ConfirmButton: "JZC61-VzVuaiHdWuRUiSC",
				confirmButton: "JZC61-VzVuaiHdWuRUiSC"
			}
		},
		"./src/reddit/components/ModalStyledComponents/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "n", (function() {
				return b
			})), n.d(t, "p", (function() {
				return f
			})), n.d(t, "o", (function() {
				return g
			})), n.d(t, "f", (function() {
				return v
			})), n.d(t, "m", (function() {
				return C
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "j", (function() {
				return E
			})), n.d(t, "k", (function() {
				return x
			})), n.d(t, "g", (function() {
				return O
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "q", (function() {
				return k
			})), n.d(t, "d", (function() {
				return j
			})), n.d(t, "l", (function() {
				return S
			})), n.d(t, "t", (function() {
				return T
			})), n.d(t, "u", (function() {
				return w
			})), n.d(t, "r", (function() {
				return I
			})), n.d(t, "a", (function() {
				return P
			})), n.d(t, "s", (function() {
				return N
			})), n.d(t, "c", (function() {
				return R
			}));
			var o = n("./src/lib/classNames/index.ts"),
				r = n("./src/lib/lessComponent.tsx"),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./src/reddit/controls/Button/index.tsx"),
				c = n("./src/reddit/controls/Input/ModalInput.tsx"),
				d = n("./src/reddit/icons/svgs/Close/index.tsx"),
				l = n("./src/reddit/components/ModalStyledComponents/index.m.less"),
				u = n.n(l);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const p = r.a.wrapped(d.a, "CloseIcon", u.a),
				h = r.a.section("ModalBody", u.a),
				b = r.a.section("ModalPostPreview", u.a),
				f = r.a.p("ModalText", u.a),
				g = r.a.div("ModalSmallText", u.a),
				v = r.a.div("ModalDescriptionText", u.a),
				C = r.a.div("ModalMetaText", u.a),
				y = r.a.label("ModalFormItem", u.a),
				E = r.a.wrapped(c.a, "ModalInput", u.a),
				x = r.a.label("ModalInputLabel", u.a),
				O = r.a.footer("ModalFooter", u.a),
				_ = r.a.header("ModalHeader", u.a),
				k = r.a.div("ModalTitle", u.a),
				j = r.a.div("ModalAnnotation", u.a),
				S = r.a.div("ModalMain", u.a),
				T = r.a.textarea("TextArea", u.a),
				w = r.a.wrapped(a.l, "WarningButton", u.a),
				I = r.a.wrapped(a.l, "PrimaryButton", u.a),
				P = r.a.wrapped(a.o, "CancelButton", u.a),
				N = r.a.wrapped(a.r, "RemoveButton", u.a),
				R = e => {
					let {
						className: t,
						...n
					} = e;
					return i.a.createElement(a.t, m({
						kind: a.b.Button,
						priority: a.c.Primary,
						className: Object(o.a)(u.a.ConfirmButton, t)
					}, n))
				}
		},
		"./src/reddit/components/Onboarding/LanguageCollection/LanguageCollection.m.less": function(e, t, n) {
			e.exports = {
				LanguageRow: "_1uqw13duLAypklZz9JuxH5",
				languageRow: "_1uqw13duLAypklZz9JuxH5",
				Selected: "C0ynfBku9Az2wYA9j1_PA",
				selected: "C0ynfBku9Az2wYA9j1_PA",
				NightModeSelected: "_3JYkv3aRJq9WBVU_Qu_O3K",
				nightModeSelected: "_3JYkv3aRJq9WBVU_Qu_O3K",
				ButtonSection: "_2go248Acx87AyaspT-IqC3",
				buttonSection: "_2go248Acx87AyaspT-IqC3",
				SelectedIcon: "Nqikdy52FO7Ok8SC7YbBy",
				selectedIcon: "Nqikdy52FO7Ok8SC7YbBy",
				FrontFlex: "_3qzPnI-sCnXtXXzmiLCUzt",
				frontFlex: "_3qzPnI-sCnXtXXzmiLCUzt",
				TextSection: "_5Rt2rPaHLuyB5smTxh9cS",
				textSection: "_5Rt2rPaHLuyB5smTxh9cS",
				Placeholder: "_3gtRwVx6uS2xZaynYajI9O",
				placeholder: "_3gtRwVx6uS2xZaynYajI9O",
				Icon: "_1ym0rG9P61fqq5EGeggDEg",
				icon: "_1ym0rG9P61fqq5EGeggDEg",
				isLeft: "_1wilU6X1e2oYYu84p5M0Bn",
				isRight: "_1N6ONFJor0MYB1AANfCh8M",
				LanguageListButtons: "_2GUwrGUdKWdruRBy2ogOPv",
				languageListButtons: "_2GUwrGUdKWdruRBy2ogOPv",
				HeaderBarImproved: "sKUGLH9bgXYnkNvi71PD6",
				headerBarImproved: "sKUGLH9bgXYnkNvi71PD6",
				MoreLanguages: "_34OOuEVRtCgQHxTw6Bm_SM",
				moreLanguages: "_34OOuEVRtCgQHxTw6Bm_SM",
				PromptContainer: "_2NBWDPVfLgJchMUSilY9hq",
				promptContainer: "_2NBWDPVfLgJchMUSilY9hq",
				PromptClose: "_1D3-VzG8d-pAsDFC2aDEqX",
				promptClose: "_1D3-VzG8d-pAsDFC2aDEqX",
				Close: "Z2DAjXDKT-rjUoOgPeR9b",
				close: "Z2DAjXDKT-rjUoOgPeR9b",
				PromptTitle: "_6pr2vYjViLknuzg7J_4II",
				promptTitle: "_6pr2vYjViLknuzg7J_4II",
				PromptSubtitle: "_1j479fpdJDH2JNDpssXW8Z",
				promptSubtitle: "_1j479fpdJDH2JNDpssXW8Z",
				PromptRow: "piSYz03CLXLD5jdQwPjUy",
				promptRow: "piSYz03CLXLD5jdQwPjUy",
				Dismiss: "Fssd937Pdx1KOrc1lhBS5",
				dismiss: "Fssd937Pdx1KOrc1lhBS5"
			}
		},
		"./src/reddit/components/Onboarding/LanguageCollection/prompt.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/actions/eligibleUxExperiences/eligibleUxExperiences.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/components/Onboarding/LanguageCollection/LanguageCollection.m.less"),
				l = n.n(d),
				u = n("./src/reddit/constants/componentTestIds.ts"),
				m = n("./src/reddit/contexts/ApiContext.tsx"),
				p = n("./src/reddit/endpoints/onboarding/languageSelections.ts"),
				h = n("./src/reddit/constants/tracking.ts"),
				b = n("./src/reddit/selectors/telemetry.ts");
			const f = "bottom_sheet";
			var g;
			! function(e) {
				e.ADD = "add", e.LATER = "maybe_later", e.SKIP = "skip"
			}(g || (g = {}));
			var v = n("./src/reddit/hooks/useTracking.ts"),
				C = n("./src/reddit/icons/svgs/Close/index.tsx"),
				y = n("./src/reddit/models/Toast/index.ts"),
				E = n("./src/reddit/selectors/eligibleUXExperiences.ts"),
				x = n("./src/reddit/selectors/experiments/uxtsIntegration.ts"),
				O = n("./src/reddit/selectors/meta.ts"),
				_ = n("./src/redditGQL/types.ts");
			const {
				fbt: k
			} = n("./node_modules/fbt/lib/FbtPublic.js"), j = e => {
				const {
					gqlContext: t
				} = e, n = Object(s.d)(), d = Object(v.a)(), m = Object(s.e)(O.b), [E, x] = Object(o.useState)(!1), [j, S] = Object(o.useState)({}), [T, w] = Object(o.useState)({}), [I, P] = Object(o.useState)([]);
				let N = ["es"];
				const R = Object(o.useCallback)(async () => {
					const e = await Object(p.b)(t);
					e && (w(e.languages), P(e.preferences), x(!0))
				}, [t]);
				Object(o.useEffect)(() => {
					R()
				}, [R]);
				const M = e => {
						d("skip" === e ? (e => t => ({
							...Object(b.p)(t),
							source: f,
							action: h.c.CLICK,
							noun: g.SKIP,
							actionInfo: {
								...Object(b.d)(t),
								type: e
							}
						}))(m) : (e => t => ({
							...Object(b.p)(t),
							source: f,
							action: h.c.CLICK,
							noun: g.LATER,
							actionInfo: {
								...Object(b.d)(t),
								type: e
							}
						}))(m)), x(!1), n(Object(a.c)({
							experience: _.eb.LanguagePreferenceBottomSheet,
							value: !1
						}))
					},
					D = () => {
						const e = Object.keys(j).join();
						d(((e, t) => n => ({
							...Object(b.p)(n),
							source: f,
							action: h.c.CLICK,
							noun: g.ADD,
							actionInfo: {
								...Object(b.d)(n),
								reason: t,
								type: e
							}
						}))(m, e)), (async () => {
							var e;
							const o = j;
							I.map(e => o[e] = !0);
							const r = await Object(p.d)(t, o);
							(null === (e = null == r ? void 0 : r.updateSpokenLanguagesPreference) || void 0 === e ? void 0 : e.ok) ? n(Object(c.f)({
								kind: y.b.SuccessCommunity,
								text: k._("Changes saved", null, {
									hk: "2isjrZ"
								})
							})): n(Object(c.f)({
								kind: y.b.Error,
								text: k._("Changes failed to save. Try adding content languages in user settings", null, {
									hk: "2YYdoj"
								})
							}))
						})(), x(!1), n(Object(a.c)({
							experience: _.eb.LanguagePreferenceBottomSheet,
							value: !1
						}))
					};
				return N = N.filter(e => !I.includes(e)), E && 0 !== N.length ? (d((e => t => ({
					...Object(b.p)(t),
					source: f,
					action: h.c.VIEW,
					noun: h.b.SCREEN,
					actionInfo: {
						...Object(b.d)(t),
						type: e
					}
				}))(m)), n(Object(a.d)(_.eb.LanguagePreferenceBottomSheet)), r.a.createElement("div", {
					className: l.a.PromptContainer
				}, r.a.createElement("div", {
					className: l.a.PromptClose
				}, r.a.createElement(C.a, {
					className: l.a.Close,
					onClick: () => M("skip"),
					"data-testid": u.e
				})), r.a.createElement("div", {
					className: l.a.PromptTitle
				}, k._("See content in more languages", null, {
					hk: "4uyzS1"
				})), r.a.createElement("div", {
					className: l.a.PromptSubtitle
				}, k._("Update your settings to make it easier to discover content in multiple languages", null, {
					hk: "3VhB1c"
				})), 1 === N.length ? r.a.createElement("div", {
					className: l.a.PromptRow,
					onClick: () => (e => {
						const t = j;
						t[e] = !0, S(t), D()
					})(N[0]),
					"data-testid": N[0]
				}, k._("Add {language}", [k._param("language", T[N[0]])], {
					hk: "2emiHZ"
				})) : null, r.a.createElement("div", {
					className: Object(i.a)(l.a.PromptRow, {
						[l.a.Dismiss]: !0
					}),
					onClick: () => M("later")
				}, k._("Maybe later", null, {
					hk: "2LjBDw"
				})))) : null
			};
			t.a = Object(m.b)(e => {
				var t;
				const {
					gqlContext: n
				} = e, o = Object(s.f)().getState();
				return (null === (t = Object(s.e)(e => Object(E.a)(e, {
					experience: _.eb.LanguagePreferenceBottomSheet
				}))) || void 0 === t ? void 0 : t.value) && Object(x.b)(o) ? r.a.createElement(j, {
					gqlContext: n
				}) : null
			})
		},
		"./src/reddit/components/OverflowMenu/index.m.less": function(e, t, n) {
			e.exports = {
				_Dropdown: "ehsOqYO6dxn_Pf9Dzwu37",
				dropdown: "ehsOqYO6dxn_Pf9Dzwu37",
				MenuButton: "_2pFdCpgBihIaYh9DSMWBIu",
				menuButton: "_2pFdCpgBihIaYh9DSMWBIu",
				mIsEnabled: "uMPgOFYlCc5uvpa2Lbteu",
				MenuIcon: "_38GxRFSqSC-Z2VLi5Xzkjy",
				menuIcon: "_38GxRFSqSC-Z2VLi5Xzkjy",
				DropdownRow: "_2DO72U0b_6CUw3msKGrnnT",
				dropdownRow: "_2DO72U0b_6CUw3msKGrnnT"
			}
		},
		"./src/reddit/components/OverflowMenu/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return x
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				m = n("./src/reddit/controls/Dropdown/index.tsx"),
				p = n("./src/reddit/controls/Dropdown/Row.tsx"),
				h = n("./src/reddit/icons/fonts/index.tsx"),
				b = n("./src/reddit/selectors/tooltip.ts"),
				f = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				g = n("./src/reddit/components/OverflowMenu/index.m.less"),
				v = n.n(g);
			const C = d.a.wrapped(m.a, "_Dropdown", v.a),
				y = Object(u.a)(C),
				E = d.a.button("MenuButton", v.a),
				x = d.a.wrapped(p.b, "DropdownRow", v.a),
				O = Object(a.c)({
					dropdownIsOpen: (e, t) => {
						let {
							dropdownId: n
						} = t;
						return Object(b.b)(n)(e)
					}
				}),
				_ = Object(i.b)(O, (e, t) => {
					let {
						dropdownId: n
					} = t;
					return {
						toggleDropdown: () => e(Object(l.h)({
							tooltipId: n
						}))
					}
				}),
				k = e => t => {
					e.onClick && e.onClick(), e.toggleDropdown(), t.stopPropagation()
				};
			t.b = _(e => s.a.createElement(E, {
				"aria-expanded": e.dropdownIsOpen,
				"aria-haspopup": !0,
				"aria-label": o.fbt._("more options", null, {
					hk: "2EnY1x"
				}),
				className: Object(c.a)(e.className, {
					[v.a.mIsEnabled]: !e.disabled && !e.defaultButtonOutline
				}),
				disabled: e.disabled,
				onClick: k(e),
				onMouseDown: e.handleMouseDown,
				id: e.dropdownId,
				"data-adclicklocation": f.b.OVERFLOW_MENU
			}, e.icon ? e.icon : s.a.createElement(h.a, {
				name: "overflow_horizontal",
				className: v.a.MenuIcon
			}), s.a.createElement(y, {
				className: e.dropdownClassName,
				isOpen: e.dropdownIsOpen,
				tooltipId: e.dropdownId,
				isFixed: e.isFixed,
				targetPosition: e.targetPosition,
				tooltipPosition: e.tooltipPosition,
				style: e.style
			}, e.children)))
		},
		"./src/reddit/components/OverlayAwareTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/higherOrderComponents/asTooltip.tsx"),
				i = n("./src/reddit/constants/elementIds.ts"),
				a = n("./src/reddit/contexts/InsideOverlay.tsx");

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}

			function d(e, t) {
				const n = Object(s.a)(e, t);
				class o extends r.a.PureComponent {
					constructor() {
						super(...arguments), this.state = {
							container: null
						}
					}
					componentDidMount() {
						if (this.props.isOverlay) {
							const e = document.getElementById(i.e);
							this.setState({
								container: e
							})
						}
					}
					render() {
						return r.a.createElement(n, c({}, this.props, {
							container: this.state.container || this.props.container,
							excludeContainerPosition: this.props.isOverlay
						}))
					}
				}
				return Object(a.b)(o)
			}
		},
		"./src/reddit/components/Poll/PollExpiry/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var o = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/components/HumanDate/index.tsx"),
				s = n("./src/lib/timeUntil/index.ts"),
				i = n("./node_modules/react/index.js"),
				a = n.n(i);
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js");

			function d(e) {
				const t = new Date(e.poll.endsAt).getTime() - Date.now() <= 0;
				return a.a.createElement("span", {
					className: e.className
				}, t ? c._("Voting closed {timeAgo}", [c._param("timeAgo", a.a.createElement(r.d, {
					seconds: e.poll.endsAt / o.Xb
				}))], {
					hk: "3OERID"
				}) : Object(s.a)(new Date(e.poll.endsAt)))
			}
		},
		"./src/reddit/components/Poll/PostTitleMetaData/index.m.less": function(e, t, n) {
			e.exports = {
				proposalMetaData: "_3yYOHq_rWQcgaR_pinEQU7",
				proposalExpiry: "_1poH87fXNrjNu84jKXBtun"
			}
		},
		"./src/reddit/components/PollCreator/DefaultHintText/index.m.less": function(e, t, n) {
			e.exports = {
				helpTextItem: "wYdL1V7fxOtMwgvL8gt4a",
				helpTextList: "_23_RY8_TK404O0hdN7zpNn",
				helpTitle: "_3qXjOYMFBOO47HoteguQiz",
				helpTitleText: "_1NjVVC7kcVvJTLxxbNEi0S",
				infoIcon: "_2EKnk91_WzE7ao5vX6K5cC"
			}
		},
		"./src/reddit/components/PollCreator/EndDatePicker/index.m.less": function(e, t, n) {
			e.exports = {
				timeZone: "jHZVOve2QGoctU0iDnnCI",
				dateTime: "_24VUErhy8JiR-xw9cMsdx0",
				timeInput: "_1YzViNj-rqobl3wArJ3k_"
			}
		},
		"./src/reddit/components/PollCreator/EndDatePicker/useEndDatePicker.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./src/lib/timezone/index.ts"),
				r = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/utils.ts"),
				s = n("./src/reddit/hooks/useLocale.ts"),
				i = n("./src/reddit/components/PollCreator/EndDatePicker/utils.ts");

			function a(e, t) {
				var n;
				const a = Object(s.a)(),
					{
						date: c,
						time: d
					} = Object(i.a)(e),
					l = Object(o.b)(),
					u = l ? Object(o.d)(l) : null,
					m = new Date,
					{
						minDate: p,
						minTime: h,
						formattedMinDatetime: b
					} = Object(i.c)(m, a),
					f = Object(r.a)(),
					g = Object(i.d)({
						date: p,
						time: h
					});
				return {
					date: c,
					time: d,
					timeZoneAbbr: null !== (n = null == u ? void 0 : u.abbreviation) && void 0 !== n ? n : "",
					onChange: e => {
						Object.values(e).every(e => e.length) && t(Object(i.d)({
							date: c,
							time: d,
							...e
						}))
					},
					maxDate: f,
					minDate: p,
					minTime: h,
					fullMinDatetime: g,
					formattedMinDatetime: b
				}
			}
		},
		"./src/reddit/components/PollCreator/EndDatePicker/utils.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			}));
			var o = n("./src/lib/timezone/index.ts"),
				r = n("./src/reddit/helpers/scheduledPosts/index.ts");
			const s = () => {
					const e = new Date;
					return e.setDate(e.getDate() + 3), e
				},
				i = e => {
					const [t, n] = Object(r.i)(Object(o.g)(e));
					return {
						date: t,
						time: n
					}
				},
				a = e => {
					let {
						date: t,
						time: n
					} = e;
					return new Date(`${t}T${n}`)
				},
				c = (e, t) => e.toLocaleString(t, {
					month: "numeric",
					day: "numeric",
					year: "numeric",
					hour: "numeric",
					minute: "2-digit"
				}),
				d = (e, t) => {
					const n = new Date(e);
					n.setHours(n.getHours() + 1);
					const {
						date: o,
						time: r
					} = i(n);
					return {
						minDate: o,
						minTime: r,
						formattedMinDatetime: c(n, t)
					}
				}
		},
		"./src/reddit/components/PollCreator/SortableOptions/index.m.less": function(e, t, n) {
			e.exports = {
				options: "vtFOVcu_sAJUlHd8Vxx_S",
				controls: "_2uAaCZzc_HQhLKkUJ66vU5",
				container: "_3Q-Z7QKdjihmmbINOEzofW",
				grapple: "_3ePBnj3VLelomSpvc5bYjW",
				input: "_2yM8wrpUFDlwPMl42pJ1ly",
				trash: "_2raOjruzA2S4cw-4wFtDJN"
			}
		},
		"./src/reddit/components/PollCreator/index.m.less": function(e, t, n) {
			e.exports = {
				flexRow: "_2G4E6Ja1LjN3lvEFdvCAMM",
				addButton: "_1MW4m9_ojHA4AO_I1MhQf3",
				container: "_3S9C536IVs6t9fXO2fE_Yq",
				help: "_1kYOBe87AO-Ly-PkWe8yd8",
				votingLengthCaret: "ekKR9rTD5h3p7yQ4SaLoa",
				votingLengthDropdown: "_1Sbl_DKDMJM71lJ_1GQgbB",
				votingLengthDropdownContainer: "_24W8XLxQSgwVVFneYfHsJR",
				votingLengthSelector: "_3TH3dFaVjJ2OSx-B_N3pDU",
				votingLengthSelector__disabled: "_2Wc5VFPksdxez0HQRlpdeE",
				votingLengthSelectorDisabled: "_2Wc5VFPksdxez0HQRlpdeE",
				votingLengthTitleText: "_1-ozAll8fJXOJ9tr9TwS1r",
				votingLengthDisplay: "gj1NXudk861pHzMz3jvCj",
				predictionSettings: "HXVbpI7By73VaXfNbuqeV",
				endDatePicker: "_2RwSuQDNqmMVVRgysrJYie",
				title: "_24GJ3HJNoyTS39atzgNnwZ"
			}
		},
		"./src/reddit/components/PostBadges/index.m.less": function(e, t, n) {
			e.exports = {
				adminIcon: "_1cje4rrmwL0yZgCOlGyBJ-",
				approveIcon: "_1knR9NIIXdSFC9IeFN11JL",
				automoderator: "_2etEb_0bRB9axAqF3uX28S",
				icon: "_3vju76MdF2FaGmELBeiJ_r",
				lockIcon: "_3wTfn3Meg1rXJ-qd2jUWMt",
				modIcon: "_SMl46gACTEszA_4A0Qfs",
				removeIcon: "_3yuF1RnBRJL4OS_STsoXcC",
				reportIcon: "_3guZWUAROueft8TPPGDZ-R",
				spamIcon: "_2BWw37nLL0rX6n7xcXciyD",
				stickyIcon: "NI8uZ-19oHf9gPO8jOvFu",
				addRemovalReason: "COGitU-ItwLZG_fP5rsdE",
				isRemoved: "_27iLVqax1FuPWTymkSkKAq",
				archivedIcon: "_2WSiH2JwZq4bXuvrDn-cgU",
				removalReason: "_16Ih3bzeELRlI6AWeW-nFy"
			}
		},
		"./src/reddit/components/PostBadges/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				m = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				p = n("./src/reddit/constants/postLayout.ts"),
				h = n("./src/reddit/constants/posts.ts"),
				b = n("./src/reddit/contexts/PageLayer/index.tsx"),
				f = n("./src/reddit/helpers/isRemoved.ts"),
				g = n("./src/reddit/helpers/modTooltipTemplates/index.ts"),
				v = n("./src/reddit/helpers/showReportIndicator/index.ts"),
				C = n("./src/reddit/icons/fonts/index.tsx"),
				y = n("./src/reddit/icons/fonts/Approve/index.tsx"),
				E = n("./src/reddit/icons/fonts/Archived/index.tsx"),
				x = n("./src/reddit/icons/fonts/Lock/index.tsx"),
				O = n("./src/reddit/icons/fonts/Remove/index.tsx"),
				_ = n("./src/reddit/icons/fonts/Report/index.tsx"),
				k = n("./src/reddit/icons/fonts/Spam/index.tsx"),
				j = n("./src/reddit/icons/fonts/Sticky/index.tsx"),
				S = n("./src/reddit/models/Post/index.ts"),
				T = n("./src/reddit/selectors/modQueue.ts"),
				w = n("./src/reddit/selectors/posts.ts"),
				I = n("./src/reddit/components/PostBadges/index.m.less"),
				P = n.n(I);

			function N() {
				return (N = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const R = e => s.a.createElement("span", N({
					className: P.a.removalReason
				}, e), e.children),
				M = () => o.fbt._("Archived", null, {
					hk: "zv3q3"
				}),
				D = () => o.fbt._("Comments are locked", null, {
					hk: "8HjJ9"
				}),
				L = e => o.fbt._("Moderator of {community name}", [o.fbt._param("community name", e)], {
					hk: "nJqIB"
				}),
				A = () => o.fbt._("Stickied post", null, {
					hk: "3qSaBs"
				}),
				F = () => o.fbt._("Pinned post", null, {
					hk: "2oxErI"
				}),
				B = (e, t, n) => {
					const o = `PostBadges--${e}--${t}`;
					return n ? `${o}--${n}` : o
				},
				U = Object(b.v)({
					isProfilePostListing: b.N,
					isSubreddit: b.Q
				}),
				K = Object(a.c)({
					isModQueueDisplayEnabled: e => {
						const t = p.e[Object(b.U)(e, {})] === p.d.Card;
						return Object(T.b)(e, t)
					},
					isPinned: (e, t) => {
						let {
							post: n
						} = t;
						return Object(w.q)(e, {
							postId: n.id
						})
					},
					modModeEnabled: b.W
				}),
				W = Object(i.b)(K, (e, t) => ({
					onHideTooltip: () => e(Object(l.i)()),
					onOpenRemovalReasonModal: () => {
						Promise.all([n.e("Reddit~RichTextEditor~reddit-components-MediumPost~reddit-components-NotificationUnit-Button~removal~87f825ba"), n.e("removalReasonActions")]).then(n.bind(null, "./src/reddit/actions/removalReasons/index.ts")).then(n => e(n.fetchReasonsAndOpenModal(t.post.belongsTo.id, [t.post.id])))
					},
					onShowTooltip: t => () => e(Object(l.f)({
						tooltipId: t
					}))
				}));
			t.a = U(W(e => {
				let {
					className: t,
					displayText: n,
					isSubreddit: i,
					inSubredditOrProfile: a,
					isCompactPinnedPost: l,
					isPinned: p,
					isProfilePostListing: b,
					modModeEnabled: T,
					onHideTooltip: w,
					onOpenRemovalReasonModal: I,
					onShowTooltip: U,
					post: K,
					tooltipType: W,
					isModQueueDisplayEnabled: G
				} = e;
				const H = {
						caretOnTop: !1
					},
					V = K.isRemoved && !K.modRemovalReason && !K.modNote && K.belongsTo.type === h.a.SUBREDDIT,
					z = B("Approve", K.id, W),
					q = B("Archived", K.id, W),
					Q = B("Lock", K.id, W),
					Y = B("Mod", K.id, W),
					J = B("Remove", K.id, W),
					X = B("Report", K.id, W),
					Z = B("Spam", K.id, W),
					$ = B("Sticky", K.id, W),
					ee = B("Pinned", K.id, W);
				return s.a.createElement("div", {
					className: t
				}, a && n && K.distinguishType === d.I.MODERATOR && s.a.createElement(r.Fragment, null, s.a.createElement(C.a, {
					name: "mod",
					isFilled: !0,
					className: Object(c.a)(P.a.icon, P.a.modIcon)
				}), s.a.createElement(u.c, N({
					tooltipId: Y,
					text: L(n)
				}, H))), K.isArchived && s.a.createElement(r.Fragment, null, s.a.createElement(E.a, {
					isFilled: !0,
					className: Object(c.a)(P.a.icon, P.a.archivedIcon),
					desc: M(),
					id: q,
					onMouseEnter: U(q),
					onMouseLeave: w
				}), s.a.createElement(u.c, N({
					tooltipId: q,
					text: M()
				}, H))), K.isLocked && !K.isSponsored && s.a.createElement(r.Fragment, null, s.a.createElement(x.a, {
					isFilled: !0,
					className: Object(c.a)(P.a.icon, P.a.lockIcon),
					desc: D(),
					id: Q,
					onMouseEnter: U(Q),
					onMouseLeave: w
				}), s.a.createElement(u.c, N({
					tooltipId: Q,
					text: D()
				}, H))), i && Object(S.v)(K) && !l && s.a.createElement(r.Fragment, null, s.a.createElement(j.a, {
					isFilled: !0,
					className: Object(c.a)(P.a.icon, P.a.stickyIcon),
					desc: A(),
					id: $,
					onMouseEnter: U($),
					onMouseLeave: w
				}), s.a.createElement(u.c, N({
					tooltipId: $,
					text: A()
				}, H))), b && p && s.a.createElement(r.Fragment, null, s.a.createElement(j.a, {
					isFilled: !0,
					className: Object(c.a)(P.a.icon, P.a.stickyIcon),
					desc: F(),
					id: ee,
					onMouseEnter: U(ee),
					onMouseLeave: w
				}), s.a.createElement(u.c, N({
					tooltipId: ee,
					text: F()
				}, H))), !G && s.a.createElement(s.a.Fragment, null, (K.isApproved || K.approvedBy) && s.a.createElement(r.Fragment, null, s.a.createElement(y.a, {
					isFilled: !0,
					className: Object(c.a)(P.a.icon, P.a.approveIcon),
					desc: Object(g.a)(K),
					id: z,
					onMouseEnter: U(z),
					onMouseLeave: w
				}), s.a.createElement(u.c, N({
					tooltipId: z,
					text: Object(g.a)(K)
				}, H))), Object(f.a)(K) && s.a.createElement(r.Fragment, null, s.a.createElement(O.a, {
					isFilled: !0,
					className: Object(c.a)(P.a.icon, P.a.removeIcon),
					desc: Object(g.b)(K),
					id: J,
					onMouseEnter: U(J),
					onMouseLeave: w
				}), V && s.a.createElement(m.a, {
					className: P.a.addRemovalReason,
					onClick: I,
					text: o.fbt._("Add a removal reason", null, {
						hk: "1YDo3"
					})
				}), (K.modRemovalReason || K.modNote) && s.a.createElement(R, {
					onMouseEnter: U(J),
					onMouseLeave: w
				}, o.fbt._("Removal reason", null, {
					hk: "2DhKVZ"
				})), s.a.createElement(u.c, N({
					tooltipId: J,
					text: Object(g.b)(K)
				}, H))), K.bannedBy && K.isSpam && s.a.createElement(r.Fragment, null, s.a.createElement(k.a, {
					isFilled: !0,
					className: Object(c.a)(P.a.icon, P.a.spamIcon),
					desc: Object(g.d)(K),
					id: Z,
					onMouseEnter: U(Z),
					onMouseLeave: w
				}), s.a.createElement(u.c, N({
					tooltipId: Z,
					text: Object(g.d)(K)
				}, H)))), Object(v.a)(K) && !T && !G && s.a.createElement(r.Fragment, null, s.a.createElement(_.a, {
					isFilled: !0,
					className: Object(c.a)(P.a.icon, P.a.reportIcon),
					desc: Object(g.c)(K.numReports),
					id: X,
					onMouseEnter: U(X),
					onMouseLeave: w
				}), s.a.createElement(u.c, N({
					tooltipId: X,
					text: Object(g.c)(K.numReports)
				}, H))))
			}))
		},
		"./src/reddit/components/PostCreationForm/Button/index.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "_18Bo5Wuo3tMV-RDB8-kh8Z",
				primaryButton: "_18Bo5Wuo3tMV-RDB8-kh8Z",
				SecondaryButton: "lUsjLveKkZWUAgDDyU1rD",
				secondaryButton: "lUsjLveKkZWUAgDDyU1rD"
			}
		},
		"./src/reddit/components/PostCreationForm/Button/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return c
			}));
			var o = n("./src/reddit/controls/Button/index.tsx"),
				r = n("./src/reddit/components/PostCreationForm/Button/index.m.less"),
				s = n.n(r),
				i = n("./src/lib/lessComponent.tsx");
			const a = i.a.wrapped(o.l, "PrimaryButton", s.a),
				c = i.a.wrapped(o.o, "SecondaryButton", s.a)
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/CollectionListItem/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1IZotn_IQQ1fgtUjaFYbkd",
				onHoverActionText: "_1Zlk1VrZ8puYZy5lJOfz--",
				Container: "_1IZotn_IQQ1fgtUjaFYbkd",
				PostTitle: "_1hzDym_NpIlizkTDXc_rQj",
				postTitle: "_1hzDym_NpIlizkTDXc_rQj",
				MetaLine: "_67JuJTdFwIJPLPDkyPX-f",
				metaLine: "_67JuJTdFwIJPLPDkyPX-f",
				SubredditName: "_88OYON0K3w_tpnmCSWlUX",
				subredditName: "_88OYON0K3w_tpnmCSWlUX",
				InfoSpan: "_3DFfW-OG-MvCLiiEN18mpq",
				infoSpan: "_3DFfW-OG-MvCLiiEN18mpq"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_1QvpnsvD_e--dvDTEcz7_w",
				wrapper: "_1QvpnsvD_e--dvDTEcz7_w",
				TopRow: "vuQEtla32r0kemmh11Hov",
				topRow: "vuQEtla32r0kemmh11Hov",
				TitleRow: "_1eSyFPTFSsfyp8BVxs83PB",
				titleRow: "_1eSyFPTFSsfyp8BVxs83PB",
				DetailsContainer: "_87UrrqUro4oVpXFAElZUX",
				detailsContainer: "_87UrrqUro4oVpXFAElZUX",
				ButtonRow: "_1CUOht5hsM0AF9T3Ox1yos",
				buttonRow: "_1CUOht5hsM0AF9T3Ox1yos",
				CloseWrapper: "_3OsXrjEdHgK1wJBfPX6IhR",
				closeWrapper: "_3OsXrjEdHgK1wJBfPX6IhR",
				Close: "_1TaKYhB80ExuTPoLaQZMRE",
				close: "_1TaKYhB80ExuTPoLaQZMRE",
				Empty: "_20K7F6rAgXGH5z83v7Ifiv",
				empty: "_20K7F6rAgXGH5z83v7Ifiv",
				EmptyImage: "_2eLeResic3Gc77W_edgNGt",
				emptyImage: "_2eLeResic3Gc77W_edgNGt",
				EmptyText: "_3t6VBoBsR8CGQvaPLHPjmW",
				emptyText: "_3t6VBoBsR8CGQvaPLHPjmW",
				FilterWrapper: "pKfhphFBuya82DYP2Q90X",
				filterWrapper: "pKfhphFBuya82DYP2Q90X",
				FilterInput: "_3W5cary86KmYWrVgEpGKPb",
				filterInput: "_3W5cary86KmYWrVgEpGKPb",
				SearchIcon: "_9T_dguVcd795c_vOyl9s4",
				searchIcon: "_9T_dguVcd795c_vOyl9s4",
				PlusIcon: "hfmgzmXCLe3hvSyZad9WP",
				plusIcon: "hfmgzmXCLe3hvSyZad9WP",
				CreateCollectionButton: "_34_h0zRV3AgFr_0sh99pKz",
				createCollectionButton: "_34_h0zRV3AgFr_0sh99pKz"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/reselect/es/index.js"),
				d = n("./src/higherOrderComponents/asModal/index.tsx"),
				l = n("./src/lib/memoizeByReference/index.ts"),
				u = n("./src/reddit/actions/postCreation/general.ts"),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/constants/keycodes.ts"),
				h = n("./src/reddit/controls/Button/index.tsx"),
				b = n("./src/reddit/controls/Input/index.tsx"),
				f = n("./src/reddit/icons/svgs/Close/index.tsx"),
				g = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				v = n("./src/reddit/icons/svgs/Search/index.tsx"),
				C = n("./src/reddit/layout/row/Inline/index.tsx"),
				y = n("./src/reddit/models/PostCreationForm/index.ts"),
				E = n("./src/reddit/selectors/postCollection.ts"),
				x = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				O = n("./src/reddit/components/HumanDate/index.tsx"),
				_ = n("./src/reddit/helpers/name/index.ts"),
				k = n("./src/reddit/models/Subreddit/index.ts"),
				j = n("./src/reddit/models/User/index.ts"),
				S = n("./src/reddit/selectors/subreddit.ts"),
				T = n("./src/reddit/selectors/user.ts"),
				w = n("./src/reddit/components/PostCreationForm/CollectionListModal/CollectionListItem/index.m.less"),
				I = n.n(w),
				P = n("./src/lib/lessComponent.tsx");
			const {
				fbt: N
			} = n("./node_modules/fbt/lib/FbtPublic.js"), R = P.a.div("Container", I.a), M = P.a.h2("PostTitle", I.a), D = P.a.div("MetaLine", I.a), L = P.a.span("SubredditName", I.a), A = P.a.time("InfoSpan", I.a), F = Object(c.c)({
				subreddit: (e, t) => {
					let {
						collection: {
							subredditId: n
						}
					} = t;
					return n ? Object(S.X)(e, {
						subredditId: n
					}) : void 0
				},
				user: T.m
			});
			class B extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.onClick = () => {
						this.props.onClick(this.props.collection.id)
					}
				}
				render() {
					const {
						collection: e,
						subreddit: t,
						user: n,
						onHoverActionText: o
					} = this.props, r = t && Object(k.i)(t) && n ? Object(_.e)(Object(j.e)(n)) : t ? t.displayText : "", s = e.postIds.length;
					return i.a.createElement(R, {
						onClick: this.onClick,
						className: I.a.container
					}, i.a.createElement(M, {
						"data-redditstyle": !0
					}, e.title), i.a.createElement(D, {
						"data-redditstyle": !0
					}, r && i.a.createElement(L, {
						"data-redditstyle": !0
					}, r), r && i.a.createElement(x.b, null), i.a.createElement(A, null, N._({
						"*": "{number of posts} posts",
						_1: "1 post"
					}, [N._plural(s, "number of posts")], {
						hk: "1Uy96U"
					})), i.a.createElement(x.b, null), i.a.createElement(A, null, N._("created {time}", [N._param("time", i.a.createElement(O.d, {
						seconds: e.createdAtUTC
					}))], {
						hk: "2cUc5m"
					}))), o && i.a.createElement("div", {
						className: I.a.onHoverActionText
					}, i.a.createElement("span", null, o)))
				}
			}
			var U = Object(a.b)(F)(B),
				K = n("./src/reddit/helpers/trackers/postCollection.ts"),
				W = n("./src/reddit/components/PostCreationForm/CollectionListModal/index.m.less"),
				G = n.n(W);
			const H = `${o.a.assetPath}/img/snoo-drafts.png`,
				V = P.a.div("TopRow", G.a),
				z = P.a.div("TitleRow", G.a),
				q = P.a.div("DetailsContainer", G.a),
				Q = P.a.wrapped(C.a, "ButtonRow", G.a),
				Y = P.a.div("CloseWrapper", G.a),
				J = P.a.wrapped(f.a, "Close", G.a),
				X = P.a.div("Empty", G.a),
				Z = P.a.img("EmptyImage", G.a),
				$ = P.a.p("EmptyText", G.a),
				ee = P.a.div("FilterWrapper", G.a),
				te = P.a.wrapped(b.a, "FilterInput", G.a),
				ne = P.a.wrapped(v.a, "SearchIcon", G.a),
				oe = P.a.wrapped(g.a, "PlusIcon", G.a),
				re = P.a.wrapped(h.p, "CreateCollectionButton", G.a),
				se = Object(l.a)((e, t) => {
					const n = t.toLowerCase();
					return e.filter(e => e.title.toLowerCase().includes(n))
				}),
				ie = Object(c.c)({
					collections: E.v
				}),
				ae = Object(a.b)(ie, (e, t) => {
					let {
						postId: n,
						isOverlay: o
					} = t;
					return {
						onOpenCreateCollectionModal: () => {
							let t = y.b;
							n && (t = Object(y.u)(n, !!o)), e(Object(u.z)(t))
						}
					}
				});
			class ce extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.state = {
						filterStr: ""
					}, this.close = () => {
						this.props.sendEvent(Object(K.c)()), this.props.onClose()
					}, this.handleEscapeKey = e => {
						e.keyCode === p.a.Escape && this.close()
					}, this.handleCreateCollectionClicked = () => {
						this.props.onOpenCreateCollectionModal(), this.props.sendEvent(Object(K.j)())
					}, this.handleCollectionSelected = e => {
						this.props.onSelectCollection(e), this.props.sendEvent(Object(K.q)())
					}, this.onFilterStringChange = e => {
						this.setState({
							filterStr: e.target.value
						})
					}, this.renderItem = e => i.a.createElement(U, {
						key: e.id,
						collection: e,
						onClick: () => this.handleCollectionSelected(e),
						onHoverActionText: this.props.onItemHoverActionText
					})
				}
				componentDidMount() {
					document.addEventListener("keydown", this.handleEscapeKey), this.props.sendEvent(Object(K.d)())
				}
				componentWillUnmount() {
					document.removeEventListener("keydown", this.handleEscapeKey)
				}
				renderNoCollections() {
					return i.a.createElement(X, null, i.a.createElement(Z, {
						src: H
					}), i.a.createElement($, null, r.fbt._("Your collections will live here", null, {
						hk: "FCxWg"
					})))
				}
				renderNoFilterMatches() {
					return i.a.createElement(X, null, i.a.createElement($, null, r.fbt._("No collection matching filter", null, {
						hk: "2vawdK"
					}), ";"))
				}
				render() {
					const {
						collections: e,
						titleText: t
					} = this.props;
					let n;
					if (0 === e.length) n = this.renderNoCollections();
					else {
						const t = se(e, this.state.filterStr);
						n = 0 === t.length ? this.renderNoFilterMatches() : t.map(this.renderItem)
					}
					return i.a.createElement("div", {
						className: G.a.wrapper,
						"data-redditstyle": !0
					}, i.a.createElement(V, null, i.a.createElement(z, {
						"data-redditstyle": !0
					}, t || r.fbt._("My collections", null, {
						hk: "3yKovS"
					}), i.a.createElement(Y, {
						onClick: this.close
					}, i.a.createElement(J, {
						"data-redditstyle": !0
					}))), i.a.createElement(ee, null, i.a.createElement(ne, null), i.a.createElement(te, {
						placeholder: r.fbt._("Find a collection", null, {
							hk: "3DbFBU"
						}),
						value: this.state.filterStr,
						onChange: this.onFilterStringChange
					}))), i.a.createElement(q, null, n), i.a.createElement(Q, null, i.a.createElement(re, {
						onClick: this.handleCreateCollectionClicked
					}, i.a.createElement(oe, null), r.fbt._("Create a collection", null, {
						hk: "37xJVm"
					}))))
				}
			}
			const de = Object(d.a)(ae(Object(m.c)(ce)));
			t.a = de
		},
		"./src/reddit/components/PostCreationForm/ControlRow/AddTournamentPredictionButton/index.m.less": function(e, t, n) {
			e.exports = {
				addTournamentPredictionButton: "_379A0ry8uhFTCCqbGtPG08",
				tooltip: "NKpm2s1DjP3vbRrlx4pxe"
			}
		},
		"./src/reddit/components/PostCreationForm/ControlRow/LivechatBadge/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2xKRZlLAshNDtzawtZNAcQ",
				liveTag: "Vgnuv7YJuNcHtQf7kh5Hd"
			}
		},
		"./src/reddit/components/PostCreationForm/ControlRow/PostModifiers/OCDisclaimer/index.m.less": function(e, t, n) {
			e.exports = {
				DontShowButton: "_1GOEXFnWfJy7WEF43f7RJk",
				dontShowButton: "_1GOEXFnWfJy7WEF43f7RJk",
				Component: "w3m9FyPsy2phDlWxoznhq",
				component: "w3m9FyPsy2phDlWxoznhq"
			}
		},
		"./src/reddit/components/PostCreationForm/ControlRow/PostModifiers/PostModifierButton/index.m.less": function(e, t, n) {
			e.exports = {
				PostModifierButton: "_5x1WjCc4HQF6tqnODOql0",
				postModifierButton: "_5x1WjCc4HQF6tqnODOql0",
				active: "HvFw1XKOfl5Jh7Run7iq4",
				HoverTooltip: "zprH8YpG-gVpFuEr-eQJw",
				hoverTooltip: "zprH8YpG-gVpFuEr-eQJw",
				TintOverlay: "stbc2Exoq0W4ZkGltglct",
				tintOverlay: "stbc2Exoq0W4ZkGltglct",
				isDisabled: "_3rEHSruwAvICnPAngYiIW1",
				mShiftTooltipToTheRight: "gceWvjO6tPHW1sEDhwkGK",
				Icon: "_3DWz59jTNPem2lIMybAGb8",
				icon: "_3DWz59jTNPem2lIMybAGb8"
			}
		},
		"./src/reddit/components/PostCreationForm/ControlRow/PostModifiers/index.m.less": function(e, t, n) {
			e.exports = {
				FlairComponent: "_2YM79GnDqrRjQQcFtEokkY",
				flairComponent: "_2YM79GnDqrRjQQcFtEokkY",
				FlairTextWrapper: "_1pXTTYLLHHqfgwyMuCqT6T",
				flairTextWrapper: "_1pXTTYLLHHqfgwyMuCqT6T",
				ModifierRow: "_2_rA2mCdhHc1Lr7Ff1ygvH",
				modifierRow: "_2_rA2mCdhHc1Lr7Ff1ygvH",
				AddFlair: "_1LD2Xsr3fioSkWZ13vMORC",
				addFlair: "_1LD2Xsr3fioSkWZ13vMORC",
				Text: "_2iXMeyQ3VxZmKCXkplOvQ_",
				text: "_2iXMeyQ3VxZmKCXkplOvQ_",
				TintOverlay: "_2vWD8kW1_iU4dc3CgY9_gH",
				tintOverlay: "_2vWD8kW1_iU4dc3CgY9_gH",
				FlairIcon: "_2U5dhGN1LkTGmvfDSXp7Pn",
				flairIcon: "_2U5dhGN1LkTGmvfDSXp7Pn",
				StyledCaretIcon: "MZjVSHyz_JYuVJV8JeezH",
				styledCaretIcon: "MZjVSHyz_JYuVJV8JeezH",
				mHasError: "_12W0J-fwDQQ6_tQ9fdpzqG",
				errorMessages: "_29DzChs2ytJ2zOxDSU_YZZ"
			}
		},
		"./src/reddit/components/PostCreationForm/ControlRow/ToggleDestCollectionButton/index.m.less": function(e, t, n) {
			e.exports = {
				button: "_1FASP6jHc95Gr8_JE5NtRM",
				active: "_2cgz1Psg0iRSwK2eF0PY7a"
			}
		},
		"./src/reddit/components/PostCreationForm/ControlRow/index.m.less": function(e, t, n) {
			e.exports = {
				ButtonLayout: "_1T0P_YQg7fOYLCRoKl_xxO",
				buttonLayout: "_1T0P_YQg7fOYLCRoKl_xxO",
				buttonLayoutStyles: "_1BOItL6vmZFDKOuaOKKJHf",
				SaveDraftButtonLayout: "_2qdAvPbBMsK4TpwNnVe-pj",
				saveDraftButtonLayout: "_2qdAvPbBMsK4TpwNnVe-pj",
				Container: "_1d1--0DMy_jAIxCCoYMo1k",
				container: "_1d1--0DMy_jAIxCCoYMo1k",
				isSubRec: "_10YwpQ5TofUedjLm5Gxek4",
				Divider: "_3DzaxETs3eHqVBAuiSTECq",
				divider: "_3DzaxETs3eHqVBAuiSTECq",
				ButtonsAndErrors: "_2DHDj0dbS1TkKD3fMqSbHy",
				buttonsAndErrors: "_2DHDj0dbS1TkKD3fMqSbHy",
				formActionsPanel: "_1wpwfeCqAvc32pPsMD0YkY",
				buttons: "I8hSeA0pEmfzicVKE1j_y",
				errorMessages: "_2kLLxn1y9vaTeT0OAc-Ikc",
				PostLoadingIcon: "_2QZRXSFrX2qcSjZIV5mRzK",
				postLoadingIcon: "_2QZRXSFrX2qcSjZIV5mRzK",
				DraftLoadingIcon: "_4S5sqoV61IY7tpZqBwoKQ",
				draftLoadingIcon: "_4S5sqoV61IY7tpZqBwoKQ",
				postModifiers: "_2pAQpGYEPAVsPmV5uVmGGU",
				clockIcon: "_1z-5BtMZ_1-gl9JLssX5SJ",
				postScheduleButton: "_2cMg4VsPGSoc_OwPOPRAie",
				postScheduleIcon: "_1ND9PCHVFG_UrSPdlJqv5W",
				removeRightBorderRadius: "_1_Xn_Na9NfUSd_yoc1w2Eb"
			}
		},
		"./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_3vV_tKesULQ5WMGh38lX4b",
				container: "_3vV_tKesULQ5WMGh38lX4b",
				Content: "_11JSvybbRhcX_cfoagpne_",
				content: "_11JSvybbRhcX_cfoagpne_",
				TitleRow: "_3Ev4JRxdS9-3GTBR5M1yCP",
				titleRow: "_3Ev4JRxdS9-3GTBR5M1yCP",
				Details: "_3Uw02TWwSQhLfCJkPsihqr",
				details: "_3Uw02TWwSQhLfCJkPsihqr",
				Footer: "_25MDqXgOCWDBjtAEBi2cmy",
				footer: "_25MDqXgOCWDBjtAEBi2cmy",
				CancelButton: "_2tLOIj2nClBaVRuMBIJE8X",
				cancelButton: "_2tLOIj2nClBaVRuMBIJE8X",
				CloseWrapper: "_GVnqGyX40oKfgIS56Q-k",
				closeWrapper: "_GVnqGyX40oKfgIS56Q-k",
				CloseIcon: "_1GgoANMMbLQJ-gSefDJZuZ",
				closeIcon: "_1GgoANMMbLQJ-gSefDJZuZ",
				Label: "_3QPFKpxsmu6j_gbiAuVgfW",
				label: "_3QPFKpxsmu6j_gbiAuVgfW",
				TitleInput: "ZEfw7a99aHsmkl4fx38l5",
				titleInput: "ZEfw7a99aHsmkl4fx38l5",
				AddCollectionIcon: "_30BNMMyQPTPvHEoL3-LXrM",
				addCollectionIcon: "_30BNMMyQPTPvHEoL3-LXrM",
				PrimaryActionButton: "_22f_S1XUre_FujBgOgEHJe",
				primaryActionButton: "_22f_S1XUre_FujBgOgEHJe",
				LoadingIcon: "_3cD2qECfUUTwega16qDhBc",
				loadingIcon: "_3cD2qECfUUTwega16qDhBc",
				ErrorText: "GIQ2YnBHQtY1QM1yPEhCR",
				errorText: "GIQ2YnBHQtY1QM1yPEhCR"
			}
		},
		"./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/higherOrderComponents/asModal/index.tsx"),
				d = n("./src/lib/formatApiError/index.ts"),
				l = n("./src/reddit/actions/postCollection/index.ts"),
				u = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				m = n("./src/reddit/constants/postCreation.ts"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				h = n("./src/reddit/controls/ErrorText/index.tsx"),
				b = n("./src/reddit/controls/Input/index.tsx"),
				f = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				g = n("./src/reddit/icons/svgs/AddCollection/index.tsx"),
				v = n("./src/reddit/icons/svgs/Close/index.tsx"),
				C = n("./src/reddit/layout/row/Inline/index.tsx"),
				y = n("./src/reddit/selectors/postCollection.ts"),
				E = n("./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.m.less"),
				x = n.n(E),
				O = n("./src/lib/lessComponent.tsx");
			const _ = O.a.div("Container", x.a),
				k = O.a.div("Content", x.a),
				j = O.a.div("TitleRow", x.a),
				S = O.a.div("Details", x.a),
				T = O.a.wrapped(u.g, "Footer", x.a),
				w = O.a.wrapped(p.o, "CancelButton", x.a),
				I = O.a.div("CloseWrapper", x.a),
				P = O.a.wrapped(v.a, "CloseIcon", x.a),
				N = O.a.label("Label", x.a),
				R = O.a.wrapped(b.a, "TitleInput", x.a),
				M = O.a.wrapped(g.a, "AddCollectionIcon", x.a),
				D = O.a.wrapped(p.l, "PrimaryActionButton", x.a),
				L = O.a.wrapped(f.a, "LoadingIcon", x.a),
				A = O.a.wrapped(h.b, "ErrorText", x.a),
				F = Object(a.c)({
					collection: y.q,
					error: y.c,
					isPending: y.g
				}),
				B = Object(i.b)(F, (e, t) => ({
					onCreate: (t, n) => e(Object(l.b)(t, n)),
					onUpdate: n => e(Object(l.h)(t.collectionId, n))
				}));
			class U extends s.a.PureComponent {
				constructor(e) {
					super(e), this.onTitleChange = e => {
						this.setState({
							collectionTitle: e.target.value
						})
					}, this.onPrimaryButtonClick = async () => {
						const {
							collectionId: e,
							subredditId: t
						} = this.props, {
							collectionTitle: n
						} = this.state;
						if (e) {
							await this.props.onUpdate(n) && this.props.onCollectionUpdated && this.props.onCollectionUpdated()
						} else {
							const e = await this.props.onCreate(n, t);
							e && this.props.onCollectionCreated && this.props.onCollectionCreated(e)
						}
					}, this.onClose = () => {
						this.props.onCancel()
					};
					const {
						collection: t
					} = e;
					this.state = {
						collectionTitle: t ? t.title : ""
					}
				}
				render() {
					const {
						collectionId: e,
						error: t,
						isPending: n
					} = this.props, r = !e, i = !!this.state.collectionTitle.trim(), a = r ? o.fbt._("Create", null, {
						hk: "Ijp7n"
					}) : o.fbt._("Save", null, {
						hk: "4yMsMq"
					});
					return s.a.createElement(_, null, s.a.createElement(I, {
						onClick: this.props.onCancel
					}, s.a.createElement(P, null)), s.a.createElement(k, null, r && s.a.createElement(s.a.Fragment, null, s.a.createElement(j, null, s.a.createElement(M, null), o.fbt._("Create a collection", null, {
						hk: "3ndxk5"
					})), s.a.createElement(S, null, o.fbt._("Group posts into one feed. Create a series of events or just a group of random things. Make something awesome!", null, {
						hk: "2eCAQw"
					}))), s.a.createElement(N, null, r ? o.fbt._("Give a title for your collection", null, {
						hk: "Uaqbe"
					}) : o.fbt._("Edit title", null, {
						hk: "1jzweg"
					}), s.a.createElement(R, {
						maxLength: m.e,
						onChange: this.onTitleChange,
						placeholder: o.fbt._("Enter title", null, {
							hk: "3B0iRI"
						}),
						value: this.state.collectionTitle
					}))), s.a.createElement(T, null, s.a.createElement(C.a, null, s.a.createElement(w, {
						onClick: this.props.onCancel
					}, o.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), s.a.createElement(D, {
						onClick: this.onPrimaryButtonClick,
						disabled: n || !i
					}, n ? s.a.createElement(L, {
						sizePx: 10
					}) : a)), t && s.a.createElement(A, null, Object(d.a)(t))))
				}
			}
			t.a = Object(c.a)(B(U))
		},
		"./src/reddit/components/PostCreationForm/CreationControls/index.m.less": function(e, t, n) {
			e.exports = {
				SubredditPicker: "k3D4EVssJ1w-8irx6jW6k",
				subredditPicker: "k3D4EVssJ1w-8irx6jW6k",
				ControlRow: "i0kJNtq5ma1uzbOX9_mM4",
				controlRow: "i0kJNtq5ma1uzbOX9_mM4",
				SubredditRec: "_1tgC4BQSzljd9viPIEvxd3",
				subredditRec: "_1tgC4BQSzljd9viPIEvxd3"
			}
		},
		"./src/reddit/components/PostCreationForm/DraftListModal/DraftListItem/Icon.m.less": function(e, t, n) {
			e.exports = {
				Component: "_2zmE2mxeSGThXfrD20TENk",
				component: "_2zmE2mxeSGThXfrD20TENk"
			}
		},
		"./src/reddit/components/PostCreationForm/DraftListModal/DraftListItem/Placeholder.m.less": function(e, t, n) {
			e.exports = {
				Container: "_3s9TqP-_YHesViWXcd4cMj",
				container: "_3s9TqP-_YHesViWXcd4cMj",
				LeftBlock: "_3ZfLmI01IKam1zqUNiCCY6",
				leftBlock: "_3ZfLmI01IKam1zqUNiCCY6",
				Content: "_3GIbVaHf4QKOhABI3DhSMo",
				content: "_3GIbVaHf4QKOhABI3DhSMo",
				MediaIcon: "_31VuujawtoKX7A_ykq786h",
				mediaIcon: "_31VuujawtoKX7A_ykq786h",
				Title: "_24WZEeSSq6ekrxl4oZMhB3",
				title: "_24WZEeSSq6ekrxl4oZMhB3",
				Secondary: "_1a6BjjqFgWMfDd1GftKY3a",
				secondary: "_1a6BjjqFgWMfDd1GftKY3a"
			}
		},
		"./src/reddit/components/PostCreationForm/DraftListModal/DraftListItem/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_2mGd4F9ksQ8wRlvFjnL0wz",
				container: "_2mGd4F9ksQ8wRlvFjnL0wz",
				LeftBlock: "_32kTNEqb0vEW5J0BmJdwnn",
				leftBlock: "_32kTNEqb0vEW5J0BmJdwnn",
				Content: "wrG0DeMFlU8RmFoT1gUDM",
				content: "wrG0DeMFlU8RmFoT1gUDM",
				RightBlock: "AnY3sJDM9Z2aUfyXs2Hfl",
				rightBlock: "AnY3sJDM9Z2aUfyXs2Hfl",
				PostTitle: "_25WWHqf4udQb0G9Wa_ar6s",
				postTitle: "_25WWHqf4udQb0G9Wa_ar6s",
				EditingPostTitle: "_3kH-PKnEjv45UIFAwY_XwK",
				editingPostTitle: "_3kH-PKnEjv45UIFAwY_XwK",
				MetaLine: "_1P65-c5DlnBqJL1jOa9TFr",
				metaLine: "_1P65-c5DlnBqJL1jOa9TFr",
				SubredditName: "_2cQKCpCLQTg1gPnnhEqZ6z",
				subredditName: "_2cQKCpCLQTg1gPnnhEqZ6z",
				DraftSavedTime: "Aegaj4-SLZNjFEolptURF",
				draftSavedTime: "Aegaj4-SLZNjFEolptURF",
				TrashIcon: "lWsFaDYxW8Sc4sqVTxVGv",
				trashIcon: "lWsFaDYxW8Sc4sqVTxVGv",
				InteractiveDiv: "_1nhwaUh9TlWeM5H9a_E18l",
				interactiveDiv: "_1nhwaUh9TlWeM5H9a_E18l",
				ConfirmDelete: "_3lIfF-MBpq24PJLxdGfIWQ",
				confirmDelete: "_3lIfF-MBpq24PJLxdGfIWQ"
			}
		},
		"./src/reddit/components/PostCreationForm/DraftListModal/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_29SuZj4Q_M_-p6FwlKJw2V",
				wrapper: "_29SuZj4Q_M_-p6FwlKJw2V",
				TitleRow: "_1t9vurufwtvAZm6k-7T1N0",
				titleRow: "_1t9vurufwtvAZm6k-7T1N0",
				DraftsNumber: "VA7GC_5VP6Yx4VSLaCW7T",
				draftsNumber: "VA7GC_5VP6Yx4VSLaCW7T",
				DetailsContainer: "_2ffvzlYi6yd1I-j5ndDKFm",
				detailsContainer: "_2ffvzlYi6yd1I-j5ndDKFm",
				ButtonRow: "_3JS6XDYnB0zNhQRfV4rLl0",
				buttonRow: "_3JS6XDYnB0zNhQRfV4rLl0",
				CancelButton: "_2AHvxdRmdK6Dve6_MNs6YW",
				cancelButton: "_2AHvxdRmdK6Dve6_MNs6YW",
				CloseWrapper: "_2put2qtgUIjmVIlQlZxeTb",
				closeWrapper: "_2put2qtgUIjmVIlQlZxeTb",
				Close: "_1Ojj3n0SwnEevN0xKAhtFi",
				close: "_1Ojj3n0SwnEevN0xKAhtFi",
				Empty: "_3j6Qa8OS7J6clTSNxqrADq",
				empty: "_3j6Qa8OS7J6clTSNxqrADq",
				EmptyImage: "_13SmMRVwMLfOrhzEqQQXrJ",
				emptyImage: "_13SmMRVwMLfOrhzEqQQXrJ",
				EmptyText: "_2OF81CBhfbV9gjOU-5n9Dr",
				emptyText: "_2OF81CBhfbV9gjOU-5n9Dr",
				DraftListModal: "_2bMp7e8oHvukp1hKtlg1r-",
				draftListModal: "_2bMp7e8oHvukp1hKtlg1r-"
			}
		},
		"./src/reddit/components/PostCreationForm/EduTooltips/BaseEduTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1LVDV1pks4den73WWY46GI",
				contentContainer: "_3v3OHx0_DIBm8WcTKrQ_Vj",
				description: "_1ZyYR40qdR1KVaYW3JJnFF",
				gotIt: "_31UHkJmzR05A-oHijI9dsj",
				hero: "_3KJU9tTmfe-f0PGdg1hJ6O",
				icon: "_1TqYQFIF_2oaFDavvx7TEE",
				iconExplanation: "_2gaQgwvoc2dROc2Uramfat",
				iconsExplanations: "_1IKgmmXb6LA2blrkyfqnxx",
				title: "_1ZeryymPzBgAm7zK9oPs3l",
				Container: "_1LVDV1pks4den73WWY46GI",
				OuterContainer: "_3cH-rE_yhLIp3GscF-WShj",
				outerContainer: "_3cH-rE_yhLIp3GscF-WShj"
			}
		},
		"./src/reddit/components/PostCreationForm/EduTooltips/CollectionButtonTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3zSOhojke1hMymIth30Ue"
			}
		},
		"./src/reddit/components/PostCreationForm/LinkEditor/index.m.less": function(e, t, n) {
			e.exports = {
				URLInput: "_3zY6b4QJpSz1067ahq73_K",
				urlInput: "_3zY6b4QJpSz1067ahq73_K",
				mHasError: "_1WipnslOO1oVfOEMxsrYU3"
			}
		},
		"./src/reddit/components/PostCreationForm/MarkdownEditor/index.m.less": function(e, t, n) {
			e.exports = {
				LoadingIcon: "dyBWJSV5slC_6_q-avEAz",
				loadingIcon: "dyBWJSV5slC_6_q-avEAz",
				ModeDescription: "_2wjlEqW6Mz7pFfwBHVpPEA",
				modeDescription: "_2wjlEqW6Mz7pFfwBHVpPEA",
				ModeWrapper: "_2IWlVWhYLpVswet-ElQ9xx",
				modeWrapper: "_2IWlVWhYLpVswet-ElQ9xx",
				SwitchModeButton: "_2POD_tWc9UVvI3zBwPH9Yu",
				switchModeButton: "_2POD_tWc9UVvI3zBwPH9Yu",
				MarkdownHelpButton: "oqXBQCZarmL4V15c4Izxm",
				markdownHelpButton: "oqXBQCZarmL4V15c4Izxm",
				Toolbar: "_1HVLi6b9dq2O2gkgGAO1Fa",
				toolbar: "_1HVLi6b9dq2O2gkgGAO1Fa"
			}
		},
		"./src/reddit/components/PostCreationForm/MarkdownEditor/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/reddit/actions/postCreation/general.ts"),
				d = n("./src/reddit/components/CommentCreation/MarkdownCommentForm/index.tsx"),
				l = n("./src/reddit/components/FocusableContent/index.tsx"),
				u = n("./src/reddit/components/MarkdownHelp/index.tsx"),
				m = n("./src/reddit/components/PostCreationForm/Prompt/index.tsx"),
				p = n("./src/reddit/components/ResizableAutosizeTextarea/index.tsx"),
				h = n("./src/reddit/constants/keycodes.ts"),
				b = n("./src/reddit/controls/Button/index.tsx"),
				f = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				g = n("./src/reddit/models/PostCreationForm/index.ts"),
				v = n("./src/reddit/selectors/activeModalId.ts"),
				C = n("./src/reddit/selectors/editorContent.ts"),
				y = n("./src/reddit/components/PostCreationForm/MarkdownEditor/index.m.less"),
				E = n.n(y),
				x = n("./src/lib/lessComponent.tsx");
			const O = x.a.wrapped(f.a, "LoadingIcon", E.a),
				_ = e => {
					let {
						isFilled: t,
						...n
					} = e;
					return s.a.createElement(O, n)
				},
				k = x.a.span("ModeDescription", E.a),
				j = x.a.div("ModeWrapper", E.a),
				S = x.a.wrapped(d.a, "MarkdownHelpButton", E.a),
				T = x.a.div("Toolbar", E.a),
				w = Object(a.c)({
					activeModalId: v.a,
					isConverting: e => Object(C.a)(e)
				}),
				I = Object(i.b)(w, (e, t) => ({
					onChange: n => {
						e(Object(c.c)(n)), t.onChange && t.onChange(n)
					},
					helpModalToggled: () => e(Object(c.z)(u.b)),
					switchToRTEModalToggled: () => e(Object(c.z)(m.a.SWITCH_TO_RTE_MODAL_ID))
				}));
			class P extends s.a.Component {
				constructor(e) {
					super(e), this.textAreaRef = null, this.onChange = e => {
						const {
							value: t
						} = e.currentTarget;
						this.props.onChange(t)
					}, this.onBlur = () => {
						this.setState({
							isFocused: !1
						}), this.props.onBlur && this.props.onBlur()
					}, this.onFocus = () => {
						const {
							onFocus: e
						} = this.props;
						e && e(), this.setState({
							isFocused: !0
						})
					}, this.handleKeyDown = e => {
						const {
							ctrlKey: t,
							metaKey: n,
							keyCode: o
						} = e;
						(t || n) && o === h.a.Enter && this.props.onSubmit()
					}, this.handleSwitchModeClick = () => {
						this.props.value ? this.props.switchToRTEModalToggled() : this.props.onSwitchEditorMode(g.i.RICH_TEXT, this.props.value)
					}, this.handleSwitchToRTEConfirm = () => {
						this.props.switchToRTEModalToggled(), this.props.onSwitchEditorMode(g.i.RICH_TEXT, this.props.value)
					}, this.setTextAreaRef = e => this.textAreaRef = e, this.state = {
						isFocused: !1
					}
				}
				componentDidMount() {
					const {
						instanceRef: e
					} = this.props;
					e && e(this)
				}
				componentWillUnmount() {
					const {
						instanceRef: e
					} = this.props;
					e && e(null)
				}
				focus() {
					this.textAreaRef && this.textAreaRef.focus()
				}
				render() {
					const {
						className: e,
						isConverting: t,
						placeholderText: n,
						focusableContentMarkdownClassName: r,
						value: i
					} = this.props, {
						isFocused: a
					} = this.state;
					return s.a.createElement("div", {
						className: e
					}, s.a.createElement(l.a, {
						className: r,
						isFocused: a
					}, s.a.createElement(T, null, s.a.createElement(j, null, s.a.createElement(k, null, o.fbt._("Markdown", null, {
						hk: "42KuwU"
					})), s.a.createElement(S, {
						onClick: this.props.helpModalToggled
					})), s.a.createElement(N, {
						isConverting: t,
						onClick: this.handleSwitchModeClick
					})), s.a.createElement(p.a, {
						disabled: !!this.props.disabled,
						initialHeight: this.props.initialHeight,
						innerRef: this.setTextAreaRef,
						onBlur: this.onBlur,
						onChange: this.onChange,
						onEditorResize: this.props.onEditorResize,
						onFocus: this.onFocus,
						onKeyDown: this.handleKeyDown,
						placeholder: n,
						value: i
					})), this.props.activeModalId === u.b && s.a.createElement(u.a, {
						withOverlay: !0
					}), this.props.activeModalId === m.a.SWITCH_TO_RTE_MODAL_ID && s.a.createElement(m.b, {
						modalId: m.a.SWITCH_TO_RTE_MODAL_ID,
						onCancel: this.props.switchToRTEModalToggled,
						onConfirm: this.handleSwitchToRTEConfirm
					}))
				}
			}
			const N = s.a.memo(e => {
				let {
					isConverting: t,
					onClick: n
				} = e;
				const r = o.fbt._("Switch to Fancy Pants Editor", null, {
					hk: "1AKY7t"
				});
				return s.a.createElement(b.t, {
					priority: b.c.Plain,
					size: b.d.XS,
					onClick: n,
					Icon: t ? _ : void 0,
					text: r
				})
			});
			t.a = I(P)
		},
		"./src/reddit/components/PostCreationForm/MediaInput/DropArea/index.m.less": function(e, t, n) {
			e.exports = {
				HiddenInput: "sU2P34us34ODfjtvAFHEh",
				hiddenInput: "sU2P34us34ODfjtvAFHEh",
				UploadButton: "_3O09Fh0CTb1KXH9g--pyTm",
				uploadButton: "_3O09Fh0CTb1KXH9g--pyTm",
				HamsterSmall: "_2O_N8Ef-BG5Cfd4rpYn2gC",
				hamsterSmall: "_2O_N8Ef-BG5Cfd4rpYn2gC",
				HamsterLarge: "wV8IXIxvKm8PPZrR4ID63",
				hamsterLarge: "wV8IXIxvKm8PPZrR4ID63",
				Container: "_1Ts5GUNze2r03Hs4YNM7R7",
				container: "_1Ts5GUNze2r03Hs4YNM7R7",
				DropArea: "_1U5lLS9mQzBY-ItvbtGGLz",
				dropArea: "_1U5lLS9mQzBY-ItvbtGGLz",
				DropAreaActive: "_3dk8Anard_IzanCLoEOxwY",
				dropAreaActive: "_3dk8Anard_IzanCLoEOxwY",
				DropAreaOver: "_2u00X-QMmF0nCuc0JgGiPG",
				dropAreaOver: "_2u00X-QMmF0nCuc0JgGiPG",
				Paragraph: "_23Ktfv_B7IB6GfAwZ1n5KM",
				paragraph: "_23Ktfv_B7IB6GfAwZ1n5KM",
				ErrorMsg: "_1g07w9noInEjzrHqFqXu7p",
				errorMsg: "_1g07w9noInEjzrHqFqXu7p",
				Box: "_2bMJxWQqwzcVG4QCyh3UhG",
				box: "_2bMJxWQqwzcVG4QCyh3UhG"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/MultipleUploadStatusBar/index.m.less": function(e, t, n) {
			e.exports = {
				ControlRow: "XAYmQCRZd6pa1gK4J2Irv",
				controlRow: "XAYmQCRZd6pa1gK4J2Irv",
				OuterDivProgressBar: "_3lnXFUS1rk-i2bmQ9tBVAg",
				outerDivProgressBar: "_3lnXFUS1rk-i2bmQ9tBVAg",
				ProgressBar: "_2h9OzlkpNau2hE61muUCcM",
				progressBar: "_2h9OzlkpNau2hE61muUCcM",
				Status: "_2QlfNrUATpUf8fxWF3xLUc",
				status: "_2QlfNrUATpUf8fxWF3xLUc"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/AddImageItem.m.less": function(e, t, n) {
			e.exports = {
				AddImageWrapper: "_3mOObaE2qUuGBwPZt06QMP",
				addImageWrapper: "_3mOObaE2qUuGBwPZt06QMP",
				AddImageItem: "_1PHeBCrOhYxisqmUW-NOTZ",
				addImageItem: "_1PHeBCrOhYxisqmUW-NOTZ",
				plusIcon: "_3fjztH0o3WW8ugsD8VUpdG",
				hiddenInput: "_8GGSjoMJRi3bIAaFgk5VT"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/ImageItem.m.less": function(e, t, n) {
			e.exports = {
				GalleryMediaUpload: "_3cm8_J6ytCvL4Z0YkUO6fO",
				galleryMediaUpload: "_3cm8_J6ytCvL4Z0YkUO6fO",
				isDragging: "_1hQY_UY2EioccXnSHJuH2j",
				isSelected: "_3mV402dYSBG5F3rfKzCHih",
				isError: "_10Cb6hifpOfnmfdg7Zetit",
				galleryImage: "-_ofbVTDK5uSQ60HcXH2-",
				deleteButton: "_3611iw8TKLU1FFCTSMHMWl",
				deleteIcon: "_1RI3AZPuym8dOTJt-TRI38",
				showDeleteNormal: "_2LKMLYT_7bo_5rfh9705Pg"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/ImageItemsWrapper.m.less": function(e, t, n) {
			e.exports = {
				itemsWrapper: "_3BGk3QOycswdTTmIh9R56y",
				sortableImages: "_7eeHxLESKnWVh8uefc7iN",
				imageStyles: "_2175QbehBw28eJRKOGrVKp",
				hoverMarker: "_1q50A238Zq0unVV8sFYvEm",
				pendingItem: "_1liymuUZSLP_05fSC0_0iQ"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/InputWrapper.m.less": function(e, t, n) {
			e.exports = {
				inputWrapper: "_1ZgKdgcmpiQuMxVOb36gpi",
				inputStyles: "_3QhJ8Am-icOjVUrut4LpNH",
				urlInputStyles: "_2P6NoGE4s1hTODn5PMPuIh",
				charsCounter: "_18XDqj2Sr9Pi7101fkIdE3"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/Layout.m.less": function(e, t, n) {
			e.exports = {
				Layout: "_3uExMaQ9CE8L0F97PE7ESO",
				layout: "_3uExMaQ9CE8L0F97PE7ESO",
				hero: "_3cjkwfQbHf5cGuN_2K1uvN",
				mainContent: "D_D1mksZjLSJKHZf-qFgh",
				sideMetaContent: "_3s8GQtCSn-VS8biCUpM7QQ",
				bottomContent: "_1ipt9uyZjJ4fiF29YsWqgy"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/SelectedImage.m.less": function(e, t, n) {
			e.exports = {
				selectedImage: "_1HQ9Q4NlQY-2w_yLQXa4MW",
				pendingImage: "_16rNFI0ovowGxjX85OoDQ7"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return r
			}));
			const o = 20,
				r = 180
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/index.m.less": function(e, t, n) {
			e.exports = {
				dropArea: "_37BTO6li-OWodKOMQsps09",
				isDropAreaActive: "OPoLiV8gJNj-kgaS3TA6s",
				isDropAreaOver: "_2dpUJvIRjH1lQlhWr9Ln7B",
				errorMessage: "_1geBZyOTOcY8e2hp9dLJBb"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/MediaUpload/Preview/index.m.less": function(e, t, n) {
			e.exports = {
				Img: "_2CZpGuT-0gMB2CW-1Z4Rzr",
				img: "_2CZpGuT-0gMB2CW-1Z4Rzr",
				BlurImg: "_3lXopXY4SQ5xn1DGFU-6mv",
				blurImg: "_3lXopXY4SQ5xn1DGFU-6mv",
				ImagePreview: "_1x86R_C1SXWhk5Ta6ZwgCE",
				imagePreview: "_1x86R_C1SXWhk5Ta6ZwgCE",
				VideoPreview: "_1qFo28RpDjnwvvZFYuoYw1",
				videoPreview: "_1qFo28RpDjnwvvZFYuoYw1",
				Component: "_32O_ZBzCA0KWydc-ydD4Ut",
				component: "_32O_ZBzCA0KWydc-ydD4Ut"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/MediaUpload/UploadStatusBar/index.m.less": function(e, t, n) {
			e.exports = {
				ControlRow: "_2UeBgPJSAh_VteJrmt29jr",
				controlRow: "_2UeBgPJSAh_VteJrmt29jr",
				Button: "mU3hHnDkWt1Fu4t0MzJ3D",
				button: "mU3hHnDkWt1Fu4t0MzJ3D",
				Status: "_2tgT4LseX3Xg9TNczoQt_8",
				status: "_2tgT4LseX3Xg9TNczoQt_8",
				Component: "_1ou_efVZQLBrztRrswvRdK",
				component: "_1ou_efVZQLBrztRrswvRdK"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/MediaUpload/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_2WJ7xvGE_xrehqTKCrcVpN",
				wrapper: "_2WJ7xvGE_xrehqTKCrcVpN",
				UploadStatusBar: "_1cAEFWtInMytYP6NpKBxK7",
				uploadStatusBar: "_1cAEFWtInMytYP6NpKBxK7",
				Controls: "_2Hg3aAL1qjiKtlSICSWx59",
				controls: "_2Hg3aAL1qjiKtlSICSWx59",
				ThumbnailSelect: "_3Beo1Ag8mmirgP8ObHTty9",
				thumbnailSelect: "_3Beo1Ag8mmirgP8ObHTty9",
				Trash: "_18Z2AbfCvCglpgZoyExSaS",
				trash: "_18Z2AbfCvCglpgZoyExSaS"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/RemovePrompt/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "RbI4r-xLIZTGjyNNqMkc2",
				wrapper: "RbI4r-xLIZTGjyNNqMkc2",
				TitleRow: "_3KkK2UFvbWMkRb887z28Ay",
				titleRow: "_3KkK2UFvbWMkRb887z28Ay",
				DetailsContainer: "_3x1u7rU-TVemMtzZVifQk",
				detailsContainer: "_3x1u7rU-TVemMtzZVifQk",
				ButtonRow: "_1rR3d9OXZt1cL70vCFunZP",
				buttonRow: "_1rR3d9OXZt1cL70vCFunZP",
				CancelButton: "_2JpoeseNULOIs1m0HM_FkJ",
				cancelButton: "_2JpoeseNULOIs1m0HM_FkJ",
				ConfirmButton: "_1-56PBUj1A-mgJh4Uhz5Jd",
				confirmButton: "_1-56PBUj1A-mgJh4Uhz5Jd"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_1UbcPNs4A8n5PIWX0H5sGt",
				container: "_1UbcPNs4A8n5PIWX0H5sGt"
			}
		},
		"./src/reddit/components/PostCreationForm/PostCreationFooter/PostSettings/Hint/index.m.less": function(e, t, n) {
			e.exports = {
				Info: "_2kALbPZ2PwY7w-w3Mtrxpl",
				info: "_2kALbPZ2PwY7w-w3Mtrxpl",
				TooltipContent: "c_vthvCq93OKrS5BGZYdr",
				tooltipContent: "c_vthvCq93OKrS5BGZYdr",
				Hint: "_2yxSY9022XfAJtQVxxa1lL",
				hint: "_2yxSY9022XfAJtQVxxa1lL",
				HoverTooltip: "_3M5yvX2tFyuTet4AEPmVDL",
				hoverTooltip: "_3M5yvX2tFyuTet4AEPmVDL",
				tooltipContentClass: "_2AY8LM9XpfuTjCMB4PF1mj"
			}
		},
		"./src/reddit/components/PostCreationForm/PostCreationFooter/PostSettings/index.m.less": function(e, t, n) {
			e.exports = {
				CheckboxInput: "rLLDF6zuY7gDPdOpDtryW",
				checkboxInput: "rLLDF6zuY7gDPdOpDtryW",
				ConnectAccountLink: "_2XixtsvkuzAkwuKe93t7Bd",
				connectAccountLink: "_2XixtsvkuzAkwuKe93t7Bd",
				Container: "_1WZBFo38dOAZ_-qyyA6sNh",
				container: "_1WZBFo38dOAZ_-qyyA6sNh",
				ContainerLeft: "ncWlnJtypP1_Mwohv06zd",
				containerLeft: "ncWlnJtypP1_Mwohv06zd",
				ContainerRight: "_1rdhEwGT1578MFV4zdgyXX",
				containerRight: "_1rdhEwGT1578MFV4zdgyXX",
				CheckboxText: "_1sBmqB8geWKIW5Nt8svFgc",
				checkboxText: "_1sBmqB8geWKIW5Nt8svFgc",
				Option: "_367d1mrPAvSzXPXQZfPXq5",
				option: "_367d1mrPAvSzXPXQZfPXq5",
				TextButton: "_5SJ8wEtj0ehde_UTuEUJL",
				textButton: "_5SJ8wEtj0ehde_UTuEUJL",
				TextBox: "_1TBGkOAQIuFnbqFv3ePDxT",
				textBox: "_1TBGkOAQIuFnbqFv3ePDxT",
				Wrapper: "_2CXYv7vwpCTLV6wKUwqkBz",
				wrapper: "_2CXYv7vwpCTLV6wKUwqkBz"
			}
		},
		"./src/reddit/components/PostCreationForm/PostCreationFooter/ScheduledTimeInfo/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_3iy2yiZt_m40oq7tdW_klw",
				container: "_3iy2yiZt_m40oq7tdW_klw",
				replayIcon: "_2ks2fE4UUmcEWL1vQnR7wp"
			}
		},
		"./src/reddit/components/PostCreationForm/PostCreationFooter/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_22Te0a5VxZnLITkTavQh95",
				container: "_22Te0a5VxZnLITkTavQh95"
			}
		},
		"./src/reddit/components/PostCreationForm/PostCreationHeader/index.m.less": function(e, t, n) {
			e.exports = {
				CreateLabel: "_3M6BmdyQcCEQZu-MylN14",
				createLabel: "_3M6BmdyQcCEQZu-MylN14",
				CountIndicator: "_3-lCASba1yl0jeRpeQ5jwm",
				countIndicator: "_3-lCASba1yl0jeRpeQ5jwm",
				LinkButton: "_3KQDVc4kBIwA5u7S9n99NQ",
				linkButton: "_3KQDVc4kBIwA5u7S9n99NQ",
				CreatePostHeader: "_1HWpiNu6dkOnZixxwDYTVJ",
				createPostHeader: "_1HWpiNu6dkOnZixxwDYTVJ",
				isSubredditRec: "_3VA7_aIOtAXL0OdVGez50V"
			}
		},
		"./src/reddit/components/PostCreationForm/PostEditor/GovTypeSelector/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1kR_hX_PP5udhk-mtPuavx",
				currentSelection: "_1ZxmKr4SrkV__KWvI2gxKt",
				flexRow: "wIleinjtpdijasCWI_jCU",
				dropdownIcon: "oK9t9SNnOOCu-BraimNJE",
				newLabel: "_1pi_9nWsspppnkpr0Km1Hl",
				pollTypeIcon: "_1ZEeQaLhgbqgxX5zvvM2OO",
				text: "_3BIAW_hHKHgVyTnhczBT4A"
			}
		},
		"./src/reddit/components/PostCreationForm/PostEditor/index.m.less": function(e, t, n) {
			e.exports = {
				focusableContent: "Mb0x12Cu8JKRJRJCcf9_K",
				mPollBorder: "_3tqYz5xeUZo9em1LrxMZOB",
				mHasError: "_24RennTZzi_jyZ_kdBt9U2",
				govToggle: "_2VmXXwMxyQk230gkKvJTzF",
				pollCreator: "_3GqK73QyFc10CoXE2bReko"
			}
		},
		"./src/reddit/components/PostCreationForm/PostTitle/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3zkbHfhLbXp21FwGj_kNZV",
				inputWrapper: "_2wyvfFW3oNcCs5GVkmcJ8z",
				PostTitleInput: "_1ec_Oj5SWdypd8L-VELKg-",
				postTitleInput: "_1ec_Oj5SWdypd8L-VELKg-",
				mHasError: "_1dItJbdjTchVLwC0krCsr3",
				charsCounter: "_10vnCUi_uRLhIdKnPglWAw"
			}
		},
		"./src/reddit/components/PostCreationForm/PredictionEditor/CharacterLimitedInput/index.m.less": function(e, t, n) {
			e.exports = {
				limitedInput: "_2lR5ZrJPEFuuPq7EOi8cj7",
				wrapper: "_2fRQQgargigjS49U0fxbS3",
				charLimit: "_2wwZJZk5ONMWVwbLF02eUq"
			}
		},
		"./src/reddit/components/PostCreationForm/PredictionEditor/ThemePicker/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_3UZKVVhHWZ57zSILZs7Jvg",
				colorTile: "_1qWXr3giJbgydoIYnzWu1S"
			}
		},
		"./src/reddit/components/PostCreationForm/PredictionEditor/TokenPicker/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3c1LCTTrv7B_tSR1sfPKj6",
				customTokenContainer: "_2SDDNzFC4L5DwfyT-wvomA",
				clearTokenButton: "uKhV3nnZaif1b1RUqut47",
				clearTokenIcon: "_1JT85JqFxloG7O5BY1ykp",
				tokenButton: "_11AqxmNlBzS51cSszKCcTj",
				selected: "_3Izz7RWkEuIrfl7tUxaPyt",
				tokenIcon: "_3Mpps5wbxkuTPgwFQKbVgf",
				addTokenIcon: "RcsGY3keMhNY8RdcN8Dmw"
			}
		},
		"./src/reddit/components/PostCreationForm/PredictionEditor/TooltipHeader/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "vjz-78t1MZNL0Yxpv_u6-",
				sectionLabel: "_2T3KnyI6uKFuDKS_c-XJ1k",
				isDisabled: "_346ckAnpRr-IOKWKMNKKFl",
				content: "_2YhlH2p0vnG0YKM3OJnSz8",
				helpIcon: "_1Hia7ATY_tYOEVwill2fvR",
				activeHelpIcon: "_3o1eq5SajxFPm93nUE3I4B"
			}
		},
		"./src/reddit/components/PostCreationForm/PredictionEditor/TournamentCreation/TournamentBanner/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2FP6mPcw7L3zJOqTqLCnFi",
				label: "_2arfpEJo0GuubbTt3e8on8",
				icon: "_298481W3NrEzQxugVTYuu7",
				tournamentName: "_2c4dzGEuqzkxFjwEBDTgom"
			}
		},
		"./src/reddit/components/PostCreationForm/PredictionEditor/TournamentCreation/index.m.less": function(e, t, n) {
			e.exports = {
				firstHeader: "i-5upYMuz3__dAhqnV3c",
				learnMoreText: "_1jGtkFrbQODOeAHdDuFzU_",
				learnMoreLink: "_1EWLkW2DjJNMbp5JzYXENj",
				modal: "_35kF49LuGE4D27xekKfxE3",
				modalWrapper: "_3xBSiPU1AtljhBN4dxtqdt",
				closeButton: "z2Rf-Ta-kq8BA8J-ARDCm"
			}
		},
		"./src/reddit/components/PostCreationForm/Prompt/PromptModal.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "_35XIX8S5eAkigMxHxx98TS",
				primaryButton: "_35XIX8S5eAkigMxHxx98TS",
				ModalText: "_1ShPAP1uGnX3ZkiyNiigAA",
				modalText: "_1ShPAP1uGnX3ZkiyNiigAA"
			}
		},
		"./src/reddit/components/PostCreationForm/Prompt/PromptModal.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/higherOrderComponents/asModal/index.tsx"),
				i = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				a = n("./src/reddit/constants/keycodes.ts"),
				c = n("./src/reddit/controls/Button/index.tsx"),
				d = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				l = n("./src/reddit/controls/TextButton/index.tsx"),
				u = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				m = n("./src/reddit/components/PostCreationForm/Prompt/PromptModal.m.less"),
				p = n.n(m),
				h = n("./src/lib/lessComponent.tsx");
			const b = h.a.wrapped(c.l, "PrimaryButton", p.a),
				f = h.a.wrapped(i.p, "ModalText", p.a);
			class g extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.handleEscapeKey = e => {
						e.keyCode === a.a.Escape && this.props.onClose()
					}
				}
				componentDidMount() {
					document.addEventListener("keydown", this.handleEscapeKey)
				}
				componentWillUnmount() {
					document.removeEventListener("keydown", this.handleEscapeKey)
				}
				render() {
					const {
						primaryButtonLoading: e,
						secondaryButtonLoading: t
					} = this.props;
					return r.a.createElement(i.e, null, r.a.createElement(i.i, null, r.a.createElement(u.a, null, r.a.createElement(i.q, null, this.props.titleText), r.a.createElement(l.a, {
						onClick: this.props.onClose
					}, r.a.createElement(i.b, null)))), r.a.createElement(i.l, null, r.a.createElement(f, null, this.props.bodyText)), r.a.createElement(i.g, null, r.a.createElement(i.a, {
						onClick: this.props.onSecondaryAction
					}, t ? r.a.createElement(d.a, {
						sizePx: 16
					}) : this.props.secondaryButtonText), r.a.createElement(b, {
						onClick: this.props.onPrimaryAction
					}, e ? r.a.createElement(d.a, {
						sizePx: 16
					}) : this.props.primaryButtonText)))
				}
			}
			t.a = Object(s.a)(g)
		},
		"./src/reddit/components/PostCreationForm/Prompt/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var o, r = n("./node_modules/fbt/lib/FbtPublic.js"),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./src/reddit/components/PostCreationForm/Prompt/PromptModal.tsx");
			! function(e) {
				e.LOAD_DRAFT_MODAL_ID = "POST_CREATION__LOAD_DRAFT_MODAL_ID", e.MAX_DRAFTS_MODAL_ID = "POST_CREATION__MAX_DRAFTS_MODAL_ID", e.SWITCH_TO_RTE_MODAL_ID = "MARKDOWN_EDITOR__SWITCH_TO_RTE_MODAL_ID"
			}(o || (o = {}));
			const c = {
					title: () => r.fbt._("Load draft", null, {
						hk: "VQ7SS"
					}),
					body: () => r.fbt._("Loading this draft will discard your current post.", null, {
						hk: "49vMci"
					}),
					confirm: () => r.fbt._("Load Draft", null, {
						hk: "29mFSs"
					}),
					cancel: () => r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})
				},
				d = {
					title: () => r.fbt._("Save draft", null, {
						hk: "36SGct"
					}),
					body: () => r.fbt._("Looks like youve hit your max number of drafts. Please delete one to make room.", null, {
						hk: "4g9gOF"
					}),
					confirm: () => r.fbt._("Manage Drafts", null, {
						hk: "3a6SXJ"
					}),
					cancel: () => r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})
				},
				l = {
					title: () => r.fbt._("Switch to Fancy Pants Editor", null, {
						hk: "22mr8J"
					}),
					body: () => r.fbt._("Switching to Fancy Pants Editor may result in a loss of content", null, {
						hk: "1cWryd"
					}),
					confirm: () => r.fbt._("Switch", null, {
						hk: "36pRzE"
					}),
					cancel: () => r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})
				},
				u = {
					[o.LOAD_DRAFT_MODAL_ID]: c,
					[o.MAX_DRAFTS_MODAL_ID]: d,
					[o.SWITCH_TO_RTE_MODAL_ID]: l
				};
			class m extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.onCancel = () => {
						this.props.onCancel(this.props.modalId)
					}, this.onConfirm = () => {
						this.props.onConfirm(this.props.modalId)
					}
				}
				render() {
					const {
						modalId: e
					} = this.props, t = u[e];
					return i.a.createElement(a.a, {
						bodyText: t.body(),
						secondaryButtonText: t.cancel(),
						primaryButtonText: t.confirm(),
						titleText: t.title(),
						onClose: this.onCancel,
						onPrimaryAction: this.onConfirm,
						onSecondaryAction: this.onCancel
					})
				}
			}
			t.b = m
		},
		"./src/reddit/components/PostCreationForm/RecaptchaOverlay/index.m.less": function(e, t, n) {
			e.exports = {
				OverlayWrapper: "_36HnnNoO8oBJDJnOgDiENG",
				overlayWrapper: "_36HnnNoO8oBJDJnOgDiENG",
				OverlayContent: "_3Ye_87oAzGPJr-7DymIhl0",
				overlayContent: "_3Ye_87oAzGPJr-7DymIhl0",
				ExplanationText: "_17qYQd3F9TbaKxu_Q0ssNq",
				explanationText: "_17qYQd3F9TbaKxu_Q0ssNq"
			}
		},
		"./src/reddit/components/PostCreationForm/SafeHarborText/index.m.less": function(e, t, n) {
			e.exports = {
				TextContainer: "_3sXblbCnnsbtHR0izSxX-Q",
				textContainer: "_3sXblbCnnsbtHR0izSxX-Q"
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/DateInput/FallbackDateInput/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_3A53iTDZ6H1L--Ky3qNCTO",
				container: "_3A53iTDZ6H1L--Ky3qNCTO",
				Select: "_2ryUqzbCnNhx8nbFXg9-c0",
				select: "_2ryUqzbCnNhx8nbFXg9-c0",
				Delimiter: "_1X2oFpzvpth9SVe2-xCR9D",
				delimiter: "_1X2oFpzvpth9SVe2-xCR9D"
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/DateInput/index.m.less": function(e, t, n) {
			e.exports = {
				Input: "_1Css-vhkiry0RZJBBPrnRI",
				input: "_1Css-vhkiry0RZJBBPrnRI"
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/DateInput/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return k
			}));
			var o = n("./node_modules/lodash/once.js"),
				r = n.n(o),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./node_modules/lodash/range.js"),
				c = n.n(a),
				d = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/DateInput/FallbackDateInput/index.m.less"),
				l = n.n(d),
				u = n("./src/lib/lessComponent.tsx");
			const m = u.a.div("Container", l.a),
				p = u.a.select("Select", l.a),
				h = u.a.span("Delimiter", l.a),
				b = 2018,
				f = e => {
					const t = new Date;
					return new Date(t.getFullYear(), e).toLocaleDateString([], {
						month: "short"
					})
				},
				g = e => {
					const [t, n, o] = e.split("-").map(Number);
					return {
						year: t,
						month: n - 1,
						day: o
					}
				};
			class v extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.onChange = e => {
						const t = {
								...g(this.props.value),
								...e
							},
							{
								year: n,
								month: o,
								day: r
							} = t,
							s = new Date(Date.UTC(n, o, r)).toISOString().slice(0, 10);
						this.props.onChange(s)
					}, this.onChangeYear = e => {
						const t = +e.target.value;
						this.onChange({
							year: t
						})
					}, this.onChangeMonth = e => {
						const t = +e.target.value;
						this.onChange({
							month: t
						})
					}, this.onChangeDay = e => {
						const t = +e.target.value;
						this.onChange({
							day: t
						})
					}
				}
				render() {
					const {
						year: e,
						month: t,
						day: n
					} = g(this.props.value);
					return i.a.createElement(m, {
						className: this.props.className
					}, i.a.createElement(p, {
						onChange: this.onChangeMonth,
						value: t
					}, c()(12).map(e => i.a.createElement("option", {
						key: e,
						value: e
					}, f(e)))), i.a.createElement(h, null, "/"), i.a.createElement(p, {
						onChange: this.onChangeDay,
						value: n
					}, c()(1, 32).map(e => i.a.createElement("option", {
						key: e,
						value: e
					}, ("0" + e).slice(-2)))), i.a.createElement(h, null, "/"), i.a.createElement(p, {
						onChange: this.onChangeYear,
						value: e
					}, c()(b, b + 10).map(e => i.a.createElement("option", {
						key: e,
						value: e
					}, e))))
				}
			}
			var C = v,
				y = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/DateInput/index.m.less"),
				E = n.n(y);

			function x() {
				return (x = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const O = r()(() => {
					const e = document.createElement("input");
					return e.setAttribute("type", "date"), e.setAttribute("value", "not-a-date"), "not-a-date" !== e.value
				}),
				_ = u.a.input("Input", E.a);

			function k(e) {
				return O() ? i.a.createElement(_, x({
					type: "date"
				}, e, {
					onChange: t => e.onChange(t.target.value)
				})) : i.a.createElement(C, e)
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/TimeInput/FallbackTimeInput/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "Q-u1MdpyF-DbsLmmseQmg",
				container: "Q-u1MdpyF-DbsLmmseQmg",
				Input: "_2UYlo-ZbVNGY329O9jwCzC",
				input: "_2UYlo-ZbVNGY329O9jwCzC",
				Delimiter: "_2a_r5Jp8FH3k8flNGKLy5f",
				delimiter: "_2a_r5Jp8FH3k8flNGKLy5f"
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/TimeInput/index.m.less": function(e, t, n) {
			e.exports = {
				TimeInput: "gRgwdQKTQf9yT3db3ACAy",
				timeInput: "gRgwdQKTQf9yT3db3ACAy"
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/TimeInput/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return k
			}));
			var o = n("./node_modules/lodash/once.js"),
				r = n.n(o),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./node_modules/lodash/clamp.js"),
				c = n.n(a),
				d = n("./src/reddit/components/FocusableContent/index.tsx"),
				l = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/TimeInput/FallbackTimeInput/index.m.less"),
				u = n.n(l),
				m = n("./src/lib/lessComponent.tsx");
			const p = m.a.wrapped(d.a, "Container", u.a),
				h = m.a.input("Input", u.a),
				b = m.a.span("Delimiter", u.a),
				f = e => ("0" + e).slice(-2),
				g = (e, t) => {
					const n = +e.slice(-2);
					if (Number.isInteger(n)) return n > t ? 0 : n
				};
			class v extends i.a.PureComponent {
				constructor(e) {
					super(e), this.callOnChange = () => {
						let e = c()(+this.state.hour, 0, 24);
						const t = c()(+this.state.minute, 0, 59);
						24 === e && t > 0 && (e = 0), this.setState({
							hour: e,
							minute: t
						});
						const n = `${f(e)}:${f(t)}`;
						this.props.onChange(n)
					}, this.onChangeHour = e => {
						const t = g(e.target.value, 24);
						void 0 !== t && this.setState({
							hour: t
						}, this.callOnChange)
					}, this.onChangeMinute = e => {
						const t = g(e.target.value, 59);
						void 0 !== t && this.setState({
							minute: t
						}, this.callOnChange)
					}, this.onHourInputBlur = () => this.setState({
						isHourInputFocused: !1
					}), this.onHourInputFocus = () => this.setState({
						isHourInputFocused: !0
					}), this.onMinuteInputBlur = () => this.setState({
						isMinuteInputFocused: !1
					}), this.onMinuteInputFocus = () => this.setState({
						isMinuteInputFocused: !0
					});
					const [t, n] = e.value.split(":").map(Number);
					this.state = {
						hour: t,
						minute: n,
						isHourInputFocused: !1,
						isMinuteInputFocused: !1
					}
				}
				componentWillReceiveProps(e) {
					const [t, n] = e.value.split(":").map(Number);
					this.setState({
						hour: t,
						minute: n
					})
				}
				render() {
					const e = this.state.isHourInputFocused || this.state.isMinuteInputFocused;
					return i.a.createElement(p, {
						className: this.props.className,
						isFocused: e
					}, i.a.createElement(h, {
						type: "number",
						onChange: this.onChangeHour,
						onFocus: this.onHourInputFocus,
						onBlur: this.onHourInputBlur,
						value: f(this.state.hour)
					}), i.a.createElement(b, null, ":"), i.a.createElement(h, {
						type: "number",
						onChange: this.onChangeMinute,
						onFocus: this.onMinuteInputFocus,
						onBlur: this.onMinuteInputBlur,
						value: f(this.state.minute)
					}))
				}
			}
			var C = v,
				y = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/TimeInput/index.m.less"),
				E = n.n(y);

			function x() {
				return (x = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const O = r()(() => {
					const e = document.createElement("input");
					return e.setAttribute("type", "time"), e.setAttribute("value", "not-a-time"), "not-a-time" !== e.value
				}),
				_ = m.a.input("TimeInput", E.a);

			function k(e) {
				return O() ? i.a.createElement(_, x({
					type: "time"
				}, e, {
					onChange: t => e.onChange(t.target.value)
				})) : i.a.createElement(C, e)
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/TimezoneSelector/index.m.less": function(e, t, n) {
			e.exports = {
				select: "_1gQeiuYndtyKo6Or5iS8xL"
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/TimezoneSelector/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/loadWithRetries/index.ts"),
				a = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				c = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/TimezoneSelector/index.m.less"),
				d = n.n(c);
			const l = e => {
				const t = e.map(a.d);
				return t.sort((e, t) => {
					const n = -1440,
						{
							offset: o = n
						} = e,
						{
							offset: r = n
						} = t;
					return r - o || (e.displayText < t.displayText ? -1 : 1) || 0
				}), t
			};
			class u extends r.a.PureComponent {
				constructor(e) {
					super(e), this.onSelect = e => {
						const t = e.target.value;
						this.props.onChange(t)
					};
					const t = u.cachedTimezoneOptions || l([this.props.selectedTimezoneName]);
					this.state = {
						timezoneOptions: t
					}
				}
				async loadTimezones() {
					const e = (await Object(i.a)(() => n.e("TimezoneList").then(n.bind(null, "./src/lib/timezone/timezoneList.ts")))).default,
						t = l(e);
					this.setState({
						timezoneOptions: t
					}), u.cachedTimezoneOptions = t
				}
				componentDidMount() {
					u.cachedTimezoneOptions || this.loadTimezones()
				}
				render() {
					return r.a.createElement("select", {
						onChange: this.onSelect,
						value: this.props.selectedTimezoneName,
						className: Object(s.a)(d.a.select, this.props.className)
					}, this.state.timezoneOptions.map(e => {
						let {
							name: t,
							displayText: n
						} = e;
						return r.a.createElement("option", {
							key: t,
							value: t
						}, n)
					}))
				}
			}
			t.a = u
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "ppLwDvFzc7jVTiV_5euUj",
				container: "ppLwDvFzc7jVTiV_5euUj",
				Content: "_3VbwtRsayHUBLVMtjkul4u",
				content: "_3VbwtRsayHUBLVMtjkul4u",
				TitleRow: "_2aRE3m6KuLAhRIDmdmFKaY",
				titleRow: "_2aRE3m6KuLAhRIDmdmFKaY",
				Hr: "_1aShcxrllO1loaDr49TUUo",
				hr: "_1aShcxrllO1loaDr49TUUo",
				TimeInput: "_1bu7h4vK0WEgtRzSz-_mbA",
				timeInput: "_1bu7h4vK0WEgtRzSz-_mbA",
				TimeSelectionRow: "BUT684iT0_upDm6a1x4q_",
				timeSelectionRow: "BUT684iT0_upDm6a1x4q_",
				RadioOptionContent: "_3Ry1zpEULyeAACzRNZgIHN",
				radioOptionContent: "_3Ry1zpEULyeAACzRNZgIHN",
				OptionDetails: "_3imVLMudY3hxD1tq8KO6MB",
				optionDetails: "_3imVLMudY3hxD1tq8KO6MB",
				RadioInput: "_3VPprBv9bGCEm-hzjVWKmd",
				radioInput: "_3VPprBv9bGCEm-hzjVWKmd",
				RadioOption: "V4Tm9i9X2Co6LU8ez1zlw",
				radioOption: "V4Tm9i9X2Co6LU8ez1zlw",
				Delimiter: "_2bajvlJVcTANoHFRcmq7lu",
				delimiter: "_2bajvlJVcTANoHFRcmq7lu",
				Footer: "_3KeMI-XaG-5bILTvrCkaGS",
				footer: "_3KeMI-XaG-5bILTvrCkaGS",
				CancelButton: "_2NvAutu3QQJ9DwGHa83msC",
				cancelButton: "_2NvAutu3QQJ9DwGHa83msC",
				DeleteButton: "_3mKiK6bFRKi6y6Wkk1xLyp",
				deleteButton: "_3mKiK6bFRKi6y6Wkk1xLyp",
				ErrorMessage: "ZK5-SDSIvd4eGlmmbaRoO",
				errorMessage: "ZK5-SDSIvd4eGlmmbaRoO",
				ClearIcon: "E0CXpIVd8SDvRSwZFAmCn",
				clearIcon: "E0CXpIVd8SDvRSwZFAmCn"
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./src/higherOrderComponents/asModal/index.tsx"),
				a = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				d = n("./src/lib/timezone/index.ts"),
				l = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				u = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/utils.ts"),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				h = n("./src/reddit/controls/RadioInput/index.tsx"),
				b = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				f = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				g = n("./src/reddit/helpers/trackers/postEvent.ts"),
				v = n("./src/reddit/icons/svgs/ClearFilled/index.tsx"),
				C = n("./src/reddit/layout/row/Inline/index.tsx"),
				y = n("./src/reddit/models/PostCreationForm/index.ts"),
				E = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/DateInput/index.tsx"),
				x = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/TimeInput/index.tsx"),
				O = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/TimezoneSelector/index.tsx"),
				_ = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/index.m.less"),
				k = n.n(_);
			const j = 240,
				S = () => {
					const e = new Date;
					e.setMinutes(60);
					const t = Object(d.g)(e);
					return e.setMinutes(e.getMinutes() + j), {
						startDate: t,
						endDate: Object(d.g)(e),
						submitTime: y.j.Now,
						timezoneName: Object(d.b)() || d.a
					}
				},
				T = c.a.div("Container", k.a),
				w = c.a.div("Content", k.a),
				I = c.a.div("TitleRow", k.a),
				P = c.a.hr("Hr", k.a),
				N = c.a.wrapped(x.a, "TimeInput", k.a),
				R = c.a.div("TimeSelectionRow", k.a),
				M = c.a.div("RadioOptionContent", k.a),
				D = c.a.span("OptionDetails", k.a),
				L = c.a.wrapped(h.a, "RadioInput", k.a),
				A = c.a.wrapped(b.a, "RadioOption", k.a),
				F = c.a.span("Delimiter", k.a),
				B = c.a.wrapped(l.g, "Footer", k.a),
				U = c.a.wrapped(p.o, "CancelButton", k.a),
				K = c.a.wrapped(p.o, "DeleteButton", k.a),
				W = c.a.div("ErrorMessage", k.a),
				G = c.a.wrapped(v.a, "ClearIcon", k.a);
			class H extends s.a.PureComponent {
				constructor(e) {
					super(e), this.currentTimezone = Object(d.b)(), this.maxDate = Object(u.a)(), this.buildEventSchedule = () => ({
						startDate: Object(f.a)(this.state.startDate, this.state.startTime),
						endDate: Object(f.a)(this.state.endDate, this.state.endTime),
						timezoneName: this.state.timezoneName,
						submitTime: this.state.submitTime
					}), this.onStartDateChange = e => {
						this.setState({
							startDate: e
						}, this.updateEndDatetime)
					}, this.onStartTimeChange = e => {
						this.setState({
							startTime: e
						}, this.updateEndDatetime)
					}, this.updateEndDatetime = () => {
						if (this.state.isEndTimeTouched) return;
						const {
							startDate: e,
							startTime: t
						} = this.state;
						if (e && t) {
							const n = Object(d.f)(Object(f.a)(e, t));
							n.setMinutes(n.getMinutes() + j);
							const [o, r] = Object(f.i)(Object(d.g)(n));
							this.setState({
								endDate: o,
								endTime: r
							})
						}
					}, this.onEndDateChange = e => {
						this.setState({
							endDate: e,
							isEndTimeTouched: !0
						})
					}, this.onEndTimeChange = e => {
						this.setState({
							endTime: e,
							isEndTimeTouched: !0
						})
					}, this.onTimezoneChange = e => {
						this.setState({
							timezoneName: e
						})
					}, this.onSubmitTimeChange = e => {
						this.setState({
							submitTime: e
						})
					}, this.onApplyClick = () => {
						const e = this.buildEventSchedule();
						this.props.sendEvent(Object(g.b)(e)), this.props.onChange(e), this.props.onClose()
					}, this.onDeleteButtonClick = () => {
						const e = this.buildEventSchedule();
						this.props.sendEvent(Object(g.d)(e)), this.props.onChange(null), this.props.onClose()
					}, this.onCancelButtonClick = () => {
						this.props.sendEvent(Object(g.c)()), this.props.onClose()
					}, this.getValidationError = () => {
						const {
							endDate: e,
							endTime: t,
							startDate: n,
							startTime: r
						} = this.state;
						if (!(n && r && e && t)) return o.fbt._("Please enter valid start and end time", null, {
							hk: "2IyBsT"
						});
						const s = Object(d.f)(Object(f.a)(n, r)),
							i = Object(d.f)(Object(f.a)(e, t));
						return s < (this.currentTimezone === this.state.timezoneName ? new Date : new Date(Date.now() - a.D)) ? o.fbt._("Event start time needs to be in the future", null, {
							hk: "3oL3LM"
						}) : i < s ? o.fbt._("End time must be after start time", null, {
							hk: "3C3TKE"
						}) : null
					}, this.getSubmitAtLabel = () => {
						const {
							startDate: e,
							startTime: t
						} = this.state;
						return Object(f.b)(e, t)
					}, this.renderSubmitTimeRadio = () => s.a.createElement(L, {
						value: this.state.submitTime,
						name: "submit_time",
						onChange: this.onSubmitTimeChange
					}, s.a.createElement(A, {
						showButton: !0,
						value: y.j.Now
					}, s.a.createElement(M, null, s.a.createElement("span", null, o.fbt._("Now", null, {
						hk: "4Cro9L"
					})), s.a.createElement(D, null, o.fbt._("Let people follow your event ahead of time so they can make sure to come back when it starts.", null, {
						hk: "xTSNh"
					})))), s.a.createElement(A, {
						showButton: !0,
						value: y.j.AtEventTime
					}, s.a.createElement(M, null, s.a.createElement("span", null, this.getSubmitAtLabel()), s.a.createElement(D, null, o.fbt._("Edit and hide this post until the event starts.", null, {
						hk: "2VC38O"
					})))));
					const t = e.schedule || S(),
						[n, r] = Object(f.i)(t.startDate),
						[i, c] = Object(f.i)(t.endDate);
					this.state = {
						startDate: n,
						startTime: r,
						endDate: i,
						endTime: c,
						timezoneName: t.timezoneName,
						submitTime: t.submitTime,
						isEndTimeTouched: !!e.schedule
					}
				}
				componentDidMount() {
					this.props.sendEvent(Object(g.e)())
				}
				render() {
					const {
						shouldShowSubmitTime: e
					} = this.props, t = this.getValidationError();
					return s.a.createElement(T, null, s.a.createElement(w, null, s.a.createElement(I, null, o.fbt._("When is the event?", null, {
						hk: "2fTD7f"
					})), s.a.createElement(R, null, o.fbt._("{start time}{to}{end time}", [o.fbt._param("start time", s.a.createElement("fieldset", null, s.a.createElement("legend", null, o.fbt._("Start time", null, {
						hk: "3nqplI"
					})), s.a.createElement(E.a, {
						max: this.maxDate,
						onChange: this.onStartDateChange,
						value: this.state.startDate
					}), s.a.createElement(N, {
						onChange: this.onStartTimeChange,
						value: this.state.startTime
					}))), o.fbt._param("to", s.a.createElement(F, null, o.fbt._("to", null, {
						hk: "2tWTBK"
					}))), o.fbt._param("end time", s.a.createElement("fieldset", {
						style: {
							opacity: this.state.isEndTimeTouched ? 1 : .5
						}
					}, s.a.createElement("legend", null, o.fbt._("End time (optional)", null, {
						hk: "2XKdsz"
					})), s.a.createElement(E.a, {
						max: this.maxDate,
						onChange: this.onEndDateChange,
						value: this.state.endDate
					}), s.a.createElement(N, {
						onChange: this.onEndTimeChange,
						value: this.state.endTime
					})))], {
						hk: "3MRWfF"
					})), s.a.createElement("div", null, s.a.createElement("label", null, o.fbt._("Time zone", null, {
						hk: "3F7Bko"
					}), s.a.createElement(O.a, {
						selectedTimezoneName: this.state.timezoneName,
						onChange: this.onTimezoneChange
					}))), e && s.a.createElement(s.a.Fragment, null, s.a.createElement(P, null), s.a.createElement("fieldset", null, s.a.createElement("legend", null, o.fbt._("When do you want to post this event?", null, {
						hk: "3OEsrt"
					})), this.renderSubmitTimeRadio()))), s.a.createElement(B, null, s.a.createElement(C.a, null, this.props.schedule && this.props.shouldShowDeleteButton && s.a.createElement(K, {
						onClick: this.onDeleteButtonClick
					}, s.a.createElement(G, null), o.fbt._("Clear", null, {
						hk: "npkgK"
					})), s.a.createElement(U, {
						onClick: this.onCancelButtonClick
					}, o.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), s.a.createElement(p.l, {
						onClick: this.onApplyClick,
						disabled: !!t
					}, o.fbt._("Apply", null, {
						hk: "2TE8JD"
					}))), t && s.a.createElement(W, null, t)))
				}
			}
			t.default = Object(i.a)(Object(m.c)(H))
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/utils.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var o = n("./src/lib/timezone/index.ts"),
				r = n("./src/reddit/helpers/scheduledPosts/index.ts");
			const s = () => {
				const e = new Date;
				e.setFullYear(e.getFullYear() + 1);
				const [t] = Object(r.i)(Object(o.g)(e));
				return t
			}
		},
		"./src/reddit/components/PostCreationForm/SubredditChangePrompt/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_1elQqozWN8v7kNb3-2JJnv",
				wrapper: "_1elQqozWN8v7kNb3-2JJnv",
				TitleRow: "_21ZJQglqJoGvKPVrE1g6y4",
				titleRow: "_21ZJQglqJoGvKPVrE1g6y4",
				DetailsContainer: "_2BCyPW29meUC7c2ZvAIF6O",
				detailsContainer: "_2BCyPW29meUC7c2ZvAIF6O",
				ButtonRow: "_3-rBvo8wMI4G0IKFdRF5et",
				buttonRow: "_3-rBvo8wMI4G0IKFdRF5et",
				CancelButton: "_12whVTuRHmPsEJZdopRGQN",
				cancelButton: "_12whVTuRHmPsEJZdopRGQN",
				ConfirmButton: "ERUkO2xr-Jto7MQoScSJG",
				confirmButton: "ERUkO2xr-Jto7MQoScSJG"
			}
		},
		"./src/reddit/components/PostCreationForm/Tabs/index.m.less": function(e, t, n) {
			e.exports = {
				Icon: "_3WIAbYQQdSmuuFLDSfhn5_",
				icon: "_3WIAbYQQdSmuuFLDSfhn5_",
				Container: "_3vyt9N_0jfZuOwByiKDi9x",
				container: "_3vyt9N_0jfZuOwByiKDi9x",
				row: "_3fd4Ceu6mb8NI6WVk0Yv5c",
				Tab: "Z1w8VkpQ23E1Wdq_My3U4",
				tab: "Z1w8VkpQ23E1Wdq_My3U4",
				isActive: "j1Q89sB76i7EBRDhnQhlr"
			}
		},
		"./src/reddit/components/PostCreationForm/index.m.less": function(e, t, n) {
			e.exports = {
				FormContent: "_3w_665DK_NH7yIsRMuZkqB",
				formContent: "_3w_665DK_NH7yIsRMuZkqB",
				CrosspostBox: "QQaE6143-4kvEuZSTBX7_",
				crosspostBox: "QQaE6143-4kvEuZSTBX7_",
				FormContainer: "HOFZo2X7Fr6JVBztpsByj",
				formContainer: "HOFZo2X7Fr6JVBztpsByj",
				TabContent: "_1zq6UabIEJJ-z9grsiCJY7",
				tabContent: "_1zq6UabIEJJ-z9grsiCJY7",
				PostingGuidelines: "_2vcPDTxC76PPQ70AdMkN0C",
				postingGuidelines: "_2vcPDTxC76PPQ70AdMkN0C",
				isSubredditRec: "_1JYtueM9ArhhK0dI1oOwCA",
				postToTitle: "_1Kxdp9wMJTKjsFvSZoeDzP",
				TalkSettings: "_3I1jRnhWPH1i6yzgZEg6N3",
				talkSettings: "_3I1jRnhWPH1i6yzgZEg6N3"
			}
		},
		"./src/reddit/components/PostFlairPicker/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return l
			}));
			var o = n("./node_modules/lodash/isEqual.js"),
				r = n.n(o),
				s = n("./src/reddit/constants/flair.ts"),
				i = n("./src/reddit/helpers/flair.ts"),
				a = n("./src/reddit/models/Flair/index.ts");
			const c = e => (e || []).find(e => e.type === a.f.Text || e.type === a.f.Image || e.type === a.f.Richtext);
			var d;
			! function(e) {
				e[e.InvalidTemplate = 0] = "InvalidTemplate", e[e.NoChanges = 1] = "NoChanges", e[e.NotSelected = 2] = "NotSelected", e[e.TextIsNotAllowed = 3] = "TextIsNotAllowed", e[e.TextIsEmpty = 4] = "TextIsEmpty", e[e.TextIsTooLong = 5] = "TextIsTooLong"
			}(d || (d = {}));
			const l = (e, t, n) => {
				if (n && !t) return {
					canSave: !0
				};
				if (!t) return {
					canSave: !1,
					reason: d.NotSelected
				};
				const o = e && t.templateId ? e[t.templateId] : void 0;
				if (!o) return {
					canSave: !1,
					reason: d.InvalidTemplate
				};
				const a = Object(i.g)(t).length;
				return 0 === a ? {
					canSave: !1,
					reason: d.TextIsEmpty
				} : a > s.g ? {
					canSave: !1,
					reason: d.TextIsTooLong
				} : Object(i.n)(t) && !Object(i.r)(o) ? {
					canSave: !1,
					reason: d.TextIsNotAllowed
				} : r()(n, t) ? {
					canSave: !1,
					reason: d.NoChanges
				} : {
					canSave: !0
				}
			}
		},
		"./src/reddit/components/PostFlairPicker/index.m.less": function(e, t, n) {
			e.exports = {
				buttonsRow: "cF9DU_4WDAKS4gs43ct2_",
				clearButton: "_3vB6Y9PiwJ0YV6c9MGbDwT"
			}
		},
		"./src/reddit/components/PostFlairPicker/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return _
			}));
			var o, r = n("./node_modules/fbt/lib/FbtPublic.js"),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/components/TrackingHelper/index.tsx"),
				l = n("./src/higherOrderComponents/asModal/index.tsx"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/components/FlairPickerTitle/index.tsx"),
				p = n("./src/reddit/components/FlairPickerWrapper/index.tsx"),
				h = n("./src/reddit/components/FlairPreview/index.tsx"),
				b = n("./src/reddit/components/FlairSearch/index.tsx"),
				f = n("./src/reddit/controls/Button/index.tsx"),
				g = n("./src/reddit/helpers/trackers/postComposer.ts"),
				v = n("./src/reddit/models/Flair/index.ts"),
				C = n("./src/reddit/selectors/postFlair.ts"),
				y = n("./src/reddit/selectors/subreddit.ts"),
				E = n("./src/reddit/components/PostFlairPicker/helpers.ts"),
				x = n("./src/reddit/components/PostFlairPicker/index.m.less"),
				O = n.n(x);
			! function(e) {
				e.UNSET = "unset", e.MOD_FLATLIST = "postModFlatlist", e.POST_OVERFLOW = "postOverlay"
			}(o || (o = {}));
			const _ = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
						n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : o.UNSET;
					return `PostFlair__Modal-[postId: ${e}]-isOverlay[${t}]-position[${n}]`
				},
				k = Object(c.c)({
					flairData: C.d,
					subreddit: y.X
				});
			class j extends i.a.Component {
				constructor(e) {
					super(e), this.trackEvent = () => {
						this.props.sendEvent(Object(g.G)(this.props.subredditId))
					}, this.onApply = () => {
						const {
							previewFlair: e
						} = this.state, t = e && e.templateId;
						this.props.onFlairChanged({
							previewFlair: e,
							selectedTemplateId: t
						}), this.props.closeModal && this.props.closeModal(), this.trackEvent()
					}, this.onClear = () => {
						this.props.sendEvent(Object(g.b)()), this.setSelectedFlair(null)
					}, this.setSelectedFlair = e => {
						this.setState({
							previewFlair: e
						})
					};
					const t = Object(E.c)(e.flairs);
					this.state = {
						previewFlair: t || null
					}
				}
				canSave() {
					const {
						templates: e
					} = this.props.flairData, {
						previewFlair: t
					} = this.state, n = Object(E.c)(this.props.flairs) || null;
					return Object(E.b)(e, t, n)
				}
				render() {
					const {
						props: e
					} = this, {
						previewFlair: t
					} = this.state, {
						className: n,
						flairData: o,
						subreddit: s
					} = e, a = s.displayText, {
						templates: c,
						templateIds: d
					} = o, {
						canSave: l
					} = this.canSave();
					return i.a.createElement(p.a, {
						className: n
					}, i.a.createElement(m.a, {
						onClosePressed: e.closeModal,
						title: r.fbt._("Select {subredditName} flair", [r.fbt._param("subredditName", a)], {
							hk: "1lDMWS"
						})
					}), i.a.createElement(h.a, {
						flair: t,
						flairTemplateType: v.d.LinkFlair,
						placeholderText: r.fbt._("Post Title", null, {
							hk: "43RsbC"
						})
					}), i.a.createElement(b.a, {
						flair: t,
						flairTemplateType: v.d.LinkFlair,
						subredditId: s.id,
						templates: c,
						templateIds: d,
						onChange: this.setSelectedFlair
					}), i.a.createElement("div", {
						className: O.a.buttonsRow
					}, i.a.createElement(f.l, {
						disabled: !l,
						onClick: this.onApply
					}, r.fbt._("Apply", null, {
						hk: "3mAjVQ"
					})), i.a.createElement(f.o, {
						className: O.a.clearButton,
						onClick: this.onClear
					}, r.fbt._("Clear Flair", null, {
						hk: "3jvT0B"
					}))))
				}
			}
			const S = Object(a.b)(k, (e, t) => ({
				closeModal: () => e(Object(u.i)(t.modalId))
			}))(j);
			t.a = Object(l.a)(Object(d.c)(S))
		},
		"./src/reddit/components/PostGuidance/index.m.less": function(e, t, n) {
			e.exports = {
				errorText: "_29Z8rNOZEXZzQgelIlxW5t",
				showAllBtn: "_3y2uOHfsXNElM_JH5BKn76"
			}
		},
		"./src/reddit/components/PostGuidance/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./src/redditGQL/types.ts"),
				a = n("./src/lib/hooks/usePrevious.ts"),
				c = n("./src/reddit/components/RichTextJson/index.tsx"),
				d = n("./src/reddit/components/PostGuidance/index.m.less"),
				l = n.n(d);
			const u = e => {
				let {
					triggeredRules: t = [],
					trackPostGuidanceView: n,
					emptyState: d = !1
				} = e;
				const [u, m] = Object(r.useState)(!1), p = t.filter(e => e.actionType === i.O.Block), h = p.length > 0 ? p : t, b = u ? h : h.slice(0, 5), f = Object(a.a)(b);
				return Object(r.useEffect)(() => {
					const e = b.map(e => e.guidanceId),
						t = (null == f ? void 0 : f.map(e => e.guidanceId)) || [],
						o = e.filter(e => !(null == t ? void 0 : t.includes(e)));
					n && o.length > 0 && n(o)
				}, [t, b, f, n]), s.a.createElement("div", {
					"data-testid": "post-guidance-validation"
				}, s.a.createElement("ol", null, b.map((e, t) => s.a.createElement("li", {
					className: `${d||e.actionType!==i.O.Block?"":l.a.errorText} text-12 pt-2xs`,
					key: t
				}, e.validationMessage.richtext ? s.a.createElement(c.b, {
					className: `${d||e.actionType!==i.O.Block?"":l.a.errorText} !text-12 !pt-2xs`,
					useExplicitTextColor: !0,
					content: JSON.parse(e.validationMessage.richtext),
					rtJsonElementProps: {}
				}) : e.validationMessage.markdown))), h.length > 5 && s.a.createElement("button", {
					"data-testid": "post-guidance-btn",
					className: `text-12 pt-2xs ${l.a.showAllBtn}`,
					onClick: () => m(e => !e)
				}, u ? o.fbt._("View less", null, {
					hk: "4dXCrs"
				}) : o.fbt._("View more", null, {
					hk: "mvs5E"
				})))
			}
		},
		"./src/reddit/components/PostMeta/index.m.less": function(e, t, n) {
			e.exports = {
				metaContainer: "Ywkt6EDfNWINeTr9lP29H",
				postTopMeta: "iaAYGvTNtknkTxuHArCzL",
				subredditName: "_1L0pdcPf58t25Jy6ljHIKR",
				SubscribeButton: "_2r87gmhJ9n0MsylKHkgDcp",
				subscribeButton: "_2r87gmhJ9n0MsylKHkgDcp",
				addModNote: "CUh9f8Zri7XfZRUI18jS5"
			}
		},
		"./src/reddit/components/PostMeta/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/selectors/moderatorPermissions.ts"),
				a = n("./src/reddit/components/AwardBadges/index.tsx"),
				c = n("./src/reddit/components/CCM/AddModNoteCTA/index.tsx"),
				d = n("./src/reddit/components/Hovercards/SubredditHovercard/index.tsx"),
				l = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				u = n("./src/reddit/components/PostBadges/index.tsx"),
				m = n("./src/reddit/components/PostTopMeta/index.tsx"),
				p = n("./src/reddit/components/QuarantinedLabel/index.tsx"),
				h = n("./src/reddit/components/SubredditNameLink/index.tsx"),
				b = n("./src/reddit/components/SubscribeButton/Inline.tsx"),
				f = n("./src/reddit/constants/posts.ts"),
				g = n("./src/reddit/controls/Button/index.tsx"),
				v = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				C = n("./src/reddit/helpers/trackers/post.ts"),
				y = n("./src/reddit/hooks/useClickSourceData.ts"),
				E = n("./src/reddit/models/Subreddit/index.ts"),
				x = n("./src/reddit/components/PostMeta/index.m.less"),
				O = n.n(x);
			t.a = e => {
				const {
					flairStyleTemplate: t,
					hideGildCta: n,
					inSubredditOrProfile: o,
					isCurrentUserProfilePost: x,
					isOverlay: _,
					isTopicPage: k,
					post: j,
					shouldShowSubscribeButton: S,
					subredditOrProfile: T,
					tooltipType: w
				} = e, I = !!k, P = Object(y.a)(), N = Object(s.e)(e => !!T && Object(i.i)(e, T.id));
				return r.a.createElement("div", {
					className: O.a.metaContainer
				}, !o && !j.isSponsored && T && r.a.createElement(d.a, {
					postId: j.id,
					subredditName: T.name
				}, r.a.createElement(h.a, {
					className: O.a.subredditName,
					"data-click-id": "subreddit",
					to: {
						pathname: T.url,
						state: P
					}
				}, T.displayText)), T && T.isQuarantined && r.a.createElement(p.a, null), !o && !j.isSponsored && T && S && !x && r.a.createElement(b.a, {
					className: O.a.SubscribeButton,
					getEventFactory: e => Object(C.n)(j.id, e ? "unsubscribe" : "subscribe"),
					identifier: {
						name: T.name,
						type: Object(E.i)(T) ? f.a.PROFILE : f.a.SUBREDDIT
					},
					postId: j.id,
					size: g.d.XXS,
					small: !0
				}), !o && !j.isSponsored && r.a.createElement(v.b, null), !o && !j.isSponsored && r.a.createElement(l.h, {
					type: j.belongsTo.type,
					id: j.belongsTo.id
				}), r.a.createElement(m.g, {
					className: O.a.postTopMeta,
					flairStyleTemplate: t,
					post: j,
					tooltipType: w,
					isModWithUserNotesPermissions: N
				}), r.a.createElement(u.a, {
					displayText: T ? T.displayText : null,
					inSubredditOrProfile: !!o,
					post: j,
					tooltipType: w
				}), !I && r.a.createElement(a.a, {
					hideCta: n,
					thing: j,
					tooltipType: _ ? m.f.Lightbox : void 0
				}), N && r.a.createElement(c.a, {
					postOrComment: j,
					className: O.a.addModNote
				}))
			}
		},
		"./src/reddit/components/PostTitle/getLeftAndRightFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var o = n("./src/reddit/helpers/flair.ts"),
				r = n("./src/reddit/models/Flair/index.ts");

			function s(e) {
				let {
					flair: t,
					isFlairPositionedLeft: n,
					showNSFWSpoilerFlairsOnly: s,
					hideNSFWSpoilerFlair: i
				} = e;
				const a = [],
					c = [],
					d = [];
				for (const m of t) m.type === r.f.Nsfw || m.type === r.f.Spoiler ? a.push(m) : Object(o.q)(m.type) ? c.push(m) : d.push(m);
				let l = [],
					u = [];
				return n ? s ? (l = a, u = []) : i ? (l = c, u = d) : (l = c, u = [...a, ...d]) : s ? (l = [], u = a) : i ? (l = [], u = [...c, ...d]) : (l = [], u = [...c, ...a, ...d]), {
					leftFlair: l,
					rightFlair: u
				}
			}
		},
		"./src/reddit/components/PostTitle/index.m.less": function(e, t, n) {
			e.exports = {
				outboundLinkIcon: "qgDkGQIoFEpMMeNtfI0BY",
				pollMeta: "FKej75-i0z1XubMqeVh9Q",
				styledLink: "SQnoC3ObvgnGjWt90zD9Z",
				Title: "_2SdHzo12ISmrC8H86TgSCp",
				title: "_2SdHzo12ISmrC8H86TgSCp",
				titleContainer: "y8HYJ-y_lTUHkQIc1mdCq",
				isNoWrap: "_2_QBmCTk6VD4M3dvKqXD23",
				isVisitedEnabled: "_2INHSNB8V5eaWp4P0rY_mE",
				postTitleVisibility: "_1hLrLjnE1G_RBCNcN9MVQf",
				blur: "_1Y3R-LNfq0EOkZUcePSt1j",
				ExtraLarge: "_29WrubtjAcKqzJSPdQqQ4h",
				extraLarge: "_29WrubtjAcKqzJSPdQqQ4h",
				Large: "_3wqmjmv3tb_k-PROt7qFZe",
				large: "_3wqmjmv3tb_k-PROt7qFZe",
				Medium: "_1zpZYP8cFNLfLDexPY65Y7",
				medium: "_1zpZYP8cFNLfLDexPY65Y7",
				Small: "uWdXen_41bh0iwLrgzFkc",
				small: "uWdXen_41bh0iwLrgzFkc",
				ExtraSmall: "_1aqE18-N18ZIRlkE1wa7DP",
				extraSmall: "_1aqE18-N18ZIRlkE1wa7DP",
				Metadata: "_2_YD0sbnnLrJvpCrMxBFaC",
				metadata: "_2_YD0sbnnLrJvpCrMxBFaC",
				Component: "_2FCtq-QzlfuN-SwVMUZMM3",
				component: "_2FCtq-QzlfuN-SwVMUZMM3"
			}
		},
		"./src/reddit/components/PostTitle/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return F
			})), n.d(t, "a", (function() {
				return J
			}));
			var o = n("./src/config.ts"),
				r = n("./node_modules/polished/dist/polished.es.js"),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./node_modules/reselect/es/index.js"),
				l = n("./src/lib/ads/index.ts"),
				u = n("./src/lib/classNames/index.ts"),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/contexts/PageLayer/index.tsx"),
				h = n("./src/reddit/controls/OutboundLink/index.tsx"),
				b = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				f = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				g = n("./src/reddit/actions/post.ts"),
				v = n("./src/reddit/constants/adEvents.ts"),
				C = n("./src/reddit/helpers/path/index.ts"),
				y = n("./src/reddit/hooks/useClickSourceData.ts"),
				E = n("./src/reddit/hooks/useIsRemovedOrDeletedPost.ts"),
				x = n("./src/reddit/hooks/usePostContext.ts"),
				O = n("./src/reddit/hooks/useTheme.ts"),
				_ = n("./src/reddit/icons/fonts/index.tsx"),
				k = n("./src/reddit/models/Flair/index.ts"),
				j = n("./src/reddit/models/Media/index.ts"),
				S = n("./src/reddit/models/Post/index.ts"),
				T = n("./src/reddit/models/Prediction/Tournament/index.ts"),
				w = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				I = n("./src/lib/getShortenedLink.ts"),
				P = n("./src/reddit/components/FlairWrapper/index.tsx"),
				N = n("./node_modules/fbt/lib/FbtPublic.js"),
				R = n("./src/lib/prettyPrintNumber/index.ts"),
				M = n("./src/reddit/components/Poll/PollExpiry/index.tsx"),
				D = n("./src/reddit/components/Poll/PostTitleMetaData/index.m.less"),
				L = n.n(D);
			const A = Object(d.c)({
				poll: (e, t) => e.polls.models[t.pollId],
				resultsByVoters: (e, t) => e.polls.results.byVoters[t.pollId]
			});
			var F, B = Object(a.b)(A)((function(e) {
					const {
						poll: t,
						resultsByVoters: n
					} = e, o = n ? n.totalVotes : "0";
					return Object(E.a)() ? null : i.a.createElement("div", {
						className: Object(u.a)(e.className, L.a.proposalMetaData)
					}, i.a.createElement("span", null, N.fbt._({
						"*": "{count} votes",
						_1: "{count} vote"
					}, [N.fbt._param("count", Object(R.a)(o)), N.fbt._plural(parseInt(o))], {
						hk: "4rP1VK"
					})), t && i.a.createElement(M.a, {
						className: L.a.proposalExpiry,
						poll: t
					}))
				})),
				U = n("./src/reddit/components/SEOTitle/index.tsx"),
				K = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				W = n("./src/reddit/selectors/experiments/nsfwBlockingExperiment.ts"),
				G = n("./src/reddit/selectors/user.ts"),
				H = n("./src/telemetry/models/Outbound.ts"),
				V = n("./src/reddit/components/PostTitle/getLeftAndRightFlair.ts"),
				z = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				q = n("./src/reddit/components/PostTitle/index.m.less"),
				Q = n.n(q);

			function Y() {
				return (Y = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}! function(e) {
				e[e.ExtraLarge = 0] = "ExtraLarge", e[e.Large = 1] = "Large", e[e.Medium = 2] = "Medium", e[e.Small = 3] = "Small", e[e.ExtraSmall = 4] = "ExtraSmall", e[e.Metadata = 5] = "Metadata"
			}(F || (F = {}));
			const J = e => {
					let {
						size: t,
						titleColor: n,
						titleType: o,
						nowrap: r,
						children: s,
						className: a,
						redditStyle: c,
						shouldBlurTitle: d
					} = e;
					const l = Object(O.a)();
					let m = "";
					switch (t) {
						case F.ExtraLarge:
							m = Q.a.ExtraLarge;
							break;
						case F.Large:
							m = Q.a.Large;
							break;
						case F.Medium:
							m = Q.a.Medium;
							break;
						case F.Small:
							m = Q.a.Small;
							break;
						case F.ExtraSmall:
							m = Q.a.ExtraSmall;
							break;
						case F.Metadata:
							m = Q.a.Metadata
					}
					return i.a.createElement("div", {
						className: Object(u.a)(Q.a.Title, a, m, {
							[Q.a.isNoWrap]: r,
							[Q.a.blur]: d
						}),
						style: {
							"--posttitletextcolor": n || Object(w.a)({
								redditStyle: c,
								theme: l
							}).titleText
						}
					}, o ? i.a.createElement(U.b, {
						type: o
					}, s) : s)
				},
				X = e => {
					let {
						className: t,
						disableVisited: n,
						titleColor: o,
						children: r,
						...s
					} = e;
					return i.a.createElement(c.a, Y({}, s, {
						className: Object(u.a)(t, Q.a.styledLink, {
							[Q.a.isVisitedEnabled]: !n
						})
					}), r)
				},
				Z = e => {
					let {
						disableVisited: t,
						nowrap: n,
						className: o,
						children: r
					} = e;
					return i.a.createElement("div", {
						className: Object(u.a)(Q.a.titleContainer, o, {
							[Q.a.isNoWrap]: n,
							[Q.a.isVisitedEnabled]: !t
						})
					}, r)
				},
				$ = Object(d.c)({
					flairPosition: (e, t) => {
						let {
							pageLayer: n
						} = t;
						return Object(p.r)(e, {
							pageLayer: n
						})
					},
					isNsfwBlurSubreddit: W.e,
					shouldOpenPostInNewTab: G.lb
				}),
				ee = e => {
					const {
						post: t
					} = e, {
						isSponsored: n
					} = t, o = Object(a.d)(), r = Object(y.a)(), s = Object(a.e)(K.b), c = Object(a.e)(K.c), d = e => {
						(s || c) && (e.preventDefault(), o(Object(g.Z)(Object(C.b)(t.permalink), t.id))), t.isSponsored && Object(S.A)(t) && o(Object(g.y)(t, v.a.Click))
					};
					if (e.isCommentsPage && !e.isCommentPermalink && !e.shouldLinkWrap) return i.a.createElement(Z, {
						nowrap: e.nowrap
					}, i.a.createElement(te, e));
					if (e.isCommentsPageAd && t.source && t.source.url) return i.a.createElement(h.b, {
						href: t.source.url,
						isSponsored: n,
						postId: t.id,
						source: t.source
					}, i.a.createElement(te, e)); {
						const o = t.permalink,
							s = e.isCommentPermalink ? Object(C.b)(o) : Object(f.a)(o, void 0, r);
						return i.a.createElement(Z, {
							disableVisited: e.disableVisited,
							nowrap: e.nowrap
						}, n && !Object(S.A)(t) ? ((e, t) => {
							const {
								source: n
							} = Object(l.t)(e, t.imageGalleryCurrentItem);
							return n ? i.a.createElement(h.b, {
								href: n.url,
								isSponsored: e.isSponsored,
								postId: e.id,
								source: n
							}, i.a.createElement(te, t)) : i.a.createElement(te, t)
						})(t, e) : i.a.createElement(X, {
							className: e.titleLinkClassName,
							"data-click-id": "body",
							disableVisited: e.disableVisited,
							target: e.shouldOpenPostInNewTab ? "_blank" : void 0,
							titleColor: e.titleColor,
							to: s,
							onClick: d
						}, i.a.createElement(te, e)))
					}
				},
				te = e => {
					const {
						leftFlair: t,
						isCommentsPageAd: n,
						post: o
					} = e;
					let r = e.format ? e.format(o) : o.title;
					n && "string" == typeof r && (r = (e => {
						return e.length >= 250 ? e.slice(0, 250 - "...".length) + "..." : e
					})(r));
					const s = e.isCommentsPage ? U.a.PostComments : U.a.PostItem,
						a = !(!e.isNsfwBlurSubreddit || !e.post.isNSFW);
					return i.a.createElement(J, {
						className: e.titleClassName,
						nowrap: e.nowrap,
						redditStyle: e.redditStyle || e.isCommentsPage || e.isCommentsPageAd,
						shouldBlurTitle: a,
						size: e.size,
						titleColor: e.titleColor,
						titleType: s
					}, t && i.a.createElement(P.a, {
						titleFlair: t,
						nowrap: !0,
						post: o,
						sendEvent: e.sendEvent
					}), r)
				},
				ne = e => {
					const {
						hideSourceLink: t,
						isNsfwBlurSubreddit: n,
						post: o
					} = e, {
						isSponsored: r
					} = o, s = e.isCommentsPage ? H.SourceElement.PostLink : H.SourceElement.ListingPostLink;
					if (Object(E.a)()) return null;
					if (n && o.isNSFW) return null;
					const a = !t && !e.isCrosspost && e.size !== F.Large && !o.isSponsored && (o.source || o.media && (o.media.type === j.o.GIFVIDEO || o.media.type === j.o.IMAGE || o.media.type === j.o.EMBED));
					if (t || !e.isCommentsPage || e.isCommentPermalink || e.shouldLinkWrap) {
						if (a) return i.a.createElement(b.a, {
							className: e.outboundLinkClassName,
							href: Object(j.E)(o),
							isSponsored: r,
							postId: o.id,
							source: o.source,
							sourceElement: s
						}, Object(I.a)(o), !o.isSponsored && i.a.createElement(_.a, {
							name: "external_link",
							className: Q.a.outboundLinkIcon
						}))
					} else if (o.source && !e.isCrosspost && e.size !== F.Large && e.size !== F.ExtraLarge) return i.a.createElement(b.a, {
						className: e.outboundLinkClassName,
						href: o.source.url,
						isSponsored: r,
						postId: o.id,
						source: o.source,
						sourceElement: s
					}, Object(I.a)(o), !o.isSponsored && i.a.createElement(_.a, {
						name: "external_link",
						className: Q.a.outboundLinkIcon
					}));
					return null
				};
			class oe extends i.a.Component {
				getDynamicStyleTags() {
					return i.a.createElement("style", {
						dangerouslySetInnerHTML: {
							__html: `\n        .${this.props.post.id}.${Q.a.Component} {\n          --postTitle-VisitedLinkColor: ${Object(r.c)(.45,Object(w.a)(this.props).titleText,"#FFFFFF")};\n          --postTitleLink-VisitedLinkColor: ${Object(r.c)(.45,this.props.titleColor||Object(w.a)(this.props).titleText,Object(w.a)(this.props).body)};\n          --postBodyLink-VisitedLinkColor: ${Object(r.c)(.45,Object(w.a)(this.props).bodyText,Object(w.a)(this.props).body)};\n        }\n      `
						}
					})
				}
				render() {
					const {
						className: e,
						disableFlair: t,
						flairPosition: n,
						isCommentsPage: r,
						isOverlay: s,
						poll: a,
						post: c,
						showNSFWSpoilerFlairsOnly: d,
						hideNSFWSpoilerFlair: l,
						onClick: m
					} = this.props, p = n === k.b.Left, h = Object(P.b)(c), {
						leftFlair: b,
						rightFlair: f
					} = Object(V.a)({
						flair: h,
						isFlairPositionedLeft: p,
						showNSFWSpoilerFlairsOnly: d,
						hideNSFWSpoilerFlair: l
					}), g = !s && !r && !t, v = g && b && b.length > 0, C = g && f && f.length > 0;
					return i.a.createElement("div", {
						className: Object(u.a)(Q.a.Component, e, c.id),
						ref: this.props.innerRef,
						"data-adclicklocation": z.a.TITLE,
						onClick: m
					}, !d && v && i.a.createElement(P.a, {
						isFlairFilter: !0,
						titleFlair: b,
						nowrap: !0,
						post: c,
						sendEvent: this.props.sendEvent
					}), !Object(T.b)(c) && i.a.createElement(ee, Y({}, this.props, {
						leftFlair: d ? b : void 0
					})), a && i.a.createElement(B, {
						className: Q.a.pollMeta,
						pollId: a.id
					}), i.a.createElement(ne, this.props), C && i.a.createElement(P.a, {
						isFlairFilter: !0,
						titleFlair: f,
						nowrap: !0,
						post: c,
						sendEvent: this.props.sendEvent
					}), i.a.createElement("div", {
						className: Q.a.postTitleVisibility,
						dangerouslySetInnerHTML: {
							__html: `\n              <img alt="" src="${o.a.assetPath}/img/renderTimingPixel.png" style="width: 1px; height: 1px;" onLoad="(__markFirstPostVisible || function(){})();" />\n            `
						}
					}), this.getDynamicStyleTags())
				}
			}
			t.c = i.a.memo((function(e) {
				const t = Object(p.ib)(),
					n = Object(p.x)(t),
					o = Object(x.a)(),
					r = Object(a.e)(r => $(r, {
						...o,
						...e,
						isCommentPermalink: n,
						pageLayer: t
					})),
					s = Object(O.a)(),
					c = Object(m.b)();
				return o ? i.a.createElement(oe, Y({
					pageLayer: t,
					isCommentPermalink: n
				}, o, r, e, {
					theme: s,
					sendEvent: c
				})) : null
			}))
		},
		"./src/reddit/components/PostingSidebar/LearnMoreAboutTalk/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_2pgQjKwBDQ7MPluFUOB41q",
				container: "_2pgQjKwBDQ7MPluFUOB41q",
				TitleContainer: "XYqpmL97Mojvuir5dZiAb",
				titleContainer: "XYqpmL97Mojvuir5dZiAb",
				AudioIcon: "_1FWxpa0UmbyF_B2qCewtxY",
				audioIcon: "_1FWxpa0UmbyF_B2qCewtxY",
				Title: "_2u9RgALks50HVuozdlhcXF",
				title: "_2u9RgALks50HVuozdlhcXF",
				Description: "_3q0yPkX3rBj4tKtZBXCD4-",
				description: "_3q0yPkX3rBj4tKtZBXCD4-",
				New: "_2ee3y-8NaFG6rkUvYc4ogg",
				new: "_2ee3y-8NaFG6rkUvYc4ogg",
				LearnMoreLink: "_3R_NxfLdPeSj6X9Glv1wM7",
				learnMoreLink: "_3R_NxfLdPeSj6X9Glv1wM7"
			}
		},
		"./src/reddit/components/PostingSidebar/LearnMoreAboutTalk/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./src/reddit/controls/Button/index.tsx"),
				a = n("./src/reddit/icons/fonts/index.tsx"),
				c = n("./src/reddit/components/PostingSidebar/LearnMoreAboutTalk/index.m.less"),
				d = n.n(c);
			t.a = () => {
				const e = Object(a.b)("audio");
				return s.a.createElement("div", {
					className: d.a.Container
				}, s.a.createElement("div", {
					className: d.a.TitleContainer
				}, s.a.createElement(e, {
					className: d.a.AudioIcon
				}), s.a.createElement("h4", {
					className: d.a.Title
				}, s.a.createElement("span", {
					className: d.a.New
				}, o.fbt._("NEW!", null, {
					hk: "x4BpB"
				})), " ", o.fbt._("Host live audio talks", null, {
					hk: "26n05N"
				}))), s.a.createElement("p", {
					className: d.a.Description
				}, o.fbt._("Have fun hosting AMAs, Q&As, or just hanging out with your community.", null, {
					hk: "18zlgC"
				})), s.a.createElement(i.t, {
					kind: i.b.ExternalLink,
					priority: i.c.PlainLink,
					href: "https://reddithelp.com/hc/en-us/articles/4404349195284 ",
					target: "_blank",
					className: d.a.LearnMoreLink
				}, o.fbt._("Learn more about Reddit Talk", null, {
					hk: "3N8tu4"
				})))
			}
		},
		"./src/reddit/components/PostingSidebar/PolicyRow/index.m.less": function(e, t, n) {
			e.exports = {
				PolicyRow: "_2N9ShiilNyzdd0B_i9geBj",
				policyRow: "_2N9ShiilNyzdd0B_i9geBj"
			}
		},
		"./src/reddit/components/PostingSidebar/PolicyRow/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/config.ts");
			const {
				redditUrl: i
			} = s.a, a = `${i}/help/contentpolicy`, c = `${i}/wiki/reddiquette`;
			var d = n("./src/reddit/components/PostingSidebar/PolicyRow/index.m.less"),
				l = n.n(d);
			const {
				fbt: u
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = e => r.a.createElement("div", {
				className: l.a.PolicyRow
			}, u._("Please be mindful of reddit's {=content policy} and practice good {=reddiquette}.", [u._param("=content policy", r.a.createElement("a", {
				href: a
			}, u._("content policy", null, {
				hk: "2PeDvo"
			}))), u._param("=reddiquette", r.a.createElement("a", {
				href: c
			}, u._("reddiquette", null, {
				hk: "uPdiw"
			})))], {
				hk: "4yQuKr"
			}))
		},
		"./src/reddit/components/PostingSidebar/PostingReddiquette/index.m.less": function(e, t, n) {
			e.exports = {
				Snoo: "_1XXU14d6sjwsheKLMcy7ro",
				snoo: "_1XXU14d6sjwsheKLMcy7ro",
				Li: "_2aD4E5YdfsXR-e8kLRuTEp",
				li: "_2aD4E5YdfsXR-e8kLRuTEp",
				Ol: "a5fJMl2u0aujwukxWH3if",
				ol: "a5fJMl2u0aujwukxWH3if",
				Title: "_27SYzmGZdspPn9yA9voNCY",
				title: "_27SYzmGZdspPn9yA9voNCY",
				Component: "_1Zj2sAyYL2zB-kzZQcWiW",
				component: "_1Zj2sAyYL2zB-kzZQcWiW"
			}
		},
		"./src/reddit/components/PostingSidebar/PostingReddiquette/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/constants/index.ts"),
				d = n("./src/reddit/icons/svgs/SnooPosting/index.tsx"),
				l = n("./src/reddit/selectors/postCreations.ts"),
				u = n("./src/reddit/components/PostingSidebar/PostingReddiquette/index.m.less"),
				m = n.n(u),
				p = n("./src/lib/lessComponent.tsx");
			const h = p.a.wrapped(d.a, "Snoo", m.a),
				b = p.a.li("Li", m.a),
				f = p.a.ol("Ol", m.a),
				g = p.a.div("Title", m.a),
				v = Object(a.c)({
					submissionType: l.rb
				});
			t.a = p.a.wrapped(Object(i.b)(v)(e => {
				const {
					className: t,
					submissionType: n
				} = e, r = n === c.bc.CROSSPOST;
				return s.a.createElement("div", {
					className: t
				}, s.a.createElement(g, null, s.a.createElement(h, null), r ? o.fbt._("Crossposting to Reddit", null, {
					hk: "2ODPDt"
				}) : o.fbt._("Posting to Reddit", null, {
					hk: "8eEIT"
				})), s.a.createElement(f, null, s.a.createElement(b, null, o.fbt._("Remember the human", null, {
					hk: "1x3u5R"
				})), s.a.createElement(b, null, o.fbt._("Behave like you would in real life", null, {
					hk: "3pxfk1"
				})), s.a.createElement(b, null, o.fbt._("Look for the original source of content", null, {
					hk: "1FfUM4"
				})), s.a.createElement(b, null, o.fbt._("Search for duplicates before posting", null, {
					hk: "3Ij1gf"
				})), s.a.createElement(b, null, o.fbt._("Read the communitys rules", null, {
					hk: "3RNQW2"
				})), r && s.a.createElement(b, null, o.fbt._("You must join a community to crosspost there", null, {
					hk: "1YAEPX"
				}))))
			}), "Component", m.a)
		},
		"./src/reddit/components/PostingSidebar/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "itxZANPrH4AAYOj6VgfL9",
				container: "itxZANPrH4AAYOj6VgfL9",
				isOpenAIPilotV1: "xpmGc4AuyuOP6ErObihFx",
				isOpenAiPilotV1: "xpmGc4AuyuOP6ErObihFx"
			}
		},
		"./src/reddit/components/PostingSidebar/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/core-js/modules/web.dom.iterable.js"),
				r = n.n(o),
				s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./node_modules/react/index.js"),
				c = n.n(a),
				d = n("./node_modules/react-redux/es/index.js"),
				l = n("./node_modules/reselect/es/index.js"),
				u = n("./src/reddit/components/IdCard/async.tsx"),
				m = n("./src/reddit/components/SidebarFooter/index.tsx"),
				p = n("./src/reddit/components/SidebarSpacer/index.tsx"),
				h = n("./src/reddit/components/Widgets/PostCollection/index.tsx"),
				b = n("./src/reddit/components/Widgets/SubredditRules/index.tsx"),
				f = n("./src/reddit/contexts/PageLayer/index.tsx"),
				g = n("./src/reddit/models/Widgets/index.ts"),
				v = n("./src/reddit/selectors/experiments/postCreationSubRec.ts"),
				C = n("./src/reddit/selectors/postCreations.ts"),
				y = n("./src/reddit/selectors/profile.ts"),
				E = n("./src/reddit/selectors/subreddit.ts"),
				x = n("./src/reddit/selectors/widgets.ts"),
				O = n("./src/reddit/components/PostingSidebar/LearnMoreAboutTalk/index.tsx"),
				_ = n("./src/reddit/components/PostingSidebar/PolicyRow/index.tsx"),
				k = n("./src/reddit/components/PostingSidebar/PostingReddiquette/index.tsx"),
				j = n("./src/reddit/components/PostingSidebar/index.m.less"),
				S = n.n(j),
				T = n("./src/lib/constants/index.ts"),
				w = n("./src/lib/lessComponent.tsx");
			const I = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ProfileIdCard",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("reddit-components-ProfileIdCard").then(n.bind(null, "./src/reddit/components/ProfileIdCard/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ProfileIdCard/index.tsx"
					}
				}),
				P = w.a.div("Container", S.a),
				N = Object(f.v)(),
				R = new Set(["all", "post"]),
				M = Object(l.a)((e, t) => {
					let {
						pageLayer: n
					} = t;
					const o = Object(f.s)(e, {
						pageLayer: n
					});
					return o && Object(E.W)(e, {
						subredditId: o.id
					})
				}, e => (e || []).filter(e => R.has(e.kind))),
				D = (e, t) => {
					let {
						pageLayer: n
					} = t;
					const o = Object(f.s)(e, {
						pageLayer: n
					});
					return !(!o || !Object(x.d)(e, {
						subredditName: o.name
					}))
				},
				L = Object(l.c)({
					hasIdCardWidgetData: D,
					isCreationPagePending: C.L,
					profile: (e, t) => {
						let {
							pageLayer: n,
							subredditOrProfileId: o
						} = t;
						return o ? Object(y.r)(e, {
							profileId: o
						}) : Object(f.l)(e, {
							pageLayer: n
						})
					},
					subreddit: f.s,
					subredditRules: M,
					currentPostCollection: f.g,
					isOpenAIPilotV1: v.g,
					submissionType: C.rb
				}),
				A = Object(d.b)(L),
				F = e => {
					const {
						className: t,
						currentPostCollection: n,
						hasIdCardWidgetData: o,
						isCreationPagePending: r,
						isOpenAIPilotV1: s,
						profile: a,
						submissionType: d,
						subreddit: l,
						subredditRules: f
					} = e, v = o || r;
					return c.a.createElement(P, {
						className: Object(i.a)(t, {
							[S.a.isOpenAIPilotV1]: s
						})
					}, n && c.a.createElement(h.a, {
						collection: n
					}), l && v && c.a.createElement(p.a, null, c.a.createElement(u.a, {
						isSubmissionPage: !0,
						listingName: l.name
					})), a && !l && c.a.createElement(p.a, null, c.a.createElement(I, {
						profileName: a.name,
						isOverlay: !1,
						isSubmissionPage: !0
					})), l && f && c.a.createElement(p.a, null, c.a.createElement(b.a, {
						subredditName: l.name,
						display: g.h.COMPACT,
						rules: f,
						redditStyle: !0
					})), d === T.bc.TALK && c.a.createElement(p.a, null, c.a.createElement(O.a, null)), c.a.createElement(k.a, null), c.a.createElement(p.a, null), c.a.createElement(_.a, null), c.a.createElement(m.a, {
						redditStyle: !0
					}))
				};
			t.a = N(A(F))
		},
		"./src/reddit/components/ProfileIdCard/SnoovatarButton/TryItOn.tsx": function(e, t, n) {
			"use strict";
			var o = n("./src/lib/classNames/index.ts"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router/esm/react-router.js"),
				c = n("./src/reddit/actions/post.ts"),
				d = n("./src/reddit/actions/snoovatarModal.ts"),
				l = n("./src/reddit/components/TrackingHelper/index.tsx"),
				u = n("./src/reddit/controls/Button/index.tsx"),
				m = n("./src/reddit/helpers/trackers/snoovatar.ts"),
				p = n("./src/reddit/icons/svgs/Shirt/index.tsx"),
				h = n("./src/reddit/models/Vote/index.ts"),
				b = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/index.m.less"),
				f = n.n(b);
			const {
				fbt: g
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = Object(a.i)(e => {
				let {
					isHovercard: t,
					username: n,
					isAvatarPost: a,
					post: b,
					share: v
				} = e;
				const C = Object(l.b)(),
					y = Object(i.d)(),
					E = b && b.id,
					x = b && b.voteState;
				let O = null;
				E || (O = t ? "user_hovercard" : "profile_overview");
				const _ = Object(r.useCallback)(() => C(Object(m.h)(t ? "user_hovercard" : "profile_overview", n)), [t, C, n]);
				return s.a.createElement(u.t, {
					onClick: () => {
						a ? (C(m.i), E && x === h.a.notVoted && y(Object(c.ib)(E))) : _();
						const e = a ? "postify" : "copy";
						y(Object(d.b)({
							clickSource: O,
							share: v,
							source: e
						}))
					},
					className: Object(o.a)(f.a.snoovatarButton, f.a.snoovatarExtraPadding, f.a.compactButtonLayout, {
						[f.a.avatarPostifyButton]: a
					}),
					isFullWidth: !0
				}, s.a.createElement(p.a, {
					className: Object(o.a)({
						[f.a.shirtIcon]: !a,
						[f.a.avatarPostButtonShirtIcon]: a
					})
				}), g._("Try this Look", null, {
					hk: "dOuPb"
				}), s.a.createElement("div", {
					className: f.a.chevronIcon
				}))
			})
		},
		"./src/reddit/components/ProfileIdCard/SnoovatarButton/index.m.less": function(e, t, n) {
			e.exports = {
				snoovatarButton: "_3F1tNW0P4Ff182mO_CefIg",
				avatarPostifyButton: "_2Viile0fcrruho_hQqpnUx",
				snoovatarExtraPadding: "_3DnDqV66Np6rVEiI8QK7kl",
				shirtIcon: "_3gYTHRBO1S_S5AOddgqD6Z",
				avatarPostButtonShirtIcon: "ARFP2bx6U967JwMoJ2Xr5",
				compactButtonLayout: "VFbNvXfZXUhRFiCTDHO6f",
				chevronIcon: "_12pWM-aURvVUuSrUyqfNZh"
			}
		},
		"./src/reddit/components/ProgressBar/index.m.less": function(e, t, n) {
			e.exports = {
				innerBar: "Db3WJFTcyAR-IM0cIkpDG",
				outerBar: "i8kQtxHYBB8Sb3bPI4M_e"
			}
		},
		"./src/reddit/components/ProgressBar/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/ProgressBar/index.m.less"),
				a = n.n(i);
			t.a = e => {
				let {
					className: t,
					innerBarClassName: n,
					percent: o
				} = e;
				return r.a.createElement("div", {
					className: Object(s.a)(a.a.outerBar, t)
				}, r.a.createElement("div", {
					className: Object(s.a)(a.a.innerBar, n),
					style: {
						width: `${o.toFixed(2)}%`
					}
				}))
			}
		},
		"./src/reddit/components/RawHTMLDisplay/index.m.less": function(e, t, n) {
			e.exports = {
				StyledRawHTMLDisplay: "_3ms2Z8z8rPWLXaErcTJ9yH",
				styledRawHtmlDisplay: "_3ms2Z8z8rPWLXaErcTJ9yH"
			}
		},
		"./src/reddit/components/RawHTMLDisplay/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/polished/dist/polished.es.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				c = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/actions/urlRequested.ts"),
				l = n("./src/reddit/hooks/useOutboundClickTracking.ts"),
				u = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				m = n("./src/reddit/components/RawHTMLDisplay/index.m.less"),
				p = n.n(m);
			const h = Object(i.b)(null, e => ({
					onNavigate: t => e(Object(d.a)(t))
				})),
				b = c.a.wrapped(e => {
					const t = Object(l.a)();
					return s.a.createElement("div", {
						className: e.className,
						dangerouslySetInnerHTML: {
							__html: e.html
						},
						onClick: n => {
							((e, t, n, o, r) => {
								if (!e.ctrlKey && !e.metaKey && 1 !== e.button && "A" === e.target.tagName) {
									e.preventDefault();
									const n = e.target.getAttribute("href");
									r && o(n, r), t(n)
								}
								e.target.classList && e.target.classList.contains("md-spoiler-text") && (e.target.dataset.revealed = !0), n && n(e)
							})(n, e.onNavigate, e.onClick, t, e.sourceElement)
						},
						style: {
							...e.style,
							"--RawHTMLDisplay-tr-even": Object(o.f)(Object(u.a)(e).body, .8),
							"--RawHTMLDisplay-tr-odd": Object(o.f)(Object(u.a)(e).line, .8)
						}
					})
				}, "StyledRawHTMLDisplay", p.a);
			t.a = h(Object(a.a)(b))
		},
		"./src/reddit/components/RequestPendingBanner/index.m.less": function(e, t, n) {
			e.exports = {
				Banner: "_1AD-JX9FUzLgvv8A5yaVqV",
				banner: "_1AD-JX9FUzLgvv8A5yaVqV",
				Subtitle: "_1ljRPHbvpC41amZF9_xBeb",
				subtitle: "_1ljRPHbvpC41amZF9_xBeb"
			}
		},
		"./src/reddit/components/RequestPendingBanner/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/InfoBanners/BannerBase/index.tsx"),
				l = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				u = n("./src/reddit/selectors/platform.ts"),
				m = n("./src/reddit/selectors/subreddit.ts"),
				p = n("./src/reddit/components/RequestPendingBanner/index.m.less"),
				h = n.n(p);
			const b = c.a.wrapped(d.a, "Banner", h.a),
				f = Object(i.b)(() => Object(a.c)({
					restrictions: m.q,
					subreddit: u.e
				}));
			t.a = f(e => {
				let {
					restrictions: t,
					subreddit: n
				} = e;
				if (!n) return null;
				const r = t === l.e.Comment ? l.a.Create : l.a.Draft;
				return s.a.createElement(b, {
					subtitle: s.a.createElement("span", {
						className: h.a.Subtitle
					}, o.fbt._("Your request to {restrictions} in {displayName} was sent and is pending. In the meantime, you can {action} a post and {=browse the community}", [o.fbt._param("restrictions", l.d[t]()), o.fbt._param("displayName", n.name), o.fbt._param("action", l.c[r]()), o.fbt._param("=browse the community", s.a.createElement("a", {
						href: `${n.url}`
					}, o.fbt._("browse the community", null, {
						hk: "3hwgAC"
					})))], {
						hk: "2CX6Q6"
					})),
					title: o.fbt._("Request to {restrictions} is pending...", [o.fbt._param("restrictions", l.d[t]())], {
						hk: "1tQuSr"
					})
				})
			})
		},
		"./src/reddit/components/ResizableAutosizeTextarea/index.m.less": function(e, t, n) {
			e.exports = {
				editorWrapper: "VBa-xDMEbFi3vsO4id4OC",
				textareaAutosize: "_6Ej82J4aTDK36LLOcpFbC",
				mIsFullHeight: "aZb6a46diyLdUQJynW3aD"
			}
		},
		"./src/reddit/components/ResizableAutosizeTextarea/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-autosize-textarea/lib/index.js"),
				i = n.n(s),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/components/ResizableAutosizeTextarea/index.m.less"),
				d = n.n(c);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const u = e => {
					let {
						className: t,
						children: n,
						editorWrapperRef: o,
						initialHeight: s
					} = e;
					return r.a.createElement("div", {
						className: Object(a.a)(d.a.editorWrapper, t),
						style: s ? {
							height: s
						} : void 0,
						ref: o
					}, n)
				},
				m = e => {
					let {
						isFullHeight: t,
						textAreaRef: n,
						...o
					} = e;
					return r.a.createElement(i.a, l({
						className: Object(a.a)(d.a.textareaAutosize, {
							[d.a.mIsFullHeight]: t
						}),
						innerRef: n
					}, o))
				};
			class p extends r.a.Component {
				constructor(e) {
					super(e), this.editorHeight = null, this.editorRef = null, this.editorStyleMutationObserver = null, this.onEditorStyleChanged = () => {
						if (!this.editorRef) return;
						const {
							isResized: e
						} = this.state;
						e || this.setState({
							isResized: !0
						});
						const t = this.editorRef.style.height ? Number.parseInt(this.editorRef.style.height) : null;
						this.editorHeight !== t && (this.editorHeight = t, t && this.props.onEditorResize && this.props.onEditorResize(t))
					}, this.setEditorWrapperRef = e => this.editorRef = e, this.state = {
						initialHeight: e.initialHeight,
						isResized: !!e.initialHeight
					}
				}
				componentDidMount() {
					this.editorRef && (this.editorStyleMutationObserver = new MutationObserver(this.onEditorStyleChanged), this.editorStyleMutationObserver.observe(this.editorRef, {
						attributes: !0,
						attributeFilter: ["style"]
					}))
				}
				componentWillUnmount() {
					this.editorStyleMutationObserver && (this.editorStyleMutationObserver.disconnect(), this.editorStyleMutationObserver = null)
				}
				render() {
					const {
						className: e,
						initialHeight: t,
						innerRef: n,
						onEditorResize: o,
						...s
					} = this.props, {
						isResized: i
					} = this.state;
					return r.a.createElement(u, {
						className: e,
						editorWrapperRef: this.setEditorWrapperRef,
						initialHeight: t
					}, r.a.createElement(m, l({}, s, {
						isFullHeight: !!i,
						textAreaRef: n
					})))
				}
			}
			t.a = p
		},
		"./src/reddit/components/ResizeSensor/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var o = n("./node_modules/raf/index.js"),
				r = n.n(o),
				s = n("./node_modules/react/index.js"),
				i = n.n(s);
			class a extends i.a.Component {
				constructor(e) {
					super(e), this.isIE = () => /Trident/.test(navigator.userAgent), this.setContainerRef = e => {
						this.containerRef || (this.containerRef = e, this.createSensor())
					}, this.handleResize = () => {
						void 0 !== this.frame && r.a.cancel(this.frame), this.frame = r()(this.props.onResize)
					}, this.containerRef = e.containerRef
				}
				shouldComponentUpdate() {
					return !1
				}
				componentDidMount() {
					this.createSensor()
				}
				createSensor() {
					if (!this.containerRef || this.sensor) return;
					this.sensor = document.createElement("object"), this.sensor.setAttribute("style", "\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      height: 100%;\n      width: 100%;\n      overflow: hidden;\n      pointer-events: none;\n      z-index: -1;\n      visibility: hidden;\n    "), this.sensor.setAttribute("tabindex", "-1"), this.sensor.onload = () => {
						this.props.onResize(), this.sensor && this.sensor.contentDocument && this.sensor.contentDocument.defaultView && this.sensor.contentDocument.defaultView.addEventListener("resize", this.handleResize)
					}, this.sensor.type = "text/html";
					const e = this.isIE();
					e && this.containerRef.appendChild(this.sensor), this.sensor.data = "about:blank", e || this.containerRef.appendChild(this.sensor), this.props.onResize()
				}
				componentWillUnmount() {
					this.sensor && (this.sensor && this.sensor.contentDocument && this.sensor.contentDocument.defaultView && this.sensor.contentDocument.defaultView.removeEventListener("resize", this.handleResize), this.containerRef && this.containerRef.removeChild(this.sensor))
				}
				render() {
					return i.a.createElement("div", {
						ref: this.setContainerRef
					})
				}
			}
		},
		"./src/reddit/components/RestrictedFlatlistButton/index.m.less": function(e, t, n) {
			e.exports = {
				removalReasonButton: "_3IEDcFIIs_TeXsZtKZGzUd",
				TextWrapper: "smOzqVIOoNqmSJcyBX2N6",
				textWrapper: "smOzqVIOoNqmSJcyBX2N6",
				Button: "_1rNBkuuOkN2SorEXyRkYjB",
				button: "_1rNBkuuOkN2SorEXyRkYjB",
				ApproveButton: "_2T9IigN7CfZvuc5KSKs2hx",
				approveButton: "_2T9IigN7CfZvuc5KSKs2hx",
				RemoveButton: "_2OvUr_pd3kddsNP_f35S28",
				removeButton: "_2OvUr_pd3kddsNP_f35S28"
			}
		},
		"./src/reddit/components/RestrictedFlatlistButton/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/RestrictedFlatlistButton/index.m.less"),
				c = n.n(a);
			const d = e => r.a.createElement("button", {
					className: Object(s.a)(c.a.Button, e.className),
					disabled: e.disabled,
					id: e.id,
					onClick: e.disabled ? void 0 : e.onClick,
					onMouseEnter: e.onMouseEnter,
					onMouseLeave: e.onMouseLeave
				}, e.children, e.text && r.a.createElement("span", {
					className: Object(s.a)(c.a.TextWrapper, e.textClassName)
				}, e.text, " ")),
				l = i.a.wrapped(d, "ApproveButton", c.a),
				u = i.a.wrapped(d, "RemoveButton", c.a),
				m = e => r.a.createElement("button", {
					className: Object(s.a)(c.a.removalReasonButton, e.className),
					onClick: e.onClick
				}, e.text)
		},
		"./src/reddit/components/RichTextEditor/Blockquote/index.m.less": function(e, t, n) {
			e.exports = {
				BlockQuoteWrapper: "_3bqfSxMWo3yWv7j4N8hQy6",
				blockQuoteWrapper: "_3bqfSxMWo3yWv7j4N8hQy6"
			}
		},
		"./src/reddit/components/RichTextEditor/CodeBlock/index.m.less": function(e, t, n) {
			e.exports = {
				CodeBlockWrapper: "_2YrwxhRxsXvszOhYWDUhMh",
				codeBlockWrapper: "_2YrwxhRxsXvszOhYWDUhMh"
			}
		},
		"./src/reddit/components/RichTextEditor/DragController/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "a", (function() {
				return b
			}));
			var o = n("./node_modules/lodash/includes.js"),
				r = n.n(o);
			var s = n("./src/reddit/helpers/dom/index.ts"),
				i = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			const a = e => e.className.indexOf("public-DraftEditor-content") >= 0,
				c = e => !!e.parentElement && !!e.parentElement.parentElement && a(e.parentElement.parentElement),
				d = e => !(!e.dataset.block || !e.dataset.offsetKey),
				l = e => {
					const {
						offsetKey: t
					} = e.dataset;
					return t ? (e => e.split("-")[0])(t) : ""
				},
				u = (e, t) => {
					return ((e, t) => {
						const n = function(e, t) {
							let n = 0,
								o = e.length - 1;
							for (; n <= o;) {
								const r = o + n >> 1,
									s = t(e[r]);
								if (s > 0) n = r + 1;
								else {
									if (!(s < 0)) return r;
									o = r - 1
								}
							}
							return n
						}(e, e => {
							const n = e.getBoundingClientRect();
							return t < n.top ? -1 : t > n.bottom ? 1 : 0
						});
						return e[Math.min(n, e.length - 1)]
					})(e.querySelectorAll("[data-block][data-offset-key]"), t)
				},
				m = (e, t) => {
					const n = Object(s.b)(e, d, a);
					return n || u(e, t)
				},
				p = (e, t) => {
					const n = (e => {
						const t = e.target;
						if (!(t instanceof HTMLElement)) return;
						const n = Object(s.b)(t, a);
						if (!n) return;
						const o = m(t, e.clientY);
						if (!o) return;
						const r = Object(s.b)(o, c);
						return r ? {
							editorContentElement: n,
							topLevelElement: r,
							blockElement: o
						} : void 0
					})(t);
					if (!n) return;
					const {
						topLevelElement: o,
						blockElement: r
					} = n, d = l(r), u = e.getCurrentContent(), p = u.getBlockForKey(d);
					if (!p) return;
					const {
						upperElement: h,
						lowerElement: b
					} = ((e, t, n, o) => {
						let r = n,
							s = n;
						if (e.getType() === i.b.UNSTYLED) r = s = t;
						else if (Object(i.o)(e.getType())) {
							r = s = t;
							const a = o.getBlockAfter(e.getKey());
							a && Object(i.u)(a.getType()) && (s = n.nextElementSibling)
						} else Object(i.u)(e.getType()) && (r = n.previousElementSibling, s = t);
						return {
							upperElement: r,
							lowerElement: s
						}
					})(p, r, o, u), {
						clientY: f,
						isBefore: g
					} = ((e, t, n) => {
						const o = e.getBoundingClientRect(),
							r = t.getBoundingClientRect();
						let i, c;
						if (n > (o.top + r.bottom) / 2) {
							i = r.bottom, c = !1;
							const e = Object(s.b)(t, e => !!e.nextElementSibling, a);
							if (e) {
								i = (e.nextElementSibling.getBoundingClientRect().top + r.bottom) / 2
							}
						} else {
							i = o.top, c = !0;
							const t = Object(s.b)(e, e => !!e.previousElementSibling, a);
							if (t) {
								i = (t.previousElementSibling.getBoundingClientRect().bottom + o.top) / 2
							}
						}
						return {
							clientY: i,
							isBefore: c
						}
					})(h, b, t.clientY);
					let v = d;
					if (p.getType() !== i.b.UNSTYLED) {
						const e = m(g ? h : b, f);
						e && (v = l(e))
					}
					return {
						clientY: f,
						isBefore: g,
						blockKey: v
					}
				},
				h = e => e.items ? !!Array.from(e.items).find(e => "file" === e.kind) : !(!e.files || !e.files.length) || r()(e.types, "Files"),
				b = e => e.items ? Array.from(e.items).map(e => "file" === e.kind ? e.getAsFile() : null).filter(Boolean) : e.files ? Array.from(e.files) : []
		},
		"./src/reddit/components/RichTextEditor/DragController/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_13Sj3UMDKkCCJTq88berCB",
				hideCaret: "_2BqK1CuzH2oWi2F9_cuFPQ",
				DropLine: "z5iuD3MVYcfS7tTihbvof",
				dropLine: "z5iuD3MVYcfS7tTihbvof",
				Tooltip: "_1z9S1KmnM79xn-UA0FnbP6",
				tooltip: "_1z9S1KmnM79xn-UA0FnbP6"
			}
		},
		"./src/reddit/components/RichTextEditor/HoverTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				tooltip: "ki2VbfBhU-qxg1S6VyET6",
				above: "_8fNGSBGvr1Ds8PbrsUGzN",
				below: "_38gWvHp3NJkR5r5ftUfbFG",
				HoverTooltip: "Nb7NCPTlQuxN_WDPUg5Q2",
				hoverTooltip: "Nb7NCPTlQuxN_WDPUg5Q2"
			}
		},
		"./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.m.less"),
				c = n.n(a);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = i.a.wrapped(e => {
				const {
					children: t,
					className: n,
					renderBelow: o,
					text: i,
					tooltipContentClass: a,
					...l
				} = e;
				return r.a.createElement("div", d({}, l, {
					className: Object(s.a)(c.a.container, n)
				}), i ? r.a.createElement("div", {
					className: Object(s.a)(c.a.tooltip, a, o ? c.a.below : c.a.above)
				}, i) : null, t)
			}, "HoverTooltip", c.a)
		},
		"./src/reddit/components/RichTextEditor/LinksController/LinkDetailsPopup/index.m.less": function(e, t, n) {
			e.exports = {
				LinkDetailsBox: "_2F28OVOVlGo6WCT2l8lHzO",
				linkDetailsBox: "_2F28OVOVlGo6WCT2l8lHzO",
				Link: "_3vJCj_aXdDc-UXA9fDK-z-",
				link: "_3vJCj_aXdDc-UXA9fDK-z-",
				LinkButton: "_1NtBcR7JgjxkWLJrk3ddD3",
				linkButton: "_1NtBcR7JgjxkWLJrk3ddD3"
			}
		},
		"./src/reddit/components/RichTextEditor/LinksController/LinkEditorPopup/index.m.less": function(e, t, n) {
			e.exports = {
				EditForm: "_1iFkUjPC4J8jzWrDthDpcv",
				editForm: "_1iFkUjPC4J8jzWrDthDpcv",
				LinkEditorBox: "_3HMg7pEvqliZhuStFZ241S",
				linkEditorBox: "_3HMg7pEvqliZhuStFZ241S",
				Input: "_2rXi0UvEKRcI3WdI52LAx1",
				input: "_2rXi0UvEKRcI3WdI52LAx1",
				Label: "_2olni9Ucr8-t8W62nTkY_",
				label: "_2olni9Ucr8-t8W62nTkY_",
				HintAndButtonRow: "_2qiAR3ZyDGPSr9zmqhP_5Z",
				hintAndButtonRow: "_2qiAR3ZyDGPSr9zmqhP_5Z",
				InvalidUrlHint: "pKrgYGkHvjHPFkWO-Gnko",
				invalidUrlHint: "pKrgYGkHvjHPFkWO-Gnko",
				SubmitButton: "_8a_rf-Al8VNnUQ42WlvF",
				submitButton: "_8a_rf-Al8VNnUQ42WlvF"
			}
		},
		"./src/reddit/components/RichTextEditor/OrderedList/index.m.less": function(e, t, n) {
			e.exports = {
				OrderedListWrapper: "_1QXegNe8bOemD558m-vc9t",
				orderedListWrapper: "_1QXegNe8bOemD558m-vc9t"
			}
		},
		"./src/reddit/components/RichTextEditor/Paragraph/index.m.less": function(e, t, n) {
			e.exports = {
				ParagraphWrapper: "_3LuG0YVLLHE2azRNVaKz7O",
				paragraphWrapper: "_3LuG0YVLLHE2azRNVaKz7O"
			}
		},
		"./src/reddit/components/RichTextEditor/TextRendering/index.m.less": function(e, t, n) {
			e.exports = {
				H1: "_15ThA3NFuzpQTnPu0I3QKj",
				h1: "_15ThA3NFuzpQTnPu0I3QKj",
				H2: "_3R5icAd6cRzwpq-yhvQUoW",
				h2: "_3R5icAd6cRzwpq-yhvQUoW",
				H3: "_3UxnA7bFPnKoS0rKMO1UYe",
				h3: "_3UxnA7bFPnKoS0rKMO1UYe",
				H4: "_10CFPbxVR0HQhyRBkeExmO",
				h4: "_10CFPbxVR0HQhyRBkeExmO",
				H5: "_3bidJE2WceaRjyBA8LLfp3",
				h5: "_3bidJE2WceaRjyBA8LLfp3",
				H6: "_27N6aQ0-d-ntRM1JkDwGg7",
				h6: "_27N6aQ0-d-ntRM1JkDwGg7"
			}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/FormatterButton/index.m.less": function(e, t, n) {
			e.exports = {
				button: "_2lAJkFZXhr5kbH7YF-sYFf",
				enabled: "_1H0LLEwUP5ys6cgxr9KhMa",
				active: "_32EiQr-Px2GJvCfigwwmuK"
			}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/FormatterButton/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/controls/Button/index.tsx"),
				c = n("./src/reddit/icons/fonts/index.tsx"),
				d = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				l = n("./src/reddit/components/RichTextEditor/Toolbar/FormatterButton/index.m.less"),
				u = n.n(l);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const p = e => {
				e.preventDefault(), e.stopPropagation()
			};
			t.a = i.a.wrapped(e => {
				const {
					active: t,
					className: n,
					disabledTooltip: o,
					enabled: i = !0,
					tooltip: l,
					Icon: h,
					iconName: b,
					onClick: f,
					overridingClassName: g,
					tooltipBelow: v,
					children: C
				} = e, y = {
					"aria-label": l,
					"aria-selected": t,
					className: g || Object(s.a)(u.a.button, n, {
						[u.a.active]: !!t,
						[u.a.enabled]: i
					}),
					onMouseDown: p,
					onClick: e => {
						p(e), i && f && f(e)
					},
					role: "button",
					tabIndex: -1
				};
				return r.a.createElement(a.t, m({}, y, {
					size: a.d.S,
					priority: a.c.Plain,
					isSquare: !0,
					Icon: b ? Object(c.b)(b) : h
				}), r.a.createElement(d.a, {
					text: (i ? l : o) || "",
					tooltipContentClass: e.tooltipContentClass,
					renderBelow: v
				}), C)
			}, "FormatterButton", u.a)
		},
		"./src/reddit/components/RichTextEditor/Toolbar/MarkdownButton/index.m.less": function(e, t, n) {
			e.exports = {
				LoadingIcon: "jOFrSZE7wRk_lVAP2pBvY",
				loadingIcon: "jOFrSZE7wRk_lVAP2pBvY",
				markdownIcon: "_2ROqhD3999k4q_d5PMRde-",
				Text: "EVdFfF5K7kZFMaYpSHbLe",
				text: "EVdFfF5K7kZFMaYpSHbLe",
				Button: "_1Mg8ZhclDuQlkzEqVU21qu",
				button: "_1Mg8ZhclDuQlkzEqVU21qu"
			}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/MarkdownButton/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/controls/Button/index.tsx"),
				l = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				u = n("./src/reddit/selectors/editorContent.ts"),
				m = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				p = n("./src/reddit/components/RichTextEditor/Toolbar/MarkdownButton/index.m.less"),
				h = n.n(p);
			const b = c.a.wrapped(l.a, "LoadingIcon", h.a),
				f = Object(a.c)({
					isConverting: (e, t) => Object(u.a)(e, t.draftKey)
				}),
				g = Object(i.b)(f);
			t.a = s.a.memo(g(e => s.a.createElement(d.t, {
				priority: d.c.Plain,
				size: d.d.XS,
				text: s.a.createElement(s.a.Fragment, null, e.isConverting && s.a.createElement(b, {
					sizePx: 12
				}), o.fbt._("Markdown Mode", null, {
					hk: "1DXoXV"
				})),
				"aria-label": o.fbt._("Switch to markdown", null, {
					hk: "OxsM0"
				}),
				tabIndex: -1,
				className: e.className,
				onClick: e.onClick
			}, !e.shouldHideTooltip && s.a.createElement(m.a, {
				text: o.fbt._("Switch to markdown", null, {
					hk: "4mWw83"
				})
			}))))
		},
		"./src/reddit/components/RichTextEditor/Toolbar/MediaInputButton/index.m.less": function(e, t, n) {
			e.exports = {
				ImageIcon: "_1jv-IJjyjDSSVuYe6CzeHv",
				imageIcon: "_1jv-IJjyjDSSVuYe6CzeHv",
				VideoIcon: "uo_2BSPFse-IQNQbclyKb",
				videoIcon: "uo_2BSPFse-IQNQbclyKb",
				HiddenInput: "_2keaDnXIlu9Yq2y-cC8zgu",
				hiddenInput: "_2keaDnXIlu9Yq2y-cC8zgu"
			}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/MediaInputButton/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/constants/icons.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts"),
				l = n("./src/reddit/components/RichTextEditor/Toolbar/FormatterButton/index.tsx"),
				u = n("./src/reddit/components/RichTextEditor/Toolbar/MediaInputButton/index.m.less"),
				m = n.n(u);
			const p = c.a.input("HiddenInput", m.a);
			class h extends r.Component {
				constructor() {
					super(...arguments), this.hiddenInputEl = null, this.onFileInputChange = e => {
						e.stopPropagation();
						const t = this.hiddenInputEl,
							n = t.files;
						n && n.length && (this.props.onFilesInput(Array.from(n)), t.value = "")
					}, this.onButtonClick = () => {
						this.hiddenInputEl && this.hiddenInputEl.click(), this.props.onClick()
					}, this.onHiddenInputClick = e => e.stopPropagation()
				}
				render() {
					const {
						accept: e,
						active: t,
						controlsState: n,
						destSubreddit: r,
						disabledTooltip: c,
						enabled: u,
						type: m
					} = this.props, h = "image" === m, b = n.blocks[d.a];
					let f = !0;
					if (r && r.allowedPostTypes) {
						const {
							images: e,
							videos: t
						} = r.allowedPostTypes;
						f = h ? e : t
					}
					let g = b.isActive,
						v = b.isEnabled && f;
					return void 0 !== t && (g = t), void 0 !== u && (v = u), s.a.createElement(l.a, {
						iconName: h ? a.a.image_post : a.a.video_post,
						active: g,
						enabled: v,
						tooltip: h ? o.fbt._("Add an image", null, {
							hk: "4bqU7J"
						}) : o.fbt._("Add a video", null, {
							hk: "2dn6oZ"
						}),
						onClick: this.onButtonClick,
						disabledTooltip: c
					}, s.a.createElement(p, {
						multiple: !0,
						innerRef: e => this.hiddenInputEl = e,
						onChange: this.onFileInputChange,
						onClick: this.onHiddenInputClick,
						type: "file",
						accept: e || Array.from(h ? i.b : i.d).join()
					}))
				}
			}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/formatterConfigs.m.less": function(e, t, n) {
			e.exports = {
				Icon: "_3UAl61hrkRAXX5JQ6m_q8R",
				icon: "_3UAl61hrkRAXX5JQ6m_q8R"
			}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/formatterConfigs.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return p
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "i", (function() {
				return v
			})), n.d(t, "k", (function() {
				return C
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "l", (function() {
				return E
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "c", (function() {
				return _
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./src/lib/constants/icons.ts"),
				a = n("./src/lib/lessComponent.tsx"),
				c = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts"),
				d = n("./src/reddit/components/RichTextEditor/Toolbar/formatterConfigs.m.less"),
				l = n.n(d);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const m = e => a.a.wrapped(e, "Icon", l.a),
				p = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
					return n => {
						const o = m(e);
						return s.a.createElement(o, u({}, n, {
							style: {
								padding: t
							}
						}))
					}
				},
				h = {
					type: "style",
					name: "bold",
					iconName: i.a.bold,
					style: c.k.BOLD,
					tooltipTranslation: () => o.fbt._("Bold", null, {
						hk: "16qNLn"
					})
				},
				b = {
					type: "style",
					name: "italics",
					iconName: i.a.italic,
					style: c.k.ITALIC,
					tooltipTranslation: () => o.fbt._("Italics", null, {
						hk: "3hxpiB"
					})
				},
				f = {
					type: "style",
					name: "strikethrough",
					iconName: i.a.strikethrough,
					style: c.k.STRIKETHROUGH,
					tooltipTranslation: () => o.fbt._("Strikethrough", null, {
						hk: "U4hXC"
					})
				},
				g = {
					type: "style",
					name: "inline_code",
					iconName: i.a.code_inline,
					style: c.k.MONOSPACE,
					tooltipTranslation: () => o.fbt._("Inline Code", null, {
						hk: "1eNxEt"
					})
				},
				v = {
					type: "style",
					name: "spoiler",
					iconName: i.a.spoiler,
					style: c.k.SPOILER,
					tooltipTranslation: () => o.fbt._("Spoiler", null, {
						hk: "1tb6Ht"
					})
				},
				C = {
					type: "style",
					name: "superscript",
					iconName: i.a.superscript,
					style: c.k.SUPERSCRIPT,
					tooltipTranslation: () => o.fbt._("Superscript", null, {
						hk: "sqKFn"
					})
				},
				y = {
					type: "block",
					name: "heading",
					iconName: i.a.text_size,
					block: c.b.H1,
					tooltipTranslation: () => o.fbt._("Heading", null, {
						hk: "4jnBPs"
					})
				},
				E = {
					type: "block",
					name: "unordered_list",
					iconName: i.a.list_bulleted,
					block: c.i.UNORDERED,
					tooltipTranslation: () => o.fbt._("Bulleted List", null, {
						hk: "21Yx7R"
					})
				},
				x = {
					type: "block",
					name: "ordered_list",
					iconName: i.a.list_numbered,
					block: c.i.ORDERED,
					tooltipTranslation: () => o.fbt._("Numbered List", null, {
						hk: "4BmF1X"
					})
				},
				O = {
					type: "block",
					name: "block_quote",
					iconName: i.a.quote,
					block: c.e,
					tooltipTranslation: () => o.fbt._("Quote Block", null, {
						hk: "1xUsGm"
					})
				},
				_ = {
					type: "block",
					name: "code_block",
					iconName: i.a.code_block,
					block: c.f,
					tooltipTranslation: () => o.fbt._("Code Block", null, {
						hk: "2y19DH"
					})
				}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/index.m.less": function(e, t, n) {
			e.exports = {
				ToolbarWrapper: "_2w8adx4kIBGPEESCyEmToa",
				toolbarWrapper: "_2w8adx4kIBGPEESCyEmToa",
				isSticky: "r7zyyy152ZTdiHhea0cIj",
				tooltip: "dMXy0l6Saub8-fPDkQvGC",
				SectionSpacer: "_2voJAi1L0g2QbtAFDHSOCK",
				sectionSpacer: "_2voJAi1L0g2QbtAFDHSOCK",
				CollapseIntoOverflow: "_2Sw_-OGBZ8HN7tA8CP2qjP",
				collapseIntoOverflow: "_2Sw_-OGBZ8HN7tA8CP2qjP",
				MarkdownButtonWrapper: "-CJZhr1W053faqFXFYgXO",
				markdownButtonWrapper: "-CJZhr1W053faqFXFYgXO",
				MarkdownButton: "_2Z7RdWBmSoubpoKJAgNIAi",
				markdownButton: "_2Z7RdWBmSoubpoKJAgNIAi"
			}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return j
			})), n.d(t, "g", (function() {
				return T
			})), n.d(t, "f", (function() {
				return w
			})), n.d(t, "h", (function() {
				return I
			})), n.d(t, "e", (function() {
				return P
			})), n.d(t, "a", (function() {
				return N
			})), n.d(t, "d", (function() {
				return R
			})), n.d(t, "b", (function() {
				return M
			}));
			var o = n("./node_modules/draft-js/lib/Draft.js"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/icons.ts"),
				d = n("./src/reddit/components/CollapseIntoOverflow/index.tsx"),
				l = n("./src/reddit/helpers/richTextEditor/index.ts"),
				u = n("./src/reddit/components/RichTextEditor/editorStateTransforms.ts"),
				m = n("./src/reddit/components/RichTextEditor/helpers/controlsState.ts"),
				p = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts"),
				h = n("./src/reddit/components/RichTextEditor/constants/editorChangeTypes.ts"),
				b = n("./src/reddit/components/RichTextEditor/helpers/common.ts"),
				f = n("./src/reddit/components/RichTextEditor/table/helpers.ts");
			var g = (e, t, n) => {
					if (Object(p.v)(o.RichUtils.getCurrentBlockType(e))) return e;
					const r = e.getCurrentContent(),
						s = e.getSelection().getEndKey(),
						i = Object(f.l)(t, n),
						a = Object(b.f)(r, s, i, b.a.after, !0),
						c = o.EditorState.push(e, a, h.e);
					return o.EditorState.forceSelection(c, o.SelectionState.createEmpty(i[0].getKey()))
				},
				v = n("./src/reddit/components/RichTextEditor/Toolbar/FormatterButton/index.tsx"),
				C = n("./src/reddit/components/RichTextEditor/Toolbar/formatterConfigs.tsx"),
				y = n("./src/reddit/components/RichTextEditor/Toolbar/MarkdownButton/index.tsx"),
				E = n("./src/reddit/components/RichTextEditor/Toolbar/MediaInputButton/index.tsx"),
				x = n("./src/reddit/components/RichTextEditor/Toolbar/index.m.less"),
				O = n.n(x);

			function _() {
				return (_ = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const k = e => i.a.createElement(v.a, _({}, e, {
					tooltipContentClass: O.a.tooltip
				})),
				j = () => i.a.createElement("div", {
					className: O.a.SectionSpacer
				}),
				S = (e, t, n, r, s) => {
					const {
						name: a,
						iconName: c,
						tooltipTranslation: d
					} = e, l = d();
					if ("style" === e.type) {
						const {
							style: o
						} = e;
						return i.a.createElement(k, {
							iconName: c,
							active: t.styles[o].isActive,
							enabled: t.styles[o].isEnabled,
							key: a,
							tooltip: l,
							onClick: () => {
								const e = Object(u.c)(o, n);
								r(e), s(a, ((e, t) => e.getCurrentInlineStyle().contains(t))(e, o))
							}
						})
					} {
						const {
							block: d
						} = e;
						return i.a.createElement(k, {
							iconName: c,
							active: t.blocks[d].isActive,
							enabled: t.blocks[d].isEnabled,
							key: a,
							tooltip: l,
							onClick: () => {
								const e = Object(u.i)(d, n);
								r(e), s(a, ((e, t) => o.RichUtils.getCurrentBlockType(e) === t)(e, d))
							}
						})
					}
				},
				T = (e, t, n, o, r) => e.map(e => S(e, t, n, o, r)),
				w = [C.b, C.e],
				I = [C.j, C.g, C.k, C.i],
				P = [C.d, C.l, C.h, C.a, C.c],
				N = e => i.a.createElement(k, {
					iconName: c.a.link_post,
					active: e.controlsState.link.isActive,
					enabled: e.controlsState.link.isEnabled,
					tooltip: r.fbt._("Link", null, {
						hk: "e4PGW"
					}),
					onClick: () => {
						e.onLinkButtonClick(), e.trackOnClick("link", !0)
					}
				}),
				R = e => i.a.createElement(k, {
					iconName: c.a.table,
					active: e.controlsState.blocks[p.l].isActive,
					enabled: e.controlsState.blocks[p.l].isEnabled,
					tooltip: r.fbt._("Table", null, {
						hk: "3cHfLT"
					}),
					onClick: () => {
						e.onChange(g(e.editorState, 3, 2)), e.trackOnClick("table", !0)
					}
				}),
				M = e => {
					const {
						className: t,
						allowImageUploads: n = !1,
						allowVideoUploads: o = !1,
						destSubreddit: r,
						editorState: s,
						isOverlay: c,
						onChange: u,
						onFilesSelect: p,
						readOnly: h,
						trackOnClick: b,
						onLinkButtonClick: f,
						onMarkdownButtonClick: g,
						editorKey: v
					} = e, C = Object(m.a)(s);
					return h && Object(m.b)(C), i.a.createElement("div", {
						className: Object(a.a)(O.a.ToolbarWrapper, t, {
							[O.a.isSticky]: !c
						})
					}, i.a.createElement(d.a, {
						oveflowMenuDropdownId: v,
						className: O.a.CollapseIntoOverflow,
						editorType: l.a.Post
					}, T(w, C, s, u, b), i.a.createElement(N, {
						controlsState: C,
						trackOnClick: b,
						onLinkButtonClick: f
					}), T(I, C, s, u, b), i.a.createElement(j, null), T(P, C, s, u, b), i.a.createElement(j, null), i.a.createElement(R, {
						controlsState: C,
						editorState: s,
						trackOnClick: b,
						onChange: u
					}), n && i.a.createElement(E.a, {
						destSubreddit: r,
						controlsState: C,
						onClick: () => b("image_upload"),
						onFilesInput: p,
						type: "image"
					}), o && i.a.createElement(E.a, {
						destSubreddit: r,
						controlsState: C,
						onClick: () => b("video_upload"),
						onFilesInput: p,
						type: "video"
					})), i.a.createElement("div", {
						className: O.a.MarkdownButtonWrapper
					}, i.a.createElement(y.a, {
						className: O.a.MarkdownButton,
						onClick: g
					})))
				}
		},
		"./src/reddit/components/RichTextEditor/Tooltip/getSelectionClientRect.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var o = n("./node_modules/draft-js/lib/Draft.js");

			function r() {
				const e = window.getSelection();
				if (!e.rangeCount) return null;
				const t = Object(o.getVisibleSelectionRect)(window);
				return t || (!t && e.focusNode && e.focusNode === e.anchorNode ? e.focusNode.getBoundingClientRect() : null)
			}
		},
		"./src/reddit/components/RichTextEditor/Tooltip/index.m.less": function(e, t, n) {
			e.exports = {
				tooltipBox: "tVQ1dB4n0mAWdcQNxFq-K",
				dropdown: "_1akkpO3lymdoWGIc5tjIpm",
				triangle: "_2O2U-Vhc1mg9O7DOwp50Aa",
				triangleBack: "_3IfYYXUMUzn2OvoiMUNcaQ",
				triangleFront: "_3CtwSTtkmKXvzDo3TmCp9C",
				triangleBelow: "_1churYJpAwcb-tf0k1c46F"
			}
		},
		"./src/reddit/components/RichTextEditor/Tooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/CSSVariableProvider/index.tsx"),
				a = n("./src/reddit/helpers/dom/index.ts"),
				c = n("./src/reddit/components/RichTextEditor/Tooltip/index.m.less"),
				d = n.n(c);
			const l = 8,
				u = 16,
				m = 15 + u / 2;
			var p;
			! function(e) {
				e[e.None = 0] = "None", e[e.Above = 1] = "Above", e[e.Below = 2] = "Below"
			}(p || (p = {}));
			const h = e => {
				let {
					isBelow: t = !1,
					style: n
				} = e;
				return r.a.createElement("div", {
					className: Object(s.a)(d.a.triangle, {
						[d.a.triangleBelow]: t
					}),
					style: n
				}, r.a.createElement("div", {
					className: d.a.triangleBack
				}), r.a.createElement("div", {
					className: d.a.triangleFront
				}))
			};
			class b extends o.Component {
				constructor(e) {
					super(e), this.containerRef = null, this.updateContainerRef = e => this.containerRef = e, this.setTargetPosition = e => {
						e ? this.updatePositioning(e) : this.setState({
							positioning: null
						})
					}, this.state = {
						positioning: null
					}
				}
				updatePositioning(e) {
					if (!this.containerRef) return;
					const t = this.containerRef.getBoundingClientRect(),
						n = Math.round(t.width),
						o = Math.round(t.height),
						r = this.state.positioning;
					if (!e) {
						if (!r) return;
						if (r.tooltipWidth === n && r.tooltipHeight === o) return
					}
					const s = e ? e.bottom : r.target.bottom,
						i = e ? e.top : r.target.top,
						c = e ? e.left : r.target.left,
						d = Object(a.e)(this.containerRef);
					let l, u, m;
					if (d) {
						const e = d.getBoundingClientRect();
						l = e.bottom - (s || 0), u = c - e.left + d.scrollLeft, m = i - e.top + d.scrollTop
					} else {
						const e = document.documentElement,
							t = window.pageYOffset || e.scrollTop;
						u = c + (window.pageXOffset || e.scrollLeft), m = i + t
					}
					const p = {
						target: {
							top: i,
							left: c
						},
						tooltipWidth: n,
						tooltipHeight: o,
						tooltip: {
							top: m,
							left: u,
							bottom: l
						}
					};
					this.adjustPositionForTriangle(p, d), this.setState({
						positioning: p
					})
				}
				adjustPositionForTriangle(e, t) {
					const {
						trianglePlacement: n
					} = this.props;
					if (!n) return;
					const o = t ? t.offsetWidth : document.documentElement.offsetWidth,
						r = o ? Math.max(e.tooltip.left + e.tooltipWidth - o, 0) : 0;
					e.tooltip.left -= r + m;
					const s = r + m - u / 2;
					let i;
					n === p.Above ? (e.tooltip.top += l, i = -l) : (e.tooltip.top -= e.tooltipHeight + l, i = e.tooltipHeight), e.triangle = {
						top: i,
						left: s
					}
				}
				componentDidUpdate(e, t) {
					e.targetPosition !== this.props.targetPosition ? this.setTargetPosition(this.props.targetPosition || null) : this.updatePositioning()
				}
				componentDidMount() {
					this.setTargetPosition(this.props.targetPosition || null), this.props.onSetPositionUpdater && this.props.onSetPositionUpdater(this.setTargetPosition)
				}
				componentWillUnmount() {
					this.props.onSetPositionUpdater && this.props.onSetPositionUpdater(null)
				}
				render() {
					const {
						aboveParent: e,
						dropdown: t,
						trianglePlacement: n
					} = this.props, {
						positioning: o
					} = this.state, a = o && void 0 !== o.triangle && r.a.createElement(h, {
						isBelow: n === p.Below,
						style: {
							top: o.triangle.top + "px",
							left: o.triangle.left + "px"
						}
					});
					let c = r.a.createElement("div", {
						className: Object(s.a)(d.a.tooltipBox, this.props.className, {
							[d.a.dropdown]: t
						}),
						style: o ? {
							left: o.tooltip.left,
							...e ? {
								bottom: o.tooltip.bottom
							} : {
								top: o.tooltip.top
							}
						} : {},
						ref: this.updateContainerRef
					}, o && this.props.children && r.a.createElement(r.a.Fragment, null, a, this.props.children));
					return this.props.usePortal && (c = Object(i.d)(c, this.props.portalContainer || document.body)), c
				}
			}
		},
		"./src/reddit/components/RichTextEditor/UnorderedList/index.m.less": function(e, t, n) {
			e.exports = {
				UnorderedListWrapper: "vXDC2CysyRNVq3lFirKDs",
				unorderedListWrapper: "vXDC2CysyRNVq3lFirKDs"
			}
		},
		"./src/reddit/components/RichTextEditor/constants/draftEditorCommands.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "g", (function() {
				return s
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "a", (function() {
				return l
			}));
			const o = "bold",
				r = "italic",
				s = "underline",
				i = "undo",
				a = "backspace",
				c = "delete",
				d = "split-block",
				l = "adjust-depth"
		},
		"./src/reddit/components/RichTextEditor/constants/editorChangeTypes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "d", (function() {
				return s
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			}));
			const o = "backspace-character",
				r = "insert-fragment",
				s = "insert-characters",
				i = "change-block-data",
				a = "change-block-type",
				c = "remove-range"
		},
		"./src/reddit/components/RichTextEditor/editorStateTransforms.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return u
			})), n.d(t, "i", (function() {
				return m
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "g", (function() {
				return v
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "e", (function() {
				return y
			})), n.d(t, "a", (function() {
				return E
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/draft-js/lib/Draft.js"),
				r = n("./node_modules/immutable/dist/immutable.js"),
				s = n("./src/reddit/components/RichTextEditor/constants/draftEditorCommands.ts"),
				i = n("./src/reddit/components/RichTextEditor/constants/editorChangeTypes.ts"),
				a = n("./src/reddit/components/RichTextEditor/emotes/helpers.ts"),
				c = n("./src/reddit/components/RichTextEditor/helpers/modifiers.ts"),
				d = n("./src/reddit/components/RichTextEditor/helpers/styles.ts"),
				l = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			const u = (e, t) => {
					return t.getSelection().isCollapsed() ? Object(d.a)(e, t) : Object(d.b)(e, t)
				},
				m = (e, t) => {
					const n = t.getCurrentContent(),
						r = t.getSelection(),
						s = r.getEndKey(),
						c = o.RichUtils.getCurrentBlockType(t) === e ? l.n : e;
					let u = t,
						m = o.Modifier.setBlockType(n, r, c);
					const p = n.getBlockForKey(s).getLength();
					if (Object(l.r)(c) || Object(l.q)(c)) {
						const e = o.SelectionState.createEmpty(r.getStartKey()).merge({
							focusKey: r.getEndKey(),
							focusOffset: p
						});
						u = Object(d.c)(u), m = ((e, t) => {
							const n = Object.keys(l.k).reduce((e, n) => o.Modifier.removeInlineStyle(e, t, l.k[n]), e);
							return Object(a.h)(n, t)
						})(m, e)
					}
					if (Object(l.q)(c) || Object(l.p)(c)) {
						const e = m.getBlockAfter(s);
						if (!e || e.getType() !== c && e.getType() !== l.n) {
							const e = o.SelectionState.createEmpty(s).merge({
								anchorOffset: p,
								focusOffset: p
							});
							m = o.Modifier.splitBlock(m, e), m = o.Modifier.setBlockType(m, m.getSelectionAfter(), l.n)
						}
					}
					return m = m.merge({
						selectionAfter: r
					}), o.EditorState.push(u, m, i.c)
				},
				p = (e, t) => {
					const n = o.Modifier.setBlockType(e, t, l.n);
					return o.Modifier.replaceText(n, t, "", Object(r.OrderedSet)([]))
				},
				h = (e, t) => o.EditorState.forceSelection(e, o.SelectionState.createEmpty(t)),
				b = e => {
					const t = e.getCurrentContent(),
						n = e.getSelection(),
						s = c.d(t, n),
						a = s.getBlockAfter(n.getEndKey()),
						d = o.SelectionState.createEmpty(a.getKey()),
						u = o.Modifier.replaceText(o.Modifier.setBlockType(s, d, l.n), d, "", Object(r.OrderedSet)([])),
						m = o.EditorState.push(e, u, i.d);
					return h(m, a.getKey())
				},
				f = e => {
					const t = e.getCurrentContent(),
						n = e.getSelection(),
						r = t.getBlockForKey(n.getEndKey()),
						i = r.set("depth", Math.max(r.getDepth() - 1, 0)),
						a = t.merge({
							blockMap: t.getBlockMap().merge({
								[r.getKey()]: i
							})
						});
					return o.EditorState.push(e, a, s.a)
				},
				g = e => {
					const t = e.getCurrentContent(),
						n = e.getSelection(),
						r = t.getBlockForKey(n.getEndKey()).getKey(),
						s = o.EditorState.push(e, p(t, n), i.c);
					return h(s, r)
				},
				v = e => {
					const t = e.getCurrentContent(),
						n = e.getSelection(),
						r = t.getBlockForKey(n.getEndKey()),
						s = r.getKey(),
						a = t.getBlockBefore(s).getKey(),
						c = o.SelectionState.createEmpty(s).merge({
							focusOffset: r.getText().length
						}),
						d = o.EditorState.push(e, p(((e, t) => {
							const n = e.getBlockMap().remove(t);
							return e.merge({
								blockMap: n
							})
						})(t, a), c), i.c);
					return h(d, s)
				},
				C = e => {
					const t = c.d(e.getCurrentContent(), e.getSelection());
					return o.EditorState.push(e, t, s.f)
				},
				y = e => {
					const t = c.a(e.getCurrentContent(), e.getSelection(), "\n");
					return o.EditorState.push(e, t, i.d)
				},
				E = e => {
					const t = e.getSelection(),
						n = c.a(e.getCurrentContent(), t, " ");
					return o.EditorState.push(e, n, i.d)
				}
		},
		"./src/reddit/components/RichTextEditor/emotes/Powerups/tooltipAsync.ts": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(o.a)({
				resolved: {},
				chunkName: () => "PowerupsEmotesTooltip",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("PowerupsEmotesTooltip").then(n.bind(null, "./src/reddit/components/RichTextEditor/emotes/Powerups/Tooltip.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/RichTextEditor/emotes/Powerups/Tooltip.tsx"
				}
			})
		},
		"./src/reddit/components/RichTextEditor/emotes/decorator.m.less": function(e, t, n) {
			e.exports = {
				emote: "Q7hqnjoPSXm7QyvW8qf57",
				sticker: "_1WD0TSe2_gY29FXmFjPCza"
			}
		},
		"./src/reddit/components/RichTextEditor/emotes/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "e", (function() {
				return v
			})), n.d(t, "i", (function() {
				return C
			})), n.d(t, "d", (function() {
				return y
			}));
			var o = n("./node_modules/draft-js/lib/Draft.js"),
				r = n("./node_modules/immutable/dist/immutable.js"),
				s = n("./src/lib/memoizeByReference/index.ts"),
				i = n("./src/reddit/components/RichTextEditor/constants/editorChangeTypes.ts"),
				a = n("./src/reddit/components/RichTextEditor/entity/entityTypes.ts"),
				c = n("./src/reddit/components/RichTextEditor/entity/getAllEntitiesInSelection.ts"),
				d = n("./src/reddit/components/RichTextEditor/helpers/common.ts"),
				l = n("./src/reddit/components/RichTextEditor/helpers/modifiers.ts"),
				u = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			const m = "";

			function p(e, t) {
				return e.createEntity(a.a.EMOTE, "IMMUTABLE", t)
			}

			function h(e, t) {
				let n = t.getCurrentContent();
				const r = (n = p(n, e)).getLastCreatedEntityKey();
				n = Object(l.b)(n, t.getSelection(), m, void 0, r);
				const s = o.EditorState.push(t, n, i.d);
				return o.EditorState.forceSelection(s, s.getSelection())
			}

			function b(e, t) {
				if (t.getStartKey() !== t.getEndKey()) return !1;
				const n = e.getBlockForKey(t.getEndKey()).getType();
				return !(Object(u.q)(n) || Object(u.r)(n) || Object(u.t)(n))
			}

			function f(e, t) {
				const n = Object(c.a)(e, t, t => {
					const n = t.getEntity();
					return !!n && e.getEntity(n).getType() === a.a.EMOTE
				});
				let r;
				for (; r = n.pop();) {
					const t = o.SelectionState.createEmpty(r.blockKey).merge({
						anchorOffset: r.start,
						focusOffset: r.end
					});
					e = o.Modifier.removeRange(e, t, "backward")
				}
				return e
			}

			function g(e) {
				const t = e.getSelection();
				if (!t.isCollapsed()) return null;
				const n = e.getCurrentContent().getBlockForKey(t.getFocusKey()),
					o = n.getText(),
					r = n.getCharacterList();
				let s = t.getFocusOffset() - 1;
				const i = [];
				for (; s >= 0;) {
					const e = o[s],
						t = r.get(s),
						n = t && t.getEntity();
					if (!e.trim().length || n) return null;
					if (":" === e && i.length > 0) break;
					i.unshift(e), s--
				}
				return s >= 0 && i.length ? i.join("").toLowerCase() : null
			}

			function v(e, t, n) {
				e.findEntityRanges(e => {
					const t = e.getEntity();
					return !!t && n.getEntity(t).getType() === a.a.EMOTE
				}, t)
			}
			const C = Object(s.a)(e => {
				if (e.getBlockMap().size > 1) return !1;
				const t = e.getFirstBlock();
				let n = 0;
				return v(t, () => n++, e), n <= 3 && n === t.getLength()
			});

			function y(e, t) {
				if (C(e.getCurrentContent()) === C(t.getCurrentContent())) return e;
				const n = e.getCurrentContent(),
					s = n.getFirstBlock();
				return o.EditorState.set(e, {
					currentContent: o.Modifier.mergeBlockData(n, Object(d.b)(s), Object(r.Map)({
						_emote_modified: new Date
					}))
				})
			}
		},
		"./src/reddit/components/RichTextEditor/entity/applyEntityToContentBlock.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var o = n("./node_modules/draft-js/lib/Draft.js");

			function r(e, t, n, r) {
				let s = e.getCharacterList();
				return s = s.withMutations(e => {
					for (let s = t; s < n; s++) e.set(s, o.CharacterMetadata.applyEntity(e.get(s), r))
				}), e.set("characterList", s)
			}
		},
		"./src/reddit/components/RichTextEditor/entity/cloneEntitiesInFragment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./src/reddit/components/RichTextEditor/entity/applyEntityToContentBlock.ts");

			function r(e, t, n, r, s) {
				const i = e.createEntity(n.getType(), n.getMutability(), n.getData()),
					a = e.getLastCreatedEntityKey();
				return [i, Object(o.a)(t, r, s, a)]
			}

			function s(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
				const o = new Map;
				let s = t,
					i = e;
				return t.forEach((e, t) => {
					e && t && e.findEntityRanges(e => !!e.getEntity(), (n, r) => {
						const s = e.getEntityAt(n),
							i = o.get(s) || [];
						i.push({
							start: n,
							end: r,
							blockKey: t
						}), o.set(s, i)
					})
				}), o.forEach((t, o) => {
					const a = e.getEntity(o);
					(n ? t.slice(1) : t).forEach(e => {
						let {
							start: t,
							end: n,
							blockKey: o
						} = e;
						const c = s.get(o),
							[d, l] = r(i, c, a, t, n);
						i = d, s = s.set(o, l)
					})
				}), [i, s]
			}
		},
		"./src/reddit/components/RichTextEditor/entity/entityTypes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const o = {
					COMMENT_LINK: "COMMENT_LINK",
					EMOTE: "EMOTE",
					LINK: "LINK",
					POST_LINK: "POST_LINK",
					SUBREDDIT_LINK: "SUBREDDIT_LINK",
					USER_LINK: "USER_LINK",
					USER_MENTION: "USER_MENTION"
				},
				r = new Set([o.COMMENT_LINK, o.LINK, o.POST_LINK, o.SUBREDDIT_LINK, o.USER_LINK, o.USER_MENTION]),
				s = (e, t) => {
					const n = e && t.getEntity(e);
					return !!n && (e => r.has(e))(n.getType())
				}
		},
		"./src/reddit/components/RichTextEditor/entity/getAllEntitiesInSelection.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var o = n("./src/reddit/components/RichTextEditor/helpers/forEachBlock.ts");

			function r(e, t, n) {
				const r = [];
				return Object(o.a)(e, t, (e, o) => {
					const s = t.getStartKey() === o ? t.getStartOffset() : 0,
						i = t.getEndKey() === o ? t.getEndOffset() : e.getLength();
					e.findEntityRanges(n, (t, n) => {
						s <= n && i >= t && r.push({
							blockKey: o,
							entityKey: e.getEntityAt(t),
							start: t,
							end: n
						})
					})
				}), r
			}
		},
		"./src/reddit/components/RichTextEditor/entity/getSelectionEntityInfo.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var o = n("./node_modules/draft-js/lib/Draft.js");

			function r(e, t) {
				const n = t.getFocusKey();
				if (n !== t.getAnchorKey()) return;
				const r = e.getBlockForKey(n),
					s = t.getStartOffset(),
					i = t.getEndOffset(),
					a = r.getEntityAt(i) || (i > 0 ? r.getEntityAt(i - 1) : null);
				if (!a) return;
				let c, d;
				if (r.findEntityRanges(e => e.getEntity() === a, (e, t) => {
						e <= s && i <= t && (c = e, d = t)
					}), "number" != typeof c || "number" != typeof d) return;
				const l = r.getText().slice(c, d);
				return {
					entitySelection: o.SelectionState.createEmpty(n).merge({
						anchorOffset: c,
						focusOffset: d
					}),
					entityKey: a,
					entityText: l
				}
			}
		},
		"./src/reddit/components/RichTextEditor/entity/link/decorator.m.less": function(e, t, n) {
			e.exports = {
				RegularLink: "_1FRfMxEAy__7c8vezYv9qP",
				regularLink: "_1FRfMxEAy__7c8vezYv9qP"
			}
		},
		"./src/reddit/components/RichTextEditor/entity/link/helpers.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "b", (function() {
				return C
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "e", (function() {
				return x
			}));
			var o = n("./node_modules/draft-js/lib/Draft.js"),
				r = n("./src/lib/linkMatchers/index.ts"),
				s = n("./src/lib/linkMatchers/customLinks.ts"),
				i = n("./src/lib/memoizeByReference/index.ts"),
				a = n("./src/reddit/components/RichTextEditor/entity/entityTypes.ts"),
				c = n("./src/reddit/components/RichTextEditor/entity/getAllEntitiesInSelection.ts"),
				d = n("./src/reddit/components/RichTextEditor/entity/getSelectionEntityInfo.ts"),
				l = n("./src/reddit/components/RichTextEditor/spoiler/helpers.ts"),
				u = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			const m = [a.a.SUBREDDIT_LINK, a.a.USER_LINK, a.a.USER_MENTION],
				p = [...m, a.a.LINK];

			function h(e, t, n) {
				e.findEntityRanges(e => {
					const t = e.getEntity();
					return !!t && p.includes(n.getEntity(t).getType())
				}, t)
			}
			const b = e => {
					const t = r.a.match(e);
					if (t && t.length && t[0]) {
						const {
							schema: e,
							url: n
						} = t[0];
						return {
							linkPrefix: e,
							url: n
						}
					}
					return {
						linkPrefix: "",
						url: ""
					}
				},
				f = Object(i.a)((function(e) {
					const t = e.getCurrentContent(),
						n = e.getSelection();
					if (!n.isCollapsed()) return;
					if (Object(u.q)(t.getBlockForKey(n.getStartKey()).getType())) return;
					const s = n.getFocusKey(),
						i = t.getBlockForKey(s),
						a = n.getFocusOffset(),
						c = i.getText(),
						d = c.lastIndexOf(" ", a - 1) + 1,
						m = c.slice(d, a);
					if (!m) return;
					const p = r.f.match(m);
					if (!p) return;
					const h = p[p.length - 1],
						b = d + h.index,
						f = d + h.lastIndex;
					let g = -1;
					if (i.findEntityRanges(e => !!e.getEntity(), (e, t) => {
							e < a && (g = t)
						}), g >= b) return;
					return i.getCharacterList().slice(b, f).find(l.b) ? void 0 : {
						selection: o.SelectionState.createEmpty(s).merge({
							anchorOffset: b,
							focusOffset: f
						}),
						url: h.url
					}
				}));

			function g(e, t, n) {
				const r = e.getSelection();
				let s = e.getCurrentContent();
				const i = (s = s.createEntity(a.a.LINK, "MUTABLE", {
					url: n
				})).getLastCreatedEntityKey();
				return s = (s = o.Modifier.applyEntity(s, t, i)).merge({
					selectionAfter: r
				}), o.EditorState.push(e, s, "apply-entity")
			}
			const v = Object(i.a)((function(e) {
				const t = e.getCurrentContent(),
					n = Object(d.a)(t, e.getSelection());
				if (!n) return;
				const o = t.getEntity(n.entityKey);
				if (o.getType() !== a.a.LINK) return;
				const {
					url: r
				} = o.getData();
				return {
					url: r,
					...n
				}
			}));
			const C = Object(i.a)((function(e) {
				const t = e.getCurrentContent(),
					n = e.getSelection(),
					o = Object(d.a)(t, n);
				if (!o) return;
				const r = n.getFocusOffset(),
					s = t.getEntity(o.entityKey),
					{
						linkPrefix: i
					} = b(o.entityText);
				return !m.includes(s.getType()) || !o.entityText.startsWith(i) || r - o.entitySelection.getStartOffset() < i.length ? void 0 : {
					internalName: o.entityText.slice(i.length),
					...o
				}
			}));

			function y(e, t, n, r) {
				let s = "apply-entity",
					i = e.getCurrentContent(),
					c = e;
				const l = Object(d.a)(i, t);
				if (n)
					if (l) {
						const e = i.getEntity(l.entityKey),
							{
								url: t
							} = e.getData();
						t !== n && (i = i.mergeEntityData(l.entityKey, {
							url: n
						})), void 0 !== r && l.entityText !== r && (i = o.Modifier.replaceText(i, l.entitySelection, r, void 0, l.entityKey), s = "insert-characters")
					} else {
						if (void 0 === r) throw new Error("New link display text must be provided!");
						const e = (i = i.createEntity(a.a.LINK, "MUTABLE", {
							url: n
						})).getLastCreatedEntityKey();
						i = o.Modifier.replaceText(i, t, r, void 0, e), s = "insert-characters"
					}
				else i = (i = o.Modifier.applyEntity(i, t, "")).merge({
					selectionAfter: e.getSelection()
				});
				return i === e.getCurrentContent() ? e : c = o.EditorState.push(c, i, s)
			}

			function E(e, t) {
				const n = C(e);
				if (!n) return e;
				const {
					linkPrefix: r,
					url: i
				} = b(n.entityText), a = `${r===s.d.mention?s.d.profile:r}${t}`, c = n.entitySelection.getStartOffset() + a.length;
				let d = y(e, n.entitySelection, i, a);
				return d = o.EditorState.forceSelection(d, n.entitySelection.merge({
					anchorOffset: c,
					focusOffset: c
				}))
			}

			function x(e, t) {
				if (t.getStartKey() !== t.getEndKey()) return !1;
				const n = e.getBlockForKey(t.getEndKey()).getType();
				return !Object(u.q)(n) && !Object(u.t)(n) && !Object(c.a)(e, t, t => {
					const n = t.getEntity();
					return !!n && e.getEntity(n).getType() !== a.a.LINK
				}).length
			}
		},
		"./src/reddit/components/RichTextEditor/helpers/common.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "i", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "g", (function() {
				return h
			}));
			var o, r = n("./node_modules/draft-js/lib/Draft.js"),
				s = n("./node_modules/immutable/dist/immutable.js"),
				i = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			! function(e) {
				e.before = "before", e.after = "after"
			}(o || (o = {}));
			const a = (e, t) => new r.ContentBlock({
					key: e || Object(r.genKey)(),
					...t ? {
						text: t,
						characterList: Object(s.List)(Object(s.Repeat)(r.CharacterMetadata.create(), t.length))
					} : {}
				}),
				c = e => e.props.children,
				d = e => c(e).props.block,
				l = function(e, t, n) {
					let s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : o.after,
						c = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
						d = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
					const l = [];
					let m = -1;
					if (e.getBlockMap().forEach((e, r) => {
							s === o.after && l.push(e), r === t && (l.push(...n), m = l.length - 1), s === o.before && l.push(e)
						}), m >= 0) {
						if (c) {
							const e = l[m + 1];
							e && e.getType() === i.n || l.splice(m + 1, 0, a())
						}
						if (d) {
							const e = m - n.length,
								t = l[e];
							t && t.getType() === i.n || l.splice(e + 1, 0, a())
						}
					}
					return e.merge({
						blockMap: r.BlockMapBuilder.createFromArray(l),
						selectionAfter: u(n[n.length - 1], !1, !0)
					})
				},
				u = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
						n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
						o = r.SelectionState.createEmpty(e.getKey()).merge({
							hasFocus: n
						});
					return t && (o = o.merge({
						anchorOffset: e.getLength(),
						focusOffset: e.getLength()
					})), o
				},
				m = (e, t) => {
					let n = e.getBlockBefore(t),
						o = e.getBlockMap();
					return o.get(t) ? (o = o.size > 1 ? o.remove(t) : o.set(t, a(t)), n = n || o.first(), e.merge({
						blockMap: o,
						selectionAfter: u(n, !0)
					})) : e
				},
				p = (e, t) => t.querySelector(`[data-block][data-offset-key="${e}-0-0"]`),
				h = e => e.getType() === i.n && !e.getText()
		},
		"./src/reddit/components/RichTextEditor/helpers/controlsState.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/lodash/forEach.js"),
				r = n.n(o),
				s = n("./src/lib/forEachGroup/index.ts"),
				i = n("./src/lib/memoizeByReference/index.ts"),
				a = n("./src/reddit/components/RichTextEditor/emotes/helpers.ts"),
				c = n("./src/reddit/components/RichTextEditor/entity/link/helpers.tsx"),
				d = n("./src/reddit/components/RichTextEditor/media/helpers.ts"),
				l = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts"),
				u = n("./src/reddit/components/RichTextEditor/table/helpers.ts"),
				m = n("./src/reddit/components/RichTextEditor/helpers/forEachBlock.ts"),
				p = n("./src/reddit/components/RichTextEditor/helpers/styles.ts");
			const h = e => {
					const t = e.getCurrentContent(),
						n = e.getSelection(),
						o = (() => {
							const e = {};
							return r()(l.k, t => e[t] = {
								isActive: !1,
								isEnabled: !1
							}), e
						})(),
						i = new Set(Object.keys(o));
					if (i.delete(l.k.HIGHLIGHT), n.isCollapsed()) {
						const r = t.getBlockForKey(n.getEndKey()),
							s = r.getType();
						Object(l.q)(s) || Object(l.r)(s) || Object(l.t)(s) || i.forEach(e => o[e].isEnabled = !0), e.getCurrentInlineStyle().forEach(e => {
							e && o[e] && (o[e].isActive = !0)
						}), Object(u.i)(r) && (o[l.k.BOLD] = {
							isEnabled: !1,
							isActive: !1
						})
					} else {
						Object(p.e)(t, n).forEach(e => {
							i.delete(e), o[e] && (o[e].isActive = !0, o[e].isEnabled = !0)
						}), Object(m.a)(t, n, (e, r) => {
							if (!i.size) return !1;
							const a = n.getStartKey() === r ? n.getStartOffset() : 0,
								c = n.getEndKey() === r ? n.getEndOffset() : e.getLength(),
								d = e.getType(),
								u = e.getCharacterList();
							Object(l.q)(d) || Object(l.r)(d) || Object(l.t)(d) || Object(s.a)(u, {
								start: a,
								end: c
							}, (n, r, s, a) => {
								const c = n.getStyle(),
									d = n.getEntity(),
									l = d ? t.getEntity(d) : null;
								if (i.forEach(t => {
										const n = !o[t].isActive,
											r = Object(p.f)(c, e, l, t, n);
										r && r !== c && (o[t].isEnabled = !0, i.delete(t))
									}), !i.size) return !1
							})
						})
					}
					return o
				},
				b = e => {
					const t = {};
					return r()(l.b, n => t[n] = {
						isActive: !1,
						isEnabled: e
					}), t
				},
				f = Object(i.a)(e => {
					const t = e.getCurrentContent(),
						n = e.getSelection(),
						o = (e => {
							const t = e.getCurrentContent(),
								n = e.getSelection();
							let o = b(!0),
								s = null;
							if (n.isCollapsed()) s = t.getBlockForKey(n.getEndKey()).getType();
							else {
								let e = null;
								Object(m.a)(t, n, (t, n) => {
									const r = t.getType();
									return Object(l.t)(r) ? (o = b(!1), !1) : (null === e && (e = r), e !== r ? (e = null, !1) : void 0)
								}), s = e
							}
							return null !== s && ((Object(l.v)(s) || Object(l.t)(s)) && r()(o, e => {
								e.isEnabled = !1
							}), o[s].isActive = !0), o
						})(e);
					return {
						giphy: {
							isActive: !1,
							isEnabled: o[l.a].isEnabled && !Object(d.j)(t)
						},
						emote: {
							isActive: !1,
							isEnabled: Object(a.b)(t, n)
						},
						link: {
							isActive: !1,
							isEnabled: Object(c.e)(t, n)
						},
						blocks: o,
						styles: h(e)
					}
				}),
				g = e => {
					r()(e.blocks, e => {
						e.isEnabled = !1
					}), r()(e.styles, e => {
						e.isEnabled = !1
					}), e.link.isEnabled = !1
				}
		},
		"./src/reddit/components/RichTextEditor/helpers/forEachBlock.ts": function(e, t, n) {
			"use strict";

			function o(e, t, n) {
				const o = t.getStartKey(),
					r = t.getEndKey();
				if (o === r) return void n(e.getBlockForKey(o), o);
				let s = !1;
				e.getBlockMap().forEach((e, t) => {
					if (t === o && (s = !0), !s || !e || !t) return;
					const i = n(e, t);
					return t !== r && i
				})
			}
			n.d(t, "a", (function() {
				return o
			}))
		},
		"./src/reddit/components/RichTextEditor/helpers/modifiers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "d", (function() {
				return d
			}));
			var o = n("./node_modules/draft-js/lib/Draft.js"),
				r = n("./src/reddit/components/RichTextEditor/entity/cloneEntitiesInFragment.ts");

			function s(e, t) {
				const n = t.getStartKey();
				if (n !== t.getEndKey()) return;
				const o = e.getBlockForKey(n),
					s = t.getStartOffset(),
					i = t.getEndOffset(),
					a = s > 0 ? o.getEntityAt(s - 1) : null,
					c = o.getEntityAt(i);
				if (!a || !c || a !== c) return;
				const d = e.getEntity(c),
					l = o.getCharacterList().toSeq().skip(i).takeWhile(e => !!e && e.getEntity() === c).count(),
					[u, m] = Object(r.a)(e, o, d, i, i + l);
				return u.merge({
					blockMap: u.getBlockMap().set(o.getKey(), m)
				})
			}

			function i(e, t, n) {
				const r = s(e, t) || e;
				return o.Modifier.replaceWithFragment(r, t, n)
			}

			function a(e, t, n, r, i) {
				let a = e;
				return -1 !== n.indexOf("\n") && (a = s(e, t) || a), o.Modifier.replaceText(a, t, n, r, i)
			}

			function c(e, t, n, r, i) {
				let a = e;
				return -1 !== n.indexOf("\n") && (a = s(e, t) || a), o.Modifier.insertText(a, t, n, r, i)
			}

			function d(e, t) {
				const n = s(e, t) || e;
				return o.Modifier.splitBlock(n, t)
			}
		},
		"./src/reddit/components/RichTextEditor/helpers/sliceContiguousBlocks.ts": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/lodash/forEach.js"),
				r = n.n(o);
			t.a = (e, t) => {
				const n = e.getBlocksAsArray(),
					o = t.getKey(),
					s = t.getType();
				let i = null,
					a = null,
					c = !1;
				if (r()(n, (e, t) => {
						if (c || e.getKey() !== o || (c = !0), e.getType() === s) null === i && (i = t), a = t;
						else {
							if (c) return !1;
							i = null, a = null
						}
					}), c) return a = a || 0, {
					start: i = i || 0,
					blocks: n.slice(i, a + 1)
				}
			}
		},
		"./src/reddit/components/RichTextEditor/helpers/styles.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			}));
			var o = n("./node_modules/draft-js/lib/Draft.js"),
				r = n("./node_modules/immutable/dist/immutable.js"),
				s = n("./src/lib/forEachGroup/index.ts"),
				i = n("./src/reddit/components/RichTextEditor/entity/entityTypes.ts"),
				a = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts"),
				c = n("./src/reddit/components/RichTextEditor/table/helpers.ts"),
				d = n("./src/reddit/components/RichTextEditor/helpers/forEachBlock.ts");
			const l = Object(r.OrderedSet)([]),
				u = function(e, t, n, o) {
					let s = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
					const d = t.getType();
					if (Object(a.q)(d) || Object(a.r)(d) || Object(a.t)(d)) return;
					if (o === a.k.BOLD && Object(c.i)(t)) return;
					const u = n ? n.getType() : null,
						m = u === i.a.SUBREDDIT_LINK || u === i.a.USER_LINK;
					return m && o !== a.k.SPOILER && o !== a.k.MONOSPACE || u === i.a.EMOTE ? void 0 : o === a.k.MONOSPACE || o === a.k.SPOILER ? s ? Object(r.OrderedSet)([o]) : l : (e.has(a.k.MONOSPACE) || e.has(a.k.SPOILER)) && s ? Object(r.OrderedSet)([o]) : !s || o !== a.k.SUPERSCRIPT && o !== a.k.SUBSCRIPT ? s ? e.add(o) : e.has(o) ? e.delete(o) : void 0 : e.delete(a.k.SUBSCRIPT).delete(a.k.SUPERSCRIPT).add(o)
				},
				m = (e, t) => {
					let n = null,
						o = !0;
					return Object(d.a)(e, t, (r, d) => {
						const l = r.getType(),
							u = Object(c.i)(r);
						if (u || (o = !1), Object(a.q)(l) || Object(a.r)(l) || Object(a.t)(l)) return !1;
						const m = t.getStartKey() === d ? t.getStartOffset() : 0,
							p = t.getEndKey() === d ? t.getEndOffset() : r.getLength(),
							h = r.getCharacterList();
						Object(s.a)(h, {
							start: m,
							end: p
						}, t => {
							const o = t.getEntity();
							if (o && e.getEntity(o).getType() === i.a.SUBREDDIT_LINK) return;
							let r = t.getStyle();
							return u && (r = r.add(a.k.BOLD)), null === n ? n = r.asMutable() : n.intersect(r), !(n && !n.size) && void 0
						})
					}), null === n ? [] : (o && n.delete(a.k.BOLD), n.toJS())
				},
				p = (e, t) => {
					const n = t.getCurrentContent(),
						r = t.getSelection();
					let i = n.getBlockMap();
					const c = -1 === m(n, r).indexOf(e);
					Object(d.a)(n, r, (t, d) => {
						if (!t || !d) return !1;
						const l = r.getStartKey() === d ? r.getStartOffset() : 0,
							m = r.getEndKey() === d ? r.getEndOffset() : t.getLength(),
							p = t.getCharacterList(),
							h = p.withMutations(r => {
								Object(s.a)(p, {
									start: l,
									end: m
								}, (s, i, d, l) => {
									const m = s.getStyle(),
										p = s.getEntity(),
										h = p ? n.getEntity(p) : null,
										b = u(m, t, h, e, c);
									if (b) {
										const e = ((e, t) => o.CharacterMetadata.create({
											style: t,
											entity: t.has(a.k.SPOILER) ? null : e.getEntity()
										}))(s, b);
										for (let t = d; t < l; t++) r.set(t, e)
									}
								})
							});
						if (h !== p) {
							const e = t.set("characterList", h);
							i = i.set(d, e)
						}
					});
					const l = n.merge({
						blockMap: i,
						selectionAfter: r
					});
					return o.EditorState.push(t, l, "change-inline-style")
				},
				h = (e, t) => {
					const n = t.getCurrentContent(),
						r = t.getSelection(),
						s = n.getBlockForKey(r.getStartKey()),
						i = s.getEntityAt(r.getStartOffset()),
						a = i ? n.getEntity(i) : null,
						c = t.getCurrentInlineStyle(),
						d = u(c, s, a, e, !c.has(e));
					let l = t;
					return d && (l = o.EditorState.setInlineStyleOverride(l, d)), l
				},
				b = e => o.EditorState.setInlineStyleOverride(e, l),
				f = (e, t) => {
					const n = e.getSelection(),
						o = t.getSelection();
					return n.getStartOffset() > 0 || n.getFocusKey() === o.getFocusKey() || e.getCurrentInlineStyle().isEmpty() ? e : b(e)
				}
		},
		"./src/reddit/components/RichTextEditor/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_3YZ-jFfccqhepgq1dDuLEv",
				container: "_3YZ-jFfccqhepgq1dDuLEv",
				FocusableContent: "_3wl1bRnSzxHkKJfvqakrNI",
				focusableContent: "_3wl1bRnSzxHkKJfvqakrNI",
				showSubmitButton: "_3Imp2y02BMA96sEJAe9M3M",
				mRedesign: "_2sl29I15jbNPrKiiB9kfVf",
				editorWrapper: "_2baJGEALPiEMZpWB2iWQs7",
				mExpanded: "_1UhKfcyzvaWRtDdXZmzg6D",
				userIcon: "_1wS6Q6S9RvAbzxaselfK2i",
				CurrentUserIcon: "_1RdaOAYbtM4Zwt3M_YE8kp",
				currentUserIcon: "_1RdaOAYbtM4Zwt3M_YE8kp",
				hasInitialHeight: "_35E-zXyMmfsLI7nv_sBvFL",
				hasInitialMinHeight: "_18GfdTZmF2EPjYSkBDE0WI",
				noBorder: "HXDWn-rmYOwqGcGtz9AKm",
				insetSubmitButton: "_3b2mbY1nb1R-z21ihISt7z",
				emptyContent: "_3cP1eCSI5AeGc6__VQ1axu",
				focusedContent: "_2O6bpyGivXLGxZ0LErKCzW"
			}
		},
		"./src/reddit/components/RichTextEditor/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/draft-js/lib/Draft.js"),
				r = (n("./node_modules/draft-js/dist/Draft.css"), n("./node_modules/fbt/lib/FbtPublic.js")),
				s = n("./node_modules/lodash/debounce.js"),
				i = n.n(s),
				a = n("./node_modules/lodash/filter.js"),
				c = n.n(a),
				d = n("./node_modules/lodash/noop.js"),
				l = n.n(d),
				u = n("./node_modules/react/index.js"),
				m = n.n(u),
				p = n("./node_modules/react-redux/es/index.js"),
				h = n("./node_modules/reselect/es/index.js"),
				b = n("./node_modules/shallowequal/index.js"),
				f = n.n(b),
				g = n("./src/lib/classNames/index.ts"),
				v = n("./src/lib/fastdom/index.ts"),
				C = n("./src/lib/lessComponent.tsx"),
				y = n("./src/lib/linkMatchers/customLinks.ts"),
				E = n("./src/lib/logs/console.ts"),
				x = n("./src/telemetry/models/Media.ts"),
				O = n("./src/realtime/GQLSubscription/async.tsx"),
				_ = n("./src/reddit/actions/economics/subredditPremium/thunkedActions.ts"),
				k = n("./src/reddit/actions/postCreation/mediaUpload.ts"),
				j = n("./src/reddit/featureFlags/index.ts"),
				S = n("./src/reddit/helpers/trackers/postComposer.ts"),
				T = n("./src/reddit/models/PostCreationForm/index.ts"),
				w = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			const I = {
				BREAK_HEADER_ENTITY: "BREAK_HEADER_ENTITY",
				CONVERT_TO_LIST_ON_SPACE: "CONVERT_TO_LIST_ON_SPACE",
				EXEC_TABLE_ON_ENTER_HANDLER: "EXEC_TABLE_ON_ENTER_HANDLER",
				INSERT_LINE_BREAK: "INSERT_LINE_BREAK",
				LINKIFY_ON_ENTER: "LINKIFY_ON_ENTER",
				LINKIFY_ON_SPACE: "LINKIFY_ON_SPACE",
				MAKE_PLAIN_BLOCK: "MAKE_PLAIN_BLOCK",
				OPEN_LINK_TOOLTIP: "OPEN_LINK_TOOLTIP",
				REDUCE_LIST_INDENT: "REDUCE_LIST_INDENT",
				REMOVE_EXTRA_LIST_ITEM: "REMOVE_EXTRA_LIST_ITEM",
				RESET_CURRENT_AND_PREVIOUS_BLOCKS: "RESET_CURRENT_AND_PREVIOUS_BLOCKS",
				SUBMIT: "SUBMIT"
			};
			const P = e => {
					const t = e.getCurrentContent().getBlockMap();
					if (t.size > 2 || (e => !!e.reduce((function() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
								t = arguments.length > 1 ? arguments[1] : void 0;
							return e + t.getLength()
						}), 0))(t) || (e => !!e.find(e => Object(w.o)(e.getType())))(t) || e.isInCompositionMode()) return null; {
						const n = e.getSelection();
						if (n.isCollapsed() && n.getFocusKey() === t.first().getKey()) return n.getFocusKey()
					}
				},
				N = e => {
					const t = e.getCharacterList().map(e => o.CharacterMetadata.create({
						entity: e.getEntity()
					}));
					return e.set("characterList", t)
				};
			var R = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				M = n("./src/reddit/components/RichTextEditor/constants/draftEditorCommands.ts"),
				D = n("./node_modules/lodash/escape.js"),
				L = n.n(D),
				A = n("./src/reddit/components/RichTextEditor/media/helpers.ts"),
				F = n("./src/reddit/components/RichTextEditor/helpers/common.ts"),
				B = n("./src/reddit/components/RichTextEditor/entity/entityTypes.ts"),
				U = n("./node_modules/immutable/dist/immutable.js"),
				K = n("./src/reddit/helpers/dom/index.ts"),
				W = n("./node_modules/lodash/chunk.js"),
				G = n.n(W),
				H = n("./node_modules/lodash/flatten.js"),
				V = n.n(H),
				z = n("./node_modules/lodash/takeWhile.js"),
				q = n.n(z),
				Q = n("./src/reddit/components/RichTextEditor/helpers/modifiers.ts"),
				Y = n("./src/reddit/components/RichTextEditor/table/helpers.ts"),
				J = n("./node_modules/lodash/last.js"),
				X = n.n(J),
				Z = n("./src/reddit/components/RichTextEditor/constants/editorChangeTypes.ts"),
				$ = n("./src/reddit/components/RichTextEditor/helpers/forEachBlock.ts"),
				ee = n("./node_modules/lodash/find.js"),
				te = n.n(ee);
			var ne = (e, t) => {
				const n = e.getSelection(),
					r = e.getCurrentContent(),
					s = r.getBlockForKey(n.getAnchorKey()),
					i = r.getBlockForKey(n.getFocusKey()),
					[a, c] = Object(Y.e)(r, s, i);
				if (!a || a !== c) return e;
				const d = Object(Y.g)(s),
					l = Object(Y.g)(i),
					{
						blocks: u,
						start: m
					} = a,
					{
						colCount: p
					} = l,
					h = u.length / p,
					{
						minCol: b,
						minRow: f,
						maxCol: g,
						maxRow: v
					} = Object(Y.f)(d, l),
					C = u.filter(e => {
						const {
							rowIndex: n,
							colIndex: o
						} = Object(Y.g)(e);
						return "rows" === t ? !(f <= n && n <= v) : !(b <= o && o <= g)
					});
				C.sort(Y.b);
				const y = "rows" === t ? p : C.length / h,
					E = V()(Object(Y.d)(G()(C, y))),
					x = r.getBlocksAsArray(),
					O = [...x.slice(0, m), ...E, ...x.slice(m + u.length)],
					_ = r.merge({
						blockMap: o.BlockMapBuilder.createFromArray(O)
					}),
					k = {
						colIndex: b,
						rowIndex: f
					};
				let j = te()(E, e => Object(Y.h)(k, Object(Y.g)(e)));
				j || (j = E.length ? E[E.length - 1] : x[m > 0 ? m - 1 : 0]);
				const S = o.SelectionState.createEmpty(j.getKey()).merge({
					focusOffset: j.getLength(),
					anchorOffset: j.getLength()
				});
				let T = o.EditorState.push(e, _, Z.e);
				return T = o.EditorState.forceSelection(T, S)
			};
			var oe = function(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
				const n = e.getSelection();
				if (n.isCollapsed()) return;
				if (n.getStartKey() === n.getEndKey() && !t) return;
				const r = e.getCurrentContent(),
					s = r.getBlockForKey(n.getAnchorKey()),
					i = r.getBlockForKey(n.getFocusKey()),
					[a, c] = Object(Y.e)(r, s, i);
				if (!a || a !== c) return;
				const d = {};
				let l = n;
				if (s === i) {
					const e = Object(Y.n)(i, 0, n.getStartOffset()),
						t = Object(Y.n)(i, n.getEndOffset());
					d[i.getKey()] = Object(Y.j)(i, [e, t]), l = n
				} else {
					if (a.blocks[0].getKey() === n.getStartKey() && X()(a.blocks).getKey() === n.getEndKey()) return ne(e, "rows");
					Object($.a)(r, n, (e, t) => {
						d[t] = Object(Y.n)(e, 0, 0)
					}), l = n.merge({
						anchorOffset: 0,
						focusOffset: 0
					})
				}
				const u = r.merge({
					blockMap: r.getBlockMap().merge(d),
					selectionAfter: l
				});
				return o.EditorState.push(e, u, Z.f)
			};
			const re = (e, t, n, o) => {
					const {
						htmlParts: r
					} = t;
					e.forEach((e, s) => {
						r.push(`<${n} ${o[s]} style="margin: 0px; padding: 4px 9px; border: 1px solid rgb(229, 227, 218);">`), Ee(e, t), r.push(`</${n}>`)
					})
				},
				se = e => {
					const t = e[0],
						n = e[e.length - 1],
						o = [...e].sort(Y.b),
						{
							minCol: r,
							maxCol: s
						} = Object(Y.f)(Object(Y.g)(t), Object(Y.g)(n)),
						i = s - r + 1;
					return Object(Y.d)(G()(o, i))
				},
				ie = (e, t, n) => {
					n ? Ee(e[0], t) : ((e, t) => {
						const {
							editor: n,
							htmlParts: o
						} = t, r = n.getEditorKey(), s = e[0].map(e => {
							const {
								alignment: t
							} = Object(Y.g)(e);
							return t ? `align="${Y.a[t]}"` : ""
						}), [i, ...a] = e;
						o.push(`\n    <table data-editor="${r}">\n      <thead>\n        <tr>`), re(i, t, "th", s), o.push("\n        </tr>\n      </thead>\n      <tbody>"), a.forEach(e => {
							o.push("\n        <tr>"), re(e, t, "td", s), o.push("\n        </tr>")
						}), o.push("\n      </tbody>\n    </table>")
					})(se(e), t)
				},
				ae = (e, t, n) => {
					n ? t.textParts.push(_e(e[0], t)) : ((e, t) => {
						const {
							textParts: n
						} = t;
						e.forEach(e => {
							n.push(e.map(e => _e(e, t)).join(" "))
						})
					})(se(e), t)
				},
				ce = e => {
					const {
						processed: t,
						remaining: n
					} = e, o = [];
					for (; n.length;) {
						const e = n[0];
						if (!Object(w.v)(e.getType())) break;
						o.push(n.shift())
					}
					const r = !n.length && !t.length,
						s = 1 === o.length && r;
					ie(o, e, s), ae(o, e, s), ((e, t, n, o) => {
						if (n)
							if (o) {
								const n = e[0].merge({
									data: Object(U.Map)(),
									type: w.n
								});
								t.blocksParts = [n]
							} else t.blocksParts = V()(se(e))
					})(o, e, r, s), t.push(...o)
				},
				de = e => oe(e, !0),
				le = (e, t, n) => {
					const r = Object(w.v)(n.first().getType()),
						s = Object(w.v)(n.last().getType()),
						i = e.getBlockForKey(t.getAnchorKey()),
						a = e.getBlockForKey(t.getFocusKey()),
						[c, d] = Object(Y.e)(e, i, a);
					return c && c === d ? ((e, t, n, r) => {
						const s = Object(w.v)(r.first().getType()),
							i = e.getBlockForKey(t.getAnchorKey()),
							a = e.getBlockForKey(t.getFocusKey()),
							{
								blocks: c,
								start: d
							} = n;
						c.sort(Y.b);
						const l = Object(Y.g)(c[0]);
						let {
							colCount: u
						} = l;
						const m = G()(c, u);
						let p = m.length;
						const {
							minRow: h,
							minCol: b
						} = Object(Y.f)(Object(Y.g)(i), Object(Y.g)(a)), f = r.toArray();
						if (s) {
							const n = q()(f, e => Object(w.v)(e.getType()));
							n.sort(Y.b);
							const r = Object(Y.g)(n[0]).colCount,
								s = G()(n, r),
								i = s.length,
								a = h + i - 1,
								l = b + r - 1;
							if (n.length !== i * r) throw new Error("Invalid table fragment!");
							if (l >= u && m.forEach(e => {
									e.push(...Object(Y.l)(l - u + 1, 1))
								}), u = m[0].length, a >= p) {
								const e = G()(Object(Y.l)(u, a - p + 1), u);
								m.push(...e)
							}
							p = m.length;
							for (let e = 0; e < i; e++)
								for (let t = 0; t < r; t++) {
									const n = h + e,
										o = b + t,
										r = s[e][t];
									m[n][o] = r.set("key", m[n][o].getKey())
								}
							const g = Object(Y.d)(m),
								v = V()(g),
								C = e.getBlocksAsArray(),
								y = [...C.slice(0, d), ...v, ...C.slice(d + c.length)],
								E = Object(Y.o)(t, m[h][b], m[a][l]);
							return e.merge({
								blockMap: o.BlockMapBuilder.createFromArray(y),
								selectionAfter: E
							})
						} {
							const n = m[h][b],
								r = Object(Y.j)(n, f, " ");
							let s = t;
							return t.getStartKey() !== t.getEndKey() && (s = Object(Y.o)(t, n, n)), Q.c(e, s, o.BlockMapBuilder.createFromArray([r]))
						}
					})(e, t, c, n) : c || d || !r && !s ? void 0 : ((e, t, n) => {
						const r = Object(w.v)(n.first().getType()),
							s = Object(w.v)(n.last().getType()),
							i = n.toArray();
						r && i.unshift(Object(F.h)()), s && i.push(Object(F.h)());
						const a = o.BlockMapBuilder.createFromArray(i);
						return Q.c(e, t, a)
					})(e, t, n)
				};
			var ue = n("./node_modules/draft-js/lib/removeEntitiesAtEdges.js"),
				me = n.n(ue);
			var pe = (e, t) => {
				const n = t.getStartKey(),
					o = t.getStartOffset(),
					r = t.getEndKey(),
					s = t.getEndOffset(),
					i = me()(e, t).getBlockMap(),
					a = i.keySeq(),
					c = a.indexOf(n),
					d = a.indexOf(r) + 1;
				return i.slice(c, d).map((e, t) => {
					const i = e.getText(),
						a = e.getCharacterList();
					return n === r ? e.merge({
						text: i.slice(o, s),
						characterList: a.slice(o, s)
					}) : t === n ? e.merge({
						text: i.slice(o),
						characterList: a.slice(o)
					}) : t === r ? e.merge({
						text: i.slice(0, s),
						characterList: a.slice(0, s)
					}) : e
				})
			};
			const he = (e, t) => {
					const n = {
							children: [],
							parentItem: t,
							type: e.getType()
						},
						o = {
							block: e,
							parentList: n
						};
					return n.children.push(o), t && (t.childrenLists = t.childrenLists || [], t.childrenLists.push(n)), {
						list: n,
						item: o
					}
				},
				be = (e, t) => {
					const {
						type: n,
						children: o
					} = e, {
						htmlParts: r
					} = t, s = n === w.b.ORDERED_LIST ? "ol" : "ul";
					r.push(`<${s}>`), o.forEach(e => ((e, t) => {
						const {
							block: n,
							childrenLists: o
						} = e, {
							htmlParts: r
						} = t;
						r.push("<li>"), Ee(n, t, !0), o && o.forEach(e => be(e, t)), r.push("</li>")
					})(e, t)), r.push(`</${s}>`)
				},
				fe = (e, t) => {
					const {
						children: n
					} = e;
					n.forEach((e, n) => ge(e, n, t))
				},
				ge = (e, t, n) => {
					const {
						block: o,
						childrenLists: r
					} = e, {
						textParts: s
					} = n, i = " ".repeat(o.getDepth()), a = o.getType() === w.b.ORDERED_LIST ? `${t+1}.` : "-", c = _e(o, n);
					s.push(`${i}${a} ${c}`), r && r.forEach(e => fe(e, n))
				},
				ve = e => {
					const {
						remaining: t
					} = e, n = t.shift(), o = n.getType(), r = [n];
					for (; t.length;) {
						const e = t[0],
							n = e.getType();
						if (!Object(w.s)(n)) break;
						if (e.getDepth() > 0 || n === w.b.UNORDERED_LIST) r.push(t.shift());
						else {
							if (n !== o) break;
							if (r.some(e => e.getType() !== w.b.ORDERED_LIST)) break;
							r.push(t.shift())
						}
					}
					const s = (e => {
						const t = e[0],
							n = {
								type: t.getType(),
								children: []
							};
						let o, r = n,
							s = t.getDepth();
						return e.forEach(e => {
							const t = e.getType(),
								n = e.getDepth();
							if (n > s) {
								const t = he(e, o);
								r = t.list, o = t.item, s = n
							} else {
								for (; s !== n;) r = r.parentItem ? r.parentItem.parentList : r, s--;
								if (t === r.type) o = {
									block: e,
									parentList: r
								}, r.children.push(o);
								else {
									const t = he(e, r.parentItem);
									r = t.list, o = t.item
								}
							}
						}), n
					})(r);
					be(s, e), fe(s, e), e.processed.push(...r)
				};
			var Ce = (e, t) => {
				const n = e.toArray().filter(e => !Object(w.t)(e.getType()));
				if (1 === n.length) {
					n[0].getType() !== w.n && n.push(new o.ContentBlock({
						key: Object(o.genKey)(),
						type: w.n
					}))
				}
				const r = o.ContentState.createFromBlockArray(n),
					s = JSON.stringify(Object(o.convertToRaw)(r));
				return `<div data-reddit-rtjson="${L()(s)}">${t}</div>`
			};
			const ye = () => !!window.clipboardData,
				Ee = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					const {
						htmlParts: o
					} = t, r = xe(e, t);
					r && r.forEach(e => o.push(n ? e.innerHTML : e.outerHTML))
				},
				xe = (e, t) => {
					const {
						selection: n,
						editor: o
					} = t, r = n.getStartKey(), s = n.getEndKey(), i = e.getKey(), a = o.refs.editor, c = Object(F.d)(i, a);
					return c ? i === r || i === s ? Object(K.c)(c) : [c] : null
				};
			var Oe = (e, t, n) => {
				const r = e.getCurrentContent(),
					s = e.getSelection(),
					i = Ie(e) || pe(r, s);
				if (!i || !i.count()) return;
				const a = i.toArray(),
					c = {
						editor: t,
						editorState: e,
						selection: s,
						remaining: a,
						processed: [],
						htmlParts: [],
						textParts: [],
						blocksParts: [...a]
					};
				for (; c.remaining.length;) {
					const e = c.remaining[0].getType();
					switch (!0) {
						case Object(w.t)(e):
							we(c);
							break;
						case Object(w.s)(e):
							ve(c);
							break;
						case Object(w.v)(e):
							ce(c);
							break;
						default:
							ke(c)
					}
				}
				const d = c.textParts.join("\n"),
					l = (e => Object(U.OrderedMap)(e.map(e => {
						const t = Object(o.genKey)();
						return [t, e.set("key", t)]
					})))(c.blocksParts);
				return ((e, t) => {
					let {
						html: n,
						text: o
					} = t;
					ye() ? window.clipboardData.setData("text", o) : (n && e.clipboardData.setData("text/html", n), e.clipboardData.setData("text/plain", o))
				})(n, {
					html: Ce(l, c.htmlParts.join("")),
					text: d
				}), n.stopPropagation(), n.preventDefault(), t.setClipboard(l), l
			};
			const _e = (e, t) => {
					const n = e.getText(),
						o = t.editorState.getCurrentContent(),
						r = [];
					let s = -1;
					return e.getCharacterList().forEach((e, t) => {
						const i = e && e.getEntity();
						if (i && void 0 !== t) {
							const e = o.getEntity(i);
							e.getType() === B.a.EMOTE && (r.push(n.substring(s + 1, t)), r.push(`:${e.getData().id}:`), s = t)
						}
					}), r.push(n.substring(s + 1, n.length)), r.join("")
				},
				ke = e => {
					const t = e.remaining.shift();
					((e, t) => Ee(e, t))(t, e), ((e, t) => {
						t.textParts.push(_e(e, t))
					})(t, e), e.processed.push(t)
				},
				je = (e, t) => {
					const n = e.first(),
						r = e.last();
					let s = e;
					if (Object(w.u)(n.getType()) ? s = s.set(s.keySeq().first(), n.merge({
							type: w.n
						})) : Object(w.o)(n.getType()) && (s = o.BlockMapBuilder.createFromArray([Object(F.h)(), ...s.toArray()])), Object(w.u)(r.getType()) || !Object(A.q)(t)) {
						const e = Object(F.h)();
						s = s.set(e.getKey(), e)
					} else if (Object(w.o)(r.getType())) {
						const e = Object(F.h)().merge({
							type: w.j
						});
						s = s.set(e.getKey(), e)
					}
					return s
				},
				Se = (e, t, n) => {
					const o = e.getBlockForKey(t.getStartKey());
					if (Object(w.u)(o.getType())) {
						const o = n.first(),
							r = n.set(n.keySeq().first(), Object(F.h)(o.getKey(), o.getText()).merge({
								type: w.j
							}));
						return Q.c(e, t, r)
					}
				},
				Te = (e, t, n) => {
					const o = ((e, t, n) => {
						const o = t ? t.getText() : "";
						return `<span data-editor="${n}">${L()(o)}</span>`
					})(0, t, n.editor.getEditorKey());
					n.htmlParts.push(o)
				},
				we = e => {
					const {
						remaining: t
					} = e, n = t.shift(), o = t[0] && Object(w.u)(t[0].getType()) ? t.shift() : void 0;
					Te(0, o, e), ((e, t) => {
						const n = e ? _e(e, t) : "";
						t.textParts.push(n)
					})(o, e), e.processed.push(n), o && e.processed.push(o)
				},
				Ie = e => {
					const t = e.getSelection(),
						n = t.getFocusKey();
					if (n !== t.getAnchorKey()) return;
					const r = e.getCurrentContent(),
						s = r.getBlockForKey(n);
					if (Object(w.o)(s.getType())) {
						const e = [s],
							t = r.getBlockAfter(s.getKey());
						return t && Object(w.u)(t.getType()) && e.push(t), o.ContentState.createFromBlockArray(e).getBlockMap()
					}
				},
				Pe = e => {
					const t = Ie(e);
					if (t) return Object(A.d)(e, t.first().getKey())
				},
				Ne = e => {
					const t = e.getSelection();
					let n = e.getCurrentContent();
					const r = n.getBlockForKey(t.getStartKey()),
						s = n.getBlockForKey(t.getEndKey());
					if (Object(w.t)(r.getType()) || Object(w.t)(s.getType())) {
						if (t.isCollapsed())
							if (Object(w.u)(r.getType())) n = Q.d(n, t), n = o.Modifier.setBlockType(n, n.getSelectionAfter(), w.n);
							else if (Object(w.o)(r.getType())) {
							let r = n.getBlockAfter(t.getStartKey());
							return r || (r = (e = Object(A.b)(e, t.getStartKey(), F.a.after)).getCurrentContent().getBlockAfter(t.getStartKey())), o.EditorState.forceSelection(e, Object(F.b)(r, !0))
						}
						return o.EditorState.push(e, n, "split-block")
					}
				},
				Re = (e, t) => {
					const n = e.getSelection(),
						r = e.getCurrentContent(),
						s = "up" === t ? n.getStartKey() : n.getEndKey(),
						i = r.getBlockForKey(s);
					if (!Object(w.o)(i.getType())) return;
					const a = "up" === t ? r.getBlockBefore(s) : r.getBlockAfter(s);
					return a ? o.EditorState.forceSelection(e, Object(F.b)(a, !0)) : Object(A.b)(e, s, "up" === t ? F.a.before : F.a.after)
				},
				Me = (e, t) => {
					if (e.shiftKey) return;
					const n = Re(t, "up");
					return n && e.preventDefault(), n
				},
				De = (e, t) => {
					if (e.shiftKey) return;
					const n = Re(t, "down");
					return n && e.preventDefault(), n
				},
				Le = (e, t) => {
					const n = e.getSelection();
					return n.isCollapsed() && 0 === n.getStartOffset() && Object(w.o)(e.getCurrentContent().getBlockForKey(n.getStartKey()).getType())
				};
			var Ae = (e, t) => {
					if (!Object(A.q)(t)) return e;
					const n = e.getSelection(),
						o = e.getCurrentContent(),
						r = o.getBlockForKey(n.getStartKey());
					if (Object(w.o)(r.getType())) {
						const t = o.getBlockAfter(r.getKey());
						if (!t || !Object(w.u)(t.getType())) return Object(A.d)(e, r.getKey(), !1)
					}
					return e
				},
				Fe = n("./src/reddit/actions/modal.ts"),
				Be = n("./src/reddit/actions/upload.ts"),
				Ue = n("./src/reddit/components/ThumbnailSelector/index.tsx"),
				Ke = e => null,
				We = n("./src/reddit/helpers/media/index.ts"),
				Ge = n("./src/reddit/helpers/richTextEditor/index.ts"),
				He = n("./src/reddit/selectors/activeModalId.ts");
			const Ve = "application/x-reddit-rte-block";
			var ze = n("./src/reddit/models/Upload/index.ts"),
				qe = n("./src/reddit/selectors/experiments/d2xShredditPlayer.ts"),
				Qe = n("./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/ImagePreview/index.m.less"),
				Ye = n.n(Qe);
			const Je = C.a.img("Img", Ye.a);
			var Xe = C.a.wrapped(e => {
					const {
						className: t,
						url: n
					} = e;
					return m.a.createElement("div", {
						className: t
					}, m.a.createElement(Je, {
						draggable: !1,
						src: n
					}))
				}, "Component", Ye.a),
				Ze = n("./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/Placeholder/index.m.less"),
				$e = n.n(Ze);
			const et = C.a.div("Message", $e.a);
			var tt = C.a.wrapped(e => {
					const {
						className: t,
						isImage: n
					} = e;
					return m.a.createElement("div", {
						className: t
					}, m.a.createElement(et, null, n ? r.fbt._("Processing video...", null, {
						hk: "3g3QoU"
					}) : r.fbt._("Processing image...", null, {
						hk: "1xoNB3"
					})))
				}, "Component", $e.a),
				nt = n("./src/lib/formatApiError/index.ts"),
				ot = n("./src/reddit/components/ProgressBar/index.tsx"),
				rt = n("./src/reddit/controls/Button/index.tsx"),
				st = n("./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/StatusBar/index.m.less"),
				it = n.n(st);
			const at = C.a.div("ControlRow", it.a),
				ct = C.a.wrapped(rt.t, "Button", it.a),
				dt = C.a.wrapped(rt.t, "ErrButton", it.a),
				lt = C.a.div("Status", it.a),
				ut = C.a.wrapped(ot.a, "ProgressBar", it.a),
				mt = C.a.div("ErrorLine", it.a),
				pt = e => t => {
					t.stopPropagation(), e(t)
				};
			var ht = C.a.wrapped(e => {
					const {
						upload: t
					} = e, n = pt(e.onCancel), o = pt(e.onRetry), s = pt(e.onRemove), {
						status: i,
						progress: a
					} = t, c = a && a.percent || 0, d = i === ze.a.FAILED || i === ze.a.CANCELED, l = (e => {
						const {
							status: t,
							progress: n
						} = e;
						return t === ze.a.CANCELED ? r.fbt._("Upload was canceled", null, {
							hk: "71azQ"
						}) : t === ze.a.FAILED ? r.fbt._("Upload failed: {errorText}", [r.fbt._param("errorText", Object(nt.a)(e.error))], {
							hk: "3NGGzE"
						}) : 100 === (n && n.percent || 0) ? r.fbt._("Success!", null, {
							hk: "3622uh"
						}) : r.fbt._("Uploading: {fileName}", [r.fbt._param("fileName", e.file.name)], {
							hk: "H7qzO"
						})
					})(t);
					return m.a.createElement("div", {
						className: e.className
					}, d ? m.a.createElement(mt, null) : m.a.createElement(ut, {
						innerBarClassName: it.a.ProgressBarInner,
						percent: c
					}), m.a.createElement(at, null, m.a.createElement(lt, {
						className: d ? it.a.hasError : void 0,
						title: d ? l : void 0
					}, l), m.a.createElement("div", {
						className: it.a.ButtonsContainer
					}, d ? [m.a.createElement(dt, {
						kind: rt.b.Button,
						priority: rt.c.Plain,
						key: "remove",
						onClick: s
					}, r.fbt._("Remove", null, {
						hk: "3tYl0U"
					})), m.a.createElement(dt, {
						kind: rt.b.Button,
						priority: rt.c.Plain,
						key: "retry",
						onClick: o
					}, r.fbt._("Retry", null, {
						hk: "3sO2HB"
					}))] : m.a.createElement(ct, {
						kind: rt.b.Button,
						priority: rt.c.Plain,
						disabled: 100 === c,
						onClick: n
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})))))
				}, "Component", it.a),
				bt = n("./node_modules/react-motion/lib/react-motion.js"),
				ft = n("./src/reddit/components/HTML5StreamPlayer/index.tsx"),
				gt = n("./src/reddit/components/Media/ShredditPlayerWrapper/index.tsx"),
				vt = n("./src/reddit/components/PlayButton/index.tsx"),
				Ct = n("./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/VideoPreview/index.m.less"),
				yt = n.n(Ct);
			const Et = {
					stiffness: 60,
					damping: 20
				},
				xt = [{
					key: "video",
					style: {
						opacity: Object(bt.spring)(1, Et)
					}
				}],
				Ot = C.a.wrapped(e => {
					const {
						autoPlay: t = !1,
						className: n,
						showControls: o,
						shouldPause: r,
						style: s,
						dashUrl: i,
						hlsUrl: a,
						isShredditPlayerRemainingFeedsEnabled: c,
						otherUrl: d,
						posterUrl: l
					} = e;
					return c ? m.a.createElement("div", {
						className: n,
						style: s
					}, m.a.createElement(gt.a, {
						isGif: !1,
						isListing: !1,
						posterUrl: l,
						preventAutoplay: !0,
						shouldUseInitializationOptimization: !0,
						source: a || d
					})) : m.a.createElement("div", {
						className: n,
						style: s
					}, m.a.createElement(ft.b, {
						autoPlay: t,
						shouldIgnoreAutoplayPref: !0,
						shouldLoad: !1,
						shouldPause: r,
						isGif: !1,
						hlsSource: a,
						mpegDashSource: i,
						otherSource: d,
						showSettingsIcon: !1,
						showControlBar: o,
						playerClickPlay: !1,
						hideUntilLoaded: !0
					}))
				}, "VideoPlayer", yt.a),
				_t = C.a.img("PosterImg", yt.a),
				kt = C.a.wrapped(e => {
					const {
						className: t,
						onPlayButtonClick: n,
						url: o,
						showPlayButton: r
					} = e;
					return m.a.createElement("div", {
						className: t
					}, m.a.createElement(_t, {
						draggable: !1,
						src: o
					}), r && m.a.createElement(vt.a, {
						className: yt.a.playButton,
						onClick: n
					}))
				}, "Poster", yt.a);
			class jt extends m.a.Component {
				constructor(e) {
					super(e), this.onPlayButtonClick = () => {
						this.setState({
							showVideo: !0
						})
					}, this.willEnter = () => ({
						opacity: 0
					}), this.willLeave = () => ({
						opacity: Object(bt.spring)(0, Et)
					}), this.didLeave = () => {
						this.setState({
							showVideo: !1
						})
					}, this.state = {
						showVideo: !1
					}
				}
				renderVideo() {
					const {
						props: e
					} = this;
					return m.a.createElement("div", {
						className: e.className
					}, m.a.createElement(Ot, {
						dashUrl: e.dashUrl,
						hlsUrl: e.hlsUrl,
						isShredditPlayerRemainingFeedsEnabled: e.isShredditPlayerRemainingFeedsEnabled,
						otherUrl: e.otherUrl,
						posterUrl: e.posterUrl,
						showControls: e.isUploaded && e.isSelected,
						shouldPause: !e.isSelected || void 0
					}))
				}
				render() {
					const {
						className: e,
						isSelected: t,
						posterUrl: n,
						dashUrl: o,
						hlsUrl: r,
						otherUrl: s,
						isShredditPlayerRemainingFeedsEnabled: i
					} = this.props;
					if (!n || i) return this.renderVideo();
					const {
						showVideo: a
					} = this.state, c = !!(o || r || s);
					return m.a.createElement(bt.TransitionMotion, {
						defaultStyles: [],
						styles: t && a && c ? xt : [],
						willEnter: this.willEnter,
						willLeave: this.willLeave,
						didLeave: this.didLeave
					}, i => m.a.createElement("div", {
						className: e
					}, i.map(e => m.a.createElement(Ot, {
						key: e.key,
						autoPlay: !0,
						style: e.style,
						otherUrl: s,
						dashUrl: o,
						hlsUrl: r,
						posterUrl: n,
						showControls: !0,
						shouldPause: !t || void 0
					})), m.a.createElement(kt, {
						url: n,
						showPlayButton: !a || !t,
						onPlayButtonClick: this.onPlayButtonClick
					})))
				}
			}
			var St = C.a.wrapped(jt, "Component", yt.a),
				Tt = n("./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/index.m.less"),
				wt = n.n(Tt);

			function It() {
				return (It = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			var Pt = e => {
					const {
						alignCenter: t,
						isSelected: n,
						onCancel: o,
						onRetry: r,
						onRemove: s,
						upload: i,
						mediaAsset: a,
						thumbnail: c,
						renderSmallMedia: d,
						...l
					} = e, u = Object(p.e)(qe.c);
					let h = !1;
					if (i) h = "image" === Object(We.g)(i.metadata.mimetype);
					else {
						if (!a) return null;
						h = a.type === A.a.Image || a.type === A.a.AnimatedImage
					}
					const b = i ? i.metadata.height : a.height,
						f = !i || i.status === ze.a.SUCCESS,
						v = h && !!b && b < 104,
						C = !b;
					return m.a.createElement("div", It({
						className: Object(g.a)(wt.a.container, {
							[wt.a.alignCenter]: t,
							[wt.a.isCompact]: v,
							[wt.a.isUploaded]: f,
							[wt.a.isSelected]: n
						})
					}, l), C ? m.a.createElement(tt, {
						className: wt.a.placeholder,
						isImage: h
					}) : h ? m.a.createElement(Xe, {
						className: Object(g.a)(wt.a.imagePreview, {
							[wt.a.renderSmallMedia]: d
						}),
						url: i ? i.metadata.localUrl : a.imageUrl
					}) : m.a.createElement(St, {
						className: wt.a.videoPreview,
						dashUrl: a ? a.dashUrl : void 0,
						hlsUrl: a ? a.hlsUrl : void 0,
						isSelected: n,
						isUploaded: f,
						otherUrl: i ? i.metadata.localUrl : void 0,
						posterUrl: c ? c.url : a.posterUrl,
						isShredditPlayerRemainingFeedsEnabled: u
					}), i && m.a.createElement(ht, {
						className: wt.a.statusBar,
						onCancel: o,
						onRemove: s,
						onRetry: r,
						upload: i
					}))
				},
				Nt = n("./src/reddit/components/RichTextEditor/media/MediaBlock/SelectionHook/index.m.less"),
				Rt = n.n(Nt);

			function Mt() {
				return (Mt = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const Dt = C.a.div("HiddenDiv", Rt.a);
			var Lt = e => {
					let {
						elementRef: t,
						...n
					} = e;
					return m.a.createElement(Dt, Mt({}, n, {
						innerRef: t
					}), m.a.createElement("br", null))
				},
				At = n("./src/reddit/components/MakeGifToggle/index.tsx"),
				Ft = n("./src/reddit/icons/svgs/ThumbnailSelect/index.tsx"),
				Bt = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				Ut = n("./src/reddit/layout/row/Inline/index.tsx"),
				Kt = n("./src/reddit/components/RichTextEditor/Toolbar/index.tsx"),
				Wt = n("./src/reddit/components/RichTextEditor/Toolbar/FormatterButton/index.tsx"),
				Gt = n("./src/reddit/components/RichTextEditor/Toolbar/formatterConfigs.tsx"),
				Ht = n("./src/reddit/components/RichTextEditor/media/MediaBlock/Toolbar/index.m.less"),
				Vt = n.n(Ht);
			const zt = C.a.wrapped(Wt.a, "FormatterButton", Vt.a),
				qt = Object(Gt.f)(Bt.b),
				Qt = Object(Gt.f)(Ft.a),
				Yt = C.a.wrapped(Ut.a, "ToolbarContent", Vt.a);
			var Jt = e => {
					const {
						alignCenter: t,
						block: n,
						editorState: o,
						onChange: s,
						showVideoControls: i
					} = e, a = n.getKey(), {
						makeGif: c = !1
					} = Object(A.h)(n) || {};
					return m.a.createElement("div", {
						className: Object(g.a)(Vt.a.container, {
							[Vt.a.alignCenter]: t
						})
					}, m.a.createElement(Yt, {
						className: Object(g.a)(Vt.a.content, {
							[Vt.a.multiButtonToolbarContent]: i
						})
					}, i && m.a.createElement(At.a, {
						isCompact: !0,
						key: "make-gif",
						on: c,
						onClick: () => s(Object(A.r)(o, a, {
							makeGif: !c
						}))
					}), i && e.showThumbnailButton && m.a.createElement(zt, {
						Icon: Qt,
						onClick: e.onThumbnailButtonClick,
						tooltip: r.fbt._("Choose thumbnail", null, {
							hk: "2gKwDF"
						}),
						tooltipBelow: !0
					}), i && m.a.createElement(Kt.c, null), m.a.createElement(zt, {
						Icon: qt,
						onClick: () => s(Object(A.d)(o, a)),
						tooltip: r.fbt._("Remove", null, {
							hk: "3tYl0U"
						}),
						tooltipBelow: !0
					})))
				},
				Xt = n("./src/reddit/components/RichTextEditor/media/MediaBlock/index.m.less"),
				Zt = n.n(Xt);
			const $t = e => `RTE_VIDEO_THUMBNAIL_SELECTOR_${e.getKey()}`,
				en = Object(h.a)(e => e.uploads, (e, t) => {
					const n = Object(A.h)(t.block);
					return n && n.uploadInfo && n.uploadInfo.uploadKey
				}, (e, t) => t ? e[t] : void 0),
				tn = Object(p.b)((e, t) => ({
					upload: en(e, t),
					isThumbnailSelectorOpen: Object(He.a)(e) === $t(t.block),
					isRteVideoPosterEnabled: j.d.rteVideoPoster(e)
				}), (e, t) => ({
					onCancelUpload: t => e(Be.i(t, !1)),
					toggleVideoThumbnailsSelector: () => e(Object(Fe.i)($t(t.block)))
				})),
				nn = C.a.div("MediaContainer", Zt.a),
				on = C.a.div("Container", Zt.a);
			class rn extends m.a.Component {
				constructor(e) {
					super(e), this.onNativeSelectionChange = () => {
						const e = window.getSelection();
						if (0 === e.rangeCount) return;
						const t = e.getRangeAt(0),
							{
								commonAncestorContainer: n
							} = t;
						this.state.active ? this.rootContainer.contains(n) || this.setState({
							active: !1
						}) : this.rootContainer && this.rootContainer.contains(n) && this.selectBlock(), this.setState({
							isInSelection: Object(K.g)(t, this.rootContainer)
						})
					}, this.selectBlock = () => {
						const e = document.createRange();
						e.selectNodeContents(this.rootContainer);
						const t = window.getSelection();
						t.removeAllRanges(), t.addRange(e), this.setState({
							active: !0
						})
					}, this.isSelected = () => {
						const e = this.props.blockProps.getEditorState().getSelection(),
							t = this.props.block.getKey();
						return this.state.active && Object(A.n)(e, t)
					}, this.onRetryUpload = () => {
						const {
							upload: e
						} = this.props;
						e && this.props.blockProps.onRetryUpload(e.key)
					}, this.onMediaViewClickCapture = e => {
						this.state.active || this.selectBlock()
					}, this.onDragStart = e => {
						e.dataTransfer.effectAllowed = "move", e.dataTransfer.setData(Ve, this.props.block.getKey())
					}, this.onRemove = () => {
						const e = this.props.blockProps.getEditorState();
						this.props.blockProps.onChange(Object(A.d)(e, this.props.block.getKey()))
					}, this.onCancelUpload = async () => {
						this.props.upload && (await this.props.onCancelUpload(this.props.upload.key), this.selectBlock())
					}, this.onToolbarStateChange = e => {
						this.props.blockProps.onChange(e)
					}, this.toggleVideoThumbnailsSelector = () => {
						this.props.toggleVideoThumbnailsSelector()
					}, this.onThumbnailSelect = e => {
						const t = this.props.blockProps.getEditorState(),
							n = this.props.block.getKey();
						let o = Object(A.r)(t, this.props.block.getKey(), {
							thumbnail: e
						});
						o = Object(A.p)(o, n), this.props.blockProps.onChange(o), this.toggleVideoThumbnailsSelector()
					}, this.state = {
						active: !1,
						isInSelection: !1
					}
				}
				shouldComponentUpdate(e, t) {
					return t.active !== this.state.active || t.isInSelection !== this.state.isInSelection || e.block !== this.props.block || e.upload !== this.props.upload || Object(A.n)(e.selection, e.block.getKey())
				}
				componentDidMount() {
					document.addEventListener("selectionchange", this.onNativeSelectionChange);
					const {
						selection: e
					} = this.props;
					e.getHasFocus() && Object(A.n)(e, this.props.block.getKey()) && this.selectBlock(), this.overlayContainer = Ke(!0)
				}
				componentWillUnmount() {
					document.removeEventListener("selectionchange", this.onNativeSelectionChange)
				}
				componentWillReceiveProps(e) {
					const t = e.block.getKey(),
						n = this.props.blockProps.getEditorState(),
						o = n;
					n !== o && this.props.blockProps.onChange(o), !this.state.active && e.selection !== this.props.selection && e.selection.getHasFocus() && Object(A.n)(e.selection, t) && this.selectBlock()
				}
				getToolbarOffset() {
					if (!this.props.blockProps.rteFocusableContentRef || !this.rootContainer) return 0;
					const {
						top: e
					} = this.rootContainer.getBoundingClientRect(), {
						top: t
					} = this.props.blockProps.rteFocusableContentRef.getBoundingClientRect();
					return e - t - 30 - 10
				}
				render() {
					const {
						block: e,
						blockProps: t,
						isRteVideoPosterEnabled: n,
						offsetKey: o,
						upload: r
					} = this.props, s = Object(A.h)(e), i = s ? s.thumbnail : void 0, a = !!r && Object(We.n)(r.metadata.mimetype || ""), {
						active: c,
						isInSelection: d
					} = this.state, l = t.editorType === Ge.a.Comment;
					return m.a.createElement(on, {
						innerRef: e => this.rootContainer = e
					}, c && m.a.createElement(Jt, {
						block: e,
						editorState: t.getEditorState(),
						onChange: this.onToolbarStateChange,
						onThumbnailButtonClick: this.toggleVideoThumbnailsSelector,
						showThumbnailButton: n,
						showVideoControls: a,
						alignCenter: !l
					}), m.a.createElement(Lt, null), m.a.createElement("div", {
						contentEditable: !1,
						"data-offset-key": o
					}, m.a.createElement(nn, {
						draggable: !0,
						onDragStart: this.onDragStart,
						innerRef: e => this.mediaContainer = e
					}, m.a.createElement(Pt, {
						isSelected: d || c,
						thumbnail: i,
						onCancel: this.onCancelUpload,
						onClickCapture: this.onMediaViewClickCapture,
						onRetry: this.onRetryUpload,
						onRemove: this.onRemove,
						upload: r,
						mediaAsset: s.mediaAsset,
						alignCenter: !l,
						renderSmallMedia: l
					})), r && a && m.a.createElement(Ue.a, {
						onSelect: this.onThumbnailSelect,
						onToggleModal: this.toggleVideoThumbnailsSelector,
						videoSource: r.metadata.localUrl,
						videoDuration: r.metadata.videoDuration,
						selected: i,
						isOpen: this.props.isThumbnailSelectorOpen
					})), m.a.createElement(Lt, null))
				}
			}
			var sn = tn(rn),
				an = n("./src/reddit/components/RichTextEditor/media/MediaCaption/index.m.less"),
				cn = n.n(an);
			class dn extends m.a.PureComponent {
				constructor(e) {
					super(e);
					const {
						contentState: t,
						block: n
					} = Object(F.e)(e.children[0]).props;
					this.mediaBlockKey = t.getBlockBefore(n.getKey()).getKey()
				}
				render() {
					const e = this.props.children[0],
						t = Object(F.e)(e),
						{
							block: n,
							contentState: o
						} = t.props,
						s = o.getBlockForKey(this.mediaBlockKey),
						i = Object(A.h)(s);
					if (!i || !(i.mediaAsset || i.uploadInfo && i.uploadInfo.mediaType)) return null;
					const a = !n.getLength();
					return m.a.createElement("div", {
						className: cn.a.wrapper,
						style: {
							"--media-caption-placeholder-text": a ? `'${r.fbt._("Add caption",null,{hk:"3zI8El"})}'` : ""
						}
					}, e)
				}
			}
			const ln = Object(U.Map)({
				[w.j]: {
					element: "div",
					wrapper: m.a.createElement(dn, null)
				}
			});
			var un = (e, t, n) => {
					const r = e.getSelection(),
						s = e.getCurrentContent(),
						i = s.getBlockForKey(r.getAnchorKey()),
						a = s.getBlockForKey(r.getFocusKey()),
						[c, d] = Object(Y.e)(s, i, a);
					if (!c || c !== d) return e;
					const {
						blocks: l,
						start: u
					} = c, m = Object(Y.g)(i), p = Object(Y.g)(a), {
						colCount: h
					} = p;
					l.sort(Y.b);
					const b = G()(l, h),
						{
							minCol: f,
							minRow: g,
							maxCol: v,
							maxRow: C
						} = Object(Y.f)(m, p),
						y = {
							rowIndex: 0,
							colIndex: 0
						};
					if ("rows" === t) {
						const e = "before" === n ? g : C + 1,
							t = G()(Object(Y.l)(h, C - g + 1), h);
						b.splice(e, 0, ...t), y.rowIndex = e
					} else {
						const e = "before" === n ? f : v + 1;
						b.forEach(t => {
							t.splice(e, 0, ...Object(Y.l)(v - f + 1, 1))
						}), y.colIndex = e
					}
					const E = Object(Y.d)(b),
						x = s.getBlocksAsArray(),
						O = V()(E),
						_ = [...x.slice(0, u), ...O, ...x.slice(u + l.length)],
						k = s.merge({
							blockMap: o.BlockMapBuilder.createFromArray(_)
						}),
						j = te()(O, e => Object(Y.h)(y, Object(Y.g)(e))),
						S = Object(Y.o)(r, j, j);
					let T = o.EditorState.push(e, k, Z.e);
					return T = o.EditorState.forceSelection(T, S)
				},
				mn = n("./node_modules/lodash/clamp.js"),
				pn = n.n(mn),
				hn = n("./src/reddit/components/RichTextEditor/helpers/sliceContiguousBlocks.ts");
			var bn = function(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "preserve";
				const r = e.getSelection(),
					s = e.getCurrentContent(),
					i = "up" === t || "left" === t ? r.getStartKey() : r.getEndKey(),
					a = s.getBlockForKey(i);
				if (!Object(w.v)(a.getType())) return;
				const c = Object(Y.g)(a),
					{
						colCount: d,
						colIndex: l,
						rowIndex: u
					} = c,
					m = s.getBlocksAsArray(),
					p = Object(hn.a)(s, a);
				if (!p) return;
				let h = u,
					b = l;
				switch (t) {
					case "up":
						h--;
						break;
					case "down":
						h++;
						break;
					case "left":
						--b < 0 && (h--, b = d - 1);
						break;
					case "right":
						++b >= d && (h++, b = 0)
				}
				const f = {
					rowIndex: h,
					colIndex: b
				};
				let g = i;
				const v = te()(p.blocks, e => Object(Y.h)(Object(Y.g)(e), f));
				if (v) g = v.getKey();
				else {
					const e = Object(Y.c)(f, c) < 0 ? p.start - 1 : p.start + p.blocks.length;
					0 <= e && e < m.length && (g = m[e].getKey())
				}
				const C = s.getBlockForKey(g);
				let y = 0;
				"preserve" === n ? y = pn()(r.getFocusOffset(), 0, C.getLength()) : "end" === n && (y = C.getLength());
				const E = r.merge({
					anchorKey: g,
					focusKey: g,
					focusOffset: y,
					anchorOffset: y
				});
				return r !== E ? o.EditorState.forceSelection(e, E) : void 0
			};
			const fn = (e, t) => {
					const n = t.getCurrentContent(),
						o = t.getSelection(),
						r = n.getBlockForKey(o.getFocusKey()),
						[s] = Object(Y.e)(n, r, r);
					if (!s) return;
					const i = Object(Y.g)(r);
					let a;
					return (a = i.colIndex === i.colCount - 1 && i.rowIndex === s.blocks.length / i.colCount - 1 && !e.shiftKey && o.getFocusKey() === o.getAnchorKey() ? un(t, "rows", "after") : bn(t, e.shiftKey ? "left" : "right", "end")) ? (e.preventDefault(), a) : void 0
				},
				gn = (e, t) => {
					if (e.shiftKey) return;
					const n = bn(t, "up");
					return n && e.preventDefault(), n
				},
				vn = (e, t) => {
					if (e.shiftKey) return;
					const n = bn(t, "down");
					return n && e.preventDefault(), n
				};
			class Cn {
				constructor() {
					this.lastRowInsertionState = null
				}
				undoRowInsertion(e) {
					const t = o.EditorState.undo(e);
					return bn(t, "down", "end") || t
				}
				isSelectionInLastRow(e) {
					const t = e.getCurrentContent(),
						n = e.getSelection(),
						o = t.getBlockForKey(n.getFocusKey()),
						[r] = Object(Y.e)(t, o, o);
					if (!r) return !1;
					const s = Object(Y.g)(r.blocks[0]).colCount,
						i = r.blocks.length / s;
					return Object(Y.g)(o).rowIndex === i - 1
				}
				insertNewRow(e) {
					const t = e.getSelection();
					let n = un(e, "rows", "after");
					return n = o.EditorState.forceSelection(n, t), n = bn(n, "down") || n, this.lastRowInsertionState = n, n
				}
				handle(e) {
					return e.getSelection().isCollapsed() ? e === this.lastRowInsertionState ? this.undoRowInsertion(e) : this.isSelectionInLastRow(e) ? this.insertNewRow(e) : bn(e, "down") || e : e
				}
			}
			const yn = (e, t) => {
				const n = e.getSelection();
				if (n.isCollapsed() || n.getStartKey() === n.getEndKey()) return;
				const r = e.getCurrentContent(),
					s = r.getBlockForKey(n.getAnchorKey()),
					i = r.getBlockForKey(n.getFocusKey()),
					[a, c] = Object(Y.e)(r, s, i);
				if (a && a === c) {
					const s = Object(Y.o)(n, i, i, !1),
						a = Q.b(r, s, t);
					return o.EditorState.push(e, a, Z.d)
				}
			};
			var En = n("./node_modules/lodash/forEach.js"),
				xn = n.n(En);
			const On = (e, t) => t ? e[0] : e[e.length - 1];
			var _n = (e, t) => {
					return e.getSelection().isCollapsed() ? ((e, t) => {
						const n = e.getSelection(),
							r = t.getSelection();
						if (!n.isCollapsed() || r.isCollapsed() || 0 !== r.getStartOffset() || r.getStartKey() !== n.getStartKey()) return e;
						const s = e.getCurrentContent(),
							i = t.getCurrentContent(),
							a = s.getBlockForKey(n.getAnchorKey());
						if (!Object(w.v)(a.getType())) return e;
						const {
							rowIndex: c,
							colIndex: d
						} = Object(Y.g)(a);
						if (0 !== c || 0 !== d) return e;
						const l = s.getBlockMap(),
							u = i.getBlockMap();
						if (l.size >= u.size) return e;
						const m = s.getBlockAfter(n.getAnchorKey()),
							p = i.getBlockAfter(r.getEndKey());
						if (m && m !== p) return e;
						const h = a.merge({
								type: w.n,
								data: Object(U.Map)({})
							}),
							b = s.merge({
								blockMap: l.set(a.getKey(), h)
							});
						return o.EditorState.set(e, {
							currentContent: b
						})
					})(e, t) : ((e, t) => {
						const n = e.getSelection();
						if (n.isCollapsed()) return e;
						if (t.getSelection() === n) return e;
						if (n.getFocusKey() === n.getAnchorKey()) return e;
						const r = e.getCurrentContent(),
							s = r.getBlockForKey(n.getAnchorKey()),
							i = r.getBlockForKey(n.getFocusKey()),
							[a, c] = Object(Y.e)(r, s, i);
						if (!a && !c) return e;
						let d = e;
						if (a !== c) {
							const t = n.getIsBackward(),
								r = Object(Y.o)(n, a ? On(a.blocks, !t) : null, c ? On(c.blocks, t) : null, t);
							n !== r && (d = o.EditorState.forceSelection(e, r))
						} else if (a && c && a === c) {
							const t = Object(Y.g)(s),
								a = Object(Y.g)(i),
								l = r.getBlocksAsArray(),
								{
									start: u,
									blocks: m
								} = c,
								p = m[0],
								h = Object(Y.g)(p);
							if (0 !== h.colIndex || 0 !== h.rowIndex) throw new Error("First table block must always has [0, 0] coordinate!");
							const b = Object(Y.b)(i, s) < 0,
								f = Object(Y.k)(t, a),
								g = [],
								v = [];
							xn()(m, e => {
								const t = Object(Y.g)(e);
								f(t.rowIndex, t.colIndex) ? g.push(e) : e !== p && v.push(e)
							});
							const C = g[0] === p;
							g.sort(Y.b);
							const y = [...l.slice(0, u), ...C ? [] : [p], ...g, ...v, ...l.slice(u + m.length)],
								E = On(g, !b),
								x = On(g, b),
								O = Object(Y.o)(n, E, x, b),
								_ = r.merge({
									blockMap: o.BlockMapBuilder.createFromArray(y),
									selectionAfter: O
								});
							d = o.EditorState.set(e, {
								currentContent: _
							}), O !== n && (d = o.EditorState.forceSelection(d, O))
						}
						return d
					})(e, t)
				},
				kn = n("./src/reddit/components/RichTextEditor/table/Renderer/index.m.less"),
				jn = n.n(kn);
			const Sn = C.a.div("Cell", jn.a),
				Tn = C.a.div("Row", jn.a),
				wn = C.a.div("Table", jn.a),
				In = (e, t) => {
					if (!t || !e.contains(t)) return;
					let n = t;
					for (; n && n !== e;) {
						if (n instanceof HTMLElement && n.hasAttribute("data-row")) return n;
						n.parentElement && (n = n.parentElement)
					}
				},
				Pn = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10,
						n = e,
						o = t;
					for (; n && o > 0;) {
						if (n instanceof HTMLElement && n.dataset.table) return n;
						n.parentElement && (n = n.parentElement), o--
					}
				},
				Nn = e => {
					const {
						dataset: t
					} = e;
					if ("string" == typeof t.row && "string" == typeof t.col) return {
						rowIndex: +t.row,
						colIndex: +t.col
					}
				},
				Rn = e => {
					const t = window.getSelection(),
						{
							focusNode: n,
							anchorNode: o,
							rangeCount: r
						} = t;
					if (n !== o && r && e) {
						const n = t.getRangeAt(0);
						return Object(K.g)(n, e) && !e.contains(n.commonAncestorContainer)
					}
					return !1
				},
				Mn = e => {
					const t = m.a.Children.toArray(e),
						n = Object(F.e)(t[0]),
						{
							selection: o,
							contentState: r,
							block: s
						} = n.props,
						{
							colCount: i
						} = Object(Y.g)(s);
					t.sort((e, t) => Object(Y.b)(Object(F.c)(e), Object(F.c)(t)));
					const a = G()(t, i);
					let c, d, l = !1;
					if (o.getAnchorKey() !== o.getFocusKey()) {
						const e = r.getBlocksAsArray(),
							n = r.getBlockForKey(o.getStartKey()),
							i = r.getBlockForKey(o.getEndKey()),
							a = e.indexOf(n),
							u = e.indexOf(i),
							m = e.indexOf(s),
							p = m + t.length - 1;
						a < m && m < u || a < p && p < u ? l = !0 : m <= a && u <= p && (d = Object(Y.g)(o.getIsBackward() ? i : n), c = Object(Y.g)(o.getIsBackward() ? n : i))
					}
					return {
						rows: a,
						anchorCell: d,
						focusCell: c,
						isSelectWholeTable: l
					}
				};
			class Dn extends m.a.Component {
				constructor(e) {
					super(e), this.tableElem = null, this.onMouseDown = e => {
						if (!this.tableElem || e.nativeEvent.detail < 2) return;
						const t = window.getSelection(),
							n = t.rangeCount ? t.getRangeAt(0) : null,
							o = In(this.tableElem, t.focusNode);
						if (n && o)
							if (2 === e.nativeEvent.detail && t.isCollapsed) {
								const r = n.cloneRange();
								r.setEndAfter(o), r.toString() || (e.preventDefault(), t.selectAllChildren(o))
							} else e.nativeEvent.detail >= 3 && (t.selectAllChildren(o), e.preventDefault())
					}, this.onNativeSelectionChange = () => {
						const e = this.tableElem;
						if (!e) return;
						const t = window.getSelection();
						if (t.anchorNode === t.focusNode) return void this.resetSelection();
						const n = In(e, t.anchorNode),
							o = In(e, t.focusNode);
						n && n === o ? this.resetSelection() : n && o ? this.setCellsRange(n, o) : n || o ? this.selectWholeTable() : Rn(e) ? this.selectWholeTable() : this.resetSelection()
					}, this.resetSelection = () => {
						(this.state.anchorCell || this.state.focusCell || this.state.isSelectWholeTable) && this.setState({
							isSelectWholeTable: !1,
							focusCell: void 0,
							anchorCell: void 0
						})
					}, this.setCellsRange = (e, t) => {
						const n = Nn(t),
							o = Nn(e);
						Object(Y.h)(n, this.state.focusCell) && Object(Y.h)(o, this.state.anchorCell) && !this.state.isSelectWholeTable || this.setState({
							focusCell: n,
							anchorCell: o,
							isSelectWholeTable: !1
						})
					}, this.selectWholeTable = () => {
						!this.state.focusCell && this.state.isSelectWholeTable || this.setState({
							focusCell: void 0,
							isSelectWholeTable: !0
						})
					}, this.state = Mn(e.children)
				}
				componentDidMount() {
					document.addEventListener("selectionchange", this.onNativeSelectionChange)
				}
				componentWillUnmount() {
					document.removeEventListener("selectionchange", this.onNativeSelectionChange)
				}
				UNSAFE_componentWillReceiveProps(e) {
					e.children !== this.props.children && this.setState(Mn(e.children))
				}
				render() {
					const {
						rows: e,
						anchorCell: t,
						focusCell: n,
						isSelectWholeTable: o
					} = this.state;
					let r;
					o ? r = (e, t) => !0 : t && n && !Object(Y.h)(t, n) && (r = Object(Y.k)(t, n));
					const s = e[0].map(e => Object(Y.g)(Object(F.e)(e).props.block).alignment),
						i = e.map((e, t) => m.a.createElement(Tn, {
							key: t
						}, e.map((e, n) => m.a.createElement(Sn, {
							"data-row": t,
							"data-col": n,
							"data-selected": !!r && r(t, n),
							key: n,
							style: {
								"--cell-text-alignment": s[n] ? Y.a[s[n]] : void 0
							}
						}, e))));
					return m.a.createElement(wn, {
						className: r ? jn.a.isFakeSelectionActive : void 0,
						innerRef: e => this.tableElem = e,
						onMouseDown: this.onMouseDown,
						"data-table": !0
					}, i)
				}
			}
			const Ln = Object(U.Map)({
				[w.l]: {
					element: "div",
					wrapper: m.a.createElement(Dn, null)
				}
			});
			var An = n("./node_modules/lodash/isEqual.js"),
				Fn = n.n(An),
				Bn = n("./src/reddit/components/RichTextEditor/Tooltip/index.tsx"),
				Un = n("./src/reddit/icons/svgs/FormattingAlignCenter/index.tsx"),
				Kn = n("./src/reddit/icons/svgs/FormattingAlignLeft/index.tsx"),
				Wn = n("./src/reddit/icons/svgs/FormattingAlignRight/index.tsx"),
				Gn = n("./src/reddit/icons/svgs/FormattingDeleteRow/index.tsx"),
				Hn = n("./src/reddit/icons/svgs/FormattingInsertRow/index.tsx"),
				Vn = n("./src/reddit/models/RichTextJson/index.ts");
			var zn = function(e) {
				arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
				const t = e.getSelection(),
					n = e.getCurrentContent(),
					r = n.getBlockForKey(t.getAnchorKey()),
					s = n.getBlockForKey(t.getFocusKey()),
					[i, a] = Object(Y.e)(n, r, s);
				if (i && i === a) {
					const {
						blocks: n
					} = i;
					n.sort(Y.b);
					const r = Object(Y.o)(t, n[0], X()(n));
					return ne(o.EditorState.set(e, {
						selection: r
					}), "rows")
				}
			};
			var qn = (e, t) => {
					const n = e.getSelection(),
						r = e.getCurrentContent(),
						s = r.getBlockForKey(n.getAnchorKey()),
						i = r.getBlockForKey(n.getFocusKey()),
						[a, c] = Object(Y.e)(r, s, i);
					if (!a || a !== c) return e;
					const d = Object(Y.g)(s),
						l = Object(Y.g)(i),
						{
							minCol: u,
							maxCol: m
						} = Object(Y.f)(d, l),
						p = a.blocks.map(e => {
							const {
								colIndex: n
							} = Object(Y.g)(e);
							return u <= n && n <= m ? Object(Y.m)(e, {
								alignment: t
							}) : e
						}),
						h = r.getBlockMap(),
						b = r.merge({
							blockMap: h.merge(o.BlockMapBuilder.createFromArray(p)),
							selectionAfter: n,
							selectionBefore: n
						});
					return o.EditorState.push(e, b, Z.b)
				},
				Qn = n("./src/reddit/components/RichTextEditor/table/Toolbar/index.m.less"),
				Yn = n.n(Qn);

			function Jn() {
				return (Jn = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const Xn = (e, t) => n => m.a.createElement(e, Jn({}, t, n)),
				Zn = Object(Gt.f)(Hn.a),
				$n = Xn(Zn, {
					orientation: "up"
				}),
				eo = Xn(Zn, {
					orientation: "right"
				}),
				to = Xn(Zn, {
					orientation: "left"
				}),
				no = Object(Gt.f)(Gn.a),
				oo = Xn(no, {
					orientation: "vertical"
				}),
				ro = Object(Gt.f)(Un.a),
				so = Object(Gt.f)(Kn.a),
				io = Object(Gt.f)(Wn.a),
				ao = Object(Gt.f)(Bt.b),
				co = C.a.wrapped(Ut.a, "ToolbarContent", Yn.a),
				lo = e => m.a.createElement(Wt.a, Jn({}, e, {
					className: Object(g.a)(Yn.a.formatterButton, e.className),
					tooltipContentClass: Yn.a.tooltip
				}));
			var uo = e => {
					const {
						editorState: t,
						onChange: n
					} = e;
					return m.a.createElement(co, null, m.a.createElement(lo, {
						Icon: so,
						onClick: () => n(qn(t, Vn.e)),
						tooltip: r.fbt._("Left align", null, {
							hk: "45eAc"
						})
					}), m.a.createElement(lo, {
						Icon: ro,
						onClick: () => n(qn(t, Vn.d)),
						tooltip: r.fbt._("Center align", null, {
							hk: "4aAfyf"
						})
					}), m.a.createElement(lo, {
						Icon: io,
						onClick: () => n(qn(t, Vn.f)),
						tooltip: r.fbt._("Right align", null, {
							hk: "3oHuXw"
						})
					}), m.a.createElement(Kt.c, null), m.a.createElement(lo, {
						Icon: to,
						onClick: () => n(un(t, "columns", "before")),
						tooltip: r.fbt._("Insert column before", null, {
							hk: "11EB6Q"
						})
					}), m.a.createElement(lo, {
						Icon: eo,
						onClick: () => n(un(t, "columns", "after")),
						tooltip: r.fbt._("Insert column after", null, {
							hk: "Ddlpl"
						})
					}), m.a.createElement(lo, {
						Icon: oo,
						onClick: () => n(ne(t, "columns")),
						tooltip: r.fbt._("Delete column", null, {
							hk: "3HaQQD"
						})
					}), m.a.createElement(Kt.c, null), m.a.createElement(lo, {
						Icon: $n,
						onClick: () => n(un(t, "rows", "before")),
						tooltip: r.fbt._("Insert row above", null, {
							hk: "1HIgn"
						})
					}), m.a.createElement(lo, {
						Icon: Zn,
						onClick: () => n(un(t, "rows", "after")),
						tooltip: r.fbt._("Insert row below", null, {
							hk: "3t7ZU"
						})
					}), m.a.createElement(lo, {
						Icon: no,
						onClick: () => n(ne(t, "rows")),
						tooltip: r.fbt._("Delete row", null, {
							hk: "3yJYqS"
						})
					}), m.a.createElement(Kt.c, null), m.a.createElement(lo, {
						Icon: ao,
						onClick: () => n(zn(t) || t),
						tooltip: r.fbt._("Delete table", null, {
							hk: "1fK0KA"
						})
					}))
				},
				mo = n("./src/reddit/components/RichTextEditor/table/ToolbarController/index.m.less"),
				po = n.n(mo);
			const ho = 20,
				bo = C.a.div("ActionButton", po.a),
				fo = C.a.div("ToolbarWrapper", po.a),
				go = e => {
					const t = {};
					if (!e || !document.documentElement) return t;
					const n = e.left - 185,
						o = e.left + 185 - document.documentElement.clientWidth;
					return n < 0 ? t.left = -n + ho + 2 : o > 0 && (t.left = -o + ho - 2), t
				},
				vo = e => {
					e.preventDefault(), e.stopPropagation()
				};
			class Co extends u.Component {
				constructor(e) {
					super(e), this.containerElem = null, this.setContainerRef = e => this.containerElem = e, this.onResize = e => {
						this.hideToolbar(), this.state.tooltipPosition && this.updateForCurrentSelection()
					}, this.onDocumentClick = e => {
						this.state.isToolbarActive && this.containerElem && (this.containerElem.contains(e.target) || this.hideToolbar())
					}, this.onNativeSelectionChange = () => {
						this.updateForCurrentSelection()
					}, this.updateForCurrentSelection = () => {
						const e = window.getSelection();
						if (!e.rangeCount) return void this.hideActionButton();
						const t = e.getRangeAt(0).commonAncestorContainer,
							{
								rteDomRef: n
							} = this.props;
						if (!n.contains(t)) return void this.hideActionButton();
						const o = Pn(t);
						if (!o) return void this.hideActionButton();
						const r = In(o, e.anchorNode);
						if (!r) return void this.hideActionButton();
						const s = In(o, e.focusNode);
						s ? this.updateActionButtonPosition(r, s) : this.hideActionButton()
					}, this.updateActionButtonPosition = (e, t) => {
						const n = e.getBoundingClientRect(),
							o = t.getBoundingClientRect(),
							r = {
								top: Math.min(n.top, o.top),
								left: Math.max(n.right, o.right) - ho
							};
						Fn()(this.state.tooltipPosition, r) || this.setState({
							tooltipPosition: r
						}), this.hideToolbar()
					}, this.hideActionButton = () => {
						this.hideToolbar(), this.state.tooltipPosition && this.setState({
							tooltipPosition: null
						})
					}, this.hideToolbar = () => {
						this.state.isToolbarActive && this.setState({
							isToolbarActive: !1
						})
					}, this.onActionButtonClick = e => {
						this.setState(e => ({
							isToolbarActive: !e.isToolbarActive
						})), vo(e)
					}, this.state = {
						isToolbarActive: !1,
						tooltipPosition: null
					}, this.api = {
						hideActionButton: this.hideActionButton
					}
				}
				componentDidMount() {
					const {
						onSetApi: e
					} = this.props;
					document.addEventListener("selectionchange", this.onNativeSelectionChange), document.addEventListener("click", this.onDocumentClick), window.addEventListener("resize", this.onResize), e && e(this.api)
				}
				componentWillUnmount() {
					const {
						onSetApi: e
					} = this.props;
					document.removeEventListener("selectionchange", this.onNativeSelectionChange), document.removeEventListener("click", this.onDocumentClick), window.removeEventListener("resize", this.onResize), e && e(null)
				}
				UNSAFE_componentWillReceiveProps(e) {
					const t = e.editorState.getSelection(),
						n = this.props.editorState.getSelection();
					t.getHasFocus() && Object(w.v)(o.RichUtils.getCurrentBlockType(e.editorState)) ? t !== n && this.hideToolbar() : this.hideActionButton()
				}
				render() {
					const e = !this.props.readOnly && this.state.isToolbarActive,
						{
							tooltipPosition: t
						} = this.state;
					return m.a.createElement("div", {
						ref: this.setContainerRef
					}, m.a.createElement(Bn.b, {
						targetPosition: t
					}, m.a.createElement(bo, {
						className: e ? po.a.isPressed : void 0,
						onClick: this.onActionButtonClick,
						onMouseDown: vo,
						onMouseMove: vo
					}, e ? m.a.createElement(fo, {
						style: go(t)
					}, m.a.createElement(uo, {
						onChange: this.props.onChange,
						editorState: this.props.editorState
					})) : null)))
				}
			}
			var yo = n("./src/reddit/components/RichTextEditor/editorStateTransforms.ts");
			n("./node_modules/core-js/modules/web.dom.iterable.js");

			function Eo() {
				return (Eo = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}

			function xo() {
				return new Map
			}
			const Oo = m.a.createContext(xo());

			function _o(e) {
				class t extends m.a.Component {
					constructor() {
						super(...arguments), this.elementRef = null, this.updateElementRef = e => {
							const {
								registry: t
							} = this.props;
							this.elementRef = e, e ? t.set(this.props.entityKey, e) : t.delete(this.props.entityKey)
						}
					}
					componentWillReceiveProps(e) {
						const {
							registry: t
						} = this.props;
						this.props.entityKey !== e.entityKey && this.elementRef && (t.get(this.props.entityKey) === this.elementRef && t.delete(this.props.entityKey), t.set(e.entityKey, this.elementRef))
					}
					render() {
						return m.a.createElement("span", {
							ref: this.updateElementRef
						}, m.a.createElement(e, this.props))
					}
				}
				return e => m.a.createElement(Oo.Consumer, null, n => m.a.createElement(t, Eo({}, e, {
					registry: n
				})))
			}
			var ko = n("./src/reddit/components/RichTextEditor/emotes/helpers.ts"),
				jo = n("./src/reddit/components/RichTextEditor/emotes/decorator.m.less"),
				So = n.n(jo);
			const To = {
					strategy: ko.e,
					component: _o(e => {
						const {
							contentState: t
						} = e, n = Object(ko.i)(t), o = t.getEntity(e.entityKey), {
							id: r,
							emoji: s,
							sticker: i
						} = o.getData(), a = n ? i : s;
						return m.a.createElement("span", {
							className: Object(g.a)(So.a.emote, {
								[So.a.sticker]: n
							}),
							title: `:${r}:`,
							style: {
								backgroundImage: `url(${a.path})`,
								width: a.x
							}
						}, e.children)
					})
				},
				wo = () => To;
			var Io = n("./src/reddit/selectors/gold/enabledFeatures.ts"),
				Po = n("./src/reddit/selectors/gold/powerups/index.ts"),
				No = n("./src/reddit/components/RichTextEditor/emotes/Powerups/tooltipAsync.ts"),
				Ro = n("./src/higherOrderComponents/makeAsync.tsx"),
				Mo = Object(Ro.a)({
					ErrorComponent: () => null,
					LoadingComponent: () => null,
					getComponent: () => n.e("SpecialMembershipsEmotesTooltip").then(n.bind(null, "./src/reddit/components/RichTextEditor/emotes/SpecialMemberships/tooltip.tsx")).then(e => e.default)
				});
			var Do = e => {
				const {
					subreddit: t
				} = e, n = t.id, o = Object(p.e)(e => Object(Io.b)(e, {
					subredditId: n
				}));
				return Object(p.e)(e => Object(Po.a)(e, {
					subredditId: n
				})) ? m.a.createElement(No.a, e) : m.a.createElement(m.a.Fragment, null, o && m.a.createElement(Mo, e))
			};
			const Lo = new Set([B.a.LINK]);
			var Ao = n("./src/reddit/components/RichTextEditor/entity/link/helpers.tsx"),
				Fo = n("./src/reddit/components/RichTextEditor/entity/link/decorator.m.less"),
				Bo = n.n(Fo);
			const Uo = C.a.a("RegularLink", Bo.a),
				Ko = {
					strategy: Ao.a,
					component: _o(e => {
						const t = e.contentState.getEntity(e.entityKey),
							{
								url: n
							} = t.getData();
						return m.a.createElement(Uo, {
							href: n
						}, e.children)
					})
				},
				Wo = () => Ko;
			var Go = n("./src/lib/linkMatchers/index.ts");
			const Ho = (e, t) => {
					if (t.getType() === w.f) return [];
					return (e.match(t.getText()) || []).filter(e => ((e, t) => {
						let {
							index: n,
							lastIndex: o
						} = t;
						for (let r = n; r < o; r++) {
							if (e.getInlineStyleAt(r).contains(w.k.MONOSPACE)) return !1
						}
						return !0
					})(t, e))
				},
				Vo = (e, t, n, r, s, i) => {
					const a = e.getBlockForKey(t),
						c = o.SelectionState.createEmpty(t),
						d = [],
						l = new Set;
					let u = e;
					const m = n === B.a.USER_MENTION ? B.a.USER_LINK : n,
						p = (e, t, o) => {
							let r = null;
							for (let s = e; s < t; s++) {
								const e = a.getEntityAt(s),
									t = e && u.getEntity(e);
								if (t) {
									if (t.getType() !== n) return;
									r || l.has(e) || (r = e)
								}
							}
							if (r) {
								u.getEntity(r).getData().url !== o && (u = u.mergeEntityData(r, {
									url: o
								}))
							}
							return r || (e => (u = u.createEntity(m, "MUTABLE", {
								url: e
							})).getLastCreatedEntityKey())(o)
						},
						h = (e, t, n) => {
							const r = c.merge({
								anchorOffset: e,
								focusOffset: t
							});
							u = o.Modifier.applyEntity(u, r, n)
						},
						b = (e, t) => h(e, t, null),
						f = u.getBlockForKey(t);
					Ho(r, f).forEach((e, r) => {
						let {
							index: a,
							lastIndex: m,
							url: b
						} = e;
						const f = p(a, m, b);
						f && (n === B.a.USER_MENTION ? (((e, n, r) => {
							const a = u && u.getBlockForKey(t),
								d = a && a.getText().substr(e, n);
							if (d && d.replace(y.d.mention, "") && d.startsWith(y.d.mention) && y.c.test(d.replace(y.d.mention, ""))) {
								const t = c.merge({
										anchorOffset: e,
										focusOffset: e + y.d.mention.length
									}),
									a = c.merge({
										anchorOffset: e,
										focusOffset: n + y.d.mention.length
									}),
									d = c.merge({
										anchorOffset: n + y.d.mention.length,
										focusOffset: n + y.d.mention.length
									});
								u = Object(Q.b)(u, t, y.d.profile), u = o.Modifier.applyEntity(u, a, r), s && i && i(o.EditorState.forceSelection(s, d))
							}
						})(a + r, m + r, f), d.push([a + r, m + r + 1])) : (h(a, m, f), d.push([a, m])), l.add(f))
					});
					let g = 0;
					return f.findEntityRanges(e => {
						const t = e.getEntity();
						return !!t && u.getEntity(t).getType() === n
					}, (e, t) => {
						if (g >= d.length) return void b(e, t);
						const [n, o] = d[g];
						t <= n ? b(e, t) : (e < n && b(e, n - 1), t > o && b(o, t), g++)
					}), u
				},
				zo = (e, t) => {
					const n = e.getCurrentContent(),
						r = t.getCurrentContent();
					if (n === r) return e;
					const s = n.getBlockMap(),
						i = r.getBlockMap();
					let a = n;
					return s.forEach((t, n) => {
						if (n) {
							if (t === i.get(n)) return;
							a = Vo(a, n, B.a.SUBREDDIT_LINK, Go.g), a = Vo(a, n, B.a.USER_LINK, Go.j), a = Vo(a, n, B.a.USER_MENTION, Go.e, e, t => e = t)
						}
					}), e.getCurrentContent() === a ? e : (a = a.merge({
						selectionAfter: e.getCurrentContent().getSelectionAfter(),
						selectionBefore: e.getCurrentContent().getSelectionBefore()
					}), o.EditorState.set(e, {
						currentContent: a
					}))
				};
			var qo = e => {
				const t = e.getCurrentContent();
				return t.getBlockMap().some(e => {
					if ((null == e ? void 0 : e.getType()) === w.a) return !0;
					let n = !1;
					return null == e || e.findEntityRanges(e => {
						const n = e.getEntity();
						return !!n && t.getEntity(n).getType() === B.a.EMOTE
					}, () => n = !0), n
				})
			};
			const Qo = " ".repeat(4),
				Yo = new RegExp("^ {1,4}|\\t"),
				Jo = new Set([w.b.CODE_BLOCK]),
				Xo = (e, t) => {
					const n = t.getCurrentContent(),
						r = t.getSelection(),
						s = e.shiftKey;
					let i = n,
						a = r.getAnchorOffset(),
						c = r.getFocusOffset();
					if (Object($.a)(n, r, (e, t) => {
							const n = e.getType();
							if ("paragraph" === n || !Jo.has(n)) return !1;
							let d = null;
							const l = e.getText(),
								u = o.SelectionState.createEmpty(t);
							if (s) {
								const e = l.match(Yo);
								if (e) {
									const t = e[0].length;
									i = Q.b(i, u.merge({
										focusOffset: t
									}), ""), d = -t
								}
							} else i = Q.a(i, r.isCollapsed() ? r : u, Qo), d = 4;
							null !== d && (t === r.getAnchorKey() && (a += d), t === r.getFocusKey() && (c += d))
						}), i !== n) return i = i.merge({
						selectionAfter: r.merge({
							anchorOffset: a,
							focusOffset: c
						})
					}), e.preventDefault(), o.EditorState.push(t, i, s ? "remove-range" : "insert-characters")
				},
				Zo = (e, t) => (e => {
					const t = e.getSelection(),
						n = e.getCurrentContent();
					if (!t.isCollapsed()) return oe(e);
					if (0 === t.getStartOffset()) {
						const o = n.getBlockForKey(t.getEndKey());
						if (Object(w.v)(o.getType())) return e; {
							const t = n.getBlockBefore(o.getKey());
							if (t && Object(w.v)(t.getType())) return e
						}
					}
				})(e) || ((e, t) => {
					const n = e.getSelection(),
						r = e.getCurrentContent();
					if (n.isCollapsed() && 0 === n.getStartOffset()) {
						const s = r.getBlockForKey(n.getEndKey());
						if (Object(w.o)(s.getType())) return Object(A.d)(e, s.getKey());
						if (Object(w.u)(s.getType())) {
							const t = r.getBlockBefore(s.getKey());
							return o.EditorState.forceSelection(e, Object(F.b)(t))
						}
						if (!Object(A.q)(t) && Object(F.g)(s)) {
							const t = r.getBlockBefore(s.getKey());
							if (t && Object(w.o)(t.getType())) return e = o.EditorState.push(e, Object(F.i)(r, s.getKey()), Z.f), o.EditorState.forceSelection(e, Object(F.b)(t))
						}
					}
				})(e, t),
				$o = (e, t) => (e => {
					const t = e.getSelection(),
						n = e.getCurrentContent();
					if (!t.isCollapsed()) return oe(e); {
						const o = n.getBlockForKey(t.getEndKey());
						if (t.getEndOffset() === o.getLength()) {
							if (Object(w.v)(o.getType())) return e; {
								const t = n.getBlockAfter(o.getKey());
								if (t && Object(w.v)(t.getType())) return e
							}
						}
					}
				})(e) || ((e, t) => {
					const n = e.getSelection(),
						r = e.getCurrentContent();
					if (!n.isCollapsed()) return;
					const s = r.getBlockForKey(n.getEndKey());
					if (n.getEndOffset() === s.getLength()) {
						if (Object(w.o)(s.getType())) return Object(A.d)(e, s.getKey()); {
							const i = r.getBlockAfter(n.getEndKey());
							if (i && Object(w.o)(i.getType())) {
								if (Object(A.q)(t)) return Object(A.d)(e, i.getKey());
								if (Object(F.g)(s)) return e = o.EditorState.push(e, Object(F.i)(r, s.getKey()), Z.f), o.EditorState.forceSelection(e, Object(F.b)(i))
							}
						}
					}
				})(e, t),
				er = e => {
					const t = e.getSelection();
					if (!t.isCollapsed()) return !1;
					const n = o.RichUtils.getCurrentBlockType(e);
					if (!w.c.includes(n)) return !1;
					if (t.getFocusOffset() > 0) {
						if ("\n" === e.getCurrentContent().getBlockForKey(t.getFocusKey()).getText()[t.getFocusOffset() - 1]) return !1
					}
					return !0
				};
			var tr = n("./src/lib/memoizeByReference/index.ts");
			const nr = Object(tr.a)(e => {
					const t = e.getSelection();
					if (!t.isCollapsed()) return;
					const n = t.getStartOffset(),
						o = e.getCurrentContent(),
						r = o.getBlockForKey(t.getFocusKey());
					if (r.getType() !== w.n) return;
					const s = r.getText();
					if (s.startsWith("1.") && 2 === n) return w.i.ORDERED;
					if (s.startsWith("*") && 1 === n) {
						const e = o.getBlockBefore(r.getKey());
						if (e && e.getType() === w.n && e.getText().startsWith("* ")) return;
						return w.i.UNORDERED
					}
				}),
				or = e => {
					const t = nr(e);
					if (!t) return e;
					const n = Object(yo.a)(e);
					let r = o.Modifier.replaceText(n.getCurrentContent(), n.getSelection().merge({
						anchorOffset: 0
					}), "");
					return r = o.Modifier.setBlockType(r, r.getSelectionAfter(), t), o.EditorState.push(n, r, Z.c)
				};
			var rr = n("./src/reddit/components/RichTextEditor/helpers/styles.ts");
			const sr = Object(Ro.a)({
				ErrorComponent: () => null,
				LoadingComponent: () => null,
				getComponent: () => n.e("GifTooltip").then(n.bind(null, "./src/reddit/components/RichTextEditor/media/GifTooltip/index.tsx")).then(e => e.default)
			});

			function ir(e) {
				return m.a.createElement(sr, e)
			}
			var ar = n("./src/reddit/components/RichTextEditor/spoiler/helpers.ts"),
				cr = n("./src/reddit/components/RichTextEditor/spoiler/decorator.m.less"),
				dr = n.n(cr);
			const lr = e => m.a.createElement("span", {
					className: dr.a.spoiler
				}, m.a.createElement("span", null), e.children, m.a.createElement("span", null)),
				ur = () => ({
					strategy: ar.a,
					component: lr
				});
			var mr = n("./src/reddit/components/FocusableContent/index.tsx"),
				pr = n("./src/reddit/components/RichTextEditor/Blockquote/index.m.less"),
				hr = n.n(pr);
			const br = C.a.div("BlockQuoteWrapper", hr.a),
				fr = Object(U.Map)({
					[w.e]: {
						element: "blockquote",
						wrapper: m.a.createElement(br, null)
					}
				});
			var gr = n("./src/reddit/components/RichTextEditor/CodeBlock/index.m.less"),
				vr = n.n(gr);
			const Cr = Object(U.Map)({
				[w.f]: {
					element: "code",
					wrapper: m.a.createElement(e => m.a.createElement("div", {
						className: vr.a.CodeBlockWrapper
					}, e.children), null)
				}
			});
			var yr = n("./node_modules/bowser/src/bowser.js"),
				Er = n.n(yr),
				xr = n("./node_modules/lodash/includes.js"),
				Or = n.n(xr),
				_r = n("./src/reddit/components/RichTextEditor/DragController/helpers.ts"),
				kr = n("./src/reddit/components/RichTextEditor/DragController/index.m.less"),
				jr = n.n(kr);
			const Sr = C.a.div("DropLine", jr.a),
				Tr = C.a.wrapped(Bn.b, "Tooltip", jr.a);
			class wr extends u.Component {
				constructor(e) {
					super(e), this.dragCount = 0, this.setContainerRef = e => this.containerRef = e, this.preventDocumentDrop = e => {
						!! function e(t) {
							return t.draggable ? t : t.parentElement ? e(t.parentElement) : null
						}(e.target) || (e.preventDefault(), e.stopPropagation())
					}, this.onDragOver = e => {
						const t = Or()(e.dataTransfer.types, Ve);
						if (!t) {
							if (!Object(_r.c)(e.dataTransfer) || !this.props.allowMediaUploads) return
						}
						if (!t && !Object(_r.c)(e.dataTransfer)) return;
						e.preventDefault();
						try {
							e.dataTransfer.dropEffect = t ? "move" : "copy"
						} catch (s) {}
						const {
							editorState: n
						} = this.props;
						let o = null;
						const r = Object(_r.b)(n, e);
						if (r) {
							const e = this.containerRef.getBoundingClientRect().left;
							o = {
								top: r.clientY,
								left: e
							}
						}
						Fn()(o, this.state.point) || this.setState({
							point: o
						})
					}, this.onDragEnter = e => {
						this.dragCount++
					}, this.onDragLeave = e => {
						this.dragCount--, 0 === this.dragCount && this.state.point && this.setState({
							point: null
						})
					}, this.onDrop = e => {
						const t = () => {
								this.dragCount = 0, this.setState({
									point: null
								})
							},
							n = Er.a.msie ? null : e.dataTransfer.getData(Ve),
							o = Object(_r.a)(e.dataTransfer);
						if (!(n || o.length && this.props.allowMediaUploads)) return void t();
						const {
							editorState: r
						} = this.props, s = Object(_r.b)(r, e);
						if (!s) return void t();
						e.preventDefault(), e.stopPropagation();
						const i = s.isBefore ? F.a.before : F.a.after;
						n ? this.props.onBlockMove(n, s.blockKey, i) : setTimeout(() => {
							this.props.onFilesDrop(o, s.blockKey, i)
						}), t()
					}, this.state = {
						point: null
					}
				}
				componentDidMount() {
					document.addEventListener("drop", this.preventDocumentDrop), document.addEventListener("dragover", this.preventDocumentDrop)
				}
				componentWillUnmount() {
					document.removeEventListener("drop", this.preventDocumentDrop), document.removeEventListener("dragover", this.preventDocumentDrop)
				}
				render() {
					const {
						children: e
					} = this.props, {
						point: t
					} = this.state, n = m.a.Children.only(e);
					return m.a.createElement("div", {
						className: Object(g.a)(jr.a.container, {
							[jr.a.hideCaret]: !!t
						}),
						onDragEnter: this.onDragEnter,
						onDragLeave: this.onDragLeave,
						onDragOver: this.onDragOver,
						onDrop: this.onDrop,
						ref: this.setContainerRef
					}, m.a.createElement("div", null, n), m.a.createElement(Tr, {
						targetPosition: t
					}, m.a.createElement(Sr, null)))
				}
			}
			var Ir = n("./node_modules/draft-js/lib/DraftPasteProcessor.js"),
				Pr = n.n(Ir),
				Nr = n("./node_modules/draft-js/lib/getEntityKeyForSelection.js"),
				Rr = n.n(Nr),
				Mr = n("./node_modules/draft-js/lib/splitTextIntoTextBlocks.js"),
				Dr = n.n(Mr),
				Lr = n("./src/reddit/components/RichTextEditor/entity/cloneEntitiesInFragment.ts"),
				Ar = n("./src/reddit/components/RichTextEditor/entity/applyEntityToContentBlock.ts");

			function Fr(e, t, n) {
				const r = Object(o.convertFromHTML)(t, void 0, n);
				if (r) {
					const {
						contentBlocks: t,
						entityMap: n
					} = r;
					if (t) {
						const r = o.BlockMapBuilder.createFromArray(function(e) {
							return e.map(e => Object(w.r)(e.getType()) ? N(e) : e)
						}(t));
						return [e.set("entityMap", n), r]
					}
				}
				return [e, null]
			}

			function Br(e, t, n) {
				const r = Dr()(t),
					s = n && 1 === r.length ? n : o.CharacterMetadata.create(),
					i = Pr.a.processText(r, s).map(e => e.merge({
						type: w.n
					}));
				return o.BlockMapBuilder.createFromArray(i)
			}
			const Ur = e => {
					if (!e) return null;
					const t = (new DOMParser).parseFromString(e, "text/html").querySelector("[data-reddit-rtjson]");
					return t && t.getAttribute("data-reddit-rtjson")
				},
				Kr = e => {
					if (ye()) return {
						text: window.clipboardData.getData("text"),
						html: null
					}; {
						const t = e.clipboardData.getData("text/html");
						return {
							text: e.clipboardData.getData("text/plain"),
							html: t
						}
					}
				};

			function Wr(e, t, n, r) {
				const {
					text: s,
					html: i
				} = Kr(n), a = function(e, t, n, o) {
					const r = {
							text: t,
							html: n,
							rtjson: o,
							fragment: null
						},
						s = e.getClipboard();
					return s && n && function(e, t, n, o) {
						return -1 !== t.indexOf(o) || 1 === e.size && e.first().getText() === n
					}(s, n, t, e.getEditorKey()) && (r.fragment = s), r
				}(t, s, i, i && Ur(i));
				t.getClipboard() && !a.fragment && t.setClipboard(null);
				const c = e.getCurrentContent(),
					d = e.getSelection(),
					l = e.getCurrentInlineStyle(),
					u = t.props.blockRenderMap;
				let m = null,
					p = c;
				if (!(m = function(e, t, n) {
						const o = e.getBlockForKey(t.getStartKey()),
							r = e.getBlockForKey(t.getEndKey());
						if (o.getType() === w.f || r.getType() === w.f) return Br(0, n).map(e => e.merge({
							type: w.f,
							depth: 0
						}))
					}(p, d, a.text)) && a.fragment && (m = a.fragment, [p, m] = Object(Lr.b)(p, m), m = je(m, r)), !m && a.rtjson && (m = function(e) {
						const t = JSON.parse(e);
						return Object(o.convertFromRaw)(t).getBlockMap()
					}(a.rtjson)), !m && a.html && ([p, m] = Fr(p, a.html, u)), !m && a.text) {
					const e = function(e, t, n) {
						return o.CharacterMetadata.create({
							style: n,
							entity: Rr()(e, t)
						})
					}(p, d, l);
					m = Br(0, a.text, e), [p, m] = function(e, t) {
						let n = e,
							o = t;
						return t.forEach(e => {
							const t = e.getText(),
								r = Go.f.match(t);
							if (!r) return;
							let s = e;
							r.forEach(e => {
								let {
									index: t,
									lastIndex: r,
									url: i
								} = e;
								const a = (n = n.createEntity(B.a.LINK, "MUTABLE", {
									url: i
								})).getLastCreatedEntityKey();
								s = Object(Ar.a)(s, t, r, a), o = o.set(s.getKey(), s)
							})
						}), [n, o]
					}(p, m)
				}
				if (m) return p = function(e, t, n) {
					if (n.isEmpty()) return e;
					let o = le(e, t, n) || Se(e, t, n);
					return o || (o = Q.c(e, t, n))
				}(p, d, m), o.EditorState.push(e, p, Z.e)
			}
			var Gr = n("./src/reddit/components/RichTextEditor/entity/getSelectionEntityInfo.ts"),
				Hr = n("./src/reddit/components/RichTextEditor/Tooltip/getSelectionClientRect.ts"),
				Vr = n("./src/reddit/components/RichTextEditor/LinksController/LinkDetailsPopup/index.m.less"),
				zr = n.n(Vr);
			const qr = C.a.div("LinkDetailsBox", zr.a),
				Qr = C.a.a("Link", zr.a),
				Yr = C.a.a("LinkButton", zr.a);
			var Jr = e => m.a.createElement("div", null, m.a.createElement(qr, {
					onMouseDown: e => e.preventDefault()
				}, m.a.createElement(Qr, {
					href: e.url,
					target: "_blank"
				}, e.url), m.a.createElement("span", null, "  "), m.a.createElement(Yr, {
					onClick: () => e.onStartEdit(),
					role: "button"
				}, r.fbt._("Change", null, {
					hk: "3aOmcP"
				})), m.a.createElement("span", null, " | "), m.a.createElement(Yr, {
					onClick: () => e.onRemove(),
					role: "button"
				}, r.fbt._("Remove", null, {
					hk: "3tYl0U"
				})))),
				Xr = n("./src/reddit/controls/Input/index.tsx"),
				Zr = n("./src/reddit/components/RichTextEditor/LinksController/LinkEditorPopup/index.m.less"),
				$r = n.n(Zr);
			const es = C.a.form("EditForm", $r.a),
				ts = C.a.wrapped(e => m.a.createElement("div", e, e.children), "LinkEditorBox", $r.a),
				ns = C.a.wrapped(Xr.a, "Input", $r.a),
				os = C.a.label("Label", $r.a),
				rs = C.a.div("HintAndButtonRow", $r.a),
				ss = C.a.span("InvalidUrlHint", $r.a),
				is = C.a.wrapped(rt.l, "SubmitButton", $r.a),
				as = e => {
					e && (e.focus(), e.select())
				},
				cs = / /g,
				ds = /\.{3}/g,
				ls = e => e.replace(cs, "%20").replace(ds, "%2E%2E%2E");
			class us extends u.Component {
				constructor(e) {
					super(e), this.focused = !1, this.focusLostTimer = 0, this.textInputElementRef = null, this.urlInputElementRef = null, this.onEdited = () => {
						const e = this.state.url.trim(),
							t = ls(e),
							n = Object(Go.i)(t);
						if (!n) return this.setState({
							isInvalidUrl: !0
						}), void(this.urlInputElementRef && this.urlInputElementRef.focus());
						const o = n.url;
						this.props.onEdited(o, this.state.displayText.trim() || e)
					}, this.onFocus = () => {
						this.focused = !0
					}, this.onBlur = () => {
						this.focused = !1, this.focusLostTimer = window.setTimeout(() => {
							this.focused || this.props.onFocusLost()
						}, 0)
					}, this.onClick = e => {
						e.stopPropagation()
					}, this.handleUrlChange = e => {
						const t = e.target.value;
						let {
							isInvalidUrl: n
						} = this.state;
						n && Object(Go.h)(Go.f, t) && (n = !1), this.setState({
							url: t,
							isInvalidUrl: n
						})
					}, this.handleDisplayTextChange = e => {
						this.setState({
							displayText: e.target.value
						})
					}, this.handleSubmit = e => {
						this.onEdited(), e.preventDefault()
					}, this.state = {
						url: e.url,
						displayText: e.displayText,
						isInvalidUrl: !1
					}
				}
				componentDidMount() {
					Object(Go.h)(Go.f, this.state.displayText) ? as(this.textInputElementRef) : as(this.urlInputElementRef)
				}
				componentWillUnmount() {
					this.focusLostTimer && clearTimeout(this.focusLostTimer)
				}
				render() {
					const {
						isInsertMode: e
					} = this.props;
					return m.a.createElement(ts, {
						tabIndex: 0,
						onClick: this.onClick,
						onBlur: this.onBlur,
						onFocus: this.onFocus
					}, m.a.createElement(es, {
						onSubmit: this.handleSubmit
					}, m.a.createElement(os, null, r.fbt._("Text:", null, {
						hk: "13SRB5"
					}), m.a.createElement(ns, {
						innerRef: e => this.textInputElementRef = e,
						type: "text",
						placeholder: r.fbt._("Title of link (optional)", null, {
							hk: "17GvI"
						}),
						value: this.state.displayText,
						onChange: this.handleDisplayTextChange
					})), m.a.createElement(os, null, r.fbt._("Link:", null, {
						hk: "3XqufJ"
					}), m.a.createElement(ns, {
						innerRef: e => this.urlInputElementRef = e,
						type: "text",
						placeholder: r.fbt._("Paste or type a link", null, {
							hk: "3QWoAf"
						}),
						value: this.state.url,
						onChange: this.handleUrlChange
					})), m.a.createElement(rs, null, m.a.createElement(is, {
						type: "submit",
						disabled: this.state.isInvalidUrl
					}, e ? r.fbt._("Insert", null, {
						hk: "3H7yaS"
					}) : r.fbt._("Apply", null, {
						hk: "3mAjVQ"
					})), this.state.isInvalidUrl ? m.a.createElement(ss, null, r.fbt._("Link doesn't look right", null, {
						hk: "1BHfKz"
					})) : null)))
				}
			}

			function ms(e, t, n) {
				const o = e.getCurrentContent(),
					r = {
						text: "",
						url: ""
					};
				if (t.isCollapsed()) return r;
				if (n) r.text = n.entityText, r.url = o.getEntity(n.entityKey).getData().url;
				else {
					r.text = function(e, t) {
						if (e.getStartKey() !== e.getEndKey()) throw new Error("Selection must be in a single block");
						return e.isCollapsed() ? "" : t.getBlockForKey(e.getStartKey()).getText().slice(e.getStartOffset(), e.getEndOffset())
					}(t, e.getCurrentContent());
					const n = Object(Go.h)(Go.f, r.text);
					n && (r.url = n.url)
				}
				return r
			}

			function ps(e, t) {
				return o.EditorState.set(e, {
					currentContent: o.Modifier.removeInlineStyle(e.getCurrentContent(), t, w.k.HIGHLIGHT)
				})
			}
			class hs extends u.Component {
				constructor(e) {
					super(e), this.api = null, this.updateTooltipPosition = null, this.lastEditorSelectionClientRect = null, this.editLinkInSelection = e => {
						const {
							editorState: t
						} = this.props;
						let n = e,
							r = t;
						const s = t.getCurrentContent();
						if (!Object(Ao.e)(s, e)) return !1;
						const i = Object(Gr.a)(s, e);
						if (i) {
							if (s.getEntity(i.entityKey).getType() !== B.a.LINK) return !1;
							n = i.entitySelection
						} else this.isEditorFocused() && (this.lastEditorSelectionClientRect = Object(Hr.a)());
						return this.state.linkSelection && (r = ps(t, this.state.linkSelection)), r = function(e, t) {
							return o.EditorState.set(e, {
								currentContent: o.Modifier.applyInlineStyle(e.getCurrentContent(), t, w.k.HIGHLIGHT)
							})
						}(t, n), this.props.onChange(r, () => {
							this.setState({
								linkSelection: n,
								linkEntity: i
							})
						}), !0
					}, this.hidePopup = () => {
						this.interruptLinkEditing(), this.hideDetailsPopup()
					}, this.showDetailsPopup = () => {
						this.state.isDetailsPopupActive || this.setState({
							isDetailsPopupActive: !0
						})
					}, this.hideDetailsPopup = () => {
						this.state.isDetailsPopupActive && this.setState({
							isDetailsPopupActive: !1
						})
					}, this.updatePosition = () => {
						if (!this.updateTooltipPosition) return;
						const {
							editorState: e,
							containerRef: t
						} = this.props, n = e.getCurrentContent();
						let o;
						if (this.state.linkSelection) {
							const e = Object(Gr.a)(n, this.state.linkSelection);
							if (e) {
								const t = this.props.entityElementRegistry.get(e.entityKey);
								o = t && t.getBoundingClientRect()
							} else this.lastEditorSelectionClientRect && (o = this.lastEditorSelectionClientRect)
						} else {
							const n = Object(Ao.c)(e);
							if (n) {
								const e = this.props.entityElementRegistry.get(n.entityKey);
								o = e && e.getBoundingClientRect()
							} else o = t && t.getBoundingClientRect()
						}
						o && (this.updateTooltipPosition({
							left: o.left,
							top: o.bottom
						}), this.lastEditorSelectionClientRect = null)
					}, this.handleLink = (e, t) => {
						const {
							linkSelection: n
						} = this.state, {
							editorState: r
						} = this.props;
						let s = r;
						n && (n.isCollapsed() || (s = ps(r, n)), void 0 !== e && (s = Object(Ao.h)(s, n, e, t)), this.setState({
							linkSelection: null,
							linkEntity: null
						}), s !== r && (s = o.EditorState.forceSelection(s, s.getSelection()), this.props.onChange(s)))
					}, this.onLinkEdited = (e, t) => {
						this.handleLink(e, t)
					}, this.interruptLinkEditing = () => this.handleLink(), this.isEditorFocused = () => this.props.editorState.getSelection().getHasFocus(), this.onStartEditFocusedLink = () => {
						const {
							editorState: e
						} = this.props, t = Object(Ao.c)(e);
						t && this.editLinkInSelection(t.entitySelection)
					}, this.onRemoveFocusedLink = () => {
						const {
							editorState: e
						} = this.props, t = Object(Ao.c)(e);
						t && this.props.onChange(Object(Ao.h)(e, t.entitySelection, ""))
					}, this.renderEditorPopup = () => {
						const {
							linkSelection: e,
							linkEntity: t
						} = this.state, {
							editorState: n
						} = this.props;
						if (!e) return null;
						const {
							text: o,
							url: r
						} = ms(n, e, t);
						return m.a.createElement(us, {
							url: r,
							displayText: o,
							isInsertMode: !t,
							onEdited: this.onLinkEdited,
							onFocusLost: this.interruptLinkEditing
						})
					}, this.renderDetailsPopup = () => {
						const e = Object(Ao.c)(this.props.editorState);
						return e && this.isEditorFocused() && this.state.isDetailsPopupActive ? m.a.createElement(Jr, {
							url: e.url,
							onStartEdit: this.onStartEditFocusedLink,
							onRemove: this.onRemoveFocusedLink
						}) : null
					}, this.state = {
						isDetailsPopupActive: !1,
						linkSelection: null,
						linkEntity: null
					}, this.api = {
						editLinkInSelection: this.editLinkInSelection,
						hidePopup: this.hidePopup
					}
				}
				componentDidMount() {
					const {
						onSetApi: e
					} = this.props;
					this.api && e && e(this.api)
				}
				componentWillUnmount() {
					this.props.onSetApi && this.props.onSetApi(null)
				}
				componentDidUpdate(e, t) {
					t.linkSelection === this.state.linkSelection && e.editorState === this.props.editorState || (this.showDetailsPopup(), this.updatePosition())
				}
				render() {
					return m.a.createElement(Bn.b, {
						onSetPositionUpdater: e => this.updateTooltipPosition = e,
						trianglePlacement: Bn.a.Above
					}, this.renderEditorPopup() || this.renderDetailsPopup())
				}
			}
			var bs = n("./src/reddit/components/RichTextEditor/OrderedList/index.m.less"),
				fs = n.n(bs);
			const gs = C.a.ol("OrderedListWrapper", fs.a),
				vs = Object(U.Map)({
					[w.i.ORDERED]: {
						element: "li",
						aliasedElements: ["li"],
						wrapper: m.a.createElement(gs, null)
					}
				});
			var Cs = n("./src/reddit/components/RichTextEditor/Paragraph/index.m.less"),
				ys = n.n(Cs);
			const Es = C.a.div("ParagraphWrapper", ys.a),
				xs = Object(U.Map)({
					[w.n]: {
						element: "div",
						aliasedElements: ["p"],
						wrapper: m.a.createElement(Es, null)
					}
				});
			var Os = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx");
			var _s = n("./src/reddit/components/RichTextEditor/TextRendering/index.m.less"),
				ks = n.n(_s);
			const js = Object(tr.a)(() => ({
					[w.k.SUPERSCRIPT]: {
						position: "relative",
						top: "-0.4em",
						fontSize: "0.7em",
						lineHeight: "0.7em"
					},
					[w.k.HIGHLIGHT]: {
						backgroundColor: "#b8e0f9"
					},
					[w.k.UNDERLINE]: {
						textDecoration: "none"
					},
					[w.k.MONOSPACE]: {
						backgroundColor: "var(--newRedditTheme-field)",
						caretColor: "#000",
						color: "var(--newRedditTheme-monospaceColor)",
						fontFamily: "Noto Mono, Menlo, Monaco, Consolas, monospace",
						padding: "0.1em 0.2em",
						fontSize: "0.8em",
						borderRadius: "3px"
					}
				})),
				Ss = C.a.div("H1", ks.a),
				Ts = C.a.div("H2", ks.a),
				ws = C.a.div("H3", ks.a),
				Is = C.a.div("H4", ks.a),
				Ps = C.a.div("H5", ks.a),
				Ns = C.a.div("H6", ks.a),
				Rs = e => ({
					component: t => m.a.createElement(e, null, m.a.createElement(o.EditorBlock, t)),
					editable: !0
				}),
				Ms = {
					[w.g.H1]: Rs(Ss),
					[w.g.H2]: Rs(Ts),
					[w.g.H3]: Rs(ws),
					[w.g.H4]: Rs(Is),
					[w.g.H5]: Rs(Ps),
					[w.g.H6]: Rs(Ns)
				},
				Ds = ["italic normal 1em 'Noto Sans'", "italic bold 1em 'Noto Sans'", "normal bold 1em 'Noto Sans'"],
				Ls = () => {
					const e = document.fonts;
					e && e.load && Ds.forEach(t => e.load(t))
				};
			var As = n("./src/reddit/components/RichTextEditor/UnorderedList/index.m.less"),
				Fs = n.n(As);
			const Bs = C.a.ul("UnorderedListWrapper", Fs.a),
				Us = Object(U.Map)({
					[w.i.UNORDERED]: {
						element: "li",
						aliasedElements: ["li"],
						wrapper: m.a.createElement(Bs, null)
					}
				});
			var Ks = n("./src/reddit/contexts/InsideOverlay.tsx"),
				Ws = n("./src/reddit/actions/subredditAutocomplete/index.ts"),
				Gs = n("./src/reddit/controls/SubredditDropdown/index.m.less"),
				Hs = n.n(Gs);

			function Vs() {
				return (Vs = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const zs = e => {
				let {
					isFocused: t,
					...n
				} = e;
				return m.a.createElement("div", Vs({
					className: Object(g.a)(Hs.a.entry, {
						[Hs.a.mIsFocused]: t
					})
				}, n))
			};
			class qs extends u.Component {
				constructor(e) {
					super(e), this.mouseDown = !1, this.onMouseUp = () => {
						this.mouseDown && (this.props.onEntrySelect(this.props.entry), this.mouseDown = !1)
					}, this.onMouseDown = e => {
						this.mouseDown = !0, e.preventDefault()
					}, this.onMouseOver = () => {
						this.props.onEntryFocus(this.props.entry)
					}, this.mouseDown = !1
				}
				componentDidUpdate() {
					this.mouseDown = !1
				}
				render() {
					return m.a.createElement(zs, {
						isFocused: this.props.isFocused,
						onMouseDown: this.onMouseDown,
						onMouseUp: this.onMouseUp,
						onMouseOver: this.onMouseOver
					}, this.props.children)
				}
			}
			var Qs = n("./src/reddit/helpers/name/index.ts"),
				Ys = n("./src/reddit/selectors/subredditAutocomplete.ts");
			const Js = Object(h.c)({
				subredditSuggestions: (e, t) => {
					const n = Object(Ys.d)(e, t);
					return n ? n.subreddits : []
				}
			});
			class Xs extends u.Component {
				constructor(e) {
					super(e), this.api = null, this.onEntrySelect = e => {
						this.props.onSelect(this.props.subredditSuggestions[e].name)
					}, this.onEntryFocus = e => {
						this.setState({
							selectedSuggestionIndex: e
						})
					}, this.moveUp = () => {
						if (this.props.subredditSuggestions.length > 1) {
							let e = this.state.selectedSuggestionIndex - 1;
							return e = e < 0 ? this.props.subredditSuggestions.length - 1 : e, this.setState({
								selectedSuggestionIndex: e
							}), !0
						}
						return !1
					}, this.moveDown = () => {
						if (this.props.subredditSuggestions.length > 1) {
							const e = (this.state.selectedSuggestionIndex + 1) % this.props.subredditSuggestions.length;
							return this.setState({
								selectedSuggestionIndex: e
							}), !0
						}
						return !1
					}, this.selectCurrent = () => {
						if (this.props.subredditSuggestions.length) {
							const e = this.props.subredditSuggestions[this.state.selectedSuggestionIndex];
							return e && this.props.onSelect(e.name), !0
						}
						return !1
					}, this.state = {
						selectedSuggestionIndex: 0
					}, this.requestSubredditAutocomplete = i()(this.requestSubredditAutocomplete.bind(this), 200, {
						maxWait: 200
					}), this.api = {
						moveUp: this.moveUp,
						moveDown: this.moveDown,
						selectCurrent: this.selectCurrent
					}
				}
				componentDidMount() {
					this.requestSubredditAutocomplete(this.props.substring), this.props.onDropdownApi(this.api)
				}
				componentWillUnmount() {
					this.props.onDropdownApi(null)
				}
				componentWillReceiveProps(e) {
					e.substring !== this.props.substring && (this.requestSubredditAutocomplete(e.substring), this.setState({
						selectedSuggestionIndex: 0
					}))
				}
				requestSubredditAutocomplete(e) {
					this.props.onGetSubredditAutocomplete(e)
				}
				render() {
					return this.props.subredditSuggestions.length ? m.a.createElement("div", {
						className: Object(g.a)(Hs.a.list, this.props.className)
					}, this.props.subredditSuggestions.map((e, t) => m.a.createElement(qs, {
						entry: t,
						isFocused: t === this.state.selectedSuggestionIndex,
						key: e.name,
						onEntrySelect: this.onEntrySelect,
						onEntryFocus: this.onEntryFocus
					}, Object(Qs.d)(e.name)))) : null
				}
			}
			var Zs = Object(p.b)(Js, (e, t) => ({
					onGetSubredditAutocomplete: t => {
						e(Ws.a(t))
					}
				}))(Xs),
				$s = n("./src/reddit/selectors/comments.ts");
			const ei = Object(h.c)({
				commentAuthors: $s.h
			});
			class ti extends u.Component {
				constructor(e) {
					super(e), this.api = null, this.onEntrySelect = e => {
						this.props.onSelect(this.state.userSuggestions[e])
					}, this.onEntryFocus = e => {
						this.setState({
							selectedSuggestionIndex: e
						})
					}, this.moveUp = () => {
						if (this.state.userSuggestions.length > 1) {
							let e = this.state.selectedSuggestionIndex - 1;
							return e = e < 0 ? this.state.userSuggestions.length - 1 : e, this.setState({
								selectedSuggestionIndex: e
							}), !0
						}
						return !1
					}, this.moveDown = () => {
						if (this.state.userSuggestions.length > 1) {
							const e = (this.state.selectedSuggestionIndex + 1) % this.state.userSuggestions.length;
							return this.setState({
								selectedSuggestionIndex: e
							}), !0
						}
						return !1
					}, this.selectCurrent = () => {
						if (this.state.userSuggestions.length) {
							const e = this.state.userSuggestions[this.state.selectedSuggestionIndex];
							return e && this.props.onSelect(e), !0
						}
						return !1
					}, this.state = {
						userSuggestions: [],
						selectedSuggestionIndex: 0
					}, this.api = {
						moveUp: this.moveUp,
						moveDown: this.moveDown,
						selectCurrent: this.selectCurrent
					}
				}
				componentDidMount() {
					this.props.onDropdownApi(this.api), this.setState({
						userSuggestions: this.filterUsers(this.props.substring)
					})
				}
				componentWillUnmount() {
					this.props.onDropdownApi(null)
				}
				componentWillReceiveProps(e) {
					e.substring !== this.props.substring && this.setState({
						selectedSuggestionIndex: 0,
						userSuggestions: this.filterUsers(e.substring)
					})
				}
				filterUsers(e) {
					const {
						commentAuthors: t
					} = this.props;
					return t.filter(t => t.toLowerCase().startsWith(e.toLowerCase()))
				}
				render() {
					return this.state.userSuggestions.length ? m.a.createElement("div", {
						className: Object(g.a)(Hs.a.list, this.props.className)
					}, this.state.userSuggestions.map((e, t) => m.a.createElement(qs, {
						key: t,
						entry: t,
						onEntryFocus: this.onEntryFocus,
						onEntrySelect: this.onEntrySelect,
						isFocused: t === this.state.selectedSuggestionIndex
					}, Object(Qs.e)(e)))) : null
				}
			}
			var ni = Object(p.b)(ei)(ti),
				oi = n("./node_modules/lodash/dropRightWhile.js"),
				ri = n.n(oi),
				si = n("./node_modules/lodash/flatMap.js"),
				ii = n.n(si),
				ai = n("./node_modules/lodash/reduceRight.js"),
				ci = n.n(ai),
				di = n("./node_modules/lodash/trimEnd.js"),
				li = n.n(di),
				ui = n("./node_modules/lodash/trimStart.js"),
				mi = n.n(ui),
				pi = n("./src/lib/forEachGroup/index.ts");

			function hi(e, t) {
				const n = [],
					o = e.withMutations(e => {
						for (; e.size && t(e.first());) n.push(e.first()), e.shift()
					});
				return {
					popped: n,
					stack: o
				}
			}
			var bi = n("./src/lib/unicodeUtils/index.ts"),
				fi = n("./src/reddit/helpers/richTextJson/index.ts"),
				gi = n("./src/reddit/models/RichTextJson/nodeMakers.ts");
			const vi = {
				BOLD: Vn.k.bold,
				ITALIC: Vn.k.italic,
				MONOSPACE: Vn.k.monospace,
				STRIKETHROUGH: Vn.k.strikethrough,
				SUBSCRIPT: Vn.k.subscript,
				SUPERSCRIPT: Vn.k.superscript,
				UNDERLINE: Vn.k.underline
			};
			var Ci = (e, t) => yi(e.getBlockMap(), e, t);
			const yi = (e, t, n) => {
					const o = [];
					let r = e.toStack();
					for (; r.size;) {
						const e = r.first(),
							s = e.getType();
						switch (r = r.shift(), s) {
							case w.g.H1:
							case w.g.H2:
							case w.g.H3:
							case w.g.H4:
							case w.g.H5:
							case w.g.H6:
								o.push(ji(e, t));
								break;
							case w.e: {
								const {
									popped: n,
									stack: s
								} = hi(r, e => e.getType() === w.e);
								r = s, o.push(Si([e, ...n], t));
								break
							}
							case w.f: {
								const {
									popped: t,
									stack: n
								} = hi(r, e => e.getType() === w.f);
								r = n, o.push(Ti([e, ...t]));
								break
							}
							case w.i.ORDERED:
							case w.i.UNORDERED: {
								const {
									popped: n,
									stack: i
								} = hi(r, e => e.getType() === s);
								r = i, o.push(wi([e, ...n], t));
								break
							}
							case w.l: {
								const {
									popped: n,
									stack: s
								} = hi(r, e => Object(w.v)(e.getType()));
								r = s, o.push(Ii([e, ...n], t));
								break
							}
							case w.a: {
								let t = r.first();
								t && Object(w.u)(t.getType()) ? r = r.shift() : t = void 0, o.push(Pi(e, t, n));
								break
							}
							case w.n:
							default:
								o.push(_i(e, t))
						}
					}
					return o
				},
				Ei = e => e.reduce((e, t) => t === w.k.UNDERLINE || t === w.k.SUBSCRIPT ? e : e | (vi[t] || 0) | 0, 0),
				xi = (e, t) => {
					const n = [],
						o = Object(bi.b)(e);
					return Object(pi.a)(t, {
						keyFn: e => e.getStyle()
					}, (t, r, s, i) => {
						if (r.isEmpty()) return;
						const a = e.slice(s, i),
							c = s + (a.length - mi()(a).length),
							d = i - (a.length - li()(a).length),
							l = d - c,
							u = o[c],
							m = o[d] - u;
						l > 0 && n.push([Ei(r), u, m])
					}), n.length ? n : null
				},
				Oi = (e, t) => {
					const n = e.getText(),
						o = e.getCharacterList(),
						r = [],
						s = w.d.includes(e.getType()),
						i = w.c.includes(e.getType());
					let a = 0;
					return Object(pi.a)(o, {
						keyFn: (e, o) => {
							const r = e.getEntity();
							return s && e.getStyle().contains(w.k.SPOILER) ? "spoiler" : Object(B.b)(r, t) ? `link-${e.getEntity()}` : "\n" === n[o] ? i ? "linebreak" : "skip" : r && t.getEntity(r).getType() === B.a.EMOTE ? `emote-${a++}` : "text"
						}
					}, (e, s, i, a) => {
						const c = n.slice(i, a),
							d = o.slice(i, a).toList();
						if ("text" === s) {
							const e = xi(c, d);
							r.push(Object(gi.s)(c, e))
						} else if ("spoiler" === s) r.push(Object(gi.n)(c));
						else if (s.startsWith("link-")) {
							const n = t.getEntity(e.getEntity());
							r.push(((e, t, n) => {
								const o = e.getType(),
									r = [B.a.USER_LINK, B.a.USER_MENTION],
									{
										url: s
									} = e.getData(),
									i = t.startsWith("/");
								if (o === B.a.SUBREDDIT_LINK) {
									const e = t.replace(y.e, "");
									return Object(gi.o)(e, i)
								}
								if (r.includes(o)) {
									const e = t.replace(y.a, "");
									return Object(gi.t)(e, i)
								}
								const a = xi(t, n);
								return Object(gi.i)(t, s, a)
							})(n, c, d))
						} else if ("linebreak" === s) r.push(Object(gi.h)());
						else if (s.startsWith("emote-")) {
							const n = t.getEntity(e.getEntity()).getData();
							r.push(Object(gi.e)(n.fullId, n.imageType))
						}
					}), r
				},
				_i = (e, t) => Object(gi.l)(Oi(e, t)),
				ki = e => "text" === e.e ? Object(gi.m)(e.t) : "link" === e.e ? Object(gi.i)(e.t, e.u, null) : e.e === Vn.z ? e.c.map(ki) : e.e === Vn.o ? Object(gi.m)("") : e,
				ji = (e, t) => Object(gi.f)(w.m[e.getType()], ((e, t) => ci()(ii()(Oi(e, t), ki), (e, t) => {
					let [n, ...o] = e;
					if (!n) return [t];
					const r = o.length ? o : [];
					return n && "raw" === t.e && "raw" === n.e ? [Object(gi.m)(t.t + n.t), ...r] : [t, n, ...r]
				}, []))(e, t)),
				Si = (e, t) => Object(gi.c)(ri()(e.map(e => ((e, t) => e.getText().trim().length ? _i(e, t) : gi.a)(e, t)), e => e === gi.a)),
				Ti = e => Object(gi.d)(e.map(e => Object(gi.m)(e.getText()))),
				wi = (e, t) => {
					if (!e.length) return Object(gi.k)([], !1);
					const n = e[0].getDepth();
					let o = null;
					const r = [];
					let s = [];
					const i = () => null !== o || s.length,
						a = () => {
							const e = [];
							null !== o && (e.push(o), o = null), s.length && (e.push(wi(s, t)), s = []), r.push(Object(gi.j)(e))
						};
					return e.forEach(e => {
						e.getDepth() > n ? s.push(e) : (i() && a(), o = Object(gi.l)(Oi(e, t)))
					}), i() && a(), Object(gi.k)(r, e[0].getType() === w.i.ORDERED)
				},
				Ii = (e, t) => {
					const n = [...e].sort(Y.b),
						o = n[0],
						{
							colCount: r
						} = Object(Y.g)(o),
						s = G()(n, r),
						i = s[0].map(e => {
							const {
								alignment: n
							} = Object(Y.g)(e);
							return Object(gi.q)(Oi(e, t), n)
						}),
						a = s.slice(1).map(e => e.map(e => Object(gi.p)(Oi(e, t))));
					return Object(gi.r)(i, a)
				},
				Pi = (e, t, n) => {
					const o = Object(A.h)(e);
					if (!o) throw new Error("Invalid atomic block!");
					const {
						uploadInfo: r,
						mediaAsset: s,
						makeGif: i
					} = o, a = t ? t.getText() : "";
					if (r && n) {
						const e = n[r.uploadKey],
							t = e && e.metadata.mimetype || "",
							{
								assetId: s,
								thumbnailAssetId: c
							} = Object(A.f)(o, n);
						return Object(We.l)(t) ? Object(gi.b)(s, a) : Object(We.m)(t) ? Object(gi.g)(s, a) : Object(gi.u)(s, a, c, i)
					} {
						const {
							assetId: e,
							type: t
						} = s;
						let n;
						switch (t) {
							case A.a.AnimatedImage:
								n = Object(gi.b)(e, a);
								break;
							case A.a.Image:
								n = Object(gi.g)(e, a);
								break;
							case A.a.Video:
								n = Object(gi.u)(e, a);
								break;
							default:
								throw new Error("Invalid media type")
						}
						return Object(fi.h)(e) ? Object(gi.l)([n]) : n
					}
				};
			var Ni, Ri = n("./src/reddit/constants/componentSizes.ts"),
				Mi = n("./src/reddit/constants/elementIds.ts");
			! function(e) {
				e.Up = "up", e.Down = "down"
			}(Ni || (Ni = {}));
			var Di = e => {
					const t = window.getSelection().focusNode;
					if (!t || !t.parentElement) return;
					const n = document.getElementById(Mi.e),
						o = n || document.documentElement;
					if (!o) return;
					const r = window.innerHeight,
						{
							bottom: s,
							top: i
						} = t.parentElement.getBoundingClientRect(),
						a = n ? 0 : Ri.f + Ri.o;
					e === Ni.Up && i < a ? o.scrollBy(0, i - a) : e === Ni.Down && s > r && o.scrollBy(0, s - r)
				},
				Li = n("./src/reddit/models/Product/index.ts"),
				Ai = (e, t, n) => {
					const o = {
						url: n
					};
					return e.createEntity(t, "MUTABLE", o)
				},
				Fi = n("./node_modules/lodash/maxBy.js"),
				Bi = n.n(Fi);
			const Ui = (e, t) => {
				if (!t) return (e => {
					const t = e.id;
					switch (e.e) {
						case Vn.n:
							return {
								assetId: t, type: A.a.Image
							};
						case Vn.a:
							return {
								assetId: t, type: A.a.AnimatedImage
							};
						case Vn.F:
							return {
								assetId: t, type: A.a.Video
							}
					}
				})(e);
				const n = t.id;
				switch (t.e) {
					case Vn.t: {
						const {
							s: e
						} = t;
						return {
							assetId: n,
							type: A.a.Image,
							imageUrl: e.u,
							width: e.x,
							height: e.y
						}
					}
					case Vn.s: {
						const {
							s: e
						} = t;
						return {
							assetId: n,
							type: A.a.AnimatedImage,
							imageUrl: e.gif,
							posterUrl: e.p,
							dashUrl: e.mp4,
							width: e.x,
							height: e.y
						}
					}
					case Vn.u: {
						const {
							isGif: e,
							dashUrl: o,
							hlsUrl: r,
							p: s,
							x: i,
							y: a
						} = t;
						let c;
						if (s) {
							c = Bi()(s, e => e.x).u
						}
						return {
							assetId: n,
							type: A.a.Video,
							isGif: e,
							dashUrl: o,
							hlsUrl: r,
							posterUrl: c,
							width: i,
							height: a
						}
					}
				}
			};

			function Ki(e, t, n) {
				const r = e.id,
					s = e.c,
					i = Vn.G(t, r),
					a = Ui(e, i),
					c = [new o.ContentBlock({
						key: Object(o.genKey)(),
						type: w.a,
						data: Object(U.Map)({
							mediaAsset: a
						})
					})];
				if (n) {
					const e = Object(F.h)(Object(o.genKey)(), s).merge({
						type: w.j
					});
					c.push(e)
				}
				return c
			}
			const Wi = Object.keys(vi),
				Gi = (e, t, n) => {
					switch (t.e) {
						case Vn.w:
							return Yi(e, t.c, w.b.UNSTYLED, n);
						case Vn.l:
							const o = w.h[t.l];
							return Yi(e, t.c || [], o, n);
						case Vn.q:
							return zi(e, t, n);
						case Vn.b:
							return Hi(e, t, n);
						case Vn.c:
							return void t.c.forEach(t => Yi(e, [t], w.b.CODE_BLOCK, n));
						case Vn.B:
							return Vi(e, t, n);
						case Vn.n:
						case Vn.a:
						case Vn.F:
							return void e.blocks.push(...Ki(t, n.mediaMetadataMap, Object(A.q)(n.editorType)))
					}
				},
				Hi = (e, t, n) => {
					t && t.c && t.c.length && t.c.forEach(t => t.e === Vn.w ? Yi(e, t.c, w.b.BLOCK_QUOTE, n) : Gi(e, t, n))
				},
				Vi = (e, t, n) => {
					const {
						h: o,
						c: r
					} = t, s = o.length;
					[o, ...r].forEach((t, r) => t.forEach((t, i) => {
						const {
							c: a = []
						} = t, {
							a: c
						} = o[i], d = {
							alignment: c,
							colCount: s,
							colIndex: i,
							rowIndex: r
						};
						Yi(e, a, w.b.TABLE_CELL, n, d)
					}))
				},
				zi = function(e, t, n) {
					let o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
					const r = t.o ? w.b.ORDERED_LIST : w.b.UNORDERED_LIST;
					t.c.forEach(t => {
						const s = t.c;
						if (!s || !s.length) return;
						const [i, a] = s, c = i.e === Vn.w ? i.c : [];
						Yi(e, c, r, n, void 0, o), a && a.e === Vn.q && zi(e, a, n, o + 1)
					})
				},
				qi = {
					[Vn.A]: ["r/", "/r/"],
					[Vn.D]: ["u/", "/user/"],
					[Vn.E]: ["u/", "/user/"],
					[Vn.x]: ["p/", ""],
					[Vn.g]: ["c/", ""]
				},
				Qi = {
					[Vn.A]: B.a.SUBREDDIT_LINK,
					[Vn.D]: B.a.USER_LINK,
					[Vn.E]: B.a.USER_MENTION,
					[Vn.x]: B.a.POST_LINK,
					[Vn.g]: B.a.COMMENT_LINK
				},
				Yi = function(e, t, n, r) {
					let s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {},
						i = arguments.length > 5 ? arguments[5] : void 0,
						a = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
					const c = e.content;
					if (1 === t.length && (t[0].e === Vn.n || t[0].e === Vn.a)) {
						const n = t[0];
						if (Object(fi.h)(n.id)) return void e.blocks.push(...Ki(n, r.mediaMetadataMap, Object(A.q)(r.editorType)))
					}
					const {
						charList: d,
						text: l,
						updatedContent: u
					} = Ji(t, c, r), m = new o.ContentBlock({
						key: Object(o.genKey)(),
						characterList: Object(U.List)(d),
						data: Object(U.fromJS)(s),
						depth: i,
						text: l,
						type: n
					});
					e.content = u || c, a ? e.blocks.unshift(m) : e.blocks.push(m)
				},
				Ji = (e, t, n) => {
					let o = t,
						r = "";
					const s = [];
					if (e.forEach(e => {
							const t = Xi(e, o, n);
							o = t.updatedContent || o, r += t.text, s.push(...t.charList)
						}), r.length !== s.length) throw new Error("Characters length mismatch!");
					return {
						charList: s,
						text: r,
						updatedContent: o !== t ? o : void 0
					}
				},
				Xi = (e, t, n) => {
					switch (e.e) {
						case Vn.C: {
							const {
								t,
								f: n
							} = e;
							return {
								charList: $i(t, n),
								text: t
							}
						}
						case Vn.z: {
							const {
								c: r
							} = e, s = Ji(r, t, n);
							return s.charList = s.charList.map(e => (e => o.CharacterMetadata.create({
								style: e.getStyle().add(w.k.SPOILER),
								entity: e.getEntity()
							}))(e)), s
						}
						case Vn.x:
						case Vn.g:
						case Vn.y: {
							const {
								t
							} = e;
							return {
								charList: $i(t),
								text: t
							}
						}
						case Vn.A:
						case Vn.D:
						case Vn.E: {
							const [n, o] = qi[e.e], r = (e.l ? "/" : "") + n + e.t, s = o + e.t, i = Ai(t, Qi[e.e], s), a = i.getLastCreatedEntityKey();
							return {
								charList: $i(r, void 0, a),
								text: r,
								updatedContent: i
							}
						}
						case Vn.p: {
							const {
								t: n,
								u: o,
								f: r
							} = e, s = Ai(t, B.a.LINK, o), i = s.getLastCreatedEntityKey();
							return {
								charList: $i(n, r, i),
								text: n,
								updatedContent: s
							}
						}
						case Vn.n:
						case Vn.a:
							const {
								id: r
							} = e;
							if (r.startsWith("emote|")) {
								const e = Object(Li.b)(r),
									o = n.activeEmotes && n.activeEmotes[e];
								if (o) {
									const e = Object(ko.c)(t, o),
										n = e.getLastCreatedEntityKey(),
										r = ko.a;
									return {
										charList: $i(r, void 0, n),
										text: r,
										updatedContent: e
									}
								}
								const s = `:${e}:`;
								return {
									charList: $i(s),
									text: s
								}
							}
							return {
								text: "", charList: $i("")
							};
						default:
							return {
								text: "", charList: $i("")
							}
					}
				},
				Zi = e => {
					const t = Wi.filter(t => !!(vi[t] & e));
					return Object(U.OrderedSet)(t)
				},
				$i = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
					const r = o.CharacterMetadata.create({
							entity: n
						}),
						s = Array(e.length).fill(r),
						i = Object(bi.a)(e);
					return t && t.forEach(e => {
						const [t, r, a] = e, c = Zi(t), d = r + a, l = o.CharacterMetadata.create({
							entity: n,
							style: c
						});
						s.fill(l, i[r], i[d])
					}), s
				},
				ea = (e, t) => {
					e.blocks.length && (e.blocks[0].getType() === w.b.TABLE_CELL && Yi(e, [], w.b.UNSTYLED, t, void 0, void 0, !0), e.blocks[e.blocks.length - 1].getType() === w.b.TABLE_CELL && Yi(e, [], w.b.UNSTYLED, t))
				};
			var ta = (e, t, n, r) => {
					const s = "string" == typeof e ? JSON.parse(e) : e;
					if (!s || !s.document || !s.document.length) return null;
					const i = {
							editorType: t,
							mediaMetadataMap: n,
							activeEmotes: r ? r.reduce((e, t) => ({
								...e,
								...t.emotes
							}), {}) : void 0
						},
						a = {
							blocks: [],
							content: o.ContentState.createFromText("")
						};
					s.document.forEach(e => {
						Gi(a, e, i)
					}), 0 === a.blocks.length && Yi(a, [], w.b.UNSTYLED, i), ea(a, i);
					const c = o.BlockMapBuilder.createFromArray(a.blocks),
						d = o.SelectionState.createEmpty(c.first().getKey());
					return a.content.merge({
						blockMap: c,
						selectionBefore: d,
						selectionAfter: d
					})
				},
				na = n("./src/reddit/components/UserIcon/CurrentUserIcon.tsx"),
				oa = n("./src/reddit/components/UsersCountIndicator/constants.ts"),
				ra = n("./src/reddit/constants/elementClassNames.ts"),
				sa = n("./src/reddit/constants/keycodes.ts"),
				ia = n("./src/reddit/helpers/correlationIdTracker.ts"),
				aa = n("./src/reddit/icons/svgs/Send/index.tsx"),
				ca = n("./src/reddit/selectors/economics.ts"),
				da = n("./src/reddit/components/RichTextEditor/index.m.less"),
				la = n.n(da);

			function ua() {
				return (ua = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			Object(Os.b)({
				draftToRTFJson: Ci,
				getMediaCount: A.g,
				getPendingThumbnailUploads: A.i,
				isAllMediaUploaded: A.m
			});
			const ma = "handled",
				pa = "not-handled",
				ha = /^\s*$/,
				ba = 20,
				fa = C.a.wrapped(mr.a, "FocusableContent", la.a),
				ga = C.a.div("Container", la.a),
				va = C.a.wrapped(na.a, "CurrentUserIcon", la.a),
				Ca = e => `${k.b}-${e}`,
				ya = Object(p.b)(() => {
					const e = (() => Object(h.a)(e => e.uploads, (e, t) => t.rteState.editorKey, (e, t) => c()(e, e => e.key.startsWith(Ca(t)))))();
					return Object(h.c)({
						editorUploads: e,
						emotesSpecialMembershipEnabled: j.d.spEmotes,
						giphySpecialMembershipEnabled: j.d.spGiphy,
						activeEmotes: (e, t) => {
							var n;
							return Object(ca.b)(e, {
								subredditId: null === (n = t.destSubreddit) || void 0 === n ? void 0 : n.id
							})
						},
						shouldShowCommentGifsTooltip: (e, t) => {
							var n;
							return Object(Io.c)(e, {
								subredditId: null === (n = t.destSubreddit) || void 0 === n ? void 0 : n.id
							})
						}
					})
				}, e => ({
					onFetchEditorProducts: t => e(Object(_.e)(t)),
					onTrackMediaDrop: t => e((e, n) => S.t(n(), t)),
					retryUpload: (t, n) => e(k.c(t, n)),
					startUploads: (t, n, o, r, s, i) => e(k.e(t, n, Ca(o), r, s, i))
				}));
			class Ea extends u.Component {
				constructor(e) {
					super(e), this.blockRenderMap = o.DefaultDraftBlockRenderMap.merge(fr, Cr, Ln, vs, xs, Us, ln), this.editorHeight = null, this.editorRef = null, this.editorRootStyleMutationObserver = null, this.linksControllerApi = null, this.suggestionDropdownApi = null, this.tableToolbarControllerApi = null, this.emotesTooltipApi = null, this.gifTooltipApi = null, this.updateSuggestionDropdownPosition = null, this.isJustAutocompleteSelected = !1, this.isJustLinkified = !1, this.isMouseDown = !1, this.isJustConvertedToList = !1, this.needSyncScroll = null, this.transforms = {
						[I.BREAK_HEADER_ENTITY]: yo.b,
						[I.INSERT_LINE_BREAK]: yo.e,
						[I.REDUCE_LIST_INDENT]: yo.f,
						[I.RESET_CURRENT_AND_PREVIOUS_BLOCKS]: yo.g,
						[I.REMOVE_EXTRA_LIST_ITEM]: yo.h,
						[M.d]: e => $o(e, this.props.editorType),
						[M.b]: e => Zo(e, this.props.editorType),
						[M.f]: yo.d,
						[M.c]: e => Object(yo.c)(w.k.BOLD, e),
						[M.e]: e => Object(yo.c)(w.k.ITALIC, e),
						[M.g]: e => Object(yo.c)(w.k.UNDERLINE, e)
					}, this.realtimeGQLVariables = void 0, this.setContainerRef = e => {
						const {
							domRef: t
						} = this.props;
						t && t(e), this.setState({
							containerRef: e
						})
					}, this.setFocusableContentRef = e => this.setState({
						focusableContentRef: e
					}), this.setUserStoppedTyping = i()(() => this.setState({
						isUserTyping: !1
					}), oa.c), this.rteStateChanged = (e, t) => {
						const n = {
							...this.props.rteState,
							isBound: !0,
							editorState: e
						};
						this.props.onChange(n, t), this.props.isTypingIndicatorsWriteTestEnabled && t && (this.state.isUserTyping || this.setState({
							isUserTyping: !0
						}), this.setUserStoppedTyping())
					}, this.hideTooltips = () => {
						this.emotesTooltipApi && this.emotesTooltipApi.closeTooltip(), this.gifTooltipApi && this.gifTooltipApi.closeTooltip(), this.tableToolbarControllerApi && this.tableToolbarControllerApi.hideActionButton(), this.linksControllerApi && this.linksControllerApi.hidePopup(), this.suppressAutocompleteForFocusedLink()
					}, this.onEditorStyleChanged = () => {
						if (!this.editorRef) return;
						const e = this.editorRef.refs.editor,
							t = e.style.height ? Number.parseInt(e.style.height) : null;
						this.editorHeight !== t && (this.hideTooltips(), this.editorHeight = t, t && this.props.onEditorResize && this.props.onEditorResize(t))
					}, this.insertValidatedMedia = () => {
						const {
							editorUploads: e,
							shouldOmitImageCaptionBlock: t
						} = this.props, {
							editorState: n,
							mediaToInsert: o
						} = this.state;
						if (!o) return;
						const {
							files: r,
							blockKey: s,
							insertionMode: i
						} = o, a = r.map(t => e.find(e => e.file === t)).filter(Boolean);
						this.setState({
							mediaToInsert: null
						});
						const c = a.filter(e => !!e.metadata.mimetype);
						c.length && this.onChange(Object(A.l)(n, c, s, i, t))
					}, this.focus = () => this.editorRef && this.editorRef.focus(), this.blur = () => this.editorRef && this.editorRef.blur(), this.isFocused = () => this.state.editorState.getSelection().getHasFocus(), this.isEmpty = () => !this.state.editorState.getCurrentContent().hasText(), this.setEditorRef = e => this.editorRef = e, this.setSuggestionDropdownApi = e => this.suggestionDropdownApi = e, this.setLinksControllerApi = e => this.linksControllerApi = e, this.setTableToolbarControllerApi = e => this.tableToolbarControllerApi = e, this.setEmotesTooltipApi = e => this.emotesTooltipApi = e, this.setGifTooltipApi = e => this.gifTooltipApi = e, this.setSuggestionDropdownPositionUpdater = e => this.updateSuggestionDropdownPosition = e, this.getEditorState = () => this.state.editorState, this.setEditorState = (e, t) => {
						const n = this.state.editorState.getCurrentContent() !== e.getCurrentContent();
						n && this.props.readOnly || (this.setState({
							editorState: e
						}, t), this.rteStateChanged(e, n))
					}, this.toolbarSetState = e => {
						const t = e.getInlineStyleOverride();
						let n = e;
						n.getSelection().getHasFocus() || (n = o.EditorState.forceSelection(n, n.getSelection()), t && (n = o.EditorState.setInlineStyleOverride(n, t))), this.onChange(n)
					}, this.onChange = (e, t) => {
						let n = e;
						n = _n(n, this.state.editorState), n = Ae(n, this.props.editorType), this.emotesTooltipApi && (n = Object(ko.d)(n, this.state.editorState)), n = zo(n, this.state.editorState), n = Object(rr.d)(n, this.state.editorState), this.setEditorState(n, t);
						let {
							suppressAutocompleteForLink: o
						} = this.state;
						if (o) {
							const t = Object(Ao.b)(e);
							t && t.entityKey === o || (o = null)
						}
						this.setState({
							suppressAutocompleteForLink: o
						}), this.isJustAutocompleteSelected = !1, this.isJustLinkified = !1, this.isMouseDown = !1, this.isJustConvertedToList = !1
					}, this.onFocus = () => {
						const {
							onFocus: e
						} = this.props;
						this.emotesTooltipApi && this.emotesTooltipApi.closeTooltip(), this.gifTooltipApi && this.gifTooltipApi.closeTooltip(), e && (Object(ia.d)(ia.a.CommentComposer, !1), e())
					}, this.handleBeforeInput = e => {
						const {
							editorState: t
						} = this.state;
						if (this.isMouseDown) return ma;
						if (Le(t, e)) return ma;
						let n = function(e, t) {
							const n = e.getSelection(),
								r = n.getFocusOffset();
							if (!n.isCollapsed() || 0 === r) return;
							const s = n.getFocusKey(),
								i = e.getCurrentContent(),
								a = i.getBlockForKey(s),
								c = a.getEntityAt(r - 1),
								d = a.getEntityAt(r);
							if (!(c && (!d || d !== c))) return;
							const l = i.getEntity(c),
								u = Lo.has(l.getType());
							if ("MUTABLE" === l.getMutability() && u) {
								const r = o.Modifier.insertText(i, n, t, e.getCurrentInlineStyle());
								return o.EditorState.push(e, r, "insert-characters")
							}
						}(t, e) || t;
						return (n = yn(n, e) || n) !== t ? (this.onChange(n), ma) : pa
					}, this.keyBindingFN = e => {
						const {
							editorState: t
						} = this.state, {
							submitOnEnter: n
						} = this.props, r = t.getSelection();
						if (e.metaKey && e.keyCode === sa.a.K) return I.OPEN_LINK_TOOLTIP;
						if (e.keyCode === sa.a.Space) {
							if (nr(t)) return I.CONVERT_TO_LIST_ON_SPACE;
							if (Object(Ao.d)(t)) return I.LINKIFY_ON_SPACE
						} else if (e.keyCode === sa.a.Enter) {
							if (e.ctrlKey || e.metaKey || n && !e.shiftKey) return I.SUBMIT;
							if (e.shiftKey && er(t)) return I.INSERT_LINE_BREAK; {
								const e = this.enterKeyBinding(t);
								if (e) return e
							}
						} else if (e.keyCode === sa.a.Backspace) {
							if (this.isJustLinkified || this.isJustConvertedToList) return M.h;
							if (r.isCollapsed()) {
								const e = t.getCurrentContent(),
									n = r.getEndKey(),
									o = r.getStartOffset(),
									s = e.getBlockForKey(n),
									i = s.getType();
								if ((Object(w.s)(i) || Object(w.q)(i) || Object(w.p)(i)) && 0 === o && s.getLength() > 0) {
									const t = e.getBlockBefore(n);
									if (!t || t.getType() !== i) return I.MAKE_PLAIN_BLOCK
								}
							}
						}
						return Object(o.getDefaultKeyBinding)(e)
					}, this.handleKeyCommand = e => {
						const {
							editorState: t
						} = this.state;
						let n = e,
							r = null;
						const s = e => {
							let t = e;
							if (r) {
								const {
									selection: e,
									url: n
								} = r;
								t = Object(Ao.f)(t, e, n)
							}
							return this.onChange(t), this.isJustLinkified = !!r, ma
						};
						if (n === I.SUBMIT) this.props.onSubmit();
						else {
							if (n === I.CONVERT_TO_LIST_ON_SPACE) {
								const e = s(or(t));
								return this.isJustConvertedToList = !0, e
							}
							if (n === I.LINKIFY_ON_SPACE) return r = Object(Ao.d)(t), s(Object(yo.a)(t));
							if (n === I.LINKIFY_ON_ENTER && (r = Object(Ao.d)(t), !(n = this.enterKeyBinding(t, !1)))) return s(Object(yo.d)(t))
						}
						if (n === I.OPEN_LINK_TOOLTIP) return this.onToolbarLinkButtonClick(), ma;
						if (n === I.MAKE_PLAIN_BLOCK) {
							return s(Object(yo.i)(w.n, t))
						}
						if (n === I.EXEC_TABLE_ON_ENTER_HANDLER) return s(this.tableOnEnterHandler.handle(t));
						const i = this.transforms[n];
						if (i) {
							const e = i(t);
							if (e) return s(e)
						}
						const a = o.RichUtils.handleKeyCommand(t, n);
						return a ? s(a) : pa
					}, this.handleOnTab = e => {
						if (this.emotesTooltipApi && this.emotesTooltipApi.handleTabInEditor() || this.suggestionDropdownApi && this.suggestionDropdownApi.selectCurrent()) return void e.preventDefault();
						const {
							editorState: t
						} = this.state;
						let n = fn(e, t);
						if (n = n || Xo(e, t)) return void this.onChange(n);
						const r = o.RichUtils.onTab(e, t, 2);
						this.onChange(r)
					}, this.handleOnUpArrow = e => {
						if (this.emotesTooltipApi && this.emotesTooltipApi.handleUpArrowInEditor() || this.suggestionDropdownApi && this.suggestionDropdownApi.moveUp()) return void e.preventDefault();
						const t = gn(e, this.state.editorState) || Me(e, this.state.editorState);
						t && this.onChange(t), this.needSyncScroll = Ni.Up
					}, this.handleOnDownArrow = e => {
						if (this.suggestionDropdownApi && this.suggestionDropdownApi.moveDown()) return void e.preventDefault();
						const t = vn(e, this.state.editorState) || De(e, this.state.editorState);
						t && this.onChange(t), this.needSyncScroll = Ni.Down
					}, this.handleReturn = e => {
						const t = Ne(this.state.editorState);
						return t ? (this.onChange(t), e.preventDefault(), ma) : this.suggestionDropdownApi && this.suggestionDropdownApi.selectCurrent() ? (e.preventDefault(), ma) : pa
					}, this.suppressAutocompleteForFocusedLink = () => {
						const e = Object(Ao.b)(this.state.editorState);
						e && this.state.suppressAutocompleteForLink !== e.entityKey && this.setState({
							suppressAutocompleteForLink: e.entityKey
						})
					}, this.handleEscape = e => {
						this.emotesTooltipApi && this.emotesTooltipApi.handleEscapeKeyInEditor(), this.suppressAutocompleteForFocusedLink()
					}, this.handleOnCopy = e => {
						this.editorRef && Oe(this.state.editorState, this.editorRef, e)
					}, this.handleOnCut = e => {
						const {
							editorState: t
						} = this.state;
						if (!this.editorRef) return;
						if (!Oe(t, this.editorRef, e)) return;
						const n = de(t) || Pe(t) || Object(A.e)(t);
						n && this.onChange(n)
					}, this.handleOnPaste = e => {
						const {
							editorState: t
						} = this.state;
						if (!this.editorRef) return;
						if (this.handleFilesPaste(e, t), e.isPropagationStopped()) return;
						const n = Wr(t, this.editorRef, e, this.props.editorType);
						n && this.onChange(n)
					}, this.handleFilesPaste = (e, t) => {
						if (!this.props.allowImageUploads && !this.props.allowVideoUploads) return void e.stopPropagation();
						const n = e.clipboardData.files;
						if (n && n.length) {
							const o = Array.from(n),
								r = t.getSelection().getEndKey();
							this.insertMediaFiles({
								files: o,
								blockKey: r,
								insertionMode: F.a.after,
								filesSource: x.FileSource.Clipboard
							}), e.stopPropagation()
						}
					}, this.handleOnMouseDown = e => {
						this.isMouseDown = !0
					}, this.handleOnMouseUp = e => {
						this.isMouseDown = !1
					}, this.handleDroppedFiles = (e, t) => ma, this.handleDrop = (e, t, n) => ma, this.handleBlur = () => {
						this.props.onBlur && this.props.onBlur()
					}, this.handlePastedText = (e, t) => ma, this.onInternalSuggestionSelected = e => {
						this.onChange(Object(Ao.g)(this.state.editorState, e)), this.isJustAutocompleteSelected = !0
					}, this.onToolbarEmoteButtonClick = e => {
						this.gifTooltipApi && this.gifTooltipApi.closeTooltip(), this.emotesTooltipApi && this.emotesTooltipApi.toggleTooltip(e)
					}, this.onToolbarGifButtonClick = e => {
						this.emotesTooltipApi && this.emotesTooltipApi.closeTooltip(), this.gifTooltipApi && this.gifTooltipApi.toggleTooltip(e)
					}, this.onToolbarLinkButtonClick = () => {
						if (!this.linksControllerApi) return;
						const {
							editorState: e
						} = this.state;
						this.linksControllerApi.editLinkInSelection(e.getSelection()) || Object(E.b)(void 0, "Current selection cannot be edited by link editor!")
					}, this.handleSwitchToMarkdownMode = () => {
						const {
							editorState: e
						} = this.state, {
							onSwitchEditorMode: t
						} = this.props, n = Os.a.toRichTextJSON({
							...this.props.rteState,
							isBound: !0,
							editorState: Object(A.c)(e)
						});
						t && t(T.i.MARKDOWN, n), this.state.confirmModalOpen && this.toggleConfirmModal()
					}, this.onToolbarMarkdownSwitchClick = () => {
						const {
							editorState: e
						} = this.state;
						e && qo(e) ? this.setState({
							confirmModalOpen: !0
						}) : this.handleSwitchToMarkdownMode()
					}, this.toggleConfirmModal = () => {
						this.setState({
							confirmModalOpen: !this.state.confirmModalOpen
						})
					}, this.insertMediaFiles = async e => {
						const {
							onFilesFilter: t,
							rteState: n,
							shouldUseGqlUploadLease: o,
							minImageDimension: r,
							editorType: s
						} = this.props, {
							files: i,
							filesSource: a
						} = e;
						let c = i;
						t && (c = t(i, this.state.editorState)), this.setState({
							mediaToInsert: {
								...e,
								files: c
							}
						});
						const d = c.slice(0, ba);
						await this.props.startUploads(d, a, n.editorKey, s === Ge.a.Post, o, r), this.insertValidatedMedia()
					}, this.onRetryUpload = e => {
						this.props.retryUpload(e, this.props.editorType === Ge.a.Post)
					}, this.onFilesSelect = e => {
						const {
							editorState: t
						} = this.state, n = t.getSelection().getEndKey();
						this.insertMediaFiles({
							files: e,
							blockKey: n,
							insertionMode: F.a.after,
							filesSource: x.FileSource.FileSelector
						})
					}, this.onFilesDrop = (e, t, n) => {
						this.props.onTrackMediaDrop(e), this.insertMediaFiles({
							files: e,
							blockKey: t,
							insertionMode: n,
							filesSource: x.FileSource.DragAndDrop
						})
					}, this.onBlockMove = (e, t, n) => {
						const {
							editorState: o
						} = this.state, r = Object(A.o)(o, e, t, n);
						r && this.onChange(r)
					}, this.getAtomicBlocksRenderConfig = () => ({
						component: sn,
						props: {
							getEditorState: this.getEditorState,
							onChange: this.onChange,
							onRetryUpload: this.onRetryUpload,
							rteFocusableContentRef: this.state.focusableContentRef,
							editorType: this.props.editorType
						}
					}), this.blockRendererFn = e => {
						const t = e.getType();
						return t === w.a ? this.getAtomicBlocksRenderConfig() : t in Ms ? Ms[t] : void 0
					}, this.renderToolbar = e => m.a.createElement(Kt.b, e), this.entityElementRegistry = xo(), this.tableOnEnterHandler = new Cn;
					const {
						postId: t,
						isTypingIndicatorsWriteTestEnabled: n
					} = e;
					n && (this.realtimeGQLVariables = {
						input: {
							channel: {
								teamOwner: "CONTENT_AND_COMMUNITIES",
								category: "USER_IS_TYPING_ON_POST",
								postID: t
							}
						}
					});
					const {
						activeEmotes: r,
						editorType: s,
						noBorder: a,
						initialHeight: c,
						initialMinHeight: d,
						rteState: l
					} = e;
					let u;
					l.isBound ? u = l.editorState : Object(Vn.I)(l.initialRTJSON) ? u = this.createInitialState(l.editorKey) : (u = o.EditorState.createWithContent(ta(l.initialRTJSON, s, l.mediaMetadataMap, r), this.editorDecorators()), u = this.moveSelectionToEnd(u)), this.state = {
						noBorder: a,
						containerRef: null,
						confirmModalOpen: !1,
						editorState: u,
						focusableContentRef: null,
						inited: !1,
						initialHeight: c,
						initialMinHeight: d,
						isUserTyping: !1,
						mediaToInsert: null,
						suppressAutocompleteForLink: null
					}
				}
				editorDecorators() {
					return new o.CompositeDecorator([wo(), ur(), Wo()])
				}
				moveSelectionToEnd(e) {
					const t = e.getCurrentContent().getBlockMap(),
						n = t.last().getKey(),
						r = t.last().getLength(),
						s = new o.SelectionState({
							anchorKey: n,
							anchorOffset: r,
							focusKey: n,
							focusOffset: r
						});
					return o.EditorState.acceptSelection(e, s)
				}
				createInitialState(e) {
					return o.EditorState.createWithContent(o.ContentState.createFromBlockArray([new o.ContentBlock({
						key: `${e}_initial`
					})]), this.editorDecorators())
				}
				componentDidMount() {
					if (this.props.rteRef && this.props.rteRef(this), v.a.write(Ls), this.rteStateChanged(this.state.editorState, !1), this.editorRef) {
						const e = this.editorRef.refs.editor;
						e.addEventListener("scroll", this.hideTooltips), this.editorRootStyleMutationObserver = new MutationObserver(this.onEditorStyleChanged), this.editorRootStyleMutationObserver.observe(e, {
							attributes: !0,
							attributeFilter: ["style"]
						})
					}
					const {
						destSubreddit: e,
						emotesSpecialMembershipEnabled: t,
						giphySpecialMembershipEnabled: n
					} = this.props;
					e && e.id && (t || n) && this.props.onFetchEditorProducts(e.id)
				}
				componentDidUpdate(e, t) {
					const n = this.getLinkForAutocomplete();
					if (n && this.updateSuggestionDropdownPosition) {
						const e = this.entityElementRegistry.get(n.entityKey);
						if (e) {
							const {
								left: t,
								bottom: n,
								height: o
							} = e.getBoundingClientRect();
							this.updateSuggestionDropdownPosition({
								left: t,
								top: n,
								bottom: n - o
							})
						}
					}
					this.needSyncScroll && (Di(this.needSyncScroll), this.needSyncScroll = null)
				}
				componentWillUnmount() {
					if (this.props.rteRef && this.props.rteRef(null), this.insertValidatedMedia = () => {}, this.props.isTypingIndicatorsWriteTestEnabled && this.setUserStoppedTyping.cancel(), this.editorRef) {
						this.editorRef.refs.editor.removeEventListener("scroll", this.hideTooltips)
					}
					this.editorRootStyleMutationObserver && (this.editorRootStyleMutationObserver.disconnect(), this.editorRootStyleMutationObserver = null)
				}
				UNSAFE_componentWillReceiveProps(e) {
					e.rteState !== this.props.rteState && e.rteState.isBound && e.rteState.editorState !== this.state.editorState && this.setState({
						editorState: e.rteState.editorState
					})
				}
				shouldComponentUpdate(e, t) {
					if (t !== this.state) return !0;
					if (!(e.rteState.isBound && e.rteState.editorState === this.state.editorState)) return !0;
					return !f()(e, this.props, (e, t, n) => "rteState" === n || void 0)
				}
				enterKeyBinding(e) {
					let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
					const n = e.getCurrentContent(),
						o = e.getSelection(),
						r = o.getStartKey(),
						s = o.getEndKey(),
						i = o.getEndOffset(),
						a = n.getBlockForKey(r).getType(),
						c = n.getBlockForKey(s),
						d = c.getType(),
						l = i === c.getText().length;
					if (a === w.l || d === w.l) return I.EXEC_TABLE_ON_ENTER_HANDLER;
					if (o.isCollapsed()) {
						if (t && Object(Ao.d)(e)) return I.LINKIFY_ON_ENTER;
						if (Object(w.r)(d) && l) return I.BREAK_HEADER_ENTITY;
						if (Object(w.s)(d)) {
							if (ha.test(c.getText())) return c.getDepth() > 0 ? I.REDUCE_LIST_INDENT : I.REMOVE_EXTRA_LIST_ITEM
						} else if (d === w.e) {
							const e = n.getBlockBefore(s);
							if (e && e.getType() === w.e && ha.test(e.getText()) && ha.test(c.getText())) return I.RESET_CURRENT_AND_PREVIOUS_BLOCKS
						} else if (d === w.f) {
							const e = n.getBlockBefore(s),
								t = n.getBlockAfter(s);
							if (!c.getText() && e && e.getType() === w.f && !e.getText() && (!t || t.getType() !== w.f)) return I.RESET_CURRENT_AND_PREVIOUS_BLOCKS
						}
					}
				}
				getLinkForAutocomplete() {
					const {
						editorState: e,
						suppressAutocompleteForLink: t
					} = this.state;
					if (!this.isJustAutocompleteSelected && e.getSelection().getHasFocus()) {
						const n = Object(Ao.b)(e);
						if (n && n.entityKey !== t) return n
					}
				}
				renderInternalLinkSuggestionDropdown() {
					const {
						isChatPost: e
					} = this.props, t = this.getLinkForAutocomplete();
					return t ? m.a.createElement(Bn.b, {
						aboveParent: e,
						dropdown: !0,
						onSetPositionUpdater: this.setSuggestionDropdownPositionUpdater
					}, t.entityText.startsWith(y.f) && m.a.createElement(Zs, {
						onDropdownApi: this.setSuggestionDropdownApi,
						onSelect: this.onInternalSuggestionSelected,
						substring: t.internalName
					}), y.a.test(t.entityText) && m.a.createElement(ni, {
						onDropdownApi: this.setSuggestionDropdownApi,
						onSelect: this.onInternalSuggestionSelected,
						substring: t.internalName
					})) : null
				}
				render() {
					const {
						className: e,
						userCanUseEmojis: t,
						userCanUseGifs: n,
						allowImageUploads: s = !1,
						allowVideoUploads: i = !1,
						dataTestId: a,
						destSubreddit: c,
						editorType: d,
						focusableContentRTEClassName: u,
						hideToolbar: p,
						rteState: h,
						isExpanded: b,
						isOverlay: f,
						isCommentBoxDesignEnabled: v,
						onSubmit: C,
						placeholderText: y,
						shouldShowCommentGifsTooltip: E,
						showSubmitButton: x = !1,
						submitButtonClassName: _,
						toolbarPosition: k = "top",
						renderToolbar: j = this.renderToolbar,
						isTypingIndicatorsWriteTestEnabled: S
					} = this.props, {
						editorKey: T
					} = h, {
						containerRef: w,
						editorState: I,
						mediaToInsert: N,
						confirmModalOpen: M,
						isUserTyping: D
					} = this.state, L = this.props.readOnly || !!N, A = P(I), F = this.isEmpty(), B = j({
						allowImageUploads: s,
						allowVideoUploads: i,
						destSubreddit: c,
						editorKey: T,
						editorState: I,
						isOverlay: !!f,
						onChange: this.toolbarSetState,
						onFilesSelect: this.onFilesSelect,
						trackOnClick: this.props.trackToolbarClick,
						readOnly: L,
						onEmoteButtonClick: this.onToolbarEmoteButtonClick,
						onGifButtonClick: this.onToolbarGifButtonClick,
						onLinkButtonClick: this.onToolbarLinkButtonClick,
						onMarkdownButtonClick: this.onToolbarMarkdownSwitchClick,
						userCanUseEmojis: !!t,
						userCanUseGifs: !!n
					}), U = !p && (!v || b);
					return m.a.createElement(ga, {
						className: e,
						innerRef: this.setContainerRef
					}, S && D && m.a.createElement(O.a, {
						variables: this.realtimeGQLVariables,
						onData: l.a,
						queryKey: "userIsTypingOnPost"
					}), v && m.a.createElement("div", {
						className: la.a.userIcon
					}, m.a.createElement(va, null)), m.a.createElement(fa, {
						className: Object(g.a)(u, {
							[la.a.showSubmitButton]: x,
							[la.a.mExpanded]: b,
							[la.a.mRedesign]: v
						}),
						noBorder: this.props.noBorder,
						isFocused: this.isFocused(),
						ref: this.setFocusableContentRef
					}, U && "top" === k && B, w && m.a.createElement(Co, {
						editorState: I,
						readOnly: L,
						onChange: this.onChange,
						onSetApi: this.setTableToolbarControllerApi,
						rteDomRef: w
					}), m.a.createElement("div", {
						className: Object(g.a)(la.a.editorWrapper, {
							[la.a.hasInitialHeight]: !!this.props.initialHeight,
							[la.a.hasInitialMinHeight]: !!this.props.initialMinHeight,
							[la.a.noBorder]: !!this.props.noBorder
						}),
						style: {
							"--rte-initial-height": this.props.initialHeight ? `${this.props.initialHeight}px` : void 0,
							"--rte-initial-min-height": this.props.initialMinHeight ? `${this.props.initialMinHeight}px` : void 0
						},
						"data-test-id": a,
						onCopyCapture: this.handleOnCopy,
						onCutCapture: this.handleOnCut,
						onPasteCapture: this.handleOnPaste,
						onMouseDown: this.handleOnMouseDown,
						onMouseUp: this.handleOnMouseUp
					}, m.a.createElement("style", {
						dangerouslySetInnerHTML: {
							__html: `\n                .${ra.b}[${ra.d}="${A}-0-0"]::after {\n                  bottom: 0;\n                  color: var(--newCommunityTheme-actionIcon);\n                  content: '${y}';\n                  cursor: text;\n                  left: 0;\n                  position: absolute;\n                  top: 0;\n                }\n              `
						}
					}), m.a.createElement(wr, {
						allowMediaUploads: (s || i) && !L,
						onBlockMove: this.onBlockMove,
						onFilesDrop: this.onFilesDrop,
						editorState: I,
						onChange: this.onChange
					}, m.a.createElement(Oo.Provider, {
						value: this.entityElementRegistry
					}, m.a.createElement(o.Editor, {
						readOnly: L,
						ref: this.setEditorRef,
						blockRendererFn: this.blockRendererFn,
						blockRenderMap: this.blockRenderMap,
						editorKey: T,
						editorState: I,
						keyBindingFn: this.keyBindingFN,
						handleBeforeInput: this.handleBeforeInput,
						handleKeyCommand: this.handleKeyCommand,
						handlePastedText: this.handlePastedText,
						handleDroppedFiles: this.handleDroppedFiles,
						handleDrop: this.handleDrop,
						onBlur: this.handleBlur,
						onChange: this.onChange,
						onFocus: this.onFocus,
						onTab: this.handleOnTab,
						onUpArrow: this.handleOnUpArrow,
						onDownArrow: this.handleOnDownArrow,
						onEscape: this.handleEscape,
						spellCheck: !0,
						handleReturn: this.handleReturn,
						customStyleMap: js()
					})))), U && "bottom" === k && B, m.a.createElement(hs, {
						containerRef: w,
						editorState: I,
						entityElementRegistry: this.entityElementRegistry,
						onSetApi: this.setLinksControllerApi,
						onChange: this.onChange
					}), d === Ge.a.Comment && c && m.a.createElement(Do, {
						editorState: I,
						onChange: this.onChange,
						onSetApi: this.setEmotesTooltipApi,
						subreddit: c,
						userCanUseEmojis: !!t
					}), (E || n) && c && m.a.createElement(ir, {
						editorState: I,
						onChange: this.onChange,
						onSetApi: this.setGifTooltipApi,
						subreddit: c,
						userCanUseGifs: !!n
					}), this.renderInternalLinkSuggestionDropdown(), x && m.a.createElement(rt.e, {
						"aria-label": r.fbt._("submit", null, {
							hk: "12XoZ8"
						}),
						className: Object(g.a)(_, la.a.insetSubmitButton, {
							[la.a.emptyContent]: F,
							[la.a.focusedContent]: this.isFocused()
						}),
						disabled: F,
						onClick: C,
						tabIndex: -1,
						type: "submit"
					}, m.a.createElement(aa.a, null))), M && m.a.createElement(R.a, {
						toggleModal: this.toggleConfirmModal,
						onConfirm: this.handleSwitchToMarkdownMode,
						actionText: r.fbt._("Continue", null, {
							hk: "3aoEeD"
						}),
						cancelActionText: r.fbt._("Cancel", null, {
							hk: "2TSLl5"
						}),
						headerText: r.fbt._("Switch to Markdown", null, {
							hk: "3zGkKa"
						}),
						modalText: d === Ge.a.Comment ? r.fbt._("Switching to markdown will remove any image or GIF from your comment.", null, {
							hk: "3v46Jt"
						}) : r.fbt._("Switching to markdown will remove any images, gifs or videos from your post.", null, {
							hk: "3rlwkB"
						}),
						trackClick: () => {}
					}))
				}
			}
			t.a = ya(Object(Ks.b)(e => m.a.createElement(Ea, ua({
				key: e.rteState.editorKey
			}, e))))
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/ImagePreview/index.m.less": function(e, t, n) {
			e.exports = {
				Img: "_1gJwMe53cjYITkMu0Ve8j-",
				img: "_1gJwMe53cjYITkMu0Ve8j-",
				Component: "_3VYFd7PKhTJ-0i22YsgFPv",
				component: "_3VYFd7PKhTJ-0i22YsgFPv"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/Placeholder/index.m.less": function(e, t, n) {
			e.exports = {
				Message: "_3cyJHYsdZdz4RWdmrzyYx-",
				message: "_3cyJHYsdZdz4RWdmrzyYx-",
				Component: "_3JSUHg1gLhxUj4PB_Pgw8a",
				component: "_3JSUHg1gLhxUj4PB_Pgw8a"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/StatusBar/index.m.less": function(e, t, n) {
			e.exports = {
				buttonBaseStyles: "_3R1ajPuzbs2MdbXedj3YXU",
				ControlRow: "_1rrSEjTxZcLOZTDNZlj5N4",
				controlRow: "_1rrSEjTxZcLOZTDNZlj5N4",
				ButtonsContainer: "dZ3F6qSOhun6ezUwcnbal",
				buttonsContainer: "dZ3F6qSOhun6ezUwcnbal",
				Button: "_2rIEdliEXr7qNb-COL-zuO",
				button: "_2rIEdliEXr7qNb-COL-zuO",
				ErrButton: "_3CUr1530H3uD-ts9tKd9RA",
				errButton: "_3CUr1530H3uD-ts9tKd9RA",
				Status: "jXuqxr-x0kyU3BSfugjwM",
				status: "jXuqxr-x0kyU3BSfugjwM",
				hasError: "_4XwI6tILia1pR9HTda4wv",
				ProgressBar: "_1NvtB5J5UfhiHd0ix7TZgb",
				progressBar: "_1NvtB5J5UfhiHd0ix7TZgb",
				ProgressBarInner: "_29o2WRRYmrLU47NaFzQzxq",
				progressBarInner: "_29o2WRRYmrLU47NaFzQzxq",
				ErrorLine: "_3M-thbkBHHvsWjDt8edbhz",
				errorLine: "_3M-thbkBHHvsWjDt8edbhz",
				Component: "_1CqupI5I-zzAInIdLwphQg",
				component: "_1CqupI5I-zzAInIdLwphQg"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/VideoPreview/index.m.less": function(e, t, n) {
			e.exports = {
				VideoPlayer: "_3gstD1_YUjNWZqjtwdgU9t",
				videoPlayer: "_3gstD1_YUjNWZqjtwdgU9t",
				PosterImg: "_2C2yx7Rf_BKPOyll-aq_hI",
				posterImg: "_2C2yx7Rf_BKPOyll-aq_hI",
				Poster: "_1UCJLqzcYXck8Ahv0PlvVw",
				poster: "_1UCJLqzcYXck8Ahv0PlvVw",
				Component: "wSihDBKVJH6iP2jdDjRQ6",
				component: "wSihDBKVJH6iP2jdDjRQ6",
				playButton: "il4HPAfKcVtq-WQY-if85"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/index.m.less": function(e, t, n) {
			e.exports = {
				statusBar: "_33CSkXq7gXeXCM2zSal9BN",
				container: "_1FMEfWD94pPZ_HdEN_e7Xy",
				isCompact: "_3-T8BPflZuKw_F2VRPDbcX",
				isUploaded: "_3Lj2c902Oeb7yL_jYu9v5L",
				isSelected: "Eaps2a9y_jwhKHth8v14G",
				imagePreview: "_2nlrFrYbO0bIKFeZ3HMbn_",
				placeholder: "_1-LSy7nvfNGWVhRWwwQu6A",
				videoPreview: "_2MumquPHY8gruoy6114twC",
				alignCenter: "_3U9f0TNBM1K2bggm3KMHTk",
				renderSmallMedia: "_3L8V1OmRzcZEzmJFdJV6dS"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/SelectionHook/index.m.less": function(e, t, n) {
			e.exports = {
				HiddenDiv: "_13RYjdyxMuKrkV_EtlOjhg",
				hiddenDiv: "_13RYjdyxMuKrkV_EtlOjhg"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/Toolbar/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3hDtN0e5U4EpahGe25ye-b",
				alignCenter: "Vh7FGvkGyl5SeyJP4J1GG",
				content: "_3wXzBVn-uBvRcixZwQWkNX",
				multiButtonToolbarContent: "_4g7-oW_EplZpFIKv75-Lu",
				FormatterButton: "_6DRydZXlG3Ko7_4xxYUhW",
				formatterButton: "_6DRydZXlG3Ko7_4xxYUhW",
				ToolbarContent: "_3qUkCQkbZvTB6uBQEQQfSZ",
				toolbarContent: "_3qUkCQkbZvTB6uBQEQQfSZ"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/index.m.less": function(e, t, n) {
			e.exports = {
				MediaContainer: "_12ZUhulrgf1BAChnRZHmZt",
				mediaContainer: "_12ZUhulrgf1BAChnRZHmZt",
				Container: "DK9d46mm9FgC8mFWPGlG_",
				container: "DK9d46mm9FgC8mFWPGlG_"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaCaption/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_2eZK2IABgFqGZLMYPxwoNY"
			}
		},
		"./src/reddit/components/RichTextEditor/media/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "q", (function() {
				return g
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "r", (function() {
				return C
			})), n.d(t, "l", (function() {
				return y
			})), n.d(t, "k", (function() {
				return E
			})), n.d(t, "n", (function() {
				return x
			})), n.d(t, "p", (function() {
				return O
			})), n.d(t, "d", (function() {
				return k
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "e", (function() {
				return S
			})), n.d(t, "m", (function() {
				return w
			})), n.d(t, "g", (function() {
				return I
			})), n.d(t, "j", (function() {
				return P
			})), n.d(t, "i", (function() {
				return N
			})), n.d(t, "o", (function() {
				return R
			})), n.d(t, "b", (function() {
				return M
			})), n.d(t, "f", (function() {
				return L
			}));
			var o, r = n("./node_modules/draft-js/lib/Draft.js"),
				s = n("./node_modules/immutable/dist/immutable.js"),
				i = n("./node_modules/lodash/flatten.js"),
				a = n.n(i),
				c = n("./node_modules/lodash/last.js"),
				d = n.n(c),
				l = n("./src/reddit/helpers/media/index.ts"),
				u = n("./src/reddit/helpers/richTextEditor/index.ts"),
				m = n("./src/reddit/helpers/richTextJson/index.ts"),
				p = n("./src/reddit/models/Upload/index.ts"),
				h = n("./src/reddit/components/RichTextEditor/constants/editorChangeTypes.ts"),
				b = n("./src/reddit/components/RichTextEditor/helpers/common.ts"),
				f = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			! function(e) {
				e[e.Image = 0] = "Image", e[e.AnimatedImage = 1] = "AnimatedImage", e[e.Video = 2] = "Video"
			}(o || (o = {}));
			const g = e => e !== u.a.Comment,
				v = e => {
					if (!Object(f.o)(e.getType())) return;
					const t = e.getData(),
						n = t.get("mediaAsset"),
						o = t.get("uploadInfo");
					if (!n && !o) return;
					const r = t.get("thumbnail");
					return {
						makeGif: t.get("makeGif"),
						thumbnail: r,
						uploadInfo: o,
						mediaAsset: n
					}
				},
				C = (e, t, n) => {
					let o = e.getCurrentContent();
					const i = o.getBlockForKey(t),
						a = v(i),
						c = a && a.uploadInfo;
					if (!c) throw new Error("Block must contain `uploadInfo` data");
					if (n.makeGif === a.makeGif && n.thumbnail === a.thumbnail) return e;
					const d = Object(s.Map)(n),
						l = o.getBlockMap().toKeyedSeq().filter(e => {
							const t = v(e);
							return !!t && !!t.uploadInfo && t.uploadInfo.uploadKey === c.uploadKey
						}).map(e => e.mergeIn(["data"], d));
					return o = (o = o.mergeIn(["blockMap"], l)).merge({
						selectionAfter: e.getSelection()
					}), r.EditorState.push(e, o, h.b)
				},
				y = (e, t, n, o, i) => {
					let c = e.getCurrentContent();
					const u = a()(t.map(e => {
						const t = Object(l.g)(e.metadata.mimetype),
							n = (e => {
								if (e && e.metadata.videoFirstFrameUrl) {
									return {
										url: e.metadata.videoFirstFrameUrl,
										time: 0
									}
								}
							})(e),
							o = new r.ContentBlock({
								key: Object(r.genKey)(),
								type: f.a,
								data: Object(s.Map)({
									uploadInfo: {
										mediaType: t,
										uploadKey: e.key
									},
									thumbnail: n
								})
							}),
							a = new r.ContentBlock({
								key: Object(r.genKey)(),
								type: f.j
							});
						return i ? [o] : [o, a]
					}));
					c = Object(b.f)(c, n, u, o);
					const m = r.EditorState.push(e, c, h.e),
						p = d()(u);
					return r.EditorState.forceSelection(m, Object(b.b)(p, !0))
				},
				E = (e, t, n, i, a, c, d, l) => {
					const u = new r.ContentBlock({
							key: Object(r.genKey)(),
							type: f.a,
							data: Object(s.Map)({
								mediaAsset: {
									type: o.AnimatedImage,
									assetId: Object(m.c)(t, i),
									imageUrl: n,
									width: a,
									height: c
								}
							})
						}),
						p = Object(b.f)(e.getCurrentContent(), d, [u], l);
					let g = r.EditorState.push(e, p, h.e);
					g = r.EditorState.forceSelection(g, Object(b.b)(u, !0));
					const v = u.getKey();
					return g.getCurrentContent().getBlockAfter(v) || (g = M(g, v)), g
				};

			function x(e, t) {
				return e.isCollapsed() && e.getStartKey() === t && 0 === e.getStartOffset() && 0 === e.getEndOffset()
			}

			function O(e, t) {
				const n = e.getCurrentContent().getBlockAfter(t);
				return r.EditorState.forceSelection(e, Object(b.b)(n, !0))
			}
			const _ = (e, t) => {
					const n = e.getBlockAfter(t);
					return e = Object(b.i)(e, t), n && Object(f.u)(n.getType()) && (e = Object(b.i)(e, n.getKey())), e
				},
				k = function(e, t) {
					let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
						o = e.getCurrentContent();
					o = _(o, t);
					let s = n ? r.EditorState.push(e, o, h.f) : r.EditorState.set(e, {
						currentContent: o
					});
					return s = r.EditorState.forceSelection(s, o.getSelectionAfter())
				},
				j = e => {
					let t = e.getCurrentContent();
					T(t).forEach(e => {
						t = _(t, e.getKey())
					});
					const n = r.EditorState.push(e, t, h.f);
					return r.EditorState.forceSelection(n, t.getSelectionAfter())
				},
				S = e => {
					let t = e.getCurrentContent();
					const n = e.getSelection();
					t = r.Modifier.removeRange(t, n, "forward");
					let o = r.EditorState.push(e, t, h.f);
					return o = r.EditorState.forceSelection(o, t.getSelectionAfter())
				},
				T = e => e.getBlockMap().toSeq().filter(e => !!e && !!v(e)),
				w = (e, t) => e.getBlockMap().toSeq().filter(e => {
					const n = v(e),
						o = n && n.uploadInfo && n.uploadInfo.uploadKey;
					return !(!o || t[o] && t[o].url)
				}).isEmpty(),
				I = e => {
					const t = T(e),
						n = {
							gifvideo: 0,
							image: 0,
							video: 0,
							total: 0
						};
					return t.forEach(e => {
						const t = v(e);
						let r;
						r = t.makeGif ? "gifvideo" : t.uploadInfo && "video" === t.uploadInfo.mediaType || t.mediaAsset && t.mediaAsset.type === o.Video ? "video" : "image", n[r]++, n.total++
					}), n
				},
				P = e => !T(e).isEmpty(),
				N = (e, t) => {
					const n = T(e).map(e => {
						const n = v(e),
							{
								uploadInfo: o,
								thumbnail: r
							} = n;
						if (!o || !r) return;
						const s = D(n),
							i = t[s];
						return i && i.url ? void 0 : {
							...r,
							uploadKey: s
						}
					}).filter(Boolean).toArray();
					return n.length ? n : void 0
				},
				R = (e, t, n, o) => {
					let s = e.getCurrentContent();
					const i = s.getBlockForKey(t),
						a = s.getBlockAfter(t),
						c = [i];
					if (a && Object(f.u)(a.getType()) && c.push(a), c.find(e => e.getKey() === n)) return;
					const l = c.reduce((e, t) => e.remove(t.getKey()), s.getBlockMap());
					s = s.set("blockMap", l), s = Object(b.f)(s, n, c, o);
					const u = r.EditorState.push(e, s, h.e);
					return r.EditorState.forceSelection(u, Object(b.b)(d()(c), !0))
				},
				M = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : b.a.after;
					const o = Object(b.h)(),
						s = Object(b.f)(e.getCurrentContent(), t, [o], n),
						i = r.EditorState.push(e, s, h.e);
					return r.EditorState.forceSelection(i, r.SelectionState.createEmpty(o.getKey()))
				},
				D = e => e.thumbnail && e.uploadInfo ? `${e.uploadInfo.uploadKey}-thumbnail-${e.thumbnail.time}` : "",
				L = (e, t) => {
					let n = "",
						o = "";
					if (e.uploadInfo) {
						const {
							uploadKey: r
						} = e.uploadInfo, s = t[r];
						s && s.url && (n = Object(p.b)(s.url));
						const i = t[D(e)];
						i && i.url && (o = Object(p.b)(i.url))
					}
					return {
						assetId: n,
						thumbnailAssetId: o
					}
				}
		},
		"./src/reddit/components/RichTextEditor/spoiler/decorator.m.less": function(e, t, n) {
			e.exports = {
				spoiler: "_1AlhnBqYYVTQbTr33YViyK"
			}
		},
		"./src/reddit/components/RichTextEditor/spoiler/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return i
			}));
			var o = n("./src/lib/forEachGroup/index.ts"),
				r = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			const s = e => e.getStyle().has(r.k.SPOILER);

			function i(e, t, n) {
				const r = e.getCharacterList();
				Object(o.a)(r, {
					keyFn: s
				}, (e, n, o, r) => {
					n && t(o, r)
				})
			}
		},
		"./src/reddit/components/RichTextEditor/table/Renderer/index.m.less": function(e, t, n) {
			e.exports = {
				Cell: "_1J5sneEp0XXo0pFsMN7Kjs",
				cell: "_1J5sneEp0XXo0pFsMN7Kjs",
				Row: "_2Hd-Rc7z9gTKIz6JUGhbcl",
				row: "_2Hd-Rc7z9gTKIz6JUGhbcl",
				Table: "_9QFGu47IyMX1ID1xQid-8",
				table: "_9QFGu47IyMX1ID1xQid-8",
				isFakeSelectionActive: "_1QXaG0_iXh-LFDkah9HqP3"
			}
		},
		"./src/reddit/components/RichTextEditor/table/Toolbar/index.m.less": function(e, t, n) {
			e.exports = {
				formatterButton: "_1dNavKEU0lSO4mo9fYWTPm",
				ToolbarContent: "_1yPmb5QUbyAQX1wIs4FYQI",
				toolbarContent: "_1yPmb5QUbyAQX1wIs4FYQI",
				tooltip: "_3fnB5glctifL-mkYhH6aA1"
			}
		},
		"./src/reddit/components/RichTextEditor/table/ToolbarController/index.m.less": function(e, t, n) {
			e.exports = {
				ActionButton: "_2g2bsszGVtKe_XRKcRrpQi",
				actionButton: "_2g2bsszGVtKe_XRKcRrpQi",
				isPressed: "_2WwwYG59S_TJRq7FSdTVKK",
				ToolbarWrapper: "_3rXrpMuvoGNBbLE7TQQCB9",
				toolbarWrapper: "_3rXrpMuvoGNBbLE7TQQCB9"
			}
		},
		"./src/reddit/components/RichTextEditor/table/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "j", (function() {
				return p
			})), n.d(t, "l", (function() {
				return h
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "k", (function() {
				return f
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "b", (function() {
				return C
			})), n.d(t, "i", (function() {
				return y
			})), n.d(t, "e", (function() {
				return E
			})), n.d(t, "o", (function() {
				return x
			})), n.d(t, "d", (function() {
				return O
			}));
			var o = n("./node_modules/draft-js/lib/Draft.js"),
				r = n("./node_modules/immutable/dist/immutable.js"),
				s = n("./src/reddit/models/RichTextJson/index.ts"),
				i = n("./src/reddit/components/RichTextEditor/helpers/sliceContiguousBlocks.ts"),
				a = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			const c = {
					[s.e]: "left",
					[s.f]: "right",
					[s.d]: "center"
				},
				d = e => {
					const t = e.getData();
					return {
						colIndex: t.get("colIndex"),
						rowIndex: t.get("rowIndex"),
						colCount: t.get("colCount"),
						alignment: t.get("alignment")
					}
				},
				l = ["data"],
				u = (e, t) => e.mergeIn(l, t),
				m = (e, t, n) => e.merge({
					text: e.getText().slice(t, n),
					characterList: e.getCharacterList().slice(t, n)
				}),
				p = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "",
						r = arguments.length > 3 ? arguments[3] : void 0;
					const s = t.map(e => e.getText()).join(n),
						i = n ? r || o.CharacterMetadata.create() : null,
						a = [];
					return t.forEach(e => {
						a.push(...e.getCharacterList().toArray()), i && t.length > 1 && a.push(i)
					}), e.merge({
						text: s,
						characterList: a
					})
				},
				h = (e, t) => {
					const n = [];
					for (let s = 0; s < t; s++)
						for (let t = 0; t < e; t++) n.push(new o.ContentBlock({
							key: Object(o.genKey)(),
							type: a.l,
							data: Object(r.Map)({
								colCount: e,
								colIndex: t,
								rowIndex: s
							})
						}));
					return n
				},
				b = (e, t) => ({
					minCol: Math.min(e.colIndex, t.colIndex),
					minRow: Math.min(e.rowIndex, t.rowIndex),
					maxCol: Math.max(e.colIndex, t.colIndex),
					maxRow: Math.max(e.rowIndex, t.rowIndex)
				}),
				f = (e, t) => {
					const {
						minCol: n,
						minRow: o,
						maxCol: r,
						maxRow: s
					} = b(e, t);
					return (e, t) => o <= e && e <= s && n <= t && t <= r
				},
				g = (e, t) => e.rowIndex < t.rowIndex ? -1 : e.rowIndex > t.rowIndex ? 1 : e.colIndex - t.colIndex,
				v = (e, t) => e === t || !(!e || !t) && 0 === g(e, t),
				C = (e, t) => g(d(e), d(t)),
				y = e => {
					if (Object(a.v)(e.getType())) {
						return 0 === d(e).rowIndex
					}
					return !1
				},
				E = (e, t, n) => {
					const o = (t, n) => {
						if (t) {
							const o = Object(i.a)(e, t);
							return o && n && -1 !== o.blocks.indexOf(n) ? [o, o] : [o, n ? Object(i.a)(e, n) : null]
						}
						return n ? o(n, null).reverse() : [null, null]
					};
					return o(Object(a.v)(t.getType()) ? t : null, Object(a.v)(n.getType()) ? n : null)
				},
				x = function(e, t, n) {
					let o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					const r = {
						isBackward: o
					};
					return t && (r.anchorKey = t.getKey(), r.anchorOffset = o ? t.getLength() : 0), n && (r.focusKey = n.getKey(), r.focusOffset = o ? 0 : n.getLength()), e.merge(r)
				},
				O = e => {
					if (!e.length) return [];
					const t = e[0].length;
					return e.map((e, n) => e.map((e, o) => u(e, {
						rowIndex: n,
						colIndex: o,
						colCount: t
					})))
				}
		},
		"./src/reddit/components/ScheduledPost/PostSchedulePickerModal/loader.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(o.a)({
				resolved: {},
				chunkName: () => "reddit-components-ScheduledPost-PostSchedulePickerModal",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-ScheduledPost-PostSchedulePickerModal").then(n.bind(null, "./src/reddit/components/ScheduledPost/PostSchedulePickerModal/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ScheduledPost/PostSchedulePickerModal/index.tsx"
				}
			})
		},
		"./src/reddit/components/SearchResultsContent/searchResultsPageTreatment/searchIgnoreClickContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var o = n("./node_modules/react/index.js");
			const r = Object(o.createContext)(!1);

			function s() {
				return Object(o.useContext)(r)
			}
		},
		"./src/reddit/components/SidebarFooter/index.m.less": function(e, t, n) {
			e.exports = {
				GreyRereddit: "_3Y8af3R9_DE3lpXa6Hq5Ab",
				greyRereddit: "_3Y8af3R9_DE3lpXa6Hq5Ab",
				Widget: "_2wqyhtudP4weVGsZdVXJgt",
				widget: "_2wqyhtudP4weVGsZdVXJgt",
				LinkContainer: "_1KrMye71CT332tKKKUWAj6",
				linkContainer: "_1KrMye71CT332tKKKUWAj6",
				Column: "_3f2nSSsPBqVDV6Sz82qgrR",
				column: "_3f2nSSsPBqVDV6Sz82qgrR",
				Link: "_3Eyh3vRo5o4IfzVZXhaWAG",
				link: "_3Eyh3vRo5o4IfzVZXhaWAG",
				NoneCapitalizeLink: "_3GijmRx58E2GzbuzKVHDex",
				noneCapitalizeLink: "_3GijmRx58E2GzbuzKVHDex",
				Copyright: "_34dh2eyzMvJfjCBLeoWiDD",
				copyright: "_34dh2eyzMvJfjCBLeoWiDD"
			}
		},
		"./src/reddit/components/SidebarFooter/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./node_modules/@reddit/reddit-country-url-redirects/dist/esm/index.js"),
				c = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/Onboarding/LanguageCollection/prompt.tsx"),
				l = n("./src/reddit/components/TrackingHelper/index.tsx"),
				u = n("./src/reddit/components/Widgets/ThemedWidget/index.tsx"),
				m = n("./src/reddit/constants/experiments.ts"),
				p = n("./src/reddit/constants/location.ts"),
				h = n("./src/reddit/contexts/PageLayer/index.tsx"),
				b = n("./src/reddit/helpers/trackers/navigation.ts"),
				f = n("./src/reddit/selectors/experiments/countrySites.ts"),
				g = n("./src/reddit/selectors/experiments/d2xPdpSideRailRecs.ts"),
				v = n("./src/reddit/selectors/experiments/navbarLikeMweb.ts"),
				C = n("./src/reddit/selectors/meta.ts"),
				y = n("./src/redditGQL/types.ts"),
				E = n("./src/reddit/components/SidebarFooter/index.m.less"),
				x = n.n(E);
			const {
				fbt: O
			} = n("./node_modules/fbt/lib/FbtPublic.js"), _ = c.a.a("Link", x.a), k = Object(i.c)({
				countryCode: C.b,
				d2xPdpSideRailRecsVariant: g.a,
				isCountrySitesEnabled: f.b,
				isD2xPdpSideRailRecsEnabled: g.b,
				isNavbarLikeMwebEnabled: v.a
			}), j = Object(s.b)(k), S = Object(h.v)({
				isFrontpage: h.B,
				isCountrySitePage: h.z
			}), T = e => {
				let {
					countryCode: t,
					reredditContent: n
				} = e;
				return r.a.createElement("div", {
					className: x.a.GreyRereddit
				}, n, !!p.c[t] && r.a.createElement("div", {
					className: x.a.LinkContainer
				}, r.a.createElement("div", {
					className: x.a.Column
				}, r.a.createElement(_, {
					href: "https://www.redditinc.com/policies/impressum"
				}, O._("Impressum", null, {
					hk: "4cKXSI"
				})), t === y.j.De && r.a.createElement(_, {
					href: "https://reddit.zendesk.com/hc/de/requests/new?ticket_form_id=360000152352",
					className: x.a.NoneCapitalizeLink
				}, O._("Report NetzDG Content", null, {
					hk: "1nszCF"
				}))), r.a.createElement("div", {
					className: x.a.Column
				}, r.a.createElement(_, {
					href: "https://www.reddithelp.com"
				}, O._("help", null, {
					hk: "4lyYaD"
				})), t === y.j.De && r.a.createElement(_, {
					href: "https://reddit.zendesk.com/hc/de/articles/360045289772-Deutschland-Meldungen-nach-dem-Netzwerkdurchsetzungsgesetz-NetzDG-"
				}, O._("Transparency report", null, {
					hk: "3CgBdG"
				})))), r.a.createElement("div", {
					className: x.a.LinkContainer
				}, r.a.createElement("div", {
					className: x.a.Column
				}, r.a.createElement(_, {
					href: "https://www.redditinc.com/policies/user-agreement"
				}, O._("User Agreement", null, {
					hk: "2RA6JL"
				})), r.a.createElement(_, {
					href: "https://www.redditinc.com/policies/privacy-policy"
				}, O._("Privacy policy", null, {
					hk: "10K04G"
				}))), r.a.createElement("div", {
					className: x.a.Column
				}, r.a.createElement(_, {
					href: "https://www.redditinc.com/policies/content-policy"
				}, O._("Content policy", null, {
					hk: "1DyxZS"
				})), r.a.createElement(_, {
					href: "https://www.redditinc.com/policies/moderator-guidelines"
				}, O._("Moderator Code of Conduct", null, {
					hk: "tWEG"
				})))), r.a.createElement("div", {
					className: x.a.Copyright
				}, O._("Reddit, Inc.  {year}. All rights reserved.", [O._param("year", (new Date).getFullYear().toString())], {
					hk: "DPZBh"
				})))
			};
			t.a = S(j(Object(l.c)(e => {
				const t = Object(s.f)().getState(),
					n = Object(f.a)(t, Object(a.c)());
				if (e.isD2xPdpSideRailRecsEnabled) {
					const t = e.d2xPdpSideRailRecsVariant === m.rd.GreyRereddit || e.d2xPdpSideRailRecsVariant === m.rd.GreyRedditNoNsfw || e.d2xPdpSideRailRecsVariant === m.rd.LargeImagePreview ? e.reredditButtons : [];
					return r.a.createElement(T, {
						reredditContent: t,
						countryCode: e.countryCode
					})
				}
				if (!e.isFrontpage && !e.isCountrySitePage) return null;
				const o = t => {
					const o = {
						de: "Deutsch",
						fr: "Franais",
						es: "Espaol",
						en: "English",
						it: "Italiano",
						pt: "Portugus"
					};
					return n.includes(t) || "en" === t ? r.a.createElement(_, {
						href: "en" === t ? "/" : `/${t}/`,
						onClick: () => e.sendEvent(Object(b.a)(t))
					}, o[t]) : null
				};
				return r.a.createElement(u.a, {
					className: x.a.Widget,
					redditStyle: e.redditStyle,
					contentOnly: !0
				}, !!p.c[e.countryCode] && r.a.createElement("div", {
					className: x.a.LinkContainer
				}, r.a.createElement("div", {
					className: x.a.Column
				}, r.a.createElement(_, {
					href: "https://www.redditinc.com/policies/impressum"
				}, O._("Impressum", null, {
					hk: "4cKXSI"
				})), e.countryCode === y.j.De && r.a.createElement(_, {
					href: "https://reddit.zendesk.com/hc/de/requests/new?ticket_form_id=360000152352",
					className: x.a.NoneCapitalizeLink
				}, O._("Report NetzDG Content", null, {
					hk: "1nszCF"
				}))), r.a.createElement("div", {
					className: x.a.Column
				}, r.a.createElement(_, {
					href: "https://www.reddithelp.com"
				}, O._("help", null, {
					hk: "4lyYaD"
				})), e.countryCode === y.j.De && r.a.createElement(_, {
					href: "https://reddit.zendesk.com/hc/de/articles/360045289772-Deutschland-Meldungen-nach-dem-Netzwerkdurchsetzungsgesetz-NetzDG-"
				}, O._("Transparency report", null, {
					hk: "3CgBdG"
				})))), r.a.createElement("div", {
					className: x.a.LinkContainer
				}, r.a.createElement("div", {
					className: x.a.Column
				}, r.a.createElement(_, {
					href: "https://www.redditinc.com/policies/user-agreement"
				}, O._("User Agreement", null, {
					hk: "2RA6JL"
				})), r.a.createElement(_, {
					href: "https://www.redditinc.com/policies/privacy-policy"
				}, O._("Privacy policy", null, {
					hk: "10K04G"
				}))), r.a.createElement("div", {
					className: x.a.Column
				}, r.a.createElement(_, {
					href: "https://www.redditinc.com/policies/content-policy"
				}, O._("Content policy", null, {
					hk: "1DyxZS"
				})), r.a.createElement(_, {
					href: "https://www.redditinc.com/policies/moderator-guidelines"
				}, O._("Moderator Code of Conduct", null, {
					hk: "tWEG"
				})))), (e.isCountrySitePage || e.isCountrySitesEnabled) && r.a.createElement("div", {
					className: x.a.LinkContainer
				}, r.a.createElement("div", {
					className: x.a.Column
				}, o("en"), o("fr"), o("it")), r.a.createElement("div", {
					className: x.a.Column
				}, o("de"), o("es"), o("pt"))), r.a.createElement("div", {
					className: x.a.Copyright
				}, O._("Reddit, Inc.  {year}. All rights reserved.", [O._param("year", (new Date).getFullYear().toString())], {
					hk: "DPZBh"
				})), r.a.createElement(d.a, null))
			})))
		},
		"./src/reddit/components/SidebarSpacer/index.m.less": function(e, t, n) {
			e.exports = {
				Component: "_2vEf-C2keJaBMY9qk_BxVn",
				component: "_2vEf-C2keJaBMY9qk_BxVn"
			}
		},
		"./src/reddit/components/SidebarSpacer/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./src/reddit/components/SidebarSpacer/index.m.less"),
				r = n.n(o),
				s = n("./src/lib/lessComponent.tsx");
			t.a = s.a.div("Component", r.a)
		},
		"./src/reddit/components/SourceLink/index.m.less": function(e, t, n) {
			e.exports = {
				OutboundLinkIcon: "_2WV2dTLgPlEXLVEmIexAxf",
				outboundLinkIcon: "_2WV2dTLgPlEXLVEmIexAxf",
				SourceLinkWrapper: "_10wC0aXnrUKfdJ4Ssz-o14",
				sourceLinkWrapper: "_10wC0aXnrUKfdJ4Ssz-o14",
				"m-comment": "_1-PD0_zreH-KVwpFoCLvQF",
				mComment: "_1-PD0_zreH-KVwpFoCLvQF"
			}
		},
		"./src/reddit/components/SourceLink/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return _
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/ads/index.ts"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/getShortenedLink.ts"),
				c = n("./node_modules/fbt/lib/FbtPublic.js"),
				d = n("./src/lib/avatarShareImages.ts"),
				l = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/TryItOn.tsx"),
				u = n("./src/reddit/components/AvatarPost/index.m.less"),
				m = n.n(u);
			var p = e => {
					let {
						sourceUrl: t,
						username: n,
						post: o
					} = e;
					const [s, i] = new URL(t).pathname.split("/").slice(2), a = Object(d.a)(i);
					return r.a.createElement("div", {
						className: m.a.avatarPostContainer
					}, r.a.createElement("img", {
						className: m.a.avatarPostImage,
						src: a,
						alt: c.fbt._("User Shared Avatar", null, {
							hk: "FDRaA"
						})
					}), r.a.createElement(l.a, {
						isHovercard: !1,
						username: n,
						isAvatarPost: !0,
						post: o,
						share: {
							username: s,
							avatarId: i
						}
					}))
				},
				h = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				b = n("./src/reddit/hooks/useIsAvatarPost.ts"),
				f = n("./src/reddit/icons/fonts/OutboundLink/index.tsx"),
				g = n("./src/reddit/components/SourceLink/index.m.less"),
				v = n.n(g),
				C = n("./src/lib/lessComponent.tsx"),
				y = n("./src/telemetry/models/Outbound.ts"),
				E = n("./src/reddit/hooks/useIsRemovedOrDeletedPost.ts");
			const x = C.a.wrapped(f.a, "OutboundLinkIcon", v.a),
				O = C.a.div("SourceLinkWrapper", v.a);

			function _(e) {
				const {
					className: t,
					post: n,
					isCommentsPage: o,
					pageLayer: c
				} = e, d = o ? y.SourceElement.PostLink : y.SourceElement.ListingPostLink, {
					source: l
				} = n, u = n.isSponsored || Object(s.u)(c), m = Object(b.a)(n), f = Object(E.a)();
				return !l || f ? null : m ? r.a.createElement(p, {
					sourceUrl: l.url,
					username: n.author,
					post: n
				}) : r.a.createElement(O, {
					className: Object(i.a)({
						[v.a["m-comment"]]: o
					}, t)
				}, r.a.createElement(h.a, {
					href: l.url,
					isSponsored: u,
					postId: n.id,
					source: l,
					sourceElement: d
				}, Object(a.a)({
					...n,
					isSponsored: u
				}), r.a.createElement(x, {
					isFilled: !0
				})))
			}
		},
		"./src/reddit/components/StructuredStyles/BladeManager/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/reddit/connectors/connectClickToToggleEditor.ts");
			class i extends r.a.Component {
				constructor() {
					super(...arguments), this.onClickCapture = e => {
						this.props.isEditing && this.props.subredditId && !this.props.isModalOpen && (e.stopPropagation(), e.preventDefault(), this.props.requestCloseBlade())
					}
				}
				render() {
					return r.a.createElement("div", {
						className: this.props.className,
						onClickCapture: this.onClickCapture,
						children: this.props.children
					})
				}
			}
			var a = Object(s.a)(i);
			t.a = e => r.a.createElement(a, e)
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/navs.m.less": function(e, t, n) {
			e.exports = {
				FormNavElement: "KLpkXNw-FZfqtRK9U_8HB",
				formNavElement: "KLpkXNw-FZfqtRK9U_8HB",
				disabled: "_2omjYUqCweNidaShU2H5EC",
				DragCard: "ygS6b189jD1GHwzotinJB",
				dragCard: "ygS6b189jD1GHwzotinJB",
				isOverAndCanDrop: "_3_GRCa3UIhqQ68fvB00PLZ",
				isDragging: "_2yg01oNjKP8Gcb4HPjf58k"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return l
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/StructuredStyles/StyledComponents/navs.m.less"),
				a = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const d = e => {
					let {
						disabled: t,
						...n
					} = e;
					return r.a.createElement("div", c({}, n, {
						className: Object(s.a)(a.a.FormNavElement, {
							[a.a.disabled]: t
						})
					}), n.children)
				},
				l = e => {
					let {
						canDrop: t,
						className: n,
						isDragging: o,
						isOver: i,
						disabled: d,
						...l
					} = e;
					return r.a.createElement("div", c({}, l, {
						className: Object(s.a)(a.a.DragCard, {
							[a.a.disabled]: d,
							[a.a.isDraffing]: o,
							[a.a.isOverAndCanDrop]: i && t
						}, n)
					}))
				}
		},
		"./src/reddit/components/SubredditNameLink/index.m.less": function(e, t, n) {
			e.exports = {
				SubredditName: "_3ryJoIoycVkA88fy40qNJc",
				subredditName: "_3ryJoIoycVkA88fy40qNJc"
			}
		},
		"./src/reddit/components/SubredditNameLink/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				r = n("./src/reddit/components/SubredditNameLink/index.m.less"),
				s = n.n(r);
			const i = n("./src/lib/lessComponent.tsx").a.wrapped(o.a, "SubredditName", s.a);
			t.a = i
		},
		"./src/reddit/components/SubscribeButton/Inline.m.less": function(e, t, n) {
			e.exports = {
				ButtonSpacer: "vXXjS_s-Ic4QZpFsPjThV",
				buttonSpacer: "vXXjS_s-Ic4QZpFsPjThV",
				Checkmark: "_2qm48d8K8lTcwSJiHL9KLT",
				checkmark: "_2qm48d8K8lTcwSJiHL9KLT",
				Plus: "_2zcGm9WDxG67GYyNNvHzlA",
				plus: "_2zcGm9WDxG67GYyNNvHzlA"
			}
		},
		"./src/reddit/components/SubscribeButton/Inline.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/reddit/components/TrackingHelper/index.tsx"),
				i = n("./src/reddit/connectors/SubscribeButton/index.ts"),
				a = n("./src/reddit/controls/Button/index.tsx"),
				c = n("./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts"),
				d = n("./src/reddit/components/SubscribeButton/Inline.m.less"),
				l = n.n(d);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const m = n("./src/lib/lessComponent.tsx").a.div("ButtonSpacer", l.a);
			class p extends r.a.Component {
				constructor(e) {
					super(e), this.onMouseEnter = () => {
						this.setState({
							isHovered: !0
						})
					}, this.onMouseLeave = () => {
						this.setState({
							isHovered: !1
						})
					}, this.onClick = e => {
						const {
							props: t
						} = this;
						if (t.userIsSubscriber ? t.onUnsubscribe() : (this.setState({
								hasJustSubscribed: !0
							}), t.onSubscribe()), t.onClick && t.onClick(e), t.getEventFactory) {
							const e = t.getEventFactory(t.userIsSubscriber);
							e && t.sendEvent(e)
						}
					}, this.renderUnsubscribeButton = () => {
						const {
							className: e,
							identifier: t,
							onSubscribe: n,
							onUnsubscribe: o,
							postId: s,
							sendEvent: i,
							size: d,
							userIsSubscriber: l,
							doNotHideOtherSubscribeButtons: m,
							getEventFactory: p,
							onSubscriptionsRequested: h,
							priority: b,
							isShredditParityEnabled: f,
							...g
						} = this.props, v = this.state.isHovered, C = Object(c.a)({
							type: t.type,
							key: v ? "unsubscribe" : "subscribed"
						}), y = g.shouldReverseColor ? a.c.Secondary : a.c.Primary;
						return r.a.createElement(a.t, u({
							className: e,
							priority: b || y,
							rplStyle: f,
							text: C,
							onClick: this.onClick,
							onMouseEnter: this.onMouseEnter,
							onMouseLeave: this.onMouseLeave,
							size: a.d.XSP
						}, g))
					}, this.renderSubscribeButton = () => {
						const {
							className: e,
							identifier: t,
							onSubscribe: n,
							onUnsubscribe: o,
							postId: s,
							sendEvent: i,
							size: d,
							userIsSubscriber: l,
							doNotHideOtherSubscribeButtons: m,
							getEventFactory: p,
							onSubscriptionsRequested: h,
							priority: b,
							isShredditParityEnabled: f,
							...g
						} = this.props, v = Object(c.a)({
							type: t.type,
							key: "subscribe"
						}), C = g.shouldReverseColor ? a.c.Secondary : a.c.Primary;
						return r.a.createElement(a.t, u({
							className: e,
							priority: b || C,
							size: a.d.XSP,
							rplStyle: f,
							text: v,
							onClick: this.onClick
						}, g, {
							id: `subscribe-button-${s}`,
							onMouseEnter: this.onMouseEnter,
							onMouseLeave: this.onMouseLeave
						}))
					}, this.state = {
						hasJustSubscribed: !1,
						isHovered: !1
					}
				}
				componentDidMount() {
					this.props.onSubscriptionsRequested()
				}
				render() {
					const {
						small: e = !1,
						userIsSubscriber: t,
						doNotHideOtherSubscribeButtons: n
					} = this.props;
					return t ? this.state.hasJustSubscribed || n ? this.renderUnsubscribeButton() : e ? null : r.a.createElement(m, null) : this.renderSubscribeButton()
				}
			}
			t.a = Object(i.a)(Object(s.c)(p))
		},
		"./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js");
			const r = e => {
					let {
						type: t
					} = e;
					return "subreddit" === t ? "subredditActions" : "profileActions"
				},
				s = {
					subredditActions: {
						subscribe: () => o.fbt._("Join", null, {
							hk: "3Nhj3V"
						}),
						subscribed: () => o.fbt._("Joined", null, {
							hk: "1YGago"
						}),
						unsubscribe: () => o.fbt._("Leave", null, {
							hk: "299znK"
						})
					},
					profileActions: {
						subscribe: () => o.fbt._("Follow", null, {
							hk: "18PRa5"
						}),
						subscribed: () => o.fbt._("Following", null, {
							hk: "sjS3y"
						}),
						unsubscribe: () => o.fbt._("Unfollow", null, {
							hk: "3c0uwF"
						})
					}
				},
				i = e => {
					let {
						type: t,
						key: n
					} = e;
					return s[r({
						type: t
					})][n]()
				}
		},
		"./src/reddit/components/Thumbnail/index.m.less": function(e, t, n) {
			e.exports = {
				blurredThumbnail: "GnWcY6GPzeZ5rzsiQ98fo",
				container: "_2MkcR85HDnYngvlVW2gMMa",
				contentType: "_2hIvPRO2xz4rn9LXAJXYDa",
				hasType: "_10qSZsDWnOBwx4bc7GJ1QF",
				hiddenImage: "_25ZOvQhQdAqwdxPd5z-KFB",
				imageThumbnail: "_33Pa96SGhFVpZeI6a7Y_Pl",
				verticallyCenterThumbnail: "Fq7oYOARH1VVCaLAuAh37",
				linkIcon: "m0n699kowSp8Wfa40lqpF",
				outboundLinkIcon: "_2rOixIHGmpfZB93ihJsw3V",
				placeholderThumbnail: "_2YO2O4rMRYYMeH_t2y8M5w",
				thumbnail: "_2c1ElNxHftd8W_nZtcG9zf",
				usePreview: "_78ohNtfA1urjgUhnN1jLi",
				LinkText: "_3HXDOeeCKnmgu_pIdoLofi",
				linkText: "_3HXDOeeCKnmgu_pIdoLofi"
			}
		},
		"./src/reddit/components/Thumbnail/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return j
			})), n.d(t, "c", (function() {
				return P
			}));
			var o = n("./src/lib/isUrl/index.ts"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				c = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/ImageWithFallback/index.tsx"),
				l = n("./src/reddit/controls/ContentType/index.tsx"),
				u = n("./src/reddit/controls/OutboundLink/index.tsx"),
				m = n("./src/reddit/icons/fonts/OutboundLink/index.tsx"),
				p = n("./src/reddit/models/Media/index.ts"),
				h = n("./src/reddit/models/Theme/index.ts"),
				b = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				f = n("./src/telemetry/models/Outbound.ts"),
				g = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				v = n("./src/reddit/components/Thumbnail/index.m.less"),
				C = n.n(v);

			function y() {
				return (y = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const E = e => e.placeholderImage || Object(b.a)(e).placeholderImage,
				x = e => e.placeholderImage ? "cover" : Object(b.a)(e).placeholderImagePosition,
				O = c.a.span("LinkText", C.a),
				_ = e => {
					let {
						className: t,
						onClick: n,
						children: o
					} = e;
					return s.a.createElement("div", {
						onClick: n,
						className: Object(i.a)(C.a.linkIcon, t)
					}, o)
				},
				k = e => s.a.createElement("img", {
					alt: e.alt,
					className: Object(i.a)(C.a.hiddenImage, e.className)
				}),
				j = e => {
					const t = s.a.createRef(),
						{
							src: n,
							errorSrc: o
						} = e;
					return n && o && Object(d.b)(n).catch(() => {
						t.current && (t.current.style.backgroundImage = `url(${o})`)
					}), s.a.createElement("div", {
						"aria-label": e.alt,
						className: Object(i.a)(C.a.thumbnail, C.a.imageThumbnail, e.className),
						"data-click-id": "image",
						"data-adclicklocation": g.a.MEDIA,
						ref: t,
						role: "img",
						style: {
							backgroundImage: `url(${e.src})`,
							borderColor: e.isOutbound ? Object(b.a)(e).button : Object(b.a)(e).line
						}
					}, e.isOutbound && s.a.createElement(_, {
						className: e.linkIconClassName
					}, s.a.createElement(m.a, {
						className: Object(i.a)(C.a.outboundLinkIcon, e.outboundLinkIconClassName),
						isFilled: !0
					}), e.text && s.a.createElement(O, {
						className: e.linkTextClassName
					}, e.text)), s.a.createElement(k, {
						alt: e.alt,
						className: "hiddenImg"
					}))
				},
				S = e => e.isOutbound ? Object(b.a)(e).button : e.placeholderImage ? "transparent" : Object(b.a)(e).line,
				T = e => {
					const t = E(e),
						n = t && {
							background: Object(h.g)(Object(b.a)(e).placeholder, t, x(e))
						};
					return s.a.createElement("div", {
						className: Object(i.a)(C.a.thumbnail, C.a.placeholderThumbnail, e.className),
						"data-click-id": "image",
						style: {
							...n,
							borderColor: S(e)
						}
					}, (!e.placeholderImage || e.showContentType) && s.a.createElement(l.a, {
						className: Object(i.a)(e.contentTypeClassName, C.a.contentType, {
							[C.a.hasType]: e.type && !e.isOutbound
						}),
						type: e.isMeta || e.isPoll ? "meta" : e.type
					}), e.isOutbound && s.a.createElement(_, {
						className: e.linkIconClassName
					}, s.a.createElement(m.a, {
						className: Object(i.a)(C.a.outboundLinkIcon, e.outboundLinkIconClassName),
						isFilled: !0
					}), e.text && s.a.createElement(O, {
						className: e.linkTextClassName
					}, e.text)))
				},
				w = e => s.a.createElement(j, y({}, e, {
					className: Object(i.a)(C.a.blurredThumbnail, e.className)
				})),
				I = Object(a.a)(e => {
					const {
						className: t,
						containerClassName: n,
						contentTypeClassName: r,
						crosspost: a,
						forceShowNSFW: c,
						isCommentsPage: d,
						isMeta: l,
						linkIconClassName: m,
						linkTextClassName: h,
						outboundLinkIconClassName: b,
						post: g,
						redditStyle: v,
						removeLink: y,
						showContentType: x,
						templatePlaceholderImage: O,
						text: _,
						theme: k,
						usePreview: j
					} = e, S = !k.subredditContext.shouldShowNSFWContent && (g.isNSFW || !(!a || !a.isNSFW)) && !c, T = E({
						placeholderImage: O,
						redditStyle: v,
						theme: k
					}), w = P(e), I = d ? f.SourceElement.PostImage : f.SourceElement.ListingPostImage, R = N(g, t, T, S, _, k, w, l, x, y, v, m, h, b, r), M = Object(p.E)(g);
					return Object(o.a)(M) && !y && M.indexOf("redditmedia") < 0 ? s.a.createElement("div", {
						className: Object(i.a)(C.a.container, j ? C.a.usePreview : "", n)
					}, s.a.createElement(u.b, {
						href: Object(p.E)(g),
						isSponsored: g.isSponsored,
						postId: g.id,
						source: g.source,
						sourceElement: I
					}, R)) : s.a.createElement("div", {
						className: Object(i.a)(C.a.container, j ? C.a.usePreview : "", n)
					}, R)
				}),
				P = e => {
					let {
						crosspost: t,
						post: n,
						url: o,
						usePreview: r
					} = e;
					if (o) return o;
					const {
						preview: s,
						thumbnail: i
					} = t || n;
					return r && s ? s.url : n.isSponsored && s && "default" === i.url ? s.url : i.url
				},
				N = (e, t, n, r, a, c, d, l, u, m, p, h, b, f, g) => {
					const v = (e => e.source && !e.isSponsored || !1)(e);
					if (Object(o.a)(d)) {
						const n = Object(i.a)(t);
						return r ? s.a.createElement(w, {
							"data-click-id": "image",
							src: d,
							className: n,
							isOutbound: v && !m,
							linkIconClassName: h,
							linkTextClassName: b,
							outboundLinkIconClassName: f,
							redditStyle: p,
							text: a,
							theme: c
						}) : s.a.createElement(j, {
							alt: e.title,
							className: n,
							src: d,
							isOutbound: v && !m,
							linkIconClassName: h,
							linkTextClassName: b,
							outboundLinkIconClassName: f,
							redditStyle: p,
							text: a,
							theme: c
						})
					}
					return s.a.createElement(T, {
						className: t,
						contentTypeClassName: g,
						placeholderImage: n,
						isMeta: l,
						isOutbound: v && !m,
						linkIconClassName: h,
						linkTextClassName: b,
						outboundLinkIconClassName: f,
						redditStyle: p,
						showContentType: u,
						text: a,
						theme: c,
						type: e.media ? e.media.type : null,
						isPoll: !!e.pollData
					})
				};
			t.b = I
		},
		"./src/reddit/components/ThumbnailSelector/index.m.less": function(e, t, n) {
			e.exports = {
				Component: "uqOt5KqJAqw5pe-WNxa0a",
				component: "uqOt5KqJAqw5pe-WNxa0a",
				TitleRow: "HEiFtUR3s93dQ2jUWWnxr",
				titleRow: "HEiFtUR3s93dQ2jUWWnxr",
				Close: "_3RlS_q06rJ_8dy_UNp3Ev7",
				close: "_3RlS_q06rJ_8dy_UNp3Ev7",
				CloseWrapper: "_3lFQIq1yN1kLxjZb5AvHjL",
				closeWrapper: "_3lFQIq1yN1kLxjZb5AvHjL",
				ThumbnailsContainer: "_2sw7c1Sfzp0uz-RIcglCo",
				thumbnailsContainer: "_2sw7c1Sfzp0uz-RIcglCo",
				Image: "_2H32szY9NZ1aKr6j4Ced7u",
				image: "_2H32szY9NZ1aKr6j4Ced7u",
				thumbnail: "_2Ks8P6YD1-8_Ju3IrYpPJf",
				isSelected: "_3oA67AGI49fKcqDP970t4U",
				ButtonRow: "_2Bo7ys2El8ABMVNqYUdrA5",
				buttonRow: "_2Bo7ys2El8ABMVNqYUdrA5",
				CancelButton: "mBq3crGX9-xOOg-b-1V85",
				cancelButton: "mBq3crGX9-xOOg-b-1V85"
			}
		},
		"./src/reddit/components/ThumbnailSelector/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/debounce.js"),
				s = n.n(r),
				i = n("./node_modules/lodash/range.js"),
				a = n.n(i),
				c = n("./node_modules/react/index.js"),
				d = n.n(c),
				l = n("./src/lib/classNames/index.ts"),
				u = n("./src/lib/lessComponent.tsx"),
				m = n("./src/higherOrderComponents/asModal/index.tsx"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				h = n("./src/reddit/helpers/media/index.ts"),
				b = n("./src/reddit/helpers/styles/mixins/loading.ts"),
				f = n("./src/reddit/icons/svgs/Close/index.tsx"),
				g = n("./src/reddit/layout/row/Inline/index.tsx"),
				v = n("./src/reddit/components/ThumbnailSelector/index.m.less"),
				C = n.n(v);
			const y = 10,
				E = Object(m.a)(u.a.div("Component", C.a)),
				x = u.a.wrapped(g.a, "TitleRow", C.a),
				O = u.a.wrapped(f.a, "Close", C.a),
				_ = u.a.div("CloseWrapper", C.a),
				k = u.a.div("ThumbnailsContainer", C.a),
				j = u.a.img("Image", C.a),
				S = e => d.a.createElement("div", {
					className: Object(l.a)(C.a.thumbnail, Object(b.a)({
						isLoading: e.isLoading
					}), {
						[C.a.isSelected]: e.isSelected
					}),
					onClick: e.onClick,
					ref: e.elementRef
				}, e.thumbnail.url && d.a.createElement(j, {
					src: e.thumbnail.url
				})),
				T = u.a.wrapped(g.a, "ButtonRow", C.a),
				w = p.l,
				I = u.a.wrapped(p.o, "CancelButton", C.a),
				P = (e, t) => {
					if (1 === e) return [0];
					const n = a()(0, t, t / (e - 1));
					return n.push(t), n.map(e => +e.toFixed(2))
				};
			class N extends d.a.Component {
				constructor(e) {
					super(e), this.isThumbnailsAreGenerating = !1, this.setSelectedElementRef = e => this.selectedElement = e, this.setThumbnails = s()(e => this.setState({
						thumbnails: e
					}), 100), this.scrollIntoView = () => {
						this.selectedElement && this.selectedElement.scrollIntoView({})
					}, this.setSelected = e => {
						this.setState({
							selectedIndex: e
						})
					}, this.onSelectButton = () => {
						const {
							selectedIndex: e
						} = this.state, t = this.state.thumbnails[e];
						this.props.onSelect({
							time: t.time,
							url: t.url
						})
					};
					const {
						thumbnailsCount: t = y,
						selected: n,
						videoDuration: o
					} = this.props, r = P(t, o).map(e => ({
						time: e,
						url: n && n.time === e ? n.url : void 0
					})), i = n ? r.findIndex(e => n.time === e.time) : -1;
					this.state = {
						thumbnails: r,
						selectedIndex: i
					}
				}
				componentDidMount() {
					this.scrollIntoView(), this.props.isOpen && this.generateVideoThumbnails()
				}
				componentDidUpdate(e) {
					this.props.isOpen && !e.isOpen && (this.scrollIntoView(), this.generateVideoThumbnails())
				}
				async generateVideoThumbnails() {
					const {
						thumbnails: e
					} = this.state;
					if (this.isThumbnailsAreGenerating || !e.find(e => !e.url)) return;
					this.isThumbnailsAreGenerating = !0;
					const t = document.createElement("video"),
						n = document.createElement("canvas");
					await Object(h.q)(t, this.props.videoSource);
					let o = 0;
					t.currentTime = e[o].time, await Object(h.e)(t, n, t => (e[o].url = t.dataUrl, o++, this.setThumbnails(e), o < e.length ? e[o].time : null)), this.setState({
						thumbnails: e
					}), this.isThumbnailsAreGenerating = !1
				}
				render() {
					if (!this.props.isOpen) return null;
					const {
						selectedIndex: e,
						thumbnails: t
					} = this.state;
					return d.a.createElement(E, {
						withOverlay: !0
					}, d.a.createElement(x, null, o.fbt._("Choose thumbnail", null, {
						hk: "XlI0H"
					}), d.a.createElement(_, {
						onClick: this.props.onToggleModal
					}, d.a.createElement(O, null))), d.a.createElement(k, null, t.map((t, n) => d.a.createElement(S, {
						key: n,
						elementRef: n === e ? this.setSelectedElementRef : void 0,
						isLoading: !t.url,
						onClick: () => this.setSelected(n),
						isSelected: n === e,
						thumbnail: t
					}))), d.a.createElement(T, null, d.a.createElement(I, {
						onClick: this.props.onToggleModal
					}, o.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), d.a.createElement(w, {
						onClick: this.onSelectButton
					}, o.fbt._("Select", null, {
						hk: "3s53WD"
					}))))
				}
			}
			t.a = N
		},
		"./src/reddit/components/UserIcon/CurrentUserIcon.tsx": function(e, t, n) {
			"use strict";
			var o = n("./src/lib/classNames/index.ts"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/reddit/helpers/userSnoovatar/index.ts"),
				d = n("./src/reddit/selectors/user.ts"),
				l = n("./src/reddit/components/UserIcon/PresenceDot.tsx"),
				u = n("./src/reddit/components/UserIcon/SnoovatarHeadshot.tsx"),
				m = n("./src/reddit/components/UserIcon/UserIcon.tsx"),
				p = n("./src/reddit/components/UserIcon/UserIcon.m.less"),
				h = n.n(p);

			function b() {
				return (b = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const f = Object(a.c)({
					currentUser: d.m,
					isNightMode: d.fb,
					isPresenceUserPrefEnabled: d.X,
					shouldHideNSFW: d.H
				}),
				g = Object(i.b)(f);
			t.a = g(e => {
				const {
					currentUser: t,
					shouldShowPresenceIndicator: n,
					isPresenceUserPrefEnabled: r,
					wrapperClassName: i,
					...a
				} = e, d = Object(c.a)(null == t ? void 0 : t.accountIcon);
				return s.a.createElement("div", {
					className: Object(o.a)(h.a.currentUserIconWrapper, i)
				}, d ? s.a.createElement(u.a, {
					headshot: t.accountIcon,
					className: e.className
				}) : s.a.createElement(m.b, b({}, a, {
					iconUrl: t ? t.accountIcon : void 0,
					isCurrentUser: !0,
					isNSFW: !!t && t.isNSFW
				})), n && s.a.createElement(l.default, {
					showPresence: !0
				}))
			})
		},
		"./src/reddit/components/UsersCountIndicator/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "g", (function() {
				return d
			}));
			const o = 5,
				r = 2,
				s = 1e4,
				i = 2e3,
				a = 3e4,
				c = 1e4,
				d = 2
		},
		"./src/reddit/components/VerticalVotes/votes.m.less": function(e, t, n) {
			e.exports = {
				customDownvote: "ceU_3ot04pOVIcrrXH9fY",
				compact: "_3sO1xEnOT_9CQBjRzczQjS",
				voted: "_8dpZTfzgKPKCUTjp9SAn1",
				customUpvote: "_2k73nZrjAYiwAj9hv7K-kq"
			}
		},
		"./src/reddit/components/VerticalVotes/votes.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return I
			})), n.d(t, "b", (function() {
				return P
			})), n.d(t, "c", (function() {
				return N
			})), n.d(t, "d", (function() {
				return R
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/CSSVariableProvider/withTheme.tsx");
			const a = (e, t, n) => o => {
				const r = e(o),
					i = t(o),
					a = !r && i;
				return Object(s.a)(n.baseClassName, o.className, {
					[n.mIsInteractive]: i,
					[n.mIsActive]: r,
					[n.mIsVoteable]: a
				})
			};
			var c = n("./src/reddit/icons/fonts/Downvote/index.tsx"),
				d = n("./src/reddit/models/Vote/index.ts"),
				l = n("./src/reddit/controls/Downvote/index.m.less"),
				u = n.n(l);
			const m = {
					...u.a,
					baseClassName: u.a.Downvote
				},
				p = e => {
					let {
						voteState: t
					} = e;
					return t === d.a.downvoted
				},
				h = a(p, e => {
					let {
						interactive: t
					} = e;
					return !1 !== t
				}, m);
			var b = e => r.a.createElement(c.a, {
					className: h(e),
					compact: e.compact,
					isFilled: p(e)
				}),
				f = n("./src/reddit/icons/fonts/Upvote/index.tsx"),
				g = n("./src/reddit/controls/Upvote/index.m.less"),
				v = n.n(g);
			const C = {
					...v.a,
					baseClassName: v.a.Upvote
				},
				y = e => {
					let {
						voteState: t
					} = e;
					return t === d.a.upvoted
				},
				E = a(y, e => {
					let {
						interactive: t
					} = e;
					return !1 !== t
				}, C);
			var x = e => r.a.createElement(f.b, {
					className: E(e),
					compact: e.compact,
					isFilled: y(e)
				}),
				O = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				_ = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				k = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				j = n("./src/reddit/components/VerticalVotes/votes.m.less"),
				S = n.n(j);

			function T() {
				return (T = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const w = e => Object(s.a)({
					[S.a.compact]: e.compact,
					[S.a.dark]: Object(_.b)(Object(O.a)(e)),
					[S.a.nightmode]: e.isNightMode
				}),
				I = Object(i.a)(e => {
					const {
						voteIcons: t
					} = Object(k.a)(e), n = {
						"--verticalvotes-customdownvote-active": `url(${t.downvoteActive})`,
						"--verticalvotes-customdownvote-inactive": `url(${t.downvoteInactive})`
					}, {
						theme: o,
						isNightMode: i,
						voteState: a,
						compact: c,
						...l
					} = e;
					return r.a.createElement("button", T({}, l, {
						className: Object(s.a)(S.a.customDownvote, w(e), {
							[S.a.voted]: e.voteState === d.a.downvoted
						}, e.className),
						style: n
					}))
				}),
				P = Object(i.a)(e => {
					const {
						voteIcons: t
					} = Object(k.a)(e), n = {
						"--verticalvotes-customupvote-active": `url(${t.upvoteActive})`,
						"--verticalvotes-customupvote-inactive": `url(${t.upvoteInactive})`
					}, {
						theme: o,
						isNightMode: i,
						voteState: a,
						compact: c,
						...l
					} = e;
					return r.a.createElement("button", T({}, l, {
						className: Object(s.a)(S.a.customUpvote, w(e), {
							[S.a.voted]: e.voteState === d.a.upvoted
						}, e.className),
						style: n
					}))
				}),
				N = b,
				R = x
		},
		"./src/reddit/components/Widgets/PostCollection/CollectionOverflowMenu/index.m.less": function(e, t, n) {
			e.exports = {
				DropdownRow: "JoWBeMWu_l8J_Hn6Udz_j",
				dropdownRow: "JoWBeMWu_l8J_Hn6Udz_j"
			}
		},
		"./src/reddit/components/Widgets/PostCollection/CollectionOverflowMenu/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/lodash/noop.js"),
				r = n.n(o),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/react-router-redux/es/index.js"),
				d = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/post.ts"),
				m = n("./src/reddit/actions/postCollection/index.ts"),
				p = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				h = n("./src/reddit/components/OverflowMenu/index.tsx"),
				b = n("./src/reddit/components/TrackingHelper/index.tsx"),
				f = n("./src/reddit/controls/Dropdown/Row.tsx"),
				g = n("./src/reddit/selectors/activeModalId.ts"),
				v = n("./src/reddit/selectors/postCollection.ts"),
				C = n("./node_modules/reselect/es/index.js"),
				y = n("./src/reddit/helpers/trackers/postCollection.ts"),
				E = n("./src/reddit/components/Widgets/PostCollection/CollectionOverflowMenu/index.m.less"),
				x = n.n(E),
				O = n("./node_modules/fbt/lib/FbtPublic.js");
			const _ = d.a.wrapped(f.b, "DropdownRow", x.a);
			let k;
			const j = Object(g.b)("DELETE_COLLECTION_CONFM_MODAL_ID"),
				S = Object(g.b)("EDIT_POST_COLLECTION_MODAL_ID"),
				T = Object(C.c)({
					createPostUrl: v.d,
					isDeleteConfirmModalOpen: j,
					isEditCollectionModalOpen: S,
					shouldShowCollectionEditOptions: v.s
				}),
				w = Object(a.b)(T, (e, t) => ({
					copyLink: () => e(Object(u.C)(t.permalink)),
					onCreatePost: n => {
						t.shouldShowCreatePost && e(Object(c.b)(n))
					},
					onRemoveCollection: () => e(Object(m.c)(t.collectionId, t.isSubmitPage)),
					onToggleDeleteConfirmModal: () => e(l.i("DELETE_COLLECTION_CONFM_MODAL_ID")),
					onToggleEditModal: async () => {
						k || (k = await Promise.all([n.e("vendors~CryptoHarbergerTaxManageModal~HarbergerTaxManageModal~ModerationPages~PostCreation~Settings~~f8934a85"), n.e("editCollectionModal")]).then(n.bind(null, "./src/reddit/components/EditCollectionModal/index.tsx")).then(e => e.EditCollectionModal)), e(l.i("EDIT_POST_COLLECTION_MODAL_ID"))
					}
				}));
			t.a = w(Object(b.c)(e => {
				const {
					className: t,
					collectionId: n,
					copyLink: o,
					createPostUrl: s,
					isDeleteConfirmModalOpen: a,
					isEditCollectionModalOpen: c,
					onCreatePost: d,
					onRemoveCollection: l,
					onToggleDeleteConfirmModal: u,
					onToggleEditModal: m,
					shouldShowCollectionEditOptions: b,
					shouldShowCreatePost: f,
					targetPosition: g,
					tooltipPosition: v,
					sendEvent: C
				} = e;
				return i.a.createElement(i.a.Fragment, null, i.a.createElement(h.b, {
					className: t,
					dropdownId: `collection-menu-${n}-${f?1:2}`,
					onClick: r.a,
					targetPosition: g,
					tooltipPosition: v
				}, i.a.createElement(_, {
					onClick: o,
					displayText: O.fbt._("Copy collection link", null, {
						hk: "3Rfodz"
					})
				}), b && i.a.createElement(i.a.Fragment, null, i.a.createElement(_, {
					onClick: () => {
						C(Object(y.l)(n)), m()
					},
					displayText: O.fbt._("Edit", null, {
						hk: "1nftDt"
					})
				}), i.a.createElement(_, {
					onClick: () => {
						C(Object(y.k)(n)), u()
					},
					displayText: O.fbt._("Delete collection", null, {
						hk: "2FyIJB"
					})
				}), f && i.a.createElement(_, {
					onClick: () => {
						d(s)
					},
					displayText: O.fbt._("Create post", null, {
						hk: "1v2jHl"
					})
				}))), c && k && i.a.createElement(k, {
					collectionId: n,
					onClose: m,
					onEditSuccess: m
				}), a && i.a.createElement(p.a, {
					actionText: O.fbt._("Yes, Delete", null, {
						hk: "15Espn"
					}),
					headerText: O.fbt._("Delete Collection", null, {
						hk: "1QJ3as"
					}),
					modalText: O.fbt._("Are you sure you want to delete this collection? The posts within the collection won't be deleted.", null, {
						hk: "36jKp5"
					}),
					onConfirm: l,
					toggleModal: u,
					trackClick: r.a
				}))
			}))
		},
		"./src/reddit/components/Widgets/PostCollection/PendingItem/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_135f7-HhEMvekPzYxVBaFE",
				activeItemIndicator: "_31zbCRopTPo2NGtlgVsrBX",
				metaLine: "_1OrlyQwYIehGSk4bhP_l2R",
				title: "_2jvQA1RLlcCLU44q6eB3g0"
			}
		},
		"./src/reddit/components/Widgets/PostCollection/PostItem/OverflowMenu/index.m.less": function(e, t, n) {
			e.exports = {
				DropdownRow: "_3V8ByF4idIiROiWQ9i468R",
				dropdownRow: "_3V8ByF4idIiROiWQ9i468R"
			}
		},
		"./src/reddit/components/Widgets/PostCollection/PostItem/OverflowMenu/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/noop.js"),
				s = n.n(r),
				i = n("./node_modules/react/index.js"),
				a = n.n(i),
				c = n("./node_modules/react-redux/es/index.js"),
				d = n("./src/lib/lessComponent.tsx"),
				l = n("./src/lib/opener/index.ts"),
				u = n("./src/reddit/components/LinkOrOverlayLink/index.tsx"),
				m = n("./src/reddit/components/OverflowMenu/index.tsx"),
				p = n("./src/reddit/controls/Dropdown/Row.tsx"),
				h = n("./src/reddit/helpers/path/index.ts"),
				b = n("./src/reddit/selectors/experiments/eventPosts.ts"),
				f = n("./src/reddit/components/Widgets/PostCollection/PostItem/OverflowMenu/index.m.less"),
				g = n.n(f);
			const v = d.a.wrapped(p.b, "DropdownRow", g.a);
			t.a = e => {
				const {
					isFutureEvent: t,
					onAddEventStartTime: n,
					onEditStartTime: r,
					onStartEventNow: i,
					postPermalink: d,
					shouldShowAddEventStartTime: p,
					targetPosition: f,
					tooltipPosition: g
				} = e, C = !Object(c.e)(b.a);
				return a.a.createElement(m.b, {
					className: e.className,
					dropdownId: e.dropdownId,
					onClick: s.a,
					targetPosition: f,
					tooltipPosition: g
				}, p && n && C && a.a.createElement(v, {
					onClick: n,
					displayText: o.fbt._("Add event start time", null, {
						hk: "4xWttR"
					})
				}), t && i && C && a.a.createElement(v, {
					onClick: i,
					displayText: o.fbt._("Start event now", null, {
						hk: "2TTNfJ"
					})
				}), t && r && C && a.a.createElement(v, {
					onClick: r,
					displayText: o.fbt._("Edit start time", null, {
						hk: "44XUxC"
					})
				}), a.a.createElement(v, {
					onClick: e.onRemoveClick,
					displayText: o.fbt._("Remove from collection", null, {
						hk: "qsiiu"
					})
				}), d && a.a.createElement(u.a, {
					target: l.d.BLANK,
					rel: l.c,
					isOverlay: !1,
					to: Object(h.b)(d)
				}, a.a.createElement(v, {
					displayText: o.fbt._("View post", null, {
						hk: "1PtvnG"
					})
				})))
			}
		},
		"./src/reddit/components/Widgets/PostCollection/PostItem/Placeholder.m.less": function(e, t, n) {
			e.exports = {
				Container: "I9mI9NePKM1BEsmfZR-6H",
				container: "I9mI9NePKM1BEsmfZR-6H",
				Content: "_6d8yyfLZcJ1OXLzEXoApB",
				content: "_6d8yyfLZcJ1OXLzEXoApB",
				Title: "_1efKScSk4JSYvERdEecZnZ",
				title: "_1efKScSk4JSYvERdEecZnZ",
				Secondary: "_3fCsv_r4CtfCTdAzBRaR9N",
				secondary: "_3fCsv_r4CtfCTdAzBRaR9N"
			}
		},
		"./src/reddit/components/Widgets/PostCollection/PostItem/index.m.less": function(e, t, n) {
			e.exports = {
				container: "ceAYEjQdznT14GrQQ52QV",
				content: "_36S4oraLw5gf--rC9-aWZs",
				overflowMenu: "MiZ0gbh9xe5Yiwt3RQf2o",
				metaLine: "_2JVAK9jCDOKkFXe1XS6gwH",
				title: "_2U-RjfXG1sY-NtByFOS-uC"
			}
		},
		"./src/reddit/components/Widgets/PostCollection/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3_XzG2WCa3EYhqzE_vUcMN",
				topRow: "r_Dz4suUXbQkBdwR-eQ77",
				collectionDescription: "_3K3iJQYRdF3d2n1WlPxkpr",
				listContainer: "_2K8wDNk-kaP5gX-QEAXuMc",
				listWrapper: "VYYQfc9_vtbBaR47zbXdB",
				menuButton: "_1BX9a5jz4LWzuQohy4Cvz4"
			}
		},
		"./src/reddit/components/Widgets/PostCollection/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/Widgets/PostCollection/CollectionOverflowMenu/index.tsx"),
				a = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/selectors/postCreations.ts"),
				l = n("./src/reddit/components/Widgets/PostCollection/PendingItem/index.m.less"),
				u = n.n(l);
			const {
				fbt: m
			} = n("./node_modules/fbt/lib/FbtPublic.js"), p = Object(c.c)({
				title: d.wb
			});
			var h = Object(a.b)(p)(e => {
					const {
						title: t
					} = e;
					return r.a.createElement("div", {
						className: u.a.container
					}, r.a.createElement("div", {
						className: u.a.activeItemIndicator
					}), t && r.a.createElement("h2", {
						className: u.a.title
					}, t), r.a.createElement("div", {
						className: u.a.metaLine
					}, m._("Editing", null, {
						hk: "2w5fAf"
					})))
				}),
				b = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				f = n("./src/reddit/actions/postCollection/index.ts"),
				g = n("./src/reddit/helpers/path/index.ts"),
				v = n("./src/reddit/selectors/posts.ts"),
				C = n("./src/reddit/components/HumanDate/index.tsx"),
				y = n("./src/lib/constants/index.ts"),
				E = n("./src/reddit/components/Widgets/PostCollection/PostItem/index.m.less"),
				x = n.n(E),
				O = n("./src/reddit/components/Widgets/PostCollection/PostItem/OverflowMenu/index.tsx"),
				_ = n("./src/reddit/helpers/styles/mixins/loading.ts"),
				k = n("./src/reddit/components/Widgets/PostCollection/PostItem/Placeholder.m.less"),
				j = n.n(k);

			function S(e) {
				let {
					className: t,
					isLoading: n
				} = e;
				const o = Object(_.a)({
					isLoading: n
				});
				return r.a.createElement("div", {
					className: Object(s.a)(j.a.Container, t)
				}, r.a.createElement("div", {
					className: j.a.Content
				}, r.a.createElement("div", {
					className: Object(s.a)(j.a.Title, o)
				}), r.a.createElement("div", {
					className: Object(s.a)(j.a.Secondary, o)
				})))
			}
			const {
				fbt: T
			} = n("./node_modules/fbt/lib/FbtPublic.js"), w = ["right", "bottom"], I = ["right", "top"];
			var P = Object(a.b)(() => Object(c.c)({
					post: v.F
				}), (e, t) => ({
					onRemovePostFromCollection: () => e(Object(f.g)(t.collectionId, t.postId))
				}))(e => {
					const {
						post: t,
						onRemovePostFromCollection: n
					} = e;
					return t ? r.a.createElement("div", {
						className: x.a.container
					}, r.a.createElement("div", {
						className: x.a.content
					}, r.a.createElement(b.a, {
						className: x.a.title,
						target: "_blank",
						to: Object(g.b)(t.permalink)
					}, t.title), r.a.createElement("div", {
						className: x.a.metaLine
					}, T._("Posted  {timeAgo}", [T._param("timeAgo", r.a.createElement(C.d, {
						seconds: t.created / y.Xb
					}))], {
						hk: "ZVJpV"
					}))), r.a.createElement(O.a, {
						onRemoveClick: n,
						className: x.a.overflowMenu,
						dropdownId: "collection-widget-item" + t.id,
						postPermalink: t.permalink,
						targetPosition: w,
						tooltipPosition: I
					})) : r.a.createElement(S, {
						className: x.a.container,
						isLoading: !0
					})
				}),
				N = n("./src/reddit/components/Widgets/PostCollection/index.m.less"),
				R = n.n(N);
			const {
				fbt: M
			} = n("./node_modules/fbt/lib/FbtPublic.js"), D = ["right", "bottom"], L = ["right", "top"];
			class A extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.renderItem = (e, t) => r.a.createElement(P, {
						collectionId: this.props.collection.id,
						key: e,
						postId: e
					})
				}
				render() {
					const {
						className: e,
						collection: t
					} = this.props, n = t.postIds.map(this.renderItem).reverse();
					return r.a.createElement("div", {
						className: Object(s.a)(e, R.a.container)
					}, r.a.createElement("div", {
						className: R.a.topRow
					}, M._("Collection", null, {
						hk: "1pY1s2"
					}), r.a.createElement(i.a, {
						className: R.a.menuButton,
						collectionId: t.id,
						isSubmitPage: !0,
						permalink: t.permalink,
						targetPosition: D,
						tooltipPosition: L
					})), r.a.createElement("h4", {
						className: R.a.collectionDescription
					}, t.title), r.a.createElement("div", {
						className: R.a.listWrapper
					}, r.a.createElement("div", {
						className: R.a.listContainer
					}, n)), r.a.createElement(h, null))
				}
			}
			t.a = A
		},
		"./src/reddit/components/Widgets/SubredditRules/Rule/index.m.less": function(e, t, n) {
			e.exports = {
				RawHTMLDisplay: "_2vztYwRKSDZV2ISjSixByA",
				rawHtmlDisplay: "_2vztYwRKSDZV2ISjSixByA",
				Chevron: "_2U-LBUvfr1W6MEMTGXgzmh",
				chevron: "_2U-LBUvfr1W6MEMTGXgzmh",
				RuleShortName: "_8ZLJI1-ZiP7pHJ_yO1L4Z",
				ruleShortName: "_8ZLJI1-ZiP7pHJ_yO1L4Z",
				pointerCursor: "_3osxlOKfiylmgqNqsW7erB",
				cleanStyle: "_12zeaxHNQC7XniG1qunPev",
				RuleIndex: "_36D5hmBSZbFxkFMkiWg6cY",
				ruleIndex: "_36D5hmBSZbFxkFMkiWg6cY",
				RuleTitle: "tbIApBd2DM_drfZQJjIum",
				ruleTitle: "tbIApBd2DM_drfZQJjIum",
				RuleDescription: "_2QhEclR_DjIrTv_oNU5MMN",
				ruleDescription: "_2QhEclR_DjIrTv_oNU5MMN"
			}
		},
		"./src/reddit/components/Widgets/SubredditRules/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return _
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./src/reddit/components/Widgets/ThemedWidget/index.tsx"),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/RawHTMLDisplay/index.tsx"),
				l = n("./src/reddit/components/RichTextJson/index.tsx"),
				u = n("./src/reddit/helpers/dom/index.ts"),
				m = n("./src/reddit/icons/fonts/index.tsx"),
				p = n("./src/reddit/layout/threeCol/ExpandCenter/index.tsx"),
				h = n("./src/reddit/models/Widgets/index.ts"),
				b = n("./src/reddit/components/Widgets/SubredditRules/Rule/index.m.less"),
				f = n.n(b);
			const g = c.a.div("RuleShortName", f.a),
				v = c.a.div("RuleIndex", f.a),
				C = c.a.div("RuleTitle", f.a),
				y = c.a.div("RuleDescription", f.a),
				E = c.a.wrapped(d.a, "RawHTMLDisplay", f.a),
				x = {};
			class O extends s.a.Component {
				constructor(e) {
					super(e), this.onClick = () => {
						Object(u.f)() || this.setState({
							isVisible: !this.state.isVisible
						})
					}, this.state = {
						isVisible: this.shouldShowFullDisplay(e)
					}
				}
				shouldShowFullDisplay(e) {
					return e.display === h.h.FULL
				}
				render() {
					const {
						props: e,
						state: t,
						onClick: n,
						shouldShowFullDisplay: o
					} = this, r = !!(e.rule.descriptionRichText || e.rule.descriptionHtml || e.rule.description), i = !o(e) && !!r;
					return s.a.createElement(g, {
						className: Object(a.a)({
							[f.a.pointerCursor]: i,
							[f.a.cleanStyle]: e.cleanStyle
						}),
						onClick: o(e) || !r ? void 0 : n
					}, s.a.createElement(p.a, null, s.a.createElement(v, {
						className: Object(a.a)({
							[f.a.cleanStyle]: e.cleanStyle
						})
					}, `${e.humanIndex}.`), s.a.createElement(C, null, `${e.rule.shortName}`), s.a.createElement("div", null, !o(e) && r && s.a.createElement(m.a, {
						name: t.isVisible ? "caret_up" : "caret_down"
					}))), t.isVisible && s.a.createElement(y, {
						className: Object(a.a)({
							[f.a.cleanStyle]: e.cleanStyle
						})
					}, e.rule.descriptionRichText ? s.a.createElement(l.b, {
						content: JSON.parse(e.rule.descriptionRichText),
						useExplicitTextColor: !0,
						rtJsonElementProps: x
					}) : e.rule.descriptionHtml ? s.a.createElement(E, {
						html: e.rule.descriptionHtml
					}) : e.rule.description))
				}
			}
			const _ = e => e.rules.length > 0 ? s.a.createElement(i.a, {
				className: e.className,
				styles: e.styles,
				title: o.fbt._("{subredditName} Rules", [o.fbt._param("subredditName", `r/${e.subredditName}`)], {
					hk: "2AwRLk"
				}),
				redditStyle: e.redditStyle
			}, e.rules.map((function(t, n) {
				return s.a.createElement(O, {
					key: `rule${t.shortName}${t.createdUtc}`,
					rule: t,
					display: e.display,
					humanIndex: n + 1
				})
			}))) : null;
			t.b = e => s.a.createElement(_, {
				rules: e.widget.data || [],
				subredditName: e.subredditName,
				display: e.widget.display,
				redditStyle: e.redditStyle,
				styles: e.widget.styles
			})
		},
		"./src/reddit/components/Widgets/ThemedWidget/index.m.less": function(e, t, n) {
			e.exports = {
				widgetBackground: "_1G4yU68P50vRZ4USXfaceV",
				clickable: "_2mtWlchu4uQf339v56bSha",
				redditStyle: "_2QeqBqfT5UbHBoViZUt-wX",
				truncatedGradient: "_1lvCNVth3dt5y8lu3vT95L",
				widgetHeader: "_ZhON3a3vplThB8NFwuJn",
				widgetTitle: "_2sggAEfRQLyoAl4J__5twU",
				widgetContent: "TmgZY6tDcdErbE5d7E0HJ",
				widgetContentOnly: "_3RPJ8hHnfFohktLZca18J6",
				truncated: "r5dzQq7dgZyAmve8abbbt",
				seeMore: "_3dbp6Cm9uKkkIBr9EsU-qS"
			}
		},
		"./src/reddit/components/Widgets/ThemedWidget/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				d = n("./src/reddit/components/SEOTitle/index.tsx"),
				l = n("./src/reddit/components/TrackingHelper/index.tsx"),
				u = n("./src/reddit/contexts/PageLayer/index.tsx"),
				m = n("./src/reddit/controls/Button/index.tsx"),
				p = n("./src/reddit/helpers/trackers/widgets.ts"),
				h = n("./src/reddit/models/NewStructuredStyles/index.ts"),
				b = n("./src/reddit/selectors/experiments/topPosts.ts"),
				f = n("./src/reddit/selectors/structuredStyles.ts"),
				g = n("./src/reddit/selectors/user.ts"),
				v = n("./src/reddit/models/Theme/index.ts"),
				C = n("./src/reddit/models/Theme/NewColorSystem/index.ts");
			const y = e => e.styles && e.styles.backgroundColor ? e.styles.backgroundColor : Object(C.a)(e).widgetColors.sidebarWidgetBackgroundColor,
				E = e => e.styles && e.styles.headerColor ? e.styles.headerColor : Object(C.a)(e).widgetColors.sidebarWidgetHeaderColor,
				x = e => {
					const t = y(e);
					return Object(v.f)(t)
				},
				O = e => {
					const t = E(e);
					return Object(v.f)(t)
				};
			var _ = n("./src/reddit/components/Widgets/ThemedWidget/index.m.less"),
				k = n.n(_);
			const {
				fbt: j
			} = n("./node_modules/fbt/lib/FbtPublic.js"), S = Object(u.v)(), T = Object(s.b)(() => Object(i.c)({
				forceRedditStyle: (e, t) => {
					const n = Object(u.o)(e, t) || void 0,
						o = t.redditStyle || Object(f.l)(e, {
							subredditId: n
						}),
						r = Object(g.fb)(e);
					return o || r
				},
				nigtmode: g.fb,
				subredditId: u.o,
				topPostVariant: b.d
			}));
			class w extends r.a.Component {
				constructor() {
					super(...arguments), this.contentRef = r.a.createRef(), this.state = {
						isTruncated: !1
					}, this.handleSeeMoreClick = () => {
						const {
							subredditId: e,
							widgetKind: t
						} = this.props;
						e && t && this.props.sendEvent(Object(p.b)(e, t)), this.setState({
							isTruncated: !1
						})
					}
				}
				componentDidMount() {
					const e = this.contentRef.current,
						t = e && e.offsetHeight;
					this.props.truncateThreshold && t && t > this.props.truncateThreshold && this.setState({
						isTruncated: !0
					})
				}
				getWidgetBackgroundStyles() {
					const e = {};
					return e.backgroundColor = y(this.props), e.borderColor = Object(h.d)(e.backgroundColor, this.props.nigtmode), e.color = e.fill = x(this.props), e
				}
				getWidgetHeaderStyles() {
					const e = {};
					return e.backgroundColor = E(this.props), e.color = e.fill = O(this.props), e
				}
				render() {
					const {
						children: e,
						className: t,
						contentOnly: n,
						forceRedditStyle: o,
						headerButton: s,
						id: i,
						onClick: c,
						onHeaderClick: l,
						title: u,
						titleClassName: p,
						truncateThreshold: h
					} = this.props, b = n ? k.a.widgetContentOnly : k.a.widgetContent, f = !o && this.props.styles, g = f ? this.getWidgetBackgroundStyles() : {}, v = f ? this.getWidgetHeaderStyles() : {};
					return r.a.createElement("div", {
						className: Object(a.a)(t, k.a.widgetBackground, {
							[k.a.redditStyle]: o,
							[k.a.clickable]: !!c,
							[k.a.truncatedGradient]: this.state.isTruncated && !this.props.noGradient
						}),
						"data-redditstyle": o,
						onClick: c,
						style: g
					}, u && r.a.createElement("div", {
						className: Object(a.a)(k.a.widgetHeader, {
							[k.a.clickable]: !!l
						}),
						id: i,
						style: {
							...v,
							...this.props.headerStyles
						},
						onClick: l
					}, r.a.createElement("div", {
						className: Object(a.a)(k.a.widgetTitle, p)
					}, r.a.createElement(d.b, {
						type: d.a.Widget
					}, u)), s), r.a.createElement("div", {
						className: Object(a.a)(b, {
							[k.a.truncated]: this.state.isTruncated
						}),
						ref: this.contentRef,
						style: {
							maxHeight: this.state.isTruncated ? h : "none"
						}
					}, e), this.state.isTruncated && r.a.createElement(m.r, {
						className: k.a.seeMore,
						onClick: this.handleSeeMoreClick
					}, j._("See More", null, {
						hk: "4w47Qu"
					})))
				}
			}
			t.a = S(T(Object(c.a)(Object(l.c)(w))))
		},
		"./src/reddit/connectors/SubscribeButton/index.ts": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react-redux/es/index.js"),
				r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/actions/subscription/index.ts"),
				i = n("./src/reddit/selectors/subreddit.ts");
			t.a = Object(o.b)(() => Object(r.c)({
				userIsSubscriber: i.jb
			}), (e, t) => {
				let {
					identifier: n
				} = t;
				return {
					onSubscribe: () => e(s.d([n], !0)),
					onSubscriptionsRequested: () => e(s.e()),
					onUnsubscribe: () => e(s.d([n], !1))
				}
			})
		},
		"./src/reddit/connectors/connectClickToToggleEditor.ts": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react-redux/es/index.js"),
				r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/actions/structuredStyles/index.ts"),
				i = n("./src/reddit/selectors/activeModalId.ts"),
				a = n("./src/reddit/selectors/structuredStyles.ts"),
				c = n("./src/reddit/constants/modals.ts");
			const d = Object(r.c)({
				bladeHasUnsavedChanges: a.a,
				isEditing: a.i,
				isBladeEditorDirty: a.h,
				isModalOpen: Object(i.b)(c.a.BLADE_UNSAVED_CHANGES)
			});
			t.a = Object(o.b)(d, (e, t) => {
				let {
					subredditId: n
				} = t;
				return {
					requestCloseBlade: () => n && e(Object(s.h)(n))
				}
			})
		},
		"./src/reddit/constants/componentSizes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return s
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return u
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "p", (function() {
				return p
			})), n.d(t, "q", (function() {
				return h
			})), n.d(t, "r", (function() {
				return b
			})), n.d(t, "t", (function() {
				return f
			})), n.d(t, "s", (function() {
				return g
			})), n.d(t, "u", (function() {
				return v
			})), n.d(t, "v", (function() {
				return C
			})), n.d(t, "k", (function() {
				return y
			})), n.d(t, "b", (function() {
				return E
			})), n.d(t, "m", (function() {
				return x
			})), n.d(t, "n", (function() {
				return O
			})), n.d(t, "o", (function() {
				return _
			}));
			const o = 284,
				r = 450,
				s = 800,
				i = 284,
				a = 48,
				c = 640,
				d = 1600,
				l = 40,
				u = 48,
				m = 24,
				p = 24,
				h = 312,
				b = 40,
				f = 270,
				g = 106,
				v = 5,
				C = 16,
				y = 1250,
				E = 82,
				x = 48,
				O = 36,
				_ = 40
		},
		"./src/reddit/constants/componentTestIds.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			}));
			const o = "comment",
				r = "comment-submission-form-markdown",
				s = "comment-submission-form-richtext",
				i = "comments-page-link-num-comments",
				a = "language-prompt-close",
				c = "post-content"
		},
		"./src/reddit/constants/jsapiEvents.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			}));
			const o = "reddit",
				r = "reddit.ready",
				s = "reddit.urlChanged"
		},
		"./src/reddit/constants/keycodes.ts": function(e, t, n) {
			"use strict";
			var o, r;
			n.d(t, "a", (function() {
					return o
				})), n.d(t, "b", (function() {
					return r
				})),
				function(e) {
					e[e.ArrowDown = 40] = "ArrowDown", e[e.ArrowLeft = 37] = "ArrowLeft", e[e.ArrowRight = 39] = "ArrowRight", e[e.ArrowUp = 38] = "ArrowUp", e[e.Backspace = 8] = "Backspace", e[e.Delete = 46] = "Delete", e[e.Enter = 13] = "Enter", e[e.Escape = 27] = "Escape", e[e.F = 70] = "F", e[e.K = 75] = "K", e[e.Space = 32] = "Space", e[e.Tab = 9] = "Tab", e[e.Comma = 188] = "Comma"
				}(o || (o = {})),
				function(e) {
					e.ArrowDown = "ArrowDown", e.ArrowLeft = "ArrowLeft", e.ArrowRight = "ArrowRight", e.ArrowUp = "ArrowUp", e.Backspace = "Backspace", e.Enter = "Enter", e.Escape = "Escape", e.F = "f", e.Tab = "Tab", e.Space = " ", e.Comma = ","
				}(r || (r = {}))
		},
		"./src/reddit/constants/postCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "g", (function() {
				return d
			}));
			const o = "PostCreation-AddEventButton",
				r = 500,
				s = "PostCreation-CollectionEducationTooltip",
				i = "PostCreation-EventEducationTooltip",
				a = 300,
				c = a,
				d = "PostCreation-AddToCollectionButton"
		},
		"./src/reddit/constants/screenWidths.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return s
			}));
			const o = 480,
				r = 960,
				s = 1200
		},
		"./src/reddit/contexts/NavbarExp.ts": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = r.a.createContext(!1)
		},
		"./src/reddit/controls/CheckboxInput/index.m.less": function(e, t, n) {
			e.exports = {
				checkboxInput: "_2BPowd18EKTnfZFrj5kY3G",
				disabled: "_303iMx_S0pgrbpYhsYTV6K",
				checkboxSelected: "_2VtQ8EjxlJXdicVJhc73gQ"
			}
		},
		"./src/reddit/controls/CheckboxInput/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/constants/keycodes.ts"),
				a = n("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				c = n("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				d = n("./src/reddit/layout/row/Inline/index.tsx"),
				l = n("./src/reddit/controls/CheckboxInput/index.m.less"),
				u = n.n(l);
			t.a = e => {
				const t = e.onChange && !e.disabled ? t => {
						t.key !== i.b.Enter && t.key !== i.b.Space || e.onChange(!e.value)
					} : void 0,
					n = e.onChange && !e.disabled ? () => e.onChange(!e.value) : void 0;
				return r.a.createElement(d.a, {
					"aria-checked": !!e.value,
					"aria-disabled": e.disabled,
					"aria-labelledby": e.name,
					className: Object(s.a)(e.className, u.a.checkboxInput, e.disabled ? u.a.disabled : null),
					onClick: n,
					onKeyPress: t,
					role: "checkbox",
					tabIndex: 0
				}, r.a.createElement("input", {
					value: e.value ? e.value.toString() : "",
					type: "hidden"
				}), e.value ? r.a.createElement(c.a, {
					className: u.a.checkboxSelected
				}) : r.a.createElement(a.a, null), e.children)
			}
		},
		"./src/reddit/controls/ContentType/index.m.less": function(e, t, n) {
			e.exports = {
				contentTypeIcon: "_3CquMWJ6RMh8E9D-_84AtZ"
			}
		},
		"./src/reddit/controls/ContentType/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/constants/icons.ts"),
				a = n("./src/reddit/icons/fonts/index.tsx"),
				c = n("./src/reddit/constants/elementClassNames.ts"),
				d = n("./src/reddit/controls/ContentType/index.m.less"),
				l = n.n(d);
			const u = e => Object(s.a)(l.a.contentTypeIcon, e.className),
				m = {
					embed: i.a.embed,
					gallery: i.a.media_gallery,
					gifvideo: i.a.gif_post,
					image: i.a.image_post,
					meta: i.a.poll_post,
					rtjson: i.a.text_post,
					text: i.a.text_post,
					video: i.a.video_post,
					liveaudio: i.a.audio
				};

			function p(e) {
				const t = u(e),
					n = e.type && m[e.type] || i.a.link_post;
				return r.a.createElement(a.a, {
					name: n,
					className: Object(s.a)({
						[c.a]: n === i.a.link_post
					}, t)
				})
			}
		},
		"./src/reddit/controls/Downvote/index.m.less": function(e, t, n) {
			e.exports = {
				Downvote: "Q0BxYHtCOJ_rNSPJMU2Y7",
				downvote: "Q0BxYHtCOJ_rNSPJMU2Y7",
				mIsInteractive: "_2fe-KdD2OM0ciaiux-G1EL",
				mIsActive: "_3emIxnIscWEPB7o5LgU_rn",
				mIsVoteable: "_3yQIOwaIuF6gn8db96Gu7y"
			}
		},
		"./src/reddit/controls/Dropdown/Row.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return g
			}));
			var o = n("./node_modules/lodash/throttle.js"),
				r = n.n(o),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/controls/UnstyledInternalLink/index.tsx"),
				d = n("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				l = n("./src/reddit/icons/svgs/Checkmark/index.tsx"),
				u = n("./src/reddit/layout/row/InlineButton/index.tsx"),
				m = n("./src/reddit/controls/Dropdown/index.m.less"),
				p = n.n(m),
				h = n("./src/reddit/controls/Dropdown/row.m.less"),
				b = n.n(h);

			function f() {
				return (f = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			class g extends i.a.Component {
				constructor() {
					super(...arguments), this.handleMouseMove = r()(() => {
						const {
							props: e
						} = this;
						e.handleActivateRow && e.handleActivateRow(e.index)
					}, 500)
				}
				render() {
					const {
						props: e
					} = this, t = e.skipRoleAttr ? null : {
						role: "menuitem"
					}, n = Object(a.a)(b.a.iconWrapper, e.iconWrapperClassName);
					return e.href ? i.a.createElement(c.a, f({}, t, {
						id: e.id,
						className: e.className,
						onBlur: e.onBlur,
						onClick: e.onClick,
						onMouseDown: e.onMouseDown,
						onMouseMove: this.handleMouseMove,
						onKeyDown: e.onKeydown,
						rel: e.rel,
						to: e.href,
						disabled: e.disabled
					}), e.children && i.a.createElement("span", {
						className: n
					}, e.children), i.a.createElement("span", {
						className: Object(a.a)(b.a.text, e.textClassName)
					}, e.displayText)) : i.a.createElement(u.a, f({}, t, {
						id: e.id,
						className: e.className,
						disabled: e.disabled,
						onBlur: e.onBlur,
						onClick: e.onClick,
						onKeyDown: e.onKeydown,
						onMouseDown: e.onMouseDown,
						onMouseMove: r()(this.handleMouseMove, 500)
					}), e.children && (e.noIcon ? i.a.createElement("div", null, e.children) : i.a.createElement("span", {
						className: n
					}, e.children)), e.displayText && i.a.createElement("span", {
						className: Object(a.a)(b.a.text, e.textClassName)
					}, e.displayText), e.showSelectedCheckmark && e.isSelected && i.a.createElement(l.a, {
						className: b.a.checkmark
					}), e.showDropdownTriangle && i.a.createElement(d.a, {
						className: p.a.dropdownTriangle
					}))
				}
			}
			t.b = e => {
				let {
					className: t,
					...n
				} = e;
				const o = Object(a.a)(b.a.row, t, {
					[b.a.mIsInteractive]: !n.noHover,
					[b.a.mIsSelected]: n.isSelected,
					[b.a.topics]: n.isTopicsStyle
				});
				return i.a.createElement(g, f({
					className: o
				}, n))
			}
		},
		"./src/reddit/controls/Dropdown/row.m.less": function(e, t, n) {
			e.exports = {
				iconWrapper: "pthKOcceozMuXLYrLlbL1",
				text: "_2-cXnP74241WI7fpcpfPmg",
				row: "_3LwUIE7yX7CZQKmD2L87vf",
				topics: "kR_ljR-F8vtc-ORj1uipB",
				checkmark: "_3Iua3qlR9JiTwjjk6NKye1",
				muteSubreddit: "ui39KJ4PwbdKkxvIBbLbV",
				modNotes: "sK8_uuNiAqPNlw-HoD2HG",
				mIsSelected: "_1IKtbRloF_LV1hPqMzP3MC",
				mIsInteractive: "_1oYEKCssGFjqxQ9jJMNj5G"
			}
		},
		"./src/reddit/controls/ErrorText/SeeAllTextModal/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_2AfJEqW9tv4b_kolKEuS9K",
				titleRow: "p4QfstubN5cRxd-gy8gFH",
				detailsContainer: "_2V3KEAhexNh-mP3TbrVClC",
				buttonRow: "_1fcbQFwN65ik28DNmWnpX4",
				confirmButton: "zcMEJWBL7q-mYGOPSpjN-"
			}
		},
		"./src/reddit/controls/ErrorText/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_2hGJP-9xfXBXd0wqhBLHhY",
				description: "_3h_9YwxjuOr77VhScPrjCI",
				moreText: "_1Y0BrhDgcSTeSYvmSPYepI"
			}
		},
		"./src/reddit/controls/ErrorText/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return y
			})), n.d(t, "c", (function() {
				return E
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/uniqueId.js"),
				s = n.n(r),
				i = n("./node_modules/raf/index.js"),
				a = n.n(i),
				c = n("./node_modules/react/index.js"),
				d = n.n(c),
				l = n("./src/lib/classNames/index.ts"),
				u = n("./src/higherOrderComponents/asModal/index.tsx"),
				m = n("./src/reddit/controls/Button/index.tsx"),
				p = n("./src/reddit/layout/row/Inline/index.tsx"),
				h = n("./src/reddit/controls/ErrorText/SeeAllTextModal/index.m.less"),
				b = n.n(h);
			var f = Object(u.a)(e => {
					const {
						children: t,
						title: n
					} = e;
					return d.a.createElement("div", {
						className: b.a.wrapper
					}, d.a.createElement(p.a, {
						className: b.a.titleRow
					}, n), d.a.createElement("div", {
						className: b.a.detailsContainer
					}, t), d.a.createElement(p.a, {
						className: b.a.buttonRow
					}, d.a.createElement(m.l, {
						className: b.a.confirmButton,
						onClick: e.onConfirmed
					}, o.fbt._("Ok", null, {
						hk: "2Giu9U"
					}))))
				}),
				g = n("./src/reddit/controls/ErrorText/index.m.less"),
				v = n.n(g);
			class C extends d.a.Component {
				constructor(e) {
					super(e), this.spanRef = d.a.createRef(), this.toggleModal = () => {
						this.setState({
							isModalOpen: !this.state.isModalOpen
						})
					}, this.state = {
						textHasOverflowed: !1,
						modalId: `ErrorTextModal--${s()()}`,
						isModalOpen: !1
					}
				}
				componentDidMount() {
					this.calcTextDidOverflow()
				}
				componentDidUpdate() {
					this.calcTextDidOverflow()
				}
				calcTextDidOverflow() {
					a()(() => {
						const e = this.spanRef.current;
						if (!e) return;
						const t = e.scrollWidth > e.clientWidth;
						this.setState(e => e.textHasOverflowed !== t ? {
							textHasOverflowed: t
						} : null)
					})
				}
				render() {
					const {
						children: e,
						className: t,
						errorModalBody: n,
						errorModalTitle: r = o.fbt._("Error", null, {
							hk: "2nPF4G"
						}),
						moreText: s = o.fbt._("More", null, {
							hk: "1bCAQ0"
						})
					} = this.props, {
						textHasOverflowed: i,
						isModalOpen: a
					} = this.state;
					return d.a.createElement("div", {
						className: Object(l.a)(v.a.wrapper, t)
					}, d.a.createElement("span", {
						className: v.a.description,
						ref: this.spanRef
					}, e), i && d.a.createElement("span", {
						className: v.a.moreText,
						onClick: this.toggleModal
					}, s), a && d.a.createElement(f, {
						onConfirmed: this.toggleModal,
						title: r
					}, n || e))
				}
			}
			const y = e => {
					const {
						className: t,
						errorClassName: n,
						errorModalTitle: o,
						fallbackMessage: r,
						messages: s = []
					} = e, i = s.length ? s : r ? [r] : [];
					return i.length ? d.a.createElement("div", {
						className: t
					}, i.map((e, t) => d.a.createElement(C, {
						className: n,
						errorModalTitle: o,
						key: t
					}, e))) : null
				},
				E = e => d.a.createElement(y, {
					fallbackMessage: o.fbt._("Something went wrong", null, {
						hk: "Cw1BT"
					}),
					messages: e
				});
			t.b = C
		},
		"./src/reddit/controls/FileDrop/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/lodash/flow.js"),
				r = n.n(o),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				a = n("./node_modules/react-dnd/lib/index.js"),
				c = n("./node_modules/react-dnd-html5-backend/lib/index.js"),
				d = n("./src/reddit/helpers/dragDropContext/index.ts");
			const l = c.NativeTypes.FILE,
				u = r()(Object(a.DropTarget)(l, {
					drop: (e, t) => {
						if (t && t.didDrop() || !t) return;
						const n = t.getItem();
						n.files && e.onDrop(n.files)
					}
				}, (e, t) => ({
					connectDropTarget: e.dropTarget(),
					isOver: t.isOver(),
					canDrop: t.canDrop()
				})), d.a);
			class m extends i.a.Component {
				render() {
					return this.props.connectDropTarget ? this.props.connectDropTarget(i.a.createElement("div", {
						className: this.props.className
					}, this.props.render(this.props.isOver, this.props.canDrop))) : null
				}
			}
			t.a = u(m)
		},
		"./src/reddit/controls/FormFields/index.m.less": function(e, t, n) {
			e.exports = {
				input: "_3CWuMoFPzdbJCxYJVmEw00",
				label: "J4DegnzzIY1-C2PFzYkrA",
				mHasValue: "t09kxBqaSw0Is_F5sUdQ1",
				inputWrapper: "_3TCLGRXxb1PXK-_sziBD2q",
				mIsInvalid: "_1pMjk4nL9CObVggXCSuELu",
				inputMovingLabelWrapper: "_2-meAmTwsZSCNYrpbEy7BX",
				mIsRedditStyle: "_3ONm7CsU4BtjX9jO5WYv2X",
				trash: "_2YUtyje1Y5rUty_3zgPOGM",
				trashContainer: "_2wjFyjW1rwWs4WFcSc7xNl",
				plus: "_3o11DwChSYlSiDT6FYqOIE",
				addValueButton: "_1Dm7EZTfDne90O5xANs501",
				multiInputWrapper: "_3CjWcr8XyX0xN32ADxPngu",
				errorText: "_2JNX-DiHbrfxhFYgkcBNaK"
			}
		},
		"./src/reddit/controls/FormFields/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "d", (function() {
				return C
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/controls/ErrorText/index.tsx"),
				c = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				d = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				l = n("./src/reddit/controls/FormFields/index.m.less"),
				u = n.n(l);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const p = i.a.input("input", u.a),
				h = e => {
					"LABEL" === e.target.tagName && (e.target.parentElement.firstElementChild.focus(), e.stopPropagation())
				},
				b = e => {
					let {
						label: t,
						children: n,
						inputRef: o,
						className: i,
						isInvalid: a,
						...c
					} = e;
					const d = void 0 !== c.value && "" !== c.value;
					return r.a.createElement("div", {
						className: Object(s.a)(u.a.inputWrapper, i, {
							[u.a.mIsInvalid]: a
						}),
						onClick: h
					}, r.a.createElement(p, m({
						"aria-invalid": a,
						innerRef: o
					}, c)), t && r.a.createElement("label", {
						className: Object(s.a)(u.a.label, {
							[u.a.mHasValue]: d
						})
					}, t), n)
				},
				f = e => {
					let {
						label: t,
						children: n,
						inputRef: o,
						isInvalid: i,
						className: a,
						redditStyle: c,
						...d
					} = e;
					const l = void 0 !== d.value && "" !== d.value;
					return r.a.createElement("div", {
						className: Object(s.a)(u.a.inputMovingLabelWrapper, a, {
							[u.a.mIsInvalid]: i,
							[u.a.mIsRedditStyle]: c
						}),
						onClick: h
					}, r.a.createElement(p, m({
						innerRef: o
					}, d)), t && r.a.createElement("label", {
						className: Object(s.a)(u.a.label, {
							[u.a.mHasValue]: l
						})
					}, t), n)
				},
				g = e => r.a.createElement("div", {
					className: Object(s.a)(u.a.addValueButton, e.className),
					onClick: e.onClick
				}, e.text, " ", r.a.createElement(c.a, {
					className: u.a.plus
				}));
			var v;
			! function(e) {
				e[e.ADD = 0] = "ADD", e[e.REMOVE = 1] = "REMOVE"
			}(v || (v = {}));
			class C extends r.a.Component {
				constructor() {
					super(...arguments), this.state = {
						addingNewInputs: !1
					}, this.addValue = () => {
						const e = this.props.values.slice();
						this.props.buttonOnTop ? e.unshift("") : e.push(""), this.props.onChange(e), this.props.onEvent && this.props.onEvent({
							action: v.ADD
						})
					}, this.updateValue = (e, t) => {
						const n = this.props.values.slice();
						n[t] = e.target.value, this.props.onChange(n)
					}, this.removeValue = e => {
						const t = this.props.values.slice(),
							n = t[e];
						t.splice(e, 1), this.props.onChange(t), this.props.onEvent && this.props.onEvent({
							action: v.REMOVE,
							value: n,
							index: e
						})
					}
				}
				componentWillReceiveProps(e) {
					e.values.length > this.props.values.length && this.setState({
						addingNewInputs: !0
					})
				}
				componentDidUpdate() {
					this.focusedInput && this.state.addingNewInputs && (this.focusedInput.focus(), this.setState({
						addingNewInputs: !1
					}))
				}
				setInputRef(e, t) {
					this.state.addingNewInputs && (!this.props.buttonOnTop || this.props.buttonOnTop && !t) && (this.focusedInput = e)
				}
				renderFields() {
					const {
						values: e,
						disabled: t,
						label: n,
						placeholder: o,
						errors: s = []
					} = this.props;
					return e.map((e, i) => r.a.createElement(b, {
						inputRef: e => this.setInputRef(e, i),
						isInvalid: !!s[i],
						disabled: t,
						type: "text",
						label: n,
						onChange: e => this.updateValue(e, i),
						placeholder: o,
						value: e,
						style: {
							paddingRight: "36px"
						}
					}, r.a.createElement("div", {
						className: u.a.trashContainer,
						onClick: () => this.removeValue(i)
					}, r.a.createElement(d.b, {
						className: u.a.trash
					})), !!s[i] && r.a.createElement(a.b, {
						className: u.a.errorText
					}, s[i])))
				}
				render() {
					const {
						className: e,
						buttonOnTop: t,
						values: n,
						maxLength: o,
						addValueText: i,
						disabled: a
					} = this.props;
					this.focusedInput = null;
					const c = !(!!o && n.length >= o) && !a;
					return r.a.createElement("div", {
						className: Object(s.a)(u.a.multiInputWrapper, e)
					}, t && c && r.a.createElement(g, {
						onClick: this.addValue,
						text: i
					}), this.renderFields(), !t && c && r.a.createElement(g, {
						onClick: this.addValue,
						text: i
					}))
				}
			}
		},
		"./src/reddit/controls/GrowingOutlinedInput/index.m.less": function(e, t, n) {
			e.exports = {
				growingOutlinedInput: "PqYQ3WC15KaceZuKcFI02"
			}
		},
		"./src/reddit/controls/Input/ModalInput.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/constants/keycodes.ts"),
				d = n("./src/reddit/controls/Input/index.m.less"),
				l = n.n(d);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			class m extends r.a.Component {
				constructor() {
					super(...arguments), this.handleKeyDown = e => {
						let {
							keyCode: t
						} = e;
						t === c.a.Escape && this.props.closeModal()
					}
				}
				render() {
					const {
						className: e,
						closeModal: t,
						...n
					} = this.props;
					return r.a.createElement("input", u({
						className: Object(i.a)(l.a.input, e),
						onKeyDown: this.handleKeyDown
					}, n))
				}
			}
			t.a = Object(s.b)(null, {
				closeModal: a.f
			})(m)
		},
		"./src/reddit/controls/Input/index.m.less": function(e, t, n) {
			e.exports = {
				input: "_3eoXtlBWKbkFYoOHUIcIgK"
			}
		},
		"./src/reddit/controls/Input/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/Input/index.m.less"),
				s = n.n(r);
			t.a = o.a.input("input", s.a)
		},
		"./src/reddit/controls/LoadingIcon/index.m.less": function(e, t, n) {
			e.exports = {
				loadingIcon: "_3LwT7hgGcSjmJ7ng7drAuq",
				spin: "ibDwUVR1CAykturOgqOS5",
				mCentered: "_2qr28EeyPvBWAsPKl-KuWN"
			}
		},
		"./src/reddit/controls/LoadingIcon/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/LoadingIcon/index.m.less"),
				a = n.n(i);
			t.a = e => {
				let {
					center: t,
					className: n,
					sizePx: o = 10
				} = e;
				return r.a.createElement("div", {
					className: Object(s.a)(a.a.loadingIcon, n, {
						[a.a.mCentered]: t
					}),
					style: {
						"--sizePx": `${o}px`
					},
					"data-testid": "LoadingIcon"
				})
			}
		},
		"./src/reddit/controls/OutboundLink/styled.tsx": function(e, t, n) {
			"use strict";
			var o = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/constants/elementClassNames.ts"),
				s = n("./src/reddit/controls/OutboundLink/index.tsx"),
				i = n("./src/reddit/controls/OutboundLink/styles.m.less"),
				a = n.n(i);
			t.a = o.a.wrapped(s.b, "styledOutboundLink", {
				styledOutboundLink: `${a.a.styledOutboundLink} ${r.l}`
			})
		},
		"./src/reddit/controls/OutboundLink/styles.m.less": function(e, t, n) {
			e.exports = {
				styledOutboundLink: "_13svhQIUZqD9PVzFcLwOKT"
			}
		},
		"./src/reddit/controls/RadioInput/RadioOption/index.m.less": function(e, t, n) {
			e.exports = {
				radioOption: "_2e6fJknJ4noSygWYov8-F1",
				radioOff: "_1lzSnSABNXX12WerTnwqI3",
				radioOn: "_3PYsg_uRJ6AGptv-hi7kqu"
			}
		},
		"./src/reddit/controls/RadioInput/RadioOption/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/constants/keycodes.ts"),
				a = n("./src/reddit/icons/svgs/RadioOff/index.tsx"),
				c = n("./src/reddit/icons/svgs/RadioOn/index.tsx"),
				d = n("./src/reddit/layout/row/Inline/index.tsx"),
				l = n("./src/reddit/controls/RadioInput/RadioOption/index.m.less"),
				u = n.n(l);
			class m extends r.a.Component {
				constructor() {
					super(...arguments), this.ref = null, this.onKeyPress = e => {
						const {
							props: t
						} = this;
						t.disabled || e.key !== i.b.Enter && e.key !== i.b.Space || (t.onClick && t.onClick(t.value), e.preventDefault())
					}
				}
				componentDidUpdate(e) {
					this.props.selected && !e.selected && this.ref && this.ref.focus()
				}
				render() {
					const {
						props: e
					} = this;
					return e.hidden ? null : r.a.createElement(d.a, {
						"aria-checked": e.selected,
						className: Object(s.a)(e.className, u.a.radioOption),
						innerRef: e => this.ref = e,
						onClick: e.disabled ? void 0 : e.onClick,
						onKeyPress: this.onKeyPress,
						role: "radio",
						tabIndex: e.tabIndex
					}, e.showButton && (e.selected ? r.a.createElement(c.a, {
						className: u.a.radioOn,
						role: "presentation"
					}) : r.a.createElement(a.a, {
						className: u.a.radioOff,
						role: "presentation"
					})), e.children)
				}
			}
			t.a = m
		},
		"./src/reddit/controls/RadioInput/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/reddit/constants/keycodes.ts");
			class i extends r.a.Component {
				constructor(e) {
					super(e), this.handleClick = e => {
						const {
							disabled: t,
							onChange: n
						} = this.props;
						t || this.state.value !== e && (n(e), this.setState({
							value: e
						}))
					}, this.getValues = () => {
						const e = [];
						return r.a.Children.forEach(this.props.children, t => {
							t.props.hidden || t.props.disabled || e.push(t.props.value)
						}), e
					}, this.onKeyDown = e => {
						const {
							disabled: t,
							onChange: n
						} = this.props, {
							value: o
						} = this.state;
						if (t) return;
						const r = e.key === s.b.ArrowUp,
							i = e.key === s.b.ArrowDown;
						if (r || i) {
							const t = this.getValues();
							if (!t.length) return;
							const s = o ? t.indexOf(o) : 0,
								i = t[((r ? s - 1 : s + 1) + t.length) % t.length];
							n(i), this.setState({
								value: i
							}), e.preventDefault()
						}
					}, this.state = {
						value: e.value || null
					}
				}
				UNSAFE_componentWillReceiveProps(e) {
					e.value !== this.props.value && this.setState({
						value: e.value || null
					})
				}
				render() {
					const {
						props: e
					} = this, {
						value: t
					} = this.state;
					return r.a.createElement("div", {
						"aria-label": e.name,
						className: e.className,
						role: "radiogroup",
						onKeyDown: this.onKeyDown
					}, r.a.createElement("input", {
						disabled: e.disabled,
						type: "hidden",
						value: t || ""
					}), r.a.Children.map(e.children, (n, o) => {
						const s = 0 === o,
							i = n.props.value === t,
							a = null !== t ? i ? 0 : -1 : s ? 0 : -1;
						return r.a.cloneElement(n, {
							disabled: e.disabled,
							onClick: e => this.handleClick(n.props.value),
							selected: i,
							tabIndex: a
						})
					}))
				}
			}
		},
		"./src/reddit/controls/Search/CommentSearch/index.m.less": function(e, t, n) {
			e.exports = {
				absolute: "_3JOs2fo7GARfPQK9n9uvyr",
				actionFont: "_2GiazGbWQeG84CupoExWj9",
				dismissButton: "_2lSQO1uFdnaWbYRKtLg3H-",
				metadataFont: "_1Vs6ZQxgSSIBCGCe2dcMoA",
				flex: "_1qRmLv2PYGtqa3xyVEYz_R",
				input: "_2WVAyd_SvtylHMe7sKaua9",
				linkTextColor: "_1zG8KFMibgWr8ahovOZAUB",
				paddingIcon: "_2i3sQHj_1l-LDzGfzQTjHM",
				postIcon: "_1rMy-IddyxrWMGR5hH5O1E",
				relative: "_3AIIvG4My2zfaJh7r8TucE",
				verticalDivider: "_34BFzBLxzKlRZTjBIHtnlh",
				dismissIcon: "_1Z_UNdjZZu53GD24SI5BLG",
				searchIcon: "_380giGvmbbYVTkgLoNx7ZP"
			}
		},
		"./src/reddit/controls/Search/CommentSearch/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return w
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "d", (function() {
				return R
			})), n.d(t, "c", (function() {
				return M
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router-redux/es/index.js"),
				c = n("./src/lib/addQueryParams/index.ts"),
				d = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/lib/makeSearchKey/index.ts"),
				m = n("./src/reddit/actions/pages/search/index.ts"),
				p = n("./src/reddit/constants/keycodes.ts"),
				h = n("./src/reddit/constants/parameters.ts"),
				b = n("./src/reddit/contexts/PageLayer/index.tsx"),
				f = n("./src/reddit/helpers/path/index.ts"),
				g = n("./src/reddit/helpers/search/searchClickSearchBarOriginElement.ts"),
				v = n("./src/reddit/helpers/search/searchImpressionId.ts"),
				C = n("./src/reddit/helpers/search/SearchTelemetrySource.ts"),
				y = n("./src/reddit/helpers/trackers/searchResults.ts"),
				E = n("./src/reddit/hooks/usePageLayer.ts"),
				x = n("./src/reddit/hooks/useTracking.ts"),
				O = n("./src/reddit/icons/fonts/index.tsx"),
				_ = n("./src/reddit/selectors/platform.ts"),
				k = n("./src/reddit/selectors/telemetry.ts"),
				j = n("./src/reddit/selectors/user.ts"),
				S = n("./src/reddit/controls/Search/CommentSearch/index.m.less"),
				T = n.n(S);
			const w = "comment_search-bar",
				I = "comment-search-button",
				P = "search-bar-dismiss-button",
				N = "COMMENT_SEARCH_BAR_TEST_ID";

			function R(e) {
				let {
					searchValue: t,
					post: n,
					subreddit: o
				} = e;
				return {
					[h.w]: t,
					[h.I]: [l.ic.Comments]
				}
			}

			function M(e) {
				const {
					expanded: t,
					bucketed: n,
					collapsed: l
				} = e.experiment, h = Object(E.a)(), S = Object(x.a)(), M = (null == h ? void 0 : h.queryParams.q) || "", [D, L] = Object(r.useState)(M), [A, F] = Object(r.useState)(t), B = Object(i.d)(), U = Object(r.useRef)(null), K = Object(i.e)(e => Object(b.h)(e, {
					pageLayer: h
				})), W = Object(i.e)(e => Object(b.s)(e, {
					pageLayer: h
				})), G = Object(i.e)(e => Object(j.mb)(e)), H = Object(i.e)(e => Object(j.rb)(e)), V = Object(i.e)(e => Object(_.i)(e));
				var z, q, Q;

				function Y() {
					var t;
					if (!D.trim() || !K) return;
					const n = new URL(K.permalink).pathname,
						o = R({
							searchValue: D,
							post: K,
							subreddit: W
						});
					g.a.set(k.a.CommentSearchBar), S(Object(y.o)(y.a.FULL_SEARCH_BUTTON, o, C.a.PdpCommentSearchBar, h || void 0));
					const r = Object(u.b)(K.id, void 0, o, G && H);
					B(Object(m.d)({
						key: r,
						options: o,
						subredditName: null == W ? void 0 : W.name,
						postId: K.id
					}));
					const s = Object(c.a)(n, o);
					B(Object(a.b)(Object(f.b)(s), {
						...null === (t = e.prevLocation) || void 0 === t ? void 0 : t.state,
						isOverlay: V,
						scrollOnLoad: !0
					}))
				}
				return z = U, q = F, Q = l, Object(r.useEffect)(() => {
					if (Q) return document.addEventListener("mousedown", e), () => {
						document.removeEventListener("mousedown", e)
					};

					function e(e) {
						z.current && !z.current.contains(e.target) && q(!1)
					}
				}, [z]), n ? s.a.createElement("div", {
					className: T.a.flex
				}, D || A ? s.a.createElement("div", {
					"data-testid": w
				}, s.a.createElement("label", {
					className: Object(d.a)(T.a.flex, T.a.relative)
				}, s.a.createElement("div", {
					className: T.a.absolute,
					role: "submit",
					onClick: Y
				}, s.a.createElement(O.a, {
					className: Object(d.a)(T.a.postIcon, T.a.paddingIcon),
					name: "search"
				})), s.a.createElement("input", {
					className: Object(d.a)(T.a.metadataFont, T.a.input),
					"data-testid": N,
					id: w,
					type: "search",
					onChange: e => {
						v.a.update(C.a.PdpCommentSearchBar), L(e.target.value)
					},
					onFocus: function() {
						v.a.update(C.a.PdpCommentSearchBar), g.a.set(k.a.CommentSearchBar), S(Object(y.o)(y.a.SEARCH_BAR, R({
							searchValue: D,
							post: K,
							subreddit: W
						}), C.a.PdpCommentSearchBar, h || void 0))
					},
					onKeyPress: function(e) {
						e.key === p.b.Enter && Y()
					},
					placeholder: o.fbt._("Search comments", null, {
						hk: "2ObH7B"
					}),
					ref: U,
					value: D
				}), D && s.a.createElement("button", {
					"aria-label": o.fbt._("Remove search bar text", null, {
						hk: "4twCsS"
					}),
					id: P,
					className: T.a.dismissButton,
					"data-testid": P,
					onClick: () => {
						L("")
					}
				}, s.a.createElement(O.a, {
					className: T.a.dismissIcon,
					name: "clear"
				})))) : s.a.createElement("button", {
					className: T.a.linkTextColor,
					"data-testid": I,
					id: I,
					onClick: () => {
						Promise.resolve(F(!0)).then(() => {
							var e;
							return null === (e = U.current) || void 0 === e ? void 0 : e.focus()
						})
					}
				}, s.a.createElement(O.a, {
					className: Object(d.a)(T.a.searchIcon, T.a.paddingIcon),
					name: "search"
				}), s.a.createElement("span", {
					className: T.a.actionFont
				}, o.fbt._("Search comments", null, {
					hk: "2ObH7B"
				})))) : null
			}
		},
		"./src/reddit/controls/Sortable/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/reddit/helpers/dragDropContext/index.ts"),
				i = n("./node_modules/lodash/flow.js"),
				a = n.n(i),
				c = n("./node_modules/react-dnd/lib/index.js");
			class d extends r.a.Component {
				constructor() {
					super(...arguments), this.handleClick = () => {
						this.props.onClick && this.props.onClick(this.props.id, this.props.index)
					}
				}
				render() {
					const {
						props: e
					} = this;
					return e.connectDropTarget && e.connectDragSource ? a()(e.connectDropTarget, e.connectDragSource)(r.a.createElement("div", {
						onClick: this.handleClick
					}, e.render(e.id, e.index, e.isDragging, e.isOver, e.canDrop))) : null
				}
			}
			var l = a()(Object(c.DragSource)("card", {
				beginDrag: e => ({
					id: e.id,
					index: e.index
				}),
				endDrag: (e, t) => {
					if (t && t.didDrop()) {
						const n = t.getDropResult();
						e.onDrop(e.id, n.id)
					}
				}
			}, (e, t) => ({
				connectDragSource: e.dragSource(),
				isDragging: t.isDragging()
			})), Object(c.DropTarget)("card", {
				drop: (e, t) => {
					if (!t || !t.didDrop()) return {
						id: e.id,
						index: e.index
					}
				},
				canDrop: (e, t) => {
					if (!t) return !1;
					const n = t.getItem();
					return e.id !== n.id
				}
			}, (e, t) => ({
				connectDropTarget: e.dropTarget(),
				isOver: t.isOver(),
				canDrop: t.canDrop()
			})))(d);
			class u extends r.a.Component {
				constructor(e) {
					super(e), this.onDrop = (e, t) => {
						this.setState(n => {
							const o = n.values.slice(),
								r = o.indexOf(e),
								s = o.splice(r, 1)[0];
							let i = o.indexOf(t);
							return r <= i && (i += 1), o.splice(i, 0, s), this.props.onDrop(e, t, o), {
								values: o
							}
						})
					}, this.state = {
						values: e.values
					}
				}
				componentWillReceiveProps(e) {
					this.setState(() => ({
						values: e.values
					}))
				}
				render() {
					const {
						className: e,
						getReactKey: t,
						onClick: n,
						render: o
					} = this.props;
					return r.a.createElement("div", {
						className: e
					}, this.state.values.map((e, s) => r.a.createElement(l, {
						id: e,
						key: t && t(e, s),
						index: s,
						render: o,
						onDrop: this.onDrop,
						onClick: n
					})))
				}
			}
			t.a = Object(s.a)(u)
		},
		"./src/reddit/controls/SubredditDropdown/index.m.less": function(e, t, n) {
			e.exports = {
				entry: "BR2J4z5ndMj6r3-QW2hHI",
				mIsFocused: "_2KXTnIrbZ1Fr5F4nZyXeKS",
				list: "_17g61LC45mhwjs-g79qbZK"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SearchBar/index.m.less": function(e, t, n) {
			e.exports = {
				input: "_1MHSX9NVr4C2QxH2dMcg4M",
				inputWrapper: "anPJr_ybRailY8NbAunl2",
				searchBar: "_3cWzf-usAKfGV1Ay7h2zM_",
				commonIconStyles: "_3UX5zf2Jh7UCwxr3e1Rrt2",
				dropdownIcon: "_15FJlGHQ_lg8wmnMsXlnes",
				iconEmpty: "_3adQsrepNO01e3sMjt2z0P",
				subredditRoundIcon: "jpIFeDw811_DQwlQEqBjm",
				userIcon: "_1Xb3_WGBJKTWZNy0MHWTsR",
				searchIcon: "_2MCEtCukiOUDUHF1PDgWwH",
				mDisabled: "I8Mbkr_v6UNBq2UjXD24r"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/DropdownEntry/index.m.less": function(e, t, n) {
			e.exports = {
				entry: "_2_6Q3rlmltjQM8nEBoNJr-",
				disabled: "_1eGUunOsIyMkgTF3IiieVl"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/DropdownSection/index.m.less": function(e, t, n) {
			e.exports = {
				title: "-T-WBPEANCCRwTdAGSdj_",
				dropdownSection: "_2MAa_9ffQVHzsZ-RD1dD5F",
				titleContainer: "_112QSSyLmEVry3hGjIPV--",
				titleText: "_3fpkz04m3VEANbACfYOR0H",
				srCreationButton: "_3ujvK82qZ7yzbpEffTiXH-"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/EntryContent/PostTypes/index.m.less": function(e, t, n) {
			e.exports = {
				iconWrapper: "_2jjSvas2tvdAFgIvSzSBax",
				mDisabled: "_2PoEIlhFzgV0sUWfM40K-N",
				rowStyle: "_3DfMNtnkrzHeGN0WyUTTuX"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/EntryContent/index.m.less": function(e, t, n) {
			e.exports = {
				subredditIcon: "vxu9qtznQ1Kvakd5mtfxV",
				main: "_11CAFoZ5ryUXHrO5iX6Ktk",
				title: "_1bEDlh2fhWPx9-h3IqUvFa",
				lockTitleWithEllipsis: "mFsxWzlvJHnXmu7_xaIzI",
				secondary: "_2q4aqq7yddFWa3SfRCihRH",
				container: "_3oyS3dPRsa51zDEONlIdts",
				mHighLight: "F6s6qTIrbT1UvKhtNmPq4"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/EntryContent/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return E
			})), n.d(t, "b", (function() {
				return x
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/SubredditIcon/index.tsx"),
				c = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				d = n("./src/reddit/icons/svgs/ImagePost/index.tsx"),
				l = n("./src/reddit/icons/svgs/Link/index.tsx"),
				u = n("./src/reddit/icons/svgs/TextPost/index.tsx"),
				m = n("./src/reddit/icons/svgs/Video/index.tsx"),
				p = n("./src/reddit/layout/row/Inline/index.tsx"),
				h = n("./src/reddit/icons/fonts/index.tsx"),
				b = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/EntryContent/PostTypes/index.m.less"),
				f = n.n(b);
			const g = [{
				type: "text",
				Icon: u.a
			}, {
				type: "images",
				Icon: d.a
			}, {
				type: "videos",
				Icon: m.a
			}, {
				type: "links",
				Icon: l.a
			}, {
				type: "talks",
				Icon: () => r.a.createElement(h.a, {
					name: "audio"
				})
			}];

			function v(e) {
				const {
					allowedPostTypes: t,
					className: n
				} = e;
				return r.a.createElement(p.a, {
					className: Object(s.a)(f.a.rowStyle, n)
				}, g.map((e, n) => {
					let {
						type: o,
						Icon: i
					} = e;
					return r.a.createElement("div", {
						className: Object(s.a)(f.a.iconWrapper, {
							[f.a.mDisabled]: !t[o]
						}),
						key: n
					}, r.a.createElement(i, null))
				}))
			}
			var C = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/EntryContent/index.m.less"),
				y = n.n(C);
			const E = i.a.wrapped(a.b, "subredditIcon", y.a);

			function x(e) {
				const {
					className: t,
					explanationText: n,
					highlight: o,
					icon: i,
					item: a,
					lockTitleWithEllipsis: d,
					onClick: l,
					secondaryText: u,
					subText: m,
					title: p
				} = e, {
					allowedPostTypes: h
				} = a;
				return r.a.createElement("div", {
					className: Object(s.a)(y.a.container, {
						[y.a.mHighlight]: o
					}, t),
					onClick: l
				}, i, r.a.createElement("div", {
					className: y.a.main
				}, r.a.createElement("span", {
					className: Object(s.a)(y.a.title, {
						[y.a.lockTitleWithEllipsis]: d
					})
				}, p), u && r.a.createElement("span", {
					className: y.a.secondary
				}, u, m && r.a.createElement(r.a.Fragment, null, r.a.createElement(c.a, null), r.a.createElement("span", {
					className: y.a.secondary
				}, m))), n && r.a.createElement("span", {
					className: y.a.secondary
				}, n)), o && h && r.a.createElement(v, {
					allowedPostTypes: h
				}))
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/ProfileEntryContent/index.m.less": function(e, t, n) {
			e.exports = {
				profileIcon: "_3JCR5jV3N1dbyHaUswxl4K"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/RecommendedSubreddits/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "C_XJ2ZB_b9iAPcFCHr4SW",
				title: "_1qKkNpHiC5Vgwbp0N8pOiG",
				contentWrapper: "_2l-m9MtS29tOlexExTlpXo",
				spinner: "_3rJ_SLWBH_jxAMlgNkciE9",
				itemWrapper: "Tx6TtQK3xJ9F5qpQlrEHT"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/RecommendedSubreddits/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return y
			})), n.d(t, "a", (function() {
				return E
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/actions/postCreation/general.ts"),
				l = n("./src/reddit/components/Hovercards/SubredditHovercard/index.tsx"),
				u = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				m = n("./src/reddit/helpers/trackers/postComposer.ts"),
				p = n("./src/reddit/hooks/useIntersectionObserver.ts"),
				h = n("./src/reddit/hooks/useTracking.ts"),
				b = n("./src/reddit/selectors/experiments/postCreationSubRec.ts"),
				f = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/SubredditEntryContent/index.tsx"),
				g = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/RecommendedSubreddits/index.m.less"),
				v = n.n(g);
			const C = e => {
					const {
						items: t,
						itemWrapperClassName: n,
						isRedditRec: i,
						onSelectRecommendation: a,
						shouldShowSubredditOnlineUsers: d = !1
					} = e, u = Object(h.a)(), b = Object(r.useCallback)((e, t) => {
						u(Object(m.w)(e, t))
					}, []), g = Object(r.useRef)(null), C = Object(r.useCallback)(e => {
						e.forEach(e => {
							const {
								isIntersecting: t
							} = e;
							t && u(Object(m.v)())
						})
					}, []);
					return Object(p.a)(g, C), s.a.createElement(s.a.Fragment, null, t.map((e, t) => s.a.createElement("div", {
						className: Object(c.a)(v.a.itemWrapper, n),
						key: e.name
					}, s.a.createElement(l.a, {
						subredditName: e.name,
						shouldOpenNewTabOnClicks: !0,
						onShow: () => b(e.name, t)
					}, s.a.createElement(f.a, {
						item: e,
						highlight: !1,
						shouldPrettyPrint: !0,
						explanationText: i ? o.fbt._("based on your subscription", null, {
							hk: "3Hb2XK"
						}) : o.fbt._("based on your content", null, {
							hk: "3u8Nrt"
						}),
						onClick: () => {
							a(e), u(Object(m.u)(e.name, t))
						},
						lockTitleWithEllipsis: !0,
						shouldShowSubredditOnlineUsers: d
					})))), s.a.createElement("span", {
						ref: g,
						key: "recommended-render"
					}))
				},
				y = e => {
					const {
						contentWrapperClassName: t,
						hasData: n,
						isPending: o,
						isRedditRec: r,
						items: i,
						itemWrapperClassName: a,
						onSelectRecommendation: c,
						shouldShowSubredditOnlineUsers: d = !1
					} = e;
					return s.a.createElement("div", {
						className: t
					}, o && s.a.createElement(u.a, {
						sizePx: 30,
						className: v.a.spinner
					}), n && !o && s.a.createElement(C, {
						isRedditRec: r,
						items: i,
						itemWrapperClassName: a,
						onSelectRecommendation: c,
						shouldShowSubredditOnlineUsers: d
					}))
				},
				E = e => {
					const t = Object(i.d)(),
						{
							isPending: n,
							hasData: c,
							isChanged: l,
							items: u,
							isRedditRec: m
						} = Object(i.e)(Object(a.c)({
							isPending: b.i,
							hasData: b.d,
							isChanged: b.e,
							items: b.c,
							isRedditRec: b.j
						}));
					return Object(r.useEffect)(() => {
						l && t(Object(d.k)())
					}, [l, t]), s.a.createElement("div", {
						className: v.a.wrapper,
						onMouseDown: e.onContainerMouseDown
					}, s.a.createElement("div", {
						className: v.a.title
					}, o.fbt._("Suggested communities", null, {
						hk: "4BebuH"
					})), s.a.createElement(y, {
						contentWrapperClassName: v.a.contentWrapper,
						hasData: c,
						isPending: n,
						isRedditRec: m,
						items: u,
						onSelectRecommendation: e.onSelectRecommendation
					}))
				}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/SubredditEntryContent/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_20inB3H1vZ94tVilqSJmU2",
				hasExplanationText: "_1xZtDFYDxzgIqaJfg9XzJh"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/SubredditEntryContent/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/prettyPrintNumber/index.ts"),
				d = n("./src/reddit/helpers/name/index.ts"),
				l = n("./src/reddit/selectors/subreddit.ts"),
				u = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/EntryContent/index.tsx"),
				m = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/SubredditEntryContent/index.m.less"),
				p = n.n(m);

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}

			function b(e) {
				const {
					item: {
						primaryColor: t,
						iconUrl: n,
						name: r,
						subscribers: m,
						active: b
					},
					shouldPrettyPrint: f,
					explanationText: g,
					shouldShowSubredditOnlineUsers: v = !1
				} = e, C = Object(i.e)(e => Object(l.z)(e, {
					subredditName: r
				})), y = Object(d.d)(r), E = void 0 !== m ? o.fbt._({
					"*": "{number} members",
					_1: "1 member"
				}, [o.fbt._plural(m, "number", f ? Object(c.b)(m) : void 0)], {
					hk: "2SvJUX"
				}) : void 0, x = C ? o.fbt._("{number users online in subreddit} online", [o.fbt._param("number users online in subreddit", Object(c.b)(C.accountsActive))], {
					hk: "49HfzS"
				}) : void 0, O = v ? `${E}  ${x}` : E, _ = void 0 !== b ? o.fbt._({
					"*": "{number} online",
					_1: "1 online"
				}, [o.fbt._plural(b, "number", f ? Object(c.b)(b) : void 0)], {
					hk: "NgOAJ"
				}) : void 0, k = s.a.createElement(u.a, {
					className: Object(a.a)(p.a.icon, {
						[p.a.hasExplanationText]: !!g
					}),
					iconUrl: n,
					primaryColor: t,
					redditStyle: !0
				});
				return s.a.createElement(u.b, h({
					icon: k,
					title: y,
					secondaryText: O,
					subText: _
				}, e))
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/index.m.less": function(e, t, n) {
			e.exports = {
				noMatches: "kaGogHhtbK_vPZj9943oa",
				container: "_3DQXGvoE1SM3Kmz20of7Iz",
				mIsValid: "_28z84WGIIVp4uDMcA3-Kgw",
				mIsVisible: "_3009h778F7QI2qu6YmsxVV"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return M
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/debounce.js"),
				s = n.n(r),
				i = n("./node_modules/react/index.js"),
				a = n.n(i),
				c = n("./src/lib/classNames/index.ts");
			const d = {
				leading: !0,
				trailing: !1
			};
			var l = function(e, t, n) {
					let o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : d;
					const r = {
							...d,
							...o
						},
						s = t > e ? 1 : -1;
					let i = e;
					if (e !== t) {
						for (r.leading || (i += s); i !== t;) n(i), i += s;
						r.trailing && n(i)
					} else(r.leading || r.trailing) && n(e)
				},
				u = n("./src/lib/forEachGroup/index.ts"),
				m = n("./src/reddit/models/SubredditAutocomplete/index.ts"),
				p = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/DropdownEntry/index.m.less"),
				h = n.n(p);
			class b extends i.Component {
				constructor(e) {
					super(e), this.mouseDown = !1, this.element = null, this.setRef = e => this.element = e, this.onMouseUp = () => {
						this.mouseDown && (this.props.disabled || this.props.onSelect(this.props.entryIndex), this.mouseDown = !1)
					}, this.onMouseDown = e => {
						this.mouseDown = !0, e.preventDefault()
					}, this.onMouseOver = () => {
						this.props.onOver(this.props.entryIndex)
					}, this.mouseDown = !1
				}
				componentDidUpdate() {
					this.mouseDown = !1, this.element && this.props.onUpdate(this.props.entryIndex, this.element)
				}
				render() {
					return a.a.createElement("div", {
						className: Object(c.a)(h.a.entry, this.props.disabled && h.a.disabled),
						onMouseDown: this.onMouseDown,
						onMouseOver: this.onMouseOver,
						onMouseUp: this.onMouseUp,
						ref: this.setRef
					}, this.props.children)
				}
			}
			var f = n("./src/reddit/controls/Button/index.tsx"),
				g = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/DropdownSection/index.m.less"),
				v = n.n(g);

			function C() {
				return (C = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			var y = e => {
					let {
						className: t,
						children: n,
						title: r,
						onOpenCommunityCreation: s,
						shouldShowCreateCommunityButton: i,
						...d
					} = e;
					return a.a.createElement("div", C({
						className: Object(c.a)(v.a.dropdownSection, t)
					}, d), r && i ? a.a.createElement("div", {
						className: v.a.titleContainer
					}, a.a.createElement("span", {
						className: v.a.titleText
					}, r), a.a.createElement(f.t, {
						className: v.a.srCreationButton,
						onClick: s,
						priority: f.c.Plain,
						size: f.d.XS
					}, o.fbt._("Create New", null, {
						hk: "3WP7G4"
					}))) : r && a.a.createElement("div", {
						className: v.a.title
					}, r), n)
				},
				E = n("./src/reddit/components/UserIcon/CurrentUserIcon.tsx"),
				x = n("./src/reddit/helpers/name/index.ts"),
				O = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/EntryContent/index.tsx"),
				_ = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/EntryContent/index.m.less"),
				k = n.n(_),
				j = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/ProfileEntryContent/index.m.less"),
				S = n.n(j);

			function T() {
				return (T = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}

			function w(e) {
				const {
					item: {
						name: t,
						subscribers: n
					}
				} = e, r = Object(x.e)(t), s = void 0 !== n ? o.fbt._({
					"*": "{number} members",
					_1: "1 member"
				}, [o.fbt._plural(n, "number")], {
					hk: "2SvJUX"
				}) : void 0, i = a.a.createElement(E.a, {
					className: Object(c.a)(S.a.profileIcon, k.a.subredditIcon)
				});
				return a.a.createElement(O.b, T({
					icon: i,
					title: r,
					secondaryText: s
				}, e))
			}
			var I = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/SubredditEntryContent/index.tsx"),
				P = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/index.m.less"),
				N = n.n(P);
			const R = {
				[m.a.OWN_PROFILE]: () => o.fbt._("Your profile", null, {
					hk: "1Qoy4P"
				}),
				[m.a.SUBSCRIBED_TO_SUBREDDIT]: () => o.fbt._("Your communities", null, {
					hk: "2XzKJR"
				}),
				[m.a.OTHER_SUBREDDIT]: () => o.fbt._("Others", null, {
					hk: "3WQHlu"
				}),
				[m.a.MODERATED_SUBREDDIT]: () => o.fbt._("Moderated subreddits", null, {
					hk: "uZtld"
				})
			};
			class M extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.selectedEntryElement = null, this.containerElement = null, this.ignoreEntryOverEvents = !1, this.activateEntryOverEvents = s()(() => this.ignoreEntryOverEvents = !1, 100), this.setContainerRef = e => this.containerElement = e, this.onEntryUpdate = (e, t) => {
						e === this.props.focusedIndex && (this.selectedEntryElement = t)
					}, this.onScroll = () => {
						this.ignoreEntryOverEvents && this.activateEntryOverEvents()
					}, this.onEntryOver = e => {
						this.ignoreEntryOverEvents || this.props.items[e].disabled || this.props.onEntryFocus(e), this.ignoreEntryOverEvents = !1
					}
				}
				componentDidUpdate() {
					if (this.props.focusedIndex >= 0 && this.selectedEntryElement && this.containerElement) {
						const e = this.selectedEntryElement.getBoundingClientRect(),
							t = this.containerElement.getBoundingClientRect();
						(e.top < t.top || e.bottom > t.bottom) && (this.ignoreEntryOverEvents = !0, 0 === this.props.focusedIndex ? this.containerElement.scrollTop = 0 : this.selectedEntryElement.scrollIntoView(e.top < t.top)), this.props.onEntryFocus(this.props.focusedIndex)
					}
				}
				getEntryContentComponent(e, t) {
					switch (e) {
						case m.a.OWN_PROFILE:
							return w;
						default:
							return I.a
					}
				}
				render() {
					const {
						focusedIndex: e,
						items: t,
						onOpenCommunityCreation: n,
						shouldShowCreateCommunityButton: r
					} = this.props, s = [];
					return this.props.showNoMatchesCaption && s.push(a.a.createElement(y, {
						key: "no-matches"
					}, a.a.createElement("div", {
						className: N.a.noMatches
					}, o.fbt._("No communities found", null, {
						hk: "4wDUHv"
					})))), Object(u.a)(t, {
						keyFn: e => e.type
					}, (o, i, c, d) => {
						const u = [];
						l(c, d, n => {
							const o = t[n],
								r = n === e,
								s = this.getEntryContentComponent(o.type, o.name);
							s && u.push(a.a.createElement(b, {
								entryIndex: n,
								disabled: o.disabled,
								key: o.id || o.name,
								onSelect: this.props.onEntrySelect,
								onOver: this.onEntryOver,
								onUpdate: this.onEntryUpdate
							}, a.a.createElement(s, {
								highlight: r,
								item: o
							})))
						});
						const p = R[i];
						s.push(a.a.createElement(y, {
							key: i,
							title: p && p(),
							onOpenCommunityCreation: n,
							shouldShowCreateCommunityButton: r && i === m.a.SUBSCRIBED_TO_SUBREDDIT
						}, u))
					}), a.a.createElement("div", {
						className: Object(c.a)(N.a.container, this.props.className, {
							[N.a.mIsValid]: this.props.isValid,
							[N.a.mIsVisible]: s.length > 0
						}),
						ref: this.setContainerRef,
						onMouseDown: this.props.onContainerMouseDown,
						onScroll: this.onScroll
					}, s)
				}
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2sfaZWDVT8JLAt2J9p4IzV",
				mIsActive: "_1d_qHIhircwk0cy-gLlRQq",
				mIsInvalid: "_3sp2CpDC4eODg63Hhf8_lz",
				subredditDropdownOpenAI: "_1OS0KkjeJ7foERCmAoM2Zc",
				subredditDropdownOpenAi: "_1OS0KkjeJ7foERCmAoM2Zc"
			}
		},
		"./src/reddit/controls/SubredditPicker/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "c", (function() {
				return h
			}));
			var o = n("./src/reddit/constants/posts.ts"),
				r = n("./src/reddit/helpers/getSubredditOrProfileIconData/index.tsx"),
				s = n("./src/reddit/helpers/name/index.ts"),
				i = n("./src/reddit/models/SubredditAutocomplete/index.ts"),
				a = n("./src/reddit/models/User/index.ts");
			const c = (e, t, n) => {
					if (Object(s.a)(e, t.name)) {
						const {
							id: e,
							name: i
						} = t, {
							url: a,
							color: c
						} = Object(r.a)({
							shouldHideNsfwIcon: n,
							subredditOrProfile: t
						});
						return {
							rawString: Object(s.d)(i),
							record: {
								id: e,
								name: i,
								iconUrl: a,
								primaryColor: c,
								type: o.a.SUBREDDIT
							}
						}
					}
					return {
						rawString: e,
						record: null
					}
				},
				d = (e, t, n) => {
					const r = Object(a.e)(t);
					if (Object(s.a)(e, r)) {
						const {
							id: e,
							accountIcon: n
						} = t;
						return {
							rawString: Object(s.e)(r),
							record: {
								id: e,
								name: r,
								iconUrl: n,
								type: o.a.PROFILE
							}
						}
					}
					return {
						rawString: e,
						record: null
					}
				},
				l = (e, t, n, o) => {
					if (t && (!n || Object(s.g)(e))) return c(e, t, o);
					if (n && (!t || Object(s.h)(e))) return d(e, n);
					if (t && n) {
						const r = c(e, t, o);
						return r.record ? r : d(e, n)
					}
					return {
						rawString: e,
						record: null
					}
				},
				u = e => {
					let t;
					return t = e.type === o.a.PROFILE ? i.a.OWN_PROFILE : i.a.OTHER_SUBREDDIT, {
						...e,
						type: t
					}
				},
				m = new RegExp("^(r/)?[A-Za-z0-9][A-Za-z0-9_]{1,20}$", "i"),
				p = new RegExp("^u/[A-Za-z0-9_-]{2,20}$", "i"),
				h = e => m.test(e) || p.test(e) || "" === e
		},
		"./src/reddit/controls/SubredditPicker/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return ne
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/lodash/isEqual.js"),
				i = n.n(s),
				a = n("./src/reddit/helpers/name/index.ts");
			class c extends r.a.Component {
				constructor(e) {
					super(e), this.isFocused = !1, this.onFocus = () => {
						this.isFocused = !0, this.props.onFocus && this.props.onFocus()
					}, this.onChange = (e, t) => {
						this.setState({
							value: e
						}, () => {
							t && (this.props.onSelect(e), this.isFocused = !1)
						})
					}, this.state = {
						value: e.value
					}
				}
				componentWillReceiveProps(e) {
					const {
						value: t
					} = this.state, {
						value: n
					} = e;
					if (!i()(t, n) && !this.isFocused) {
						t.record && !n.record && Object(a.a)(t.record.name, n.rawString) ? this.setState({
							value: {
								rawString: n.rawString,
								record: t.record
							}
						}) : this.setState({
							value: n
						})
					}
				}
				render() {
					return r.a.createElement(r.a.Fragment, null, this.props.renderPicker({
						onChange: this.onChange,
						onFocus: this.onFocus,
						value: this.state.value
					}))
				}
			}
			var d = n("./node_modules/react-redux/es/index.js"),
				l = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/objectSelector/index.ts"),
				m = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/actions/subredditAutocomplete/index.ts"),
				h = n("./src/reddit/actions/subredditCrosspostable.ts"),
				b = n("./src/reddit/actions/subscription/index.ts"),
				f = n("./src/reddit/constants/modals.ts"),
				g = n("./src/reddit/contexts/PageLayer/index.tsx"),
				v = n("./src/reddit/controls/SubredditPicker/helpers.ts"),
				C = n("./node_modules/lodash/debounce.js"),
				y = n.n(C),
				E = n("./src/lib/classNames/index.ts"),
				x = n("./src/reddit/constants/keycodes.ts"),
				O = n("./src/reddit/constants/posts.ts"),
				_ = n("./src/reddit/models/SubredditAutocomplete/index.ts"),
				k = n("./node_modules/fbt/lib/FbtPublic.js"),
				j = n("./src/reddit/icons/fonts/index.tsx"),
				S = n("./src/lib/lessComponent.tsx"),
				T = n("./src/reddit/components/SubredditIcon/index.tsx"),
				w = n("./src/reddit/components/UserIcon/CurrentUserIcon.tsx"),
				I = n("./src/reddit/controls/SubredditPicker/Picker/SearchBar/index.m.less"),
				P = n.n(I);
			const N = S.a.wrapped(T.b, "subredditRoundIcon", P.a),
				R = S.a.wrapped(w.a, "userIcon", P.a),
				M = S.a.span("iconEmpty", P.a);

			function D() {
				return (D = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const L = e => {
				e.preventDefault(), e.stopPropagation()
			};

			function A(e) {
				const {
					className: t,
					disabled: n,
					isActive: o,
					onDropdownClick: s,
					inputRef: i,
					record: a,
					value: c,
					...d
				} = e;
				let l = r.a.createElement(M, null);
				return o ? l = r.a.createElement(j.a, {
					name: "search",
					className: P.a.searchIcon
				}) : a && (l = a.type === O.a.SUBREDDIT ? r.a.createElement(N, a) : r.a.createElement(R, null)), r.a.createElement("div", {
					className: Object(E.a)(P.a.searchBar, t)
				}, l, r.a.createElement("div", {
					className: P.a.inputWrapper
				}, r.a.createElement("input", D({
					className: P.a.input,
					ref: i,
					disabled: n,
					placeholder: o ? k.fbt._("Search communities", null, {
						hk: "1mtF5A"
					}) : k.fbt._("Choose a community", null, {
						hk: "44gKTd"
					}),
					spellCheck: !1,
					value: c
				}, d))), r.a.createElement("div", {
					onClick: s,
					onMouseDown: L
				}, r.a.createElement(j.a, {
					name: "caret_down",
					className: P.a.dropdownIcon
				})))
			}
			var F = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/index.tsx"),
				B = n("./src/reddit/selectors/experiments/postCreationSubRec.ts"),
				U = n("./src/reddit/controls/SubredditPicker/Picker/index.m.less"),
				K = n.n(U),
				W = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/RecommendedSubreddits/index.tsx");
			const G = Object(l.c)({
				isOpenAIPilotV1: B.g,
				shouldRenderRec: B.m
			});
			class H extends r.a.Component {
				constructor(e) {
					var t;
					super(e), t = this, this.inputRef = null, this.setInputRef = e => {
						this.inputRef = e, this.props.inputRef && this.props.inputRef(e)
					}, this.commitSelection = () => {
						const e = this.getPickerValue(!0);
						Object(v.c)(e.rawString) ? this.props.onChange(e, !0) : this.props.onChange({
							rawString: "",
							record: null
						}, !0), this.state.isOpen && this.setState({
							isOpen: !1
						})
					}, this.callOnChange = () => this.props.onChange(this.getPickerValue()), this.requestAutocomplete = y()(e => this.props.onGetSubredditAutocomplete(e), 200, {
						maxWait: 200
					}), this.selectItem = e => {
						const t = this.props.items[e];
						if (!t) throw new Error("Invalid item index");
						let n;
						n = t.type === _.a.OWN_PROFILE ? Object(a.e)(t.name) : Object(a.d)(t.name), this.setState({
							inputValue: n,
							focusedIndex: e
						}, this.commitSelection)
					}, this.onSelectRecommendation = e => {
						if (!e) throw new Error("Invalid item index");
						let t;
						t = e.type === _.a.OWN_PROFILE ? Object(a.e)(e.name) : Object(a.d)(e.name), this.props.onChange({
							rawString: t,
							record: {
								name: e.name,
								iconUrl: e.iconUrl,
								primaryColor: e.primaryColor,
								type: O.a.SUBREDDIT
							}
						}, !0), this.state.isOpen && this.setState({
							isOpen: !1
						})
					}, this.getPickerValue = function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						const n = t.state.inputValue,
							o = t.state.focusedIndex,
							{
								items: r,
								value: s
							} = t.props;
						if (s && s.record && Object(a.a)(n, s.record.name)) return {
							...s,
							rawString: n
						};
						const i = r[o] || e && r.find(e => Object(a.a)(e.name, n));
						if (!i) return {
							rawString: n,
							record: null
						};
						const {
							type: c,
							id: d,
							name: l,
							iconUrl: u,
							primaryColor: m,
							allowedPostTypes: p
						} = i;
						return {
							rawString: n,
							record: Object(a.a)(n, l) ? {
								id: d,
								name: l,
								iconUrl: u,
								primaryColor: m,
								allowedPostTypes: p,
								type: c === _.a.OWN_PROFILE ? O.a.PROFILE : O.a.SUBREDDIT
							} : null
						}
					}, this.findNextEnabledItemIndex = e => {
						const t = e ? -1 : 1;
						let n = this.state.focusedIndex + t,
							o = this.props.items[n];
						for (; o;) {
							if (!o.disabled) return n;
							n += t, o = this.props.items[n]
						}
						return n
					}, this.moveSelection = function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						const {
							value: n,
							items: o
						} = t.props;
						let r = t.findNextEnabledItemIndex(e);
						r < -1 ? r = o.length - 1 : r >= o.length && (r = -1);
						const s = -1 === r ? n.rawString : o[r].name;
						s && t.setState({
							focusedIndex: r,
							inputValue: s
						})
					}, this.placeCursorAtTheEnd = () => {
						const e = this.state.inputValue.length;
						this.inputRef && this.inputRef.setSelectionRange(e, e)
					}, this.onDropdownClick = e => {
						const {
							inputRef: t
						} = this;
						this.state.isOpen ? this.setState({
							isOpen: !1
						}) : (t && t.focus(), this.setState({
							isOpen: !0
						}), this.placeCursorAtTheEnd()), e.preventDefault(), e.stopPropagation()
					}, this.onFocus = () => {
						this.props.onFocus && this.props.onFocus(), this.setState({
							isActive: !0,
							isOpen: !0
						}), this.inputRef && this.inputRef.select()
					}, this.onBlur = () => {
						this.props.selectOnBlur && this.state.isOpen ? (this.commitSelection(), this.setState({
							isActive: !1
						})) : this.setState({
							isActive: !1,
							isOpen: !1
						})
					}, this.onDropdownContainerMouseDown = e => {
						e.preventDefault()
					}, this.onEntryFocus = e => {
						this.setState({
							focusedIndex: e
						})
					}, this.onEntrySelect = e => {
						this.selectItem(e)
					}, this.onInputChange = e => {
						this.state.isOpen || this.setState({
							isOpen: !0
						});
						const t = e.target.value,
							n = this.state.inputValue;
						this.requestAutocomplete(t), this.setState({
							inputValue: t
						}, this.callOnChange), this.props.onInputChange && this.props.onInputChange(n, t)
					}, this.onKeyDown = e => {
						e.which === x.a.ArrowUp ? (this.moveSelection(!0), e.preventDefault()) : e.which === x.a.ArrowDown ? (this.moveSelection(), e.preventDefault()) : e.which === x.a.Enter || e.which === x.a.Tab ? (-1 !== this.state.focusedIndex ? this.selectItem(this.state.focusedIndex) : this.commitSelection(), e.which !== x.a.Tab && e.preventDefault()) : e.which === x.a.Escape && (this.inputRef && this.inputRef.blur(), e.preventDefault())
					}, this.state = {
						isActive: !1,
						isOpen: !1,
						focusedIndex: 0,
						inputValue: e.value.rawString
					}
				}
				componentDidMount() {
					const {
						value: {
							rawString: e
						}
					} = this.props;
					e && this.requestAutocomplete(e)
				}
				UNSAFE_componentWillReceiveProps(e) {
					this.setState({
						focusedIndex: -1,
						inputValue: e.value.rawString
					})
				}
				render() {
					const {
						className: e,
						disabled: t,
						isOpenAIPilotV1: n,
						isValid: o = !0,
						items: s,
						shouldRenderRec: i,
						value: a,
						shouldShowCreateCommunityButton: c
					} = this.props, {
						isActive: d,
						isOpen: l
					} = this.state, u = a.record;
					return r.a.createElement("div", {
						className: Object(E.a)(K.a.container, e, {
							[K.a.mIsActive]: d,
							[K.a.mIsInvalid]: !o
						})
					}, r.a.createElement(A, {
						disabled: t,
						isActive: this.state.isActive,
						value: this.state.inputValue,
						inputRef: this.setInputRef,
						onDropdownClick: this.onDropdownClick,
						onChange: this.onInputChange,
						onFocus: this.onFocus,
						onBlur: this.onBlur,
						onKeyDown: this.onKeyDown,
						record: u
					}), !this.state.inputValue && l && i && r.a.createElement(W.a, {
						onSelectRecommendation: this.onSelectRecommendation,
						onContainerMouseDown: this.onDropdownContainerMouseDown
					}), l && (!i || !!this.state.inputValue) && r.a.createElement(F.a, {
						className: n ? K.a.subredditDropdownOpenAI : void 0,
						items: s,
						isValid: o,
						focusedIndex: this.state.focusedIndex,
						showNoMatchesCaption: !this.props.haveSuggestions && this.props.isAllDataRetrieved,
						onContainerMouseDown: this.onDropdownContainerMouseDown,
						onEntryFocus: this.onEntryFocus,
						onEntrySelect: this.onEntrySelect,
						onOpenCommunityCreation: this.props.openCommunityCreation,
						shouldShowCreateCommunityButton: c
					}))
				}
			}
			var V = Object(d.b)(G)(H),
				z = n("./src/reddit/helpers/trackers/postComposer.ts"),
				q = n("./src/reddit/selectors/platform.ts"),
				Q = n("./src/reddit/selectors/subredditAutocomplete.ts"),
				Y = n("./src/reddit/selectors/user.ts");

			function J() {
				return (J = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const X = Object(g.v)(),
				Z = Object(u.a)(Object(l.a)((e, t) => t.value, (e, t) => {
					let {
						allowCrosspostableOnly: n,
						includeUserProfile: o,
						value: r
					} = t;
					return Object(Q.a)(e, {
						allowCrosspostableOnly: n,
						includeUserProfile: o,
						substring: r.rawString
					})
				}, e => Object(Y.sb)(e) && Object(q.j)(e), (e, t, n) => {
					const {
						suggestedItems: o,
						fallbackItems: r,
						isAllDataRetrieved: s
					} = t, i = o.length ? o : e.record ? [Object(v.a)(e.record)] : [];
					return {
						items: 0 === i.length && s ? r : i,
						haveSuggestions: i.length > 0,
						isAllDataRetrieved: t.isAllDataRetrieved,
						isAutocompletePending: t.isPending,
						shouldShowCreateCommunityButton: n
					}
				})),
				$ = {
					onGetInitialData: e => t => t(e ? h.d() : b.e()),
					onGetSubredditAutocomplete: p.a,
					openCommunityCreation: () => async (e, t) => {
						Object(z.c)(t()), e(Object(m.h)(f.a.SUBREDDIT_CREATION_MODAL_ID))
					}
				};
			class ee extends r.a.Component {
				constructor() {
					super(...arguments), this.onGetSubredditAutocomplete = e => {
						this.props.onGetSubredditAutocomplete(e)
					}
				}
				componentDidMount() {
					this.props.onGetInitialData(!!this.props.allowCrosspostableOnly)
				}
				render() {
					return r.a.createElement(V, J({}, this.props, {
						onGetSubredditAutocomplete: this.onGetSubredditAutocomplete
					}))
				}
			}
			var te = X(Object(d.b)(Z, $)(ee));
			class ne extends r.a.Component {
				constructor() {
					super(...arguments), this.renderPicker = e => r.a.createElement(te, {
						allowCrosspostableOnly: this.props.allowCrosspostableOnly,
						className: this.props.className,
						disabled: this.props.disabled || !1,
						includeUserProfile: this.props.includeUserProfile,
						inputRef: this.props.inputRef,
						isValid: this.props.isValid,
						onChange: e.onChange,
						onFocus: e.onFocus,
						onInputChange: this.props.onInputChange,
						value: e.value,
						selectOnBlur: this.props.selectOnBlur || !1
					})
				}
				render() {
					return r.a.createElement(c, {
						onFocus: this.props.onFocus,
						onSelect: this.props.onSelect,
						renderPicker: this.renderPicker,
						value: this.props.value
					})
				}
			}
		},
		"./src/reddit/controls/TextButton/index.m.less": function(e, t, n) {
			e.exports = {
				textButton: "qYzY57HWQ8W424hj3s10-"
			}
		},
		"./src/reddit/controls/TextButton/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/TextButton/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("button", {
				children: e.children,
				className: Object(s.a)(a.a.textButton, e.className),
				disabled: e.disabled,
				onClick: e.onClick
			})
		},
		"./src/reddit/controls/ToggleSwitch/index.m.less": function(e, t, n) {
			e.exports = {
				toggleDisplay: "_2FKpII1jz0h6xCAw1kQAvS",
				toggleSwitch: "_2e2g485kpErHhJQUiyvvC2",
				redditStyle: "_3kUvbpMbR21zJBboDdBH7D",
				mActive: "_1L5kUnhRYhUJ4TkMbOTKkI",
				mDisabled: "_3clF3xRMqSWmoBQpXv8U5z",
				xs: "_1asGWL2_XadHoBuUlNArOq",
				s: "_1hku5xiXsbqzLmszstPyR3",
				m: "_10hZCcuqkss2sf5UbBMCSD",
				l: "_1fCdbQCDv6tiX242k80-LO",
				xl: "_2Jp5Pv4tgpAsTcnUzTsXgO"
			}
		},
		"./src/reddit/controls/ToggleSwitch/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/Button/index.tsx"),
				a = n("./src/reddit/controls/ToggleSwitch/index.m.less"),
				c = n.n(a);
			t.a = Object(o.memo)(Object(o.forwardRef)((e, t) => {
				const n = e.size || i.d.XS;
				return r.a.createElement("button", {
					"aria-checked": e.on,
					className: Object(s.a)(c.a.toggleSwitch, e.className, {
						[c.a.xs]: n === i.d.XS,
						[c.a.s]: n === i.d.S,
						[c.a.m]: n === i.d.M,
						[c.a.l]: n === i.d.L,
						[c.a.xl]: n === i.d.XL,
						[c.a.mActive]: e.on && !e.disabled || e.forceOn && e.on,
						[c.a.mDisabled]: e.disabled,
						[c.a.redditStyle]: e.redditStyle
					}),
					style: e.on && !e.disabled && e.activeColorOverride ? {
						backgroundColor: e.activeColorOverride
					} : void 0,
					id: e.id,
					role: "switch",
					tabIndex: e.tabIndex,
					type: "button",
					onClick: () => !e.disabled && e.onToggle && e.onToggle(),
					ref: t
				}, r.a.createElement("div", {
					className: c.a.toggleDisplay
				}))
			}))
		},
		"./src/reddit/controls/Typography/index.m.less": function(e, t, n) {
			e.exports = {
				heading1: "_37JeV292IJA7_x1qej_-2H",
				heading2: "p13k-tsMcatGBlVpJBZmw",
				heading3: "_1nHvvYpmn7q9eWDAGzKcce",
				heading4: "_1-rwUWsB5F8WmYI8F66dai",
				heading5: "_22RKdGqihAj6MFumW6DuRV",
				heading6: "_4xqrI_N1UdqsK9E1RSisG",
				body1: "_2HJOIn4SJm4z1NeCv_hNFu",
				body2: "_3ImIPX9rfoPmUrZ1R8KGqS",
				actionFont: "_3uShGanwyVFBaTiPMFzfAC",
				metadata: "_2nyJGeaFJbXTqTh9OGwxfu",
				metadata3: "_3BIqvjJkJKZfH4vtC11dGF"
			}
		},
		"./src/reddit/controls/Typography/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return c
			}));
			var o = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/Typography/index.m.less"),
				s = n.n(r);
			o.a.h1("heading1", s.a), o.a.h2("heading2", s.a), o.a.h3("heading3", s.a), o.a.h4("heading4", s.a);
			const i = o.a.h5("heading5", s.a),
				a = (o.a.h6("heading6", s.a), o.a.p("body1", s.a), o.a.p("body2", s.a)),
				c = (o.a.p("actionFont", s.a), o.a.p("metadata", s.a));
			o.a.p("metadata3", s.a)
		},
		"./src/reddit/controls/UnstyledInternalLink/index.m.less": function(e, t, n) {
			e.exports = {
				unstyledInternalLink: "_39Glgtoolpdt4PIzcnjPSW"
			}
		},
		"./src/reddit/controls/UnstyledInternalLink/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/InternalLink/index.tsx"),
				s = n("./src/reddit/controls/UnstyledInternalLink/index.m.less"),
				i = n.n(s);
			t.a = o.a.wrapped(r.default, "unstyledInternalLink", i.a)
		},
		"./src/reddit/controls/Upvote/index.m.less": function(e, t, n) {
			e.exports = {
				Upvote: "_3SUsITjKNQ7Tp0Wi2jGxIM",
				upvote: "_3SUsITjKNQ7Tp0Wi2jGxIM",
				mIsInteractive: "qW0l8Af61EP35WIG6vnGk",
				mIsActive: "Z3lT0VGlALek4Q9j0ZQCr",
				mIsVoteable: "_3edNsMs0PNfyQYofMNVhsG"
			}
		},
		"./src/reddit/endpoints/economics/emojis.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return i
			}));
			var o = n("./src/config.ts"),
				r = n("./src/reddit/endpoints/governance/requester.ts");
			const s = (e, t) => Object(r.a)(e, {
					method: "post",
					endpoint: `${o.a.metaUrl}/orders`,
					data: {
						price: "0",
						currency: "usd",
						products: [{
							productId: t.productId,
							quantity: "1"
						}],
						subredditId: t.subredditId
					}
				}),
				i = (e, t) => Object(r.a)(e, {
					method: "get",
					endpoint: `${o.a.metaUrl}/product-collections/${t}?types=emotes_pack`
				})
		},
		"./src/reddit/endpoints/economics/specialMembership.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			}));
			var o = n("./src/config.ts"),
				r = n("./src/lib/omitHeaders/index.ts"),
				s = n("./src/reddit/constants/headers.ts"),
				i = n("./src/reddit/endpoints/governance/requester.ts"),
				a = n("./src/reddit/helpers/governanceErrorText/index.ts"),
				c = n("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts");

			function d(e, t) {
				return Object(i.a)(e, {
					endpoint: `${o.a.metaUrl}/communities/${t.subredditId}/me`,
					method: "patch",
					data: {
						specialMemberships: {
							settings: {
								renew: !1
							}
						}
					}
				})
			}

			function l(e, t) {
				return Object(i.a)(e, {
					endpoint: `${o.a.metaUrl}/ps/me/braintree-client-tokens`,
					method: "post",
					data: {
						username: t && t.username
					}
				})
			}

			function u(e, t) {
				return Object(i.a)(e, {
					endpoint: `${o.a.metaUrl}/orders`,
					method: "post",
					data: {
						currency: "usd",
						orderTarget: "special_membership",
						price: t.trial ? "0" : t.price,
						products: [{
							productId: t.productId,
							quantity: "1"
						}],
						providerArgs: {
							paymentNonce: t.nonce,
							savePaymentMethod: !0
						},
						providerName: "braintree",
						subredditId: t.subredditId,
						targetArgs: {
							renew: !0,
							receiverName: t.username
						}
					}
				})
			}

			function m(e, t) {
				return Object(i.a)(Object(r.a)(e, [s.a]), {
					endpoint: `${e.apiUrl}/api/info?id=${t.join(",")}`,
					method: "get"
				}).then(e => {
					if (e.ok) {
						const t = e.body.data.children.map(e => {
							let {
								data: t
							} = e;
							return Object(c.a)(t)
						}).reduce((e, t) => (e[t.id] = t, e), {});
						return {
							...e,
							body: t
						}
					}
					return e
				})
			}
			async function p(e, t) {
				const n = await Object(i.a)(e, {
					endpoint: `${o.a.metaUrl}/orders`,
					method: "post",
					data: {
						...t,
						currency: "points",
						orderTarget: "special_membership",
						products: [{
							productId: "provisional_membership",
							quantity: "1"
						}],
						targetArgs: {
							renew: !1
						}
					}
				});
				if (!n.ok) throw new Error(`Error fetching provisional membership: ${Object(a.b)(n.error)}`);
				return n.body
			}
		},
		"./src/reddit/endpoints/economics/subredditPremium.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/lodash/merge.js"),
				r = n.n(o),
				s = n("./src/config.ts"),
				i = n("./src/reddit/endpoints/governance/badges.ts"),
				a = n("./src/reddit/endpoints/governance/community.ts"),
				c = n("./src/reddit/endpoints/governance/products/badges.ts"),
				d = n("./src/reddit/endpoints/governance/requester.ts");
			async function l(e, t, n) {
				const o = {
						subredditId: t,
						badges: {},
						errors: {},
						collections: {},
						products: {},
						subscription: void 0,
						userOwnedBadges: []
					},
					l = function(e, t) {
						return Object(d.a)(e, {
							method: "get",
							endpoint: `${s.a.metaUrl}/product-collections/${t}?types=badge`
						})
					}(e, t),
					u = Object(a.a)(e, {
						subredditId: t
					}),
					m = Object(c.b)(e, t),
					p = Object(i.c)(e, t, n),
					[h, b, f, g] = await Promise.all([l, u, m, p]);
				if (h.ok ? o.collections = h.body : o.errors.collections = h.error, b.ok) {
					const e = b.body;
					o.subscription = e.specialMemberships, o.communityRaw = e
				}
				return f.ok ? o.products = f.body : o.errors.products = f.error, g.ok ? (r()(o.badges, g.body.badges), o.userOwnedBadges = g.body.userOwnedBadges) : o.errors.userBadges = g.error, o
			}
			const u = (e, t) => Object(d.a)(e, {
				endpoint: `${s.a.metaUrl}/products/${t}?types=badge,membership`,
				method: "delete"
			})
		},
		"./src/reddit/endpoints/governance/badges.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./src/config.ts"),
				r = n("./src/reddit/endpoints/governance/requester.ts");
			async function s(e, t, n) {
				const s = Object(r.a)(e, {
						headers: {
							"X-HTTP-Method-Override": "GET"
						},
						method: "post",
						endpoint: `${o.a.metaUrl}/badges/${t}`,
						data: {
							selected: !0,
							users: n
						}
					}),
					i = await s;
				if (i.ok) {
					const e = {},
						t = {},
						n = i.body;
					return Object.keys(n).forEach(o => {
						const r = n[o];
						t[o] = r, e[r.userId] || (e[r.userId] = []), e[r.userId].push(r.id)
					}), {
						...i,
						body: {
							badges: t,
							usersAppliedBadges: e
						}
					}
				}
				return i
			}
			async function i(e, t, n) {
				const s = await Object(r.a)(e, {
					method: "get",
					endpoint: `${o.a.metaUrl}/badges/${t}?users=${n}`
				});
				if (s.ok) {
					const e = {},
						t = [],
						n = s.body;
					return Object.keys(n).forEach(o => {
						const r = n[o];
						e[o] = r, t.push(r.id)
					}), {
						...s,
						body: {
							badges: e,
							userOwnedBadges: t
						}
					}
				}
				return s
			}

			function a(e, t, n) {
				let s = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
				return Object(r.a)(e, {
					method: "patch",
					endpoint: `${o.a.metaUrl}/badges/${t}/${n}`,
					data: {
						selected: s
					}
				})
			}
		},
		"./src/reddit/endpoints/governance/community.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var o = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				s = n("./src/reddit/endpoints/governance/requester.ts");

			function i(e, t) {
				return Object(s.a)(e, {
					endpoint: `${o.a.metaUrl}/communities/${t.subredditId}/me`,
					method: r.ob.GET
				})
			}
		},
		"./src/reddit/endpoints/governance/crypto.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "j", (function() {
				return i
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "l", (function() {
				return d
			})), n.d(t, "k", (function() {
				return l
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "n", (function() {
				return v
			}));
			var o, r = n("./src/config.ts"),
				s = n("./src/reddit/endpoints/governance/requester.ts");

			function i(e) {
				switch (e) {
					case o.Ethereum:
					case o.EthTraderEthereum:
						return "Ethereum Main Network";
					case o.Rinkeby:
					case o.EthTraderRinkeby:
						return "Rinkeby Test Network"
				}
				return e + " Network"
			}

			function a(e) {
				switch (e) {
					case o.Ethereum:
					case o.EthTraderEthereum:
						return "https://meta-api.reddit.com/ethereum/ethereum";
					case o.Rinkeby:
					case o.EthTraderRinkeby:
						return "https://meta-api.reddit.com/ethereum/rinkeby";
					case o.ArbitrumRinkeby:
						return "https://meta-api.reddit.com/ethereum/ethereum:5391184";
					case o.ArbitrumNitroDevnet:
						return "https://meta-api.reddit.com/ethereum/nitroDevnet";
					case o.ArbitrumMainnet:
						return "https://a4ba.arbitrum.io/rpc";
					default:
						return `https://meta-api.reddit.com/ethereum/${e}`
				}
			}

			function c(e) {
				switch (e) {
					case o.Ethereum:
					case o.EthTraderEthereum:
						return "homestead";
					case o.Rinkeby:
					case o.EthTraderRinkeby:
						return "rinkeby";
					case o.ArbitrumRinkeby:
						return 5391184;
					case o.ArbitrumNitroDevnet:
						return 421612;
					case o.ArbitrumMainnet:
						return 42170;
					default: {
						const [, t] = e.split(":");
						return t
					}
				}
			}

			function d(e) {
				return e === o.ArbitrumRinkeby ? 5e3 : 3e4
			}
			async function l(e, t, n) {
				return Object(s.a)(e, {
					method: "post",
					endpoint: `${r.a.metaUrl}/crypto/${t}/challenges`,
					data: {
						challengeType: "registration-challenge-EIP712",
						address: n
					}
				})
			}
			async function u(e, t, n) {
				return await Object(s.a)(e, {
					method: "post",
					endpoint: `${r.a.metaUrl}/crypto/${t}/registrations`,
					data: n
				})
			}
			async function m(e, t, n) {
				return await Object(s.a)(e, {
					method: "delete",
					endpoint: `${r.a.metaUrl}/crypto/${t}/registrations/${n}`
				})
			}! function(e) {
				e.Ethereum = "ethereum:1", e.Rinkeby = "ethereum:4", e.ArbitrumNova = "ethereum:42170", e.ArbitrumRinkeby = "ethereum:5391184", e.ArbitrumNitroDevnet = "ethereum:421612", e.ArbitrumMainnet = "ethereum:42170", e.EthTraderEthereum = "ethereum:1:ethtrader", e.EthTraderRinkeby = "ethereum:4:ethtrader"
			}(o || (o = {}));
			const p = (e, t, n) => ({
					type: "burn-link",
					subredditId: e,
					amount: t,
					burnMemo: n
				}),
				h = e => ({
					type: "convert-to-coins",
					subredditId: e
				}),
				b = e => ({
					type: "claim",
					subredditId: e
				}),
				f = e => ({
					type: "subscribe",
					subredditId: e
				}),
				g = (e, t, n, o) => ({
					type: "transfer",
					subredditId: e,
					recipient: t,
					recipientAddress: n,
					amount: o
				});
			async function v(e, t) {
				return await Object(s.a)(e, {
					method: "put",
					endpoint: `${r.a.metaUrl}/crypto/ethereum/transaction-intent`,
					data: t
				})
			}
		},
		"./src/reddit/endpoints/governance/products/badges.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			}));
			var o = n("./src/config.ts"),
				r = n("./src/reddit/endpoints/governance/requester.ts");

			function s(e, t) {
				return Object(r.a)(e, {
					method: "get",
					endpoint: `${o.a.metaUrl}/products/${t}?types=badge`
				})
			}

			function i(e, t) {
				return Object(r.a)(e, {
					method: "get",
					endpoint: `${o.a.metaUrl}/products/${t}?types=badge,membership`
				})
			}

			function a(e, t) {
				return Object(r.a)(e, {
					method: "post",
					endpoint: `${o.a.metaUrl}/orders`,
					data: t
				})
			}

			function c(e, t) {
				return Object(r.a)(e, {
					method: "post",
					endpoint: `${o.a.metaUrl}/orders`,
					data: {
						currency: "usd",
						price: t.price,
						products: t.products,
						providerArgs: {
							paymentNonce: t.nonce
						},
						providerName: "braintree",
						subredditId: t.subredditId
					}
				})
			}
		},
		"./src/reddit/endpoints/governance/wallet.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var o = n("./src/config.ts"),
				r = (n("./src/lib/bigNumberUtils/percent.ts"), n("./src/lib/constants/index.ts")),
				s = n("./src/reddit/endpoints/governance/requester.ts");

			function i(e, t) {
				return Object(s.a)(e, {
					endpoint: `${o.a.metaUrl}/wallets/${t.subredditId}/me`,
					method: r.ob.GET
				}).then(e => {
					if (e.ok) {
						const n = e.body,
							o = {
								[t.subredditId]: n
							};
						return {
							...e,
							body: o
						}
					}
					return e
				})
			}

			function a(e, t) {
				return Object(s.a)(e, {
					headers: {
						"X-HTTP-Method-Override": "GET"
					},
					endpoint: `${o.a.metaUrl}/wallets/${t.subredditId}`,
					method: r.ob.POST,
					data: t.userIds
				}).then(e => e.ok ? {
					...e,
					body: {
						wallets: e.body
					}
				} : e)
			}
		},
		"./src/reddit/endpoints/onboarding/languageSelections.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return l
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./src/lib/makeGqlRequest/index.ts");
			var r, s = n("./src/redditGQL/operations/LanguageSelections.json"),
				i = n("./src/redditGQL/operations/UpdateSpokenLanguagesPreference.json");
			! function(e) {
				e.ALL_KEY = "all_languages_simple", e.SUGGESTED_KEY = "suggested_languages", e.TOP_KEYS = "top_languages"
			}(r || (r = {}));
			const a = (e, t) => {
					const n = {
						allKey: e,
						suggestedKey: r.SUGGESTED_KEY
					};
					return Object(o.a)(t, {
						...s,
						variables: n
					})
				},
				c = async e => {
					const t = await a(r.ALL_KEY, e());
					if (!t.ok) return null;
					const n = t.body,
						o = null == n ? void 0 : n.data;
					return o ? (e => {
						const t = {},
							n = e.identity.preferences.spokenLanguages || [];
						return e.all.map(e => {
							t[e.isoCode] = e.translatedDisplayName
						}), {
							languages: t,
							preferences: n
						}
					})(o) : null
				}, d = async (e, t, n) => {
					const o = await a(e, t());
					if (!o.ok) return null;
					const s = o.body,
						i = null == s ? void 0 : s.data;
					if (i) {
						return ((e, t, n) => {
							let o = null,
								r = [];
							const s = [],
								i = [],
								a = {},
								c = {};
							if (!e) {
								t.identity.preferences.spokenLanguages.map(e => {
									c[e] = !0
								})
							}
							for (let d = 0; d < t.suggested.length; d++) {
								const r = t.suggested[d];
								if (a[r.isoCode] = !0, n === r.isoCode) o = r;
								else {
									if (!e && c[r.isoCode]) continue; {
										const t = !!(e || !e && c[r.isoCode]);
										s.push({
											selected: t,
											...r
										})
									}
								}
							}
							for (let d = 0; d < t.all.length; d++) {
								const s = t.all[d];
								s.isoCode === n ? (o = s, i.push({
									selected: !0,
									...s
								})) : !e && c[s.isoCode] ? i.push({
									selected: !0,
									...s
								}) : a[s.isoCode] || r.push({
									selected: !(e || !c[s.isoCode]),
									...s
								})
							}
							if (r = s.concat(r), null === o) {
								const e = n.split("-").shift();
								for (let t = 0; t < r.length; t++)
									if (r[t].isoCode === e) {
										o = r[t], r.splice(t, 1);
										break
									}
							}
							return o && ((e || !e && c[o.isoCode]) && (o.selected = !0), r.unshift(o)), e || (r = i.concat(r)), {
								sortedLanguages: r
							}
						})(e === r.TOP_KEYS, i, n)
					}
					return null
				}, l = async (e, t) => {
					const n = await ((e, t) => {
						const n = {
							input: {
								spokenLanguages: t
							}
						};
						return Object(o.a)(e, {
							...i,
							variables: n
						})
					})(e(), Object.keys(t));
					if (!n.ok) return null;
					const r = n.body;
					return null == r ? void 0 : r.data
				}
		},
		"./src/reddit/endpoints/post/create.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return C
			})), n.d(t, "f", (function() {
				return y
			})), n.d(t, "e", (function() {
				return E
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "a", (function() {
				return O
			}));
			var o = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				d = n("./src/reddit/helpers/flair.ts"),
				l = n("./src/reddit/helpers/name/index.ts"),
				u = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				m = n("./src/reddit/models/Poll/index.ts"),
				p = n("./src/reddit/models/Post/index.ts"),
				h = n("./src/reddit/models/PostCreationForm/index.ts"),
				b = n("./src/reddit/models/RichTextJson/addRTJParam.ts");

			function f(e) {
				return Math.floor(e.valueOf() / 1e3)
			}
			const g = e => {
					switch (e.kind) {
						case h.p.CROSSPOST:
							return h.p.CROSSPOST;
						case h.p.LINK:
							return h.p.LINK;
						case h.p.POLL:
							return h.p.POLL;
						case h.p.MEDIA:
							return e.makeGif ? h.p.VIDEO_GIF : e.mediaType;
						default:
							return "self"
					}
				},
				v = e => {
					switch (e.kind) {
						case h.p.RICH_TEXT:
							return {
								richtext_json: JSON.stringify({
									document: e.document
								})
							};
						case h.p.MARKDOWN:
							return {
								text: e.markdown
							};
						case h.p.LINK:
						case h.p.MEDIA:
							return {
								url: e.url
							};
						case h.p.CROSSPOST:
							return {
								crosspost_fullname: e.sourcePostId
							};
						case h.p.POLL:
							return e.poll.type === m.a.Prediction ? {
								duration: 999999,
								end_timestamp: f(e.poll.endDate),
								options: e.poll.options.map(e => e.text),
								prediction: !0,
								text: e.markdown,
								raw_rtjson: "markdown" in e ? null : JSON.stringify({
									document: e.document
								})
							} : {
								duration: Math.floor(e.poll.duration / 864e5),
								options: e.poll.options.map(e => e.text),
								text: e.markdown,
								raw_rtjson: "markdown" in e ? null : JSON.stringify({
									document: e.document
								})
							}
					}
				},
				C = e => {
					const t = Object(l.i)(e.destSubreddit.name);
					return {
						...e.destSubreddit.isProfile ? {
							sr: `u_${t}`,
							submit_type: "profile"
						} : {
							sr: t,
							submit_type: "subreddit"
						},
						api_type: "json",
						show_error_list: !0,
						draft_id: e.draftId || void 0,
						title: e.title,
						discussion_type: e.isChatPost ? p.b.Chat : void 0,
						spoiler: e.isSpoiler,
						nsfw: e.isNSFW,
						recaptcha_token: e.reCaptchaEnterpriseToken,
						...e.kind !== h.p.POLL ? {
							kind: g(e),
							original_content: e.isOC
						} : {},
						post_to_twitter: e.postToTwitter,
						sendreplies: e.sendReplies,
						...e.gRecaptchaResponse ? {
							"g-recaptcha-response": e.gRecaptchaResponse
						} : {},
						resubmit: e.resubmit,
						...v(e),
						...e.kind === h.p.MEDIA && "video" === e.mediaType ? {
							video_poster_url: e.videoThumbnailUrl
						} : {},
						...e.kind === h.p.MEDIA && e.makeGif ? {
							make_gif: "on"
						} : {},
						...e.flair ? {
							flair_id: e.flair.templateId,
							flair_text: Object(d.g)(e.flair)
						} : {},
						...e.validate_on_submit ? {
							validate_on_submit: e.validate_on_submit
						} : {},
						...e.eventSchedule && {
							event_start: e.eventSchedule.startDate,
							event_end: e.eventSchedule.endDate,
							event_tz: e.eventSchedule.timezoneName,
							unlist: e.eventSchedule.submitTime === h.j.AtEventTime
						},
						...e.collectionId && {
							collection_id: e.collectionId
						}
					}
				},
				y = e => {
					const t = /comments\/(\w+)\/.*$/.exec(e),
						n = t && t[1];
					return n ? `${r.Ob.Post}_${n}` : ""
				},
				E = async (e, t) => {
					if (!e.ok) return Object(u.b)(e);
					const n = e.body.json.data;
					let r = n.url;
					r || t.kind !== h.p.MEDIA || (r = await ((e, t) => new Promise(n => {
						const o = new WebSocket(e),
							r = e => {
								o.close(), clearTimeout(s), n(e)
							},
							s = setTimeout(() => {
								r("")
							}, t);
						o.onmessage = e => {
							const t = JSON.parse(e.data),
								n = "success" === t.type ? t.payload.redirect : "";
							r(n)
						}, o.onerror = e => {
							r("")
						}
					}))(n.websocket_url, 3e4));
					const s = n.id || y(r),
						i = Object(o.parse)(r).path,
						a = n.drafts_count;
					return {
						...e,
						body: {
							id: s,
							path: i,
							draftsCount: a
						}
					}
				}, x = (e, t) => Object(s.a)(Object(i.a)(e, [a.a]), {
					endpoint: Object(b.a)(Object(c.a)(`${e.apiUrl}/api/submit_poll_post.json?resubmit=true`)),
					method: r.ob.POST,
					data: C(t),
					type: "json"
				}).then(e => E(e, t)), O = (e, t) => Object(s.a)(Object(i.a)(e, [a.a]), {
					endpoint: Object(b.a)(Object(c.a)(`${e.apiUrl}/api/submit_gallery_post.json?resubmit=true`)),
					method: r.ob.POST,
					data: {
						...C(t),
						items: t.galleryItems.map(e => ({
							caption: e.caption,
							outbound_url: e.url,
							media_id: e.assetId
						}))
					},
					type: "json"
				}).then(e => E(e, t));
			t.c = (e, t) => Object(s.a)(Object(i.a)(e, [a.a]), {
				endpoint: Object(b.a)(Object(c.a)(`${e.apiUrl}/api/submit?resubmit=true`)),
				method: r.ob.POST,
				data: C(t)
			}).then(async e => await E(e, t))
		},
		"./src/reddit/endpoints/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return u
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "a", (function() {
				return x
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/reddit/helpers/flair.ts"),
				s = n("./src/reddit/helpers/richTextJson/index.ts"),
				i = n("./src/reddit/models/Post/index.ts"),
				a = n("./src/reddit/models/PostCreationForm/index.ts"),
				c = n("./src/reddit/models/ScheduledPost/index.ts"),
				d = n("./src/redditGQL/operations/CreateScheduledPost.json"),
				l = n("./src/redditGQL/operations/SubredditScheduledPosts.json");
			const u = (e, t) => Object(o.a)(e, {
					...l,
					variables: {
						...t,
						includeRecurring: !(!t.includeRecurring || !t.includeRecurring.recurringFirst),
						includeStandalone: !(!t.includeStandalone || !t.includeStandalone.standaloneFirst),
						recurringAfter: t.includeRecurring ? t.includeRecurring.recurringAfter : void 0,
						recurringFirst: t.includeRecurring ? t.includeRecurring.recurringFirst : void 0,
						standaloneAfter: t.includeStandalone ? t.includeStandalone.standaloneAfter : void 0,
						standaloneFirst: t.includeStandalone ? t.includeStandalone.standaloneFirst : void 0
					}
				}),
				m = (e, t) => {
					if (!e.ok || !e.body) return !1;
					const n = e.body;
					return !!(n.data && n.data.subredditInfoById && n.data.subredditInfoById.scheduledPosts && n.data.subredditInfoById.scheduledPosts[t] && n.data.subredditInfoById.scheduledPosts[t].edges)
				},
				p = (e, t) => !(!e.ok || !e.body) && (!(t.includeStandalone && !(e => m(e, c.g.standalonePosts))(e)) && !(t.includeRecurring && !(e => m(e, c.g.recurringPosts))(e))),
				h = e => {
					let {
						poll: t,
						schedule: n,
						submission: o,
						subredditId: s
					} = e;
					return {
						collectionId: o.collectionId || "",
						discussionType: o.isChatPost ? i.b.Chat : i.b.Comment,
						isContestMode: o.isContestMode,
						isPostAsMetaMod: o.isPostAsMetaMod,
						isSpoiler: o.isSpoiler,
						isNsfw: o.isNSFW,
						poll: t && E(t),
						title: o.title,
						isOriginalContent: o.isOC,
						flair: o.flair ? {
							id: o.flair.templateId,
							text: Object(r.g)(o.flair)
						} : {},
						sticky: o.sticky,
						subredditId: s,
						suggestedCommentSort: o.suggestedSort,
						isSendReplies: o.sendReplies,
						...b(n),
						...C(o),
						assetIds: y(o)
					}
				},
				b = e => ({
					scheduling: {
						publishAt: e.submitDate,
						clientTimezone: e.timezoneName,
						frequency: e.recurrenceInfo ? e.recurrenceInfo.frequency : void 0,
						interval: e.recurrenceInfo ? e.recurrenceInfo.interval : void 0,
						byMonthDays: e.recurrenceInfo ? e.recurrenceInfo.byMonthDays : void 0,
						byWeekDays: e.recurrenceInfo ? e.recurrenceInfo.byWeekDays : void 0
					}
				}),
				f = e => ({
					scheduling: Object.keys(e).length > 0 ? {
						clientTimezone: e.timezoneName || void 0,
						publishAt: e.submitDate || void 0,
						frequency: e.recurrenceInfo ? e.recurrenceInfo.frequency : void 0,
						interval: e.recurrenceInfo ? e.recurrenceInfo.interval : void 0,
						byMonthDays: e.recurrenceInfo ? e.recurrenceInfo.byMonthDays : void 0,
						byWeekDays: e.recurrenceInfo ? e.recurrenceInfo.byWeekDays : void 0
					} : void 0
				}),
				g = e => {
					let {
						poll: t,
						schedule: n,
						scheduledPostId: o,
						submission: r,
						subredditId: s
					} = e;
					const i = h({
						poll: t,
						schedule: n,
						submission: r,
						subredditId: s
					});
					return {
						id: o,
						...i,
						flair: Object.keys(i.flair || {}).length ? {
							...i.flair
						} : {
							id: "",
							text: ""
						}
					}
				},
				v = e => /^https?:\/\//i.test(e) ? e : `http://${e}`,
				C = e => {
					switch (e.kind) {
						case a.p.RICH_TEXT:
							return {
								content: {
									richText: JSON.stringify({
										document: e.document
									})
								}
							};
						case a.p.MARKDOWN:
							return {
								content: {
									markdown: e.markdown
								}
							};
						case a.p.LINK:
							return {
								content: {}, link: {
									url: v(e.url)
								}
							};
						default:
							return {
								content: {}
							}
					}
				},
				y = e => {
					let t = [];
					if (e.document) {
						const n = e.document || [];
						t = Object(s.d)(n)
					}
					return t
				},
				E = e => {
					if (e && e.options && e.duration && (e.options = e.options.map(e => ({
							text: e.text.trim()
						})).filter(e => !!e.text), e.options.length)) return e.duration = Math.floor(e.duration / 864e5), e
				},
				x = (e, t) => Object(o.a)(e, {
					...d,
					variables: {
						input: t
					}
				})
		},
		"./src/reddit/endpoints/scheduledPosts/update.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var o = n("./src/redditGQL/operations/UpdateScheduledPost.json"),
				r = n("./src/lib/makeGqlRequest/index.ts");
			const s = (e, t) => Object(r.a)(e, {
				...o,
				variables: {
					input: t
				}
			})
		},
		"./src/reddit/endpoints/subreddit/subscriptions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			}));
			var o = n("./src/redditGQL/operations/SubscribedSubreddits.json"),
				r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts"),
				d = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			t.a = e => Object(i.a)(e, o);
			const l = (e, t) => {
					let {
						subredditIds: n,
						subredditNames: o,
						subscribe: i
					} = t;
					return Object(s.a)(Object(a.a)(e, [c.a]), {
						method: r.ob.POST,
						endpoint: Object(d.a)(`${e.apiUrl}/api/subscribe`),
						data: {
							action: i ? "sub" : "unsub",
							sr: n && n.join(",") || void 0,
							sr_name: o && o.join(",") || void 0,
							api_type: "json"
						}
					})
				},
				u = (e, t, n) => Object(s.a)(Object(a.a)(e, [c.a]), {
					method: r.ob.POST,
					endpoint: `${e.apiUrl}/api/favorite`,
					data: {
						make_favorite: n ? "true" : "false",
						sr_name: t,
						api_type: "json"
					}
				})
		},
		"./src/reddit/endpoints/talk/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = (n("./node_modules/uuid/dist/esm-browser/v4.js"), n("./src/lib/makeGqlRequest/index.ts")),
				s = n("./src/lib/makeRequest/index.ts"),
				i = (n("./src/reddit/models/Subreddit/index.ts"), n("./src/redditGQL/operations/CreateLiveAudioRoomOnProfile.json"), n("./src/redditGQL/operations/CreateLiveAudioRoomOrError.json"), n("./src/redditGQL/operations/GetAvailableAudioRoomTopics.json"), n("./src/redditGQL/operations/GetSubredditAllowedPostTypes.json")),
				a = n("./src/redditGQL/operations/GetUserProfileAllowedPostTypes.json"),
				c = (n("./src/redditGQL/operations/PrepareLiveAudioRoom.json"), n("./src/redditGQL/operations/PrepareLiveAudioRoomOnProfile.json"), n("./src/redditGQL/operations/ReportTalk.json")),
				d = (n("./src/redditGQL/operations/StartLiveAudioRoom.json"), n("./src/redditGQL/types.ts"));
			const l = (e, t) => Object(r.a)(e, {
					...c,
					variables: t
				}),
				u = async (e, t) => {
					const n = await Object(r.a)(e, {
						...i,
						variables: t
					});
					return !!Object(s.c)(n) && (n.body.data.subredditInfoById.allowedPostTypes || []).includes(d.Q.Talk)
				}, m = async (e, t) => {
					var n, o;
					const i = await Object(r.a)(e, {
						...a,
						variables: t
					});
					return !!Object(s.c)(i) && (null !== (o = null === (n = i.body.data.profileByName) || void 0 === n ? void 0 : n.allowedPostTypes) && void 0 !== o ? o : []).includes(d.Q.Talk)
				};
			d.k.ServiceError, o.fbt._("Something's wrong with the talk service right now. Check back later.", null, {
				hk: "3XqPJS"
			}), d.k.UserNotAuthorized, o.fbt._("You don't have permission to start talks in this community.", null, {
				hk: "1XY1Ss"
			}), d.k.RoomLimitExceeded, o.fbt._("You can only create three talks at one time. To continue, close a talk you're not using.", null, {
				hk: "3zPx9X"
			}), d.k.ConcurrentRoomLimitExceeded, o.fbt._("Too many talks are happening right now. Try again later.", null, {
				hk: "2LYXJx"
			}), d.k.SubredditRoomLimitExceeded, o.fbt._("This community can only host two talks at a time. Try again after one has ended.", null, {
				hk: "2mGf21"
			}), d.S.ServiceError, o.fbt._("Something's wrong with the talk service right now. Check back later.", null, {
				hk: "3XqPJS"
			}), d.S.UserNotAuthorized, o.fbt._("You don't have permission to start talks in this community.", null, {
				hk: "1XY1Ss"
			})
		},
		"./src/reddit/featureFlags/component.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/featureFlags/index.ts");

			function c(e, t, n) {
				const o = Object(i.c)({
					featureEnabled: t => a.d[e](t)
				});
				return Object(s.b)(o)(e => {
					const {
						featureEnabled: o,
						...s
					} = e, i = s;
					return o ? r.a.createElement(t, i) : void 0 !== n ? r.a.createElement(n, i) : null
				})
			}
		},
		"./src/reddit/helpers/brandSafety/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var o = n("./src/reddit/models/WhitelistStatus/index.ts");
			const r = (e, t) => {
				const n = e.some(e => e.isNSFW),
					r = t.some(e => e.wls === o.b.NO_ADS);
				return !n && !r
			}
		},
		"./src/reddit/helpers/crypto/vaultActionLink.ts": function(e, t, n) {
			"use strict";

			function o(e) {
				return e.match(/^https:\/\/www\.reddit\.com\/vault\/burn/)
			}

			function r(e) {
				const {
					subreddit: t,
					amount: n,
					memo: o,
					cta: r
				} = e;
				return t && n && o && r ? {
					subreddit: t,
					amount: n,
					memo: o,
					cta: r
				} : (console.error("subreddit, amount, and memo query params required for vault action"), null)
			}
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return r
			}))
		},
		"./src/reddit/helpers/dom/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			}));
			var o = n("./node_modules/lodash/map.js"),
				r = n.n(o),
				s = n("./src/lib/FocusTrap/index.ts");
			const i = () => {
					const e = document.getSelection();
					return !!e && (e.rangeCount > 0 && e.getRangeAt(0).toString().length > 0)
				},
				a = () => i() ? (() => {
					const e = document.getSelection();
					if (!e) return [];
					const t = e.getRangeAt(0).cloneContents().childNodes;
					return r()(t, e => e.textContent || "")
				})() : null,
				c = (e, t) => {
					const n = document.createRange();
					return n.selectNode(t), e.compareBoundaryPoints(Range.END_TO_START, n) < 0 && e.compareBoundaryPoints(Range.START_TO_END, n) > 0
				},
				d = e => {
					const t = window.getSelection();
					if (1 !== t.rangeCount) return;
					const n = t.getRangeAt(0);
					if (!c(n, e)) return;
					const {
						startContainer: o,
						startOffset: r,
						endContainer: s,
						endOffset: i
					} = n, a = document.createRange();
					a.selectNode(e);
					let d = !0;
					if (-1 === a.compareBoundaryPoints(Range.START_TO_START, n) && (a.setStart(o, r), d = !1), 1 === a.compareBoundaryPoints(Range.END_TO_END, n) && (a.setEnd(s, i), d = !1), d) return [e];
					const l = document.createElement("div");
					return l.appendChild(a.cloneContents()), [...l.childNodes]
				},
				l = (e, t, n) => {
					let o = e;
					for (; o && (!n || !n(o));) {
						if (o && t(o)) return o;
						o = o.parentElement
					}
				},
				u = e => e && e.parentElement && l(e.parentElement, e => "static" !== window.getComputedStyle(e).getPropertyValue("position")),
				m = e => {
					e.querySelectorAll(s.a).forEach(e => {
						e.tabIndex = -1
					})
				}
		},
		"./src/reddit/helpers/dragDropContext/index.ts": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react-dnd/lib/index.js"),
				r = n("./node_modules/react-dnd-html5-backend/lib/index.js"),
				s = n.n(r);
			t.a = Object(o.DragDropContext)(s.a)
		},
		"./src/reddit/helpers/economics/sortBadges.ts": function(e, t, n) {
			"use strict";

			function o(e, t) {
				if (e.placement && !t.placement) return -1;
				if (t.placement && !e.placement) return 1;
				if (e.position && !t.position) return -1;
				if (t.position && !e.position) return 1;
				let n = 0;
				return e.placement && t.placement && (n = e.placement.localeCompare(t.placement)), 0 === n && e.position && t.position && (n = e.position - t.position), 0 === n && (n = e.title.localeCompare(t.title)), n
			}

			function r(e) {
				return [...e].sort(o)
			}
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return r
			}))
		},
		"./src/reddit/helpers/externalAccount/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			}));
			const o = () => new BroadcastChannel("external_account"),
				r = e => {
					const t = o();
					t.postMessage({
						type: "connected",
						provider: e
					}), t.close()
				}
		},
		"./src/reddit/helpers/genericServerError/index.ts": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts");
			t.a = () => ({
				type: r.K.SERVER_ERROR,
				fields: [{
					field: "",
					msg: o.fbt._("Something went wrong.", null, {
						hk: "RcX5A"
					})
				}]
			})
		},
		"./src/reddit/helpers/governance/tokens.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return c
			}));
			var o = n("./node_modules/bignumber.js/bignumber.js"),
				r = n("./src/lib/prettyPrintNumber/index.ts");

			function s(e, t) {
				const n = new o.BigNumber(e),
					r = new o.BigNumber(t || 1);
				return n.dividedToIntegerBy(r).toString()
			}

			function i(e, t) {
				return Object(r.b)(parseInt(s(e, t), 10))
			}

			function a(e, t) {
				const n = new o.BigNumber(e),
					r = new o.BigNumber(t || 1);
				return n.multipliedBy(r).toFixed(0)
			}

			function c(e) {
				const t = new o.BigNumber(e),
					n = new o.BigNumber("1e18");
				return t.dividedBy(n).toString()
			}
		},
		"./src/reddit/helpers/governanceErrorText/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return i
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/fbt/lib/FbtPublic.js");

			function r(e) {
				return e[0].toUpperCase() + e.slice(1)
			}

			function s(e) {
				return "extra" in e ? "string" == typeof e.extra ? e.extra : Object.keys(e.extra).map(t => e.extra[t]).map(r).join(" ") : o.fbt._("Something went wrong. Please try again later.", null, {
					hk: "16ibYk"
				})
			}

			function i(e) {
				const t = `${e.type} (${e.code})`;
				return "message" in e ? `${t}: ${e.message}` : t
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return s
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			}));
			const o = e => e.subredditInfoById.scheduledPosts.recurringPosts ? {
					recurringPosts: {
						models: p(e.subredditInfoById.scheduledPosts.recurringPosts.edges),
						pageInfo: {
							...e.subredditInfoById.scheduledPosts.recurringPosts.pageInfo
						}
					},
					recurringPostsIds: e.subredditInfoById.scheduledPosts.recurringPosts.edges.map(e => e.node.id)
				} : {},
				r = e => e.subredditInfoById.scheduledPosts.standalonePosts ? {
					standalonePosts: {
						models: u(e.subredditInfoById.scheduledPosts.standalonePosts.edges),
						pageInfo: {
							...e.subredditInfoById.scheduledPosts.standalonePosts.pageInfo
						}
					},
					standalonePostsIds: e.subredditInfoById.scheduledPosts.standalonePosts.edges.map(e => e.node.id)
				} : {},
				s = e => ({
					...e,
					subredditInfoById: {
						id: e.subredditInfoById.id,
						scheduledPosts: {
							...o(e),
							...r(e)
						}
					}
				}),
				i = e => e.subredditInfoById.scheduledPosts && !!e.subredditInfoById.scheduledPosts.recurringPosts && !!e.subredditInfoById.scheduledPosts.recurringPostsIds,
				a = e => e.subredditInfoById.scheduledPosts && !!e.subredditInfoById.scheduledPosts.standalonePosts && !!e.subredditInfoById.scheduledPosts.standalonePostsIds,
				c = e => i(e) && a(e),
				d = e => !i(e) && a(e),
				l = e => i(e) && !a(e),
				u = e => e.map(e => m(e.node)),
				m = e => ({
					id: e.id,
					title: e.title,
					body: e.body,
					postKind: e.postKind,
					collectionId: e.collections.edges.length ? e.collections.edges[0].node.id : void 0,
					discussionType: e.discussionType,
					isContestMode: e.isContestMode,
					isPostAsMetaMod: e.isPostAsMetaMod,
					isSpoiler: e.isSpoiler,
					isNsfw: e.isNsfw,
					isOriginalContent: e.isOriginalContent,
					isSendReplies: e.isSendReplies,
					isSticky: !!e.sticky && "NONE" !== e.sticky,
					mediaAssets: e.mediaAssets,
					subreddit: {
						...e.subreddit
					},
					suggestedCommentSort: e.suggestedCommentSort,
					owner: {
						...e.owner
					},
					poll: e.poll,
					contentType: e.contentType,
					clientTimezone: e.clientTimezone,
					publishAt: e.publishAt.split(".")[0],
					state: e.state,
					flair: e.flair ? {
						...e.flair
					} : void 0,
					sticky: e.sticky,
					isModDistinguished: "MODERATOR" === e.distinguishedAs,
					url: e.url
				}),
				p = e => e.map(e => h(e.node)),
				h = e => ({
					...m(e),
					frequency: e.frequency,
					byMonthDays: e.byMonthDays || [],
					byWeekDays: e.byWeekDays || [],
					interval: e.interval || 1
				}),
				b = e => (e => !!e.frequency && !!e.interval)(e) ? h(e) : m(e)
		},
		"./src/reddit/helpers/isArrayEqual.ts": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/lodash/isEqual.js"),
				r = n.n(o),
				s = n("./node_modules/lodash/xorWith.js"),
				i = n.n(s);
			t.a = (e, t) => {
				const n = i()(e, t, r.a);
				return !(!n || 0 !== n.length)
			}
		},
		"./src/reddit/helpers/isRemoved.ts": function(e, t, n) {
			"use strict";
			t.a = e => !!e.bannedBy && !e.isSpam
		},
		"./src/reddit/helpers/loadThirdPartyScript.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./src/config.ts"),
				r = n("./src/lib/fastdom/index.ts");
			const s = "https://js.stripe.com/v3/",
				i = "https://www.paypalobjects.com/api/checkout.js",
				a = {
					checkout: "https://js.braintreegateway.com/web/3.44.2/js/paypal-checkout.min.js",
					client: "https://js.braintreegateway.com/web/3.44.2/js/client.min.js",
					paypal: `https://www.paypal.com/sdk/js?client-id=${o.a.paypal.braintreeApiKey}` + "&currency=USD&vault=true"
				};

			function c(e, t) {
				return t() ? Promise.resolve() : new Promise((n, o) => r.a.write(() => {
					t() && n();
					const r = document.head;
					let s = r.querySelector(`script[src='${e}']`);

					function i() {
						this.removeEventListener("load", i), this.removeEventListener("error", a), n()
					}

					function a() {
						this.removeEventListener("load", i), this.removeEventListener("error", a), s && r.removeChild(s), o()
					}
					s || ((s = document.createElement("script")).src = e, r.appendChild(s)), s.addEventListener("load", i), s.addEventListener("error", a)
				}))
			}

			function d() {
				return c(s, () => "undefined" != typeof Stripe)
			}

			function l() {
				return c(i, () => "undefined" != typeof paypalCheckout).then(() => {
					"undefined" == typeof paypalCheckout && "undefined" != typeof window && (window.paypalCheckout = paypal), paypal = void 0
				})
			}

			function u() {
				return Promise.all(Object.keys(a).map(e => {
					const t = "__" + e;
					return c(a[e], () => void 0 !== window[t]).then(() => {
						window[t] = !0
					})
				}))
			}
		},
		"./src/reddit/helpers/modTooltipTemplates/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/humanizeUTCDate/index.tsx");
			const s = e => e.approvedBy && "string" == typeof e.approvedBy && e.approvedAtUTC ? o.fbt._("Approved by {username} at {time}", [o.fbt._param("username", e.approvedBy), o.fbt._param("time", Object(r.a)(e.approvedAtUTC))], {
					hk: "3G807D"
				}) : o.fbt._("Approved", null, {
					hk: "3CbKag"
				}),
				i = e => {
					let t = e.bannedBy && "string" == typeof e.bannedBy && e.bannedAtUTC ? o.fbt._("Removed by {username} at {time}", [o.fbt._param("username", e.bannedBy), o.fbt._param("time", Object(r.a)(e.bannedAtUTC))], {
						hk: "2Ey569"
					}) : o.fbt._("Removed", null, {
						hk: "238xK9"
					});
					return e.modReasonBy && e.modRemovalReason && (t = t + "\n" + o.fbt._("Reason by {username}:", [o.fbt._param("username", `u/${e.bannedBy}`)], {
						hk: "3qLdNZ"
					}) + e.modRemovalReason), e.modNote && (t = t + "\n" + o.fbt._("Note:", null, {
						hk: "2LD4vO"
					}) + e.modNote), t
				},
				a = e => o.fbt._({
					"*": "{number} Reports",
					_1: "1 Report"
				}, [o.fbt._plural(e, "number")], {
					hk: "3S0yx6"
				}),
				c = e => e.bannedBy && "string" == typeof e.bannedBy && e.bannedAtUTC ? o.fbt._("Removed as spam by {username} at {time}", [o.fbt._param("username", e.bannedBy), o.fbt._param("time", Object(r.a)(e.bannedAtUTC))], {
					hk: "2uutjk"
				}) : o.fbt._("Removed as spam", null, {
					hk: "1hD9G0"
				})
		},
		"./src/reddit/helpers/ordinal/index.ts": function(e, t, n) {
			"use strict";
			t.a = function(e) {
				const t = ["th", "st", "nd", "rd"],
					n = e % 100;
				return e + (t[(n - 20) % 10] || t[n] || t[0])
			}
		},
		"./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			}));
			var o = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/helpers/isComment.ts"),
				s = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				i = n("./src/reddit/models/Vote/index.ts"),
				a = e => !0 === e ? i.a.upvoted : !1 === e ? i.a.downvoted : i.a.notVoted,
				c = n("./src/reddit/models/Comment/index.ts");
			t.a = e => {
				const t = {
					approvedAtUTC: e.approved_at_utc,
					approvedBy: e.approved_by,
					author: e.author,
					authorId: e.author_fullname,
					bannedAtUTC: e.banned_at_utc,
					bannedBy: e.banned_by,
					body: e.body_html,
					bodyMD: e.body,
					collapsed: e.collapsed,
					collapsedReason: e.collapsed_reason,
					collapsedReasonCode: e.collapsed_reason_code,
					collapsedBecauseCrowdControl: e.collapsed_because_crowd_control,
					commentType: e.comment_type,
					created: e.created_utc,
					deletedBy: l(e),
					distinguishType: e.distinguished || "",
					editedAt: null,
					id: e.name,
					ignoreReports: e.ignore_reports,
					isAdmin: "admin" === e.distinguished,
					isAuthorPremium: !!e.author_premium,
					isApproved: e.approved,
					isDeleted: e.author === o.G,
					isGildable: e.can_gild,
					isLocked: e.locked,
					isMod: "moderator" === e.distinguished,
					isOp: e.is_submitter,
					isRemoved: e.removed,
					isScoreHidden: e.score_hidden,
					isSpam: e.spam,
					isStickied: e.stickied,
					isSaved: e.isSaved,
					isSystem: !1,
					subredditId: e.subreddit_id,
					markdown: e.body,
					media: {
						mediaMetadata: e.media_metadata,
						type: "rtjson",
						richtextContent: d(e.rtjson),
						rteMode: e.rte_mode
					},
					modReports: e.mod_reports,
					modReportsDismissed: e.mod_reports_dismissed,
					numReports: e.num_reports,
					parentId: Object(r.a)(e.parent_id) ? e.parent_id : null,
					permalink: e.permalink,
					postAuthor: e.link_author || null,
					postId: e.link_id,
					postTitle: e.link_title || null,
					sendReplies: e.send_replies,
					score: e.score,
					treatmentTags: e.treatment_tags,
					userReports: e.user_reports,
					userReportsDismissed: e.user_reports_dismissed,
					voteState: a(e.likes)
				};
				return e.all_awardings && (t.allAwardings = Object(s.a)(e.all_awardings)), e.awarders && (t.awarders = e.awarders), e.associated_award && (t.associatedAwardId = e.associated_award.id, t.associatedAward = Object(s.b)(e.associated_award)), t
			};
			const d = e => "string" == typeof e ? JSON.parse(e) : e,
				l = e => e.author !== o.G ? null : e.body === o.H ? c.c.User : e.body === o.Rb ? c.c.Moderator : null
		},
		"./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			}));
			var o = n("./src/lib/constants/index.ts");
			const r = e => {
					for (const t of e) {
						const e = t[0] || "";
						switch (e) {
							case o.K.NO_STRIPE_SUBSCRIPTION:
							case o.K.USER_DOESNT_EXIST:
							case o.K.USER_REQUIRED_ERROR:
							case o.K.VALIDATION_ERROR:
								return e;
							case o.K.NO_USER:
							case o.K.NO_TEXT:
							case o.K.NO_URL:
								return o.K.VALIDATION_ERROR;
							case o.K.CREDIT_CARD_FAILURE:
							case o.K.CREDIT_CARD_FAILURE_GENERIC:
								return o.K.CREDIT_CARD_FAILURE;
							default:
								if (e.startsWith("SUBMIT_VALIDATION")) return o.K.SUBMIT_VALIDATION_ERROR
						}
					}
					return o.K.VALIDATION_ERROR
				},
				s = e => {
					const t = e.body;
					return {
						type: r(t.json.errors),
						fields: t.json.errors.map(e => ({
							field: e[2] || "",
							msg: e[1]
						}))
					}
				},
				i = e => {
					const t = e.body;
					return !e.ok && t && t.json && t.json.errors ? {
						...e,
						error: s(e)
					} : e
				};
			t.a = s
		},
		"./src/reddit/helpers/richTextEditor/index.ts": function(e, t, n) {
			"use strict";
			var o;
			n.d(t, "a", (function() {
					return o
				})),
				function(e) {
					e[e.Post = 0] = "Post", e[e.Comment = 1] = "Comment"
				}(o || (o = {}))
		},
		"./src/reddit/helpers/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return h
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "f", (function() {
				return y
			})), n.d(t, "e", (function() {
				return x
			})), n.d(t, "h", (function() {
				return O
			})), n.d(t, "g", (function() {
				return _
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js");
			n("./node_modules/react/index.js");
			const r = function(e) {
				if (void 0 === e) throw new Error("invariant(...): Second argument must be a string.")
			};

			function s(e, t) {
				for (var n = arguments.length, o = new Array(n > 2 ? n - 2 : 0), s = 2; s < n; s++) o[s - 2] = arguments[s];
				if (r(t), !e) {
					let e;
					if (void 0 === t) e = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
					else {
						let n = 0;
						(e = new Error(t.replace(/%s/g, () => String(o[n++])))).name = "Invariant Violation"
					}
					throw e.framesToPop = 1, e
				}
			}
			const i = {
					AND: "AND",
					NONE: "NONE",
					OR: "OR"
				},
				a = {
					COMMA: "COMMA",
					SEMICOLON: "SEMICOLON"
				};
			var c = function(e, t, n) {
					const r = e.length;
					if (0 === r) return "";
					if (1 === r) return e[0];
					const c = e[r - 1];
					let d = e[0];
					for (let s = 1; s < r - 1; ++s) switch (n) {
						case a.SEMICOLON:
							d = o.fbt._("{previous items}; {following items}", [o.fbt._param("previous items", d), o.fbt._param("following items", e[s])], {
								hk: "4hs4xq"
							});
							break;
						default:
							d = o.fbt._("{previous items}, {following items}", [o.fbt._param("previous items", d), o.fbt._param("following items", e[s])], {
								hk: "2z8RMb"
							})
					}
					return function(e, t, n, r) {
						switch (n) {
							case i.AND:
								return o.fbt._("{list of items} and {last item }", [o.fbt._param("list of items", e), o.fbt._param("last item ", t)], {
									hk: "1ylan1"
								});
							case i.OR:
								return o.fbt._("{list of items} or {last item}", [o.fbt._param("list of items", e), o.fbt._param("last item", t)], {
									hk: "3q8AmB"
								});
							case i.NONE:
								switch (r) {
									case a.SEMICOLON:
										return o.fbt._("{previous item}; {last item}", [o.fbt._param("previous item", e), o.fbt._param("last item", t)], {
											hk: "1h77rJ"
										});
									default:
										return o.fbt._("{list of items}, {last item}", [o.fbt._param("list of items", e), o.fbt._param("last item", t)], {
											hk: "3Q0iaX"
										})
								}
								default:
									s(!1, "Invalid conjunction %s provided to intlList", n)
						}
					}(d, c, t || i.AND, n || a.COMMA)
				},
				d = n("./src/lib/timezone/index.ts"),
				l = n("./src/reddit/helpers/isArrayEqual.ts"),
				u = n("./src/reddit/helpers/ordinal/index.ts"),
				m = n("./src/reddit/models/ScheduledPost/index.ts");
			const p = e => {
					return `${e.toLocaleDateString(void 0,{month:"numeric",day:"numeric"})} @ ${e.toLocaleTimeString(void 0,{hour:"numeric",minute:"numeric"}).replace(" ","").toLowerCase()}`
				},
				h = (e, t) => {
					if (e && t) {
						const n = Object(d.f)(f(e, t)),
							r = p(n);
						return o.fbt._("At {time}", [o.fbt._param("time", r)], {
							hk: "25s5Tg"
						})
					}
					return o.fbt._("Submit post at scheduled event time", null, {
						hk: "lYsoU"
					})
				},
				b = e => e.slice(0, 5),
				f = (e, t) => `${e}T${b(t)}:00`,
				g = e => {
					const [t, n] = e.split("T");
					return [t, b(n)]
				},
				v = e => {
					const [t, n] = g(e);
					if (t && n) {
						const e = Object(d.f)(f(t, n));
						return p(e)
					}
					return ""
				},
				C = e => {
					const t = Object(d.d)(e);
					let n, o = e;
					if (t) {
						n = t.offset, o = `(GMT${Object(d.e)(t.offset)}) ${e.replace("/"," - ").replace(/_/g," ")}`
					}
					return {
						name: e,
						displayText: o,
						offset: n
					}
				},
				y = e => "string" == typeof e,
				E = e => {
					const t = new Date,
						n = e - t.getDay();
					return t.setDate(t.getDate() + n), t.toLocaleDateString(void 0, {
						weekday: "long"
					})
				},
				x = e => {
					const t = (e => {
						const [t, n] = g(e);
						if (t && n) {
							return Object(d.f)(f(t, n)).toLocaleTimeString(void 0, {
								hour: "numeric",
								minute: "numeric"
							})
						}
						return ""
					})(e.publishAt);
					if (e.frequency === m.d.Hourly) return 2 === e.interval ? o.fbt._("Every other hour", null, {
						hk: "64vzK"
					}) : e.interval > 1 ? o.fbt._("Every {hour interval} hours", [o.fbt._param("hour interval", e.interval.toString())], {
						hk: "3x8zaD"
					}) : o.fbt._("Every hour", null, {
						hk: "1VzCs"
					});
					if (e.frequency === m.d.Daily) return 2 === e.interval ? o.fbt._("Every other day at {start time}", [o.fbt._param("start time", t)], {
						hk: "yTynp"
					}) : e.interval > 1 ? o.fbt._("Every {day interval} days at {start time}", [o.fbt._param("day interval", e.interval.toString()), o.fbt._param("start time", t)], {
						hk: "2OoGlG"
					}) : o.fbt._("Every day at {start time}", [o.fbt._param("start time", t)], {
						hk: "1cvwm2"
					});
					if (e.frequency === m.d.Weekly) {
						const n = (e => c(e.map(m.l).sort((e, t) => e - t).map(E), i.AND, a.COMMA))(e.byWeekDays);
						return 2 === e.interval ? o.fbt._("Every other week on {days of week } at {start time}", [o.fbt._param("days of week ", n), o.fbt._param("start time", t)], {
							hk: "43xwaa"
						}) : e.interval > 1 ? o.fbt._("Every {interval} weeks on {days of week} at {start time}", [o.fbt._param("interval", e.interval.toString()), o.fbt._param("days of week", n), o.fbt._param("start time", t)], {
							hk: "2IVbH"
						}) : o.fbt._("Every week on {days of week} at {start time}", [o.fbt._param("days of week", n), o.fbt._param("start time", t)], {
							hk: "2Zl0L"
						})
					}
					const n = (e => c(e.sort((e, t) => e - t).map(u.a), i.AND, a.COMMA))(e.byMonthDays);
					return 2 === e.interval ? o.fbt._({
						"*": "Every other month on the {days of month} days at {start time}",
						_1: "Every other month on the {days of month} day at {start time}"
					}, [o.fbt._param("days of month", n), o.fbt._plural(e.byMonthDays.length), o.fbt._param("start time", t)], {
						hk: "okH9o"
					}) : e.interval > 1 ? o.fbt._({
						"*": "Every {interval} months on the {days of month} days at {start time}",
						_1: "Every {interval} months on the {days of month} day at {start time}"
					}, [o.fbt._param("interval", e.interval.toString()), o.fbt._param("days of month", n), o.fbt._plural(e.byMonthDays.length), o.fbt._param("start time", t)], {
						hk: "KqN3x"
					}) : o.fbt._({
						"*": "Every month on the {days of month} days at {start time}",
						_1: "Every month on the {days of month} day at {start time}"
					}, [o.fbt._param("days of month", n), o.fbt._plural(e.byMonthDays.length), o.fbt._param("start time", t)], {
						hk: "1jBuYc"
					})
				},
				O = e => {
					let t = null;
					e.frequency && (t = e.frequency), (e.byWeekDays.length > 1 || e.byMonthDays.length > 1 || e.interval > 1) && (t = m.b);
					const n = Object(d.f)(e.publishAt),
						o = Object(m.r)(n.getDay()),
						r = n.getDate();
					return 1 === e.byWeekDays.length && e.byWeekDays[0] !== o && (t = m.b), 1 === e.byMonthDays.length && e.byMonthDays[0] !== r && (t = m.b), {
						recurrenceInfo: e.frequency ? {
							frequency: e.frequency,
							byMonthDays: e.byMonthDays,
							byWeekDays: e.byWeekDays,
							interval: e.interval
						} : null,
						frequencyOption: t,
						submitDate: e.publishAt,
						timezoneName: e.clientTimezone
					}
				},
				_ = (e, t) => {
					if (!e && t || e && !t) return !1;
					if (!e && !t) return !0;
					for (const n in e) {
						if (!t) return !1;
						if (e.hasOwnProperty(n)) {
							if (Array.isArray(e[n]) && (!Array.isArray(t[n]) || !Object(l.a)(e[n], t[n]))) return !1;
							if (e[n] !== t[n]) return !1
						}
					}
					return !0
				}
		},
		"./src/reddit/helpers/sessionStorage/index.ts": function(e, t, n) {
			"use strict";
			var o;
			n.d(t, "d", (function() {
					return s
				})), n.d(t, "b", (function() {
					return i
				})), n.d(t, "a", (function() {
					return a
				})), n.d(t, "c", (function() {
					return c
				})),
				function(e) {
					e.COMMENT_BEFORE_SIGNUP_STORAGE = "comment_before_signup_storage"
				}(o || (o = {}));
			const r = e => {
					if (window.sessionStorage) {
						const t = window.sessionStorage.getItem(e);
						if (t) return JSON.parse(t)
					}
					return null
				},
				s = e => {
					((e, t) => {
						window.sessionStorage && window.sessionStorage.setItem(e, JSON.stringify(t))
					})(o.COMMENT_BEFORE_SIGNUP_STORAGE, e)
				},
				i = () => r(o.COMMENT_BEFORE_SIGNUP_STORAGE),
				a = () => (e => {
					window.sessionStorage && window.sessionStorage.removeItem(e)
				})(o.COMMENT_BEFORE_SIGNUP_STORAGE),
				c = () => {
					return !!r(o.COMMENT_BEFORE_SIGNUP_STORAGE)
				}
		},
		"./src/reddit/helpers/showReportIndicator/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => !e.ignoreReports && (e.numReports || 0) > 0
		},
		"./src/reddit/helpers/styles/mixins/loading.m.less": function(e, t, n) {
			e.exports = {
				loadingBackground: "fzTkuBRFT8iIn1XnJX_Yn",
				"m-loading": "_34yMY7-6MNnz3utfjExvIq",
				mLoading: "_34yMY7-6MNnz3utfjExvIq",
				gradientAnimation: "vnt666wwqSK5qL63sBn9P",
				loadingBar: "_3giTODNeZ-Po90u8Ghs4aI",
				loadingContainer: "VRC9QT7CgUxvhK0ceQSrn"
			}
		},
		"./src/reddit/helpers/styles/mixins/loading.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var o = n("./src/lib/classNames/index.ts"),
				r = n("./src/reddit/helpers/styles/mixins/loading.m.less"),
				s = n.n(r);
			const i = e => {
					let {
						isLoading: t
					} = e;
					return Object(o.a)(s.a.loadingBackground, {
						[s.a["m-loading"]]: t
					})
				},
				a = e => Object(o.a)(s.a.loadingBar, i(e))
		},
		"./src/reddit/helpers/styles/postBackgroundColor.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/polished/dist/polished.es.js");
			var o = n("./src/reddit/models/Theme/NewColorSystem/index.ts");

			function r(e) {
				return e.flairStyleTemplate && e.flairStyleTemplate.postBackgroundColor ? e.flairStyleTemplate.postBackgroundColor : Object(o.a)(e).post
			}
		},
		"./src/reddit/helpers/trackers/commentsChat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return l
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "n", (function() {
				return C
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "h", (function() {
				return E
			})), n.d(t, "m", (function() {
				return x
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "j", (function() {
				return _
			}));
			var o = n("./src/lib/makeCommentsPageKey/index.ts"),
				r = n("./src/reddit/constants/tracking.ts"),
				s = n("./src/reddit/selectors/comments.ts"),
				i = n("./src/reddit/selectors/commentSelector.ts"),
				a = n("./src/reddit/selectors/telemetry.ts"),
				c = n("./src/telemetry/models/Event.ts");
			const d = (e, t) => ({
					...Object(a.p)(e),
					subreddit: Object(a.mb)(e),
					profile: Object(a.U)(e),
					post: Object(a.L)(e, t),
					comment: Object(a.i)({
						state: e,
						commentId: t
					})
				}),
				l = (e, t) => {
					const n = Object(i.c)(e, {
							commentId: t
						}),
						r = n && Object(o.a)(n.postId);
					if (!n || !r) return null;
					const c = {
							commentId: t,
							commentsPageKey: r
						},
						d = t && r && Object(s.j)(e, c) || 0;
					return Object(a.A)(e, void 0, {
						depth: d
					})
				},
				u = e => {
					var t;
					return null !== (t = e.split("chat_reaction_")[1]) && void 0 !== t ? t : ""
				},
				m = (e, t) => n => ({
					action: "load",
					noun: e,
					post: Object(a.L)(n, t),
					source: c.b.ChatView,
					subreddit: Object(a.mb)(n)
				}),
				p = (e, t) => n => ({
					...d(n, t),
					source: "live_post",
					action: r.c.CLICK,
					noun: e,
					actionInfo: {
						reason: "live_post",
						pageType: "actions_menu"
					},
					listing: l(n, t)
				}),
				h = e => t => ({
					...d(t, e),
					source: "chat_post",
					action: r.c.VIEW,
					noun: "last_message"
				}),
				b = e => t => ({
					...d(t, e),
					source: "chat_post",
					action: r.c.SUBMIT,
					noun: "reply",
					post: Object(a.L)(t, e),
					comment: Object(a.i)({
						state: t,
						commentId: e
					}),
					actionInfo: Object(a.d)(t, {
						reason: "live_post",
						type: "live_post"
					})
				}),
				f = e => t => ({
					...d(t, e),
					source: "chat_post",
					action: r.c.CLICK,
					noun: "comment",
					actionInfo: Object(a.d)(t, {
						pageType: "user_mention",
						reason: "live_post",
						type: "live_post"
					})
				}),
				g = e => t => ({
					...d(t, e),
					source: "chat_post",
					action: r.c.VIEW,
					noun: "warning",
					post: Object(a.L)(t, e),
					actionInfo: {
						pageType: "spam_rate_countdown"
					}
				}),
				v = e => t => ({
					...d(t, e),
					source: "chat_post",
					action: r.c.CLOSE,
					noun: "warning",
					post: Object(a.L)(t, e),
					actionInfo: {
						pageType: "spam_rate_countdown"
					}
				}),
				C = e => t => ({
					...d(t, e),
					source: "global",
					action: r.c.VIEW,
					noun: "screen",
					actionInfo: {
						reason: "live_post",
						pageType: "given_awards_list"
					},
					listing: l(t, e)
				}),
				y = (e, t, n) => o => ({
					...d(o, t),
					source: c.b.Chat,
					action: r.c.CLICK,
					noun: "reaction",
					actionInfo: {
						pageType: n,
						reason: u(e)
					},
					chat: {
						type: "live_post"
					},
					listing: l(o, t)
				}),
				E = (e, t, n) => o => ({
					...d(o, t),
					source: c.b.Chat,
					action: r.c.DELETE,
					noun: "reaction",
					actionInfo: {
						pageType: n,
						reason: u(e)
					},
					chat: {
						type: "live_post"
					},
					listing: l(o, t)
				}),
				x = () => e => {
					var t;
					return {
						...Object(a.p)(e),
						subreddit: Object(a.mb)(e),
						profile: Object(a.U)(e),
						actionInfo: {
							...Object(a.d)(e),
							paneName: (null === window || void 0 === window ? void 0 : window.parent) !== window ? "chat_tab" : (null === (t = null == e ? void 0 : e.platform.currentPage) || void 0 === t ? void 0 : t.locationState.clickSource) || ""
						},
						source: "chat_post",
						action: r.c.VIEW,
						noun: "hint"
					}
				},
				O = e => t => {
					const n = d(t, e);
					return n.comment.type = "thread_chat", {
						...n,
						source: "live_post",
						action: r.c.CLICK,
						noun: "chat_thread",
						actionInfo: Object(a.d)(t, {
							pageType: "actions_menu"
						})
					}
				},
				_ = e => t => {
					const n = d(t, e);
					return n.comment.type = "thread_chat", {
						...n,
						source: "live_post",
						action: r.c.SUBMIT,
						noun: "comment",
						actionInfo: Object(a.d)(t)
					}
				}
		},
		"./src/reddit/helpers/trackers/commentsPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return p
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "k", (function() {
				return E
			})), n.d(t, "j", (function() {
				return x
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "l", (function() {
				return _
			}));
			var o = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/constants/tracking.ts"),
				s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				i = n("./src/reddit/models/PostDraft/index.ts"),
				a = n("./src/reddit/selectors/comments.ts"),
				c = n("./src/reddit/selectors/platform.ts"),
				d = n("./src/reddit/selectors/telemetry.ts"),
				l = n("./src/telemetry/index.ts"),
				u = n("./src/reddit/constants/richTextJson.ts");
			const m = e => {
					const t = Object(c.o)(e);
					return {
						source: "comment_composer",
						action: r.c.CLICK,
						...Object(d.p)(e),
						screen: Object(d.db)(e),
						subreddit: Object(d.mb)(e),
						post: t ? Object(d.L)(e, t) : null,
						profile: Object(d.U)(e),
						correlationId: Object(s.c)(s.a.CommentComposer)
					}
				},
				p = async (e, t, o, r, s) => {
					const i = {
							commentId: s,
							commentsPageKey: o
						},
						c = s && Object(a.j)(e, i) || 0,
						{
							getFlairData: u
						} = await n.e("getFlairData").then(n.bind(null, "./src/reddit/helpers/trackers/features/getFlairData.ts")),
						p = r ? "image" : void 0;
					return Object(l.a)({
						noun: "comment",
						...m(e),
						comment: s ? Object(d.i)({
							state: e,
							commentId: s,
							contentType: p
						}) : null,
						listing: Object(d.A)(e, void 0, {
							depth: c
						}),
						commentComposer: {
							editorMode: t
						},
						userFlair: u(e),
						media: {
							mimetype: null == r ? void 0 : r.mimetype,
							size: null == r ? void 0 : r.size
						}
					})
				}, h = e => {
					let {
						state: t,
						bodyText: n,
						postId: r,
						error: s,
						parentId: i,
						uploadMetadata: a
					} = e;
					const c = m(t),
						d = s.type === o.Qb ? "karma_rate_limit" : s.fields && s.fields.length > 0 ? s.fields[0].msg : void 0,
						p = a ? "image" : function(e) {
							return e.includes(`"id":"${u.d}`)
						}("string" == typeof n ? n : JSON.stringify(n)) ? "giphy" : void 0;
					return Object(l.a)({
						...c,
						source: s.type === o.Qb ? "backend" : "comment_composer",
						actionInfo: {
							...c.actionInfo,
							reason: d
						},
						action: "error",
						noun: "comment",
						comment: {
							bodyText: n,
							parentId: i,
							postId: r,
							contentType: p
						},
						media: {
							mimetype: null == a ? void 0 : a.mimetype,
							size: null == a ? void 0 : a.size
						}
					})
				}, b = e => Object(l.a)({
					noun: "cancel",
					...m(e)
				}), f = (e, t) => {
					t === i.c.replyToPost && Object(l.a)({
						noun: "input",
						...m(e)
					})
				}, g = (e, t) => Object(l.a)({
					source: "comment",
					noun: "delete",
					action: "click",
					...Object(d.p)(t),
					screen: Object(d.db)(t),
					subreddit: Object(d.mb)(t),
					post: Object(d.L)(t, e)
				}), v = e => Object(l.a)({
					noun: "edit",
					...m(e)
				}), C = e => Object(l.a)({
					noun: "save_edit",
					...m(e)
				}), y = (e, t) => n => {
					const o = "image_upload" === e || "video_upload" === e;
					return {
						...m(n),
						noun: o ? e : "text_option",
						commentComposer: {
							textType: e,
							finalStatus: t ? "on" : "off"
						}
					}
				}, E = () => e => ({
					...m(e),
					action: "open",
					noun: "gif_tooltip"
				}), x = e => t => ({
					...m(t),
					action: "change",
					noun: "gif_tooltip_search",
					search: {
						query: e
					}
				}), O = () => e => ({
					...m(e),
					action: "select",
					noun: "gif_tooltip_result"
				}), _ = () => e => ({
					...m(e),
					source: "comment_composer",
					action: "open",
					noun: "images_tooltip"
				})
		},
		"./src/reddit/helpers/trackers/communityAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "i", (function() {
				return g
			}));
			var o = n("./src/reddit/models/Gold/Award.ts"),
				r = n("./src/reddit/selectors/telemetry.ts"),
				s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				i = n("./src/reddit/helpers/trackers/gild.ts");
			const a = e => ({
					...r.p(e),
					screen: r.db(e),
					subreddit: r.mb(e),
					userSubreddit: r.vb(e)
				}),
				c = e => ({
					awardId: e.id,
					awardName: e.name,
					isModAward: e.awardType === o.e.Moderator,
					isTemporatyAward: !!e.endsAt,
					numberCoins: e.coinPrice,
					numberMonths: Math.floor((e.daysOfPremium || 0) / 30),
					numberCoinsToRecipient: e.coinReward || 0,
					numberCoinsToCommunity: e.subredditCoinReward || 0,
					type: Object(i.getAwardTypeFromAward)(e)
				}),
				d = () => e => ({
					...a(e),
					source: "awards",
					action: "click",
					correlationId: Object(s.c)(s.a.AwardCreationFlow),
					noun: "create"
				}),
				l = e => t => ({
					...a(t),
					source: "awards",
					action: "click",
					correlationId: Object(s.c)(s.a.AwardDeletionFlow),
					noun: "delete",
					goldPurchase: e ? c(e) : null,
					media: e ? {
						url: e.icon.url
					} : null
				}),
				u = (e, t, n) => o => ({
					...a(o),
					source: "create_award",
					action: e,
					correlationId: Object(s.c)(s.a.AwardCreationFlow),
					noun: t,
					goldPurchase: n
				}),
				m = (e, t, n, o) => r => ({
					...a(r),
					source: "create_award",
					action: "upload",
					correlationId: Object(s.c)(s.a.AwardCreationFlow),
					noun: "image",
					actionInfo: o ? {
						reason: o
					} : {
						success: !0
					},
					media: t ? {
						fileName: t.file.name,
						height: t.height,
						id: t.id,
						mimetype: t.file.type,
						size: t.file.size,
						type: "image",
						uploadDuration: n,
						url: e,
						width: t.width
					} : null
				}),
				p = (e, t, n) => o => ({
					...a(o),
					source: "create_award",
					action: "click",
					correlationId: Object(s.c)(s.a.AwardCreationFlow),
					noun: "create",
					media: t && e ? {
						fileName: t.file.name,
						height: t.height,
						id: t.id,
						mimetype: t.file.type,
						size: t.file.size,
						type: "image",
						url: e,
						width: t.width
					} : null,
					goldPurchase: n ? c(n) : null
				}),
				h = (e, t, n) => o => ({
					...a(o),
					source: "create_award",
					action: e,
					correlationId: Object(s.c)(s.a.AwardCreationFlow),
					noun: t,
					goldPurchase: n ? c(n) : null
				}),
				b = (e, t, n) => o => ({
					...a(o),
					source: "awards",
					action: "click",
					noun: n,
					goldPurchase: c(e),
					profile: r.V(o, t),
					subreddit: r.nb(o, t)
				}),
				f = (e, t) => b(e, t, "disable_in_community"),
				g = (e, t) => b(e, t, "enable_in_community")
		},
		"./src/reddit/helpers/trackers/gild.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "getAwardTypeFromAward", (function() {
				return u
			})), n.d(t, "clickGildEvent", (function() {
				return h
			})), n.d(t, "clickAddAward", (function() {
				return b
			})), n.d(t, "clickHideAward", (function() {
				return f
			})), n.d(t, "clickConfirmHideAward", (function() {
				return g
			})), n.d(t, "clickCancelHideAward", (function() {
				return v
			})), n.d(t, "clickAwardReportFlow", (function() {
				return y
			})), n.d(t, "clickCancelAwardReportFlow", (function() {
				return E
			})), n.d(t, "clickFlagAwardUsage", (function() {
				return x
			})), n.d(t, "clickCancelFlagAwardUsage", (function() {
				return O
			})), n.d(t, "clickConfirmFlagAwardUsage", (function() {
				return _
			})), n.d(t, "clickReportAward", (function() {
				return k
			})), n.d(t, "clickCancelReportAward", (function() {
				return j
			})), n.d(t, "clickConfirmReportAward", (function() {
				return S
			})), n.d(t, "viewGildModalEvent", (function() {
				return T
			})), n.d(t, "clickSelectAwardEvent", (function() {
				return w
			})), n.d(t, "triggerAnonymousEvent", (function() {
				return I
			})), n.d(t, "clickMessageInputEvent", (function() {
				return P
			})), n.d(t, "typeMessageInputEvent", (function() {
				return N
			})), n.d(t, "clickLearnMoreLinkEvent", (function() {
				return R
			})), n.d(t, "clickQuestionMarkEvent", (function() {
				return M
			})), n.d(t, "clickConfirmAwardEvent", (function() {
				return D
			})), n.d(t, "clickGetPremiumEvent", (function() {
				return L
			})), n.d(t, "clickAddCoinsButtonEvent", (function() {
				return A
			})), n.d(t, "clickNextButtonEvent", (function() {
				return F
			})), n.d(t, "clickCloseGildModalEvent", (function() {
				return B
			})), n.d(t, "viewKarmaSuccessEvent", (function() {
				return U
			})), n.d(t, "clickFilterEvent", (function() {
				return K
			})), n.d(t, "clickNextFiltersEvent", (function() {
				return W
			})), n.d(t, "clickPreviousFiltersEvent", (function() {
				return G
			}));
			var o = n("./src/reddit/helpers/trackers/commentsChat.ts"),
				r = n("./src/reddit/models/Gold/Award.ts"),
				s = n("./src/reddit/selectors/commentSelector.ts"),
				i = n("./src/reddit/selectors/telemetry.ts"),
				a = n("./src/telemetry/models/GoldPurchase.ts"),
				c = n("./src/reddit/helpers/correlationIdTracker.ts"),
				d = n("./src/reddit/helpers/isComment.ts"),
				l = n("./src/reddit/selectors/gild.ts");
			const u = e => e.awardType === r.e.Global && e.awardSubType === r.d.Appreciation ? a.GoldPurchaseType.GidAppreciation : e.awardType === r.e.Global && e.awardSubType === r.d.Premium ? a.GoldPurchaseType.GidPremium : e.awardSubType === r.d.Group ? a.GoldPurchaseType.GidGroup : e.awardType === r.e.Community ? a.GoldPurchaseType.GidCommunity : e.awardType === r.e.Moderator ? a.GoldPurchaseType.GidMod : e.awardType === r.e.Global && e.awardSubType === r.d.Global ? a.GoldPurchaseType.GidGlobal : a.GoldPurchaseType.GidUnknown,
				m = (e, t) => ({
					awardId: e.id,
					awardName: e.name,
					isTemporaryAward: !!e.endsAt,
					numberCoinsToRecipient: e.coinReward,
					type: u(e),
					...t
				}),
				p = (e, t, n) => {
					const r = t && Object(s.g)(e, {
						commentId: t
					});
					return {
						...i.p(e),
						actionInfo: i.d(e, {
							reason: r ? "live_post" : void 0,
							...n
						}),
						comment: t ? i.i({
							state: e,
							commentId: t
						}) : void 0,
						correlationId: Object(l.b)(e) || Object(c.d)(c.a.GildingFlow, !1),
						post: t ? i.L(e, t) : void 0,
						screen: i.db(e),
						subreddit: i.mb(e),
						userSubreddit: i.vb(e),
						listing: t ? Object(o.k)(e, t) : void 0
					}
				},
				h = (e, t) => n => ({
					...p(n, e, t),
					source: Object(d.a)(e) ? "comment" : "post",
					action: "click",
					noun: "give_gold",
					feed: i.s(n)
				}),
				b = e => t => ({
					...p(t, e),
					source: Object(d.a)(e) ? "comment" : "post",
					action: "click",
					noun: "add_award",
					feed: i.s(t)
				}),
				f = (e, t) => n => ({
					...p(n, t),
					source: Object(d.a)(t) ? "comment" : "post",
					action: "click",
					noun: "hide_award",
					goldPurchase: m(e)
				}),
				g = (e, t) => n => ({
					...p(n, t),
					source: Object(d.a)(t) ? "comment" : "post",
					action: "click",
					noun: "confirm_hide_award",
					goldPurchase: m(e)
				}),
				v = (e, t) => n => ({
					...p(n, t),
					source: Object(d.a)(t) ? "comment" : "post",
					action: "click",
					noun: "cancel_hide_award",
					goldPurchase: m(e)
				}),
				C = e => (t, n) => o => ({
					...p(o, n),
					source: Object(d.a)(n) ? "comment" : "post",
					action: "click",
					noun: e,
					goldPurchase: m(t)
				}),
				y = C("award_hovercard_report"),
				E = C("cancel_award_hovercard_report"),
				x = C("flag_award"),
				O = C("cancel_flag_award"),
				_ = C("confirm_flag_award"),
				k = C("report_community_award"),
				j = C("cancel_report_community_award"),
				S = C("confirm_report_community_award"),
				T = (e, t, n) => o => ({
					...p(o, n),
					source: "give_gold",
					action: "view",
					noun: "page",
					goldPurchase: {
						defaultOption: e,
						defaultAnonymous: t
					}
				}),
				w = (e, t, n) => o => ({
					...p(o, t),
					source: "give_gold",
					action: "click",
					noun: "award",
					goldPurchase: m(e, n)
				}),
				I = (e, t) => n => ({
					...p(n, t),
					source: "give_gold",
					action: e,
					noun: "anonymous"
				}),
				P = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "message_input"
				}),
				N = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "type",
					noun: "message_input"
				}),
				R = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "learn_more"
				}),
				M = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "question"
				}),
				D = (e, t) => n => ({
					...p(n, e),
					source: "give_gold",
					action: "click",
					noun: "confirm",
					goldPurchase: {
						contentType: Object(d.a)(e) ? "comment" : "post",
						...m(t)
					}
				}),
				L = (e, t) => n => ({
					...p(n, e),
					source: "give_gold",
					action: "click",
					noun: "get_premium",
					goldPurchase: {
						contentType: Object(d.a)(e) ? "comment" : "post",
						...m(t)
					}
				}),
				A = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "add_coins"
				}),
				F = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "next"
				}),
				B = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "close"
				}),
				U = e => {
					let {
						award: t,
						awardeeKarmaEarned: n,
						awarderKarmaEarned: o,
						numberCoins: r,
						thingId: s
					} = e;
					return e => ({
						...p(e, s),
						source: "give_gold",
						action: "view",
						noun: "karma_success",
						goldPurchase: {
							contentType: Object(d.a)(s) ? "comment" : "post",
							awardeeKarmaEarned: n,
							awarderKarmaEarned: o,
							numberCoins: r,
							...m(t)
						}
					})
				},
				K = e => t => ({
					...p(t),
					source: "give_gold",
					action: "click",
					noun: "filter",
					goldPurchase: {
						filterId: e.tag,
						filterName: e.content.markdown
					}
				}),
				W = () => e => ({
					...p(e),
					source: "give_gold",
					action: "click",
					noun: "next_filters"
				}),
				G = () => e => ({
					...p(e),
					source: "give_gold",
					action: "click",
					noun: "previous_filters"
				})
		},
		"./src/reddit/helpers/trackers/goldPayment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return b
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "e", (function() {
				return C
			})), n.d(t, "c", (function() {
				return y
			})), n.d(t, "a", (function() {
				return E
			})), n.d(t, "g", (function() {
				return x
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "j", (function() {
				return _
			}));
			var o = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/models/Gold/ProductOffer.ts"),
				s = n("./src/reddit/selectors/gold/giveAwards.ts"),
				i = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				a = n("./src/reddit/selectors/goldPurchaseModals.ts"),
				c = n("./src/reddit/selectors/telemetry.ts"),
				d = n("./src/telemetry/models/GoldPurchase.ts"),
				l = n("./src/telemetry/models/Payment.ts"),
				u = n("./src/reddit/helpers/trackers/gild.ts"),
				m = n("./src/reddit/helpers/correlationIdTracker.ts"),
				p = n("./src/reddit/helpers/isComment.ts"),
				h = n("./src/reddit/helpers/trackers/communityAwards.ts");
			const b = (e, t) => {
					const {
						thingId: n,
						packageId: l
					} = t, b = !!n, f = s.b(e), g = f ? Object(u.getAwardTypeFromAward)(f) : null, v = b ? g : a.p(e) ? d.GoldPurchaseType.Premium : d.GoldPurchaseType.Coins, C = n ? Object(p.a)(n) ? "comment" : "post" : void 0, y = l || a.u(e), E = [...Object(i.d)(e), ...Object(i.e)(e)].filter(e => e.mobileId === y)[0], x = t.offerContext || (f && 0 === f.coinPrice ? r.a.StorefrontFreeAward : Object(r.d)(E, b)), O = E ? Math.round(1e4 * (E.baselinePennies - E.pennies) / E.baselinePennies) / 100 : 0, _ = E ? Math.round(1e4 * (E.coins - E.baselineCoins) / E.coins) / 100 : 0, k = E ? E.baselinePennies !== E.pennies ? `${O}_percent_price` : E.baselineCoins !== E.coins ? `${_}_percent_bonus` : void 0 : void 0, j = v === d.GoldPurchaseType.Premium ? o.Eb : E ? E.pennies : void 0;
					return {
						...c.p(e),
						comment: n ? c.i({
							state: e,
							commentId: n
						}) : null,
						correlationId: a.s(e) || Object(m.d)(m.a.GoldPayment, !1),
						post: n ? c.L(e, n) : null,
						screen: c.db(e),
						subreddit: n ? c.mb(e) : null,
						goldPurchase: {
							...f ? Object(h.a)(f) : null,
							type: v,
							gildedContent: b,
							contentType: C,
							numberCoins: E ? E.coins : void 0,
							offerContext: x,
							offerType: k
						},
						payment: {
							currency: "USD",
							amountInSmallestDenom: j
						},
						purchase: {
							priceMicros: j
						}
					}
				},
				f = (e, t, n) => o => ({
					...b(o, {
						packageId: t,
						thingId: e,
						offerContext: n
					}),
					source: "gold_payment",
					action: "click",
					noun: "close"
				}),
				g = e => t => ({
					...b(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "paypal"
				}),
				v = e => t => ({
					...b(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "continue_paypal"
				}),
				C = e => t => ({
					...b(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "credit_card"
				}),
				y = e => t => ({
					...b(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "complete_credit_card"
				}),
				E = (e, t) => n => ({
					...b(n, {
						packageId: e,
						offerContext: t
					}),
					source: "gold_payment",
					action: "click",
					noun: "confirm"
				}),
				x = e => t => ({
					...b(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "display",
					noun: "error"
				}),
				O = (e, t, n) => o => {
					const r = b(o, {
						packageId: t,
						thingId: e,
						offerContext: n
					});
					return {
						...r,
						source: "gold_payment",
						action: "view",
						noun: "page",
						payment: {
							...r.payment,
							defaultOption: l.PaymentMethod.Paypal
						},
						goldPurchase: {
							...r.goldPurchase,
							source: e ? d.GiveGold : a.p(o) ? d.PremiumMarketing : d.CoinsMarketing
						}
					}
				},
				_ = e => t => {
					var n;
					const o = b(t, {
						thingId: e
					});
					return {
						...o,
						source: "gold_payment",
						action: "view",
						noun: "success",
						payment: {
							...o.payment,
							method: (null === (n = t.platform.currentPage) || void 0 === n ? void 0 : n.queryParams.thanks) ? l.PaymentMethod.Paypal : l.PaymentMethod.CreditCard
						}
					}
				}
		},
		"./src/reddit/helpers/trackers/modTools.ts": function(e, t, n) {
			"use strict";
			n.d(t, "m", (function() {
				return i
			})), n.d(t, "n", (function() {
				return a
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "q", (function() {
				return b
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "k", (function() {
				return g
			})), n.d(t, "r", (function() {
				return v
			})), n.d(t, "i", (function() {
				return C
			})), n.d(t, "j", (function() {
				return y
			})), n.d(t, "a", (function() {
				return E
			})), n.d(t, "o", (function() {
				return x
			})), n.d(t, "p", (function() {
				return O
			}));
			var o = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const s = e => ({
					screen: Object(r.db)(e),
					profile: Object(r.U)(e),
					subreddit: Object(r.mb)(e),
					userSubreddit: Object(r.vb)(e)
				}),
				i = e => t => ({
					source: "nav",
					action: "click",
					noun: e ? "mod_mode_on" : "mod_mode_off",
					...s(t)
				}),
				a = (e, t) => n => ({
					source: "post_mod_action_menu",
					action: "click",
					noun: e,
					post: Object(r.L)(n, t),
					...s(n)
				}),
				c = (e, t) => n => ({
					source: "comment",
					action: "click",
					noun: e,
					post: Object(r.L)(n, t),
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					media: {
						mimetype: Object(r.k)(n, t)
					},
					...s(n)
				}),
				d = (e, t) => n => ({
					source: "comment",
					action: o.c.CLICK,
					noun: e,
					post: Object(r.L)(n, t),
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					actionInfo: {
						pageType: "chat_live_post"
					},
					...s(n)
				}),
				l = (e, t) => n => ({
					source: "comment",
					action: o.c.UNDO,
					noun: e,
					post: Object(r.L)(n, t),
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					...s(n)
				}),
				u = (e, t) => n => ({
					source: "comment_overflow_menu",
					action: "click",
					noun: e,
					post: Object(r.L)(n, t),
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					...s(n)
				}),
				m = (e, t) => n => ({
					source: "mod_distinguish_menu",
					action: "click",
					noun: e,
					post: Object(r.L)(n, t),
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					...s(n)
				}),
				p = (e, t) => n => ({
					source: "comment_mod_action_menu",
					action: "click",
					noun: e,
					post: Object(r.L)(n, t),
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					...s(n)
				}),
				h = (e, t) => n => ({
					source: "comment_report_menu",
					action: "click",
					noun: e,
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					post: Object(r.L)(n, t),
					...s(n)
				}),
				b = (e, t) => n => ({
					source: "post_report_menu",
					action: "click",
					noun: e,
					post: Object(r.L)(n, t),
					...s(n)
				}),
				f = (e, t) => n => ({
					source: "post",
					action: "click",
					noun: e,
					post: Object(r.L)(n, t),
					subreddit: Object(r.pb)(n, t)
				}),
				g = (e, t) => n => ({
					source: "comment",
					action: "click",
					noun: e,
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					post: Object(r.L)(n, t),
					subreddit: Object(r.pb)(n, t)
				}),
				v = (e, t, n, o) => s => ({
					source: e ? "comment" : "post",
					action: "click",
					noun: t ? "unsnooze_reporter" : "snooze_reporter",
					post: Object(r.L)(s, n),
					subreddit: Object(r.pb)(s, n),
					actionInfo: {
						reason: o
					},
					...e && {
						comment: Object(r.i)({
							state: s,
							commentId: n
						})
					}
				}),
				C = () => e => ({
					...s(e),
					source: "modqueue",
					noun: "content_type_live_post",
					action: "view",
					actionInfo: {
						pageType: "chat_live_post"
					}
				}),
				y = (e, t, n) => o => ({
					...s(o),
					source: "moderator",
					noun: "action",
					action: "click",
					actionInfo: {
						pageType: "mod_queue",
						paneName: n,
						reason: t
					},
					comment: Object(r.i)({
						state: o,
						commentId: e
					}) || void 0,
					post: Object(r.L)(o, e)
				}),
				E = (e, t) => n => ({
					...s(n),
					source: "moderator",
					noun: "add_note_mod_queue",
					action: "click",
					comment: Object(r.i)({
						state: n,
						commentId: e
					}) || void 0,
					post: Object(r.L)(n, e),
					modAction: {
						targetUserId: t
					}
				}),
				x = (e, t, n, o) => i => ({
					source: "post_mod_action_menu",
					action: "click",
					post: Object(r.L)(i, t),
					noun: e,
					setting: {
						value: n,
						oldValue: o
					},
					...s(i)
				}),
				O = (e, t, n, o) => i => ({
					source: "post_mod_action_menu",
					action: "save",
					post: Object(r.L)(i, t),
					noun: e,
					setting: {
						value: n,
						oldValue: o
					},
					...s(i)
				})
		},
		"./src/reddit/helpers/trackers/navigation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "a", (function() {
				return d
			}));
			n("./src/reddit/constants/categories.tsx");
			var o = n("./src/reddit/selectors/telemetry.ts");
			const r = e => ({
					screen: o.db(e),
					profile: o.U(e),
					subreddit: o.mb(e)
				}),
				s = e => t => ({
					action: "click",
					source: "nav",
					noun: e,
					...r(t)
				}),
				i = (e, t) => n => ({
					action: "click",
					source: "nav",
					noun: e,
					...r(n),
					topicMetadata: {
						displayName: t
					}
				}),
				a = e => t => ({
					...r(t),
					source: "sort_switch",
					action: "click",
					noun: e
				}),
				c = e => t => ({
					...r(t),
					source: "time_sort_switch",
					action: "click",
					noun: e
				}),
				d = e => t => ({
					...r(t),
					source: "nav",
					action: "click",
					noun: `lang_${e}`
				})
		},
		"./src/reddit/helpers/trackers/postCollection.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "n", (function() {
				return b
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "p", (function() {
				return C
			})), n.d(t, "c", (function() {
				return y
			})), n.d(t, "j", (function() {
				return E
			})), n.d(t, "q", (function() {
				return x
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "l", (function() {
				return _
			})), n.d(t, "i", (function() {
				return k
			})), n.d(t, "d", (function() {
				return j
			}));
			var o, r, s = n("./src/reddit/constants/tracking.ts"),
				i = n("./src/reddit/helpers/trackers/postEvent.ts"),
				a = n("./src/reddit/selectors/platform.ts"),
				c = n("./src/reddit/selectors/telemetry.ts");
			! function(e) {
				e.collection = "collection", e.collectionComposer = "collection_composer", e.postComposer = "post_composer", e.postOverflowMenu = "post_overflow_menu"
			}(o || (o = {})),
			function(e) {
				e.post = "post", e.follow = "follow", e.unfollow = "unfollow", e.screen = "screen", e.eventEducation = "event_education", e.eventEducationGotIt = "event_education_got_it", e.collectionEducation = "collection_education", e.collectionEducationGotIt = "collection_education_got_it", e.collectionCancel = "cancel", e.collectionCreate = "collection_create", e.collectionSelect = "collection_select", e.collectionDelete = "collection_delete", e.collectionEdit = "collection_edit", e.collectionAddPost = "collection_add_post", e.collectionRemovePost = "remove_post_from_collection", e.startEvent = "start_event"
			}(r || (r = {}));
			const d = e => t => ({
					source: o.collection,
					noun: r.post,
					...m(t, e)
				}),
				l = e => {
					let {
						postId: t,
						isFollowed: n
					} = e;
					return e => ({
						source: o.collection,
						noun: n ? r.unfollow : r.follow,
						...m(e, t)
					})
				},
				u = e => {
					let {
						postId: t,
						isFollowed: n
					} = e;
					return e => ({
						source: i.a.postEvent,
						noun: n ? r.unfollow : r.follow,
						...m(e, t)
					})
				},
				m = (e, t) => {
					const n = {
						...c.p(e),
						action: s.c.CLICK,
						subreddit: c.mb(e)
					};
					return void 0 === t ? n : {
						...n,
						post: c.L(e, t),
						postCollection: c.N(e, {
							postId: t
						}),
						postEvent: c.O(e, {
							postId: t
						})
					}
				},
				p = e => ({
					...g(e),
					action: s.c.VIEW,
					noun: r.collectionEducation
				}),
				h = e => ({
					...g(e),
					action: s.c.CLICK,
					noun: r.collectionEducationGotIt
				}),
				b = e => ({
					...g(e),
					action: s.c.VIEW,
					noun: r.eventEducation
				}),
				f = e => ({
					...g(e),
					action: s.c.CLICK,
					noun: r.eventEducationGotIt
				}),
				g = e => ({
					...c.p(e),
					subreddit: c.mb(e),
					source: o.postComposer
				}),
				v = (e, t) => n => ({
					...m(n, e),
					source: t || o.postOverflowMenu,
					noun: r.collectionAddPost
				}),
				C = e => t => ({
					...m(t, e),
					source: o.collectionComposer,
					noun: r.collectionRemovePost
				}),
				y = () => e => ({
					...m(e),
					source: o.collectionComposer,
					noun: r.collectionCancel
				}),
				E = () => e => {
					const t = Object(a.o)(e) || void 0;
					return {
						...m(e, t),
						source: o.collectionComposer,
						noun: r.collectionCreate
					}
				},
				x = () => e => ({
					...m(e),
					source: o.collectionComposer,
					noun: r.collectionSelect
				}),
				O = e => t => ({
					...c.p(t),
					subreddit: c.mb(t),
					source: o.collectionComposer,
					action: s.c.CLICK,
					noun: r.collectionDelete,
					postCollection: c.M(t, {
						collectionId: e
					})
				}),
				_ = e => t => ({
					...m(t),
					source: o.collectionComposer,
					noun: r.collectionEdit,
					postCollection: c.M(t, {
						collectionId: e
					})
				}),
				k = e => t => ({
					...m(t, e),
					source: o.collectionComposer,
					noun: r.startEvent
				}),
				j = () => e => {
					const t = Object(a.o)(e) || void 0;
					return {
						...m(e, t),
						source: o.collectionComposer,
						action: s.c.VIEW,
						noun: r.screen
					}
				}
		},
		"./src/reddit/helpers/trackers/postEvent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "d", (function() {
				return C
			}));
			var o, r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/eventTools/index.ts"),
				i = n("./src/lib/timezone/index.ts"),
				a = n("./src/reddit/constants/tracking.ts"),
				c = n("./src/reddit/models/PostCreationForm/index.ts"),
				d = n("./src/reddit/selectors/platform.ts"),
				l = n("./src/reddit/selectors/postCreations.ts"),
				u = n("./src/reddit/selectors/telemetry.ts"),
				m = n("./src/telemetry/index.ts");
			! function(e) {
				e.postEvent = "post_event", e.postComposer = "post_composer", e.eventComposer = "event_composer"
			}(o || (o = {}));
			const p = e => u.d(e, {
					pageType: "event_submit"
				}),
				h = e => {
					Object(m.a)({
						...u.p(e),
						source: o.postComposer,
						action: a.c.CLICK,
						noun: "event_create",
						subreddit: u.mb(e)
					})
				},
				b = e => {
					Object(m.a)({
						...u.p(e),
						source: o.postComposer,
						action: a.c.CLICK,
						noun: "event_edit",
						subreddit: u.mb(e),
						postEvent: y(e),
						postComposer: E(e)
					})
				},
				f = () => e => ({
					source: o.eventComposer,
					action: a.c.VIEW,
					noun: a.b.SCREEN,
					actionInfo: p(e),
					postEvent: y(e)
				}),
				g = e => t => ({
					..._(t, Object(d.o)(t)),
					source: o.postComposer,
					noun: "apply",
					postComposer: x(e)
				}),
				v = () => e => ({
					..._(e, Object(d.o)(e)),
					noun: "cancel",
					actionInfo: p(e)
				}),
				C = e => t => ({
					..._(t, Object(d.o)(t)),
					noun: "delete",
					actionInfo: p(t),
					postComposer: E(t),
					postEvent: O(e)
				}),
				y = e => {
					const t = Object(l.p)(e);
					return t && O(t)
				},
				E = e => x(Object(l.p)(e)),
				x = e => {
					return {
						postScheduled: !!e,
						submitScheduledTime: e && e.submitTime === c.j.AtEventTime ? Object(i.f)(e.startDate).getTime() / r.Xb : void 0
					}
				},
				O = e => {
					const t = Object(i.f)(e.startDate).getTime() / r.Xb,
						n = Object(i.f)(e.endDate).getTime() / r.Xb;
					return {
						eventStartTimestamp: t,
						eventEndTimestamp: n,
						eventState: Object(s.e)(t, n)
					}
				},
				_ = (e, t) => {
					const n = {
						source: o.eventComposer,
						action: a.c.CLICK,
						subreddit: u.mb(e)
					};
					return t ? {
						...n,
						post: u.L(e, t),
						postEvent: u.O(e, {
							postId: t
						}),
						postCollection: u.N(e, {
							postId: t
						})
					} : n
				}
		},
		"./src/reddit/helpers/trackers/postFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			}));
			var o = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/helpers/search/SearchTelemetrySource.ts"),
				s = n("./src/reddit/selectors/telemetry.ts"),
				i = n("./src/reddit/helpers/flair.ts"),
				a = n("./src/reddit/helpers/search/searchImpressionId.ts");
			const c = (e, t) => n => {
					const i = `flair_name:'${t.postFlairName}'`;
					return {
						source: "post",
						action: "click",
						noun: "post_flair",
						...s.p(n),
						actionInfo: s.d(n),
						correlationId: Object(o.c)(o.a.SearchResults),
						post: s.L(n, e),
						search: {
							...s.P(n, t),
							query: i,
							queryId: s.gb(n, r.a.SERP),
							impressionId: a.a.get(r.a.SERP)
						},
						subreddit: s.mb(n)
					}
				},
				d = e => t => ({
					source: "post_flair_widget",
					action: "click",
					noun: "post_flair_search",
					...s.p(t),
					actionInfo: s.d(t),
					correlationId: Object(o.c)(o.a.SearchResults),
					search: s.P(t, e),
					subreddit: s.mb(t)
				}),
				l = e => t => {
					const n = Object(i.g)(e);
					return {
						...s.p(t),
						action: "click",
						noun: "post_flair",
						source: "post_flair_widget",
						subreddit: s.mb(t),
						postFlair: {
							id: e.templateId,
							title: n
						}
					}
				},
				u = () => e => ({
					...s.p(e),
					action: "click",
					noun: "overflow",
					source: "post_flair_widget",
					subreddit: s.mb(e)
				}),
				m = e => t => {
					const n = Object(i.g)(e);
					return {
						...s.p(t),
						action: "click",
						noun: "clear",
						source: "post_flair_widget",
						subreddit: s.mb(t),
						postFlair: {
							id: e.templateId,
							title: n
						}
					}
				},
				p = (e, t) => n => {
					const o = Object(i.g)(e),
						c = s.L(n, t),
						d = `flair_name:'${o}'`;
					return {
						...s.p(n),
						action: "click",
						noun: "post_flair",
						source: "post",
						subreddit: s.mb(n),
						postFlair: {
							id: e.templateId,
							title: o
						},
						post: c,
						search: {
							query: d,
							subredditId: c ? c.subredditId : void 0,
							subredditName: c ? c.subredditName : void 0,
							postFlairName: o,
							originElement: "post_flair",
							queryId: s.gb(n, r.a.SERP),
							impressionId: a.a.get(r.a.SERP),
							originPageType: n.platform.currentPage ? s.w(n.platform.currentPage) : void 0
						},
						feed: s.s(n)
					}
				}
		},
		"./src/reddit/helpers/trackers/predictions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "p", (function() {
				return a
			})), n.d(t, "m", (function() {
				return c
			})), n.d(t, "n", (function() {
				return d
			})), n.d(t, "l", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "q", (function() {
				return h
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "i", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "g", (function() {
				return v
			})), n.d(t, "c", (function() {
				return C
			})), n.d(t, "j", (function() {
				return y
			})), n.d(t, "h", (function() {
				return E
			})), n.d(t, "o", (function() {
				return x
			}));
			var o = n("./src/reddit/models/Prediction/index.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const s = "poll",
				i = "predictions",
				a = e => ({
					...Object(r.p)(e),
					source: s,
					action: "view",
					noun: "predict_option_modal"
				}),
				c = e => {
					let {
						pollId: t,
						selectedNumberCoins: n,
						totalStakeAmount: o
					} = e;
					return e => ({
						...Object(r.p)(e),
						source: s,
						action: "confirm",
						noun: "predict",
						poll: Object(r.K)(e, t, !1, void 0, n),
						goldPurchase: {
							numberCoins: o
						}
					})
				},
				d = e => {
					let {
						pollId: t,
						selectedNumberTokens: n
					} = e;
					return e => ({
						...Object(r.p)(e),
						source: s,
						action: "confirm",
						noun: "predict",
						poll: Object(r.K)(e, t, !1, void 0, void 0, n)
					})
				},
				l = e => {
					let {
						pollId: t,
						currency: n,
						amount: i
					} = e;
					return e => {
						const a = n === o.a.Coins ? i : void 0,
							c = n === o.a.Tokens ? i : void 0;
						return {
							...Object(r.p)(e),
							source: s,
							action: "close",
							noun: "prediction_modal",
							poll: Object(r.K)(e, t, !1, a, c)
						}
					}
				},
				u = e => ({
					...Object(r.p)(e),
					source: s,
					action: "click",
					noun: "add_coins"
				}),
				m = e => {
					let {
						targetUserId: t
					} = e;
					return e => ({
						...Object(r.p)(e),
						source: i,
						action: "click",
						noun: "leaderboard_profile",
						targetUser: {
							id: t
						}
					})
				},
				p = e => {
					let {
						pageType: t
					} = e;
					return e => ({
						...Object(r.p)(e),
						source: i,
						action: "click",
						noun: "tournament",
						actionInfo: {
							pageType: t
						}
					})
				},
				h = () => e => ({
					...Object(r.p)(e),
					source: "global",
					action: "view",
					noun: "screen",
					actionInfo: {
						pageType: "mod_tool_predict"
					}
				}),
				b = () => e => ({
					...Object(r.p)(e),
					source: "mod_tool_predict",
					action: "click",
					noun: "end_tournament"
				}),
				f = () => e => ({
					...Object(r.p)(e),
					source: "mod_tool_predict",
					action: "click",
					noun: "rename_tournament"
				}),
				g = e => t => ({
					...Object(r.p)(t),
					source: "mod_tool_predict",
					action: "click",
					noun: "enable_predictions",
					actionInfo: {
						pageType: "predictions_picker"
					},
					setting: {
						value: e ? "1" : "0",
						oldValue: e ? "0" : "1"
					},
					subreddit: Object(r.mb)(t)
				}),
				v = () => e => ({
					...Object(r.p)(e),
					source: i,
					action: "click",
					noun: "next"
				}),
				C = () => e => ({
					...Object(r.p)(e),
					source: i,
					action: "click",
					noun: "add_more"
				}),
				y = () => e => ({
					...Object(r.p)(e),
					source: i,
					action: "click",
					noun: "start_tournament"
				}),
				E = () => e => ({
					...Object(r.p)(e),
					source: "menu_links_bar",
					action: "click",
					noun: "predictions_tab"
				}),
				x = () => e => ({
					...Object(r.p)(e),
					source: "predictions_tab",
					action: "view",
					noun: "predictions_how_it_works",
					subreddit: Object(r.mb)(e)
				})
		},
		"./src/reddit/helpers/trackers/privateCommunity.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			var o = n("./src/reddit/selectors/telemetry.ts");
			const r = e => t => ({
					...o.p(t),
					source: e,
					action: "click",
					noun: "request_to_join_button",
					subreddit: o.mb(t)
				}),
				s = e => t => ({
					...o.p(t),
					source: e,
					action: "click",
					noun: "request_to_join_submit",
					subreddit: o.mb(t)
				})
		},
		"./src/reddit/helpers/trackers/restrictedCommunity.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			var o = n("./src/reddit/selectors/telemetry.ts");
			const r = e => t => ({
					...o.p(t),
					source: e,
					action: "click",
					noun: "request_restricted_approval_button",
					subreddit: o.mb(t)
				}),
				s = e => t => ({
					...o.p(t),
					source: "request_restricted_approval_form",
					action: "click",
					noun: e,
					subreddit: o.mb(t)
				})
		},
		"./src/reddit/helpers/trackers/scheduledPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return a
			})), n.d(t, "y", (function() {
				return c
			})), n.d(t, "m", (function() {
				return d
			})), n.d(t, "p", (function() {
				return l
			})), n.d(t, "q", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "o", (function() {
				return h
			})), n.d(t, "r", (function() {
				return b
			})), n.d(t, "k", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "n", (function() {
				return C
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "g", (function() {
				return x
			})), n.d(t, "l", (function() {
				return O
			})), n.d(t, "t", (function() {
				return _
			})), n.d(t, "j", (function() {
				return k
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "x", (function() {
				return S
			})), n.d(t, "u", (function() {
				return T
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "s", (function() {
				return I
			})), n.d(t, "v", (function() {
				return P
			})), n.d(t, "w", (function() {
				return N
			}));
			var o = n("./src/reddit/models/ScheduledPost/index.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const s = e => ({
					...r.p(e),
					screen: r.db(e),
					subreddit: r.mb(e),
					userSubreddit: r.vb(e)
				}),
				i = e => ({
					id: e.id,
					publishAt: e.publishAt,
					clientTimezone: e.clientTimezone,
					isRecurring: Object(o.q)(e)
				}),
				a = () => e => ({
					source: "post_composer",
					action: "click",
					noun: "schedule_post",
					...s(e)
				}),
				c = () => e => ({
					source: "scheduled_post_composer",
					action: "view",
					noun: "schedule_post_composer",
					...s(e)
				}),
				d = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_date",
					...s(e)
				}),
				l = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_time",
					...s(e)
				}),
				u = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_timezone",
					...s(e)
				}),
				m = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "apply",
					...s(e)
				}),
				p = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "cancel",
					...s(e)
				}),
				h = e => t => ({
					source: "post_composer",
					action: "click",
					noun: "schedule_post_submit",
					...s(t),
					scheduledPost: i(e)
				}),
				b = e => t => ({
					source: "post_composer",
					action: "click",
					noun: "schedule_post_update_submit",
					...s(t),
					scheduledPost: i(e)
				}),
				f = () => e => ({
					source: "mod_hub_nav",
					action: "click",
					noun: "scheduled_posts",
					...s(e)
				}),
				g = () => e => ({
					source: "mod_hub_nav",
					action: "click",
					noun: "event_posts",
					...s(e)
				}),
				v = () => e => ({
					source: "post",
					action: "click",
					noun: "edit_post",
					...s(e)
				}),
				C = () => e => ({
					source: "post",
					action: "click",
					noun: "submit_post_now",
					...s(e)
				}),
				y = e => t => ({
					source: "post",
					action: "click",
					noun: "overflow_menu",
					...s(t),
					actionInfo: r.d(t, {
						pageType: e ? "recurring_posts" : "scheduled_posts"
					})
				}),
				E = {
					[o.d.Hourly]: "hourly_frequency",
					[o.d.Daily]: "daily_frequency",
					[o.d.Weekly]: "weekly_frequency",
					[o.d.Monthly]: "monthly_frequency",
					[o.b]: "custom_frequency"
				},
				x = e => t => ({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: null === e ? "one_time_frequency" : E[e],
					...s(t)
				}),
				O = () => e => ({
					source: "post",
					action: "click",
					noun: "start_event_now",
					...s(e)
				}),
				_ = (e, t, n) => i => ({
					source: "post",
					action: "click",
					noun: Object(o.m)(e),
					...s(i),
					actionInfo: r.d(i, {
						settingValue: t ? "true" : "false",
						pageType: n ? "recurring_posts" : "scheduled_posts"
					})
				}),
				k = () => e => ({
					source: "recurring_post_module",
					action: "click",
					noun: "schedule_post_cta",
					...s(e)
				}),
				j = () => e => ({
					source: "recurring_post_module",
					action: "click",
					noun: "edit_recurring_post",
					...s(e)
				}),
				S = () => e => ({
					source: "recurring_post_composer",
					action: "view",
					noun: "recurring_post_composer",
					...s(e)
				}),
				T = () => (e, t) => ({
					source: "recurring_post_composer",
					action: "click",
					noun: "update",
					...s(e),
					scheduledPost: i(t)
				}),
				w = () => e => ({
					source: "recurring_post_composer",
					action: "click",
					noun: "cancel",
					...s(e)
				}),
				I = () => (e, t) => ({
					source: "recurring_post_composer",
					action: "click",
					noun: "delete",
					...s(e),
					scheduledPost: i(t)
				}),
				P = () => e => ({
					source: "scheduled_post_composer",
					action: "view",
					noun: "custom_schedule_post_composer",
					...s(e)
				}),
				N = () => (e, t) => {
					const n = s(e);
					return {
						source: "post",
						action: "view",
						noun: "error",
						...n,
						actionInfo: {
							...n.actionInfo,
							reason: "failed_post"
						},
						scheduledPost: i(t)
					}
				}
		},
		"./src/reddit/helpers/trackers/snoovatar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "s", (function() {
				return m
			})), n.d(t, "l", (function() {
				return p
			})), n.d(t, "o", (function() {
				return h
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "r", (function() {
				return v
			})), n.d(t, "e", (function() {
				return C
			})), n.d(t, "k", (function() {
				return y
			})), n.d(t, "n", (function() {
				return x
			})), n.d(t, "j", (function() {
				return O
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "q", (function() {
				return j
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "p", (function() {
				return I
			})), n.d(t, "m", (function() {
				return P
			}));
			var o = n("./src/reddit/models/Gold/ProductOffer.ts"),
				r = n("./src/reddit/selectors/avatarMarketing.ts"),
				s = n("./src/reddit/selectors/telemetry.ts"),
				i = n("./src/reddit/selectors/user.ts"),
				a = n("./src/reddit/helpers/userSnoovatar/index.ts");
			const c = {
					goldPurchase: {
						offerContext: o.a.AvatarNewGear
					}
				},
				d = e => t => {
					const n = {
						source: e,
						action: "click",
						noun: "edit_snoovatar",
						...s.p(t)
					};
					return Object(r.a)(t) && Object.assign(n, c), n
				},
				l = (e, t) => n => {
					const {
						id: o
					} = Object(i.Db)(n, {
						userName: t
					});
					return {
						source: e,
						action: "click",
						noun: "copy_avatar",
						...s.p(n),
						snoovatar: {
							userGenerated: o
						}
					}
				},
				u = e => ({
					...s.p(e),
					source: "avatar",
					action: "click",
					noun: "try_this_look_post",
					snoovatar: s.kb(e)
				}),
				m = e => ({
					...s.p(e, {
						isGVSEvent: !0
					}),
					source: "global",
					action: "view",
					noun: "screen",
					actionInfo: {
						pageType: "snoovatar_builder"
					},
					snoovatar: s.kb(e)
				}),
				p = e => ({
					...s.p(e),
					source: "avatar_builder",
					action: "click",
					noun: "close",
					snoovatar: s.kb(e)
				}),
				h = e => ({
					source: "nav",
					action: "view",
					noun: "avatar_marketing",
					...s.p(e),
					...c
				}),
				b = e => ({
					source: "nav",
					action: "click",
					noun: "avatar_marketing",
					...s.p(e),
					...c
				}),
				f = e => t => ({
					...s.p(t),
					source: "snoovatar",
					action: "set_to_profile",
					noun: "snoovatar",
					snoovatar: {
						userGeneratedSource: e
					}
				}),
				g = e => t => n => ({
					source: "avatar",
					action: e,
					noun: "community_spaces",
					...s.p(n),
					snoovatar: s.kb(n),
					actionInfo: {
						paneName: "avatar_community_spaces" + (t ? "_control" : "")
					}
				}),
				v = g("view"),
				C = g("click"),
				y = g("dismiss"),
				E = (e, t, n) => () => o => ({
					source: e,
					action: t,
					noun: n,
					...s.p(o),
					snoovatar: s.kb(o)
				}),
				x = E("anniversary_achievement", "view", "anniversary_achievement"),
				O = E("anniversary_achievement", "click", "close"),
				_ = E("anniversary_achievement", "click", "equip"),
				k = e => () => t => ({
					...s.p(t),
					source: "gold_top_nav",
					action: e,
					noun: "quick_create_cta"
				}),
				j = k("view"),
				S = k("click"),
				T = (e, t, n) => o => ({
					source: e,
					action: t,
					noun: n,
					...s.p(o),
					actionInfo: {
						pageType: "onboarding"
					},
					snoovatar: s.kb(o)
				}),
				w = e => T("onboarding", "click", e),
				I = () => T("avatar", "view", "onboarding"),
				P = e => {
					let {
						user: t,
						pageType: n,
						userHasNft: o
					} = e;
					return e => {
						const r = Object(a.a)(t.accountIcon),
							i = (null == t ? void 0 : t.id) && (null == t ? void 0 : t.username);
						return {
							source: "profile",
							action: "screen",
							noun: "load",
							...s.p(e),
							actionInfo: {
								pageType: n
							},
							profile: i ? {
								id: t.id,
								name: t.username
							} : null,
							snoovatar: {
								snoovatarActive: r,
								userHasNft: o
							},
							marketplace: {
								hasCollectibleCollection: !1
							}
						}
					}
				}
		},
		"./src/reddit/helpers/trackers/subredditMuting.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return i
			}));
			var o = n("./src/reddit/selectors/telemetry.ts"),
				r = n("./src/telemetry/models/Event.ts");
			const s = e => {
					let {
						subredditId: t,
						postId: n
					} = e;
					return e => ({
						source: r.f.SubredditMuting,
						action: r.d.Mute,
						noun: r.e.Subreddit,
						subreddit: {
							id: t
						},
						...o.p(e),
						...n && {
							post: {
								id: n
							}
						}
					})
				},
				i = e => {
					let {
						subredditId: t,
						postId: n
					} = e;
					return e => ({
						source: r.f.SubredditMuting,
						action: r.d.Unmute,
						noun: r.e.Subreddit,
						subreddit: {
							id: t
						},
						...o.p(e),
						...n && {
							post: {
								id: n
							}
						}
					})
				}
		},
		"./src/reddit/helpers/trackers/userFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			}));
			var o = n("./src/reddit/helpers/flair.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const s = () => e => ({
					source: "id_card",
					action: "click",
					noun: "user_flair_picker",
					...r.p(e)
				}),
				i = e => t => {
					const n = r.mb(t),
						{
							userFlair: s,
							achievementFlair: i
						} = e;
					return {
						source: "user_flair_picker",
						action: "click",
						noun: "user_flair",
						...r.p(t),
						subreddit: n,
						userFlair: {
							id: null == s ? void 0 : s.id,
							title: s ? Object(o.g)(s) : void 0,
							isActive: !!s || void 0,
							achievementFlairId: null == i ? void 0 : i.type,
							achievementFlairTitle: null == i ? void 0 : i.name,
							isLocked: null == i ? void 0 : i.isLocked
						}
					}
				},
				a = () => e => ({
					source: "user_flair_picker",
					action: "click",
					noun: "edit_user_flair",
					...r.p(e)
				}),
				c = e => t => ({
					source: "user_flair_picker",
					action: "click",
					noun: "enable_powerups_flair",
					setting: {
						value: e ? "0" : "1",
						oldValue: e ? "1" : "0"
					},
					subreddit: r.mb(t),
					...r.p(t)
				})
		},
		"./src/reddit/helpers/trackers/widgets.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return l
			}));
			var o, r, s = n("./src/reddit/constants/tracking.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			! function(e) {
				e.REREDDIT_PROMO = "rereddit_promo", e.SEE_MORE = "see_more", e.TOPIC = "topic", e.TOPICS_WIDGET = "topics_widget"
			}(o || (o = {})),
			function(e) {
				e.COMMUNITY_WIDGETS = "community_widgets", e.POST = "post", e.SIDEBAR = "sidebar", e.TOPICS_WIDGET = "topics_widget"
			}(r || (r = {}));
			const a = (e, t) => n => ({
					source: r.COMMUNITY_WIDGETS,
					action: s.c.CLICK,
					noun: o.SEE_MORE,
					widget: Object(i.zb)(n, {
						subredditId: e,
						widgetKind: t
					}),
					...i.p
				}),
				c = (e, t) => n => ({
					source: r.POST,
					action: s.c.CLICK,
					noun: o.REREDDIT_PROMO,
					post: i.L(n, e),
					subreddit: i.mb(n),
					...t && {
						banner: {
							buttonText: t,
							id: o.REREDDIT_PROMO
						}
					},
					...i.p(n)
				}),
				d = () => e => ({
					source: r.SIDEBAR,
					action: s.c.VIEW,
					noun: o.TOPICS_WIDGET,
					...i.p(e)
				}),
				l = e => t => ({
					source: r.TOPICS_WIDGET,
					action: s.c.CLICK,
					noun: o.TOPIC,
					...i.p(t),
					topicMetadata: {
						displayName: e
					}
				})
		},
		"./src/reddit/hooks/useClickSourceData.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var o = n("./node_modules/react/index.js"),
				r = n("./node_modules/react-redux/es/index.js"),
				s = n("./src/reddit/helpers/clickSourceData/index.ts");

			function i() {
				const e = Object(r.e)(e => e.platform.currentPage),
					[t, n] = Object(o.useState)({});
				return Object(o.useEffect)(() => {
					n(Object(s.b)(e))
				}, [e]), t
			}
		},
		"./src/reddit/hooks/useInfoTextTooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var o = n("./node_modules/icepick/icepick.js"),
				r = n("./node_modules/react/index.js"),
				s = n("./src/lib/hooks/useTooltip.ts");
			const i = Object(o.freeze)({
				name: "offset",
				options: {
					offset: [0, 6]
				}
			});

			function a(e) {
				const t = Object(r.useMemo)(() => {
					const t = Object(s.a)(e);
					return Object(o.updateIn)(t, ["modifiers"], e => Object(o.push)(e, i))
				}, [e]);
				return Object(s.b)(t)
			}
		},
		"./src/reddit/hooks/useIsAvatarPost.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var o = n("./node_modules/react-redux/es/index.js");
			const r = ["t2_83axfjo9", "t2_5ybo8iyi", "t2_7yef0w0w", "t2_fvlxukt", "t2_16060o", "t2_364me452", "t2_46dwatoq", "t2_86xzqcqi", "t2_97lsdz5t", "t2_8394tzuq ", "t2_b46ms2wj", "t2_btxoz0zb"],
				s = ["t5_q0gj4", "t5_2rjli"],
				i = new RegExp(/https:\/\/(www\.)?reddit.com\/avatar\/.*\/\d+$/);
			var a = n("./src/reddit/selectors/experiments/econ/index.ts");
			const c = e => Object(o.e)(t => {
				return !!(e => {
					let {
						adminId: t,
						subredditId: n,
						avatarShareUrl: o
					} = e;
					const a = i.test(o.trim()),
						c = r.includes(t),
						d = s.includes(n);
					return a && c && d
				})({
					adminId: e.authorId,
					subredditId: e.belongsTo.id,
					avatarShareUrl: e.source ? e.source.url : ""
				}) && Object(a.a)(t)
			})
		},
		"./src/reddit/hooks/useIsRemovedOrDeletedPost.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var o = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/reddit/selectors/removedPosts.ts");
			const s = () => Object(o.e)(e => Object(r.d)(e))
		},
		"./src/reddit/hooks/useLocalStorage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var o = n("./node_modules/react/index.js"),
				r = n("./src/reddit/helpers/localStorage/index.ts");
			const s = {},
				i = (e, t, n) => (s[e] || (s[e] = {
					callbacks: [],
					value: n
				}), s[e].callbacks.push(t), {
					deregister: () => {
						const {
							callbacks: n
						} = s[e], o = n.indexOf(t);
						o > -1 && n.splice(o, 1)
					},
					emit: n => {
						s[e].value !== n && (s[e].value = n, s[e].callbacks.forEach(e => {
							e !== t && e(n)
						}))
					}
				});

			function a(e, t) {
				const n = Object(o.useRef)(null);
				let s;
				s = Object(r.G)(e);
				const [a, c] = Object(o.useState)(null != s ? s : t);
				return Object(o.useEffect)(() => (n.current = i(e, c, t), () => {
					var e;
					return null === (e = n.current) || void 0 === e ? void 0 : e.deregister()
				}), [e, t]), Object(o.useEffect)(() => {
					var e;
					null === (e = n.current) || void 0 === e || e.emit(a)
				}, [a]), [a, function(t) {
					Object(r.Lb)(e, t), c(t)
				}]
			}
		},
		"./src/reddit/hooks/useLocale.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			}));
			var o = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/index.js"),
				r = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/selectors/meta.ts");
			const a = "undefined" == typeof document ? function() {
				const e = Object(s.e)(i.k) || r.DEFAULT_LOCALE;
				return Object(o.isPseudoLocale)(e) ? r.DEFAULT_LOCALE : e
			} : function() {
				const e = document.documentElement.lang || r.DEFAULT_LOCALE;
				return Object(o.isPseudoLocale)(e) ? r.DEFAULT_LOCALE : e
			};
			t.a = a;
			const c = () => {
				const e = a(),
					t = Object(s.e)(i.b);
				return t ? e.replace(/([a-z]+-)([A-Z]+)/, `$1${t}`) : e
			}
		},
		"./src/reddit/hooks/useModalState.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);

			function s() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
				const [t, n] = r.a.useState(e);
				return [t, () => n(!0), () => n(!1)]
			}
		},
		"./src/reddit/hooks/usePostContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var o = n("./src/lib/sentry/index.ts"),
				r = n("./node_modules/react/index.js"),
				s = n("./src/reddit/contexts/Post/index.tsx");

			function i() {
				const e = Object(r.useContext)(s.c);
				return e || o.c.captureMessage("No post context provided"), e
			}
		},
		"./src/reddit/hooks/useTheme.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var o = n("./node_modules/react/index.js"),
				r = n("./src/lib/CSSVariableProvider/index.tsx");

			function s() {
				return Object(o.useContext)(r.b)
			}
		},
		"./src/reddit/icons/fonts/Approve/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(s.a)(Object(i.b)("approve", e.isFilled), c.a.approveIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Archived/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(s.a)(Object(i.b)("archived", e.isFilled), c.a.archivedIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Downvote/index.m.less": function(e, t, n) {
			e.exports = {
				compactDownvote: "_2GCoZTwJW7199HSwNZwlHk",
				compactDownvoteWrapper: "jR747Vd1NbfaLusf5bHre",
				downvote: "ZyxIIl4FP5gHGrJDzNpUC",
				downvoteWrapper: "_1iKd82bq_nqObFvSH1iC_Q"
			}
		},
		"./src/reddit/icons/fonts/Downvote/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/Downvote/index.m.less"),
				c = n.n(a);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const l = e => r.a.createElement("i", {
				className: Object(s.a)(Object(i.b)("downvote", e.isFilled), c.a.downvote, e.className)
			});
			t.a = e => {
				let {
					compact: t,
					isFilled: n,
					...o
				} = e;
				return t ? r.a.createElement("span", d({}, o, {
					className: Object(s.a)(c.a.compactDownvoteWrapper, o.className)
				}), r.a.createElement(l, {
					className: c.a.compactDownvote,
					isFilled: n
				})) : r.a.createElement("span", d({}, o, {
					className: Object(s.a)(c.a.downvoteWrapper, o.className)
				}), r.a.createElement(l, {
					isFilled: n
				}))
			}
		},
		"./src/reddit/icons/fonts/DropdownTriangle/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(s.b)("caret_down",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Info/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(s.b)("info",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Lock/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(s.a)(Object(i.b)("lock", e.isFilled), c.a.lockIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/OutboundLink/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(s.b)("external_link",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Premium/index.m.less": function(e, t, n) {
			e.exports = {
				PremiumIcon: "dLp3R7pmxclGjLS87yr5S",
				premiumIcon: "dLp3R7pmxclGjLS87yr5S"
			}
		},
		"./src/reddit/icons/fonts/Premium/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Premium/index.m.less"),
				a = n.n(i);
			const c = n("./src/lib/lessComponent.tsx").a.wrapped(e => r.a.createElement("i", {
				title: e.title,
				className: `${Object(s.b)("premium",e.isFilled)} ${e.className}`
			}), "PremiumIcon", a.a)
		},
		"./src/reddit/icons/fonts/Remove/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(s.a)(Object(i.b)("remove", e.isFilled), c.a.removeIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Report/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(s.a)(Object(i.b)("report", e.isFilled), c.a.reportIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Spam/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(s.a)(Object(i.b)("spam", e.isFilled), c.a.spamIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Sticky/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(s.a)(Object(i.b)("pin", e.isFilled), c.a.stickyIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Upvote/index.m.less": function(e, t, n) {
			e.exports = {
				compactUpvote: "_39UOLMgvssWenwbRxz_iEn",
				compactUpvoteWrapper: "_3wVayy5JvIMI67DheMYra2",
				upvote: "_2Jxk822qXs4DaXwsN7yyHA",
				upvoteWrapper: "_2q7IQ0BUOWeEZoeAxN555e"
			}
		},
		"./src/reddit/icons/fonts/Upvote/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/Upvote/index.m.less"),
				c = n.n(a);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const l = e => r.a.createElement("i", {
				className: Object(s.a)(Object(i.b)("upvote", e.isFilled), c.a.upvote, e.className)
			});
			t.b = e => {
				let {
					compact: t,
					isFilled: n,
					...o
				} = e;
				return t ? r.a.createElement("span", d({}, o, {
					className: Object(s.a)(c.a.compactUpvoteWrapper, o.className)
				}), r.a.createElement(l, {
					className: c.a.compactUpvote,
					isFilled: n
				})) : r.a.createElement("span", d({}, o, {
					className: Object(s.a)(c.a.upvoteWrapper, o.className)
				}), r.a.createElement(l, {
					isFilled: n
				}))
			}
		},
		"./src/reddit/icons/svgs/AddCollection/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 24 24"
			}, r.a.createElement("defs", null, r.a.createElement("path", {
				id: "svg-add-collection",
				d: "M19.2 2.4a2.4 2.4 0 0 1 2.4 2.4v.936a3.577 3.577 0 0 0-2.4-.936H4.8c-.925 0-1.763.361-2.4.936V4.8a2.4 2.4 0 0 1 2.4-2.4h14.4zm0 3.6a2.4 2.4 0 0 1 2.4 2.4v.936a3.577 3.577 0 0 0-2.4-.936H4.8c-.925 0-1.763.361-2.4.936V8.4A2.4 2.4 0 0 1 4.8 6h14.4zm0 3.6a2.4 2.4 0 0 1 2.4 2.4v7.2a2.4 2.4 0 0 1-2.4 2.4H4.8a2.4 2.4 0 0 1-2.4-2.4V12a2.4 2.4 0 0 1 2.4-2.4h14.4zm-3.806 5.1H12.9v-2.494a.9.9 0 1 0-1.8 0V14.7H8.607a.9.9 0 1 0 0 1.8H11.1v2.494a.9.9 0 1 0 1.8 0V16.5h2.494a.9.9 0 0 0 0-1.8z"
			})), r.a.createElement("use", {
				fill: "inherit",
				xlinkHref: "#svg-add-collection",
				fillRule: "evenodd"
			}))
		},
		"./src/reddit/icons/svgs/Checkbox/index.m.less": function(e, t, n) {
			e.exports = {
				checkbox: "_1vmueUAOJJg7fhS7wxztWa"
			}
		},
		"./src/reddit/icons/svgs/Checkbox/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Checkbox/index.m.less"),
				a = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				let {
					className: t,
					...n
				} = e;
				return r.a.createElement("svg", c({
					xmlns: "http://www.w3.org/2000/svg",
					width: "20",
					height: "20",
					viewBox: "0 0 20 20",
					className: Object(s.a)(a.a.checkbox, t)
				}, n), r.a.createElement("path", {
					fill: "inherit",
					d: "M1.66666667,3.34755033 L1.66666667,16.6524497 C1.66666667,17.5781756 2.42112363,18.3333333 3.34755033,18.3333333 L16.6524497,18.3333333 C17.5781756,18.3333333 18.3333333,17.5788764 18.3333333,16.6524497 L18.3333333,3.34755033 C18.3333333,2.42182438 17.5788764,1.66666667 16.6524497,1.66666667 L3.34755033,1.66666667 C2.42182438,1.66666667 1.66666667,2.42112363 1.66666667,3.34755033 Z M0,3.34755033 C0,1.49874933 1.5032506,0 3.34755033,0 L16.6524497,0 C18.5012507,0 20,1.5032506 20,3.34755033 L20,16.6524497 C20,18.5012507 18.4967494,20 16.6524497,20 L3.34755033,20 C1.49874933,20 0,18.4967494 0,16.6524497 L0,3.34755033 Z"
				}))
			}
		},
		"./src/reddit/icons/svgs/CheckboxSelected/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);

			function s() {
				return (s = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", s({
				xmlns: "http://www.w3.org/2000/svg",
				width: "20",
				height: "20",
				viewBox: "0 0 20 20"
			}, e), r.a.createElement("path", {
				fill: "inherit",
				d: "M0,3.34755033 C0,1.49874933 1.5032506,0 3.34755033,0 L16.6524497,0 C18.5012507,0 20,1.5032506 20,3.34755033 L20,16.6524497 C20,18.5012507 18.4967494,20 16.6524497,20 L3.34755033,20 C1.49874933,20 0,18.4967494 0,16.6524497 L0,3.34755033 Z M8.50575,15.1995 L15.797625,7.907625 C16.25325,7.452625 16.25325,6.71325 15.797625,6.25825 C15.342,5.802625 14.602625,5.802625 14.147625,6.25825 L7.7295,12.676375 L5.635125,10.327625 C5.20575,9.846375 4.46825,9.805125 3.987625,10.23325 C3.506375,10.662625 3.4645,11.400125 3.89325,11.88075 L6.810125,15.151375 C7.023875,15.39075 7.327,15.531375 7.647625,15.54075 C7.658875,15.54075 7.6695,15.541375 7.68075,15.541375 C7.990125,15.541375 8.287,15.41825 8.50575,15.1995 Z"
			}))
		},
		"./src/reddit/icons/svgs/Checkmark/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 22",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M8.9310375,15.1995 C8.70135,15.41825 8.38963125,15.541375 8.0647875,15.541375 C8.052975,15.541375 8.04181875,15.54075 8.03000625,15.54075 C7.69335,15.531375 7.37506875,15.39075 7.15063125,15.151375 L4.0879125,11.88075 C3.637725,11.400125 3.68169375,10.662625 4.18700625,10.23325 C4.6916625,9.805125 5.4660375,9.846375 5.91688125,10.327625 L8.115975,12.676375 L14.8550063,6.25825 C15.3327563,5.802625 16.1091,5.802625 16.5875063,6.25825 C17.0659125,6.71325 17.0659125,7.452625 16.5875063,7.907625 L8.9310375,15.1995 Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/ChevronDown/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 12 12",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, r.a.createElement("g", null, r.a.createElement("polygon", {
				fill: "inherit",
				points: "11.0584 4.0602 6.0292 9.0894 1 4.0602 2.0608 3 6.0292 6.9684 9.9982 3"
			})))
		},
		"./src/reddit/icons/svgs/ClearFilled/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				onClick: e.onClick,
				onMouseUp: e.onMouseUp,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 40 40"
			}, r.a.createElement("path", {
				d: "M20 2.5C10.3 2.5 2.5 10.3 2.5 20c0 9.7 7.8 17.5 17.5 17.5S37.5 29.7 37.5 20C37.5 10.3 29.7 2.5 20 2.5zM24.2 27.7L20 23.5l-4.2 4.2c-1.1 1.1-2.5 1.1-3.5 0-1.1-1.1-1.1-2.4 0-3.5l4.2-4.2-4.2-4.2c-1.1-1.1-1.1-2.5 0-3.5 1.1-1.1 2.4-1.1 3.5 0l4.2 4.2 4.2-4.2c1.1-1.1 2.5-1.1 3.5 0 1.1 1.1 1.1 2.4 0 3.5L23.5 20l4.2 4.2c1.1 1.1 1.1 2.5 0 3.5C26.7 28.8 25.3 28.8 24.2 27.7z"
			}))
		},
		"./src/reddit/icons/svgs/Dropdown/index.m.less": function(e, t, n) {
			e.exports = {
				dropdown: "XHbKeEqnW58ib9mTN6jnS",
				mRedditStyle: "u_kypUXmB-k1A5TcC8MI9"
			}
		},
		"./src/reddit/icons/svgs/Dropdown/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Dropdown/index.m.less"),
				a = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const d = e => {
				let {
					className: t,
					isSubreddit: n,
					...o
				} = e;
				return r.a.createElement("svg", c({
					className: Object(s.a)(a.a.dropdown, {
						[a.a.mRedditStyle]: !n
					}, t),
					viewBox: "0 0 20 20",
					xmlns: "http://www.w3.org/2000/svg"
				}, o), r.a.createElement("path", {
					d: "M14.17,9.35,10,13.53,5.83,9.35a.5.5,0,0,1,.35-.85h7.64a.5.5,0,0,1,.35.85"
				}))
			};
			t.b = d
		},
		"./src/reddit/icons/svgs/FormattingAlignCenter/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1ZVHRoTDdo57082D2GcC80"
			}
		},
		"./src/reddit/icons/svgs/FormattingAlignCenter/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingAlignCenter/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(s.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", {
				fill: "inherit",
				fillRule: "nonzero"
			}, r.a.createElement("path", {
				d: "M3.5 11h13c.55 0 1-.45 1-1s-.45-1-1-1h-13c-.55 0-1 .45-1 1s.45 1 1 1zM7.42 16h5.08c.55 0 1-.45 1-1s-.45-1-1-1H7.42c-.56 0-1 .45-1 1s.44 1 1 1zM3.5 6h13c.55 0 1-.45 1-1s-.45-1-1-1h-13c-.55 0-1 .45-1 1s.45 1 1 1z"
			})))
		},
		"./src/reddit/icons/svgs/FormattingAlignLeft/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_33vXt91MK_ualpifvvw_3v"
			}
		},
		"./src/reddit/icons/svgs/FormattingAlignLeft/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingAlignLeft/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(s.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", {
				fill: "inherit",
				fillRule: "nonzero"
			}, r.a.createElement("path", {
				d: "M3.5 11h13c.55 0 1-.45 1-1s-.45-1-1-1h-13c-.55 0-1 .45-1 1s.45 1 1 1zM3.5 16h5.4c.54 0 1-.45 1-1s-.46-1-1-1H3.5c-.55 0-1 .45-1 1s.45 1 1 1zM3.5 6h13c.55 0 1-.45 1-1s-.45-1-1-1h-13c-.55 0-1 .45-1 1s.45 1 1 1z"
			})))
		},
		"./src/reddit/icons/svgs/FormattingAlignRight/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_34rYEsgbWk8eOQx_bs7fTV"
			}
		},
		"./src/reddit/icons/svgs/FormattingAlignRight/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingAlignRight/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(s.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", {
				fill: "inherit",
				fillRule: "nonzero"
			}, r.a.createElement("path", {
				d: "M3.5 11h13c.55 0 1-.45 1-1s-.45-1-1-1h-13c-.55 0-1 .45-1 1s.45 1 1 1zM11.5 16h5c.55 0 1-.45 1-1s-.45-1-1-1h-5c-.55 0-1 .45-1 1s.45 1 1 1zM3.5 6h13c.55 0 1-.45 1-1s-.45-1-1-1h-13c-.55 0-1 .45-1 1s.45 1 1 1z"
			})))
		},
		"./src/reddit/icons/svgs/FormattingDeleteRow/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_8Y1-XP7A1OOfoU_mUqKcg"
			}
		},
		"./src/reddit/icons/svgs/FormattingDeleteRow/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingDeleteRow/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(s.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", {
				fill: "inherit",
				fillRule: "nonzero",
				transform: "vertical" === e.orientation ? "rotate(90, 10, 10)" : ""
			}, r.a.createElement("path", {
				d: "M3 3c0-.55.45-1 1-1h12c.55 0 1 .45 1 1v14c0 .55-.45 1-1 1H4c-.55 0-1-.45-1-1V3zM2 3v14c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2z"
			}), r.a.createElement("path", {
				d: "M2 15h16v1H2M2 4h16v1H2M7.17 11.4l4.24-4.23c.4-.4 1.04-.4 1.43 0 .4.4.4 1.03 0 1.42L8.6 12.82c-.4.4-1.04.4-1.43 0-.4-.4-.4-1.03 0-1.42z"
			}), r.a.createElement("path", {
				d: "M8.6 7.17l4.23 4.24c.4.4.4 1.04 0 1.43-.4.4-1.03.4-1.42 0L7.18 8.6c-.4-.4-.4-1.04 0-1.43.4-.4 1.03-.4 1.42 0z"
			})))
		},
		"./src/reddit/icons/svgs/FormattingInsertRow/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1PNKgIKbpvIWTVU3LO0PJQ"
			}
		},
		"./src/reddit/icons/svgs/FormattingInsertRow/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingInsertRow/index.m.less"),
				a = n.n(i);
			const c = {
				up: "rotate(180 10 10)",
				down: "",
				left: "rotate(90 10 10)",
				right: "rotate(-90 10 10)"
			};
			t.a = e => r.a.createElement("svg", {
				className: Object(s.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", {
				fill: "inherit",
				fillRule: "nonzero",
				transform: c[e.orientation || "down"]
			}, r.a.createElement("path", {
				d: "M17 17c0 .55-.45 1-1 1H4c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h12c.55 0 1 .45 1 1v14zm1 0V3c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2z"
			}), r.a.createElement("path", {
				d: "M18 6H2V5h16M13 13H7c-.55 0-1-.45-1-1s.45-1 1-1h6c.55 0 1 .45 1 1s-.45 1-1 1z"
			}), r.a.createElement("path", {
				d: "M9 15V9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1z"
			})))
		},
		"./src/reddit/icons/svgs/GovSmall/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 16 14",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M8.5,0.2l6.2,3c0.5,0.3,0.6,0.9,0.3,1.4C14.9,4.8,14.6,5,14.2,5H1.8c-0.6,0-1-0.4-1-1 c0-0.4,0.2-0.7,0.5-0.9l6.2-3C7.9,0,8.1,0,8.5,0.2z"
			}), r.a.createElement("path", {
				d: "M2,12h12c0.6,0,1,0.4,1,1l0,0c0,0.6-0.4,1-1,1H2c-0.6,0-1-0.4-1-1l0,0C1,12.4,1.4,12,2,12z"
			}), r.a.createElement("path", {
				d: "M3.8,6h0.5C4.7,6,5,6.3,5,6.8v3.5C5,10.7,4.7,11,4.2,11H3.8C3.3,11,3,10.7,3,10.3V6.8C3,6.3,3.3,6,3.8,6z"
			}), r.a.createElement("path", {
				d: "M7.8,6h0.5C8.7,6,9,6.3,9,6.8v3.5C9,10.7,8.7,11,8.2,11H7.8C7.3,11,7,10.7,7,10.3V6.8 C7,6.3,7.3,6,7.8,6z"
			}), r.a.createElement("path", {
				d: "M11.8,6h0.5C12.7,6,13,6.3,13,6.8v3.5c0,0.4-0.3,0.8-0.8,0.8h-0.5c-0.4,0-0.8-0.3-0.8-0.8V6.8 C11,6.3,11.3,6,11.8,6z"
			})))
		},
		"./src/reddit/icons/svgs/Grapple/index.m.less": function(e, t, n) {
			e.exports = {
				grapple: "_23XYJUJn_XitrV-LLkNyCQ",
				mIsDragging: "_1jCsYjqdUw4PYY-s3mGB47"
			}
		},
		"./src/reddit/icons/svgs/Grapple/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Grapple/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(s.a)(e.className, a.a.grapple, {
					[a.a.mIsDragging]: e.isDragging
				}),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("title", {
				id: `${e.title}-title`
			}, e.title), r.a.createElement("g", null, r.a.createElement("path", {
				d: "M8,2 C8.553,2 9,2.447 9,3 L9,5 C9,5.553 8.553,6 8,6 L6,6 C5.447,6 5,5.553 5,5 L5,3 C5,2.447 5.447,2 6,2 L8,2 Z M14,2 C14.553,2 15,2.447 15,3 L15,5 C15,5.553 14.553,6 14,6 L12,6 C11.447,6 11,5.553 11,5 L11,3 C11,2.447 11.447,2 12,2 L14,2 Z M8,8 C8.553,8 9,8.447 9,9 L9,11 C9,11.553 8.553,12 8,12 L6,12 C5.447,12 5,11.553 5,11 L5,9 C5,8.447 5.447,8 6,8 L8,8 Z M14,8 C14.553,8 15,8.447 15,9 L15,11 C15,11.553 14.553,12 14,12 L12,12 C11.447,12 11,11.553 11,11 L11,9 C11,8.447 11.447,8 12,8 L14,8 Z M8,14 C8.553,14 9,14.447 9,15 L9,17 C9,17.553 8.553,18 8,18 L6,18 C5.447,18 5,17.553 5,17 L5,15 C5,14.447 5.447,14 6,14 L8,14 Z M14,14 C14.553,14 15,14.447 15,15 L15,17 C15,17.553 14.553,18 14,18 L12,18 C11.447,18 11,17.553 11,17 L11,15 C11,14.447 11.447,14 12,14 L14,14 Z"
			})))
		},
		"./src/reddit/icons/svgs/Hamster1/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 53 67"
			}, r.a.createElement("g", {
				fill: "none",
				fillRule: "evenodd"
			}, r.a.createElement("path", {
				fill: "#000",
				d: "M36.17 15.7877c-2.1457-.6233-4.6272.5142-5.0853 2.419-.174.7268-.5168 1.0273-1.2283 1.124-1.5643.2126-2.9247.8707-4.0924 1.901-.807.7112-1.2403 1.523-1.2154 2.6702.0477 2.1067 1.0792 3.8318 2.0054 5.608.2256.432 2.0283-.631 1.111-.082-.616-1.9145-1.1994-3.6348-1.7152-5.3744-.2127-.72.0527-1.406.7364-1.754 1.2204-.6195 2.4954-1.1375 3.7456-1.702.5923-.2676.93-.057 1.27.465.821 1.2544 1.9995 2.04 3.5757 1.8642 1.6357-.1817 2.555-1.264 3.054-2.7215.6707-1.956-.2665-3.8677-2.1616-4.4176"
			}), r.a.createElement("path", {
				fill: "#FF8717",
				d: "M32.575 18.997c-.1866-1.1486.5913-2.0766 1.949-2.3235 1.4877-.2722 2.729.4466 2.9796 1.7235.2642 1.345-.7003 2.9457-1.9175 3.1832-1.341.2627-2.7447-.9416-3.011-2.5832"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M17.0857 23.965c-2.5846-.806-4.1367.6-4.4678 3.2556-.3653 2.9378.675 6.234 3.5116 7.1787 2.9598.9843 5.8344-1.5318 6.3822-4.5023.4535-2.4616-3.5227-5.3826-5.426-5.932-3.1034-.9685 1.507.4345 0 0M39.321 24.512c-2.184-2.2814-6.028.2842-7.4777 2.256-.521.7074-.9206 1.5057-1.1896 2.3475-.35 1.0897.269.94.3743 1.8643.1922 1.6742 2.1314 3.3578 3.7206 3.5912 4.7354.694 7.7125-6.7713 4.3803-10.2603.1294.1364.259.2717.3894.408-.0658-.0692-.1315-.1384-.1973-.2066-1.9745-2.0624.696.7283 0 0M18.9308 59.6326c-.1867-.0458-.3346.0093-.443.1056-.001 0-.001-.001-.002-.001-1.5598.099-3.8566.7662-4.6848 2.1695-.8887 1.507.7358 2.5096 2.148 2.674 1.553.1813 3.8715-.3148 4.4405-1.8975.439-1.2193-.0328-2.7012-1.4587-3.0506M34.37 60.348c-.242-.0358-.5174.043-.6267.2957-1.5118 3.4664 6.185 5.586 7.6074 2.4245 1.3572-3.016-4.6648-4.4187-6.9808-2.7203"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M39.9895 37.3797c-3.8707-9.353-16.7772-11.6802-23.5762-4.7352-3.177 3.245-4.373 8.2466-4.83 9.7576-1.4357 4.748-1.561 10.198.7932 14.6874 3.987 7.605 16.61 9.4605 23.792 5.505 9.1842-5.058 6.6638-18.3606 3.437-26.1424.2377.5734.4746 1.1468.7124 1.7202-.1096-.2645-.219-.528-.3285-.7925-2.1562-5.211 1.182 2.856 0 0"
			}), r.a.createElement("path", {
				fill: "#FF8717",
				d: "M26.4406 29.6162c3.5285 0 8.4696 2.1882 10.6613 4.9576 2.5828 3.2633 3.7284 8.3103 4.3175 12.3626.4945 3.4113-.4807 8.203-2.2755 11.186-2.1327 3.5455-6.732 4.5153-10.5422 4.4935-4.6918-.026-10.162-.5288-13.2412-4.577-2.77-3.643-3.234-8.4117-2.506-12.8188.401-2.4216 1.0284-5.207 1.9967-7.4706 2.105-4.9197 5.7597-8.1334 11.5893-8.1334"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M41.5915 49.6162c.03-.6952.008-1.3605-.044-2l.044 2zM37.4186 60.1975c-1.3365-.7743-2.342-2.1664-2.536-3.716-.0665-.533-.0396-1.074-.0128-1.61.0477-.9814.1004-1.9818.458-2.8933.4095-1.0428 1.1846-1.8868 1.9427-2.7034.46-.4967.9212-.9934 1.3823-1.49.7273-.7844 1.6783-1.6223 2.688-1.475-.4125-2.465-1.0336-5.1514-2.0422-7.567-1.0493 2.024-3.0208 3.9137-5.4086 2.871-.5147-.2242-.8774-.3756-1.3395-.7027-.8615-.7398-1.9138-.9498-3.157-.6288-.2702.3008-.5265.6128-.769.9368-.5157.521-1.1567.9812-1.9347.7632-1.7777-.5007-2.97-2.9346-5.1046-1.4002-.8675.624-1.9396 1.5637-3.0953 1.5082-2.0044-.096-3.3925-1.0983-4.2153-2.752-.776 2.0393-1.2024 4.4066-1.5432 6.479-.0407.2524-.0636.5098-.0974.7652.6232-.0353 1.2462-.013 1.8206.219.6776.2727 1.2182.8037 1.74 1.3225.8435.8388 1.708 1.706 2.187 2.8033.4382 1.0014.5227 2.123.5366 3.2183.015 1.0882-.0338 2.1754-.145 3.2566-.1313 1.284-.475 2.7296-1.571 3.3606 3.1707 2.359 7.553 2.7054 11.4153 2.7266 3.2216.0182 6.9976-.6774 9.4033-3.0224-.2027-.0868-.4104-.1585-.6022-.2695"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M19.3634 62.297c-.4735.8925-1.877 1.0785-2.832 1.1074-.5274.0154-1.058-.045-1.5395-.25-.894-.3822-.2403-1.1526.2322-1.5266.884-.7018 2.083-1.0513 3.2383-1.1217.114-.0072.2012-.0478.2752-.0993.846.2655.982 1.2193.6257 1.8904M39.1353 63.7074c-.7183.2857-1.607.0788-2.318-.0972-1.225-.3028-2.4647-1.2617-2.3147-2.656.0894-.0388.1756-.0948.2438-.1942 1.16-1.6788 4.4677-.7897 5.5096.6697.7194 1.008-.38 1.984-1.1207 2.2777"
			}), r.a.createElement("path", {
				fill: "#C18D42",
				d: "M17.2218 28.842c-.2698-1.599-.862-3.239-2.209-4.0722-1.519-.9397-1.5314 2.7022-1.4284 3.646.1773 1.6212.7036 4.1546 2.031 4.9962 1.0735.6814 1.7476-.4387 1.9068-1.9332.105-.9777-.1392-1.678-.3004-2.6368-.3327-1.9776.2232 1.3268 0 0"
			}), r.a.createElement("path", {
				fill: "#FF8717",
				d: "M15.5475 24.681c1.747.664 2.8352 2.0178 3.3196 3.9672.3962 1.5937.7234 3.6126-.1366 4.959 1.6953.081 3.8534-.3464 3.6123-2.602 1.339-1.9475-4.229-7.018-6.7952-6.3243M33.6698 32.7516c-.407-.451.364.404 0 0"
			}), r.a.createElement("path", {
				fill: "#C18D42",
				d: "M35.796 29.1142c-.1635.7146-.323 1.4594-.211 2.192.178 1.1545.9577 1.6425 1.872 1.0695 1.2238-.7655 1.577-2.3845 1.9186-3.693.1864-.7164.529-3.6248-.9526-2.9716-1.4423.6354-2.308 2.0174-2.627 3.4032-.238 1.0394.3698-1.6104 0 0"
			}), r.a.createElement("path", {
				fill: "#FF8717",
				d: "M35.3533 32.5596c-1.0047-1.2304-.5965-3.2887-.0174-4.64.6404-1.496 1.6748-2.6295 3.2115-3.037-.0695-.041-.136-.083-.2138-.114-1.9296-.775-4.9295 1.584-5.8667 3.0262-.6885 1.0606-2.0135 2.6206.8063 4.2594.7018.4085 1.3024.687 2.08.5054"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M32.8514 39.097c-.577.676-1.6076.6748-2.4273.0963-1.264-.8917-1.1062-3.3024.122-4.234.7017-.532 1.6705-.4205 2.1302.1645 1.53 1.946.6833 3.3772.1752 3.973"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M30.755 38.0938c-.2703-.432-.2692-1.2056-.039-1.8203.3575-.9478 1.322-.8296 1.6942.092.213.5263.1684 1.252-.0664 1.597-.7778 1.1484-1.3505.512-1.5888.1313"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M24.71 39.009c-.6662.8048-2.161.7863-3.1096.0826-1.5367-1.1425-1.2565-2.9377-.0257-3.8424.9816-.721 1.9472-.897 2.8605-.1542 1.636 1.3315 1.2372 2.751.2748 3.914"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M21.79 38.1136c-.322-.4-.3135-1.296-.0326-1.8656.4566-.922 1.1752-.7538 1.537-.016.2884.589.359 1.1686.0612 1.7166-.5324.982-1.0995.7425-1.5656.165"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M24.5598 40.2202c.8506 1.8878 3.3605 1.9104 3.9825-.235.0587-.206-.3954-.314-.471-.3215-1.1-.0954-2.188-.0502-3.278.1646-.637.1256.158.5627.459.5024.9212-.182 1.8433-.2474 2.7733-.167-.157-.1068-.314-.2136-.471-.3216-.14.4862-.3785.834-.7293 1.098-.5525.4157-1.0443-.1445-1.3017-.716-.147-.3266-1.094-.2915-.9638-.0038"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M22.5907 41.495c1.505 1.488 4.0743 1.4078 5.0584-.571-.3263-.06-.6527-.121-.98-.182-.2436 2.3982 3.9335 2.359 4.8708.653.1018-.186-.8275-.4596-.9802-.1822-.556 1.1467-1.526 1.0504-2.9105-.2888.029-.284-.8573-.428-.98-.182-.497 1.0008-1.7188 2.179-3.194.7215-.1837-.182-1.14-.221-.8843.0315M19.5653 46.516c-.473 6.7128 8.6924 4.2055 5.1774-.548-.6672-.903-.7844.151-.5202.7218.5274 1.1447.4853 2.1653-.5644 2.844-1.2192.7874-2.6945.0107-2.9834-1.216-.112-.5384-.144-1.082-.0936-1.6312.0237-.3453-.993-.4877-1.0157-.1705M29.6923 44.8475c-1.689 1.2247-1.5924 4.6386.8496 4.7633 1.13.0575 2.2874-.3435 3.0557-1.1673.3415-.3653 1.5518-2.4732.5793-2.709-1.2043-.293-1.2043 3.92-3.9756 3.001-.9725-.3227-.5812-1.1573-.5253-1.9048.0163-.218 1.4523-3.0258.0163-1.9832"
			})))
		},
		"./src/reddit/icons/svgs/Hamster2/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 53 67"
			}, r.a.createElement("g", {
				fill: "none",
				fillRule: "evenodd"
			}, r.a.createElement("path", {
				fill: "#FFF",
				d: "M9.5927 33.2517c.829 1.0475-1.9245 5.7044-2.2983 5.6247-7.91-1.6942-2.065-11.142 2.2983-5.6247z"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M7.2853 38.8738c-7.8952-1.69-2.0557-11.1393 2.297-5.625.8272 1.047-.4264.8297-.9997.3446-1.1508-.97-2.3416-1.2604-3.462-.3077-1.3005 1.107-.879 3.0184.443 3.748.585.3038 1.202.5194 1.8517.6446.4058.0876.243 1.275-.13 1.1955"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M50.0333 34.034c-.1167 1.5037-.772 2.978-1.8564 3.877-.4812.3997-3.1335 1.7-3.25.3792-.1457-1.6356-1.7525-4.3107-.3047-6.062 1.7012-2.06 5.6625-1.444 5.411 1.8057z"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M38.8415 2.2205c-2.7586-.8015-5.949.661-6.538 3.11-.2237.9345-.6645 1.321-1.5794 1.4452-2.011.2734-3.7602 1.1195-5.2615 2.444-1.0375.9146-1.5946 1.9584-1.5627 3.4333.0614 2.7088 1.3876 4.9268 2.5785 7.2106.29.5554 2.6078-.8114 1.4285-.1056-.7922-2.4615-1.5422-4.6733-2.2054-6.91-.2734-.9256.0677-1.8078.9468-2.2552 1.569-.7964 3.2084-1.4625 4.8157-2.188.7615-.3443 1.196-.0734 1.633.5976 1.0553 1.6128 2.5707 2.623 4.597 2.397 2.1033-.2337 3.2852-1.6254 3.9266-3.4992.8624-2.515-.3425-4.9727-2.779-5.6797"
			}), r.a.createElement("path", {
				fill: "#FF8717",
				d: "M33.9315 6.857c-.224-1.3784.7095-2.492 2.3388-2.7883 1.7852-.3266 3.275.536 3.5755 2.0682.317 1.614-.8404 3.5347-2.301 3.8197-1.6092.3153-3.2938-1.13-3.6133-3.0997"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M14.7982 12.4437c-3.36-1.0258-5.3778.7637-5.8082 4.1436-.4748 3.739.8778 7.9344 4.5652 9.1366 3.8478 1.2526 7.5847-1.9496 8.297-5.7303.5894-3.133-4.5797-6.8506-7.054-7.55-4.0343-1.2325 1.959.5532 0 0M43.3042 13.0588c-2.8393-2.6964-7.8367.3357-9.7212 2.666-.6773.836-1.1967 1.7795-1.5465 2.7743-.455 1.288.3498 1.111.4866 2.2034.25 1.9786 2.771 3.9682 4.837 4.244 6.156.8204 10.0262-8.0023 5.6943-12.1256.1683.161.3367.321.5063.482-.0855-.0817-.171-.1634-.2564-.244-2.567-2.4376.9047.8605 0 0M16.2644 58.021c-.2208-.059-.3958.012-.5237.136-.0012 0-.0012-.0012-.0024-.0012-1.8447.1275-4.5607.9865-5.54 2.7936-1.051 1.9405.87 3.2314 2.5398 3.4432 1.8366.2334 4.5785-.4055 5.2513-2.4435.519-1.57-.0387-3.478-1.725-3.928M35.8236 58.9218c-.272-.045-.582.0543-.705.3726-1.7005 4.3674 6.9575 7.0378 8.5576 3.0546 1.5267-3.7998-5.2473-5.567-7.8526-3.4272"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M43.621 29.1977c-4.9592-11.951-21.4957-14.9246-30.207-6.0505-4.0707 4.1463-5.603 10.5374-6.1882 12.468-1.8397 6.067-2.0003 13.0306 1.016 18.767 5.1085 9.718 21.2816 12.0886 30.4837 7.0343 11.767-6.463 8.538-23.4607 4.4034-33.4042.3046.7327.608 1.4654.9127 2.198-.1402-.338-.2804-.6746-.4207-1.0126-2.7626-6.6584 1.5146 3.6495 0 0"
			}), r.a.createElement("path", {
				fill: "#FF8717",
				d: "M25.8506 19.7317c4.5594 0 10.944 2.8204 13.7762 6.3902 3.3375 4.2063 4.8178 10.7118 5.579 15.935.639 4.3973-.6212 10.5736-2.9403 14.4188-2.7558 4.57-8.6988 5.8202-13.6222 5.792-6.0627-.0332-13.131-.6814-17.1098-5.8996-3.5793-4.6956-4.179-10.8425-3.2382-16.523.518-3.1216 1.329-6.7118 2.58-9.6297 2.7202-6.3415 7.4425-10.4838 14.9753-10.4838"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M45.9425 45c.03-.6952.008-1.3605-.044-2l.044 2zM39.8434 58.144c-1.7227-.9698-3.0188-2.7136-3.2686-4.6547-.0858-.6677-.0512-1.3455-.0166-2.017.0615-1.2292.1293-2.4824.5904-3.6243.5277-1.3063 1.5267-2.3634 2.504-3.3865.593-.622 1.1872-1.2443 1.7815-1.8665.9376-.9825 2.1633-2.032 3.4645-1.8475-.5315-3.088-1.332-6.453-2.632-9.4792-1.3524 2.5355-3.8935 4.9027-6.971 3.5964-.6636-.2807-1.131-.4704-1.7266-.88-1.1105-.927-2.467-1.19-4.069-.788-.3485.377-.679.7677-.9914 1.1736-.6647.6525-1.4908 1.2292-2.4937.956-2.2913-.6272-3.8283-3.676-6.5793-1.754-1.1182.7816-2.5 1.959-3.9896 1.8893-2.5832-.12-4.3725-1.3758-5.433-3.4472-1.0002 2.5544-1.5497 5.5198-1.989 8.116-.0525.316-.082.6386-.1255.9585.803-.0443 1.606-.0165 2.3464.2743.8734.3415 1.57 1.0066 2.2425 1.6566 1.0874 1.0508 2.2016 2.137 2.819 3.5116.5648 1.2545.6737 2.6594.6916 4.0315.0193 1.3633-.0435 2.7252-.187 4.0796-.169 1.6085-.612 3.4193-2.0248 4.2097 4.087 2.9553 9.735 3.389 14.7134 3.4156 4.1523.0226 9.0192-.8486 12.12-3.7862-.2614-.1088-.529-.1986-.7762-.3377"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M16.6775 61.5205c-.5682 1.19-2.2523 1.438-3.3982 1.4765-.633.0205-1.2697-.0602-1.8475-.3336-1.0727-.5094-.2883-1.5367.2787-2.0352 1.0607-.9357 2.4997-1.4018 3.886-1.4957.137-.0097.2414-.064.3303-.1325 1.015.354 1.1784 1.6258.7507 2.5205M41.3178 62.8585c-.838.2857-1.875.079-2.7043-.097-1.429-.303-2.8756-1.2618-2.7005-2.656.1043-.039.2048-.095.2843-.1944 1.3534-1.6787 5.2124-.7896 6.428.6698.8393 1.008-.4433 1.984-1.3075 2.2777"
			}), r.a.createElement("path", {
				fill: "#C18D42",
				d: "M14.4914 18.1648c-.3373-1.9542-1.0774-3.9587-2.7615-4.977-1.8987-1.1487-1.9142 3.3025-1.7855 4.4562.2217 1.9814.8796 5.0777 2.5387 6.1064 1.342.8328 2.1846-.5362 2.3836-2.363.131-1.1948-.174-2.0508-.3754-3.2226-.416-2.417.279 1.6217 0 0"
			}), r.a.createElement("path", {
				fill: "#FF8717",
				d: "M11.8985 13.079c1.9966.812 3.2402 2.4664 3.7938 4.849.4527 1.9478.8267 4.4154-.1562 6.061 1.9376.099 4.404-.4234 4.1285-3.1804 1.5303-2.38-4.8333-8.5774-7.766-7.7295M35.0207 23.1353c-.407-.451.364.404 0 0"
			}), r.a.createElement("path", {
				fill: "#C18D42",
				d: "M38.2093 19.4974c-.2045.9188-.4038 1.8764-.264 2.8182.2225 1.4844 1.197 2.112 2.34 1.3752 1.5298-.9843 1.9712-3.066 2.3983-4.748.233-.9213.6613-4.6607-1.1908-3.8208-1.803.8168-2.885 2.5937-3.2835 4.3754-.2977 1.3363.462-2.0706 0 0"
			}), r.a.createElement("path", {
				fill: "#FF8717",
				d: "M37.7916 23.9292c-1.2917-1.538-.767-4.111-.0223-5.8.8235-1.87 2.1534-3.287 4.1292-3.7963-.0894-.0513-.175-.1037-.275-.1424-2.481-.9687-6.3378 1.98-7.5428 3.7826-.8853 1.3257-2.5888 3.2757 1.0366 5.3243.9024.5106 1.6746.859 2.6743.6317"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M34.0283 31.3767c-.721.8113-2.0094.81-3.034.1158-1.58-1.07-1.383-3.963.1523-5.081.877-.6384 2.088-.5045 2.6627.1976 1.9127 2.3352.854 4.0527.219 4.7677"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M31.106 29.4776c-.2703-.432-.2692-1.2056-.039-1.8204.3574-.9477 1.322-.8296 1.6942.092.213.5264.1684 1.252-.0664 1.597-.7778 1.1484-1.3506.5122-1.5888.1314"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M23.8934 30.2714c-.7994.9656-2.5933.9435-3.7315.099-1.844-1.371-1.508-3.5252-.031-4.6108 1.178-.8653 2.3368-1.0765 3.4327-.185 1.9633 1.5977 1.4846 3.301.3297 4.6968"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M20.141 29.4974c-.322-.4-.3135-1.2962-.0326-1.8657.4566-.922 1.1752-.7537 1.537-.0158.2884.5886.359 1.1683.061 1.7164-.5322.982-1.0993.7424-1.5654.165"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M23.9138 33.604c1.0632 1.8878 4.2007 1.9104 4.9782-.235.0733-.206-.4943-.314-.5887-.3215-1.375-.0955-2.735-.0502-4.0976.1646-.796.1257.1975.5628.574.5025 1.1512-.1822 2.304-.2475 3.4664-.167-.196-.1068-.3923-.2136-.5886-.3216-.175.486-.4732.834-.9117 1.0977-.6905.4157-1.3054-.1445-1.627-.716-.184-.3266-1.3676-.2914-1.205-.0038"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M20.9512 35.318c1.8397 2.232 4.9797 2.112 6.1826-.8564-.399-.09-.798-.1816-1.198-.273-.2976 3.5973 4.8077 3.5387 5.9532.9794.1245-.279-1.0113-.6892-1.198-.273-.6794 1.72-1.8652 1.5755-3.5572-.4334.0354-.426-1.048-.642-1.198-.273-.6075 1.5012-2.1007 3.2685-3.9037 1.0823-.2244-.2732-1.393-.3318-1.0808.047M44.4978 32.213c1.7332-2.056 5.7836-1.429 5.5353 1.821-.115 1.5038-.7808 2.977-1.8867 3.8733-.4907.3984-3.198 1.692-3.3206.3704-.1534-1.6365 4.8643-1.0204 4.2203-4.8223-.2264-1.3343-1.284-.9385-2.1835-.974-.262-.0102-3.8398 1.4795-2.3647-.2684"
			})))
		},
		"./src/reddit/icons/svgs/Help/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 16 16",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				fill: "inherit",
				d: "M8.622 10.616c.078.08.14.175.183.28.044.105.07.218.07.332 0 .237-.087.456-.253.62-.167.168-.385.255-.622.255-.236 0-.455-.087-.62-.254-.167-.166-.255-.385-.255-.622 0-.114.027-.227.07-.332.044-.105.105-.2.184-.28.087-.088.174-.15.288-.193.324-.13.71-.052.954.193zm-.205-6.242c1.595 0 2.466.807 2.466 1.92 0 .976-.556 1.448-1.238 1.816-.615.317-.83.518-.904.898 0 .004-.034.207-.036.21-.034.126-.087.244-.18.336-.14.14-.323.21-.524.21-.097 0-.192-.017-.29-.052-.087-.035-.165-.088-.235-.158-.14-.14-.22-.333-.22-.533 0-.11.02-.188.074-.348.16-.472.55-.896 1.056-1.17.577-.327.84-.558.84-1.07 0-.42-.357-.715-.987-.715-.496 0-.996.218-1.39.52-.26.2-.62.202-.858-.02l-.05-.05c-.313-.29-.27-.787.075-1.04.603-.444 1.394-.753 2.4-.753zM8 13.25c-2.895 0-5.25-2.355-5.25-5.25S5.105 2.75 8 2.75 13.25 5.105 13.25 8 10.895 13.25 8 13.25M8 1C4.14 1 1 4.14 1 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7"
			}))
		},
		"./src/reddit/icons/svgs/ImagePost/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1pAYDrDlDFEJk994qhxbYj"
			}
		},
		"./src/reddit/icons/svgs/ImagePost/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/ImagePost/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(s.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				d: "M16,2H4A2,2,0,0,0,2,4V16a2,2,0,0,0,2,2H16a2,2,0,0,0,2-2V4A2,2,0,0,0,16,2Zm0,14H10.14a.49.49,0,0,1,.05-.48l3.15-4.26a.5.5,0,0,1,.38-.2.53.53,0,0,1,.4.17L16,13.35ZM4,13.51,7.26,8.82a.54.54,0,0,1,.42-.21.5.5,0,0,1,.41.23l2.85,4.34L8.84,16H4Zm10.4-7.1a1.7,1.7,0,1,1-1.7-1.7A1.7,1.7,0,0,1,14.4,6.41Z"
			}))
		},
		"./src/reddit/icons/svgs/Info/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M10,8.5 C10.553,8.5 11,8.948 11,9.5 L11,13.5 C11,14.052 10.553,14.5 10,14.5 C9.447,14.5 9,14.052 9,13.5 L9,9.5 C9,8.948 9.447,8.5 10,8.5 Z M10.7002,5.79 C10.8012,5.89 10.8702,6 10.9212,6.12 C10.9712,6.24 11.0002,6.37 11.0002,6.5 C11.0002,6.57 10.9902,6.63 10.9802,6.7 C10.9712,6.76 10.9502,6.82 10.9212,6.88 C10.9002,6.94 10.8702,7 10.8302,7.05 C10.7902,7.11 10.7502,7.16 10.7002,7.21 C10.6602,7.25 10.6102,7.29 10.5512,7.33 C10.5002,7.37 10.4402,7.4 10.3812,7.42 C10.3202,7.45 10.2612,7.47 10.1902,7.48 C10.1312,7.49 10.0602,7.5 10.0002,7.5 C9.7402,7.5 9.4802,7.39 9.2902,7.21 C9.1102,7.02 9.0002,6.77 9.0002,6.5 C9.0002,6.37 9.0302,6.24 9.0802,6.12 C9.1312,5.99 9.2002,5.89 9.2902,5.79 C9.5202,5.56 9.8702,5.46 10.1902,5.52 C10.2612,5.53 10.3202,5.55 10.3812,5.58 C10.4402,5.6 10.5002,5.63 10.5512,5.67 C10.6102,5.71 10.6602,5.75 10.7002,5.79 Z M10,16 C6.691,16 4,13.309 4,10 C4,6.691 6.691,4 10,4 C13.309,4 16,6.691 16,10 C16,13.309 13.309,16 10,16 M10,2 C5.589,2 2,5.589 2,10 C2,14.411 5.589,18 10,18 C14.411,18 18,14.411 18,10 C18,5.589 14.411,2 10,2"
			})))
		},
		"./src/reddit/icons/svgs/Link/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "M18.4773727,1.51993937 C19.4600354,2.50135191 20.0013751,3.80656808 20.0013751,5.19554812 C20.0013751,6.58577837 19.4600354,7.89099453 18.4773727,8.87240707 C17.9885417,9.35998782 17.1984109,9.35998782 16.7095799,8.87240707 C16.2207489,8.38357611 16.2207489,7.59094484 16.7095799,7.10461429 C17.2196644,6.59452982 17.500961,5.91691759 17.500961,5.19554812 C17.500961,4.47542886 17.2196644,3.79781663 16.7095799,3.28773215 C15.6569056,2.23755822 13.9453721,2.23755822 12.8926978,3.28773215 L8.62324066,7.55843946 C7.57181653,8.6111138 7.57181653,10.3226473 8.62324066,11.3753216 C9.11207162,11.8629024 9.11207162,12.6555336 8.62324066,13.1431144 C8.37945029,13.3869048 8.05939728,13.509425 7.73934427,13.509425 C7.41929127,13.509425 7.09923826,13.3869048 6.85544788,13.1431144 C4.82886225,11.1152785 4.82886225,7.81723232 6.85544788,5.79064668 L11.124905,1.51993937 C13.1502404,-0.505396058 16.4495368,-0.507896472 18.4773727,1.51993937 Z M11.3753215,6.8540728 C11.8641524,6.36524184 12.6542833,6.36524184 13.1431142,6.8540728 C15.1696999,8.88065844 15.1696999,12.1799549 13.1431142,14.2065405 L8.87240693,18.4772478 C7.89099439,19.4586603 6.58452801,20 5.19679818,20 C3.80781814,20 2.50135177,19.4586603 1.51993923,18.4772478 C-0.50664641,16.4506622 -0.50664641,13.1513657 1.51993923,11.1247801 C2.00877019,10.6359491 2.80015125,10.6359491 3.28773201,11.1247801 C3.77656297,11.6136111 3.77656297,12.4037419 3.28773201,12.8925729 C2.23505767,13.9452472 2.23505767,15.6567807 3.28773201,16.709455 C4.34040635,17.7621294 6.05193981,17.7621294 7.10461415,16.709455 L11.3753215,12.4387477 C12.4279958,11.3860734 12.4279958,9.67453992 11.3753215,8.62186558 C10.8864905,8.13303462 10.8864905,7.34290376 11.3753215,6.8540728 Z"
			})))
		},
		"./src/reddit/icons/svgs/LiveChat/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);

			function s() {
				return (s = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", s({
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 16 16",
				stroke: "white"
			}, e), r.a.createElement("path", {
				d: "M1.17567 6.90708L1.17579 6.9071L1.17765 6.89503C1.61505 4.05191 3.95864 1.69386 6.90278 1.17649C11.5294 0.445398 15.5469 4.48817 14.7445 9.01081L14.7433 9.01787L14.7422 9.02495C14.3037 11.8753 11.9552 14.2237 9.10488 14.6623L9.10486 14.6621L9.09283 14.6642C7.41037 14.9568 5.80338 14.5919 4.48582 13.7867L4.249 13.642L3.98282 13.7206L1.45885 14.4663L2.19817 12.0209L2.27918 11.7529L2.13322 11.5141C1.31702 10.1785 0.886321 8.57086 1.17567 6.90708Z",
				strokeWidth: "1.25",
				strokeMiterlimit: "10",
				strokeLinecap: "square"
			}), r.a.createElement("path", {
				d: "M8.00018 12.3201C10.386 12.3201 12.3202 10.3859 12.3202 8.00005C12.3202 5.61418 10.386 3.68005 8.00018 3.68005C5.61431 3.68005 3.68018 5.61418 3.68018 8.00005C3.68018 10.3859 5.61431 12.3201 8.00018 12.3201Z",
				strokeWidth: "1.25",
				strokeMiterlimit: "10"
			}), r.a.createElement("path", {
				d: "M8.00008 9.92008C9.06047 9.92008 9.92008 9.06047 9.92008 8.00008C9.92008 6.93969 9.06047 6.08008 8.00008 6.08008C6.93969 6.08008 6.08008 6.93969 6.08008 8.00008C6.08008 9.06047 6.93969 9.92008 8.00008 9.92008Z",
				strokeWidth: "1.25",
				strokeMiterlimit: "10"
			}))
		},
		"./src/reddit/icons/svgs/MarkdownMode/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 208 128"
			}, r.a.createElement("rect", {
				width: "198",
				height: "118",
				x: "5",
				y: "5",
				ry: "10",
				stroke: "currentColor",
				strokeWidth: "10",
				fill: "none"
			}), r.a.createElement("path", {
				d: "M30 98v-68h20l20 25 20-25h20v68h-20v-39l-20 25-20-25v39zM155 98l-30-33h20v-35h20v35h20z"
			}))
		},
		"./src/reddit/icons/svgs/Pencil/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("title", {
				id: `${e.title}-title`
			}, e.title), r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "M15.75,7.834625 L12,4.084625 L12.808,3.276625 C13.8435,2.241125 15.5225,2.241125 16.558,3.276625 C17.5935,4.312125 17.5935,5.991125 16.558,7.026625 L15.75,7.834625 Z M11.366,5 L15.116,8.75 L7.25,16.616 L3.5,12.866 L11.366,5 Z M2.5035,13.5 L6.1125,17.109 L1,18.6125 L2.5035,13.5 Z"
			})))
		},
		"./src/reddit/icons/svgs/Plus/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				version: "1.1"
			}, r.a.createElement("g", {
				stroke: "none"
			}, r.a.createElement("g", {
				transform: "translate(-34.000000, -136.000000)",
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M45.2,147.2 L48.8,147.2 C49.46272,147.2 50,146.66272 50,146 C50,145.33728 49.46272,144.8 48.8,144.8 L45.2,144.8 L45.2,141.2 C45.2,140.53728 44.66272,140 44,140 C43.33728,140 42.8,140.53728 42.8,141.2 L42.8,144.8 L39.2,144.8 C38.53728,144.8 38,145.33728 38,146 C38,146.66272 38.53728,147.2 39.2,147.2 L42.8,147.2 L42.8,150.8 C42.8,151.46272 43.33728,152 44,152 C44.66272,152 45.2,151.46272 45.2,150.8 L45.2,147.2 Z"
			}))))
		},
		"./src/reddit/icons/svgs/Poll/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M2.1952,13.9279 C2.9452,13.9279 3.5382,14.3119 3.8382,14.8939 L2.8962,15.3249 C2.7702,15.0489 2.4882,14.8519 2.1232,14.8519 C1.6192,14.8519 1.2232,15.3189 1.2232,15.9489 C1.2232,16.5849 1.6252,17.0409 2.1172,17.0409 C2.4882,17.0409 2.7772,16.8369 2.9262,16.5369 L3.9162,16.8909 C3.6102,17.5559 2.9802,17.9639 2.1952,17.9639 C1.0492,17.9639 0.1202,17.0759 0.1202,15.9489 C0.1202,14.8279 1.0492,13.9279 2.1952,13.9279 Z M11.5004,14.5 C12.3294,14.5 13.0004,15.171 13.0004,16 C13.0004,16.829 12.3294,17.5 11.5004,17.5 L6.5004,17.5 C5.6714,17.5 5.0004,16.829 5.0004,16 C5.0004,15.171 5.6714,14.5 6.5004,14.5 L11.5004,14.5 Z M1.8953,8.0003 C2.8063,8.0003 3.5503,8.2643 3.5503,9.0313 C3.5503,9.3433 3.3523,9.5893 3.0763,9.7813 C3.4483,9.9553 3.7243,10.2253 3.7243,10.6623 C3.7243,11.5179667 2.93757778,11.8598556 2.22929983,11.8952023 L2.1053,11.8983 L0.3723,11.8983 L0.3723,8.0003 L1.8953,8.0003 Z M18.5004,8.5 C19.3294,8.5 20.0004,9.171 20.0004,10 C20.0004,10.829 19.3294,11.5 18.5004,11.5 L6.5004,11.5 C5.6714,11.5 5.0004,10.829 5.0004,10 C5.0004,9.171 5.6714,8.5 6.5004,8.5 L18.5004,8.5 Z M1.8623,8.8693 L1.4753,8.8693 L1.4753,11.0283 L1.9843,11.0283 C2.3013,11.0283 2.5853,10.7603 2.5853,10.4623 C2.5853,10.0713909 2.27786198,9.92097769 2.01460128,9.89686048 L1.9373,9.8933 L1.9373,9.7853 C2.0923,9.7853 2.4353,9.6783 2.4353,9.3333 C2.4353,8.9793 2.1923,8.8693 1.8623,8.8693 Z M2.783,1.9997 L4.096,5.8977 L2.963,5.8977 C2.963,5.8977 2.147,3.3737 2.063,3.0137 L2.063,3.0137 L2.039,3.0137 C1.955,3.3737 1.127,5.8977 1.127,5.8977 L1.127,5.8977 L-2.25597319e-13,5.8977 L1.319,1.9997 L2.783,1.9997 Z M15.5004,2.5 C16.3294,2.5 17.0004,3.171 17.0004,4 C17.0004,4.829 16.3294,5.5 15.5004,5.5 L6.5004,5.5 C5.6714,5.5 5.0004,4.829 5.0004,4 C5.0004,3.171 5.6714,2.5 6.5004,2.5 L15.5004,2.5 Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/RadioOff/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_11Rht_b1e-kmk12gkz7Lug"
			}
		},
		"./src/reddit/icons/svgs/RadioOff/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/RadioOff/index.m.less"),
				a = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", c({}, e, {
				className: Object(s.a)(a.a.icon, e.className),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}), r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M10,1.66666667 C5.39762708,1.66666667 1.66666667,5.39762708 1.66666667,10 C1.66666667,14.6023729 5.39762708,18.3333333 10,18.3333333 C14.6023729,18.3333333 18.3333333,14.6023729 18.3333333,10 C18.3333333,5.39762708 14.6023729,1.66666667 10,1.66666667 Z M10,0 C15.5228475,-1.01453063e-15 20,4.4771525 20,10 C20,15.5228475 15.5228475,20 10,20 C4.4771525,20 6.76353751e-16,15.5228475 0,10 C-6.76353751e-16,4.4771525 4.4771525,1.01453063e-15 10,0 Z"
			})))
		},
		"./src/reddit/icons/svgs/RadioOn/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);

			function s() {
				return (s = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", s({}, e, {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}), r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M10,6.66666667 C8.15905083,6.66666667 6.66666667,8.15905083 6.66666667,10 C6.66666667,11.8409492 8.15905083,13.3333333 10,13.3333333 C11.8409492,13.3333333 13.3333333,11.8409492 13.3333333,10 C13.3333333,8.15905083 11.8409492,6.66666667 10,6.66666667 Z M10,0 C15.5228475,-1.01453063e-15 20,4.4771525 20,10 C20,15.5228475 15.5228475,20 10,20 C4.4771525,20 6.76353751e-16,15.5228475 0,10 C-6.76353751e-16,4.4771525 4.4771525,1.01453063e-15 10,0 Z"
			})))
		},
		"./src/reddit/icons/svgs/Replay/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);

			function s() {
				return (s = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", s({}, e, {
				viewBox: "13 12 23 23",
				xmlns: "http://www.w3.org/2000/svg"
			}), r.a.createElement("g", null, r.a.createElement("path", {
				d: "M32.5 23.3c-.7 0-1.2.5-1.2 1.2 0 4-3.2 7.2-7.2 7.2s-7.2-3.2-7.2-7.2c0-3.6 2.7-6.6 6.2-7.1v1.7c0 .2.1.4.3.5.1 0 .2.1.3.1.1 0 .3 0 .4-.1l3.6-3c.1-.1.2-.3.2-.5s-.1-.3-.2-.5l-3.7-3c-.2-.1-.4-.2-.6-.1-.2.1-.4.3-.4.6V15c-4.8.5-8.6 4.6-8.6 9.5 0 5.3 4.3 9.6 9.6 9.6s9.6-4.3 9.6-9.6c.1-.7-.5-1.2-1.1-1.2",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Search/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				d: "M15.59,13.91l2.78,2.69a1.25,1.25,0,1,1-1.74,1.8l-2.82-2.73a8,8,0,1,1,1.78-1.76ZM14.64,9.2A5.45,5.45,0,1,0,9.2,14.64,5.45,5.45,0,0,0,14.64,9.2Z"
			}))
		},
		"./src/reddit/icons/svgs/Send/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				id: e.id,
				viewBox: "0 0 18 18",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M17.98 8.87c-.012-.093-.03-.182-.062-.27-.017-.043-.034-.085-.055-.126-.013-.026-.02-.057-.034-.082l-.07-.1c-.018-.02-.04-.03-.055-.046-.073-.083-.158-.145-.252-.204-.032-.02-.053-.055-.088-.072L3.88 1.12c-.35-.176-.764-.158-1.096.05-.332.208-.534.576-.534.973V5c0 .507.33.954.81 1.097L9 7.857H3.375c-.175 0-.347.04-.503.12L.622 9.12c-.48.243-.724.8-.582 1.325.135.5.582.84 1.085.84.027 0 .054 0 .08-.003l1.045-.075v4.65c0 .396.202.764.534.972.18.112.386.17.59.17.173 0 .346-.04.505-.12l13.483-6.85c.08-.044.134-.075.184-.113.05-.038.092-.085.136-.13.012-.013.026-.022.037-.036.092-.107.147-.21.19-.32.013-.03.02-.06.03-.09.013-.045.033-.086.042-.132.008-.046.013-.09.017-.138 0-.023-.008-.043-.008-.063 0-.017.008-.03.008-.048 0-.032-.017-.058-.02-.09z"
			})))
		},
		"./src/reddit/icons/svgs/Shirt/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = function(e) {
				let {
					className: t
				} = e;
				return r.a.createElement("svg", {
					className: t,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", {
					fill: "inherit"
				}, r.a.createElement("path", {
					d: "M7 1.75a.486.486 0 01.487.4 2.574 2.574 0 005.085 0 .488.488 0 01.488-.4h1.583A.5.5 0 0115 1.9l3.951 4.09a.5.5 0 01-.006.7l-1.931 1.938a.5.5 0 01-.649.05l-1.482-1.084.007 10.156a.5.5 0 01-.5.5H5.385a.5.5 0 01-.5-.5l.007-10.156L3.7 8.626a.5.5 0 01-.677-.026L1.115 6.694a.5.5 0 01-.006-.7L5.06 1.9a.5.5 0 01.359-.153z"
				})))
			}
		},
		"./src/reddit/icons/svgs/SnooPosting/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 45 43"
			}, r.a.createElement("g", {
				fill: "none",
				fillRule: "evenodd"
			}, r.a.createElement("g", {
				fill: "#0DD3BB",
				transform: "translate(0 4)"
			}, r.a.createElement("ellipse", {
				cx: "25.492",
				cy: "22.2631",
				transform: "rotate(5 25.492 22.263)",
				rx: "17.6396",
				ry: "13.9883"
			}), r.a.createElement("ellipse", {
				cx: "19.3519",
				cy: "17.9699",
				transform: "rotate(5 19.352 17.97)",
				rx: "14.7297",
				ry: "16.0688"
			}), r.a.createElement("ellipse", {
				cx: "14.0251",
				cy: "27.7862",
				transform: "rotate(5 14.025 27.786)",
				rx: "8.4751",
				ry: "8.9243"
			}), r.a.createElement("ellipse", {
				cx: "11.808",
				cy: "17.4531",
				transform: "rotate(5 11.808 17.453)",
				rx: "10.7695",
				ry: "10.8575"
			}), r.a.createElement("ellipse", {
				cx: "12.1168",
				cy: "22.4429",
				transform: "rotate(5 12.117 22.443)",
				rx: "8.4751",
				ry: "8.9243"
			})), r.a.createElement("path", {
				fill: "#FFF",
				d: "M35.6875 31.5625c-1.3275 1.8696-6.7017 5.0483-8.7188 6.0313-2.0174.983-13.478 2.1465-15.625-.6876-1.5625-2.0624-.9687-4.625 1-6.1562C9.6563 29.2812 8.125 27.8437 7 24.9062c-.0872-.2277-1.1015-1.763-.875-1.7812l.9375-4.0313c.8158-2.9308 4.2118-5.1638 6.7992-6.5715 2.3198-1.2615 4.9067-1.934 7.5113-2.1714 2.1052-.192 4.259-.101 6.277.554 2.0182.6552 4.2956 1.063 5.5063 2.8765 0 0 1.5532 3.6305 1.6736 5.5487.1204 1.9177-2.0402 6.1206-2.0402 6.1206"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M31.5665 34.5708c.6293 1.944.9 4.0143.794 6.0635 0 0-.473 1.3654-6.7204 1.3654-6.2478 0-7.6077-.7104-7.6077-.7104.047-1.224.0518-2.4493.014-3.6732-.0028-.097.0414-.2356.13-.2062l-.1555-7.319 12.5354-2.0634c.4433.252.8525.5696 1.211.9412l-.2007 5.6022z"
			}), r.a.createElement("path", {
				fill: "#FF0",
				d: "M34.0514 21.4676c-.3642.8707-.5738 1.8017-.8143 2.7188-.601 2.29-1.4044 4.5218-2.3967 6.658.1578.0357.3286.0014.4624-.0927.072.7567 1.0046 1.1686 1.678.8836.6734-.2846 1.071-1.0334 1.2235-1.777.0223-.1084.0407-.2198.0277-.33-.0202-.1737-.114-.3265-.1996-.477-.6817-1.2056-.9025-2.6877-.6033-4.0528.099-.4518.2715-.9186.6318-1.1878.2046-.1536.452-.2293.6975-.2872.6156-.146 1.2512-.198 1.8812-.154l.33-1.1467c.054-.1864.108-.3773.0993-.572-.0212-.4554-.393-.8263-.8058-.9727-.412-.1463-.8604-.115-1.2947-.0823"
			}), r.a.createElement("path", {
				fill: "#F15A24",
				d: "M12.322 21.7194c.061.3407.127.693.3168.977.3034.4517.85.6324 1.3573.785.3797.1136.7785.2284 1.165.141.2643-.0598.5012-.2104.725-.3697.61-.433 1.1792-.9615 1.5326-1.6395.3962-.7593.4926-1.684.2625-2.5148-.0912-.3294-.2458-.6615-.524-.843-.2292-.1494-.5564-.2205-.6293-.4927-.1057-.3946-1.938-.4537-2.25-.4202-.474.051-.939.1728-1.2797.5403-.9068.9784-.8953 2.613-.676 3.8366M24.194 19.0418c.0644.3482.1334.708.3344.998.3193.462.8963.6468 1.431.8023.4005.1164.8212.234 1.2286.1447.2793-.0614.529-.2154.7647-.3776.644-.443 1.244-.983 1.617-1.6756.4174-.776.5195-1.7205.2768-2.5694-.0964-.3366-.2596-.6762-.5526-.8614-.242-.1528-.587-.2255-.664-.5037-.1117-.4033-2.0443-.464-2.3736-.4297-.4998.052-.9902.1766-1.3498.5523-.9564 1-.9442 2.67-.7126 3.9202"
			}), r.a.createElement("path", {
				fill: "#CCC",
				d: "M35.9408 20.9708c.222.0064.4462.0053.6533.066.4068.1196.9188.5786.945-.1845.007-.1902.012-.3904-.0708-.56-.122-.251-.5983-.9602-.824-1.087-.1087-.061-.236-.0694-.359-.073-.3063-.0092-.613.0014-.9182.0315-.9906.0986-.7374 1.4513.01 1.725.177.0647.3693.0764.5638.082"
			}), r.a.createElement("path", {
				fill: "#FF7BAC",
				d: "M37.8215 19.8532c-.0306.0467-.0694.0968-.123.099-.0946.0034-.1258-.128-.1816-.2085-.0644-.0938-.1824-.1258-.29-.1506-.4784-.112-1.163-.1415-1.5974-.3738-.4688-.251-.4095-.3117-.2434-.8975.178-.6268.4606-1.3722 1.071-1.6617 2.0532-.9728 2.1506 1.9814 1.3643 3.1932"
			}), r.a.createElement("path", {
				fill: "#FF0",
				d: "M30.808 32.959c.0077.0694.0343.1556.1004.1593-.0834-.0335-.1158.1122-.095.203.429.0508.8583.1012 1.2877.152.263.0313.5674.0482.752-.151.1304-.141.16-.3512.1825-.5462.032-.274.064-.548.0964-.822.0082-.0724.0135-.1552-.0336-.2086-.034-.0388-.087-.051-.137-.0588-.219-.0327-.446-.0064-.6532.075-.6713.2642-.6634-.6747-1.1966-.4688-.4516.1747-.346 1.279-.3035 1.6663"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M31.9858 34.3613c.3538.146.738.196 1.1182.2014 2.1213.03 4.1668-1.396 5.0646-3.4086.8978-2.0117.661-4.4994-.4998-6.3584-.514-.8238-1.3235-1.5857-2.2608-1.5168-.594.0433-1.1344.429-1.4745.9404-.3405.5112-.499 1.1347-.552 1.7558-.1233 1.4442.3143 2.9324 1.1923 4.053"
			}), r.a.createElement("path", {
				fill: "#F7E1CB",
				d: "M11.2195 30.4984l9.4083-2.7606 1.318 7.9058-7.4904 2.7607"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M12.7516 37.7683c.2136.2304.5864.1393.8525-.0207 1.096-.6588 1.5454-2.1516 1.337-3.4564-.108-.6758-.3805-1.3463-.877-1.792-.4966-.446-1.243-.6212-1.827-.3125-.402.212-.682.6167-.8776 1.041-.4437.9637-.5192 2.107-.206 3.1258.1683.548.462 1.0782.9255 1.388.4637.3095 1.1184.3464 1.543-.0195"
			}), r.a.createElement("g", null, r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M27.37 11.0563c-2.068-.6386-4.2747-.727-6.4318-.54-2.669.2313-5.8933.8336-7.6967 2.1168-.6986.4972-3.0193 1.2145-3.5257 3.1977"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M10.0543 14.9054c-1.561-.3985-3.317.0782-4.4594 1.2103-1.1422 1.132-1.726 2.906-1.237 4.4356.5752 1.8004 1.926 3.0712 2.306 3.275"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M10.0543 14.9054c-1.561-.3985-3.317.0782-4.4594 1.2103-1.1422 1.132-1.7258 2.906-1.237 4.4356.5756 1.8004 1.926 3.0712 2.306 3.275"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M11.823 29.9606c-2.7657-.9024-4.92-3.4455-5.3476-6.3126-.034-.2298.0103-.55.2428-.5677M33.1486 15.4973c.192.314.384.6286.576.9427.114.1872.2283.374.33.5677.5276 1.003.7084 2.182.5062 3.2958M35.8308 16.6844c-1.6376 4.9262-3.3644 9.8235-5.1785 14.688"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M35.671 17.0804c.2263-.288.586-.4587.9517-.4895.366-.0313.736.0692 1.0563.2483.2708.1508.515.364.6543.6404.1393.276.161.6202.0118.8913M38.3983 17.8874c-.6142 1.9982-1.3304 3.9652-2.145 5.891"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M37.245 21.08c.2485-.5347.1342-1.2158-.2747-1.641-.4093-.425-1.0872-.5678-1.6347-.3436-.1367.0562-.278.1512-.301.297"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M37.2275 21.501c.0044-.5535-.3094-1.0984-.791-1.374-.482-.2753-1.113-.2705-1.5904.012"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M34.2996 20.788c.7136-.389 1.6686-.2757 2.2706.269.2052.1856.376.4304.3964.706.006.0785-.0008.1578-.0196.2345M31.8127 33.921c.3626.1424.7564.1912 1.1458.1963 2.1737.0294 4.2697-1.3607 5.1896-3.3225.92-1.961.6773-4.386-.512-6.1982-.5268-.803-1.3562-1.5457-2.3166-1.4785-.6087.0423-1.1624.4184-1.511.9168-.3488.4983-.5113 1.106-.5655 1.7115-.1264 1.4077.322 2.8584 1.2216 3.9508M33.9912 29.3915l-1.467 4.0393M32.6352 33.0774c-.951.6286-1.8904 1.2738-2.8177 1.935"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M30.6496 31.0486l-.6455 4.1743c-.0058.0366-.0053.083.0385.099.044.0162.0833-.0547.0346-.0517"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M30.1422 33.367c.1982-.3278.4635-.6147.7748-.8386.078.1534.1257.3226.139.4943.287-.1218.5986-.183.9103-.1802-.3703.3692-.701.778-.9844 1.2173"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M31.195 33.0817c-.389.5013-.7464 1.0268-1.0695 1.5725.0302-.0257.0604-.0514.0902-.0775M30.7412 32.969c.0104.3634-.12.7275-.3766 1.0607M32.6658 33.0168c.1094-.676.1787-1.3585.2074-2.0422-.326.1956-.6525.3912-.979.5872-.1045.0627-.2386.1262-.3414.06-.063-.04-.091-.1166-.1135-.1874-.133-.4158-.2417-.8396-.3253-1.2682-.291.3247-.547.6807-.7626 1.0594"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M33.4372 28.176c-.177.4906-.354.9812-.5313 1.472-.285.7874-.5726 1.5822-1.0206 2.291M36.2456 21.1264c.048-.0176.0608-.0917.0218-.1244-.3043.6815-.5497 1.3883-.732 2.1112M30.4806 30.95c-.0843.2098-.1095.43-.074.6453M32.6366 25.235c-1.3602 1.8225-3.2855 3.1704-5.3524 4.1286-2.0672.958-4.284 1.55-6.5023 2.0763M30.348 27.747c.454.2455.8732.5552 1.24.9174M31.3832 34.1252c.6447 1.895.9225 3.913.8134 5.9105"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M20.2203 27.5033c.529 2.5225.9453 5.069 1.2474 7.6282.0048.042.0063.0925-.0276.1178-.0345.0253-.095-.029-.0603-.0536"
			}), r.a.createElement("path", {
				stroke: "#000",
				d: "M21.462 35.1753c-2.4317 1.1842-4.9882 2.113-7.614 2.7662-.0714.0177-.1587.031-.208-.023-.0494-.0544.038-.1667.0828-.1083",
				strokeLinecap: "round",
				strokeLinejoin: "round"
			}), r.a.createElement("path", {
				stroke: "#000",
				d: "M13.3965 36.9094l.6482 1.51c-.01-.0428-.0207-.086-.0312-.129",
				strokeLinecap: "round",
				strokeLinejoin: "round"
			}), r.a.createElement("path", {
				stroke: "#000",
				d: "M12.104 37.242c.219.2246.601.1358.8735-.0202 1.123-.6422 1.5835-2.0972 1.3698-3.369-.111-.659-.3898-1.3124-.8986-1.747-.5087-.4348-1.2736-.6054-1.872-.3045-.4118.2066-.6988.601-.8992 1.0147-.4546.9394-.532 2.054-.211 3.047.1723.5342.4733 1.051.9482 1.353.4753.3016 1.1462.3376 1.5813-.019M10.6766 30.3595c-.0715-.0158-.065.1064-.022.1655l.7927 1.0914c.011.0154.0276.0326.0457.0264.018-.006.0015-.0418-.01-.0268M10.6893 30.2222c3.1114-1.025 6.255-1.953 9.425-2.782.0814.1758.1628.352.2443.5274",
				strokeLinecap: "round",
				strokeLinejoin: "round"
			}), r.a.createElement("path", {
				stroke: "#000",
				d: "M17.6433 28.0588c-.2222-.2202-.246-.6037-.5073-.7755-.2244-.148-.522-.0737-.7792.0048-1.0368.3175-2.073.6346-3.11.952-.2287.07-.4843.163-.579.382-.1275.2944.111.6096.332.843M13.849 27.877c-.025-.1897.085-.3783.2402-.4906.1554-.1123.349-.1592.5393-.1816.302-.0364.678.0275.7848.3115M17.774 36.8926c-.1595-.0286-.2392.1064-.234.201.068 1.193.0596 2.3876-.0247 3.5806M27.3276 14.627c-1.155-.254-2.4348.1776-3.1982 1.0778-.763.9005-.975 2.23-.5294 3.3214.203.498.537.9487.9825 1.252.757.5157 1.7714.556 2.64.263.9157-.3095 1.7137-.983 2.115-1.8592.401-.8763.3797-1.9464-.108-2.7783-.4875-.8312-1.447-1.3828-2.412-1.3303",
				strokeLinecap: "round",
				strokeLinejoin: "round"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeWidth: ".5",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M15.604 17.5287c-.993-.5754-2.3376-.3743-3.2093.371-.872.745-1.2777 1.9505-1.1753 3.0903.038.4224.1422.845.359 1.2103.4368.7372 1.309 1.1618 2.168 1.1684.8592.007 1.6937-.3673 2.346-.924.2724-.2316.518-.497.7086-.799.465-.738.5666-1.6924.2675-2.511-.2992-.8188-.993-1.485-1.8255-1.7524"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M25.8734 23.061c.019.8443.036 1.706-.2144 2.513-.3128 1.0058-1.0497 1.8733-1.9936 2.347-.9442.4738-2.0827.547-3.0803.1982"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M24.826 27.045c-.909 1.0263-2.4282 1.5463-3.7262 1.098-.325-.1124-.682-.385-.5983-.7172-.305-.1123-.6554.132-.9616.024-.1132-.0405-.2045-.124-.2882-.21-.507-.519-.8602-1.1846-1.0054-1.894 1.3742.2257 2.797.237 4.147-.1035.6403-.1614 1.2614-.404 1.8365-.7284.2493-.1406 1.482-1.2717 1.6324-1.2287.3404.0972-.014 1.6884-.081 1.9398-.1798.6673-.4952 1.3003-.9554 1.82"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M24.826 27.045c-.909 1.0263-2.4282 1.5463-3.7262 1.098-.325-.1124-.682-.385-.5983-.7172-.305-.1123-.6554.132-.9616.024-.1132-.0405-.2045-.124-.2882-.21-.507-.519-.8602-1.1846-1.0054-1.894 1.3742.2257 2.797.237 4.147-.1035.6403-.1614 1.2614-.404 1.8365-.7284.2493-.1406 1.482-1.2717 1.6324-1.2287.3404.0972-.014 1.6884-.081 1.9398-.1798.6673-.4952 1.3003-.9554 1.82z"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M27.1593 11.0486c.356-.539.901-.9515 1.5182-1.148.3725-.1184.7656-.1595 1.157-.1632 1.2186-.011 2.452.3553 3.4137 1.1013.9616.7464 1.63 1.8822 1.7275 3.0925l.0405 1.2437c.0792.8083-.1735 1.644-.687 2.274-.0244.03-.0506.0716-.0296.1038.021.0323.0833-.0212.0465-.033"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M27.1593 11.0486c.356-.539.901-.9515 1.5182-1.148.3725-.1184.7656-.1595 1.157-.1632 1.2186-.011 2.452.3553 3.4137 1.1013.9616.7464 1.63 1.8822 1.7275 3.0925l.0405 1.2437c.0792.8083-.1735 1.644-.687 2.274-.0244.03-.0506.0716-.0296.1038.021.0323.0833-.0212.0465-.033M19.0092 10.923c-.1602-.079-.1772-.2954-.172-.4733.078-2.7703.1672-5.5993 1.1384-8.1964 1.835.0793 3.6632.3303 5.4515.7494"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M24.8624 3.1944c-.9362 1.032-.8485 2.7633.0626 3.8172.9108 1.0536 2.4758 1.4224 3.826 1.0687.64-.1677 1.2505-.4896 1.6915-.981 1.0054-1.121.9137-2.9152.1555-4.215-.237-.407-.534-.784-.9052-1.075-.72-.5643-1.7132-.7643-2.597-.5235-.883.241-1.6355.917-1.9667 1.768"
			}), r.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M24.8624 3.1944c-.9362 1.032-.8485 2.7633.0626 3.8172.9108 1.0536 2.4758 1.4224 3.826 1.0687.64-.1677 1.2505-.4896 1.6915-.981 1.0054-1.121.9137-2.9152.1555-4.215-.237-.407-.534-.784-.9052-1.075-.72-.5643-1.7132-.7643-2.597-.5235-.883.241-1.6355.917-1.9667 1.768"
			}))))
		},
		"./src/reddit/icons/svgs/TextPost/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_13NhOjx-Siom7MKe3Dex5y"
			}
		},
		"./src/reddit/icons/svgs/TextPost/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/TextPost/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(s.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				fill: "inherit",
				fillRule: "evenodd",
				d: "M16.8656 7.205H13.139c-.3428 0-.621-.2782-.621-.621 0-.343.2782-.621.621-.621h3.7266c.343 0 .621.278.621.621 0 .3428-.278.621-.621.621zm0 3.416H13.139c-.3428 0-.621-.2782-.621-.621s.2782-.621.621-.621h3.7266c.343 0 .621.2782.621.621s-.278.621-.621.621zm0 3.416H3.2016c-.343 0-.621-.278-.621-.621 0-.3428.278-.621.621-.621h13.664c.343 0 .621.2782.621.621 0 .343-.278.621-.621.621zm-13.664 3.416c-.343 0-.621-.278-.621-.621 0-.3428.278-.621.621-.621h13.664c.343 0 .621.2782.621.621 0 .343-.278.621-.621.621H3.2016zm-.621-14.285c0-.343.278-.621.621-.621h6.5997c.343 0 .621.278.621.621V10c0 .3428-.278.621-.621.621H3.2016c-.343 0-.621-.2782-.621-.621V3.168zM1.3382.0625C.6513.0625.096.6178.096 1.3047v17.3906c0 .687.5554 1.2422 1.2423 1.2422H18.729c.6868 0 1.242-.5553 1.242-1.2422V1.3047c0-.687-.5552-1.2422-1.242-1.2422H1.3382z"
			}))
		},
		"./src/reddit/icons/svgs/ThumbnailSelect/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_3QNLLzw_kUPhkWkxg22tT9"
			}
		},
		"./src/reddit/icons/svgs/ThumbnailSelect/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/ThumbnailSelect/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(s.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", {
				fill: "none",
				fillRule: "evenodd"
			}, r.a.createElement("path", {
				d: "M0 0h20v20H0z"
			}), r.a.createElement("path", {
				fill: "#A5A4A4",
				d: "M6 3h8c1.1046 0 2 .8954 2 2v10c0 1.1046-.8954 2-2 2H6c-1.1046 0-2-.8954-2-2V5c0-1.1046.8954-2 2-2zm11 1c1.1046 0 2 .8954 2 2v8c0 1.1046-.8954 2-2 2V4zM3 4v12h-.6667C1.597 16 1 15.1734 1 14.1538V5.8462C1 4.8266 1.597 4 2.3333 4H3z"
			})))
		},
		"./src/reddit/icons/svgs/Trash2/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1Fa4RPHlhrfUZuNaXK2-eP"
			}
		},
		"./src/reddit/icons/svgs/Trash2/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Trash2/index.m.less"),
				a = n.n(i);
			const c = e => r.a.createElement("svg", {
				className: Object(s.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, r.a.createElement("path", {
				d: "M16.5,2H12.71l-.85-.85A.5.5,0,0,0,11.5,1h-3a.5.5,0,0,0-.35.15L7.29,2H3.5a.5.5,0,0,0-.5.5v1a.5.5,0,0,0,.5.5h13a.5.5,0,0,0,.5-.5v-1A.5.5,0,0,0,16.5,2Z"
			}), r.a.createElement("path", {
				d: "M16.5,5H3.5a.5.5,0,0,0-.5.5v12A1.5,1.5,0,0,0,4.5,19h11A1.5,1.5,0,0,0,17,17.5V5.5A.5.5,0,0,0,16.5,5ZM6.75,15.5a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Zm4,0a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Zm4,0a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Z"
			}));
			t.b = c
		},
		"./src/reddit/icons/svgs/Video/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("g", {
				transform: "translate(3, 4)"
			}, r.a.createElement("path", {
				d: "M15.4927,2.1514 C15.1797,1.9734 14.7947,1.9784 14.4857,2.1644 L11.9997,3.6554 L11.9997,2.0004 C11.9997,0.8974 11.1027,0.0004 9.9997,0.0004 L1.9997,0.0004 C0.8967,0.0004 -0.0003,0.8974 -0.0003,2.0004 L-0.0003,10.0004 C-0.0003,11.1034 0.8967,12.0004 1.9997,12.0004 L9.9997,12.0004 C11.1027,12.0004 11.9997,11.1034 11.9997,10.0004 L11.9997,8.3664 L14.4907,9.8394 C14.6477,9.9324 14.8237,9.9784 14.9997,9.9784 C15.1707,9.9784 15.3417,9.9344 15.4957,9.8474 C15.8077,9.6694 15.9997,9.3384 15.9997,8.9784 L15.9997,3.0214 C15.9997,2.6614 15.8057,2.3284 15.4927,2.1514"
			})))
		},
		"./src/reddit/layout/page/Listing/BackgroundContainer.m.less": function(e, t, n) {
			e.exports = {
				backgroundContainer: "_2wxsLGNmMLx6sEMLJyn2o9"
			}
		},
		"./src/reddit/layout/page/Listing/BackgroundContainer.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				a = n("./src/reddit/models/Theme/index.ts"),
				c = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				d = n("./src/reddit/layout/page/Listing/BackgroundContainer.m.less"),
				l = n.n(d);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const m = Object(i.a)(e => {
				const {
					backgroundColor: t,
					className: n,
					redditStyle: o,
					theme: i,
					...d
				} = e, m = Object(c.a)(e), p = {
					"--pseudo-before-background": t || Object(a.g)(m.canvas, m.canvasImgUrl, m.canvasImgPosition)
				};
				return r.a.createElement("div", u({
					className: Object(s.a)(l.a.backgroundContainer, n),
					style: p
				}, d))
			})
		},
		"./src/reddit/layout/page/Listing/Content.m.less": function(e, t, n) {
			e.exports = {
				styledContent: "_1OVBBWLtHoSPfGCRaPzpTf",
				mCanFlexFullWidth: "PaJBYLqPf_Gie2aZntVQ7",
				mLargePostLayout: "_3nSp9cdBpqL13CqjdMr2L_",
				mDisableFullScreen: "_2udhMC-jldHp_EpAuBeSR1",
				mClassicWidth: "_1Tc65kRFm7a8piCXHVL4L4",
				mIsEditing: "_25-JsrYQ-pXWBM8eqpxeN7",
				onlyChildMargin: "_2OVNlZuUd8L9v0yVECZ2iA"
			}
		},
		"./src/reddit/layout/page/Listing/Content.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/constants/postLayout.ts"),
				d = n("./src/reddit/contexts/PageLayer/index.tsx"),
				l = n("./src/reddit/selectors/structuredStyles.ts"),
				u = n("./src/reddit/layout/page/Listing/Content.m.less"),
				m = n.n(u);

			function p() {
				return (p = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const h = Object(d.v)(),
				b = Object(i.c)({
					isEditing: l.i,
					layout: (e, t) => t.forcedLayout || Object(d.U)(e, t)
				}),
				f = Object(s.b)(b);
			t.a = h(f(e => {
				let {
					className: t,
					hideOnlyChildMargin: n,
					disableFullscreen: o,
					dispatch: s,
					fitPageToContent: i,
					forcedLayout: l,
					isCollectionLayout: u,
					isEditing: h,
					layout: b,
					pageLayer: f,
					...g
				} = e;
				return r.a.createElement("div", p({
					className: Object(a.a)(t, m.a.styledContent, {
						[m.a.mLargePostLayout]: b === c.g.Large || Object(d.R)(f),
						[m.a.mDisableFullScreen]: o && !u,
						[m.a.mClassicWidth]: u,
						[m.a.mIsEditing]: !!h,
						[m.a.mCanFlexFullWidth]: !i,
						[m.a.onlyChildMargin]: !n
					})
				}, g))
			}))
		},
		"./src/reddit/layout/page/Listing/index.m.less": function(e, t, n) {
			e.exports = {
				body: "_31N0dvxfpsO6Ur5AKx4O5d",
				sidebar: "_3Kd8DQpBIbsr5E1JcrMFTY",
				defaultLayout: "_1tvThPWQpORoc2taKebHxs",
				"m-collectionLayout": "K1OCXipJxqOt01sOdQXEx",
				mCollectionLayout: "K1OCXipJxqOt01sOdQXEx",
				outerContainer: "qYj03fU5CXf5t2Fc5iSvg",
				outerContainerExp: "_35NDNOyTzBcywfeEavUt6p",
				innerContainer: "_3ozFtOe6WpJEMUtxDOIvtU",
				bannerNavContainer: "q4a8asWOWdfdniAbgNhMh"
			}
		},
		"./src/reddit/layout/page/Listing/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/reddit/layout/page/Listing/BackgroundContainer.tsx"),
				i = n("./src/reddit/layout/page/Listing/Content.tsx"),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/constants/componentSizes.ts"),
				d = n("./src/reddit/constants/elementClassNames.ts"),
				l = n("./src/reddit/constants/screenWidths.ts"),
				u = n("./src/reddit/contexts/NavbarExp.ts"),
				m = n("./node_modules/classnames/index.js"),
				p = n.n(m),
				h = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				b = n("./src/lib/constants/icons.ts"),
				f = n("./src/reddit/components/SubredditIcon/index.tsx"),
				g = n("./src/reddit/icons/fonts/index.tsx"),
				v = n("./src/reddit/components/BackToSubreddit/index.m.less"),
				C = n.n(v);
			var y = e => {
					const {
						subredditName: t
					} = e, n = `/${t}`;
					return r.a.createElement(h.a, {
						className: C.a.backToSubreddit,
						to: n
					}, r.a.createElement("div", {
						className: C.a.innerContainer
					}, r.a.createElement(g.a, {
						name: b.a.back,
						className: p()(C.a.content, C.a.back)
					}), r.a.createElement(f.b, {
						className: p()(C.a.content, C.a.subredditIcon)
					}), r.a.createElement("span", {
						className: p()(C.a.content, C.a.title)
					}, t)))
				},
				E = n("./src/reddit/components/StructuredStyles/BladeManager/index.tsx"),
				x = n("./src/reddit/layout/page/Listing/index.m.less"),
				O = n.n(x);
			t.a = e => {
				const {
					backgroundColor: t,
					backToSubredditName: n,
					className: m,
					containerRef: p,
					content: h,
					contentBanner: b,
					contentClassName: f,
					contentNavBar: g,
					disableFullscreen: v,
					fitPageToContent: C,
					forcedLayout: x,
					hideOnlyChildMargin: _,
					isCollectionLayout: k,
					isPageSwapped: j,
					maxWidth: S,
					navBar: T,
					redditStyle: w,
					sidebar: I,
					sidebars: P,
					trendingUnit: N,
					subredditId: R
				} = e, M = N ? "28px" : "0", D = j ? {
					marginRight: `${c.p}px`,
					marginTop: M
				} : {
					marginLeft: `${c.p}px`,
					marginTop: M
				}, L = I && r.a.createElement("div", {
					className: Object(a.a)(O.a.sidebar, k ? O.a["m-collectionLayout"] : O.a.defaultLayout),
					style: D
				}, I), A = r.a.createElement(i.a, {
					hideOnlyChildMargin: _,
					className: f,
					disableFullscreen: v,
					fitPageToContent: C,
					forcedLayout: x,
					isCollectionLayout: k
				}, b, n && r.a.createElement(y, {
					subredditName: n
				}), h);
				let F;
				F = P ? r.a.createElement(r.a.Fragment, null, P[0], A, P[1]) : j ? r.a.createElement(r.a.Fragment, null, L, A) : r.a.createElement(r.a.Fragment, null, A, L);
				const B = v ? `${S||l.a+2*c.l}px` : "100%",
					U = Object(o.useContext)(u.a);
				return r.a.createElement(E.a, {
					subredditId: R
				}, r.a.createElement("div", {
					className: Object(a.a)(O.a.outerContainer, d.i, m, {
						[O.a.outerContainerExp]: U
					}),
					ref: p
				}, r.a.createElement(s.a, {
					className: d.h,
					redditStyle: w,
					backgroundColor: t
				}), r.a.createElement("div", {
					className: O.a.innerContainer
				}, T, g, (e => e.hero ? r.a.createElement(r.a.Fragment, null, e.hero) : null)(e), r.a.createElement("div", {
					style: {
						maxWidth: B
					}
				}, N), r.a.createElement("div", {
					className: O.a.body,
					style: {
						maxWidth: B
					}
				}, F))))
			}
		},
		"./src/reddit/layout/row/Inline/index.m.less": function(e, t, n) {
			e.exports = {
				inlineRow: "XZK-LTFT5CgGo9MvPQQsy"
			}
		},
		"./src/reddit/layout/row/Inline/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/layout/row/Inline/index.m.less"),
				s = n.n(r);
			t.a = o.a.div("inlineRow", s.a)
		},
		"./src/reddit/layout/row/InlineButton/index.m.less": function(e, t, n) {
			e.exports = {
				inlineButton: "_10K5i7NW6qcm-UoCtpB3aK"
			}
		},
		"./src/reddit/layout/row/InlineButton/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/layout/row/InlineButton/index.m.less"),
				s = n.n(r);
			t.a = o.a.button("inlineButton", s.a)
		},
		"./src/reddit/layout/row/RightAlign/index.m.less": function(e, t, n) {
			e.exports = {
				rightAligned: "_1sEFSGIUpFtX1hzGDyWJpr"
			}
		},
		"./src/reddit/layout/row/RightAlign/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/layout/row/RightAlign/index.m.less"),
				s = n.n(r);
			t.a = o.a.div("rightAligned", s.a)
		},
		"./src/reddit/layout/threeCol/ExpandCenter/index.m.less": function(e, t, n) {
			e.exports = {
				leftAndRight: "_3P6gMBKOhtWWrytWm-8hc",
				center: "CEs01bewsmQQV7LRLaHib",
				expandedCenterContainer: "_2FZY7HXlkf-PdemHbQoAEt"
			}
		},
		"./src/reddit/layout/threeCol/ExpandCenter/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/higherOrderComponents/warnOnChildrenCount/index.tsx"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/layout/threeCol/ExpandCenter/index.m.less"),
				c = n.n(a);
			t.a = Object(s.a)(e => r.a.createElement("div", {
				className: Object(i.a)(c.a.expandedCenterContainer, e.className)
			}, r.a.createElement("div", {
				className: c.a.leftAndRight,
				style: {
					flexBasis: e.widthLeft
				}
			}, Array.isArray(e.children) && e.children[0]), r.a.createElement("div", {
				className: c.a.center
			}, Array.isArray(e.children) && e.children[1]), r.a.createElement("div", {
				className: c.a.leftAndRight,
				style: {
					flexBasis: e.widthRight
				}
			}, Array.isArray(e.children) && e.children[2])), 3)
		},
		"./src/reddit/layout/twoCol/ExpandLeft/index.m.less": function(e, t, n) {
			e.exports = {
				left: "_5gAwSCo7K8G413IoE78Ml",
				right: "_2ghjBMFIsORwdO3oh2Kq6g",
				exapndLeftContainer: "_1zTJo0Ndih4fp__5DjbClN"
			}
		},
		"./src/reddit/layout/twoCol/ExpandLeft/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./src/higherOrderComponents/warnOnChildrenCount/index.tsx"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/layout/twoCol/ExpandLeft/index.m.less"),
				c = n.n(a);
			t.a = Object(s.a)(e => r.a.createElement("div", {
				className: Object(i.a)(c.a.exapndLeftContainer, e.className)
			}, r.a.createElement("div", {
				className: c.a.left
			}, Array.isArray(e.children) && e.children[0]), r.a.createElement("div", {
				className: c.a.right,
				style: {
					flexBasis: e.widthRight
				}
			}, Array.isArray(e.children) && e.children[1])), 2)
		},
		"./src/reddit/models/Badge/managementPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			}));
			var o, r, s = n("./src/reddit/models/Badge/index.ts");
			! function(e) {
				e.Loyalty = "loyalty", e.Achievement = "achievement", e.Cosmetic = "cosmetic"
			}(o || (o = {})),
			function(e) {
				e.Gallery = "gallery", e.MyBadges = "my-badges"
			}(r || (r = {}));
			const i = {
					[o.Loyalty]: s.a.First,
					[o.Achievement]: s.a.Second,
					[o.Cosmetic]: void 0
				},
				a = e => e === s.a.First ? o.Loyalty : e === s.a.Second ? o.Achievement : o.Cosmetic
		},
		"./src/reddit/models/ScheduledPost/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "s", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "r", (function() {
				return g
			})), n.d(t, "l", (function() {
				return v
			})), n.d(t, "k", (function() {
				return C
			})), n.d(t, "i", (function() {
				return y
			})), n.d(t, "j", (function() {
				return E
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "n", (function() {
				return O
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "m", (function() {
				return k
			})), n.d(t, "q", (function() {
				return j
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./src/lib/assertNever.ts"),
				r = n("./src/reddit/models/GqlTopLevelField.ts"),
				s = n("./src/reddit/models/User/index.ts");
			const i = "scheduledposts";
			var a, c, d;
			! function(e) {
				e.LINK = "LINK", e.POLL = "POLL", e.SELF = "SELF"
			}(a || (a = {})),
			function(e) {
				e.RTJSON = "RTJSON", e.TEXT = "TEXT"
			}(c || (c = {})),
			function(e) {
				e.CREATED = "CREATED", e.PROCESSING = "PROCESSING", e.FAILED = "FAILED", e.SUCCESS = "SUCCESS"
			}(d || (d = {}));
			const l = e => {
					return new Set(["links", "text", "polls"]).has(e)
				},
				u = e => e.__typename === s.c.AvailableRedditor,
				m = e => e.__typename === r.a.Subreddit;
			var p, h, b, f;
			! function(e) {
				e.standalonePosts = "standalonePosts", e.recurringPosts = "recurringPosts"
			}(p || (p = {})),
			function(e) {
				e.MONDAY = "MONDAY", e.TUESDAY = "TUESDAY", e.WEDNESDAY = "WEDNESDAY", e.THURSDAY = "THURSDAY", e.FRIDAY = "FRIDAY", e.SATURDAY = "SATURDAY", e.SUNDAY = "SUNDAY"
			}(h || (h = {})),
			function(e) {
				e[e.MONDAY = 0] = "MONDAY", e[e.TUESDAY = 1] = "TUESDAY", e[e.WEDNESDAY = 2] = "WEDNESDAY", e[e.THURSDAY = 3] = "THURSDAY", e[e.FRIDAY = 4] = "FRIDAY", e[e.SATURDAY = 5] = "SATURDAY", e[e.SUNDAY = 6] = "SUNDAY"
			}(b || (b = {})),
			function(e) {
				e[e.SUNDAY = 0] = "SUNDAY", e[e.MONDAY = 1] = "MONDAY", e[e.TUESDAY = 2] = "TUESDAY", e[e.WEDNESDAY = 3] = "WEDNESDAY", e[e.THURSDAY = 4] = "THURSDAY", e[e.FRIDAY = 5] = "FRIDAY", e[e.SATURDAY = 6] = "SATURDAY"
			}(f || (f = {}));
			const g = e => h[f[e]],
				v = e => f[h[e]],
				C = e => b[h[e]],
				y = e => h[b[e]],
				E = e => f[b[e]];
			var x;
			! function(e) {
				e.Hourly = "HOURLY", e.Daily = "DAILY", e.Weekly = "WEEKLY", e.Monthly = "MONTHLY"
			}(x || (x = {}));
			const O = e => {
					switch (e) {
						case x.Hourly:
						case x.Daily:
						case x.Weekly:
						case x.Monthly:
							return !0
					}
					return !1
				},
				_ = "custom",
				k = e => {
					switch (e) {
						case "isNsfw":
							return "mark_as_nsfw";
						case "isOriginalContent":
							return "mark_as_oc";
						case "isSticky":
							return "sticky";
						case "isModDistinguished":
							return "mod_distinguish";
						case "isSpoiler":
							return "mark_as_spoiler";
						case "isContestMode":
							return "mark_as_contest_mode";
						case "isPostAsMetaMod":
							return "post_as_meta_mod";
						default:
							return Object(o.a)(e)
					}
				},
				j = e => "frequency" in e && !!e.frequency
		},
		"./src/reddit/pages/ErrorPages/index.m.less": function(e, t, n) {
			e.exports = {
				primaryRouterLink: "WPSTJCepGLEWZl2fETrUM",
				container: "_3pfk0xbr5atzL7KT8pXEZG",
				title: "_3uo9iClHghoc_hoxzdgipi"
			}
		},
		"./src/reddit/pages/ErrorPages/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				s = n.n(r),
				i = n("./src/reddit/controls/Button/index.tsx"),
				a = n("./src/reddit/pages/ErrorPages/index.m.less"),
				c = n.n(a);
			const d = e => {
					let {
						shouldReloadHome: t
					} = e;
					return t ? s.a.createElement(i.a, {
						kind: i.b.ExternalLink,
						priority: i.c.Primary,
						className: c.a.primaryRouterLink,
						href: "/"
					}, o.fbt._("Go Home", null, {
						hk: "3E9E1g"
					})) : s.a.createElement(i.a, {
						kind: i.b.InternalLink,
						priority: i.c.Primary,
						className: c.a.primaryRouterLink,
						to: "/"
					}, o.fbt._("Go Home", null, {
						hk: "3E9E1g"
					}))
				},
				l = e => {
					let {
						message: t,
						shouldReloadHome: n
					} = e;
					return s.a.createElement("div", {
						className: c.a.container
					}, s.a.createElement("h3", {
						className: c.a.title
					}, t || o.fbt._("Sorry, there doesn't seem to be anything here.", null, {
						hk: "3VvHek"
					})), s.a.createElement(d, {
						shouldReloadHome: n
					}))
				},
				u = e => {
					let {
						message: t,
						shouldReloadHome: n
					} = e;
					return s.a.createElement("div", {
						className: c.a.container
					}, s.a.createElement("h3", {
						className: c.a.title
					}, t || o.fbt._("Sorry, You do not have permission to view this page.", null, {
						hk: "4lRbHD"
					})), s.a.createElement(d, {
						shouldReloadHome: n
					}))
				}
		},
		"./src/reddit/pages/PostCreation/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				s = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/actions/postCreation/general.ts"),
				c = n("./src/reddit/components/JumpToContent/index.tsx"),
				d = n("./node_modules/fbt/lib/FbtPublic.js"),
				l = n("./node_modules/lodash/once.js"),
				u = n.n(l),
				m = n("./node_modules/react-router-redux/es/index.js"),
				p = n("./src/lib/classNames/index.ts"),
				h = n("./src/lib/constants/index.ts"),
				b = n("./node_modules/lodash/debounce.js"),
				f = n.n(b),
				g = n("./src/reddit/constants/keycodes.ts"),
				v = n("./src/reddit/helpers/correlationIdTracker.ts"),
				C = n("./src/reddit/models/PostCreationForm/index.ts"),
				y = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				E = n("./src/reddit/pages/ErrorPages/index.tsx"),
				x = n("./src/reddit/selectors/experiments/postGuidance.ts"),
				O = n("./src/reddit/selectors/postCollection.ts"),
				_ = n("./src/reddit/selectors/postGuidance.ts"),
				k = n("./src/reddit/components/CrosspostBox/index.tsx"),
				j = n("./src/reddit/endpoints/talk/index.ts"),
				S = n("./src/reddit/hooks/useGqlContext.ts"),
				T = n("./src/reddit/selectors/experiments/econ/index.ts"),
				w = n("./src/reddit/selectors/postCreations.ts");

			function I() {
				return (I = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			var P = n("./src/reddit/components/RequestPendingBanner/index.tsx"),
				N = n("./src/reddit/components/RichTextEditor/media/helpers.ts"),
				R = n("./src/reddit/contexts/PageLayer/index.tsx"),
				M = n("./src/reddit/helpers/trackers/postComposer.ts"),
				D = n("./src/reddit/selectors/activeModalId.ts"),
				L = n("./src/reddit/selectors/platform.ts"),
				A = n("./src/reddit/selectors/postDraft.ts"),
				F = n("./src/reddit/selectors/subreddit.ts"),
				B = n("./src/reddit/selectors/user.ts"),
				U = n("./src/reddit/actions/changeUsername.ts"),
				K = n("./src/reddit/actions/externalAccount.ts"),
				W = n("./src/reddit/actions/postCreation/mediaUpload.ts"),
				G = n("./src/reddit/actions/postCreation/submit.ts"),
				H = n("./src/reddit/actions/postCreation/subredditChange.ts"),
				V = n("./src/reddit/actions/postDraft.ts"),
				z = n("./src/reddit/actions/reCaptchaEnterprise.ts"),
				q = n("./src/reddit/actions/upload.ts"),
				Q = n("./src/reddit/helpers/externalAccount/index.tsx"),
				Y = n("./src/reddit/selectors/experiments/postCreationSubRec.ts"),
				J = n("./node_modules/history/esm/history.js"),
				X = n("./node_modules/react-router/esm/react-router.js"),
				Z = n("./src/lib/matchRoute/index.ts"),
				$ = n("./src/reddit/components/PostCreationForm/Prompt/PromptModal.tsx"),
				ee = n("./src/reddit/components/TrackingHelper/index.tsx"),
				te = n("./src/reddit/selectors/scheduledPosts/index.ts");
			const ne = "DISCARD_POST_ON_NAVIGATION_MODAL_ID",
				oe = Object(i.c)({
					isEditingScheduledPost: e => !!Object(te.r)(e),
					isScheduledPost: w.U
				});
			var re = Object(s.b)(oe)(e => {
					const {
						isEditingScheduledPost: t,
						isScheduledPost: n,
						onAbort: s,
						onDiscardConfirmed: i,
						onSaveDraft: a,
						submissionType: c
					} = e, l = Object(ee.b)(), u = Object(o.useCallback)(() => {
						s(), l(Object(M.l)())
					}, [s, l]);
					return h.J.has(c) && !n ? r.a.createElement($.a, {
						bodyText: d.fbt._("Do you want to save a draft of your post?", null, {
							hk: "3EV54t"
						}),
						onClose: s,
						onPrimaryAction: a,
						onSecondaryAction: i,
						primaryButtonText: d.fbt._("Save Draft", null, {
							hk: "1VdofA"
						}),
						secondaryButtonText: d.fbt._("Discard Post", null, {
							hk: "1CBjtn"
						}),
						titleText: d.fbt._("Save draft", null, {
							hk: "44JnYT"
						})
					}) : r.a.createElement($.a, {
						bodyText: t ? d.fbt._("Returning to the previous page will discard your changes", null, {
							hk: "2LlXOp"
						}) : d.fbt._("Returning to the previous page will discard your post", null, {
							hk: "3fT0mW"
						}),
						onClose: s,
						onPrimaryAction: u,
						onSecondaryAction: i,
						primaryButtonText: d.fbt._("Edit Post", null, {
							hk: "3dI1el"
						}),
						secondaryButtonText: t ? d.fbt._("Discard Changes", null, {
							hk: "7JOA"
						}) : d.fbt._("Discard Post", null, {
							hk: "1CBjtn"
						}),
						titleText: t ? d.fbt._("Discard Changes", null, {
							hk: "2vyCBa"
						}) : d.fbt._("Discard Post", null, {
							hk: "2BlkSe"
						})
					})
				}),
				se = n("./src/reddit/routes/postCreation/index.ts");
			const ie = e => (e.returnValue = "", ""),
				ae = Object(i.c)({
					destSubreddit: w.h,
					hasError: w.w,
					havePostContent: w.D,
					isChanged: w.H,
					modalId: D.a,
					submitPostPending: w.tb
				}),
				ce = Object(s.b)(ae, e => ({
					onToggleDiscardModal: () => e(a.z(ne))
				}), (e, t, n) => ({
					...e,
					...t,
					...n
				}));
			class de extends r.a.Component {
				constructor() {
					super(...arguments), this.unblockNavigation = null, this.ensureBlocked = e => {
						e.isChanged && (e.havePostContent || e.destSubreddit.name) ? this.block(e) : this.unblock()
					}, this.block = e => {
						this.unblockNavigation || (window.addEventListener("beforeunload", ie), this.unblockNavigation = e.history.block((e, t) => {
							if (!Object(Z.a)(Object(J.e)(e), [se.a])) return this.props.modalId !== ne && this.props.onToggleDiscardModal(), "Are you sure you want to leave?"
						}))
					}, this.unblock = () => {
						this.unblockNavigation && (this.unblockNavigation(), this.unblockNavigation = null), window.removeEventListener("beforeunload", ie)
					}
				}
				componentDidMount() {
					this.ensureBlocked(this.props)
				}
				componentWillReceiveProps(e) {
					!this.props.submitPostPending || e.submitPostPending || e.hasError ? this.ensureBlocked(e) : this.unblock()
				}
				componentWillUnmount() {
					this.unblock()
				}
				render() {
					return null
				}
			}
			var le = Object(R.v)({
					draftId: R.w,
					pageLayer: e => e
				})(ce(Object(X.i)(de))),
				ue = n("./src/reddit/components/PostCreationForm/CollectionListModal/index.tsx"),
				me = n("./src/reddit/components/PostCreationForm/ControlRow/LivechatBadge/index.m.less"),
				pe = n.n(me);
			const he = () => r.a.createElement("div", {
				className: pe.a.container
			}, r.a.createElement("span", {
				className: pe.a.liveTag
			}, d.fbt._("Live", null, {
				hk: "4o8ujy"
			})), d.fbt._("Chat Enabled", null, {
				hk: "1B6dGh"
			}));
			var be = n("./src/telemetry/index.ts"),
				fe = n("./src/lib/lessComponent.tsx"),
				ge = n("./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/index.tsx"),
				ve = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				Ce = n("./src/reddit/components/ScheduledPost/PostSchedulePickerModal/loader.tsx"),
				ye = n("./src/reddit/controls/ErrorText/index.tsx"),
				Ee = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				xe = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				Oe = n("./src/reddit/icons/fonts/index.tsx"),
				_e = n("./src/reddit/models/Media/index.ts"),
				ke = n("./src/reddit/models/Poll/index.ts"),
				je = n("./src/reddit/models/Upload/index.ts"),
				Se = n("./src/reddit/selectors/moderatorPermissions.ts"),
				Te = n("./src/reddit/models/Duplicates/index.ts"),
				we = n("./src/reddit/selectors/posts.ts");
			var Ie = n("./src/reddit/components/PostCreationForm/Button/index.tsx"),
				Pe = n("./src/lib/timezone/index.ts"),
				Ne = n("./src/reddit/icons/svgs/Replay/index.tsx"),
				Re = n("./src/reddit/components/PostCreationForm/PostCreationFooter/ScheduledTimeInfo/index.m.less"),
				Me = n.n(Re);
			const {
				fbt: De
			} = n("./node_modules/fbt/lib/FbtPublic.js"), Le = fe.a.div("Container", Me.a), Ae = Object(i.c)({
				eventSchedule: w.p,
				postSchedule: w.gb
			});
			var Fe = Object(s.b)(Ae)(e => {
					const {
						eventSchedule: t,
						postSchedule: n
					} = e;
					let o;
					if (t && t.submitTime !== C.j.Now) o = (e => {
						const t = Object(Pe.f)(e.startDate);
						let n = `${t.toLocaleDateString(void 0,{month:"numeric",day:"numeric",year:"2-digit"})} ${t.toLocaleTimeString([],{hour:"numeric",minute:"numeric"}).replace(" ","")}`;
						const o = Object(Pe.d)(e.timezoneName, +t);
						return o && (n += ` ${o.abbreviation}`), r.a.createElement("span", null, De._("Will automatically post at", null, {
							hk: "1ixr16"
						}), " ", r.a.createElement("time", {
							dateTime: e.startDate
						}, n))
					})(t);
					else {
						if (!n) return null;
						o = (e => {
							const t = Object(Pe.f)(e.submitDate);
							let n = `${t.toLocaleDateString(void 0,{month:"numeric",day:"numeric"})} ${t.toLocaleTimeString([],{hour:"numeric",minute:"numeric"}).replace(" ","")}`;
							const o = Object(Pe.d)(e.timezoneName, +t);
							o && (n += ` ${o.abbreviation}`);
							const s = e.recurrenceInfo ? r.a.createElement("span", null, r.a.createElement(Ne.a, {
								className: Me.a.replayIcon
							}), De._("Recurring post template scheduled for", null, {
								hk: "2tTwIB"
							})) : De._("Post scheduled for", null, {
								hk: "47yVoo"
							});
							return r.a.createElement("span", null, s, " ", r.a.createElement("time", {
								dateTime: e.submitDate
							}, n))
						})(n)
					}
					return r.a.createElement(Le, null, o)
				}),
				Be = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				Ue = n("./src/lib/linkMatchers/index.ts"),
				Ke = n("./src/lib/makeActionCreator/index.ts"),
				We = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				Ge = n("./src/lib/makeApiRequest/index.ts"),
				He = n("./src/lib/omitHeaders/index.ts"),
				Ve = n("./src/reddit/constants/headers.ts"),
				ze = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts");
			var qe = n("./src/reddit/actions/postCreation/constants.ts");
			const Qe = Object(Ke.a)(qe.L),
				Ye = Object(Ke.a)(qe.M),
				Je = (e, t) => async (n, o, r) => {
					let {
						apiContext: s
					} = r;
					const i = o(),
						a = Object(We.u)(i, {
							pageLayer: t
						});
					if (!a) return;
					const c = Object(w.q)(i, {
						field: e
					});
					if (!c) return;
					const l = Object(w.f)(i),
						u = await ((e, t, n, o, r) => Object(Ge.a)(Object(He.a)(e, [Ve.a]), {
							endpoint: `${e.apiUrl}/api/validate_submission_field`,
							method: h.ob.POST,
							data: {
								sr: t,
								field: n,
								kind: o,
								title: r.title || "",
								url: r.url || null,
								text: r.selftext,
								richtext_json: r.rtjson && JSON.stringify({
									document: r.rtjson
								}),
								flair_id: r.flairId || null,
								show_error_list: !0
							}
						}).then(ze.b))(s(), a.name, e, l, c),
						m = u.error || function(e, t) {
							if (e === h.Cb.LINK && !Object(Ue.h)(Ue.f, t.url || "")) return {
								fields: [{
									field: h.Cb.LINK,
									msg: d.fbt._("Link doesn't look right", null, {
										hk: "11qrsa"
									})
								}],
								type: h.K.SUBMIT_VALIDATION_ERROR
							}
						}(e, c);
					m && m.fields && m.fields.length ? n(Qe(m)) : n(Ye(e)), u.error && n(Object(G.e)(u.error))
				};
			var Xe = n("./src/reddit/components/Flair/index.tsx"),
				Ze = n("./src/reddit/controls/TextButton/index.tsx"),
				$e = n("./src/reddit/controls/Typography/index.tsx"),
				et = n("./src/reddit/components/PostCreationForm/ControlRow/PostModifiers/OCDisclaimer/index.m.less"),
				tt = n.n(et);
			const {
				fbt: nt
			} = n("./node_modules/fbt/lib/FbtPublic.js"), ot = fe.a.wrapped(Ze.a, "DontShowButton", tt.a);
			var rt, st = fe.a.wrapped(e => {
					const {
						className: t,
						onDoNotShowClick: n
					} = e;
					return r.a.createElement("div", {
						className: t
					}, r.a.createElement($e.a, null, nt._("Use the OC tag if you want to take credit for your post as Original Content.", null, {
						hk: "2D3GYX"
					})), r.a.createElement($e.a, null, r.a.createElement(ot, {
						onClick: n
					}, nt._("Cool, whatever, don't show me this again.", null, {
						hk: "4nvsEF"
					}))))
				}, "Component", tt.a),
				it = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				at = n("./src/reddit/constants/colors.ts"),
				ct = n("./src/reddit/controls/Button/index.tsx");
			! function(e) {
				e.CHAT = "chat", e.FLAIR = "flair", e.GOVERNANCE = "gov", e.SPOILER = "spoiler", e.NSFW = "nsfw", e.ORIGINAL_CONTENT = "originalContent", e.SCHEDULE = "schedule"
			}(rt || (rt = {}));
			var dt = n("./src/reddit/components/PostCreationForm/ControlRow/PostModifiers/PostModifierButton/index.m.less"),
				lt = n.n(dt);
			fe.a.div("TintOverlay", lt.a);
			const ut = (e, t) => {
					switch (t) {
						case rt.ORIGINAL_CONTENT:
							return {
								backgroundColor: at.a.orangered, textColor: e.newCommunityTheme.body, iconColor: e.newCommunityTheme.body
							};
						case rt.CHAT:
							return {
								backgroundColor: at.a.chat, textColor: e.newCommunityTheme.lightText, iconColor: e.newCommunityTheme.lightText
							};
						case rt.SPOILER:
							return {
								backgroundColor: at.a.spoiler, textColor: e.newCommunityTheme.lightText, iconColor: e.newCommunityTheme.lightText
							};
						case rt.NSFW:
							return {
								backgroundColor: at.a.nsfw, textColor: e.newCommunityTheme.body, iconColor: e.newCommunityTheme.body
							};
						case rt.FLAIR:
							return {
								backgroundColor: e.newCommunityTheme.flair, textColor: e.newCommunityTheme.body, iconColor: e.newCommunityTheme.body
							};
						case rt.SCHEDULE:
							return {
								backgroundColor: e.newCommunityTheme.active, textColor: e.newCommunityTheme.body, iconColor: e.newCommunityTheme.body
							};
						case rt.GOVERNANCE:
							return {
								backgroundColor: e.newCommunityTheme.line, textColor: e.newCommunityTheme.bodyText, iconColor: e.newCommunityTheme.bodyText
							};
						default:
							return {
								backgroundColor: "none", textColor: e.newCommunityTheme.body, iconColor: e.newCommunityTheme.body
							}
					}
				},
				mt = e => Object(Be.a)(t => {
					const {
						addModifierTooltip: n,
						children: o,
						className: s,
						disabled: i,
						disabledTooltip: a,
						Icon: c,
						id: d,
						onClick: l,
						removeModifierTooltip: u,
						style: m,
						text: h,
						theme: b,
						toggled: f
					} = t, g = i && a ? a : f ? u : n, v = {
						color: t.textColor || b && ut(b, e).textColor,
						fill: t.textColor || b && ut(b, e).iconColor,
						backgroundColor: t.backgroundColor || b && ut(b, e).backgroundColor,
						borderColor: "transparent"
					};
					return r.a.createElement(ct.t, {
						"aria-label": g,
						className: Object(p.a)(s, lt.a.PostModifierButton),
						disabled: i,
						Icon: c,
						id: d,
						onClick: l,
						priority: ct.c.Secondary,
						style: {
							...m,
							...f ? v : {}
						},
						text: h
					}, r.a.createElement(it.a, {
						text: g,
						className: lt.a.HoverTooltip,
						tooltipContentClass: t.shiftTooltipToRight ? lt.a.mShiftTooltipToTheRight : void 0
					}), o)
				});
			var pt, ht = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/index.tsx"),
				bt = n("./src/reddit/components/PostFlairPicker/index.tsx");
			! function(e) {
				e.ORIGINAL_CONTENT_DISCLAIMER = "original_content_disclaimer"
			}(pt || (pt = {}));
			var ft = n("./src/reddit/constants/postCreation.ts"),
				gt = n("./src/reddit/helpers/localStorage/index.ts"),
				vt = n("./src/reddit/helpers/trackers/postEvent.ts"),
				Ct = n("./src/reddit/icons/svgs/LiveChat/index.tsx"),
				yt = n("./src/reddit/layout/row/Inline/index.tsx"),
				Et = n("./src/reddit/models/Subreddit/index.ts"),
				xt = n("./src/reddit/selectors/chatPost.ts");
			const Ot = e => e.creations.formState.fieldValidation;
			var _t = n("./src/telemetry/models/PostComposer.ts"),
				kt = n("./src/reddit/components/PostCreationForm/ControlRow/PostModifiers/index.m.less"),
				jt = n.n(kt);
			const St = "PostFlair--Modal--CreationForm",
				Tt = e => {
					let t = Object(Pe.f)(e.startDate).toLocaleDateString(void 0, {
						month: "numeric",
						day: "numeric",
						hour: "numeric",
						minute: "numeric"
					});
					return t = t.replace(" ", "").replace(",", " ")
				},
				wt = fe.a.wrapped(Xe.c, "FlairComponent", jt.a),
				It = fe.a.div("FlairTextWrapper", jt.a),
				Pt = fe.a.wrapped(yt.a, "ModifierRow", jt.a),
				Nt = mt(rt.ORIGINAL_CONTENT),
				Rt = mt(rt.CHAT),
				Mt = mt(rt.SPOILER),
				Dt = mt(rt.NSFW),
				Lt = mt(rt.FLAIR),
				At = mt(rt.SCHEDULE),
				Ft = Object(R.v)({
					draftId: R.w,
					pageLayer: e => e
				}),
				Bt = Object(i.c)({
					activeModalId: D.a,
					canAddPostFlair: w.c,
					currentSubredditId: R.o,
					destSubreddit: w.h,
					destSubredditAboutInfo: w.g,
					eventSchedule: w.p,
					isChatPostAvailable: xt.a,
					isChatPostSelected: w.I,
					isEventPostCreationAvailable: w.N,
					isNsfw: w.Q,
					isSpoiler: w.V,
					isOriginalContent: w.R,
					flair: w.r,
					postCreationFieldErrors: Ot,
					postSchedule: w.gb,
					submissionType: w.a
				}),
				Ut = Object(s.b)(Bt, (e, t) => {
					let {
						onPostFieldValidation: n,
						pageLayer: o
					} = t;
					return {
						doNotShowOriginalContentDisclaimerClicked: () => e((e, t) => M.f(t())),
						onEventScheduleChange: t => {
							e(a.a(t))
						},
						postFlairAdded: t => {
							e(a.b(t)), n(e(Je(h.Cb.FLAIR, o)))
						},
						toggleSchedulePicker: (t, n) => {
							e(a.z(C.g)), t && e((e, t) => {
								(n ? vt.g : vt.f)(t())
							})
						},
						toggleChatPostTag: t => {
							e(a.u(!t)), e((e, n) => M.M(n(), !t, _t.ToggleNoun.CHAT))
						},
						toggleFlairPicker: () => e(a.z(St)),
						toggleNsfwTag: t => {
							e(a.v(!t)), e((e, n) => M.M(n(), !t, _t.ToggleNoun.NSFW))
						},
						toggleOriginalContentTag: t => {
							e(a.w(!t)), e((e, n) => M.M(n(), !t, _t.ToggleNoun.ORIGINAL_CONTENT))
						},
						toggleSpoilerTag: t => {
							e(a.y(!t)), e((e, n) => M.M(n(), !t, _t.ToggleNoun.SPOILER))
						}
					}
				});
			class Kt extends r.a.Component {
				constructor() {
					super(...arguments), this.state = {
						showOCDisclaimer: !1
					}, this.handlePostFlairSelected = e => {
						let {
							previewFlair: t
						} = e;
						this.props.flair !== t && this.props.postFlairAdded(t)
					}, this.handleOCDisclaimerDoNotShowClick = () => {
						const {
							doNotShowOriginalContentDisclaimerClicked: e
						} = this.props;
						e(), Object(gt.ub)(pt.ORIGINAL_CONTENT_DISCLAIMER, !0), this.setState({
							showOCDisclaimer: !1
						})
					}, this.handleOriginalContentClick = () => {
						this.props.toggleOriginalContentTag(this.props.isOriginalContent)
					}, this.handleChatPostClick = () => {
						this.props.toggleChatPostTag(this.props.isChatPostSelected)
					}, this.handleSpoilerClick = () => {
						this.props.toggleSpoilerTag(this.props.isSpoiler)
					}, this.handleNsfwClick = () => {
						this.props.toggleNsfwTag(this.props.isNsfw)
					}, this.handleToggleSchedulePicker = () => {
						const e = this.props.activeModalId !== C.g,
							t = !!this.props.eventSchedule;
						this.props.toggleSchedulePicker(e, t)
					}, this.handleToggleFlairPicker = () => {
						this.props.toggleFlairPicker(), this.props.sendEvent(M.y())
					}
				}
				componentDidMount() {
					this.setState({
						showOCDisclaimer: !Object(gt.j)(pt.ORIGINAL_CONTENT_DISCLAIMER)
					})
				}
				render() {
					const {
						activeModalId: e,
						canAddPostFlair: t,
						className: n,
						currentSubredditId: o,
						destSubreddit: s,
						destSubredditAboutInfo: i,
						eventSchedule: a,
						disabled: c,
						flair: l,
						isChatPostAvailable: u,
						isChatPostSelected: m,
						isEventPostCreationAvailable: b,
						isNsfw: f,
						isSpoiler: g,
						isOriginalContent: v,
						postCreationFieldErrors: y,
						postSchedule: E,
						submissionType: x,
						theme: O
					} = this.props, {
						showOCDisclaimer: _
					} = this.state, k = !!l, {
						backgroundColor: j = null,
						textColor: S = null
					} = l || {}, {
						allOriginalContent: T = !1
					} = i || {}, w = s.isProfile || Object(Et.h)(i), I = c || !w || T || x === h.bc.CROSSPOST, P = c || !(s.isProfile || Object(Et.j)(i)), N = c, R = c || !!E;
					return r.a.createElement("div", {
						className: n
					}, r.a.createElement(Pt, null, u && r.a.createElement(Rt, {
						disabled: N,
						onClick: this.handleChatPostClick,
						toggled: m,
						addModifierTooltip: d.fbt._("Use live chat instead of comments", null, {
							hk: "27t9lW"
						}),
						removeModifierTooltip: d.fbt._("Use comments instead of live chat", null, {
							hk: "3seokS"
						}),
						Icon: m ? Object(Oe.b)("checkmark") : Ct.a,
						text: d.fbt._("Live Chat", null, {
							hk: "cZlvm"
						})
					}), b && r.a.createElement(At, {
						disabled: R,
						id: ft.a,
						onClick: this.handleToggleSchedulePicker,
						shiftTooltipToRight: !0,
						toggled: !!a,
						addModifierTooltip: d.fbt._("Add time and date info", null, {
							hk: "L2KN8"
						}),
						removeModifierTooltip: d.fbt._("Edit event data", null, {
							hk: "1FSblM"
						}),
						Icon: Object(Oe.b)("scheduled"),
						text: a ? Tt(a) : d.fbt._("Event", null, {
							hk: "40pq7b"
						})
					}, a && r.a.createElement(Oe.a, {
						name: "edit",
						className: jt.a.editScheduledIcon
					})), e === C.g && r.a.createElement(ht.default, {
						schedule: this.props.eventSchedule,
						onClose: this.handleToggleSchedulePicker,
						onChange: this.props.onEventScheduleChange,
						shouldShowSubmitTime: !0,
						shouldShowDeleteButton: !0
					}), r.a.createElement(Nt, {
						disabled: I,
						onClick: this.handleOriginalContentClick,
						shiftTooltipToRight: !0,
						toggled: w && (v || T),
						addModifierTooltip: d.fbt._("Mark this post as Original Content [OC]", null, {
							hk: "3V5aHC"
						}),
						removeModifierTooltip: d.fbt._("Unmark this post as Original Content [OC]", null, {
							hk: "2oj9GI"
						}),
						disabledTooltip: w ? "" : d.fbt._("This community does not allow original content tag", null, {
							hk: "2ydrVm"
						}),
						Icon: Object(Oe.b)(v ? "checkmark" : "add"),
						text: d.fbt._("OC", null, {
							hk: "2GRpRs"
						})
					}), r.a.createElement(Mt, {
						disabled: P,
						onClick: this.handleSpoilerClick,
						toggled: g,
						addModifierTooltip: d.fbt._("Mark as a spoiler", null, {
							hk: "3ICynB"
						}),
						removeModifierTooltip: d.fbt._("Unmark as a spoiler", null, {
							hk: "34pmqg"
						}),
						disabledTooltip: P ? d.fbt._("This community does not allow spoiler tag", null, {
							hk: "H75tq"
						}) : "",
						Icon: Object(Oe.b)(g ? "checkmark" : "add"),
						text: d.fbt._("Spoiler", null, {
							hk: "4CA9TG"
						})
					}), r.a.createElement(Dt, {
						disabled: c,
						onClick: this.handleNsfwClick,
						toggled: f,
						addModifierTooltip: d.fbt._("Mark as Not Safe For Work", null, {
							hk: "1LNeZB"
						}),
						removeModifierTooltip: d.fbt._("Unmark Not Safe For Work", null, {
							hk: "1EcrjD"
						}),
						Icon: Object(Oe.b)(f ? "checkmark" : "add"),
						text: d.fbt._("NSFW", null, {
							hk: "3Tg62D"
						})
					}), r.a.createElement(Lt, {
						className: Object(p.a)(jt.a.AddFlair, {
							[jt.a.isToggled]: k,
							[jt.a.mHasError]: y[h.Cb.FLAIR].length > 0
						}),
						disabled: !t || c,
						disabledTooltip: s.id ? d.fbt._("Not available for this community", null, {
							hk: "2gkbLI"
						}) : d.fbt._("Select a subreddit to enable flair", null, {
							hk: "1LNvTq"
						}),
						onClick: this.handleToggleFlairPicker,
						toggled: k,
						addModifierTooltip: d.fbt._("Add flair", null, {
							hk: "1RHLMM"
						}),
						removeModifierTooltip: d.fbt._("Change or remove flair", null, {
							hk: "34t9cQ"
						}),
						backgroundColor: j,
						textColor: S,
						Icon: e => r.a.createElement(Oe.a, {
							name: "tag",
							className: Object(p.a)(e.className, jt.a.FlairIcon)
						}),
						style: {
							"--flairColor": k ? Object(Xe.d)({
								...this.props,
								backgroundColor: j,
								textColor: S
							}) : !t || c ? O.newCommunityTheme.actionIconTinted80 : O.newCommunityTheme.actionIcon
						},
						text: r.a.createElement(r.a.Fragment, null, l ? r.a.createElement(wt, {
							flair: l,
							forceSmallEmojis: !0
						}) : r.a.createElement(It, null, d.fbt._("Flair", null, {
							hk: "4Dtvp0"
						})), r.a.createElement(Oe.a, {
							name: "caret_down",
							className: jt.a.StyledCaretIcon
						}))
					}), e === St && r.a.createElement(bt.a, {
						flairs: l ? [l] : [],
						modalId: St,
						onFlairChanged: this.handlePostFlairSelected,
						subredditId: o || ""
					})), r.a.createElement(ye.a, {
						className: jt.a.errorMessages,
						messages: y[h.Cb.FLAIR]
					}), w && v && _ && r.a.createElement(st, {
						onDoNotShowClick: this.handleOCDisclaimerDoNotShowClick
					}))
				}
			}
			var Wt = Ft(Object(Be.a)(Object(ee.c)(Ut(Kt)))),
				Gt = n("./src/config.ts"),
				Ht = n("./src/higherOrderComponents/asTooltip.tsx"),
				Vt = n("./src/reddit/components/PostCreationForm/EduTooltips/BaseEduTooltip/index.m.less"),
				zt = n.n(Vt);
			const {
				fbt: qt
			} = n("./node_modules/fbt/lib/FbtPublic.js"), Qt = fe.a.div("Container", zt.a), Yt = fe.a.div("OuterContainer", zt.a);
			class Jt extends r.a.Component {
				constructor() {
					super(...arguments), this.tooltipRef = null, this.onGotItClick = e => {
						this.close(!0), e.stopPropagation()
					}, this.onKeyDown = e => {
						e.keyCode === g.a.Escape && this.close(!1)
					}, this.onMouseClick = e => {
						this.tooltipRef && !this.tooltipRef.contains(e.target) && this.close(!1)
					}, this.onWindowResize = () => {
						this.close(!1)
					}, this.setTooltipRef = e => {
						this.tooltipRef = e
					}
				}
				componentDidMount() {
					document.addEventListener("keydown", this.onKeyDown), document.addEventListener("click", this.onMouseClick), window.addEventListener("resize", this.onWindowResize), this.tooltipRef && this.tooltipRef.scrollIntoView({
						behavior: "smooth",
						block: "end"
					})
				}
				componentWillUnmount() {
					document.removeEventListener("keydown", this.onKeyDown), document.removeEventListener("click", this.onMouseClick), window.removeEventListener("resize", this.onWindowResize)
				}
				close(e) {
					this.props.onClose(e)
				}
				render() {
					const e = this.props;
					return r.a.createElement(Yt, {
						className: e.className,
						innerRef: this.setTooltipRef,
						style: e.style
					}, r.a.createElement(Qt, {
						className: zt.a.container
					}, r.a.createElement("img", {
						src: e.heroImagePath,
						className: zt.a.hero
					}), r.a.createElement("div", {
						className: zt.a.contentContainer
					}, r.a.createElement("div", {
						className: zt.a.title
					}, e.title), r.a.createElement("div", {
						className: zt.a.description
					}, e.description), r.a.createElement("div", {
						className: zt.a.iconsExplanations
					}, e.iconsExplanations.map((e, t) => {
						const n = e.iconComponent;
						return r.a.createElement("div", {
							className: zt.a.iconExplanation,
							key: t
						}, r.a.createElement(n, {
							className: zt.a.icon
						}), e.text)
					})), r.a.createElement(ct.l, {
						className: zt.a.gotIt,
						onClick: this.onGotItClick
					}, qt._("Got it", null, {
						hk: "2RPumB"
					})))))
				}
			}
			var Xt = Object(Ht.a)(Jt),
				Zt = n("./src/reddit/actions/modal.ts"),
				$t = n("./src/reddit/helpers/trackers/postCollection.ts");
			const en = [{
					id: ft.d,
					getShowTimesLeft: gt.Q,
					setShowTimesLeft: gt.Tb,
					tooltipShown: $t.n,
					tooltipDismissed: $t.m
				}, {
					id: ft.c,
					getShowTimesLeft: gt.P,
					setShowTimesLeft: gt.Sb,
					tooltipShown: $t.f,
					tooltipDismissed: $t.e
				}],
				tn = {};
			let nn;
			const on = () => (void 0 === nn && (nn = en.filter(e => e.getShowTimesLeft() > 0).map(e => e.id)), nn),
				rn = e => {
					const t = on().indexOf(e);
					t > -1 && on().splice(t, 1)
				},
				sn = e => async (t, n) => {
					const o = en.find(t => t.id === e);
					o && (an(o, !0), Object(be.a)(o.tooltipDismissed(n())))
				}, an = (e, t) => {
					e.setShowTimesLeft(t ? 0 : e.getShowTimesLeft() - 1)
				}, cn = () => async (e, t) => {
					const n = Object(D.a)(t()),
						o = on().find(e => !!tn[e]);
					if (!o || o === n) return;
					const r = en.find(e => e.id === o);
					r && (Object(be.a)(r.tooltipShown(t())), an(r)), e(Zt.i(o))
				}, dn = f()(e => e(), 100);
			var ln = n("./src/reddit/components/PostCreationForm/EduTooltips/CollectionButtonTooltip/index.m.less"),
				un = n.n(ln);
			var mn = function(e, t) {
					const n = Object(i.c)({
						isOpen: e => Object(D.a)(e) === t
					});
					class o extends r.a.Component {
						componentDidMount() {
							tn[t] = !0, dn(this.props.onShowNextTooltip)
						}
						componentWillUnmount() {
							tn[t] = !1, dn(this.props.onShowNextTooltip)
						}
						render() {
							const {
								isOpen: t,
								...n
							} = this.props;
							return t ? r.a.createElement(e, n) : null
						}
					}
					return Object(s.b)(n, e => ({
						onCloseTooltip: n => {
							rn(t), n && e(sn(t)), e(Zt.i(t)), e(cn())
						},
						onShowNextTooltip: () => e(cn())
					}))(o)
				}(e => r.a.createElement(Xt, {
					className: un.a.container,
					description: d.fbt._("Create a series of scheduled events or just group random things. Make something awesome.", null, {
						hk: "40PwoH"
					}),
					heroImagePath: `${Gt.a.assetPath}/img/collection-tooltip-hero@2x.png`,
					iconsExplanations: [{
						iconComponent: Object(Oe.b)("add"),
						text: d.fbt._("Compose a post like normal.", null, {
							hk: "466GER"
						})
					}, {
						iconComponent: Object(Oe.b)("collection"),
						text: d.fbt._("Create & name your collection.", null, {
							hk: "3BuZKz"
						})
					}, {
						iconComponent: Object(Oe.b)("add_to_feed"),
						text: d.fbt._("Add more posts to your collection.", null, {
							hk: "2wzlHs"
						})
					}],
					isOpen: !0,
					isOverlayOff: !0,
					onClose: e.onCloseTooltip,
					title: d.fbt._("Create Collections!", null, {
						hk: "3tSmbj"
					}),
					tooltipId: ft.g
				}), ft.c),
				pn = n("./src/reddit/components/PostCreationForm/ControlRow/ToggleDestCollectionButton/index.m.less"),
				hn = n.n(pn);
			var bn = r.a.memo(e => {
					const {
						disabled: t,
						isToggled: n
					} = e, o = n ? "delete" : "collection";
					return r.a.createElement(ct.t, {
						className: hn.a.button,
						priority: ct.c.Plain,
						disabled: t,
						id: ft.g,
						onClick: e.onClick,
						Icon: Object(Oe.b)(o)
					}, r.a.createElement(it.a, {
						text: n ? d.fbt._("Cancel adding to collection", null, {
							hk: "359w09"
						}) : d.fbt._("Add to collection", null, {
							hk: "48nVCZ"
						})
					}), !n && r.a.createElement(mn, null))
				}),
				fn = n("./src/reddit/actions/economics/predictions/index.ts"),
				gn = n("./src/reddit/actions/toaster.ts"),
				vn = n("./src/reddit/helpers/trackers/predictions.ts"),
				Cn = n("./src/reddit/hooks/usePageLayer.ts"),
				yn = n("./src/reddit/hooks/useTracking.ts"),
				En = n("./src/reddit/models/Toast/index.ts"),
				xn = n("./src/reddit/selectors/features/predictions/tournaments/index.ts");
			const {
				fbt: On
			} = n("./node_modules/fbt/lib/FbtPublic.js"), _n = e => {
				let {
					onClose: t
				} = e;
				const n = Object(s.d)(),
					i = Object(yn.a)(),
					[c, d] = Object(o.useState)(!1),
					l = Object(s.e)(w.u),
					u = Object(s.e)(w.v),
					p = Object(s.e)(w.xb),
					h = Object(Cn.a)(),
					{
						subredditName: b
					} = (null == h ? void 0 : h.urlParams) || {},
					f = Object(s.e)(e => Object(F.I)(e, b));
				return r.a.createElement($.a, {
					withOverlay: !0,
					onOverlayClick: t,
					titleText: On._("Prediction created", null, {
						hk: "1O6btq"
					}),
					bodyText: On._("The prediction remains unpublished until the tournament begins. More predictions can be added at any time before the tournament ends.", null, {
						hk: "20T2xQ"
					}),
					onClose: t,
					primaryButtonText: On._("Start Tournament", null, {
						hk: "ft2Io"
					}),
					primaryButtonLoading: c,
					onPrimaryAction: async () => {
						i(Object(vn.j)()), d(!0), n(Object(fn.b)({
							prediction: {
								formData: l,
								formState: u
							}
						}));
						try {
							await n(Object(fn.g)(f, (null == p ? void 0 : p.name) || On._("Predictions Tournament", null, {
								hk: "2Zgcqj"
							}), (null == p ? void 0 : p.theme) || "theme_1", (null == p ? void 0 : p.token) || null)), n(Object(a.s)()), n(Object(fn.v)()), n(Object(fn.l)(b)), n(Object(m.b)(`/r/${b}/predictions/`))
						} catch (e) {
							n(Object(fn.u)()), n(Object(gn.f)({
								duration: 5e3,
								kind: En.b.Error,
								text: On._("Error: Failed to create prediction tournament", null, {
									hk: "1gJN9i"
								})
							}))
						}
						d(!1)
					},
					onSecondaryAction: () => {
						i(Object(vn.c)()), n(Object(fn.b)({
							prediction: {
								formData: l,
								formState: u
							}
						})), n(Object(a.s)()), n(Object(a.g)({
							submissionType: "prediction"
						})), t()
					},
					secondaryButtonText: On._("Create Another", null, {
						hk: "pQB1L"
					})
				})
			};
			var kn = n("./src/reddit/components/PostCreationForm/ControlRow/AddTournamentPredictionButton/index.m.less"),
				jn = n.n(kn);
			const {
				fbt: Sn
			} = n("./node_modules/fbt/lib/FbtPublic.js");

			function Tn(e) {
				let {
					className: t,
					disabled: n
				} = e;
				const i = Object(s.d)(),
					c = Object(yn.a)(),
					d = Object(s.e)(w.u),
					l = Object(s.e)(w.v),
					[u, h] = Object(o.useState)(!1),
					[b, f] = Object(o.useState)(!1),
					g = Object(s.e)(w.F),
					v = Object(s.e)(w.z),
					C = Object(s.e)(w.y),
					y = Object(Cn.a)(),
					E = Object(s.e)(e => Object(We.q)(e, {
						pageLayer: y
					})),
					x = Object(s.e)(e => Object(F.X)(e, {
						subredditId: E
					})),
					O = Object(s.e)(e => Object(xn.b)(e, {
						subredditId: E
					}));
				return r.a.createElement("div", {
					className: Object(p.a)(jn.a.addTournamentPredictionButton, t)
				}, r.a.createElement(ct.l, {
					disabled: b || n || !v || !C,
					onClick: () => {
						O ? (async () => {
							f(!0), i(Object(fn.b)({
								prediction: {
									formData: d,
									formState: l
								}
							}));
							try {
								await i(Object(fn.a)(O.tournamentId, E)), i(Object(a.s)()), i(Object(fn.v)()), i(Object(fn.l)(x.name)), i(Object(m.b)(`/r/${x.name}/predictions/`))
							} catch (e) {
								i(Object(fn.u)()), e.message.match(/max limit/) ? i(Object(gn.f)({
									duration: 1e4,
									kind: En.b.Error,
									text: Sn._("Oops, youve reached the limit of predictions in a single Tournament. You can always start a new Tournament after ending the current one.", null, {
										hk: "1LClJE"
									})
								})) : i(Object(gn.f)({
									duration: 5e3,
									kind: En.b.Error,
									text: Sn._("Error: Failed to add prediction to tournament", null, {
										hk: "3YK8YR"
									})
								}))
							}
							f(!1)
						})() : (c(Object(vn.g)()), h(!0))
					}
				}, b ? r.a.createElement(Ee.a, {
					sizePx: 16
				}) : O ? Sn._("Post", null, {
					hk: "12GkA5"
				}) : Sn._("Next", null, {
					hk: "2m41ub"
				})), r.a.createElement("div", {
					className: jn.a.tooltip
				}, g ? v ? C ? null : Sn._("End must be at least one hour from now", null, {
					hk: "lWM41"
				}) : Sn._("Options cannot be empty", null, {
					hk: "2BR1pQ"
				}) : Sn._("A title is required", null, {
					hk: "2hoEW2"
				})), u && r.a.createElement(_n, {
					onClose: () => h(!1)
				}))
			}
			var wn = n("./src/reddit/components/PostCreationForm/ControlRow/index.m.less"),
				In = n.n(wn);
			const Pn = () => d.fbt._("Post", null, {
					hk: "47QFCY"
				}),
				Nn = () => d.fbt._("Cancel", null, {
					hk: "2TSLl5"
				}),
				Rn = () => d.fbt._("Saved!", null, {
					hk: "34qXtS"
				}),
				Mn = () => d.fbt._("Save Draft", null, {
					hk: "3wckxd"
				}),
				Dn = () => d.fbt._("Updated!", null, {
					hk: "45fGGU"
				}),
				Ln = () => d.fbt._("Update draft", null, {
					hk: "1c8tCb"
				}),
				An = () => d.fbt._("Please fix the above requirements", null, {
					hk: "17Yk98"
				}),
				Fn = () => d.fbt._("Something went wrong. Just don't panic.", null, {
					hk: "4x2ypi"
				}),
				Bn = 10,
				Un = e => {
					return [h.bc.LINK_ONLY, h.bc.POLL, h.bc.POST].includes(e)
				},
				Kn = fe.a.div("ButtonLayout", In.a),
				Wn = fe.a.div("SaveDraftButtonLayout", In.a),
				Gn = fe.a.wrapped(Ee.a, "PostLoadingIcon", In.a),
				Hn = fe.a.wrapped(Gn, "DraftLoadingIcon", In.a),
				Vn = Object(i.a)(w.lb, ve.a.getMediaCount),
				zn = (e, t) => {
					return !!!Object(R.l)(e, t) && e.creations.formData.isPoll
				},
				qn = [],
				Qn = e => {
					const t = Object(w.lb)(e),
						n = Object(w.rb)(e);
					if (!t.isBound || n !== h.bc.POST || !Object(w.nb)(e)) return qn;
					const o = (e => {
						const {
							allowedPostTypes: t,
							name: n
						} = Object(w.h)(e), o = Vn(e);
						if (!o || !t) return null;
						let r = "";
						return !o.total || t.images || t.videos ? o.video && !t.videos ? r = d.fbt._("Videos are not allowed in r/{subreddit name}", [d.fbt._param("subreddit name", n)], {
							hk: "1EUr31"
						}) : !o.image && !o.gifvideo || t.images || (r = d.fbt._("Images are not allowed in r/{subreddit name}", [d.fbt._param("subreddit name", n)], {
							hk: "2pxaRa"
						})) : r = d.fbt._("Videos and images are not allowed in r/{subreddit name}", [d.fbt._param("subreddit name", n)], {
							hk: "3AMcQ8"
						}), r || null
					})(e);
					return o ? [o] : (e => {
						const t = Vn(e);
						if (!t) return qn;
						const n = [];
						return t.image > h.fb && n.push(d.fbt._("Post may not contain more that 20 images", null, {
							hk: "1Szc36"
						})), t.video + t.gifvideo > h.ib && n.push(d.fbt._("Post may not contain more that 5 videos", null, {
							hk: "2WhZ8k"
						})), n
					})(e)
				},
				Yn = (e, t) => {
					let {
						sourcePostId: n
					} = t;
					const o = Object(w.pb)(e, {
							sourcePostId: n
						}),
						{
							allowedPostTypes: r,
							id: s,
							isProfile: i,
							name: a
						} = Object(w.h)(e);
					if (!n) return d.fbt._("A source post is required to crosspost", null, {
						hk: "2TeLDw"
					});
					if (!s) return d.fbt._("A destination community is required to crosspost", null, {
						hk: "3haidF"
					});
					const c = i ? Object(B.nb)(e, {
						userId: s
					}) : s;
					if (c) {
						if (((e, t, n) => {
								const o = Object(Te.a)(n, {
										sort: "new",
										crossposts_only: !0
									}),
									r = e.subreddits.duplicates.models[t];
								return !(r && r[o])
							})(e, c, n)) return d.fbt._("Checking community...", null, {
							hk: "1ycXCe"
						});
						if (((e, t, n) => {
								const o = ((e, t, n) => {
									const o = e.subreddits.duplicates.models[t];
									return o ? o[n] : []
								})(e, t, Object(Te.a)(n, {
									sort: "new",
									crossposts_only: !0
								}));
								return 0 !== o.length && Object(we.x)(e, o[0])
							})(e, c, n)) return d.fbt._("This community has the same crosspost within last 24 hours", null, {
							hk: "177pgf"
						})
					}
					if (!r || !o) return null;
					if (o.source) return !r.links && d.fbt._("This community does not allow for crossposting of link posts", null, {
						hk: "2cZPxJ"
					});
					const {
						isCrosspostableSubreddit: l
					} = Object(F.z)(e, {
						subredditName: a
					});
					if (!l) return d.fbt._("This community does not allow for crossposting of any posts", null, {
						hk: "2KrrAO"
					});
					switch (o.media && o.media.type) {
						case _e.o.TEXT:
						case _e.o.RTJSON:
							return !r.text && d.fbt._("This community does not allow for crossposting of text posts", null, {
								hk: "1a4voI"
							});
						case _e.o.IMAGE:
							return !r.images && d.fbt._("This community does not allow for crossposting of image posts", null, {
								hk: "tGzk7"
							});
						case _e.o.VIDEO:
						case _e.o.GIFVIDEO:
						case _e.o.EMBED:
							return !r.videos && d.fbt._("This community does not allow for crossposting of video posts", null, {
								hk: "w6HED"
							})
					}
					return null
				},
				Jn = (e, t) => {
					let {
						sourcePostId: n
					} = t;
					const o = Object(w.Z)(e),
						r = Object(w.lb)(e),
						s = Object(w.rb)(e);
					if (s === h.bc.IMAGE_ONLY) return !1;
					if (!Object(w.h)(e).name || !Object(w.F)(e)) return !1;
					if (s === h.bc.POST || s === h.bc.POLL || s === h.bc.PREDICTION) {
						const t = Qn(e),
							n = !ve.a.isAllMediaUploaded(r, e.uploads);
						return !t.length && !n
					}
					if (s === h.bc.MEDIA) {
						const {
							items: t
						} = o, n = t.every(t => {
							const n = e.uploads[t.uploadKey];
							return !(!n || !n.url || n.status !== je.a.SUCCESS)
						});
						return t.length > 0 && n
					}
					return s === h.bc.LINK_ONLY ? Object(w.A)(e) : s === h.bc.CROSSPOST && !Yn(e, {
						sourcePostId: n
					})
				},
				Xn = Object(i.c)({
					isPoll: zn,
					activeModalId: D.a,
					currentSubredditOrProfile: R.q,
					canPostAsModerator: w.e,
					currentCollection: R.g,
					errorMsgs: (e, t) => {
						let {
							sourcePostId: n
						} = t;
						if (Object(w.w)(e)) return Object(w.o)(e);
						if (n) {
							const t = Yn(e, {
								sourcePostId: n
							});
							if (t) return [t]
						}
						return Qn(e)
					},
					eventSchedule: w.p,
					hasDraftError: A.f,
					hasError: w.w,
					postGuidanceBlockRuleTriggered: _.c,
					hasSubmitValidationError: w.x,
					destSubredditAboutInfo: w.g,
					govType: e => e.creations.formData.govType,
					isAddingToTournament: (e, t) => {
						let {
							subredditId: n
						} = t;
						return !!n && Object(w.G)(e, {
							subredditId: n
						})
					},
					isChatPostSelected: w.I,
					isContestMode: w.J,
					isCreatingTournamentPrediction: (e, t) => {
						let {
							subredditId: n
						} = t;
						return !!n && Object(w.K)(e, {
							subredditId: n
						})
					},
					isDraftsFeatureEnabled: (e, t) => !zn(e, t),
					isDraftPending: A.g,
					isMediaUploadPending: w.ab,
					isModeratorSomewhere: Se.k,
					isPostAsMetaMod: w.S,
					isPostPending: w.tb,
					isPostSubmitEnabled: Jn,
					isSaveDraftEnabled: e => {
						const t = Object(w.rb)(e);
						if (!h.J.has(t) || !Object(w.H)(e)) return !1;
						const n = Object(w.h)(e),
							o = Object(w.n)(e),
							r = t === h.bc.LINK_ONLY && Object(w.A)(e),
							s = t === h.bc.POST && o === C.i.RICH_TEXT && Object(w.E)(e),
							i = t === h.bc.POST && o === C.i.MARKDOWN && Object(w.B)(e),
							a = r || s || i;
						return !!n.name || Object(w.F)(e) || a
					},
					isScheduledPost: w.U,
					postSchedule: w.gb,
					postToTwitter: w.ib,
					isEditingScheduledPost: e => !!Object(te.r)(e),
					showContributorRequestFlow: e => Object(F.w)(e, y.e.Post),
					showScheduledPosts: w.ob,
					stickyPosition: w.qb,
					submissionType: w.a,
					submitMode: w.sb,
					suggestedSort: w.vb
				}),
				Zn = Object(R.v)(),
				$n = Object(s.b)(Xn, e => ({
					onResetDestCollection: () => e(H.c()),
					onScheduledPostSettingsChange: t => e(a.C(t)),
					onTrackCancelButtonClick: () => {
						e((e, t) => M.a(t()))
					},
					openCollectionsListOrCreationModal: t => e(a.n(t)),
					togglePostSchedulePicker: () => e(a.z(C.o)),
					clickPostSchedule: () => {
						e((e, t) => Object(be.a)(Object(xe.i)()(t())))
					}
				})),
				eo = 2e3,
				to = e => e ? d.fbt._("Update", null, {
					hk: "3MoYFL"
				}) : d.fbt._("Schedule", null, {
					hk: "4bXWUG"
				});
			class no extends r.a.Component {
				constructor() {
					super(...arguments), this.isSavedTimer = null, this.state = {
						draftId: null,
						isSaved: !1
					}, this.onCancel = () => {
						this.props.onTrackCancelButtonClick(), this.props.onCancel()
					}, this.handleDestCollectionClick = () => {
						const {
							currentCollection: e,
							onResetDestCollection: t,
							currentSubredditOrProfile: n,
							openCollectionsListOrCreationModal: o,
							sendEvent: r
						} = this.props;
						if (e) return t();
						n && (o(n.id), r(Object($t.b)(void 0, $t.a.collectionComposer)))
					}, this.shouldDisablePostButton = () => {
						const {
							contributorRequestPending: e,
							hasSubmitValidationError: t,
							postGuidanceBlockRuleTriggered: n,
							isDraftPending: o,
							isMediaUploadPending: r,
							isPostPending: s,
							isPostSubmitEnabled: i
						} = this.props;
						return !i || o || s || r || this.state.isSaved || t || e || n
					}, this.shouldDisablePostScheduleButton = () => {
						const {
							eventSchedule: e,
							postToTwitter: t,
							submissionType: n
						} = this.props;
						return !!e || t || !Un(n)
					}, this.openPostSchedulePickerModal = () => {
						this.props.togglePostSchedulePicker(), this.props.clickPostSchedule()
					}
				}
				UNSAFE_componentWillReceiveProps(e) {
					!this.props.isDraftPending || e.isDraftPending || e.hasDraftError || this.setState({
						isSaved: !0,
						draftId: this.props.draftId
					}, () => {
						this.isSavedTimer = window.setTimeout(() => {
							this.isSavedTimer = null, this.setState({
								isSaved: !1,
								draftId: null
							})
						}, eo)
					})
				}
				componentWillUnmount() {
					this.isSavedTimer && (clearTimeout(this.isSavedTimer), this.isSavedTimer = null)
				}
				getSaveDraftButtonText() {
					const {
						draftId: e
					} = this.props, {
						isSaved: t,
						draftId: n
					} = this.state;
					return t ? n ? Dn() : Rn() : e ? Ln() : Mn()
				}
				render() {
					const {
						activeModalId: e,
						canPostAsModerator: t,
						currentCollection: n,
						destSubredditAboutInfo: s,
						govType: i,
						hasError: a,
						hasSubmitValidationError: c,
						isEditingScheduledPost: l,
						errorMsgs: u,
						isAddingToTournament: m,
						isChatPostSelected: b,
						isContestMode: f,
						isCreatingTournamentPrediction: g,
						isDraftsFeatureEnabled: v,
						isDraftPending: E,
						isPoll: x,
						isMediaUploadPending: O,
						isOpenAISubRec: _,
						isPostAsMetaMod: k,
						isPostPending: j,
						isSaveDraftEnabled: S,
						isScheduledPost: T,
						onPostFieldValidation: w,
						onSaveDraft: I,
						onScheduledPostSettingsChange: P,
						onSubmit: N,
						postSchedule: R,
						sendEvent: M,
						shouldRenderDivider: D = !0,
						showContributorRequestFlow: L,
						showScheduledPosts: A,
						stickyPosition: F,
						submissionType: B,
						submitMode: U,
						suggestedSort: K,
						togglePostSchedulePicker: W
					} = this.props, {
						isSaved: G
					} = this.state, H = E || j || O, V = U === C.r.Post && O, z = U === C.r.Draft && O, {
						collectionsEnabled: q = !1
					} = s || {}, Q = H, Y = Object(p.a)(In.a.ButtonLayout, {
						[In.a.autoWidth]: x || L || A
					}), J = i === ke.a.Prediction && (g || m);
					return r.a.createElement("div", {
						className: Object(p.a)(In.a.Container, {
							[In.a.isSubRec]: _
						})
					}, r.a.createElement(Wt, {
						className: In.a.postModifiers,
						disabled: H,
						onPostFieldValidation: w
					}), D && r.a.createElement("hr", {
						className: In.a.Divider
					}), r.a.createElement("div", {
						className: In.a.ButtonsAndErrors
					}, r.a.createElement("div", {
						className: In.a.formActionsPanel
					}, r.a.createElement("div", {
						className: In.a.buttons
					}, r.a.createElement("div", {
						className: Y
					}, L ? r.a.createElement(ge.default, {
						eventSource: y.b.PostSubmission,
						smallButton: !0
					}) : J ? r.a.createElement(Tn, {
						disabled: this.shouldDisablePostButton()
					}) : r.a.createElement(Ie.a, {
						disabled: this.shouldDisablePostButton(),
						onClick: () => {
							N()
						},
						className: Object(p.a)(A && In.a.removeRightBorderRadius)
					}, j || V ? r.a.createElement(Gn, {
						sizePx: Bn
					}) : r.a.createElement(o.Fragment, null, T ? to(l) : Pn())), A && !J && r.a.createElement(Ie.a, {
						title: d.fbt._("Make a scheduled post", null, {
							hk: "3TBSMs"
						}),
						disabled: this.shouldDisablePostScheduleButton(),
						onClick: this.openPostSchedulePickerModal,
						className: In.a.postScheduleButton,
						Icon: R ? Object(Oe.b)("edit", {
							className: In.a.postScheduleIcon
						}) : Object(Oe.b)("scheduled", {
							className: In.a.postScheduleIcon
						})
					})), e === C.o && r.a.createElement(Ce.a, {
						isContestMode: f,
						isPostAsMetaMod: k,
						sendEvent: M,
						schedule: R,
						stickyPosition: F,
						suggestedSort: K,
						onChange: P,
						onClose: W
					}), v && B !== h.bc.MEDIA && B !== h.bc.POLL && !T ? r.a.createElement(Wn, null, r.a.createElement(Ie.b, {
						disabled: !S || H || G,
						onClick: I
					}, E || z ? r.a.createElement(Hn, {
						sizePx: Bn
					}) : this.getSaveDraftButtonText())) : r.a.createElement(Kn, null, r.a.createElement(Ie.b, {
						disabled: H || G,
						onClick: this.onCancel
					}, Nn())), q && t && r.a.createElement(bn, {
						disabled: Q,
						isToggled: !!n,
						onClick: this.handleDestCollectionClick
					})), b && r.a.createElement(he, null)), r.a.createElement(Fe, null), !!(a || u.length || c) && r.a.createElement(ye.a, {
						className: In.a.errorMessages,
						messages: u,
						fallbackMessage: c ? An() : Fn()
					})))
				}
			}
			var oo = Zn($n(Object(ee.c)(no))),
				ro = n("./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.tsx"),
				so = n("./src/reddit/constants/posts.ts"),
				io = n("./src/reddit/controls/SubredditPicker/index.tsx"),
				ao = n("./src/reddit/controls/SubredditPicker/helpers.ts"),
				co = n("./src/reddit/helpers/name/index.ts"),
				lo = n("./src/reddit/components/PostCreationForm/CreationControls/index.m.less"),
				uo = n.n(lo);
			const mo = Object(i.a)(w.h, D.a, w.cb, B.m, R.s, B.H, (e, t, n, o, r, s) => {
					const i = n && !t ? n : e;
					if (!i || !i.name) return Object(ao.b)("", null, null, s);
					const {
						name: a,
						isProfile: c
					} = i;
					return c ? Object(ao.b)(Object(co.e)(a), null, o, s) : Object(ao.b)(Object(co.d)(a), r, null, s)
				}),
				po = Object(i.c)({
					pending: w.eb,
					pickerValue: mo
				}),
				ho = Object(s.b)(po, (e, t) => {
					let {
						draftId: n,
						pageLayer: o
					} = t;
					return {
						onSubredditChangeRequested: t => e(H.b(t, o))
					}
				});
			class bo extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.inputRef = null, this.onSelectSubreddit = e => {
						const {
							rawString: t,
							record: n
						} = e, o = n && n.name || Object(co.i)(t), r = n && n.type === so.a.PROFILE || Object(co.h)(t), s = {
							name: o,
							isProfile: r,
							allowedPostTypes: n && n.allowedPostTypes
						};
						this.props.onSubredditChangeRequested(s), r || this.props.sendEvent(Object(M.L)(null == n ? void 0 : n.id))
					}, this.setInputRef = e => this.inputRef = e, this.trackSearchEvent = (e, t) => {
						const n = !e && t && t.length > 0,
							o = e && e.length > 0 && !t;
						if (n || o) {
							const e = t ? "type" : "clear";
							this.props.sendEvent(Object(M.K)(e))
						}
					}, this.onTrackSubredditPickerClick = () => {
						this.props.sendEvent(Object(M.J)())
					}
				}
				render() {
					return r.a.createElement(yt.a, {
						className: Object(p.a)(uo.a.ControlRow, this.props.className)
					}, r.a.createElement(io.a, {
						allowCrosspostableOnly: this.props.allowCrosspostableOnly,
						className: uo.a.SubredditPicker,
						disabled: this.props.pending,
						includeUserProfile: this.props.includeUserProfile,
						inputRef: this.setInputRef,
						onSelect: this.onSelectSubreddit,
						onFocus: this.onTrackSubredditPickerClick,
						selectOnBlur: !0,
						onInputChange: this.trackSearchEvent,
						value: this.props.pickerValue
					}))
				}
			}
			var fo = Object(R.v)({
					draftId: R.w,
					pageLayer: e => e
				})(Object(ee.c)(ho(bo))),
				go = n("./node_modules/lodash/range.js"),
				vo = n.n(go),
				Co = n("./src/higherOrderComponents/asModal/index.tsx"),
				yo = n("./src/reddit/icons/svgs/Close/index.tsx"),
				Eo = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				xo = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				Oo = n("./src/reddit/models/User/index.ts"),
				_o = n("./src/reddit/components/HumanDate/index.tsx"),
				ko = n("./src/reddit/models/PostDraft/index.ts"),
				jo = n("./src/reddit/components/PostCreationForm/DraftListModal/DraftListItem/Icon.m.less"),
				So = n.n(jo),
				To = n("./src/lib/constants/icons.ts");

			function wo() {
				return (wo = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const Io = {
				[ko.b.Image]: To.a.image_post,
				[ko.b.Link]: To.a.link_post,
				[ko.b.Markdown]: To.a.text_post,
				[ko.b.RichText]: To.a.text_post,
				[ko.b.Video]: To.a.video_post
			};
			var Po = fe.a.wrapped(e => {
					const {
						draftKind: t,
						...n
					} = e, o = Io[t] || To.a.link_post;
					return r.a.createElement(Oe.a, wo({
						name: o
					}, n))
				}, "Component", So.a),
				No = n("./src/reddit/components/PostCreationForm/DraftListModal/DraftListItem/index.m.less"),
				Ro = n.n(No);
			const Mo = fe.a.div("Container", Ro.a),
				Do = fe.a.div("LeftBlock", Ro.a),
				Lo = fe.a.div("Content", Ro.a),
				Ao = fe.a.div("RightBlock", Ro.a),
				Fo = fe.a.h2("PostTitle", Ro.a),
				Bo = fe.a.wrapped(Fo, "EditingPostTitle", Ro.a),
				Uo = fe.a.div("MetaLine", Ro.a),
				Ko = fe.a.span("SubredditName", Ro.a),
				Wo = fe.a.time("DraftSavedTime", Ro.a),
				Go = fe.a.wrapped(xo.b, "TrashIcon", Ro.a),
				Ho = fe.a.div("InteractiveDiv", Ro.a),
				Vo = fe.a.button("ConfirmDelete", Ro.a),
				zo = Object(i.c)({
					isDraftDeletionPending: (e, t) => {
						let {
							draft: {
								id: n
							}
						} = t;
						return Object(A.a)(e, n)
					},
					subreddit: (e, t) => {
						let {
							draft: {
								subredditId: n
							}
						} = t;
						return n ? Object(F.X)(e, {
							subredditId: n
						}) : void 0
					},
					user: B.m
				}),
				qo = Object(s.b)(zo, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return {
						deleteDraft: t => e(V.o(t, n))
					}
				}),
				Qo = Object(R.v)({
					currentDraftId: R.w,
					pageLayer: e => e
				}),
				Yo = 1e3;
			class Jo extends r.a.Component {
				constructor() {
					super(...arguments), this.state = {
						showConfirmText: !1
					}, this.onClick = () => {
						this.props.onClick(this.props.draft.id)
					}, this.onConfirmClick = e => {
						e.stopPropagation(), this.props.deleteDraft(this.props.draft.id)
					}, this.onTrashCanClick = e => {
						e.stopPropagation(), this.setState({
							showConfirmText: !0
						})
					}
				}
				render() {
					const {
						draft: e,
						currentDraftId: t,
						isDraftDeletionPending: n,
						subreddit: o,
						user: s
					} = this.props, i = o && Object(Et.i)(o) && s ? {
						displayText: Object(co.e)(Object(Oo.e)(s)),
						url: `/user/${Object(Oo.e)(s)}/`
					} : o;
					if (n) return null;
					const a = e.title || d.fbt._("Untitled", null, {
						hk: "2gEXjp"
					});
					return r.a.createElement(Mo, {
						onClick: this.onClick
					}, r.a.createElement(Do, null, r.a.createElement(Po, {
						draftKind: e.kind
					})), r.a.createElement(Lo, null, t === e.id ? r.a.createElement(Bo, {
						"data-redditstyle": !0
					}, d.fbt._("EDITING: {postTitle}", [d.fbt._param("postTitle", a)], {
						hk: "3M5MUj"
					})) : r.a.createElement(Fo, {
						"data-redditstyle": !0
					}, a), r.a.createElement(Uo, {
						"data-redditstyle": !0
					}, i && r.a.createElement(Ko, {
						"data-redditstyle": !0
					}, i.displayText), i && r.a.createElement(Eo.b, null), r.a.createElement(Wo, null, d.fbt._("Draft saved {draftSavedAtTime}", [d.fbt._param("draftSavedAtTime", r.a.createElement(_o.d, {
						seconds: (e.modified || e.created) / Yo
					}))], {
						hk: "2HjAWY"
					})))), r.a.createElement(Ao, null, this.state.showConfirmText ? r.a.createElement(Vo, {
						onClick: this.onConfirmClick,
						"data-redditstyle": !0
					}, t === e.id ? d.fbt._("Delete working draft?", null, {
						hk: "2iGoUj"
					}) : d.fbt._("Confirm", null, {
						hk: "2bjb66"
					})) : r.a.createElement(Ho, {
						onClick: this.onTrashCanClick
					}, r.a.createElement(Go, {
						"data-redditstyle": !0
					}))))
				}
			}
			var Xo = Qo(qo(Jo)),
				Zo = n("./src/reddit/helpers/styles/mixins/loading.ts"),
				$o = n("./src/reddit/components/PostCreationForm/DraftListModal/DraftListItem/Placeholder.m.less"),
				er = n.n($o);
			const tr = fe.a.div("Container", er.a),
				nr = fe.a.div("LeftBlock", er.a),
				or = fe.a.div("Content", er.a),
				rr = fe.a.div("MediaIcon", er.a),
				sr = fe.a.div("Title", er.a),
				ir = fe.a.div("Secondary", er.a);
			var ar = e => {
					let {
						className: t,
						isLoading: n
					} = e;
					return r.a.createElement(tr, {
						className: t,
						"data-redditstyle": !0
					}, r.a.createElement(nr, null, r.a.createElement(rr, {
						className: Object(Zo.a)({
							isLoading: n
						}),
						"data-redditstyle": !0
					})), r.a.createElement(or, null, r.a.createElement(sr, {
						className: Object(Zo.b)({
							isLoading: n
						}),
						"data-redditstyle": !0
					}), r.a.createElement(ir, {
						className: Object(Zo.b)({
							isLoading: n
						}),
						"data-redditstyle": !0
					})))
				},
				cr = n("./src/reddit/components/PostCreationForm/DraftListModal/index.m.less"),
				dr = n.n(cr);

			function lr() {
				return (lr = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const {
				fbt: ur
			} = n("./node_modules/fbt/lib/FbtPublic.js"), mr = `${Gt.a.assetPath}/img/snoo-drafts.png`, pr = 3, hr = fe.a.div("Wrapper", dr.a), br = fe.a.div("TitleRow", dr.a), fr = fe.a.span("DraftsNumber", dr.a), gr = fe.a.div("DetailsContainer", dr.a), vr = fe.a.wrapped(yt.a, "ButtonRow", dr.a), Cr = fe.a.wrapped(ct.o, "CancelButton", dr.a), yr = fe.a.div("CloseWrapper", dr.a), Er = fe.a.wrapped(yo.a, "Close", dr.a), xr = fe.a.div("Empty", dr.a), Or = fe.a.img("EmptyImage", dr.a), _r = fe.a.p("EmptyText", dr.a), kr = Object(i.c)({
				drafts: A.c,
				isPending: A.b,
				maxDrafts: B.eb
			}), jr = Object(s.b)(kr);
			class Sr extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.handleEscapeKey = e => {
						e.keyCode === g.a.Escape && this.props.onClose()
					}, this.renderItem = e => r.a.createElement(Xo, {
						key: e.id,
						draft: e,
						onClick: () => this.props.onLoadDraft(e)
					})
				}
				componentDidMount() {
					document.addEventListener("keydown", this.handleEscapeKey)
				}
				componentWillUnmount() {
					document.removeEventListener("keydown", this.handleEscapeKey)
				}
				renderPlaceholder(e) {
					return r.a.createElement(ar, {
						isLoading: !0,
						key: e
					})
				}
				renderEmpty() {
					return r.a.createElement(xr, null, r.a.createElement(Or, {
						src: mr
					}), r.a.createElement(_r, null, ur._("Your drafts will live here", null, {
						hk: "NIEIr"
					})))
				}
				render() {
					const {
						drafts: e,
						isPending: t,
						maxDrafts: n
					} = this.props;
					let o;
					return o = t ? vo()(pr).map(this.renderPlaceholder) : 0 === e.length ? this.renderEmpty() : e.map(this.renderItem), r.a.createElement(hr, {
						"data-redditstyle": !0
					}, r.a.createElement(br, {
						"data-redditstyle": !0
					}, ur._("Drafts", null, {
						hk: "1fvOmI"
					}), r.a.createElement(fr, {
						"data-redditstyle": !0
					}, e.length, "/", n), r.a.createElement(yr, {
						onClick: this.props.onClose
					}, r.a.createElement(Er, {
						"data-redditstyle": !0
					}))), r.a.createElement(gr, null, o), r.a.createElement(vr, {
						"data-redditstyle": !0
					}, r.a.createElement(Cr, {
						onClick: this.props.onClose,
						"data-redditstyle": !0
					}, ur._("Close", null, {
						hk: "4gbyAA"
					}))))
				}
			}
			const Tr = fe.a.wrapped(Object(Co.a)(jr(Sr)), "DraftListModal", dr.a);
			var wr = e => r.a.createElement(Tr, lr({
					withOverlay: !0,
					onOverlayClick: e.onClose
				}, e)),
				Ir = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				Pr = n("./src/lib/forceHttps/index.ts"),
				Nr = n("./src/reddit/components/PostCreationForm/SafeHarborText/index.m.less"),
				Rr = n.n(Nr);
			const {
				fbt: Mr
			} = n("./node_modules/fbt/lib/FbtPublic.js"), Dr = new RegExp(`\\b(${[..._e.y].join("|")})\\.com$`, "i"), Lr = new RegExp(`\\.(${_e.x.join("|")})$`), Ar = fe.a.div("TextContainer", Rr.a);
			class Fr extends r.a.Component {
				constructor() {
					super(...arguments), this.isUrlScraped = e => {
						const t = Object(Ir.parse)(Object(Pr.a)(e));
						return !(!t.hostname || !Dr.test(t.hostname)) || !(!t.pathname || !Lr.test(t.pathname))
					}
				}
				render() {
					return this.props.value && this.isUrlScraped(this.props.value) ? r.a.createElement(Ar, null, Mr._("Posting this link saves the image or gif to Reddit", null, {
						hk: "1zFV82"
					})) : null
				}
			}
			var Br = n("./node_modules/react-autosize-textarea/lib/index.js"),
				Ur = n.n(Br),
				Kr = n("./src/reddit/controls/GrowingOutlinedInput/index.m.less"),
				Wr = n.n(Kr);

			function Gr() {
				return (Gr = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			class Hr extends r.a.Component {
				constructor(e) {
					super(e), this.innerRef = null, this.focused = !1, this.setInnerRef = e => {
						this.innerRef = e, this.props.textareaRef && this.props.textareaRef(e)
					}, this.handleOnValueChange = () => {
						this.props.onValueChange && this.props.onValueChange(this.state.value)
					}, this.onFocus = e => {
						this.focused = !0, this.props.onFocus && this.props.onFocus(e)
					}, this.onBlur = e => {
						this.focused = !1, this.props.onBlur && this.props.onBlur(e)
					}, this.onChange = e => {
						if (this.innerRef) {
							const e = this.innerRef.value.replace(/\n/g, " ");
							this.setState(() => ({
								value: e
							}), this.handleOnValueChange)
						}
						this.props.onChange && this.props.onChange(e)
					}, this.onKeyPress = e => {
						13 === e.which && e.preventDefault(), this.props.onKeyPress && this.props.onKeyPress(e)
					}, this.state = {
						value: e.value || ""
					}
				}
				componentWillReceiveProps(e) {
					this.focused || this.state.value === e.value || this.setState({
						value: e.value
					})
				}
				render() {
					const {
						value: e
					} = this.state, {
						className: t,
						onValueChange: n,
						textareaRef: o,
						minHeight: s,
						...i
					} = this.props;
					return r.a.createElement(Ur.a, Gr({}, i, {
						className: Object(p.a)(Wr.a.growingOutlinedInput, t),
						style: {
							minHeight: s
						},
						innerRef: this.setInnerRef,
						onFocus: this.onFocus,
						onBlur: this.onBlur,
						onChange: this.onChange,
						onKeyPress: this.onKeyPress,
						value: e
					}))
				}
			}
			var Vr = n("./src/reddit/components/PostCreationForm/LinkEditor/index.m.less"),
				zr = n.n(Vr);
			const qr = Object(i.c)({
					pending: w.eb,
					postCreationFieldErrors: Ot,
					subreddit: R.s,
					value: w.X
				}),
				Qr = Object(s.b)(qr, (e, t) => {
					let {
						onChange: n,
						onPostFieldValidation: o,
						pageLayer: r
					} = t;
					return {
						onBlur: () => {
							o(e(Je(h.Cb.LINK, r)))
						},
						onChange: t => {
							e(a.r(t)), n(t)
						},
						onFocus: () => e((e, t) => M.s(t(), C.l.CLICK, C.m.URL))
					}
				});
			var Yr, Jr = Object(R.v)()(Qr(e => {
					const {
						pending: t,
						postCreationFieldErrors: n,
						subreddit: o,
						value: s
					} = e, i = n[h.Cb.LINK].length > 0;
					return r.a.createElement("div", null, r.a.createElement(Hr, {
						className: Object(p.a)(zr.a.URLInput, {
							[zr.a.mHasError]: i
						}),
						placeholder: d.fbt._("Url", null, {
							hk: "4dfMY"
						}),
						value: s,
						onBlur: e.onBlur,
						onFocus: e.onFocus,
						onKeyDown: e.onKeyDown,
						onValueChange: e.onChange,
						readOnly: t
					}), r.a.createElement(ye.a, {
						errorModalTitle: o ? Object(co.d)(o.name) : void 0,
						messages: n[h.Cb.LINK]
					}), r.a.createElement(Fr, {
						value: s
					}))
				})),
				Xr = n("./node_modules/lodash/clamp.js"),
				Zr = n.n(Xr),
				$r = n("./node_modules/lodash/pickBy.js"),
				es = n.n($r),
				ts = n("./src/lib/formatApiError/index.ts"),
				ns = n("./src/lib/objectSelector/index.ts"),
				os = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/lodash/isEqual.js")),
				rs = n.n(os),
				ss = n("./src/reddit/controls/Sortable/index.tsx");
			! function(e) {
				e.RemoveGalleryItem = "REMOVE_GALLERY_ITEM", e.SelectGalleryItem = "SELECT_GALLERY_ITEM", e.SetGalleryItems = "SET_GALLERY_ITEMS", e.SetCaptionInput = "SET_CAPTION_INPUT", e.SetURLInput = "SET_URL_INPUT", e.SelectPrevMedia = "SELECT_PREV_MEDIA", e.SelectNextMedia = "SELECT_NEXT_MEDIA"
			}(Yr || (Yr = {}));
			var is = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/constants.ts"),
				as = n("./node_modules/lodash/upperFirst.js"),
				cs = n.n(as),
				ds = n("./src/reddit/icons/svgs/Hamster1/index.tsx"),
				ls = n("./src/reddit/icons/svgs/Hamster2/index.tsx"),
				us = n("./src/reddit/components/PostCreationForm/MediaInput/DropArea/index.m.less"),
				ms = n.n(us);
			const {
				fbt: ps
			} = n("./node_modules/fbt/lib/FbtPublic.js"), hs = [...Array.from(h.b), ...Array.from(h.d)].join(), bs = fe.a.input("HiddenInput", ms.a), fs = fe.a.wrapped(ct.o, "UploadButton", ms.a), gs = fe.a.wrapped(ds.a, "HamsterSmall", ms.a), vs = fe.a.wrapped(ls.a, "HamsterLarge", ms.a), Cs = fe.a.div("Container", ms.a), ys = fe.a.div("DropArea", ms.a), Es = fe.a.wrapped(ys, "DropAreaActive", ms.a), xs = fe.a.wrapped(Es, "DropAreaOver", ms.a), Os = fe.a.p("Paragraph", ms.a), _s = fe.a.p("ErrorMsg", ms.a), ks = fe.a.div("Box", ms.a);
			class js extends r.a.Component {
				constructor() {
					super(...arguments), this.hiddenInputEl = null, this.onFileInput = e => {
						this.props.onFileInput(e.currentTarget.files)
					}, this.clickUploadButton = () => this.hiddenInputEl && this.hiddenInputEl.click()
				}
				render() {
					const {
						isOver: e,
						canDrop: t,
						lastErrorMsg: n,
						allowMultiple: o
					} = this.props;
					return r.a.createElement(Cs, null, r.a.createElement(bs, {
						innerRef: e => this.hiddenInputEl = e,
						onChange: this.onFileInput,
						type: "file",
						accept: hs,
						multiple: o
					}), e ? r.a.createElement(xs, null, r.a.createElement(ks, null, r.a.createElement(vs, null), r.a.createElement(Os, null, ps._("Drop Here to Upload", null, {
						hk: "3e1xuE"
					})))) : t ? r.a.createElement(Es, null, r.a.createElement(ks, null, r.a.createElement(gs, null), ps._("Drop Here to Upload", null, {
						hk: "3e1xuE"
					}))) : r.a.createElement(ys, null, r.a.createElement(Os, null, ps._({
						"*": "Drag and drop images or {=Upload}",
						_1: "Drag and drop image or {=Upload}"
					}, [ps._plural(o ? 2 : 1), ps._param("=Upload", r.a.createElement(fs, {
						onClick: this.clickUploadButton
					}, ps._("Upload", null, {
						hk: "41ZNAf"
					})))], {
						hk: "2OuWpT"
					})), n && r.a.createElement(_s, null, cs()(n))))
				}
			}
			var Ss = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				Ts = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/AddImageItem.m.less"),
				ws = n.n(Ts);

			function Is(e) {
				const {
					onClickEvent: t,
					onFileInput: n
				} = e, s = Object(o.useRef)(null), i = Object(o.useCallback)(() => {
					s && s.current && s.current.click(), t()
				}, [t, s]), a = Object(o.useCallback)(e => {
					n(e.currentTarget.files)
				}, [n]);
				return r.a.createElement("span", {
					className: ws.a.AddImageWrapper
				}, r.a.createElement("input", {
					accept: hs,
					className: ws.a.hiddenInput,
					multiple: !0,
					onChange: a,
					ref: s,
					type: "file"
				}), r.a.createElement("button", {
					className: ws.a.AddImageItem,
					onClick: i
				}, r.a.createElement(Ss.a, {
					className: ws.a.plusIcon
				})))
			}
			var Ps = n("./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx"),
				Ns = n("./src/reddit/icons/svgs/ClearFilled/index.tsx"),
				Rs = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/ImageItem.m.less"),
				Ms = n.n(Rs);
			var Ds = e => {
					const {
						canDrop: t,
						mediaUpload: n,
						isDragging: s,
						isOver: i,
						isSelected: a,
						mediaItem: c,
						removeGalleryItem: d,
						dispatch: l
					} = e, u = Object(o.useRef)(null), m = n.key, h = n.status === je.a.FAILED, b = Object(o.useCallback)(() => l((e => ({
						type: Yr.SelectGalleryItem,
						payload: {
							key: e
						}
					}))(m)), [l, m]), f = Object(o.useCallback)(e => {
						e.stopPropagation(), d(c)
					}, [d, c]), g = n.metadata.localUrl;
					return g ? r.a.createElement("span", {
						ref: u
					}, r.a.createElement(Ps.a, {
						canDrop: t,
						className: Object(p.a)(Ms.a.GalleryMediaUpload, {
							[Ms.a.isDragging]: s,
							[Ms.a.isSelected]: a,
							[Ms.a.isError]: h
						}),
						isDragging: s,
						isOver: i
					}, r.a.createElement("span", {
						className: Object(p.a)(Ms.a.galleryImage, {
							[Ms.a.isDragging]: s,
							[Ms.a.isSelected]: a,
							[Ms.a.isError]: h
						}),
						onClick: b,
						style: {
							backgroundImage: `url("${g}")`
						}
					}, r.a.createElement("button", {
						className: Object(p.a)(Ms.a.deleteButton, {
							[Ms.a.isDragging]: s,
							[Ms.a.showDeleteNormal]: !a,
							[Ms.a.isError]: h
						}),
						onClick: f
					}, r.a.createElement(Ns.a, {
						className: Object(p.a)(Ms.a.deleteIcon, {
							[Ms.a.isDragging]: s
						})
					}))))) : null
				},
				Ls = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/ImageItemsWrapper.m.less"),
				As = n.n(Ls);
			var Fs = e => {
					const {
						onRemoveUpload: t,
						dispatch: n,
						mediaState: s,
						uploads: i
					} = e, a = Object(yn.a)(), c = Object(o.useCallback)(() => a(M.o()), [a]), d = Object(o.useCallback)(e => {
						t(e.uploadKey), a(M.q())
					}, [a, t]);
					return r.a.createElement("div", {
						className: As.a.itemsWrapper
					}, r.a.createElement(ss.a, {
						className: As.a.sortableImages,
						values: s.items,
						getReactKey: e => e.uploadKey,
						render: (e, t, o, a, c) => {
							const l = i[e.uploadKey];
							if (!l) return null;
							if (Object(je.c)(l)) return r.a.createElement("span", {
								className: Object(p.a)(As.a.pendingItem, Object(Zo.b)({
									isLoading: !0
								}))
							});
							const u = e.uploadKey === s.selectedKey;
							return r.a.createElement("span", {
								className: As.a.imageStyles
							}, a && r.a.createElement("span", {
								className: As.a.hoverMarker
							}), r.a.createElement(Ds, {
								canDrop: c,
								dispatch: n,
								isDragging: o,
								isOver: a,
								isSelected: u,
								mediaItem: e,
								key: e.uploadKey,
								mediaUpload: l,
								removeGalleryItem: d
							}))
						},
						onDrop: (e, t, o) => {
							n((e => ({
								type: Yr.SetGalleryItems,
								payload: {
									items: e
								}
							}))(o))
						}
					}), s.items.length < is.b && r.a.createElement(Is, {
						onClickEvent: c,
						onFileInput: e.onFileInput
					}))
				},
				Bs = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/InputWrapper.m.less"),
				Us = n.n(Bs);
			var Ks = e => {
					const {
						uploads: t,
						galleryItem: n,
						isSelected: s,
						dispatch: i
					} = e, a = t[n.uploadKey], c = n.caption, l = n.url, u = Object(yn.a)(), m = Object(o.useCallback)(e => i((e => ({
						type: Yr.SetCaptionInput,
						payload: {
							input: e
						}
					}))(e)), [i]), h = Object(o.useCallback)(e => i((e => ({
						type: Yr.SetURLInput,
						payload: {
							input: e
						}
					}))(e)), [i]), b = Object(o.useCallback)(e => u(M.p(e)), [u]), f = Object(o.useCallback)(() => b(C.m.CAPTION), [b]), g = Object(o.useCallback)(() => b(C.m.OUTBOUND_URL), [b]), v = !s || !a || !a.url || Object(je.c)(a);
					return r.a.createElement("div", null, r.a.createElement("div", {
						className: Us.a.inputWrapper
					}, r.a.createElement(Hr, {
						className: Us.a.inputStyles,
						disabled: v,
						maxLength: is.a,
						onFocus: f,
						onValueChange: m,
						placeholder: d.fbt._("Add a caption...", null, {
							hk: "1fOmKi"
						}),
						value: c
					}), r.a.createElement("div", {
						className: Us.a.charsCounter
					}, c.length, "/", is.a)), r.a.createElement("div", {
						className: Us.a.inputWrapper
					}, r.a.createElement(Hr, {
						className: Object(p.a)(Us.a.inputStyles, Us.a.urlInputStyles),
						disabled: v,
						onFocus: g,
						onValueChange: h,
						placeholder: d.fbt._("Add a link...", null, {
							hk: "Z6l9K"
						}),
						value: l
					})))
				},
				Ws = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/Layout.m.less"),
				Gs = n.n(Ws);
			var Hs = e => {
					const {
						heroSlot: t,
						mainContent: n,
						sideMetaContent: o,
						bottomContent: s
					} = e;
					return r.a.createElement("div", {
						className: Gs.a.Layout
					}, r.a.createElement("div", {
						className: Gs.a.hero
					}, t), n && r.a.createElement("div", {
						className: Gs.a.mainContent
					}, n), o && r.a.createElement("div", {
						className: Gs.a.sideMetaContent
					}, o), r.a.createElement("div", {
						className: Gs.a.bottomContent
					}, s))
				},
				Vs = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/SelectedImage.m.less"),
				zs = n.n(Vs);
			var qs = e => {
					const {
						upload: t
					} = e, n = t.metadata.localUrl;
					return Object(je.c)(t) ? r.a.createElement("span", {
						className: Object(p.a)(zs.a.pendingImage, Object(Zo.b)({
							isLoading: !0
						}))
					}) : r.a.createElement("img", {
						className: zs.a.selectedImage,
						src: n
					})
				},
				Qs = n("./src/reddit/components/ProgressBar/index.tsx"),
				Ys = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/MultipleUploadStatusBar/index.m.less"),
				Js = n.n(Ys);
			const {
				fbt: Xs
			} = n("./node_modules/fbt/lib/FbtPublic.js"), Zs = fe.a.div("ControlRow", Js.a), $s = fe.a.div("Status", Js.a);
			var ei = fe.a.wrapped(e => {
					const {
						progress: t
					} = e, n = t && t.percent || 0;
					return r.a.createElement("div", {
						className: e.className
					}, r.a.createElement(Qs.a, {
						percent: n,
						className: Js.a.OuterDivProgressBar,
						innerBarClassName: Js.a.ProgressBar
					}), r.a.createElement(Zs, null, r.a.createElement($s, {
						className: Js.a.StatusText
					}, n < 100 ? Xs._("Image uploading in progress...", null, {
						hk: "n2dCj"
					}) : Xs._("Image uploading completed", null, {
						hk: "4ko42w"
					}))))
				}, "Component", Js.a),
				ti = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/index.m.less"),
				ni = n.n(ti);

			function oi(e) {
				const {
					canDrop: t,
					dispatch: n,
					isOver: s,
					mediaState: i,
					onFileInput: a,
					onRemoveUpload: c,
					uploads: l
				} = e, [u, m] = Object(o.useState)([]), h = i.selectedKey, b = i.items.length > 1, f = i.items.find(e => e.uploadKey === h), g = h && l[h], v = i.items.filter(e => {
					const t = l[e.uploadKey];
					return !!t && t.status === je.a.FAILED
				}).length, C = Object.values(l).filter(je.c);
				if (!rs()(u, C))
					if (0 === C.length) m([]);
					else {
						const e = C.filter(e => !u.some(t => t.key === e.key));
						e.length > 0 && m([...u, ...e])
					} const y = u.length > 0,
					E = {
						percent: (() => {
							if (!y) return 0;
							let e = 0;
							return u.forEach(t => {
								const n = l[t.key];
								if (null == n || n && (n.status === je.a.CANCELED || n.status === je.a.FAILED || n.status === je.a.SUCCESS)) e += 100;
								else {
									const n = l[t.key].progress;
									e += n && n.percent || 0
								}
							}), e / u.length
						})(),
						uploaded: 0
					};
				return r.a.createElement(r.a.Fragment, null, r.a.createElement("div", {
					className: Object(p.a)(ni.a.dropArea, {
						[ni.a.isDropAreaActive]: t,
						[ni.a.isDropAreaOver]: s
					})
				}, r.a.createElement(Hs, {
					heroSlot: r.a.createElement(Fs, {
						mediaState: i,
						onFileInput: a,
						onRemoveUpload: c,
						uploads: l,
						dispatch: n
					}),
					mainContent: g && b && r.a.createElement(qs, {
						upload: g
					}),
					sideMetaContent: f && b && r.a.createElement(Ks, {
						dispatch: n,
						galleryItem: f,
						uploads: l,
						isSelected: !!h
					}),
					bottomContent: null
				})), y ? r.a.createElement(ei, {
					progress: E
				}) : null, !!v && r.a.createElement(ye.a, {
					className: ni.a.errorMessage,
					messages: [d.fbt._("Some files failed to upload, please remove or retry them", null, {
						hk: "3BP9AQ"
					})]
				}))
			}
			var ri = n("./src/reddit/components/RichTextEditor/DragController/helpers.ts"),
				si = n("./src/reddit/components/ThumbnailSelector/index.tsx"),
				ii = n("./src/reddit/controls/FileDrop/index.tsx"),
				ai = n("./src/reddit/helpers/media/index.ts"),
				ci = n("./src/telemetry/models/Media.ts"),
				di = n("./src/reddit/components/MakeGifToggle/index.tsx"),
				li = n("./src/reddit/icons/svgs/ThumbnailSelect/index.tsx"),
				ui = n("./src/reddit/components/HTML5StreamPlayer/index.tsx"),
				mi = n("./src/reddit/components/Media/ShredditPlayerWrapper/index.tsx"),
				pi = n("./src/reddit/selectors/experiments/d2xShredditPlayer.ts"),
				hi = n("./src/reddit/components/PostCreationForm/MediaInput/MediaUpload/Preview/index.m.less"),
				bi = n.n(hi);
			const fi = fe.a.img("Img", bi.a),
				gi = fe.a.img("BlurImg", bi.a),
				vi = fe.a.wrapped(e => {
					const {
						className: t,
						url: n
					} = e;
					return r.a.createElement("div", {
						className: t
					}, r.a.createElement(gi, {
						src: n
					}), r.a.createElement(fi, {
						src: n
					}))
				}, "ImagePreview", bi.a),
				Ci = fe.a.wrapped(e => {
					const {
						className: t,
						url: n,
						showControls: o,
						videoBlurImgSrc: i
					} = e;
					return Object(s.e)(pi.c) ? r.a.createElement("div", {
						className: t
					}, r.a.createElement(mi.a, {
						isGif: !1,
						isListing: !1,
						posterUrl: i,
						preventAutoplay: !0,
						shouldUseInitializationOptimization: !0,
						source: n
					})) : r.a.createElement("div", {
						className: t
					}, r.a.createElement(ui.b, {
						shouldLoad: !1,
						shouldPause: !1,
						isGif: !1,
						otherSource: n,
						showControlBar: o,
						showSettingsIcon: !1,
						blurImageSrc: i
					}))
				}, "VideoPreview", bi.a);
			var yi = fe.a.wrapped(e => {
					const {
						className: t,
						type: n,
						url: o,
						showControls: s,
						videoBlurImgSrc: i
					} = e;
					return r.a.createElement("div", {
						className: t
					}, "image" === n ? r.a.createElement(vi, {
						url: o
					}) : r.a.createElement(Ci, {
						url: o,
						videoBlurImgSrc: i,
						showControls: s
					}))
				}, "Component", bi.a),
				Ei = n("./src/reddit/components/PostCreationForm/MediaInput/MediaUpload/UploadStatusBar/index.m.less"),
				xi = n.n(Ei);
			const {
				fbt: Oi
			} = n("./node_modules/fbt/lib/FbtPublic.js"), _i = fe.a.div("ControlRow", xi.a), ki = fe.a.wrapped(ct.r, "Button", xi.a), ji = fe.a.div("Status", xi.a);
			var Si = fe.a.wrapped(e => {
					const {
						name: t,
						progress: n,
						onCancel: o
					} = e, s = n && n.percent || 0;
					return r.a.createElement("div", {
						className: e.className
					}, r.a.createElement(Qs.a, {
						percent: s
					}), r.a.createElement(_i, null, r.a.createElement(ji, null, s < 100 ? Oi._("Uploading {fileName}", [Oi._param("fileName", t)], {
						hk: "1F1ZHh"
					}) : Oi._("Success!", null, {
						hk: "2SQAeu"
					})), s < 100 && r.a.createElement(ki, {
						onClick: o
					}, Oi._("Cancel", null, {
						hk: "2TSLl5"
					}))))
				}, "Component", xi.a),
				Ti = n("./src/reddit/components/RichTextEditor/Toolbar/FormatterButton/index.tsx"),
				wi = n("./src/reddit/components/PostCreationForm/MediaInput/MediaUpload/index.m.less"),
				Ii = n.n(wi);
			const Pi = fe.a.div("Wrapper", Ii.a),
				Ni = fe.a.div("Controls", Ii.a),
				Ri = fe.a.wrapped(li.a, "ThumbnailSelect", Ii.a),
				Mi = e => {
					let {
						isFilled: t,
						...n
					} = e;
					return r.a.createElement(Ri, n)
				};

			function Di(e) {
				const {
					isPostSubmitPending: t,
					mediaType: n,
					onCancelUpload: o,
					onRemove: s,
					upload: i
				} = e, a = i.metadata, {
					localUrl: c,
					videoFirstFrameUrl: l
				} = a, u = i.status, m = u === je.a.PENDING || u === je.a.UPLOADING, p = u === je.a.SUCCESS, h = !t;
				return r.a.createElement(Pi, null, m ? r.a.createElement(Si, {
					className: Ii.a.UploadStatusBar,
					name: i.file.name,
					progress: i.progress,
					onCancel: o
				}) : null, c ? r.a.createElement(yi, {
					type: n,
					url: c,
					showControls: p,
					videoBlurImgSrc: l
				}) : null, p && r.a.createElement(Ni, null, "video" === n && r.a.createElement(di.a, {
					disabled: !!e.makeGifDisableReason || !h,
					tooltip: e.makeGifDisableReason,
					on: e.isMakeGifToggleOn,
					onClick: e.onMakeGifToggle
				}), "video" === n && r.a.createElement(Ti.a, {
					enabled: h,
					Icon: Mi,
					tooltip: d.fbt._("Choose thumbnail", null, {
						hk: "2XlKfd"
					}),
					onClick: e.onShowThumbnailSelector
				}), r.a.createElement(Ti.a, {
					enabled: h,
					iconName: "delete",
					tooltip: d.fbt._("Remove", null, {
						hk: "H42IB"
					}),
					onClick: s
				})))
			}
			var Li = n("./src/reddit/components/PostCreationForm/MediaInput/RemovePrompt/index.m.less"),
				Ai = n.n(Li);
			const Fi = "POST_CREATION_MEDIA_REMOVE_PROMPT_ID",
				Bi = fe.a.div("Wrapper", Ai.a),
				Ui = fe.a.wrapped(yt.a, "TitleRow", Ai.a),
				Ki = fe.a.div("DetailsContainer", Ai.a),
				Wi = fe.a.wrapped(yt.a, "ButtonRow", Ai.a),
				Gi = fe.a.wrapped(ct.o, "CancelButton", Ai.a),
				Hi = fe.a.wrapped(ct.l, "ConfirmButton", Ai.a);
			var Vi = Object(Co.a)(e => {
					const {
						isVideo: t
					} = e;
					return r.a.createElement(Bi, null, r.a.createElement(Ui, null, t ? d.fbt._("Remove video?", null, {
						hk: "34eepe"
					}) : d.fbt._("Remove image?", null, {
						hk: "41e1Uy"
					})), r.a.createElement(Ki, null, t ? d.fbt._("Are you sure you want to remove your video?", null, {
						hk: "smTuF"
					}) : d.fbt._("Are you sure you want to remove your image?", null, {
						hk: "Ci5LM"
					})), r.a.createElement(Wi, null, r.a.createElement(Gi, {
						onClick: e.onCanceled
					}, d.fbt._("Keep", null, {
						hk: "4gFSdj"
					})), r.a.createElement(Hi, {
						onClick: e.onConfirmed
					}, d.fbt._("Remove", null, {
						hk: "3tYl0U"
					}))))
				}),
				zi = n("./src/reddit/components/PostCreationForm/MediaInput/index.m.less"),
				qi = n.n(zi);
			const Qi = "MEDIA_POST_VIDEO_THUMBNAIL_SELECTOR_MODAL_ID",
				Yi = Object(R.v)(),
				Ji = Object(i.c)({
					activeModalId: D.a,
					isPostPending: w.eb,
					uploads: Object(ns.a)(e => es()(e.uploads, e => e.key.startsWith(W.a))),
					value: w.Z,
					isImageGalleryCreationEnabled: w.P,
					isVideoCreationEnabled: w.W
				}),
				Xi = Object(s.b)(Ji, e => ({
					onChange: t => e(a.d(t)),
					startMediaGalleryUploads: (t, n) => e(W.d(t, n)),
					removeUpload: t => e(q.i(t, !0)),
					toggleThumbnailModal: () => e(a.z(Qi)),
					toggleRemovePrompt: () => e(a.z(Fi))
				})),
				Zi = fe.a.div("Container", qi.a),
				$i = (e, t, n) => {
					if (!e.length) return null;
					let o = e.findIndex(e => e.uploadKey === n);
					if (-1 === o) {
						const r = t.findIndex(e => e.uploadKey === n);
						o = Zr()(r - 1, 0, e.length - 1)
					}
					return e[o].uploadKey
				};
			class ea extends r.a.Component {
				constructor() {
					super(...arguments), this.onFileDrop = e => this.uploadMediaFiles(e, ci.FileSource.DragAndDrop), this.onFileInput = e => this.uploadMediaFiles(e, ci.FileSource.FileSelector), this.onRemoveUpload = e => {
						const {
							value: t
						} = this.props, {
							items: n,
							selectedKey: o
						} = t, r = n.filter(t => t.uploadKey !== e);
						this.props.onChange({
							...t,
							items: r,
							selectedKey: $i(r, n, o)
						}), this.props.removeUpload(e)
					}, this.onCancelSingleMediaUpload = () => {
						this.onRemoveUpload(this.getSingleUpload().key)
					}, this.handlePaste = e => {
						if (e.clipboardData) {
							const t = Object(ri.a)(e.clipboardData);
							t.length && (e.preventDefault(), e.stopPropagation(), this.uploadMediaFiles(t, ci.FileSource.Clipboard))
						}
					}, this.onRemoveConfirmed = () => {
						this.props.toggleRemovePrompt(), this.onRemoveUpload(this.getSingleUpload().key)
					}, this.onThumbnailSelect = e => {
						this.toggleThumbnailSelector();
						const {
							value: t
						} = this.props;
						if (!Object(C.x)(t)) return;
						const n = t.items[0],
							o = n.video;
						this.props.onChange({
							...t,
							items: [{
								...n,
								video: {
									...o,
									thumbnail: e
								}
							}]
						})
					}, this.toggleThumbnailSelector = () => {
						this.props.toggleThumbnailModal()
					}, this.onMakeGifToggle = () => {
						const {
							value: e
						} = this.props;
						if (!Object(C.x)(e)) return;
						const t = e.items[0],
							n = t.video;
						this.props.onChange({
							...e,
							items: [{
								...t,
								video: {
									...n,
									isMakeGif: !n.isMakeGif
								}
							}]
						})
					}, this.dispatchAction = e => {
						const {
							value: t
						} = this.props, n = function(e, t) {
							switch (t.type) {
								case Yr.SelectGalleryItem: {
									const {
										key: n
									} = t.payload;
									return {
										...e,
										selectedKey: n
									}
								}
								case Yr.SetGalleryItems: {
									const {
										items: n
									} = t.payload;
									return {
										...e,
										items: n
									}
								}
								case Yr.SetCaptionInput: {
									const {
										input: n
									} = t.payload, {
										selectedKey: o,
										items: r
									} = e;
									return o ? {
										...e,
										items: r.map(e => e.uploadKey === o ? {
											...e,
											caption: n
										} : e)
									} : e
								}
								case Yr.SetURLInput: {
									const {
										input: n
									} = t.payload, {
										selectedKey: o,
										items: r
									} = e;
									return o ? {
										...e,
										items: r.map(e => e.uploadKey === o ? {
											...e,
											url: n
										} : e)
									} : e
								}
								case Yr.SelectPrevMedia: {
									const {
										selectedKey: t,
										items: n
									} = e, o = n.findIndex(e => e.uploadKey === t);
									let r = -1 === o ? 0 : o - 1;
									return r < 0 && (r = n.length - 1), {
										...e,
										selectedKey: n[r].uploadKey
									}
								}
								case Yr.SelectNextMedia: {
									const {
										selectedKey: t,
										items: n
									} = e, o = n.findIndex(e => e.uploadKey === t), r = -1 === o ? 0 : (o + 1) % n.length;
									return {
										...e,
										selectedKey: n[r].uploadKey
									}
								}
								default:
									return e
							}
						}(t, e);
						this.props.onChange(n)
					}, this.renderDropArea = (e, t) => {
						const {
							isPostPending: n,
							value: o,
							isImageGalleryCreationEnabled: s,
							uploads: i
						} = this.props;
						if (!Object(C.x)(o) && s && o.items.length >= 1) return r.a.createElement(oi, {
							isOver: e,
							canDrop: t,
							dispatch: this.dispatchAction,
							mediaState: o,
							onFileInput: this.onFileInput,
							onRemoveUpload: this.onRemoveUpload,
							uploads: i
						}); {
							const i = this.getSingleUpload(),
								a = this.props.value.items[0],
								{
									isMakeGif: c = !1,
									makeGifDisableReason: d = null
								} = a && a.video || {},
								l = i && i.status === je.a.FAILED,
								u = i && l ? Object(ts.a)(i.error) : "",
								m = i && Object(ai.g)(i.metadata.mimetype);
							return o && m && i && !l ? r.a.createElement(Di, {
								isPostSubmitPending: n,
								upload: i,
								mediaType: m,
								onRemove: this.props.toggleRemovePrompt,
								onCancelUpload: this.onCancelSingleMediaUpload,
								onShowThumbnailSelector: this.toggleThumbnailSelector,
								onMakeGifToggle: this.onMakeGifToggle,
								isMakeGifToggleOn: c,
								makeGifDisableReason: d
							}) : r.a.createElement(js, {
								lastErrorMsg: u,
								isOver: e,
								canDrop: t,
								onFileInput: this.onFileInput,
								allowMultiple: s
							})
						}
					}
				}
				componentDidMount() {
					document.addEventListener("paste", this.handlePaste)
				}
				componentWillUnmount() {
					document.removeEventListener("paste", this.handlePaste)
				}
				getSingleUpload() {
					const {
						items: e
					} = this.props.value, t = 1 === e.length && e[0];
					return t && this.props.uploads[t.uploadKey] || void 0
				}
				uploadMediaFiles(e, t) {
					this.props.startMediaGalleryUploads([...e], t)
				}
				render() {
					const {
						value: e
					} = this.props, {
						items: t
					} = e, n = this.getSingleUpload(), o = t[0], s = Object(C.x)(e), i = s && o.video.thumbnail || void 0;
					return r.a.createElement(Zi, null, r.a.createElement(ii.a, {
						render: (e, t) => this.renderDropArea(e, t),
						onDrop: this.onFileDrop
					}), n && n.metadata.videoDuration && r.a.createElement(si.a, {
						onSelect: this.onThumbnailSelect,
						onToggleModal: this.toggleThumbnailSelector,
						videoSource: n.metadata.localUrl,
						videoDuration: n.metadata.videoDuration,
						selected: i,
						isOpen: this.props.activeModalId === Qi
					}), this.props.activeModalId === Fi && r.a.createElement(Vi, {
						isVideo: s,
						onCanceled: this.props.toggleRemovePrompt,
						onConfirmed: this.onRemoveConfirmed
					}))
				}
			}
			var ta = Yi(Xi(ea)),
				na = n("./src/reddit/actions/post.ts"),
				oa = n("./src/reddit/controls/CheckboxInput/index.tsx"),
				ra = n("./src/reddit/controls/OutboundLink/index.tsx"),
				sa = n("./src/reddit/selectors/externalAccount.ts"),
				ia = n("./src/reddit/icons/fonts/Info/index.tsx"),
				aa = n("./src/reddit/components/PostCreationForm/PostCreationFooter/PostSettings/Hint/index.m.less"),
				ca = n.n(aa);
			const da = fe.a.wrapped(ia.a, "Info", ca.a),
				la = fe.a.div("TooltipContent", ca.a);
			var ua = e => r.a.createElement("div", {
					className: ca.a.Hint
				}, r.a.createElement(it.a, {
					className: ca.a.HoverTooltip,
					tooltipContentClass: ca.a.tooltipContentClass,
					text: r.a.createElement(la, null, e.text)
				}), r.a.createElement(da, null)),
				ma = n("./src/reddit/components/PostCreationForm/PostCreationFooter/PostSettings/index.m.less"),
				pa = n.n(ma);
			const ha = fe.a.wrapped(oa.a, "CheckboxInput", pa.a),
				ba = fe.a.wrapped(ra.b, "ConnectAccountLink", pa.a),
				fa = fe.a.div("Container", pa.a),
				ga = fe.a.div("ContainerLeft", pa.a),
				va = fe.a.div("ContainerRight", pa.a),
				Ca = fe.a.div("CheckboxText", pa.a),
				ya = fe.a.div("Option", pa.a),
				Ea = fe.a.wrapped(Ze.a, "TextButton", pa.a),
				xa = fe.a.input("TextBox", pa.a),
				Oa = fe.a.div("Wrapper", pa.a),
				_a = Object(i.c)({
					connectedTwitterAccount: sa.a,
					currentSubredditOrProfile: R.q,
					currentUser: B.m,
					isDraftPending: A.g,
					isMediaUploadPending: w.ab,
					isPostPending: w.tb,
					isPublicLink: w.T,
					postToTwitter: w.ib,
					sendReplies: w.mb,
					sharingLink: A.i,
					submissionType: w.a
				}),
				ka = Object(s.b)(_a, (e, t) => ({
					togglePostToTwitter: t => {
						e(a.A(t)), e((e, n) => M.I(n(), t))
					},
					toggleSendReplies: t => {
						e(a.B(t))
					},
					toggleDraftIsPublic: n => {
						e(V.s(n)), e(Object(V.r)(t.draftId)), e((e, o) => {
							const r = Object(A.h)(o(), t.draftId);
							r && M.i(o(), r, n)
						})
					},
					copyLink: t => e(Object(na.C)(t)),
					trackConnectAccountsClick: () => e((e, t) => M.d(t()))
				}), (e, t, n) => ({
					...e,
					...t,
					...n,
					onTogglePostToTwitter: () => t.togglePostToTwitter(!e.postToTwitter),
					onToggleSendReplies: () => t.toggleSendReplies(!e.sendReplies),
					onToggleDraftIsPublic: () => {
						t.toggleDraftIsPublic(!e.isPublicLink), e.isPublicLink || t.copyLink(e.sharingLink)
					},
					onCopyLink: () => t.copyLink(e.sharingLink)
				}));
			var ja = Object(R.v)()(ka(e => {
					const {
						connectedTwitterAccount: t,
						currentSubredditOrProfile: n,
						currentUser: o,
						draftId: s,
						submissionType: i
					} = e, a = !!n && !!n.isQuarantined, c = e.isDraftPending || e.isPostPending || e.isMediaUploadPending, l = i !== h.bc.MEDIA && s, u = e.isPublicLink, m = o && o.hasUserProfile;
					return r.a.createElement(fa, null, r.a.createElement(ga, {
						className: e.className
					}, r.a.createElement(yt.a, null, r.a.createElement(ya, null, r.a.createElement(ha, {
						disabled: c,
						name: "send-replies",
						onChange: e.onToggleSendReplies,
						value: e.sendReplies
					}, r.a.createElement(Ca, null, d.fbt._("Send me post reply notifications", null, {
						hk: "3kNmey"
					}))))), m && t && r.a.createElement(yt.a, null, r.a.createElement(ya, null, r.a.createElement(ha, {
						disabled: c || a,
						name: "post-to-twitter",
						onChange: e.onTogglePostToTwitter,
						value: e.postToTwitter
					}, r.a.createElement(Ca, null, d.fbt._("Share this post on Twitter", null, {
						hk: "3SPI4V"
					}))))), m && !t && !a && r.a.createElement(yt.a, null, r.a.createElement(ba, {
						href: "/settings#connected-accounts",
						onClick: e.trackConnectAccountsClick
					}, d.fbt._("Connect accounts to share your post", null, {
						hk: "1nIuWp"
					})), r.a.createElement(ua, {
						text: d.fbt._("Connect a Twitter account in your User Settings. With a connected account you can choose to share new posts you make directly to Twitter.", null, {
							hk: "JRoQz"
						})
					}))), r.a.createElement(va, {
						className: e.className
					}, l && r.a.createElement(Oa, null, r.a.createElement(ya, null, r.a.createElement(ha, {
						name: "enable-public-link",
						onChange: e.onToggleDraftIsPublic,
						value: e.isPublicLink
					}, r.a.createElement(Ca, null, d.fbt._("Enable public draft link", null, {
						hk: "1SpDgT"
					})), r.a.createElement(ua, {
						text: d.fbt._("This option will create a link to a preview of this draft. Anyone with this link will be able to see this draft. You can disable this link at any time.", null, {
							hk: "1r77YF"
						})
					})))), l && u && r.a.createElement(yt.a, null, r.a.createElement(xa, {
						disabled: !0,
						value: e.sharingLink
					}), r.a.createElement(Ea, {
						onClick: e.onCopyLink
					}, d.fbt._("Copy link", null, {
						hk: "22rywZ"
					})))))
				})),
				Sa = n("./src/reddit/components/PostCreationForm/PostCreationFooter/index.m.less"),
				Ta = n.n(Sa);
			const wa = fe.a.div("Container", Ta.a);
			var Ia = e => r.a.createElement(wa, null, r.a.createElement(ja, {
					draftId: e.draftId
				})),
				Pa = n("./src/reddit/featureFlags/profileCollections.ts"),
				Na = n("./src/reddit/selectors/profile.ts"),
				Ra = n("./src/reddit/components/PostCreationForm/PostCreationHeader/index.m.less"),
				Ma = n.n(Ra);
			const Da = fe.a.span("CountIndicator", Ma.a),
				La = fe.a.wrapped(ct.r, "LinkButton", Ma.a),
				Aa = La,
				Fa = Object(i.c)({
					canPostAsModerator: w.e,
					collectionsCount: e => {
						const t = Object(w.h)(e);
						let n = t.id;
						if (t.isProfile && Object(Pa.a)(e)) {
							const o = Object(Na.k)(e, {
								profileName: t.name
							});
							n = o && o.id
						}
						return n ? Object(O.u)(e, {
							subredditId: n
						}) : 0
					},
					destSubredditAboutInfo: w.g,
					draftsCount: B.n,
					isPending: w.eb,
					isOpenAIPilotV1: Y.g
				});
			var Ba = Object(s.b)(Fa, e => ({
					showDraftsList: () => {
						e(V.p()), e(a.z(C.e))
					},
					showCollectionsList: () => {
						e(a.z(C.a))
					}
				}))(e => {
					const {
						canPostAsModerator: t,
						collectionsCount: n,
						destSubredditAboutInfo: s,
						draftsCount: i,
						isPending: a,
						showCollectionsList: c,
						showDraftsList: l,
						submissionType: u,
						submitMode: m,
						isOpenAIPilotV1: b
					} = e, f = Object(ee.b)(), g = Object(o.useCallback)(() => {
						l(), f(Object(M.k)(i))
					}, [l, f, i]), v = u === h.bc.CROSSPOST, y = v ? d.fbt._("Create a crosspost", null, {
						hk: "1oNF7H"
					}) : d.fbt._("Create a post", null, {
						hk: "4u8qEy"
					}), E = t && s && s.collectionsEnabled;
					return r.a.createElement("div", {
						className: Object(p.a)(Ma.a.CreatePostHeader, {
							[Ma.a.isSubredditRec]: b
						})
					}, r.a.createElement("div", {
						className: Ma.a.CreateLabel
					}, m === C.r.Draft ? d.fbt._("Edit draft", null, {
						hk: "oMgcW"
					}) : y), !v && r.a.createElement(r.a.Fragment, null, E && r.a.createElement(Aa, {
						onClick: c
					}, d.fbt._("Collections", null, {
						hk: "2FVot0"
					}), r.a.createElement(Da, null, n)), r.a.createElement(La, {
						disabled: a,
						onClick: g
					}, d.fbt._("Drafts", null, {
						hk: "25z4rQ"
					}), r.a.createElement(Da, null, i))))
				}),
				Ua = n("./src/reddit/actions/polls.ts"),
				Ka = n("./src/reddit/actions/postCreation/editorContent.ts"),
				Wa = n("./src/reddit/actions/postCreation/postGuidance.ts"),
				Ga = n("./src/reddit/components/Governance/TokenAmount/index.tsx"),
				Ha = n("./src/reddit/selectors/crypto/points.ts"),
				Va = n("./src/reddit/components/Governance/PollHelpText/index.m.less"),
				za = n.n(Va);

			function qa(e) {
				var t;
				const {
					subreddit: n
				} = e, o = Object(s.e)(e => Object(Ha.b)(e, n.id));
				if (!o) return null;
				const i = null === (t = o.polls) || void 0 === t ? void 0 : t.decisionThreshold;
				return r.a.createElement("div", {
					className: za.a.pollHelpText
				}, i && r.a.createElement(r.a.Fragment, null, r.a.createElement(Ga.a, {
					className: za.a.decisionThreholdAmount,
					amount: i,
					subredditId: n.id
				}), r.a.createElement("div", {
					className: za.a.decisionThresholdTitle
				}, d.fbt._("Decision Threshold", null, {
					hk: "39nut8"
				}))), r.a.createElement("div", {
					className: za.a.decisionThresholdExplanation
				}, d.fbt._("Governance Polls pass when one option reaches the Decision Threshold. The Decision Threshold is updated regularly based on the number of {tokenName} that voted in previous governance polls.", [d.fbt._param("tokenName", o.name)], {
					hk: "Di1tp"
				})))
			}
			var Qa = n("./src/reddit/actions/governance/index.ts"),
				Ya = n("./src/reddit/actions/tooltip.ts"),
				Ja = n("./src/reddit/controls/Dropdown/index.tsx"),
				Xa = n("./src/reddit/controls/Dropdown/Row.tsx"),
				Za = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				$a = n("./src/reddit/components/PollCreator/EndDatePicker/utils.ts");
			const ec = () => ({
					text: ""
				}),
				tc = () => ({
					duration: 3 * h.D,
					endDate: Object($a.b)(),
					options: Array.from({
						length: 2
					}).map(ec)
				});
			var nc = n("./src/reddit/components/PollCreator/SortableOptions/index.m.less"),
				oc = n.n(nc),
				rc = n("./src/reddit/icons/svgs/Grapple/index.tsx");

			function sc(e) {
				return r.a.createElement("div", {
					className: Object(p.a)(e.className, oc.a.container),
					style: {
						left: e.isDropTarget ? 16 : 0,
						opacity: ic(e),
						pointerEvents: e.isDisabled ? "none" : void 0
					}
				}, r.a.createElement(rc.a, {
					className: oc.a.grapple
				}), r.a.createElement("input", {
					className: oc.a.input,
					maxLength: 120,
					placeholder: `${d.fbt._("option",null,{hk:"3IGnB"})} ${e.index+1}`,
					value: e.text,
					onBlur: e.onBlur,
					onChange: t => e.onTextChange(t.currentTarget.value),
					onFocus: e.onFocus
				}), e.removable && r.a.createElement(xo.a, {
					className: oc.a.trash,
					onClick: e.onRemove
				}))
			}

			function ic(e) {
				return e.isDisabled ? .5 : e.isBeingDragged ? .25 : 1
			}
			const {
				fbt: ac
			} = n("./node_modules/fbt/lib/FbtPublic.js");

			function cc(e, t) {
				return `${t}-${e}`
			}
			const dc = e => {
				let {
					poll: t,
					onUpdatePoll: n,
					disabled: s,
					renderExtraControls: i
				} = e;
				const a = Object(yn.a)(),
					[c, d] = Object(o.useState)(!1),
					l = () => d(!1),
					u = () => d(!0),
					m = e => {
						c && (e.preventDefault(), e.stopPropagation())
					},
					p = e => o => {
						const r = t.options.indexOf(e);
						n({
							...t,
							options: t.options.slice(0, r).concat({
								text: o
							}).concat(t.options.slice(r + 1))
						})
					},
					h = e => () => {
						n({
							...t,
							options: t.options.filter(t => t !== e)
						})
					};
				Object(o.useEffect)(() => (document.addEventListener("dragstart", m), document.addEventListener("drop", m), document.addEventListener("dragover", m), () => {
					document.removeEventListener("dragstart", m), document.removeEventListener("drop", m), document.removeEventListener("dragover", m)
				}));
				const b = t.options.length >= 6 || s;
				return r.a.createElement("div", {
					className: oc.a.options
				}, r.a.createElement(ss.a, {
					getReactKey: cc,
					render: (e, t, n, o, i) => r.a.createElement(sc, {
						index: t,
						isBeingDragged: n,
						isDisabled: s,
						isDropTarget: o && i,
						option: e,
						removable: t > 1,
						text: e.text,
						onBlur: l,
						onFocus: u,
						onTextChange: p(e),
						onRemove: h(e)
					}),
					values: t.options,
					onDrop: (e, o, r) => n({
						...t,
						options: r
					})
				}), r.a.createElement("div", {
					className: oc.a.controls
				}, r.a.createElement(ct.t, {
					className: oc.a.addButton,
					disabled: b,
					onClick: () => void(t.options.length <= 6 && (a(Object(M.z)()), n({
						...t,
						options: t.options.concat({
							text: ""
						})
					}))),
					priority: ct.c.Plain
				}, ac._("Add Option", null, {
					hk: "hUP0k"
				})), i && i()))
			};
			var lc = n("./src/reddit/components/PollCreator/index.m.less"),
				uc = n.n(lc);
			const mc = 7,
				pc = "poll-creation-voting-length";
			var hc;
			! function(e) {
				e.Options = "options", e.VotingLength = "votingLength"
			}(hc || (hc = {}));
			const bc = Object(Ht.a)(Ja.a),
				fc = Object(i.c)({
					tournamentsEnabled: (e, t) => {
						let {
							subredditId: n
						} = t;
						return !!n && Object(F.S)(e, {
							subredditId: n
						})
					},
					allowPolls: w.d,
					votingLengthDropdownIsOpen: e => e.tooltip.tooltipId === pc
				});
			class gc extends r.a.Component {
				constructor(e) {
					super(e), this.handleVotingLengthDropdownClick = () => {
						const {
							sendEvent: e,
							votingLengthDropdownIsOpen: t
						} = this.props;
						t || e(Object(M.A)()), this.props.onToggleVotingLengthDropdown()
					}, this.handleChangeVotingLength = e => t => {
						this.props.onUpdatePoll({
							...e,
							duration: t
						}), this.props.onToggleVotingLengthDropdown()
					}
				}
				sectionIsDisabled(e) {
					return this.props.disabledSections && this.props.disabledSections.includes(e)
				}
				render() {
					const {
						className: e,
						poll: t = tc()
					} = this.props;
					return r.a.createElement("div", {
						"data-testid": "poll-creator"
					}, r.a.createElement("div", {
						className: Object(p.a)(e, uc.a.container)
					}, r.a.createElement(dc, {
						poll: t,
						disabled: Boolean(this.sectionIsDisabled(hc.Options)),
						onUpdatePoll: this.props.onUpdatePoll,
						renderExtraControls: () => this.renderControls(t)
					}), this.props.hintTextComponent && r.a.createElement("div", {
						className: uc.a.help
					}, this.props.hintTextComponent)))
				}
				renderControls(e) {
					const t = this.sectionIsDisabled(hc.VotingLength),
						n = Math.floor(e.duration / h.D);
					return r.a.createElement("div", {
						className: Object(p.a)(uc.a.votingLengthSelector, {
							[uc.a.votingLengthSelector__disabled]: !!t
						})
					}, r.a.createElement("div", {
						className: uc.a.votingLengthTitleText
					}, d.fbt._("Voting length:", null, {
						hk: "4pPVUg"
					})), r.a.createElement("div", {
						className: uc.a.votingLengthDropdownContainer,
						id: pc
					}, r.a.createElement("div", {
						className: uc.a.votingLengthDisplay,
						onClick: this.handleVotingLengthDropdownClick
					}, r.a.createElement("div", null, d.fbt._({
						"*": "{numDays} days",
						_1: "{numDays} day"
					}, [d.fbt._param("numDays", String(n)), d.fbt._plural(n)], {
						hk: "2HsFBA"
					})), r.a.createElement(Za.a, {
						className: uc.a.votingLengthCaret
					})), this.renderVotingLengthDropdown(e)))
				}
				renderVotingLengthDropdown(e) {
					const {
						votingLengthDropdownIsOpen: t
					} = this.props, n = this.handleChangeVotingLength(e);
					return r.a.createElement(bc, {
						className: uc.a.votingLengthDropdown,
						tooltipId: pc,
						isOpen: t
					}, Array.from({
						length: mc
					}).map((t, o) => {
						const s = o + 1;
						return r.a.createElement(Xa.b, {
							"data-redditstyle": !0,
							key: o,
							index: o,
							displayText: d.fbt._({
								"*": "{number} days",
								_1: "1 day"
							}, [d.fbt._plural(s, "number")], {
								hk: "bXXYo"
							}),
							isSelected: Math.floor(e.duration / h.D) === s,
							onClick: () => n(s * h.D)
						})
					}))
				}
			}
			var vc = Object(s.b)(fc, (e, t) => ({
					onToggleVotingLengthDropdown: () => e(Object(Ya.h)({
						tooltipId: pc
					})),
					setPollType: n => e(Object(a.l)({
						oldType: t.pollType || null,
						type: n
					}))
				}))(Object(ee.c)(gc)),
				Cc = n("./src/reddit/components/Governance/ProposalTemplates/Generic/index.m.less"),
				yc = n.n(Cc);
			const Ec = [{
				text: "Yes"
			}, {
				text: "No"
			}];

			function xc(e) {
				const t = {
					duration: e.poll ? e.poll.duration : h.D,
					options: e.options || Ec
				};
				return r.a.createElement("div", {
					className: Object(p.a)(yc.a.container, e.className)
				}, r.a.createElement("div", {
					className: yc.a.topline
				}, e.children.map(e => "string" == typeof e ? r.a.createElement("div", {
					className: yc.a.text
				}, e) : e)), r.a.createElement(vc, {
					disabledSections: [hc.Options],
					hintTextComponent: r.a.createElement("div", {
						className: yc.a.hintText
					}, r.a.createElement(qa, {
						subreddit: e.subreddit
					})),
					poll: t,
					onUpdatePoll: e.onUpdatePoll
				}))
			}
			var Oc = n("./src/reddit/controls/FormFields/index.tsx"),
				_c = n("./src/reddit/components/Governance/ProposalTemplates/Spinoff/index.m.less"),
				kc = n.n(_c);
			const jc = 3,
				Sc = 20,
				Tc = /[^(\w|_)]/g;
			const wc = Object(i.c)({
				newSubredditName: e => e.creations.formData.newSubreddit
			});
			var Ic = Object(s.b)(wc, e => ({
					onSubredditNameChange: t => e(Object(Qa.a)({
						subredditName: t
					}))
				}))((function(e) {
					return r.a.createElement(xc, {
						className: e.className,
						options: ke.f[ke.a.Spinoff](e.newSubredditName),
						poll: e.poll,
						subreddit: e.subreddit,
						onUpdatePoll: e.onUpdatePoll
					}, d.fbt._("Should we spin-off to", null, {
						hk: "3oKiyE"
					}), r.a.createElement(Oc.c, {
						redditStyle: !0,
						className: kc.a.input,
						label: d.fbt._("subreddit name", null, {
							hk: "1qzJqB"
						}),
						max: Sc,
						min: jc,
						type: "text",
						value: e.newSubredditName,
						onChange: t => {
							const n = t.currentTarget.value.replace(Tc, "");
							e.onSubredditNameChange(n)
						}
					}), d.fbt._("?", null, {
						hk: "1b1vhH"
					}))
				})),
				Pc = n("./src/reddit/components/Governance/ProposalTemplates/TopModReplacement/index.m.less"),
				Nc = n.n(Pc);
			const Rc = 20;
			const Mc = Object(i.c)({
				topMod: e => e.creations.formData.newTopMod
			});
			var Dc = Object(s.b)(Mc, e => ({
					onUsernameChange: t => e(Object(Qa.b)({
						username: t
					}))
				}))((function(e) {
					return r.a.createElement(xc, {
						className: e.className,
						options: ke.f[ke.a.ReplaceTopMod](),
						poll: e.poll,
						subreddit: e.subreddit,
						onUpdatePoll: e.onUpdatePoll
					}, d.fbt._("Should", null, {
						hk: "22RF0A"
					}), r.a.createElement(Oc.c, {
						redditStyle: !0,
						className: Nc.a.input,
						label: d.fbt._("username", null, {
							hk: "1Fk03V"
						}),
						max: Rc,
						type: "text",
						value: e.topMod,
						onChange: t => e.onUsernameChange(t.currentTarget.value)
					}), d.fbt._("become the top moderator?", null, {
						hk: "4COtce"
					}))
				})),
				Lc = n("./src/reddit/icons/svgs/Info/index.tsx"),
				Ac = n("./src/reddit/components/PollCreator/DefaultHintText/index.m.less"),
				Fc = n.n(Ac);
			const Bc = e => [() => d.fbt._("Suggest short clear options", null, {
				hk: "4bpIfe"
			}), () => d.fbt._("The more options, the better", null, {
				hk: "37GJUq"
			}), () => e ? d.fbt._("Choose the prediction duration", null, {
				hk: "16Yw7y"
			}) : d.fbt._("Choose the poll duration", null, {
				hk: "19Gh6D"
			}), () => d.fbt._("Options can't be edited after post creation", null, {
				hk: "3iRICg"
			})];

			function Uc(e) {
				const {
					isPrediction: t
				} = e;
				return r.a.createElement(o.Fragment, null, r.a.createElement("div", {
					className: Fc.a.helpTitle
				}, r.a.createElement(Lc.a, {
					className: Fc.a.infoIcon
				}), r.a.createElement("div", {
					className: Fc.a.helpTitleText
				}, t ? d.fbt._("Tips on Better Predictions", null, {
					hk: "3kIzkr"
				}) : d.fbt._("Tips on Better Polls", null, {
					hk: "2QMuX9"
				}))), r.a.createElement("ol", {
					className: Fc.a.helpTextList
				}, Bc(!!t).map(e => r.a.createElement("li", {
					className: Fc.a.helpTextItem,
					key: e()
				}, e()))))
			}
			var Kc = n("./src/reddit/components/PostCreationForm/MarkdownEditor/index.tsx"),
				Wc = n("./src/reddit/components/RichTextEditor/index.tsx"),
				Gc = n("./src/reddit/featureFlags/component.tsx"),
				Hc = n("./src/reddit/helpers/richTextEditor/index.ts"),
				Vc = n("./src/reddit/models/PostRequirements/index.ts"),
				zc = n("./src/reddit/components/Econ/Prediction/hooks/useTournamentsQuery.ts"),
				qc = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/DateInput/index.tsx"),
				Qc = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/TimeInput/index.tsx"),
				Yc = n("./src/reddit/components/PollCreator/EndDatePicker/useEndDatePicker.tsx"),
				Jc = n("./src/reddit/components/PollCreator/EndDatePicker/index.m.less"),
				Xc = n.n(Jc);

			function Zc(e) {
				let {
					poll: t
				} = e;
				const n = Object(s.d)(),
					{
						endDate: o
					} = t,
					{
						date: i,
						time: a,
						timeZoneAbbr: c,
						onChange: l,
						maxDate: u,
						minDate: m,
						minTime: p
					} = Object(Yc.a)(o, e => n(Object(Ua.b)({
						...t,
						endDate: e
					})));
				return r.a.createElement("div", {
					className: Xc.a.dateTime
				}, r.a.createElement(qc.a, {
					"aria-label": d.fbt._("Prediction end date", null, {
						hk: "4zYv4T"
					}),
					onChange: e => l({
						date: e
					}),
					min: m,
					max: u,
					value: i,
					required: !0
				}), r.a.createElement(Qc.a, {
					className: Xc.a.timeInput,
					"aria-label": d.fbt._("Prediction end time", null, {
						hk: "1idFl4"
					}),
					onChange: e => l({
						time: e
					}),
					min: p,
					value: a,
					required: !0
				}), c && r.a.createElement("div", {
					className: Xc.a.timeZone
				}, c))
			}
			var $c = n("./src/reddit/components/ContentTooltip/index.tsx"),
				ed = n("./src/reddit/selectors/telemetry.ts");
			const td = e => ({
					...Object(ed.p)(e),
					source: vn.a,
					action: "view",
					noun: "predict_info_modal",
					subreddit: Object(ed.mb)(e)
				}),
				nd = e => ({
					...Object(ed.p)(e),
					source: vn.a,
					action: "close",
					noun: "predict_info_modal",
					subreddit: Object(ed.mb)(e)
				}),
				od = e => ({
					...Object(ed.p)(e),
					source: vn.a,
					action: "click",
					noun: "predictions_how_it_works",
					subreddit: Object(ed.mb)(e),
					actionInfo: {
						pageType: "predict_info_modal"
					}
				});
			var rd = n("./src/reddit/components/PostCreationForm/PredictionEditor/TooltipHeader/index.m.less"),
				sd = n.n(rd);
			const {
				fbt: id
			} = n("./node_modules/fbt/lib/FbtPublic.js"), ad = {
				top: at.a.alienblue,
				bottom: at.a.alienblue
			}, cd = e => {
				let {
					tooltipId: t,
					tooltipContent: n,
					className: i,
					isDisabled: a,
					children: c
				} = e;
				const [d, l] = Object(o.useState)(!1), u = Object(s.d)(), m = Object(yn.a)(), h = Object(Oe.b)("help"), b = () => {
					l(!d), u(Object(Ya.h)({
						tooltipId: t
					}))
				};
				return r.a.createElement("div", {
					className: Object(p.a)(sd.a.wrapper, i, {
						[sd.a.isDisabled]: a
					})
				}, r.a.createElement("h3", {
					className: sd.a.sectionLabel
				}, c), r.a.createElement("span", {
					id: t,
					onMouseEnter: () => {
						m((e => t => ({
							...Object(ed.p)(t),
							source: vn.a,
							action: "view",
							noun: "info_tooltip",
							subreddit: Object(ed.mb)(t),
							actionInfo: {
								...Object(ed.d)(t),
								reason: e
							}
						}))(t)), b()
					},
					onMouseLeave: b
				}, r.a.createElement(h, {
					className: Object(p.a)(sd.a.helpIcon, {
						[sd.a.activeHelpIcon]: d
					})
				}), r.a.createElement($c.a, {
					tooltipId: t,
					defaultTooltipPosition: "top",
					caretColor: ad
				}, r.a.createElement("div", {
					className: sd.a.content
				}, n))))
			}, {
				fbt: dd
			} = n("./node_modules/fbt/lib/FbtPublic.js"), ld = () => {
				const e = Object(s.d)(),
					t = Object(R.ib)(),
					n = Object(s.e)(e => Object(R.s)(e, {
						pageLayer: t
					})),
					i = Object(s.e)(w.s),
					c = Object(s.e)(w.t) || tc();
				return Object(zc.a)((null == n ? void 0 : n.id) || ""), Object(o.useEffect)(() => {
					e(Object(a.l)({
						oldType: i || null,
						type: ke.a.Prediction
					}))
				}, [e, i]), n ? r.a.createElement(r.a.Fragment, null, r.a.createElement(cd, {
					tooltipId: "option",
					tooltipContent: dd._("Provide up to 6 answers that redditors can choose from as their prediction. If your question could have more than 6 answers, try providing the top five with a sixth option like none of these.", null, {
						hk: "h7WeS"
					})
				}, dd._("Options", null, {
					hk: "2unvji"
				})), r.a.createElement(dc, {
					poll: c,
					onUpdatePoll: t => e(Object(Ua.b)(t))
				}), r.a.createElement(cd, {
					tooltipId: "prediction_end_date",
					tooltipContent: dd._("The time when redditors can no longer make predictions. After this time you can select the correct answer to resolve the question and then manually end the tournament when all questions are answered.", null, {
						hk: "Z5iQv"
					})
				}, dd._("Prediction End Date", null, {
					hk: "1r06y3"
				})), r.a.createElement(Zc, {
					poll: c
				})) : null
			};
			var ud = n("./src/reddit/featureFlags/index.ts"),
				md = n("./src/reddit/icons/svgs/GovSmall/index.tsx"),
				pd = n("./src/reddit/icons/svgs/Poll/index.tsx"),
				hd = n("./src/reddit/components/PostCreationForm/PostEditor/GovTypeSelector/index.m.less"),
				bd = n.n(hd);
			const fd = Object(Ht.a)(Ja.a),
				gd = [{
					Icon: pd.a,
					showNewTag: !0,
					text: () => d.fbt._("general", null, {
						hk: "2zk1er"
					}),
					type: null
				}, {
					Icon: md.a,
					showNewTag: !1,
					text: () => d.fbt._("governance", null, {
						hk: "1wlLfQ"
					}),
					type: ke.a.GovGeneric
				}, {
					Icon: md.a,
					showNewTag: !1,
					text: () => d.fbt._("spin-off a new community", null, {
						hk: "jNK0c"
					}),
					type: ke.a.Spinoff
				}],
				vd = "gov-type-selector-dropdown";
			const Cd = Object(i.c)({
				dropdownIsOpen: e => e.tooltip.tooltipId === vd,
				govType: e => e.creations.formData.govType,
				spinoffEnabled: ud.d.spSpinoffs
			});
			var yd = Object(s.b)(Cd, e => ({
					onChangeGovType: (t, n) => {
						e(Object(a.l)({
							oldType: n,
							type: t
						})), e(Object(Ya.i)())
					},
					onToggleDropdown: () => e(Object(Ya.h)({
						tooltipId: vd
					}))
				}))((function(e) {
					const t = function(e, t) {
							return gd.filter(e => {
								let {
									type: n
								} = e;
								return !(!t.spinoffEnabled && n === ke.a.Spinoff)
							})
						}(0, e),
						n = t.find(t => t.type === e.govType) || t[0];
					return r.a.createElement("div", {
						className: Object(p.a)(bd.a.container, e.className)
					}, r.a.createElement("div", {
						className: bd.a.currentSelection,
						id: vd,
						onClick: e.onToggleDropdown
					}, r.a.createElement(n.Icon, {
						className: bd.a.pollTypeIcon
					}), r.a.createElement("div", {
						className: bd.a.text
					}, n.text()), r.a.createElement(Za.a, {
						className: bd.a.dropdownIcon
					}), n.showNewTag && r.a.createElement("div", {
						className: bd.a.newLabel
					}, d.fbt._("new", null, {
						hk: "4iv34v"
					}))), r.a.createElement(fd, {
						className: bd.a.dropdown,
						tooltipId: vd,
						isOpen: e.dropdownIsOpen
					}, t.map((t, o) => r.a.createElement(Xa.b, {
						"data-redditstyle": !0,
						displayText: t.text(),
						isSelected: t.type === n.type,
						key: o,
						onClick: () => e.onChangeGovType(t.type, e.govType)
					}))))
				})),
				Ed = n("./src/reddit/components/PostGuidance/index.tsx"),
				xd = n("./src/redditGQL/types.ts"),
				Od = n("./src/reddit/components/PostCreationForm/PostEditor/index.m.less"),
				_d = n.n(Od);

			function kd() {
				return (kd = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const jd = Object(Gc.a)("spGovPolls", yd),
				Sd = (e, t) => !e && t && t.bodyRestrictionPolicy === Vc.a.Required,
				Td = Object(i.c)({
					canPostAsModerator: w.e,
					destSubreddit: w.h,
					draft: A.d,
					editorMode: w.n,
					govType: e => e.creations.formData.govType,
					markdownBody: w.Y,
					pending: w.eb,
					poll: e => e.creations.formData.polls || void 0,
					postCreationFieldErrors: Ot,
					postRequirements: w.ub,
					postGuidanceBodyTriggeredRules: _.d,
					postGuidanceBlockRuleTriggered: _.c,
					rteState: w.lb,
					shouldAllowBodyText: w.nb,
					subreddit: R.s,
					isImageCreationEnabled: w.O,
					isVideoCreationEnabled: w.W,
					isFormEmpty: e => {
						var t;
						const n = (null === (t = Object(w.q)(e, {
								field: h.Cb.TITLE
							})) || void 0 === t ? void 0 : t.title) || "",
							o = Object(w.n)(e),
							r = Object(w.lb)(e),
							s = o === C.i.RICH_TEXT ? ve.a.getRawText(r, " ") : Object(w.Y)(e);
						return "" === n && "" === s
					}
				}),
				wd = Object(s.b)(Td, (e, t) => {
					let {
						onChange: n,
						onPostFieldValidation: o,
						onPostGuidanceValidation: r,
						pageLayer: s
					} = t;
					return {
						onBlur: () => {
							o(e(Je(h.Cb.BODY, s)))
						},
						onFocus: () => {
							e((e, t) => M.s(t(), C.l.CLICK, C.m.BODY))
						},
						onMarkdownStateChange: () => {
							r(() => e(Wa.a(s))), n()
						},
						onRTEStateChange: (t, o) => {
							e(a.e({
								rteState: t,
								isContentChanged: o
							})), r(() => e(Wa.a(s))), n()
						},
						onTrackPostGuidanceView: t => {
							e((e, n) => M.B(n(), t))
						},
						onToggleEditorMode: (t, n) => e(Ka.d(C.h.POST_CREATION, t, n)),
						onTrackToolbarClick: (t, n) => e((e, o) => M.N(o(), t, n)),
						onUpdatePoll: t => e(Object(Ua.b)(t)),
						setSubmissionType: t => e(a.g({
							submissionType: t
						}))
					}
				});
			class Id extends r.a.Component {
				constructor() {
					super(...arguments), this.state = {
						hasFocus: !1
					}, this.onEditorResize = e => {
						this.setState({
							editorHeight: e
						})
					}, this.onToggleEditorMode = async (e, t) => {
						await this.props.onToggleEditorMode(e, t), e === C.i.RICH_TEXT ? this.rteRef && this.rteRef.focus() : this.markdownEditorRef && this.markdownEditorRef.focus()
					}, this.setRteRef = e => this.rteRef = e, this.setMarkdownEditorRef = e => this.markdownEditorRef = e, this.onBlur = () => {
						setTimeout(() => this.setState({
							hasFocus: !1
						}), 150), this.props.onBlur()
					}, this.onFocus = () => {
						this.setState({
							hasFocus: !0
						}), this.props.onFocus()
					}, this.hasPostGuidanceBlockingError = () => this.props.postGuidanceBodyTriggeredRules.some(e => e.actionType === xd.O.Block), this.showPostGuidance = () => this.state.hasFocus || this.hasPostGuidanceBlockingError()
				}
				componentDidMount() {
					const {
						pageLayer: e,
						setSubmissionType: t
					} = this.props;
					(null == e ? void 0 : e.queryParams.type) === h.Db && t(h.bc.PREDICTION)
				}
				renderEditor() {
					const {
						canPostAsModerator: e,
						destSubreddit: t,
						editorMode: n,
						isImageCreationEnabled: o,
						isVideoCreationEnabled: s,
						markdownBody: i,
						pending: a,
						postCreationFieldErrors: c,
						postRequirements: l,
						rteState: u,
						submissionType: m,
						isFormEmpty: b
					} = this.props, f = m === h.bc.POLL, g = c[h.Cb.BODY].length > 0 || this.hasPostGuidanceBlockingError() && !b, v = Sd(e, l) ? d.fbt._("Text (required)", null, {
						hk: "E1dIP"
					}) : d.fbt._("Text (optional)", null, {
						hk: "4jfNex"
					});
					return n === C.i.RICH_TEXT ? r.a.createElement(Wc.a, {
						allowImageUploads: o,
						allowVideoUploads: s,
						focusableContentRTEClassName: Object(p.a)(_d.a.focusableContent, {
							[_d.a.mHasError]: g,
							[_d.a.mPollBorder]: !!f
						}),
						destSubreddit: t,
						editorType: Hc.a.Post,
						initialHeight: this.state.editorHeight,
						rteState: u,
						onBlur: this.onBlur,
						onChange: this.props.onRTEStateChange,
						onEditorResize: this.onEditorResize,
						onFocus: this.onFocus,
						onSubmit: this.props.onSubmit,
						onSwitchEditorMode: this.onToggleEditorMode,
						placeholderText: v,
						readOnly: a,
						rteRef: this.setRteRef,
						trackToolbarClick: this.props.onTrackToolbarClick
					}) : r.a.createElement(Kc.a, {
						focusableContentMarkdownClassName: Object(p.a)(_d.a.focusableContent, {
							[_d.a.mHasError]: g,
							[_d.a.mPollBorder]: !!f
						}),
						initialHeight: this.state.editorHeight,
						instanceRef: this.setMarkdownEditorRef,
						onBlur: this.onBlur,
						onChange: this.props.onMarkdownStateChange,
						onEditorResize: this.onEditorResize,
						onFocus: this.onFocus,
						value: i,
						onSubmit: this.props.onSubmit,
						onSwitchEditorMode: this.onToggleEditorMode,
						placeholderText: v
					})
				}
				render() {
					const {
						postCreationFieldErrors: e,
						postGuidanceBodyTriggeredRules: t,
						shouldAllowBodyText: n,
						submissionType: o,
						subreddit: s,
						onTrackPostGuidanceView: i,
						isFormEmpty: a
					} = this.props;
					return r.a.createElement("div", null, n && this.renderEditor(), o === h.bc.POLL && r.a.createElement("div", {
						className: _d.a.pollCreator
					}, r.a.createElement(jd, {
						className: _d.a.govToggle
					}), this.govType()), o === h.bc.PREDICTION && r.a.createElement(ld, null), r.a.createElement(ye.a, {
						errorModalTitle: s ? Object(co.d)(s.name) : void 0,
						messages: e[h.Cb.BODY]
					}), this.showPostGuidance() && r.a.createElement(Ed.a, {
						triggeredRules: t,
						trackPostGuidanceView: i,
						emptyState: a
					}))
				}
				govType() {
					var e;
					const {
						govType: t,
						poll: n,
						subreddit: o
					} = this.props, s = {
						onUpdatePoll: this.props.onUpdatePoll,
						poll: n
					}, i = {
						...s,
						pollType: t
					}, a = {
						...i,
						allowPredictions: this.props.isPredictionCreationAllowed,
						subredditId: null === (e = this.props.subreddit) || void 0 === e ? void 0 : e.id
					};
					switch (t) {
						case ke.a.ReplaceTopMod:
							return o ? r.a.createElement(Dc, kd({}, s, {
								subreddit: o
							})) : r.a.createElement(vc, kd({}, i, {
								hintTextComponent: r.a.createElement(Uc, null)
							}));
						case ke.a.GovGeneric:
							return r.a.createElement(vc, kd({}, i, {
								hintTextComponent: o ? r.a.createElement(qa, {
									subreddit: o
								}) : r.a.createElement(Uc, null)
							}));
						case ke.a.Spinoff:
							return o ? r.a.createElement(Ic, kd({}, s, {
								subreddit: o
							})) : r.a.createElement(vc, kd({}, i, {
								hintTextComponent: r.a.createElement(Uc, null)
							}));
						case ke.a.Prediction:
							return r.a.createElement(vc, kd({}, a, {
								hintTextComponent: r.a.createElement(Uc, {
									isPrediction: !0
								})
							}));
						case ke.a.GA:
						case null:
							return r.a.createElement(vc, kd({}, a, {
								hintTextComponent: r.a.createElement(Uc, null)
							}))
					}
				}
			}
			var Pd = Object(R.v)({
					draftId: R.w,
					pageLayer: e => e
				})(wd(Id)),
				Nd = n("./src/reddit/components/Econ/Prediction/UnicornIcon/index.tsx"),
				Rd = n("./src/reddit/icons/svgs/AddSquare/index.tsx"),
				Md = n("./src/reddit/components/PostCreationForm/PredictionEditor/TokenPicker/index.m.less"),
				Dd = n.n(Md);
			const Ld = e => {
				let {
					subredditId: t,
					value: n,
					onChange: o
				} = e;
				const [i, a] = r.a.useState(), c = r.a.useRef(null), l = Object(s.e)(e => Object(xn.f)(e, {
					subredditId: t
				}));
				return r.a.createElement("div", {
					className: Dd.a.container
				}, r.a.createElement("input", {
					ref: c,
					style: {
						display: "none"
					},
					onChange: async e => {
						const t = e.currentTarget.files;
						(null == t ? void 0 : t.length) && (a(t[0]), o(t[0]))
					},
					type: "file",
					accept: "image/png,image/jpeg"
				}), i ? r.a.createElement("div", {
					className: Dd.a.customTokenContainer
				}, r.a.createElement("button", {
					className: Object(p.a)(Dd.a.tokenButton, {
						[Dd.a.selected]: n === i
					}),
					onClick: () => o(i),
					title: d.fbt._("Set Custom Token", null, {
						hk: "1wFp57"
					})
				}, r.a.createElement("img", {
					className: Dd.a.tokenIcon,
					alt: d.fbt._("Custom Token", null, {
						hk: "3M8nxA"
					}),
					src: URL.createObjectURL(i)
				})), r.a.createElement("button", {
					className: Dd.a.clearTokenButton,
					onClick: () => {
						n === i && o(null), a(void 0), c.current.value = ""
					}
				}, r.a.createElement(yo.a, {
					className: Dd.a.clearTokenIcon
				}))) : r.a.createElement("button", {
					className: Dd.a.tokenButton,
					onClick: () => {
						var e;
						return null === (e = c.current) || void 0 === e ? void 0 : e.click()
					},
					title: d.fbt._("Add Custom Token", null, {
						hk: "3vDASa"
					})
				}, r.a.createElement(Rd.a, {
					className: Object(p.a)(Dd.a.tokenIcon, Dd.a.addTokenIcon)
				})), (null == l ? void 0 : l.tokenIconUrl) && r.a.createElement("button", {
					className: Object(p.a)(Dd.a.tokenButton, {
						[Dd.a.selected]: n === l.tokenIconUrl
					}),
					onClick: () => o(l.tokenIconUrl),
					title: d.fbt._("Previous Tournament Token", null, {
						hk: "3mEGE9"
					})
				}, r.a.createElement("img", {
					className: Dd.a.tokenIcon,
					alt: d.fbt._("Previous Tournament Token", null, {
						hk: "19mBuu"
					}),
					src: l.tokenIconUrl
				})), r.a.createElement("button", {
					className: Object(p.a)(Dd.a.tokenButton, {
						[Dd.a.selected]: null === n
					}),
					onClick: () => o(null),
					title: d.fbt._("Default Token", null, {
						hk: "2Qsr4e"
					})
				}, r.a.createElement(Nd.a, {
					className: Dd.a.tokenIcon
				})))
			};
			var Ad = n("./src/reddit/components/Econ/Prediction/themes.ts"),
				Fd = n("./src/reddit/components/Econ/Prediction/TournamentTokenIcon/index.tsx"),
				Bd = n("./src/reddit/components/PostCreationForm/PredictionEditor/TournamentCreation/TournamentBanner/index.m.less"),
				Ud = n.n(Bd);
			const Kd = e => {
				let {
					tournament: t
				} = e;
				return r.a.createElement("div", {
					className: Ud.a.container,
					style: {
						backgroundImage: Ad.a[t.theme] || Ad.a.theme_1
					}
				}, r.a.createElement("div", {
					className: Ud.a.label
				}, r.a.createElement(Fd.a, {
					className: Ud.a.icon,
					tournamentId: t.tournamentId
				}), d.fbt._("Current Tournament", null, {
					hk: "jBKr3"
				})), r.a.createElement("h3", {
					className: Ud.a.tournamentName
				}, t.name))
			};
			var Wd = n("./src/reddit/constants/modals.ts"),
				Gd = n("./src/reddit/components/PostCreationForm/PredictionEditor/CharacterLimitedInput/index.m.less"),
				Hd = n.n(Gd);
			const Vd = e => {
				let {
					isDisabled: t,
					name: n,
					onChange: o
				} = e;
				const i = Object(s.e)(L.e),
					a = (null == i ? void 0 : i.displayText) ? `${i.displayText} Predictions Tournament` : "Predictions Tournament";
				return r.a.createElement("div", {
					className: Hd.a.wrapper
				}, r.a.createElement("input", {
					"aria-label": d.fbt._("tournament-name-input", null, {
						hk: "3n3HoG"
					}),
					name: "tournament-name",
					className: Hd.a.limitedInput,
					disabled: t,
					type: "text",
					value: n,
					onChange: e => {
						const {
							value: t
						} = e.target;
						t.length <= 90 && o(t)
					},
					placeholder: d.fbt._("e.g. {Sample tournament name prefixed with subreddit display text}", [d.fbt._param("Sample tournament name prefixed with subreddit display text", a)], {
						hk: "1Mu4q8"
					})
				}), !t && r.a.createElement("div", {
					className: Hd.a.charLimit
				}, n.length, "/", 90))
			};
			var zd = n("./src/reddit/components/PostCreationForm/PredictionEditor/ThemePicker/index.m.less"),
				qd = n.n(zd);
			const Qd = ["#493AC1", "#00756F", "#99941A", "#DC8F1A", "#ED622C", "#EB7A7A", "#61676A", "#303030"],
				Yd = e => {
					let {
						theme: t = Qd[0],
						isDisabled: n,
						onChange: o
					} = e;
					const s = Object(yn.a)(),
						i = e => {
							s((e => t => ({
								...Object(ed.p)(t),
								source: vn.a,
								action: "click",
								noun: "theme_selection",
								subreddit: Object(ed.mb)(t),
								predictions: {
									tournamentThemeId: e
								}
							}))(e)), o(e)
						};
					return r.a.createElement("div", {
						className: qd.a.wrapper
					}, Qd.map((e, o) => {
						const s = `theme_${o+1}`;
						return r.a.createElement(ct.t, {
							key: s,
							className: qd.a.colorTile,
							style: {
								background: e
							},
							Icon: s === t ? Object(Oe.b)("checkmark_fill") : void 0,
							onClick: () => i(s),
							priority: ct.c.Plain,
							disabled: n
						})
					}))
				};
			var Jd = n("./src/reddit/components/Econ/Prediction/PredictionEducationMessage/EducationMessage/index.tsx"),
				Xd = n("./src/reddit/components/Econ/Prediction/PredictionEducationMessage/EducationMessage/constants.ts"),
				Zd = n("./src/reddit/hooks/useModalState.ts"),
				$d = n("./src/reddit/components/Econ/Tournament/Sidebar/HowItWorks/Content.tsx"),
				el = n("./src/reddit/components/PostCreationForm/PredictionEditor/TournamentCreation/index.m.less"),
				tl = n.n(el);

			function nl() {
				return (nl = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const ol = [{
					title: d.fbt._("Create questions", null, {
						hk: "hokTI"
					}),
					description: d.fbt._("Start a Predictions Tournament by creating questions, giving it a name, and selecting a theme. Try to create questions at least 2-3 days ahead of their end date. You can always add more later!", null, {
						hk: "1oN9ta"
					})
				}, {
					title: d.fbt._("Redditors make predictions", null, {
						hk: "USPzW"
					}),
					description: d.fbt._("Redditors predict using free tokens. They win bigger rewards by using more tokens when theyre confident with their predictions. More questions = more chances to predict.", null, {
						hk: "1hfMP9"
					})
				}, {
					title: d.fbt._("Resolve questions and announce winners", null, {
						hk: "4CZw7"
					}),
					description: d.fbt._("You resolve predictions by selecting the correct answer once it ends. When all questions are resolved, you can end the Tournament and Top Predictors will be announced!", null, {
						hk: "4fsynq"
					})
				}],
				rl = Object(Co.a)(e => {
					let {
						onClose: t
					} = e;
					return r.a.createElement("div", {
						className: tl.a.modalWrapper
					}, r.a.createElement(ct.t, {
						"aria-label": d.fbt._("Close", null, {
							hk: "2xO1CF"
						}),
						className: tl.a.closeButton,
						Icon: Object(Oe.b)("close"),
						onClick: t,
						priority: ct.c.Plain
					}), r.a.createElement($d.a, {
						steps: ol,
						withModalStyles: !0
					}))
				}),
				sl = e => r.a.createElement(rl, nl({
					className: tl.a.modal,
					withOverlay: !0,
					onOverlayClick: e.onClose
				}, e)),
				il = () => {
					const [e, t, n] = Object(Zd.a)(!1), o = Object(yn.a)();
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(Jd.a, {
						onClose: () => o(nd),
						onView: () => o(td),
						title: d.fbt._("Predictions", null, {
							hk: "4pJFGW"
						}),
						newBadge: !0,
						message: r.a.createElement(r.a.Fragment, null, r.a.createElement("h3", {
							className: tl.a.learnMoreText
						}, d.fbt._("A prediction tournament is a series of questions where redditors can win free tokens by predicting the future. Start a Tournament, add questions at any time and when you end the tournament winners are announced!", null, {
							hk: "10ymoN"
						})), r.a.createElement("button", {
							className: tl.a.learnMoreLink,
							onClick: () => {
								o(od), t()
							}
						}, d.fbt._("Learn more about prediction tournaments", null, {
							hk: "1chKID"
						}))),
						storageKey: Xd.a.feature,
						isFullWidth: !0
					}), e && r.a.createElement(sl, {
						onClose: n
					}))
				},
				al = e => {
					let {
						isApprovedUser: t,
						subredditId: n
					} = e;
					const i = Object(s.d)(),
						c = Object(s.e)(T.i),
						l = Object(s.e)(e => Object(xn.b)(e, {
							subredditId: n
						})),
						u = Object(s.e)(e => !!n && Object(xn.k)(e, {
							subredditId: n
						})),
						m = Object(s.e)(e => Object(xn.i)(e, {
							subredditId: n
						})),
						p = Object(s.e)(e => Object(xn.h)(e, {
							subredditId: n
						})),
						h = Object(s.e)(w.xb);
					Object(o.useEffect)(() => {
						!u && m && !l && t && i(Object(Zt.h)(Wd.a.ECON_PREDICTIONS_START_TOURNAMENT_LIMIT))
					}, [i, l, m, t, u]), Object(o.useEffect)(() => {
						!1 === (null == l ? void 0 : l.isActive) && p && i(Object(Zt.h)(Wd.a.ECON_PREDICTIONS_INACTIVITY_MODAL))
					}, [i, l, p]);
					const b = !l;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(il, null), b ? r.a.createElement(r.a.Fragment, null, r.a.createElement(cd, {
						className: tl.a.firstHeader,
						tooltipId: "tournament_name",
						tooltipContent: d.fbt._("The name of the tournament shown to your community. Questions in this tournament will be grouped together in one post, and you can change the name later in mod tools.", null, {
							hk: "11na95"
						}),
						isDisabled: !b
					}, d.fbt._("Tournament Name", null, {
						hk: "4HBhy"
					})), r.a.createElement(Vd, {
						name: h.name,
						onChange: e => {
							i(Object(a.D)({
								name: e
							}))
						},
						isDisabled: !b
					}), r.a.createElement(cd, {
						tooltipId: "tournament_theme",
						tooltipContent: d.fbt._("The main color used to style the tournament.", null, {
							hk: "2QKzZn"
						}),
						isDisabled: !b
					}, d.fbt._("Tournament Theme", null, {
						hk: "4nMPA"
					})), r.a.createElement(Yd, {
						theme: h.theme,
						onChange: e => {
							i(Object(a.D)({
								theme: e
							}))
						},
						isDisabled: !b
					}), c && r.a.createElement(r.a.Fragment, null, r.a.createElement(cd, {
						tooltipId: "tournament_token",
						tooltipContent: d.fbt._("The image to be used for the Tournament token shown to users. Remember, tokens are free, but are a fun way to allow users to predict and get ranked when they win.", null, {
							hk: "2rxVIk"
						}),
						isDisabled: !b
					}, d.fbt._("Tournament Token", null, {
						hk: "eLf9P"
					})), r.a.createElement(Ld, {
						subredditId: n,
						value: h.token,
						onChange: e => {
							i(Object(a.D)({
								token: e
							}))
						}
					}))) : r.a.createElement(Kd, {
						tournament: l
					}), r.a.createElement(cd, {
						tooltipId: "prediction_question",
						tooltipContent: d.fbt._("This should be a question about a future event that can only be answered after the event has passed. You can add more questions later.", null, {
							hk: "1kli3v"
						})
					}, d.fbt._("Prediction Question", null, {
						hk: "1MRcq1"
					})))
				};
			var cl = n("./src/reddit/components/PostCreationForm/PostTitle/index.m.less"),
				dl = n.n(cl);
			const ll = Object(i.c)({
					canPostAsModerator: w.e,
					disableTitleEdits: e => e.creations.formData.govType === ke.a.ReplaceTopMod || e.creations.formData.govType === ke.a.Spinoff,
					pending: w.eb,
					postCreationFieldErrors: Ot,
					postRequirements: w.ub,
					postGuidanceBlockRuleTriggered: _.c,
					postGuidanceTitleTriggeredRules: _.f,
					shouldAllowBodyText: w.nb,
					submissionType: w.a,
					subreddit: R.s,
					title: w.wb,
					isFormEmpty: e => {
						var t;
						const n = (null === (t = Object(w.q)(e, {
								field: h.Cb.TITLE
							})) || void 0 === t ? void 0 : t.title) || "",
							o = Object(w.n)(e),
							r = Object(w.lb)(e),
							s = o === C.i.RICH_TEXT ? ve.a.getRawText(r, " ") : Object(w.Y)(e);
						return "" === n && "" === s
					}
				}),
				ul = Object(s.b)(ll, (e, t) => {
					let {
						onChange: n,
						onPostFieldValidation: o,
						onPostGuidanceValidation: r,
						pageLayer: s
					} = t;
					return {
						onBlur: () => {
							o(e(Je(h.Cb.TITLE, s)))
						},
						onChange: t => {
							e(a.h(t)), r(() => e(Wa.a(s))), n(t)
						},
						onInputFocus: () => e((e, t) => M.s(t(), C.l.CLICK, C.m.TITLE)),
						onTrackPostGuidanceView: t => {
							e((e, n) => M.B(n(), t))
						}
					}
				});
			var ml = Object(R.v)()(ul(e => {
					const {
						canPostAsModerator: t,
						isApprovedUser: n,
						isFormEmpty: s,
						onBlur: i,
						onInputFocus: a,
						onTrackPostGuidanceView: c,
						postRequirements: l,
						postGuidanceTitleTriggeredRules: u,
						postCreationFieldErrors: m,
						subreddit: b
					} = e, f = e.submissionType === h.bc.POST && !e.shouldAllowBodyText, g = u.some(e => e.actionType === xd.O.Block), v = m[h.Cb.TITLE].length > 0 || g && !s, C = t ? ft.f : l && l.titleTextMaxLength || ft.f, y = e.submissionType === h.bc.PREDICTION, E = y ? d.fbt._("e.g. Who will win best actress at the Oscars this year?", null, {
						hk: "YLQFW"
					}) : d.fbt._("Title", null, {
						hk: "j3s6r"
					}), [x, O] = Object(o.useState)(!1), _ = Object(o.useCallback)(() => {
						setTimeout(() => O(!1), 150), i()
					}, [i]), k = Object(o.useCallback)(() => {
						O(!0), a()
					}, [a]), j = g || x;
					return r.a.createElement("div", {
						className: dl.a.container
					}, y && r.a.createElement(al, {
						isApprovedUser: n,
						subredditId: (null == b ? void 0 : b.id) || ""
					}), r.a.createElement("div", {
						className: dl.a.inputWrapper
					}, r.a.createElement(Hr, {
						className: Object(p.a)(dl.a.PostTitleInput, {
							[dl.a.mHasError]: v
						}),
						disabled: e.disableTitleEdits,
						maxLength: C,
						minHeight: f ? 92 : void 0,
						onBlur: _,
						onFocus: k,
						onKeyDown: e.onKeyDown,
						onValueChange: e.onChange,
						placeholder: E,
						readOnly: e.pending,
						value: e.title
					}), r.a.createElement("div", {
						className: dl.a.charsCounter
					}, e.title.length, "/", C)), r.a.createElement(ye.a, {
						errorModalTitle: b ? Object(co.d)(b.name) : void 0,
						messages: m[h.Cb.TITLE]
					}), j && r.a.createElement(Ed.a, {
						triggeredRules: u,
						trackPostGuidanceView: c,
						emptyState: s
					}))
				})),
				pl = n("./src/reddit/components/PostCreationForm/Prompt/index.tsx");
			const hl = "g-recaptcha",
				bl = "image",
				fl = {
					COMPACT: "compact",
					NORMAL: "normal"
				},
				gl = () => new Promise(e => {
					if (window.grecaptcha) return e(window.grecaptcha);
					window.grecaptchaOnLoad = () => e(window.grecaptcha);
					const t = document.createElement("script");
					t.src = "https://www.google.com/recaptcha/api.js?onload=grecaptchaOnLoad&render=explicit", document.body.appendChild(t)
				});
			class vl extends r.a.Component {
				shouldComponentUpdate() {
					return !1
				}
				componentDidMount() {
					const {
						callback: e,
						size: t,
						type: n
					} = this.props;
					gl().then(o => {
						o.render(hl, {
							callback: e,
							type: n,
							sitekey: Gt.a.recaptchaSitekey,
							size: t || fl.COMPACT
						})
					})
				}
				componentWillReceiveProps(e) {
					this.props.submissionPending && !e.submissionPending && gl().then(e => {
						e.reset()
					})
				}
				render() {
					return r.a.createElement("div", {
						className: "Recaptcha",
						id: hl
					})
				}
			}
			var Cl = n("./src/reddit/components/PostCreationForm/RecaptchaOverlay/index.m.less"),
				yl = n.n(Cl);
			const {
				fbt: El
			} = n("./node_modules/fbt/lib/FbtPublic.js"), xl = fe.a.div("OverlayWrapper", yl.a), Ol = fe.a.div("OverlayContent", yl.a), _l = fe.a.div("ExplanationText", yl.a);
			var kl = Object(s.b)(void 0, (e, t) => ({
				onChange: n => {
					e(a.f(n)), t.callback(n)
				}
			}))(e => r.a.createElement(xl, null, r.a.createElement(Ol, null, r.a.createElement(_l, null, El._("Ok, one more thing ... you're human, right?", null, {
				hk: "2xDwBB"
			})), r.a.createElement(vl, {
				submissionPending: !0,
				callback: e.onChange,
				size: fl.NORMAL,
				type: bl
			}))));
			const jl = "POST_CREATION__CONFIRM_SAVE_DRAFT_WITH_LIMITATIONS";

			function Sl(e) {
				const {
					hasEventSchedule: t,
					hasRichPostMedia: n
				} = e;
				let o = d.fbt._("Saving this draft will not save media and the applied event schedule, all other information will be saved", null, {
					hk: "3NIEQF"
				});
				return n && !t ? o = d.fbt._("Saving this draft will not save media, all other information will be saved", null, {
					hk: "2tpNPY"
				}) : !n && t && (o = d.fbt._("Saving this draft will not save the applied event schedule, all other information will be saved", null, {
					hk: "3wm3T3"
				})), r.a.createElement($.a, {
					bodyText: o,
					onClose: e.onCancel,
					onPrimaryAction: e.onConfirm,
					onSecondaryAction: e.onCancel,
					primaryButtonText: d.fbt._("Save", null, {
						hk: "4yMsMq"
					}),
					secondaryButtonText: d.fbt._("Cancel", null, {
						hk: "2TSLl5"
					}),
					titleText: d.fbt._("Save draft", null, {
						hk: "1RxZQJ"
					})
				})
			}
			var Tl = n("./src/reddit/components/PostCreationForm/SubredditChangePrompt/index.m.less"),
				wl = n.n(Tl);
			const Il = {
					[C.q.ImageWillBeRemoved]: {
						removePromptTitle: () => d.fbt._("Remove image?", null, {
							hk: "3Pk53F"
						}),
						removeConfirm: () => d.fbt._("Change and remove image", null, {
							hk: "Ik8BT"
						}),
						removeCancel: () => d.fbt._("Keep image", null, {
							hk: "1e7FY0"
						}),
						details: e => d.fbt._("Aw crap, {sureddit name} doesn't allow images. If you change to {suredditName} your image will be removed.", [d.fbt._param("sureddit name", `r/${e}`), d.fbt._param("suredditName", `r/${e}`)], {
							hk: "1zQOEn"
						})
					},
					[C.q.VideoWillBeRemovedMediaNotAllowed]: {
						removePromptTitle: () => d.fbt._("Remove video?", null, {
							hk: "12xLOq"
						}),
						removeConfirm: () => d.fbt._("Change and remove video", null, {
							hk: "3izwIJ"
						}),
						removeCancel: () => d.fbt._("Keep video", null, {
							hk: "32ZDlX"
						}),
						details: e => d.fbt._("Aw crap, {sureddit name} doesn't allow videos. If you change to {suredditName} your video will be removed.", [d.fbt._param("sureddit name", `r/${e}`), d.fbt._param("suredditName", `r/${e}`)], {
							hk: "1sxEJG"
						})
					},
					[C.q.VideoWillBeRemovedTooLongForGif]: {
						removePromptTitle: () => d.fbt._("Remove video?", null, {
							hk: "12xLOq"
						}),
						removeConfirm: () => d.fbt._("Change and remove video", null, {
							hk: "3izwIJ"
						}),
						removeCancel: () => d.fbt._("Keep video", null, {
							hk: "32ZDlX"
						}),
						details: e => d.fbt._("Aw crap, {sureddit name} doesn't allow videos. Please upload a video less than 60 seconds to convert to animated GIF. If you change to {suredditName} your video will be removed.", [d.fbt._param("sureddit name", `r/${e}`), d.fbt._param("suredditName", `r/${e}`)], {
							hk: "34j8hI"
						})
					},
					[C.q.GalleryWillBeRemovedGalleryNotAllowed]: {
						removePromptTitle: () => d.fbt._("Remove gallery?", null, {
							hk: "4mddlm"
						}),
						removeConfirm: () => d.fbt._("Change and remove gallery", null, {
							hk: "2JB1HN"
						}),
						removeCancel: () => d.fbt._("Keep gallery", null, {
							hk: "26kW19"
						}),
						details: e => d.fbt._("Aw crap, {sureddit name} doesn't allow galleries. If you change to {suredditName} your gallery will be removed.", [d.fbt._param("sureddit name", `r/${e}`), d.fbt._param("suredditName", `r/${e}`)], {
							hk: "11irkw"
						})
					}
				},
				Pl = fe.a.div("Wrapper", wl.a),
				Nl = fe.a.wrapped(yt.a, "TitleRow", wl.a),
				Rl = fe.a.div("DetailsContainer", wl.a),
				Ml = fe.a.wrapped(yt.a, "ButtonRow", wl.a),
				Dl = fe.a.wrapped(ct.l, "CancelButton", wl.a),
				Ll = fe.a.wrapped(ct.o, "ConfirmButton", wl.a);
			var Al = Object(Co.a)(e => {
					const {
						promptType: t,
						nextSubreddit: n
					} = e, o = Il[t];
					return r.a.createElement(Pl, null, r.a.createElement(Nl, null, o.removePromptTitle()), r.a.createElement(Rl, null, o.details(n.name)), r.a.createElement(Ml, null, r.a.createElement(Ll, {
						onClick: e.onConfirmed
					}, o.removeConfirm()), r.a.createElement(Dl, {
						onClick: e.onCanceled
					}, o.removeCancel())))
				}),
				Fl = n("./src/lib/filterQueryParams/index.ts"),
				Bl = n("./src/reddit/models/ScheduledPost/index.ts"),
				Ul = n("./src/reddit/selectors/experiments/nsfwCommunityMediaUpload.ts"),
				Kl = n("./src/reddit/selectors/features/predictions/creation/index.ts"),
				Wl = n("./src/reddit/components/PostCreationForm/Tabs/index.m.less"),
				Gl = n.n(Wl);
			const Hl = e => r.a.createElement("button", {
					className: Object(p.a)(Gl.a.Tab, e.className, {
						[Gl.a.isActive]: e.active
					}),
					disabled: e.disabled,
					onClick: e.onClick
				}, e.children),
				Vl = Object(i.a)(w.d, w.e, w.h, w.U, w.eb, R.s, Ul.a, (e, t, n, o, r, s, i) => {
					const {
						images: a = !0,
						links: c = !0,
						text: d = !0,
						videos: l = !0
					} = n.allowedPostTypes || {}, u = !!s && s.isNSFW && i;
					return {
						link: r || !c || o && !Object(Bl.h)("links"),
						media: !l && !a && !t || r || u || o && !Object(Bl.h)("images"),
						post: !d && !t || r || o && !Object(Bl.h)("text"),
						poll: !e || o && !Object(Bl.h)("polls")
					}
				}),
				zl = Object(i.c)({
					canPostAsModerator: w.e,
					destSubreddit: w.h,
					govType: e => e.creations.formData.govType,
					hasCreatedPredictionDrafts: Kl.a,
					isTabsDisabled: Vl,
					pending: w.eb,
					submissionType: w.a,
					subreddit: R.s,
					isImageGalleryCreationEnabled: w.P
				}),
				ql = Object(s.b)(zl, (e, t) => ({
					onChange: (n, o) => {
						e(a.g({
							submissionType: n,
							extra: o
						})), e((e, t) => M.D(t(), n)), e(a.x(n === h.bc.POLL)), ((e, t, n) => {
							if (!t) return;
							const o = Object(Fl.a)(t.url, n);
							t.url !== o && e(Object(m.c)(o))
						})(e, t.pageLayer, ["url", "media", "onlyTitle", "text", "selftext", "type"])
					}
				}));
			class Ql extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.onPostTabClick = () => {
						this.props.isTabsDisabled.post || this.props.onChange(h.bc.POST, {
							govType: this.props.govType
						})
					}, this.onMediaTabClick = () => {
						this.props.isTabsDisabled.media || this.props.onChange(h.bc.MEDIA, {
							govType: this.props.govType
						})
					}, this.onLinkTabClick = () => {
						this.props.isTabsDisabled.link || this.props.onChange(h.bc.LINK_ONLY, {
							govType: this.props.govType
						})
					}, this.onPollTabClick = () => {
						this.props.isTabsDisabled.poll && !this.props.isPredictionCreationAllowed || this.props.onChange(h.bc.POLL, {
							govType: this.props.govType
						})
					}, this.onPredictionTabClick = () => {
						this.props.onChange(h.bc.PREDICTION, {
							govType: this.props.govType
						})
					}
				}
				render() {
					const {
						destSubreddit: e,
						hasCreatedPredictionDrafts: t,
						isTabsDisabled: n,
						submissionType: o,
						isImageGalleryCreationEnabled: s,
						isPredictionCreationAllowed: i
					} = this.props, {
						name: a = "",
						allowedPostTypes: c
					} = e, {
						images: l = !0,
						videos: u = !0
					} = c || {};
					let m = d.fbt._({
						"*": "Images & Video",
						_1: "Image & Video"
					}, [d.fbt._plural(s ? 2 : 1)], {
						hk: "3VeQoy"
					});
					return l && !u ? m = s ? d.fbt._("Images", null, {
						hk: "3fSX8N"
					}) : d.fbt._("Image", null, {
						hk: "uFHQ1"
					}) : u && !l && (m = d.fbt._("Video", null, {
						hk: "3w6DFr"
					})), r.a.createElement("div", {
						className: Gl.a.Container
					}, r.a.createElement("div", {
						className: Gl.a.row
					}, r.a.createElement(Hl, {
						active: o === h.bc.POST,
						disabled: t || n.post,
						onClick: this.onPostTabClick
					}, r.a.createElement(Oe.a, {
						name: "text_post",
						isFilled: o === h.bc.POST,
						className: Gl.a.Icon
					}), d.fbt._("Post", null, {
						hk: "ozUj2"
					})), r.a.createElement(Hl, {
						active: o === h.bc.MEDIA,
						disabled: t || n.media,
						onClick: this.onMediaTabClick
					}, n.media && r.a.createElement(it.a, {
						text: d.fbt._("Images and videos are not allowed in {subreddit name}", [d.fbt._param("subreddit name", `r/${a}`)], {
							hk: "2uC6BP"
						})
					}), r.a.createElement(Oe.a, {
						name: "image_post",
						isFilled: o === h.bc.MEDIA,
						className: Gl.a.Icon
					}), m), r.a.createElement(Hl, {
						active: o === h.bc.LINK_ONLY,
						disabled: t || n.link,
						onClick: this.onLinkTabClick
					}, r.a.createElement(Oe.a, {
						name: "link_post",
						isFilled: o === h.bc.LINK_ONLY,
						className: Gl.a.Icon
					}), d.fbt._("Link", null, {
						hk: "1pbEKv"
					})), r.a.createElement(Hl, {
						active: o === h.bc.POLL,
						disabled: t || n.poll && !i,
						onClick: this.onPollTabClick
					}, r.a.createElement(Oe.a, {
						name: "poll_post",
						isFilled: o === h.bc.POLL,
						className: Gl.a.Icon
					}), d.fbt._("Poll", null, {
						hk: "SQdo4"
					})), i && r.a.createElement(Hl, {
						active: o === h.bc.PREDICTION,
						disabled: t || !i,
						onClick: this.onPredictionTabClick
					}, r.a.createElement(Oe.a, {
						name: "prediction",
						isFilled: "prediction" === o,
						className: Gl.a.Icon
					}), d.fbt._("Predictions", null, {
						hk: "QtPNQ"
					}))))
				}
			}
			var Yl = Object(R.v)()(ql(Ql));

			function Jl() {
				return (Jl = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			var Xl = n("./src/reddit/components/PostCreationForm/index.m.less"),
				Zl = n.n(Xl),
				$l = n("./src/reddit/selectors/isModeratorOfSubreddit.ts");
			const eu = fe.a.div("FormContent", Zl.a),
				tu = fe.a.wrapped(k.c, "CrosspostBox", Zl.a),
				nu = fe.a.div("FormContainer", Zl.a),
				ou = fe.a.div("TabContent", Zl.a),
				ru = Object(R.v)({
					draftId: R.w,
					isPostCreationPage: R.I,
					pageLayer: e => e,
					sourcePostId: e => Object(R.ab)(e).source_id
				}),
				su = Object(i.c)({
					submissionType: w.a,
					allowNavigationCallback: L.a,
					contributorRequestPending: e => Object(F.e)(e, y.e.Post),
					discardGoesBack: (e, t) => {
						let {
							pageLayer: n
						} = t;
						const o = Object(R.X)(e, {
							pageLayer: n
						});
						return !!o && "/" === o[0]
					},
					draft: A.d,
					draftsCount: B.n,
					editorMode: w.n,
					eventSchedule: w.p,
					includeUserProfile: B.j,
					isChanged: w.H,
					isNameEditable: B.U,
					isPostSubmitEnabled: Jn,
					isScheduledPost: w.U,
					flair: w.r,
					hasError: w.w,
					havePostContent: w.D,
					linkBody: w.X,
					markdownBody: w.Y,
					rteBody: w.lb,
					maxDrafts: B.eb,
					modalId: D.a,
					needsCaptcha: w.bb,
					nextSubreddit: w.cb,
					pending: w.eb,
					isPostGuidanceEligible: (e, t) => {
						var n;
						const o = Object(R.q)(e, t);
						if (!o) return !1;
						const r = Object(_.e)(e, {
								subredditName: o.name.toLowerCase()
							}),
							s = Object($l.c)(e, {
								subredditId: o.id
							});
						return !("post" !== Object(w.a)(e) || null === (n = null == r ? void 0 : r.postGuidanceConfig) || void 0 === n || !n.length || s) && Object(x.a)(e)
					},
					postRequirements: w.ub,
					sourcePostRoot: w.pb,
					submitMode: w.sb,
					subredditOrProfile: R.q,
					title: w.wb,
					uploads: e => e.uploads,
					isModeratorOfSubreddit: (e, t) => {
						const n = Object(R.q)(e, t);
						return !!n && Object($l.c)(e, {
							subredditId: n.id
						})
					},
					isOpenAIPilotV1: Y.g,
					isSubredditHasCollections: (e, t) => {
						const n = Object(R.q)(e, t);
						return !!n && Object(O.m)(e, {
							subredditId: n.id
						})
					},
					isTalkTopicSelectionEnabled: T.u,
					isScheduledTalksEnabled: T.n
				});
			class iu extends r.a.Component {
				constructor(e) {
					super(e), this.postFieldValidationPending = null, this.postGuidanceValidationPending = null, this.sendStartTypingInputBodyEvent = u()(() => this.props.onStartTypingInput(C.m.BODY)), this.sendStartTypingInputTitleEvent = u()(() => this.props.onStartTypingInput(C.m.TITLE)), this.sendStartTypingInputUrlEvent = u()(() => this.props.onStartTypingInput(C.m.URL)), this.onExternalAccountConnected = () => {
						this.props.onExternalAccountsDataRequested()
					}, this.onRecaptchaSucceeded = () => {
						this.props.onSubmit(this.props.submitMode, this.postFieldValidationPending, this.postGuidanceValidationPending)
					}, this.onDiscardPromptOnNavigationConfirm = () => {
						this.props.onTrackDiscardButtonClick(), this.props.discardGoesBack || this.props.onDiscardPromptOnNavigationConfirmed(), this.props.allowNavigationCallback && this.props.allowNavigationCallback(!0)
					}, this.onDiscardPromptOnNewPostConfirm = () => {
						this.props.onTrackDiscardButtonClick(), this.props.onToggleModal(C.d), this.props.onDiscardPromptOnCreatePostConfirmed()
					}, this.onDiscardPromptAbort = () => {
						this.props.onToggleModal(this.props.modalId), this.props.allowNavigationCallback && this.props.allowNavigationCallback(!1)
					}, this.onDiscardPromptSaveDraft = () => {
						this.props.onToggleModal(this.props.modalId), this.onSaveDraft()
					}, this.handleKeyDown = e => {
						const {
							ctrlKey: t,
							metaKey: n,
							keyCode: o
						} = e;
						(t || n) && o === g.a.Enter && this.onSubmit()
					}, this.onSubredditChangePromptConfirmed = () => {
						this.props.nextSubreddit && (this.props.onCancelAndRemoveMediaUpload(), this.props.onRedirectToSubreddit(this.props.nextSubreddit))
					}, this.onSubmit = () => {
						const {
							isPostSubmitEnabled: e,
							isScheduledPost: t,
							onSubmit: n
						} = this.props, o = Object(v.c)(v.a.PostComposer);
						e && n(t ? C.r.ScheduledPost : C.r.Post, this.postFieldValidationPending, this.postGuidanceValidationPending, o)
					}, this.onSaveDraft = async () => {
						const {
							draftId: e,
							draftsCount: t,
							eventSchedule: n,
							maxDrafts: o,
							onToggleModal: r
						} = this.props;
						!e && t >= o ? r(pl.a.MAX_DRAFTS_MODAL_ID) : n || this.hasRichPostMedia() ? r(jl) : this.props.onSubmit(C.r.Draft, this.postFieldValidationPending, this.postGuidanceValidationPending)
					}, this.tryLoadDraft = e => {
						this.props.isChanged ? (this.setState({
							draftToLoad: e
						}), this.props.onToggleModal(pl.a.LOAD_DRAFT_MODAL_ID)) : (this.props.onToggleModal(C.e), this.onLoadDraft(e))
					}, this.onLoadDraft = e => {
						e && this.props.onLoadDraft(e)
					}, this.onSelectCollection = e => {
						this.props.onSetDestCollection(e.id)
					}, this.onPromptCancel = e => {
						this.props.onToggleModal(e)
					}, this.onToggleCurrentModal = () => {
						this.props.modalId && this.props.onToggleModal(this.props.modalId)
					}, this.onPromptConfirm = e => {
						switch (e) {
							case pl.a.LOAD_DRAFT_MODAL_ID:
								this.props.onToggleModal(e), this.onLoadDraft(this.state.draftToLoad);
								break;
							case pl.a.MAX_DRAFTS_MODAL_ID:
								this.props.onRequestDraftList(), this.props.onToggleModal(C.e);
								break;
							default:
								this.props.onToggleModal(e)
						}
					}, this.onConfirmSavingDraftWithLimitations = () => {
						this.onToggleCurrentModal(), this.props.onSubmit(C.r.Draft, this.postFieldValidationPending, this.postGuidanceValidationPending)
					}, this.onToggleCollectionListModal = () => {
						this.props.onToggleModal(C.a)
					}, this.onCollectionCreated = e => {
						this.onToggleCurrentModal(), this.onSelectCollection(e)
					}, this.onDraftListClose = () => {
						this.props.onToggleModal(C.e)
					}, this.onPostFieldValidation = e => {
						this.postFieldValidationPending = e
					}, this.onPostGuidanceValidation = f()(e => {
						if (!this.props.isPostGuidanceEligible) return Promise.resolve();
						this.postGuidanceValidationPending = e()
					}, 150), this.renderTabContent = () => r.a.createElement(r.a.Fragment, null, r.a.createElement(ml, {
						isApprovedUser: this.props.isApprovedUser,
						onChange: this.sendStartTypingInputTitleEvent,
						onKeyDown: this.handleKeyDown,
						onPostFieldValidation: this.onPostFieldValidation,
						onPostGuidanceValidation: this.onPostGuidanceValidation
					}), this.renderActiveForm()), this.state = {
						draftToLoad: null
					}
				}
				componentDidMount() {
					Object(v.d)(v.a.PostComposer, !1), this.externalAccountEventsChannel = Object(Q.a)(), this.externalAccountEventsChannel.addEventListener("message", this.onExternalAccountConnected), this.props.isNameEditable && this.props.startChangeUsernameFlow(), this.props.onLoadRecaptchaEnterprise()
				}
				componentWillUnmount() {
					Object(v.b)(v.a.PostComposer), this.externalAccountEventsChannel && this.externalAccountEventsChannel.close(), this.props.onUnmount()
				}
				hasRichPostMedia() {
					const {
						rteBody: e,
						submissionType: t
					} = this.props;
					return t === h.bc.POST && e.isBound && Object(N.j)(e.editorState.getCurrentContent())
				}
				renderActiveForm() {
					switch (this.props.submissionType) {
						case h.bc.POST:
						case h.bc.POLL:
						case h.bc.PREDICTION:
							return r.a.createElement(Pd, {
								submissionType: this.props.submissionType,
								isPredictionCreationAllowed: this.props.isPredictionCreationAllowed,
								onChange: this.sendStartTypingInputBodyEvent,
								onPostFieldValidation: this.onPostFieldValidation,
								onPostGuidanceValidation: this.onPostGuidanceValidation,
								onSubmit: this.onSubmit
							});
						case h.bc.MEDIA:
							return r.a.createElement(ta, null);
						case h.bc.LINK_ONLY:
							return r.a.createElement(Jr, {
								onChange: this.sendStartTypingInputUrlEvent,
								onKeyDown: this.handleKeyDown,
								onPostFieldValidation: this.onPostFieldValidation
							});
						case h.bc.CROSSPOST: {
							const {
								sourcePostRoot: e
							} = this.props;
							return e && r.a.createElement(tu, {
								postId: e.id,
								mediaProps: {
									isExpando: !1,
									isListing: !1,
									isNotCardView: !0,
									post: e,
									primaryContent: !1,
									showCentered: !0,
									showFull: !0,
									shouldLoad: !0,
									shouldPause: !1
								}
							})
						}
						default:
							return d.fbt._("Invalid submissionType", null, {
								hk: "3GqKJS"
							})
					}
				}
				render() {
					const {
						contributorRequestPending: e,
						draftId: t,
						includeUserProfile: n,
						isApprovedUser: o,
						isOpenAIPilotV1: s,
						isPredictionCreationAllowed: i,
						modalId: a,
						needsCaptcha: c,
						nextSubreddit: l,
						postRequirements: u,
						sourcePostId: m,
						sourcePostRoot: b,
						submissionType: f,
						submitMode: g,
						subredditOrProfile: v
					} = this.props;
					if (f === h.bc.CROSSPOST) {
						if (!b) return r.a.createElement(E.b, {
							message: d.fbt._("The original post cannot be found", null, {
								hk: "3ieS5B"
							})
						});
						if (!b.isCrosspostable || b.isSponsored) return r.a.createElement(E.a, {
							message: d.fbt._("The original post cannot be crossposted", null, {
								hk: "4hn9ht"
							})
						})
					}
					const y = u && u.guidelinesText && u.guidelinesText.trim() || "";
					return r.a.createElement(nu, null, r.a.createElement(Ba, {
						submissionType: f,
						submitMode: g
					}), !s && r.a.createElement(r.a.Fragment, null, r.a.createElement(fo, {
						includeUserProfile: n,
						allowCrosspostableOnly: !!m
					}), !!y && r.a.createElement("div", {
						className: Zl.a.PostingGuidelines
					}, y)), r.a.createElement(eu, null, f !== h.bc.CROSSPOST && r.a.createElement(Yl, {
						isPredictionCreationAllowed: i,
						isApprovedUser: o
					}), r.a.createElement(ou, null, this.renderTabContent()), s && r.a.createElement(r.a.Fragment, null, r.a.createElement("div", {
						className: Zl.a.postToTitle
					}, d.fbt._("Post to", null, {
						hk: "1t9e1N"
					})), r.a.createElement(fo, {
						includeUserProfile: n,
						allowCrosspostableOnly: !!m,
						className: uo.a.SubredditRec
					}), !!y && r.a.createElement("div", {
						className: Object(p.a)(Zl.a.PostingGuidelines, Zl.a.isSubredditRec)
					}, y)), e && r.a.createElement(P.a, null), r.a.createElement(oo, {
						contributorRequestPending: e,
						draftId: t,
						onCancel: this.props.onDiscardPromptOnNavigationConfirmed,
						onPostFieldValidation: this.onPostFieldValidation,
						onSaveDraft: this.onSaveDraft,
						onSubmit: this.onSubmit,
						sourcePostId: m,
						subredditId: null == v ? void 0 : v.id,
						shouldRenderDivider: !s,
						isOpenAISubRec: s
					}), r.a.createElement(Ia, {
						draftId: t
					})), c && r.a.createElement(kl, {
						callback: this.onRecaptchaSucceeded
					}), a === ne && r.a.createElement(re, {
						onAbort: this.onDiscardPromptAbort,
						onDiscardConfirmed: this.onDiscardPromptOnNavigationConfirm,
						onSaveDraft: this.onDiscardPromptSaveDraft,
						submissionType: f
					}), a === C.d && r.a.createElement(re, {
						onAbort: this.onDiscardPromptAbort,
						onDiscardConfirmed: this.onDiscardPromptOnNewPostConfirm,
						onSaveDraft: this.onDiscardPromptSaveDraft,
						submissionType: f
					}), a === C.e && r.a.createElement(wr, {
						onClose: this.onDraftListClose,
						onLoadDraft: this.tryLoadDraft
					}), a === C.a && v && r.a.createElement(ue.a, {
						onClose: this.onToggleCollectionListModal,
						onSelectCollection: this.onSelectCollection,
						subredditId: v.id
					}), Object(C.v)(a) && v && r.a.createElement(ro.a, {
						onCancel: this.props.closeCreateCollectionModal,
						onCollectionCreated: this.onCollectionCreated,
						subredditId: v.id
					}), a === pl.a.LOAD_DRAFT_MODAL_ID && r.a.createElement(pl.b, {
						modalId: pl.a.LOAD_DRAFT_MODAL_ID,
						onCancel: this.onPromptCancel,
						onConfirm: this.onPromptConfirm
					}), a === pl.a.MAX_DRAFTS_MODAL_ID && r.a.createElement(pl.b, {
						modalId: pl.a.MAX_DRAFTS_MODAL_ID,
						onCancel: this.onPromptCancel,
						onConfirm: this.onPromptConfirm
					}), a === jl && r.a.createElement(Sl, {
						onCancel: this.onToggleCurrentModal,
						onConfirm: this.onConfirmSavingDraftWithLimitations,
						hasEventSchedule: !!this.props.eventSchedule,
						hasRichPostMedia: this.hasRichPostMedia()
					}), l && (a === C.q.ImageWillBeRemoved || a === C.q.VideoWillBeRemovedTooLongForGif || a === C.q.VideoWillBeRemovedMediaNotAllowed || a === C.q.GalleryWillBeRemovedGalleryNotAllowed) && r.a.createElement(Al, {
						withOverlay: !0,
						promptType: a,
						nextSubreddit: l,
						onConfirmed: this.onSubredditChangePromptConfirmed,
						onCanceled: this.props.onCancelSubredditChange
					}), r.a.createElement(le, null))
				}
			}
			var au, cu = ru(Object(s.b)(su, (e, t) => {
					let {
						draftId: n,
						sourcePostId: o,
						pageLayer: r
					} = t;
					return {
						onLoadDraft: t => e(V.q(t)),
						onSubmit: (t, s, i, a) => e(G.c(t, {
							draftId: n || void 0,
							pageLayer: r,
							postFieldValidationPending: s,
							postGuidanceValidationPending: i,
							sourcePostId: o,
							correlationId: a
						})),
						onDiscardPromptOnCreatePostConfirmed: () => {
							e(a.q(!1, r))
						},
						onDiscardPromptOnNavigationConfirmed: (t, n) => {
							e(t ? Object(m.a)() : n ? Object(m.b)(n.url) : Object(m.b)("/"))
						},
						onExternalAccountsDataRequested: () => e(K.o()),
						onRedirectToSubreddit: t => e(H.a(t, n)),
						onCancelSubredditChange: () => {
							e(a.z("")), e(H.e())
						},
						onCancelAndRemoveMediaUpload: () => {
							e(Object(a.d)({
								items: [],
								selectedKey: null
							})), e(q.j(W.a, !0))
						},
						onClearErrors: (t, n) => t && e(a.i(n)),
						onLoadRecaptchaEnterprise: () => e(Object(z.d)(!0)),
						onRequestDraftList: () => e(V.p()),
						onSetDestCollection: t => e(H.d(t)),
						onStartTypingInput: t => e((e, n) => M.s(n(), C.l.TYPE, t)),
						onToggleIsChanged: t => e(a.t(t)),
						onToggleModal: t => e(a.z(t)),
						onTrackDiscardButtonClick: () => e((e, t) => M.e(t())),
						onUnmount: () => e((e, t) => {
							e(q.j(W.a, !0)), e(q.i(C.n, !0))
						}),
						onUploadPendingThumbnails: t => e(W.f(t)),
						startChangeUsernameFlow: () => e(Object(U.startChangeUsernameFlow)())
					}
				}, (e, t, n) => ({
					...e,
					...t,
					...n,
					onClearErrors: n => t.onClearErrors(e.hasError || e.hasSubmitValidationError, n),
					onDiscardPromptOnNavigationConfirmed: () => t.onDiscardPromptOnNavigationConfirmed(e.discardGoesBack, e.subreddit),
					closeCreateCollectionModal: () => {
						e.isSubredditHasCollections || e.modalId !== C.c ? t.onToggleModal(C.a) : t.onToggleModal(C.c)
					}
				}))(function(e) {
					return t => {
						const {
							isPredictionCreationAllowed: n,
							isApprovedUser: o
						} = function() {
							const [e, t] = r.a.useState(!1), [n, o] = r.a.useState(!1), i = Object(s.d)(), a = Object(R.ib)(), c = Object(s.e)(e => Object(R.s)(e, {
								pageLayer: a
							})), d = Object(s.e)(e => c && Object(Se.h)(e, {
								subredditId: c.id
							}));
							return r.a.useEffect(() => c && c.allowPredictions ? d ? t(!0) : void Promise.resolve(i(Object(fn.h)(c.id))).then(e => {
								t(Boolean(e)), o(Boolean(e))
							}) : t(!1), [i, c, d]), {
								isPredictionCreationAllowed: e,
								isApprovedUser: n
							}
						}();
						return r.a.createElement(e, Jl({}, t, {
							isPredictionCreationAllowed: n,
							isApprovedUser: o
						}))
					}
				}((au = iu, e => {
					const t = Object(S.a)(),
						[n, i] = Object(o.useState)(!1),
						a = Object(s.e)(e => Object(w.h)(e)),
						c = Object(s.e)(T.v),
						d = Object(o.useMemo)(() => {
							var e;
							return !!(null === (e = a.allowedPostTypes) || void 0 === e ? void 0 : e.talks)
						}, [a]);
					return Object(o.useEffect)(() => {
						let e = !1;
						return a.id && (a.isProfile && c ? (async () => {
							const n = await Object(j.a)(t(), {
								name: a.name
							});
							e || i(n)
						})() : d && (async () => {
							const n = await Object(j.b)(t(), {
								subredditId: a.id
							});
							e || i(n)
						})()), () => {
							e = !0
						}
					}, [a, t, c, d]), r.a.createElement(au, I({}, e, {
						isTalkCreationAllowedForUser: n
					}))
				})))),
				du = n("./src/reddit/components/PostingSidebar/index.tsx"),
				lu = n("./src/reddit/layout/page/Listing/index.tsx"),
				uu = n("./src/lib/makePostCreationPageKey/index.ts"),
				mu = n("./src/reddit/helpers/trackers/screenview.ts"),
				pu = n("./src/telemetry/models/Timer.ts");
			const hu = Object(i.c)({
					destSubreddit: w.h,
					user: B.m
				}),
				bu = Object(s.b)(hu, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return {
						onResetForm: () => e(a.q(!1, n))
					}
				}),
				fu = Object(R.v)({
					draftId: R.w,
					pageLayer: e => e
				});
			class gu extends o.Component {
				componentDidMount() {
					document.documentElement.scrollTop = document.body.scrollTop = 0;
					const e = this.props.pageLayer;
					if (e) {
						const t = Object(uu.a)(e.urlParams);
						be.c.has(t) && this.props.sendEvent(Object(mu.k)(t, pu.TimerType.InApp, be.c.end(t)))
					}
				}
				UNSAFE_componentWillReceiveProps(e) {
					this.props.draftId && !e.draftId && e.onResetForm()
				}
				render() {
					const {
						destSubreddit: e,
						user: t
					} = this.props;
					if (e.isProfile) {
						if (!t) return r.a.createElement(E.b, null);
						if (Object(Oo.e)(t).toLowerCase() !== e.name.toLowerCase()) return r.a.createElement(E.a, null)
					}
					return r.a.createElement(lu.a, {
						redditStyle: !0,
						disableFullscreen: !0,
						navBar: r.a.createElement("div", null),
						content: r.a.createElement(r.a.Fragment, null, r.a.createElement(c.a, null), r.a.createElement(cu, null)),
						sidebar: r.a.createElement(du.a, null)
					})
				}
			}
			t.default = fu(bu(Object(ee.c)(gu)))
		},
		"./src/reddit/reducers/economics/paymentSystems/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var o, r = n("./src/reddit/actions/economics/paymentSystems/constants.ts");
			! function(e) {
				e[e.Failure = 0] = "Failure", e[e.Fetched = 1] = "Fetched", e[e.NotFetched = 2] = "NotFetched", e[e.Pending = 3] = "Pending"
			}(o || (o = {}));
			const s = {
				status: o.NotFetched
			};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : s,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						if (e.status === o.Fetched && e.data.stripe && e.data.stripe.sources) {
							const n = t.payload.cardId,
								{
									[n]: o,
									...r
								} = e.data.stripe.sources;
							return {
								...e,
								data: {
									...e.data,
									stripe: {
										...e.data.stripe,
										sources: r
									}
								}
							}
						}
						return e;
					case r.e:
						if (e.status === o.Fetched && e.data.braintree && e.data.braintree.sources) {
							const n = t.payload.sourceId,
								{
									[n]: o,
									...r
								} = e.data.braintree.sources;
							return {
								...e,
								data: {
									...e.data,
									braintree: {
										...e.data.braintree,
										sources: r
									}
								}
							}
						}
						return e;
					case r.b:
						return {
							error: t.payload.error, status: o.Failure
						};
					case r.c:
						return {
							data: t.payload, status: o.Fetched
						};
					case r.d:
						return {
							status: o.Pending
						};
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/economics/subredditPremium/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o, r = n("./src/lib/constants/specialMembership.ts"),
				s = n("./src/reddit/actions/economics/subredditPremium/constants.ts"),
				i = n("./src/reddit/helpers/economics/sortBadges.ts"),
				a = n("./src/reddit/models/Badge/index.ts"),
				c = n("./src/reddit/models/Badge/managementPage.ts");
			! function(e) {
				e[e.NotFetched = 0] = "NotFetched", e[e.Fetched = 1] = "Fetched"
			}(o || (o = {}));
			const d = {};

			function l(e) {
				return "userId" in e
			}

			function u(e, t, n, o) {
				e.forEach(e => {
					e.collections && Object.keys(e.collections).forEach(r => {
						let s;
						(s = e.placement ? e.placement === a.a.First ? o[c.a.Loyalty][r] : o[c.a.Achievement][r] : l(e) ? o[c.a.Cosmetic][c.c.MyBadges][r] : o[c.a.Cosmetic][c.c.Gallery][r]) && (l(e) ? n.has(e.id) && s.unlocked.push(e) : t.has(e.id) || s.locked.push(e))
					})
				})
			}

			function m(e) {
				const t = (e, t) => {
					const n = parseInt(e.price || "0"),
						o = parseInt(t.price || "0");
					return n === o ? Object(i.b)(e, t) : n - o
				};
				return e.locked.sort(t), e.unlocked.sort(t), e
			}

			function p(e, t) {
				return Object.keys(e).map(t => e[t]).filter(e => !!e.locked.length || !!e.unlocked.length || e.id === r.a).map(m).sort((e, n) => {
					const o = t[e.id],
						r = t[n.id];
					return Object(i.b)(o, r)
				})
			}

			function h(e) {
				const t = {
					[c.a.Loyalty]: {},
					[c.a.Achievement]: {},
					[c.a.Cosmetic]: {
						[c.c.Gallery]: {},
						[c.c.MyBadges]: {}
					}
				};
				Object.keys(e.collections).forEach(n => {
					const o = e.collections[n],
						r = {
							description: o.description,
							highlight: o.extra && o.extra.style && o.extra.style.color,
							id: o.id,
							locked: [],
							title: o.title,
							unlocked: []
						};
					t[c.a.Loyalty][n] = {
						...r,
						locked: [],
						unlocked: []
					}, t[c.a.Achievement][n] = {
						...r,
						locked: [],
						unlocked: []
					}, t[c.a.Cosmetic][c.c.Gallery][n] = {
						...r,
						locked: [],
						unlocked: []
					}, t[c.a.Cosmetic][c.c.MyBadges][n] = {
						...r,
						locked: [],
						unlocked: []
					}
				});
				const n = new Set;
				e.userOwnedBadges.forEach(t => {
					const o = e.badges[t];
					o && n.add(o.type)
				});
				const o = new Set(e.userOwnedBadges);
				return u(Object.keys(e.badges).map(t => e.badges[t]), n, o, t), u(Object.keys(e.products).map(t => e.products[t]), n, o, t), {
					collections: {
						[c.a.Loyalty]: p(t[c.a.Loyalty], e.collections),
						[c.a.Achievement]: p(t[c.a.Achievement], e.collections),
						[c.a.Cosmetic]: {
							[c.c.Gallery]: p(t[c.a.Cosmetic][c.c.Gallery], e.collections),
							[c.c.MyBadges]: p(t[c.a.Cosmetic][c.c.MyBadges], e.collections)
						}
					},
					subscription: e.subscription,
					userOwnedBadges: e.userOwnedBadges.map(t => e.badges[t]).filter(Boolean)
				}
			}
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : d,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case s.a: {
						const {
							subredditId: n
						} = t.payload, r = e[n];
						return r && r.status === o.Fetched ? {
							...e,
							[n]: {
								...r,
								data: {
									...r.data
								},
								raw: {
									...r.raw
								}
							}
						} : e
					}
					case s.h: {
						const {
							subredditId: n
						} = t.payload, r = e[n];
						return r && r.status === o.Fetched ? {
							...e,
							[n]: {
								...r,
								data: {
									...r.data,
									subscription: {
										...r.data.subscription || {},
										settings: {
											renew: !1
										}
									}
								},
								raw: {
									...r.raw,
									subscription: {
										...r.raw.subscription || {},
										settings: {
											renew: !1
										}
									}
								}
							}
						} : e
					}
					case s.i: {
						const n = t.payload;
						return {
							...e,
							[n.subredditId]: {
								raw: n,
								data: h(n),
								status: o.Fetched
							}
						}
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/features/avatar/index.ts": function(e, t, n) {
			"use strict";
			var o, r, s = n("./node_modules/redux/es/redux.js"),
				i = n("./src/reddit/actions/snoovatar.ts");
			! function(e) {
				e.PREMIUM = "PREMIUM"
			}(o || (o = {})),
			function(e) {
				e[e.BACKGROUND = 0] = "BACKGROUND", e[e.ACCESSORY_BACK = 1] = "ACCESSORY_BACK", e[e.HAIR_BACK = 2] = "HAIR_BACK", e[e.BODY_BOTTOM = 3] = "BODY_BOTTOM", e[e.BODY = 4] = "BODY", e[e.ACCESSORY = 5] = "ACCESSORY", e[e.FACE_LOWER = 6] = "FACE_LOWER", e[e.FACE_UPPER = 7] = "FACE_UPPER", e[e.HAIR = 8] = "HAIR", e[e.HEAD_ACCESSORY = 9] = "HEAD_ACCESSORY"
			}(r || (r = {}));
			const a = {
				id: "",
				csrf_token: "",
				snoovatar: null,
				websocketsUrls: {
					renderer: "",
					download: ""
				},
				capabilities: [o.PREMIUM],
				hasActiveClosetSubscription: !1
			};
			var c = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.b:
						return {
							...t.payload
						};
					default:
						return e
				}
			};
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const d = {
					marketingEvent: {
						active: !1,
						assetUrls: null,
						experimentRequired: null
					},
					quickCreateV1: {
						id: "-1",
						active: !1,
						text: "",
						min_days_on_reddit: 0,
						should_have_avatar: !1,
						max_event_views: 0,
						min_days_since_last_event_interaction: 0,
						webAssetUrls: []
					},
					pushcard: null
				},
				l = "avatar_quick_create_event",
				u = "avatar_marketing_event",
				m = "avatar_pushcard",
				p = "avatar_promo_archived";
			var h;
			! function(e) {
				e.MaxEventViews = "targeting:max_event_views", e.Title = "copy:pushcard_title", e.Cta = "copy:pushcard_cta", e.BannerTitle = "copy:banner_title", e.BannerBody = "copy:banner_body", e.Deeplink = "deeplink"
			}(h || (h = {}));
			const b = e => {
					let {
						startsAt: t,
						endsAt: n
					} = e;
					const o = t && new Date(t) <= new Date,
						r = !!n && new Date(n) < new Date;
					return !!o && !r
				},
				f = e => {
					const {
						id: t,
						tags: n,
						webAssetUrls: o
					} = e, [r, s] = o, i = n.reduce((e, t) => {
						if (!t) return e;
						const n = Object.values(h).find(e => t.startsWith(e));
						return n ? (e[n] = t.slice(n.length + 1), e) : e
					}, {});
					return {
						id: t,
						maxViews: parseInt(i[h.MaxEventViews], 10),
						banner: {
							id: t,
							iconUrl: r,
							title: i[h.BannerTitle],
							body: i[h.BannerBody]
						},
						imageUrl: s,
						title: i[h.Title],
						cta: i[h.Cta],
						deeplink: i[h.Deeplink]
					}
				},
				g = e => {
					const t = {};
					return null == e || e.forEach(e => {
						if (null == e ? void 0 : e.startsWith("targeting:")) {
							const n = e.split(":");
							if (!n.length && n.length < 3) return null;
							try {
								t[n[1]] = JSON.parse(n[2])
							} catch {
								t[n[1]] = n[2]
							}
						}
					}), t
				};

			function v(e) {
				const t = {};
				return e.forEach(e => {
					var n;
					const {
						webAssetUrls: o,
						tags: r
					} = e;
					if (!(null == r ? void 0 : r.includes(p))) {
						if ((null == r ? void 0 : r.includes(m)) && o && o.length >= 2 && (t.pushcard = f(e)), null == r ? void 0 : r.includes(l)) {
							const {
								text: n,
								id: s
							} = e, i = o || null, a = g(r);
							t.quickCreateV1 = {
								...a,
								id: s,
								text: n,
								active: b(e) && !!i,
								webAssetUrls: i
							}
						}
						if (null == r ? void 0 : r.includes(u)) {
							const s = o || null,
								i = (null === (n = r.find(e => (null == e ? void 0 : e.startsWith("feature:")) && e.includes("web"))) || void 0 === n ? void 0 : n.split("feature:")[1]) || null;
							t.marketingEvent = {
								active: b(e) && !!s,
								assetUrls: s,
								experimentRequired: i
							}
						}
					}
				}), t
			}
			var C = n("./src/reddit/actions/economics/marketplace/constants.ts"),
				y = n("./src/reddit/actions/goldPurchaseModals/constants.ts"),
				E = n("./src/reddit/actions/modal.ts"),
				x = n("./src/reddit/constants/modals.ts");
			var O = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				var n, o;
				switch (t.type) {
					case y.s:
						const {
							avatarMarketingEvents: r
						} = t.payload;
						return r ? {
							...d,
							...v(r)
						} : d;
					case C.b:
					case C.c:
					case C.f:
						return (null == e ? void 0 : e.pushcard) ? {
							...e,
							pushcard: {
								...e.pushcard
							}
						} : e;
					case E.c:
						return (null === (n = t.payload) || void 0 === n ? void 0 : n.id) === x.a.SNOOVATAR_MODAL ? {
							...d,
							pushcard: null !== (o = null == e ? void 0 : e.pushcard) && void 0 !== o ? o : null
						} : e;
					default:
						return e
				}
			};
			var _ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.a: {
						const {
							image: e,
							accessory_ids: n
						} = t.payload;
						return {
							image: e,
							accessoryIds: n
						}
					}
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				marketing: O,
				avatarUser: c,
				randomAvatar: _
			})
		},
		"./src/reddit/reducers/features/crypto/index.ts": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/redux/es/redux.js"),
				r = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/actions/economics/claims/constants.ts")),
				s = n("./src/reddit/actions/economics/me/constants.ts");
			const i = {};
			var a = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case s.a: {
							const n = t.payload.claimPoints || {},
								o = Object.keys(n).reduce((t, o) => (t[o] = {
									...e[o],
									availableClaims: n[o]
								}, t), {});
							return Object.keys(e).forEach(t => {
								var n;
								(null === (n = e[t]) || void 0 === n ? void 0 : n.isClaiming) && (o[t] = o[t] || {
									availableClaims: []
								}, o[t].isClaiming = !0)
							}), o
						}
						case r.b:
						case r.a:
							const {
								subredditId: n
							} = t.payload;
							return {
								...e, [n]: {
									...e[n],
									isClaiming: t.type === r.b
								}
							};
						default:
							return e
					}
				},
				c = n("./src/reddit/actions/governance/constants.ts");
			const d = 15e4,
				l = {},
				u = {
					filled: "img/communityPoints/default_filled.png",
					grey: "img/communityPoints/default_grey.png"
				};

			function m(e) {
				var t, n, o, r, s;
				const i = null === (t = e.walletProvider) || void 0 === t ? void 0 : t.extra,
					a = null == i ? void 0 : i.contracts,
					c = null == a ? void 0 : a.unlocked,
					l = null !== (o = null === (n = e.walletProvider) || void 0 === n ? void 0 : n.provider) && void 0 !== o ? o : e.provider,
					m = !!(null === (r = e.walletProvider) || void 0 === r ? void 0 : r.inTransition),
					p = null == i ? void 0 : i.metaTransactions,
					h = (null == p ? void 0 : p.allowedContractMethods) || {},
					b = (null == p ? void 0 : p.gasLimit) || d,
					f = (null == c ? void 0 : c.decimals) || 0,
					g = "1" + "0".repeat(f);
				return {
					allowedContractMethods: h,
					blockchainProvider: l,
					contractAddress: (null == c ? void 0 : c.address) || "",
					contracts: a,
					decimals: f,
					displayConversion: g,
					gasLimit: b,
					images: e.images || u,
					inTransition: m,
					name: e.name,
					nomenclature: null === (s = e.extra) || void 0 === s ? void 0 : s.nomenclature,
					polls: e.polls,
					symbol: (null == c ? void 0 : c.token) || ""
				}
			}
			var p = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case c.a: {
						const {
							subredditId: n,
							meta: o
						} = t.payload;
						return {
							...e,
							[n]: m(o)
						}
					}
					default:
						return e
				}
			};
			const h = {};
			var b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : h,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case c.n: {
						const {
							subredditId: n,
							wallets: o
						} = t.payload, r = Object.keys(o).reduce((t, r) => {
							return {
								...t,
								[r]: {
									...e[r] || {},
									[n]: o[r]
								}
							}
						}, {});
						return {
							...e,
							...r
						}
					}
					default:
						return e
				}
			};
			t.a = Object(o.c)({
				claims: a,
				points: p,
				publicWallets: b
			})
		},
		"./src/reddit/reducers/pages/modHub/index.ts": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/subredditModeration/constants.ts");
			var s = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.g:
						case r.f:
							return null;
						case r.e:
							return t.payload;
						default:
							return e
					}
				},
				i = n("./src/reddit/models/SubredditModeration/index.ts");
			const a = {};
			var c = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.g: {
							const {
								subredditId: n,
								fetchedToken: o
							} = t.payload, r = Object(i.e)(n, o);
							return {
								...e,
								[r]: !0
							}
						}
						case r.f:
						case r.e: {
							const {
								subredditId: n,
								fetchedToken: o
							} = t.payload, r = Object(i.e)(n, o);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				d = Object(o.c)({
					error: s,
					pending: c
				});
			const l = {};
			var u = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.f: {
						const {
							fetchedToken: n,
							subredditId: o
						} = t.payload, r = Object(i.e)(o, n);
						return {
							...e,
							[r]: !0
						}
					}
					default:
						return e
				}
			};
			const m = {};
			var p = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.f: {
							const {
								subredditId: e,
								after: n
							} = t.payload;
							return {
								[e]: n
							}
						}
						default:
							return e
					}
				},
				h = n("./node_modules/icepick/icepick.js");
			const b = {};
			var f = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : b,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.d:
					case r.f: {
						const {
							subredditId: n,
							approvedSubmitters: o
						} = t.payload, r = {
							[n]: o
						};
						return Object(h.merge)(e, r)
					}
					case r.k: {
						const {
							subredditId: n,
							userId: o
						} = t.payload;
						return Object(h.unsetIn)(e, [n, o])
					}
					default:
						return e
				}
			};
			var g = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.j:
					case r.i:
						return null;
					case r.h:
						return t.payload;
					default:
						return e
				}
			};
			var v = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.j:
							return !0;
						case r.i:
						case r.h:
							return !1;
						default:
							return e
					}
				},
				C = Object(o.c)({
					error: g,
					pending: v
				});
			var y = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.j:
							return null;
						case r.i: {
							const e = t.payload.approvedSubmitterIds[0];
							return e ? t.payload.approvedSubmitters[e] : null
						}
						default:
							return e
					}
				},
				E = Object(o.c)({
					api: C,
					result: y
				});
			const x = {};
			var O = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : x,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.f: {
							const {
								subredditId: n,
								approvedSubmitterIds: o
							} = t.payload;
							return e[n] ? {
								...e,
								[n]: [...e[n], ...o]
							} : {
								...e,
								[n]: o
							}
						}
						case r.k: {
							const {
								subredditId: n,
								userId: o
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== o)
							}
						}
						case r.d: {
							const {
								subredditId: n,
								approvedSubmitterIds: o
							} = t.payload, r = o[0];
							return r && e[n] && -1 === e[n].indexOf(r) ? {
								[n]: [r, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				_ = Object(o.c)({
					api: d,
					fetchedTokens: u,
					loadMore: p,
					models: f,
					search: E,
					userOrder: O
				});
			var k = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.n:
					case r.m:
						return null;
					case r.l:
						return t.payload;
					default:
						return e
				}
			};
			const j = {};
			var S = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : j,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.n: {
							const {
								subredditId: n,
								fetchedToken: o
							} = t.payload, r = Object(i.f)(n, o);
							return {
								...e,
								[r]: !0
							}
						}
						case r.m:
						case r.l: {
							const {
								subredditId: n,
								fetchedToken: o
							} = t.payload, r = Object(i.f)(n, o);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				T = Object(o.c)({
					error: k,
					pending: S
				});
			const w = {};
			var I = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : w,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.m: {
						const {
							fetchedToken: n,
							subredditId: o
						} = t.payload, r = Object(i.f)(o, n);
						return {
							...e,
							[r]: !0
						}
					}
					default:
						return e
				}
			};
			const P = {};
			var N = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : P,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.m: {
						const {
							subredditId: e,
							loadMoreToken: n
						} = t.payload;
						return {
							[e]: n
						}
					}
					default:
						return e
				}
			};
			const R = {};
			var M = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : R,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.m: {
							const {
								subredditId: n,
								approvedTalkHosts: o,
								forceRefresh: r
							} = t.payload, s = {
								[n]: [...r ? [] : e[n] || [], ...o]
							};
							return Object(h.merge)(e, s)
						}
						case r.o: {
							const {
								subredditId: n,
								userId: o
							} = t.payload, r = {
								[n]: e[n].filter(e => e.redditor.id !== o)
							};
							return Object(h.merge)(e, r)
						}
						default:
							return e
					}
				},
				D = Object(o.c)({
					api: T,
					fetchedTokens: I,
					loadMore: N,
					models: M
				}),
				L = n("./src/reddit/actions/grantUserFlair/constants.ts");
			var A = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case L.g:
					case L.i:
						return null;
					case L.f:
						return t.payload;
					default:
						return e
				}
			};
			var F = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case L.i:
							return !0;
						case L.g:
						case L.f:
							return !1;
						default:
							return e
					}
				},
				B = Object(o.c)({
					error: A,
					pending: F
				}),
				U = n("./node_modules/lodash/merge.js"),
				K = n.n(U),
				W = n("./node_modules/lodash/omit.js"),
				G = n.n(W);
			const H = {};
			var V = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : H,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case L.g:
					case L.k: {
						const {
							subredditId: n,
							flairedUsers: o
						} = t.payload;
						return K()({
							...e
						}, {
							[n]: o
						})
					}
					case L.c: {
						const {
							subredditId: n,
							userName: o
						} = t.payload, r = G()(e[n], o);
						return {
							...e,
							[n]: r
						}
					}
					case L.a:
					case L.b:
					case L.h:
						const {
							subredditId: n, userName: o, applied: r
						} = t.payload;
						return r ? {
							...e,
							[n]: {
								...e[n],
								[o]: r
							}
						} : e;
					default:
						return e
				}
			};
			const z = {};
			var q = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : z,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case L.g: {
						const {
							key: n,
							pageInfo: o
						} = t.payload;
						return {
							...e,
							[n]: o
						}
					}
					default:
						return e
				}
			};
			var Q = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case L.l:
					case L.k:
						return null;
					case L.j:
						return t.payload;
					default:
						return e
				}
			};
			var Y = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case L.l:
							return !0;
						case L.k:
						case L.j:
							return !1;
						default:
							return e
					}
				},
				J = Object(o.c)({
					error: Q,
					pending: Y
				});
			var X = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case L.k: {
							const {
								searchResult: e
							} = t.payload;
							return e
						}
						case L.c: {
							const {
								userName: n
							} = t.payload;
							return e === n ? null : e
						}
						default:
							return e
					}
				},
				Z = Object(o.c)({
					api: J,
					result: X
				});
			const $ = {};
			var ee = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case L.g: {
							const {
								key: n,
								userOrder: o
							} = t.payload;
							return {
								...e,
								[n]: o
							}
						}
						case L.a: {
							const {
								key: n,
								userName: o
							} = t.payload;
							if (!n) return e;
							if (!e[n].includes(o)) {
								const t = [...e[n], o];
								return {
									...e,
									[n]: t
								}
							}
							return e
						}
						case L.c: {
							const {
								userName: n
							} = t.payload, o = {};
							for (const t in e) o[t] = e[t].filter(e => e !== n);
							return o
						}
						default:
							return e
					}
				},
				te = Object(o.c)({
					api: B,
					models: V,
					pageInfo: q,
					search: Z,
					userOrder: ee
				}),
				ne = n("./src/reddit/actions/moderationLog/constants.ts");
			const oe = {};
			var re = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oe,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.b: {
						const {
							normalizedCategories: n
						} = t.payload;
						return Object(h.merge)(e, n)
					}
					default:
						return e
				}
			};
			const se = {};
			var ie = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : se,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							actionIds: n,
							key: o,
							subredditId: r
						} = t.payload;
						return {
							...e,
							[r]: {
								...e[r] || {},
								[o]: n
							}
						}
					}
					default:
						return e
				}
			};
			const ae = {};
			var ce = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ae,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.c: {
							const {
								normalizedModerationLog: n,
								subredditId: o
							} = t.payload, r = {};
							n.forEach(e => {
								r[e.id] = e
							});
							const s = {
								[o]: r
							};
							return K()({
								...e
							}, s)
						}
						default:
							return e
					}
				},
				de = Object(o.c)({
					itemOrder: ie,
					models: ce
				});
			var le = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							approximateCount: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			var ue = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							endCursor: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			const me = {};
			var pe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : me,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							hasNextPage: n,
							subredditId: o
						} = t.payload;
						return {
							...e,
							[o]: n
						}
					}
					default:
						return e
				}
			};
			const he = {};
			var be = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : he,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							hasPreviousPage: n,
							subredditId: o
						} = t.payload;
						return {
							...e,
							[o]: n
						}
					}
					default:
						return e
				}
			};
			var fe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							subredditId: n,
							insightsData: o
						} = t.payload;
						return {
							...e,
							[n]: o
						}
					}
					default:
						return e
				}
			};
			const ge = [];
			var ve = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ge,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.a: {
						const {
							normalizedModerators: n,
							subredditId: o
						} = t.payload;
						return {
							...e,
							[o]: n
						}
					}
					default:
						return e
				}
			};
			var Ce = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.c: {
							const {
								startCursor: e
							} = t.payload;
							return e
						}
						default:
							return e
					}
				},
				ye = Object(o.c)({
					actionCategories: re,
					actions: de,
					approximateCount: le,
					endCursor: ue,
					hasNextPage: pe,
					hasPreviousPage: be,
					moderators: ve,
					startCursor: Ce,
					insightsEntrypoint: fe
				});
			const Ee = {};
			var xe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ee,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.O:
					case r.y: {
						const {
							subredditId: n,
							moderators: o
						} = t.payload.response || t.payload, r = {
							[n]: o
						};
						return Object(h.merge)(e, r)
					}
					case r.C: {
						const {
							subredditId: n,
							userId: o,
							permissions: r
						} = t.payload;
						return Object(h.setIn)(e, [n, o, "modPermissions"], r)
					}
					case r.jb: {
						const {
							subredditId: n,
							userId: o
						} = t.payload;
						return Object(h.unsetIn)(e, [n, o])
					}
					default:
						return e
				}
			};
			const Oe = {};
			var _e = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Oe,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.z:
					case r.y: {
						const {
							key: n,
							subredditId: o
						} = t.payload;
						return o ? {
							...e,
							[n]: null
						} : e
					}
					case r.x: {
						const {
							error: n,
							key: o,
							subredditId: r
						} = t.payload;
						return r ? {
							...e,
							[o]: n
						} : e
					}
					default:
						return e
				}
			};
			const ke = {};
			var je = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ke,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.x:
						case r.y: {
							const {
								subredditId: n,
								key: o
							} = t.payload;
							return n ? {
								...e,
								[o]: !1
							} : e
						}
						case r.z: {
							const {
								subredditId: n,
								key: o
							} = t.payload;
							return n ? {
								...e,
								[o]: !0
							} : e
						}
						default:
							return e
					}
				},
				Se = Object(o.c)({
					error: _e,
					pending: je
				});
			const Te = {};
			var we = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Te,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.y: {
							const {
								subredditId: n,
								response: o,
								key: r
							} = t.payload;
							return Object(h.setIn)(e, [n, r], o.moderatorIds)
						}
						case r.jb: {
							const {
								subredditId: n,
								userId: o,
								key: r
							} = t.payload, s = e[n][r].filter(e => e !== o);
							return Object(h.setIn)(e, [n, r], s)
						}
						default:
							return e
					}
				},
				Ie = Object(o.c)({
					data: we,
					api: Se
				});
			var Pe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.F:
					case r.E:
						return null;
					case r.D:
						return t.payload;
					default:
						return e
				}
			};
			var Ne = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.E:
						case r.D:
							return !1;
						case r.F:
							return !0;
						default:
							return e
					}
				},
				Re = Object(o.c)({
					error: Pe,
					pending: Ne
				});
			const Me = {};
			var De = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Me,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.E: {
						const {
							subredditId: n,
							moderators: o
						} = t.payload;
						return Object(h.set)(e, n, o)
					}
					case r.gb: {
						const {
							subredditId: n,
							userId: o
						} = t.payload;
						return Object(h.unsetIn)(e, [n, o])
					}
					case r.c: {
						const n = t.payload,
							{
								subredditId: o,
								moderators: r
							} = n,
							s = {
								[o]: r
							};
						return Object(h.merge)(e, s)
					}
					default:
						return e
				}
			};
			const Le = {};
			var Ae = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Le,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.E: {
							const {
								subredditId: n,
								moderatorIds: o
							} = t.payload;
							return {
								...e,
								[n]: o
							}
						}
						case r.gb: {
							const {
								subredditId: n,
								userId: o
							} = t.payload, r = e[n].filter(e => e !== o);
							return {
								...e,
								[n]: r
							}
						}
						case r.c: {
							const n = t.payload,
								{
									subredditId: o,
									moderatorIds: r
								} = n,
								s = [...e[o] || [], ...r];
							return {
								...e,
								[o]: s
							}
						}
						default:
							return e
					}
				},
				Fe = Object(o.c)({
					api: Re,
					models: De,
					userOrder: Ae
				});
			const Be = {};
			var Ue = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Be,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.L: {
						const {
							subredditId: n,
							response: o
						} = t.payload, {
							invitePending: r
						} = o, s = {
							[n]: r
						};
						return Object(h.merge)(e, s)
					}
					case r.I:
					case r.J: {
						const {
							subredditId: n
						} = t.payload;
						return Object(h.unset)(e, n)
					}
					default:
						return e
				}
			};
			const Ke = {};
			var We = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ke,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.y: {
						const {
							response: e
						} = t.payload;
						return {
							[e.subredditId]: {
								after: e.after,
								before: e.before
							}
						}
					}
					default:
						return e
				}
			};
			const Ge = {};
			var He = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ge,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.L: {
						const {
							response: e
						} = t.payload;
						return {
							[e.subredditId]: {
								after: e.after,
								before: e.before
							}
						}
					}
					default:
						return e
				}
			};
			const Ve = {};
			var ze = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ve,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.L: {
						const {
							response: n
						} = t.payload, o = {
							[n.subredditId]: n.moderators
						};
						return Object(h.merge)({
							...e
						}, o)
					}
					case r.C: {
						const n = t.payload,
							{
								subredditId: o,
								userId: r,
								permissions: s
							} = n;
						return e[o] && e[o][r] ? Object(h.setIn)(e, [o, r, "modPermissions"], s) : e
					}
					default:
						return e
				}
			};
			var qe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.P:
					case r.O:
						return null;
					case r.N:
						return t.payload;
					default:
						return e
				}
			};
			var Qe = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.P:
							return !0;
						case r.O:
						case r.N:
							return !1;
						default:
							return e
					}
				},
				Ye = Object(o.c)({
					error: qe,
					pending: Qe
				}),
				Je = n("./node_modules/lodash/isEqual.js"),
				Xe = n.n(Je);
			var Ze = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.P:
						case r.N:
						case r.jb:
							return null;
						case r.O: {
							const e = t.payload.moderatorIds[0];
							return e ? t.payload.moderators[e] : null
						}
						case r.C: {
							const {
								userId: n,
								permissions: o
							} = t.payload;
							return e && e.id === n && !Xe()(e.modPermissions, o) ? {
								...e,
								modPermissions: o
							} : e
						}
						default:
							return e
					}
				},
				$e = Object(o.c)({
					api: Ye,
					result: Ze
				});
			const et = {};
			var tt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : et,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.M:
					case r.L: {
						const {
							subredditId: n,
							key: o
						} = t.payload;
						return n ? {
							...e,
							[o]: null
						} : e
					}
					case r.K: {
						const {
							error: n,
							subredditId: o,
							key: r
						} = t.payload;
						return o ? {
							...e,
							[r]: n
						} : e
					}
					default:
						return e
				}
			};
			const nt = {};
			var ot = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.K:
						case r.L: {
							const {
								subredditId: n,
								key: o
							} = t.payload;
							return n ? {
								...e,
								[o]: !1
							} : e
						}
						case r.M: {
							const {
								subredditId: n,
								key: o
							} = t.payload;
							return n ? {
								...e,
								[o]: !0
							} : e
						}
						default:
							return e
					}
				},
				rt = Object(o.c)({
					error: tt,
					pending: ot
				});
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const st = {};
			var it = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : st,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.L: {
							const {
								response: n,
								subredditId: o,
								key: r
							} = t.payload, {
								moderatorIds: s
							} = n;
							return Object(h.merge)(e, {
								[o]: {
									[r]: s
								}
							})
						}
						case r.jb: {
							const {
								subredditId: n,
								userId: o
							} = t.payload, r = {
								...e[n]
							};
							return Object.keys(e[n]).forEach(t => {
								const s = e[n][t].filter(e => e !== o);
								r[t] = s
							}), Object(h.set)(e, n, r)
						}
						default:
							return e
					}
				},
				at = Object(o.c)({
					data: it,
					api: rt
				}),
				ct = Object(o.c)({
					editableModerators: xe,
					editableUserOrder: Ie,
					invitedModerators: Fe,
					invitePending: Ue,
					loadMoreModerators: He,
					loadMoreEditableModerators: We,
					models: ze,
					search: $e,
					userOrder: at
				}),
				dt = n("./src/reddit/actions/bulkActions/constants.ts");
			var lt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case dt.c:
						case dt.b:
							return null;
						case dt.a:
							return t.payload;
						default:
							return e
					}
				},
				ut = n("./src/reddit/actions/modQueue/constants.ts");
			var mt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case dt.c:
							return !0;
						case dt.b:
						case dt.a:
						case ut.x:
						case ut.w:
							return !1;
						default:
							return e
					}
				},
				pt = Object(o.c)({
					error: lt,
					pending: mt
				});
			const ht = {};
			var bt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ht,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.a: {
							const {
								ids: n
							} = t.payload, o = {};
							return n.forEach(e => o[e] = !0), {
								...e,
								...o
							}
						}
						case ut.d: {
							const {
								ids: n
							} = t.payload;
							return G()(e, n)
						}
						case ut.c: {
							const {
								ids: e
							} = t.payload, n = {};
							return e.forEach(e => n[e] = !0), n
						}
						default:
							return e
					}
				},
				ft = n("./src/reddit/models/ModQueue/index.ts");
			const gt = {};
			var vt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case dt.b: {
							const {
								operation: e,
								ids: n
							} = t.payload;
							return "approve" === e ? gt : {
								[ft.c[e]]: n
							}
						}
						default:
							return e
					}
				},
				Ct = Object(o.c)({
					api: pt,
					selectedItems: bt,
					undoLastAction: vt
				});
			var yt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.g:
					case ut.f:
						return null;
					case ut.e:
						return t.payload;
					default:
						return e
				}
			};
			var Et = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.g:
							return !0;
						case ut.f:
						case ut.e:
							return !1;
						default:
							return e
					}
				},
				xt = Object(o.c)({
					error: yt,
					pending: Et
				});
			const Ot = {};
			var _t = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ot,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.f: {
						const {
							listingKey: n,
							page: o,
							response: r
						} = t.payload, {
							modqueue: s
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[o]: s
							}
						}
					}
					default:
						return e
				}
			};
			const kt = {};
			var jt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.f: {
							const {
								listingKey: n,
								response: o
							} = t.payload, {
								modqueue: r
							} = o, s = r[r.length - 1] || null;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				St = Object(o.c)({
					api: xt,
					itemOrder: _t,
					loadMore: jt
				}),
				Tt = n("./src/reddit/actions/pages/modListing/constants.ts");
			var wt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Tt.e: {
						const n = t.payload,
							{
								moderatingSubreddits: o
							} = n;
						return o ? null : e
					}
					case ut.i:
					case ut.f:
					case ut.r:
					case ut.u:
					case ut.A: {
						const {
							response: e
						} = t.payload, {
							moderatedAfter: n
						} = e;
						return n
					}
					case ut.n: {
						const e = t.payload,
							{
								moderatedAfter: n
							} = e;
						return n
					}
					default:
						return e
				}
			};
			const It = [];
			var Pt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : It,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.i:
					case ut.f:
					case ut.r:
					case ut.u:
					case ut.A: {
						const {
							response: e
						} = t.payload, {
							listingOrder: n
						} = e;
						return n
					}
					case ut.n: {
						const n = t.payload,
							{
								listingOrder: o
							} = n;
						return [...e, ...o]
					}
					case Tt.e: {
						const n = t.payload,
							{
								listingOrder: o
							} = n;
						return o || e
					}
					default:
						return e
				}
			};
			var Nt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.b:
						return !0;
					default:
						return e
				}
			};
			var Rt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.n:
							return !0;
						case ut.b:
							return !1;
						default:
							return e
					}
				},
				Mt = Object(o.c)({
					after: wt,
					data: Pt,
					loaded: Nt,
					pending: Rt
				});
			var Dt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.j:
					case ut.i:
						return null;
					case ut.h:
						return t.payload;
					default:
						return e
				}
			};
			var Lt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.j:
							return !0;
						case ut.i:
						case ut.h:
							return !1;
						default:
							return e
					}
				},
				At = Object(o.c)({
					error: Dt,
					pending: Lt
				});
			const Ft = {};
			var Bt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ft,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.i: {
						const {
							listingKey: n,
							page: o,
							response: r
						} = t.payload, {
							modqueue: s
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[o]: s
							}
						}
					}
					default:
						return e
				}
			};
			const Ut = {};
			var Kt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ut,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.i: {
							const {
								listingKey: n,
								response: o
							} = t.payload, {
								modqueue: r
							} = o, s = r[r.length - 1] || null;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				Wt = Object(o.c)({
					api: At,
					itemOrder: Bt,
					loadMore: Kt
				});
			var Gt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.s:
					case ut.r:
						return null;
					case ut.q:
						return t.payload;
					default:
						return e
				}
			};
			var Ht = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.s:
							return !0;
						case ut.r:
						case ut.q:
							return !1;
						default:
							return e
					}
				},
				Vt = Object(o.c)({
					error: Gt,
					pending: Ht
				});
			const zt = {};
			var qt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.r: {
						const {
							listingKey: n,
							page: o,
							response: r
						} = t.payload, {
							modqueue: s
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[o]: s
							}
						}
					}
					default:
						return e
				}
			};
			const Qt = {};
			var Yt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.r: {
							const {
								listingKey: n,
								response: o
							} = t.payload, {
								modqueue: r
							} = o, s = r[r.length - 1] || null;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				Jt = Object(o.c)({
					api: Vt,
					itemOrder: qt,
					loadMore: Yt
				});
			var Xt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.v:
					case ut.u:
						return null;
					case ut.t:
						return t.payload;
					default:
						return e
				}
			};
			var Zt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.v:
							return !0;
						case ut.u:
						case ut.t:
							return !1;
						default:
							return e
					}
				},
				$t = Object(o.c)({
					error: Xt,
					pending: Zt
				});
			const en = {};
			var tn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : en,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.u: {
						const {
							listingKey: n,
							page: o,
							response: r
						} = t.payload, {
							modqueue: s
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[o]: s
							}
						}
					}
					default:
						return e
				}
			};
			const nn = {};
			var on = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.u: {
							const {
								listingKey: n,
								response: o
							} = t.payload, {
								modqueue: r
							} = o, s = r[r.length - 1] || null;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				rn = Object(o.c)({
					api: $t,
					itemOrder: tn,
					loadMore: on
				});
			var sn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.B:
					case ut.A:
						return null;
					case ut.z:
						return t.payload;
					default:
						return e
				}
			};
			var an = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.B:
							return !0;
						case ut.A:
						case ut.z:
							return !1;
						default:
							return e
					}
				},
				cn = Object(o.c)({
					error: sn,
					pending: an
				});
			const dn = {};
			var ln = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.A: {
						const {
							listingKey: n,
							page: o,
							response: r
						} = t.payload, {
							modqueue: s
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[o]: s
							}
						}
					}
					default:
						return e
				}
			};
			const un = {};
			var mn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : un,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.A: {
							const {
								listingKey: n,
								response: o
							} = t.payload, {
								modqueue: r
							} = o, s = r[r.length - 1] || null;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				pn = Object(o.c)({
					api: cn,
					itemOrder: ln,
					loadMore: mn
				}),
				hn = Object(o.c)({
					bulkAction: Ct,
					edited: St,
					moderatedCommunitiesOrder: Mt,
					modqueue: Wt,
					reports: Jt,
					spam: rn,
					unmoderated: pn
				});
			var bn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.Y:
					case r.W:
						return null;
					case r.V:
						return t.payload;
					default:
						return e
				}
			};
			const fn = {};
			var gn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.Y: {
							const {
								subredditId: n,
								fetchedToken: o
							} = t.payload, r = Object(i.e)(n, o);
							return {
								...e,
								[r]: !0
							}
						}
						case r.W:
						case r.V: {
							const {
								subredditId: n,
								fetchedToken: o
							} = t.payload, r = Object(i.e)(n, o);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				vn = Object(o.c)({
					error: bn,
					pending: gn
				});
			const Cn = {};
			var yn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Cn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.W: {
							const {
								fetchedToken: n,
								subredditId: o
							} = t.payload, r = Object(i.e)(o, n);
							return {
								...e,
								[r]: !0
							}
						}
						default:
							return e
					}
				},
				En = n("./src/reddit/actions/inContextModeration.ts");
			var xn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case En.b:
						return t.payload;
					default:
						return e
				}
			};
			const On = {};
			var _n = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : On,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.W: {
						const {
							subredditId: e,
							after: n
						} = t.payload;
						return {
							[e]: n
						}
					}
					default:
						return e
				}
			};
			const kn = {};
			var jn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.X:
					case r.W: {
						const {
							subredditId: n,
							mutedUsers: o
						} = t.payload, r = {
							[n]: o
						};
						return Object(h.merge)(e, r)
					}
					case r.cb: {
						const {
							subredditId: n,
							userId: o
						} = t.payload;
						return Object(h.unsetIn)(e, [n, o])
					}
					default:
						return e
				}
			};
			var Sn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.bb:
					case r.ab:
						return null;
					case r.Z:
						return t.payload;
					default:
						return e
				}
			};
			var Tn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.bb:
							return !0;
						case r.ab:
						case r.Z:
							return !1;
						default:
							return e
					}
				},
				wn = Object(o.c)({
					error: Sn,
					pending: Tn
				});
			var In = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.bb:
						case r.Z:
							return null;
						case r.ab: {
							const e = t.payload.mutedUserIds[0];
							return e ? t.payload.mutedUsers[e] : null
						}
						default:
							return e
					}
				},
				Pn = Object(o.c)({
					api: wn,
					result: In
				});
			const Nn = {};
			var Rn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.W: {
							const {
								subredditId: n,
								mutedUserIds: o
							} = t.payload;
							return e[n] ? {
								...e,
								[n]: [...e[n], ...o]
							} : {
								...e,
								[n]: o
							}
						}
						case r.cb: {
							const {
								subredditId: n,
								userId: o
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== o)
							}
						}
						case r.X: {
							const {
								subredditId: n,
								mutedUserIds: o
							} = t.payload, r = o[0];
							return r && e[n] && -1 === e[n].indexOf(r) ? {
								[n]: [r, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				Mn = Object(o.c)({
					api: vn,
					fetchedTokens: yn,
					inContext: xn,
					loadMore: _n,
					models: jn,
					search: Pn,
					userOrder: Rn
				});
			t.a = Object(o.c)({
				approvedSubmitters: _,
				approvedTalkHosts: D,
				flairedUsers: te,
				moderationLog: ye,
				moderators: ct,
				modQueue: hn,
				muted: Mn
			})
		},
		"./src/reddit/selectors/authorFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			}));
			const o = (e, t) => {
					let {
						post: n
					} = t;
					const o = n.belongsTo.id;
					if (!o) return null;
					const r = e.authorFlair.models[o];
					if (!r) return null;
					const s = n.author;
					return s && r[s] || null
				},
				r = (e, t) => {
					let {
						subredditId: n
					} = t;
					const o = e.authorFlair && e.authorFlair.inContext && e.authorFlair.inContext.username;
					if (!o) return null;
					if (!n) return null;
					const r = e.authorFlair.models[n];
					return r ? r[o] : null
				},
				s = e => e.authorFlair.inContext
		},
		"./src/reddit/selectors/avatar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			}));
			var o = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/avatar/index.ts");
			Object(o.a)({
				features: {
					avatar: r.a
				}
			});
			const s = e => {
					var t, n;
					return null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.avatarUser
				},
				i = e => {
					var t, n;
					return null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.avatarUser.csrf_token
				},
				a = e => {
					var t, n;
					return (null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.randomAvatar) || null
				}
		},
		"./src/reddit/selectors/avatarMarketing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			}));
			var o = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/avatar/index.ts"),
				s = n("./src/reddit/selectors/experiments/econ/simpleExperiment.ts");
			Object(o.a)({
				features: {
					avatar: r.a
				}
			});
			const i = e => {
					var t, n;
					return !!(null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.marketing)
				},
				a = e => {
					var t, n, o, r;
					const i = null === (o = null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.marketing) || void 0 === o ? void 0 : o.marketingEvent;
					if (!(null == i ? void 0 : i.active) || !(null === (r = null == i ? void 0 : i.assetUrls) || void 0 === r ? void 0 : r.length)) return null;
					const a = i.assetUrls[0];
					return !i.experimentRequired || Object(s.a)(i.experimentRequired)(e) ? a : null
				}
		},
		"./src/reddit/selectors/crypto/points.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "a", (function() {
				return l
			}));
			var o = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/reddit/contexts/PageLayer/index.tsx"),
				s = n("./src/reddit/endpoints/governance/crypto.ts"),
				i = n("./src/lib/initializeClient/installReducer.ts"),
				a = n("./src/reddit/reducers/features/crypto/index.ts");
			Object(i.a)({
				features: {
					crypto: a.a
				}
			});
			const c = (e, t) => {
				var n, o, r;
				return t ? null === (r = null === (o = null === (n = e.features) || void 0 === n ? void 0 : n.crypto) || void 0 === o ? void 0 : o.points) || void 0 === r ? void 0 : r[t] : void 0
			};

			function d() {
				const e = Object(r.ib)(),
					t = Object(o.e)(t => Object(r.s)(t, {
						pageLayer: e
					})),
					n = Object(o.e)(e => c(e, null == t ? void 0 : t.id));
				return {
					subreddit: t,
					pointsDetails: n
				}
			}
			const l = (e, t) => {
				var n;
				const o = null === (n = c(e, t)) || void 0 === n ? void 0 : n.blockchainProvider;
				return o === s.a.Ethereum || o === s.a.Rinkeby || o === s.a.EthTraderEthereum || o === s.a.EthTraderRinkeby || o === s.a.ArbitrumRinkeby
			}
		},
		"./src/reddit/selectors/editorContent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var o = n("./src/reddit/actions/postCreation/constants.ts");
			const r = (e, t) => e.creations.api.editor.converting.pending[t || o.k]
		},
		"./src/reddit/selectors/experiments/antievil/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var o = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const s = e => {
				return Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: o.M
				}) === o.Yd
			}
		},
		"./src/reddit/selectors/experiments/commentSearchPdp.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var o = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				s = n("./node_modules/reselect/es/index.js");
			const i = Object(s.a)(e => Object(r.c)(e, {
				experimentEligibilitySelector: r.a,
				experimentName: o.Ab
			}), e => ({
				bucketed: e === o.gd.ExpandedSearch || e === o.gd.CollapsedSearch,
				collapsed: e === o.gd.CollapsedSearch,
				expanded: e === o.gd.ExpandedSearch
			}))
		},
		"./src/reddit/selectors/experiments/contributeBeforeSignUp.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			}));
			var o = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				s = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/experiments/utils.ts");
			const a = ["au", "br", "ca", "de", "fr", "gb", "in", "mx", "us", "row"],
				c = Object(o.a)((e, t) => Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: `d2x_start_comment_before_sign_up_${t}`
				}), i.a),
				d = e => a.find(t => !!Object(i.a)(c(e, t))),
				l = Object(o.a)(d, e => !!e),
				u = e => {
					const t = d(e);
					return !!t && c(e, t) === r.Y.SkipOnboarding
				},
				m = e => {
					const t = d(e);
					return !!t && c(e, t) === r.Y.RegOnboarding
				}
		},
		"./src/reddit/selectors/experiments/d2xPdpSideRailRecs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			}));
			var o = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				s = n("./src/reddit/selectors/experiments/index.ts"),
				i = n("./src/reddit/selectors/experiments/utils.ts"),
				a = n("./src/reddit/selectors/meta.ts"),
				c = n("./node_modules/reselect/es/index.js");
			const d = Object(c.a)(e => Object(r.c)(e, {
					experimentEligibilitySelector: e => Object(a.h)(e) && Object(s.f)(e),
					experimentName: o.uc
				}), i.a),
				l = Object(c.a)(e => Object(r.c)(e, {
					experimentEligibilitySelector: e => !Object(a.h)(e) && Object(s.f)(e),
					experimentName: o.tc
				}), i.a),
				u = Object(c.a)(d, l, (e, t) => e || t),
				m = Object(c.a)(d, l, (e, t) => !(!e && !t))
		},
		"./src/reddit/selectors/experiments/navbarLikeMweb.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var o = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const s = e => Object(r.c)(e, {
				experimentName: o.Ue,
				experimentEligibilitySelector: r.a
			}) === o.df.Enabled
		},
		"./src/reddit/selectors/experiments/presence.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var o = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const s = e => {
				return Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: o.rf
				}) === o.Yd
			}
		},
		"./src/reddit/selectors/experiments/typingIndicators.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return l
			}));
			var o = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				s = n("./src/reddit/selectors/experiments/index.ts"),
				i = n("./src/reddit/selectors/experiments/presence.ts");
			const a = e => {
					if (Object(i.a)(e)) return !1;
					return Object(r.c)(e, {
						experimentEligibilitySelector: s.e,
						experimentName: o.Ag
					}) === o.Yd
				},
				c = e => {
					return Object(r.c)(e, {
						experimentEligibilitySelector: s.e,
						experimentName: o.Bg
					}) === o.Yd
				},
				d = e => {
					if (Object(i.a)(e)) return !1;
					const t = Object(r.c)(e, {
						experimentEligibilitySelector: s.e,
						experimentName: o.zg
					});
					return t === o.sg.TypingIndicators || t === o.sg.IndicatorsPlusCTA
				},
				l = e => {
					if (Object(i.a)(e)) return !1;
					const t = Object(s.d)(e, {
						experimentName: o.zg
					});
					return (null == t ? void 0 : t.variant) === o.sg.IndicatorsPlusCTA
				}
		},
		"./src/reddit/selectors/experiments/uxtsIntegration.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return a
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return d
			}));
			var o = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				s = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/user.ts");
			const a = e => {
					var t;
					return (null === (t = null == e ? void 0 : e.user.experiments.byName[r.cd]) || void 0 === t ? void 0 : t.variant) === r.Yd
				},
				c = Object(o.a)(e => Object(s.c)(e, {
					experimentEligibilitySelector: i.S,
					experimentName: r.bc
				}), e => e === r.nd.BottomSheet),
				d = Object(o.a)(e => Object(s.c)(e, {
					experimentEligibilitySelector: i.S,
					experimentName: r.bc,
					expEventOverride: !1
				}), e => !!e)
		},
		"./src/reddit/selectors/gild.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "f", (function() {
				return s
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "a", (function() {
				return d
			}));
			const o = e => e.gild.gildModalThingId,
				r = e => e.gild.correlationId || void 0,
				s = e => e.gild.isAnonymous,
				i = e => e.gild.isIframed,
				a = e => e.gild.message,
				c = e => e.gild.api.pending,
				d = e => e.gild.api.error
		},
		"./src/reddit/selectors/gold/awardIcon.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			}));
			var o = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/Gold/Award.ts"),
				s = n("./src/reddit/selectors/commentSelector.ts"),
				i = n("./src/reddit/selectors/gold/giveAwards.ts"),
				a = n("./src/reddit/selectors/posts.ts"),
				c = n("./src/reddit/selectors/user.ts"),
				d = n("./src/reddit/selectors/userPrefs.ts");
			const l = [32, 48, 64, 128],
				u = (e, t, n) => {
					const o = t ? e[`staticIcon${n}`] : e[`icon${n}`];
					return (null == o ? void 0 : o.url) ? o.url : t ? e.staticIcon.url : e.icon.url
				},
				m = e => {
					let {
						award: t,
						size: n,
						prefersReducedMotion: o,
						postOrComment: s
					} = e;
					return t.awardSubType === r.d.Group ? (e => {
						let {
							award: t,
							size: n,
							prefersReducedMotion: o,
							postOrComment: r
						} = e, s = t;
						if ((null == r ? void 0 : r.awardCountsById) && r.awardCountsById[t.id] && t.tiers) {
							const e = r.awardCountsById[t.id];
							s = t.tiers.reduce((t, n) => e >= n.awardingsRequired ? n : t)
						}
						return u(s, o, n)
					})({
						award: t,
						size: n,
						prefersReducedMotion: o,
						postOrComment: s
					}) : u(t, o, n)
				},
				p = Object(o.a)((e, t) => {
					let {
						awards: n,
						minSize: o,
						postOrCommentId: r
					} = t;
					const i = Object(d.d)(e),
						c = l.find(e => e >= o),
						u = r ? Object(a.F)(e, {
							postId: r
						}) || Object(s.c)(e, {
							commentId: r
						}) : void 0;
					return n.reduce((e, t) => (t && (e[t.id] = m({
						award: t,
						size: c,
						prefersReducedMotion: i,
						postOrComment: u
					})), e), {})
				}),
				h = (e, t) => {
					let {
						award: n,
						minSize: o,
						postOrCommentId: r
					} = t;
					return n ? p(e, {
						awards: [n],
						minSize: o,
						postOrCommentId: r
					})[n.id] : void 0
				},
				b = (e, t) => {
					let {
						minSize: n,
						userName: o
					} = t;
					const r = Object(c.Db)(e, {
						userName: o
					});
					if (r && r.awardedLastMonth && r.awardedLastMonth.topAward) return h(e, {
						award: r.awardedLastMonth.topAward,
						minSize: n
					})
				},
				f = e => {
					const t = Object(i.b)(e),
						n = Object(i.a)(e);
					return h(e, {
						award: t,
						postOrCommentId: n || void 0,
						minSize: 512
					})
				}
		},
		"./src/reddit/selectors/gold/enabledFeatures.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "c", (function() {
				return l
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/featureFlags/index.ts"),
				s = n("./src/reddit/selectors/economics.ts"),
				i = n("./src/reddit/selectors/gold/powerups/index.ts"),
				a = n("./src/reddit/selectors/gold/powerups/benefitSettings.ts");
			const c = Object(o.a)(r.d.spEmotes, s.b, i.a, (e, t, n) => {
					if (n) return !0;
					const o = !(!t || !Object.keys(t).length);
					return e && o
				}),
				d = Object(o.a)(s.b, i.b, i.c, i.a, (e, t, n, o) => {
					if (o) return [...t, ...n].slice(0, 3);
					let r = [];
					for (const s of e || [])
						if ((r = [...r, ...Object.values(s.emotes)]).length > 3) break;
					return r.slice(0, 3)
				}),
				l = Object(o.a)(r.d.spGiphy, i.a, a.a, (e, t, n) => !!(e || t && n))
		},
		"./src/reddit/selectors/gold/giveAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return r
			}));
			const o = e => e.gild.selectedAward,
				r = e => e.gild.gildedThing
		},
		"./src/reddit/selectors/goldPurchaseModals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "r", (function() {
				return i
			})), n.d(t, "t", (function() {
				return a
			})), n.d(t, "s", (function() {
				return c
			})), n.d(t, "v", (function() {
				return d
			})), n.d(t, "u", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "q", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "o", (function() {
				return h
			})), n.d(t, "p", (function() {
				return b
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "l", (function() {
				return v
			})), n.d(t, "x", (function() {
				return C
			})), n.d(t, "y", (function() {
				return y
			})), n.d(t, "w", (function() {
				return E
			})), n.d(t, "z", (function() {
				return x
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "g", (function() {
				return _
			})), n.d(t, "i", (function() {
				return k
			})), n.d(t, "k", (function() {
				return j
			})), n.d(t, "m", (function() {
				return S
			})), n.d(t, "j", (function() {
				return T
			})), n.d(t, "n", (function() {
				return w
			})), n.d(t, "e", (function() {
				return I
			})), n.d(t, "d", (function() {
				return P
			}));
			var o = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				r = n("./src/lib/initializeClient/installReducer.ts"),
				s = n("./src/reddit/reducers/features/goldPurchase/index.ts");
			Object(r.a)({
				features: {
					goldPurchase: s.a
				}
			});
			const i = e => e.features.goldPurchase.purchaseModal.activePage,
				a = e => e.features.goldPurchase.purchaseModal.gildThingId || void 0,
				c = e => e.features.goldPurchase.purchaseModal.correlationId || void 0,
				d = e => e.features.goldPurchase.purchaseModal.showModal,
				l = e => e.features.goldPurchase.purchaseModal.packageId,
				u = e => e.features.goldPurchase.packageOfferModal.packageId,
				m = e => e.features.goldPurchase.premiumPurchaseModal.renewInterval,
				p = e => {
					const t = Object(o.i)(e),
						n = (e => e.features.goldPurchase.premiumPurchaseModal.packageId)(e);
					return t.length && n && t.find(e => e.mobileId === n) || null
				},
				h = e => e.features.goldPurchase.premiumPurchaseModal.activePage,
				b = e => e.features.goldPurchase.premiumPurchaseModal.showModal,
				f = e => e.features.goldPurchase.payment.paymentMethod,
				g = e => e.features.goldPurchase.payment.cardName,
				v = e => e.features.goldPurchase.payment.postalCode,
				C = e => e.features.goldPurchase.payment.savedCardsPending,
				y = e => e.features.goldPurchase.payment.savedCards,
				E = e => e.features.goldPurchase.payment.rememberCard,
				x = e => e.features.goldPurchase.payment.useSavedCard,
				O = e => e.features.goldPurchase.payment.cardValidation.cardCvc,
				_ = e => e.features.goldPurchase.payment.cardValidation.cardExpiry,
				k = e => e.features.goldPurchase.payment.cardValidation.cardNumber,
				j = e => e.features.goldPurchase.payment.cardValidation.nameOnCard,
				S = e => e.features.goldPurchase.payment.cardValidation.postalCode,
				T = e => e.features.goldPurchase.payment.stripeToken.errorMessage,
				w = e => e.features.goldPurchase.payment.stripeToken.pending,
				I = e => e.features.goldPurchase.payment.paypal.passthrough,
				P = e => e.features.goldPurchase.payment.paypal.errorMessage
		},
		"./src/reddit/selectors/products.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./src/reddit/models/Product/index.ts");
			const r = (e, t) => {
					const n = e.products.models[t];
					if (n && n.type === o.a.Badge) return n
				},
				s = (e, t) => {
					let {
						productId: n
					} = t;
					const o = e.products.models[n];
					if (o) {
						const t = o.subredditId,
							r = Object.keys(e.user.ownedBadges[t] || {}),
							s = e.badges.models,
							i = Date.now();
						let a = !1;
						return r.forEach(e => {
							const t = s[e];
							t && t.type === n && t.endsAt > i && (a = !0)
						}), a
					}
					return !1
				}
		},
		"./src/reddit/selectors/removedPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				i = n("./src/reddit/helpers/getRichTextContent/index.ts"),
				a = n("./src/reddit/models/Media/index.ts"),
				c = n("./src/reddit/models/Post/index.ts"),
				d = n("./src/reddit/selectors/user.ts");
			const l = new Set([c.g.AntiEvilOps, c.g.AutomodFiltered, c.g.CommunityOps, c.g.ContentTakedown, c.g.CopyrightTakedown, c.g.Moderator, c.g.Reddit]),
				u = new Set([c.g.Author, c.g.AuthorDeleted]),
				m = Object(r.a)(s.a, e => {
					var t;
					if (!e) return !1;
					if (e.removedByCategory) {
						const t = e.removedByCategory;
						return l.has(t)
					}
					if (e.created > Date.UTC(2019, 0)) return !1;
					const n = o.fbt._("[removed]", null, {
						hk: "2CBRa4"
					}).toString();
					let r = Object(i.b)(e);
					return r || (null === (t = e.media) || void 0 === t ? void 0 : t.type) !== a.o.TEXT || (r = e.media.markdownContent), r === n
				}),
				p = Object(r.a)(s.a, e => {
					var t;
					if (!e) return !1;
					if (e.removedByCategory) {
						const t = e.removedByCategory;
						return u.has(t)
					}
					if (e.created > Date.UTC(2019, 0)) return !1;
					const n = o.fbt._("[deleted]", null, {
						hk: "12mOne"
					}).toString();
					let r = Object(i.b)(e);
					return r || (null === (t = e.media) || void 0 === t ? void 0 : t.type) !== a.o.TEXT || (r = e.media.markdownContent), r === n
				}),
				h = Object(r.a)(s.a, e => {
					if (!e) return !1;
					if (e && e.isSpam) return !1;
					if (e.removedByCategory) {
						const t = e.removedByCategory;
						return u.has(t)
					}
					return !(e.created > Date.UTC(2019, 0))
				}),
				b = Object(r.a)(d.m, s.a, (e, t) => !!((null == e ? void 0 : e.id) && (null == t ? void 0 : t.authorId)) && e.id === t.authorId),
				f = Object(r.a)(s.a, e => !(!e || !1 !== e.isRobotIndexable))
		},
		"./src/reddit/selectors/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return i
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "i", (function() {
				return d
			})), n.d(t, "j", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "q", (function() {
				return h
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "p", (function() {
				return g
			})), n.d(t, "k", (function() {
				return v
			})), n.d(t, "a", (function() {
				return C
			})), n.d(t, "r", (function() {
				return y
			})), n.d(t, "m", (function() {
				return E
			})), n.d(t, "n", (function() {
				return x
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "o", (function() {
				return k
			})), n.d(t, "b", (function() {
				return j
			}));
			var o = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				r = n("./src/reddit/models/Flair/index.ts"),
				s = n("./src/reddit/models/ScheduledPost/index.ts");
			const i = (e, t) => {
					let {
						subredditId: n
					} = t;
					return ((e, t) => {
						let {
							subredditId: n,
							type: o
						} = t;
						return !!e.posts.scheduledPosts[o].models[n]
					})(e, {
						subredditId: n,
						type: s.g.standalonePosts
					})
				},
				a = (e, t) => {
					let {
						subredditId: n,
						type: o
					} = t;
					return !!e.posts.scheduledPosts[o].pageInfo[n] && e.posts.scheduledPosts[o].pageInfo[n].hasNextPage
				},
				c = (e, t) => {
					let {
						subredditId: n,
						type: o
					} = t;
					return e.posts.scheduledPosts[o].pageInfo[n] ? e.posts.scheduledPosts[o].pageInfo[n].endCursor : null
				},
				d = e => e.posts.scheduledPosts.api.pending,
				l = e => e.posts.scheduledPosts.api.pendingUpdate,
				u = e => e.posts.scheduledPosts.api.error,
				m = {},
				p = [],
				h = (e, t) => {
					let {
						subredditId: n
					} = t;
					return (e.posts.scheduledPosts.standalonePosts.postOrder[n] || p).filter(t => !!(e.posts.scheduledPosts.standalonePosts.models[n] || m)[t]).map(t => e.posts.scheduledPosts.standalonePosts.models[n][t])
				},
				b = (e, t) => {
					let {
						subredditId: n
					} = t;
					return (e.posts.scheduledPosts.recurringPosts.postOrder[n] || p).filter(t => !!(e.posts.scheduledPosts.recurringPosts.models[n] || m)[t]).map(t => e.posts.scheduledPosts.recurringPosts.models[n][t])
				},
				f = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: o,
						type: r
					} = t;
					return (e.posts.scheduledPosts[r].models[n] || m)[o] || void 0
				},
				g = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: o
					} = t;
					return f(e, {
						subredditId: n,
						scheduledPostId: o,
						type: s.g.standalonePosts
					})
				},
				v = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: o
					} = t;
					const r = f(e, {
						subredditId: n,
						scheduledPostId: o,
						type: s.g.recurringPosts
					});
					return r || r
				},
				C = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: o
					} = t;
					return g(e, {
						subredditId: n,
						scheduledPostId: o
					}) || v(e, {
						subredditId: n,
						scheduledPostId: o
					})
				},
				y = e => e.creations.formData.scheduledPostId,
				E = e => {
					let {
						scheduledPost: t
					} = e;
					return (e => {
						let {
							flair: t,
							isNsfw: n,
							isSpoiler: s,
							isOriginalContent: i
						} = e;
						const a = [];
						return i && a.push({
							text: "OC",
							type: r.f.Oc
						}), t && a.push(...Object(o.c)(t)), s && a.push({
							text: "spoiler",
							type: r.f.Spoiler
						}), n && a.push({
							text: "nsfw",
							type: r.f.Nsfw
						}), a
					})(t)
				},
				x = e => {
					let {
						scheduledPost: t
					} = e;
					const n = E({
							scheduledPost: t
						}),
						o = n.find(e => e.type === r.f.Richtext);
					return o || (n.find(e => e.type === r.f.Text) || null)
				},
				O = e => e.posts.scheduledPosts[s.g.recurringPosts].editModal.scheduledPostId,
				_ = e => e.posts.scheduledPosts[s.g.recurringPosts].editModal.subredditId,
				k = e => e.posts.scheduledPosts.api.pendingUpdate,
				j = e => e.posts.scheduledPosts.api.creationToken
		},
		"./src/reddit/selectors/userPrefs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			}));
			var o = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/selectors/user.ts");
			const s = e => {
					const t = Object(r.S)(e);
					if (i(e)) return !1;
					const {
						subscriptionsPinned: n
					} = e.user.prefs;
					return void 0 === n && !t || !!n
				},
				i = e => !(!e.platform.currentPage || !e.platform.currentPage.meta || e.platform.currentPage.meta.name !== o.Tb.MODERATION_PAGES),
				a = e => e.user.prefs.reduceAnimationsFromAwards,
				c = e => !!e.user.prefs.over18
		},
		"./src/reddit/singleton/EventSystem.ts": function(e, t, n) {
			"use strict";
			var o = n("./src/config.ts"),
				r = n("./src/lib/fastdom/index.ts"),
				s = n("./src/reddit/actions/jsApi.ts");
			const i = "JSAPI customEvent.detail.name is deprecated. Please upgrade to <meta>",
				a = "jsapi.consumer",
				c = "/r/redesign/wiki/jsapi";
			var d = n("./src/reddit/constants/jsapiEvents.ts");
			const l = 100;
			const u = new class {
				constructor() {
					if (this.queue = [], this.active = !1, "undefined" == typeof document) return;
					let e;
					this.store = new Promise(t => e = t), this.attachStore = t => e(t);
					const t = document.querySelectorAll(`meta[name="${a}"]`);
					t.length && (t.forEach(e => {
						const t = e.content;
						this.store.then(e => e.dispatch(s.b(t)))
					}), this.store.then(() => this.fireEventsQueue())), document.addEventListener(d.b, e => this.onReadyEvent(e), !0)
				}
				onReadyEvent(e) {
					let t;
					if (this.active = !0, e.target && e.target instanceof HTMLMetaElement && e.target.name === a && (t = e.target.content), !t) try {
						e.detail && (t = e.detail.name, console.warn(i, `${o.a.redditUrl}${c}`, e))
					} catch (n) {
						return void console.error(i, `${o.a.redditUrl}${c}`, n)
					}
					this.store.then(e => {
						e.dispatch(s.b(t || "")), this.fireEventsQueue()
					})
				}
				publish(e, t, n) {
					const o = {
						name: e,
						props: t,
						element: n
					};
					this.queue.push(o), this.queue.length > l && this.queue.shift(), this.active && this.fireEvent(o)
				}
				fireEvent(e) {
					e.element.dispatchEvent(new CustomEvent(e.name, {
						detail: e.props
					}))
				}
				fireEventsQueue() {
					r.a.read(() => {
						for (let e = 0; e < this.queue.length; e++) {
							const t = this.queue[e];
							this.fireEvent(t)
						}
					})
				}
			};
			t.a = u
		},
		"./src/redditGQL/operations/CommentToxicity.json": function(e) {
			e.exports = JSON.parse('{"id":"445164f0825f"}')
		},
		"./src/redditGQL/operations/CreateComment.json": function(e) {
			e.exports = JSON.parse('{"id":"f0b0ca6701b9"}')
		},
		"./src/redditGQL/operations/CreateLiveAudioRoomOnProfile.json": function(e) {
			e.exports = JSON.parse('{"id":"e35a47c6aa21"}')
		},
		"./src/redditGQL/operations/CreateLiveAudioRoomOrError.json": function(e) {
			e.exports = JSON.parse('{"id":"f1f366237119"}')
		},
		"./src/redditGQL/operations/CreateScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"737d59db38fc"}')
		},
		"./src/redditGQL/operations/DeleteSubredditMuteSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"c518a45f60a5"}')
		},
		"./src/redditGQL/operations/GetAvailableAudioRoomTopics.json": function(e) {
			e.exports = JSON.parse('{"id":"05271fef4b69"}')
		},
		"./src/redditGQL/operations/GetSubredditAllowedPostTypes.json": function(e) {
			e.exports = JSON.parse('{"id":"f65cf1eba776"}')
		},
		"./src/redditGQL/operations/GetUserProfileAllowedPostTypes.json": function(e) {
			e.exports = JSON.parse('{"id":"34fa0ef8e099"}')
		},
		"./src/redditGQL/operations/LanguageSelections.json": function(e) {
			e.exports = JSON.parse('{"id":"40df26b7117b"}')
		},
		"./src/redditGQL/operations/MutedSubreddits.json": function(e) {
			e.exports = JSON.parse('{"id":"c09ff0d041c1"}')
		},
		"./src/redditGQL/operations/PollVote.json": function(e) {
			e.exports = JSON.parse('{"id":"a20cc8dd230d"}')
		},
		"./src/redditGQL/operations/PostGuidanceValidation.json": function(e) {
			e.exports = JSON.parse('{"id":"f61154c007f1"}')
		},
		"./src/redditGQL/operations/PrepareLiveAudioRoom.json": function(e) {
			e.exports = JSON.parse('{"id":"a04297924fc8"}')
		},
		"./src/redditGQL/operations/PrepareLiveAudioRoomOnProfile.json": function(e) {
			e.exports = JSON.parse('{"id":"649e9f8bd6d9"}')
		},
		"./src/redditGQL/operations/ReportTalk.json": function(e) {
			e.exports = JSON.parse('{"id":"139ca5b89cf9"}')
		},
		"./src/redditGQL/operations/StartLiveAudioRoom.json": function(e) {
			e.exports = JSON.parse('{"id":"6e7ab4bd4873"}')
		},
		"./src/redditGQL/operations/SubredditScheduledPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"2289de7a3370"}')
		},
		"./src/redditGQL/operations/SubredditTypeaheadSearch.json": function(e) {
			e.exports = JSON.parse('{"id":"20edc5ee12df"}')
		},
		"./src/redditGQL/operations/SubscribedSubreddits.json": function(e) {
			e.exports = JSON.parse('{"id":"ca83defc2e15"}')
		},
		"./src/redditGQL/operations/UpdateComment.json": function(e) {
			e.exports = JSON.parse('{"id":"3d83ef4f0375"}')
		},
		"./src/redditGQL/operations/UpdateCommentFollowState.json": function(e) {
			e.exports = JSON.parse('{"id":"0a2ed51664c5"}')
		},
		"./src/redditGQL/operations/UpdateScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"db256acfa640"}')
		},
		"./src/redditGQL/operations/UpdateSpokenLanguagesPreference.json": function(e) {
			e.exports = JSON.parse('{"id":"6d0707c83164"}')
		},
		"./src/redditGQL/operations/UpdateSubredditMuteAndNotificationLevelSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"2620d72fd633"}')
		},
		"./src/redditGQL/operations/UpdateSubredditMuteSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"432f6b475ece"}')
		}
	}
]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/PostCreation.773a0a9e2804cdcd7a06.js.map