// https://www.redditstatic.com/desktop2x/Governance~ModListing~Reddit~ReportFlow.01e832fec08b376ce5b3.js
// Retrieved at 6/22/2023, 6:10:04 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["Governance~ModListing~Reddit~ReportFlow"], {
		"./src/lib/assertNever.ts": function(t, e, i) {
			"use strict";

			function n(t) {
				throw new Error(`Unexpected object: ${t}`)
			}
			i.d(e, "a", (function() {
				return n
			}))
		},
		"./src/lib/constants/icons.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			}));
			const n = {
				activity: "activity",
				activity_fill: "activity_fill",
				add: "add",
				add_fill: "add_fill",
				add_media: "add_media",
				add_media_fill: "add_media_fill",
				add_to_feed: "add_to_feed",
				add_to_feed_fill: "add_to_feed_fill",
				admin: "admin",
				admin_fill: "admin_fill",
				all: "all",
				all_fill: "all_fill",
				appearance: "appearance",
				appearance_fill: "appearance_fill",
				approve: "approve",
				approve_fill: "approve_fill",
				archived: "archived",
				archived_fill: "archived_fill",
				aspect_ratio: "aspect_ratio",
				aspect_ratio_fill: "aspect_ratio_fill",
				aspect_rectangle: "aspect_rectangle",
				aspect_rectangle_fill: "aspect_rectangle_fill",
				attach: "attach",
				attach_fill: "attach_fill",
				audio: "audio",
				audio_fill: "audio_fill",
				author: "author",
				author_fill: "author_fill",
				avatar_style: "avatar_style",
				avatar_style_fill: "avatar_style_fill",
				award: "award",
				award_fill: "award_fill",
				back: "back",
				back_fill: "back_fill",
				ban: "ban",
				ban_fill: "ban_fill",
				best: "best",
				best_fill: "best_fill",
				block: "block",
				block_fill: "block_fill",
				bold: "bold",
				bold_fill: "bold_fill",
				bot: "bot",
				bot_fill: "bot_fill",
				bounce: "bounce",
				bounce_fill: "bounce_fill",
				browse: "browse",
				browse_fill: "browse_fill",
				browser: "browser",
				browser_fill: "browser_fill",
				cake: "cake",
				cake_fill: "cake_fill",
				calendar: "calendar",
				camera: "camera",
				camera_fill: "camera_fill",
				campaign: "campaign",
				caret_down: "caret_down",
				caret_down_fill: "caret_down_fill",
				caret_left: "caret_left",
				caret_left_fill: "caret_left_fill",
				caret_right: "caret_right",
				caret_right_fill: "caret_right_fill",
				caret_up: "caret_up",
				caret_up_fill: "caret_up_fill",
				chat: "chat",
				chat_fill: "chat_fill",
				chat_group: "chat_group",
				chat_group_fill: "chat_group_fill",
				chat_new: "chat_new",
				chat_new_fill: "chat_new_fill",
				checkbox: "checkbox",
				checkbox_dismiss: "checkbox_dismiss",
				checkbox_dismiss_fill: "checkbox_dismiss_fill",
				checkbox_fill: "checkbox_fill",
				checkmark: "checkmark",
				checkmark_fill: "checkmark_fill",
				chrome: "chrome",
				chrome_fill: "chrome_fill",
				clear: "clear",
				clear_fill: "clear_fill",
				close: "close",
				close_fill: "close_fill",
				closed_captioning: "closed_captioning",
				closed_captioning_fill: "closed_captioning_fill",
				code_block: "code_block",
				code_block_fill: "code_block_fill",
				code_inline: "code_inline",
				code_inline_fill: "code_inline_fill",
				coins: "coins",
				coins_fill: "coins_fill",
				coins_outline_color: "coins_outline_color",
				collapse: "collapse",
				collapse_fill: "collapse_fill",
				collection: "collection",
				collection_fill: "collection_fill",
				comment: "comment",
				comment_fill: "comment_fill",
				comments: "comments",
				comments_fill: "comments_fill",
				community: "community",
				community_fill: "community_fill",
				controversial: "controversial",
				controversial_fill: "controversial_fill",
				crop: "crop",
				crop_fill: "crop_fill",
				crosspost: "crosspost",
				crosspost_fill: "crosspost_fill",
				crowd_control: "crowd_control",
				crowd_control_fill: "crowd_control_fill",
				custom_feed: "custom_feed",
				custom_feed_fill: "custom_feed_fill",
				customize: "customize",
				customize_fill: "customize_fill",
				day: "day",
				day_fill: "day_fill",
				delete: "delete",
				delete_fill: "delete_fill",
				discover: "discover",
				discover_fill: "discover_fill",
				dismiss_all: "dismiss_all",
				dismiss_all_fill: "dismiss_all_fill",
				distinguish: "distinguish",
				distinguish_fill: "distinguish_fill",
				down: "down",
				down_fill: "down_fill",
				download: "download",
				download_fill: "download_fill",
				downvote: "downvote",
				downvote_fill: "downvote_fill",
				downvotes: "downvotes",
				downvotes_fill: "downvotes_fill",
				drag: "drag",
				duplicate: "duplicate",
				duplicate_fill: "duplicate_fill",
				edit: "edit",
				edit_fill: "edit_fill",
				effect: "effect",
				effect_fill: "effect_fill",
				embed: "embed",
				embed_fill: "embed_fill",
				emoji: "emoji",
				emoji_fill: "emoji_fill",
				expand: "expand",
				expand_fill: "expand_fill",
				external_link: "external_link",
				external_link_fill: "external_link_fill",
				feed_posts: "feed_posts",
				feed_posts_fill: "feed_posts_fill",
				feed_video: "feed_video",
				feed_video_fill: "feed_video_fill",
				filter: "filter",
				filter_fill: "filter_fill",
				format: "format",
				format_fill: "format_fill",
				forward: "forward",
				forward_fill: "forward_fill",
				gif_post: "gif_post",
				gif_post_fill: "gif_post_fill",
				heart: "heart",
				heart_fill: "heart_fill",
				help: "help",
				help_fill: "help_fill",
				hide: "hide",
				hide_fill: "hide_fill",
				history: "history",
				history_fill: "history_fill",
				home: "home",
				home_fill: "home_fill",
				hot: "hot",
				hot_fill: "hot_fill",
				ignore_reports: "ignore_reports",
				ignore_reports_fill: "ignore_reports_fill",
				image_post: "image_post",
				image_post_fill: "image_post_fill",
				info: "info",
				info_fill: "info_fill",
				italic: "italic",
				italic_fill: "italic_fill",
				join: "join",
				join_fill: "join_fill",
				joined: "joined",
				joined_fill: "joined_fill",
				jump_down: "jump_down",
				jump_down_fill: "jump_down_fill",
				jump_up: "jump_up",
				jump_up_fill: "jump_up_fill",
				karma: "karma",
				karma_fill: "karma_fill",
				keyboard: "keyboard",
				keyboard_fill: "keyboard_fill",
				kick: "kick",
				kick_fill: "kick_fill",
				leave: "leave",
				leave_fill: "leave_fill",
				left: "left",
				left_fill: "left_fill",
				link_post: "link_post",
				link_post_fill: "link_post_fill",
				list_bulleted: "list_bulleted",
				list_bulleted_fill: "list_bulleted_fill",
				list_numbered: "list_numbered",
				list_numbered_fill: "list_numbered_fill",
				live: "live",
				live_fill: "live_fill",
				load: "load",
				location: "location",
				location_fill: "location_fill",
				lock: "lock",
				lock_fill: "lock_fill",
				logout: "logout",
				logout_fill: "logout_fill",
				loop: "loop",
				loop_fill: "loop_fill",
				mark_read: "mark_read",
				mark_read_fill: "mark_read_fill",
				mask: "mask",
				mask_fill: "mask_fill",
				media_gallery: "media_gallery",
				media_gallery_fill: "media_gallery_fill",
				meme: "meme",
				meme_fill: "meme_fill",
				menu: "menu",
				menu_fill: "menu_fill",
				message: "message",
				message_fill: "message_fill",
				mod: "mod",
				mod_fill: "mod_fill",
				mod_mail: "mod_mail",
				mod_mail_fill: "mod_mail_fill",
				mod_mode: "mod_mode",
				mod_mode_fill: "mod_mode_fill",
				mod_mute: "mod_mute",
				mod_mute_fill: "mod_mute_fill",
				mod_overflow: "mod_overflow",
				mod_overflow_fill: "mod_overflow_fill",
				mod_queue: "mod_queue",
				mod_queue_fill: "mod_queue_fill",
				mod_unmute: "mod_unmute",
				mod_unmute_fill: "mod_unmute_fill",
				new: "new",
				new_fill: "new_fill",
				night: "night",
				night_fill: "night_fill",
				notification: "notification",
				notification_fill: "notification_fill",
				notification_frequent: "notification_frequent",
				notification_frequent_fill: "notification_frequent_fill",
				notification_off: "notification_off",
				notification_off_fill: "notification_off_fill",
				nsfw: "nsfw",
				nsfw_fill: "nsfw_fill",
				nsfw_language: "nsfw_language",
				nsfw_language_fill: "nsfw_language_fill",
				nsfw_violence: "nsfw_violence",
				nsfw_violence_fill: "nsfw_violence_fill",
				original: "original",
				original_fill: "original_fill",
				overflow_carat: "overflow_carat",
				overflow_carat_fill: "overflow_carat_fill",
				overflow_horizontal: "overflow_horizontal",
				overflow_vertical: "overflow_vertical",
				pause: "pause",
				pause_fill: "pause_fill",
				payment: "payment",
				payment_fill: "payment_fill",
				peace: "peace",
				peace_fill: "peace_fill",
				pending_posts: "pending_posts",
				pending_posts_fill: "pending_posts_fill",
				pin: "pin",
				pin_fill: "pin_fill",
				play: "play",
				play_fill: "play_fill",
				poll_post: "poll_post",
				poll_post_fill: "poll_post_fill",
				popular: "popular",
				popular_fill: "popular_fill",
				prediction: "prediction",
				prediction_fill: "prediction_fill",
				premium: "premium",
				premium_fill: "premium_fill",
				privacy: "privacy",
				privacy_fill: "privacy_fill",
				profile: "profile",
				profile_fill: "profile_fill",
				promote_snoo: "promote_snoo",
				qr_code: "qr_code",
				quarantined: "quarantined",
				quarantined_fill: "quarantined_fill",
				quote: "quote",
				quote_fill: "quote_fill",
				r_slash: "r_slash",
				r_slash_fill: "r_slash_fill",
				radio_button: "radio_button",
				radio_button_fill: "radio_button_fill",
				random: "random",
				random_fill: "random_fill",
				rating_drugs: "rating_drugs",
				rating_everyone: "rating_everyone",
				rating_mature: "rating_mature",
				rating_nsfw: "rating_nsfw",
				rating_violence: "rating_violence",
				refresh: "refresh",
				refresh_fill: "refresh_fill",
				remove: "remove",
				remove_fill: "remove_fill",
				reply: "reply",
				reply_fill: "reply_fill",
				report: "report",
				report_fill: "report_fill",
				reverse: "reverse",
				reverse_fill: "reverse_fill",
				right: "right",
				right_fill: "right_fill",
				rising: "rising",
				rising_fill: "rising_fill",
				rotate: "rotate",
				rotate_fill: "rotate_fill",
				rules: "rules",
				rules_fill: "rules_fill",
				safari: "safari",
				safari_fill: "safari_fill",
				save: "save",
				save_fill: "save_fill",
				saved: "saved",
				saved_fill: "saved_fill",
				scheduled: "scheduled",
				scheduled_fill: "scheduled_fill",
				search: "search",
				search_fill: "search_fill",
				self: "self",
				self_fill: "self_fill",
				send: "send",
				send_fill: "send_fill",
				settings: "settings",
				settings_fill: "settings_fill",
				share: "share",
				share_android: "share_android",
				share_android_fill: "share_android_fill",
				share_fill: "share_fill",
				share_ios: "share_ios",
				share_ios_fill: "share_ios_fill",
				show: "show",
				show_fill: "show_fill",
				side_menu: "side_menu",
				side_menu_fill: "side_menu_fill",
				skipback10: "skipback10",
				skipback10_fill: "skipback10_fill",
				skipforward10: "skipforward10",
				skipforward10_fill: "skipforward10_fill",
				sort: "sort",
				sort_fill: "sort_fill",
				spam: "spam",
				spam_fill: "spam_fill",
				spoiler: "spoiler",
				spoiler_fill: "spoiler_fill",
				sponsored: "sponsored",
				sponsored_fill: "sponsored_fill",
				star: "star",
				star_fill: "star_fill",
				statistics: "statistics",
				statistics_fill: "statistics_fill",
				sticker: "sticker",
				sticker_fill: "sticker_fill",
				strikethrough: "strikethrough",
				strikethrough_fill: "strikethrough_fill",
				subtract: "subtract",
				subtract_fill: "subtract_fill",
				superscript: "superscript",
				superscript_fill: "superscript_fill",
				swipe_back: "swipe_back",
				swipe_back_fill: "swipe_back_fill",
				swipe_down: "swipe_down",
				swipe_down_fill: "swipe_down_fill",
				swipe_forward: "swipe_forward",
				swipe_forward_fill: "swipe_forward_fill",
				swipe_up: "swipe_up",
				swipe_up_fill: "swipe_up_fill",
				table: "table",
				table_fill: "table_fill",
				tag: "tag",
				tag_fill: "tag_fill",
				tap: "tap",
				tap_fill: "tap_fill",
				text_post: "text_post",
				text_post_fill: "text_post_fill",
				text_size: "text_size",
				text_size_fill: "text_size_fill",
				top: "top",
				top_fill: "top_fill",
				topic: "topic",
				topic_activism: "topic_activism",
				topic_addiction_support: "topic_addiction_support",
				topic_advice: "topic_advice",
				topic_animals: "topic_animals",
				topic_anime: "topic_anime",
				topic_art: "topic_art",
				topic_beauty: "topic_beauty",
				topic_business: "topic_business",
				topic_careers: "topic_careers",
				topic_cars: "topic_cars",
				topic_celebrity: "topic_celebrity",
				topic_crafts: "topic_crafts",
				topic_crypto: "topic_crypto",
				topic_culture: "topic_culture",
				topic_diy: "topic_diy",
				topic_entertainment: "topic_entertainment",
				topic_ethics: "topic_ethics",
				topic_family: "topic_family",
				topic_fashion: "topic_fashion",
				topic_fitness: "topic_fitness",
				topic_food: "topic_food",
				topic_funny: "topic_funny",
				topic_gender: "topic_gender",
				topic_health: "topic_health",
				topic_help: "topic_help",
				topic_history: "topic_history",
				topic_internet: "topic_internet",
				topic_law: "topic_law",
				topic_learning: "topic_learning",
				topic_lifestyle: "topic_lifestyle",
				topic_mature: "topic_mature",
				topic_mensfashion: "topic_mensfashion",
				topic_menshealth: "topic_menshealth",
				topic_meta: "topic_meta",
				topic_military: "topic_military",
				topic_movies: "topic_movies",
				topic_music: "topic_music",
				topic_news: "topic_news",
				topic_other: "topic_other",
				topic_outdoors: "topic_outdoors",
				topic_pets: "topic_pets",
				topic_photography: "topic_photography",
				topic_places: "topic_places",
				topic_politics: "topic_politics",
				topic_programming: "topic_programming",
				topic_reading: "topic_reading",
				topic_reading_fill: "topic_reading_fill",
				topic_religion: "topic_religion",
				topic_science: "topic_science",
				topic_sexorientation: "topic_sexorientation",
				topic_sports: "topic_sports",
				topic_style: "topic_style",
				topic_tabletop: "topic_tabletop",
				topic_technology: "topic_technology",
				topic_television: "topic_television",
				topic_traumasupport: "topic_traumasupport",
				topic_travel: "topic_travel",
				topic_videogaming: "topic_videogaming",
				topic_womenshealth: "topic_womenshealth",
				trim: "trim",
				trim_fill: "trim_fill",
				trophy: "trophy",
				trophy_fill: "trophy_fill",
				u_slash: "u_slash",
				u_slash_fill: "u_slash_fill",
				unban: "unban",
				unban_fill: "unban_fill",
				undo: "undo",
				undo_fill: "undo_fill",
				unheart: "unheart",
				unlock: "unlock",
				unlock_fill: "unlock_fill",
				unmod: "unmod",
				unmod_fill: "unmod_fill",
				unpin: "unpin",
				unpin_fill: "unpin_fill",
				unverified: "unverified",
				unverified_fill: "unverified_fill",
				up: "up",
				up_fill: "up_fill",
				upload: "upload",
				upload_fill: "upload_fill",
				upvote: "upvote",
				upvote_fill: "upvote_fill",
				upvotes: "upvotes",
				upvotes_fill: "upvotes_fill",
				user: "user",
				user_fill: "user_fill",
				user_note: "user_note",
				user_note_fill: "user_note_fill",
				vault: "vault",
				vault_fill: "vault_fill",
				verified: "verified",
				verified_fill: "verified_fill",
				video_camera: "video_camera",
				video_camera_fill: "video_camera_fill",
				video_post: "video_post",
				video_post_fill: "video_post_fill",
				view_card: "view_card",
				view_card_fill: "view_card_fill",
				view_classic: "view_classic",
				view_classic_fill: "view_classic_fill",
				view_compact: "view_compact",
				view_compact_fill: "view_compact_fill",
				view_grid_fill: "view_grid_fill",
				view_grid_fill_1: "view_grid_fill_1",
				views: "views",
				views_fill: "views_fill",
				volume: "volume",
				volume_fill: "volume_fill",
				volume_mute: "volume_mute",
				volume_mute_fill: "volume_mute_fill",
				wiki: "wiki",
				wiki_fill: "wiki_fill",
				wiki_ban: "wiki_ban",
				wiki_ban_fill: "wiki_ban_fill",
				wiki_unban: "wiki_unban",
				wiki_unban_fill: "wiki_unban_fill",
				world: "world",
				world_fill: "world_fill"
			}
		},
		"./src/lib/formatApiError/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return o
			}));
			var n = i("./node_modules/fbt/lib/FbtPublic.js"),
				r = i("./src/lib/constants/index.ts");

			function o(t, e) {
				return t ? t.fields && t.fields.length ? t.fields.map(t => t.msg).join(", ") : t.type && s[t.type] ? s[t.type]() : 401 === e ? n.fbt._("There was an authentication error", null, {
					hk: "2KZTRv"
				}) : n.fbt._("Something went wrong", null, {
					hk: "3i6szH"
				}) : ""
			}
			const s = {
				[r.k]: () => n.fbt._("you're not allowed to do that", null, {
					hk: "1jGKQw"
				}),
				[r.N]: () => n.fbt._("GIF size must be less than {max file size}MB", [n.fbt._param("max file size", Math.floor(r.eb / r.mb).toString())], {
					hk: "1zzsdM"
				}),
				[r.W]: () => n.fbt._("Image size must be less than {max file size}MB", [n.fbt._param("max file size", Math.floor(r.gb / r.mb).toString())], {
					hk: "3H6bF8"
				}),
				[r.Y]: () => n.fbt._("Sorry, we accept only images (.png, .jpeg, .gif) and videos (.mp4, .mov)", null, {
					hk: "1hw868"
				}),
				[r.vc]: () => n.fbt._("Video size must be less than {max file size}GB", [n.fbt._param("max file size", (r.kb / r.mb / 1024).toFixed(1))], {
					hk: "4FkABU"
				})
			}
		},
		"./src/lib/makePostDraftPageKey/index.ts": function(t, e, i) {
			"use strict";

			function n(t) {
				let e = "PostDraftPage";
				return t.draftId && (e += `--[draftId:${t.draftId}]`), e
			}
			i.d(e, "a", (function() {
				return n
			}))
		},
		"./src/reddit/actions/apiRequestState.ts": function(t, e, i) {
			"use strict";
			i.d(e, "d", (function() {
				return o
			})), i.d(e, "a", (function() {
				return s
			})), i.d(e, "b", (function() {
				return l
			})), i.d(e, "c", (function() {
				return c
			})), i.d(e, "h", (function() {
				return a
			})), i.d(e, "e", (function() {
				return d
			})), i.d(e, "f", (function() {
				return u
			})), i.d(e, "g", (function() {
				return _
			}));
			var n = i("./src/lib/makeActionCreator/index.ts"),
				r = i("./src/reddit/models/ApiRequestState/index.ts");
			const o = "API_REQUEST_STATE__STARTED",
				s = "API_REQUEST_STATE__COMPLETED",
				l = "API_REQUEST_STATE__FAILED",
				c = "API_REQUEST_STATE__RELEASED";

			function a(t) {
				return {
					type: o,
					payload: {
						apiRequestStatus: r.a.Pending,
						apiRequestId: t
					}
				}
			}

			function d(t) {
				return {
					type: s,
					payload: {
						apiRequestStatus: r.a.Complete,
						apiRequestId: t
					}
				}
			}

			function u(t, e) {
				return {
					type: l,
					payload: {
						apiRequestStatus: r.a.Failed,
						apiRequestId: t,
						apiError: e
					}
				}
			}
			const _ = Object(n.a)(c)
		},
		"./src/reddit/actions/grantUserFlair/constants.ts": function(t, e, i) {
			"use strict";
			i.d(e, "i", (function() {
				return n
			})), i.d(e, "g", (function() {
				return r
			})), i.d(e, "f", (function() {
				return o
			})), i.d(e, "l", (function() {
				return s
			})), i.d(e, "k", (function() {
				return l
			})), i.d(e, "j", (function() {
				return c
			})), i.d(e, "h", (function() {
				return a
			})), i.d(e, "a", (function() {
				return d
			})), i.d(e, "b", (function() {
				return u
			})), i.d(e, "e", (function() {
				return _
			})), i.d(e, "c", (function() {
				return f
			})), i.d(e, "d", (function() {
				return p
			}));
			const n = "SUBREDDIT__FLAIRED_USERS_PENDING",
				r = "SUBREDDIT__FLAIRED_USERS_LOADED",
				o = "SUBREDDIT__FLAIRED_USERS_FAILED",
				s = "SUBREDDIT__FLAIRED_USERS_SEARCH_PENDING",
				l = "SUBREDDIT__FLAIRED_USERS_SEARCH_LOADED",
				c = "SUBREDDIT__FLAIRED_USERS_SEARCH_FAILED",
				a = "SUBREDDIT__FLAIRED_USERS_OWNFLAIR_CHANGED",
				d = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_ADDED",
				u = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_CHANGED",
				_ = "SUBREDDIT__FLAIRED_USERS_DELETE_PENDING",
				f = "SUBREDDIT__FLAIRED_USERS_DELETE_COMPLETED",
				p = "SUBREDDIT__FLAIRED_USERS_DELETE_FAILED"
		},
		"./src/reddit/actions/postFlairStyleTemplates/constants.ts": function(t, e, i) {
			"use strict";
			i.d(e, "c", (function() {
				return n
			})), i.d(e, "b", (function() {
				return r
			})), i.d(e, "a", (function() {
				return o
			}));
			const n = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_PENDING",
				r = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_LOADED",
				o = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_FAILED"
		},
		"./src/reddit/actions/shortcuts/utils.ts": function(t, e, i) {
			"use strict";
			i.d(e, "c", (function() {
				return s
			})), i.d(e, "a", (function() {
				return l
			})), i.d(e, "b", (function() {
				return c
			})), i.d(e, "d", (function() {
				return a
			}));
			var n = i("./src/reddit/constants/shortcuts.ts"),
				r = i("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				o = i("./src/reddit/helpers/routeKey/index.ts");
			const s = t => {
					const e = t.platform.currentPage;
					if (!e || !e.routeMatch) return;
					const i = e.routeMatch,
						n = Object(r.a)(t);
					return Object(o.b)(i, t, n)
				},
				l = t => {
					const e = document.getElementById(t);
					e && e.focus()
				},
				c = t => {
					const e = document.getElementById(t),
						i = window.scrollX,
						n = window.scrollY;
					e && (e.focus(), window.scrollTo(i, n))
				},
				a = () => {
					c(n.b)
				}
		},
		"./src/reddit/actions/structuredStyles/constants.ts": function(t, e, i) {
			"use strict";
			i.d(e, "l", (function() {
				return n
			})), i.d(e, "k", (function() {
				return r
			})), i.d(e, "j", (function() {
				return o
			})), i.d(e, "i", (function() {
				return s
			})), i.d(e, "h", (function() {
				return l
			})), i.d(e, "g", (function() {
				return c
			})), i.d(e, "b", (function() {
				return a
			})), i.d(e, "c", (function() {
				return d
			})), i.d(e, "e", (function() {
				return u
			})), i.d(e, "d", (function() {
				return _
			})), i.d(e, "f", (function() {
				return f
			})), i.d(e, "a", (function() {
				return p
			})), i.d(e, "n", (function() {
				return m
			})), i.d(e, "m", (function() {
				return b
			}));
			const n = "STRUCTURED_STYLES__STYLES_RESET_PENDING",
				r = "STRUCTURED_STYLES__STYLES_RESET_LOADED",
				o = "STRUCTURED_STYLES__STYLES_RESET_FAILED",
				s = "SUBREDDIT__STYLES_PENDING",
				l = "SUBREDDIT__STYLES_LOADED",
				c = "SUBREDDIT__STYLES_FAILED",
				a = "STRUCTURED_STYLES__DRAFT_REPLACED",
				d = "STRUCTURED_STYLES__DRAFT_UPDATED",
				u = "STRUCTURED_STYLES__EDITING_STOPPED",
				_ = "STRUCTURED_STYLES__EDITING_STARTED",
				f = "STRUCTURED_STYLES__IMAGE_UPLOAD_ADDED",
				p = "STRUCTURED_STYLES__DIRTIED_BLADE_EDITOR",
				m = "STRUCTURED_STYLES__UNDIRTIED_BLADE_EDITOR",
				b = "STRUCTURED_STYLES__STYLES_UPDATED_LOADED"
		},
		"./src/reddit/actions/structuredStyles/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "l", (function() {
				return P
			})), i.d(e, "k", (function() {
				return G
			})), i.d(e, "j", (function() {
				return z
			})), i.d(e, "e", (function() {
				return X
			})), i.d(e, "d", (function() {
				return V
			})), i.d(e, "g", (function() {
				return $
			})), i.d(e, "c", (function() {
				return Z
			})), i.d(e, "f", (function() {
				return et
			})), i.d(e, "b", (function() {
				return it
			})), i.d(e, "m", (function() {
				return nt
			})), i.d(e, "a", (function() {
				return rt
			})), i.d(e, "h", (function() {
				return ot
			})), i.d(e, "i", (function() {
				return st
			}));
			i("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = i("./node_modules/lodash/omit.js"),
				r = i.n(n),
				o = i("./node_modules/lodash/pick.js"),
				s = i.n(o),
				l = i("./node_modules/react-router-redux/es/index.js"),
				c = i("./src/lib/filterQueryParams/index.ts"),
				a = i("./src/lib/formatApiError/index.ts"),
				d = i("./src/lib/makeActionCreator/index.ts"),
				u = i("./src/reddit/actions/apiRequestState.ts"),
				_ = i("./src/reddit/actions/imageUploads.ts"),
				f = i("./src/reddit/actions/modal.ts"),
				p = i("./src/reddit/endpoints/moderator/structuredStyles.ts"),
				m = i("./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts"),
				b = i("./src/reddit/selectors/postFlair.ts"),
				S = i("./src/reddit/selectors/subreddit.ts"),
				E = i("./src/reddit/actions/postFlairStyleTemplates/constants.ts");
			const g = Object(d.a)(E.c),
				h = Object(d.a)(E.b),
				y = Object(d.a)(E.a);
			var D = i("./src/reddit/actions/toaster.ts"),
				I = i("./src/reddit/actions/widgets/index.ts"),
				O = i("./src/reddit/constants/modals.ts"),
				T = i("./src/reddit/helpers/getGenericUploadError.ts"),
				w = i("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				k = i("./src/reddit/helpers/media/index.ts"),
				j = i("./src/reddit/models/Image/index.tsx"),
				v = i("./src/reddit/models/StructuredStyles/index.ts"),
				x = i("./src/reddit/models/Toast/index.ts"),
				R = i("./src/reddit/selectors/activeModalId.ts"),
				L = i("./src/reddit/selectors/platform.ts"),
				U = i("./src/reddit/selectors/structuredStyles.ts"),
				C = i("./src/reddit/selectors/user.ts"),
				N = i("./src/reddit/helpers/trackers/blade.ts"),
				B = i("./src/telemetry/index.ts"),
				A = i("./src/reddit/actions/structuredStyles/constants.ts");
			const P = Object(d.a)(A.m),
				F = {
					bannerBackgroundImage: ["bannerBackgroundImagePosition"],
					bannerPositionedImage: ["bannerPositionedImagePosition", "secondaryBannerPositionedImage"]
				},
				M = t => {
					const e = {
						...t
					};
					return Object.keys(t).forEach(i => {
						F[i] && !t[i] && F[i].forEach(t => e[t] = null)
					}), e
				},
				G = (t, e, i, n) => async (r, o, s) => {
					const {
						apiContext: l
					} = s, c = o(), d = M(e), f = c.structuredStyles.models[t];
					let m;
					for (const t in d)
						if (d[t] !== f[t]) {
							m = !0;
							break
						} if (!m) return;
					r(Object(u.h)(n));
					const b = Object(N.i)(i)(c);
					let E = null,
						g = null;
					try {
						(E = await Object(_.f)(o(), j.a.StructuredStyles)) && (g = Object(_.m)(E)(r, o, s))
					} catch (O) {
						const t = Object(T.a)("webSocket");
						return void r(Object(u.f)(n, t))
					}
					const h = Object(S.X)(c, {
							subredditId: t
						}).name,
						y = await p.e(l(), h, d),
						I = {};
					if (y.ok) {
						if (g) try {
							await g
						} catch (O) {}
						const i = Object(U.f)(o(), {
							apiRequestId: n
						});
						for (const t in i)
							if (t in e) {
								const e = Object(U.g)(o(), {
									name: t
								});
								e && Object(j.j)(e) && (I[t] = i[t])
							} Object.keys(I).length && r(H(I)), r(Object(u.e)(n)), r(P({
							subredditId: t,
							styles: {
								...d,
								...I
							}
						}))
					} else E && E.websocket.close(), r(Object(u.f)(n, y.error)), y.body && r(D.f({
						kind: x.b.Error,
						text: Object(a.a)(y.error, y.status)
					}));
					Object(B.a)({
						...b,
						actionInfo: {
							...b.actionInfo,
							success: y.ok
						}
					})
				}, q = Object(d.a)(A.l), W = Object(d.a)(A.k), K = Object(d.a)(A.j), z = t => async (e, i, n) => {
					let {
						apiContext: r
					} = n;
					e(q({
						subredditId: t
					}));
					const o = Object(S.X)(i(), {
							subredditId: t
						}).name,
						s = await p.f(r(), o);
					if (s.ok) {
						const n = i().structuredStyles.models[t],
							r = n ? n.mobileKeyColor : null;
						e(W({
							subredditId: t,
							styles: {
								mobileKeyColor: r
							}
						}))
					} else e(K({
						subredditId: t,
						...s.error
					}))
				}, Y = Object(d.a)(A.d), X = t => async (e, i, n) => {
					const r = i(),
						o = r.structuredStyles.models[t] || {},
						s = Object(C.fb)(r);
					e(Y({
						isNightmodeOn: s,
						styles: o,
						subredditId: t
					})), dt(t, !1)(e, i, n), (t => async (e, i, n) => {
						let {
							gqlContext: r
						} = n;
						const o = i(),
							s = Object(S.X)(o, {
								subredditId: t
							});
						if (!s) return;
						const l = Object(b.d)(o, {
								subredditId: t
							}),
							c = l && l.templateIds;
						if (!c || !c.length) return;
						e(g({
							subredditId: t
						}));
						const a = await Object(p.a)(r(), s.name, c);
						if (a.ok) {
							const i = {};
							if (a.body) {
								const {
									data: t
								} = a.body;
								if (t && t.subreddit)
									for (const e of t.subreddit.postFlairStyleTemplates) i[e.id] = Object(m.a)(e)
							}
							e(h({
								subredditId: t,
								templates: i
							}))
						} else e(y({
							subredditId: t,
							error: a.error
						}))
					})(t)(e, i, n), Object(I.g)(t, !1)(e, i, n)
				}, H = Object(d.a)(A.c), V = t => async (e, i, n) => {
					const r = M(t),
						o = i();
					for (const t in r)
						if (Object(v.l)(t))
							if (r[t]) {
								if ("string" != typeof r[t]) {
									const o = r[t],
										s = await Object(j.e)(o);
									$(t, s)(e, i, n), r[t] = ""
								}
							} else {
								const i = Object(U.g)(o, {
									name: t
								});
								i && e(Object(_.h)(i))
							} e(H(r))
				}, Q = Object(d.a)(A.f), $ = (t, e, i) => async (n, r, o) => {
					const s = r(),
						l = i || s.structuredStyles.isEditing,
						c = Object(S.X)(s, {
							subredditId: l
						}).name;
					n(Q({
						imageKey: t,
						uploadId: e.id
					})), n(Object(_.k)(e));
					const a = await p.d(o.apiContext(), c, e.file.name, t, await Object(k.h)(e.file));
					try {
						const i = await Object(_.g)(r(), a, e, j.a.StructuredStyles);
						if (i) {
							const e = i.url;
							n(Object(_.j)(i)), n(H({
								[t]: e
							}))
						}
					} catch (d) {
						if (d instanceof Error) throw d;
						n(Object(_.i)(d))
					}
				}, J = Object(d.a)(A.b), Z = (t, e, i) => async (n, o, l) => {
					const c = o(),
						a = c.structuredStyles.models[t] || {},
						d = c.structuredStyles.draft,
						u = Object(N.h)(e)(c);
					if (i) {
						const e = s()(a, i),
							o = {
								...r()(d, i),
								...e
							};
						n(J({
							subredditId: t,
							styles: o
						}))
					} else {
						n(J({
							subredditId: t,
							styles: a
						}))
					}
					Object(B.a)(u)
				}, tt = Object(d.a)(A.e), et = () => async (t, e, i) => {
					const n = e(),
						r = Object(C.gb)(n),
						o = !!Object(L.a)(n);
					if (t(tt({
							nightmodeTempUpdated: r
						})), o) return;
					const {
						url: s
					} = n.platform.currentPage;
					s && t(Object(l.c)(Object(c.a)(s, ["styling", "route"])))
				}, it = Object(d.a)(A.a), nt = Object(d.a)(A.n), rt = () => async t => t(et()), ot = t => async (e, i) => {
					const n = i(),
						r = Object(U.i)(n);
					!Object(R.b)(O.a.BLADE_UNSAVED_CHANGES)(n) && r && (Object(U.a)(n, {
						subredditId: t
					}) ? e(Object(f.i)(O.a.BLADE_UNSAVED_CHANGES)) : e(rt()))
				}, st = t => async (e, i) => {
					const n = i();
					Object(U.i)(n) || e(Object(C.fb)(n) ? Object(f.i)(O.a.BLADE_NIGHTMODE) : X(t))
				}, lt = Object(d.a)(A.i), ct = Object(d.a)(A.h), at = Object(d.a)(A.g), dt = (t, e) => async (i, n, r) => {
					let {
						gqlContext: o,
						apiContext: s
					} = r;
					i(lt({
						subredditId: t
					}));
					const l = Object(S.X)(n(), {
						subredditId: t
					});
					if (!l) return;
					if (!e) {
						const n = await p.c(s(), l.name, e);
						if (n.ok) {
							const e = n.body,
								r = e.data ? e.data.style : {};
							i(ct({
								subredditId: t,
								styles: r
							}))
						} else i(at({
							subredditId: t,
							...n.error
						}));
						return
					}
					const c = await p.b(o(), l.name);
					if (c.ok) {
						let e = {};
						if (c.body) {
							const {
								data: t
							} = c.body;
							t && t.subreddit && t.subreddit.styles && (e = Object(w.a)(t.subreddit.styles))
						}
						i(ct({
							subredditId: t,
							styles: e
						}))
					} else i(at({
						subredditId: t,
						...c.error
					}))
				}
		},
		"./src/reddit/actions/subreddit/constants.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			})), i.d(e, "b", (function() {
				return r
			})), i.d(e, "c", (function() {
				return o
			})), i.d(e, "o", (function() {
				return s
			})), i.d(e, "n", (function() {
				return l
			})), i.d(e, "w", (function() {
				return c
			})), i.d(e, "v", (function() {
				return a
			})), i.d(e, "r", (function() {
				return d
			})), i.d(e, "q", (function() {
				return u
			})), i.d(e, "p", (function() {
				return _
			})), i.d(e, "u", (function() {
				return f
			})), i.d(e, "t", (function() {
				return p
			})), i.d(e, "s", (function() {
				return m
			})), i.d(e, "m", (function() {
				return b
			})), i.d(e, "l", (function() {
				return S
			})), i.d(e, "k", (function() {
				return E
			})), i.d(e, "B", (function() {
				return g
			})), i.d(e, "A", (function() {
				return h
			})), i.d(e, "C", (function() {
				return y
			})), i.d(e, "D", (function() {
				return D
			})), i.d(e, "E", (function() {
				return I
			})), i.d(e, "e", (function() {
				return O
			})), i.d(e, "d", (function() {
				return T
			})), i.d(e, "y", (function() {
				return w
			})), i.d(e, "z", (function() {
				return k
			})), i.d(e, "x", (function() {
				return j
			})), i.d(e, "j", (function() {
				return v
			})), i.d(e, "F", (function() {
				return x
			})), i.d(e, "G", (function() {
				return R
			})), i.d(e, "i", (function() {
				return L
			})), i.d(e, "h", (function() {
				return U
			})), i.d(e, "g", (function() {
				return C
			})), i.d(e, "f", (function() {
				return N
			}));
			const n = "SUBREDDIT__ADD_TOP_SUBREDDIT_MODELS",
				r = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS",
				o = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS_PAGE_INFO",
				s = "SUBREDDIT__POSTS_LOADED",
				l = "SUBREDDIT__POSTS_SET_FAILED",
				c = "SUBREDDIT__SUBREDDITS_POSTS_LOADED",
				a = "SUBREDDIT__SUBREDDITS_POSTS_SET_FAILED",
				d = "SUBREDDIT__RANKINGS_PENDING",
				u = "SUBREDDIT__RANKINGS_LOADED",
				_ = "SUBREDDIT__RANKINGS_FAILED",
				f = "SUBREDDIT__SIMILAR_SUBREDDITS_PENDING",
				p = "SUBREDDIT__SIMILAR_SUBREDDITS_LOADED",
				m = "SUBREDDIT__SIMILAR_SUBREDDITS_FAILED",
				b = "SUBREDDIT__ONBOARDING_SUBREDDITS_PENDING",
				S = "SUBREDDIT__ONBOARDING_SUBREDDITS_LOADED",
				E = "SUBREDDIT__ONBOARDING_SUBREDDITS_FAILED",
				g = "SUBREDDIT__EDIT_REQUESTED",
				h = "SUBREDDIT__EDIT_FAILED",
				y = "SUBREDDIT__EDIT_SUCCESS",
				D = "SUBREDDIT_QUESTIONS_LOADED",
				I = "SUBREDDIT_SURVEY_ANSWERED",
				O = "SUBREDDIT_SURVEY_DISMISSED",
				T = "SUBREDDIT_SURVEY_DISMISS",
				w = "SUBREDDIT_ABOUT_INFO_UPDATE__PENDING",
				k = "SUBREDDIT_ABOUT_INFO_UPDATE__SUCCESS",
				j = "SUBREDDIT_ABOUT_INFO_UPDATE__FAILED",
				v = "MUTE_SUBREDDIT__SUCCESS",
				x = "UNMUTE_SUBREDDIT_SUCCESS",
				R = "UPDATE_MUTE_AND_NOTIFICATION_LEVEL_SUCCESS",
				L = "MUTED_SUBREDDIT_LOADED__SUCCESS",
				U = "MUTED_SUBREDDIT_LOADED__FAILED",
				C = "MUTED_SUBREDDIT_LIST__UNMUTE",
				N = "MUTED_SUBREDDIT_LIST__MUTE"
		},
		"./src/reddit/actions/widgets/constants.ts": function(t, e, i) {
			"use strict";
			i.d(e, "g", (function() {
				return n
			})), i.d(e, "i", (function() {
				return r
			})), i.d(e, "h", (function() {
				return o
			})), i.d(e, "f", (function() {
				return s
			})), i.d(e, "d", (function() {
				return l
			})), i.d(e, "e", (function() {
				return c
			})), i.d(e, "c", (function() {
				return a
			})), i.d(e, "b", (function() {
				return d
			})), i.d(e, "a", (function() {
				return u
			}));
			const n = "WIDGETS__WIDGET_CREATED",
				r = "WIDGETS__WIDGET_UPDATED",
				o = "WIDGET_DELETED",
				s = "WIDGETS_SORTED",
				l = "WIDGETS__STARTED_EDITING_WIDGET",
				c = "WIDGETS__LOADED",
				a = "SUBREDDIT__WIDGETS_PENDING",
				d = "SUBREDDIT__WIDGETS_LOADED",
				u = "SUBREDDIT__WIDGETS_FAILED"
		},
		"./src/reddit/actions/widgets/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "c", (function() {
				return I
			})), i.d(e, "e", (function() {
				return T
			})), i.d(e, "d", (function() {
				return k
			})), i.d(e, "h", (function() {
				return v
			})), i.d(e, "a", (function() {
				return x
			})), i.d(e, "b", (function() {
				return R
			})), i.d(e, "f", (function() {
				return U
			})), i.d(e, "g", (function() {
				return A
			}));
			var n = i("./node_modules/fbt/lib/FbtPublic.js"),
				r = i("./src/lib/makeActionCreator/index.ts"),
				o = i("./src/reddit/actions/apiRequestState.ts"),
				s = i("./src/reddit/actions/imageUploads.ts"),
				l = i("./src/reddit/actions/toaster.ts"),
				c = i("./src/lib/constants/index.ts"),
				a = i("./src/lib/makeApiRequest/index.ts"),
				d = i("./src/lib/omitHeaders/index.ts"),
				u = i("./src/reddit/constants/headers.ts");
			const _ = async (t, e, i) => Object(a.a)(Object(d.a)(t, [u.a]), {
				endpoint: `${t.apiUrl}/r/${e}/api/widgets`,
				method: c.ob.GET,
				type: "json",
				data: {
					progressive_images: i
				}
			});
			var f = i("./src/reddit/helpers/getGenericUploadError.ts"),
				p = i("./src/reddit/helpers/media/index.ts"),
				m = i("./src/lib/assertNever.ts"),
				b = i("./src/reddit/models/Widgets/index.ts"),
				S = i("./src/reddit/selectors/subreddit.ts"),
				E = i("./src/reddit/helpers/widgets/index.tsx"),
				g = i("./src/reddit/models/Image/index.tsx"),
				h = i("./src/reddit/models/Toast/index.ts"),
				y = i("./src/reddit/actions/widgets/constants.ts");
			const D = Object(r.a)(y.g),
				I = (t, e, i) => async (r, _, p) => {
					const {
						apiContext: m
					} = p;
					r(Object(o.h)(i));
					const b = _(),
						y = Object(S.X)(b, {
							subredditId: t
						}).name,
						I = Object(E.e)(e);
					let O = null,
						T = null;
					try {
						(O = await Object(s.f)(b, g.a.Widgets)) && (T = Object(s.m)(O)(r, _, p))
					} catch (k) {
						const t = Object(f.a)("webSocket");
						return void r(Object(o.f)(i, t))
					}
					const w = await (async (t, e, i) => Object(a.a)(Object(d.a)(t, [u.a]), {
						endpoint: `${t.apiUrl}/r/${e}/api/widget`,
						method: c.ob.POST,
						type: "json",
						data: i
					}))(m(), y, I);
					if (w.ok) {
						let s = w.body;
						const c = s.id;
						if ("calendar" === e.kind && r(Object(l.f)({
								kind: h.b.SuccessMod,
								text: n.fbt._("New calendar added! It may take a few minutes to see your events appear", null, {
									hk: "4iETrT"
								})
							})), O) {
							try {
								await T
							} catch (k) {}
							s = await r(P(t, c)) || s
						}
						r(D({
							subredditId: t,
							widget: s,
							widgetId: c
						})), r(Object(o.e)(i))
					} else O && O.websocket.close(), r(Object(o.f)(i, w.error))
				}, O = Object(r.a)(y.i), T = (t, e, i) => async (r, _, p) => {
					const {
						apiContext: y
					} = p;
					r(Object(o.h)(i));
					const D = e.id,
						I = _(),
						T = Object(S.X)(I, {
							subredditId: t
						}).name,
						w = Object(E.e)(e);
					let k = null,
						j = null;
					try {
						(k = await Object(s.f)(I, g.a.Widgets)) && (j = Object(s.m)(k)(r, _, p))
					} catch (x) {
						const t = Object(f.a)("webSocket");
						return void r(Object(o.f)(i, t))
					}
					const v = await (async (t, e, i) => Object(a.a)(Object(d.a)(t, [u.a]), {
						endpoint: `${t.apiUrl}/r/${e}/api/widget/${i.id}`,
						method: c.ob.PUT,
						type: "json",
						data: i
					}))(y(), T, w);
					if (v.ok) {
						let s = function(t, e, i) {
							switch (t.kind) {
								case b.i.Calendar:
								case b.i.IdCard:
								case b.i.SubredditRules:
									return {
										...t, ...e
									};
								case b.i.CommunityList: {
									const n = {};
									for (const e of t.data) n[e.name] = e;
									return {
										...e,
										data: e.data.map(t => {
											if (!("subscribers" in n[t])) {
												const e = {
														subredditName: t
													},
													n = Object(S.C)(i, e),
													r = Object(S.z)(i, e);
												return {
													name: n.name,
													subscribers: n ? n.subscribers : void 0,
													iconUrl: n ? n.communityIcon : void 0,
													isNSFW: n ? n.isNSFW : void 0,
													isSubscribed: r ? r.userIsSubscriber : void 0
												}
											}
											return n[t]
										})
									}
								}
								case b.i.Button:
								case b.i.Custom:
								case b.i.Image:
								case b.j.Menu:
								case b.i.Moderators:
								case b.i.Textarea:
								case b.i.PostFlair:
									return e;
								default:
									return Object(m.a)(t)
							}
						}(e, v.body, I);
						j && (s = await r(P(t, D)) || s), r(O({
							subredditId: t,
							widgetId: D,
							widget: s
						})), "calendar" === e.kind && r(Object(l.f)({
							kind: h.b.SuccessMod,
							text: n.fbt._("Calendar is updated! It may take a few minutes to see your events change", null, {
								hk: "10XWV"
							})
						})), r(Object(o.e)(i))
					} else k && k.websocket.close(), r(Object(o.f)(i, v.error))
				}, w = Object(r.a)(y.h), k = (t, e, i) => async (n, r, s) => {
					let {
						apiContext: l
					} = s;
					n(Object(o.h)(i));
					const _ = e.id,
						f = Object(S.X)(r(), {
							subredditId: t
						}).name,
						p = await (async (t, e, i) => Object(a.a)(Object(d.a)(t, [u.a]), {
							endpoint: `${t.apiUrl}/r/${e}/api/widget/${i.id}`,
							method: c.ob.DELETE,
							type: "json"
						}))(l(), f, e);
					p.ok ? (n(Object(o.e)(i)), n(w({
						subredditId: t,
						widgetId: _
					}))) : n(Object(o.f)(i, p.error))
				}, j = Object(r.a)(y.f), v = (t, e) => async (i, n, r) => {
					let {
						apiContext: o
					} = r;
					const s = Object(S.X)(n(), {
						subredditId: t
					}).name;
					(await (async (t, e, i) => Object(a.a)(Object(d.a)(t, [u.a]), {
						endpoint: `${t.apiUrl}/r/${e}/api/widget_order/sidebar`,
						method: c.ob.PATCH,
						type: "json",
						data: i
					}))(o(), s, e)).ok && i(j({
						subredditId: t,
						widgetIds: e
					}))
				}, x = t => {
					let {
						imageData: e
					} = t;
					return async (t, i, n) => {
						const r = i(),
							o = r.structuredStyles.isEditing,
							l = Object(S.X)(r, {
								subredditId: o
							}).name;
						t(Object(s.k)(e));
						const _ = await (async (t, e, i, n) => Object(a.a)(Object(d.a)(t, [u.a]), {
							endpoint: `${t.apiUrl}/r/${e}/api/widget_image_upload_s3`,
							method: c.ob.POST,
							data: {
								filepath: i,
								mimetype: n
							}
						}))(n.apiContext(), l, e.file.name, await Object(p.h)(e.file));
						let f = !1;
						try {
							const n = await Object(s.g)(i(), _, e, g.a.Widgets);
							n && (t(Object(s.j)(n)), f = !0)
						} catch (m) {
							if (m instanceof Error) throw m;
							t(Object(s.i)(m))
						}
						return f
					}
				}, R = Object(r.a)(y.d), L = Object(r.a)(y.e), U = (t, e) => async (i, n, r) => {
					let {
						apiContext: s
					} = r;
					i(Object(o.h)(e));
					const l = Object(S.X)(n(), {
							subredditId: t
						}).name,
						c = await _(s(), l);
					if (c.ok) {
						const n = c.body;
						i(L({
							subredditId: t,
							widgets: n
						})), i(Object(o.e)(e))
					} else i(Object(o.f)(e, c.error))
				}, C = Object(r.a)(y.c), N = Object(r.a)(y.b), B = Object(r.a)(y.a), A = (t, e) => async (i, n, r) => {
					let {
						apiContext: o
					} = r;
					i(C({
						subredditId: t
					}));
					const s = Object(S.X)(n(), {
							subredditId: t
						}).name,
						l = await _(o(), s, e);
					if (l.ok) {
						const e = l.body;
						i(N({
							subredditId: t,
							widgets: e
						}))
					} else i(B({
						subredditId: t,
						error: l.error
					}))
				}, P = (t, e) => async (i, n, r) => {
					let {
						apiContext: o
					} = r;
					const s = Object(S.X)(n(), {
							subredditId: t
						}).name,
						l = await _(o(), s, !0);
					if (l.ok) return l.body.items[e]
				}
		},
		"./src/reddit/components/TrackingHelper/index.tsx": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return d
			})), i.d(e, "b", (function() {
				return u
			})), i.d(e, "c", (function() {
				return _
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./node_modules/react-redux/es/index.js"),
				s = i("./src/reddit/selectors/telemetry.ts"),
				l = i("./src/telemetry/index.ts");

			function c() {
				return (c = Object.assign || function(t) {
					for (var e = 1; e < arguments.length; e++) {
						var i = arguments[e];
						for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
					}
					return t
				}).apply(this, arguments)
			}
			const a = r.a.createContext(() => {});

			function d(t) {
				let {
					children: e
				} = t;
				const i = Object(o.f)(),
					c = Object(n.useCallback)(t => {
						{
							const e = i.getState(),
								n = t(e);
							Object(l.a)({
								...s.o(e),
								...n
							})
						}
					}, [i]);
				return r.a.createElement(a.Provider, {
					value: c
				}, e ? r.a.Children.only(e) : null)
			}

			function u() {
				return Object(n.useContext)(a)
			}

			function _(t) {
				function e(e) {
					const i = u();
					return r.a.createElement(t, c({}, e, {
						sendEvent: i
					}))
				}
				const i = t.name || t.displayName;
				return e.displayName = `Tracked(${i})`, e.WrappedComponent = t, e
			}
		},
		"./src/reddit/constants/elementIds.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			})), i.d(e, "b", (function() {
				return r
			})), i.d(e, "d", (function() {
				return o
			})), i.d(e, "e", (function() {
				return s
			})), i.d(e, "c", (function() {
				return l
			}));
			const n = "AppRouter-main-content",
				r = "bladeContainer",
				o = "header",
				s = "overlayScrollContainer",
				l = "collectionPostListScrollContainer"
		},
		"./src/reddit/constants/shortcuts.ts": function(t, e, i) {
			"use strict";
			var n, r;
			i.d(e, "d", (function() {
					return n
				})), i.d(e, "c", (function() {
					return r
				})), i.d(e, "b", (function() {
					return o
				})), i.d(e, "a", (function() {
					return s
				})),
				function(t) {
					t.CommentPage = "CommentPage", t.Global = "Global", t.Lightbox = "Lightbox", t.Listing = "Listing", t.Modqueue = "Modqueue", t.CommunityChat = "CommunityChat"
				}(n || (n = {})),
				function(t) {
					t.Close = "CLOSE", t.CollapseOrLoad = "COLLAPSE_OR_LOAD", t.Downvote = "DOWNVOTE", t.Expando = "EXPANDO", t.Hide = "HIDE", t.Konami = "KONAMI", t.NewPost = "NEW_POST", t.NextComment = "NEXT_COMMENT", t.NextPost = "NEXT_POST", t.OpenIndex = "OPEN_INDEX", t.OpenLightbox = "OPEN_LIGHTBOX", t.OpenLink = "OPEN_LINK", t.PrevComment = "PREV_COMMENT", t.PrevPost = "PREV_POST", t.Reply = "REPLY", t.Save = "SAVE", t.Upvote = "UPVOTE"
				}(r || (r = {}));
			const o = "SHORTCUT_FOCUSABLE_DIV",
				s = [9, 13, 32]
		},
		"./src/reddit/constants/zIndex.ts": function(t, e, i) {
			"use strict";
			i.d(e, "f", (function() {
				return n
			})), i.d(e, "c", (function() {
				return r
			})), i.d(e, "d", (function() {
				return o
			})), i.d(e, "a", (function() {
				return s
			})), i.d(e, "e", (function() {
				return l
			})), i.d(e, "g", (function() {
				return c
			})), i.d(e, "b", (function() {
				return a
			}));
			const n = 4,
				r = 60,
				o = 70,
				s = 90,
				l = 99,
				c = 100,
				a = 100
		},
		"./src/reddit/controls/Button/index.m.less": function(t, e, i) {
			t.exports = {
				Button: "_2iuoyPiKHN3kfOoeIQalDT",
				button: "_2iuoyPiKHN3kfOoeIQalDT",
				isFullWidth: "_34mIRHpFtnJ0Sk97S2Z3D9",
				xxsmallButtonStyles: "_1h6qKGhVsgNfytYFlo8m3f",
				Icon: "_1mvTX6krm3Q2d1CSyUm28s",
				icon: "_1mvTX6krm3Q2d1CSyUm28s",
				isLeft: "_1HHR_ND8U6x6YrIqKFeXZy",
				isRight: "_3tKmDp5VAtgWvabEmFkJ7T",
				xsmallButtonStyles: "_3uJP0daPEH2plzVEYyTdaH",
				xsmallBigPaddingButtonStyles: "UEPNkU0rd1-nvbkOcBatc",
				smallButtonStyles: "HNozj_dKjQZ59ZsfEegz8",
				mediumButtonStyles: "_3ukcnQySDskQwK_wB2iXYl",
				largeButtonStyles: "_1J4mN6_wNfCtSyMDUNGQqN",
				xlargeButtonStyles: "XpD6n11mOiKNg8ZKtvgVR",
				primary: "_10BQ7pjWbeYP63SAPNS8Ts",
				active: "_39a0Mt5b1i2joAqIaEHOWJ",
				redditStyle: "_2nelDm85zKKmuD94NequP0",
				DangerButtonColors: "_1t63zWyh9UUgsyQc6acROM",
				dangerButtonColors: "_1t63zWyh9UUgsyQc6acROM",
				GoldButtonColors: "_10UWrWSil1Xu6pdSaa_3-K",
				goldButtonColors: "_10UWrWSil1Xu6pdSaa_3-K",
				PremiumButtonColors: "q_unSaY23rpdd3lDvGZ-",
				premiumButtonColors: "q_unSaY23rpdd3lDvGZ-",
				secondary: "_2tU8R9NTqhvBrhoNAXWWcP",
				rplStyle: "_2Z-LWN_PrkTncEM_mPuEW5",
				tertiary: "_4Glnzr5LA7bNBGMWGW4pU",
				plain: "_3zbhtNO0bdck0oYbYRhjMC",
				isIconOnly: "_1tPpYVD73ugqp4k-VMFRki",
				isSquare: "_3ojSE1JW7jxNzUzZK8kt7m",
				ExtraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				extraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				InlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				inlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				ChatButton: "_13twe55MPRo1LqypxB-LJx",
				chatButton: "_13twe55MPRo1LqypxB-LJx",
				PlainLinkButton: "_2UhHcZFBOYxMULbf2p-skl",
				plainLinkButton: "_2UhHcZFBOYxMULbf2p-skl"
			}
		},
		"./src/reddit/controls/Button/index.tsx": function(t, e, i) {
			"use strict";
			i.d(e, "d", (function() {
				return u
			})), i.d(e, "c", (function() {
				return _
			})), i.d(e, "h", (function() {
				return f
			})), i.d(e, "b", (function() {
				return p
			})), i.d(e, "a", (function() {
				return m
			})), i.d(e, "m", (function() {
				return g
			})), i.d(e, "n", (function() {
				return h
			})), i.d(e, "l", (function() {
				return y
			})), i.d(e, "p", (function() {
				return D
			})), i.d(e, "q", (function() {
				return I
			})), i.d(e, "o", (function() {
				return O
			})), i.d(e, "s", (function() {
				return T
			})), i.d(e, "r", (function() {
				return w
			})), i.d(e, "f", (function() {
				return k
			})), i.d(e, "g", (function() {
				return j
			})), i.d(e, "k", (function() {
				return v
			})), i.d(e, "e", (function() {
				return x
			})), i.d(e, "i", (function() {
				return R
			})), i.d(e, "j", (function() {
				return L
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./src/lib/classNames/index.ts"),
				s = i("./src/reddit/controls/InternalLink/index.tsx"),
				l = i("./src/reddit/controls/Button/index.m.less"),
				c = i.n(l);

			function a() {
				return (a = Object.assign || function(t) {
					for (var e = 1; e < arguments.length; e++) {
						var i = arguments[e];
						for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
					}
					return t
				}).apply(this, arguments)
			}
			const d = {
				role: "button",
				tabIndex: 0
			};
			var u, _, f, p;
			! function(t) {
				t.XXS = "xxsmallButtonStyles", t.XS = "xsmallButtonStyles", t.XSP = "xsmallBigPaddingButtonStyles", t.S = "smallButtonStyles", t.M = "mediumButtonStyles", t.L = "largeButtonStyles", t.XL = "xlargeButtonStyles"
			}(u || (u = {})),
			function(t) {
				t.Primary = "primary", t.Secondary = "secondary", t.Tertiary = "tertiary", t.Plain = "plain", t.PlainLink = "plainLink"
			}(_ || (_ = {})),
			function(t) {
				t.L = "left", t.R = "right", t.C = "center"
			}(f || (f = {})),
			function(t) {
				t.Button = "button", t.ExternalLink = "external-link", t.InternalLink = "internal-link"
			}(p || (p = {}));
			const m = t => {
					const {
						"data-redditstyle": e,
						Icon: i,
						iconClassName: n,
						iconPosition: s = f.C,
						isFullWidth: l = !1,
						isSquare: m = !1,
						children: g,
						className: h,
						kind: y = p.Button,
						priority: D = _.Primary,
						redditStyle: I,
						rplStyle: O,
						size: T = u.S,
						text: w,
						textClassName: k,
						...j
					} = t, v = (t => {
						let {
							baseClassName: e,
							redditStyle: i,
							rplStyle: n,
							dataRedditStyle: r,
							Icon: s,
							isFullWidth: l,
							isSquare: a,
							priority: d,
							size: u,
							text: _
						} = t;
						return Object(o.a)(e, c.a.Button, d && c.a[d], u && c.a[u], {
							[c.a.isFullWidth]: l,
							[c.a.isIconOnly]: !!s && !_,
							[c.a.isSquare]: a,
							[c.a.redditStyle]: !(!i && !r),
							[c.a.rplStyle]: n
						})
					})({
						baseClassName: h,
						children: g,
						dataRedditStyle: e,
						Icon: i,
						isFullWidth: l,
						isSquare: m,
						priority: D,
						redditStyle: I,
						rplStyle: O,
						size: T,
						text: w
					}), x = (t => {
						let {
							children: e,
							text: i,
							Icon: n,
							iconClassName: s,
							iconPosition: l,
							priority: a,
							textClassName: d
						} = t;
						return !n && i ? r.a.createElement("span", {
							className: d
						}, i) : r.a.createElement(r.a.Fragment, null, n && (l === f.C || l === f.L) && r.a.createElement(n, {
							className: Object(o.a)(c.a.Icon, s, {
								[c.a.isLeft]: l === f.L
							}),
							isFilled: a === _.Primary
						}), i && r.a.createElement("span", {
							className: Object(o.a)(c.a.Text, d)
						}, i), e && e, n && l === f.R && r.a.createElement(n, {
							className: Object(o.a)(c.a.Icon, s, c.a.isRight),
							isFilled: a === _.Primary
						}))
					})({
						children: g,
						text: w,
						Icon: i,
						iconClassName: n,
						iconPosition: s,
						priority: D,
						textClassName: k
					});
					return y === p.InternalLink && (t => "to" in t)(j) ? r.a.createElement(b, a({}, d, j, {
						className: v
					}), x) : y === p.ExternalLink && (t => "href" in t)(j) ? r.a.createElement(S, a({}, d, j, {
						className: v
					}), x) : r.a.createElement(E, a({}, d, j, {
						className: v
					}), x)
				},
				b = t => r.a.createElement(s.default, t),
				S = t => r.a.createElement("a", t),
				E = t => r.a.createElement("button", t),
				g = t => r.a.createElement(m, a({
					kind: p.ExternalLink,
					priority: _.Primary
				}, t)),
				h = t => r.a.createElement(m, a({
					kind: p.InternalLink,
					priority: _.Primary
				}, t)),
				y = t => r.a.createElement(m, a({
					kind: p.Button,
					priority: _.Primary
				}, t)),
				D = t => r.a.createElement(m, a({
					kind: p.ExternalLink,
					priority: _.Secondary
				}, t)),
				I = t => r.a.createElement(m, a({
					kind: p.InternalLink,
					priority: _.Secondary
				}, t)),
				O = t => r.a.createElement(m, a({
					kind: p.Button,
					priority: _.Secondary
				}, t)),
				T = t => r.a.createElement(m, a({
					kind: p.InternalLink,
					priority: _.Plain
				}, t)),
				w = t => r.a.createElement(m, a({
					kind: p.Button,
					priority: _.Plain
				}, t)),
				k = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						priority: _.Primary,
						className: Object(o.a)(e, c.a.DangerButtonColors)
					}, i))
				},
				j = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.GoldButtonColors)
					}, i))
				},
				v = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.PremiumButtonColors)
					}, i))
				},
				x = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.ChatButton)
					}, i))
				},
				R = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.InlineTextButton)
					}, i))
				},
				L = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.PlainLinkButton),
						priority: _.PlainLink
					}, i))
				};
			e.t = m
		},
		"./src/reddit/controls/Dropdown/index.m.less": function(t, e, i) {
			t.exports = {
				dropdownTriangle: "_1oxgVV3q47KbjEKqP5CHuM",
				dropdown: "_2uYY-KeuYHKiwl-9aF0UiL"
			}
		},
		"./src/reddit/controls/Dropdown/index.tsx": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return d
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./src/lib/classNames/index.ts"),
				s = i("./src/lib/domUtils/index.ts"),
				l = i("./src/reddit/constants/zIndex.ts"),
				c = i("./src/reddit/controls/Dropdown/index.m.less"),
				a = i.n(c);
			class d extends r.a.Component {
				componentDidMount() {
					this.props.onDropdownMounted && this.props.onDropdownMounted(), this.props.noFocus || this.ref && this.ref.focus({
						preventScroll: this.props.isOverlay
					})
				}
				componentWillUnmount() {
					Object(s.a)(this.props.tooltipId)
				}
				render() {
					const t = this.props,
						e = {};
					return (t.isFixed || t.isOverlay) && (t.isFixed && (e.position = "fixed"), t.isOverlay && (e.zIndex = t.isFixed ? l.d + 1 : l.c)), r.a.createElement("div", {
						className: Object(o.a)(a.a.dropdown, t.className),
						id: this.props.id,
						ref: t => this.ref = t,
						role: "menu",
						style: {
							...e,
							...t.style
						},
						tabIndex: -1,
						onScroll: t.onScroll
					}, t.children)
				}
			}
		},
		"./src/reddit/controls/InternalLink/index.m.less": function(t, e, i) {
			t.exports = {
				disabledLink: "_1tQt2CUWT3M7NNSMoh_o_4"
			}
		},
		"./src/reddit/controls/InternalLink/index.tsx": function(t, e, i) {
			"use strict";
			i.r(e), i.d(e, "default", (function() {
				return u
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./node_modules/react-router-dom/esm/react-router-dom.js"),
				s = i("./src/lib/classNames/index.ts"),
				l = i("./src/reddit/helpers/path/index.ts"),
				c = i("./src/reddit/controls/InternalLink/index.m.less"),
				a = i.n(c);

			function d() {
				return (d = Object.assign || function(t) {
					for (var e = 1; e < arguments.length; e++) {
						var i = arguments[e];
						for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
					}
					return t
				}).apply(this, arguments)
			}

			function u(t) {
				let {
					children: e,
					className: i,
					disabled: n,
					replace: c,
					to: u,
					..._
				} = t;
				return n ? r.a.createElement("span", {
					className: Object(s.a)(a.a.disabledLink, i)
				}, e) : ("string" == typeof u && (u = Object(l.b)(u)), r.a.createElement(o.a, d({
					className: i,
					to: u
				}, _), e))
			}
		},
		"./src/reddit/endpoints/subreddit/about.ts": function(t, e, i) {
			"use strict";
			var n = i("./src/lib/makeGqlRequest/index.ts"),
				r = i("./src/redditGQL/operations/SubredditAbout.json");
			e.a = (t, e, i) => Object(n.a)(t, {
				...r,
				variables: {
					subredditName: e,
					includeSubreddit: i
				}
			})
		},
		"./src/reddit/endpoints/subreddit/notificationSettings.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return s
			})), i.d(e, "b", (function() {
				return l
			}));
			var n = i("./src/redditGQL/operations/FetchSubredditsNotificationSettings.json"),
				r = i("./src/redditGQL/operations/UpdateSubredditNotificationSettings.json"),
				o = i("./src/lib/makeGqlRequest/index.ts");
			const s = (t, e) => Object(o.a)(t, {
					...n,
					variables: {
						subredditIds: [e]
					}
				}),
				l = (t, e, i) => Object(o.a)(t, {
					...r,
					variables: {
						input: {
							...i,
							subredditId: e
						}
					}
				})
		},
		"./src/reddit/helpers/getTimeSortForListing/index.ts": function(t, e, i) {
			"use strict";
			var n = i("./src/lib/constants/index.ts"),
				r = i("./src/lib/listingSort/index.ts");
			e.a = (t, e) => {
				if (t) return Object(r.a)(t) ? e || n.pc : void 0
			}
		},
		"./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts": function(t, e, i) {
			"use strict";
			e.a = t => ({
				...t.id && {
					id: t.id
				},
				...t.postBackgroundColor && {
					postBackgroundColor: t.postBackgroundColor
				},
				...t.postBackgroundImage && {
					postBackgroundImage: t.postBackgroundImage
				},
				...t.postPlaceholderImage && {
					postPlaceholderImage: t.postPlaceholderImage
				},
				...t.postTitleColor && {
					postTitleColor: t.postTitleColor
				}
			})
		},
		"./src/reddit/helpers/pageActionLoginRedirect.ts": function(t, e, i) {
			"use strict";
			i("./node_modules/history/esm/history.js"), i("./src/reddit/actions/platform.ts");
			var n = i("./src/config.ts");
			e.a = (t, e) => {
				const i = e.platform.currentPage && e.platform.currentPage.url;
				let r = `${n.a.accountManagerOrigin}/login/`;
				const o = window.location.origin;
				i && (r += `?dest=${encodeURIComponent(`${o}${i}`)}`), window.location.href = r
			}
		},
		"./src/reddit/helpers/toggleBodyScroll/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "b", (function() {
				return o
			})), i.d(e, "a", (function() {
				return s
			})), i.d(e, "e", (function() {
				return l
			})), i.d(e, "d", (function() {
				return c
			})), i.d(e, "c", (function() {
				return a
			}));
			var n = i("./src/reddit/constants/elementIds.ts");
			let r;
			const o = () => {
					const t = document.body.dataset.previousOverflow;
					if (!t) return;
					document.body.removeAttribute("data-previous-overflow");
					const e = document.getElementById(n.d);
					document.body.style.overflow = t, document.body.style.marginRight = "", e && (e.style.marginRight = "")
				},
				s = () => {
					if (document.body.dataset.previousOverflow) return;
					const t = document.body.style.overflow || "auto";
					document.body.dataset.previousOverflow = t, r || (r = c(document.body)), document.body.style.overflow = "hidden", document.body.style.marginRight = `${r}px`;
					const e = document.getElementById(n.d);
					e && (e.style.marginRight = `${r}px`)
				},
				l = t => {
					t ? o() : s()
				},
				c = t => {
					const e = t.getBoundingClientRect();
					return window.innerWidth - (e.left + e.right)
				},
				a = t => {
					if (!t || !document.body) return 0;
					const e = c(document.body),
						i = t.offsetWidth - t.scrollWidth;
					return e || i
				}
		},
		"./src/reddit/helpers/trackers/blade.ts": function(t, e, i) {
			"use strict";
			i.d(e, "i", (function() {
				return s
			})), i.d(e, "h", (function() {
				return l
			})), i.d(e, "f", (function() {
				return c
			})), i.d(e, "g", (function() {
				return a
			})), i.d(e, "c", (function() {
				return d
			})), i.d(e, "d", (function() {
				return u
			})), i.d(e, "j", (function() {
				return f
			})), i.d(e, "b", (function() {
				return p
			})), i.d(e, "a", (function() {
				return m
			})), i.d(e, "e", (function() {
				return S
			})), i.d(e, "k", (function() {
				return E
			}));
			var n = i("./src/reddit/constants/blade.ts"),
				r = i("./src/reddit/selectors/telemetry.ts");
			const o = (t, e) => i => ({
					...r.o(i),
					source: n.c.Appearance,
					action: "click",
					noun: t,
					actionInfo: r.d(i, {
						paneName: e
					}),
					subreddit: r.lb(i)
				}),
				s = t => o("save_style", t),
				l = t => o("cancel_style", t),
				c = t => e => ({
					source: n.c.Structure,
					action: "click",
					noun: t,
					screen: r.cb(e),
					subreddit: r.lb(e)
				}),
				a = t => e => ({
					source: n.c.Appearance,
					action: "click",
					noun: t,
					screen: r.cb(e),
					subreddit: r.lb(e)
				}),
				d = (t, e) => i => ({
					source: "colorpicker",
					action: "click",
					noun: t,
					actionInfo: r.d(i, {
						paneName: n.f[e]
					}),
					screen: r.cb(i),
					subreddit: r.lb(i)
				}),
				u = t => e => ({
					source: n.g[t],
					action: "click",
					noun: "colorpicker",
					actionInfo: r.d(e, {
						paneName: n.f[t]
					}),
					screen: r.cb(e),
					subreddit: r.lb(e)
				}),
				_ = t => ({
					screen: r.cb(t),
					subreddit: r.lb(t)
				}),
				f = () => t => ({
					source: n.c.Appearance,
					action: "view",
					noun: "blade",
					..._(t)
				}),
				p = t => e => ({
					source: n.a[t],
					action: "click",
					noun: n.b[t],
					..._(e)
				}),
				m = () => t => ({
					source: n.c.Appearance,
					action: "click",
					noun: "back",
					..._(t)
				}),
				b = t => e => ({
					source: n.c.PostFlairManagement,
					action: "click",
					noun: t,
					..._(e)
				}),
				S = (t, e) => ({
					...r.o(t),
					...b(e)(t)
				}),
				E = t => e => ({
					source: n.c.MenuLinks,
					action: "click",
					noun: t ? "wiki_link_on" : "wiki_link_off",
					screen: r.cb(e),
					subreddit: r.lb(e),
					userSubreddit: r.ub(e)
				})
		},
		"./src/reddit/helpers/trackers/postComposer.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return h
			})), i.d(e, "e", (function() {
				return y
			})), i.d(e, "L", (function() {
				return D
			})), i.d(e, "J", (function() {
				return I
			})), i.d(e, "D", (function() {
				return O
			})), i.d(e, "z", (function() {
				return T
			})), i.d(e, "A", (function() {
				return w
			})), i.d(e, "N", (function() {
				return k
			})), i.d(e, "C", (function() {
				return j
			})), i.d(e, "m", (function() {
				return v
			})), i.d(e, "F", (function() {
				return x
			})), i.d(e, "E", (function() {
				return R
			})), i.d(e, "t", (function() {
				return L
			})), i.d(e, "s", (function() {
				return U
			})), i.d(e, "M", (function() {
				return C
			})), i.d(e, "p", (function() {
				return N
			})), i.d(e, "o", (function() {
				return B
			})), i.d(e, "q", (function() {
				return A
			})), i.d(e, "f", (function() {
				return F
			})), i.d(e, "r", (function() {
				return q
			})), i.d(e, "B", (function() {
				return K
			})), i.d(e, "j", (function() {
				return z
			})), i.d(e, "g", (function() {
				return Y
			})), i.d(e, "h", (function() {
				return X
			})), i.d(e, "d", (function() {
				return H
			})), i.d(e, "I", (function() {
				return V
			})), i.d(e, "i", (function() {
				return Q
			})), i.d(e, "c", (function() {
				return $
			})), i.d(e, "v", (function() {
				return Z
			})), i.d(e, "u", (function() {
				return tt
			})), i.d(e, "H", (function() {
				return et
			})), i.d(e, "w", (function() {
				return it
			})), i.d(e, "k", (function() {
				return nt
			})), i.d(e, "G", (function() {
				return rt
			})), i.d(e, "y", (function() {
				return ot
			})), i.d(e, "b", (function() {
				return st
			})), i.d(e, "n", (function() {
				return lt
			})), i.d(e, "x", (function() {
				return ct
			})), i.d(e, "l", (function() {
				return at
			})), i.d(e, "K", (function() {
				return dt
			}));
			var n = i("./src/reddit/constants/tracking.ts"),
				r = i("./src/reddit/helpers/correlationIdTracker.ts"),
				o = i("./src/reddit/helpers/media/index.ts"),
				s = i("./src/reddit/models/PostCreationForm/index.ts"),
				l = i("./src/reddit/models/PostDraft/index.ts"),
				c = i("./src/reddit/selectors/experiments/postCreationSubRec.ts"),
				a = i("./src/reddit/selectors/postDraft.ts"),
				d = i("./src/reddit/selectors/postGuidance.ts"),
				u = i("./src/reddit/selectors/subreddit.ts"),
				_ = i("./src/reddit/selectors/telemetry.ts"),
				f = i("./src/reddit/selectors/user.ts"),
				p = i("./src/telemetry/index.ts"),
				m = i("./src/telemetry/models/PostComposer.ts"),
				b = i("./src/telemetry/models/PostDraft.ts");
			const S = {
					imageOnly: "image",
					linkOnly: "link",
					media: "media",
					poll: "poll",
					post: "self",
					prediction: "prediction",
					crosspost: "crosspost",
					talk: "talk"
				},
				E = t => ({
					source: "post_composer",
					action: n.c.CLICK,
					..._.o(t),
					screen: _.cb(t),
					correlationId: Object(r.c)(r.a.PostComposer)
				}),
				g = (t, e) => "self" !== e ? {} : {
					editorMode: t.user.prefs.editorMode === s.i.MARKDOWN ? "markdown" : "rte"
				},
				h = t => {
					Object(p.a)({
						noun: "cancel",
						...E(t)
					})
				},
				y = t => {
					Object(p.a)({
						noun: "discard",
						...E(t)
					})
				},
				D = t => e => ({
					...E(e),
					noun: "subreddit_choice",
					subreddit: t ? _.mb(e, t) : void 0,
					actionInfo: _.g(e)
				}),
				I = () => t => ({
					...E(t),
					noun: "subreddit_selector"
				}),
				O = (t, e) => {
					Object(p.a)({
						noun: "post_type_selector",
						postComposer: {
							type: S[e]
						},
						...E(t)
					})
				},
				T = () => t => ({
					noun: "add_option",
					...E(t)
				}),
				w = () => t => ({
					noun: "voting_length",
					...E(t)
				}),
				k = (t, e, i) => {
					"image_upload" === e || "video_upload" === e ? Object(p.a)({
						noun: e,
						...E(t)
					}) : Object(p.a)({
						noun: "text_option",
						postComposer: {
							textType: e,
							finalStatus: i ? "on" : "off"
						},
						...E(t)
					})
				},
				j = (t, e, i, n) => {
					Object(p.a)({
						noun: "post",
						subreddit: _.lb(t),
						postComposer: {
							type: e,
							...g(t, e)
						},
						post: i ? _.K(t, i) : null,
						...E(t),
						correlationId: n
					})
				},
				v = (t, e) => {
					const i = e === s.i.MARKDOWN ? "markdown_mode" : "rte_mode";
					Object(p.a)({
						noun: i,
						...E(t)
					})
				},
				x = (t, e) => {
					Object(p.a)({
						noun: "save",
						subreddit: _.lb(t),
						postComposer: {
							type: e,
							...g(t, e)
						},
						...E(t)
					})
				},
				R = (t, e) => {
					const i = t.uploads[e];
					i.error && Object(p.a)({
						...E(t),
						noun: "media",
						action: n.c.REJECT,
						actionInfo: {
							..._.d(t),
							reason: JSON.stringify(i.error)
						}
					})
				},
				L = (t, e) => {
					e.forEach(e => {
						const i = Object(o.g)(e.type);
						i && Object(p.a)({
							...E(t),
							action: n.c.DRAG,
							noun: i
						})
					})
				},
				U = (t, e, i) => {
					Object(p.a)({
						...E(t),
						noun: "input",
						postComposer: {
							inputType: i
						},
						action: e,
						actionInfo: _.g(t)
					})
				},
				C = (t, e, i) => {
					Object(p.a)({
						...E(t),
						noun: i,
						action: Object(m.getToggleAction)(e),
						actionInfo: _.g(t)
					})
				},
				N = t => P("input", t),
				B = () => P("add"),
				A = () => P("remove_image"),
				P = (t, e) => i => ({
					...E(i),
					noun: t,
					postComposer: {
						inputType: e,
						type: S.imageOnly
					},
					action: n.c.CLICK
				}),
				F = t => {
					Object(p.a)({
						...E(t),
						noun: "hide_oc_description",
						action: n.c.CLICK
					})
				},
				M = (t, e) => {
					if (e) {
						const i = _.mb(t, e);
						if (i) return {
							subreddit: i
						};
						const n = _.U(t, e);
						if (n) return {
							profile: n
						}
					}
				},
				G = (t, e) => {
					const i = d.e(t, {
							subredditName: e
						}),
						n = d.g(t);
					return {
						automoderator: {
							automod_post_guidance: !!i && i.postGuidanceConfig.length > 0,
							automod_post_guidance_ids: n
						}
					}
				},
				q = (t, e) => {
					const {
						draftId: i,
						destSubreddit: n
					} = e, r = Object(f.m)(t), o = Object(a.d)(t, {
						draftId: i
					}), s = {
						authorId: r ? r.id : void 0,
						createdTimestamp: o ? o.created : void 0,
						id: i || void 0,
						nsfw: e.isNSFW,
						originalContent: e.isOC,
						spoiler: e.isSpoiler,
						titleLength: e.title.length
					};
					switch (e.kind) {
						case l.b.Link:
							s.type = b.DraftType.Link, s.urlLength = e.body.length;
							break;
						case l.b.Markdown:
							s.type = b.DraftType.Self, s.bodyTextLength = e.body.length;
							break;
						case l.b.RichText:
							s.type = b.DraftType.RichText, e.documentStats && (s.bodyTextLength = e.documentStats.textLength, s.numberRteImages = e.documentStats.rteImagesCount, s.numberRteVideos = e.documentStats.rteVideosCount);
							break;
						case l.b.Image:
							s.type = b.DraftType.Image;
							break;
						case l.b.Video:
							s.type = b.DraftType.Video
					}
					return {
						postDraft: s,
						...M(t, n.id)
					}
				},
				W = (t, e) => {
					const i = Object(f.m)(t),
						n = {
							authorId: i ? i.id : void 0,
							createdTimestamp: e.created,
							id: e.id,
							nsfw: e.isNSFW,
							originalContent: e.isOriginalContent,
							spoiler: e.isSpoiler,
							titleLength: e.title.length
						};
					switch (e.kind) {
						case l.b.Link:
							n.type = b.DraftType.Link, n.urlLength = (e.body || "").length;
							break;
						case l.b.Markdown:
							n.type = b.DraftType.Self, n.bodyTextLength = (e.body || "").length;
							break;
						case l.b.RichText:
							n.type = b.DraftType.RichText
					}
					return {
						postDraft: n,
						...M(t, e.subredditId)
					}
				},
				K = (t, e) => {
					Object(p.a)({
						noun: "post_guidance",
						...E(t),
						action: n.c.VIEW,
						actionInfo: {
							..._.d(t)
						},
						automoderator: {
							automod_post_guidance_ids: e
						}
					})
				},
				z = (t, e) => {
					Object(p.a)({
						noun: "draft_load",
						...E(t),
						...q(t, e)
					})
				},
				Y = (t, e, i) => {
					Object(p.a)({
						noun: e.draftId ? "draft_update" : "draft_create",
						...E(t),
						...q(t, e),
						...G(t, i)
					})
				},
				X = (t, e) => {
					Object(p.a)({
						noun: "draft_delete",
						...E(t),
						...W(t, e)
					})
				},
				H = t => {
					Object(p.a)({
						...E(t),
						noun: "social_connect_link",
						action: n.c.CLICK
					})
				},
				V = (t, e) => {
					Object(p.a)({
						...E(t),
						noun: "twitter_share_checkbox",
						action: Object(m.getToggleAction)(e)
					})
				},
				Q = (t, e, i) => {
					Object(p.a)({
						...E(t),
						...q(t, e),
						noun: "draft_share",
						action: i ? n.c.ENABLE : n.c.DISABLE
					})
				},
				$ = t => {
					Object(p.a)({
						...E(t),
						noun: "create_community",
						actionInfo: {
							..._.d(t),
							pageType: "post_select_community"
						}
					})
				},
				J = "community_recommendation",
				Z = () => t => ({
					...E(t),
					action: n.c.VIEW,
					noun: J,
					listing: {
						links: Object(c.c)(t).map(e => Object(u.I)(t, e.name))
					}
				}),
				tt = (t, e) => i => ({
					...E(i),
					action: n.c.CLICK,
					noun: J,
					actionInfo: {
						..._.d(i),
						position: e
					},
					subreddit: {
						name: t,
						id: Object(u.I)(i, t)
					}
				}),
				et = t => {
					Object(p.a)({
						...E(t),
						action: n.c.SKIP,
						noun: J
					})
				},
				it = (t, e) => i => ({
					...E(i),
					action: n.c.VIEW,
					noun: `${J}_hover`,
					actionInfo: {
						..._.d(i),
						position: e
					},
					subreddit: {
						name: t,
						id: Object(u.I)(i, t)
					}
				}),
				nt = t => e => ({
					...E(e),
					action: n.c.CLICK,
					noun: "draft_preview",
					actionInfo: {
						..._.d(e),
						count: t
					}
				}),
				rt = t => e => ({
					...E(e),
					action: "add",
					noun: "flair",
					subreddit: _.mb(e, t)
				}),
				ot = () => t => ({
					...E(t),
					action: n.c.CLICK,
					noun: "flair_dropdown"
				}),
				st = () => t => ({
					...E(t),
					action: "clear",
					noun: "flair"
				}),
				lt = () => t => ({
					...E(t),
					action: "search",
					noun: "flair"
				}),
				ct = t => {
					let {
						actionInfoType: e,
						subredditId: i = "",
						noun: o = "create_post"
					} = t;
					return t => ({
						...E(t),
						action: n.c.CLICK,
						noun: o,
						actionInfo: {
							..._.d(t),
							type: e
						},
						correlationId: Object(r.d)(r.a.PostComposer, !1),
						subreddit: i ? _.mb(t, i) : void 0
					})
				},
				at = () => t => ({
					...E(t),
					action: n.c.CLICK,
					noun: "edit_post"
				}),
				dt = t => e => ({
					...E(e),
					action: "type",
					noun: "subreddit_search",
					actionInfo: {
						..._.d(e),
						type: t
					}
				})
		},
		"./src/reddit/icons/fonts/helpers.m.less": function(t, e, i) {
			t.exports = {
				TooltipDesc: "_37iEJpUpWXN00_fpZKHglg",
				tooltipDesc: "_37iEJpUpWXN00_fpZKHglg"
			}
		},
		"./src/reddit/icons/fonts/helpers.tsx": function(t, e, i) {
			"use strict";
			i.d(e, "b", (function() {
				return a
			})), i.d(e, "a", (function() {
				return d
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./src/reddit/icons/fonts/helpers.m.less"),
				s = i.n(o),
				l = i("./src/lib/constants/icons.ts"),
				c = i("./src/lib/lessComponent.tsx");
			const a = (t, e) => `icon icon-${t}${e&&!t.includes("fill")&&l.a[`${t}_fill`]?"_fill":""}`,
				d = c.a.wrapped(t => r.a.createElement("span", {
					className: t.className
				}, t.children), "TooltipDesc", s.a)
		},
		"./src/reddit/icons/svgs/Close/index.tsx": function(t, e, i) {
			"use strict";
			var n = i("./node_modules/react/index.js"),
				r = i.n(n);

			function o() {
				return (o = Object.assign || function(t) {
					for (var e = 1; e < arguments.length; e++) {
						var i = arguments[e];
						for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
					}
					return t
				}).apply(this, arguments)
			}
			e.a = t => r.a.createElement("svg", o({
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, t), r.a.createElement("polygon", {
				fill: "inherit",
				points: "11.649 9.882 18.262 3.267 16.495 1.5 9.881 8.114 3.267 1.5 1.5 3.267 8.114 9.883 1.5 16.497 3.267 18.264 9.881 11.65 16.495 18.264 18.262 16.497"
			}))
		},
		"./src/reddit/models/ApiRequestState/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			})), i.d(e, "b", (function() {
				return o
			}));
			var n, r = i("./node_modules/uuid/dist/esm-browser/v4.js");
			! function(t) {
				t[t.Pending = 0] = "Pending", t[t.Complete = 1] = "Complete", t[t.Failed = 2] = "Failed"
			}(n || (n = {}));
			const o = () => Object(r.a)()
		},
		"./src/reddit/selectors/experiments/communityDirectoryBacklinks/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "c", (function() {
				return d
			})), i.d(e, "a", (function() {
				return _
			})), i.d(e, "b", (function() {
				return f
			}));
			var n = i("./src/reddit/constants/experiments.ts"),
				r = i("./src/reddit/helpers/chooseVariant/index.ts"),
				o = i("./src/server/helpers/canonicalUrl.tsx");
			const s = (t, e) => t.find(t => e <= t);

			function l(t, e) {
				return Object(o.c)(`/best/communities/${t}/#${e}`)
			}

			function c(t, e) {
				return t > 50 ? {
					percentile: s([0, 1, 5, 10, 20, 50], e),
					position: t
				} : {
					position: t
				}
			}
			var a = i("./src/reddit/selectors/subreddit.ts");
			const d = t => {
					return Object(r.c)(t, {
						experimentEligibilitySelector: r.a,
						experimentName: n.L,
						expEventOverride: !1
					}) === n.U.Enabled
				},
				u = (t, e) => {
					let {
						subredditId: i,
						subredditAboutInfo: n
					} = e;
					if (d(t) && i && (null == n ? void 0 : n.directoryRankings)) return function(t, e) {
						const i = null === (n = t.rankings) || void 0 === n ? void 0 : n[0];
						var n;
						if (i && i.position > 0 && e) {
							const t = Math.ceil(i.position / i.totalRanked * 100);
							if (t <= 50) return {
								url: l(i.pageNumber, e),
								...c(i.position, t)
							}
						}
					}(n.directoryRankings, i)
				},
				_ = (t, e) => {
					const i = Object(a.C)(t, {
							subredditName: e
						}),
						n = Object(a.z)(t, {
							subredditName: e
						});
					return u(t, {
						subredditId: null == i ? void 0 : i.id,
						subredditAboutInfo: n
					})
				},
				f = t => {
					const e = t.platform.currentPage,
						i = e && e.routeMatch,
						n = i ? i.match.params.subredditName : void 0;
					if (!n) return;
					const r = _(t, n);
					return (null == r ? void 0 : r.url) ? {
						internalLinkUrl: null == r ? void 0 : r.url
					} : void 0
				}
		},
		"./src/reddit/selectors/experiments/postCreationSubRec.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return d
			})), i.d(e, "b", (function() {
				return u
			})), i.d(e, "g", (function() {
				return p
			})), i.d(e, "j", (function() {
				return m
			})), i.d(e, "h", (function() {
				return b
			})), i.d(e, "i", (function() {
				return S
			})), i.d(e, "f", (function() {
				return E
			})), i.d(e, "d", (function() {
				return g
			})), i.d(e, "c", (function() {
				return h
			})), i.d(e, "e", (function() {
				return y
			})), i.d(e, "l", (function() {
				return D
			})), i.d(e, "k", (function() {
				return I
			})), i.d(e, "m", (function() {
				return O
			}));
			var n = i("./src/lib/constants/index.ts"),
				r = i("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				o = i("./src/reddit/constants/experiments.ts"),
				s = i("./src/reddit/helpers/chooseVariant/index.ts"),
				l = i("./src/reddit/models/PostCreationForm/index.ts"),
				c = i("./src/reddit/models/SubredditAutocomplete/index.ts"),
				a = i("./src/reddit/selectors/subreddit.ts");
			const d = 3,
				u = t => _(t) ? 1 : (f(t), .5),
				_ = t => {
					return Object(s.c)(t, {
						experimentEligibilitySelector: s.a,
						experimentName: o.ff
					}) === o.hf.ContentMatch
				},
				f = t => {
					return Object(s.c)(t, {
						experimentEligibilitySelector: s.a,
						experimentName: o.ff
					}) === o.hf.ConfidenceAndSuccess
				},
				p = t => {
					const e = Object(s.c)(t, {
						experimentEligibilitySelector: s.a,
						experimentName: o.ff
					});
					return e === o.hf.ContentMatch || e === o.hf.ConfidenceAndSuccess || e === o.V.Control1 || e === o.V.Control2
				},
				m = t => {
					const e = Object(s.c)(t, {
						experimentEligibilitySelector: s.a,
						experimentName: o.ff
					});
					return e === o.V.Control1 || e === o.V.Control2
				},
				b = t => {
					const e = Object(s.c)(t, {
						experimentEligibilitySelector: s.a,
						experimentName: o.ff
					});
					return e === o.hf.ContentMatch || e === o.hf.ConfidenceAndSuccess
				},
				S = t => t.creations.subredditRec.api.pending,
				E = t => t.creations.subredditRec.api.error,
				g = t => {
					return t.creations.subredditRec.order.length > 0
				},
				h = t => {
					const e = t.creations.subredditRec.order,
						i = [];
					return e.forEach(e => {
						const n = Object(a.z)(t, {
								subredditName: e
							}),
							r = Object(a.C)(t, {
								subredditName: e
							});
						if (r && n) {
							const t = {
								iconUrl: r.icon.url,
								name: r.name,
								primaryColor: r.primaryColor,
								subscribers: n.subscribers,
								type: c.a.OTHER_SUBREDDIT
							};
							i.push(t)
						}
					}), i
				},
				y = t => t.creations.subredditRec.isInputChanged,
				D = t => {
					if (!(t.creations.formData.submissionType === n.bc.POST)) return "";
					const e = t.creations.formState.editorMode === l.i.RICH_TEXT || null === t.creations.formState.editorMode,
						i = t.creations.formState.editorMode === l.i.MARKDOWN;
					if (e) {
						const e = t.creations.formData.body.rte;
						return r.a.getRawText(e, " ") || ""
					}
					return i && t.creations.formData.body.markdown || ""
				},
				I = t => {
					return t.creations.formData.submissionType === n.bc.LINK_ONLY && t.creations.formData.body.link || ""
				},
				O = t => p(t) && (!E(t) || E(t) && y(t)) && (t => {
					const e = t.creations.formData.title,
						i = I(t),
						n = D(t);
					return !!(e || i || n)
				})(t) && (t.creations.formData.submissionType === n.bc.POST || t.creations.formData.submissionType === n.bc.LINK_ONLY || t.creations.formData.submissionType === n.bc.CROSSPOST)
		},
		"./src/reddit/selectors/experiments/topPosts.ts": function(t, e, i) {
			"use strict";
			i.d(e, "d", (function() {
				return a
			})), i.d(e, "a", (function() {
				return d
			})), i.d(e, "b", (function() {
				return u
			})), i.d(e, "c", (function() {
				return _
			}));
			var n = i("./node_modules/reselect/es/index.js"),
				r = i("./src/reddit/constants/experiments.ts"),
				o = i("./src/reddit/contexts/PageLayer/index.tsx"),
				s = i("./src/reddit/helpers/chooseVariant/index.ts"),
				l = i("./src/reddit/selectors/user.ts");
			const c = Object(n.a)(l.S, (t, e) => {
					let {
						pageLayer: i
					} = e;
					return Object(o.B)(i)
				}, (t, e) => {
					let {
						pageLayer: i
					} = e;
					return Object(o.Q)(i)
				}, (t, e, i) => !t && !e && i),
				a = Object(n.a)((t, e) => Object(s.c)(t, {
					experimentName: r.yd,
					experimentEligibilitySelector: t => c(t, e)
				}), t => t),
				d = t => t === r.og.NoCommunityWidgets,
				u = t => t === r.og.NoRulesModerators,
				_ = t => t === r.og.RelatedPostsDu
		},
		"./src/reddit/selectors/postGuidance.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			})), i.d(e, "e", (function() {
				return r
			})), i.d(e, "b", (function() {
				return o
			})), i.d(e, "c", (function() {
				return s
			})), i.d(e, "f", (function() {
				return l
			})), i.d(e, "d", (function() {
				return c
			})), i.d(e, "g", (function() {
				return a
			}));
			const n = (t, e) => {
					let {
						subredditName: i
					} = e;
					return t.postGuidance.api.fetch.pending[i.toLowerCase()] || !1
				},
				r = (t, e) => {
					let {
						subredditName: i
					} = e;
					return t.postGuidance.models[i.toLowerCase()]
				},
				o = (t, e) => {
					let {
						subredditId: i
					} = e;
					return t.postGuidance.allowlist[i]
				},
				s = t => t.creations.formState.postGuidance.isBlockRuleTriggered,
				l = t => t.creations.formState.postGuidance.titleTriggeredRules,
				c = t => t.creations.formState.postGuidance.bodyTriggeredRules,
				a = t => t.creations.formState.postGuidance.uniqueRules
		},
		"./src/reddit/selectors/tooltip.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			})), i.d(e, "b", (function() {
				return r
			})), i.d(e, "c", (function() {
				return o
			}));
			const n = t => t.tooltip.tooltipId,
				r = t => e => e.tooltip.tooltipId === t,
				o = t => t.tooltip.params
		},
		"./src/redditGQL/operations/FetchSubredditsNotificationSettings.json": function(t) {
			t.exports = JSON.parse('{"id":"5d042135b4c5"}')
		},
		"./src/redditGQL/operations/SubredditAbout.json": function(t) {
			t.exports = JSON.parse('{"id":"4016ffe922f6"}')
		},
		"./src/redditGQL/operations/UpdateSubredditNotificationSettings.json": function(t) {
			t.exports = JSON.parse('{"id":"0af4f630a2e1"}')
		}
	}
]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/Governance~ModListing~Reddit~ReportFlow.01e832fec08b376ce5b3.js.map