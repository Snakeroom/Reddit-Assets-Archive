// https://www.redditstatic.com/desktop2x/vendors~Subreddit~SubredditWiki.c17b16c26feb8de5d65f.js
// Retrieved at 1/5/2023, 12:00:05 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["vendors~Subreddit~SubredditWiki"], {
		"./node_modules/another-json/another-json.js": function(e, t, i) {
			"use strict";
			for (var n = /[\\\"\x00-\x1F]/g, r = {}, s = 0; s < 32; ++s) r[String.fromCharCode(s)] = "\\U" + ("0000" + s.toString(16)).slice(-4).toUpperCase();

			function o(e) {
				return n.lastIndex = 0, e.replace(n, (function(e) {
					return r[e]
				}))
			}

			function a(e) {
				switch (typeof e) {
					case "string":
						return '"' + o(e) + '"';
					case "number":
						return isFinite(e) ? e : "null";
					case "boolean":
						return e;
					case "object":
						return null === e ? "null" : Array.isArray(e) ? function(e) {
							for (var t = "[", i = "", n = 0; n < e.length; ++n) i += t, t = ",", i += a(e[n]);
							return "," != t ? "[]" : i + "]"
						}(e) : function(e) {
							var t = "{",
								i = "",
								n = Object.keys(e);
							n.sort();
							for (var r = 0; r < n.length; ++r) {
								var s = n[r];
								i += t + '"' + o(s) + '":', t = ",", i += a(e[s])
							}
							return "," != t ? "{}" : i + "}"
						}(e);
					default:
						throw new Error("Cannot stringify: " + typeof e)
				}
			}
			r["\b"] = "\\b", r["\t"] = "\\t", r["\n"] = "\\n", r["\f"] = "\\f", r["\r"] = "\\r", r['"'] = '\\"', r["\\"] = "\\\\", e.exports = {
				stringify: a
			}
		},
		"./node_modules/autosize/dist/autosize.js": function(e, t, i) {
			var n, r, s;
			r = [t, e], void 0 === (s = "function" == typeof(n = function(e, t) {
				"use strict";
				var i, n, r = "function" == typeof Map ? new Map : (i = [], n = [], {
						has: function(e) {
							return i.indexOf(e) > -1
						},
						get: function(e) {
							return n[i.indexOf(e)]
						},
						set: function(e, t) {
							-1 === i.indexOf(e) && (i.push(e), n.push(t))
						},
						delete: function(e) {
							var t = i.indexOf(e);
							t > -1 && (i.splice(t, 1), n.splice(t, 1))
						}
					}),
					s = function(e) {
						return new Event(e, {
							bubbles: !0
						})
					};
				try {
					new Event("test")
				} catch (c) {
					s = function(e) {
						var t = document.createEvent("Event");
						return t.initEvent(e, !0, !1), t
					}
				}

				function o(e) {
					if (e && e.nodeName && "TEXTAREA" === e.nodeName && !r.has(e)) {
						var t, i = null,
							n = e.clientWidth,
							o = null,
							a = function() {
								e.clientWidth !== n && u()
							},
							d = function(t) {
								window.removeEventListener("resize", a, !1), e.removeEventListener("input", u, !1), e.removeEventListener("keyup", u, !1), e.removeEventListener("autosize:destroy", d, !1), e.removeEventListener("autosize:update", u, !1), Object.keys(t).forEach((function(i) {
									e.style[i] = t[i]
								})), r.delete(e)
							}.bind(e, {
								height: e.style.height,
								resize: e.style.resize,
								overflowY: e.style.overflowY,
								overflowX: e.style.overflowX,
								wordWrap: e.style.wordWrap
							});
						e.addEventListener("autosize:destroy", d, !1), "onpropertychange" in e && "oninput" in e && e.addEventListener("keyup", u, !1), window.addEventListener("resize", a, !1), e.addEventListener("input", u, !1), e.addEventListener("autosize:update", u, !1), e.style.overflowX = "hidden", e.style.wordWrap = "break-word", r.set(e, {
							destroy: d,
							update: u
						}), "vertical" === (t = window.getComputedStyle(e, null)).resize ? e.style.resize = "none" : "both" === t.resize && (e.style.resize = "horizontal"), i = "content-box" === t.boxSizing ? -(parseFloat(t.paddingTop) + parseFloat(t.paddingBottom)) : parseFloat(t.borderTopWidth) + parseFloat(t.borderBottomWidth), isNaN(i) && (i = 0), u()
					}

					function l(t) {
						var i = e.style.width;
						e.style.width = "0px", e.offsetWidth, e.style.width = i, e.style.overflowY = t
					}

					function c() {
						var t = e.style.height,
							r = function(e) {
								for (var t = []; e && e.parentNode && e.parentNode instanceof Element;) e.parentNode.scrollTop && t.push({
									node: e.parentNode,
									scrollTop: e.parentNode.scrollTop
								}), e = e.parentNode;
								return t
							}(e),
							s = document.documentElement && document.documentElement.scrollTop;
						e.style.height = "auto";
						var o = e.scrollHeight + i;
						0 !== e.scrollHeight ? (e.style.height = o + "px", n = e.clientWidth, r.forEach((function(e) {
							e.node.scrollTop = e.scrollTop
						})), s && (document.documentElement.scrollTop = s)) : e.style.height = t
					}

					function u() {
						c();
						var t = Math.round(parseFloat(e.style.height)),
							i = window.getComputedStyle(e, null),
							n = "content-box" === i.boxSizing ? Math.round(parseFloat(i.height)) : e.offsetHeight;
						if (n !== t ? "hidden" === i.overflowY && (l("scroll"), c(), n = "content-box" === i.boxSizing ? Math.round(parseFloat(window.getComputedStyle(e, null).height)) : e.offsetHeight) : "hidden" !== i.overflowY && (l("hidden"), c(), n = "content-box" === i.boxSizing ? Math.round(parseFloat(window.getComputedStyle(e, null).height)) : e.offsetHeight), o !== n) {
							o = n;
							var r = s("autosize:resized");
							try {
								e.dispatchEvent(r)
							} catch (a) {}
						}
					}
				}

				function a(e) {
					var t = r.get(e);
					t && t.destroy()
				}

				function d(e) {
					var t = r.get(e);
					t && t.update()
				}
				var l = null;
				"undefined" == typeof window || "function" != typeof window.getComputedStyle ? ((l = function(e) {
					return e
				}).destroy = function(e) {
					return e
				}, l.update = function(e) {
					return e
				}) : ((l = function(e, t) {
					return e && Array.prototype.forEach.call(e.length ? e : [e], (function(e) {
						return o(e)
					})), e
				}).destroy = function(e) {
					return e && Array.prototype.forEach.call(e.length ? e : [e], a), e
				}, l.update = function(e) {
					return e && Array.prototype.forEach.call(e.length ? e : [e], d), e
				}), t.exports = l
			}) ? n.apply(t, r) : n) || (e.exports = s)
		},
		"./node_modules/base-x/src/index.js": function(e, t, i) {
			"use strict";
			e.exports = function(e) {
				if (e.length >= 255) throw new TypeError("Alphabet too long");
				for (var t = new Uint8Array(256), i = 0; i < t.length; i++) t[i] = 255;
				for (var n = 0; n < e.length; n++) {
					var r = e.charAt(n),
						s = r.charCodeAt(0);
					if (255 !== t[s]) throw new TypeError(r + " is ambiguous");
					t[s] = n
				}
				var o = e.length,
					a = e.charAt(0),
					d = Math.log(o) / Math.log(256),
					l = Math.log(256) / Math.log(o);

				function c(e) {
					if ("string" != typeof e) throw new TypeError("Expected String");
					if (0 === e.length) return new Uint8Array;
					for (var i = 0, n = 0, r = 0; e[i] === a;) n++, i++;
					for (var s = (e.length - i) * d + 1 >>> 0, l = new Uint8Array(s); e[i];) {
						var c = t[e.charCodeAt(i)];
						if (255 === c) return;
						for (var u = 0, h = s - 1;
							(0 !== c || u < r) && -1 !== h; h--, u++) c += o * l[h] >>> 0, l[h] = c % 256 >>> 0, c = c / 256 >>> 0;
						if (0 !== c) throw new Error("Non-zero carry");
						r = u, i++
					}
					for (var m = s - r; m !== s && 0 === l[m];) m++;
					for (var p = new Uint8Array(n + (s - m)), g = n; m !== s;) p[g++] = l[m++];
					return p
				}
				return {
					encode: function(t) {
						if (t instanceof Uint8Array || (ArrayBuffer.isView(t) ? t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : Array.isArray(t) && (t = Uint8Array.from(t))), !(t instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
						if (0 === t.length) return "";
						for (var i = 0, n = 0, r = 0, s = t.length; r !== s && 0 === t[r];) r++, i++;
						for (var d = (s - r) * l + 1 >>> 0, c = new Uint8Array(d); r !== s;) {
							for (var u = t[r], h = 0, m = d - 1;
								(0 !== u || h < n) && -1 !== m; m--, h++) u += 256 * c[m] >>> 0, c[m] = u % o >>> 0, u = u / o >>> 0;
							if (0 !== u) throw new Error("Non-zero carry");
							n = h, r++
						}
						for (var p = d - n; p !== d && 0 === c[p];) p++;
						for (var g = a.repeat(i); p < d; ++p) g += e.charAt(c[p]);
						return g
					},
					decodeUnsafe: c,
					decode: function(e) {
						var t = c(e);
						if (t) return t;
						throw new Error("Non-base" + o + " character")
					}
				}
			}
		},
		"./node_modules/bowser/src/bowser.js": function(e, t, i) {
			var n;
			n = function() {
				var e = !0;

				function t(t) {
					function i(e) {
						var i = t.match(e);
						return i && i.length > 1 && i[1] || ""
					}

					function n(e) {
						var i = t.match(e);
						return i && i.length > 1 && i[2] || ""
					}
					var r, s = i(/(ipod|iphone|ipad)/i).toLowerCase(),
						o = !/like android/i.test(t) && /android/i.test(t),
						a = /nexus\s*[0-6]\s*/i.test(t),
						d = !a && /nexus\s*[0-9]+/i.test(t),
						l = /CrOS/.test(t),
						c = /silk/i.test(t),
						u = /sailfish/i.test(t),
						h = /tizen/i.test(t),
						m = /(web|hpw)os/i.test(t),
						p = /windows phone/i.test(t),
						g = (/SamsungBrowser/i.test(t), !p && /windows/i.test(t)),
						f = !s && !c && /macintosh/i.test(t),
						v = !o && !u && !h && !m && /linux/i.test(t),
						y = n(/edg([ea]|ios)\/(\d+(\.\d+)?)/i),
						b = i(/version\/(\d+(\.\d+)?)/i),
						_ = /tablet/i.test(t) && !/tablet pc/i.test(t),
						S = !_ && /[^-]mobi/i.test(t),
						E = /xbox/i.test(t);
					/opera/i.test(t) ? r = {
						name: "Opera",
						opera: e,
						version: b || i(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
					} : /opr\/|opios/i.test(t) ? r = {
						name: "Opera",
						opera: e,
						version: i(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || b
					} : /SamsungBrowser/i.test(t) ? r = {
						name: "Samsung Internet for Android",
						samsungBrowser: e,
						version: b || i(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
					} : /coast/i.test(t) ? r = {
						name: "Opera Coast",
						coast: e,
						version: b || i(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
					} : /yabrowser/i.test(t) ? r = {
						name: "Yandex Browser",
						yandexbrowser: e,
						version: b || i(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
					} : /ucbrowser/i.test(t) ? r = {
						name: "UC Browser",
						ucbrowser: e,
						version: i(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
					} : /mxios/i.test(t) ? r = {
						name: "Maxthon",
						maxthon: e,
						version: i(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
					} : /epiphany/i.test(t) ? r = {
						name: "Epiphany",
						epiphany: e,
						version: i(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
					} : /puffin/i.test(t) ? r = {
						name: "Puffin",
						puffin: e,
						version: i(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
					} : /sleipnir/i.test(t) ? r = {
						name: "Sleipnir",
						sleipnir: e,
						version: i(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
					} : /k-meleon/i.test(t) ? r = {
						name: "K-Meleon",
						kMeleon: e,
						version: i(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
					} : p ? (r = {
						name: "Windows Phone",
						osname: "Windows Phone",
						windowsphone: e
					}, y ? (r.msedge = e, r.version = y) : (r.msie = e, r.version = i(/iemobile\/(\d+(\.\d+)?)/i))) : /msie|trident/i.test(t) ? r = {
						name: "Internet Explorer",
						msie: e,
						version: i(/(?:msie |rv:)(\d+(\.\d+)?)/i)
					} : l ? r = {
						name: "Chrome",
						osname: "Chrome OS",
						chromeos: e,
						chromeBook: e,
						chrome: e,
						version: i(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
					} : /edg([ea]|ios)/i.test(t) ? r = {
						name: "Microsoft Edge",
						msedge: e,
						version: y
					} : /vivaldi/i.test(t) ? r = {
						name: "Vivaldi",
						vivaldi: e,
						version: i(/vivaldi\/(\d+(\.\d+)?)/i) || b
					} : u ? r = {
						name: "Sailfish",
						osname: "Sailfish OS",
						sailfish: e,
						version: i(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
					} : /seamonkey\//i.test(t) ? r = {
						name: "SeaMonkey",
						seamonkey: e,
						version: i(/seamonkey\/(\d+(\.\d+)?)/i)
					} : /firefox|iceweasel|fxios/i.test(t) ? (r = {
						name: "Firefox",
						firefox: e,
						version: i(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
					}, /\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(t) && (r.firefoxos = e, r.osname = "Firefox OS")) : c ? r = {
						name: "Amazon Silk",
						silk: e,
						version: i(/silk\/(\d+(\.\d+)?)/i)
					} : /phantom/i.test(t) ? r = {
						name: "PhantomJS",
						phantom: e,
						version: i(/phantomjs\/(\d+(\.\d+)?)/i)
					} : /slimerjs/i.test(t) ? r = {
						name: "SlimerJS",
						slimer: e,
						version: i(/slimerjs\/(\d+(\.\d+)?)/i)
					} : /blackberry|\bbb\d+/i.test(t) || /rim\stablet/i.test(t) ? r = {
						name: "BlackBerry",
						osname: "BlackBerry OS",
						blackberry: e,
						version: b || i(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
					} : m ? (r = {
						name: "WebOS",
						osname: "WebOS",
						webos: e,
						version: b || i(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
					}, /touchpad\//i.test(t) && (r.touchpad = e)) : /bada/i.test(t) ? r = {
						name: "Bada",
						osname: "Bada",
						bada: e,
						version: i(/dolfin\/(\d+(\.\d+)?)/i)
					} : h ? r = {
						name: "Tizen",
						osname: "Tizen",
						tizen: e,
						version: i(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || b
					} : /qupzilla/i.test(t) ? r = {
						name: "QupZilla",
						qupzilla: e,
						version: i(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || b
					} : /chromium/i.test(t) ? r = {
						name: "Chromium",
						chromium: e,
						version: i(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || b
					} : /chrome|crios|crmo/i.test(t) ? r = {
						name: "Chrome",
						chrome: e,
						version: i(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
					} : o ? r = {
						name: "Android",
						version: b
					} : /safari|applewebkit/i.test(t) ? (r = {
						name: "Safari",
						safari: e
					}, b && (r.version = b)) : s ? (r = {
						name: "iphone" == s ? "iPhone" : "ipad" == s ? "iPad" : "iPod"
					}, b && (r.version = b)) : r = /googlebot/i.test(t) ? {
						name: "Googlebot",
						googlebot: e,
						version: i(/googlebot\/(\d+(\.\d+))/i) || b
					} : {
						name: i(/^(.*)\/(.*) /),
						version: n(/^(.*)\/(.*) /)
					}, !r.msedge && /(apple)?webkit/i.test(t) ? (/(apple)?webkit\/537\.36/i.test(t) ? (r.name = r.name || "Blink", r.blink = e) : (r.name = r.name || "Webkit", r.webkit = e), !r.version && b && (r.version = b)) : !r.opera && /gecko\//i.test(t) && (r.name = r.name || "Gecko", r.gecko = e, r.version = r.version || i(/gecko\/(\d+(\.\d+)?)/i)), r.windowsphone || !o && !r.silk ? !r.windowsphone && s ? (r[s] = e, r.ios = e, r.osname = "iOS") : f ? (r.mac = e, r.osname = "macOS") : E ? (r.xbox = e, r.osname = "Xbox") : g ? (r.windows = e, r.osname = "Windows") : v && (r.linux = e, r.osname = "Linux") : (r.android = e, r.osname = "Android");
					var w = "";
					r.windows ? w = function(e) {
						switch (e) {
							case "NT":
								return "NT";
							case "XP":
								return "XP";
							case "NT 5.0":
								return "2000";
							case "NT 5.1":
								return "XP";
							case "NT 5.2":
								return "2003";
							case "NT 6.0":
								return "Vista";
							case "NT 6.1":
								return "7";
							case "NT 6.2":
								return "8";
							case "NT 6.3":
								return "8.1";
							case "NT 10.0":
								return "10";
							default:
								return
						}
					}(i(/Windows ((NT|XP)( \d\d?.\d)?)/i)) : r.windowsphone ? w = i(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i) : r.mac ? w = (w = i(/Mac OS X (\d+([_\.\s]\d+)*)/i)).replace(/[_\s]/g, ".") : s ? w = (w = i(/os (\d+([_\s]\d+)*) like mac os x/i)).replace(/[_\s]/g, ".") : o ? w = i(/android[ \/-](\d+(\.\d+)*)/i) : r.webos ? w = i(/(?:web|hpw)os\/(\d+(\.\d+)*)/i) : r.blackberry ? w = i(/rim\stablet\sos\s(\d+(\.\d+)*)/i) : r.bada ? w = i(/bada\/(\d+(\.\d+)*)/i) : r.tizen && (w = i(/tizen[\/\s](\d+(\.\d+)*)/i)), w && (r.osversion = w);
					var k = !r.windows && w.split(".")[0];
					return _ || d || "ipad" == s || o && (3 == k || k >= 4 && !S) || r.silk ? r.tablet = e : (S || "iphone" == s || "ipod" == s || o || a || r.blackberry || r.webos || r.bada) && (r.mobile = e), r.msedge || r.msie && r.version >= 10 || r.yandexbrowser && r.version >= 15 || r.vivaldi && r.version >= 1 || r.chrome && r.version >= 20 || r.samsungBrowser && r.version >= 4 || r.firefox && r.version >= 20 || r.safari && r.version >= 6 || r.opera && r.version >= 10 || r.ios && r.osversion && r.osversion.split(".")[0] >= 6 || r.blackberry && r.version >= 10.1 || r.chromium && r.version >= 20 ? r.a = e : r.msie && r.version < 10 || r.chrome && r.version < 20 || r.firefox && r.version < 20 || r.safari && r.version < 6 || r.opera && r.version < 10 || r.ios && r.osversion && r.osversion.split(".")[0] < 6 || r.chromium && r.version < 20 ? r.c = e : r.x = e, r
				}
				var i = t("undefined" != typeof navigator && navigator.userAgent || "");

				function n(e) {
					return e.split(".").length
				}

				function r(e, t) {
					var i, n = [];
					if (Array.prototype.map) return Array.prototype.map.call(e, t);
					for (i = 0; i < e.length; i++) n.push(t(e[i]));
					return n
				}

				function s(e) {
					for (var t = Math.max(n(e[0]), n(e[1])), i = r(e, (function(e) {
							var i = t - n(e);
							return r((e += new Array(i + 1).join(".0")).split("."), (function(e) {
								return new Array(20 - e.length).join("0") + e
							})).reverse()
						})); --t >= 0;) {
						if (i[0][t] > i[1][t]) return 1;
						if (i[0][t] !== i[1][t]) return -1;
						if (0 === t) return 0
					}
				}

				function o(e, n, r) {
					var o = i;
					"string" == typeof n && (r = n, n = void 0), void 0 === n && (n = !1), r && (o = t(r));
					var a = "" + o.version;
					for (var d in e)
						if (e.hasOwnProperty(d) && o[d]) {
							if ("string" != typeof e[d]) throw new Error("Browser version in the minVersion map should be a string: " + d + ": " + String(e));
							return s([a, e[d]]) < 0
						} return n
				}
				return i.test = function(e) {
					for (var t = 0; t < e.length; ++t) {
						var n = e[t];
						if ("string" == typeof n && n in i) return !0
					}
					return !1
				}, i.isUnsupportedBrowser = o, i.compareVersions = s, i.check = function(e, t, i) {
					return !o(e, t, i)
				}, i._detect = t, i.detect = t, i
			}, e.exports ? e.exports = n() : i("./node_modules/webpack/buildin/amd-define.js")("bowser", n)
		},
		"./node_modules/bs58/index.js": function(e, t, i) {
			const n = i("./node_modules/base-x/src/index.js");
			e.exports = n("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
		},
		"./node_modules/computed-style/dist/computedStyle.commonjs.js": function(e, t) {
			e.exports = function(e, t, i) {
				return ((i = window.getComputedStyle) ? i(e) : e.currentStyle)[t.replace(/-(\w)/gi, (function(e, t) {
					return t.toUpperCase()
				}))]
			}
		},
		"./node_modules/content-type/index.js": function(e, t, i) {
			"use strict";
			var n = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,
				r = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,
				s = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,
				o = /\\([\u000b\u0020-\u00ff])/g,
				a = /([\\"])/g,
				d = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

			function l(e) {
				var t = String(e);
				if (s.test(t)) return t;
				if (t.length > 0 && !r.test(t)) throw new TypeError("invalid parameter value");
				return '"' + t.replace(a, "\\$1") + '"'
			}

			function c(e) {
				this.parameters = Object.create(null), this.type = e
			}
			t.format = function(e) {
				if (!e || "object" != typeof e) throw new TypeError("argument obj is required");
				var t = e.parameters,
					i = e.type;
				if (!i || !d.test(i)) throw new TypeError("invalid type");
				var n = i;
				if (t && "object" == typeof t)
					for (var r, o = Object.keys(t).sort(), a = 0; a < o.length; a++) {
						if (r = o[a], !s.test(r)) throw new TypeError("invalid parameter name");
						n += "; " + r + "=" + l(t[r])
					}
				return n
			}, t.parse = function(e) {
				if (!e) throw new TypeError("argument string is required");
				var t = "object" == typeof e ? function(e) {
					var t;
					"function" == typeof e.getHeader ? t = e.getHeader("content-type") : "object" == typeof e.headers && (t = e.headers && e.headers["content-type"]);
					if ("string" != typeof t) throw new TypeError("content-type header is missing from object");
					return t
				}(e) : e;
				if ("string" != typeof t) throw new TypeError("argument string is required to be a string");
				var i = t.indexOf(";"),
					r = -1 !== i ? t.substr(0, i).trim() : t.trim();
				if (!d.test(r)) throw new TypeError("invalid media type");
				var s = new c(r.toLowerCase());
				if (-1 !== i) {
					var a, l, u;
					for (n.lastIndex = i; l = n.exec(t);) {
						if (l.index !== i) throw new TypeError("invalid parameter format");
						i += l[0].length, a = l[1].toLowerCase(), '"' === (u = l[2])[0] && (u = u.substr(1, u.length - 2).replace(o, "$1")), s.parameters[a] = u
					}
					if (i !== t.length) throw new TypeError("invalid parameter format")
				}
				return s
			}
		},
		"./node_modules/line-height/lib/line-height.js": function(e, t, i) {
			var n = i("./node_modules/computed-style/dist/computedStyle.commonjs.js");
			e.exports = function(e) {
				var t = n(e, "line-height"),
					i = parseFloat(t, 10);
				if (t === i + "") {
					var r = e.style.lineHeight;
					e.style.lineHeight = t + "em", t = n(e, "line-height"), i = parseFloat(t, 10), r ? e.style.lineHeight = r : delete e.style.lineHeight
				}
				if (-1 !== t.indexOf("pt") ? (i *= 4, i /= 3) : -1 !== t.indexOf("mm") ? (i *= 96, i /= 25.4) : -1 !== t.indexOf("cm") ? (i *= 96, i /= 2.54) : -1 !== t.indexOf("in") ? i *= 96 : -1 !== t.indexOf("pc") && (i *= 16), i = Math.round(i), "normal" === t) {
					var s = e.nodeName,
						o = document.createElement(s);
					o.innerHTML = "&nbsp;", "TEXTAREA" === s.toUpperCase() && o.setAttribute("rows", "1");
					var a = n(e, "font-size");
					o.style.fontSize = a, o.style.padding = "0px", o.style.border = "0px";
					var d = document.body;
					d.appendChild(o), i = o.offsetHeight, d.removeChild(o)
				}
				return i
			}
		},
		"./node_modules/linkify-it/index.js": function(e, t, i) {
			"use strict";

			function n(e) {
				return Array.prototype.slice.call(arguments, 1).forEach((function(t) {
					t && Object.keys(t).forEach((function(i) {
						e[i] = t[i]
					}))
				})), e
			}

			function r(e) {
				return Object.prototype.toString.call(e)
			}

			function s(e) {
				return "[object Function]" === r(e)
			}

			function o(e) {
				return e.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&")
			}
			var a = {
				fuzzyLink: !0,
				fuzzyEmail: !0,
				fuzzyIP: !1
			};
			var d = {
					"http:": {
						validate: function(e, t, i) {
							var n = e.slice(t);
							return i.re.http || (i.re.http = new RegExp("^\\/\\/" + i.re.src_auth + i.re.src_host_port_strict + i.re.src_path, "i")), i.re.http.test(n) ? n.match(i.re.http)[0].length : 0
						}
					},
					"https:": "http:",
					"ftp:": "http:",
					"//": {
						validate: function(e, t, i) {
							var n = e.slice(t);
							return i.re.no_http || (i.re.no_http = new RegExp("^" + i.re.src_auth + "(?:localhost|(?:(?:" + i.re.src_domain + ")\\.)+" + i.re.src_domain_root + ")" + i.re.src_port + i.re.src_host_terminator + i.re.src_path, "i")), i.re.no_http.test(n) ? t >= 3 && ":" === e[t - 3] ? 0 : t >= 3 && "/" === e[t - 3] ? 0 : n.match(i.re.no_http)[0].length : 0
						}
					},
					"mailto:": {
						validate: function(e, t, i) {
							var n = e.slice(t);
							return i.re.mailto || (i.re.mailto = new RegExp("^" + i.re.src_email_name + "@" + i.re.src_host_strict, "i")), i.re.mailto.test(n) ? n.match(i.re.mailto)[0].length : 0
						}
					}
				},
				l = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]",
				c = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");

			function u(e) {
				var t = e.re = i("./node_modules/linkify-it/lib/re.js")(e.__opts__),
					n = e.__tlds__.slice();

				function a(e) {
					return e.replace("%TLDS%", t.src_tlds)
				}
				e.onCompile(), e.__tlds_replaced__ || n.push(l), n.push(t.src_xn), t.src_tlds = n.join("|"), t.email_fuzzy = RegExp(a(t.tpl_email_fuzzy), "i"), t.link_fuzzy = RegExp(a(t.tpl_link_fuzzy), "i"), t.link_no_ip_fuzzy = RegExp(a(t.tpl_link_no_ip_fuzzy), "i"), t.host_fuzzy_test = RegExp(a(t.tpl_host_fuzzy_test), "i");
				var d = [];

				function c(e, t) {
					throw new Error('(LinkifyIt) Invalid schema "' + e + '": ' + t)
				}
				e.__compiled__ = {}, Object.keys(e.__schemas__).forEach((function(t) {
					var i = e.__schemas__[t];
					if (null !== i) {
						var n = {
							validate: null,
							link: null
						};
						if (e.__compiled__[t] = n, "[object Object]" === r(i)) return ! function(e) {
							return "[object RegExp]" === r(e)
						}(i.validate) ? s(i.validate) ? n.validate = i.validate : c(t, i) : n.validate = function(e) {
							return function(t, i) {
								var n = t.slice(i);
								return e.test(n) ? n.match(e)[0].length : 0
							}
						}(i.validate), void(s(i.normalize) ? n.normalize = i.normalize : i.normalize ? c(t, i) : n.normalize = function(e, t) {
							t.normalize(e)
						});
						! function(e) {
							return "[object String]" === r(e)
						}(i) ? c(t, i): d.push(t)
					}
				})), d.forEach((function(t) {
					e.__compiled__[e.__schemas__[t]] && (e.__compiled__[t].validate = e.__compiled__[e.__schemas__[t]].validate, e.__compiled__[t].normalize = e.__compiled__[e.__schemas__[t]].normalize)
				})), e.__compiled__[""] = {
					validate: null,
					normalize: function(e, t) {
						t.normalize(e)
					}
				};
				var u = Object.keys(e.__compiled__).filter((function(t) {
					return t.length > 0 && e.__compiled__[t]
				})).map(o).join("|");
				e.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + t.src_ZPCc + "))(" + u + ")", "i"), e.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + t.src_ZPCc + "))(" + u + ")", "ig"), e.re.pretest = RegExp("(" + e.re.schema_test.source + ")|(" + e.re.host_fuzzy_test.source + ")|@", "i"),
					function(e) {
						e.__index__ = -1, e.__text_cache__ = ""
					}(e)
			}

			function h(e, t) {
				var i = e.__index__,
					n = e.__last_index__,
					r = e.__text_cache__.slice(i, n);
				this.schema = e.__schema__.toLowerCase(), this.index = i + t, this.lastIndex = n + t, this.raw = r, this.text = r, this.url = r
			}

			function m(e, t) {
				var i = new h(e, t);
				return e.__compiled__[i.schema].normalize(i, e), i
			}

			function p(e, t) {
				if (!(this instanceof p)) return new p(e, t);
				var i;
				t || (i = e, Object.keys(i || {}).reduce((function(e, t) {
					return e || a.hasOwnProperty(t)
				}), !1) && (t = e, e = {})), this.__opts__ = n({}, a, t), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = n({}, d, e), this.__compiled__ = {}, this.__tlds__ = c, this.__tlds_replaced__ = !1, this.re = {}, u(this)
			}
			p.prototype.add = function(e, t) {
				return this.__schemas__[e] = t, u(this), this
			}, p.prototype.set = function(e) {
				return this.__opts__ = n(this.__opts__, e), this
			}, p.prototype.test = function(e) {
				if (this.__text_cache__ = e, this.__index__ = -1, !e.length) return !1;
				var t, i, n, r, s, o, a, d;
				if (this.re.schema_test.test(e))
					for ((a = this.re.schema_search).lastIndex = 0; null !== (t = a.exec(e));)
						if (r = this.testSchemaAt(e, t[2], a.lastIndex)) {
							this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + r;
							break
						} return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (d = e.search(this.re.host_fuzzy_test)) >= 0 && (this.__index__ < 0 || d < this.__index__) && null !== (i = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) && (s = i.index + i[1].length, (this.__index__ < 0 || s < this.__index__) && (this.__schema__ = "", this.__index__ = s, this.__last_index__ = i.index + i[0].length)), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && e.indexOf("@") >= 0 && null !== (n = e.match(this.re.email_fuzzy)) && (s = n.index + n[1].length, o = n.index + n[0].length, (this.__index__ < 0 || s < this.__index__ || s === this.__index__ && o > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = s, this.__last_index__ = o)), this.__index__ >= 0
			}, p.prototype.pretest = function(e) {
				return this.re.pretest.test(e)
			}, p.prototype.testSchemaAt = function(e, t, i) {
				return this.__compiled__[t.toLowerCase()] ? this.__compiled__[t.toLowerCase()].validate(e, i, this) : 0
			}, p.prototype.match = function(e) {
				var t = 0,
					i = [];
				this.__index__ >= 0 && this.__text_cache__ === e && (i.push(m(this, t)), t = this.__last_index__);
				for (var n = t ? e.slice(t) : e; this.test(n);) i.push(m(this, t)), n = n.slice(this.__last_index__), t += this.__last_index__;
				return i.length ? i : null
			}, p.prototype.tlds = function(e, t) {
				return e = Array.isArray(e) ? e : [e], t ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter((function(e, t, i) {
					return e !== i[t - 1]
				})).reverse(), u(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, u(this), this)
			}, p.prototype.normalize = function(e) {
				e.schema || (e.url = "http://" + e.url), "mailto:" !== e.schema || /^mailto:/i.test(e.url) || (e.url = "mailto:" + e.url)
			}, p.prototype.onCompile = function() {}, e.exports = p
		},
		"./node_modules/linkify-it/lib/re.js": function(e, t, i) {
			"use strict";
			e.exports = function(e) {
				var t = {};
				t.src_Any = i("./node_modules/uc.micro/properties/Any/regex.js").source, t.src_Cc = i("./node_modules/uc.micro/categories/Cc/regex.js").source, t.src_Z = i("./node_modules/uc.micro/categories/Z/regex.js").source, t.src_P = i("./node_modules/uc.micro/categories/P/regex.js").source, t.src_ZPCc = [t.src_Z, t.src_P, t.src_Cc].join("|"), t.src_ZCc = [t.src_Z, t.src_Cc].join("|");
				return t.src_pseudo_letter = "(?:(?![><｜]|" + t.src_ZPCc + ")" + t.src_Any + ")", t.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", t.src_auth = "(?:(?:(?!" + t.src_ZCc + "|[@/\\[\\]()]).)+@)?", t.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", t.src_host_terminator = "(?=$|[><｜]|" + t.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + t.src_ZPCc + "))", t.src_path = "(?:[/?#](?:(?!" + t.src_ZCc + "|[><｜]|[()[\\]{}.,\"'?!\\-]).|\\[(?:(?!" + t.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + t.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + t.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + t.src_ZCc + '|["]).)+\\"|\\\'(?:(?!' + t.src_ZCc + "|[']).)+\\'|\\'(?=" + t.src_pseudo_letter + "|[-]).|\\.{2,3}[a-zA-Z0-9%/]|\\.(?!" + t.src_ZCc + "|[.]).|" + (e && e["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + "\\,(?!" + t.src_ZCc + ").|\\!(?!" + t.src_ZCc + "|[!]).|\\?(?!" + t.src_ZCc + "|[?]).)+|\\/)?", t.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+', t.src_xn = "xn--[a-z0-9\\-]{1,59}", t.src_domain_root = "(?:" + t.src_xn + "|" + t.src_pseudo_letter + "{1,63})", t.src_domain = "(?:" + t.src_xn + "|(?:" + t.src_pseudo_letter + ")|(?:" + t.src_pseudo_letter + "(?:-(?!-)|" + t.src_pseudo_letter + "){0,61}" + t.src_pseudo_letter + "))", t.src_host = "(?:(?:(?:(?:" + t.src_domain + ")\\.)*" + t.src_domain + "))", t.tpl_host_fuzzy = "(?:" + t.src_ip4 + "|(?:(?:(?:" + t.src_domain + ")\\.)+(?:%TLDS%)))", t.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + t.src_domain + ")\\.)+(?:%TLDS%))", t.src_host_strict = t.src_host + t.src_host_terminator, t.tpl_host_fuzzy_strict = t.tpl_host_fuzzy + t.src_host_terminator, t.src_host_port_strict = t.src_host + t.src_port + t.src_host_terminator, t.tpl_host_port_fuzzy_strict = t.tpl_host_fuzzy + t.src_port + t.src_host_terminator, t.tpl_host_port_no_ip_fuzzy_strict = t.tpl_host_no_ip_fuzzy + t.src_port + t.src_host_terminator, t.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + t.src_ZPCc + "|>|$))", t.tpl_email_fuzzy = "(^|[><｜]|\\(|" + t.src_ZCc + ")(" + t.src_email_name + "@" + t.tpl_host_fuzzy_strict + ")", t.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + t.src_ZPCc + "))((?![$+<=>^`|｜])" + t.tpl_host_port_fuzzy_strict + t.src_path + ")", t.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + t.src_ZPCc + "))((?![$+<=>^`|｜])" + t.tpl_host_port_no_ip_fuzzy_strict + t.src_path + ")", t
			}
		},
		"./node_modules/lodash/_baseClamp.js": function(e, t) {
			e.exports = function(e, t, i) {
				return e == e && (void 0 !== i && (e = e <= i ? e : i), void 0 !== t && (e = e >= t ? e : t)), e
			}
		},
		"./node_modules/lodash/_baseReduce.js": function(e, t) {
			e.exports = function(e, t, i, n, r) {
				return r(e, (function(e, r, s) {
					i = n ? (n = !1, e) : t(i, e, r, s)
				})), i
			}
		},
		"./node_modules/lodash/clamp.js": function(e, t, i) {
			var n = i("./node_modules/lodash/_baseClamp.js"),
				r = i("./node_modules/lodash/toNumber.js");
			e.exports = function(e, t, i) {
				return void 0 === i && (i = t, t = void 0), void 0 !== i && (i = (i = r(i)) == i ? i : 0), void 0 !== t && (t = (t = r(t)) == t ? t : 0), n(r(e), t, i)
			}
		},
		"./node_modules/lodash/flatMap.js": function(e, t, i) {
			var n = i("./node_modules/lodash/_baseFlatten.js"),
				r = i("./node_modules/lodash/map.js");
			e.exports = function(e, t) {
				return n(r(e, t), 1)
			}
		},
		"./node_modules/lodash/random.js": function(e, t, i) {
			var n = i("./node_modules/lodash/_baseRandom.js"),
				r = i("./node_modules/lodash/_isIterateeCall.js"),
				s = i("./node_modules/lodash/toFinite.js"),
				o = parseFloat,
				a = Math.min,
				d = Math.random;
			e.exports = function(e, t, i) {
				if (i && "boolean" != typeof i && r(e, t, i) && (t = i = void 0), void 0 === i && ("boolean" == typeof t ? (i = t, t = void 0) : "boolean" == typeof e && (i = e, e = void 0)), void 0 === e && void 0 === t ? (e = 0, t = 1) : (e = s(e), void 0 === t ? (t = e, e = 0) : t = s(t)), e > t) {
					var l = e;
					e = t, t = l
				}
				if (i || e % 1 || t % 1) {
					var c = d();
					return a(e + c * (t - e + o("1e-" + ((c + "").length - 1))), t)
				}
				return n(e, t)
			}
		},
		"./node_modules/lodash/reduce.js": function(e, t, i) {
			var n = i("./node_modules/lodash/_arrayReduce.js"),
				r = i("./node_modules/lodash/_baseEach.js"),
				s = i("./node_modules/lodash/_baseIteratee.js"),
				o = i("./node_modules/lodash/_baseReduce.js"),
				a = i("./node_modules/lodash/isArray.js");
			e.exports = function(e, t, i) {
				var d = a(e) ? n : o,
					l = arguments.length < 3;
				return d(e, s(t, 4), i, l, r)
			}
		},
		"./node_modules/lodash/times.js": function(e, t, i) {
			var n = i("./node_modules/lodash/_baseTimes.js"),
				r = i("./node_modules/lodash/_castFunction.js"),
				s = i("./node_modules/lodash/toInteger.js"),
				o = 9007199254740991,
				a = 4294967295,
				d = Math.min;
			e.exports = function(e, t) {
				if ((e = s(e)) < 1 || e > o) return [];
				var i = a,
					l = d(e, a);
				t = r(t), e -= a;
				for (var c = n(l, t); ++i < e;) t(i);
				return c
			}
		},
		"./node_modules/loglevel/lib/loglevel.js": function(e, t, i) {
			var n, r;
			! function(s, o) {
				"use strict";
				void 0 === (r = "function" == typeof(n = function() {
					var e = function() {},
						t = "undefined",
						i = typeof window !== t && typeof window.navigator !== t && /Trident\/|MSIE /.test(window.navigator.userAgent),
						n = ["trace", "debug", "info", "warn", "error"];

					function r(e, t) {
						var i = e[t];
						if ("function" == typeof i.bind) return i.bind(e);
						try {
							return Function.prototype.bind.call(i, e)
						} catch (n) {
							return function() {
								return Function.prototype.apply.apply(i, [e, arguments])
							}
						}
					}

					function s() {
						console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace()
					}

					function o(t, i) {
						for (var r = 0; r < n.length; r++) {
							var s = n[r];
							this[s] = r < t ? e : this.methodFactory(s, t, i)
						}
						this.log = this.debug
					}

					function a(e, i, n) {
						return function() {
							typeof console !== t && (o.call(this, i, n), this[e].apply(this, arguments))
						}
					}

					function d(n, o, d) {
						return function(n) {
							return "debug" === n && (n = "log"), typeof console !== t && ("trace" === n && i ? s : void 0 !== console[n] ? r(console, n) : void 0 !== console.log ? r(console, "log") : e)
						}(n) || a.apply(this, arguments)
					}

					function l(e, i, r) {
						var s, a = this;
						i = null == i ? "WARN" : i;
						var l = "loglevel";

						function c() {
							var e;
							if (typeof window !== t && l) {
								try {
									e = window.localStorage[l]
								} catch (r) {}
								if (typeof e === t) try {
									var i = window.document.cookie,
										n = i.indexOf(encodeURIComponent(l) + "="); - 1 !== n && (e = /^([^;]+)/.exec(i.slice(n))[1])
								} catch (r) {}
								return void 0 === a.levels[e] && (e = void 0), e
							}
						}
						"string" == typeof e ? l += ":" + e : "symbol" == typeof e && (l = void 0), a.name = e, a.levels = {
							TRACE: 0,
							DEBUG: 1,
							INFO: 2,
							WARN: 3,
							ERROR: 4,
							SILENT: 5
						}, a.methodFactory = r || d, a.getLevel = function() {
							return s
						}, a.setLevel = function(i, r) {
							if ("string" == typeof i && void 0 !== a.levels[i.toUpperCase()] && (i = a.levels[i.toUpperCase()]), !("number" == typeof i && i >= 0 && i <= a.levels.SILENT)) throw "log.setLevel() called with invalid level: " + i;
							if (s = i, !1 !== r && function(e) {
									var i = (n[e] || "silent").toUpperCase();
									if (typeof window !== t && l) {
										try {
											return void(window.localStorage[l] = i)
										} catch (r) {}
										try {
											window.document.cookie = encodeURIComponent(l) + "=" + i + ";"
										} catch (r) {}
									}
								}(i), o.call(a, i, e), typeof console === t && i < a.levels.SILENT) return "No console available for logging"
						}, a.setDefaultLevel = function(e) {
							i = e, c() || a.setLevel(e, !1)
						}, a.resetLevel = function() {
							a.setLevel(i, !1),
								function() {
									if (typeof window !== t && l) {
										try {
											return void window.localStorage.removeItem(l)
										} catch (e) {}
										try {
											window.document.cookie = encodeURIComponent(l) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC"
										} catch (e) {}
									}
								}()
						}, a.enableAll = function(e) {
							a.setLevel(a.levels.TRACE, e)
						}, a.disableAll = function(e) {
							a.setLevel(a.levels.SILENT, e)
						};
						var u = c();
						null == u && (u = i), a.setLevel(u, !1)
					}
					var c = new l,
						u = {};
					c.getLogger = function(e) {
						if ("symbol" != typeof e && "string" != typeof e || "" === e) throw new TypeError("You must supply a name when creating a logger.");
						var t = u[e];
						return t || (t = u[e] = new l(e, c.getLevel(), c.methodFactory)), t
					};
					var h = typeof window !== t ? window.log : void 0;
					return c.noConflict = function() {
						return typeof window !== t && window.log === c && (window.log = h), c
					}, c.getLoggers = function() {
						return u
					}, c.default = c, c
				}) ? n.call(t, i, t, e) : n) || (e.exports = r)
			}()
		},
		"./node_modules/matrix-events-sdk/lib/ExtensibleEvents.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.ExtensibleEvents = void 0;
			var n = i("./node_modules/matrix-events-sdk/lib/NamespacedMap.js"),
				r = i("./node_modules/matrix-events-sdk/lib/InvalidEventError.js"),
				s = i("./node_modules/matrix-events-sdk/lib/interpreters/legacy/MRoomMessage.js"),
				o = i("./node_modules/matrix-events-sdk/lib/interpreters/modern/MMessage.js"),
				a = i("./node_modules/matrix-events-sdk/lib/events/message_types.js"),
				d = i("./node_modules/matrix-events-sdk/lib/events/poll_types.js"),
				l = i("./node_modules/matrix-events-sdk/lib/interpreters/modern/MPoll.js");

			function c(e, t) {
				var i = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
				if (!i) {
					if (Array.isArray(e) || (i = function(e, t) {
							if (!e) return;
							if ("string" == typeof e) return u(e, t);
							var i = Object.prototype.toString.call(e).slice(8, -1);
							"Object" === i && e.constructor && (i = e.constructor.name);
							if ("Map" === i || "Set" === i) return Array.from(e);
							if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return u(e, t)
						}(e)) || t && e && "number" == typeof e.length) {
						i && (e = i);
						var n = 0,
							r = function() {};
						return {
							s: r,
							n: function() {
								return n >= e.length ? {
									done: !0
								} : {
									done: !1,
									value: e[n++]
								}
							},
							e: function(e) {
								throw e
							},
							f: r
						}
					}
					throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
				}
				var s, o = !0,
					a = !1;
				return {
					s: function() {
						i = i.call(e)
					},
					n: function() {
						var e = i.next();
						return o = e.done, e
					},
					e: function(e) {
						a = !0, s = e
					},
					f: function() {
						try {
							o || null == i.return || i.return()
						} finally {
							if (a) throw s
						}
					}
				}
			}

			function u(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var i = 0, n = new Array(t); i < t; i++) n[i] = e[i];
				return n
			}

			function h(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}

			function m(e, t, i) {
				return t in e ? Object.defineProperty(e, t, {
					value: i,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = i, e
			}
			var p = function() {
				function e() {
					! function(e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
					}(this, e), m(this, "interpreters", new n.NamespacedMap([
						[s.LEGACY_M_ROOM_MESSAGE, s.parseMRoomMessage],
						[a.M_MESSAGE, o.parseMMessage],
						[a.M_EMOTE, o.parseMMessage],
						[a.M_NOTICE, o.parseMMessage],
						[d.M_POLL_START, l.parseMPoll],
						[d.M_POLL_RESPONSE, l.parseMPoll],
						[d.M_POLL_END, l.parseMPoll]
					])), m(this, "_unknownInterpretOrder", [a.M_MESSAGE])
				}
				var t, i, u;
				return t = e, u = [{
					key: "defaultInstance",
					get: function() {
						return e._defaultInstance
					}
				}, {
					key: "unknownInterpretOrder",
					get: function() {
						return e.defaultInstance.unknownInterpretOrder
					},
					set: function(t) {
						e.defaultInstance.unknownInterpretOrder = t
					}
				}, {
					key: "registerInterpreter",
					value: function(t, i) {
						e.defaultInstance.registerInterpreter(t, i)
					}
				}, {
					key: "parse",
					value: function(t) {
						return e.defaultInstance.parse(t)
					}
				}], (i = [{
					key: "unknownInterpretOrder",
					get: function() {
						var e;
						return null !== (e = this._unknownInterpretOrder) && void 0 !== e ? e : []
					},
					set: function(e) {
						this._unknownInterpretOrder = e
					}
				}, {
					key: "registerInterpreter",
					value: function(e, t) {
						this.interpreters.set(e, t)
					}
				}, {
					key: "parse",
					value: function(e) {
						try {
							if (this.interpreters.hasNamespaced(e.type)) return this.interpreters.getNamespaced(e.type)(e);
							var t, i = c(this.unknownInterpretOrder);
							try {
								for (i.s(); !(t = i.n()).done;) {
									var n = t.value;
									if (this.interpreters.has(n)) {
										var s = this.interpreters.get(n)(e);
										if (s) return s
									}
								}
							} catch (o) {
								i.e(o)
							} finally {
								i.f()
							}
							return null
						} catch (a) {
							if (a instanceof r.InvalidEventError) return null;
							throw a
						}
					}
				}]) && h(t.prototype, i), u && h(t, u), Object.defineProperty(t, "prototype", {
					writable: !1
				}), e
			}();
			t.ExtensibleEvents = p, m(p, "_defaultInstance", new p)
		},
		"./node_modules/matrix-events-sdk/lib/IPartialEvent.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-events-sdk/lib/InvalidEventError.js": function(e, t, i) {
			"use strict";

			function n(e) {
				return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				})(e)
			}

			function r(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}

			function s(e, t) {
				if (t && ("object" === n(t) || "function" == typeof t)) return t;
				if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
				return function(e) {
					if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return e
				}(e)
			}

			function o(e) {
				var t = "function" == typeof Map ? new Map : void 0;
				return (o = function(e) {
					if (null === e || (i = e, -1 === Function.toString.call(i).indexOf("[native code]"))) return e;
					var i;
					if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
					if (void 0 !== t) {
						if (t.has(e)) return t.get(e);
						t.set(e, n)
					}

					function n() {
						return a(e, arguments, c(this).constructor)
					}
					return n.prototype = Object.create(e.prototype, {
						constructor: {
							value: n,
							enumerable: !1,
							writable: !0,
							configurable: !0
						}
					}), l(n, e)
				})(e)
			}

			function a(e, t, i) {
				return (a = d() ? Reflect.construct : function(e, t, i) {
					var n = [null];
					n.push.apply(n, t);
					var r = new(Function.bind.apply(e, n));
					return i && l(r, i.prototype), r
				}).apply(null, arguments)
			}

			function d() {
				if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
				if (Reflect.construct.sham) return !1;
				if ("function" == typeof Proxy) return !0;
				try {
					return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
				} catch (e) {
					return !1
				}
			}

			function l(e, t) {
				return (l = Object.setPrototypeOf || function(e, t) {
					return e.__proto__ = t, e
				})(e, t)
			}

			function c(e) {
				return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
					return e.__proto__ || Object.getPrototypeOf(e)
				})(e)
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.InvalidEventError = void 0;
			var u = function(e) {
				! function(e, t) {
					if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
					e.prototype = Object.create(t && t.prototype, {
						constructor: {
							value: e,
							writable: !0,
							configurable: !0
						}
					}), Object.defineProperty(e, "prototype", {
						writable: !1
					}), t && l(e, t)
				}(h, e);
				var t, i, n, o, a, u = (t = h, i = d(), function() {
					var e, n = c(t);
					if (i) {
						var r = c(this).constructor;
						e = Reflect.construct(n, arguments, r)
					} else e = n.apply(this, arguments);
					return s(this, e)
				});

				function h(e) {
					return function(e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
					}(this, h), u.call(this, e)
				}
				return n = h, o && r(n.prototype, o), a && r(n, a), Object.defineProperty(n, "prototype", {
					writable: !1
				}), n
			}(o(Error));
			t.InvalidEventError = u
		},
		"./node_modules/matrix-events-sdk/lib/NamespacedMap.js": function(e, t, i) {
			"use strict";

			function n(e, t) {
				var i = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
				if (!i) {
					if (Array.isArray(e) || (i = function(e, t) {
							if (!e) return;
							if ("string" == typeof e) return r(e, t);
							var i = Object.prototype.toString.call(e).slice(8, -1);
							"Object" === i && e.constructor && (i = e.constructor.name);
							if ("Map" === i || "Set" === i) return Array.from(e);
							if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return r(e, t)
						}(e)) || t && e && "number" == typeof e.length) {
						i && (e = i);
						var n = 0,
							s = function() {};
						return {
							s,
							n: function() {
								return n >= e.length ? {
									done: !0
								} : {
									done: !1,
									value: e[n++]
								}
							},
							e: function(e) {
								throw e
							},
							f: s
						}
					}
					throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
				}
				var o, a = !0,
					d = !1;
				return {
					s: function() {
						i = i.call(e)
					},
					n: function() {
						var e = i.next();
						return a = e.done, e
					},
					e: function(e) {
						d = !0, o = e
					},
					f: function() {
						try {
							a || null == i.return || i.return()
						} finally {
							if (d) throw o
						}
					}
				}
			}

			function r(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var i = 0, n = new Array(t); i < t; i++) n[i] = e[i];
				return n
			}

			function s(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.NamespacedMap = void 0;
			var o = function() {
				function e(t) {
					var i, r, s;
					if (function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, e), i = this, r = "internalMap", s = new Map, r in i ? Object.defineProperty(i, r, {
							value: s,
							enumerable: !0,
							configurable: !0,
							writable: !0
						}) : i[r] = s, t) {
						var o, a = n(t);
						try {
							for (a.s(); !(o = a.n()).done;) {
								var d = o.value;
								this.set(d[0], d[1])
							}
						} catch (l) {
							a.e(l)
						} finally {
							a.f()
						}
					}
				}
				var t, i, r;
				return t = e, (i = [{
					key: "get",
					value: function(e) {
						return e.name && this.internalMap.has(e.name) ? this.internalMap.get(e.name) : e.altName && this.internalMap.has(e.altName) ? this.internalMap.get(e.altName) : null
					}
				}, {
					key: "set",
					value: function(e, t) {
						e.name && this.internalMap.set(e.name, t), e.altName && this.internalMap.set(e.altName, t)
					}
				}, {
					key: "has",
					value: function(e) {
						return !!this.get(e)
					}
				}, {
					key: "delete",
					value: function(e) {
						e.name && this.internalMap.delete(e.name), e.altName && this.internalMap.delete(e.altName)
					}
				}, {
					key: "hasNamespaced",
					value: function(e) {
						return this.internalMap.has(e)
					}
				}, {
					key: "getNamespaced",
					value: function(e) {
						return this.internalMap.get(e)
					}
				}]) && s(t.prototype, i), r && s(t, r), Object.defineProperty(t, "prototype", {
					writable: !1
				}), e
			}();
			t.NamespacedMap = o
		},
		"./node_modules/matrix-events-sdk/lib/NamespacedValue.js": function(e, t, i) {
			"use strict";

			function n(e) {
				return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				})(e)
			}

			function r(e, t) {
				return (r = Object.setPrototypeOf || function(e, t) {
					return e.__proto__ = t, e
				})(e, t)
			}

			function s(e) {
				var t = function() {
					if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
					if (Reflect.construct.sham) return !1;
					if ("function" == typeof Proxy) return !0;
					try {
						return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
					} catch (e) {
						return !1
					}
				}();
				return function() {
					var i, n = a(e);
					if (t) {
						var r = a(this).constructor;
						i = Reflect.construct(n, arguments, r)
					} else i = n.apply(this, arguments);
					return o(this, i)
				}
			}

			function o(e, t) {
				if (t && ("object" === n(t) || "function" == typeof t)) return t;
				if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
				return function(e) {
					if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return e
				}(e)
			}

			function a(e) {
				return (a = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
					return e.__proto__ || Object.getPrototypeOf(e)
				})(e)
			}

			function d(e, t) {
				if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
			}

			function l(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}

			function c(e, t, i) {
				return t && l(e.prototype, t), i && l(e, i), Object.defineProperty(e, "prototype", {
					writable: !1
				}), e
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.UnstableValue = t.NamespacedValue = void 0;
			var u = function() {
				function e(t, i) {
					if (d(this, e), this.stable = t, this.unstable = i, !this.unstable && !this.stable) throw new Error("One of stable or unstable values must be supplied")
				}
				return c(e, [{
					key: "name",
					get: function() {
						return this.stable ? this.stable : this.unstable
					}
				}, {
					key: "altName",
					get: function() {
						return this.stable ? this.unstable : null
					}
				}, {
					key: "matches",
					value: function(e) {
						return !!this.name && this.name === e || !!this.altName && this.altName === e
					}
				}, {
					key: "findIn",
					value: function(e) {
						var t;
						return this.name && (t = null == e ? void 0 : e[this.name]), !t && this.altName && (t = null == e ? void 0 : e[this.altName]), t
					}
				}, {
					key: "includedIn",
					value: function(e) {
						var t = !1;
						return this.name && (t = e.includes(this.name)), !t && this.altName && (t = e.includes(this.altName)), t
					}
				}]), e
			}();
			t.NamespacedValue = u;
			var h = function(e) {
				! function(e, t) {
					if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
					e.prototype = Object.create(t && t.prototype, {
						constructor: {
							value: e,
							writable: !0,
							configurable: !0
						}
					}), Object.defineProperty(e, "prototype", {
						writable: !1
					}), t && r(e, t)
				}(i, e);
				var t = s(i);

				function i(e, n) {
					var r;
					if (d(this, i), !(r = t.call(this, e, n)).unstable) throw new Error("Unstable value must be supplied");
					return r
				}
				return c(i, [{
					key: "name",
					get: function() {
						return this.unstable
					}
				}, {
					key: "altName",
					get: function() {
						return this.stable
					}
				}]), i
			}(u);
			t.UnstableValue = h
		},
		"./node_modules/matrix-events-sdk/lib/events/EmoteEvent.js": function(e, t, i) {
			"use strict";

			function n(e) {
				return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				})(e)
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.EmoteEvent = void 0;
			var r = i("./node_modules/matrix-events-sdk/lib/events/MessageEvent.js"),
				s = i("./node_modules/matrix-events-sdk/lib/events/message_types.js"),
				o = i("./node_modules/matrix-events-sdk/lib/utility/events.js");

			function a(e, t, i) {
				return t in e ? Object.defineProperty(e, t, {
					value: i,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = i, e
			}

			function d(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}

			function l() {
				return (l = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, i) {
					var n = c(e, t);
					if (n) {
						var r = Object.getOwnPropertyDescriptor(n, t);
						return r.get ? r.get.call(arguments.length < 3 ? e : i) : r.value
					}
				}).apply(this, arguments)
			}

			function c(e, t) {
				for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = p(e)););
				return e
			}

			function u(e, t) {
				return (u = Object.setPrototypeOf || function(e, t) {
					return e.__proto__ = t, e
				})(e, t)
			}

			function h(e) {
				var t = function() {
					if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
					if (Reflect.construct.sham) return !1;
					if ("function" == typeof Proxy) return !0;
					try {
						return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
					} catch (e) {
						return !1
					}
				}();
				return function() {
					var i, n = p(e);
					if (t) {
						var r = p(this).constructor;
						i = Reflect.construct(n, arguments, r)
					} else i = n.apply(this, arguments);
					return m(this, i)
				}
			}

			function m(e, t) {
				if (t && ("object" === n(t) || "function" == typeof t)) return t;
				if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
				return function(e) {
					if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return e
				}(e)
			}

			function p(e) {
				return (p = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
					return e.__proto__ || Object.getPrototypeOf(e)
				})(e)
			}
			var g = function(e) {
				! function(e, t) {
					if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
					e.prototype = Object.create(t && t.prototype, {
						constructor: {
							value: e,
							writable: !0,
							configurable: !0
						}
					}), Object.defineProperty(e, "prototype", {
						writable: !1
					}), t && u(e, t)
				}(c, e);
				var t, i, n, r = h(c);

				function c(e) {
					return function(e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
					}(this, c), r.call(this, e)
				}
				return t = c, n = [{
					key: "from",
					value: function(e, t) {
						var i;
						return new c({
							type: s.M_EMOTE.name,
							content: (i = {}, a(i, s.M_TEXT.name, e), a(i, s.M_HTML.name, t), i)
						})
					}
				}], (i = [{
					key: "isEmote",
					get: function() {
						return !0
					}
				}, {
					key: "isEquivalentTo",
					value: function(e) {
						return (0, o.isEventTypeSame)(e, s.M_EMOTE) || l(p(c.prototype), "isEquivalentTo", this).call(this, e)
					}
				}, {
					key: "serialize",
					value: function() {
						var e = l(p(c.prototype), "serialize", this).call(this);
						return e.content.msgtype = "m.emote", e
					}
				}]) && d(t.prototype, i), n && d(t, n), Object.defineProperty(t, "prototype", {
					writable: !1
				}), c
			}(r.MessageEvent);
			t.EmoteEvent = g
		},
		"./node_modules/matrix-events-sdk/lib/events/ExtensibleEvent.js": function(e, t, i) {
			"use strict";

			function n(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.ExtensibleEvent = void 0;
			var r = function() {
				function e(t) {
					! function(e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
					}(this, e), this.wireFormat = t
				}
				var t, i, r;
				return t = e, (i = [{
					key: "wireContent",
					get: function() {
						return this.wireFormat.content
					}
				}]) && n(t.prototype, i), r && n(t, r), Object.defineProperty(t, "prototype", {
					writable: !1
				}), e
			}();
			t.ExtensibleEvent = r
		},
		"./node_modules/matrix-events-sdk/lib/events/MessageEvent.js": function(e, t, i) {
			"use strict";

			function n(e) {
				return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				})(e)
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.MessageEvent = void 0;
			var r = i("./node_modules/matrix-events-sdk/lib/events/ExtensibleEvent.js"),
				s = i("./node_modules/matrix-events-sdk/lib/types.js"),
				o = i("./node_modules/matrix-events-sdk/lib/InvalidEventError.js"),
				a = i("./node_modules/matrix-events-sdk/lib/events/message_types.js"),
				d = i("./node_modules/matrix-events-sdk/lib/utility/events.js");

			function l(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function c(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? l(Object(i), !0).forEach((function(t) {
						v(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : l(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}

			function u(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}

			function h(e, t) {
				return (h = Object.setPrototypeOf || function(e, t) {
					return e.__proto__ = t, e
				})(e, t)
			}

			function m(e) {
				var t = function() {
					if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
					if (Reflect.construct.sham) return !1;
					if ("function" == typeof Proxy) return !0;
					try {
						return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
					} catch (e) {
						return !1
					}
				}();
				return function() {
					var i, n = f(e);
					if (t) {
						var r = f(this).constructor;
						i = Reflect.construct(n, arguments, r)
					} else i = n.apply(this, arguments);
					return p(this, i)
				}
			}

			function p(e, t) {
				if (t && ("object" === n(t) || "function" == typeof t)) return t;
				if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
				return g(e)
			}

			function g(e) {
				if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				return e
			}

			function f(e) {
				return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
					return e.__proto__ || Object.getPrototypeOf(e)
				})(e)
			}

			function v(e, t, i) {
				return t in e ? Object.defineProperty(e, t, {
					value: i,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = i, e
			}
			var y = function(e) {
				! function(e, t) {
					if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
					e.prototype = Object.create(t && t.prototype, {
						constructor: {
							value: e,
							writable: !0,
							configurable: !0
						}
					}), Object.defineProperty(e, "prototype", {
						writable: !1
					}), t && h(e, t)
				}(l, e);
				var t, i, n, r = m(l);

				function l(e) {
					var t;
					! function(e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
					}(this, l), v(g(t = r.call(this, e)), "text", void 0), v(g(t), "html", void 0), v(g(t), "renderings", void 0);
					var i = a.M_MESSAGE.findIn(t.wireContent),
						n = a.M_TEXT.findIn(t.wireContent),
						d = a.M_HTML.findIn(t.wireContent);
					if ((0, s.isProvided)(i)) {
						if (!Array.isArray(i)) throw new o.InvalidEventError("m.message contents must be an array");
						var c = i.find((function(e) {
								return !(0, s.isProvided)(e.mimetype) || "text/plain" === e.mimetype
							})),
							u = i.find((function(e) {
								return "text/html" === e.mimetype
							}));
						if (!c) throw new o.InvalidEventError("m.message is missing a plain text representation");
						t.text = c.body, t.html = null == u ? void 0 : u.body, t.renderings = i
					} else {
						if (!(0, s.isOptionalAString)(n)) throw new o.InvalidEventError("Missing textual representation for event");
						t.text = n, t.html = d, t.renderings = [{
							body: n,
							mimetype: "text/plain"
						}], t.html && t.renderings.push({
							body: t.html,
							mimetype: "text/html"
						})
					}
					return t
				}
				return t = l, n = [{
					key: "from",
					value: function(e, t) {
						var i;
						return new l({
							type: a.M_MESSAGE.name,
							content: (i = {}, v(i, a.M_TEXT.name, e), v(i, a.M_HTML.name, t), i)
						})
					}
				}], (i = [{
					key: "isEmote",
					get: function() {
						return a.M_EMOTE.matches(this.wireFormat.type) || (0, s.isProvided)(a.M_EMOTE.findIn(this.wireFormat.content))
					}
				}, {
					key: "isNotice",
					get: function() {
						return a.M_NOTICE.matches(this.wireFormat.type) || (0, s.isProvided)(a.M_NOTICE.findIn(this.wireFormat.content))
					}
				}, {
					key: "isEquivalentTo",
					value: function(e) {
						return (0, d.isEventTypeSame)(e, a.M_MESSAGE)
					}
				}, {
					key: "serializeMMessageOnly",
					value: function() {
						var e = v({}, a.M_MESSAGE.name, this.renderings);
						if (1 === this.renderings.length) {
							var t = this.renderings[0].mimetype;
							void 0 !== t && "text/plain" !== t || (e = v({}, a.M_TEXT.name, this.renderings[0].body))
						}
						return e
					}
				}, {
					key: "serialize",
					value: function() {
						var e;
						return {
							type: "m.room.message",
							content: c(c({}, this.serializeMMessageOnly()), {}, {
								body: this.text,
								msgtype: "m.text",
								format: this.html ? "org.matrix.custom.html" : void 0,
								formatted_body: null !== (e = this.html) && void 0 !== e ? e : void 0
							})
						}
					}
				}]) && u(t.prototype, i), n && u(t, n), Object.defineProperty(t, "prototype", {
					writable: !1
				}), l
			}(r.ExtensibleEvent);
			t.MessageEvent = y
		},
		"./node_modules/matrix-events-sdk/lib/events/NoticeEvent.js": function(e, t, i) {
			"use strict";

			function n(e) {
				return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				})(e)
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.NoticeEvent = void 0;
			var r = i("./node_modules/matrix-events-sdk/lib/events/MessageEvent.js"),
				s = i("./node_modules/matrix-events-sdk/lib/events/message_types.js"),
				o = i("./node_modules/matrix-events-sdk/lib/utility/events.js");

			function a(e, t, i) {
				return t in e ? Object.defineProperty(e, t, {
					value: i,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = i, e
			}

			function d(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}

			function l() {
				return (l = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, i) {
					var n = c(e, t);
					if (n) {
						var r = Object.getOwnPropertyDescriptor(n, t);
						return r.get ? r.get.call(arguments.length < 3 ? e : i) : r.value
					}
				}).apply(this, arguments)
			}

			function c(e, t) {
				for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = p(e)););
				return e
			}

			function u(e, t) {
				return (u = Object.setPrototypeOf || function(e, t) {
					return e.__proto__ = t, e
				})(e, t)
			}

			function h(e) {
				var t = function() {
					if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
					if (Reflect.construct.sham) return !1;
					if ("function" == typeof Proxy) return !0;
					try {
						return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
					} catch (e) {
						return !1
					}
				}();
				return function() {
					var i, n = p(e);
					if (t) {
						var r = p(this).constructor;
						i = Reflect.construct(n, arguments, r)
					} else i = n.apply(this, arguments);
					return m(this, i)
				}
			}

			function m(e, t) {
				if (t && ("object" === n(t) || "function" == typeof t)) return t;
				if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
				return function(e) {
					if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return e
				}(e)
			}

			function p(e) {
				return (p = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
					return e.__proto__ || Object.getPrototypeOf(e)
				})(e)
			}
			var g = function(e) {
				! function(e, t) {
					if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
					e.prototype = Object.create(t && t.prototype, {
						constructor: {
							value: e,
							writable: !0,
							configurable: !0
						}
					}), Object.defineProperty(e, "prototype", {
						writable: !1
					}), t && u(e, t)
				}(c, e);
				var t, i, n, r = h(c);

				function c(e) {
					return function(e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
					}(this, c), r.call(this, e)
				}
				return t = c, n = [{
					key: "from",
					value: function(e, t) {
						var i;
						return new c({
							type: s.M_NOTICE.name,
							content: (i = {}, a(i, s.M_TEXT.name, e), a(i, s.M_HTML.name, t), i)
						})
					}
				}], (i = [{
					key: "isNotice",
					get: function() {
						return !0
					}
				}, {
					key: "isEquivalentTo",
					value: function(e) {
						return (0, o.isEventTypeSame)(e, s.M_NOTICE) || l(p(c.prototype), "isEquivalentTo", this).call(this, e)
					}
				}, {
					key: "serialize",
					value: function() {
						var e = l(p(c.prototype), "serialize", this).call(this);
						return e.content.msgtype = "m.notice", e
					}
				}]) && d(t.prototype, i), n && d(t, n), Object.defineProperty(t, "prototype", {
					writable: !1
				}), c
			}(r.MessageEvent);
			t.NoticeEvent = g
		},
		"./node_modules/matrix-events-sdk/lib/events/PollEndEvent.js": function(e, t, i) {
			"use strict";

			function n(e) {
				return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				})(e)
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.PollEndEvent = void 0;
			var r = i("./node_modules/matrix-events-sdk/lib/events/poll_types.js"),
				s = i("./node_modules/matrix-events-sdk/lib/InvalidEventError.js"),
				o = i("./node_modules/matrix-events-sdk/lib/events/relationship_types.js"),
				a = i("./node_modules/matrix-events-sdk/lib/events/MessageEvent.js"),
				d = i("./node_modules/matrix-events-sdk/lib/events/message_types.js"),
				l = i("./node_modules/matrix-events-sdk/lib/utility/events.js");

			function c(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function u(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? c(Object(i), !0).forEach((function(t) {
						y(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : c(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}

			function h(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}

			function m(e, t) {
				return (m = Object.setPrototypeOf || function(e, t) {
					return e.__proto__ = t, e
				})(e, t)
			}

			function p(e) {
				var t = function() {
					if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
					if (Reflect.construct.sham) return !1;
					if ("function" == typeof Proxy) return !0;
					try {
						return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
					} catch (e) {
						return !1
					}
				}();
				return function() {
					var i, n = v(e);
					if (t) {
						var r = v(this).constructor;
						i = Reflect.construct(n, arguments, r)
					} else i = n.apply(this, arguments);
					return g(this, i)
				}
			}

			function g(e, t) {
				if (t && ("object" === n(t) || "function" == typeof t)) return t;
				if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
				return f(e)
			}

			function f(e) {
				if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				return e
			}

			function v(e) {
				return (v = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
					return e.__proto__ || Object.getPrototypeOf(e)
				})(e)
			}

			function y(e, t, i) {
				return t in e ? Object.defineProperty(e, t, {
					value: i,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = i, e
			}
			var b = function(e) {
				! function(e, t) {
					if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
					e.prototype = Object.create(t && t.prototype, {
						constructor: {
							value: e,
							writable: !0,
							configurable: !0
						}
					}), Object.defineProperty(e, "prototype", {
						writable: !1
					}), t && m(e, t)
				}(g, e);
				var t, i, n, c = p(g);

				function g(e) {
					var t;
					! function(e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
					}(this, g), y(f(t = c.call(this, e)), "pollEventId", void 0), y(f(t), "closingMessage", void 0);
					var i = t.wireContent["m.relates_to"];
					if (!o.REFERENCE_RELATION.matches(null == i ? void 0 : i.rel_type) || "string" != typeof(null == i ? void 0 : i.event_id)) throw new s.InvalidEventError("Relationship must be a reference to an event");
					return t.pollEventId = i.event_id, t.closingMessage = new a.MessageEvent(t.wireFormat), t
				}
				return t = g, n = [{
					key: "from",
					value: function(e, t) {
						var i;
						return new g({
							type: r.M_POLL_END.name,
							content: (i = {
								"m.relates_to": {
									rel_type: o.REFERENCE_RELATION.name,
									event_id: e
								}
							}, y(i, r.M_POLL_END.name, {}), y(i, d.M_TEXT.name, t), i)
						})
					}
				}], (i = [{
					key: "isEquivalentTo",
					value: function(e) {
						return (0, l.isEventTypeSame)(e, r.M_POLL_END)
					}
				}, {
					key: "serialize",
					value: function() {
						return {
							type: r.M_POLL_END.name,
							content: u(y({
								"m.relates_to": {
									rel_type: o.REFERENCE_RELATION.name,
									event_id: this.pollEventId
								}
							}, r.M_POLL_END.name, {}), this.closingMessage.serialize().content)
						}
					}
				}]) && h(t.prototype, i), n && h(t, n), Object.defineProperty(t, "prototype", {
					writable: !1
				}), g
			}(i("./node_modules/matrix-events-sdk/lib/events/ExtensibleEvent.js").ExtensibleEvent);
			t.PollEndEvent = b
		},
		"./node_modules/matrix-events-sdk/lib/events/PollResponseEvent.js": function(e, t, i) {
			"use strict";

			function n(e) {
				return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				})(e)
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.PollResponseEvent = void 0;
			var r = i("./node_modules/matrix-events-sdk/lib/events/ExtensibleEvent.js"),
				s = i("./node_modules/matrix-events-sdk/lib/events/poll_types.js"),
				o = i("./node_modules/matrix-events-sdk/lib/InvalidEventError.js"),
				a = i("./node_modules/matrix-events-sdk/lib/events/relationship_types.js"),
				d = i("./node_modules/matrix-events-sdk/lib/utility/events.js");

			function l(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}

			function c(e, t) {
				return (c = Object.setPrototypeOf || function(e, t) {
					return e.__proto__ = t, e
				})(e, t)
			}

			function u(e) {
				var t = function() {
					if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
					if (Reflect.construct.sham) return !1;
					if ("function" == typeof Proxy) return !0;
					try {
						return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
					} catch (e) {
						return !1
					}
				}();
				return function() {
					var i, n = p(e);
					if (t) {
						var r = p(this).constructor;
						i = Reflect.construct(n, arguments, r)
					} else i = n.apply(this, arguments);
					return h(this, i)
				}
			}

			function h(e, t) {
				if (t && ("object" === n(t) || "function" == typeof t)) return t;
				if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
				return m(e)
			}

			function m(e) {
				if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				return e
			}

			function p(e) {
				return (p = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
					return e.__proto__ || Object.getPrototypeOf(e)
				})(e)
			}

			function g(e, t, i) {
				return t in e ? Object.defineProperty(e, t, {
					value: i,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = i, e
			}
			var f = function(e) {
				! function(e, t) {
					if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
					e.prototype = Object.create(t && t.prototype, {
						constructor: {
							value: e,
							writable: !0,
							configurable: !0
						}
					}), Object.defineProperty(e, "prototype", {
						writable: !1
					}), t && c(e, t)
				}(h, e);
				var t, i, n, r = u(h);

				function h(e) {
					var t;
					! function(e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
					}(this, h), g(m(t = r.call(this, e)), "internalAnswerIds", void 0), g(m(t), "internalSpoiled", void 0), g(m(t), "pollEventId", void 0);
					var i = t.wireContent["m.relates_to"];
					if (!a.REFERENCE_RELATION.matches(null == i ? void 0 : i.rel_type) || "string" != typeof(null == i ? void 0 : i.event_id)) throw new o.InvalidEventError("Relationship must be a reference to an event");
					return t.pollEventId = i.event_id, t.validateAgainst(null), t
				}
				return t = h, n = [{
					key: "from",
					value: function(e, t) {
						return new h({
							type: s.M_POLL_RESPONSE.name,
							content: g({
								"m.relates_to": {
									rel_type: a.REFERENCE_RELATION.name,
									event_id: t
								}
							}, s.M_POLL_RESPONSE.name, {
								answers: e
							})
						})
					}
				}], (i = [{
					key: "answerIds",
					get: function() {
						return this.internalAnswerIds
					}
				}, {
					key: "spoiled",
					get: function() {
						return this.internalSpoiled
					}
				}, {
					key: "validateAgainst",
					value: function(e) {
						var t = s.M_POLL_RESPONSE.findIn(this.wireContent);
						if (!Array.isArray(null == t ? void 0 : t.answers)) return this.internalSpoiled = !0, void(this.internalAnswerIds = []);
						var i = t.answers;
						if (i.some((function(e) {
								return "string" != typeof e
							})) || 0 === i.length) return this.internalSpoiled = !0, void(this.internalAnswerIds = []);
						if (e) {
							if (i.some((function(t) {
									return !e.answers.some((function(e) {
										return e.id === t
									}))
								}))) return this.internalSpoiled = !0, void(this.internalAnswerIds = []);
							i = i.slice(0, e.maxSelections)
						}
						this.internalAnswerIds = i, this.internalSpoiled = !1
					}
				}, {
					key: "isEquivalentTo",
					value: function(e) {
						return (0, d.isEventTypeSame)(e, s.M_POLL_RESPONSE)
					}
				}, {
					key: "serialize",
					value: function() {
						return {
							type: s.M_POLL_RESPONSE.name,
							content: g({
								"m.relates_to": {
									rel_type: a.REFERENCE_RELATION.name,
									event_id: this.pollEventId
								}
							}, s.M_POLL_RESPONSE.name, {
								answers: this.spoiled ? void 0 : this.answerIds
							})
						}
					}
				}]) && l(t.prototype, i), n && l(t, n), Object.defineProperty(t, "prototype", {
					writable: !1
				}), h
			}(r.ExtensibleEvent);
			t.PollResponseEvent = f
		},
		"./node_modules/matrix-events-sdk/lib/events/PollStartEvent.js": function(e, t, i) {
			"use strict";

			function n(e) {
				return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				})(e)
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.PollStartEvent = t.PollAnswerSubevent = void 0;
			var r = i("./node_modules/matrix-events-sdk/lib/events/poll_types.js"),
				s = i("./node_modules/matrix-events-sdk/lib/events/MessageEvent.js"),
				o = i("./node_modules/matrix-events-sdk/lib/events/message_types.js"),
				a = i("./node_modules/matrix-events-sdk/lib/InvalidEventError.js"),
				d = i("./node_modules/matrix-events-sdk/lib/NamespacedValue.js"),
				l = i("./node_modules/matrix-events-sdk/lib/utility/events.js"),
				c = i("./node_modules/matrix-events-sdk/lib/events/ExtensibleEvent.js");

			function u(e) {
				return function(e) {
					if (Array.isArray(e)) return h(e)
				}(e) || function(e) {
					if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
				}(e) || function(e, t) {
					if (!e) return;
					if ("string" == typeof e) return h(e, t);
					var i = Object.prototype.toString.call(e).slice(8, -1);
					"Object" === i && e.constructor && (i = e.constructor.name);
					if ("Map" === i || "Set" === i) return Array.from(e);
					if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return h(e, t)
				}(e) || function() {
					throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
				}()
			}

			function h(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var i = 0, n = new Array(t); i < t; i++) n[i] = e[i];
				return n
			}

			function m(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function p(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? m(Object(i), !0).forEach((function(t) {
						k(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : m(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}

			function g(e, t) {
				if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
			}

			function f(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}

			function v(e, t, i) {
				return t && f(e.prototype, t), i && f(e, i), Object.defineProperty(e, "prototype", {
					writable: !1
				}), e
			}

			function y(e, t) {
				if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
				e.prototype = Object.create(t && t.prototype, {
					constructor: {
						value: e,
						writable: !0,
						configurable: !0
					}
				}), Object.defineProperty(e, "prototype", {
					writable: !1
				}), t && b(e, t)
			}

			function b(e, t) {
				return (b = Object.setPrototypeOf || function(e, t) {
					return e.__proto__ = t, e
				})(e, t)
			}

			function _(e) {
				var t = function() {
					if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
					if (Reflect.construct.sham) return !1;
					if ("function" == typeof Proxy) return !0;
					try {
						return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
					} catch (e) {
						return !1
					}
				}();
				return function() {
					var i, n = w(e);
					if (t) {
						var r = w(this).constructor;
						i = Reflect.construct(n, arguments, r)
					} else i = n.apply(this, arguments);
					return S(this, i)
				}
			}

			function S(e, t) {
				if (t && ("object" === n(t) || "function" == typeof t)) return t;
				if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
				return E(e)
			}

			function E(e) {
				if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				return e
			}

			function w(e) {
				return (w = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
					return e.__proto__ || Object.getPrototypeOf(e)
				})(e)
			}

			function k(e, t, i) {
				return t in e ? Object.defineProperty(e, t, {
					value: i,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = i, e
			}
			var T = function(e) {
				y(i, e);
				var t = _(i);

				function i(e) {
					var n;
					g(this, i), k(E(n = t.call(this, e)), "id", void 0);
					var r = e.content.id;
					if (!r || "string" != typeof r) throw new a.InvalidEventError("Answer ID must be a non-empty string");
					return n.id = r, n
				}
				return v(i, [{
					key: "serialize",
					value: function() {
						return {
							type: "org.matrix.sdk.poll.answer",
							content: p({
								id: this.id
							}, this.serializeMMessageOnly())
						}
					}
				}], [{
					key: "from",
					value: function(e, t) {
						return new i({
							type: "org.matrix.sdk.poll.answer",
							content: k({
								id: e
							}, o.M_TEXT.name, t)
						})
					}
				}]), i
			}(s.MessageEvent);
			t.PollAnswerSubevent = T;
			var I = function(e) {
				y(i, e);
				var t = _(i);

				function i(e) {
					var n;
					g(this, i), k(E(n = t.call(this, e)), "question", void 0), k(E(n), "kind", void 0), k(E(n), "rawKind", void 0), k(E(n), "maxSelections", void 0), k(E(n), "answers", void 0);
					var o = r.M_POLL_START.findIn(n.wireContent);
					if (!o.question) throw new a.InvalidEventError("A question is required");
					if (n.question = new s.MessageEvent({
							type: "org.matrix.sdk.poll.question",
							content: o.question
						}), n.rawKind = o.kind, r.M_POLL_KIND_DISCLOSED.matches(n.rawKind) ? n.kind = r.M_POLL_KIND_DISCLOSED : n.kind = r.M_POLL_KIND_UNDISCLOSED, n.maxSelections = Number.isFinite(o.max_selections) && o.max_selections > 0 ? o.max_selections : 1, !Array.isArray(o.answers)) throw new a.InvalidEventError("Poll answers must be an array");
					var d = o.answers.slice(0, 20).map((function(e) {
						return new T({
							type: "org.matrix.sdk.poll.answer",
							content: e
						})
					}));
					if (d.length <= 0) throw new a.InvalidEventError("No answers available");
					return n.answers = d, n
				}
				return v(i, [{
					key: "isEquivalentTo",
					value: function(e) {
						return (0, l.isEventTypeSame)(e, r.M_POLL_START)
					}
				}, {
					key: "serialize",
					value: function() {
						var e;
						return {
							type: r.M_POLL_START.name,
							content: (e = {}, k(e, r.M_POLL_START.name, {
								question: this.question.serialize().content,
								kind: this.rawKind,
								max_selections: this.maxSelections,
								answers: this.answers.map((function(e) {
									return e.serialize().content
								}))
							}), k(e, o.M_TEXT.name, "".concat(this.question.text, "\n").concat(this.answers.map((function(e, t) {
								return "".concat(t + 1, ". ").concat(e.text)
							})).join("\n"))), e)
						}
					}
				}], [{
					key: "from",
					value: function(e, t, n) {
						var s, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
						return new i({
							type: r.M_POLL_START.name,
							content: (s = {}, k(s, o.M_TEXT.name, e), k(s, r.M_POLL_START.name, {
								question: k({}, o.M_TEXT.name, e),
								kind: n instanceof d.NamespacedValue ? n.name : n,
								max_selections: a,
								answers: t.map((function(e) {
									return k({
										id: R()
									}, o.M_TEXT.name, e)
								}))
							}), s)
						})
					}
				}]), i
			}(c.ExtensibleEvent);
			t.PollStartEvent = I;
			var C = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

			function R() {
				return u(Array(16)).map((function() {
					return C.charAt(Math.floor(Math.random() * C.length))
				})).join("")
			}
		},
		"./node_modules/matrix-events-sdk/lib/events/message_types.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.M_TEXT = t.M_NOTICE = t.M_MESSAGE = t.M_HTML = t.M_EMOTE = void 0;
			var n = i("./node_modules/matrix-events-sdk/lib/NamespacedValue.js"),
				r = new n.UnstableValue("m.message", "org.matrix.msc1767.message");
			t.M_MESSAGE = r;
			var s = new n.UnstableValue("m.text", "org.matrix.msc1767.text");
			t.M_TEXT = s;
			var o = new n.UnstableValue("m.html", "org.matrix.msc1767.html");
			t.M_HTML = o;
			var a = new n.UnstableValue("m.emote", "org.matrix.msc1767.emote");
			t.M_EMOTE = a;
			var d = new n.UnstableValue("m.notice", "org.matrix.msc1767.notice");
			t.M_NOTICE = d
		},
		"./node_modules/matrix-events-sdk/lib/events/poll_types.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.M_POLL_START = t.M_POLL_RESPONSE = t.M_POLL_KIND_UNDISCLOSED = t.M_POLL_KIND_DISCLOSED = t.M_POLL_END = void 0;
			var n = i("./node_modules/matrix-events-sdk/lib/NamespacedValue.js"),
				r = new n.UnstableValue("m.poll.disclosed", "org.matrix.msc3381.poll.disclosed");
			t.M_POLL_KIND_DISCLOSED = r;
			var s = new n.UnstableValue("m.poll.undisclosed", "org.matrix.msc3381.poll.undisclosed");
			t.M_POLL_KIND_UNDISCLOSED = s;
			var o = new n.UnstableValue("m.poll.start", "org.matrix.msc3381.poll.start");
			t.M_POLL_START = o;
			var a = new n.UnstableValue("m.poll.response", "org.matrix.msc3381.poll.response");
			t.M_POLL_RESPONSE = a;
			var d = new n.UnstableValue("m.poll.end", "org.matrix.msc3381.poll.end");
			t.M_POLL_END = d
		},
		"./node_modules/matrix-events-sdk/lib/events/relationship_types.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.REFERENCE_RELATION = void 0;
			var n = new(i("./node_modules/matrix-events-sdk/lib/NamespacedValue.js").NamespacedValue)("m.reference");
			t.REFERENCE_RELATION = n
		},
		"./node_modules/matrix-events-sdk/lib/index.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			});
			var n = i("./node_modules/matrix-events-sdk/lib/ExtensibleEvents.js");
			Object.keys(n).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === n[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return n[e]
					}
				}))
			}));
			var r = i("./node_modules/matrix-events-sdk/lib/IPartialEvent.js");
			Object.keys(r).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === r[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return r[e]
					}
				}))
			}));
			var s = i("./node_modules/matrix-events-sdk/lib/InvalidEventError.js");
			Object.keys(s).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === s[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return s[e]
					}
				}))
			}));
			var o = i("./node_modules/matrix-events-sdk/lib/NamespacedValue.js");
			Object.keys(o).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === o[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return o[e]
					}
				}))
			}));
			var a = i("./node_modules/matrix-events-sdk/lib/NamespacedMap.js");
			Object.keys(a).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === a[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return a[e]
					}
				}))
			}));
			var d = i("./node_modules/matrix-events-sdk/lib/types.js");
			Object.keys(d).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === d[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return d[e]
					}
				}))
			}));
			var l = i("./node_modules/matrix-events-sdk/lib/utility/MessageMatchers.js");
			Object.keys(l).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === l[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return l[e]
					}
				}))
			}));
			var c = i("./node_modules/matrix-events-sdk/lib/utility/events.js");
			Object.keys(c).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === c[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return c[e]
					}
				}))
			}));
			var u = i("./node_modules/matrix-events-sdk/lib/interpreters/legacy/MRoomMessage.js");
			Object.keys(u).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === u[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return u[e]
					}
				}))
			}));
			var h = i("./node_modules/matrix-events-sdk/lib/interpreters/modern/MMessage.js");
			Object.keys(h).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === h[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return h[e]
					}
				}))
			}));
			var m = i("./node_modules/matrix-events-sdk/lib/interpreters/modern/MPoll.js");
			Object.keys(m).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === m[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return m[e]
					}
				}))
			}));
			var p = i("./node_modules/matrix-events-sdk/lib/events/relationship_types.js");
			Object.keys(p).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === p[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return p[e]
					}
				}))
			}));
			var g = i("./node_modules/matrix-events-sdk/lib/events/ExtensibleEvent.js");
			Object.keys(g).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === g[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return g[e]
					}
				}))
			}));
			var f = i("./node_modules/matrix-events-sdk/lib/events/message_types.js");
			Object.keys(f).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === f[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return f[e]
					}
				}))
			}));
			var v = i("./node_modules/matrix-events-sdk/lib/events/MessageEvent.js");
			Object.keys(v).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === v[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return v[e]
					}
				}))
			}));
			var y = i("./node_modules/matrix-events-sdk/lib/events/EmoteEvent.js");
			Object.keys(y).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === y[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return y[e]
					}
				}))
			}));
			var b = i("./node_modules/matrix-events-sdk/lib/events/NoticeEvent.js");
			Object.keys(b).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === b[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return b[e]
					}
				}))
			}));
			var _ = i("./node_modules/matrix-events-sdk/lib/events/poll_types.js");
			Object.keys(_).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === _[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return _[e]
					}
				}))
			}));
			var S = i("./node_modules/matrix-events-sdk/lib/events/PollStartEvent.js");
			Object.keys(S).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === S[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return S[e]
					}
				}))
			}));
			var E = i("./node_modules/matrix-events-sdk/lib/events/PollResponseEvent.js");
			Object.keys(E).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === E[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return E[e]
					}
				}))
			}));
			var w = i("./node_modules/matrix-events-sdk/lib/events/PollEndEvent.js");
			Object.keys(w).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === w[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return w[e]
					}
				}))
			}))
		},
		"./node_modules/matrix-events-sdk/lib/interpreters/legacy/MRoomMessage.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.LEGACY_M_ROOM_MESSAGE = void 0, t.parseMRoomMessage = function(e) {
				var t, i, o;
				if (a.M_MESSAGE.findIn(e.content) || a.M_TEXT.findIn(e.content)) return new n.MessageEvent(e);
				var d, u = null === (t = e.content) || void 0 === t ? void 0 : t.msgtype,
					h = null === (i = e.content) || void 0 === i ? void 0 : i.body,
					m = "org.matrix.custom.html" === (null === (o = e.content) || void 0 === o ? void 0 : o.format) ? e.content.formatted_body : null;
				return "m.text" === u ? new n.MessageEvent(l(l({}, e), {}, {
					content: l(l({}, e.content), {}, (d = {}, c(d, a.M_TEXT.name, h), c(d, a.M_HTML.name, m), d))
				})) : "m.notice" === u ? new r.NoticeEvent(l(l({}, e), {}, {
					content: l(l({}, e.content), {}, (p = {}, c(p, a.M_TEXT.name, h), c(p, a.M_HTML.name, m), p))
				})) : "m.emote" === u ? new s.EmoteEvent(l(l({}, e), {}, {
					content: l(l({}, e.content), {}, (g = {}, c(g, a.M_TEXT.name, h), c(g, a.M_HTML.name, m), g))
				})) : null;
				var p, g
			};
			var n = i("./node_modules/matrix-events-sdk/lib/events/MessageEvent.js"),
				r = i("./node_modules/matrix-events-sdk/lib/events/NoticeEvent.js"),
				s = i("./node_modules/matrix-events-sdk/lib/events/EmoteEvent.js"),
				o = i("./node_modules/matrix-events-sdk/lib/NamespacedValue.js"),
				a = i("./node_modules/matrix-events-sdk/lib/events/message_types.js");

			function d(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function l(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? d(Object(i), !0).forEach((function(t) {
						c(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : d(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}

			function c(e, t, i) {
				return t in e ? Object.defineProperty(e, t, {
					value: i,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = i, e
			}
			var u = new o.NamespacedValue("m.room.message");
			t.LEGACY_M_ROOM_MESSAGE = u
		},
		"./node_modules/matrix-events-sdk/lib/interpreters/modern/MMessage.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.parseMMessage = function(e) {
				if (r.M_EMOTE.matches(e.type)) return new s.EmoteEvent(e);
				if (r.M_NOTICE.matches(e.type)) return new o.NoticeEvent(e);
				return new n.MessageEvent(e)
			};
			var n = i("./node_modules/matrix-events-sdk/lib/events/MessageEvent.js"),
				r = i("./node_modules/matrix-events-sdk/lib/events/message_types.js"),
				s = i("./node_modules/matrix-events-sdk/lib/events/EmoteEvent.js"),
				o = i("./node_modules/matrix-events-sdk/lib/events/NoticeEvent.js")
		},
		"./node_modules/matrix-events-sdk/lib/interpreters/modern/MPoll.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.parseMPoll = function(e) {
				if (n.M_POLL_START.matches(e.type)) return new r.PollStartEvent(e);
				if (n.M_POLL_RESPONSE.matches(e.type)) return new s.PollResponseEvent(e);
				if (n.M_POLL_END.matches(e.type)) return new o.PollEndEvent(e);
				return null
			};
			var n = i("./node_modules/matrix-events-sdk/lib/events/poll_types.js"),
				r = i("./node_modules/matrix-events-sdk/lib/events/PollStartEvent.js"),
				s = i("./node_modules/matrix-events-sdk/lib/events/PollResponseEvent.js"),
				o = i("./node_modules/matrix-events-sdk/lib/events/PollEndEvent.js")
		},
		"./node_modules/matrix-events-sdk/lib/types.js": function(e, t, i) {
			"use strict";

			function n(e) {
				return null != e
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.isOptionalAString = function(e) {
				return n(e) && "string" == typeof e
			}, t.isProvided = n
		},
		"./node_modules/matrix-events-sdk/lib/utility/MessageMatchers.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.LegacyMsgType = void 0, t.isEventLike = function(e, t) {
				var i = e.content;
				if (t === n.Text) return r.M_MESSAGE.matches(e.type) || "m.room.message" === e.type && "m.text" === (null == i ? void 0 : i.msgtype);
				if (t === n.Emote) return r.M_EMOTE.matches(e.type) || "m.room.message" === e.type && "m.emote" === (null == i ? void 0 : i.msgtype);
				if (t === n.Notice) return r.M_NOTICE.matches(e.type) || "m.room.message" === e.type && "m.notice" === (null == i ? void 0 : i.msgtype);
				return !1
			};
			var n, r = i("./node_modules/matrix-events-sdk/lib/events/message_types.js");
			t.LegacyMsgType = n,
				function(e) {
					e.Text = "m.text", e.Notice = "m.notice", e.Emote = "m.emote"
				}(n || (t.LegacyMsgType = n = {}))
		},
		"./node_modules/matrix-events-sdk/lib/utility/events.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.isEventTypeSame = function(e, t) {
				if ("string" == typeof e) return "string" == typeof t ? t === e : t.matches(e);
				if ("string" == typeof t) return e.matches(t);
				var i = t,
					n = e;
				return i.matches(n.name) || i.matches(n.altName)
			}
		},
		"./node_modules/matrix-js-sdk/lib/@types/PushRules.js": function(e, t, i) {
			"use strict";
			let n, r, s;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.TweakName = t.RuleId = t.PushRuleKind = t.PushRuleActionName = t.DMMemberCountCondition = t.ConditionOperator = t.ConditionKind = void 0, t.isDmMemberCountCondition = function(e) {
					return "==2" === e || "2" === e
				}, t.PushRuleActionName = n,
				function(e) {
					e.DontNotify = "dont_notify", e.Notify = "notify", e.Coalesce = "coalesce"
				}(n || (t.PushRuleActionName = n = {})), t.TweakName = r,
				function(e) {
					e.Highlight = "highlight", e.Sound = "sound"
				}(r || (t.TweakName = r = {})), t.ConditionOperator = s,
				function(e) {
					e.ExactEquals = "==", e.LessThan = "<", e.GreaterThan = ">", e.GreaterThanOrEqual = ">=", e.LessThanOrEqual = "<="
				}(s || (t.ConditionOperator = s = {}));
			let o, a, d;
			t.DMMemberCountCondition = "2", t.ConditionKind = o,
				function(e) {
					e.EventMatch = "event_match", e.ContainsDisplayName = "contains_display_name", e.RoomMemberCount = "room_member_count", e.SenderNotificationPermission = "sender_notification_permission", e.CallStarted = "call_started", e.CallStartedPrefix = "org.matrix.msc3914.call_started"
				}(o || (t.ConditionKind = o = {})), t.PushRuleKind = a,
				function(e) {
					e.Override = "override", e.ContentSpecific = "content", e.RoomSpecific = "room", e.SenderSpecific = "sender", e.Underride = "underride"
				}(a || (t.PushRuleKind = a = {})), t.RuleId = d,
				function(e) {
					e.Master = ".m.rule.master", e.ContainsDisplayName = ".m.rule.contains_display_name", e.ContainsUserName = ".m.rule.contains_user_name", e.AtRoomNotification = ".m.rule.roomnotif", e.DM = ".m.rule.room_one_to_one", e.EncryptedDM = ".m.rule.encrypted_room_one_to_one", e.Message = ".m.rule.message", e.EncryptedMessage = ".m.rule.encrypted", e.InviteToSelf = ".m.rule.invite_for_me", e.MemberEvent = ".m.rule.member_event", e.IncomingCall = ".m.rule.call", e.SuppressNotices = ".m.rule.suppress_notices", e.Tombstone = ".m.rule.tombstone"
				}(d || (t.RuleId = d = {}))
		},
		"./node_modules/matrix-js-sdk/lib/@types/beacon.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.M_BEACON_INFO = t.M_BEACON = void 0;
			var n = i("./node_modules/matrix-js-sdk/lib/NamespacedValue.js");
			const r = new n.UnstableValue("m.beacon_info", "org.matrix.msc3672.beacon_info");
			t.M_BEACON_INFO = r;
			const s = new n.UnstableValue("m.beacon", "org.matrix.msc3672.beacon");
			t.M_BEACON = s
		},
		"./node_modules/matrix-js-sdk/lib/@types/event.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.UNSTABLE_MSC3089_TREE_SUBTYPE = t.UNSTABLE_MSC3089_LEAF = t.UNSTABLE_MSC3089_BRANCH = t.UNSTABLE_MSC3088_PURPOSE = t.UNSTABLE_MSC3088_ENABLED = t.UNSTABLE_MSC2716_MARKER = t.UNSTABLE_ELEMENT_FUNCTIONAL_USERS = t.RoomType = t.RoomCreateTypeField = t.RelationType = t.PUSHER_ENABLED = t.PUSHER_DEVICE_ID = t.MsgType = t.LOCAL_NOTIFICATION_SETTINGS_PREFIX = t.EventType = t.EVENT_VISIBILITY_CHANGE_TYPE = void 0;
			var n = i("./node_modules/matrix-js-sdk/lib/NamespacedValue.js");
			let r, s, o;
			t.EventType = r,
				function(e) {
					e.RoomCanonicalAlias = "m.room.canonical_alias", e.RoomCreate = "m.room.create", e.RoomJoinRules = "m.room.join_rules", e.RoomMember = "m.room.member", e.RoomThirdPartyInvite = "m.room.third_party_invite", e.RoomPowerLevels = "m.room.power_levels", e.RoomName = "m.room.name", e.RoomTopic = "m.room.topic", e.RoomAvatar = "m.room.avatar", e.RoomPinnedEvents = "m.room.pinned_events", e.RoomEncryption = "m.room.encryption", e.RoomHistoryVisibility = "m.room.history_visibility", e.RoomGuestAccess = "m.room.guest_access", e.RoomServerAcl = "m.room.server_acl", e.RoomTombstone = "m.room.tombstone", e.SpaceChild = "m.space.child", e.SpaceParent = "m.space.parent", e.RoomRedaction = "m.room.redaction", e.RoomMessage = "m.room.message", e.RoomMessageEncrypted = "m.room.encrypted", e.Sticker = "m.sticker", e.CallInvite = "m.call.invite", e.CallCandidates = "m.call.candidates", e.CallAnswer = "m.call.answer", e.CallHangup = "m.call.hangup", e.CallReject = "m.call.reject", e.CallSelectAnswer = "m.call.select_answer", e.CallNegotiate = "m.call.negotiate", e.CallSDPStreamMetadataChanged = "m.call.sdp_stream_metadata_changed", e.CallSDPStreamMetadataChangedPrefix = "org.matrix.call.sdp_stream_metadata_changed", e.CallReplaces = "m.call.replaces", e.CallAssertedIdentity = "m.call.asserted_identity", e.CallAssertedIdentityPrefix = "org.matrix.call.asserted_identity", e.KeyVerificationRequest = "m.key.verification.request", e.KeyVerificationStart = "m.key.verification.start", e.KeyVerificationCancel = "m.key.verification.cancel", e.KeyVerificationMac = "m.key.verification.mac", e.KeyVerificationDone = "m.key.verification.done", e.KeyVerificationKey = "m.key.verification.key", e.KeyVerificationAccept = "m.key.verification.accept", e.KeyVerificationReady = "m.key.verification.ready", e.RoomMessageFeedback = "m.room.message.feedback", e.Reaction = "m.reaction", e.Typing = "m.typing", e.Receipt = "m.receipt", e.Presence = "m.presence", e.FullyRead = "m.fully_read", e.Tag = "m.tag", e.SpaceOrder = "org.matrix.msc3230.space_order", e.PushRules = "m.push_rules", e.Direct = "m.direct", e.IgnoredUserList = "m.ignored_user_list", e.RoomKey = "m.room_key", e.RoomKeyRequest = "m.room_key_request", e.ForwardedRoomKey = "m.forwarded_room_key", e.Dummy = "m.dummy", e.GroupCallPrefix = "org.matrix.msc3401.call", e.GroupCallMemberPrefix = "org.matrix.msc3401.call.member"
				}(r || (t.EventType = r = {})), t.RelationType = s,
				function(e) {
					e.Annotation = "m.annotation", e.Replace = "m.replace", e.Reference = "m.reference", e.Thread = "m.thread"
				}(s || (t.RelationType = s = {})), t.MsgType = o,
				function(e) {
					e.Text = "m.text", e.Emote = "m.emote", e.Notice = "m.notice", e.Image = "m.image", e.File = "m.file", e.Audio = "m.audio", e.Location = "m.location", e.Video = "m.video", e.KeyVerificationRequest = "m.key.verification.request"
				}(o || (t.MsgType = o = {}));
			let a;
			t.RoomCreateTypeField = "type", t.RoomType = a,
				function(e) {
					e.Space = "m.space", e.UnstableCall = "org.matrix.msc3417.call", e.ElementVideo = "io.element.video"
				}(a || (t.RoomType = a = {}));
			const d = new n.UnstableValue("m.room.purpose", "org.matrix.msc3088.purpose");
			t.UNSTABLE_MSC3088_PURPOSE = d;
			const l = new n.UnstableValue("m.enabled", "org.matrix.msc3088.enabled");
			t.UNSTABLE_MSC3088_ENABLED = l;
			const c = new n.UnstableValue("m.data_tree", "org.matrix.msc3089.data_tree");
			t.UNSTABLE_MSC3089_TREE_SUBTYPE = c;
			const u = new n.UnstableValue("m.leaf", "org.matrix.msc3089.leaf");
			t.UNSTABLE_MSC3089_LEAF = u;
			const h = new n.UnstableValue("m.branch", "org.matrix.msc3089.branch");
			t.UNSTABLE_MSC3089_BRANCH = h;
			const m = new n.UnstableValue("m.room.marker", "org.matrix.msc2716.marker");
			t.UNSTABLE_MSC2716_MARKER = m;
			const p = new n.UnstableValue("io.element.functional_members", "io.element.functional_members");
			t.UNSTABLE_ELEMENT_FUNCTIONAL_USERS = p;
			const g = new n.UnstableValue("m.visibility", "org.matrix.msc3531.visibility");
			t.EVENT_VISIBILITY_CHANGE_TYPE = g;
			const f = new n.UnstableValue("enabled", "org.matrix.msc3881.enabled");
			t.PUSHER_ENABLED = f;
			const v = new n.UnstableValue("device_id", "org.matrix.msc3881.device_id");
			t.PUSHER_DEVICE_ID = v;
			const y = new n.UnstableValue("m.local_notification_settings", "org.matrix.msc3890.local_notification_settings");
			t.LOCAL_NOTIFICATION_SETTINGS_PREFIX = y
		},
		"./node_modules/matrix-js-sdk/lib/@types/extensible_events.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.TEXT_NODE_TYPE = void 0;
			const n = new(i("./node_modules/matrix-js-sdk/lib/NamespacedValue.js").UnstableValue)("m.text", "org.matrix.msc1767.text");
			t.TEXT_NODE_TYPE = n
		},
		"./node_modules/matrix-js-sdk/lib/@types/location.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.M_TIMESTAMP = t.M_LOCATION = t.M_ASSET = t.LocationAssetType = void 0;
			var n = i("./node_modules/matrix-js-sdk/lib/NamespacedValue.js");
			i("./node_modules/matrix-js-sdk/lib/@types/extensible_events.js");
			let r;
			t.LocationAssetType = r,
				function(e) {
					e.Self = "m.self", e.Pin = "m.pin"
				}(r || (t.LocationAssetType = r = {}));
			const s = new n.UnstableValue("m.asset", "org.matrix.msc3488.asset");
			t.M_ASSET = s;
			const o = new n.UnstableValue("m.ts", "org.matrix.msc3488.ts");
			t.M_TIMESTAMP = o;
			const a = new n.UnstableValue("m.location", "org.matrix.msc3488.location");
			t.M_LOCATION = a
		},
		"./node_modules/matrix-js-sdk/lib/@types/partials.js": function(e, t, i) {
			"use strict";
			let n, r, s, o, a, d;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.Visibility = t.RestrictedAllowType = t.Preset = t.JoinRule = t.HistoryVisibility = t.GuestAccess = void 0, t.Visibility = n,
				function(e) {
					e.Public = "public", e.Private = "private"
				}(n || (t.Visibility = n = {})), t.Preset = r,
				function(e) {
					e.PrivateChat = "private_chat", e.TrustedPrivateChat = "trusted_private_chat", e.PublicChat = "public_chat"
				}(r || (t.Preset = r = {})), t.JoinRule = s,
				function(e) {
					e.Public = "public", e.Invite = "invite", e.Private = "private", e.Knock = "knock", e.Restricted = "restricted"
				}(s || (t.JoinRule = s = {})), t.RestrictedAllowType = o,
				function(e) {
					e.RoomMembership = "m.room_membership"
				}(o || (t.RestrictedAllowType = o = {})), t.GuestAccess = a,
				function(e) {
					e.CanJoin = "can_join", e.Forbidden = "forbidden"
				}(a || (t.GuestAccess = a = {})), t.HistoryVisibility = d,
				function(e) {
					e.Invited = "invited", e.Joined = "joined", e.Shared = "shared", e.WorldReadable = "world_readable"
				}(d || (t.HistoryVisibility = d = {}))
		},
		"./node_modules/matrix-js-sdk/lib/@types/read_receipts.js": function(e, t, i) {
			"use strict";
			let n;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.ReceiptType = void 0, t.ReceiptType = n,
				function(e) {
					e.Read = "m.read", e.FullyRead = "m.fully_read", e.ReadPrivate = "m.read.private"
				}(n || (t.ReceiptType = n = {}))
		},
		"./node_modules/matrix-js-sdk/lib/@types/requests.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-js-sdk/lib/@types/search.js": function(e, t, i) {
			"use strict";
			var n;
			let r;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.SearchOrderBy = void 0,
				function(e) {
					e.RoomId = "room_id", e.Sender = "sender"
				}(n || (n = {})), t.SearchOrderBy = r,
				function(e) {
					e.Recent = "recent", e.Rank = "rank"
				}(r || (t.SearchOrderBy = r = {}))
		},
		"./node_modules/matrix-js-sdk/lib/@types/sync.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.UNREAD_THREAD_NOTIFICATIONS = void 0;
			const n = new(i("./node_modules/matrix-js-sdk/lib/NamespacedValue.js").ServerControlledNamespacedValue)("unread_thread_notifications", "org.matrix.msc3773.unread_thread_notifications");
			t.UNREAD_THREAD_NOTIFICATIONS = n
		},
		"./node_modules/matrix-js-sdk/lib/@types/topic.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.M_TOPIC = void 0;
			const n = new(i("./node_modules/matrix-js-sdk/lib/NamespacedValue.js").UnstableValue)("m.topic", "org.matrix.msc3765.topic");
			t.M_TOPIC = n
		},
		"./node_modules/matrix-js-sdk/lib/NamespacedValue.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.UnstableValue = t.ServerControlledNamespacedValue = t.NamespacedValue = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js"));
			class s {
				constructor(e, t) {
					if (this.stable = e, this.unstable = t, !this.unstable && !this.stable) throw new Error("One of stable or unstable values must be supplied")
				}
				get name() {
					return this.stable ? this.stable : this.unstable
				}
				get altName() {
					return this.stable ? this.unstable : null
				}
				get names() {
					const e = [this.name],
						t = this.altName;
					return t && e.push(t), e
				}
				matches(e) {
					return this.name === e || this.altName === e
				}
				findIn(e) {
					let t = void 0;
					return this.name && (t = null == e ? void 0 : e[this.name]), !t && this.altName && (t = null == e ? void 0 : e[this.altName]), t
				}
				includedIn(e) {
					let t = !1;
					return this.name && (t = e.includes(this.name)), !t && this.altName && (t = e.includes(this.altName)), t
				}
			}
			t.NamespacedValue = s;
			t.ServerControlledNamespacedValue = class extends s {
				constructor(...e) {
					super(...e), (0, r.default)(this, "preferUnstable", !1)
				}
				setPreferUnstable(e) {
					this.preferUnstable = e
				}
				get name() {
					return this.stable && !this.preferUnstable ? this.stable : this.unstable
				}
			};
			t.UnstableValue = class extends s {
				constructor(e, t) {
					if (super(e, t), !this.unstable) throw new Error("Unstable value must be supplied")
				}
				get name() {
					return this.unstable
				}
				get altName() {
					return this.stable
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/ReEmitter.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.TypedReEmitter = t.ReEmitter = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js"));
			class s {
				constructor(e) {
					this.target = e, (0, r.default)(this, "reEmitters", new Map)
				}
				reEmit(e, t) {
					let i = this.reEmitters.get(e);
					i || (i = new Map, this.reEmitters.set(e, i));
					for (const n of t) {
						const t = (...t) => {
							"error" === n && 0 === this.target.listenerCount("error") || this.target.emit(n, ...t, e)
						};
						e.on(n, t), i.set(n, t)
					}
				}
				stopReEmitting(e, t) {
					const i = this.reEmitters.get(e);
					if (i) {
						for (const n of t) e.off(n, i.get(n)), i.delete(n);
						0 === i.size && this.reEmitters.delete(e)
					}
				}
			}
			t.ReEmitter = s;
			t.TypedReEmitter = class extends s {
				constructor(e) {
					super(e)
				}
				reEmit(e, t) {
					super.reEmit(e, t)
				}
				stopReEmitting(e, t) {
					super.stopReEmitting(e, t)
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/ToDeviceMessageQueue.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.ToDeviceMessageQueue = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = i("./node_modules/matrix-js-sdk/lib/scheduler.js");
			const a = 20;
			t.ToDeviceMessageQueue = class {
				constructor(e) {
					this.client = e, (0, r.default)(this, "sending", !1), (0, r.default)(this, "running", !0), (0, r.default)(this, "retryTimeout", null), (0, r.default)(this, "retryAttempts", 0), (0, r.default)(this, "sendQueue", async () => {
						if (null !== this.retryTimeout && clearTimeout(this.retryTimeout), this.retryTimeout = null, this.sending || !this.running) return;
						let e;
						s.logger.debug("Attempting to send queued to-device messages"), this.sending = !0;
						try {
							for (; this.running && null !== (e = await this.client.store.getOldestToDeviceBatch());) await this.sendBatch(e), await this.client.store.removeToDeviceBatch(e.id), this.retryAttempts = 0;
							if (!this.running) return;
							s.logger.debug("All queued to-device messages sent")
						} catch (t) {
							++this.retryAttempts;
							const i = o.MatrixScheduler.RETRY_BACKOFF_RATELIMIT(null, this.retryAttempts, t);
							if (-1 === i) return void(4 === Math.floor(t.httpStatus / 100) ? (s.logger.error("Fatal error when sending to-device message - dropping to-device batch!", t), await this.client.store.removeToDeviceBatch(e.id)) : s.logger.info("Automatic retry limit reached for to-device messages."));
							s.logger.info(`Failed to send batch of to-device messages. Will retry in ${i}ms`, t), this.retryTimeout = setTimeout(this.sendQueue, i)
						} finally {
							this.sending = !1
						}
					})
				}
				start() {
					this.running = !0, this.sendQueue()
				}
				stop() {
					this.running = !1, null !== this.retryTimeout && clearTimeout(this.retryTimeout), this.retryTimeout = null
				}
				async queueBatch(e) {
					const t = [];
					for (let i = 0; i < e.batch.length; i += a) {
						const n = {
							eventType: e.eventType,
							batch: e.batch.slice(i, i + a),
							txnId: this.client.makeTxnId()
						};
						t.push(n);
						const r = n.batch.map(e => `${e.userId}:${e.deviceId}`);
						s.logger.info(`Created batch of to-device messages with txn id ${n.txnId} for ${r}`)
					}
					await this.client.store.saveToDeviceBatches(t), s.logger.info(`Enqueued to-device messages with txn ids ${t.map(e=>e.txnId)}`), this.sendQueue()
				}
				async sendBatch(e) {
					const t = {};
					for (const i of e.batch) t[i.userId] || (t[i.userId] = {}), t[i.userId][i.deviceId] = i.payload;
					s.logger.info(`Sending batch of ${e.batch.length} to-device messages with ID ${e.id} and txnId ${e.txnId}`), await this.client.sendToDevice(e.eventType, t, e.txnId)
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/autodiscovery.js": function(e, t, i) {
			"use strict";
			(function(e) {
				var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.AutoDiscoveryAction = t.AutoDiscovery = void 0;
				var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
					s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
					o = i("./node_modules/matrix-js-sdk/lib/http-api/index.js");
				let a;
				var d;
				t.AutoDiscoveryAction = a,
					function(e) {
						e.SUCCESS = "SUCCESS", e.IGNORE = "IGNORE", e.PROMPT = "PROMPT", e.FAIL_PROMPT = "FAIL_PROMPT", e.FAIL_ERROR = "FAIL_ERROR"
					}(a || (t.AutoDiscoveryAction = a = {})),
					function(e) {
						e.Invalid = "Invalid homeserver discovery response", e.GenericFailure = "Failed to get autodiscovery configuration from server", e.InvalidHsBaseUrl = "Invalid base_url for m.homeserver", e.InvalidHomeserver = "Homeserver URL does not appear to be a valid Matrix homeserver", e.InvalidIsBaseUrl = "Invalid base_url for m.identity_server", e.InvalidIdentityServer = "Identity server URL does not appear to be a valid identity server", e.InvalidIs = "Invalid identity server discovery response", e.MissingWellknown = "No .well-known JSON file found", e.InvalidJson = "Invalid JSON"
					}(d || (d = {}));
				class l {
					static async fromDiscoveryConfig(e) {
						const t = {
							"m.homeserver": {
								state: l.FAIL_ERROR,
								error: l.ERROR_INVALID,
								base_url: null
							},
							"m.identity_server": {
								state: l.PROMPT,
								error: null,
								base_url: null
							}
						};
						if (!e || !e["m.homeserver"]) return s.logger.error("No m.homeserver key in config"), t["m.homeserver"].state = l.FAIL_PROMPT, t["m.homeserver"].error = l.ERROR_INVALID, Promise.resolve(t);
						if (!e["m.homeserver"].base_url) return s.logger.error("No m.homeserver base_url in config"), t["m.homeserver"].state = l.FAIL_PROMPT, t["m.homeserver"].error = l.ERROR_INVALID_HS_BASE_URL, Promise.resolve(t);
						const i = this.sanitizeWellKnownUrl(e["m.homeserver"].base_url);
						if (!i) return s.logger.error("Invalid base_url for m.homeserver"), t["m.homeserver"].error = l.ERROR_INVALID_HS_BASE_URL, Promise.resolve(t);
						const n = await this.fetchWellKnownObject(`${i}/_matrix/client/versions`);
						if (!n || !n.raw.versions) return s.logger.error("Invalid /versions response"), t["m.homeserver"].error = l.ERROR_INVALID_HOMESERVER, t["m.homeserver"].base_url = i, Promise.resolve(t);
						t["m.homeserver"] = {
							state: l.SUCCESS,
							error: null,
							base_url: i
						};
						let r = "";
						if (e["m.identity_server"]) {
							const i = {
								"m.homeserver": t["m.homeserver"],
								"m.identity_server": {
									state: l.FAIL_PROMPT,
									error: l.ERROR_INVALID_IS,
									base_url: null
								}
							};
							if (!(r = this.sanitizeWellKnownUrl(e["m.identity_server"].base_url))) return s.logger.error("Invalid base_url for m.identity_server"), i["m.identity_server"].error = l.ERROR_INVALID_IS_BASE_URL, Promise.resolve(i);
							const n = await this.fetchWellKnownObject(`${r}/_matrix/identity/api/v1`);
							if (!n || !n.raw || n.action !== a.SUCCESS) return s.logger.error("Invalid /api/v1 response"), i["m.identity_server"].error = l.ERROR_INVALID_IDENTITY_SERVER, i["m.identity_server"].base_url = r, Promise.resolve(i)
						}
						return r && r.toString().length > 0 && (t["m.identity_server"] = {
							state: l.SUCCESS,
							error: null,
							base_url: r
						}), Object.keys(e).forEach(i => {
							if ("m.homeserver" === i || "m.identity_server" === i) {
								const n = ["error", "state", "base_url"];
								for (const r of Object.keys(e[i])) n.includes(r) || (t[i][r] = e[i][r])
							} else t[i] = e[i]
						}), Promise.resolve(t)
					}
					static async findClientConfig(e) {
						if (!e || "string" != typeof e || 0 === e.length) throw new Error("'domain' must be a string of non-zero length");
						const t = {
								"m.homeserver": {
									state: l.FAIL_ERROR,
									error: l.ERROR_INVALID,
									base_url: null
								},
								"m.identity_server": {
									state: l.PROMPT,
									error: null,
									base_url: null
								}
							},
							i = await this.fetchWellKnownObject(`https://${e}/.well-known/matrix/client`);
						return i && i.action === a.SUCCESS ? l.fromDiscoveryConfig(i.raw) : (s.logger.error("No response or error when parsing .well-known"), i.reason && s.logger.error(i.reason), i.action === a.IGNORE ? t["m.homeserver"] = {
							state: l.PROMPT,
							error: null,
							base_url: null
						} : (t["m.homeserver"].state = l.FAIL_PROMPT, t["m.homeserver"].error = l.ERROR_INVALID), Promise.resolve(t))
					}
					static async getRawClientConfig(e) {
						if (!e || "string" != typeof e || 0 === e.length) throw new Error("'domain' must be a string of non-zero length");
						const t = await this.fetchWellKnownObject(`https://${e}/.well-known/matrix/client`);
						return t && t.raw || {}
					}
					static sanitizeWellKnownUrl(e) {
						if (!e) return !1;
						try {
							var t;
							let n;
							try {
								n = new URL(e)
							} catch (i) {
								s.logger.error("Could not parse url", i)
							}
							if (null === (t = n) || void 0 === t || !t.hostname) return !1;
							if ("http:" !== n.protocol && "https:" !== n.protocol) return !1;
							const r = n.port ? `:${n.port}` : "",
								o = n.pathname ? n.pathname : "";
							let a = `${n.protocol}//${n.hostname}${r}${o}`;
							return a.endsWith("/") && (a = a.substring(0, a.length - 1)), a
						} catch (i) {
							return s.logger.error(i), !1
						}
					}
					static fetch(t, i) {
						return this.fetchFn ? this.fetchFn(t, i) : e.fetch(t, i)
					}
					static setFetchFn(e) {
						l.fetchFn = e
					}
					static async fetchWellKnownObject(e) {
						let t;
						try {
							if (404 === (t = await l.fetch(e, {
									method: o.Method.Get,
									signal: (0, o.timeoutSignal)(5e3)
								})).status) return {
								raw: {},
								action: a.IGNORE,
								reason: l.ERROR_MISSING_WELLKNOWN
							};
							if (!t.ok) return {
								raw: {},
								action: a.FAIL_PROMPT,
								reason: "General failure"
							}
						} catch (i) {
							const e = i;
							let t = "";
							return "object" == typeof e && (t = null == e ? void 0 : e.message), {
								error: e,
								raw: {},
								action: a.FAIL_PROMPT,
								reason: t || "General failure"
							}
						}
						try {
							return {
								raw: await t.json(),
								action: a.SUCCESS
							}
						} catch (i) {
							const e = i;
							return {
								error: e,
								raw: {},
								action: a.FAIL_PROMPT,
								reason: "SyntaxError" === (null == e ? void 0 : e.name) ? l.ERROR_INVALID_JSON : l.ERROR_INVALID
							}
						}
					}
				}
				t.AutoDiscovery = l, (0, r.default)(l, "ERROR_INVALID", d.Invalid), (0, r.default)(l, "ERROR_GENERIC_FAILURE", d.GenericFailure), (0, r.default)(l, "ERROR_INVALID_HS_BASE_URL", d.InvalidHsBaseUrl), (0, r.default)(l, "ERROR_INVALID_HOMESERVER", d.InvalidHomeserver), (0, r.default)(l, "ERROR_INVALID_IS_BASE_URL", d.InvalidIsBaseUrl), (0, r.default)(l, "ERROR_INVALID_IDENTITY_SERVER", d.InvalidIdentityServer), (0, r.default)(l, "ERROR_INVALID_IS", d.InvalidIs), (0, r.default)(l, "ERROR_MISSING_WELLKNOWN", d.MissingWellknown), (0, r.default)(l, "ERROR_INVALID_JSON", d.InvalidJson), (0, r.default)(l, "ALL_ERRORS", Object.keys(d)), (0, r.default)(l, "FAIL_ERROR", a.FAIL_ERROR), (0, r.default)(l, "FAIL_PROMPT", a.FAIL_PROMPT), (0, r.default)(l, "PROMPT", a.PROMPT), (0, r.default)(l, "SUCCESS", a.SUCCESS), (0, r.default)(l, "fetchFn", void 0)
			}).call(this, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/browser-index.js": function(e, t, i) {
			"use strict";
			(function(e) {
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = {};
				t.default = void 0;
				var r = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = s(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var o in e)
						if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
							var a = r ? Object.getOwnPropertyDescriptor(e, o) : null;
							a && (a.get || a.set) ? Object.defineProperty(n, o, a) : n[o] = e[o]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/matrix.js"));

				function s(e) {
					if ("function" != typeof WeakMap) return null;
					var t = new WeakMap,
						i = new WeakMap;
					return (s = function(e) {
						return e ? i : t
					})(e)
				}
				if (Object.keys(r).forEach((function(e) {
						"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === r[e] || Object.defineProperty(t, e, {
							enumerable: !0,
							get: function() {
								return r[e]
							}
						}))
					})), e.__js_sdk_entrypoint) throw new Error("Multiple matrix-js-sdk entrypoints detected!");
				let o;
				e.__js_sdk_entrypoint = !0;
				try {
					o = e.indexedDB
				} catch (d) {}
				o && r.setCryptoStoreFactory((function() {
					return new r.IndexedDBCryptoStore(o, "matrix-js-sdk:crypto")
				}));
				var a = r;
				t.default = a, e.matrixcs = r
			}).call(this, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/client.js": function(e, t, i) {
			"use strict";
			(function(e) {
				var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.UNSTABLE_MSC3852_LAST_SEEN_UA = t.RoomVersionStability = t.PendingEventOrdering = t.MatrixClient = t.M_AUTHENTICATION = t.ClientEvent = t.CRYPTO_ENABLED = void 0, t.fixNotificationCountOnDecryption = be;
				var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/objectWithoutProperties.js")),
					s = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
					o = i("./node_modules/matrix-events-sdk/lib/index.js"),
					a = i("./node_modules/matrix-js-sdk/lib/sync.js"),
					d = i("./node_modules/matrix-js-sdk/lib/models/event.js"),
					l = i("./node_modules/matrix-js-sdk/lib/store/stub.js"),
					c = i("./node_modules/matrix-js-sdk/lib/webrtc/call.js"),
					u = i("./node_modules/matrix-js-sdk/lib/filter.js"),
					h = i("./node_modules/matrix-js-sdk/lib/webrtc/callEventHandler.js"),
					m = ne(i("./node_modules/matrix-js-sdk/lib/utils.js")),
					p = i("./node_modules/matrix-js-sdk/lib/models/event-timeline.js"),
					g = i("./node_modules/matrix-js-sdk/lib/pushprocessor.js"),
					f = i("./node_modules/matrix-js-sdk/lib/autodiscovery.js"),
					v = ne(i("./node_modules/matrix-js-sdk/lib/crypto/olmlib.js")),
					y = i("./node_modules/matrix-js-sdk/lib/ReEmitter.js"),
					b = i("./node_modules/matrix-js-sdk/lib/crypto/RoomList.js"),
					_ = i("./node_modules/matrix-js-sdk/lib/logger.js"),
					S = i("./node_modules/matrix-js-sdk/lib/service-types.js"),
					E = i("./node_modules/matrix-js-sdk/lib/http-api/index.js"),
					w = i("./node_modules/matrix-js-sdk/lib/crypto/index.js"),
					k = i("./node_modules/matrix-js-sdk/lib/crypto/recoverykey.js"),
					T = i("./node_modules/matrix-js-sdk/lib/crypto/key_passphrase.js"),
					I = i("./node_modules/matrix-js-sdk/lib/models/user.js"),
					C = i("./node_modules/matrix-js-sdk/lib/content-repo.js"),
					R = i("./node_modules/matrix-js-sdk/lib/models/search-result.js"),
					j = i("./node_modules/matrix-js-sdk/lib/crypto/dehydration.js"),
					O = i("./node_modules/matrix-js-sdk/lib/crypto/api.js"),
					x = ne(i("./node_modules/matrix-js-sdk/lib/content-helpers.js")),
					M = i("./node_modules/matrix-js-sdk/lib/models/room.js"),
					P = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
					D = i("./node_modules/matrix-js-sdk/lib/@types/partials.js"),
					A = i("./node_modules/matrix-js-sdk/lib/event-mapper.js"),
					L = i("./node_modules/matrix-js-sdk/lib/randomstring.js"),
					U = i("./node_modules/matrix-js-sdk/lib/crypto/backup.js"),
					N = i("./node_modules/matrix-js-sdk/lib/models/MSC3089TreeSpace.js"),
					F = i("./node_modules/matrix-js-sdk/lib/@types/search.js"),
					B = i("./node_modules/matrix-js-sdk/lib/@types/PushRules.js"),
					K = i("./node_modules/matrix-js-sdk/lib/webrtc/groupCall.js"),
					q = i("./node_modules/matrix-js-sdk/lib/webrtc/mediaHandler.js"),
					$ = i("./node_modules/matrix-js-sdk/lib/webrtc/groupCallEventHandler.js"),
					V = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js"),
					W = i("./node_modules/matrix-js-sdk/lib/@types/read_receipts.js"),
					G = i("./node_modules/matrix-js-sdk/lib/sliding-sync-sdk.js"),
					H = i("./node_modules/matrix-js-sdk/lib/models/thread.js"),
					z = i("./node_modules/matrix-js-sdk/lib/@types/beacon.js"),
					Y = i("./node_modules/matrix-js-sdk/lib/NamespacedValue.js"),
					J = i("./node_modules/matrix-js-sdk/lib/ToDeviceMessageQueue.js"),
					Q = i("./node_modules/matrix-js-sdk/lib/models/read-receipt.js"),
					X = i("./node_modules/matrix-js-sdk/lib/models/invites-ignorer.js"),
					Z = i("./node_modules/matrix-js-sdk/lib/@types/sync.js"),
					ee = i("./node_modules/matrix-js-sdk/lib/feature.js");
				const te = ["server", "limit", "since"];

				function ie(e) {
					if ("function" != typeof WeakMap) return null;
					var t = new WeakMap,
						i = new WeakMap;
					return (ie = function(e) {
						return e ? i : t
					})(e)
				}

				function ne(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = ie(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} return n.default = e, i && i.set(e, n), n
				}

				function re(e, t) {
					var i = Object.keys(e);
					if (Object.getOwnPropertySymbols) {
						var n = Object.getOwnPropertySymbols(e);
						t && (n = n.filter((function(t) {
							return Object.getOwnPropertyDescriptor(e, t).enumerable
						}))), i.push.apply(i, n)
					}
					return i
				}

				function se(e) {
					for (var t = 1; t < arguments.length; t++) {
						var i = null != arguments[t] ? arguments[t] : {};
						t % 2 ? re(Object(i), !0).forEach((function(t) {
							(0, s.default)(e, t, i[t])
						})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : re(Object(i)).forEach((function(t) {
							Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
						}))
					}
					return e
				}
				const oe = 3e3,
					ae = (0, w.isCryptoAvailable)();
				t.CRYPTO_ENABLED = ae;
				const de = 216e5,
					le = 6e5,
					ce = new Y.UnstableValue("last_seen_user_agent", "org.matrix.msc3852.last_seen_user_agent");
				let ue, he;
				var me;
				t.UNSTABLE_MSC3852_LAST_SEEN_UA = ce, t.PendingEventOrdering = ue,
					function(e) {
						e.Chronological = "chronological", e.Detached = "detached"
					}(ue || (t.PendingEventOrdering = ue = {})), t.RoomVersionStability = he,
					function(e) {
						e.Stable = "stable", e.Unstable = "unstable"
					}(he || (t.RoomVersionStability = he = {})),
					function(e) {
						e.MasterKey = "master_key", e.SelfSigningKey = "self_signing_key", e.UserSigningKey = "user_signing_key"
					}(me || (me = {}));
				const pe = new Y.UnstableValue("m.authentication", "org.matrix.msc2965.authentication");
				t.M_AUTHENTICATION = pe;
				const ge = "$";
				let fe;
				t.ClientEvent = fe,
					function(e) {
						e.Sync = "sync", e.Event = "event", e.ToDeviceEvent = "toDeviceEvent", e.AccountData = "accountData", e.Room = "Room", e.DeleteRoom = "deleteRoom", e.SyncUnexpectedError = "sync.unexpectedError", e.ClientWellKnown = "WellKnown.client", e.ReceivedVoipEvent = "received_voip_event", e.TurnServers = "turnServers", e.TurnServersError = "turnServers.error"
					}(fe || (t.ClientEvent = fe = {}));
				const ve = new Y.UnstableValue("action", "org.matrix.msc3824.action");
				class ye extends V.TypedEventEmitter {
					constructor(e) {
						var t;
						super(), (0, s.default)(this, "reEmitter", new y.TypedReEmitter(this)), (0, s.default)(this, "olmVersion", null), (0, s.default)(this, "usingExternalCrypto", !1), (0, s.default)(this, "store", void 0), (0, s.default)(this, "deviceId", void 0), (0, s.default)(this, "credentials", void 0), (0, s.default)(this, "pickleKey", void 0), (0, s.default)(this, "scheduler", void 0), (0, s.default)(this, "clientRunning", !1), (0, s.default)(this, "timelineSupport", !1), (0, s.default)(this, "urlPreviewCache", {}), (0, s.default)(this, "identityServer", void 0), (0, s.default)(this, "http", void 0), (0, s.default)(this, "crypto", void 0), (0, s.default)(this, "cryptoCallbacks", void 0), (0, s.default)(this, "callEventHandler", void 0), (0, s.default)(this, "groupCallEventHandler", void 0), (0, s.default)(this, "supportsCallTransfer", !1), (0, s.default)(this, "forceTURN", !1), (0, s.default)(this, "iceCandidatePoolSize", 0), (0, s.default)(this, "idBaseUrl", void 0), (0, s.default)(this, "baseUrl", void 0), (0, s.default)(this, "canSupportVoip", !1), (0, s.default)(this, "peekSync", null), (0, s.default)(this, "isGuestAccount", !1), (0, s.default)(this, "ongoingScrollbacks", {}), (0, s.default)(this, "notifTimelineSet", null), (0, s.default)(this, "cryptoStore", void 0), (0, s.default)(this, "verificationMethods", void 0), (0, s.default)(this, "fallbackICEServerAllowed", !1), (0, s.default)(this, "roomList", void 0), (0, s.default)(this, "syncApi", void 0), (0, s.default)(this, "roomNameGenerator", void 0), (0, s.default)(this, "pushRules", void 0), (0, s.default)(this, "syncLeftRoomsPromise", void 0), (0, s.default)(this, "syncedLeftRooms", !1), (0, s.default)(this, "clientOpts", void 0), (0, s.default)(this, "clientWellKnownIntervalID", void 0), (0, s.default)(this, "canResetTimelineCallback", void 0), (0, s.default)(this, "canSupport", new Map), (0, s.default)(this, "pushProcessor", new g.PushProcessor(this)), (0, s.default)(this, "serverVersionsPromise", void 0), (0, s.default)(this, "cachedCapabilities", void 0), (0, s.default)(this, "clientWellKnown", void 0), (0, s.default)(this, "clientWellKnownPromise", void 0), (0, s.default)(this, "turnServers", []), (0, s.default)(this, "turnServersExpiry", 0), (0, s.default)(this, "checkTurnServersIntervalID", void 0), (0, s.default)(this, "exportedOlmDeviceToImport", void 0), (0, s.default)(this, "txnCtr", 0), (0, s.default)(this, "mediaHandler", new q.MediaHandler(this)), (0, s.default)(this, "sessionId", void 0), (0, s.default)(this, "pendingEventEncryption", new Map), (0, s.default)(this, "useE2eForGroupCall", !0), (0, s.default)(this, "toDeviceMessageQueue", void 0), (0, s.default)(this, "ignoredInvites", void 0), (0, s.default)(this, "startCallEventHandler", () => {
							this.isInitialSyncComplete() && (this.callEventHandler.start(), this.groupCallEventHandler.start(), this.off(fe.Sync, this.startCallEventHandler))
						}), e.baseUrl = m.ensureNoTrailingSlash(e.baseUrl), e.idBaseUrl = m.ensureNoTrailingSlash(e.idBaseUrl), this.baseUrl = e.baseUrl, this.idBaseUrl = e.idBaseUrl, this.identityServer = e.identityServer, this.usingExternalCrypto = null !== (t = e.usingExternalCrypto) && void 0 !== t && t, this.store = e.store || new l.StubStore, this.deviceId = e.deviceId || null, this.sessionId = (0, L.randomString)(10);
						const i = e.userId || null;
						this.credentials = {
							userId: i
						}, this.http = new E.MatrixHttpApi(this, {
							fetchFn: e.fetchFn,
							baseUrl: e.baseUrl,
							idBaseUrl: e.idBaseUrl,
							accessToken: e.accessToken,
							prefix: E.ClientPrefix.R0,
							onlyData: !0,
							extraParams: e.queryParams,
							localTimeoutMs: e.localTimeoutMs,
							useAuthorizationHeader: e.useAuthorizationHeader
						}), e.deviceToImport ? this.deviceId ? _.logger.warn("not importing device because device ID is provided to constructor independently of exported data") : this.credentials.userId ? _.logger.warn("not importing device because user ID is provided to constructor independently of exported data") : e.deviceToImport.deviceId ? (this.deviceId = e.deviceToImport.deviceId, this.credentials.userId = e.deviceToImport.userId, this.exportedOlmDeviceToImport = e.deviceToImport.olmDevice) : _.logger.warn("not importing device because no device ID in exported data") : e.pickleKey && (this.pickleKey = e.pickleKey), this.scheduler = e.scheduler, this.scheduler && this.scheduler.setProcessFunction(async e => {
							const t = this.getRoom(e.getRoomId());
							e.status !== d.EventStatus.SENDING && this.updatePendingEventStatus(t, e, d.EventStatus.SENDING);
							const i = await this.sendEventHttpRequest(e);
							return t && t.updatePendingEvent(e, d.EventStatus.SENT, i.event_id), i
						}), (0, c.supportsMatrixCall)() && (this.callEventHandler = new h.CallEventHandler(this), this.groupCallEventHandler = new $.GroupCallEventHandler(this), this.canSupportVoip = !0, this.on(fe.Sync, this.startCallEventHandler)), this.timelineSupport = Boolean(e.timelineSupport), this.cryptoStore = e.cryptoStore, this.verificationMethods = e.verificationMethods, this.cryptoCallbacks = e.cryptoCallbacks || {}, this.forceTURN = e.forceTURN || !1, this.iceCandidatePoolSize = void 0 === e.iceCandidatePoolSize ? 0 : e.iceCandidatePoolSize, this.supportsCallTransfer = e.supportsCallTransfer || !1, this.fallbackICEServerAllowed = e.fallbackICEServerAllowed || !1, void 0 !== e.useE2eForGroupCall && (this.useE2eForGroupCall = e.useE2eForGroupCall), this.roomList = new b.RoomList(this.cryptoStore), this.roomNameGenerator = e.roomNameGenerator, this.toDeviceMessageQueue = new J.ToDeviceMessageQueue(this), this.on(d.MatrixEventEvent.Decrypted, e => {
							be(this, e)
						}), this.on(M.RoomEvent.Receipt, (e, t) => {
							if (t && this.isRoomEncrypted(t.roomId)) {
								const n = e.getContent();
								if (!(Object.keys(n).filter(e => {
										for (const [t, i] of Object.entries(n[e]))
											if (m.isSupportedReceiptType(t) && i && Object.keys(i).includes(this.getUserId())) return !0;
										return !1
									}).length > 0)) return;
								const r = 20,
									s = t.getLiveTimeline().getEvents();
								let o = 0;
								for (let e = s.length - 1; e >= 0; e--) {
									var i;
									if (e === s.length - r) return;
									const n = s[e];
									if (t.hasUserReadEvent(this.getUserId(), n.getId())) break;
									const a = this.getPushActionsForEvent(n);
									o += null != a && null !== (i = a.tweaks) && void 0 !== i && i.highlight ? 1 : 0
								}
								t.setUnreadNotificationCount(M.NotificationCountType.Highlight, o)
							}
						}), this.ignoredInvites = new X.IgnoredInvites(this)
					}
					async startClient(e) {
						if (this.clientRunning) return;
						this.clientRunning = !0, "number" == typeof e && (e = {
							initialSyncLimit: e
						});
						const t = this.getUserId();
						t && this.store.storeUser(new I.User(t)), this.crypto && this.crypto.uploadDeviceKeys(), this.canSupportVoip && (this.checkTurnServersIntervalID = setInterval(() => {
							this.checkTurnServers()
						}, le), this.checkTurnServers()), this.syncApi && (_.logger.error("Still have sync object whilst not running: stopping old one"), this.syncApi.stop());
						try {
							await this.getVersions();
							const {
								threads: e,
								list: t,
								fwdPagination: i
							} = await this.doesServerSupportThread();
							H.Thread.setServerSideSupport(e), H.Thread.setServerSideListSupport(t), H.Thread.setServerSideFwdPaginationSupport(i)
						} catch (i) {
							_.logger.error("Can't fetch server versions, continuing to initialise sync, this will be retried later", i)
						}
						this.clientOpts = Object.assign({}, e), this.clientOpts.crypto = this.crypto, this.clientOpts.canResetEntireTimeline = e => !!this.canResetTimelineCallback && this.canResetTimelineCallback(e), this.clientOpts.slidingSync ? this.syncApi = new G.SlidingSyncSdk(this.clientOpts.slidingSync, this, this.clientOpts) : this.syncApi = new a.SyncApi(this, this.clientOpts), this.syncApi.sync(), void 0 !== this.clientOpts.clientWellKnownPollPeriod && (this.clientWellKnownIntervalID = setInterval(() => {
							this.fetchClientWellKnown()
						}, 1e3 * this.clientOpts.clientWellKnownPollPeriod), this.fetchClientWellKnown()), this.toDeviceMessageQueue.start()
					}
					stopClient() {
						var t, i, n, r, s;
						null === (t = this.crypto) || void 0 === t || t.stop(), this.clientRunning && (_.logger.log("stopping MatrixClient"), this.clientRunning = !1, null === (i = this.syncApi) || void 0 === i || i.stop(), this.syncApi = void 0, null === (n = this.peekSync) || void 0 === n || n.stopPeeking(), null === (r = this.callEventHandler) || void 0 === r || r.stop(), null === (s = this.groupCallEventHandler) || void 0 === s || s.stop(), this.callEventHandler = void 0, this.groupCallEventHandler = void 0, e.clearInterval(this.checkTurnServersIntervalID), this.checkTurnServersIntervalID = void 0, void 0 !== this.clientWellKnownIntervalID && e.clearInterval(this.clientWellKnownIntervalID), this.toDeviceMessageQueue.stop())
					}
					async rehydrateDevice() {
						if (this.crypto) throw new Error("Cannot rehydrate device after crypto is initialized");
						if (!this.cryptoCallbacks.getDehydrationKey) return;
						const t = await this.getDehydratedDevice();
						if (!t) return;
						if (!t.device_data || !t.device_id) return void _.logger.info("no dehydrated device found");
						const i = new e.Olm.Account;
						try {
							const e = t.device_data;
							if (e.algorithm !== j.DEHYDRATION_ALGORITHM) return void _.logger.warn("Wrong algorithm for dehydrated device");
							_.logger.log("unpickling dehydrated device");
							const n = await this.cryptoCallbacks.getDehydrationKey(e, t => {
								i.unpickle(new Uint8Array(t), e.account)
							});
							if (i.unpickle(n, e.account), _.logger.log("unpickled device"), (await this.http.authedRequest(E.Method.Post, "/dehydrated_device/claim", void 0, {
									device_id: t.device_id
								}, {
									prefix: "/_matrix/client/unstable/org.matrix.msc2697.v2"
								})).success) {
								this.deviceId = t.device_id, _.logger.info("using dehydrated device");
								const e = this.pickleKey || "DEFAULT_KEY";
								return this.exportedOlmDeviceToImport = {
									pickledAccount: i.pickle(e),
									sessions: [],
									pickleKey: e
								}, i.free(), this.deviceId
							}
							return i.free(), void _.logger.info("not using dehydrated device")
						} catch (n) {
							i.free(), _.logger.warn("could not unpickle", n)
						}
					}
					async getDehydratedDevice() {
						try {
							return await this.http.authedRequest(E.Method.Get, "/dehydrated_device", void 0, void 0, {
								prefix: "/_matrix/client/unstable/org.matrix.msc2697.v2"
							})
						} catch (e) {
							return void _.logger.info("could not get dehydrated device", e)
						}
					}
					async setDehydrationKey(e, t, i) {
						if (this.crypto) return this.crypto.dehydrationManager.setKeyAndQueueDehydration(e, t, i);
						_.logger.warn("not dehydrating device if crypto is not enabled")
					}
					async createDehydratedDevice(e, t, i) {
						if (this.crypto) return await this.crypto.dehydrationManager.setKey(e, t, i), this.crypto.dehydrationManager.dehydrateDevice();
						_.logger.warn("not dehydrating device if crypto is not enabled")
					}
					async exportDevice() {
						if (this.crypto) return {
							userId: this.credentials.userId,
							deviceId: this.deviceId,
							olmDevice: await this.crypto.olmDevice.export()
						};
						_.logger.warn("not exporting device if crypto is not enabled")
					}
					clearStores() {
						if (this.clientRunning) throw new Error("Cannot clear stores while client is running");
						const e = [];
						return e.push(this.store.deleteAllData()), this.cryptoStore && e.push(this.cryptoStore.deleteAllData()), Promise.all(e).then()
					}
					getUserId() {
						return this.credentials && this.credentials.userId ? this.credentials.userId : null
					}
					getDomain() {
						return this.credentials && this.credentials.userId ? this.credentials.userId.replace(/^.*?:/, "") : null
					}
					getUserIdLocalpart() {
						return this.credentials && this.credentials.userId ? this.credentials.userId.split(":")[0].substring(1) : null
					}
					getDeviceId() {
						return this.deviceId
					}
					getSessionId() {
						return this.sessionId
					}
					supportsVoip() {
						return this.canSupportVoip
					}
					getMediaHandler() {
						return this.mediaHandler
					}
					setForceTURN(e) {
						this.forceTURN = e
					}
					setSupportsCallTransfer(e) {
						this.supportsCallTransfer = e
					}
					getUseE2eForGroupCall() {
						return this.useE2eForGroupCall
					}
					createCall(e) {
						return (0, c.createNewMatrixCall)(this, e)
					}
					async createGroupCall(e, t, i, n, r, s) {
						if (this.getGroupCallForRoom(e)) throw new Error(`${e} already has an existing group call`);
						const o = this.getRoom(e);
						if (!o) throw new Error(`Cannot find room ${e}`);
						return new K.GroupCall(this, o, t, i, n, void 0, r, s).create()
					}
					waitUntilRoomReadyForGroupCalls(e) {
						return this.groupCallEventHandler.waitUntilRoomReadyForGroupCalls(e)
					}
					getGroupCallForRoom(e) {
						return this.groupCallEventHandler.groupCalls.get(e) || null
					}
					getSyncState() {
						var e, t;
						return null !== (e = null === (t = this.syncApi) || void 0 === t ? void 0 : t.getSyncState()) && void 0 !== e ? e : null
					}
					getSyncStateData() {
						return this.syncApi ? this.syncApi.getSyncStateData() : null
					}
					isInitialSyncComplete() {
						const e = this.getSyncState();
						return !!e && (e === a.SyncState.Prepared || e === a.SyncState.Syncing)
					}
					isGuest() {
						return this.isGuestAccount
					}
					setGuest(e) {
						this.isGuestAccount = e
					}
					getScheduler() {
						return this.scheduler
					}
					retryImmediately() {
						var e, t;
						return this.toDeviceMessageQueue.sendQueue(), null !== (e = null === (t = this.syncApi) || void 0 === t ? void 0 : t.retryImmediately()) && void 0 !== e && e
					}
					getNotifTimelineSet() {
						return this.notifTimelineSet
					}
					setNotifTimelineSet(e) {
						this.notifTimelineSet = e
					}
					getCapabilities(e = !1) {
						const t = (new Date).getTime();
						return this.cachedCapabilities && !e && t < this.cachedCapabilities.expiration ? (_.logger.log("Returning cached capabilities"), Promise.resolve(this.cachedCapabilities.capabilities)) : this.http.authedRequest(E.Method.Get, "/capabilities").catch(e => {
							_.logger.error(e)
						}).then((e = {}) => {
							const i = e.capabilities || {},
								n = Object.keys(i).length ? de : 6e4 + 5e3 * Math.random();
							return this.cachedCapabilities = {
								capabilities: i,
								expiration: t + n
							}, _.logger.log("Caching capabilities: ", i), i
						})
					}
					async initCrypto() {
						if (!(0, w.isCryptoAvailable)()) throw new Error("End-to-end encryption not supported in this js-sdk build: did you remember to load the olm library?");
						if (this.crypto) return void _.logger.warn("Attempt to re-initialise e2e encryption on MatrixClient");
						if (!this.cryptoStore) throw new Error("Cannot enable encryption: no cryptoStore provided");
						_.logger.log("Crypto: Starting up crypto store..."), await this.cryptoStore.startup(), _.logger.log("Crypto: initialising roomlist..."), await this.roomList.init();
						const e = this.getUserId();
						if (null === e) throw new Error("Cannot enable encryption on MatrixClient with unknown userId: ensure userId is passed in createClient().");
						if (null === this.deviceId) throw new Error("Cannot enable encryption on MatrixClient with unknown deviceId: ensure deviceId is passed in createClient().");
						const t = new w.Crypto(this, e, this.deviceId, this.store, this.cryptoStore, this.roomList, this.verificationMethods);
						this.reEmitter.reEmit(t, [w.CryptoEvent.KeyBackupFailed, w.CryptoEvent.KeyBackupSessionsRemaining, w.CryptoEvent.RoomKeyRequest, w.CryptoEvent.RoomKeyRequestCancellation, w.CryptoEvent.Warning, w.CryptoEvent.DevicesUpdated, w.CryptoEvent.WillUpdateDevices, w.CryptoEvent.DeviceVerificationChanged, w.CryptoEvent.UserTrustStatusChanged, w.CryptoEvent.KeysChanged]), _.logger.log("Crypto: initialising crypto object..."), await t.init({
							exportedOlmDevice: this.exportedOlmDeviceToImport,
							pickleKey: this.pickleKey
						}), delete this.exportedOlmDeviceToImport, this.olmVersion = w.Crypto.getOlmVersion(), t.registerEventHandlers(this), this.crypto = t
					}
					isCryptoEnabled() {
						return !!this.crypto
					}
					getDeviceEd25519Key() {
						var e, t;
						return null !== (e = null === (t = this.crypto) || void 0 === t ? void 0 : t.getDeviceEd25519Key()) && void 0 !== e ? e : null
					}
					getDeviceCurve25519Key() {
						var e, t;
						return null !== (e = null === (t = this.crypto) || void 0 === t ? void 0 : t.getDeviceCurve25519Key()) && void 0 !== e ? e : null
					}
					async uploadKeys() {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						await this.crypto.uploadDeviceKeys()
					}
					downloadKeys(e, t) {
						return this.crypto ? this.crypto.downloadKeys(e, t) : Promise.reject(new Error("End-to-end encryption disabled"))
					}
					getStoredDevicesForUser(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.getStoredDevicesForUser(e) || []
					}
					getStoredDevice(e, t) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.getStoredDevice(e, t) || null
					}
					setDeviceVerified(e, t, i = !0) {
						const n = this.setDeviceVerification(e, t, i, null, null);
						return e == this.credentials.userId && this.checkKeyBackup(), n
					}
					setDeviceBlocked(e, t, i = !0) {
						return this.setDeviceVerification(e, t, null, i, null)
					}
					setDeviceKnown(e, t, i = !0) {
						return this.setDeviceVerification(e, t, null, null, i)
					}
					async setDeviceVerification(e, t, i, n, r) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						await this.crypto.setDeviceVerification(e, t, i, n, r)
					}
					requestVerificationDM(e, t) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.requestVerificationDM(e, t)
					}
					findVerificationRequestDMInProgress(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.findVerificationRequestDMInProgress(e)
					}
					getVerificationRequestsToDeviceInProgress(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.getVerificationRequestsToDeviceInProgress(e)
					}
					requestVerification(e, t) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.requestVerification(e, t)
					}
					beginKeyVerification(e, t, i) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.beginKeyVerification(e, t, i)
					}
					checkSecretStorageKey(e, t) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.checkSecretStorageKey(e, t)
					}
					setGlobalBlacklistUnverifiedDevices(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.globalBlacklistUnverifiedDevices = e, e
					}
					getGlobalBlacklistUnverifiedDevices() {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.globalBlacklistUnverifiedDevices
					}
					setGlobalErrorOnUnknownDevices(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						this.crypto.globalErrorOnUnknownDevices = e
					}
					getGlobalErrorOnUnknownDevices() {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.globalErrorOnUnknownDevices
					}
					getCrossSigningId(e = O.CrossSigningKey.Master) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.getCrossSigningId(e)
					}
					getStoredCrossSigningForUser(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.getStoredCrossSigningForUser(e)
					}
					checkUserTrust(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.checkUserTrust(e)
					}
					checkDeviceTrust(e, t) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.checkDeviceTrust(e, t)
					}
					checkIfOwnDeviceCrossSigned(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.checkIfOwnDeviceCrossSigned(e)
					}
					checkOwnCrossSigningTrust(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.checkOwnCrossSigningTrust(e)
					}
					checkCrossSigningPrivateKey(e, t) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.checkCrossSigningPrivateKey(e, t)
					}
					legacyDeviceVerification(e, t, i) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.legacyDeviceVerification(e, t, i)
					}
					prepareToEncrypt(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.prepareToEncrypt(e)
					}
					isCrossSigningReady() {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.isCrossSigningReady()
					}
					bootstrapCrossSigning(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.bootstrapCrossSigning(e)
					}
					getCryptoTrustCrossSignedDevices() {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.getCryptoTrustCrossSignedDevices()
					}
					setCryptoTrustCrossSignedDevices(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.setCryptoTrustCrossSignedDevices(e)
					}
					countSessionsNeedingBackup() {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.countSessionsNeedingBackup()
					}
					getEventEncryptionInfo(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.getEventEncryptionInfo(e)
					}
					createRecoveryKeyFromPassphrase(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.createRecoveryKeyFromPassphrase(e)
					}
					isSecretStorageReady() {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.isSecretStorageReady()
					}
					bootstrapSecretStorage(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.bootstrapSecretStorage(e)
					}
					addSecretStorageKey(e, t, i) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.addSecretStorageKey(e, t, i)
					}
					hasSecretStorageKey(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.hasSecretStorageKey(e)
					}
					storeSecret(e, t, i) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.storeSecret(e, t, i)
					}
					getSecret(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.getSecret(e)
					}
					isSecretStored(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.isSecretStored(e)
					}
					requestSecret(e, t) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.requestSecret(e, t)
					}
					getDefaultSecretStorageKeyId() {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.getDefaultSecretStorageKeyId()
					}
					setDefaultSecretStorageKeyId(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.setDefaultSecretStorageKeyId(e)
					}
					checkSecretStoragePrivateKey(e, t) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.checkSecretStoragePrivateKey(e, t)
					}
					async getEventSenderDeviceInfo(e) {
						return this.crypto ? this.crypto.getEventSenderDeviceInfo(e) : null
					}
					async isEventSenderVerified(e) {
						const t = await this.getEventSenderDeviceInfo(e);
						return !!t && t.isVerified()
					}
					cancelAndResendEventRoomKeyRequest(e) {
						if (!this.crypto) throw new Error("End-to-End encryption disabled");
						return e.cancelAndResendKeyRequest(this.crypto, this.getUserId())
					}
					setRoomEncryption(e, t) {
						if (!this.crypto) throw new Error("End-to-End encryption disabled");
						return this.crypto.setRoomEncryption(e, t)
					}
					isRoomEncrypted(e) {
						const t = this.getRoom(e);
						return !!t && (!!t.currentState.getStateEvents(P.EventType.RoomEncryption, "") || this.roomList.isRoomEncrypted(e))
					}
					encryptAndSendToDevices(e, t) {
						if (!this.crypto) throw new Error("End-to-End encryption disabled");
						return this.crypto.encryptAndSendToDevices(e, t)
					}
					forceDiscardSession(e) {
						if (!this.crypto) throw new Error("End-to-End encryption disabled");
						this.crypto.forceDiscardSession(e)
					}
					exportRoomKeys() {
						return this.crypto ? this.crypto.exportRoomKeys() : Promise.reject(new Error("End-to-end encryption disabled"))
					}
					importRoomKeys(e, t) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.importRoomKeys(e, t)
					}
					checkKeyBackup() {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.backupManager.checkKeyBackup()
					}
					async getKeyBackupVersion() {
						let e;
						try {
							e = await this.http.authedRequest(E.Method.Get, "/room_keys/version", void 0, void 0, {
								prefix: E.ClientPrefix.V3
							})
						} catch (t) {
							if ("M_NOT_FOUND" === t.errcode) return null;
							throw t
						}
						return U.BackupManager.checkBackupVersion(e), e
					}
					isKeyBackupTrusted(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.backupManager.isKeyBackupTrusted(e)
					}
					getKeyBackupEnabled() {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.backupManager.getKeyBackupEnabled()
					}
					enableKeyBackup(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.backupManager.enableKeyBackup(e)
					}
					disableKeyBackup() {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						this.crypto.backupManager.disableKeyBackup()
					}
					async prepareKeyBackupVersion(e, t = {
						secureSecretStorage: !1
					}) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						const {
							algorithm: i,
							auth_data: n,
							recovery_key: r,
							privateKey: s
						} = await this.crypto.backupManager.prepareKeyBackupVersion(e);
						return t.secureSecretStorage && (await this.storeSecret("m.megolm_backup.v1", (0, v.encodeBase64)(s)), _.logger.info("Key backup private key stored in secret storage")), {
							algorithm: i,
							auth_data: n,
							recovery_key: r
						}
					}
					isKeyBackupKeyStored() {
						return Promise.resolve(this.isSecretStored("m.megolm_backup.v1"))
					}
					async createKeyBackupVersion(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						await this.crypto.backupManager.createKeyBackupVersion(e);
						const t = {
							algorithm: e.algorithm,
							auth_data: e.auth_data
						};
						await this.crypto.signObject(t.auth_data), this.cryptoCallbacks.getCrossSigningKey && this.crypto.crossSigningInfo.getId() && await this.crypto.crossSigningInfo.signObject(t.auth_data, "master");
						const i = await this.http.authedRequest(E.Method.Post, "/room_keys/version", void 0, t, {
							prefix: E.ClientPrefix.V3
						});
						return await this.checkKeyBackup(), this.getKeyBackupEnabled() || _.logger.error("Key backup not usable even though we just created it"), i
					}
					async deleteKeyBackupVersion(e) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						this.crypto.backupManager.version && this.crypto.backupManager.disableKeyBackup();
						const t = m.encodeUri("/room_keys/version/$version", {
							$version: e
						});
						await this.http.authedRequest(E.Method.Delete, t, void 0, void 0, {
							prefix: E.ClientPrefix.V3
						})
					}
					makeKeyBackupPath(e, t, i) {
						let n;
						return {
							path: n = void 0 !== t ? m.encodeUri("/room_keys/keys/$roomId/$sessionId", {
								$roomId: e,
								$sessionId: t
							}) : void 0 !== e ? m.encodeUri("/room_keys/keys/$roomId", {
								$roomId: e
							}) : "/room_keys/keys",
							queryData: void 0 === i ? void 0 : {
								version: i
							}
						}
					}
					async sendKeyBackup(e, t, i, n) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						const r = this.makeKeyBackupPath(e, t, i);
						await this.http.authedRequest(E.Method.Put, r.path, r.queryData, n, {
							prefix: E.ClientPrefix.V3
						})
					}
					async scheduleAllGroupSessionsForBackup() {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						await this.crypto.backupManager.scheduleAllGroupSessionsForBackup()
					}
					flagAllGroupSessionsForBackup() {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						return this.crypto.backupManager.flagAllGroupSessionsForBackup()
					}
					isValidRecoveryKey(e) {
						try {
							return (0, k.decodeRecoveryKey)(e), !0
						} catch (t) {
							return !1
						}
					}
					keyBackupKeyFromPassword(e, t) {
						return (0, T.keyFromAuthData)(t.auth_data, e)
					}
					keyBackupKeyFromRecoveryKey(e) {
						return (0, k.decodeRecoveryKey)(e)
					}
					async restoreKeyBackupWithPassword(e, t, i, n, r) {
						const s = await (0, T.keyFromAuthData)(n.auth_data, e);
						return this.restoreKeyBackup(s, t, i, n, r)
					}
					async restoreKeyBackupWithSecretStorage(e, t, i, n) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						const r = await this.getSecret("m.megolm_backup.v1"),
							s = (0, w.fixBackupKey)(r);
						if (s) {
							const e = await this.crypto.getSecretStorageKey();
							await this.storeSecret("m.megolm_backup.v1", s, [e[0]])
						}
						const o = (0, v.decodeBase64)(s || r);
						return this.restoreKeyBackup(o, t, i, e, n)
					}
					restoreKeyBackupWithRecoveryKey(e, t, i, n, r) {
						const s = (0, k.decodeRecoveryKey)(e);
						return this.restoreKeyBackup(s, t, i, n, r)
					}
					async restoreKeyBackupWithCache(e, t, i, n) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						const r = await this.crypto.getSessionBackupPrivateKey();
						if (!r) throw new Error("Couldn't get key");
						return this.restoreKeyBackup(r, e, t, i, n)
					}
					async restoreKeyBackup(e, t, i, n, r) {
						const s = null == r ? void 0 : r.cacheCompleteCallback,
							o = null == r ? void 0 : r.progressCallback;
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						let a = 0,
							d = [];
						const l = this.makeKeyBackupPath(t, i, n.version),
							c = await U.BackupManager.makeAlgorithm(n, async () => e),
							u = c.untrusted;
						try {
							if (!(await c.keyMatches(e))) return Promise.reject(new E.MatrixError({
								errcode: ye.RESTORE_BACKUP_ERROR_BAD_KEY
							}));
							this.crypto.storeSessionBackupPrivateKey(e).catch(e => {
								_.logger.warn("Error caching session backup key:", e)
							}).then(s), o && o({
								stage: "fetch"
							});
							const n = await this.http.authedRequest(E.Method.Get, l.path, l.queryData, void 0, {
								prefix: E.ClientPrefix.V3
							});
							if (n.rooms) {
								const e = n.rooms;
								for (const [t, i] of Object.entries(e)) {
									if (!i.sessions) continue;
									a += Object.keys(i.sessions).length;
									const e = await c.decryptSessions(i.sessions);
									for (const i of e) i.room_id = t, d.push(i)
								}
							} else if (n.sessions) {
								const e = n.sessions;
								a = Object.keys(e).length, d = await c.decryptSessions(e);
								for (const i of d) i.room_id = t
							} else {
								a = 1;
								try {
									const [e] = await c.decryptSessions({
										[i]: n
									});
									e.room_id = t, e.session_id = i, d.push(e)
								} catch (h) {
									_.logger.log("Failed to decrypt megolm session from backup", h)
								}
							}
						} finally {
							c.free()
						}
						return await this.importRoomKeys(d, {
							progressCallback: o,
							untrusted: u,
							source: "backup"
						}), await this.checkKeyBackup(), {
							total: a,
							imported: d.length
						}
					}
					async deleteKeysFromBackup(e, t, i) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						const n = this.makeKeyBackupPath(e, t, i);
						await this.http.authedRequest(E.Method.Delete, n.path, n.queryData, void 0, {
							prefix: E.ClientPrefix.V3
						})
					}
					async sendSharedHistoryKeys(e, t) {
						if (!this.crypto) throw new Error("End-to-end encryption disabled");
						const i = this.roomList.getRoomEncryption(e);
						if (!i) return void _.logger.error("Unknown room.  Not sharing decryption keys");
						const n = await this.crypto.downloadKeys(t),
							r = {};
						for (const [o, a] of Object.entries(n)) r[o] = Object.values(a);
						const s = this.crypto.getRoomDecryptor(e, i.algorithm);
						s.sendSharedHistoryInboundSessions ? await s.sendSharedHistoryInboundSessions(r) : _.logger.warn("Algorithm does not support sharing previous keys", i.algorithm)
					}
					getMediaConfig() {
						return this.http.authedRequest(E.Method.Get, "/config", void 0, void 0, {
							prefix: E.MediaPrefix.R0
						})
					}
					getRoom(e) {
						return e ? this.store.getRoom(e) : null
					}
					getRooms() {
						return this.store.getRooms()
					}
					getVisibleRooms() {
						const e = this.store.getRooms(),
							t = new Set;
						for (const i of e) {
							const e = i.currentState.getStateEvents(P.EventType.RoomCreate, "");
							if (e) {
								const i = e.getContent().predecessor;
								i && i.room_id && t.add(i.room_id)
							}
						}
						return e.filter(e => {
							return !e.currentState.getStateEvents(P.EventType.RoomTombstone, "") || !t.has(e.roomId)
						})
					}
					getUser(e) {
						return this.store.getUser(e)
					}
					getUsers() {
						return this.store.getUsers()
					}
					setAccountData(e, t) {
						const i = m.encodeUri("/user/$userId/account_data/$type", {
							$userId: this.credentials.userId,
							$type: e
						});
						return (0, E.retryNetworkOperation)(5, () => this.http.authedRequest(E.Method.Put, i, void 0, t))
					}
					getAccountData(e) {
						return this.store.getAccountData(e)
					}
					async getAccountDataFromServer(e) {
						if (this.isInitialSyncComplete()) {
							const t = this.store.getAccountData(e);
							return t ? t.getContent() : null
						}
						const t = m.encodeUri("/user/$userId/account_data/$type", {
							$userId: this.credentials.userId,
							$type: e
						});
						try {
							return await this.http.authedRequest(E.Method.Get, t)
						} catch (n) {
							var i;
							if ("M_NOT_FOUND" === (null === (i = n.data) || void 0 === i ? void 0 : i.errcode)) return null;
							throw n
						}
					}
					getIgnoredUsers() {
						const e = this.getAccountData("m.ignored_user_list");
						return e && e.getContent() && e.getContent().ignored_users ? Object.keys(e.getContent().ignored_users) : []
					}
					setIgnoredUsers(e) {
						const t = {
							ignored_users: {}
						};
						return e.forEach(e => {
							t.ignored_users[e] = {}
						}), this.setAccountData("m.ignored_user_list", t)
					}
					isUserIgnored(e) {
						return this.getIgnoredUsers().includes(e)
					}
					async joinRoom(e, t = {}) {
						void 0 === t.syncRoom && (t.syncRoom = !0);
						const i = this.getRoom(e);
						if (null != i && i.hasMembershipState(this.credentials.userId, "join")) return Promise.resolve(i);
						let n = Promise.resolve();
						t.inviteSignUrl && (n = this.http.requestOtherUrl(E.Method.Post, new URL(t.inviteSignUrl), {
							mxid: this.credentials.userId
						}));
						const r = {};
						t.viaServers && (r.server_name = t.viaServers);
						try {
							const i = {},
								s = await n;
							s && (i.third_party_signed = s);
							const o = m.encodeUri("/join/$roomid", {
									$roomid: e
								}),
								d = (await this.http.authedRequest(E.Method.Post, o, r, i)).room_id,
								l = new a.SyncApi(this, this.clientOpts).createRoom(d);
							return t.syncRoom, l
						} catch (s) {
							throw s
						}
					}
					resendEvent(e, t) {
						return this.toDeviceMessageQueue.sendQueue(), this.updatePendingEventStatus(t, e, d.EventStatus.SENDING), this.encryptAndSendEvent(t, e)
					}
					cancelPendingEvent(e) {
						if (![d.EventStatus.QUEUED, d.EventStatus.NOT_SENT, d.EventStatus.ENCRYPTING].includes(e.status)) throw new Error("cannot cancel an event with status " + e.status);
						e.status === d.EventStatus.ENCRYPTING ? this.pendingEventEncryption.delete(e.getId()) : this.scheduler && e.status === d.EventStatus.QUEUED && this.scheduler.removeEventFromQueue(e);
						const t = this.getRoom(e.getRoomId());
						this.updatePendingEventStatus(t, e, d.EventStatus.CANCELLED)
					}
					setRoomName(e, t) {
						return this.sendStateEvent(e, P.EventType.RoomName, {
							name: t
						})
					}
					setRoomTopic(e, t, i) {
						const n = x.makeTopicContent(t, i);
						return this.sendStateEvent(e, P.EventType.RoomTopic, n)
					}
					getRoomTags(e) {
						const t = m.encodeUri("/user/$userId/rooms/$roomId/tags", {
							$userId: this.credentials.userId,
							$roomId: e
						});
						return this.http.authedRequest(E.Method.Get, t)
					}
					setRoomTag(e, t, i) {
						const n = m.encodeUri("/user/$userId/rooms/$roomId/tags/$tag", {
							$userId: this.credentials.userId,
							$roomId: e,
							$tag: t
						});
						return this.http.authedRequest(E.Method.Put, n, void 0, i)
					}
					deleteRoomTag(e, t) {
						const i = m.encodeUri("/user/$userId/rooms/$roomId/tags/$tag", {
							$userId: this.credentials.userId,
							$roomId: e,
							$tag: t
						});
						return this.http.authedRequest(E.Method.Delete, i)
					}
					setRoomAccountData(e, t, i) {
						const n = m.encodeUri("/user/$userId/rooms/$roomId/account_data/$type", {
							$userId: this.credentials.userId,
							$roomId: e,
							$type: t
						});
						return this.http.authedRequest(E.Method.Put, n, void 0, i)
					}
					setPowerLevel(e, t, i, n) {
						let r = {
							users: {}
						};
						(null == n ? void 0 : n.getType()) === P.EventType.RoomPowerLevels && (r = m.deepCopy(n.getContent())), r.users[t] = i;
						const s = m.encodeUri("/rooms/$roomId/state/m.room.power_levels", {
							$roomId: e
						});
						return this.http.authedRequest(E.Method.Put, s, void 0, r)
					}
					async unstable_createLiveBeacon(e, t) {
						return this.unstable_setLiveBeacon(e, t)
					}
					async unstable_setLiveBeacon(e, t) {
						return this.sendStateEvent(e, z.M_BEACON_INFO.name, t, this.getUserId())
					}
					sendEvent(e, t, i, n, r) {
						var s, o;
						if (null !== (s = t) && void 0 !== s && s.startsWith(ge) || null === t || (r = n, n = i, i = t, t = null), t && (null === (o = n["m.relates_to"]) || void 0 === o || !o.rel_type)) {
							var a, d;
							const i = !(null === (a = n["m.relates_to"]) || void 0 === a || !a["m.in_reply_to"]);
							n["m.relates_to"] = se(se({}, n["m.relates_to"]), {}, {
								rel_type: H.THREAD_RELATION_TYPE.name,
								event_id: t,
								is_falling_back: !i
							});
							const r = null === (d = this.getRoom(e)) || void 0 === d ? void 0 : d.getThread(t);
							var l, c;
							if (r && !i) n["m.relates_to"]["m.in_reply_to"] = {
								event_id: null !== (l = null === (c = r.lastReply(e => e.isRelation(H.THREAD_RELATION_TYPE.name) && !e.status)) || void 0 === c ? void 0 : c.getId()) && void 0 !== l ? l : t
							}
						}
						return this.sendCompleteEvent(e, t, {
							type: i,
							content: n
						}, r)
					}
					sendCompleteEvent(e, t, i, n) {
						n || (n = this.makeTxnId());
						const r = new d.MatrixEvent(Object.assign(i, {
								event_id: "~" + e + ":" + n,
								user_id: this.credentials.userId,
								sender: this.credentials.userId,
								room_id: e,
								origin_server_ts: (new Date).getTime()
							})),
							s = this.getRoom(e),
							o = t ? null == s ? void 0 : s.getThread(t) : void 0;
						o && r.setThread(o), this.reEmitter.reEmit(r, [d.MatrixEventEvent.Replaced, d.MatrixEventEvent.VisibilityChange]), null == s || s.reEmitter.reEmit(r, [d.MatrixEventEvent.BeforeRedaction]);
						const a = r.getAssociatedId();
						if (null != a && a.startsWith("~")) {
							const e = null == s ? void 0 : s.getPendingEvents().find(e => e.getId() === a);
							null == e || e.once(d.MatrixEventEvent.LocalEventIdReplaced, () => {
								r.updateAssociatedId(e.getId())
							})
						}
						const l = r.getType();
						return _.logger.log(`sendEvent of type ${l} in ${e} with txnId ${n}`), r.setTxnId(n), r.setStatus(d.EventStatus.SENDING), null == s || s.addPendingEvent(r, n), r.status === d.EventStatus.NOT_SENT ? Promise.reject(new Error("Event blocked by other events not yet sent")) : this.encryptAndSendEvent(s, r)
					}
					encryptAndSendEvent(e, t) {
						let i = !1;
						return Promise.resolve().then(() => {
							const n = this.encryptEventIfNeeded(t, null != e ? e : void 0);
							return n ? (this.pendingEventEncryption.set(t.getId(), n), this.updatePendingEventStatus(e, t, d.EventStatus.ENCRYPTING), n.then(() => {
								this.pendingEventEncryption.has(t.getId()) ? this.updatePendingEventStatus(e, t, d.EventStatus.SENDING) : i = !0
							})) : null
						}).then(() => {
							if (i) return {};
							let n = null;
							return this.scheduler && (n = this.scheduler.queueEvent(t)) && this.scheduler.getQueueForEvent(t).length > 1 && this.updatePendingEventStatus(e, t, d.EventStatus.QUEUED), n || (n = this.sendEventHttpRequest(t), e && (n = n.then(i => (e.updatePendingEvent(t, d.EventStatus.SENT, i.event_id), i)))), n
						}).catch(i => {
							_.logger.error("Error sending event", i.stack || i);
							try {
								t.error = i, this.updatePendingEventStatus(e, t, d.EventStatus.NOT_SENT)
							} catch (n) {
								_.logger.error("Exception in error handler!", n.stack || i)
							}
							throw i instanceof E.MatrixError && (i.event = t), i
						})
					}
					encryptEventIfNeeded(e, t) {
						if (e.isEncrypted()) return null;
						if (e.isRedaction()) return null;
						if (!this.isRoomEncrypted(e.getRoomId())) return null;
						if (!this.crypto && this.usingExternalCrypto) return null;
						if (e.getType() === P.EventType.Reaction) return null;
						if (!this.crypto) throw new Error("This room is configured to use encryption, but your client does not support encryption.");
						return this.crypto.encryptEvent(e, t)
					}
					getEncryptedIfNeededEventType(e, t) {
						return t === P.EventType.Reaction ? t : this.isRoomEncrypted(e) ? P.EventType.RoomMessageEncrypted : t
					}
					updatePendingEventStatus(e, t, i) {
						e ? e.updatePendingEvent(t, i) : t.setStatus(i)
					}
					sendEventHttpRequest(e) {
						let t = e.getTxnId();
						t || (t = this.makeTxnId(), e.setTxnId(t));
						const i = {
							$roomId: e.getRoomId(),
							$eventType: e.getWireType(),
							$stateKey: e.getStateKey(),
							$txnId: t
						};
						let n;
						if (e.isState()) {
							let t = "/rooms/$roomId/state/$eventType";
							e.getStateKey() && e.getStateKey().length > 0 && (t = "/rooms/$roomId/state/$eventType/$stateKey"), n = m.encodeUri(t, i)
						} else if (e.isRedaction()) {
							const t = "/rooms/$roomId/redact/$redactsEventId/$txnId";
							n = m.encodeUri(t, se({
								$redactsEventId: e.event.redacts
							}, i))
						} else n = m.encodeUri("/rooms/$roomId/send/$eventType/$txnId", i);
						return this.http.authedRequest(E.Method.Put, n, void 0, e.getWireContent()).then(t => (_.logger.log(`Event sent to ${e.getRoomId()} with event id ${t.event_id}`), t))
					}
					redactEvent(e, t, i, n, r) {
						var s, o;
						null !== (s = i) && void 0 !== s && s.startsWith(ge) || (r = n, n = i, i = t, t = null);
						const a = null === (o = r) || void 0 === o ? void 0 : o.reason;
						return this.sendCompleteEvent(e, t, {
							type: P.EventType.RoomRedaction,
							content: {
								reason: a
							},
							redacts: i
						}, n)
					}
					sendMessage(e, t, i, n) {
						"string" != typeof t && null !== t && (n = i, i = t, t = null);
						let r = P.EventType.RoomMessage,
							s = i;
						const a = (e = {}, t = !0) => {
								let i;
								if (e.msgtype === P.MsgType.Text ? i = o.MessageEvent.from(e.body, e.formatted_body).serialize() : e.msgtype === P.MsgType.Emote ? i = o.EmoteEvent.from(e.body, e.formatted_body).serialize() : e.msgtype === P.MsgType.Notice && (i = o.NoticeEvent.from(e.body, e.formatted_body).serialize()), i && e["m.new_content"] && t) {
									const t = a(e["m.new_content"], !1);
									t && (i.content["m.new_content"] = t.content)
								}
								if (i)
									for (const [n, r] of Object.entries(e)) i.content.hasOwnProperty(n) || (i.content[n] = r);
								return i
							},
							d = a(s);
						return d && (r = d.type, s = d.content), this.sendEvent(e, t, r, s, n)
					}
					sendTextMessage(e, t, i, n) {
						var r;
						null !== (r = t) && void 0 !== r && r.startsWith(ge) || null === t || (n = i, i = t, t = null);
						const s = x.makeTextMessage(i);
						return this.sendMessage(e, t, s, n)
					}
					sendNotice(e, t, i, n) {
						var r;
						null !== (r = t) && void 0 !== r && r.startsWith(ge) || null === t || (n = i, i = t, t = null);
						const s = x.makeNotice(i);
						return this.sendMessage(e, t, s, n)
					}
					sendEmoteMessage(e, t, i, n) {
						var r;
						null !== (r = t) && void 0 !== r && r.startsWith(ge) || null === t || (n = i, i = t, t = null);
						const s = x.makeEmoteMessage(i);
						return this.sendMessage(e, t, s, n)
					}
					sendImageMessage(e, t, i, n, r = "Image") {
						var s;
						null !== (s = t) && void 0 !== s && s.startsWith(ge) || null === t || (r = n || "Image", n = i, i = t, t = null);
						const o = {
							msgtype: P.MsgType.Image,
							url: i,
							info: n,
							body: r
						};
						return this.sendMessage(e, t, o)
					}
					sendStickerMessage(e, t, i, n, r = "Sticker") {
						var s;
						null !== (s = t) && void 0 !== s && s.startsWith(ge) || null === t || (r = n || "Sticker", n = i, i = t, t = null);
						const o = {
							url: i,
							info: n,
							body: r
						};
						return this.sendEvent(e, t, P.EventType.Sticker, o)
					}
					sendHtmlMessage(e, t, i, n) {
						var r;
						null !== (r = t) && void 0 !== r && r.startsWith(ge) || null === t || (n = i, i = t, t = null);
						const s = x.makeHtmlMessage(i, n);
						return this.sendMessage(e, t, s)
					}
					sendHtmlNotice(e, t, i, n) {
						var r;
						null !== (r = t) && void 0 !== r && r.startsWith(ge) || null === t || (n = i, i = t, t = null);
						const s = x.makeHtmlNotice(i, n);
						return this.sendMessage(e, t, s)
					}
					sendHtmlEmote(e, t, i, n) {
						var r;
						null !== (r = t) && void 0 !== r && r.startsWith(ge) || null === t || (n = i, i = t, t = null);
						const s = x.makeHtmlEmote(i, n);
						return this.sendMessage(e, t, s)
					}
					async sendReceipt(e, t, i, n = !1) {
						if (this.isGuest()) return Promise.resolve({});
						const r = m.encodeUri("/rooms/$roomId/receipt/$receiptType/$eventId", {
							$roomId: e.getRoomId(),
							$receiptType: t,
							$eventId: e.getId()
						});
						if (this.canSupport.get(ee.Feature.ThreadUnreadNotifications) !== ee.ServerSupport.Unsupported && !n) {
							const t = !!e.threadRootId;
							i = se(se({}, i), {}, {
								thread_id: t ? e.threadRootId : Q.MAIN_ROOM_TIMELINE
							})
						}
						const s = this.http.authedRequest(E.Method.Post, r, void 0, i || {}),
							o = this.getRoom(e.getRoomId());
						return o && this.credentials.userId && o.addLocalEchoReceipt(this.credentials.userId, e, t), s
					}
					async sendReadReceipt(e, t = W.ReceiptType.Read, i = !1) {
						if (!e) return;
						const n = e.getId(),
							r = this.getRoom(e.getRoomId());
						if (null != r && r.hasPendingEvent(n)) throw new Error(`Cannot set read receipt to a pending event (${n})`);
						return this.sendReceipt(e, t, {}, i)
					}
					async setRoomReadMarkers(e, t, i, n) {
						const r = this.getRoom(e);
						if (r && r.hasPendingEvent(t)) throw new Error(`Cannot set read marker to a pending event (${t})`);
						let s, o;
						if (i) {
							if (s = i.getId(), null != r && r.hasPendingEvent(s)) throw new Error(`Cannot set read receipt to a pending event (${s})`);
							null == r || r.addLocalEchoReceipt(this.credentials.userId, i, W.ReceiptType.Read)
						}
						if (n) {
							if (o = n.getId(), null != r && r.hasPendingEvent(o)) throw new Error(`Cannot set read receipt to a pending event (${o})`);
							null == r || r.addLocalEchoReceipt(this.credentials.userId, n, W.ReceiptType.ReadPrivate)
						}
						return await this.setRoomReadMarkersHttpRequest(e, t, s, o)
					}
					getUrlPreview(e, t) {
						t = 6e4 * Math.floor(t / 6e4);
						const i = new URL(e);
						i.hash = "";
						const n = t + "_" + (e = i.toString()),
							r = this.urlPreviewCache[n];
						if (r) return r;
						const s = this.http.authedRequest(E.Method.Get, "/preview_url", {
							url: e,
							ts: t.toString()
						}, void 0, {
							prefix: E.MediaPrefix.R0
						});
						return this.urlPreviewCache[n] = s, s
					}
					sendTyping(e, t, i) {
						if (this.isGuest()) return Promise.resolve({});
						const n = m.encodeUri("/rooms/$roomId/typing/$userId", {
								$roomId: e,
								$userId: this.getUserId()
							}),
							r = {
								typing: t
							};
						return t && (r.timeout = i || 2e4), this.http.authedRequest(E.Method.Put, n, void 0, r)
					}
					getRoomUpgradeHistory(e, t = !1) {
						let i = this.getRoom(e);
						if (!i) return [];
						const n = [i];
						let r = i.currentState.getStateEvents(P.EventType.RoomCreate, "");
						for (; r;) {
							const e = r.getContent().predecessor;
							if (!e || !e.room_id) break; {
								const i = this.getRoom(e.room_id);
								if (!i) break;
								if (t) {
									const e = i.currentState.getStateEvents(P.EventType.RoomTombstone, "");
									if (!e || e.getContent().replacement_room !== i.roomId) break
								}
								n.splice(0, 0, i), r = i.currentState.getStateEvents(P.EventType.RoomCreate, "")
							}
						}
						let s = i.currentState.getStateEvents(P.EventType.RoomTombstone, "");
						for (; s;) {
							const e = this.getRoom(s.getContent().replacement_room);
							if (!e) break;
							if (e.roomId === i.roomId) break;
							if (t) {
								if (!(r = e.currentState.getStateEvents(P.EventType.RoomCreate, "")) || !r.getContent().predecessor) break;
								if (r.getContent().predecessor.room_id !== i.roomId) break
							}
							if (n.push(e), new Set(n.map(e => e.roomId)).size < n.length) return n.slice(0, n.length - 1);
							s = (i = e).currentState.getStateEvents(P.EventType.RoomTombstone, "")
						}
						return n
					}
					invite(e, t, i) {
						return this.membershipChange(e, t, "invite", i)
					}
					inviteByEmail(e, t) {
						return this.inviteByThreePid(e, "email", t)
					}
					async inviteByThreePid(e, t, i) {
						var n;
						const r = m.encodeUri("/rooms/$roomId/invite", {
								$roomId: e
							}),
							s = this.getIdentityServerUrl(!0);
						if (!s) return Promise.reject(new E.MatrixError({
							error: "No supplied identity server URL",
							errcode: "ORG.MATRIX.JSSDK_MISSING_PARAM"
						}));
						const o = {
							id_server: s,
							medium: t,
							address: i
						};
						if (null !== (n = this.identityServer) && void 0 !== n && n.getAccessToken && await this.doesServerAcceptIdentityAccessToken()) {
							const e = await this.identityServer.getAccessToken();
							e && (o.id_access_token = e)
						}
						return this.http.authedRequest(E.Method.Post, r, void 0, o)
					}
					leave(e) {
						return this.membershipChange(e, void 0, "leave")
					}
					leaveRoomChain(e, t = !0) {
						const i = this.getRoomUpgradeHistory(e);
						let n = i;
						if (!t) {
							n = [];
							for (const t of i)
								if (n.push(t), t.roomId === e) break
						}
						const r = {},
							s = [],
							o = e => this.leave(e).then(() => {
								delete r[e]
							}).catch(t => (r[e] = t, null));
						for (const a of n) s.push(o(a.roomId));
						return Promise.all(s).then(() => r)
					}
					ban(e, t, i) {
						return this.membershipChange(e, t, "ban", i)
					}
					forget(e, t = !0) {
						const i = this.membershipChange(e, void 0, "forget");
						return t ? i.then(t => (this.store.removeRoom(e), this.emit(fe.DeleteRoom, e), t)) : i
					}
					unban(e, t) {
						const i = m.encodeUri("/rooms/$roomId/unban", {
								$roomId: e
							}),
							n = {
								user_id: t
							};
						return this.http.authedRequest(E.Method.Post, i, void 0, n)
					}
					kick(e, t, i) {
						const n = m.encodeUri("/rooms/$roomId/kick", {
								$roomId: e
							}),
							r = {
								user_id: t,
								reason: i
							};
						return this.http.authedRequest(E.Method.Post, n, void 0, r)
					}
					membershipChange(e, t, i, n) {
						const r = m.encodeUri("/rooms/$room_id/$membership", {
							$room_id: e,
							$membership: i
						});
						return this.http.authedRequest(E.Method.Post, r, void 0, {
							user_id: t,
							reason: n
						})
					}
					getPushActionsForEvent(e, t = !1) {
						return e.getPushActions() && !t || e.setPushActions(this.pushProcessor.actionsForEvent(e)), e.getPushActions()
					}
					setProfileInfo(e, t) {
						const i = m.encodeUri("/profile/$userId/$info", {
							$userId: this.credentials.userId,
							$info: e
						});
						return this.http.authedRequest(E.Method.Put, i, void 0, t)
					}
					async setDisplayName(e) {
						const t = await this.setProfileInfo("displayname", {
								displayname: e
							}),
							i = this.getUser(this.getUserId());
						return i && (i.displayName = e, i.emit(I.UserEvent.DisplayName, i.events.presence, i)), t
					}
					async setAvatarUrl(e) {
						const t = await this.setProfileInfo("avatar_url", {
								avatar_url: e
							}),
							i = this.getUser(this.getUserId());
						return i && (i.avatarUrl = e, i.emit(I.UserEvent.AvatarUrl, i.events.presence, i)), t
					}
					mxcUrlToHttp(e, t, i, n, r) {
						return (0, C.getHttpUriForMxc)(this.baseUrl, e, t, i, n, r)
					}
					async setPresence(e) {
						const t = m.encodeUri("/presence/$userId/status", {
							$userId: this.credentials.userId
						});
						if (-1 === ["offline", "online", "unavailable"].indexOf(e.presence)) throw new Error("Bad presence value: " + e.presence);
						await this.http.authedRequest(E.Method.Put, t, void 0, e)
					}
					getPresence(e) {
						const t = m.encodeUri("/presence/$userId/status", {
							$userId: e
						});
						return this.http.authedRequest(E.Method.Get, t)
					}
					scrollback(e, t = 30) {
						let i = 0,
							n = this.ongoingScrollbacks[e.roomId] || {};
						if (n.promise) return n.promise;
						if (n.errorTs) {
							const e = Date.now() - n.errorTs;
							i = Math.max(oe - e, 0)
						}
						if (null === e.oldState.paginationToken) return Promise.resolve(e);
						const r = this.store.scrollback(e, t).length;
						if (r === t) return Promise.resolve(e);
						t -= r;
						const s = new Promise((n, r) => {
							(0, m.sleep)(i).then(() => this.createMessagesRequest(e.roomId, e.oldState.paginationToken, t, p.Direction.Backward)).then(t => {
								const i = t.chunk.map(this.getEventMapper());
								if (t.state) {
									const i = t.state.map(this.getEventMapper());
									e.currentState.setUnknownStateEvents(i)
								}
								const [r, s] = e.partitionThreadedEvents(i);
								this.processBeaconEvents(e, r), e.addEventsToTimeline(r, !0, e.getLiveTimeline()), this.processThreadEvents(e, s, !0), e.oldState.paginationToken = t.end, 0 === t.chunk.length && (e.oldState.paginationToken = null), this.store.storeEvents(e, i, t.end, !0), delete this.ongoingScrollbacks[e.roomId], n(e)
							}).catch(t => {
								this.ongoingScrollbacks[e.roomId] = {
									errorTs: Date.now()
								}, r(t)
							})
						});
						return n = {
							promise: s
						}, this.ongoingScrollbacks[e.roomId] = n, s
					}
					getEventMapper(e) {
						return (0, A.eventMapperFor)(this, e || {})
					}
					async getEventTimeline(e, t) {
						var i, n, r, s;
						if (!this.timelineSupport) throw new Error("timeline support is disabled. Set the 'timelineSupport' parameter to true when creating MatrixClient to enable it.");
						if (null == e || !e.room) throw new Error("getEventTimeline only supports room timelines");
						if (e.getTimelineForEvent(t)) return e.getTimelineForEvent(t);
						if (e.thread && this.supportsExperimentalThreads()) return this.getThreadTimeline(e, t);
						const o = m.encodeUri("/rooms/$roomId/context/$eventId", {
							$roomId: e.room.roomId,
							$eventId: t
						});
						let a = void 0;
						null !== (i = this.clientOpts) && void 0 !== i && i.lazyLoadMembers && (a = {
							filter: JSON.stringify(u.Filter.LAZY_LOADING_MESSAGES_FILTER)
						});
						const d = await this.http.authedRequest(E.Method.Get, o, a);
						if (!d.event) throw new Error("'event' not in '/context' result - homeserver too old?");
						if (e.getTimelineForEvent(t)) return e.getTimelineForEvent(t);
						const l = this.getEventMapper(),
							c = l(d.event);
						if (c.isRelation(H.THREAD_RELATION_TYPE.name)) return void _.logger.warn("Tried loading a regular timeline at the position of a thread event");
						const h = [...d.events_after.reverse().map(l), c, ...d.events_before.map(l)];
						let g = e.getTimelineForEvent(h[0].getId());
						g ? g.getState(p.EventTimeline.BACKWARDS).setUnknownStateEvents(d.state.map(l)) : ((g = e.addTimeline()).initialiseState(d.state.map(l)), g.getState(p.EventTimeline.FORWARDS).paginationToken = d.end);
						const [f, v] = e.room.partitionThreadedEvents(h);
						return e.addEventsToTimeline(f, !0, g, d.start), this.processThreadEvents(e.room, v, !0), this.processBeaconEvents(e.room, f), null !== (n = null !== (r = e.getTimelineForEvent(t)) && void 0 !== r ? r : null === (s = e.room.findThreadForEvent(c)) || void 0 === s ? void 0 : s.liveTimeline) && void 0 !== n ? n : g
					}
					async getThreadTimeline(e, t) {
						var i;
						if (!this.supportsExperimentalThreads()) throw new Error("could not get thread timeline: no client support");
						if (!e.room) throw new Error("could not get thread timeline: not a room timeline");
						if (!e.thread) throw new Error("could not get thread timeline: not a thread timeline");
						const n = m.encodeUri("/rooms/$roomId/context/$eventId", {
								$roomId: e.room.roomId,
								$eventId: t
							}),
							r = {
								limit: "0"
							};
						null !== (i = this.clientOpts) && void 0 !== i && i.lazyLoadMembers && (r.filter = JSON.stringify(u.Filter.LAZY_LOADING_MESSAGES_FILTER));
						const s = await this.http.authedRequest(E.Method.Get, n, r),
							o = this.getEventMapper(),
							a = o(s.event);
						if (e.canContain(a) && H.Thread.hasServerSideSupport) {
							if (H.Thread.hasServerSideFwdPaginationSupport) {
								var d, l, c;
								if (!e.thread) throw new Error("could not get thread timeline: not a thread timeline");
								const i = e.thread,
									n = await this.fetchRelations(e.room.roomId, i.id, H.THREAD_RELATION_TYPE.name, null, {
										dir: p.Direction.Backward,
										from: s.start
									}),
									r = await this.fetchRelations(e.room.roomId, i.id, H.THREAD_RELATION_TYPE.name, null, {
										dir: p.Direction.Forward,
										from: s.end
									}),
									u = [...r.chunk.reverse().map(o), a, ...n.chunk.map(o)];
								for (const t of u) {
									var h;
									await (null === (h = e.thread) || void 0 === h ? void 0 : h.processEvent(t))
								}
								let m = e.getTimelineForEvent(a.getId());
								return m ? m.getState(p.EventTimeline.BACKWARDS).setUnknownStateEvents(s.state.map(o)) : (m = e.addTimeline()).initialiseState(s.state.map(o)), e.addEventsToTimeline(u, !0, m, r.next_batch), n.next_batch || e.addEventsToTimeline([o(n.original_event)], !0, m, null), m.setPaginationToken(null !== (d = n.next_batch) && void 0 !== d ? d : null, p.Direction.Backward), m.setPaginationToken(null !== (l = r.next_batch) && void 0 !== l ? l : null, p.Direction.Forward), this.processBeaconEvents(e.room, u), null !== (c = e.getTimelineForEvent(t)) && void 0 !== c ? c : m
							} {
								var g;
								const t = e.thread,
									i = await this.fetchRelations(e.room.roomId, t.id, H.THREAD_RELATION_TYPE.name, null, {
										dir: p.Direction.Backward,
										from: s.start
									}),
									n = [];
								let r = s.end;
								for (; r;) {
									var f;
									const i = await this.fetchRelations(e.room.roomId, t.id, H.THREAD_RELATION_TYPE.name, null, {
										dir: p.Direction.Forward,
										from: r
									});
									r = null !== (f = i.next_batch) && void 0 !== f ? f : null, n.push(...i.chunk)
								}
								const d = [...n.reverse().map(o), a, ...i.chunk.map(o)];
								for (const s of d) {
									var v;
									await (null === (v = e.thread) || void 0 === v ? void 0 : v.processEvent(s))
								}
								const l = e.getLiveTimeline();
								return l.getState(p.EventTimeline.BACKWARDS).setUnknownStateEvents(s.state.map(o)), e.addEventsToTimeline(d, !0, l, null), i.next_batch || e.addEventsToTimeline([o(i.original_event)], !0, l, null), l.setPaginationToken(null !== (g = i.next_batch) && void 0 !== g ? g : null, p.Direction.Backward), l.setPaginationToken(null, p.Direction.Forward), this.processBeaconEvents(e.room, d), l
							}
						}
					}
					async getLatestTimeline(e) {
						if (!this.timelineSupport) throw new Error("timeline support is disabled. Set the 'timelineSupport' parameter to true when creating MatrixClient to enable it.");
						if (!e.room) throw new Error("getLatestTimeline only supports room timelines");
						let t;
						if (null !== e.threadListType) {
							var i;
							t = null === (i = (await this.createThreadListMessagesRequest(e.room.roomId, null, 1, p.Direction.Backward, e.threadListType, e.getFilter())).chunk) || void 0 === i ? void 0 : i[0]
						} else if (e.thread && H.Thread.hasServerSideSupport) {
							var n;
							t = null === (n = (await this.fetchRelations(e.room.roomId, e.thread.id, H.THREAD_RELATION_TYPE.name, null, {
								dir: p.Direction.Backward,
								limit: 1
							})).chunk) || void 0 === n ? void 0 : n[0]
						} else {
							var r, s;
							const i = m.encodeUri("/rooms/$roomId/messages", {
									$roomId: e.room.roomId
								}),
								n = {
									dir: "b"
								};
							null !== (r = this.clientOpts) && void 0 !== r && r.lazyLoadMembers && (n.filter = JSON.stringify(u.Filter.LAZY_LOADING_MESSAGES_FILTER)), t = null === (s = (await this.http.authedRequest(E.Method.Get, i, n)).chunk) || void 0 === s ? void 0 : s[0]
						}
						if (!t) throw new Error("No message returned when trying to construct getLatestTimeline");
						return this.getEventTimeline(e, t.event_id)
					}
					createMessagesRequest(e, t, i = 30, n, r) {
						var s;
						const o = m.encodeUri("/rooms/$roomId/messages", {
								$roomId: e
							}),
							a = {
								limit: i.toString(),
								dir: n
							};
						t && (a.from = t);
						let d = null;
						var l;
						(null !== (s = this.clientOpts) && void 0 !== s && s.lazyLoadMembers && (d = Object.assign({}, u.Filter.LAZY_LOADING_MESSAGES_FILTER)), r) && (d = d || {}, Object.assign(d, null === (l = r.getRoomTimelineFilterComponent()) || void 0 === l ? void 0 : l.toJSON()));
						return d && (a.filter = JSON.stringify(d)), this.http.authedRequest(E.Method.Get, o, a)
					}
					createThreadListMessagesRequest(e, t, i = 30, n = p.Direction.Backward, r = H.ThreadFilterType.All, s) {
						var o;
						const a = m.encodeUri("/rooms/$roomId/threads", {
								$roomId: e
							}),
							d = {
								limit: i.toString(),
								dir: n,
								include: (0, H.threadFilterTypeToFilter)(r)
							};
						t && (d.from = t);
						let l = {};
						var c;
						(null !== (o = this.clientOpts) && void 0 !== o && o.lazyLoadMembers && (l = se({}, u.Filter.LAZY_LOADING_MESSAGES_FILTER)), s) && (l = se(se({}, l), null === (c = s.getRoomTimelineFilterComponent()) || void 0 === c ? void 0 : c.toJSON()));
						Object.keys(l).length && (d.filter = JSON.stringify(l));
						const h = {
							prefix: H.Thread.hasServerSideListSupport === H.FeatureSupport.Stable ? "/_matrix/client/v1" : "/_matrix/client/unstable/org.matrix.msc3856"
						};
						return this.http.authedRequest(E.Method.Get, a, d, void 0, h).then(e => {
							var t;
							return se(se({}, e), {}, {
								chunk: null === (t = e.chunk) || void 0 === t ? void 0 : t.reverse(),
								start: e.prev_batch,
								end: e.next_batch
							})
						})
					}
					paginateEventTimeline(e, t) {
						const i = e.getTimelineSet() === this.notifTimelineSet,
							n = this.getRoom(e.getRoomId()),
							r = e.getTimelineSet().threadListType,
							s = e.getTimelineSet().thread,
							o = (t = t || {}).backwards || !1;
						if (i && !o) throw new Error("paginateNotifTimeline can only paginate backwards");
						const a = o ? p.EventTimeline.BACKWARDS : p.EventTimeline.FORWARDS,
							d = e.getPaginationToken(a),
							l = e.paginationRequests[a];
						if (l) return l;
						let c, u, h;
						var m;
						if (i) c = "/notifications", u = {
							limit: (null !== (m = t.limit) && void 0 !== m ? m : 30).toString(),
							only: "highlight"
						}, d && "end" !== d && (u.from = d), h = this.http.authedRequest(E.Method.Get, "/notifications", u).then(async t => {
							const i = t.next_token,
								n = [];
							for (let e = 0; e < t.notifications.length; e++) {
								const i = t.notifications[e],
									r = this.getEventMapper()(i.event);
								r.setPushActions(g.PushProcessor.actionListToActionsObject(i.actions)), r.event.room_id = i.room_id, n[e] = r
							}
							const r = e.getTimelineSet();
							return r.addEventsToTimeline(n, o, e, i), this.processBeaconEvents(r.room, n), o && !t.next_token && e.setPaginationToken(null, a), Boolean(t.next_token)
						}).finally(() => {
							e.paginationRequests[a] = null
						}), e.paginationRequests[a] = h;
						else if (null !== r) {
							if (!n) throw new Error("Unknown room " + e.getRoomId());
							if (!H.Thread.hasServerSideFwdPaginationSupport && a === p.Direction.Forward) throw new Error("Cannot paginate threads forwards without server-side support for MSC 3715");
							h = this.createThreadListMessagesRequest(e.getRoomId(), d, t.limit, a, r, e.getFilter()).then(t => {
								if (t.state) {
									const i = e.getState(a),
										n = t.state.map(this.getEventMapper());
									i.setUnknownStateEvents(n)
								}
								const i = t.end,
									r = t.chunk.map(this.getEventMapper());
								return e.getTimelineSet().addEventsToTimeline(r, o, e, i), this.processBeaconEvents(n, r), this.processThreadRoots(n, r, o), o && t.end == t.start && e.setPaginationToken(null, a), t.end !== t.start
							}).finally(() => {
								e.paginationRequests[a] = null
							}), e.paginationRequests[a] = h
						} else if (s) {
							var f, v;
							if (!this.getRoom(null !== (f = e.getRoomId()) && void 0 !== f ? f : void 0)) throw new Error("Unknown room " + e.getRoomId());
							h = this.fetchRelations(null !== (v = e.getRoomId()) && void 0 !== v ? v : "", s.id, H.THREAD_RELATION_TYPE.name, null, {
								dir: a,
								limit: t.limit,
								from: null != d ? d : void 0
							}).then(async t => {
								const i = this.getEventMapper(),
									n = t.chunk.map(i);
								for (const o of n) {
									var r, s;
									await (null === (r = e.getTimelineSet()) || void 0 === r ? void 0 : null === (s = r.thread) || void 0 === s ? void 0 : s.processEvent(o))
								}
								const d = t.next_batch,
									l = e.getTimelineSet();
								return l.addEventsToTimeline(n, o, e, null != d ? d : null), !d && o && l.addEventsToTimeline([i(t.original_event)], !0, e, null), this.processBeaconEvents(l.room, n), o && !d && e.setPaginationToken(null, a), Boolean(d)
							}).finally(() => {
								e.paginationRequests[a] = null
							}), e.paginationRequests[a] = h
						} else {
							if (!n) throw new Error("Unknown room " + e.getRoomId());
							h = this.createMessagesRequest(e.getRoomId(), d, t.limit, a, e.getFilter()).then(t => {
								if (t.state) {
									const i = e.getState(a),
										n = t.state.map(this.getEventMapper());
									i.setUnknownStateEvents(n)
								}
								const i = t.end,
									r = t.chunk.map(this.getEventMapper()),
									s = e.getTimelineSet(),
									[d] = n.partitionThreadedEvents(r);
								s.addEventsToTimeline(d, o, e, i), this.processBeaconEvents(n, d), this.processThreadRoots(n, d.filter(e => e.isRelation(H.THREAD_RELATION_TYPE.name)), !1);
								const l = void 0 === t.end || t.end === t.start;
								return o && l && e.setPaginationToken(null, a), !l
							}).finally(() => {
								e.paginationRequests[a] = null
							}), e.paginationRequests[a] = h
						}
						return h
					}
					resetNotifTimelineSet() {
						this.notifTimelineSet && this.notifTimelineSet.resetLiveTimeline("end")
					}
					peekInRoom(e) {
						var t;
						return null === (t = this.peekSync) || void 0 === t || t.stopPeeking(), this.peekSync = new a.SyncApi(this, this.clientOpts), this.peekSync.peek(e)
					}
					stopPeeking() {
						this.peekSync && (this.peekSync.stopPeeking(), this.peekSync = null)
					}
					setGuestAccess(e, t) {
						const i = this.sendStateEvent(e, P.EventType.RoomGuestAccess, {
							guest_access: t.allowJoin ? "can_join" : "forbidden"
						}, "");
						let n = Promise.resolve(void 0);
						return t.allowRead && (n = this.sendStateEvent(e, P.EventType.RoomHistoryVisibility, {
							history_visibility: "world_readable"
						}, "")), Promise.all([n, i]).then()
					}
					requestRegisterEmailToken(e, t, i, n) {
						return this.requestTokenFromEndpoint("/register/email/requestToken", {
							email: e,
							client_secret: t,
							send_attempt: i,
							next_link: n
						})
					}
					requestRegisterMsisdnToken(e, t, i, n, r) {
						return this.requestTokenFromEndpoint("/register/msisdn/requestToken", {
							country: e,
							phone_number: t,
							client_secret: i,
							send_attempt: n,
							next_link: r
						})
					}
					requestAdd3pidEmailToken(e, t, i, n) {
						return this.requestTokenFromEndpoint("/account/3pid/email/requestToken", {
							email: e,
							client_secret: t,
							send_attempt: i,
							next_link: n
						})
					}
					requestAdd3pidMsisdnToken(e, t, i, n, r) {
						return this.requestTokenFromEndpoint("/account/3pid/msisdn/requestToken", {
							country: e,
							phone_number: t,
							client_secret: i,
							send_attempt: n,
							next_link: r
						})
					}
					requestPasswordEmailToken(e, t, i, n) {
						return this.requestTokenFromEndpoint("/account/password/email/requestToken", {
							email: e,
							client_secret: t,
							send_attempt: i,
							next_link: n
						})
					}
					requestPasswordMsisdnToken(e, t, i, n, r) {
						return this.requestTokenFromEndpoint("/account/password/msisdn/requestToken", {
							country: e,
							phone_number: t,
							client_secret: i,
							send_attempt: n,
							next_link: r
						})
					}
					async requestTokenFromEndpoint(e, t) {
						const i = Object.assign({}, t);
						if (!(await this.doesServerSupportSeparateAddAndBind()) && this.idBaseUrl) {
							var n;
							const e = new URL(this.idBaseUrl);
							if (i.id_server = e.host, null !== (n = this.identityServer) && void 0 !== n && n.getAccessToken && await this.doesServerAcceptIdentityAccessToken()) {
								const e = await this.identityServer.getAccessToken();
								e && (i.id_access_token = e)
							}
						}
						return this.http.request(E.Method.Post, e, void 0, i)
					}
					getRoomPushRule(e, t) {
						var i, n;
						if (this.pushRules) return null === (i = this.pushRules[e]) || void 0 === i ? void 0 : null === (n = i.room) || void 0 === n ? void 0 : n.find(e => e.rule_id === t);
						throw new Error("SyncApi.sync() must be done before accessing to push rules.")
					}
					setRoomMutePushRule(e, t, i) {
						let n, r = !1;
						const s = this.getRoomPushRule(e, t);
						if (null != s && s.actions.includes(B.PushRuleActionName.DontNotify) && (r = !0), i)
							if (s) {
								if (!r) {
									const i = m.defer();
									this.deletePushRule(e, B.PushRuleKind.RoomSpecific, s.rule_id).then(() => {
										this.addPushRule(e, B.PushRuleKind.RoomSpecific, t, {
											actions: [B.PushRuleActionName.DontNotify]
										}).then(() => {
											i.resolve()
										}).catch(e => {
											i.reject(e)
										})
									}).catch(e => {
										i.reject(e)
									}), n = i.promise
								}
							} else n = this.addPushRule(e, B.PushRuleKind.RoomSpecific, t, {
								actions: [B.PushRuleActionName.DontNotify]
							});
						else r && (n = this.deletePushRule(e, B.PushRuleKind.RoomSpecific, s.rule_id));
						if (n) return new Promise((e, t) => {
							n.then(() => {
								this.getPushRules().then(t => {
									this.pushRules = t, e()
								}).catch(e => {
									t(e)
								})
							}).catch(e => {
								this.getPushRules().then(i => {
									this.pushRules = i, t(e)
								}).catch(i => {
									t(e)
								})
							})
						})
					}
					searchMessageText(e) {
						const t = {
							search_term: e.query
						};
						return "keys" in e && (t.keys = e.keys), this.search({
							body: {
								search_categories: {
									room_events: t
								}
							}
						})
					}
					searchRoomEvents(e) {
						const t = {
								search_categories: {
									room_events: {
										search_term: e.term,
										filter: e.filter,
										order_by: F.SearchOrderBy.Recent,
										event_context: {
											before_limit: 1,
											after_limit: 1,
											include_profile: !0
										}
									}
								}
							},
							i = {
								_query: t,
								results: [],
								highlights: []
							};
						return this.search({
							body: t
						}).then(e => this.processRoomEventsSearch(i, e))
					}
					backPaginateRoomEventsSearch(e) {
						if (!e.next_batch) return Promise.reject(new Error("Cannot backpaginate event search any further"));
						if (e.pendingRequest) return e.pendingRequest;
						const t = {
								body: e._query,
								next_batch: e.next_batch
							},
							i = this.search(t, e.abortSignal).then(t => this.processRoomEventsSearch(e, t)).finally(() => {
								e.pendingRequest = void 0
							});
						return e.pendingRequest = i, i
					}
					processRoomEventsSearch(e, t) {
						var i, n;
						const r = t.search_categories.room_events;
						e.count = r.count, e.next_batch = r.next_batch;
						const s = new Set(r.highlights);
						e.highlights.forEach(e => {
							s.add(e)
						}), e.highlights = Array.from(s);
						const o = this.getEventMapper(),
							a = null !== (i = null === (n = r.results) || void 0 === n ? void 0 : n.length) && void 0 !== i ? i : 0;
						for (let d = 0; d < a; d++) {
							const t = R.SearchResult.fromJson(r.results[d], o),
								i = this.getRoom(t.context.getEvent().getRoomId());
							if (i)
								for (const e of t.context.getTimeline()) {
									const t = i.getMember(e.getSender());
									!e.sender && t && (e.sender = t)
								}
							e.results.push(t)
						}
						return e
					}
					syncLeftRooms() {
						if (this.syncedLeftRooms) return Promise.resolve([]);
						if (this.syncLeftRoomsPromise) return this.syncLeftRoomsPromise;
						const e = new a.SyncApi(this, this.clientOpts);
						return this.syncLeftRoomsPromise = e.syncLeftRooms(), this.syncLeftRoomsPromise.then(() => {
							_.logger.log("Marking success of sync left room request"), this.syncedLeftRooms = !0
						}).finally(() => {
							this.syncLeftRoomsPromise = void 0
						}), this.syncLeftRoomsPromise
					}
					createFilter(e) {
						const t = m.encodeUri("/user/$userId/filter", {
							$userId: this.credentials.userId
						});
						return this.http.authedRequest(E.Method.Post, t, void 0, e).then(t => {
							const i = u.Filter.fromJson(this.credentials.userId, t.filter_id, e);
							return this.store.storeFilter(i), i
						})
					}
					getFilter(e, t, i) {
						if (i) {
							const i = this.store.getFilter(e, t);
							if (i) return Promise.resolve(i)
						}
						const n = m.encodeUri("/user/$userId/filter/$filterId", {
							$userId: e,
							$filterId: t
						});
						return this.http.authedRequest(E.Method.Get, n).then(i => {
							const n = u.Filter.fromJson(e, t, i);
							return this.store.storeFilter(n), n
						})
					}
					async getOrCreateFilter(e, t) {
						const i = this.store.getFilterIdByName(e);
						let n;
						if (i) {
							try {
								const e = await this.getFilter(this.credentials.userId, i, !0);
								if (e) {
									const r = e.getDefinition(),
										s = t.getDefinition();
									m.deepCompare(r, s) && (n = i)
								}
							} catch (s) {
								if ("M_UNKNOWN" !== s.errcode && "M_NOT_FOUND" !== s.errcode) throw s
							}
							n || this.store.setFilterIdByName(e, void 0)
						}
						if (n) return n;
						const r = await this.createFilter(t.getDefinition());
						return this.store.setFilterIdByName(e, r.filterId), r.filterId
					}
					getOpenIdToken() {
						const e = m.encodeUri("/user/$userId/openid/request_token", {
							$userId: this.credentials.userId
						});
						return this.http.authedRequest(E.Method.Post, e, void 0, {})
					}
					turnServer() {
						return this.http.authedRequest(E.Method.Get, "/voip/turnServer")
					}
					getTurnServers() {
						return this.turnServers || []
					}
					getTurnServersExpiry() {
						return this.turnServersExpiry
					}
					get pollingTurnServers() {
						return void 0 !== this.checkTurnServersIntervalID
					}
					async checkTurnServers() {
						if (!this.canSupportVoip) return;
						let t = !1;
						const i = this.turnServersExpiry - Date.now();
						if (i > le) _.logger.debug("TURN creds are valid for another " + i + " ms: not fetching new ones."), t = !0;
						else {
							_.logger.debug("Fetching new TURN credentials");
							try {
								const e = await this.turnServer();
								if (e.uris) {
									_.logger.log("Got TURN URIs: " + e.uris + " refresh in " + e.ttl + " secs");
									const i = {
										urls: e.uris,
										username: e.username,
										credential: e.password
									};
									this.turnServers = [i], this.turnServersExpiry = Date.now() + 1e3 * e.ttl, t = !0, this.emit(fe.TurnServers, this.turnServers)
								}
							} catch (n) {
								_.logger.error("Failed to get TURN URIs", n), 403 === n.httpStatus ? (_.logger.info("TURN access unavailable for this account: stopping credentials checks"), null !== this.checkTurnServersIntervalID && e.clearInterval(this.checkTurnServersIntervalID), this.checkTurnServersIntervalID = void 0, this.emit(fe.TurnServersError, n, !0)) : this.emit(fe.TurnServersError, n, !1)
							}
						}
						return t
					}
					setFallbackICEServerAllowed(e) {
						this.fallbackICEServerAllowed = e
					}
					isFallbackICEServerAllowed() {
						return this.fallbackICEServerAllowed
					}
					isSynapseAdministrator() {
						const e = m.encodeUri("/_synapse/admin/v1/users/$userId/admin", {
							$userId: this.getUserId()
						});
						return this.http.authedRequest(E.Method.Get, e, void 0, void 0, {
							prefix: ""
						}).then(e => e.admin)
					}
					whoisSynapseUser(e) {
						const t = m.encodeUri("/_synapse/admin/v1/whois/$userId", {
							$userId: e
						});
						return this.http.authedRequest(E.Method.Get, t, void 0, void 0, {
							prefix: ""
						})
					}
					deactivateSynapseUser(e) {
						const t = m.encodeUri("/_synapse/admin/v1/deactivate/$userId", {
							$userId: e
						});
						return this.http.authedRequest(E.Method.Post, t, void 0, void 0, {
							prefix: ""
						})
					}
					async fetchClientWellKnown() {
						var e;
						this.clientWellKnownPromise = f.AutoDiscovery.getRawClientConfig(null !== (e = this.getDomain()) && void 0 !== e ? e : void 0), this.clientWellKnown = await this.clientWellKnownPromise, this.emit(fe.ClientWellKnown, this.clientWellKnown)
					}
					getClientWellKnown() {
						return this.clientWellKnown
					}
					waitForClientWellKnown() {
						if (!this.clientRunning) throw new Error("Client is not running");
						return this.clientWellKnownPromise
					}
					storeClientOptions() {
						const e = ["boolean", "string", "number"],
							t = Object.entries(this.clientOpts).filter(([t, i]) => e.includes(typeof i)).reduce((e, [t, i]) => (e[t] = i, e), {});
						return this.store.storeClientOptions(t)
					}
					async _unstable_getSharedRooms(e) {
						const t = await this.doesServerSupportUnstableFeature("uk.half-shot.msc2666"),
							i = await this.doesServerSupportUnstableFeature("uk.half-shot.msc2666.mutual_rooms");
						if (!t && !i) throw Error("Server does not support mutual_rooms API");
						const n = m.encodeUri(`/uk.half-shot.msc2666/user/${i?"mutual_rooms":"shared_rooms"}/$userId`, {
							$userId: e
						});
						return (await this.http.authedRequest(E.Method.Get, n, void 0, void 0, {
							prefix: E.ClientPrefix.Unstable
						})).joined
					}
					async getVersions() {
						if (this.serverVersionsPromise) return this.serverVersionsPromise;
						this.serverVersionsPromise = this.http.request(E.Method.Get, "/_matrix/client/versions", void 0, void 0, {
							prefix: ""
						}).catch(e => {
							throw this.serverVersionsPromise = void 0, e
						});
						const e = await this.serverVersionsPromise;
						this.canSupport = await (0, ee.buildFeatureSupportMap)(e);
						const t = this.canSupport.get(ee.Feature.ThreadUnreadNotifications);
						return Z.UNREAD_THREAD_NOTIFICATIONS.setPreferUnstable(t === ee.ServerSupport.Unstable), this.serverVersionsPromise
					}
					async isVersionSupported(e) {
						const {
							versions: t
						} = await this.getVersions();
						return t && t.includes(e)
					}
					async doesServerSupportLazyLoading() {
						const e = await this.getVersions();
						if (!e) return !1;
						const t = e.versions,
							i = e.unstable_features;
						return t && t.includes("r0.5.0") || i && i["m.lazy_load_members"]
					}
					async doesServerRequireIdServerParam() {
						const e = await this.getVersions();
						if (!e) return !0;
						const t = e.versions;
						if (t && t.includes("r0.6.0")) return !1;
						const i = e.unstable_features;
						return !i || (void 0 === i["m.require_identity_server"] || i["m.require_identity_server"])
					}
					async doesServerAcceptIdentityAccessToken() {
						const e = await this.getVersions();
						if (!e) return !1;
						const t = e.versions,
							i = e.unstable_features;
						return t && t.includes("r0.6.0") || i && i["m.id_access_token"]
					}
					async doesServerSupportSeparateAddAndBind() {
						const e = await this.getVersions();
						if (!e) return !1;
						const t = e.versions,
							i = e.unstable_features;
						return (null == t ? void 0 : t.includes("r0.6.0")) || (null == i ? void 0 : i["m.separate_add_and_bind"])
					}
					async doesServerSupportUnstableFeature(e) {
						const t = await this.getVersions();
						if (!t) return !1;
						const i = t.unstable_features;
						return i && !!i[e]
					}
					async doesServerForceEncryptionForPreset(e) {
						const t = await this.getVersions();
						if (!t) return !1;
						const i = t.unstable_features,
							n = e.includes("_chat") ? e.substring(0, e.indexOf("_chat")) : e;
						return i && !!i[`io.element.e2ee_forced.${n}`]
					}
					async doesServerSupportThread() {
						if (await this.isVersionSupported("v1.4")) return {
							threads: H.FeatureSupport.Stable,
							list: H.FeatureSupport.Stable,
							fwdPagination: H.FeatureSupport.Stable
						};
						try {
							const [e, t, i, n, r, s] = await Promise.all([this.doesServerSupportUnstableFeature("org.matrix.msc3440"), this.doesServerSupportUnstableFeature("org.matrix.msc3440.stable"), this.doesServerSupportUnstableFeature("org.matrix.msc3856"), this.doesServerSupportUnstableFeature("org.matrix.msc3856.stable"), this.doesServerSupportUnstableFeature("org.matrix.msc3715"), this.doesServerSupportUnstableFeature("org.matrix.msc3715.stable")]);
							return {
								threads: (0, H.determineFeatureSupport)(t, e),
								list: (0, H.determineFeatureSupport)(n, i),
								fwdPagination: (0, H.determineFeatureSupport)(s, r)
							}
						} catch (e) {
							return {
								threads: H.FeatureSupport.None,
								list: H.FeatureSupport.None,
								fwdPagination: H.FeatureSupport.None
							}
						}
					}
					doesServerSupportLogoutDevices() {
						return this.isVersionSupported("r0.6.1")
					}
					hasLazyLoadMembersEnabled() {
						var e;
						return !(null === (e = this.clientOpts) || void 0 === e || !e.lazyLoadMembers)
					}
					setCanResetTimelineCallback(e) {
						this.canResetTimelineCallback = e
					}
					getCanResetTimelineCallback() {
						return this.canResetTimelineCallback
					}
					async relations(e, t, i, n, r = {
						dir: p.Direction.Backward
					}) {
						var s, o;
						const a = n ? this.getEncryptedIfNeededEventType(e, n) : null,
							d = await this.fetchRelations(e, t, i, a, r),
							l = this.getEventMapper(),
							c = d.original_event ? l(d.original_event) : void 0;
						let u = d.chunk.map(l);
						if (a === P.EventType.RoomMessageEncrypted) {
							const e = c ? u.concat(c) : u;
							await Promise.all(e.map(e => this.decryptEventIfNeeded(e))), null !== n && (u = u.filter(e => e.getType() === n))
						}
						return c && i === P.RelationType.Replace && (u = u.filter(e => e.getSender() === c.getSender())), {
							originalEvent: null != c ? c : null,
							events: u,
							nextBatch: null !== (s = d.next_batch) && void 0 !== s ? s : null,
							prevBatch: null !== (o = d.prev_batch) && void 0 !== o ? o : null
						}
					}
					getCrossSigningCacheCallbacks() {
						var e;
						return null === (e = this.crypto) || void 0 === e ? void 0 : e.crossSigningInfo.getCacheCallbacks()
					}
					generateClientSecret() {
						return (0, L.randomString)(32)
					}
					decryptEventIfNeeded(e, t) {
						return e.shouldAttemptDecryption() && this.isCryptoEnabled() && e.attemptDecryption(this.crypto, t), e.isBeingDecrypted() ? e.getDecryptionPromise() : Promise.resolve()
					}
					termsUrlForService(e, t) {
						switch (e) {
							case S.SERVICE_TYPES.IS:
								return this.http.getUrl("/terms", void 0, E.IdentityPrefix.V2, t);
							case S.SERVICE_TYPES.IM:
								return this.http.getUrl("/terms", void 0, "/_matrix/integrations/v1", t);
							default:
								throw new Error("Unsupported service type")
						}
					}
					getHomeserverUrl() {
						return this.baseUrl
					}
					getIdentityServerUrl(e = !1) {
						var t, i;
						return e && (null !== (t = this.idBaseUrl) && void 0 !== t && t.startsWith("http://") || null !== (i = this.idBaseUrl) && void 0 !== i && i.startsWith("https://")) ? this.idBaseUrl.split("://")[1] : this.idBaseUrl
					}
					setIdentityServerUrl(e) {
						this.idBaseUrl = m.ensureNoTrailingSlash(e), this.http.setIdBaseUrl(this.idBaseUrl)
					}
					getAccessToken() {
						return this.http.opts.accessToken || null
					}
					setAccessToken(e) {
						this.http.opts.accessToken = e
					}
					isLoggedIn() {
						return void 0 !== this.http.opts.accessToken
					}
					makeTxnId() {
						return "m" + (new Date).getTime() + "." + this.txnCtr++
					}
					isUsernameAvailable(e) {
						return this.http.authedRequest(E.Method.Get, "/register/available", {
							username: e
						}).then(e => e.available).catch(e => "M_USER_IN_USE" !== e.errcode && Promise.reject(e))
					}
					register(e, t, i, n, r, s, o) {
						!0 === r ? r = {
							email: !0
						} : null != r && !1 !== r || (r = {}), i && (n.session = i);
						const a = {
							auth: n,
							refresh_token: !0
						};
						return null != e && (a.username = e), null != t && (a.password = t), r.email && (a.bind_email = !0), r.msisdn && (a.bind_msisdn = !0), null != s && (a.guest_access_token = s), null != o && (a.inhibit_login = o), null != t && (a.x_show_msisdn = !0), this.registerRequest(a)
					}
					registerGuest(e) {
						return (e = e || {}).body = e.body || {}, this.registerRequest(e.body, "guest")
					}
					registerRequest(e, t) {
						const i = {};
						return t && (i.kind = t), this.http.request(E.Method.Post, "/register", i, e)
					}
					refreshToken(e) {
						return this.http.authedRequest(E.Method.Post, "/refresh", void 0, {
							refresh_token: e
						}, {
							prefix: E.ClientPrefix.V1,
							inhibitLogoutEmit: !0
						})
					}
					loginFlows() {
						return this.http.request(E.Method.Get, "/login")
					}
					login(e, t) {
						const i = {
							type: e
						};
						return Object.assign(i, t), this.http.authedRequest(E.Method.Post, "/login", void 0, i).then(e => (e.access_token && e.user_id && (this.http.opts.accessToken = e.access_token, this.credentials = {
							userId: e.user_id
						}), e))
					}
					loginWithPassword(e, t) {
						return this.login("m.login.password", {
							user: e,
							password: t
						})
					}
					loginWithSAML2(e) {
						return this.login("m.login.saml2", {
							relay_state: e
						})
					}
					getCasLoginUrl(e) {
						return this.getSsoLoginUrl(e, "cas")
					}
					getSsoLoginUrl(e, t = "sso", i, n) {
						let r = "/login/" + t + "/redirect";
						i && (r += "/" + i);
						const s = {
							redirectUrl: e,
							[ve.unstable]: n
						};
						return this.http.getUrl(r, s, E.ClientPrefix.R0).href
					}
					loginWithToken(e) {
						return this.login("m.login.token", {
							token: e
						})
					}
					async logout(e = !1) {
						var t, i;
						if (null !== (t = this.crypto) && void 0 !== t && null !== (i = t.backupManager) && void 0 !== i && i.getKeyBackupEnabled()) try {
							for (; await this.crypto.backupManager.backupPendingKeys(200) > 0;);
						} catch (n) {
							_.logger.error("Key backup request failed when logging out. Some keys may be missing from backup", n)
						}
						return e && (this.stopClient(), this.http.abort()), this.http.authedRequest(E.Method.Post, "/logout")
					}
					deactivateAccount(e, t) {
						const i = {};
						return e && (i.auth = e), void 0 !== t && (i.erase = t), this.http.authedRequest(E.Method.Post, "/account/deactivate", void 0, i)
					}
					requestLoginToken(e) {
						const t = {
							auth: e
						};
						return this.http.authedRequest(E.Method.Post, "/org.matrix.msc3882/login/token", void 0, t, {
							prefix: E.ClientPrefix.Unstable
						})
					}
					getFallbackAuthUrl(e, t) {
						const i = m.encodeUri("/auth/$loginType/fallback/web", {
							$loginType: e
						});
						return this.http.getUrl(i, {
							session: t
						}, E.ClientPrefix.R0).href
					}
					async createRoom(e) {
						var t;
						const i = (e.invite_3pid || []).filter(e => !e.id_access_token);
						if (i.length > 0 && null !== (t = this.identityServer) && void 0 !== t && t.getAccessToken && await this.doesServerAcceptIdentityAccessToken()) {
							const e = await this.identityServer.getAccessToken();
							if (e)
								for (const t of i) t.id_access_token = e
						}
						return this.http.authedRequest(E.Method.Post, "/createRoom", void 0, e)
					}
					fetchRelations(e, t, i, n, r = {
						dir: p.Direction.Backward
					}) {
						let s = r;
						H.Thread.hasServerSideFwdPaginationSupport === H.FeatureSupport.Experimental && (s = (0, m.replaceParam)("dir", "org.matrix.msc3715.dir", s));
						const o = m.encodeParams(s);
						let a = "/rooms/$roomId/relations/$eventId";
						null !== i ? (a += "/$relationType", null !== n && (a += "/$eventType")) : null !== n && (_.logger.warn(`eventType: ${n} ignored when fetching\n            relations as relationType is null`), n = null);
						const d = m.encodeUri(a + "?" + o, {
							$roomId: e,
							$eventId: t,
							$relationType: i,
							$eventType: n
						});
						return this.http.authedRequest(E.Method.Get, d, void 0, void 0, {
							prefix: E.ClientPrefix.Unstable
						})
					}
					roomState(e) {
						const t = m.encodeUri("/rooms/$roomId/state", {
							$roomId: e
						});
						return this.http.authedRequest(E.Method.Get, t)
					}
					fetchRoomEvent(e, t) {
						const i = m.encodeUri("/rooms/$roomId/event/$eventId", {
							$roomId: e,
							$eventId: t
						});
						return this.http.authedRequest(E.Method.Get, i)
					}
					members(e, t, i, n) {
						const r = {};
						t && (r.membership = t), i && (r.not_membership = i), n && (r.at = n);
						const s = m.encodeParams(r),
							o = m.encodeUri("/rooms/$roomId/members?" + s, {
								$roomId: e
							});
						return this.http.authedRequest(E.Method.Get, o)
					}
					upgradeRoom(e, t) {
						const i = m.encodeUri("/rooms/$roomId/upgrade", {
							$roomId: e
						});
						return this.http.authedRequest(E.Method.Post, i, void 0, {
							new_version: t
						})
					}
					getStateEvent(e, t, i) {
						const n = {
							$roomId: e,
							$eventType: t,
							$stateKey: i
						};
						let r = m.encodeUri("/rooms/$roomId/state/$eventType", n);
						return void 0 !== i && (r = m.encodeUri(r + "/$stateKey", n)), this.http.authedRequest(E.Method.Get, r)
					}
					sendStateEvent(e, t, i, n = "", r = {}) {
						const s = {
							$roomId: e,
							$eventType: t,
							$stateKey: n
						};
						let o = m.encodeUri("/rooms/$roomId/state/$eventType", s);
						return void 0 !== n && (o = m.encodeUri(o + "/$stateKey", s)), this.http.authedRequest(E.Method.Put, o, void 0, i, r)
					}
					roomInitialSync(e, t) {
						var i;
						const n = m.encodeUri("/rooms/$roomId/initialSync", {
							$roomId: e
						});
						return this.http.authedRequest(E.Method.Get, n, {
							limit: null !== (i = null == t ? void 0 : t.toString()) && void 0 !== i ? i : "30"
						})
					}
					async setRoomReadMarkersHttpRequest(e, t, i, n) {
						const r = m.encodeUri("/rooms/$roomId/read_markers", {
								$roomId: e
							}),
							s = {
								[W.ReceiptType.FullyRead]: t,
								[W.ReceiptType.Read]: i
							};
						return (await this.doesServerSupportUnstableFeature("org.matrix.msc2285.stable") || await this.isVersionSupported("v1.4")) && (s[W.ReceiptType.ReadPrivate] = n), this.http.authedRequest(E.Method.Post, r, void 0, s)
					}
					getJoinedRooms() {
						const e = m.encodeUri("/joined_rooms", {});
						return this.http.authedRequest(E.Method.Get, e)
					}
					getJoinedRoomMembers(e) {
						const t = m.encodeUri("/rooms/$roomId/joined_members", {
							$roomId: e
						});
						return this.http.authedRequest(E.Method.Get, t)
					}
					publicRooms(e = {}) {
						let {
							server: t,
							limit: i,
							since: n
						} = e, s = (0, r.default)(e, te);
						const o = {
							server: t,
							limit: i,
							since: n
						};
						return 0 === Object.keys(s).length ? this.http.authedRequest(E.Method.Get, "/publicRooms", o) : this.http.authedRequest(E.Method.Post, "/publicRooms", o, s)
					}
					createAlias(e, t) {
						const i = m.encodeUri("/directory/room/$alias", {
								$alias: e
							}),
							n = {
								room_id: t
							};
						return this.http.authedRequest(E.Method.Put, i, void 0, n)
					}
					deleteAlias(e) {
						const t = m.encodeUri("/directory/room/$alias", {
							$alias: e
						});
						return this.http.authedRequest(E.Method.Delete, t)
					}
					getLocalAliases(e) {
						const t = m.encodeUri("/rooms/$roomId/aliases", {
								$roomId: e
							}),
							i = E.ClientPrefix.V3;
						return this.http.authedRequest(E.Method.Get, t, void 0, void 0, {
							prefix: i
						})
					}
					getRoomIdForAlias(e) {
						const t = m.encodeUri("/directory/room/$alias", {
							$alias: e
						});
						return this.http.authedRequest(E.Method.Get, t)
					}
					resolveRoomAlias(e) {
						const t = m.encodeUri("/directory/room/$alias", {
							$alias: e
						});
						return this.http.request(E.Method.Get, t)
					}
					getRoomDirectoryVisibility(e) {
						const t = m.encodeUri("/directory/list/room/$roomId", {
							$roomId: e
						});
						return this.http.authedRequest(E.Method.Get, t)
					}
					setRoomDirectoryVisibility(e, t) {
						const i = m.encodeUri("/directory/list/room/$roomId", {
							$roomId: e
						});
						return this.http.authedRequest(E.Method.Put, i, void 0, {
							visibility: t
						})
					}
					setRoomDirectoryVisibilityAppService(e, t, i) {
						const n = m.encodeUri("/directory/list/appservice/$networkId/$roomId", {
							$networkId: e,
							$roomId: t
						});
						return this.http.authedRequest(E.Method.Put, n, void 0, {
							visibility: i
						})
					}
					searchUserDirectory(e) {
						const t = {
							search_term: e.term
						};
						return void 0 !== e.limit && (t.limit = e.limit), this.http.authedRequest(E.Method.Post, "/user_directory/search", void 0, t)
					}
					uploadContent(e, t) {
						return this.http.uploadContent(e, t)
					}
					cancelUpload(e) {
						return this.http.cancelUpload(e)
					}
					getCurrentUploads() {
						return this.http.getCurrentUploads()
					}
					getProfileInfo(e, t) {
						const i = t ? m.encodeUri("/profile/$userId/$info", {
							$userId: e,
							$info: t
						}) : m.encodeUri("/profile/$userId", {
							$userId: e
						});
						return this.http.authedRequest(E.Method.Get, i)
					}
					getThreePids() {
						return this.http.authedRequest(E.Method.Get, "/account/3pid")
					}
					addThreePid(e, t) {
						const i = {
							threePidCreds: e,
							bind: t
						};
						return this.http.authedRequest(E.Method.Post, "/account/3pid", void 0, i)
					}
					async addThreePidOnly(e) {
						const t = await this.isVersionSupported("r0.6.0") ? E.ClientPrefix.R0 : E.ClientPrefix.Unstable;
						return this.http.authedRequest(E.Method.Post, "/account/3pid/add", void 0, e, {
							prefix: t
						})
					}
					async bindThreePid(e) {
						const t = await this.isVersionSupported("r0.6.0") ? E.ClientPrefix.R0 : E.ClientPrefix.Unstable;
						return this.http.authedRequest(E.Method.Post, "/account/3pid/bind", void 0, e, {
							prefix: t
						})
					}
					async unbindThreePid(e, t) {
						const i = {
								medium: e,
								address: t,
								id_server: this.getIdentityServerUrl(!0)
							},
							n = await this.isVersionSupported("r0.6.0") ? E.ClientPrefix.R0 : E.ClientPrefix.Unstable;
						return this.http.authedRequest(E.Method.Post, "/account/3pid/unbind", void 0, i, {
							prefix: n
						})
					}
					deleteThreePid(e, t) {
						return this.http.authedRequest(E.Method.Post, "/account/3pid/delete", void 0, {
							medium: e,
							address: t
						})
					}
					setPassword(e, t, i) {
						const n = {
							auth: e,
							new_password: t,
							logout_devices: i
						};
						return this.http.authedRequest(E.Method.Post, "/account/password", void 0, n)
					}
					getDevices() {
						return this.http.authedRequest(E.Method.Get, "/devices")
					}
					getDevice(e) {
						const t = m.encodeUri("/devices/$device_id", {
							$device_id: e
						});
						return this.http.authedRequest(E.Method.Get, t)
					}
					setDeviceDetails(e, t) {
						const i = m.encodeUri("/devices/$device_id", {
							$device_id: e
						});
						return this.http.authedRequest(E.Method.Put, i, void 0, t)
					}
					deleteDevice(e, t) {
						const i = m.encodeUri("/devices/$device_id", {
								$device_id: e
							}),
							n = {};
						return t && (n.auth = t), this.http.authedRequest(E.Method.Delete, i, void 0, n)
					}
					deleteMultipleDevices(e, t) {
						const i = {
							devices: e
						};
						t && (i.auth = t);
						return this.http.authedRequest(E.Method.Post, "/delete_devices", void 0, i)
					}
					async getPushers() {
						const e = await this.http.authedRequest(E.Method.Get, "/pushers");
						return await this.doesServerSupportUnstableFeature("org.matrix.msc3881") || (e.pushers = e.pushers.map(e => (e.hasOwnProperty(P.PUSHER_ENABLED.name) || (e[P.PUSHER_ENABLED.name] = !0), e))), e
					}
					setPusher(e) {
						return this.http.authedRequest(E.Method.Post, "/pushers/set", void 0, e)
					}
					setLocalNotificationSettings(e, t) {
						const i = `${P.LOCAL_NOTIFICATION_SETTINGS_PREFIX.name}.${e}`;
						return this.setAccountData(i, t)
					}
					getPushRules() {
						return this.http.authedRequest(E.Method.Get, "/pushrules/").then(e => g.PushProcessor.rewriteDefaultRules(e))
					}
					addPushRule(e, t, i, n) {
						const r = m.encodeUri("/pushrules/" + e + "/$kind/$ruleId", {
							$kind: t,
							$ruleId: i
						});
						return this.http.authedRequest(E.Method.Put, r, void 0, n)
					}
					deletePushRule(e, t, i) {
						const n = m.encodeUri("/pushrules/" + e + "/$kind/$ruleId", {
							$kind: t,
							$ruleId: i
						});
						return this.http.authedRequest(E.Method.Delete, n)
					}
					setPushRuleEnabled(e, t, i, n) {
						const r = m.encodeUri("/pushrules/" + e + "/$kind/$ruleId/enabled", {
							$kind: t,
							$ruleId: i
						});
						return this.http.authedRequest(E.Method.Put, r, void 0, {
							enabled: n
						})
					}
					setPushRuleActions(e, t, i, n) {
						const r = m.encodeUri("/pushrules/" + e + "/$kind/$ruleId/actions", {
							$kind: t,
							$ruleId: i
						});
						return this.http.authedRequest(E.Method.Put, r, void 0, {
							actions: n
						})
					}
					search(e, t) {
						const i = {};
						return e.next_batch && (i.next_batch = e.next_batch), this.http.authedRequest(E.Method.Post, "/search", i, e.body, {
							abortSignal: t
						})
					}
					uploadKeysRequest(e, t) {
						return this.http.authedRequest(E.Method.Post, "/keys/upload", void 0, e)
					}
					uploadKeySignatures(e) {
						return this.http.authedRequest(E.Method.Post, "/keys/signatures/upload", void 0, e, {
							prefix: E.ClientPrefix.V3
						})
					}
					downloadKeysForUsers(e, t = {}) {
						const i = {
							device_keys: {}
						};
						return "token" in t && (i.token = t.token), e.forEach(e => {
							i.device_keys[e] = []
						}), this.http.authedRequest(E.Method.Post, "/keys/query", void 0, i)
					}
					claimOneTimeKeys(e, t = "signed_curve25519", i) {
						const n = {};
						void 0 === t && (t = "signed_curve25519");
						for (const [s, o] of e) {
							const e = n[s] || {};
							n[s] = e, e[o] = t
						}
						const r = {
							one_time_keys: n
						};
						i && (r.timeout = i);
						return this.http.authedRequest(E.Method.Post, "/keys/claim", void 0, r)
					}
					getKeyChanges(e, t) {
						const i = {
							from: e,
							to: t
						};
						return this.http.authedRequest(E.Method.Get, "/keys/changes", i)
					}
					uploadDeviceSigningKeys(e, t) {
						const i = Object.assign({}, t);
						return e && Object.assign(i, {
							auth: e
						}), this.http.authedRequest(E.Method.Post, "/keys/device_signing/upload", void 0, i, {
							prefix: E.ClientPrefix.Unstable
						})
					}
					registerWithIdentityServer(e) {
						if (!this.idBaseUrl) throw new Error("No identity server base URL set");
						const t = this.http.getUrl("/account/register", void 0, E.IdentityPrefix.V2, this.idBaseUrl);
						return this.http.requestOtherUrl(E.Method.Post, t, e)
					}
					requestEmailToken(e, t, i, n, r) {
						const s = {
							client_secret: t,
							email: e,
							send_attempt: null == i ? void 0 : i.toString(),
							next_link: n
						};
						return this.http.idServerRequest(E.Method.Post, "/validate/email/requestToken", s, E.IdentityPrefix.V2, r)
					}
					requestMsisdnToken(e, t, i, n, r, s) {
						const o = {
							client_secret: i,
							country: e,
							phone_number: t,
							send_attempt: null == n ? void 0 : n.toString(),
							next_link: r
						};
						return this.http.idServerRequest(E.Method.Post, "/validate/msisdn/requestToken", o, E.IdentityPrefix.V2, s)
					}
					submitMsisdnToken(e, t, i, n) {
						const r = {
							sid: e,
							client_secret: t,
							token: i
						};
						return this.http.idServerRequest(E.Method.Post, "/validate/msisdn/submitToken", r, E.IdentityPrefix.V2, n)
					}
					submitMsisdnTokenOtherUrl(e, t, i, n) {
						const r = {
							sid: t,
							client_secret: i,
							token: n
						};
						return this.http.requestOtherUrl(E.Method.Post, e, r)
					}
					getIdentityHashDetails(e) {
						return this.http.idServerRequest(E.Method.Get, "/hash_details", void 0, E.IdentityPrefix.V2, e)
					}
					async identityHashedLookup(t, i) {
						const n = {},
							r = await this.getIdentityHashDetails(i);
						if (!r || !r.lookup_pepper || !r.algorithms) throw new Error("Unsupported identity server: bad response");
						n.pepper = r.lookup_pepper;
						const s = {};
						if (r.algorithms.includes("sha256")) {
							const i = new e.Olm.Utility;
							n.addresses = t.map(e => {
								const t = e[0].toLowerCase(),
									r = e[1].toLowerCase(),
									o = i.sha256(`${t} ${r} ${n.pepper}`).replace(/\+/g, "-").replace(/\//g, "_");
								return s[o] = e[0], o
							}), n.algorithm = "sha256"
						} else {
							if (!r.algorithms.includes("none")) throw new Error("Unsupported identity server: unknown hash algorithm");
							n.addresses = t.map(e => {
								const t = `${e[0].toLowerCase()} ${e[1].toLowerCase()}`;
								return s[t] = e[0], t
							}), n.algorithm = "none"
						}
						const o = await this.http.idServerRequest(E.Method.Post, "/lookup", n, E.IdentityPrefix.V2, i);
						if (!o || !o.mappings) return [];
						const a = [];
						for (const e of Object.keys(o.mappings)) {
							const t = o.mappings[e],
								i = s[e];
							if (!i) throw new Error("Identity server returned more results than expected");
							a.push({
								address: i,
								mxid: t
							})
						}
						return a
					}
					async lookupThreePid(e, t, i) {
						const n = (await this.identityHashedLookup([
							[t, e]
						], i)).find(e => e.address === t);
						return n ? {
							address: t,
							medium: e,
							mxid: n.mxid
						} : {}
					}
					async bulkLookupThreePids(e, t) {
						const i = await this.identityHashedLookup(e.map(e => [e[1], e[0]]), t),
							n = [];
						for (const r of i) {
							const t = e.find(e => e[1] === r.address);
							if (!t) throw new Error("Identity sever returned unexpected results");
							n.push([t[0], r.address, r.mxid])
						}
						return {
							threepids: n
						}
					}
					getIdentityAccount(e) {
						return this.http.idServerRequest(E.Method.Get, "/account", void 0, E.IdentityPrefix.V2, e)
					}
					sendToDevice(e, t, i) {
						const n = m.encodeUri("/sendToDevice/$eventType/$txnId", {
								$eventType: e,
								$txnId: i || this.makeTxnId()
							}),
							r = {
								messages: t
							},
							s = Object.keys(t).reduce((e, i) => (e[i] = Object.keys(t[i]), e), {});
						return _.logger.log(`PUT ${n}`, s), this.http.authedRequest(E.Method.Put, n, void 0, r)
					}
					queueToDevice(e) {
						return this.toDeviceMessageQueue.queueBatch(e)
					}
					getThirdpartyProtocols() {
						return this.http.authedRequest(E.Method.Get, "/thirdparty/protocols").then(e => {
							if (!e || "object" != typeof e) throw new Error(`/thirdparty/protocols did not return an object: ${e}`);
							return e
						})
					}
					getThirdpartyLocation(e, t) {
						const i = m.encodeUri("/thirdparty/location/$protocol", {
							$protocol: e
						});
						return this.http.authedRequest(E.Method.Get, i, t)
					}
					getThirdpartyUser(e, t) {
						const i = m.encodeUri("/thirdparty/user/$protocol", {
							$protocol: e
						});
						return this.http.authedRequest(E.Method.Get, i, t)
					}
					getTerms(e, t) {
						const i = this.termsUrlForService(e, t);
						return this.http.requestOtherUrl(E.Method.Get, i)
					}
					agreeToTerms(e, t, i, n) {
						const r = this.termsUrlForService(e, t),
							s = {
								Authorization: "Bearer " + i
							};
						return this.http.requestOtherUrl(E.Method.Post, r, {
							user_accepts: n
						}, {
							headers: s
						})
					}
					reportEvent(e, t, i, n) {
						const r = m.encodeUri("/rooms/$roomId/report/$eventId", {
							$roomId: e,
							$eventId: t
						});
						return this.http.authedRequest(E.Method.Post, r, void 0, {
							score: i,
							reason: n
						})
					}
					getRoomHierarchy(e, t, i, n = !1, r) {
						const s = m.encodeUri("/rooms/$roomId/hierarchy", {
								$roomId: e
							}),
							o = {
								suggested_only: String(n),
								max_depth: null == i ? void 0 : i.toString(),
								from: r,
								limit: null == t ? void 0 : t.toString()
							};
						return this.http.authedRequest(E.Method.Get, s, o, void 0, {
							prefix: E.ClientPrefix.V1
						}).catch(e => {
							if ("M_UNRECOGNIZED" === e.errcode) return this.http.authedRequest(E.Method.Get, s, o, void 0, {
								prefix: "/_matrix/client/unstable/org.matrix.msc2946"
							});
							throw e
						})
					}
					async unstableCreateFileTree(e) {
						const {
							room_id: t
						} = await this.createRoom({
							name: e,
							preset: D.Preset.PrivateChat,
							power_level_content_override: se(se({}, N.DEFAULT_TREE_POWER_LEVELS_TEMPLATE), {}, {
								users: {
									[this.getUserId()]: 100
								}
							}),
							creation_content: {
								[P.RoomCreateTypeField]: P.RoomType.Space
							},
							initial_state: [{
								type: P.UNSTABLE_MSC3088_PURPOSE.name,
								state_key: P.UNSTABLE_MSC3089_TREE_SUBTYPE.name,
								content: {
									[P.UNSTABLE_MSC3088_ENABLED.name]: !0
								}
							}, {
								type: P.EventType.RoomEncryption,
								state_key: "",
								content: {
									algorithm: v.MEGOLM_ALGORITHM
								}
							}]
						});
						return new N.MSC3089TreeSpace(this, t)
					}
					unstableGetFileTreeSpace(e) {
						var t, i;
						const n = this.getRoom(e);
						if ("join" !== (null == n ? void 0 : n.getMyMembership())) return null;
						const r = n.currentState.getStateEvents(P.EventType.RoomCreate, ""),
							s = n.currentState.getStateEvents(P.UNSTABLE_MSC3088_PURPOSE.name, P.UNSTABLE_MSC3089_TREE_SUBTYPE.name);
						if (!r) throw new Error("Expected single room create event");
						return null != s && null !== (t = s.getContent()) && void 0 !== t && t[P.UNSTABLE_MSC3088_ENABLED.name] ? (null === (i = r.getContent()) || void 0 === i ? void 0 : i[P.RoomCreateTypeField]) !== P.RoomType.Space ? null : new N.MSC3089TreeSpace(this, e) : null
					}
					slidingSync(e, t, i) {
						const n = {};
						e.pos && (n.pos = e.pos, delete e.pos), e.timeout && (n.timeout = e.timeout, delete e.timeout);
						const r = e.clientTimeout;
						return delete e.clientTimeout, this.http.authedRequest(E.Method.Post, "/sync", n, e, {
							prefix: "/_matrix/client/unstable/org.matrix.msc3575",
							baseUrl: t,
							localTimeoutMs: r,
							abortSignal: i
						})
					}
					supportsExperimentalThreads() {
						var e;
						return (null === (e = this.clientOpts) || void 0 === e ? void 0 : e.experimentalThreadSupport) || !1
					}
					async getRoomSummary(e, t) {
						const i = m.encodeUri("/rooms/$roomid/summary", {
							$roomid: e
						});
						return this.http.authedRequest(E.Method.Get, i, {
							via: t
						}, void 0, {
							prefix: "/_matrix/client/unstable/im.nheko.summary"
						})
					}
					processThreadEvents(e, t, i) {
						e.processThreadedEvents(t, i)
					}
					processThreadRoots(e, t, i) {
						e.processThreadRoots(t, i)
					}
					processBeaconEvents(e, t) {
						null != t && t.length && e && e.currentState.processBeaconEvents(t, this)
					}
					async whoami() {
						return this.http.authedRequest(E.Method.Get, "/account/whoami")
					}
					timestampToEvent(e, t, i) {
						const n = m.encodeUri("/rooms/$roomId/timestamp_to_event", {
							$roomId: e
						});
						return this.http.authedRequest(E.Method.Get, n, {
							ts: t.toString(),
							dir: i
						}, void 0, {
							prefix: "/_matrix/client/unstable/org.matrix.msc3030"
						})
					}
				}

				function be(e, t) {
					var i, n, r;
					const s = t.getPushActions(),
						o = e.getPushActionsForEvent(t, !0),
						a = e.getRoom(t.getRoomId());
					if (!a || !e.getUserId()) return;
					const d = !!t.threadRootId && !t.isThreadRoot,
						l = null !== (i = d ? a.getThreadUnreadNotificationCount(t.threadRootId, M.NotificationCountType.Highlight) : a.getUnreadNotificationCount(M.NotificationCountType.Highlight)) && void 0 !== i ? i : 0,
						c = !(null == s || null === (n = s.tweaks) || void 0 === n || !n.highlight),
						u = !(null == o || null === (r = o.tweaks) || void 0 === r || !r.highlight);
					if (c !== u || l > 0) {
						var h;
						if (!(d ? null === (h = a.getThread(t.threadRootId)) || void 0 === h ? void 0 : h.hasUserReadEvent(e.getUserId(), t.getId()) : a.hasUserReadEvent(e.getUserId(), t.getId()))) {
							var m;
							let e = l;
							u && !c && e++, !u && c && e--, d ? a.setThreadUnreadNotificationCount(t.threadRootId, M.NotificationCountType.Highlight, e) : a.setUnreadNotificationCount(M.NotificationCountType.Highlight, e), (null !== (m = d ? a.getThreadUnreadNotificationCount(t.threadRootId, M.NotificationCountType.Total) : a.getUnreadNotificationCount(M.NotificationCountType.Total)) && void 0 !== m ? m : 0) < e && (d ? a.setThreadUnreadNotificationCount(t.threadRootId, M.NotificationCountType.Total, e) : a.setUnreadNotificationCount(M.NotificationCountType.Total, e))
						}
					}
				}
				t.MatrixClient = ye, (0, s.default)(ye, "RESTORE_BACKUP_ERROR_BAD_KEY", "RESTORE_BACKUP_ERROR_BAD_KEY")
			}).call(this, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/content-helpers.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.makeBeaconInfoContent = t.makeBeaconContent = t.getTextForLocationEvent = void 0, t.makeEmoteMessage = function(e) {
				return {
					msgtype: o.MsgType.Emote,
					body: e
				}
			}, t.makeHtmlEmote = function(e, t) {
				return {
					msgtype: o.MsgType.Emote,
					format: "org.matrix.custom.html",
					body: e,
					formatted_body: t
				}
			}, t.makeHtmlMessage = function(e, t) {
				return {
					msgtype: o.MsgType.Text,
					format: "org.matrix.custom.html",
					body: e,
					formatted_body: t
				}
			}, t.makeHtmlNotice = function(e, t) {
				return {
					msgtype: o.MsgType.Notice,
					format: "org.matrix.custom.html",
					body: e,
					formatted_body: t
				}
			}, t.makeLocationContent = void 0, t.makeNotice = function(e) {
				return {
					msgtype: o.MsgType.Notice,
					body: e
				}
			}, t.makeTextMessage = function(e) {
				return {
					msgtype: o.MsgType.Text,
					body: e
				}
			}, t.parseTopicContent = t.parseLocationEvent = t.parseBeaconInfoContent = t.parseBeaconContent = t.makeTopicContent = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-events-sdk/lib/index.js"),
				o = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				a = i("./node_modules/matrix-js-sdk/lib/@types/extensible_events.js"),
				d = i("./node_modules/matrix-js-sdk/lib/@types/location.js"),
				l = i("./node_modules/matrix-js-sdk/lib/@types/topic.js");

			function c(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}
			const u = (e, t, i, n) => {
				const r = `at ${new Date(i).toISOString()}`;
				return [t === d.LocationAssetType.Self ? "User" : void 0, "Location", n ? `"${n}"` : void 0, e, r].filter(Boolean).join(" ")
			};
			t.getTextForLocationEvent = u;
			const h = (e, t, i, n, s) => {
				const l = null != e ? e : u(t, s || d.LocationAssetType.Self, i, n),
					h = i ? {
						[d.M_TIMESTAMP.name]: i
					} : {};
				return function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var i = null != arguments[t] ? arguments[t] : {};
						t % 2 ? c(Object(i), !0).forEach((function(t) {
							(0, r.default)(e, t, i[t])
						})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : c(Object(i)).forEach((function(t) {
							Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
						}))
					}
					return e
				}({
					msgtype: o.MsgType.Location,
					body: l,
					geo_uri: t,
					[d.M_LOCATION.name]: {
						description: n,
						uri: t
					},
					[d.M_ASSET.name]: {
						type: s || d.LocationAssetType.Self
					},
					[a.TEXT_NODE_TYPE.name]: l
				}, h)
			};
			t.makeLocationContent = h;
			t.parseLocationEvent = e => {
				var t, i;
				const n = d.M_LOCATION.findIn(e),
					r = d.M_ASSET.findIn(e),
					s = d.M_TIMESTAMP.findIn(e),
					o = a.TEXT_NODE_TYPE.findIn(e),
					l = null !== (t = null == n ? void 0 : n.uri) && void 0 !== t ? t : null == e ? void 0 : e.geo_uri,
					c = null == n ? void 0 : n.description,
					u = null !== (i = null == r ? void 0 : r.type) && void 0 !== i ? i : d.LocationAssetType.Self,
					m = null != o ? o : e.body;
				return h(m, l, null != s ? s : void 0, c, u)
			};
			t.makeTopicContent = (e, t) => {
				const i = [{
					body: e,
					mimetype: "text/plain"
				}];
				return (0, s.isProvided)(t) && i.push({
					body: t,
					mimetype: "text/html"
				}), {
					topic: e,
					[l.M_TOPIC.name]: i
				}
			};
			t.parseTopicContent = e => {
				var t, i, n;
				const r = l.M_TOPIC.findIn(e);
				return {
					text: null !== (t = null == r ? void 0 : null === (i = r.find(e => !(0, s.isProvided)(e.mimetype) || "text/plain" === e.mimetype)) || void 0 === i ? void 0 : i.body) && void 0 !== t ? t : e.topic,
					html: null == r ? void 0 : null === (n = r.find(e => "text/html" === e.mimetype)) || void 0 === n ? void 0 : n.body
				}
			};
			t.makeBeaconInfoContent = (e, t, i, n, r) => ({
				description: i,
				timeout: e,
				live: t,
				[d.M_TIMESTAMP.name]: r || Date.now(),
				[d.M_ASSET.name]: {
					type: null != n ? n : d.LocationAssetType.Self
				}
			});
			t.parseBeaconInfoContent = e => {
				var t;
				const {
					description: i,
					timeout: n,
					live: r
				} = e, s = null !== (t = d.M_TIMESTAMP.findIn(e)) && void 0 !== t ? t : void 0, o = d.M_ASSET.findIn(e);
				return {
					description: i,
					timeout: n,
					live: r,
					assetType: null == o ? void 0 : o.type,
					timestamp: s
				}
			};
			t.makeBeaconContent = (e, t, i, n) => ({
				[d.M_LOCATION.name]: {
					description: n,
					uri: e
				},
				[d.M_TIMESTAMP.name]: t,
				"m.relates_to": {
					rel_type: s.REFERENCE_RELATION.name,
					event_id: i
				}
			});
			t.parseBeaconContent = e => {
				var t;
				const i = d.M_LOCATION.findIn(e),
					n = null !== (t = d.M_TIMESTAMP.findIn(e)) && void 0 !== t ? t : void 0;
				return {
					description: null == i ? void 0 : i.description,
					uri: null == i ? void 0 : i.uri,
					timestamp: n
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/content-repo.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.getHttpUriForMxc = function(e, t, i, r, s, o = !1) {
				if ("string" != typeof t || !t) return "";
				if (0 !== t.indexOf("mxc://")) return o ? t : "";
				let a = t.slice(6),
					d = "/_matrix/media/r0/download/";
				const l = {};
				i && (l.width = Math.round(i).toString());
				r && (l.height = Math.round(r).toString());
				s && (l.method = s);
				Object.keys(l).length > 0 && (d = "/_matrix/media/r0/thumbnail/");
				const c = a.indexOf("#");
				let u = "";
				c >= 0 && (u = a.slice(c), a = a.slice(0, c));
				const h = 0 === Object.keys(l).length ? "" : "?" + n.encodeParams(l);
				return e + d + a + h + u
			};
			var n = function(e, t) {
				if (!t && e && e.__esModule) return e;
				if (null === e || "object" != typeof e && "function" != typeof e) return {
					default: e
				};
				var i = r(t);
				if (i && i.has(e)) return i.get(e);
				var n = {},
					s = Object.defineProperty && Object.getOwnPropertyDescriptor;
				for (var o in e)
					if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
						var a = s ? Object.getOwnPropertyDescriptor(e, o) : null;
						a && (a.get || a.set) ? Object.defineProperty(n, o, a) : n[o] = e[o]
					} n.default = e, i && i.set(e, n);
				return n
			}(i("./node_modules/matrix-js-sdk/lib/utils.js"));

			function r(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (r = function(e) {
					return e ? i : t
				})(e)
			}
		},
		"./node_modules/matrix-js-sdk/lib/crypto/CrossSigning.js": function(e, t, i) {
			"use strict";
			(function(e, n) {
				var r = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.UserTrustLevel = t.DeviceTrustLevel = t.CrossSigningLevel = t.CrossSigningInfo = void 0, t.createCryptoStoreCacheCallbacks = function(e, t) {
					return {
						getCrossSigningKeyCache: async function(i, r) {
							const s = await new Promise(t => e.doTxn("readonly", [d.IndexedDBCryptoStore.STORE_ACCOUNT], n => {
								e.getSecretStorePrivateKey(n, t, i)
							}));
							if (s && s.ciphertext) {
								const e = n.from(t.pickleKey),
									r = await (0, l.decryptAES)(s, e, i);
								return (0, o.decodeBase64)(r)
							}
							return s
						},
						storeCrossSigningKeyCache: async function(i, r) {
							if (!(r instanceof Uint8Array)) throw new Error(`storeCrossSigningKeyCache expects Uint8Array, got ${r}`);
							const s = n.from(t.pickleKey),
								a = await (0, l.encryptAES)((0, o.encodeBase64)(r), s, i);
							return e.doTxn("readwrite", [d.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
								e.storeSecretStorePrivateKey(t, i, a)
							})
						}
					}
				}, t.requestKeysDuringVerification = async function(e, t, i) {
					if (e.getUserId() !== t) return;
					return a.logger.log("Cross-signing: Self-verification done; requesting keys"), new Promise((t, n) => {
						const r = e,
							s = r.crypto.crossSigningInfo,
							d = new h(s.userId, {
								getCrossSigningKey: async e => {
									a.logger.debug("Cross-signing: requesting secret", e, i);
									const {
										promise: t
									} = r.requestSecret(`m.cross_signing.${e}`, [i]), n = await t, s = (0, o.decodeBase64)(n);
									return Uint8Array.from(s)
								}
							}, s.getCacheCallbacks());
						d.keys = s.keys;
						const l = new Promise(e => {
								setTimeout(e, c, new Error("Timeout"))
							}),
							u = (async () => {
								if (!(await r.crypto.getSessionBackupPrivateKey())) {
									a.logger.info("No cached backup key found. Requesting...");
									const e = r.requestSecret("m.megolm_backup.v1", [i]),
										t = await e.promise;
									a.logger.info("Got key backup key, decoding...");
									const n = (0, o.decodeBase64)(t);
									a.logger.info("Decoded backup key, storing..."), await r.crypto.storeSessionBackupPrivateKey(Uint8Array.from(n)), a.logger.info("Backup key stored. Starting backup restore...");
									const s = await r.getKeyBackupVersion();
									r.restoreKeyBackupWithCache(void 0, void 0, s).then(() => {
										a.logger.info("Backup restored.")
									})
								}
							})();
						return Promise.race([Promise.all([d.getCrossSigningKey("master"), d.getCrossSigningKey("self_signing"), d.getCrossSigningKey("user_signing"), u]), l]).then(t, n)
					}).catch(e => {
						a.logger.warn("Cross-signing: failure while requesting keys:", e)
					})
				};
				var s = r(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
					o = i("./node_modules/matrix-js-sdk/lib/crypto/olmlib.js"),
					a = i("./node_modules/matrix-js-sdk/lib/logger.js"),
					d = i("./node_modules/matrix-js-sdk/lib/crypto/store/indexeddb-crypto-store.js"),
					l = i("./node_modules/matrix-js-sdk/lib/crypto/aes.js");
				const c = 6e4;

				function u(e) {
					return Object.values(e.keys)[0]
				}
				class h {
					constructor(e, t = {}, i = {}) {
						this.userId = e, this.callbacks = t, this.cacheCallbacks = i, (0, s.default)(this, "keys", {}), (0, s.default)(this, "firstUse", !0), (0, s.default)(this, "crossSigningVerifiedBefore", !1)
					}
					static fromStorage(e, t) {
						const i = new h(t);
						for (const n in e) e.hasOwnProperty(n) && (i[n] = e[n]);
						return i
					}
					toStorage() {
						return {
							keys: this.keys,
							firstUse: this.firstUse,
							crossSigningVerifiedBefore: this.crossSigningVerifiedBefore
						}
					}
					async getCrossSigningKey(t, i) {
						const n = ["master", "self_signing", "user_signing"].indexOf(t) >= 0;
						if (!this.callbacks.getCrossSigningKey) throw new Error("No getCrossSigningKey callback supplied");

						function r(t) {
							if (!t) return;
							const n = new e.Olm.PkSigning,
								r = n.init_with_seed(t);
							if (r === i) return [r, n];
							n.free()
						}
						void 0 === i && (i = this.getId(t));
						let s = null;
						this.cacheCallbacks.getCrossSigningKeyCache && n && (s = await this.cacheCallbacks.getCrossSigningKeyCache(t, i));
						const o = r(s);
						if (o) return o;
						const a = r(s = await this.callbacks.getCrossSigningKey(t, i));
						if (a) return this.cacheCallbacks.storeCrossSigningKeyCache && n && await this.cacheCallbacks.storeCrossSigningKeyCache(t, s), a;
						if (!s) throw new Error("getCrossSigningKey callback for " + t + " returned falsey");
						throw new Error("Key type " + t + " from getCrossSigningKey callback did not match")
					}
					async isStoredInSecretStorage(e) {
						const t = await e.isStored("m.cross_signing.master") || {};

						function i(e) {
							for (const i of Object.keys(t)) e[i] || delete t[i]
						}
						for (const n of ["self_signing", "user_signing"]) i(await e.isStored(`m.cross_signing.${n}`) || {});
						return Object.keys(t).length ? t : null
					}
					static async storeInSecretStorage(e, t) {
						for (const [i, n] of e) {
							const e = (0, o.encodeBase64)(n);
							await t.store(`m.cross_signing.${i}`, e)
						}
					}
					static async getFromSecretStorage(e, t) {
						const i = await t.get(`m.cross_signing.${e}`);
						return i ? (0, o.decodeBase64)(i) : null
					}
					async isStoredInKeyCache(e) {
						const t = this.cacheCallbacks;
						if (!t) return !1;
						const i = e ? [e] : ["master", "self_signing", "user_signing"];
						for (const r of i) {
							var n;
							if (!(await (null === (n = t.getCrossSigningKeyCache) || void 0 === n ? void 0 : n.call(t, r)))) return !1
						}
						return !0
					}
					async getCrossSigningKeysFromCache() {
						const e = new Map,
							t = this.cacheCallbacks;
						if (!t) return e;
						for (const n of ["master", "self_signing", "user_signing"]) {
							var i;
							const r = await (null === (i = t.getCrossSigningKeyCache) || void 0 === i ? void 0 : i.call(t, n));
							r && e.set(n, r)
						}
						return e
					}
					getId(e = "master") {
						if (!this.keys[e]) return null;
						return u(this.keys[e])
					}
					async resetKeys(t) {
						if (!this.callbacks.saveCrossSigningKeys) throw new Error("No saveCrossSigningKeys callback supplied");
						if (void 0 === t || t & m.MASTER || !this.keys.master) t = m.MASTER | m.USER_SIGNING | m.SELF_SIGNING;
						else if (0 === t) return;
						const i = {},
							n = {};
						let r, s;
						try {
							if (t & m.MASTER ? (r = new e.Olm.PkSigning, i.master = r.generate_seed(), s = r.init_with_seed(i.master), n.master = {
									user_id: this.userId,
									usage: ["master"],
									keys: {
										["ed25519:" + s]: s
									}
								}) : [s, r] = await this.getCrossSigningKey("master"), t & m.SELF_SIGNING) {
								const t = new e.Olm.PkSigning;
								try {
									i.self_signing = t.generate_seed();
									const e = t.init_with_seed(i.self_signing);
									n.self_signing = {
										user_id: this.userId,
										usage: ["self_signing"],
										keys: {
											["ed25519:" + e]: e
										}
									}, (0, o.pkSign)(n.self_signing, r, this.userId, s)
								} finally {
									t.free()
								}
							}
							if (t & m.USER_SIGNING) {
								const t = new e.Olm.PkSigning;
								try {
									i.user_signing = t.generate_seed();
									const e = t.init_with_seed(i.user_signing);
									n.user_signing = {
										user_id: this.userId,
										usage: ["user_signing"],
										keys: {
											["ed25519:" + e]: e
										}
									}, (0, o.pkSign)(n.user_signing, r, this.userId, s)
								} finally {
									t.free()
								}
							}
							Object.assign(this.keys, n), this.callbacks.saveCrossSigningKeys(i)
						} finally {
							r && r.free()
						}
					}
					clearKeys() {
						this.keys = {}
					}
					setKeys(e) {
						const t = {};
						if (e.master) {
							if (e.master.user_id !== this.userId) {
								const t = "Mismatched user ID " + e.master.user_id + " in master key from " + this.userId;
								throw a.logger.error(t), new Error(t)
							}
							this.keys.master ? u(e.master) !== this.getId() && (this.firstUse = !1) : this.firstUse = !0, t.master = e.master
						} else {
							if (!this.keys.master) throw new Error("Tried to set cross-signing keys without a master key");
							t.master = this.keys.master
						}
						const i = u(t.master);
						if (e.user_signing) {
							if (e.user_signing.user_id !== this.userId) {
								const t = "Mismatched user ID " + e.master.user_id + " in user_signing key from " + this.userId;
								throw a.logger.error(t), new Error(t)
							}
							try {
								(0, o.pkVerify)(e.user_signing, i, this.userId)
							} catch (n) {
								throw a.logger.error("invalid signature on user-signing key"), n
							}
						}
						if (e.self_signing) {
							if (e.self_signing.user_id !== this.userId) {
								const t = "Mismatched user ID " + e.master.user_id + " in self_signing key from " + this.userId;
								throw a.logger.error(t), new Error(t)
							}
							try {
								(0, o.pkVerify)(e.self_signing, i, this.userId)
							} catch (n) {
								throw a.logger.error("invalid signature on self-signing key"), n
							}
						}
						e.master && (this.keys.master = e.master, delete this.keys.self_signing, delete this.keys.user_signing), e.self_signing && (this.keys.self_signing = e.self_signing), e.user_signing && (this.keys.user_signing = e.user_signing)
					}
					updateCrossSigningVerifiedBefore(e) {
						!this.crossSigningVerifiedBefore && e && (this.crossSigningVerifiedBefore = !0)
					}
					async signObject(e, t) {
						if (!this.keys[t]) throw new Error("Attempted to sign with " + t + " key but no such key present");
						const [i, n] = await this.getCrossSigningKey(t);
						try {
							return (0, o.pkSign)(e, n, this.userId, i), e
						} finally {
							n.free()
						}
					}
					async signUser(e) {
						if (this.keys.user_signing) return this.signObject(e.keys.master, "user_signing");
						a.logger.info("No user signing key: not signing user")
					}
					async signDevice(e, t) {
						if (e !== this.userId) throw new Error(`Trying to sign ${e}'s device; can only sign our own device`);
						if (this.keys.self_signing) return this.signObject({
							algorithms: t.algorithms,
							keys: t.keys,
							device_id: t.deviceId,
							user_id: e
						}, "self_signing");
						a.logger.info("No self signing key: not signing device")
					}
					checkUserTrust(e) {
						if (this.userId === e.userId && this.getId() && this.getId() === e.getId() && this.getId("self_signing") && this.getId("self_signing") === e.getId("self_signing")) return new p(!0, !0, this.firstUse);
						if (!this.keys.user_signing) return new p(!1, !1, e.firstUse);
						let t;
						const i = e.keys.master,
							n = this.getId("user_signing");
						try {
							(0, o.pkVerify)(i, n, this.userId), t = !0
						} catch (r) {
							t = !1
						}
						return new p(t, e.crossSigningVerifiedBefore, e.firstUse)
					}
					checkDeviceTrust(e, t, i, n) {
						const r = this.checkUserTrust(e),
							s = e.keys.self_signing;
						if (!s) return new g(!1, !1, i, n);
						const a = function(e, t) {
							return {
								algorithms: e.algorithms,
								keys: e.keys,
								device_id: e.deviceId,
								user_id: t,
								signatures: e.signatures
							}
						}(t, e.userId);
						try {
							return (0, o.pkVerify)(s, e.getId(), e.userId), (0, o.pkVerify)(a, u(s), e.userId), g.fromUserTrustLevel(r, i, n)
						} catch (d) {
							return new g(!1, !1, i, n)
						}
					}
					getCacheCallbacks() {
						return this.cacheCallbacks
					}
				}
				let m;
				t.CrossSigningInfo = h, t.CrossSigningLevel = m,
					function(e) {
						e[e.MASTER = 4] = "MASTER", e[e.USER_SIGNING = 2] = "USER_SIGNING", e[e.SELF_SIGNING = 1] = "SELF_SIGNING"
					}(m || (t.CrossSigningLevel = m = {}));
				class p {
					constructor(e, t, i) {
						this.crossSigningVerified = e, this.crossSigningVerifiedBefore = t, this.tofu = i
					}
					isVerified() {
						return this.isCrossSigningVerified()
					}
					isCrossSigningVerified() {
						return this.crossSigningVerified
					}
					wasCrossSigningVerified() {
						return this.crossSigningVerifiedBefore
					}
					isTofu() {
						return this.tofu
					}
				}
				t.UserTrustLevel = p;
				class g {
					constructor(e, t, i, n) {
						this.crossSigningVerified = e, this.tofu = t, this.localVerified = i, this.trustCrossSignedDevices = n
					}
					static fromUserTrustLevel(e, t, i) {
						return new g(e.isCrossSigningVerified(), e.isTofu(), t, i)
					}
					isVerified() {
						return Boolean(this.isLocallyVerified() || this.trustCrossSignedDevices && this.isCrossSigningVerified())
					}
					isCrossSigningVerified() {
						return this.crossSigningVerified
					}
					isLocallyVerified() {
						return this.localVerified
					}
					isTofu() {
						return this.tofu
					}
				}
				t.DeviceTrustLevel = g
			}).call(this, i("./node_modules/webpack/buildin/global.js"), i("./node_modules/buffer/index.js").Buffer)
		},
		"./node_modules/matrix-js-sdk/lib/crypto/DeviceList.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.TrackingStatus = t.DeviceList = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = i("./node_modules/matrix-js-sdk/lib/crypto/deviceinfo.js"),
				a = i("./node_modules/matrix-js-sdk/lib/crypto/CrossSigning.js"),
				d = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = m(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/crypto/olmlib.js")),
				l = i("./node_modules/matrix-js-sdk/lib/crypto/store/indexeddb-crypto-store.js"),
				c = i("./node_modules/matrix-js-sdk/lib/utils.js"),
				u = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js"),
				h = i("./node_modules/matrix-js-sdk/lib/crypto/index.js");

			function m(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (m = function(e) {
					return e ? i : t
				})(e)
			}
			let p;
			t.TrackingStatus = p,
				function(e) {
					e[e.NotTracked = 0] = "NotTracked", e[e.PendingDownload = 1] = "PendingDownload", e[e.DownloadInProgress = 2] = "DownloadInProgress", e[e.UpToDate = 3] = "UpToDate"
				}(p || (t.TrackingStatus = p = {}));
			class g extends u.TypedEventEmitter {
				constructor(e, t, i, n = 250) {
					super(), this.cryptoStore = t, this.keyDownloadChunkSize = n, (0, r.default)(this, "devices", {}), (0, r.default)(this, "crossSigningInfo", {}), (0, r.default)(this, "userByIdentityKey", {}), (0, r.default)(this, "deviceTrackingStatus", {}), (0, r.default)(this, "syncToken", null), (0, r.default)(this, "keyDownloadsInProgressByUser", new Map), (0, r.default)(this, "dirty", !1), (0, r.default)(this, "savePromise", null), (0, r.default)(this, "resolveSavePromise", null), (0, r.default)(this, "savePromiseTime", null), (0, r.default)(this, "saveTimer", null), (0, r.default)(this, "hasFetched", null), (0, r.default)(this, "serialiser", void 0), this.serialiser = new f(e, i, this)
				}
				async load() {
					await this.cryptoStore.doTxn("readonly", [l.IndexedDBCryptoStore.STORE_DEVICE_DATA], e => {
						this.cryptoStore.getEndToEndDeviceData(e, e => {
							var t;
							this.hasFetched = Boolean(e && e.devices), this.devices = e ? e.devices : {}, this.crossSigningInfo = e && e.crossSigningInfo || {}, this.deviceTrackingStatus = e ? e.trackingStatus : {}, this.syncToken = null !== (t = null == e ? void 0 : e.syncToken) && void 0 !== t ? t : null, this.userByIdentityKey = {};
							for (const i of Object.keys(this.devices)) {
								const e = this.devices[i];
								for (const t of Object.keys(e)) {
									const n = e[t].keys["curve25519:" + t];
									void 0 !== n && (this.userByIdentityKey[n] = i)
								}
							}
						})
					});
					for (const e of Object.keys(this.deviceTrackingStatus)) this.deviceTrackingStatus[e] == p.DownloadInProgress && (this.deviceTrackingStatus[e] = p.PendingDownload)
				}
				stop() {
					null !== this.saveTimer && clearTimeout(this.saveTimer)
				}
				async saveIfDirty(e = 500) {
					if (!this.dirty) return Promise.resolve(!1);
					const t = Date.now() + e;
					this.savePromiseTime && t < this.savePromiseTime && (clearTimeout(this.saveTimer), this.saveTimer = null, this.savePromiseTime = null);
					let i = this.savePromise;
					if (null === i && (i = new Promise(e => {
							this.resolveSavePromise = e
						}), this.savePromise = i), null === this.saveTimer) {
						const i = this.resolveSavePromise;
						this.savePromiseTime = t, this.saveTimer = setTimeout(() => {
							s.logger.log("Saving device tracking data", this.syncToken), this.savePromiseTime = null, this.saveTimer = null, this.savePromise = null, this.resolveSavePromise = null, this.cryptoStore.doTxn("readwrite", [l.IndexedDBCryptoStore.STORE_DEVICE_DATA], e => {
								var t;
								this.cryptoStore.storeEndToEndDeviceData({
									devices: this.devices,
									crossSigningInfo: this.crossSigningInfo,
									trackingStatus: this.deviceTrackingStatus,
									syncToken: null !== (t = this.syncToken) && void 0 !== t ? t : void 0
								}, e)
							}).then(() => {
								this.dirty = !1, null == i || i(!0)
							}, e => {
								s.logger.error("Failed to save device tracking data", this.syncToken), s.logger.error(e)
							})
						}, e)
					}
					return i
				}
				getSyncToken() {
					return this.syncToken
				}
				setSyncToken(e) {
					this.syncToken = e
				}
				downloadKeys(e, t) {
					const i = [],
						n = [];
					if (e.forEach(e => {
							const r = this.deviceTrackingStatus[e];
							this.keyDownloadsInProgressByUser.has(e) ? (s.logger.log("downloadKeys: already have a download in progress for " + `${e}: awaiting its result`), n.push(this.keyDownloadsInProgressByUser.get(e))) : (t || r != p.UpToDate) && i.push(e)
						}), 0 != i.length) {
						s.logger.log("downloadKeys: downloading for", i);
						const e = this.doKeyDownload(i);
						n.push(e)
					}
					return 0 === n.length && s.logger.log("downloadKeys: already have all necessary keys"), Promise.all(n).then(() => this.getDevicesFromStore(e))
				}
				getDevicesFromStore(e) {
					const t = {};
					return e.forEach(e => {
						t[e] = {}, (this.getStoredDevicesForUser(e) || []).forEach((function(i) {
							t[e][i.deviceId] = i
						}))
					}), t
				}
				getKnownUserIds() {
					return Object.keys(this.devices)
				}
				getStoredDevicesForUser(e) {
					const t = this.devices[e];
					if (!t) return null;
					const i = [];
					for (const n in t) t.hasOwnProperty(n) && i.push(o.DeviceInfo.fromStorage(t[n], n));
					return i
				}
				getRawStoredDevicesForUser(e) {
					return this.devices[e]
				}
				getStoredCrossSigningForUser(e) {
					return this.crossSigningInfo[e] ? a.CrossSigningInfo.fromStorage(this.crossSigningInfo[e], e) : null
				}
				storeCrossSigningForUser(e, t) {
					this.crossSigningInfo[e] = t, this.dirty = !0
				}
				getStoredDevice(e, t) {
					const i = this.devices[e];
					if (null != i && i[t]) return o.DeviceInfo.fromStorage(i[t], t)
				}
				getUserByIdentityKey(e, t) {
					return e !== d.OLM_ALGORITHM && e !== d.MEGOLM_ALGORITHM ? null : this.userByIdentityKey[t]
				}
				getDeviceByIdentityKey(e, t) {
					const i = this.getUserByIdentityKey(e, t);
					if (!i) return null;
					const n = this.devices[i];
					if (!n) return null;
					for (const r in n) {
						if (!n.hasOwnProperty(r)) continue;
						const e = n[r];
						for (const i in e.keys) {
							if (!e.keys.hasOwnProperty(i)) continue;
							if (0 !== i.indexOf("curve25519:")) continue;
							if (e.keys[i] == t) return o.DeviceInfo.fromStorage(e, r)
						}
					}
					return null
				}
				storeDevicesForUser(e, t) {
					this.setRawStoredDevicesForUser(e, t), this.dirty = !0
				}
				startTrackingDeviceList(e) {
					if ("string" != typeof e) throw new Error("userId must be a string; was " + e);
					this.deviceTrackingStatus[e] || (s.logger.log("Now tracking device list for " + e), this.deviceTrackingStatus[e] = p.PendingDownload, this.dirty = !0)
				}
				stopTrackingDeviceList(e) {
					this.deviceTrackingStatus[e] && (s.logger.log("No longer tracking device list for " + e), this.deviceTrackingStatus[e] = p.NotTracked, this.dirty = !0)
				}
				stopTrackingAllDeviceLists() {
					for (const e of Object.keys(this.deviceTrackingStatus)) this.deviceTrackingStatus[e] = p.NotTracked;
					this.dirty = !0
				}
				invalidateUserDeviceList(e) {
					this.deviceTrackingStatus[e] && (s.logger.log("Marking device list outdated for", e), this.deviceTrackingStatus[e] = p.PendingDownload, this.dirty = !0)
				}
				refreshOutdatedDeviceLists() {
					this.saveIfDirty();
					const e = [];
					for (const t of Object.keys(this.deviceTrackingStatus)) {
						this.deviceTrackingStatus[t] == p.PendingDownload && e.push(t)
					}
					return this.doKeyDownload(e)
				}
				setRawStoredDevicesForUser(e, t) {
					if (void 0 !== this.devices[e])
						for (const [i, n] of Object.entries(this.devices[e])) {
							const e = n.keys["curve25519:" + i];
							delete this.userByIdentityKey[e]
						}
					this.devices[e] = t;
					for (const [i, n] of Object.entries(t)) {
						const t = n.keys["curve25519:" + i];
						this.userByIdentityKey[t] = e
					}
				}
				setRawStoredCrossSigningForUser(e, t) {
					this.crossSigningInfo[e] = t
				}
				doKeyDownload(e) {
					if (0 === e.length) return Promise.resolve();
					const t = this.serialiser.updateDevicesForUsers(e, this.syncToken).then(() => {
						i(!0)
					}, t => {
						throw s.logger.error("Error downloading keys for " + e + ":", t), i(!1), t
					});
					e.forEach(e => {
						this.keyDownloadsInProgressByUser.set(e, t), this.deviceTrackingStatus[e] == p.PendingDownload && (this.deviceTrackingStatus[e] = p.DownloadInProgress)
					});
					const i = i => {
						this.emit(h.CryptoEvent.WillUpdateDevices, e, !this.hasFetched), e.forEach(e => {
							if (this.dirty = !0, this.keyDownloadsInProgressByUser.get(e) !== t) return void s.logger.log("Another update in the queue for", e, "- not marking up-to-date");
							this.keyDownloadsInProgressByUser.delete(e), this.deviceTrackingStatus[e] == p.DownloadInProgress && (i ? (this.deviceTrackingStatus[e] = p.UpToDate, s.logger.log("Device list for", e, "now up to date")) : this.deviceTrackingStatus[e] = p.PendingDownload)
						}), this.saveIfDirty(), this.emit(h.CryptoEvent.DevicesUpdated, e, !this.hasFetched), this.hasFetched = !0
					};
					return t
				}
			}
			t.DeviceList = g;
			class f {
				constructor(e, t, i) {
					this.baseApis = e, this.olmDevice = t, this.deviceList = i, (0, r.default)(this, "downloadInProgress", !1), (0, r.default)(this, "keyDownloadsQueuedByUser", {}), (0, r.default)(this, "queuedQueryDeferred", void 0), (0, r.default)(this, "syncToken", void 0)
				}
				updateDevicesForUsers(e, t) {
					return e.forEach(e => {
						this.keyDownloadsQueuedByUser[e] = !0
					}), this.queuedQueryDeferred || (this.queuedQueryDeferred = (0, c.defer)()), this.syncToken = t, this.downloadInProgress ? (s.logger.log("Queued key download for", e), this.queuedQueryDeferred.promise) : this.doQueuedQueries()
				}
				doQueuedQueries() {
					if (this.downloadInProgress) throw new Error("DeviceListUpdateSerialiser.doQueuedQueries called with request active");
					const e = Object.keys(this.keyDownloadsQueuedByUser);
					this.keyDownloadsQueuedByUser = {};
					const t = this.queuedQueryDeferred;
					this.queuedQueryDeferred = void 0, s.logger.log("Starting key download for", e), this.downloadInProgress = !0;
					const i = {};
					this.syncToken && (i.token = this.syncToken);
					const n = [];
					for (let r = 0; r < e.length; r += this.deviceList.keyDownloadChunkSize) {
						const t = e.slice(r, r + this.deviceList.keyDownloadChunkSize);
						n.push(() => this.baseApis.downloadKeysForUsers(t, i))
					}
					return (0, c.chunkPromises)(n, 3).then(async t => {
						const i = Object.assign({}, ...t.map(e => e.device_keys || {})),
							n = Object.assign({}, ...t.map(e => e.master_keys || {})),
							r = Object.assign({}, ...t.map(e => e.self_signing_keys || {})),
							o = Object.assign({}, ...t.map(e => e.user_signing_keys || {}));
						for (const d of e) {
							await (0, c.sleep)(5);
							try {
								await this.processQueryResponseForUser(d, i[d], {
									master: null == n ? void 0 : n[d],
									self_signing: null == r ? void 0 : r[d],
									user_signing: null == o ? void 0 : o[d]
								})
							} catch (a) {
								s.logger.error(`Error processing keys for ${d}:`, a)
							}
						}
					}).then(() => {
						s.logger.log("Completed key download for " + e), this.downloadInProgress = !1, null == t || t.resolve(), this.queuedQueryDeferred && this.doQueuedQueries()
					}, i => {
						s.logger.warn("Error downloading keys for " + e + ":", i), this.downloadInProgress = !1, null == t || t.reject(i)
					}), t.promise
				}
				async processQueryResponseForUser(e, t, i) {
					s.logger.log("got device keys for " + e + ":", t), s.logger.log("got cross-signing keys for " + e + ":", i); {
						const i = {},
							n = this.deviceList.getRawStoredDevicesForUser(e);
						n && Object.keys(n).forEach(e => {
							const t = o.DeviceInfo.fromStorage(n[e], e);
							i[e] = t
						}), await async function(e, t, i, n, r, o) {
							let a = !1;
							for (const d in i)
								if (i.hasOwnProperty(d) && !(d in n)) {
									if (t === r && d === o) {
										s.logger.warn(`Local device ${d} missing from sync, skipping removal`);
										continue
									}
									s.logger.log("Device " + t + ":" + d + " has been removed"), delete i[d], a = !0
								} for (const d in n) {
								if (!n.hasOwnProperty(d)) continue;
								const r = n[d];
								r.user_id === t ? r.device_id === d ? await v(e, i, r) && (a = !0) : s.logger.warn("Mismatched device_id " + r.device_id + " in keys from " + t + ":" + d) : s.logger.warn("Mismatched user_id " + r.user_id + " in keys from " + t + ":" + d)
							}
							return a
						}(this.olmDevice, e, i, t || {}, this.baseApis.getUserId(), this.baseApis.deviceId);
						const r = {};
						Object.keys(i).forEach(e => {
							r[e] = i[e].toStorage()
						}), this.deviceList.setRawStoredDevicesForUser(e, r)
					}
					if (i && (i.master || i.self_signing || i.user_signing)) {
						const t = this.deviceList.getStoredCrossSigningForUser(e) || new a.CrossSigningInfo(e);
						t.setKeys(i), this.deviceList.setRawStoredCrossSigningForUser(e, t.toStorage()), this.deviceList.emit(h.CryptoEvent.UserCrossSigningUpdated, e)
					}
				}
			}
			async function v(e, t, i) {
				if (!i.keys) return !1;
				const n = i.device_id,
					r = i.user_id,
					a = "ed25519:" + n,
					l = i.keys[a];
				if (!l) return s.logger.warn("Device " + r + ":" + n + " has no ed25519 key"), !1;
				const c = i.unsigned || {},
					u = i.signatures || {};
				try {
					await d.verifySignature(e, i, r, n, l)
				} catch (m) {
					return s.logger.warn("Unable to verify signature on device " + r + ":" + n + ":" + m), !1
				}
				let h;
				if (n in t) {
					if ((h = t[n]).getFingerprint() != l) return s.logger.warn("Ed25519 key for device " + r + ":" + n + " has changed"), !1
				} else t[n] = h = new o.DeviceInfo(n);
				return h.keys = i.keys || {}, h.algorithms = i.algorithms || [], h.unsigned = c, h.signatures = u, !0
			}
		},
		"./node_modules/matrix-js-sdk/lib/crypto/EncryptionSetup.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.EncryptionSetupOperation = t.EncryptionSetupBuilder = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = i("./node_modules/matrix-js-sdk/lib/models/event.js"),
				a = i("./node_modules/matrix-js-sdk/lib/crypto/CrossSigning.js"),
				d = i("./node_modules/matrix-js-sdk/lib/crypto/store/indexeddb-crypto-store.js"),
				l = i("./node_modules/matrix-js-sdk/lib/http-api/index.js"),
				c = i("./node_modules/matrix-js-sdk/lib/client.js"),
				u = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js");
			t.EncryptionSetupBuilder = class {
				constructor(e, t) {
					(0, r.default)(this, "accountDataClientAdapter", void 0), (0, r.default)(this, "crossSigningCallbacks", void 0), (0, r.default)(this, "ssssCryptoCallbacks", void 0), (0, r.default)(this, "crossSigningKeys", void 0), (0, r.default)(this, "keySignatures", void 0), (0, r.default)(this, "keyBackupInfo", void 0), (0, r.default)(this, "sessionBackupPrivateKey", void 0), this.accountDataClientAdapter = new m(e), this.crossSigningCallbacks = new p, this.ssssCryptoCallbacks = new g(t)
				}
				addCrossSigningKeys(e, t) {
					this.crossSigningKeys = {
						authUpload: e,
						keys: t
					}
				}
				addSessionBackup(e) {
					this.keyBackupInfo = e
				}
				addSessionBackupPrivateKeyToCache(e) {
					this.sessionBackupPrivateKey = e
				}
				addKeySignature(e, t, i) {
					this.keySignatures || (this.keySignatures = {});
					const n = this.keySignatures[e] || {};
					this.keySignatures[e] = n, n[t] = i
				}
				async setAccountData(e, t) {
					await this.accountDataClientAdapter.setAccountData(e, t)
				}
				buildOperation() {
					const e = this.accountDataClientAdapter.values;
					return new h(e, this.crossSigningKeys, this.keyBackupInfo, this.keySignatures)
				}
				async persist(e) {
					if (this.crossSigningKeys) {
						const i = (0, a.createCryptoStoreCacheCallbacks)(e.cryptoStore, e.olmDevice);
						for (const e of ["master", "self_signing", "user_signing"]) {
							var t;
							s.logger.log(`Cache ${e} cross-signing private key locally`);
							const n = this.crossSigningCallbacks.privateKeys.get(e);
							await (null === (t = i.storeCrossSigningKeyCache) || void 0 === t ? void 0 : t.call(i, e, n))
						}
						await e.cryptoStore.doTxn("readwrite", [d.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
							e.cryptoStore.storeCrossSigningKeys(t, this.crossSigningKeys.keys)
						})
					}
					this.sessionBackupPrivateKey && await e.storeSessionBackupPrivateKey(this.sessionBackupPrivateKey)
				}
			};
			class h {
				constructor(e, t, i, n) {
					this.accountData = e, this.crossSigningKeys = t, this.keyBackupInfo = i, this.keySignatures = n
				}
				async apply(e) {
					const t = e.baseApis;
					if (this.crossSigningKeys) {
						var i, n;
						const r = {};
						for (const [e, t] of Object.entries(this.crossSigningKeys.keys)) r[e + "_key"] = t;
						await (null === (i = (n = this.crossSigningKeys).authUpload) || void 0 === i ? void 0 : i.call(n, e => t.uploadDeviceSigningKeys(e, r))), e.crossSigningInfo.setKeys(this.crossSigningKeys.keys)
					}
					if (this.accountData)
						for (const [r, s] of this.accountData) await t.setAccountData(r, s);
					this.keySignatures && await t.uploadKeySignatures(this.keySignatures), this.keyBackupInfo && (this.keyBackupInfo.version ? await t.http.authedRequest(l.Method.Put, "/room_keys/version/" + this.keyBackupInfo.version, void 0, {
						algorithm: this.keyBackupInfo.algorithm,
						auth_data: this.keyBackupInfo.auth_data
					}, {
						prefix: l.ClientPrefix.V3
					}) : await t.http.authedRequest(l.Method.Post, "/room_keys/version", void 0, this.keyBackupInfo, {
						prefix: l.ClientPrefix.V3
					}))
				}
			}
			t.EncryptionSetupOperation = h;
			class m extends u.TypedEventEmitter {
				constructor(e) {
					super(), this.existingValues = e, (0, r.default)(this, "values", new Map)
				}
				getAccountDataFromServer(e) {
					return Promise.resolve(this.getAccountData(e))
				}
				getAccountData(e) {
					const t = this.values.get(e);
					if (t) return t;
					const i = this.existingValues[e];
					return i ? i.getContent() : null
				}
				setAccountData(e, t) {
					const i = this.values.get(e);
					return this.values.set(e, t), Promise.resolve().then(() => {
						const n = new o.MatrixEvent({
							type: e,
							content: t
						});
						return this.emit(c.ClientEvent.AccountData, n, i), {}
					})
				}
			}
			class p {
				constructor() {
					(0, r.default)(this, "privateKeys", new Map)
				}
				getCrossSigningKeyCache(e, t) {
					return this.getCrossSigningKey(e, t)
				}
				storeCrossSigningKeyCache(e, t) {
					return this.privateKeys.set(e, t), Promise.resolve()
				}
				getCrossSigningKey(e, t) {
					var i;
					return Promise.resolve(null !== (i = this.privateKeys.get(e)) && void 0 !== i ? i : null)
				}
				saveCrossSigningKeys(e) {
					for (const [t, i] of Object.entries(e)) this.privateKeys.set(t, i)
				}
			}
			class g {
				constructor(e) {
					this.delegateCryptoCallbacks = e, (0, r.default)(this, "privateKeys", new Map)
				}
				async getSecretStorageKey({
					keys: e
				}, t) {
					var i;
					for (const n of Object.keys(e)) {
						const e = this.privateKeys.get(n);
						if (e) return [n, e]
					}
					if (null != this && null !== (i = this.delegateCryptoCallbacks) && void 0 !== i && i.getSecretStorageKey) {
						const i = await this.delegateCryptoCallbacks.getSecretStorageKey({
							keys: e
						}, t);
						if (i) {
							const [e, t] = i;
							this.privateKeys.set(e, t)
						}
						return i
					}
					return null
				}
				addPrivateKey(e, t, i) {
					var n, r;
					this.privateKeys.set(e, i), null === (n = this.delegateCryptoCallbacks) || void 0 === n || null === (r = n.cacheSecretStorageKey) || void 0 === r || r.call(n, e, t, i)
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/crypto/OlmDevice.js": function(e, t, i) {
			"use strict";
			(function(e) {
				var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.WITHHELD_MESSAGES = t.OlmDevice = void 0;
				var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
					s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
					o = i("./node_modules/matrix-js-sdk/lib/crypto/store/indexeddb-crypto-store.js"),
					a = function(e, t) {
						if (!t && e && e.__esModule) return e;
						if (null === e || "object" != typeof e && "function" != typeof e) return {
							default: e
						};
						var i = d(t);
						if (i && i.has(e)) return i.get(e);
						var n = {},
							r = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var s in e)
							if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
								var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
								o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
							} n.default = e, i && i.set(e, n);
						return n
					}(i("./node_modules/matrix-js-sdk/lib/crypto/algorithms/index.js"));

				function d(e) {
					if ("function" != typeof WeakMap) return null;
					var t = new WeakMap,
						i = new WeakMap;
					return (d = function(e) {
						return e ? i : t
					})(e)
				}
				const l = 49152;

				function c(e) {
					if (void 0 === e) throw new Error("payloadString undefined");
					if (e.length > l) {
						const t = new Error("Message too long (" + e.length + " bytes). The maximum for an encrypted message is " + l + " bytes.");
						throw t.data = {
							errcode: "M_TOO_LARGE",
							error: "Payload too large for encrypted message"
						}, t
					}
				}
				t.OlmDevice = class {
					constructor(e) {
						this.cryptoStore = e, (0, r.default)(this, "pickleKey", "DEFAULT_KEY"), (0, r.default)(this, "deviceCurve25519Key", null), (0, r.default)(this, "deviceEd25519Key", null), (0, r.default)(this, "maxOneTimeKeys", null), (0, r.default)(this, "outboundGroupSessionStore", {}), (0, r.default)(this, "inboundGroupSessionMessageIndexes", {}), (0, r.default)(this, "sessionsInProgress", {}), (0, r.default)(this, "olmPrekeyPromise", Promise.resolve())
					}
					static getOlmVersion() {
						return e.Olm.get_library_version()
					}
					async init({
						pickleKey: t,
						fromExportedDevice: i
					} = {}) {
						let n;
						const r = new e.Olm.Account;
						try {
							i ? (t && s.logger.warn("ignoring opts.pickleKey because opts.fromExportedDevice is present."), this.pickleKey = i.pickleKey, await this.initialiseFromExportedDevice(i, r)) : (t && (this.pickleKey = t), await this.initialiseAccount(r)), n = JSON.parse(r.identity_keys()), this.maxOneTimeKeys = r.max_number_of_one_time_keys()
						} finally {
							r.free()
						}
						this.deviceCurve25519Key = n.curve25519, this.deviceEd25519Key = n.ed25519
					}
					async initialiseFromExportedDevice(e, t) {
						await this.cryptoStore.doTxn("readwrite", [o.IndexedDBCryptoStore.STORE_ACCOUNT, o.IndexedDBCryptoStore.STORE_SESSIONS], t => {
							this.cryptoStore.storeAccount(t, e.pickledAccount), e.sessions.forEach(e => {
								const {
									deviceKey: i,
									sessionId: n
								} = e, r = {
									session: e.session,
									lastReceivedMessageTs: e.lastReceivedMessageTs
								};
								this.cryptoStore.storeEndToEndSession(i, n, r, t)
							})
						}), t.unpickle(this.pickleKey, e.pickledAccount)
					}
					async initialiseAccount(e) {
						await this.cryptoStore.doTxn("readwrite", [o.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
							this.cryptoStore.getAccount(t, i => {
								null !== i ? e.unpickle(this.pickleKey, i) : (e.create(), i = e.pickle(this.pickleKey), this.cryptoStore.storeAccount(t, i))
							})
						})
					}
					getAccount(t, i) {
						this.cryptoStore.getAccount(t, t => {
							const n = new e.Olm.Account;
							try {
								n.unpickle(this.pickleKey, t), i(n)
							} finally {
								n.free()
							}
						})
					}
					storeAccount(e, t) {
						this.cryptoStore.storeAccount(e, t.pickle(this.pickleKey))
					}
					async export () {
						const e = {
							pickleKey: this.pickleKey
						};
						return await this.cryptoStore.doTxn("readonly", [o.IndexedDBCryptoStore.STORE_ACCOUNT, o.IndexedDBCryptoStore.STORE_SESSIONS], t => {
							this.cryptoStore.getAccount(t, t => {
								e.pickledAccount = t
							}), e.sessions = [], this.cryptoStore.getAllEndToEndSessions(t, t => {
								e.sessions.push(t)
							})
						}), e
					}
					getSession(e, t, i, n) {
						this.cryptoStore.getEndToEndSession(e, t, i, e => {
							this.unpickleSession(e, n)
						})
					}
					unpickleSession(t, i) {
						const n = new e.Olm.Session;
						try {
							n.unpickle(this.pickleKey, t.session), i(Object.assign({}, t, {
								session: n
							}))
						} finally {
							n.free()
						}
					}
					saveSession(e, t, i) {
						const n = t.session.session_id(),
							r = Object.assign(t, {
								session: t.session.pickle(this.pickleKey)
							});
						this.cryptoStore.storeEndToEndSession(e, n, r, i)
					}
					getUtility(t) {
						const i = new e.Olm.Utility;
						try {
							return t(i)
						} finally {
							i.free()
						}
					}
					async sign(e) {
						let t;
						return await this.cryptoStore.doTxn("readonly", [o.IndexedDBCryptoStore.STORE_ACCOUNT], i => {
							this.getAccount(i, i => {
								t = i.sign(e)
							})
						}), t
					}
					async getOneTimeKeys() {
						let e;
						return await this.cryptoStore.doTxn("readonly", [o.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
							this.getAccount(t, t => {
								e = JSON.parse(t.one_time_keys())
							})
						}), e
					}
					maxNumberOfOneTimeKeys() {
						var e;
						return null !== (e = this.maxOneTimeKeys) && void 0 !== e ? e : -1
					}
					async markKeysAsPublished() {
						await this.cryptoStore.doTxn("readwrite", [o.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
							this.getAccount(e, t => {
								t.mark_keys_as_published(), this.storeAccount(e, t)
							})
						})
					}
					generateOneTimeKeys(e) {
						return this.cryptoStore.doTxn("readwrite", [o.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
							this.getAccount(t, i => {
								i.generate_one_time_keys(e), this.storeAccount(t, i)
							})
						})
					}
					async generateFallbackKey() {
						await this.cryptoStore.doTxn("readwrite", [o.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
							this.getAccount(e, t => {
								t.generate_fallback_key(), this.storeAccount(e, t)
							})
						})
					}
					async getFallbackKey() {
						let e;
						return await this.cryptoStore.doTxn("readonly", [o.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
							this.getAccount(t, t => {
								e = JSON.parse(t.unpublished_fallback_key())
							})
						}), e
					}
					async forgetOldFallbackKey() {
						await this.cryptoStore.doTxn("readwrite", [o.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
							this.getAccount(e, t => {
								t.forget_old_fallback_key(), this.storeAccount(e, t)
							})
						})
					}
					async createOutboundSession(t, i) {
						let n;
						return await this.cryptoStore.doTxn("readwrite", [o.IndexedDBCryptoStore.STORE_ACCOUNT, o.IndexedDBCryptoStore.STORE_SESSIONS], r => {
							this.getAccount(r, s => {
								const o = new e.Olm.Session;
								try {
									o.create_outbound(s, t, i), n = o.session_id(), this.storeAccount(r, s);
									const e = {
										session: o,
										lastReceivedMessageTs: Date.now()
									};
									this.saveSession(t, e, r)
								} finally {
									o.free()
								}
							})
						}, s.logger.withPrefix("[createOutboundSession]")), n
					}
					async createInboundSession(t, i, n) {
						if (0 !== i) throw new Error("Need messageType == 0 to create inbound session");
						let r;
						return await this.cryptoStore.doTxn("readwrite", [o.IndexedDBCryptoStore.STORE_ACCOUNT, o.IndexedDBCryptoStore.STORE_SESSIONS], s => {
							this.getAccount(s, o => {
								const a = new e.Olm.Session;
								try {
									a.create_inbound_from(o, t, n), o.remove_one_time_keys(a), this.storeAccount(s, o);
									const e = a.decrypt(i, n),
										d = {
											session: a,
											lastReceivedMessageTs: Date.now()
										};
									this.saveSession(t, d, s), r = {
										payload: e,
										session_id: a.session_id()
									}
								} finally {
									a.free()
								}
							})
						}, s.logger.withPrefix("[createInboundSession]")), r
					}
					async getSessionIdsForDevice(e) {
						const t = s.logger.withPrefix("[getSessionIdsForDevice]");
						if (e in this.sessionsInProgress) {
							t.debug(`Waiting for Olm session for ${e} to be created`);
							try {
								await this.sessionsInProgress[e]
							} catch (n) {}
						}
						let i;
						return await this.cryptoStore.doTxn("readonly", [o.IndexedDBCryptoStore.STORE_SESSIONS], t => {
							this.cryptoStore.getEndToEndSessions(e, t, e => {
								i = Object.keys(e)
							})
						}, t), i
					}
					async getSessionIdForDevice(e, t = !1, i) {
						const n = await this.getSessionInfoForDevice(e, t, i);
						if (0 === n.length) return null;
						let r = 0;
						for (let s = 1; s < n.length; s++) {
							const e = n[s],
								t = void 0 === e.lastReceivedMessageTs ? 0 : e.lastReceivedMessageTs,
								i = n[r],
								o = void 0 === i.lastReceivedMessageTs ? 0 : i.lastReceivedMessageTs;
							(t > o || t === o && e.sessionId < i.sessionId) && (r = s)
						}
						return n[r].sessionId
					}
					async getSessionInfoForDevice(e, t = !1, i = s.logger) {
						if (i = i.withPrefix("[getSessionInfoForDevice]"), e in this.sessionsInProgress && !t) {
							i.debug(`Waiting for Olm session for ${e} to be created`);
							try {
								await this.sessionsInProgress[e]
							} catch (r) {}
						}
						const n = [];
						return await this.cryptoStore.doTxn("readonly", [o.IndexedDBCryptoStore.STORE_SESSIONS], t => {
							this.cryptoStore.getEndToEndSessions(e, t, e => {
								const t = Object.keys(e).sort();
								for (const i of t) this.unpickleSession(e[i], e => {
									n.push({
										lastReceivedMessageTs: e.lastReceivedMessageTs,
										hasReceivedMessage: e.session.has_received_message(),
										sessionId: i
									})
								})
							})
						}, i), n
					}
					async encryptMessage(e, t, i) {
						let n;
						return c(i), await this.cryptoStore.doTxn("readwrite", [o.IndexedDBCryptoStore.STORE_SESSIONS], r => {
							this.getSession(e, t, r, o => {
								const a = o.session.describe();
								s.logger.log("encryptMessage: Olm Session ID " + t + " to " + e + ": " + a), n = o.session.encrypt(i), this.saveSession(e, o, r)
							})
						}, s.logger.withPrefix("[encryptMessage]")), n
					}
					async decryptMessage(e, t, i, n) {
						let r;
						return await this.cryptoStore.doTxn("readwrite", [o.IndexedDBCryptoStore.STORE_SESSIONS], o => {
							this.getSession(e, t, o, a => {
								const d = a.session.describe();
								s.logger.log("decryptMessage: Olm Session ID " + t + " from " + e + ": " + d), r = a.session.decrypt(i, n), a.lastReceivedMessageTs = Date.now(), this.saveSession(e, a, o)
							})
						}, s.logger.withPrefix("[decryptMessage]")), r
					}
					async matchesSession(e, t, i, n) {
						if (0 !== i) return !1;
						let r;
						return await this.cryptoStore.doTxn("readonly", [o.IndexedDBCryptoStore.STORE_SESSIONS], i => {
							this.getSession(e, t, i, e => {
								r = e.session.matches_inbound(n)
							})
						}, s.logger.withPrefix("[matchesSession]")), r
					}
					async recordSessionProblem(e, t, i) {
						await this.cryptoStore.storeEndToEndSessionProblem(e, t, i)
					}
					sessionMayHaveProblems(e, t) {
						return this.cryptoStore.getEndToEndSessionProblem(e, t)
					}
					filterOutNotifiedErrorDevices(e) {
						return this.cryptoStore.filterOutNotifiedErrorDevices(e)
					}
					saveOutboundGroupSession(e) {
						this.outboundGroupSessionStore[e.session_id()] = e.pickle(this.pickleKey)
					}
					getOutboundGroupSession(t, i) {
						const n = this.outboundGroupSessionStore[t];
						if (void 0 === n) throw new Error("Unknown outbound group session " + t);
						const r = new e.Olm.OutboundGroupSession;
						try {
							return r.unpickle(this.pickleKey, n), i(r)
						} finally {
							r.free()
						}
					}
					createOutboundGroupSession() {
						const t = new e.Olm.OutboundGroupSession;
						try {
							return t.create(), this.saveOutboundGroupSession(t), t.session_id()
						} finally {
							t.free()
						}
					}
					encryptGroupMessage(e, t) {
						return s.logger.log(`encrypting msg with megolm session ${e}`), c(t), this.getOutboundGroupSession(e, e => {
							const i = e.encrypt(t);
							return this.saveOutboundGroupSession(e), i
						})
					}
					getOutboundGroupSessionKey(e) {
						return this.getOutboundGroupSession(e, (function(e) {
							return {
								chain_index: e.message_index(),
								key: e.session_key()
							}
						}))
					}
					unpickleInboundGroupSession(t, i) {
						const n = new e.Olm.InboundGroupSession;
						try {
							return n.unpickle(this.pickleKey, t.session), i(n)
						} finally {
							n.free()
						}
					}
					getInboundGroupSession(e, t, i, n, r) {
						this.cryptoStore.getEndToEndInboundGroupSession(t, i, n, (t, i) => {
							if (null !== t) {
								if (null !== e && e !== t.room_id) throw new Error("Mismatched room_id for inbound group session (expected " + t.room_id + ", was " + e + ")");
								this.unpickleInboundGroupSession(t, e => {
									r(e, t, i)
								})
							} else r(null, null, i)
						})
					}
					async addInboundGroupSession(t, i, n, r, a, d, l, c = {}) {
						await this.cryptoStore.doTxn("readwrite", [o.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, o.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD, o.IndexedDBCryptoStore.STORE_SHARED_HISTORY_INBOUND_GROUP_SESSIONS], o => {
							this.getInboundGroupSession(t, i, r, o, (u, h) => {
								const m = new e.Olm.InboundGroupSession;
								try {
									if (l ? m.import_session(a) : m.create(a), r != m.session_id()) throw new Error("Mismatched group session ID from senderKey: " + i);
									if (u && (s.logger.log("Update for megolm session " + i + "/" + r), u.first_known_index() <= m.first_known_index())) {
										if (!h.untrusted || c.untrusted) return void s.logger.log(`Keeping existing megolm session ${r}`);
										if (u.first_known_index() < m.first_known_index()) return void(u.export_session(m.first_known_index()) === m.export_session(m.first_known_index()) ? (s.logger.info("Upgrading trust of existing megolm session " + r + " based on newly-received trusted session"), h.untrusted = !1, this.cryptoStore.storeEndToEndInboundGroupSession(i, r, h, o)) : s.logger.warn("Newly-received megolm session " + r + " does not match existing session! Keeping existing session"))
									}
									s.logger.info("Storing megolm session " + i + "/" + r + " with first index " + m.first_known_index());
									const e = Object.assign({}, c, {
										room_id: t,
										session: m.pickle(this.pickleKey),
										keysClaimed: d,
										forwardingCurve25519KeyChain: n
									});
									this.cryptoStore.storeEndToEndInboundGroupSession(i, r, e, o), !u && c.sharedHistory && this.cryptoStore.addSharedHistoryInboundGroupSession(t, i, r, o)
								} finally {
									m.free()
								}
							})
						}, s.logger.withPrefix("[addInboundGroupSession]"))
					}
					async addInboundGroupSessionWithheld(e, t, i, n, r) {
						await this.cryptoStore.doTxn("readwrite", [o.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], s => {
							this.cryptoStore.storeEndToEndInboundGroupSessionWithheld(t, i, {
								room_id: e,
								code: n,
								reason: r
							}, s)
						})
					}
					async decryptGroupMessage(e, t, i, n, r, d) {
						let l, c = null;
						if (await this.cryptoStore.doTxn("readwrite", [o.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, o.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], s => {
								this.getInboundGroupSession(e, t, i, s, (e, o, u) => {
									if (null === e || null === o) return u && (l = new a.DecryptionError("MEGOLM_UNKNOWN_INBOUND_SESSION_ID", h(u), {
										session: t + "|" + i
									})), void(c = null);
									let m;
									try {
										m = e.decrypt(n)
									} catch (g) {
										return void(l = "OLM.UNKNOWN_MESSAGE_INDEX" === (null == g ? void 0 : g.message) && u ? new a.DecryptionError("MEGOLM_UNKNOWN_INBOUND_SESSION_ID", h(u), {
											session: t + "|" + i
										}) : g)
									}
									let p = m.plaintext;
									if (void 0 === p) p = m;
									else {
										const e = t + "|" + i + "|" + m.message_index;
										if (e in this.inboundGroupSessionMessageIndexes) {
											const t = this.inboundGroupSessionMessageIndexes[e];
											if (t.id !== r || t.timestamp !== d) return void(l = new Error("Duplicate message index, possible replay attack: " + e))
										}
										this.inboundGroupSessionMessageIndexes[e] = {
											id: r,
											timestamp: d
										}
									}
									o.session = e.pickle(this.pickleKey), this.cryptoStore.storeEndToEndInboundGroupSession(t, i, o, s), c = {
										result: p,
										keysClaimed: o.keysClaimed || {},
										senderKey: t,
										forwardingCurve25519KeyChain: o.forwardingCurve25519KeyChain || [],
										untrusted: !!o.untrusted
									}
								})
							}, s.logger.withPrefix("[decryptGroupMessage]")), l) throw l;
						return c
					}
					async hasInboundSessionKeys(e, t, i) {
						let n;
						return await this.cryptoStore.doTxn("readonly", [o.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, o.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], r => {
							this.cryptoStore.getEndToEndInboundGroupSession(t, i, r, r => {
								null !== r ? e !== r.room_id ? (s.logger.warn(`requested keys for inbound group session ${t}|` + `${i}, with incorrect room_id ` + `(expected ${r.room_id}, ` + `was ${e})`), n = !1) : n = !0 : n = !1
							})
						}, s.logger.withPrefix("[hasInboundSessionKeys]")), n
					}
					async getInboundGroupSessionKey(e, t, i, n) {
						let r = null;
						return await this.cryptoStore.doTxn("readonly", [o.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, o.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], s => {
							this.getInboundGroupSession(e, t, i, s, (e, t) => {
								if (null === e || null === t) return void(r = null);
								void 0 === n && (n = e.first_known_index());
								const i = e.export_session(n),
									s = (t.keysClaimed || {}).ed25519 || null,
									o = t.forwardingCurve25519KeyChain || [],
									a = "untrusted" in t ? t.untrusted : o.length > 0;
								r = {
									chain_index: n,
									key: i,
									forwarding_curve25519_key_chain: o,
									sender_claimed_ed25519_key: s,
									shared_history: t.sharedHistory || !1,
									untrusted: a
								}
							})
						}, s.logger.withPrefix("[getInboundGroupSessionKey]")), r
					}
					exportInboundGroupSession(e, t, i) {
						return this.unpickleInboundGroupSession(i, n => {
							const r = n.first_known_index();
							return {
								sender_key: e,
								sender_claimed_keys: i.keysClaimed,
								room_id: i.room_id,
								session_id: t,
								session_key: n.export_session(r),
								forwarding_curve25519_key_chain: i.forwardingCurve25519KeyChain || [],
								first_known_index: n.first_known_index(),
								"org.matrix.msc3061.shared_history": i.sharedHistory || !1
							}
						})
					}
					async getSharedHistoryInboundGroupSessions(e) {
						let t;
						return await this.cryptoStore.doTxn("readonly", [o.IndexedDBCryptoStore.STORE_SHARED_HISTORY_INBOUND_GROUP_SESSIONS], i => {
							t = this.cryptoStore.getSharedHistoryInboundGroupSessions(e, i)
						}, s.logger.withPrefix("[getSharedHistoryInboundGroupSessionsForRoom]")), t
					}
					verifySignature(e, t, i) {
						this.getUtility((function(n) {
							n.ed25519_verify(e, t, i)
						}))
					}
				};
				const u = {
					"m.unverified": "The sender has disabled encrypting to unverified devices.",
					"m.blacklisted": "The sender has blocked you.",
					"m.unauthorised": "You are not authorised to read the message.",
					"m.no_olm": "Unable to establish a secure channel."
				};

				function h(e) {
					return e.code && e.code in u ? u[e.code] : e.reason ? e.reason : "decryption key withheld"
				}
				t.WITHHELD_MESSAGES = u
			}).call(this, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/crypto/OutgoingRoomKeyRequestManager.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.RoomKeyRequestState = t.OutgoingRoomKeyRequestManager = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = i("./node_modules/matrix-js-sdk/lib/@types/event.js");
			const a = 500;
			let d;
			t.RoomKeyRequestState = d,
				function(e) {
					e[e.Unsent = 0] = "Unsent", e[e.Sent = 1] = "Sent", e[e.CancellationPending = 2] = "CancellationPending", e[e.CancellationPendingAndWillResend = 3] = "CancellationPendingAndWillResend"
				}(d || (t.RoomKeyRequestState = d = {}));

			function l(e) {
				return e.room_id + " / " + e.session_id
			}

			function c(e) {
				return `[${e.map(e=>`${e.userId}:${e.deviceId}`).join(",")}]`
			}
			t.OutgoingRoomKeyRequestManager = class {
				constructor(e, t, i) {
					this.baseApis = e, this.deviceId = t, this.cryptoStore = i, (0, r.default)(this, "sendOutgoingRoomKeyRequestsTimer", void 0), (0, r.default)(this, "sendOutgoingRoomKeyRequestsRunning", !1), (0, r.default)(this, "clientRunning", !0)
				}
				stop() {
					s.logger.log("stopping OutgoingRoomKeyRequestManager"), this.clientRunning = !1
				}
				sendQueuedRequests() {
					this.startTimer()
				}
				async queueRoomKeyRequest(e, t, i = !1) {
					const n = await this.cryptoStore.getOutgoingRoomKeyRequest(e);
					if (n) switch (n.state) {
						case d.CancellationPendingAndWillResend:
						case d.Unsent:
							return;
						case d.CancellationPending: {
							const e = i ? d.CancellationPendingAndWillResend : d.Sent;
							await this.cryptoStore.updateOutgoingRoomKeyRequest(n.requestId, d.CancellationPending, {
								state: e,
								cancellationTxnId: this.baseApis.makeTxnId()
							});
							break
						}
						case d.Sent:
							if (i) {
								const o = d.CancellationPendingAndWillResend,
									a = await this.cryptoStore.updateOutgoingRoomKeyRequest(n.requestId, d.Sent, {
										state: o,
										cancellationTxnId: this.baseApis.makeTxnId(),
										requestTxnId: this.baseApis.makeTxnId()
									});
								if (!a) return this.queueRoomKeyRequest(e, t, i);
								try {
									await this.sendOutgoingRoomKeyRequestCancellation(a, !0)
								} catch (r) {
									s.logger.error("Error sending room key request cancellation; will retry later.", r)
								}
							}
							break;
						default:
							throw new Error("unhandled state: " + n.state)
					} else await this.cryptoStore.getOrAddOutgoingRoomKeyRequest({
						requestBody: e,
						recipients: t,
						requestId: this.baseApis.makeTxnId(),
						state: d.Unsent
					})
				}
				cancelRoomKeyRequest(e) {
					return this.cryptoStore.getOutgoingRoomKeyRequest(e).then(t => {
						if (t) switch (t.state) {
							case d.CancellationPending:
							case d.CancellationPendingAndWillResend:
								return;
							case d.Unsent:
								return s.logger.log("deleting unnecessary room key request for " + l(e)), this.cryptoStore.deleteOutgoingRoomKeyRequest(t.requestId, d.Unsent);
							case d.Sent:
								return this.cryptoStore.updateOutgoingRoomKeyRequest(t.requestId, d.Sent, {
									state: d.CancellationPending,
									cancellationTxnId: this.baseApis.makeTxnId()
								}).then(t => {
									t ? this.sendOutgoingRoomKeyRequestCancellation(t).catch(e => {
										s.logger.error("Error sending room key request cancellation; will retry later.", e), this.startTimer()
									}) : s.logger.log("Tried to cancel room key request for " + l(e) + " but it was already cancelled in another tab")
								});
							default:
								throw new Error("unhandled state: " + t.state)
						}
					})
				}
				getOutgoingSentRoomKeyRequest(e, t) {
					return this.cryptoStore.getOutgoingRoomKeyRequestsByTarget(e, t, [d.Sent])
				}
				async cancelAndResendAllOutgoingRequests() {
					const e = await this.cryptoStore.getAllOutgoingRoomKeyRequestsByState(d.Sent);
					return Promise.all(e.map(({
						requestBody: e,
						recipients: t
					}) => this.queueRoomKeyRequest(e, t, !0)))
				}
				startTimer() {
					if (this.sendOutgoingRoomKeyRequestsTimer) return;
					this.sendOutgoingRoomKeyRequestsTimer = setTimeout(() => {
						if (this.sendOutgoingRoomKeyRequestsRunning) throw new Error("RoomKeyRequestSend already in progress!");
						this.sendOutgoingRoomKeyRequestsRunning = !0, this.sendOutgoingRoomKeyRequests().finally(() => {
							this.sendOutgoingRoomKeyRequestsRunning = !1
						}).catch(e => {
							s.logger.warn(`error in OutgoingRoomKeyRequestManager: ${e}`)
						})
					}, a)
				}
				async sendOutgoingRoomKeyRequests() {
					if (!this.clientRunning) return void(this.sendOutgoingRoomKeyRequestsTimer = void 0);
					const e = await this.cryptoStore.getOutgoingRoomKeyRequestByState([d.CancellationPending, d.CancellationPendingAndWillResend, d.Unsent]);
					if (e) try {
						switch (e.state) {
							case d.Unsent:
								await this.sendOutgoingRoomKeyRequest(e);
								break;
							case d.CancellationPending:
								await this.sendOutgoingRoomKeyRequestCancellation(e);
								break;
							case d.CancellationPendingAndWillResend:
								await this.sendOutgoingRoomKeyRequestCancellation(e, !0)
						}
						return this.sendOutgoingRoomKeyRequests()
					} catch (t) {
						s.logger.error("Error sending room key request; will retry later.", t), this.sendOutgoingRoomKeyRequestsTimer = void 0
					} else this.sendOutgoingRoomKeyRequestsTimer = void 0
				}
				sendOutgoingRoomKeyRequest(e) {
					s.logger.log(`Requesting keys for ${l(e.requestBody)}` + ` from ${c(e.recipients)}` + `(id ${e.requestId})`);
					const t = {
						action: "request",
						requesting_device_id: this.deviceId,
						request_id: e.requestId,
						body: e.requestBody
					};
					return this.sendMessageToDevices(t, e.recipients, e.requestTxnId || e.requestId).then(() => this.cryptoStore.updateOutgoingRoomKeyRequest(e.requestId, d.Unsent, {
						state: d.Sent
					}))
				}
				sendOutgoingRoomKeyRequestCancellation(e, t = !1) {
					s.logger.log("Sending cancellation for key request for " + `${l(e.requestBody)} to ` + `${c(e.recipients)} ` + `(cancellation id ${e.cancellationTxnId})`);
					const i = {
						action: "request_cancellation",
						requesting_device_id: this.deviceId,
						request_id: e.requestId
					};
					return this.sendMessageToDevices(i, e.recipients, e.cancellationTxnId).then(() => t ? this.cryptoStore.updateOutgoingRoomKeyRequest(e.requestId, d.CancellationPendingAndWillResend, {
						state: d.Unsent
					}) : this.cryptoStore.deleteOutgoingRoomKeyRequest(e.requestId, d.CancellationPending))
				}
				sendMessageToDevices(e, t, i) {
					const n = {};
					for (const r of t) n[r.userId] || (n[r.userId] = {}), n[r.userId][r.deviceId] = e;
					return this.baseApis.sendToDevice(o.EventType.RoomKeyRequest, n, i)
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/crypto/RoomList.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.RoomList = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/crypto/store/indexeddb-crypto-store.js");
			t.RoomList = class {
				constructor(e) {
					this.cryptoStore = e, (0, r.default)(this, "roomEncryption", {})
				}
				async init() {
					await this.cryptoStore.doTxn("readwrite", [s.IndexedDBCryptoStore.STORE_ROOMS], e => {
						this.cryptoStore.getEndToEndRooms(e, e => {
							this.roomEncryption = e
						})
					})
				}
				getRoomEncryption(e) {
					return this.roomEncryption[e] || null
				}
				isRoomEncrypted(e) {
					return Boolean(this.getRoomEncryption(e))
				}
				async setRoomEncryption(e, t) {
					this.roomEncryption[e] = t, await this.cryptoStore.doTxn("readwrite", [s.IndexedDBCryptoStore.STORE_ROOMS], i => {
						this.cryptoStore.storeEndToEndRoom(e, t, i)
					})
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/crypto/SecretStorage.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.SecretStorage = t.SECRET_STORAGE_ALGORITHM_V1_AES = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = u(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/crypto/olmlib.js")),
				a = i("./node_modules/matrix-js-sdk/lib/randomstring.js"),
				d = i("./node_modules/matrix-js-sdk/lib/crypto/aes.js"),
				l = i("./node_modules/matrix-js-sdk/lib/client.js"),
				c = i("./node_modules/matrix-js-sdk/lib/utils.js");

			function u(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (u = function(e) {
					return e ? i : t
				})(e)
			}
			const h = "m.secret_storage.v1.aes-hmac-sha2";
			t.SECRET_STORAGE_ALGORITHM_V1_AES = h;
			t.SecretStorage = class {
				constructor(e, t, i) {
					this.accountDataAdapter = e, this.cryptoCallbacks = t, this.baseApis = i, (0, r.default)(this, "requests", new Map)
				}
				async getDefaultKeyId() {
					const e = await this.accountDataAdapter.getAccountDataFromServer("m.secret_storage.default_key");
					return e ? e.key : null
				}
				setDefaultKeyId(e) {
					return new Promise((t, i) => {
						const n = i => {
							"m.secret_storage.default_key" === i.getType() && i.getContent().key === e && (this.accountDataAdapter.removeListener(l.ClientEvent.AccountData, n), t())
						};
						this.accountDataAdapter.on(l.ClientEvent.AccountData, n), this.accountDataAdapter.setAccountData("m.secret_storage.default_key", {
							key: e
						}).catch(e => {
							this.accountDataAdapter.removeListener(l.ClientEvent.AccountData, n), i(e)
						})
					})
				}
				async addKey(e, t = {}, i) {
					const n = {
						algorithm: e
					};
					if (t.name && (n.name = t.name), e !== h) throw new Error(`Unknown key algorithm ${e}`);
					if (t.passphrase && (n.passphrase = t.passphrase), t.key) {
						const {
							iv: e,
							mac: i
						} = await (0, d.calculateKeyCheck)(t.key);
						n.iv = e, n.mac = i
					}
					if (!i)
						do {
							i = (0, a.randomString)(32)
						} while (await this.accountDataAdapter.getAccountDataFromServer(`m.secret_storage.key.${i}`));
					return await this.accountDataAdapter.setAccountData(`m.secret_storage.key.${i}`, n), {
						keyId: i,
						keyInfo: n
					}
				}
				async getKey(e) {
					if (e || (e = await this.getDefaultKeyId()), !e) return null;
					const t = await this.accountDataAdapter.getAccountDataFromServer("m.secret_storage.key." + e);
					return t ? [e, t] : null
				}
				async hasKey(e) {
					return Boolean(await this.getKey(e))
				}
				async checkKey(e, t) {
					if (t.algorithm === h) {
						if (t.mac) {
							const {
								mac: i
							} = await (0, d.calculateKeyCheck)(e, t.iv);
							return t.mac.replace(/=+$/g, "") === i.replace(/=+$/g, "")
						}
						return !0
					}
					throw new Error("Unknown algorithm")
				}
				async store(e, t, i) {
					const n = {};
					if (!i) {
						const e = await this.getDefaultKeyId();
						if (!e) throw new Error("No keys specified and no default key present");
						i = [e]
					}
					if (0 === i.length) throw new Error("Zero keys given to encrypt with!");
					for (const r of i) {
						const i = await this.accountDataAdapter.getAccountDataFromServer("m.secret_storage.key." + r);
						if (!i) throw new Error("Unknown key: " + r);
						if (i.algorithm === h) {
							const s = {
									[r]: i
								},
								[, o] = await this.getSecretStorageKey(s, e);
							n[r] = await o.encrypt(t)
						} else s.logger.warn("unknown algorithm for secret storage key " + r + ": " + i.algorithm)
					}
					await this.accountDataAdapter.setAccountData(e, {
						encrypted: n
					})
				}
				async get(e) {
					const t = await this.accountDataAdapter.getAccountDataFromServer(e);
					if (!t) return;
					if (!t.encrypted) throw new Error("Content is not encrypted!");
					const i = {};
					for (const s of Object.keys(t.encrypted)) {
						const e = await this.accountDataAdapter.getAccountDataFromServer("m.secret_storage.key." + s),
							n = t.encrypted[s];
						e.algorithm === h && n.iv && n.ciphertext && n.mac && (i[s] = e)
					}
					if (0 === Object.keys(i).length) throw new Error(`Could not decrypt ${e} because none of ` + "the keys it is encrypted with are for a supported algorithm");
					let n, r;
					try {
						[n, r] = await this.getSecretStorageKey(i, e);
						const s = t.encrypted[n];
						return s.passthrough ? (0, o.encodeBase64)(r.get_private_key()) : r.decrypt(s)
					} finally {
						r && r.free && r.free()
					}
				}
				async isStored(e) {
					const t = await this.accountDataAdapter.getAccountDataFromServer(e);
					if (null == t || !t.encrypted) return null;
					const i = {};
					for (const n of Object.keys(t.encrypted)) {
						const e = await this.accountDataAdapter.getAccountDataFromServer("m.secret_storage.key." + n);
						if (!e) continue;
						const r = t.encrypted[n];
						e.algorithm === h && r.iv && r.ciphertext && r.mac && (i[n] = e)
					}
					return Object.keys(i).length ? i : null
				}
				request(e, t) {
					const i = this.baseApis.makeTxnId(),
						n = (0, c.defer)();
					this.requests.set(i, {
						name: e,
						devices: t,
						deferred: n
					});
					const r = {
							name: e,
							action: "request",
							requesting_device_id: this.baseApis.deviceId,
							request_id: i
						},
						o = {};
					for (const s of t) o[s] = r;
					return s.logger.info(`Request secret ${e} from ${t}, id ${i}`), this.baseApis.sendToDevice("m.secret.request", {
						[this.baseApis.getUserId()]: o
					}), {
						requestId: i,
						promise: n.promise,
						cancel: e => {
							const r = {
									action: "request_cancellation",
									requesting_device_id: this.baseApis.deviceId,
									request_id: i
								},
								s = {};
							for (const i of t) s[i] = r;
							this.baseApis.sendToDevice("m.secret.request", {
								[this.baseApis.getUserId()]: s
							}), n.reject(new Error(e || "Cancelled"))
						}
					}
				}
				async onRequestReceived(e) {
					const t = e.getSender(),
						i = e.getContent();
					if (t !== this.baseApis.getUserId() || !(i.name && i.action && i.requesting_device_id && i.request_id)) return;
					const n = i.requesting_device_id;
					if ("request_cancellation" === i.action);
					else if ("request" === i.action) {
						if (n === this.baseApis.deviceId) return;
						if (s.logger.info("received request for secret (" + t + ", " + n + ", " + i.request_id + ")"), !this.cryptoCallbacks.onSecretRequested) return;
						const e = await this.cryptoCallbacks.onSecretRequested(t, n, i.request_id, i.name, this.baseApis.checkDeviceTrust(t, n));
						if (e) {
							s.logger.info(`Preparing ${i.name} secret for ${n}`);
							const r = {
									type: "m.secret.send",
									content: {
										request_id: i.request_id,
										secret: e
									}
								},
								a = {
									algorithm: o.OLM_ALGORITHM,
									sender_key: this.baseApis.crypto.olmDevice.deviceCurve25519Key,
									ciphertext: {}
								};
							await o.ensureOlmSessionsForDevices(this.baseApis.crypto.olmDevice, this.baseApis, {
								[t]: [this.baseApis.getStoredDevice(t, n)]
							}), await o.encryptMessageForDevice(a.ciphertext, this.baseApis.getUserId(), this.baseApis.deviceId, this.baseApis.crypto.olmDevice, t, this.baseApis.getStoredDevice(t, n), r);
							const d = {
								[t]: {
									[n]: a
								}
							};
							s.logger.info(`Sending ${i.name} secret for ${n}`), this.baseApis.sendToDevice("m.room.encrypted", d)
						} else s.logger.info(`Request denied for ${i.name} secret for ${n}`)
					}
				}
				onSecretReceived(e) {
					if (e.getSender() !== this.baseApis.getUserId()) return;
					if (!o.isOlmEncrypted(e)) return void s.logger.error("secret event not properly encrypted");
					const t = e.getContent();
					if (this.baseApis.crypto.deviceList.getUserByIdentityKey(o.OLM_ALGORITHM, e.getSenderKey() || "") !== e.getSender()) return void s.logger.error("sending device does not belong to the user it claims to be from");
					s.logger.log("got secret share for request", t.request_id);
					const i = this.requests.get(t.request_id);
					if (i) {
						const n = this.baseApis.crypto.deviceList.getDeviceByIdentityKey(o.OLM_ALGORITHM, e.getSenderKey());
						if (!n) return void s.logger.log("secret share from unknown device with key", e.getSenderKey());
						if (!i.devices.includes(n.deviceId)) return void s.logger.log("unsolicited secret share from device", n.deviceId);
						if (!this.baseApis.crypto.checkDeviceInfoTrust(e.getSender(), n).isVerified()) return void s.logger.log("secret share from unverified device");
						s.logger.log(`Successfully received secret ${i.name} ` + `from ${n.deviceId}`), i.deferred.resolve(t.secret)
					}
				}
				async getSecretStorageKey(e, t) {
					if (!this.cryptoCallbacks.getSecretStorageKey) throw new Error("No getSecretStorageKey callback supplied");
					const i = await this.cryptoCallbacks.getSecretStorageKey({
						keys: e
					}, t);
					if (!i) throw new Error("getSecretStorageKey callback returned falsey");
					if (i.length < 2) throw new Error("getSecretStorageKey callback returned invalid data");
					const [n, r] = i;
					if (!e[n]) throw new Error("App returned unknown key from getSecretStorageKey!");
					if (e[n].algorithm === h) {
						return [n, {
							encrypt: function(e) {
								return (0, d.encryptAES)(e, r, t)
							},
							decrypt: function(e) {
								return (0, d.decryptAES)(e, r, t)
							}
						}]
					}
					throw new Error("Unknown key type: " + e[n].algorithm)
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/crypto/aes.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.calculateKeyCheck = function(e, t) {
				return o(d, e, "", t)
			}, t.decryptAES = async function(e, t, i) {
				const [s, o] = await a(t, i), d = (0, n.decodeBase64)(e.ciphertext);
				if (!(await r.subtleCrypto.verify({
						name: "HMAC"
					}, o, (0, n.decodeBase64)(e.mac), d))) throw new Error(`Error decrypting secret ${i}: bad MAC`);
				const l = await r.subtleCrypto.decrypt({
					name: "AES-CTR",
					counter: (0, n.decodeBase64)(e.iv),
					length: 64
				}, s, d);
				return (new TextDecoder).decode(new Uint8Array(l))
			}, t.encryptAES = o;
			var n = i("./node_modules/matrix-js-sdk/lib/crypto/olmlib.js"),
				r = i("./node_modules/matrix-js-sdk/lib/crypto/crypto.js");
			const s = new Uint8Array(8);
			async function o(e, t, i, s) {
				let o;
				s ? o = (0, n.decodeBase64)(s) : (o = new Uint8Array(16), r.crypto.getRandomValues(o), o[8] &= 127);
				const [d, l] = await a(t, i), c = (new r.TextEncoder).encode(e), u = await r.subtleCrypto.encrypt({
					name: "AES-CTR",
					counter: o,
					length: 64
				}, d, c), h = await r.subtleCrypto.sign({
					name: "HMAC"
				}, l, u);
				return {
					iv: (0, n.encodeBase64)(o),
					ciphertext: (0, n.encodeBase64)(u),
					mac: (0, n.encodeBase64)(h)
				}
			}
			async function a(e, t) {
				const i = await r.subtleCrypto.importKey("raw", e, {
						name: "HKDF"
					}, !1, ["deriveBits"]),
					n = await r.subtleCrypto.deriveBits({
						name: "HKDF",
						salt: s,
						info: (new r.TextEncoder).encode(t),
						hash: "SHA-256"
					}, i, 512),
					o = n.slice(0, 32),
					a = n.slice(32),
					d = r.subtleCrypto.importKey("raw", o, {
						name: "AES-CTR"
					}, !1, ["encrypt", "decrypt"]),
					l = r.subtleCrypto.importKey("raw", a, {
						name: "HMAC",
						hash: {
							name: "SHA-256"
						}
					}, !1, ["sign", "verify"]);
				return Promise.all([d, l])
			}
			const d = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
		},
		"./node_modules/matrix-js-sdk/lib/crypto/algorithms/base.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.UnknownDeviceError = t.EncryptionAlgorithm = t.ENCRYPTION_CLASSES = t.DecryptionError = t.DecryptionAlgorithm = t.DECRYPTION_CLASSES = void 0, t.registerAlgorithm = function(e, t, i) {
				s.set(e, t), o.set(e, i)
			};
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js"));
			const s = new Map;
			t.ENCRYPTION_CLASSES = s;
			const o = new Map;
			t.DECRYPTION_CLASSES = o;
			t.EncryptionAlgorithm = class {
				constructor(e) {
					(0, r.default)(this, "userId", void 0), (0, r.default)(this, "deviceId", void 0), (0, r.default)(this, "crypto", void 0), (0, r.default)(this, "olmDevice", void 0), (0, r.default)(this, "baseApis", void 0), (0, r.default)(this, "roomId", void 0), this.userId = e.userId, this.deviceId = e.deviceId, this.crypto = e.crypto, this.olmDevice = e.olmDevice, this.baseApis = e.baseApis, this.roomId = e.roomId
				}
				prepareToEncrypt(e) {}
				onRoomMembership(e, t, i) {}
			};
			t.DecryptionAlgorithm = class {
				constructor(e) {
					(0, r.default)(this, "userId", void 0), (0, r.default)(this, "crypto", void 0), (0, r.default)(this, "olmDevice", void 0), (0, r.default)(this, "baseApis", void 0), (0, r.default)(this, "roomId", void 0), this.userId = e.userId, this.crypto = e.crypto, this.olmDevice = e.olmDevice, this.baseApis = e.baseApis, this.roomId = e.roomId
				}
				async onRoomKeyEvent(e) {}
				async importRoomKey(e, t) {}
				hasKeysForKeyRequest(e) {
					return Promise.resolve(!1)
				}
				shareKeysWithDevice(e) {
					throw new Error("shareKeysWithDevice not supported for this DecryptionAlgorithm")
				}
				async retryDecryptionFromSender(e) {
					return !1
				}
			};
			class DecryptionError extends Error {
				constructor(e, t, i) {
					super(t), this.code = e, (0, r.default)(this, "detailedString", void 0), this.code = e, this.name = "DecryptionError", this.detailedString = function(e, t) {
						let i = e.name + "[msg: " + e.message;
						t && (i += ", " + Object.keys(t).map(e => e + ": " + t[e]).join(", "));
						return i += "]"
					}(this, i)
				}
			}
			t.DecryptionError = DecryptionError;
			class UnknownDeviceError extends Error {
				constructor(e, t, i) {
					super(e), this.devices = t, this.event = i, this.name = "UnknownDeviceError", this.devices = t
				}
			}
			t.UnknownDeviceError = UnknownDeviceError
		},
		"./node_modules/matrix-js-sdk/lib/crypto/algorithms/index.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), i("./node_modules/matrix-js-sdk/lib/crypto/algorithms/olm.js"), i("./node_modules/matrix-js-sdk/lib/crypto/algorithms/megolm.js");
			var n = i("./node_modules/matrix-js-sdk/lib/crypto/algorithms/base.js");
			Object.keys(n).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === n[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return n[e]
					}
				}))
			}))
		},
		"./node_modules/matrix-js-sdk/lib/crypto/algorithms/megolm.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.isRoomSharedHistory = h;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = u(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/crypto/olmlib.js")),
				a = i("./node_modules/matrix-js-sdk/lib/crypto/algorithms/base.js"),
				d = i("./node_modules/matrix-js-sdk/lib/crypto/OlmDevice.js"),
				l = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				c = i("./node_modules/matrix-js-sdk/lib/crypto/OutgoingRoomKeyRequestManager.js");

			function u(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (u = function(e) {
					return e ? i : t
				})(e)
			}

			function h(e) {
				var t, i;
				const n = null == e ? void 0 : null === (t = e.currentState) || void 0 === t ? void 0 : t.getStateEvents("m.room.history_visibility", ""),
					r = null == n ? void 0 : null === (i = n.getContent()) || void 0 === i ? void 0 : i.history_visibility;
				return ["world_readable", "shared"].includes(r)
			}
			class m {
				constructor(e, t = !1) {
					this.sessionId = e, this.sharedHistory = t, (0, r.default)(this, "useCount", 0), (0, r.default)(this, "creationTime", void 0), (0, r.default)(this, "sharedWithDevices", {}), (0, r.default)(this, "blockedDevicesNotified", {}), this.creationTime = (new Date).getTime()
				}
				needsRotation(e, t) {
					const i = (new Date).getTime() - this.creationTime;
					return (this.useCount >= e || i >= t) && (s.logger.log("Rotating megolm session after " + this.useCount + " messages, " + i + "ms"), !0)
				}
				markSharedWithDevice(e, t, i, n) {
					this.sharedWithDevices[e] || (this.sharedWithDevices[e] = {}), this.sharedWithDevices[e][t] = {
						deviceKey: i,
						messageIndex: n
					}
				}
				markNotifiedBlockedDevice(e, t) {
					this.blockedDevicesNotified[e] || (this.blockedDevicesNotified[e] = {}), this.blockedDevicesNotified[e][t] = !0
				}
				sharedWithTooManyDevices(e) {
					for (const t in this.sharedWithDevices)
						if (this.sharedWithDevices.hasOwnProperty(t)) {
							if (!e.hasOwnProperty(t)) return s.logger.log("Starting new megolm session because we shared with " + t), !0;
							for (const i in this.sharedWithDevices[t])
								if (this.sharedWithDevices[t].hasOwnProperty(i) && !e[t].hasOwnProperty(i)) return s.logger.log("Starting new megolm session because we shared with " + t + ":" + i), !0
						} return !1
				}
			}
			class p extends a.EncryptionAlgorithm {
				constructor(e) {
					var t, i, n, s;
					super(e), (0, r.default)(this, "setupPromise", Promise.resolve(null)), (0, r.default)(this, "outboundSessions", {}), (0, r.default)(this, "sessionRotationPeriodMsgs", void 0), (0, r.default)(this, "sessionRotationPeriodMs", void 0), (0, r.default)(this, "encryptionPreparation", void 0), (0, r.default)(this, "roomId", void 0), this.roomId = e.roomId, this.sessionRotationPeriodMsgs = null !== (t = null === (i = e.config) || void 0 === i ? void 0 : i.rotation_period_msgs) && void 0 !== t ? t : 100, this.sessionRotationPeriodMs = null !== (n = null === (s = e.config) || void 0 === s ? void 0 : s.rotation_period_ms) && void 0 !== n ? n : 6048e5
				}
				async ensureOutboundSession(e, t, i, n = !1) {
					const r = this.setupPromise.then(async r => {
						const o = h(e),
							a = await this.prepareSession(t, o, r);
						try {
							await this.shareSession(t, o, n, i, a)
						} catch (d) {
							s.logger.error(`Failed to ensure outbound session in ${this.roomId}`, d)
						}
						return a
					});
					return r.catch(e => {
						s.logger.error(`Failed to setup outbound session in ${this.roomId}`, e)
					}), this.setupPromise = r, r
				}
				async prepareSession(e, t, i) {
					var n, r;
					return i && t !== i.sharedHistory && (i = null), null !== (n = i) && void 0 !== n && n.needsRotation(this.sessionRotationPeriodMsgs, this.sessionRotationPeriodMs) && (s.logger.log("Starting new megolm session because we need to rotate."), i = null), null !== (r = i) && void 0 !== r && r.sharedWithTooManyDevices(e) && (i = null), i || (s.logger.log(`Starting new megolm session for room ${this.roomId}`), i = await this.prepareNewSession(t), s.logger.log(`Started new megolm session ${i.sessionId} ` + `for room ${this.roomId}`), this.outboundSessions[i.sessionId] = i), i
				}
				async shareSession(e, t, i, n, r) {
					const a = {};
					for (const [s, o] of Object.entries(e))
						for (const [e, t] of Object.entries(o)) {
							t.getIdentityKey() != this.olmDevice.deviceCurve25519Key && (r.sharedWithDevices[s] && void 0 !== r.sharedWithDevices[s][e] || (a[s] = a[s] || [], a[s].push(t)))
						}
					const d = this.olmDevice.getOutboundGroupSessionKey(r.sessionId),
						l = {
							type: "m.room_key",
							content: {
								algorithm: o.MEGOLM_ALGORITHM,
								room_id: this.roomId,
								session_id: r.sessionId,
								session_key: d.key,
								chain_index: d.chain_index,
								"org.matrix.msc3061.shared_history": t
							}
						},
						[c, u] = await o.getExistingOlmSessions(this.olmDevice, this.baseApis, a);
					await Promise.all([(async () => {
						s.logger.debug(`Sharing keys with existing Olm sessions in ${this.roomId}`, u), await this.shareKeyWithOlmSessions(r, d, l, u), s.logger.debug(`Shared keys with existing Olm sessions in ${this.roomId}`)
					})(), (async () => {
						s.logger.debug(`Sharing keys (start phase 1) with new Olm sessions in ${this.roomId}`, c);
						const e = [],
							t = Date.now(),
							n = [];
						await this.shareKeyWithDevices(r, d, l, c, e, i ? 1e4 : 2e3, n), s.logger.debug(`Shared keys (end phase 1) with new Olm sessions in ${this.roomId}`), !i && Date.now() - t < 1e4 ? (async () => {
							const t = {},
								i = new Set;
							for (const e of n) i.add(e);
							const o = [];
							for (const {
									userId: n,
									deviceInfo: r
								} of e) {
								const e = n.slice(n.indexOf(":") + 1);
								i.has(e) ? (t[n] = t[n] || [], t[n].push(r)) : o.push({
									userId: n,
									deviceInfo: r
								})
							}
							s.logger.debug(`Sharing keys (start phase 2) with new Olm sessions in ${this.roomId}`), await this.shareKeyWithDevices(r, d, l, t, o, 3e4), s.logger.debug(`Shared keys (end phase 2) with new Olm sessions in ${this.roomId}`), await this.notifyFailedOlmDevices(r, d, o)
						})() : await this.notifyFailedOlmDevices(r, d, e), s.logger.debug(`Shared keys (all phases done) with new Olm sessions in ${this.roomId}`)
					})(), (async () => {
						s.logger.debug(`There are ${Object.entries(n).length} blocked devices in ${this.roomId}`, Object.entries(n)), s.logger.debug(`Notifying newly blocked devices in ${this.roomId}`);
						const e = {};
						let t = 0;
						for (const [i, s] of Object.entries(n))
							for (const [n, o] of Object.entries(s)) r.blockedDevicesNotified[i] && void 0 !== r.blockedDevicesNotified[i][n] || (e[i] = e[i] || {}, e[i][n] = {
								device: o
							}, t++);
						await this.notifyBlockedDevices(r, e), s.logger.debug(`Notified ${t} newly blocked devices in ${this.roomId}`, e)
					})()])
				}
				async prepareNewSession(e) {
					const t = this.olmDevice.createOutboundGroupSession(),
						i = this.olmDevice.getOutboundGroupSessionKey(t);
					return await this.olmDevice.addInboundGroupSession(this.roomId, this.olmDevice.deviceCurve25519Key, [], t, i.key, {
						ed25519: this.olmDevice.deviceEd25519Key
					}, !1, {
						sharedHistory: e
					}), this.crypto.backupManager.backupGroupSession(this.olmDevice.deviceCurve25519Key, t), new m(t, e)
				}
				getDevicesWithoutSessions(e, t, i = []) {
					for (const [n, r] of Object.entries(t)) {
						const t = e[n];
						for (const e of r) {
							const r = e.deviceId;
							t[r].sessionId || (i.push({
								userId: n,
								deviceInfo: e
							}), delete t[r])
						}
					}
					return i
				}
				splitDevices(e) {
					let t = [];
					const i = [t];
					for (const [n, r] of Object.entries(e)) {
						for (const e of Object.values(r)) t.push({
							userId: n,
							deviceInfo: e.device
						});
						t.length > 20 && (t = [], i.push(t))
					}
					return 0 === t.length && i.pop(), i
				}
				encryptAndSendKeysToDevices(e, t, i, n) {
					return this.crypto.encryptAndSendToDevices(i, n).then(() => {
						for (const n of i) e.markSharedWithDevice(n.userId, n.deviceInfo.deviceId, n.deviceInfo.getIdentityKey(), t)
					}).catch(e => {
						throw s.logger.error("failed to encryptAndSendToDevices", e), e
					})
				}
				async sendBlockedNotificationsToDevices(e, t, i) {
					const n = {};
					for (const r of t) {
						const e = r.userId,
							t = r.deviceInfo,
							s = t.deviceInfo.deviceId,
							o = Object.assign({}, i);
						o.code = t.code, o.reason = t.reason, "m.no_olm" === o.code && (delete o.room_id, delete o.session_id), n[e] || (n[e] = {}), n[e][s] = o
					}
					await this.baseApis.sendToDevice("m.room_key.withheld", n);
					for (const r of Object.keys(n))
						for (const t of Object.keys(n[r])) e.markNotifiedBlockedDevice(r, t)
				}
				async reshareKeyWithDevice(e, t, i, n) {
					const r = this.outboundSessions[t];
					if (!r) return void s.logger.debug(`megolm session ${t} not found: not re-sharing keys`);
					if (void 0 === r.sharedWithDevices[i]) return void s.logger.debug(`megolm session ${t} never shared with user ${i}`);
					const a = r.sharedWithDevices[i][n.deviceId];
					if (void 0 === a) return void s.logger.debug("megolm session ID " + t + " never shared with device " + i + ":" + n.deviceId);
					if (a.deviceKey !== n.getIdentityKey()) return void s.logger.warn(`Session has been shared with device ${n.deviceId} but with identity ` + `key ${a.deviceKey}. Key is now ${n.getIdentityKey()}!`);
					const d = await this.olmDevice.getInboundGroupSessionKey(this.roomId, e, t, a.messageIndex);
					if (!d) return void s.logger.warn(`No inbound session key found for megolm ${t}: not re-sharing keys`);
					await o.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, {
						[i]: [n]
					});
					const l = {
							type: "m.forwarded_room_key",
							content: {
								algorithm: o.MEGOLM_ALGORITHM,
								room_id: this.roomId,
								session_id: t,
								session_key: d.key,
								chain_index: d.chain_index,
								sender_key: e,
								sender_claimed_ed25519_key: d.sender_claimed_ed25519_key,
								forwarding_curve25519_key_chain: d.forwarding_curve25519_key_chain,
								"org.matrix.msc3061.shared_history": d.shared_history || !1
							}
						},
						c = {
							algorithm: o.OLM_ALGORITHM,
							sender_key: this.olmDevice.deviceCurve25519Key,
							ciphertext: {}
						};
					await o.encryptMessageForDevice(c.ciphertext, this.userId, this.deviceId, this.olmDevice, i, n, l), await this.baseApis.sendToDevice("m.room.encrypted", {
						[i]: {
							[n.deviceId]: c
						}
					}), s.logger.debug(`Re-shared key for megolm session ${t} with ${i}:${n.deviceId}`)
				}
				async shareKeyWithDevices(e, t, i, n, r, a, d) {
					var l;
					s.logger.debug(`Ensuring Olm sessions for devices in ${this.roomId}`);
					const c = await o.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, n, !1, a, d, null === (l = s.logger.withPrefix) || void 0 === l ? void 0 : l.call(s.logger, `[${this.roomId}]`));
					s.logger.debug(`Ensured Olm sessions for devices in ${this.roomId}`), this.getDevicesWithoutSessions(c, n, r), s.logger.debug(`Sharing keys with newly created Olm sessions in ${this.roomId}`), await this.shareKeyWithOlmSessions(e, t, i, c), s.logger.debug(`Shared keys with newly created Olm sessions in ${this.roomId}`)
				}
				async shareKeyWithOlmSessions(e, t, i, n) {
					const r = this.splitDevices(n);
					for (let a = 0; a < r.length; a++) {
						const n = `megolm keys for ${e.sessionId} ` + `in ${this.roomId} (slice ${a+1}/${r.length})`;
						try {
							s.logger.debug(`Sharing ${n}`, r[a].map(e => `${e.userId}/${e.deviceInfo.deviceId}`)), await this.encryptAndSendKeysToDevices(e, t.chain_index, r[a], i), s.logger.debug(`Shared ${n}`)
						} catch (o) {
							throw s.logger.error(`Failed to share ${n}`), o
						}
					}
				}
				async notifyFailedOlmDevices(e, t, i) {
					s.logger.debug(`Notifying ${i.length} devices we failed to ` + `create Olm sessions in ${this.roomId}`);
					for (const {
							userId: s,
							deviceInfo: o
						} of i) {
						const i = o.deviceId;
						e.markSharedWithDevice(s, i, o.getIdentityKey(), t.chain_index)
					}
					const n = await this.olmDevice.filterOutNotifiedErrorDevices(i);
					s.logger.debug(`Need to notify ${n.length} failed devices ` + `which haven't been notified before in ${this.roomId}`);
					const r = {};
					for (const {
							userId: s,
							deviceInfo: o
						} of n) r[s] = r[s] || {}, r[s][o.deviceId] = {
						device: {
							code: "m.no_olm",
							reason: d.WITHHELD_MESSAGES["m.no_olm"],
							deviceInfo: o
						}
					};
					await this.notifyBlockedDevices(e, r), s.logger.debug(`Notified ${n.length} devices we failed to ` + `create Olm sessions in ${this.roomId}`)
				}
				async notifyBlockedDevices(e, t) {
					const i = {
							room_id: this.roomId,
							session_id: e.sessionId,
							algorithm: o.MEGOLM_ALGORITHM,
							sender_key: this.olmDevice.deviceCurve25519Key
						},
						n = this.splitDevices(t);
					for (let o = 0; o < n.length; o++) try {
						await this.sendBlockedNotificationsToDevices(e, n[o], i), s.logger.log(`Completed blacklist notification for ${e.sessionId} ` + `in ${this.roomId} (slice ${o+1}/${n.length})`)
					} catch (r) {
						throw s.logger.log(`blacklist notification for ${e.sessionId} in ` + `${this.roomId} (slice ${o+1}/${n.length}) failed`), r
					}
				}
				prepareToEncrypt(e) {
					if (null == this.encryptionPreparation) s.logger.debug(`Preparing to encrypt events for ${this.roomId}`), this.encryptionPreparation = {
						startTime: Date.now(),
						promise: (async () => {
							try {
								s.logger.debug(`Getting devices in ${this.roomId}`);
								const [t, i] = await this.getDevicesInRoom(e);
								this.crypto.globalErrorOnUnknownDevices && this.removeUnknownDevices(t), s.logger.debug(`Ensuring outbound session in ${this.roomId}`), await this.ensureOutboundSession(e, t, i, !0), s.logger.debug(`Ready to encrypt events for ${this.roomId}`)
							} catch (t) {
								s.logger.error(`Failed to prepare to encrypt events for ${this.roomId}`, t)
							} finally {
								delete this.encryptionPreparation
							}
						})()
					};
					else {
						const e = Date.now() - this.encryptionPreparation.startTime;
						s.logger.debug(`Already started preparing to encrypt for ${this.roomId} ` + `${e} ms ago, skipping`)
					}
				}
				async encryptMessage(e, t, i) {
					if (s.logger.log(`Starting to encrypt event for ${this.roomId}`), null != this.encryptionPreparation) try {
						await this.encryptionPreparation.promise
					} catch (h) {}
					const n = this.isVerificationEvent(t, i),
						[r, a] = await this.getDevicesInRoom(e, n);
					this.crypto.globalErrorOnUnknownDevices && this.checkForUnknownDevices(r);
					const d = await this.ensureOutboundSession(e, r, a),
						l = {
							room_id: this.roomId,
							type: t,
							content: i
						},
						c = this.olmDevice.encryptGroupMessage(d.sessionId, JSON.stringify(l)),
						u = {
							algorithm: o.MEGOLM_ALGORITHM,
							sender_key: this.olmDevice.deviceCurve25519Key,
							ciphertext: c,
							session_id: d.sessionId,
							device_id: this.deviceId
						};
					return d.useCount++, u
				}
				isVerificationEvent(e, t) {
					switch (e) {
						case l.EventType.KeyVerificationCancel:
						case l.EventType.KeyVerificationDone:
						case l.EventType.KeyVerificationMac:
						case l.EventType.KeyVerificationStart:
						case l.EventType.KeyVerificationKey:
						case l.EventType.KeyVerificationReady:
						case l.EventType.KeyVerificationAccept:
							return !0;
						case l.EventType.RoomMessage:
							return t.msgtype === l.MsgType.KeyVerificationRequest;
						default:
							return !1
					}
				}
				forceDiscardSession() {
					this.setupPromise = this.setupPromise.then(() => null)
				}
				checkForUnknownDevices(e) {
					const t = {};
					if (Object.keys(e).forEach(i => {
							Object.keys(e[i]).forEach(n => {
								const r = e[i][n];
								r.isUnverified() && !r.isKnown() && (t[i] || (t[i] = {}), t[i][n] = r)
							})
						}), Object.keys(t).length) throw new a.UnknownDeviceError("This room contains unknown devices which have not been verified. We strongly recommend you verify them before continuing.", t)
				}
				removeUnknownDevices(e) {
					for (const [t, i] of Object.entries(e)) {
						for (const [e, t] of Object.entries(i)) t.isUnverified() && !t.isKnown() && delete i[e];
						0 === Object.keys(i).length && delete e[t]
					}
				}
				async getDevicesInRoom(e, t = !1) {
					const i = (await e.getEncryptionTargetMembers()).map((function(e) {
						return e.userId
					}));
					let n = this.crypto.globalBlacklistUnverifiedDevices;
					const r = e.getBlacklistUnverifiedDevices();
					"boolean" == typeof r && (n = r);
					const s = await this.crypto.downloadKeys(i, !1),
						o = {};
					for (const a in s) {
						if (!s.hasOwnProperty(a)) continue;
						const e = s[a];
						for (const i in e) {
							if (!e.hasOwnProperty(i)) continue;
							const r = this.crypto.checkDeviceTrust(a, i);
							if (e[i].isBlocked() || !r.isVerified() && n && !t) {
								o[a] || (o[a] = {});
								const t = e[i].isBlocked();
								o[a][i] = {
									code: t ? "m.blacklisted" : "m.unverified",
									reason: d.WITHHELD_MESSAGES[t ? "m.blacklisted" : "m.unverified"],
									deviceInfo: e[i]
								}, delete e[i]
							}
						}
					}
					return [s, o]
				}
			}
			class g extends a.DecryptionAlgorithm {
				constructor(e) {
					super(e), (0, r.default)(this, "pendingEvents", new Map), (0, r.default)(this, "olmlib", o), (0, r.default)(this, "roomId", void 0), this.roomId = e.roomId
				}
				async decryptEvent(e) {
					const t = e.getWireContent();
					if (!t.sender_key || !t.session_id || !t.ciphertext) throw new a.DecryptionError("MEGOLM_MISSING_FIELDS", "Missing fields in input");
					let i;
					this.addEventToPendingList(e);
					try {
						i = await this.olmDevice.decryptGroupMessage(e.getRoomId(), t.sender_key, t.session_id, t.ciphertext, e.getId(), e.getTs())
					} catch (r) {
						if ("DecryptionError" === r.name) throw r;
						let i = "OLM_DECRYPT_GROUP_MESSAGE_ERROR";
						throw "OLM.UNKNOWN_MESSAGE_INDEX" === (null == r ? void 0 : r.message) && (this.requestKeysForEvent(e), i = "OLM_UNKNOWN_MESSAGE_INDEX"), new a.DecryptionError(i, r ? r.toString() : "Unknown Error: Error is undefined", {
							session: t.sender_key + "|" + t.session_id
						})
					}
					if (null === i) {
						this.crypto.backupManager.queryKeyBackupRateLimited(e.getRoomId(), t.session_id).catch(() => {}), this.requestKeysForEvent(e);
						const i = await this.olmDevice.sessionMayHaveProblems(t.sender_key, e.getTs() - 12e4);
						if (i) {
							let e = f[i.type] || f.unknown;
							throw i.fixed && (e += " Trying to create a new secure channel and re-requesting the keys."), new a.DecryptionError("MEGOLM_UNKNOWN_INBOUND_SESSION_ID", e, {
								session: t.sender_key + "|" + t.session_id
							})
						}
						throw new a.DecryptionError("MEGOLM_UNKNOWN_INBOUND_SESSION_ID", "The sender's device has not sent us the keys for this message.", {
							session: t.sender_key + "|" + t.session_id
						})
					}
					i.untrusted || this.removeEventFromPendingList(e);
					const n = JSON.parse(i.result);
					if (n.room_id !== e.getRoomId()) throw new a.DecryptionError("MEGOLM_BAD_ROOM", "Message intended for room " + n.room_id);
					return {
						clearEvent: n,
						senderCurve25519Key: i.senderKey,
						claimedEd25519Key: i.keysClaimed.ed25519,
						forwardingCurve25519KeyChain: i.forwardingCurve25519KeyChain,
						untrusted: i.untrusted
					}
				}
				requestKeysForEvent(e) {
					const t = e.getWireContent(),
						i = e.getKeyRequestRecipients(this.userId);
					this.crypto.requestRoomKey({
						room_id: e.getRoomId(),
						algorithm: t.algorithm,
						sender_key: t.sender_key,
						session_id: t.session_id
					}, i)
				}
				addEventToPendingList(e) {
					var t;
					const i = e.getWireContent(),
						n = i.sender_key,
						r = i.session_id;
					this.pendingEvents.has(n) || this.pendingEvents.set(n, new Map);
					const s = this.pendingEvents.get(n);
					s.has(r) || s.set(r, new Set), null === (t = s.get(r)) || void 0 === t || t.add(e)
				}
				removeEventFromPendingList(e) {
					const t = e.getWireContent(),
						i = t.sender_key,
						n = t.session_id,
						r = this.pendingEvents.get(i),
						s = null == r ? void 0 : r.get(n);
					s && (s.delete(e), 0 === s.size && r.delete(n), 0 === r.size && this.pendingEvents.delete(i))
				}
				async onRoomKeyEvent(e) {
					const t = e.getContent();
					let i, n = e.getSenderKey(),
						r = [],
						a = !1;
					const d = {};
					if (t.room_id && t.session_key && t.session_id && t.algorithm)
						if (o.isOlmEncrypted(e)) {
							if (t["org.matrix.msc3061.shared_history"] && (d.sharedHistory = !0), "m.forwarded_room_key" == e.getType()) {
								var l, u, h, m;
								const p = this.crypto.deviceList.getDeviceByIdentityKey(o.OLM_ALGORITHM, n);
								if (this.baseApis.crypto.deviceList.getUserByIdentityKey(o.OLM_ALGORITHM, n) !== e.getSender()) return void s.logger.error("sending device does not belong to the user it claims to be from");
								const g = (p ? await this.crypto.cryptoStore.getOutgoingRoomKeyRequestsByTarget(e.getSender(), p.deviceId, [c.RoomKeyRequestState.Sent]) : []).some(e => e.requestBody.room_id === t.room_id && e.requestBody.session_id === t.session_id),
									f = this.baseApis.getRoom(t.room_id),
									v = null == f ? void 0 : null === (l = f.getMember(this.userId)) || void 0 === l ? void 0 : l.events.member,
									y = (null == v ? void 0 : v.getSender()) === e.getSender() || (null == v ? void 0 : null === (u = v.getUnsigned()) || void 0 === u ? void 0 : u.prev_sender) === e.getSender() && "invite" === (null == v ? void 0 : null === (h = v.getPrevContent()) || void 0 === h ? void 0 : h.membership),
									b = e.getSender() === this.baseApis.getUserId();
								if (!g && !b) {
									if (!d.sharedHistory) return void s.logger.log("forwarded key not shared history - ignoring");
									if (f && !y) return void s.logger.log("forwarded key not from inviter or from us - ignoring")
								}
								if (a = !0, (r = (r = Array.isArray(t.forwarding_curve25519_key_chain) ? t.forwarding_curve25519_key_chain : []).slice()).push(n), !t.sender_key) return void s.logger.error("forwarded_room_key event is missing sender_key field");
								const _ = t.sender_claimed_ed25519_key;
								if (!_) return void s.logger.error("forwarded_room_key_event is missing sender_claimed_ed25519_key field");
								if (i = {
										ed25519: _
									}, !f) {
									const n = {
										senderId: e.getSender(),
										senderKey: t.sender_key,
										sessionId: t.session_id,
										sessionKey: t.session_key,
										keysClaimed: i,
										forwardingCurve25519KeyChain: r
									};
									return void(await this.crypto.cryptoStore.doTxn("readwrite", ["parked_shared_history"], e => this.crypto.cryptoStore.addParkedSharedHistory(t.room_id, n, e), s.logger.withPrefix("[addParkedSharedHistory]")))
								}
								const S = null !== (m = this.crypto.deviceList.getDeviceByIdentityKey(o.OLM_ALGORITHM, n)) && void 0 !== m ? m : void 0,
									E = this.crypto.checkDeviceInfoTrust(e.getSender(), S);
								if (b && !E.isVerified()) return;
								d.untrusted = !0, n = t.sender_key
							} else i = e.getKeysClaimed();
							t["org.matrix.msc3061.shared_history"] && (d.sharedHistory = !0);
							try {
								await this.olmDevice.addInboundGroupSession(t.room_id, n, r, t.session_id, t.session_key, i, a, d), await this.retryDecryption(n, t.session_id, !d.untrusted) && this.crypto.cancelRoomKeyRequest({
									algorithm: t.algorithm,
									room_id: t.room_id,
									session_id: t.session_id,
									sender_key: n
								}), await this.crypto.backupManager.backupGroupSession(n, t.session_id)
							} catch (p) {
								s.logger.error(`Error handling m.room_key_event: ${p}`)
							}
						} else s.logger.error("key event not properly encrypted");
					else s.logger.error("key event is missing fields")
				}
				async onRoomKeyWithheldEvent(e) {
					const t = e.getContent(),
						i = t.sender_key;
					if ("m.no_olm" === t.code) {
						const n = e.getSender();
						if (s.logger.warn(`${n}:${i} was unable to establish an olm session with us`), await this.olmDevice.getSessionIdForDevice(i)) return s.logger.debug("New session already created.  Not creating a new one."), await this.olmDevice.recordSessionProblem(i, "no_olm", !0), void this.retryDecryptionFromSender(i);
						let r = this.crypto.deviceList.getDeviceByIdentityKey(t.algorithm, i);
						if (!(r || (await this.crypto.downloadKeys([n], !1), r = this.crypto.deviceList.getDeviceByIdentityKey(t.algorithm, i)))) return s.logger.info("Couldn't find device for identity key " + i + ": not establishing session"), await this.olmDevice.recordSessionProblem(i, "no_olm", !1), void this.retryDecryptionFromSender(i);
						await o.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, {
							[n]: [r]
						}, !1);
						const a = {
							algorithm: o.OLM_ALGORITHM,
							sender_key: this.olmDevice.deviceCurve25519Key,
							ciphertext: {}
						};
						await o.encryptMessageForDevice(a.ciphertext, this.userId, void 0, this.olmDevice, n, r, {
							type: "m.dummy"
						}), await this.olmDevice.recordSessionProblem(i, "no_olm", !0), this.retryDecryptionFromSender(i), await this.baseApis.sendToDevice("m.room.encrypted", {
							[n]: {
								[r.deviceId]: a
							}
						})
					} else await this.olmDevice.addInboundGroupSessionWithheld(t.room_id, i, t.session_id, t.code, t.reason)
				}
				hasKeysForKeyRequest(e) {
					const t = e.requestBody;
					return this.olmDevice.hasInboundSessionKeys(t.room_id, t.sender_key, t.session_id)
				}
				shareKeysWithDevice(e) {
					const t = e.userId,
						i = e.deviceId,
						n = this.crypto.getStoredDevice(t, i),
						r = e.requestBody;
					this.olmlib.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, {
						[t]: [n]
					}).then(e => {
						return e[t][i].sessionId ? (s.logger.log("sharing keys for session " + r.sender_key + "|" + r.session_id + " with device " + t + ":" + i), this.buildKeyForwardingMessage(r.room_id, r.sender_key, r.session_id)) : null
					}).then(e => {
						const r = {
							algorithm: o.OLM_ALGORITHM,
							sender_key: this.olmDevice.deviceCurve25519Key,
							ciphertext: {}
						};
						return this.olmlib.encryptMessageForDevice(r.ciphertext, this.userId, void 0, this.olmDevice, t, n, e).then(() => {
							const e = {
								[t]: {
									[i]: r
								}
							};
							return this.baseApis.sendToDevice("m.room.encrypted", e)
						})
					})
				}
				async buildKeyForwardingMessage(e, t, i) {
					const n = await this.olmDevice.getInboundGroupSessionKey(e, t, i);
					return {
						type: "m.forwarded_room_key",
						content: {
							algorithm: o.MEGOLM_ALGORITHM,
							room_id: e,
							sender_key: t,
							sender_claimed_ed25519_key: n.sender_claimed_ed25519_key,
							session_id: i,
							session_key: n.key,
							chain_index: n.chain_index,
							forwarding_curve25519_key_chain: n.forwarding_curve25519_key_chain,
							"org.matrix.msc3061.shared_history": n.shared_history || !1
						}
					}
				}
				importRoomKey(e, t = {}) {
					const i = {};
					return (t.untrusted || e.untrusted) && (i.untrusted = !0), e["org.matrix.msc3061.shared_history"] && (i.sharedHistory = !0), this.olmDevice.addInboundGroupSession(e.room_id, e.sender_key, e.forwarding_curve25519_key_chain, e.session_id, e.session_key, e.sender_claimed_keys, !0, i).then(() => {
						"backup" !== t.source && this.crypto.backupManager.backupGroupSession(e.sender_key, e.session_id).catch(e => {
							s.logger.log("Failed to back up megolm session", e)
						}), this.retryDecryption(e.sender_key, e.session_id, !i.untrusted)
					})
				}
				async retryDecryption(e, t, i) {
					var n;
					const r = this.pendingEvents.get(e);
					if (!r) return !0;
					const o = r.get(t);
					return !o || (s.logger.debug("Retrying decryption on events", [...o]), await Promise.all([...o].map(async e => {
						try {
							await e.attemptDecryption(this.crypto, {
								isRetry: !0,
								forceRedecryptIfUntrusted: i
							})
						} catch (t) {}
					})), !(null !== (n = this.pendingEvents.get(e)) && void 0 !== n && n.has(t)))
				}
				async retryDecryptionFromSender(e) {
					const t = this.pendingEvents.get(e);
					return !t || (this.pendingEvents.delete(e), await Promise.all([...t].map(async ([e, t]) => {
						await Promise.all([...t].map(async e => {
							try {
								await e.attemptDecryption(this.crypto)
							} catch (t) {}
						}))
					})), !this.pendingEvents.has(e))
				}
				async sendSharedHistoryInboundSessions(e) {
					await o.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, e), s.logger.log("sendSharedHistoryInboundSessions to users", Object.keys(e));
					const t = await this.olmDevice.getSharedHistoryInboundGroupSessions(this.roomId);
					s.logger.log("shared-history sessions", t);
					for (const [i, n] of t) {
						const t = await this.buildKeyForwardingMessage(this.roomId, i, n),
							r = [],
							a = {};
						for (const [i, n] of Object.entries(e)) {
							a[i] = {};
							for (const e of n) {
								const n = {
									algorithm: o.OLM_ALGORITHM,
									sender_key: this.olmDevice.deviceCurve25519Key,
									ciphertext: {}
								};
								a[i][e.deviceId] = n, r.push(o.encryptMessageForDevice(n.ciphertext, this.userId, void 0, this.olmDevice, i, e, t))
							}
						}
						await Promise.all(r);
						for (const e of Object.keys(a)) {
							for (const t of Object.keys(a[e])) 0 === Object.keys(a[e][t].ciphertext).length && (s.logger.log("No ciphertext for device " + e + ":" + t + ": pruning"), delete a[e][t]);
							0 === Object.keys(a[e]).length && (s.logger.log("Pruned all devices for user " + e), delete a[e])
						}
						if (0 === Object.keys(a).length) return void s.logger.log("No users left to send to: aborting");
						await this.baseApis.sendToDevice("m.room.encrypted", a)
					}
				}
			}
			const f = {
				no_olm: "The sender was unable to establish a secure channel.",
				unknown: "The secure channel with the sender was corrupted."
			};
			(0, a.registerAlgorithm)(o.MEGOLM_ALGORITHM, p, g)
		},
		"./node_modules/matrix-js-sdk/lib/crypto/algorithms/olm.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js")(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				r = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				s = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = d(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/crypto/olmlib.js")),
				o = i("./node_modules/matrix-js-sdk/lib/crypto/deviceinfo.js"),
				a = i("./node_modules/matrix-js-sdk/lib/crypto/algorithms/base.js");

			function d(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (d = function(e) {
					return e ? i : t
				})(e)
			}
			const l = o.DeviceInfo.DeviceVerification;
			class c extends a.EncryptionAlgorithm {
				constructor(...e) {
					super(...e), (0, n.default)(this, "sessionPrepared", !1), (0, n.default)(this, "prepPromise", null)
				}
				ensureSession(e) {
					return this.prepPromise ? this.prepPromise : this.sessionPrepared ? Promise.resolve() : (this.prepPromise = this.crypto.downloadKeys(e).then(() => this.crypto.ensureOlmSessionsForUsers(e)).then(() => {
						this.sessionPrepared = !0
					}).finally(() => {
						this.prepPromise = null
					}), this.prepPromise)
				}
				async encryptMessage(e, t, i) {
					const n = (await e.getEncryptionTargetMembers()).map((function(e) {
						return e.userId
					}));
					await this.ensureSession(n);
					const r = {
							room_id: e.roomId,
							type: t,
							content: i
						},
						o = {
							algorithm: s.OLM_ALGORITHM,
							sender_key: this.olmDevice.deviceCurve25519Key,
							ciphertext: {}
						},
						a = [];
					for (const d of n) {
						const e = this.crypto.getStoredDevicesForUser(d) || [];
						for (const t of e) {
							t.getIdentityKey() != this.olmDevice.deviceCurve25519Key && (t.verified != l.BLOCKED && a.push(s.encryptMessageForDevice(o.ciphertext, this.userId, this.deviceId, this.olmDevice, d, t, r)))
						}
					}
					return Promise.all(a).then(() => o)
				}
			}
			class u extends a.DecryptionAlgorithm {
				async decryptEvent(e) {
					const t = e.getWireContent(),
						i = t.sender_key,
						n = t.ciphertext;
					if (!n) throw new a.DecryptionError("OLM_MISSING_CIPHERTEXT", "Missing ciphertext");
					if (!(this.olmDevice.deviceCurve25519Key in n)) throw new a.DecryptionError("OLM_NOT_INCLUDED_IN_RECIPIENTS", "Not included in recipients");
					const r = n[this.olmDevice.deviceCurve25519Key];
					let o;
					try {
						o = await this.decryptMessage(i, r)
					} catch (c) {
						throw new a.DecryptionError("OLM_BAD_ENCRYPTED_MESSAGE", "Bad Encrypted Message", {
							sender: i,
							err: c
						})
					}
					const d = JSON.parse(o);
					if (d.recipient != this.userId) throw new a.DecryptionError("OLM_BAD_RECIPIENT", "Message was intented for " + d.recipient);
					if (d.recipient_keys.ed25519 != this.olmDevice.deviceEd25519Key) throw new a.DecryptionError("OLM_BAD_RECIPIENT_KEY", "Message not intended for this device", {
						intended: d.recipient_keys.ed25519,
						our_key: this.olmDevice.deviceEd25519Key
					});
					await this.crypto.deviceList.downloadKeys([e.getSender()], !1);
					const l = this.crypto.deviceList.getUserByIdentityKey(s.OLM_ALGORITHM, i);
					if (l !== e.getSender() && null != l) throw new a.DecryptionError("OLM_BAD_SENDER", "Message claimed to be from " + e.getSender(), {
						real_sender: l
					});
					if (d.sender != e.getSender()) throw new a.DecryptionError("OLM_FORWARDED_MESSAGE", "Message forwarded from " + d.sender, {
						reported_sender: e.getSender()
					});
					if (d.room_id !== e.getRoomId()) throw new a.DecryptionError("OLM_BAD_ROOM", "Message intended for room " + d.room_id, {
						reported_room: e.getRoomId() || "ROOM_ID_UNDEFINED"
					});
					return {
						clearEvent: d,
						senderCurve25519Key: i,
						claimedEd25519Key: (d.keys || {}).ed25519 || null
					}
				}
				decryptMessage(e, t) {
					if (0 !== t.type) return this.reallyDecryptMessage(e, t); {
						const i = this.olmDevice.olmPrekeyPromise.then(() => this.reallyDecryptMessage(e, t));
						return this.olmDevice.olmPrekeyPromise = i.catch(() => {}), i
					}
				}
				async reallyDecryptMessage(e, t) {
					const i = await this.olmDevice.getSessionIdsForDevice(e),
						n = {};
					for (const a of i) try {
						const i = await this.olmDevice.decryptMessage(e, a, t.type, t.body);
						return r.logger.log("Decrypted Olm message from " + e + " with session " + a), i
					} catch (o) {
						if (await this.olmDevice.matchesSession(e, a, t.type, t.body)) throw new Error("Error decrypting prekey message with existing session id " + a + ": " + o.message);
						n[a] = o.message
					}
					if (0 !== t.type) {
						if (0 === i.length) throw new Error("No existing sessions");
						throw new Error("Error decrypting non-prekey message with existing sessions: " + JSON.stringify(n))
					}
					let s;
					try {
						s = await this.olmDevice.createInboundSession(e, t.type, t.body)
					} catch (o) {
						throw n["(new)"] = o.message, new Error("Error decrypting prekey message: " + JSON.stringify(n))
					}
					return r.logger.log("created new inbound Olm session ID " + s.session_id + " with " + e), s.payload
				}
			}(0, a.registerAlgorithm)(s.OLM_ALGORITHM, c, u)
		},
		"./node_modules/matrix-js-sdk/lib/crypto/api.js": function(e, t, i) {
			"use strict";
			let n;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.CrossSigningKey = void 0, t.CrossSigningKey = n,
				function(e) {
					e.Master = "master", e.SelfSigning = "self_signing", e.UserSigning = "user_signing"
				}(n || (t.CrossSigningKey = n = {}))
		},
		"./node_modules/matrix-js-sdk/lib/crypto/backup.js": function(e, t, i) {
			"use strict";
			(function(e) {
				var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.algorithmsByName = t.DefaultAlgorithm = t.Curve25519 = t.BackupManager = t.Aes256 = void 0;
				var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
					s = i("./node_modules/matrix-js-sdk/lib/client.js"),
					o = i("./node_modules/matrix-js-sdk/lib/logger.js"),
					a = i("./node_modules/matrix-js-sdk/lib/crypto/olmlib.js"),
					d = i("./node_modules/matrix-js-sdk/lib/crypto/key_passphrase.js"),
					l = i("./node_modules/matrix-js-sdk/lib/utils.js"),
					c = i("./node_modules/matrix-js-sdk/lib/crypto/store/indexeddb-crypto-store.js"),
					u = i("./node_modules/matrix-js-sdk/lib/crypto/recoverykey.js"),
					h = i("./node_modules/matrix-js-sdk/lib/crypto/aes.js"),
					m = i("./node_modules/matrix-js-sdk/lib/NamespacedValue.js"),
					p = i("./node_modules/matrix-js-sdk/lib/crypto/index.js"),
					g = i("./node_modules/matrix-js-sdk/lib/crypto/crypto.js"),
					f = i("./node_modules/matrix-js-sdk/lib/http-api/index.js");
				const v = 200,
					y = 5e3;
				class b {
					constructor(e, t) {
						this.baseApis = e, this.getKey = t, (0, r.default)(this, "algorithm", void 0), (0, r.default)(this, "backupInfo", void 0), (0, r.default)(this, "checkedForBackup", void 0), (0, r.default)(this, "sendingBackups", void 0), (0, r.default)(this, "sessionLastCheckAttemptedTime", {}), this.checkedForBackup = !1, this.sendingBackups = !1
					}
					get version() {
						return this.backupInfo && this.backupInfo.version
					}
					static checkBackupVersion(e) {
						const t = w[e.algorithm];
						if (!t) throw new Error("Unknown backup algorithm: " + e.algorithm);
						if ("object" != typeof e.auth_data) throw new Error("Invalid backup data returned");
						return t.checkBackupVersion(e)
					}
					static makeAlgorithm(e, t) {
						const i = w[e.algorithm];
						if (!i) throw new Error("Unknown backup algorithm");
						return i.init(e.auth_data, t)
					}
					async enableKeyBackup(e) {
						this.backupInfo = e, this.algorithm && this.algorithm.free(), this.algorithm = await b.makeAlgorithm(e, this.getKey), this.baseApis.emit(p.CryptoEvent.KeyBackupStatus, !0), this.scheduleKeyBackupSend()
					}
					disableKeyBackup() {
						this.algorithm && this.algorithm.free(), this.algorithm = void 0, this.backupInfo = void 0, this.baseApis.emit(p.CryptoEvent.KeyBackupStatus, !1)
					}
					getKeyBackupEnabled() {
						return this.checkedForBackup ? Boolean(this.algorithm) : null
					}
					async prepareKeyBackupVersion(e, t) {
						const i = t ? w[t] : k;
						if (!i) throw new Error("Unknown backup algorithm");
						const [n, r] = await i.prepare(e), s = (0, u.encodeRecoveryKey)(n);
						return {
							algorithm: i.algorithmName,
							auth_data: r,
							recovery_key: s,
							privateKey: n
						}
					}
					async createKeyBackupVersion(e) {
						this.algorithm = await b.makeAlgorithm(e, this.getKey)
					}
					async checkAndStart() {
						if (o.logger.log("Checking key backup status..."), this.baseApis.isGuest()) return o.logger.log("Skipping key backup check since user is guest"), this.checkedForBackup = !0, null;
						let e;
						try {
							var t;
							e = null !== (t = await this.baseApis.getKeyBackupVersion()) && void 0 !== t ? t : void 0
						} catch (n) {
							return o.logger.log("Error checking for active key backup", n), 404 === n.httpStatus && (this.checkedForBackup = !0), null
						}
						this.checkedForBackup = !0;
						const i = await this.isKeyBackupTrusted(e);
						return i.usable && !this.backupInfo ? (o.logger.log(`Found usable key backup v${e.version}: enabling key backups`), await this.enableKeyBackup(e)) : !i.usable && this.backupInfo ? (o.logger.log("No usable key backup: disabling key backup"), this.disableKeyBackup()) : i.usable || this.backupInfo ? i.usable && this.backupInfo && (e.version !== this.backupInfo.version ? (o.logger.log(`On backup version ${this.backupInfo.version} but ` + `found version ${e.version}: switching.`), this.disableKeyBackup(), await this.enableKeyBackup(e), await this.scheduleAllGroupSessionsForBackup()) : o.logger.log(`Backup version ${e.version} still current`)) : o.logger.log("No usable key backup: not enabling key backup"), {
							backupInfo: e,
							trustInfo: i
						}
					}
					async checkKeyBackup() {
						return this.checkedForBackup = !1, this.checkAndStart()
					}
					async queryKeyBackupRateLimited(e, t) {
						if (!this.backupInfo) return;
						const i = (new Date).getTime();
						(!this.sessionLastCheckAttemptedTime[t] || i - this.sessionLastCheckAttemptedTime[t] > y) && (this.sessionLastCheckAttemptedTime[t] = i, await this.baseApis.restoreKeyBackupWithCache(e, t, this.backupInfo, {}))
					}
					async isKeyBackupTrusted(e) {
						const t = {
							usable: !1,
							trusted_locally: !1,
							sigs: []
						};
						if (!(e && e.algorithm && e.auth_data && e.auth_data.signatures)) return o.logger.info("Key backup is absent or missing required data"), t;
						const i = this.baseApis.getUserId(),
							n = await this.baseApis.crypto.getSessionBackupPrivateKey();
						if (n) {
							let i = null;
							try {
								i = await b.makeAlgorithm(e, async () => n), await i.keyMatches(n) && (o.logger.info("Backup is trusted locally"), t.trusted_locally = !0)
							} catch {} finally {
								var r;
								null === (r = i) || void 0 === r || r.free()
							}
						}
						const s = e.auth_data.signatures[i] || {};
						for (const l of Object.keys(s)) {
							const n = l.split(":");
							if ("ed25519" !== n[0]) {
								o.logger.log("Ignoring unknown signature type: " + n[0]);
								continue
							}
							const r = {
									deviceId: n[1]
								},
								s = this.baseApis.crypto.crossSigningInfo.getId();
							if (s === r.deviceId) {
								r.crossSigningId = !0;
								try {
									await (0, a.verifySignature)(this.baseApis.crypto.olmDevice, e.auth_data, i, r.deviceId, s), r.valid = !0
								} catch (d) {
									o.logger.warn("Bad signature from cross signing key " + s, d), r.valid = !1
								}
								t.sigs.push(r);
								continue
							}
							const c = this.baseApis.crypto.deviceList.getStoredDevice(i, r.deviceId);
							if (c) {
								r.device = c, r.deviceTrust = this.baseApis.checkDeviceTrust(i, r.deviceId);
								try {
									await (0, a.verifySignature)(this.baseApis.crypto.olmDevice, e.auth_data, i, c.deviceId, c.getFingerprint()), r.valid = !0
								} catch (d) {
									o.logger.info("Bad signature from key ID " + l + " userID " + this.baseApis.getUserId() + " device ID " + c.deviceId + " fingerprint: " + c.getFingerprint(), e.auth_data, d), r.valid = !1
								}
							} else r.valid = null, o.logger.info("Ignoring signature from unknown key " + l);
							t.sigs.push(r)
						}
						return t.usable = t.sigs.some(e => {
							var t;
							return e.valid && (e.device && (null === (t = e.deviceTrust) || void 0 === t ? void 0 : t.isVerified()) || e.crossSigningId)
						}), t
					}
					async scheduleKeyBackupSend(e = 1e4) {
						if (!this.sendingBackups) {
							this.sendingBackups = !0;
							try {
								const i = Math.random() * e;
								await (0, l.sleep)(i);
								let n = 0;
								for (;;) {
									if (!this.algorithm) return;
									try {
										if (0 === await this.backupPendingKeys(v)) return;
										n = 0
									} catch (t) {
										if (n++, o.logger.log("Key backup request failed", t), t.data && ("M_NOT_FOUND" == t.data.errcode || "M_WRONG_ROOM_KEYS_VERSION" == t.data.errcode)) throw await this.checkKeyBackup(), this.baseApis.crypto.emit(p.CryptoEvent.KeyBackupFailed, t.data.errcode), t
									}
									n && await (0, l.sleep)(1e3 * Math.pow(2, Math.min(n - 1, 4)))
								}
							} finally {
								this.sendingBackups = !1
							}
						}
					}
					async backupPendingKeys(e) {
						const t = await this.baseApis.crypto.cryptoStore.getSessionsNeedingBackup(e);
						if (!t.length) return 0;
						let i = await this.baseApis.crypto.cryptoStore.countSessionsNeedingBackup();
						this.baseApis.crypto.emit(p.CryptoEvent.KeyBackupSessionsRemaining, i);
						const n = {};
						for (const s of t) {
							var r;
							const e = s.sessionData.room_id;
							void 0 === n[e] && (n[e] = {
								sessions: {}
							});
							const t = this.baseApis.crypto.olmDevice.exportInboundGroupSession(s.senderKey, s.sessionId, s.sessionData);
							t.algorithm = a.MEGOLM_ALGORITHM;
							const i = (t.forwarding_curve25519_key_chain || []).length,
								o = this.baseApis.crypto.deviceList.getUserByIdentityKey(a.MEGOLM_ALGORITHM, s.senderKey),
								d = null !== (r = this.baseApis.crypto.deviceList.getDeviceByIdentityKey(a.MEGOLM_ALGORITHM, s.senderKey)) && void 0 !== r ? r : void 0,
								l = this.baseApis.crypto.checkDeviceInfoTrust(o, d).isVerified();
							n[e].sessions[s.sessionId] = {
								first_message_index: t.first_known_index,
								forwarded_count: i,
								is_verified: l,
								session_data: await this.algorithm.encryptSession(t)
							}
						}
						return await this.baseApis.sendKeyBackup(void 0, void 0, this.backupInfo.version, {
							rooms: n
						}), await this.baseApis.crypto.cryptoStore.unmarkSessionsNeedingBackup(t), i = await this.baseApis.crypto.cryptoStore.countSessionsNeedingBackup(), this.baseApis.crypto.emit(p.CryptoEvent.KeyBackupSessionsRemaining, i), t.length
					}
					async backupGroupSession(e, t) {
						await this.baseApis.crypto.cryptoStore.markSessionsNeedingBackup([{
							senderKey: e,
							sessionId: t
						}]), this.backupInfo && this.scheduleKeyBackupSend()
					}
					async scheduleAllGroupSessionsForBackup() {
						await this.flagAllGroupSessionsForBackup(), this.scheduleKeyBackupSend(0)
					}
					async flagAllGroupSessionsForBackup() {
						await this.baseApis.crypto.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, c.IndexedDBCryptoStore.STORE_BACKUP], e => {
							this.baseApis.crypto.cryptoStore.getAllEndToEndInboundGroupSessions(e, t => {
								null !== t && this.baseApis.crypto.cryptoStore.markSessionsNeedingBackup([t], e)
							})
						});
						const e = await this.baseApis.crypto.cryptoStore.countSessionsNeedingBackup();
						return this.baseApis.emit(p.CryptoEvent.KeyBackupSessionsRemaining, e), e
					}
					countSessionsNeedingBackup() {
						return this.baseApis.crypto.cryptoStore.countSessionsNeedingBackup()
					}
				}
				t.BackupManager = b;
				class _ {
					constructor(e, t, i) {
						this.authData = e, this.publicKey = t, this.getKey = i
					}
					static async init(t, i) {
						if (!(t && "public_key" in t)) throw new Error("auth_data missing required information");
						const n = new e.Olm.PkEncryption;
						return n.set_recipient_key(t.public_key), new _(t, n, i)
					}
					static async prepare(t) {
						const i = new e.Olm.PkDecryption;
						try {
							const n = {};
							if (t)
								if (t instanceof Uint8Array) n.public_key = i.init_with_private_key(t);
								else {
									const e = await (0, d.keyFromPassphrase)(t);
									n.private_key_salt = e.salt, n.private_key_iterations = e.iterations, n.public_key = i.init_with_private_key(e.key)
								}
							else n.public_key = i.generate_key();
							return (new e.Olm.PkEncryption).set_recipient_key(n.public_key), [i.get_private_key(), n]
						} finally {
							i.free()
						}
					}
					static checkBackupVersion(e) {
						if (!("public_key" in e.auth_data)) throw new Error("Invalid backup data returned")
					}
					get untrusted() {
						return !0
					}
					async encryptSession(e) {
						const t = Object.assign({}, e);
						return delete t.session_id, delete t.room_id, delete t.first_known_index, this.publicKey.encrypt(JSON.stringify(t))
					}
					async decryptSessions(t) {
						const i = await this.getKey(),
							n = new e.Olm.PkDecryption;
						try {
							if (n.init_with_private_key(i) !== this.authData.public_key) throw new f.MatrixError({
								errcode: s.MatrixClient.RESTORE_BACKUP_ERROR_BAD_KEY
							});
							const e = [];
							for (const [i, s] of Object.entries(t)) try {
								const t = JSON.parse(n.decrypt(s.session_data.ephemeral, s.session_data.mac, s.session_data.ciphertext));
								t.session_id = i, e.push(t)
							} catch (r) {
								o.logger.log("Failed to decrypt megolm session from backup", r, s)
							}
							return e
						} finally {
							n.free()
						}
					}
					async keyMatches(t) {
						const i = new e.Olm.PkDecryption;
						let n;
						try {
							n = i.init_with_private_key(t)
						} finally {
							i.free()
						}
						return n === this.authData.public_key
					}
					free() {
						this.publicKey.free()
					}
				}
				t.Curve25519 = _, (0, r.default)(_, "algorithmName", "m.megolm_backup.v1.curve25519-aes-sha2");
				const S = new m.UnstableValue("m.megolm_backup.v1.aes-hmac-sha2", "org.matrix.msc3270.v1.aes-hmac-sha2");
				class E {
					constructor(e, t) {
						this.authData = e, this.key = t
					}
					static async init(e, t) {
						if (!e) throw new Error("auth_data missing");
						const i = await t();
						if (e.mac) {
							const {
								mac: t
							} = await (0, h.calculateKeyCheck)(i, e.iv);
							if (e.mac.replace(/=+$/g, "") !== t.replace(/=+/g, "")) throw new Error("Key does not match")
						}
						return new E(e, i)
					}
					static async prepare(e) {
						let t;
						const i = {};
						if (e)
							if (e instanceof Uint8Array) t = new Uint8Array(e);
							else {
								const n = await (0, d.keyFromPassphrase)(e);
								i.private_key_salt = n.salt, i.private_key_iterations = n.iterations, t = n.key
							}
						else t = function(e) {
							const t = new Uint8Array(e);
							return g.crypto.getRandomValues(t), t
						}(32);
						const {
							iv: n,
							mac: r
						} = await (0, h.calculateKeyCheck)(t);
						return i.iv = n, i.mac = r, [t, i]
					}
					static checkBackupVersion(e) {
						if (!("iv" in e.auth_data && "mac" in e.auth_data)) throw new Error("Invalid backup data returned")
					}
					get untrusted() {
						return !1
					}
					encryptSession(e) {
						const t = Object.assign({}, e);
						return delete t.session_id, delete t.room_id, delete t.first_known_index, (0, h.encryptAES)(JSON.stringify(t), this.key, e.session_id)
					}
					async decryptSessions(e) {
						const t = [];
						for (const [n, r] of Object.entries(e)) try {
							const e = JSON.parse(await (0, h.decryptAES)(r.session_data, this.key, n));
							e.session_id = n, t.push(e)
						} catch (i) {
							o.logger.log("Failed to decrypt megolm session from backup", i, r)
						}
						return t
					}
					async keyMatches(e) {
						if (this.authData.mac) {
							const {
								mac: t
							} = await (0, h.calculateKeyCheck)(e, this.authData.iv);
							return this.authData.mac.replace(/=+$/g, "") === t.replace(/=+/g, "")
						}
						return !0
					}
					free() {
						this.key.fill(0)
					}
				}
				t.Aes256 = E, (0, r.default)(E, "algorithmName", S.name);
				const w = {
					[_.algorithmName]: _,
					[E.algorithmName]: E
				};
				t.algorithmsByName = w;
				const k = _;
				t.DefaultAlgorithm = k
			}).call(this, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/crypto/crypto.js": function(e, t, i) {
			"use strict";
			(function(e) {
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.crypto = t.TextEncoder = void 0, t.setCrypto = function(e) {
					var i;
					t.crypto = u = e, t.subtleCrypto = h = null !== (i = e.subtle) && void 0 !== i ? i : e.webkitSubtle
				}, t.setTextEncoder = function(e) {
					t.TextEncoder = m = e
				}, t.subtleCrypto = void 0;
				var n, r, s, o, a, d, l, c = i("./node_modules/matrix-js-sdk/lib/logger.js");
				let u = null === (n = e.window) || void 0 === n ? void 0 : n.crypto;
				t.crypto = u;
				let h = null !== (r = null === (s = e.window) || void 0 === s ? void 0 : null === (o = s.crypto) || void 0 === o ? void 0 : o.subtle) && void 0 !== r ? r : null === (a = e.window) || void 0 === a ? void 0 : null === (d = a.crypto) || void 0 === d ? void 0 : d.webkitSubtle;
				t.subtleCrypto = h;
				let m = null === (l = e.window) || void 0 === l ? void 0 : l.TextEncoder;
				if (t.TextEncoder = m, !u) try {
					t.crypto = u = i("./node_modules/crypto-browserify/index.js").webcrypto
				} catch (g) {
					c.logger.error("Failed to load webcrypto", g)
				}
				var p;
				h || (t.subtleCrypto = h = null === (p = u) || void 0 === p ? void 0 : p.subtle);
				if (!m) try {
					t.TextEncoder = m = i("./node_modules/util/util.js").TextEncoder
				} catch (g) {
					c.logger.error("Failed to load TextEncoder util", g)
				}
			}).call(this, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/crypto/dehydration.js": function(e, t, i) {
			"use strict";
			(function(e, n) {
				var r = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.DehydrationManager = t.DEHYDRATION_ALGORITHM = void 0;
				var s = r(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
					o = r(i("./node_modules/another-json/another-json.js")),
					a = i("./node_modules/matrix-js-sdk/lib/crypto/olmlib.js"),
					d = i("./node_modules/matrix-js-sdk/lib/crypto/store/indexeddb-crypto-store.js"),
					l = i("./node_modules/matrix-js-sdk/lib/crypto/aes.js"),
					c = i("./node_modules/matrix-js-sdk/lib/logger.js"),
					u = i("./node_modules/matrix-js-sdk/lib/http-api/index.js");
				const h = "org.matrix.msc2697.v1.olm.libolm_pickle";
				t.DEHYDRATION_ALGORITHM = h;
				const m = 6048e5;
				t.DehydrationManager = class {
					constructor(e) {
						this.crypto = e, (0, s.default)(this, "inProgress", !1), (0, s.default)(this, "timeoutId", void 0), (0, s.default)(this, "key", void 0), (0, s.default)(this, "keyInfo", void 0), (0, s.default)(this, "deviceDisplayName", void 0), this.getDehydrationKeyFromCache()
					}
					getDehydrationKeyFromCache() {
						return this.crypto.cryptoStore.doTxn("readonly", [d.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
							this.crypto.cryptoStore.getSecretStorePrivateKey(t, async t => {
								if (t) {
									const {
										key: i,
										keyInfo: r,
										deviceDisplayName: s,
										time: o
									} = t, d = e.from(this.crypto.olmDevice.pickleKey), c = await (0, l.decryptAES)(i, d, h);
									this.key = (0, a.decodeBase64)(c), this.keyInfo = r, this.deviceDisplayName = s;
									const u = Date.now(),
										p = Math.max(1, o + m - u);
									this.timeoutId = n.setTimeout(this.dehydrateDevice.bind(this), p)
								}
							}, "dehydration")
						})
					}
					async setKeyAndQueueDehydration(e, t = {}, i) {
						await this.setKey(e, t, i) || this.dehydrateDevice()
					}
					async setKey(e, t = {}, i) {
						if (!e) return this.timeoutId && (n.clearTimeout(this.timeoutId), this.timeoutId = void 0), await this.crypto.cryptoStore.doTxn("readwrite", [d.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
							this.crypto.cryptoStore.storeSecretStorePrivateKey(e, "dehydration", null)
						}), this.key = void 0, void(this.keyInfo = void 0);
						let r = !!this.key && e.length == this.key.length;
						for (let n = 0; r && n < e.length; n++) e[n] != this.key[n] && (r = !1);
						return r || (this.key = e, this.keyInfo = t, this.deviceDisplayName = i), r
					}
					async dehydrateDevice() {
						if (this.inProgress) c.logger.log("Dehydration already in progress -- not starting new dehydration");
						else {
							this.inProgress = !0, this.timeoutId && (n.clearTimeout(this.timeoutId), this.timeoutId = void 0);
							try {
								const t = e.from(this.crypto.olmDevice.pickleKey),
									i = await (0, l.encryptAES)((0, a.encodeBase64)(this.key), t, h);
								await this.crypto.cryptoStore.doTxn("readwrite", [d.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
									this.crypto.cryptoStore.storeSecretStorePrivateKey(e, "dehydration", {
										keyInfo: this.keyInfo,
										key: i,
										deviceDisplayName: this.deviceDisplayName,
										time: Date.now()
									})
								}), c.logger.log("Attempting to dehydrate device"), c.logger.log("Creating account");
								const r = new n.Olm.Account;
								r.create();
								const s = JSON.parse(r.identity_keys()),
									p = r.max_number_of_one_time_keys();
								r.generate_one_time_keys(p / 2), r.generate_fallback_key();
								const g = JSON.parse(r.one_time_keys()),
									f = JSON.parse(r.fallback_key());
								r.mark_keys_as_published();
								const v = r.pickle(new Uint8Array(this.key)),
									y = {
										algorithm: h,
										account: v
									};
								this.keyInfo.passphrase && (y.passphrase = this.keyInfo.passphrase), c.logger.log("Uploading account to server");
								const b = (await this.crypto.baseApis.http.authedRequest(u.Method.Put, "/dehydrated_device", void 0, {
									device_data: y,
									initial_device_display_name: this.deviceDisplayName
								}, {
									prefix: "/_matrix/client/unstable/org.matrix.msc2697.v2"
								})).device_id;
								c.logger.log("Preparing device keys", b);
								const _ = {
										algorithms: this.crypto.supportedAlgorithms,
										device_id: b,
										user_id: this.crypto.userId,
										keys: {
											[`ed25519:${b}`]: s.ed25519,
											[`curve25519:${b}`]: s.curve25519
										}
									},
									S = r.sign(o.default.stringify(_));
								_.signatures = {
									[this.crypto.userId]: {
										[`ed25519:${b}`]: S
									}
								}, this.crypto.crossSigningInfo.getId("self_signing") && await this.crypto.crossSigningInfo.signObject(_, "self_signing"), c.logger.log("Preparing one-time keys");
								const E = {};
								for (const [e, n] of Object.entries(g.curve25519)) {
									const t = {
											key: n
										},
										i = r.sign(o.default.stringify(t));
									t.signatures = {
										[this.crypto.userId]: {
											[`ed25519:${b}`]: i
										}
									}, E[`signed_curve25519:${e}`] = t
								}
								c.logger.log("Preparing fallback keys");
								const w = {};
								for (const [e, n] of Object.entries(f.curve25519)) {
									const t = {
											key: n,
											fallback: !0
										},
										i = r.sign(o.default.stringify(t));
									t.signatures = {
										[this.crypto.userId]: {
											[`ed25519:${b}`]: i
										}
									}, w[`signed_curve25519:${e}`] = t
								}
								return c.logger.log("Uploading keys to server"), await this.crypto.baseApis.http.authedRequest(u.Method.Post, "/keys/upload/" + encodeURI(b), void 0, {
									device_keys: _,
									one_time_keys: E,
									"org.matrix.msc2732.fallback_keys": w
								}), c.logger.log("Done dehydrating"), this.timeoutId = n.setTimeout(this.dehydrateDevice.bind(this), m), b
							} finally {
								this.inProgress = !1
							}
						}
					}
					stop() {
						this.timeoutId && (n.clearTimeout(this.timeoutId), this.timeoutId = void 0)
					}
				}
			}).call(this, i("./node_modules/buffer/index.js").Buffer, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/crypto/deviceinfo.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.DeviceInfo = void 0;
			var r, s = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js"));
			! function(e) {
				e[e.Blocked = -1] = "Blocked", e[e.Unverified = 0] = "Unverified", e[e.Verified = 1] = "Verified"
			}(r || (r = {}));
			class o {
				static fromStorage(e, t) {
					const i = new o(t);
					for (const n in e) e.hasOwnProperty(n) && (i[n] = e[n]);
					return i
				}
				constructor(e) {
					this.deviceId = e, (0, s.default)(this, "algorithms", []), (0, s.default)(this, "keys", {}), (0, s.default)(this, "verified", r.Unverified), (0, s.default)(this, "known", !1), (0, s.default)(this, "unsigned", {}), (0, s.default)(this, "signatures", {})
				}
				toStorage() {
					return {
						algorithms: this.algorithms,
						keys: this.keys,
						verified: this.verified,
						known: this.known,
						unsigned: this.unsigned,
						signatures: this.signatures
					}
				}
				getFingerprint() {
					return this.keys["ed25519:" + this.deviceId]
				}
				getIdentityKey() {
					return this.keys["curve25519:" + this.deviceId]
				}
				getDisplayName() {
					return this.unsigned.device_display_name || null
				}
				isBlocked() {
					return this.verified == r.Blocked
				}
				isVerified() {
					return this.verified == r.Verified
				}
				isUnverified() {
					return this.verified == r.Unverified
				}
				isKnown() {
					return !0 === this.known
				}
			}
			t.DeviceInfo = o, (0, s.default)(o, "DeviceVerification", {
				VERIFIED: r.Verified,
				UNVERIFIED: r.Unverified,
				BLOCKED: r.Blocked
			})
		},
		"./node_modules/matrix-js-sdk/lib/crypto/index.js": function(e, t, i) {
			"use strict";
			(function(e, n) {
				var r = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.IncomingRoomKeyRequest = t.CryptoEvent = t.Crypto = void 0, t.fixBackupKey = G, t.isCryptoAvailable = function() {
					return Boolean(e.Olm)
				}, t.verificationMethods = void 0;
				var s = r(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
					o = r(i("./node_modules/another-json/another-json.js")),
					a = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
					d = i("./node_modules/matrix-js-sdk/lib/ReEmitter.js"),
					l = i("./node_modules/matrix-js-sdk/lib/logger.js"),
					c = i("./node_modules/matrix-js-sdk/lib/crypto/OlmDevice.js"),
					u = N(i("./node_modules/matrix-js-sdk/lib/crypto/olmlib.js")),
					h = i("./node_modules/matrix-js-sdk/lib/crypto/DeviceList.js"),
					m = i("./node_modules/matrix-js-sdk/lib/crypto/deviceinfo.js"),
					p = N(i("./node_modules/matrix-js-sdk/lib/crypto/algorithms/index.js")),
					g = i("./node_modules/matrix-js-sdk/lib/crypto/CrossSigning.js"),
					f = i("./node_modules/matrix-js-sdk/lib/crypto/EncryptionSetup.js"),
					v = i("./node_modules/matrix-js-sdk/lib/crypto/SecretStorage.js"),
					y = i("./node_modules/matrix-js-sdk/lib/crypto/OutgoingRoomKeyRequestManager.js"),
					b = i("./node_modules/matrix-js-sdk/lib/crypto/store/indexeddb-crypto-store.js"),
					_ = i("./node_modules/matrix-js-sdk/lib/crypto/verification/QRCode.js"),
					S = i("./node_modules/matrix-js-sdk/lib/crypto/verification/SAS.js"),
					E = i("./node_modules/matrix-js-sdk/lib/crypto/key_passphrase.js"),
					w = i("./node_modules/matrix-js-sdk/lib/crypto/recoverykey.js"),
					k = i("./node_modules/matrix-js-sdk/lib/crypto/verification/request/VerificationRequest.js"),
					T = i("./node_modules/matrix-js-sdk/lib/crypto/verification/request/InRoomChannel.js"),
					I = i("./node_modules/matrix-js-sdk/lib/crypto/verification/request/ToDeviceChannel.js"),
					C = i("./node_modules/matrix-js-sdk/lib/crypto/verification/IllegalMethod.js"),
					R = i("./node_modules/matrix-js-sdk/lib/errors.js"),
					j = i("./node_modules/matrix-js-sdk/lib/crypto/aes.js"),
					O = i("./node_modules/matrix-js-sdk/lib/crypto/dehydration.js"),
					x = i("./node_modules/matrix-js-sdk/lib/crypto/backup.js"),
					M = i("./node_modules/matrix-js-sdk/lib/models/room.js"),
					P = i("./node_modules/matrix-js-sdk/lib/models/room-member.js"),
					D = i("./node_modules/matrix-js-sdk/lib/models/event.js"),
					A = i("./node_modules/matrix-js-sdk/lib/client.js"),
					L = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js");

				function U(e) {
					if ("function" != typeof WeakMap) return null;
					var t = new WeakMap,
						i = new WeakMap;
					return (U = function(e) {
						return e ? i : t
					})(e)
				}

				function N(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = U(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} return n.default = e, i && i.set(e, n), n
				}

				function F(e, t) {
					var i = Object.keys(e);
					if (Object.getOwnPropertySymbols) {
						var n = Object.getOwnPropertySymbols(e);
						t && (n = n.filter((function(t) {
							return Object.getOwnPropertyDescriptor(e, t).enumerable
						}))), i.push.apply(i, n)
					}
					return i
				}
				const B = m.DeviceInfo.DeviceVerification,
					K = {
						[_.ReciprocateQRCode.NAME]: _.ReciprocateQRCode,
						[S.SAS.NAME]: S.SAS,
						[_.SHOW_QR_CODE_METHOD]: C.IllegalMethod,
						[_.SCAN_QR_CODE_METHOD]: C.IllegalMethod
					},
					q = {
						RECIPROCATE_QR_CODE: _.ReciprocateQRCode.NAME,
						SAS: S.SAS.NAME
					};
				t.verificationMethods = q;
				const $ = 36e5;
				let V;
				t.CryptoEvent = V,
					function(e) {
						e.DeviceVerificationChanged = "deviceVerificationChanged", e.UserTrustStatusChanged = "userTrustStatusChanged", e.UserCrossSigningUpdated = "userCrossSigningUpdated", e.RoomKeyRequest = "crypto.roomKeyRequest", e.RoomKeyRequestCancellation = "crypto.roomKeyRequestCancellation", e.KeyBackupStatus = "crypto.keyBackupStatus", e.KeyBackupFailed = "crypto.keyBackupFailed", e.KeyBackupSessionsRemaining = "crypto.keyBackupSessionsRemaining", e.KeySignatureUploadFailure = "crypto.keySignatureUploadFailure", e.VerificationRequest = "crypto.verification.request", e.Warning = "crypto.warning", e.WillUpdateDevices = "crypto.willUpdateDevices", e.DevicesUpdated = "crypto.devicesUpdated", e.KeysChanged = "crossSigning.keysChanged"
					}(V || (t.CryptoEvent = V = {}));
				class W extends L.TypedEventEmitter {
					static getOlmVersion() {
						return c.OlmDevice.getOlmVersion()
					}
					constructor(e, t, i, n, r, o, a) {
						if (super(), this.baseApis = e, this.userId = t, this.deviceId = i, this.clientStore = n, this.cryptoStore = r, this.roomList = o, (0, s.default)(this, "backupManager", void 0), (0, s.default)(this, "crossSigningInfo", void 0), (0, s.default)(this, "olmDevice", void 0), (0, s.default)(this, "deviceList", void 0), (0, s.default)(this, "dehydrationManager", void 0), (0, s.default)(this, "secretStorage", void 0), (0, s.default)(this, "reEmitter", void 0), (0, s.default)(this, "verificationMethods", void 0), (0, s.default)(this, "supportedAlgorithms", void 0), (0, s.default)(this, "outgoingRoomKeyRequestManager", void 0), (0, s.default)(this, "toDeviceVerificationRequests", void 0), (0, s.default)(this, "inRoomVerificationRequests", void 0), (0, s.default)(this, "trustCrossSignedDevices", !0), (0, s.default)(this, "lastOneTimeKeyCheck", null), (0, s.default)(this, "oneTimeKeyCheckInProgress", !1), (0, s.default)(this, "roomEncryptors", new Map), (0, s.default)(this, "roomDecryptors", new Map), (0, s.default)(this, "deviceKeys", {}), (0, s.default)(this, "globalBlacklistUnverifiedDevices", !1), (0, s.default)(this, "globalErrorOnUnknownDevices", !0), (0, s.default)(this, "receivedRoomKeyRequests", []), (0, s.default)(this, "receivedRoomKeyRequestCancellations", []), (0, s.default)(this, "processingRoomKeyRequests", !1), (0, s.default)(this, "lazyLoadMembers", !1), (0, s.default)(this, "roomDeviceTrackingState", {}), (0, s.default)(this, "lastNewSessionForced", {}), (0, s.default)(this, "sendKeyRequestsImmediately", !1), (0, s.default)(this, "oneTimeKeyCount", void 0), (0, s.default)(this, "needsNewFallback", void 0), (0, s.default)(this, "fallbackCleanup", void 0), (0, s.default)(this, "onDeviceListUserCrossSigningUpdated", async e => {
								if (e === this.userId) {
									const t = this.deviceList.getStoredCrossSigningForUser(e),
										i = t ? t.getId() : null,
										n = this.crossSigningInfo.getId(),
										r = n !== i;
									n && i && !r ? await this.checkOwnCrossSigningTrust() : (this.storeTrustedSelfKeys(null), this.emit(V.KeysChanged, {}), this.emit(V.UserTrustStatusChanged, this.userId, this.checkUserTrust(e)))
								} else {
									await this.checkDeviceVerifications(e);
									const t = this.deviceList.getStoredCrossSigningForUser(e);
									t && (t.updateCrossSigningVerifiedBefore(this.checkUserTrust(e).isCrossSigningVerified()), this.deviceList.setRawStoredCrossSigningForUser(e, t.toStorage())), this.emit(V.UserTrustStatusChanged, e, this.checkUserTrust(e))
								}
							}), (0, s.default)(this, "onMembership", (e, t, i) => {
								try {
									this.onRoomMembership(e, t, i)
								} catch (n) {
									l.logger.error("Error handling membership change:", n)
								}
							}), (0, s.default)(this, "onToDeviceEvent", e => {
								try {
									l.logger.log(`received to_device ${e.getType()} from: ` + `${e.getSender()} id: ${e.getId()}`), "m.room_key" == e.getType() || "m.forwarded_room_key" == e.getType() ? this.onRoomKeyEvent(e) : "m.room_key_request" == e.getType() ? this.onRoomKeyRequestEvent(e) : "m.secret.request" === e.getType() ? this.secretStorage.onRequestReceived(e) : "m.secret.send" === e.getType() ? this.secretStorage.onSecretReceived(e) : "m.room_key.withheld" === e.getType() ? this.onRoomKeyWithheldEvent(e) : e.getContent().transaction_id ? this.onKeyVerificationMessage(e) : "m.bad.encrypted" === e.getContent().msgtype ? this.onToDeviceBadEncrypted(e) : (e.isBeingDecrypted() || e.shouldAttemptDecryption()) && (e.isBeingDecrypted() || e.attemptDecryption(this), e.once(D.MatrixEventEvent.Decrypted, e => {
										this.onToDeviceEvent(e)
									}))
								} catch (t) {
									l.logger.error("Error handling toDeviceEvent:", t)
								}
							}), (0, s.default)(this, "onTimelineEvent", (e, t, i, n, {
								liveEvent: r = !0
							} = {}) => {
								if (!T.InRoomChannel.validateEvent(e, this.baseApis)) return;
								this.handleVerificationEvent(e, this.inRoomVerificationRequests, e => {
									const t = new T.InRoomChannel(this.baseApis, e.getRoomId());
									return new k.VerificationRequest(t, this.verificationMethods, this.baseApis)
								}, r)
							}), this.reEmitter = new d.TypedReEmitter(this), a) {
							this.verificationMethods = new Map;
							for (const e of a) "string" == typeof e ? K[e] && this.verificationMethods.set(e, K[e]) : e.NAME ? this.verificationMethods.set(e.NAME, e) : l.logger.warn(`Excluding unknown verification method ${e}`)
						} else this.verificationMethods = new Map(Object.entries(K));
						this.backupManager = new x.BackupManager(e, async () => {
							const e = await this.getSessionBackupPrivateKey();
							if (e) return e;
							const t = await this.getSecret("m.megolm_backup.v1");
							if (t) {
								const e = G(t);
								if (e) {
									const t = await this.getSecretStorageKey();
									await this.storeSecret("m.megolm_backup.v1", e, [t[0]])
								}
								return u.decodeBase64(e || t)
							}
							if (this.baseApis.cryptoCallbacks && this.baseApis.cryptoCallbacks.getBackupKey) return this.baseApis.cryptoCallbacks.getBackupKey();
							throw new Error("Unable to get private key")
						}), this.olmDevice = new c.OlmDevice(r), this.deviceList = new h.DeviceList(e, r, this.olmDevice), this.deviceList.on(V.UserCrossSigningUpdated, this.onDeviceListUserCrossSigningUpdated), this.reEmitter.reEmit(this.deviceList, [V.DevicesUpdated, V.WillUpdateDevices]), this.supportedAlgorithms = Array.from(p.DECRYPTION_CLASSES.keys()), this.outgoingRoomKeyRequestManager = new y.OutgoingRoomKeyRequestManager(e, this.deviceId, this.cryptoStore), this.toDeviceVerificationRequests = new I.ToDeviceRequests, this.inRoomVerificationRequests = new T.InRoomRequests;
						const m = this.baseApis.cryptoCallbacks || {},
							f = (0, g.createCryptoStoreCacheCallbacks)(r, this.olmDevice);
						this.crossSigningInfo = new g.CrossSigningInfo(t, m, f), this.secretStorage = new v.SecretStorage(e, m, e), this.dehydrationManager = new O.DehydrationManager(this), !m.getCrossSigningKey && m.getSecretStorageKey && (m.getCrossSigningKey = async e => g.CrossSigningInfo.getFromSecretStorage(e, this.secretStorage))
					}
					async init({
						exportedOlmDevice: t,
						pickleKey: i
					} = {}) {
						l.logger.log("Crypto: initialising Olm..."), await e.Olm.init(), l.logger.log(t ? "Crypto: initialising Olm device from exported device..." : "Crypto: initialising Olm device..."), await this.olmDevice.init({
							fromExportedDevice: t,
							pickleKey: i
						}), l.logger.log("Crypto: loading device list..."), await this.deviceList.load(), this.deviceKeys["ed25519:" + this.deviceId] = this.olmDevice.deviceEd25519Key, this.deviceKeys["curve25519:" + this.deviceId] = this.olmDevice.deviceCurve25519Key, l.logger.log("Crypto: fetching own devices...");
						let n = this.deviceList.getRawStoredDevicesForUser(this.userId);
						if (n || (n = {}), !n[this.deviceId]) {
							l.logger.log("Crypto: adding this device to the store...");
							const e = {
								keys: this.deviceKeys,
								algorithms: this.supportedAlgorithms,
								verified: B.VERIFIED,
								known: !0
							};
							n[this.deviceId] = e, this.deviceList.storeDevicesForUser(this.userId, n), this.deviceList.saveIfDirty()
						}
						await this.cryptoStore.doTxn("readonly", [b.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
							this.cryptoStore.getCrossSigningKeys(e, e => {
								e && 0 !== Object.keys(e).length && (l.logger.log("Loaded cross-signing public keys from crypto store"), this.crossSigningInfo.setKeys(e))
							})
						}), this.deviceList.startTrackingDeviceList(this.userId), l.logger.log("Crypto: checking for key backup..."), this.backupManager.checkAndStart()
					}
					getCryptoTrustCrossSignedDevices() {
						return this.trustCrossSignedDevices
					}
					setCryptoTrustCrossSignedDevices(e) {
						this.trustCrossSignedDevices = e;
						for (const t of this.deviceList.getKnownUserIds()) {
							const e = this.deviceList.getRawStoredDevicesForUser(t);
							for (const i of Object.keys(e)) {
								const e = this.checkDeviceTrust(t, i);
								if (!e.isLocallyVerified() && e.isCrossSigningVerified()) {
									const e = this.deviceList.getStoredDevice(t, i);
									this.emit(V.DeviceVerificationChanged, t, i, e)
								}
							}
						}
					}
					async createRecoveryKeyFromPassphrase(t) {
						const i = new e.Olm.PkDecryption;
						try {
							const e = {};
							if (t) {
								const n = await (0, E.keyFromPassphrase)(t);
								e.passphrase = {
									algorithm: "m.pbkdf2",
									iterations: n.iterations,
									salt: n.salt
								}, e.pubkey = i.init_with_private_key(n.key)
							} else e.pubkey = i.generate_key();
							const n = i.get_private_key();
							return {
								keyInfo: e,
								encodedPrivateKey: (0, w.encodeRecoveryKey)(n),
								privateKey: n
							}
						} finally {
							null == i || i.free()
						}
					}
					async isCrossSigningReady() {
						const e = this.crossSigningInfo.getId(),
							t = await this.crossSigningInfo.isStoredInKeyCache() || await this.crossSigningInfo.isStoredInSecretStorage(this.secretStorage);
						return !(!e || !t)
					}
					async isSecretStorageReady() {
						const e = await this.secretStorage.hasKey(),
							t = await this.crossSigningInfo.isStoredInSecretStorage(this.secretStorage),
							i = !this.backupManager.getKeyBackupEnabled() || await this.baseApis.isKeyBackupKeyStored();
						return !!(e && t && i)
					}
					async bootstrapCrossSigning({
						authUploadDeviceSigningKeys: e,
						setupNewCrossSigning: t
					} = {}) {
						l.logger.log("Bootstrapping cross-signing");
						const i = this.baseApis.cryptoCallbacks,
							n = new f.EncryptionSetupBuilder(this.baseApis.store.accountData, i),
							r = new g.CrossSigningInfo(this.userId, n.crossSigningCallbacks, n.crossSigningCallbacks),
							s = async () => {
								r.resetKeys(), await this.signObject(r.keys.master), n.addCrossSigningKeys(e, r.keys);
								const t = this.deviceList.getStoredDevice(this.userId, this.deviceId),
									i = await r.signDevice(this.userId, t);
								n.addKeySignature(this.userId, this.deviceId, i), this.backupManager.backupInfo && (await r.signObject(this.backupManager.backupInfo.auth_data, "master"), n.addSessionBackup(this.backupManager.backupInfo))
							}, o = this.crossSigningInfo.getId(), a = await this.crossSigningInfo.isStoredInKeyCache(), d = await this.crossSigningInfo.isStoredInSecretStorage(this.secretStorage), c = a || d;
						l.logger.log({
							setupNewCrossSigning: t,
							publicKeysOnDevice: o,
							privateKeysInCache: a,
							privateKeysInStorage: d,
							privateKeysExistSomewhere: c
						}), !c || t ? (l.logger.log("Cross-signing private keys not found locally or in secret storage, creating new keys"), await s()) : o && a ? l.logger.log("Cross-signing public keys trusted and private keys found locally") : d && (l.logger.log("Cross-signing private keys not found locally, but they are available in secret storage, reading storage and caching locally"), await this.checkOwnCrossSigningTrust({
							allowPrivateKeyRequests: !0
						}));
						const u = n.crossSigningCallbacks.privateKeys;
						if (u.size && !this.baseApis.cryptoCallbacks.saveCrossSigningKeys) {
							const e = new v.SecretStorage(n.accountDataClientAdapter, n.ssssCryptoCallbacks, void 0);
							await e.hasKey() && (l.logger.log("Storing new cross-signing private keys in secret storage"), await g.CrossSigningInfo.storeInSecretStorage(u, e))
						}
						const h = n.buildOperation();
						await h.apply(this), await n.persist(this), l.logger.log("Cross-signing ready")
					}
					async bootstrapSecretStorage({
						createSecretStorageKey: e = (async () => ({})),
						keyBackupInfo: t,
						setupNewKeyBackup: i,
						setupNewSecretStorage: n,
						getKeyBackupPassphrase: r
					} = {}) {
						l.logger.log("Bootstrapping Secure Secret Storage");
						const s = this.baseApis.cryptoCallbacks,
							o = new f.EncryptionSetupBuilder(this.baseApis.store.accountData, s),
							a = new v.SecretStorage(o.accountDataClientAdapter, o.ssssCryptoCallbacks, void 0);
						let d = null;
						const c = async (e, t) => {
							t && (e.key = t);
							const {
								keyId: i,
								keyInfo: n
							} = await a.addKey(v.SECRET_STORAGE_ALGORITHM_V1_AES, e);
							return t && o.ssssCryptoCallbacks.addPrivateKey(i, n, t), await a.setDefaultKeyId(i), i
						}, h = async (e, t) => {
							if (!t.mac) {
								var i, n;
								const r = await (null === (i = (n = this.baseApis.cryptoCallbacks).getSecretStorageKey) || void 0 === i ? void 0 : i.call(n, {
									keys: {
										[e]: t
									}
								}, ""));
								if (r) {
									const i = r[1];
									o.ssssCryptoCallbacks.addPrivateKey(e, t, i);
									const {
										iv: n,
										mac: s
									} = await (0, j.calculateKeyCheck)(i);
									t.iv = n, t.mac = s, await o.setAccountData(`m.secret_storage.key.${e}`, t)
								}
							}
						}, m = async e => {
							if (this.crossSigningInfo.getId() && await this.crossSigningInfo.isStoredInKeyCache("master")) try {
								l.logger.log("Adding cross-signing signature to key backup"), await this.crossSigningInfo.signObject(e, "master")
							} catch (t) {
								l.logger.error("Signing key backup with cross-signing keys failed", t)
							} else l.logger.warn("Cross-signing keys not available, skipping signature on key backup")
						}, p = await this.getSecretStorageKey(), [y, b] = p || [null, null], _ = !n && b && b.algorithm === v.SECRET_STORAGE_ALGORITHM_V1_AES;
						if (l.logger.log({
								keyBackupInfo: t,
								setupNewKeyBackup: i,
								setupNewSecretStorage: n,
								storageExists: _,
								oldKeyInfo: b
							}), _ || t)
							if (!_ && t) {
								l.logger.log("Secret storage does not exist, using key backup key");
								const e = await this.getSessionBackupPrivateKey() || await (null == r ? void 0 : r()),
									i = {};
								t.auth_data.private_key_salt && t.auth_data.private_key_iterations && (i.passphrase = {
									algorithm: "m.pbkdf2",
									iterations: t.auth_data.private_key_iterations,
									salt: t.auth_data.private_key_salt,
									bits: 256
								}), d = await c(i, e), await a.store("m.megolm_backup.v1", u.encodeBase64(e), [d]), await m(t.auth_data), o.addSessionBackup(t)
							} else l.logger.log("Secret storage exists"), b && b.algorithm === v.SECRET_STORAGE_ALGORITHM_V1_AES && await h(y, b);
						else {
							l.logger.log("Secret storage does not exist, creating new storage key");
							const {
								keyInfo: t = {},
								privateKey: i
							} = await e();
							d = await c(t, i)
						}
						if (!this.baseApis.cryptoCallbacks.saveCrossSigningKeys && await this.isCrossSigningReady() && (d || !(await this.crossSigningInfo.isStoredInSecretStorage(a)))) {
							l.logger.log("Copying cross-signing private keys from cache to secret storage");
							const e = await this.crossSigningInfo.getCrossSigningKeysFromCache();
							await g.CrossSigningInfo.storeInSecretStorage(e, a)
						}
						if (i && !t) {
							l.logger.log("Creating new message key backup version");
							const e = await this.baseApis.prepareKeyBackupVersion(null, {
									secureSecretStorage: !1
								}),
								t = (0, w.decodeRecoveryKey)(e.recovery_key);
							await a.store("m.megolm_backup.v1", u.encodeBase64(t));
							const i = {
								algorithm: e.algorithm,
								auth_data: e.auth_data
							};
							await m(i.auth_data), await this.signObject(i.auth_data), o.addSessionBackup(i)
						}
						const S = await a.get("m.megolm_backup.v1");
						if (S) {
							l.logger.info("Got session backup key from secret storage: caching");
							const e = G(S);
							if (e) {
								const t = d || y;
								await a.store("m.megolm_backup.v1", e, t ? [t] : null)
							}
							const t = new Uint8Array(u.decodeBase64(e || S));
							o.addSessionBackupPrivateKeyToCache(t)
						} else if (this.backupManager.getKeyBackupEnabled()) {
							const e = await this.getSessionBackupPrivateKey() || await (null == r ? void 0 : r());
							if (!e) return void l.logger.error("Key backup is enabled but couldn't get key backup key!");
							l.logger.info("Got session backup key from cache/user that wasn't in SSSS: saving to SSSS"), await a.store("m.megolm_backup.v1", u.encodeBase64(e))
						}
						const E = o.buildOperation();
						await E.apply(this), await o.persist(this), l.logger.log("Secure Secret Storage ready")
					}
					addSecretStorageKey(e, t, i) {
						return this.secretStorage.addKey(e, t, i)
					}
					hasSecretStorageKey(e) {
						return this.secretStorage.hasKey(e)
					}
					getSecretStorageKey(e) {
						return this.secretStorage.getKey(e)
					}
					storeSecret(e, t, i) {
						return this.secretStorage.store(e, t, i)
					}
					getSecret(e) {
						return this.secretStorage.get(e)
					}
					isSecretStored(e) {
						return this.secretStorage.isStored(e)
					}
					requestSecret(e, t) {
						return t || (t = Object.keys(this.deviceList.getRawStoredDevicesForUser(this.userId))), this.secretStorage.request(e, t)
					}
					getDefaultSecretStorageKeyId() {
						return this.secretStorage.getDefaultKeyId()
					}
					setDefaultSecretStorageKeyId(e) {
						return this.secretStorage.setDefaultKeyId(e)
					}
					checkSecretStorageKey(e, t) {
						return this.secretStorage.checkKey(e, t)
					}
					checkSecretStoragePrivateKey(t, i) {
						let n = null;
						try {
							return (n = new e.Olm.PkDecryption).init_with_private_key(t) === i
						} finally {
							var r;
							null === (r = n) || void 0 === r || r.free()
						}
					}
					async getSessionBackupPrivateKey() {
						let e = await new Promise(e => {
							this.cryptoStore.doTxn("readonly", [b.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
								this.cryptoStore.getSecretStorePrivateKey(t, e, "m.megolm_backup.v1")
							})
						});
						if (e && "string" == typeof e && (e = new Uint8Array(u.decodeBase64(G(e) || e)), await this.storeSessionBackupPrivateKey(e)), e && e.ciphertext) {
							const t = n.from(this.olmDevice.pickleKey),
								i = await (0, j.decryptAES)(e, t, "m.megolm_backup.v1");
							e = u.decodeBase64(i)
						}
						return e
					}
					async storeSessionBackupPrivateKey(e) {
						if (!(e instanceof Uint8Array)) throw new Error(`storeSessionBackupPrivateKey expects Uint8Array, got ${e}`);
						const t = n.from(this.olmDevice.pickleKey),
							i = await (0, j.encryptAES)(u.encodeBase64(e), t, "m.megolm_backup.v1");
						return this.cryptoStore.doTxn("readwrite", [b.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
							this.cryptoStore.storeSecretStorePrivateKey(e, "m.megolm_backup.v1", i)
						})
					}
					checkCrossSigningPrivateKey(t, i) {
						let n = null;
						try {
							return (n = new e.Olm.PkSigning).init_with_seed(t) === i
						} finally {
							var r;
							null === (r = n) || void 0 === r || r.free()
						}
					}
					async afterCrossSigningLocalKeyChange() {
						l.logger.info("Starting cross-signing key change post-processing");
						const e = this.deviceList.getStoredDevice(this.userId, this.deviceId),
							t = await this.crossSigningInfo.signDevice(this.userId, e);
						l.logger.info(`Starting background key sig upload for ${this.deviceId}`);
						const i = ({
							shouldEmit: e = !1
						}) => this.baseApis.uploadKeySignatures({
							[this.userId]: {
								[this.deviceId]: t
							}
						}).then(t => {
							const {
								failures: n
							} = t || {};
							if (Object.keys(n || []).length > 0) throw e && this.baseApis.emit(V.KeySignatureUploadFailure, n, "afterCrossSigningLocalKeyChange", i), new R.KeySignatureUploadError("Key upload failed", {
								failures: n
							});
							l.logger.info(`Finished background key sig upload for ${this.deviceId}`)
						}).catch(e => {
							l.logger.error(`Error during background key sig upload for ${this.deviceId}`, e)
						});
						i({
							shouldEmit: !0
						});
						const n = this.baseApis.cryptoCallbacks.shouldUpgradeDeviceVerifications;
						if (n) {
							l.logger.info("Starting device verification upgrade");
							const e = {};
							for (const [t, i] of Object.entries(this.deviceList.crossSigningInfo)) {
								const n = await this.checkForDeviceVerificationUpgrade(t, g.CrossSigningInfo.fromStorage(i, t));
								n && (e[t] = n)
							}
							if (Object.keys(e).length > 0) {
								l.logger.info(`Found ${Object.keys(e).length} verif users to upgrade`);
								try {
									const t = await n({
										users: e
									});
									if (t)
										for (const i of t) i in e && await this.baseApis.setDeviceVerified(i, e[i].crossSigningInfo.getId())
								} catch (r) {
									l.logger.log("shouldUpgradeDeviceVerifications threw an error: not upgrading", r)
								}
							}
							l.logger.info("Finished device verification upgrade")
						}
						l.logger.info("Finished cross-signing key change post-processing")
					}
					async checkForDeviceVerificationUpgrade(e, t) {
						const i = this.crossSigningInfo.checkUserTrust(t);
						if (t.firstUse && !i.isVerified()) {
							const i = this.deviceList.getRawStoredDevicesForUser(e),
								n = await this.checkForValidDeviceSignature(e, t.keys.master, i);
							if (n.length) return {
								devices: n.map(e => m.DeviceInfo.fromStorage(i[e], e)),
								crossSigningInfo: t
							}
						}
					}
					async checkForValidDeviceSignature(e, t, i) {
						const n = [];
						if (i && t.signatures && t.signatures[e])
							for (const s of Object.keys(t.signatures[e])) {
								const [, o] = s.split(":", 2);
								if (o in i && i[o].verified === B.VERIFIED) try {
									await u.verifySignature(this.olmDevice, t, e, o, i[o].keys[s]), n.push(o)
								} catch (r) {}
							}
						return n
					}
					getCrossSigningId(e) {
						return this.crossSigningInfo.getId(e)
					}
					getStoredCrossSigningForUser(e) {
						return this.deviceList.getStoredCrossSigningForUser(e)
					}
					checkUserTrust(e) {
						const t = this.deviceList.getStoredCrossSigningForUser(e);
						return t ? this.crossSigningInfo.checkUserTrust(t) : new g.UserTrustLevel(!1, !1, !1)
					}
					checkDeviceTrust(e, t) {
						const i = this.deviceList.getStoredDevice(e, t);
						return this.checkDeviceInfoTrust(e, i)
					}
					checkDeviceInfoTrust(e, t) {
						const i = !(null == t || !t.isVerified()),
							n = this.deviceList.getStoredCrossSigningForUser(e);
						if (t && n) {
							const r = this.trustCrossSignedDevices || e === this.userId;
							return this.crossSigningInfo.checkDeviceTrust(n, t, i, r)
						}
						return new g.DeviceTrustLevel(!1, !1, i, !1)
					}
					checkIfOwnDeviceCrossSigned(e) {
						var t;
						const i = this.deviceList.getStoredDevice(this.userId, e);
						if (!i) return !1;
						const n = this.deviceList.getStoredCrossSigningForUser(this.userId);
						return null !== (t = null == n ? void 0 : n.checkDeviceTrust(n, i, !1, !0).isCrossSigningVerified()) && void 0 !== t && t
					}
					async checkOwnCrossSigningTrust({
						allowPrivateKeyRequests: e = !1
					} = {}) {
						const t = this.userId;
						await this.downloadKeys([this.userId]);
						const i = await this.crossSigningInfo.getCrossSigningKeysFromCache(),
							n = this.deviceList.getStoredCrossSigningForUser(t);
						if (!n) return void l.logger.error("Got cross-signing update event for user " + t + " but no new cross-signing information found!");
						const r = n.getId(),
							s = this.crossSigningInfo.getId() !== r,
							o = n.getId() && !i.has("master");
						if (s && l.logger.info("Got new master public key", r), e && (s || o)) {
							l.logger.info("Attempting to retrieve cross-signing master private key");
							let e = null;
							try {
								e = (await this.crossSigningInfo.getCrossSigningKey("master", r))[1], l.logger.info("Got cross-signing master private key")
							} finally {
								var a;
								null === (a = e) || void 0 === a || a.free()
							}
						}
						const d = this.crossSigningInfo.getId("self_signing"),
							c = this.crossSigningInfo.getId("user_signing");
						this.storeTrustedSelfKeys(n.keys);
						const u = d !== n.getId("self_signing"),
							h = c !== n.getId("user_signing"),
							m = n.getId("self_signing") && !i.has("self_signing"),
							p = n.getId("user_signing") && !i.has("user_signing"),
							g = {};
						if (u && l.logger.info("Got new self-signing key", n.getId("self_signing")), e && (u || m)) {
							l.logger.info("Attempting to retrieve cross-signing self-signing private key");
							let e = null;
							try {
								e = (await this.crossSigningInfo.getCrossSigningKey("self_signing", n.getId("self_signing")))[1], l.logger.info("Got cross-signing self-signing private key")
							} finally {
								var f;
								null === (f = e) || void 0 === f || f.free()
							}
							const t = this.deviceList.getStoredDevice(this.userId, this.deviceId),
								i = await this.crossSigningInfo.signDevice(this.userId, t);
							g[this.deviceId] = i
						}
						if (h && l.logger.info("Got new user-signing key", n.getId("user_signing")), e && (h || p)) {
							l.logger.info("Attempting to retrieve cross-signing user-signing private key");
							let e = null;
							try {
								e = (await this.crossSigningInfo.getCrossSigningKey("user_signing", n.getId("user_signing")))[1], l.logger.info("Got cross-signing user-signing private key")
							} finally {
								var v;
								null === (v = e) || void 0 === v || v.free()
							}
						}
						if (s) {
							const e = this.crossSigningInfo.keys.master;
							await this.signObject(e);
							const t = e.signatures[this.userId]["ed25519:" + this.deviceId];
							g[this.crossSigningInfo.getId()] = Object.assign({}, e, {
								signatures: {
									[this.userId]: {
										["ed25519:" + this.deviceId]: t
									}
								}
							})
						}
						const y = Object.keys(g);
						if (y.length) {
							const e = ({
								shouldEmit: t = !1
							}) => (l.logger.info(`Starting background key sig upload for ${y}`), this.baseApis.uploadKeySignatures({
								[this.userId]: g
							}).then(i => {
								const {
									failures: n
								} = i || {};
								if (l.logger.info(`Finished background key sig upload for ${y}`), Object.keys(n || []).length > 0) throw t && this.baseApis.emit(V.KeySignatureUploadFailure, n, "checkOwnCrossSigningTrust", e), new R.KeySignatureUploadError("Key upload failed", {
									failures: n
								})
							}).catch(e => {
								l.logger.error(`Error during background key sig upload for ${y}`, e)
							}));
							e({
								shouldEmit: !0
							})
						}
						this.emit(V.UserTrustStatusChanged, t, this.checkUserTrust(t)), s && (this.emit(V.KeysChanged, {}), await this.afterCrossSigningLocalKeyChange()), await this.backupManager.checkKeyBackup()
					}
					async storeTrustedSelfKeys(e) {
						e ? this.crossSigningInfo.setKeys(e) : this.crossSigningInfo.clearKeys(), await this.cryptoStore.doTxn("readwrite", [b.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
							this.cryptoStore.storeCrossSigningKeys(e, this.crossSigningInfo.keys)
						})
					}
					async checkDeviceVerifications(e) {
						const t = this.baseApis.cryptoCallbacks.shouldUpgradeDeviceVerifications;
						if (t) {
							if (l.logger.info(`Starting device verification upgrade for ${e}`), this.crossSigningInfo.keys.user_signing) {
								const i = this.deviceList.getStoredCrossSigningForUser(e);
								if (i) {
									const n = await this.checkForDeviceVerificationUpgrade(e, i);
									if (n) {
										(await t({
											users: {
												[e]: n
											}
										})).includes(e) && await this.baseApis.setDeviceVerified(e, i.getId())
									}
								}
							}
							l.logger.info(`Finished device verification upgrade for ${e}`)
						}
					}
					enableLazyLoading() {
						this.lazyLoadMembers = !0
					}
					registerEventHandlers(e) {
						e.on(P.RoomMemberEvent.Membership, this.onMembership), e.on(A.ClientEvent.ToDeviceEvent, this.onToDeviceEvent), e.on(M.RoomEvent.Timeline, this.onTimelineEvent), e.on(D.MatrixEventEvent.Decrypted, this.onTimelineEvent)
					}
					start() {
						l.logger.warn("MatrixClient.crypto.start() is deprecated")
					}
					stop() {
						this.outgoingRoomKeyRequestManager.stop(), this.deviceList.stop(), this.dehydrationManager.stop()
					}
					getDeviceEd25519Key() {
						return this.olmDevice.deviceEd25519Key
					}
					getDeviceCurve25519Key() {
						return this.olmDevice.deviceCurve25519Key
					}
					setGlobalBlacklistUnverifiedDevices(e) {
						this.globalBlacklistUnverifiedDevices = e
					}
					getGlobalBlacklistUnverifiedDevices() {
						return this.globalBlacklistUnverifiedDevices
					}
					uploadDeviceKeys() {
						const e = {
							algorithms: this.supportedAlgorithms,
							device_id: this.deviceId,
							keys: this.deviceKeys,
							user_id: this.userId
						};
						return this.signObject(e).then(() => this.baseApis.uploadKeysRequest({
							device_keys: e
						}))
					}
					updateOneTimeKeyCount(e) {
						if (!isFinite(e)) throw new TypeError("Parameter for updateOneTimeKeyCount has to be a number");
						this.oneTimeKeyCount = e
					}
					setNeedsNewFallback(e) {
						this.needsNewFallback = e
					}
					getNeedsNewFallback() {
						return !!this.needsNewFallback
					}
					maybeUploadOneTimeKeys() {
						if (this.oneTimeKeyCheckInProgress) return;
						const e = Date.now();
						if (null !== this.lastOneTimeKeyCheck && e - this.lastOneTimeKeyCheck < 6e4) return;
						this.lastOneTimeKeyCheck = e;
						const t = this.olmDevice.maxNumberOfOneTimeKeys(),
							i = Math.floor(t / 2),
							n = async e => {
								for (; i > e || this.getNeedsNewFallback();) {
									if (i > e) {
										l.logger.info("generating oneTimeKeys");
										const t = Math.min(i - e, 5);
										await this.olmDevice.generateOneTimeKeys(t)
									}
									if (this.getNeedsNewFallback()) {
										const e = await this.olmDevice.getFallbackKey();
										e.curve25519 && 0 != Object.keys(e.curve25519).length || (l.logger.info("generating fallback key"), this.fallbackCleanup && (clearTimeout(this.fallbackCleanup), delete this.fallbackCleanup), await this.olmDevice.generateFallbackKey())
									}
									l.logger.info("calling uploadOneTimeKeys");
									const t = await this.uploadOneTimeKeys();
									if (!t.one_time_key_counts || !t.one_time_key_counts.signed_curve25519) throw new Error("response for uploading keys does not contain one_time_key_counts.signed_curve25519");
									e = t.one_time_key_counts.signed_curve25519
								}
							};
						this.oneTimeKeyCheckInProgress = !0, Promise.resolve().then(() => void 0 !== this.oneTimeKeyCount ? Promise.resolve(this.oneTimeKeyCount) : this.baseApis.uploadKeysRequest({}).then(e => e.one_time_key_counts.signed_curve25519 || 0)).then(e => n(e)).catch(e => {
							l.logger.error("Error uploading one-time keys", e.stack || e)
						}).finally(() => {
							this.oneTimeKeyCount = void 0, this.oneTimeKeyCheckInProgress = !1
						})
					}
					async uploadOneTimeKeys() {
						const e = [];
						let t;
						if (this.getNeedsNewFallback()) {
							t = {};
							const i = await this.olmDevice.getFallbackKey();
							for (const [n, r] of Object.entries(i.curve25519)) {
								const i = {
									key: r,
									fallback: !0
								};
								t["signed_curve25519:" + n] = i, e.push(this.signObject(i))
							}
							this.setNeedsNewFallback(!1)
						}
						const i = await this.olmDevice.getOneTimeKeys(),
							n = {};
						for (const o in i.curve25519)
							if (i.curve25519.hasOwnProperty(o)) {
								const t = {
									key: i.curve25519[o]
								};
								n["signed_curve25519:" + o] = t, e.push(this.signObject(t))
							} await Promise.all(e);
						const r = {
							one_time_keys: n
						};
						t && (r["org.matrix.msc2732.fallback_keys"] = t, r.fallback_keys = t);
						const s = await this.baseApis.uploadKeysRequest(r);
						return t && (this.fallbackCleanup = setTimeout(() => {
							delete this.fallbackCleanup, this.olmDevice.forgetOldFallbackKey()
						}, 36e5)), await this.olmDevice.markKeysAsPublished(), s
					}
					downloadKeys(e, t) {
						return this.deviceList.downloadKeys(e, !!t)
					}
					getStoredDevicesForUser(e) {
						return this.deviceList.getStoredDevicesForUser(e)
					}
					getStoredDevice(e, t) {
						return this.deviceList.getStoredDevice(e, t)
					}
					saveDeviceList(e) {
						return this.deviceList.saveIfDirty(e)
					}
					async setDeviceVerification(e, t, i = null, n = null, r = null, s) {
						const o = this.deviceList.getStoredCrossSigningForUser(e);
						if (o && o.getId() === t) {
							if (null !== n || null !== r) throw new Error("Cannot set blocked or known for a cross-signing key");
							if (!i) throw new Error("Cannot set a cross-signing key as unverified");
							const a = s ? Object.values(s)[0] : null;
							if (s && (1 !== Object.values(s).length || a !== o.getId())) throw new Error(`Key did not match expected value: expected ${o.getId()}, got ${a}`);
							if (this.crossSigningInfo.getId() || e !== this.crossSigningInfo.userId || (this.storeTrustedSelfKeys(o.keys), this.emit(V.UserTrustStatusChanged, this.userId, this.checkUserTrust(e))), e !== this.userId) {
								l.logger.info("Master key " + o.getId() + " for " + e + " marked verified. Signing...");
								const i = await this.crossSigningInfo.signUser(o);
								if (i) {
									const n = async ({
										shouldEmit: r = !1
									}) => {
										l.logger.info("Uploading signature for " + e + "...");
										const s = await this.baseApis.uploadKeySignatures({
												[e]: {
													[t]: i
												}
											}),
											{
												failures: o
											} = s || {};
										if (Object.keys(o || []).length > 0) throw r && this.baseApis.emit(V.KeySignatureUploadFailure, o, "setDeviceVerification", n), new R.KeySignatureUploadError("Key upload failed", {
											failures: o
										})
									};
									await n({
										shouldEmit: !0
									})
								}
								return i
							}
							return o
						}
						const a = this.deviceList.getRawStoredDevicesForUser(e);
						if (!a || !a[t]) throw new Error("Unknown device " + e + ":" + t);
						const d = a[t];
						let c = d.verified;
						if (i) {
							if (s)
								for (const [e, t] of Object.entries(s))
									if (d.keys[e] !== t) throw new Error(`Key did not match expected value: expected ${t}, got ${d.keys[e]}`);
							c = B.VERIFIED
						} else null !== i && c == B.VERIFIED && (c = B.UNVERIFIED);
						n ? c = B.BLOCKED : null !== n && c == B.BLOCKED && (c = B.UNVERIFIED);
						let u = d.known;
						if (null !== r && (u = r), d.verified === c && d.known === u || (d.verified = c, d.known = u, this.deviceList.storeDevicesForUser(e, a), this.deviceList.saveIfDirty()), i && e === this.userId) {
							let i;
							if (l.logger.info("Own device " + t + " marked verified: signing"), this.checkDeviceTrust(e, t).isCrossSigningVerified() ? l.logger.log(`Own device ${t} already cross-signing verified`) : i = await this.crossSigningInfo.signDevice(e, m.DeviceInfo.fromStorage(d, t)), i) {
								const n = async ({
									shouldEmit: r = !1
								}) => {
									l.logger.info("Uploading signature for " + t);
									const s = await this.baseApis.uploadKeySignatures({
											[e]: {
												[t]: i
											}
										}),
										{
											failures: o
										} = s || {};
									if (Object.keys(o || []).length > 0) throw r && this.baseApis.emit(V.KeySignatureUploadFailure, o, "setDeviceVerification", n), new R.KeySignatureUploadError("Key upload failed", {
										failures: o
									})
								};
								await n({
									shouldEmit: !0
								})
							}
						}
						const h = m.DeviceInfo.fromStorage(d, t);
						return this.emit(V.DeviceVerificationChanged, e, t, h), h
					}
					findVerificationRequestDMInProgress(e) {
						return this.inRoomVerificationRequests.findRequestInProgress(e)
					}
					getVerificationRequestsToDeviceInProgress(e) {
						return this.toDeviceVerificationRequests.getRequestsInProgress(e)
					}
					requestVerificationDM(e, t) {
						const i = this.inRoomVerificationRequests.findRequestInProgress(t);
						if (i) return Promise.resolve(i);
						const n = new T.InRoomChannel(this.baseApis, t, e);
						return this.requestVerificationWithChannel(e, n, this.inRoomVerificationRequests)
					}
					requestVerification(e, t) {
						t || (t = Object.keys(this.deviceList.getRawStoredDevicesForUser(e)));
						const i = this.toDeviceVerificationRequests.findRequestInProgress(e, t);
						if (i) return Promise.resolve(i);
						const n = new I.ToDeviceChannel(this.baseApis, e, t, I.ToDeviceChannel.makeTransactionId());
						return this.requestVerificationWithChannel(e, n, this.toDeviceVerificationRequests)
					}
					async requestVerificationWithChannel(e, t, i) {
						let n = new k.VerificationRequest(t, this.verificationMethods, this.baseApis);
						t.transactionId && i.setRequestByChannel(t, n), await n.sendRequest();
						const r = i.getRequestByChannel(t);
						return r ? n = r : (l.logger.log("Crypto: adding new request to " + `requestsByTxnId with id ${t.transactionId} ${t.roomId}`), i.setRequestByChannel(t, n)), n
					}
					beginKeyVerification(e, t, i, n = null) {
						let r;
						if (n) {
							if (!(r = this.toDeviceVerificationRequests.getRequestBySenderAndTxnId(t, n))) throw new Error(`No request found for user ${t} with ` + `transactionId ${n}`)
						} else {
							n = I.ToDeviceChannel.makeTransactionId();
							const e = new I.ToDeviceChannel(this.baseApis, t, [i], n, i);
							r = new k.VerificationRequest(e, this.verificationMethods, this.baseApis), this.toDeviceVerificationRequests.setRequestBySenderAndTxnId(t, n, r)
						}
						return r.beginKeyVerification(e, {
							userId: t,
							deviceId: i
						})
					}
					async legacyDeviceVerification(e, t, i) {
						const n = I.ToDeviceChannel.makeTransactionId(),
							r = new I.ToDeviceChannel(this.baseApis, e, [t], n, t),
							s = new k.VerificationRequest(r, this.verificationMethods, this.baseApis);
						this.toDeviceVerificationRequests.setRequestBySenderAndTxnId(e, n, s);
						const o = s.beginKeyVerification(i, {
							userId: e,
							deviceId: t
						});
						return await Promise.race([o.verify(), s.waitFor(e => e.started)]), s
					}
					async getOlmSessionsForUser(e) {
						const t = this.getStoredDevicesForUser(e) || [],
							i = {};
						for (const n of t) {
							const e = n.getIdentityKey(),
								t = await this.olmDevice.getSessionInfoForDevice(e);
							i[n.deviceId] = {
								deviceIdKey: e,
								sessions: t
							}
						}
						return i
					}
					getEventSenderDeviceInfo(e) {
						const t = e.getSenderKey(),
							i = e.getWireContent().algorithm;
						if (!t || !i) return null;
						if (e.isKeySourceUntrusted()) return null;
						const n = this.deviceList.getDeviceByIdentityKey(i, t);
						if (null === n) return null;
						const r = e.getClaimedEd25519Key();
						return r ? r !== n.getFingerprint() ? (l.logger.warn("Event " + e.getId() + " claims ed25519 key " + r + " but sender device has key " + n.getFingerprint()), null) : n : (l.logger.warn("Event " + e.getId() + " claims no ed25519 key: cannot verify sending device"), null)
					}
					getEventEncryptionInfo(e) {
						var t, i;
						const n = {};
						if (n.senderKey = null !== (t = e.getSenderKey()) && void 0 !== t ? t : void 0, n.algorithm = e.getWireContent().algorithm, !n.senderKey || !n.algorithm) return n.encrypted = !1, n;
						n.encrypted = !0, e.isKeySourceUntrusted() ? n.authenticated = !1 : n.authenticated = !0, n.sender = null !== (i = this.deviceList.getDeviceByIdentityKey(n.algorithm, n.senderKey)) && void 0 !== i ? i : void 0;
						const r = e.getClaimedEd25519Key();
						return r || (l.logger.warn("Event " + e.getId() + " claims no ed25519 key: cannot verify sending device"), n.mismatchedSender = !0), n.sender && r !== n.sender.getFingerprint() && (l.logger.warn("Event " + e.getId() + " claims ed25519 key " + r + "but sender device has key " + n.sender.getFingerprint()), n.mismatchedSender = !0), n
					}
					forceDiscardSession(e) {
						const t = this.roomEncryptors.get(e);
						if (void 0 === t) throw new Error("Room not encrypted");
						if (void 0 === t.forceDiscardSession) throw new Error("Room encryption algorithm doesn't support session discarding");
						t.forceDiscardSession()
					}
					async setRoomEncryption(e, t, i) {
						if (!t.algorithm) return void l.logger.log("Ignoring setRoomEncryption with no algorithm");
						const n = this.roomList.getRoomEncryption(e);
						if (n && JSON.stringify(n) != JSON.stringify(t)) return void l.logger.error("Ignoring m.room.encryption event which requests a change of config in " + e);
						if (this.roomEncryptors.get(e)) return;
						let r = null;
						n || (r = this.roomList.setRoomEncryption(e, t));
						const s = p.ENCRYPTION_CLASSES.get(t.algorithm);
						if (!s) throw new Error("Unable to encrypt with " + t.algorithm);
						const o = new s({
							userId: this.userId,
							deviceId: this.deviceId,
							crypto: this,
							olmDevice: this.olmDevice,
							baseApis: this.baseApis,
							roomId: e,
							config: t
						});
						this.roomEncryptors.set(e, o), r && await r, this.lazyLoadMembers ? l.logger.log("Enabling encryption in " + e) : (l.logger.log("Enabling encryption in " + e + "; starting to track device lists for all users therein"), await this.trackRoomDevices(e), i || this.deviceList.refreshOutdatedDeviceLists())
					}
					trackRoomDevices(e) {
						const t = async () => {
							if (!this.roomEncryptors.has(e)) return;
							const t = this.clientStore.getRoom(e);
							if (!t) throw new Error(`Unable to start tracking devices in unknown room ${e}`);
							l.logger.log(`Starting to track devices for room ${e} ...`), (await t.getEncryptionTargetMembers()).forEach(e => {
								this.deviceList.startTrackingDeviceList(e.userId)
							})
						};
						let i = this.roomDeviceTrackingState[e];
						return i || (i = t(), this.roomDeviceTrackingState[e] = i.catch(t => {
							throw delete this.roomDeviceTrackingState[e], t
						})), i
					}
					ensureOlmSessionsForUsers(e, t) {
						const i = {};
						for (const n of e) {
							i[n] = [];
							const e = this.getStoredDevicesForUser(n) || [];
							for (const t of e) {
								t.getIdentityKey() != this.olmDevice.deviceCurve25519Key && (t.verified != B.BLOCKED && i[n].push(t))
							}
						}
						return u.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, i, t)
					}
					async exportRoomKeys() {
						const e = [];
						return await this.cryptoStore.doTxn("readonly", [b.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS], t => {
							this.cryptoStore.getAllEndToEndInboundGroupSessions(t, t => {
								if (null === t) return;
								const i = this.olmDevice.exportInboundGroupSession(t.senderKey, t.sessionId, t.sessionData);
								delete i.first_known_index, i.algorithm = u.MEGOLM_ALGORITHM, e.push(i)
							})
						}), e
					}
					importRoomKeys(e, t = {}) {
						let i = 0,
							n = 0;
						const r = e.length;

						function s() {
							var e;
							null === (e = t.progressCallback) || void 0 === e || e.call(t, {
								stage: "load_keys",
								successes: i,
								failures: n,
								total: r
							})
						}
						return Promise.all(e.map(e => {
							if (!e.room_id || !e.algorithm) return l.logger.warn("ignoring room key entry with missing fields", e), n++, t.progressCallback && s(), null;
							return this.getRoomDecryptor(e.room_id, e.algorithm).importRoomKey(e, t).finally(() => {
								i++, t.progressCallback && s()
							})
						})).then()
					}
					countSessionsNeedingBackup() {
						return this.backupManager.countSessionsNeedingBackup()
					}
					prepareToEncrypt(e) {
						const t = this.roomEncryptors.get(e.roomId);
						t && t.prepareToEncrypt(e)
					}
					async encryptEvent(e, t) {
						if (!t) throw new Error("Cannot send encrypted messages in unknown rooms");
						const i = e.getRoomId(),
							n = this.roomEncryptors.get(i);
						if (!n) throw new Error("Room was previously configured to use encryption, but is no longer. Perhaps the homeserver is hiding the configuration event.");
						this.roomDeviceTrackingState[i] || this.trackRoomDevices(i), await this.roomDeviceTrackingState[i];
						let r = e.getContent();
						const s = r["m.relates_to"];
						s && delete(r = Object.assign({}, r))["m.relates_to"];
						const o = r["io.element.performance_metrics"];
						o && delete(r = Object.assign({}, r))["io.element.performance_metrics"];
						const a = await n.encryptMessage(t, e.getType(), r);
						s && (a["m.relates_to"] = s), o && (a["io.element.performance_metrics"] = o), e.makeEncrypted("m.room.encrypted", a, this.olmDevice.deviceCurve25519Key, this.olmDevice.deviceEd25519Key)
					}
					async decryptEvent(e) {
						if (e.isRedacted()) {
							const t = new D.MatrixEvent(function(e) {
									for (var t = 1; t < arguments.length; t++) {
										var i = null != arguments[t] ? arguments[t] : {};
										t % 2 ? F(Object(i), !0).forEach((function(t) {
											(0, s.default)(e, t, i[t])
										})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : F(Object(i)).forEach((function(t) {
											Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
										}))
									}
									return e
								}({
									room_id: e.getRoomId()
								}, e.getUnsigned().redacted_because)),
								i = await this.decryptEvent(t);
							return {
								clearEvent: {
									room_id: e.getRoomId(),
									type: "m.room.message",
									content: {},
									unsigned: {
										redacted_because: i.clearEvent
									}
								}
							}
						} {
							const t = e.getWireContent();
							return this.getRoomDecryptor(e.getRoomId(), t.algorithm).decryptEvent(e)
						}
					}
					async handleDeviceListChanges(e, t) {
						e.oldSyncToken && await this.evalDeviceListChanges(t)
					}
					requestRoomKey(e, t, i = !1) {
						return this.outgoingRoomKeyRequestManager.queueRoomKeyRequest(e, t, i).then(() => {
							this.sendKeyRequestsImmediately && this.outgoingRoomKeyRequestManager.sendQueuedRequests()
						}).catch(e => {
							l.logger.error("Error requesting key for event", e)
						})
					}
					cancelRoomKeyRequest(e) {
						this.outgoingRoomKeyRequestManager.cancelRoomKeyRequest(e).catch(e => {
							l.logger.warn("Error clearing pending room key requests", e)
						})
					}
					async cancelAndResendAllOutgoingKeyRequests() {
						await this.outgoingRoomKeyRequestManager.cancelAndResendAllOutgoingRequests()
					}
					async onCryptoEvent(e) {
						const t = e.getRoomId(),
							i = e.getContent();
						try {
							await this.setRoomEncryption(t, i, !0)
						} catch (n) {
							l.logger.error(`Error configuring encryption in room ${t}`, n)
						}
					}
					async onSyncWillProcess(e) {
						e.oldSyncToken || (l.logger.log("Initial sync performed - resetting device tracking state"), this.deviceList.stopTrackingAllDeviceLists(), this.deviceList.startTrackingDeviceList(this.userId), this.roomDeviceTrackingState = {}), this.sendKeyRequestsImmediately = !1
					}
					async onSyncCompleted(e) {
						var t;
						this.deviceList.setSyncToken(null !== (t = e.nextSyncToken) && void 0 !== t ? t : null), this.deviceList.saveIfDirty(), this.deviceList.startTrackingDeviceList(this.userId), this.deviceList.refreshOutdatedDeviceLists(), e.catchingUp || (this.maybeUploadOneTimeKeys(), this.processReceivedRoomKeyRequests(), this.outgoingRoomKeyRequestManager.sendQueuedRequests(), this.sendKeyRequestsImmediately = !0)
					}
					async evalDeviceListChanges(e) {
						if (e.changed && Array.isArray(e.changed) && e.changed.forEach(e => {
								this.deviceList.invalidateUserDeviceList(e)
							}), e.left && Array.isArray(e.left) && e.left.length) {
							const t = new Set(await this.getTrackedE2eUsers());
							e.left.forEach(e => {
								t.has(e) || this.deviceList.stopTrackingDeviceList(e)
							})
						}
					}
					async getTrackedE2eUsers() {
						const e = [];
						for (const t of this.getTrackedE2eRooms()) {
							const i = await t.getEncryptionTargetMembers();
							for (const t of i) e.push(t.userId)
						}
						return e
					}
					getTrackedE2eRooms() {
						return this.clientStore.getRooms().filter(e => {
							if (!this.roomEncryptors.get(e.roomId)) return !1;
							if (!this.roomDeviceTrackingState[e.roomId]) return !1;
							const t = e.getMyMembership();
							return "join" === t || "invite" === t
						})
					}
					async encryptAndSendToDevices(e, t) {
						const i = {
							eventType: a.EventType.RoomMessageEncrypted,
							batch: []
						};
						try {
							await Promise.all(e.map(async ({
								userId: e,
								deviceInfo: n
							}) => {
								const r = n.deviceId,
									s = {
										algorithm: u.OLM_ALGORITHM,
										sender_key: this.olmDevice.deviceCurve25519Key,
										ciphertext: {}
									};
								i.batch.push({
									userId: e,
									deviceId: r,
									payload: s
								}), await u.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, {
									[e]: [n]
								}), await u.encryptMessageForDevice(s.ciphertext, this.userId, this.deviceId, this.olmDevice, e, n, t)
							})), i.batch = i.batch.filter(e => Object.keys(e.payload.ciphertext).length > 0 || (l.logger.log(`No ciphertext for device ${e.userId}:${e.deviceId}: pruning`), !1));
							try {
								await this.baseApis.queueToDevice(i)
							} catch (n) {
								throw l.logger.error("sendToDevice failed", n), n
							}
						} catch (n) {
							throw l.logger.error("encryptAndSendToDevices promises failed", n), n
						}
					}
					onRoomKeyEvent(e) {
						const t = e.getContent();
						t.room_id && t.algorithm ? (this.backupManager.checkedForBackup || this.backupManager.checkAndStart(), this.getRoomDecryptor(t.room_id, t.algorithm).onRoomKeyEvent(e)) : l.logger.error("key event is missing fields")
					}
					onRoomKeyWithheldEvent(e) {
						const t = e.getContent();
						if (!(("m.no_olm" === t.code || t.room_id && t.session_id) && t.algorithm && t.sender_key)) return void l.logger.error("key withheld event is missing fields");
						l.logger.info(`Got room key withheld event from ${e.getSender()} (${t.sender_key}) ` + `for ${t.algorithm}/${t.room_id}/${t.session_id} ` + `with reason ${t.code} (${t.reason})`);
						const i = this.getRoomDecryptor(t.room_id, t.algorithm);
						if (i.onRoomKeyWithheldEvent && i.onRoomKeyWithheldEvent(e), !t.room_id) {
							const e = this.getRoomDecryptors(t.algorithm);
							for (const i of e) i.retryDecryptionFromSender(t.sender_key)
						}
					}
					onKeyVerificationMessage(e) {
						if (!I.ToDeviceChannel.validateEvent(e, this.baseApis)) return;
						this.handleVerificationEvent(e, this.toDeviceVerificationRequests, e => {
							if (!I.ToDeviceChannel.canCreateRequest(I.ToDeviceChannel.getEventType(e))) return;
							const t = e.getContent(),
								i = t && t.from_device;
							if (!i) return;
							const n = e.getSender(),
								r = new I.ToDeviceChannel(this.baseApis, n, [i]);
							return new k.VerificationRequest(r, this.verificationMethods, this.baseApis)
						})
					}
					async handleVerificationEvent(e, t, i, n = !0) {
						if (e.isSending() && e.status != D.EventStatus.SENT) {
							let t, i;
							try {
								await new Promise((n, r) => {
									t = n, i = () => {
										e.status == D.EventStatus.CANCELLED && r(new Error("Event status set to CANCELLED."))
									}, e.once(D.MatrixEventEvent.LocalEventIdReplaced, t), e.on(D.MatrixEventEvent.Status, i)
								})
							} catch (o) {
								return void l.logger.error("error while waiting for the verification event to be sent: ", o)
							} finally {
								e.removeListener(D.MatrixEventEvent.LocalEventIdReplaced, t), e.removeListener(D.MatrixEventEvent.Status, i)
							}
						}
						let r = t.getRequest(e),
							s = !1;
						if (!r) {
							if (!(r = i(e))) return void l.logger.log("Crypto: could not find VerificationRequest for " + `${e.getType()}, and could not create one, so ignoring.`);
							s = !0, t.setRequest(e, r)
						}
						e.setVerificationRequest(r);
						try {
							await r.channel.handleEvent(e, r, n)
						} catch (o) {
							l.logger.error("error while handling verification event", o)
						}
						s && !r.initiatedByMe && !r.invalid && !r.observeOnly && this.baseApis.emit(V.VerificationRequest, r)
					}
					async onToDeviceBadEncrypted(e) {
						const t = e.getWireContent(),
							i = e.getSender(),
							n = t.algorithm,
							r = t.sender_key,
							s = () => {
								const e = this.getRoomDecryptors(u.MEGOLM_ALGORITHM);
								for (const t of e) t.retryDecryptionFromSender(r)
							};
						if (void 0 === i || void 0 === r || void 0 === r) return;
						this.lastNewSessionForced[i] = this.lastNewSessionForced[i] || {};
						const o = this.lastNewSessionForced[i][r] || 0;
						if (o + $ > Date.now()) return l.logger.debug("New session already forced with device " + i + ":" + r + " at " + o + ": not forcing another"), await this.olmDevice.recordSessionProblem(r, "wedged", !0), void s();
						let a = this.deviceList.getDeviceByIdentityKey(n, r);
						if (!(a || (await this.downloadKeys([i], !1), a = this.deviceList.getDeviceByIdentityKey(n, r)))) return l.logger.info("Couldn't find device for identity key " + r + ": not re-establishing session"), await this.olmDevice.recordSessionProblem(r, "wedged", !1), void s();
						const d = {};
						d[i] = [a], await u.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, d, !0), this.lastNewSessionForced[i][r] = Date.now();
						const c = {
							algorithm: u.OLM_ALGORITHM,
							sender_key: this.olmDevice.deviceCurve25519Key,
							ciphertext: {}
						};
						await u.encryptMessageForDevice(c.ciphertext, this.userId, this.deviceId, this.olmDevice, i, a, {
							type: "m.dummy"
						}), await this.olmDevice.recordSessionProblem(r, "wedged", !0), s(), await this.baseApis.sendToDevice("m.room.encrypted", {
							[i]: {
								[a.deviceId]: c
							}
						});
						const h = await this.outgoingRoomKeyRequestManager.getOutgoingSentRoomKeyRequest(i, a.deviceId);
						for (const l of h) this.requestRoomKey(l.requestBody, l.recipients, !0)
					}
					onRoomMembership(e, t, i) {
						const n = t.roomId,
							r = this.roomEncryptors.get(n);
						if (r) {
							var s;
							if (n in this.roomDeviceTrackingState) "join" == t.membership ? (l.logger.log("Join event for " + t.userId + " in " + n), this.deviceList.startTrackingDeviceList(t.userId)) : "invite" == t.membership && null !== (s = this.clientStore.getRoom(n)) && void 0 !== s && s.shouldEncryptForInvitedMembers() && (l.logger.log("Invite event for " + t.userId + " in " + n), this.deviceList.startTrackingDeviceList(t.userId));
							r.onRoomMembership(e, t, i)
						}
					}
					onRoomKeyRequestEvent(e) {
						const t = e.getContent();
						if ("request" === t.action) {
							const t = new H(e);
							this.receivedRoomKeyRequests.push(t)
						} else if ("request_cancellation" === t.action) {
							const t = new z(e);
							this.receivedRoomKeyRequestCancellations.push(t)
						}
					}
					async processReceivedRoomKeyRequests() {
						if (!this.processingRoomKeyRequests) {
							this.processingRoomKeyRequests = !0;
							try {
								const e = this.receivedRoomKeyRequests;
								this.receivedRoomKeyRequests = [];
								const t = this.receivedRoomKeyRequestCancellations;
								this.receivedRoomKeyRequestCancellations = [], await Promise.all(e.map(e => this.processReceivedRoomKeyRequest(e))), await Promise.all(t.map(e => this.processReceivedRoomKeyRequestCancellation(e)))
							} catch (e) {
								l.logger.error(`Error processing room key requsts: ${e}`)
							} finally {
								this.processingRoomKeyRequests = !1
							}
						}
					}
					async processReceivedRoomKeyRequest(e) {
						const t = e.userId,
							i = e.deviceId,
							n = e.requestBody,
							r = n.room_id,
							s = n.algorithm;
						if (l.logger.log(`m.room_key_request from ${t}:${i}` + ` for ${r} / ${n.session_id} (id ${e.requestId})`), t !== this.userId) {
							if (!this.roomEncryptors.get(r)) return void l.logger.debug(`room key request for unencrypted room ${r}`);
							const e = this.roomEncryptors.get(r),
								s = this.deviceList.getStoredDevice(t, i);
							if (!s) return void l.logger.debug(`Ignoring keyshare for unknown device ${t}:${i}`);
							try {
								await e.reshareKeyWithDevice(n.sender_key, n.session_id, t, s)
							} catch (a) {
								l.logger.warn("Failed to re-share keys for session " + n.session_id + " with device " + t + ":" + s.deviceId, a)
							}
							return
						}
						if (i === this.deviceId) return void l.logger.log("Ignoring room key request from ourselves");
						if (!this.roomDecryptors.has(r)) return void l.logger.log(`room key request for unencrypted room ${r}`);
						const o = this.roomDecryptors.get(r).get(s);
						if (o)
							if (await o.hasKeysForKeyRequest(e)) {
								if (e.share = () => {
										o.shareKeysWithDevice(e)
									}, this.checkDeviceTrust(t, i).isVerified()) return l.logger.log("device is already verified: sharing keys"), void e.share();
								this.emit(V.RoomKeyRequest, e)
							} else l.logger.log(`room key request for unknown session ${r} / ` + n.session_id);
						else l.logger.log(`room key request for unknown alg ${s} in room ${r}`)
					}
					async processReceivedRoomKeyRequestCancellation(e) {
						l.logger.log(`m.room_key_request cancellation for ${e.userId}:` + `${e.deviceId} (id ${e.requestId})`), this.emit(V.RoomKeyRequestCancellation, e)
					}
					getRoomDecryptor(e, t) {
						let i, n;
						if (e && ((i = this.roomDecryptors.get(e)) || (i = new Map, this.roomDecryptors.set(e, i)), n = i.get(t))) return n;
						const r = p.DECRYPTION_CLASSES.get(t);
						if (!r) throw new p.DecryptionError("UNKNOWN_ENCRYPTION_ALGORITHM", 'Unknown encryption algorithm "' + t + '".');
						return n = new r({
							userId: this.userId,
							crypto: this,
							olmDevice: this.olmDevice,
							baseApis: this.baseApis,
							roomId: null != e ? e : void 0
						}), i && i.set(t, n), n
					}
					getRoomDecryptors(e) {
						const t = [];
						for (const i of this.roomDecryptors.values()) i.has(e) && t.push(i.get(e));
						return t
					}
					async signObject(e) {
						const t = e.signatures || {},
							i = e.unsigned;
						delete e.signatures, delete e.unsigned, t[this.userId] = t[this.userId] || {}, t[this.userId]["ed25519:" + this.deviceId] = await this.olmDevice.sign(o.default.stringify(e)), e.signatures = t, void 0 !== i && (e.unsigned = i)
					}
				}

				function G(e) {
					if ("string" != typeof e || e.indexOf(",") < 0) return null;
					const t = Uint8Array.from(e.split(","), e => parseInt(e));
					return u.encodeBase64(t)
				}
				t.Crypto = W;
				class H {
					constructor(e) {
						(0, s.default)(this, "userId", void 0), (0, s.default)(this, "deviceId", void 0), (0, s.default)(this, "requestId", void 0), (0, s.default)(this, "requestBody", void 0), (0, s.default)(this, "share", void 0);
						const t = e.getContent();
						this.userId = e.getSender(), this.deviceId = t.requesting_device_id, this.requestId = t.request_id, this.requestBody = t.body || {}, this.share = () => {
							throw new Error("don't know how to share keys for this request yet")
						}
					}
				}
				t.IncomingRoomKeyRequest = H;
				class z {
					constructor(e) {
						(0, s.default)(this, "userId", void 0), (0, s.default)(this, "deviceId", void 0), (0, s.default)(this, "requestId", void 0);
						const t = e.getContent();
						this.userId = e.getSender(), this.deviceId = t.requesting_device_id, this.requestId = t.request_id
					}
				}
			}).call(this, i("./node_modules/webpack/buildin/global.js"), i("./node_modules/buffer/index.js").Buffer)
		},
		"./node_modules/matrix-js-sdk/lib/crypto/key_passphrase.js": function(e, t, i) {
			"use strict";
			(function(e) {
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.deriveKey = a, t.keyFromAuthData = function(t, i) {
					if (!e.Olm) throw new Error("Olm is not available");
					if (!t.private_key_salt || !t.private_key_iterations) throw new Error("Salt and/or iterations not found: this backup cannot be restored with a passphrase");
					return a(i, t.private_key_salt, t.private_key_iterations, t.private_key_bits || o)
				}, t.keyFromPassphrase = async function(t) {
					if (!e.Olm) throw new Error("Olm is not available");
					const i = (0, n.randomString)(32);
					return {
						key: await a(t, i, s, o),
						salt: i,
						iterations: s
					}
				};
				var n = i("./node_modules/matrix-js-sdk/lib/randomstring.js"),
					r = i("./node_modules/matrix-js-sdk/lib/crypto/crypto.js");
				const s = 5e5,
					o = 256;
				async function a(e, t, i, n = o) {
					if (!r.subtleCrypto || !r.TextEncoder) throw new Error("Password-based backup is not available on this platform");
					const s = await r.subtleCrypto.importKey("raw", (new r.TextEncoder).encode(e), {
							name: "PBKDF2"
						}, !1, ["deriveBits"]),
						a = await r.subtleCrypto.deriveBits({
							name: "PBKDF2",
							salt: (new r.TextEncoder).encode(t),
							iterations: i,
							hash: "SHA-512"
						}, s, n);
					return new Uint8Array(a)
				}
			}).call(this, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/crypto/olmlib.js": function(e, t, i) {
			"use strict";
			(function(e, n) {
				var r = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.OLM_ALGORITHM = t.MEGOLM_BACKUP_ALGORITHM = t.MEGOLM_ALGORITHM = void 0, t.decodeBase64 = function(e) {
					return n.from(e, "base64")
				}, t.encodeBase64 = p, t.encodeUnpaddedBase64 = function(e) {
					return p(e).replace(/=+$/g, "")
				}, t.encryptMessageForDevice = async function(e, t, i, n, r, s, o) {
					const d = s.getIdentityKey(),
						l = await n.getSessionIdForDevice(d);
					if (null === l) return void a.logger.log("[olmlib.encryptMessageForDevice] Unable to find Olm session for device " + `${r}:${s.deviceId}`);
					a.logger.log(`[olmlib.encryptMessageForDevice] Using Olm session ${l} for device ` + `${r}:${s.deviceId}`);
					const c = {
						sender: t,
						sender_device: i,
						keys: {
							ed25519: n.deviceEd25519Key
						},
						recipient: r,
						recipient_keys: {
							ed25519: s.getFingerprint()
						}
					};
					Object.assign(c, o), e[d] = await n.encryptMessage(d, l, JSON.stringify(c))
				}, t.ensureOlmSessionsForDevices = async function(e, t, i, n = !1, r, s, o = a.logger) {
					const d = [],
						l = {},
						c = {};
					for (const [, a] of Object.entries(i))
						for (const t of a) {
							const i = t.getIdentityKey();
							i !== e.deviceCurve25519Key && (e.sessionsInProgress[i] || (e.sessionsInProgress[i] = new Promise(t => {
								c[i] = n => {
									delete e.sessionsInProgress[i], t(n)
								}
							})))
						}
					for (const [a, h] of Object.entries(i)) {
						l[a] = {};
						for (const t of h) {
							const i = t.deviceId,
								r = t.getIdentityKey();
							if (r === e.deviceCurve25519Key) {
								o.info("Attempted to start session with ourself! Ignoring"), l[a][i] = {
									device: t,
									sessionId: null
								};
								continue
							}
							const s = `for ${r} (${a}:${i})`,
								u = await e.getSessionIdForDevice(r, !!c[r], o);
							null !== u && c[r] && c[r](), (null === u || n) && (n ? o.info(`Forcing new Olm session ${s}`) : o.info(`Making new Olm session ${s}`), d.push([a, i])), l[a][i] = {
								device: t,
								sessionId: u
							}
						}
					}
					if (0 === d.length) return l;
					let u, m = `one-time keys for ${d.length} devices`;
					try {
						o.debug(`Claiming ${m}`), u = await t.claimOneTimeKeys(d, "signed_curve25519", r), o.debug(`Claimed ${m}`)
					} catch (f) {
						for (const e of Object.values(c)) e();
						throw o.log(`Failed to claim ${m}`, f, d), f
					}
					s && "failures" in u && s.push(...Object.keys(u.failures));
					const p = u.one_time_keys || {},
						g = [];
					for (const [a, v] of Object.entries(i)) {
						const t = p[a] || {};
						for (const i of v) {
							const r = i.deviceId,
								s = i.getIdentityKey();
							if (s === e.deviceCurve25519Key) continue;
							if (l[a][r].sessionId && !n) continue;
							const d = t[r] || {};
							let u = null;
							for (const e in d) 0 === e.indexOf("signed_curve25519:") && (u = d[e]);
							u ? g.push(h(e, u, a, i).then(e => {
								c[s] && c[s](null != e ? e : void 0), l[a][r].sessionId = e
							}, e => {
								throw c[s] && c[s](), e
							})) : (o.warn("No one-time keys (alg=signed_curve25519) " + `for device ${a}:${r}`), c[s] && c[s]())
						}
					}
					return m = `Olm sessions for ${g.length} devices`, o.debug(`Starting ${m}`), await Promise.all(g), o.debug(`Started ${m}`), l
				}, t.getExistingOlmSessions = async function(e, t, i) {
					const n = {},
						r = {},
						s = [];
					for (const [o, a] of Object.entries(i))
						for (const t of a) {
							const i = t.deviceId,
								a = t.getIdentityKey();
							s.push((async () => {
								const s = await e.getSessionIdForDevice(a, !0);
								null === s ? (n[o] = n[o] || [], n[o].push(t)) : (r[o] = r[o] || {}, r[o][i] = {
									device: t,
									sessionId: s
								})
							})())
						}
					return await Promise.all(s), [n, r]
				}, t.isOlmEncrypted = function(e) {
					if (!e.getSenderKey()) return a.logger.error("Event has no sender key (not encrypted?)"), !1;
					if (e.getWireType() !== d.EventType.RoomMessageEncrypted || !["m.olm.v1.curve25519-aes-sha2"].includes(e.getWireContent().algorithm)) return a.logger.error("Event was not encrypted using an appropriate algorithm"), !1;
					return !0
				}, t.pkSign = function(t, i, n, r) {
					let s = !1;
					if (i instanceof Uint8Array) {
						const t = new e.Olm.PkSigning;
						r = t.init_with_seed(i), i = t, s = !0
					}
					const a = t.signatures || {};
					delete t.signatures;
					const d = t.unsigned;
					t.unsigned && delete t.unsigned;
					try {
						const e = a[n] || {};
						return a[n] = e, e["ed25519:" + r] = i.sign(o.default.stringify(t))
					} finally {
						t.signatures = a, d && (t.unsigned = d), s && i.free()
					}
				}, t.pkVerify = function(t, i, n) {
					const r = "ed25519:" + i;
					if (!(t.signatures && t.signatures[n] && t.signatures[n][r])) throw new Error("No signature");
					const s = t.signatures[n][r],
						a = new e.Olm.Utility,
						d = t.signatures;
					delete t.signatures;
					const l = t.unsigned;
					t.unsigned && delete t.unsigned;
					try {
						a.ed25519_verify(i, o.default.stringify(t), s)
					} finally {
						t.signatures = d, l && (t.unsigned = l), a.free()
					}
				}, t.verifySignature = m;
				var s, o = r(i("./node_modules/another-json/another-json.js")),
					a = i("./node_modules/matrix-js-sdk/lib/logger.js"),
					d = i("./node_modules/matrix-js-sdk/lib/@types/event.js");
				! function(e) {
					e.Olm = "m.olm.v1.curve25519-aes-sha2", e.Megolm = "m.megolm.v1.aes-sha2", e.MegolmBackup = "m.megolm_backup.v1.curve25519-aes-sha2"
				}(s || (s = {}));
				const l = s.Olm;
				t.OLM_ALGORITHM = l;
				const c = s.Megolm;
				t.MEGOLM_ALGORITHM = c;
				const u = s.MegolmBackup;
				async function h(e, t, i, n) {
					const r = n.deviceId;
					try {
						await m(e, t, i, r, n.getFingerprint())
					} catch (o) {
						return a.logger.error("Unable to verify signature on one-time key for device " + i + ":" + r + ":", o), null
					}
					let s;
					try {
						s = await e.createOutboundSession(n.getIdentityKey(), t.key)
					} catch (o) {
						return a.logger.error("Error starting olm session with device " + i + ":" + r + ": " + o), null
					}
					return a.logger.log("Started new olm sessionid " + s + " for device " + i + ":" + r), s
				}
				async function m(e, t, i, n, r) {
					const s = "ed25519:" + n,
						a = ((t.signatures || {})[i] || {})[s];
					if (!a) throw Error("No signature");
					const d = Object.assign({}, t);
					"unsigned" in d && delete d.unsigned, delete d.signatures;
					const l = o.default.stringify(d);
					e.verifySignature(r, l, a)
				}

				function p(e) {
					return n.from(e).toString("base64")
				}
				t.MEGOLM_BACKUP_ALGORITHM = u
			}).call(this, i("./node_modules/webpack/buildin/global.js"), i("./node_modules/buffer/index.js").Buffer)
		},
		"./node_modules/matrix-js-sdk/lib/crypto/recoverykey.js": function(e, t, i) {
			"use strict";
			(function(e, n) {
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.decodeRecoveryKey = function(e) {
					const t = r.decode(e.replace(/ /g, ""));
					let i = 0;
					for (const n of t) i ^= n;
					if (0 !== i) throw new Error("Incorrect parity");
					for (let n = 0; n < o.length; ++n)
						if (t[n] !== o[n]) throw new Error("Incorrect prefix");
					if (t.length !== o.length + n.Olm.PRIVATE_KEY_LENGTH + 1) throw new Error("Incorrect length");
					return Uint8Array.from(t.slice(o.length, o.length + n.Olm.PRIVATE_KEY_LENGTH))
				}, t.encodeRecoveryKey = function(t) {
					var i;
					const n = e.alloc(o.length + t.length + 1);
					n.set(o, 0), n.set(t, o.length);
					let s = 0;
					for (let e = 0; e < n.length - 1; ++e) s ^= n[e];
					n[n.length - 1] = s;
					const a = r.encode(n);
					return null === (i = a.match(/.{1,4}/g)) || void 0 === i ? void 0 : i.join(" ")
				};
				var r = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = s(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var o in e)
						if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
							var a = r ? Object.getOwnPropertyDescriptor(e, o) : null;
							a && (a.get || a.set) ? Object.defineProperty(n, o, a) : n[o] = e[o]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/bs58/index.js"));

				function s(e) {
					if ("function" != typeof WeakMap) return null;
					var t = new WeakMap,
						i = new WeakMap;
					return (s = function(e) {
						return e ? i : t
					})(e)
				}
				const o = [139, 1]
			}).call(this, i("./node_modules/buffer/index.js").Buffer, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/crypto/store/indexeddb-crypto-store-backend.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.VERSION = t.Backend = void 0, t.upgradeDatabase = function(e, t) {
				s.logger.log(`Upgrading IndexedDBCryptoStore from version ${t}` + ` to ${c}`), l.forEach((i, n) => {
					t <= n && i(e)
				})
			};
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = a(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/utils.js"));

			function a(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (a = function(e) {
					return e ? i : t
				})(e)
			}
			const d = !1;
			t.Backend = class {
				constructor(e) {
					this.db = e, (0, r.default)(this, "nextTxnId", 0), e.onversionchange = () => {
						s.logger.log(`versionchange for indexeddb ${this.db.name}: closing`), e.close()
					}
				}
				async startup() {
					return this
				}
				async deleteAllData() {
					throw Error("This is not implemented, call IDBFactory::deleteDatabase(dbName) instead.")
				}
				getOrAddOutgoingRoomKeyRequest(e) {
					const t = e.requestBody;
					return new Promise((i, n) => {
						const r = this.db.transaction("outgoingRoomKeyRequests", "readwrite");
						r.onerror = n, this._getOutgoingRoomKeyRequest(r, t, n => {
							if (n) return s.logger.log("already have key request outstanding for " + `${t.room_id} / ${t.session_id}: ` + "not sending another"), void i(n);
							s.logger.log(`enqueueing key request for ${t.room_id} / ` + t.session_id), r.oncomplete = () => {
								i(e)
							}, r.objectStore("outgoingRoomKeyRequests").add(e)
						})
					})
				}
				getOutgoingRoomKeyRequest(e) {
					return new Promise((t, i) => {
						const n = this.db.transaction("outgoingRoomKeyRequests", "readonly");
						n.onerror = i, this._getOutgoingRoomKeyRequest(n, e, e => {
							t(e)
						})
					})
				}
				_getOutgoingRoomKeyRequest(e, t, i) {
					const n = e.objectStore("outgoingRoomKeyRequests").index("session").openCursor([t.room_id, t.session_id]);
					n.onsuccess = () => {
						const e = n.result;
						if (!e) return void i(null);
						const r = e.value;
						o.deepCompare(r.requestBody, t) ? i(r) : e.continue()
					}
				}
				getOutgoingRoomKeyRequestByState(e) {
					if (0 === e.length) return Promise.resolve(null);
					let t, i = 0;
					const n = this.db.transaction("outgoingRoomKeyRequests", "readonly"),
						r = n.objectStore("outgoingRoomKeyRequests"),
						s = e[i];
					return r.index("state").openCursor(s).onsuccess = function n() {
						const r = this.result;
						if (r) return void(t = r.value);
						if (++i >= e.length) return;
						const s = e[i];
						this.source.openCursor(s).onsuccess = n
					}, h(n).then(() => t)
				}
				getAllOutgoingRoomKeyRequestsByState(e) {
					return new Promise((t, i) => {
						const n = this.db.transaction("outgoingRoomKeyRequests", "readonly").objectStore("outgoingRoomKeyRequests").index("state").getAll(e);
						n.onsuccess = () => t(n.result), n.onerror = () => i(n.error)
					})
				}
				getOutgoingRoomKeyRequestsByTarget(e, t, i) {
					let n = 0;
					const r = [];
					const s = this.db.transaction("outgoingRoomKeyRequests", "readonly"),
						o = s.objectStore("outgoingRoomKeyRequests"),
						a = i[n];
					return o.index("state").openCursor(a).onsuccess = function s() {
						const o = this.result;
						if (o) {
							const i = o.value;
							i.recipients.some(i => i.userId === e && i.deviceId === t) && r.push(i), o.continue()
						} else {
							if (++n >= i.length) return;
							const e = i[n];
							this.source.openCursor(e).onsuccess = s
						}
					}, h(s).then(() => r)
				}
				updateOutgoingRoomKeyRequest(e, t, i) {
					let n = null;
					const r = this.db.transaction("outgoingRoomKeyRequests", "readwrite");
					return r.objectStore("outgoingRoomKeyRequests").openCursor(e).onsuccess = function() {
						const e = this.result;
						if (!e) return;
						const r = e.value;
						r.state == t ? (Object.assign(r, i), e.update(r), n = r) : s.logger.warn(`Cannot update room key request from ${t} ` + `as it was already updated to ${r.state}`)
					}, h(r).then(() => n)
				}
				deleteOutgoingRoomKeyRequest(e, t) {
					const i = this.db.transaction("outgoingRoomKeyRequests", "readwrite"),
						n = i.objectStore("outgoingRoomKeyRequests").openCursor(e);
					return n.onsuccess = () => {
						const e = n.result;
						if (!e) return;
						const i = e.value;
						i.state == t ? e.delete() : s.logger.warn(`Cannot delete room key request in state ${i.state} ` + `(expected ${t})`)
					}, h(i)
				}
				getAccount(e, t) {
					const i = e.objectStore("account").get("-");
					i.onsuccess = function() {
						try {
							t(i.result || null)
						} catch (n) {
							u(e, n)
						}
					}
				}
				storeAccount(e, t) {
					e.objectStore("account").put(t, "-")
				}
				getCrossSigningKeys(e, t) {
					const i = e.objectStore("account").get("crossSigningKeys");
					i.onsuccess = function() {
						try {
							t(i.result || null)
						} catch (n) {
							u(e, n)
						}
					}
				}
				getSecretStorePrivateKey(e, t, i) {
					const n = e.objectStore("account").get(`ssss_cache:${i}`);
					n.onsuccess = function() {
						try {
							t(n.result || null)
						} catch (i) {
							u(e, i)
						}
					}
				}
				storeCrossSigningKeys(e, t) {
					e.objectStore("account").put(t, "crossSigningKeys")
				}
				storeSecretStorePrivateKey(e, t, i) {
					e.objectStore("account").put(i, `ssss_cache:${t}`)
				}
				countEndToEndSessions(e, t) {
					const i = e.objectStore("sessions").count();
					i.onsuccess = function() {
						try {
							t(i.result)
						} catch (n) {
							u(e, n)
						}
					}
				}
				getEndToEndSessions(e, t, i) {
					const n = t.objectStore("sessions").index("deviceKey").openCursor(e),
						r = {};
					n.onsuccess = function() {
						const e = n.result;
						if (e) r[e.value.sessionId] = {
							session: e.value.session,
							lastReceivedMessageTs: e.value.lastReceivedMessageTs
						}, e.continue();
						else try {
							i(r)
						} catch (s) {
							u(t, s)
						}
					}
				}
				getEndToEndSession(e, t, i, n) {
					const r = i.objectStore("sessions").get([e, t]);
					r.onsuccess = function() {
						try {
							r.result ? n({
								session: r.result.session,
								lastReceivedMessageTs: r.result.lastReceivedMessageTs
							}) : n(null)
						} catch (e) {
							u(i, e)
						}
					}
				}
				getAllEndToEndSessions(e, t) {
					const i = e.objectStore("sessions").openCursor();
					i.onsuccess = function() {
						try {
							const e = i.result;
							e ? (t(e.value), e.continue()) : t(null)
						} catch (n) {
							u(e, n)
						}
					}
				}
				storeEndToEndSession(e, t, i, n) {
					n.objectStore("sessions").put({
						deviceKey: e,
						sessionId: t,
						session: i.session,
						lastReceivedMessageTs: i.lastReceivedMessageTs
					})
				}
				async storeEndToEndSessionProblem(e, t, i) {
					const n = this.db.transaction("session_problems", "readwrite");
					n.objectStore("session_problems").put({
						deviceKey: e,
						type: t,
						fixed: i,
						time: Date.now()
					}), await h(n)
				}
				async getEndToEndSessionProblem(e, t) {
					let i = null;
					const n = this.db.transaction("session_problems", "readwrite"),
						r = n.objectStore("session_problems").index("deviceKey").getAll(e);
					return r.onsuccess = () => {
						const e = r.result;
						if (!e.length) return void(i = null);
						e.sort((e, t) => e.time - t.time);
						const n = e[e.length - 1];
						for (const r of e)
							if (r.time > t) return void(i = Object.assign({}, r, {
								fixed: n.fixed
							}));
						i = n.fixed ? null : n
					}, await h(n), i
				}
				async filterOutNotifiedErrorDevices(e) {
					const t = this.db.transaction("notified_error_devices", "readwrite").objectStore("notified_error_devices"),
						i = [];
					return await Promise.all(e.map(e => new Promise(n => {
						const {
							userId: r,
							deviceInfo: s
						} = e, o = t.get([r, s.deviceId]);
						o.onsuccess = function() {
							o.result || (t.put({
								userId: r,
								deviceId: s.deviceId
							}), i.push(e)), n()
						}
					}))), i
				}
				getEndToEndInboundGroupSession(e, t, i, n) {
					let r = !1,
						s = !1;
					const o = i.objectStore("inbound_group_sessions").get([e, t]);
					o.onsuccess = function() {
						try {
							r = o.result ? o.result.session : null, !1 !== s && n(r, s)
						} catch (e) {
							u(i, e)
						}
					};
					const a = i.objectStore("inbound_group_sessions_withheld").get([e, t]);
					a.onsuccess = function() {
						try {
							s = a.result ? a.result.session : null, !1 !== r && n(r, s)
						} catch (e) {
							u(i, e)
						}
					}
				}
				getAllEndToEndInboundGroupSessions(e, t) {
					const i = e.objectStore("inbound_group_sessions").openCursor();
					i.onsuccess = function() {
						const n = i.result;
						if (n) {
							try {
								t({
									senderKey: n.value.senderCurve25519Key,
									sessionId: n.value.sessionId,
									sessionData: n.value.session
								})
							} catch (r) {
								u(e, r)
							}
							n.continue()
						} else try {
							t(null)
						} catch (r) {
							u(e, r)
						}
					}
				}
				addEndToEndInboundGroupSession(e, t, i, n) {
					const r = n.objectStore("inbound_group_sessions").add({
						senderCurve25519Key: e,
						sessionId: t,
						session: i
					});
					r.onerror = i => {
						var o;
						"ConstraintError" === (null === (o = r.error) || void 0 === o ? void 0 : o.name) ? (i.stopPropagation(), i.preventDefault(), s.logger.log("Ignoring duplicate inbound group session: " + e + " / " + t)) : u(n, new Error("Failed to add inbound group session: " + r.error))
					}
				}
				storeEndToEndInboundGroupSession(e, t, i, n) {
					n.objectStore("inbound_group_sessions").put({
						senderCurve25519Key: e,
						sessionId: t,
						session: i
					})
				}
				storeEndToEndInboundGroupSessionWithheld(e, t, i, n) {
					n.objectStore("inbound_group_sessions_withheld").put({
						senderCurve25519Key: e,
						sessionId: t,
						session: i
					})
				}
				getEndToEndDeviceData(e, t) {
					const i = e.objectStore("device_data").get("-");
					i.onsuccess = function() {
						try {
							t(i.result || null)
						} catch (n) {
							u(e, n)
						}
					}
				}
				storeEndToEndDeviceData(e, t) {
					t.objectStore("device_data").put(e, "-")
				}
				storeEndToEndRoom(e, t, i) {
					i.objectStore("rooms").put(t, e)
				}
				getEndToEndRooms(e, t) {
					const i = {},
						n = e.objectStore("rooms").openCursor();
					n.onsuccess = function() {
						const r = n.result;
						if (r) i[r.key] = r.value, r.continue();
						else try {
							t(i)
						} catch (s) {
							u(e, s)
						}
					}
				}
				getSessionsNeedingBackup(e) {
					return new Promise((t, i) => {
						const n = [],
							r = this.db.transaction(["sessions_needing_backup", "inbound_group_sessions"], "readonly");
						r.onerror = i, r.oncomplete = function() {
							t(n)
						};
						const s = r.objectStore("sessions_needing_backup"),
							o = r.objectStore("inbound_group_sessions"),
							a = s.openCursor();
						a.onsuccess = function() {
							const t = a.result;
							if (t) {
								const i = o.get(t.key);
								i.onsuccess = function() {
									n.push({
										senderKey: i.result.senderCurve25519Key,
										sessionId: i.result.sessionId,
										sessionData: i.result.session
									})
								}, (!e || n.length < e) && t.continue()
							}
						}
					})
				}
				countSessionsNeedingBackup(e) {
					e || (e = this.db.transaction("sessions_needing_backup", "readonly"));
					const t = e.objectStore("sessions_needing_backup");
					return new Promise((e, i) => {
						const n = t.count();
						n.onerror = i, n.onsuccess = () => e(n.result)
					})
				}
				async unmarkSessionsNeedingBackup(e, t) {
					t || (t = this.db.transaction("sessions_needing_backup", "readwrite"));
					const i = t.objectStore("sessions_needing_backup");
					await Promise.all(e.map(e => new Promise((t, n) => {
						const r = i.delete([e.senderKey, e.sessionId]);
						r.onsuccess = t, r.onerror = n
					})))
				}
				async markSessionsNeedingBackup(e, t) {
					t || (t = this.db.transaction("sessions_needing_backup", "readwrite"));
					const i = t.objectStore("sessions_needing_backup");
					await Promise.all(e.map(e => new Promise((t, n) => {
						const r = i.put({
							senderCurve25519Key: e.senderKey,
							sessionId: e.sessionId
						});
						r.onsuccess = t, r.onerror = n
					})))
				}
				addSharedHistoryInboundGroupSession(e, t, i, n) {
					n || (n = this.db.transaction("shared_history_inbound_group_sessions", "readwrite"));
					const r = n.objectStore("shared_history_inbound_group_sessions"),
						s = r.get([e]);
					s.onsuccess = () => {
						const {
							sessions: n
						} = s.result || {
							sessions: []
						};
						n.push([t, i]), r.put({
							roomId: e,
							sessions: n
						})
					}
				}
				getSharedHistoryInboundGroupSessions(e, t) {
					t || (t = this.db.transaction("shared_history_inbound_group_sessions", "readonly"));
					const i = t.objectStore("shared_history_inbound_group_sessions").get([e]);
					return new Promise((e, t) => {
						i.onsuccess = () => {
							const {
								sessions: t
							} = i.result || {
								sessions: []
							};
							e(t)
						}, i.onerror = t
					})
				}
				addParkedSharedHistory(e, t, i) {
					i || (i = this.db.transaction("parked_shared_history", "readwrite"));
					const n = i.objectStore("parked_shared_history"),
						r = n.get([e]);
					r.onsuccess = () => {
						const {
							parked: i
						} = r.result || {
							parked: []
						};
						i.push(t), n.put({
							roomId: e,
							parked: i
						})
					}
				}
				takeParkedSharedHistory(e, t) {
					t || (t = this.db.transaction("parked_shared_history", "readwrite"));
					const i = t.objectStore("parked_shared_history").openCursor(e);
					return new Promise((e, t) => {
						i.onsuccess = () => {
							const t = i.result;
							if (!t) return void e([]);
							const n = t.value;
							t.delete(), e(n)
						}, i.onerror = t
					})
				}
				doTxn(e, t, i, n = s.logger) {
					let r, o;
					if (d) {
						const i = this.nextTxnId++;
						r = Date.now(), o = `${e} crypto store transaction ${i} in ${t}`, n.debug(`Starting ${o}`)
					}
					const a = this.db.transaction(t, e),
						l = h(a),
						c = i(a);
					return d && l.then(() => {
						const e = Date.now() - r;
						n.debug(`Finished ${o}, took ${e} ms`)
					}, () => {
						const e = Date.now() - r;
						n.error(`Failed ${o}, took ${e} ms`)
					}), l.then(() => c)
				}
			};
			const l = [e => {
					! function(e) {
						const t = e.createObjectStore("outgoingRoomKeyRequests", {
							keyPath: "requestId"
						});
						t.createIndex("session", ["requestBody.room_id", "requestBody.session_id"]), t.createIndex("state", "state")
					}(e)
				}, e => {
					e.createObjectStore("account")
				}, e => {
					e.createObjectStore("sessions", {
						keyPath: ["deviceKey", "sessionId"]
					}).createIndex("deviceKey", "deviceKey")
				}, e => {
					e.createObjectStore("inbound_group_sessions", {
						keyPath: ["senderCurve25519Key", "sessionId"]
					})
				}, e => {
					e.createObjectStore("device_data")
				}, e => {
					e.createObjectStore("rooms")
				}, e => {
					e.createObjectStore("sessions_needing_backup", {
						keyPath: ["senderCurve25519Key", "sessionId"]
					})
				}, e => {
					e.createObjectStore("inbound_group_sessions_withheld", {
						keyPath: ["senderCurve25519Key", "sessionId"]
					})
				}, e => {
					e.createObjectStore("session_problems", {
						keyPath: ["deviceKey", "time"]
					}).createIndex("deviceKey", "deviceKey"), e.createObjectStore("notified_error_devices", {
						keyPath: ["userId", "deviceId"]
					})
				}, e => {
					e.createObjectStore("shared_history_inbound_group_sessions", {
						keyPath: ["roomId"]
					})
				}, e => {
					e.createObjectStore("parked_shared_history", {
						keyPath: ["roomId"]
					})
				}],
				c = l.length;

			function u(e, t) {
				e._mx_abortexception = t;
				try {
					e.abort()
				} catch (t) {}
			}

			function h(e) {
				return new Promise((t, i) => {
					e.oncomplete = () => {
						void 0 !== e._mx_abortexception && i(e._mx_abortexception), t(null)
					}, e.onerror = t => {
						void 0 !== e._mx_abortexception ? i(e._mx_abortexception) : (s.logger.log("Error performing indexeddb txn", t), i(e.error))
					}, e.onabort = t => {
						void 0 !== e._mx_abortexception ? i(e._mx_abortexception) : (s.logger.log("Error performing indexeddb txn", t), i(e.error))
					}
				})
			}
			t.VERSION = c
		},
		"./node_modules/matrix-js-sdk/lib/crypto/store/indexeddb-crypto-store.js": function(e, t, i) {
			"use strict";
			(function(e) {
				var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.IndexedDBCryptoStore = void 0;
				var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
					s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
					o = i("./node_modules/matrix-js-sdk/lib/crypto/store/localStorage-crypto-store.js"),
					a = i("./node_modules/matrix-js-sdk/lib/crypto/store/memory-crypto-store.js"),
					d = h(i("./node_modules/matrix-js-sdk/lib/crypto/store/indexeddb-crypto-store-backend.js")),
					l = i("./node_modules/matrix-js-sdk/lib/errors.js"),
					c = h(i("./node_modules/matrix-js-sdk/lib/indexeddb-helpers.js"));

				function u(e) {
					if ("function" != typeof WeakMap) return null;
					var t = new WeakMap,
						i = new WeakMap;
					return (u = function(e) {
						return e ? i : t
					})(e)
				}

				function h(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = u(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} return n.default = e, i && i.set(e, n), n
				}
				class m {
					static exists(e, t) {
						return c.exists(e, t)
					}
					constructor(e, t) {
						this.indexedDB = e, this.dbName = t, (0, r.default)(this, "backendPromise", void 0), (0, r.default)(this, "backend", void 0)
					}
					startup() {
						return this.backendPromise ? this.backendPromise : (this.backendPromise = new Promise((e, t) => {
							if (!this.indexedDB) return void t(new Error("no indexeddb support available"));
							s.logger.log(`connecting to indexeddb ${this.dbName}`);
							const i = this.indexedDB.open(this.dbName, d.VERSION);
							i.onupgradeneeded = e => {
								const t = i.result,
									n = e.oldVersion;
								d.upgradeDatabase(t, n)
							}, i.onblocked = () => {
								s.logger.log("can't yet open IndexedDBCryptoStore because it is open elsewhere")
							}, i.onerror = e => {
								s.logger.log("Error connecting to indexeddb", e), t(i.error)
							}, i.onsuccess = () => {
								const t = i.result;
								s.logger.log(`connected to indexeddb ${this.dbName}`), e(new d.Backend(t))
							}
						}).then(e => e.doTxn("readonly", [m.STORE_INBOUND_GROUP_SESSIONS, m.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], t => {
							e.getEndToEndInboundGroupSession("", "", t, () => {})
						}).then(() => e)).catch(t => {
							if ("VersionError" === t.name) throw s.logger.warn("Crypto DB is too new for us to use!", t), new l.InvalidCryptoStoreError(l.InvalidCryptoStoreState.TooNew);
							s.logger.warn(`unable to connect to indexeddb ${this.dbName}` + `: falling back to localStorage store: ${t}`);
							try {
								return new o.LocalStorageCryptoStore(e.localStorage)
							} catch (t) {
								return s.logger.warn(`unable to open localStorage: falling back to in-memory store: ${t}`), new a.MemoryCryptoStore
							}
						}).then(e => (this.backend = e, e)), this.backendPromise)
					}
					deleteAllData() {
						return new Promise((e, t) => {
							if (!this.indexedDB) return void t(new Error("no indexeddb support available"));
							s.logger.log(`Removing indexeddb instance: ${this.dbName}`);
							const i = this.indexedDB.deleteDatabase(this.dbName);
							i.onblocked = () => {
								s.logger.log("can't yet delete IndexedDBCryptoStore because it is open elsewhere")
							}, i.onerror = e => {
								s.logger.log("Error deleting data from indexeddb", e), t(i.error)
							}, i.onsuccess = () => {
								s.logger.log(`Removed indexeddb instance: ${this.dbName}`), e()
							}
						}).catch(e => {
							s.logger.warn(`unable to delete IndexedDBCryptoStore: ${e}`)
						})
					}
					getOrAddOutgoingRoomKeyRequest(e) {
						return this.backend.getOrAddOutgoingRoomKeyRequest(e)
					}
					getOutgoingRoomKeyRequest(e) {
						return this.backend.getOutgoingRoomKeyRequest(e)
					}
					getOutgoingRoomKeyRequestByState(e) {
						return this.backend.getOutgoingRoomKeyRequestByState(e)
					}
					getAllOutgoingRoomKeyRequestsByState(e) {
						return this.backend.getAllOutgoingRoomKeyRequestsByState(e)
					}
					getOutgoingRoomKeyRequestsByTarget(e, t, i) {
						return this.backend.getOutgoingRoomKeyRequestsByTarget(e, t, i)
					}
					updateOutgoingRoomKeyRequest(e, t, i) {
						return this.backend.updateOutgoingRoomKeyRequest(e, t, i)
					}
					deleteOutgoingRoomKeyRequest(e, t) {
						return this.backend.deleteOutgoingRoomKeyRequest(e, t)
					}
					getAccount(e, t) {
						this.backend.getAccount(e, t)
					}
					storeAccount(e, t) {
						this.backend.storeAccount(e, t)
					}
					getCrossSigningKeys(e, t) {
						this.backend.getCrossSigningKeys(e, t)
					}
					getSecretStorePrivateKey(e, t, i) {
						this.backend.getSecretStorePrivateKey(e, t, i)
					}
					storeCrossSigningKeys(e, t) {
						this.backend.storeCrossSigningKeys(e, t)
					}
					storeSecretStorePrivateKey(e, t, i) {
						this.backend.storeSecretStorePrivateKey(e, t, i)
					}
					countEndToEndSessions(e, t) {
						this.backend.countEndToEndSessions(e, t)
					}
					getEndToEndSession(e, t, i, n) {
						this.backend.getEndToEndSession(e, t, i, n)
					}
					getEndToEndSessions(e, t, i) {
						this.backend.getEndToEndSessions(e, t, i)
					}
					getAllEndToEndSessions(e, t) {
						this.backend.getAllEndToEndSessions(e, t)
					}
					storeEndToEndSession(e, t, i, n) {
						this.backend.storeEndToEndSession(e, t, i, n)
					}
					storeEndToEndSessionProblem(e, t, i) {
						return this.backend.storeEndToEndSessionProblem(e, t, i)
					}
					getEndToEndSessionProblem(e, t) {
						return this.backend.getEndToEndSessionProblem(e, t)
					}
					filterOutNotifiedErrorDevices(e) {
						return this.backend.filterOutNotifiedErrorDevices(e)
					}
					getEndToEndInboundGroupSession(e, t, i, n) {
						this.backend.getEndToEndInboundGroupSession(e, t, i, n)
					}
					getAllEndToEndInboundGroupSessions(e, t) {
						this.backend.getAllEndToEndInboundGroupSessions(e, t)
					}
					addEndToEndInboundGroupSession(e, t, i, n) {
						this.backend.addEndToEndInboundGroupSession(e, t, i, n)
					}
					storeEndToEndInboundGroupSession(e, t, i, n) {
						this.backend.storeEndToEndInboundGroupSession(e, t, i, n)
					}
					storeEndToEndInboundGroupSessionWithheld(e, t, i, n) {
						this.backend.storeEndToEndInboundGroupSessionWithheld(e, t, i, n)
					}
					storeEndToEndDeviceData(e, t) {
						this.backend.storeEndToEndDeviceData(e, t)
					}
					getEndToEndDeviceData(e, t) {
						this.backend.getEndToEndDeviceData(e, t)
					}
					storeEndToEndRoom(e, t, i) {
						this.backend.storeEndToEndRoom(e, t, i)
					}
					getEndToEndRooms(e, t) {
						this.backend.getEndToEndRooms(e, t)
					}
					getSessionsNeedingBackup(e) {
						return this.backend.getSessionsNeedingBackup(e)
					}
					countSessionsNeedingBackup(e) {
						return this.backend.countSessionsNeedingBackup(e)
					}
					unmarkSessionsNeedingBackup(e, t) {
						return this.backend.unmarkSessionsNeedingBackup(e, t)
					}
					markSessionsNeedingBackup(e, t) {
						return this.backend.markSessionsNeedingBackup(e, t)
					}
					addSharedHistoryInboundGroupSession(e, t, i, n) {
						this.backend.addSharedHistoryInboundGroupSession(e, t, i, n)
					}
					getSharedHistoryInboundGroupSessions(e, t) {
						return this.backend.getSharedHistoryInboundGroupSessions(e, t)
					}
					addParkedSharedHistory(e, t, i) {
						this.backend.addParkedSharedHistory(e, t, i)
					}
					takeParkedSharedHistory(e, t) {
						return this.backend.takeParkedSharedHistory(e, t)
					}
					doTxn(e, t, i, n) {
						return this.backend.doTxn(e, t, i, n)
					}
				}
				t.IndexedDBCryptoStore = m, (0, r.default)(m, "STORE_ACCOUNT", "account"), (0, r.default)(m, "STORE_SESSIONS", "sessions"), (0, r.default)(m, "STORE_INBOUND_GROUP_SESSIONS", "inbound_group_sessions"), (0, r.default)(m, "STORE_INBOUND_GROUP_SESSIONS_WITHHELD", "inbound_group_sessions_withheld"), (0, r.default)(m, "STORE_SHARED_HISTORY_INBOUND_GROUP_SESSIONS", "shared_history_inbound_group_sessions"), (0, r.default)(m, "STORE_PARKED_SHARED_HISTORY", "parked_shared_history"), (0, r.default)(m, "STORE_DEVICE_DATA", "device_data"), (0, r.default)(m, "STORE_ROOMS", "rooms"), (0, r.default)(m, "STORE_BACKUP", "sessions_needing_backup")
			}).call(this, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/crypto/store/localStorage-crypto-store.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.LocalStorageCryptoStore = void 0;
			var n = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				r = i("./node_modules/matrix-js-sdk/lib/crypto/store/memory-crypto-store.js");
			const s = "crypto.",
				o = s + "account",
				a = s + "cross_signing_keys",
				d = s + "notified_error_devices",
				l = s + "device_data",
				c = s + "inboundgroupsessions/",
				u = s + "inboundgroupsessions.withheld/",
				h = s + "rooms/",
				m = s + "sessionsneedingbackup";

			function p(e) {
				return s + "sessions/" + e
			}

			function g(e) {
				return s + "session.problems/" + e
			}

			function f(e, t) {
				return c + e + "/" + t
			}

			function v(e, t) {
				return u + e + "/" + t
			}

			function y(e) {
				return h + e
			}
			class b extends r.MemoryCryptoStore {
				static exists(e) {
					const t = e.length;
					for (let n = 0; n < t; n++) {
						var i;
						if (null !== (i = e.key(n)) && void 0 !== i && i.startsWith(s)) return !0
					}
					return !1
				}
				constructor(e) {
					super(), this.store = e
				}
				countEndToEndSessions(e, t) {
					let i = 0;
					for (let r = 0; r < this.store.length; ++r) {
						var n;
						null !== (n = this.store.key(r)) && void 0 !== n && n.startsWith(p("")) && ++i
					}
					t(i)
				}
				_getEndToEndSessions(e) {
					const t = _(this.store, p(e)),
						i = {};
					for (const [n, r] of Object.entries(t || {})) i[n] = "string" == typeof r ? {
						session: r
					} : r;
					return i
				}
				getEndToEndSession(e, t, i, n) {
					n(this._getEndToEndSessions(e)[t] || {})
				}
				getEndToEndSessions(e, t, i) {
					i(this._getEndToEndSessions(e) || {})
				}
				getAllEndToEndSessions(e, t) {
					for (let n = 0; n < this.store.length; ++n) {
						var i;
						if (null !== (i = this.store.key(n)) && void 0 !== i && i.startsWith(p(""))) {
							const e = this.store.key(n).split("/")[1];
							for (const i of Object.values(this._getEndToEndSessions(e))) t(i)
						}
					}
				}
				storeEndToEndSession(e, t, i, n) {
					const r = this._getEndToEndSessions(e) || {};
					r[t] = i, S(this.store, p(e), r)
				}
				async storeEndToEndSessionProblem(e, t, i) {
					const n = g(e),
						r = _(this.store, n) || [];
					r.push({
						type: t,
						fixed: i,
						time: Date.now()
					}), r.sort((e, t) => e.time - t.time), S(this.store, n, r)
				}
				async getEndToEndSessionProblem(e, t) {
					const i = g(e),
						n = _(this.store, i) || [];
					if (!n.length) return null;
					const r = n[n.length - 1];
					for (const s of n)
						if (s.time > t) return Object.assign({}, s, {
							fixed: r.fixed
						});
					return r.fixed ? null : r
				}
				async filterOutNotifiedErrorDevices(e) {
					const t = _(this.store, d) || {},
						i = [];
					for (const n of e) {
						const {
							userId: e,
							deviceInfo: r
						} = n;
						e in t ? r.deviceId in t[e] || (i.push(n), t[e][r.deviceId] = !0) : (i.push(n), t[e] = {
							[r.deviceId]: !0
						})
					}
					return S(this.store, d, t), i
				}
				getEndToEndInboundGroupSession(e, t, i, n) {
					n(_(this.store, f(e, t)), _(this.store, v(e, t)))
				}
				getAllEndToEndInboundGroupSessions(e, t) {
					for (let i = 0; i < this.store.length; ++i) {
						const e = this.store.key(i);
						null != e && e.startsWith(c) && t({
							senderKey: e.slice(c.length, c.length + 43),
							sessionId: e.slice(c.length + 44),
							sessionData: _(this.store, e)
						})
					}
					t(null)
				}
				addEndToEndInboundGroupSession(e, t, i, n) {
					_(this.store, f(e, t)) || this.storeEndToEndInboundGroupSession(e, t, i, n)
				}
				storeEndToEndInboundGroupSession(e, t, i, n) {
					S(this.store, f(e, t), i)
				}
				storeEndToEndInboundGroupSessionWithheld(e, t, i, n) {
					S(this.store, v(e, t), i)
				}
				getEndToEndDeviceData(e, t) {
					t(_(this.store, l))
				}
				storeEndToEndDeviceData(e, t) {
					S(this.store, l, e)
				}
				storeEndToEndRoom(e, t, i) {
					S(this.store, y(e), t)
				}
				getEndToEndRooms(e, t) {
					const i = {},
						n = y("");
					for (let r = 0; r < this.store.length; ++r) {
						const e = this.store.key(r);
						if (null != e && e.startsWith(n)) {
							i[e.slice(n.length)] = _(this.store, e)
						}
					}
					t(i)
				}
				getSessionsNeedingBackup(e) {
					const t = _(this.store, m) || {},
						i = [];
					for (const n in t)
						if (Object.prototype.hasOwnProperty.call(t, n)) {
							const t = n.slice(0, 43),
								r = n.slice(44);
							if (this.getEndToEndInboundGroupSession(t, r, null, e => {
									i.push({
										senderKey: t,
										sessionId: r,
										sessionData: e
									})
								}), e && i.length >= e) break
						} return Promise.resolve(i)
				}
				countSessionsNeedingBackup() {
					const e = _(this.store, m) || {};
					return Promise.resolve(Object.keys(e).length)
				}
				unmarkSessionsNeedingBackup(e) {
					const t = _(this.store, m) || {};
					for (const i of e) delete t[i.senderKey + "/" + i.sessionId];
					return S(this.store, m, t), Promise.resolve()
				}
				markSessionsNeedingBackup(e) {
					const t = _(this.store, m) || {};
					for (const i of e) t[i.senderKey + "/" + i.sessionId] = !0;
					return S(this.store, m, t), Promise.resolve()
				}
				deleteAllData() {
					return this.store.removeItem(o), Promise.resolve()
				}
				getAccount(e, t) {
					t(_(this.store, o))
				}
				storeAccount(e, t) {
					S(this.store, o, t)
				}
				getCrossSigningKeys(e, t) {
					t(_(this.store, a))
				}
				getSecretStorePrivateKey(e, t, i) {
					t(_(this.store, s + `ssss_cache.${i}`))
				}
				storeCrossSigningKeys(e, t) {
					S(this.store, a, t)
				}
				storeSecretStorePrivateKey(e, t, i) {
					S(this.store, s + `ssss_cache.${t}`, i)
				}
				doTxn(e, t, i) {
					return Promise.resolve(i(null))
				}
			}

			function _(e, t) {
				try {
					return JSON.parse(e.getItem(t))
				} catch (i) {
					n.logger.log("Error: Failed to get key %s: %s", t, i.message), n.logger.log(i.stack)
				}
				return null
			}

			function S(e, t, i) {
				e.setItem(t, JSON.stringify(i))
			}
			t.LocalStorageCryptoStore = b
		},
		"./node_modules/matrix-js-sdk/lib/crypto/store/memory-crypto-store.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.MemoryCryptoStore = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = a(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/utils.js"));

			function a(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (a = function(e) {
					return e ? i : t
				})(e)
			}

			function d(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function l(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? d(Object(i), !0).forEach((function(t) {
						(0, r.default)(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : d(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}
			t.MemoryCryptoStore = class {
				constructor() {
					(0, r.default)(this, "outgoingRoomKeyRequests", []), (0, r.default)(this, "account", null), (0, r.default)(this, "crossSigningKeys", null), (0, r.default)(this, "privateKeys", {}), (0, r.default)(this, "sessions", {}), (0, r.default)(this, "sessionProblems", {}), (0, r.default)(this, "notifiedErrorDevices", {}), (0, r.default)(this, "inboundGroupSessions", {}), (0, r.default)(this, "inboundGroupSessionsWithheld", {}), (0, r.default)(this, "deviceData", null), (0, r.default)(this, "rooms", {}), (0, r.default)(this, "sessionsNeedingBackup", {}), (0, r.default)(this, "sharedHistoryInboundGroupSessions", {}), (0, r.default)(this, "parkedSharedHistory", new Map)
				}
				async startup() {
					return this
				}
				deleteAllData() {
					return Promise.resolve()
				}
				getOrAddOutgoingRoomKeyRequest(e) {
					const t = e.requestBody;
					return o.promiseTry(() => {
						const i = this._getOutgoingRoomKeyRequest(t);
						return i ? (s.logger.log("already have key request outstanding for " + `${t.room_id} / ${t.session_id}: ` + "not sending another"), i) : (s.logger.log(`enqueueing key request for ${t.room_id} / ` + t.session_id), this.outgoingRoomKeyRequests.push(e), e)
					})
				}
				getOutgoingRoomKeyRequest(e) {
					return Promise.resolve(this._getOutgoingRoomKeyRequest(e))
				}
				_getOutgoingRoomKeyRequest(e) {
					for (const t of this.outgoingRoomKeyRequests)
						if (o.deepCompare(t.requestBody, e)) return t;
					return null
				}
				getOutgoingRoomKeyRequestByState(e) {
					for (const t of this.outgoingRoomKeyRequests)
						for (const i of e)
							if (t.state === i) return Promise.resolve(t);
					return Promise.resolve(null)
				}
				getAllOutgoingRoomKeyRequestsByState(e) {
					return Promise.resolve(this.outgoingRoomKeyRequests.filter(t => t.state == e))
				}
				getOutgoingRoomKeyRequestsByTarget(e, t, i) {
					const n = [];
					for (const r of this.outgoingRoomKeyRequests)
						for (const s of i) r.state === s && r.recipients.some(i => i.userId === e && i.deviceId === t) && n.push(r);
					return Promise.resolve(n)
				}
				updateOutgoingRoomKeyRequest(e, t, i) {
					for (const n of this.outgoingRoomKeyRequests)
						if (n.requestId === e) return n.state !== t ? (s.logger.warn(`Cannot update room key request from ${t} ` + `as it was already updated to ${n.state}`), Promise.resolve(null)) : (Object.assign(n, i), Promise.resolve(n));
					return Promise.resolve(null)
				}
				deleteOutgoingRoomKeyRequest(e, t) {
					for (let i = 0; i < this.outgoingRoomKeyRequests.length; i++) {
						const n = this.outgoingRoomKeyRequests[i];
						if (n.requestId === e) return n.state != t ? (s.logger.warn(`Cannot delete room key request in state ${n.state} ` + `(expected ${t})`), Promise.resolve(null)) : (this.outgoingRoomKeyRequests.splice(i, 1), Promise.resolve(n))
					}
					return Promise.resolve(null)
				}
				getAccount(e, t) {
					t(this.account)
				}
				storeAccount(e, t) {
					this.account = t
				}
				getCrossSigningKeys(e, t) {
					t(this.crossSigningKeys)
				}
				getSecretStorePrivateKey(e, t, i) {
					t(this.privateKeys[i] || null)
				}
				storeCrossSigningKeys(e, t) {
					this.crossSigningKeys = t
				}
				storeSecretStorePrivateKey(e, t, i) {
					this.privateKeys[t] = i
				}
				countEndToEndSessions(e, t) {
					t(Object.keys(this.sessions).length)
				}
				getEndToEndSession(e, t, i, n) {
					n((this.sessions[e] || {})[t] || null)
				}
				getEndToEndSessions(e, t, i) {
					i(this.sessions[e] || {})
				}
				getAllEndToEndSessions(e, t) {
					Object.entries(this.sessions).forEach(([e, i]) => {
						Object.entries(i).forEach(([i, n]) => {
							t(l(l({}, n), {}, {
								deviceKey: e,
								sessionId: i
							}))
						})
					})
				}
				storeEndToEndSession(e, t, i, n) {
					let r = this.sessions[e];
					void 0 === r && (r = {}, this.sessions[e] = r), r[t] = i
				}
				async storeEndToEndSessionProblem(e, t, i) {
					const n = this.sessionProblems[e] = this.sessionProblems[e] || [];
					n.push({
						type: t,
						fixed: i,
						time: Date.now()
					}), n.sort((e, t) => e.time - t.time)
				}
				async getEndToEndSessionProblem(e, t) {
					const i = this.sessionProblems[e] || [];
					if (!i.length) return null;
					const n = i[i.length - 1];
					for (const r of i)
						if (r.time > t) return Object.assign({}, r, {
							fixed: n.fixed
						});
					return n.fixed ? null : n
				}
				async filterOutNotifiedErrorDevices(e) {
					const t = this.notifiedErrorDevices,
						i = [];
					for (const n of e) {
						const {
							userId: e,
							deviceInfo: r
						} = n;
						e in t ? r.deviceId in t[e] || (i.push(n), t[e][r.deviceId] = !0) : (i.push(n), t[e] = {
							[r.deviceId]: !0
						})
					}
					return i
				}
				getEndToEndInboundGroupSession(e, t, i, n) {
					const r = e + "/" + t;
					n(this.inboundGroupSessions[r] || null, this.inboundGroupSessionsWithheld[r] || null)
				}
				getAllEndToEndInboundGroupSessions(e, t) {
					for (const i of Object.keys(this.inboundGroupSessions)) t({
						senderKey: i.slice(0, 43),
						sessionId: i.slice(44),
						sessionData: this.inboundGroupSessions[i]
					});
					t(null)
				}
				addEndToEndInboundGroupSession(e, t, i, n) {
					const r = e + "/" + t;
					void 0 === this.inboundGroupSessions[r] && (this.inboundGroupSessions[r] = i)
				}
				storeEndToEndInboundGroupSession(e, t, i, n) {
					this.inboundGroupSessions[e + "/" + t] = i
				}
				storeEndToEndInboundGroupSessionWithheld(e, t, i, n) {
					const r = e + "/" + t;
					this.inboundGroupSessionsWithheld[r] = i
				}
				getEndToEndDeviceData(e, t) {
					t(this.deviceData)
				}
				storeEndToEndDeviceData(e, t) {
					this.deviceData = e
				}
				storeEndToEndRoom(e, t, i) {
					this.rooms[e] = t
				}
				getEndToEndRooms(e, t) {
					t(this.rooms)
				}
				getSessionsNeedingBackup(e) {
					const t = [];
					for (const i in this.sessionsNeedingBackup)
						if (this.inboundGroupSessions[i] && (t.push({
								senderKey: i.slice(0, 43),
								sessionId: i.slice(44),
								sessionData: this.inboundGroupSessions[i]
							}), e && i.length >= e)) break;
					return Promise.resolve(t)
				}
				countSessionsNeedingBackup() {
					return Promise.resolve(Object.keys(this.sessionsNeedingBackup).length)
				}
				unmarkSessionsNeedingBackup(e) {
					for (const t of e) {
						const e = t.senderKey + "/" + t.sessionId;
						delete this.sessionsNeedingBackup[e]
					}
					return Promise.resolve()
				}
				markSessionsNeedingBackup(e) {
					for (const t of e) {
						const e = t.senderKey + "/" + t.sessionId;
						this.sessionsNeedingBackup[e] = !0
					}
					return Promise.resolve()
				}
				addSharedHistoryInboundGroupSession(e, t, i) {
					const n = this.sharedHistoryInboundGroupSessions[e] || [];
					n.push([t, i]), this.sharedHistoryInboundGroupSessions[e] = n
				}
				getSharedHistoryInboundGroupSessions(e) {
					return Promise.resolve(this.sharedHistoryInboundGroupSessions[e] || [])
				}
				addParkedSharedHistory(e, t) {
					var i;
					const n = null !== (i = this.parkedSharedHistory.get(e)) && void 0 !== i ? i : [];
					n.push(t), this.parkedSharedHistory.set(e, n)
				}
				takeParkedSharedHistory(e) {
					var t;
					const i = null !== (t = this.parkedSharedHistory.get(e)) && void 0 !== t ? t : [];
					return this.parkedSharedHistory.delete(e), Promise.resolve(i)
				}
				doTxn(e, t, i) {
					return Promise.resolve(i(null))
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/crypto/verification/Base.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.VerificationEvent = t.VerificationBase = t.SwitchStartEventError = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/models/event.js"),
				o = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				a = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				d = i("./node_modules/matrix-js-sdk/lib/crypto/deviceinfo.js"),
				l = i("./node_modules/matrix-js-sdk/lib/crypto/verification/Error.js"),
				c = i("./node_modules/matrix-js-sdk/lib/crypto/CrossSigning.js"),
				u = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js");
			const h = new Error("Verification timed out");
			class SwitchStartEventError extends Error {
				constructor(e) {
					super(), this.startEvent = e
				}
			}
			let m;
			t.SwitchStartEventError = SwitchStartEventError, t.VerificationEvent = m,
				function(e) {
					e.Cancel = "cancel"
				}(m || (t.VerificationEvent = m = {}));
			class p extends u.TypedEventEmitter {
				constructor(e, t, i, n, s, o) {
					super(), this.channel = e, this.baseApis = t, this.userId = i, this.deviceId = n, this.startEvent = s, this.request = o, (0, r.default)(this, "cancelled", !1), (0, r.default)(this, "_done", !1), (0, r.default)(this, "promise", null), (0, r.default)(this, "transactionTimeoutTimer", null), (0, r.default)(this, "expectedEvent", void 0), (0, r.default)(this, "resolve", void 0), (0, r.default)(this, "reject", void 0), (0, r.default)(this, "resolveEvent", void 0), (0, r.default)(this, "rejectEvent", void 0), (0, r.default)(this, "started", void 0), (0, r.default)(this, "doVerification", void 0)
				}
				get initiatedByMe() {
					if (!this.startEvent) return !0;
					const e = this.startEvent.getSender(),
						t = this.startEvent.getContent();
					return e === this.baseApis.getUserId() && t.from_device === this.baseApis.getDeviceId()
				}
				get hasBeenCancelled() {
					return this.cancelled
				}
				resetTimer() {
					a.logger.info("Refreshing/starting the verification transaction timeout timer"), null !== this.transactionTimeoutTimer && clearTimeout(this.transactionTimeoutTimer), this.transactionTimeoutTimer = setTimeout(() => {
						this._done || this.cancelled || (a.logger.info("Triggering verification timeout"), this.cancel(h))
					}, 6e5)
				}
				endTimer() {
					null !== this.transactionTimeoutTimer && (clearTimeout(this.transactionTimeoutTimer), this.transactionTimeoutTimer = null)
				}
				send(e, t) {
					return this.channel.send(e, t)
				}
				waitForEvent(e) {
					if (this._done) return Promise.reject(new Error("Verification is already done"));
					const t = this.request.getEventFromOtherParty(e);
					return t ? Promise.resolve(t) : (this.expectedEvent = e, new Promise((e, t) => {
						this.resolveEvent = e, this.rejectEvent = t
					}))
				}
				canSwitchStartEvent(e) {
					return !1
				}
				switchStartEvent(e) {
					if (this.canSwitchStartEvent(e))
						if (a.logger.log("Verification Base: switching verification start event", {
								restartingFlow: !!this.rejectEvent
							}), this.rejectEvent) {
							const t = this.rejectEvent;
							this.rejectEvent = void 0, t(new SwitchStartEventError(e))
						} else this.startEvent = e
				}
				handleEvent(e) {
					var t;
					if (!this._done)
						if (e.getType() === this.expectedEvent) this.expectedEvent !== o.EventType.KeyVerificationDone && (this.expectedEvent = void 0, this.rejectEvent = void 0, this.resetTimer(), null === (t = this.resolveEvent) || void 0 === t || t.call(this, e));
						else if (e.getType() === o.EventType.KeyVerificationCancel) {
						const t = this.reject;
						if (this.reject = void 0, t) {
							const i = e.getContent(),
								{
									reason: n,
									code: r
								} = i;
							t(new Error("Other side cancelled verification " + `because ${n} (${r})`))
						}
					} else if (this.expectedEvent) {
						const t = new Error("Unexpected message: expecting " + this.expectedEvent + " but got " + e.getType());
						if (this.expectedEvent = void 0, this.rejectEvent) {
							const e = this.rejectEvent;
							this.rejectEvent = void 0, e(t)
						}
						this.cancel(t)
					}
				}
				async done() {
					var e;
					if (this.endTimer(), !this._done) return this.request.onVerifierFinished(), null === (e = this.resolve) || void 0 === e || e.call(this), (0, c.requestKeysDuringVerification)(this.baseApis, this.userId, this.deviceId)
				}
				cancel(e) {
					if (this.endTimer(), !this._done) {
						if (this.cancelled = !0, this.request.onVerifierCancelled(), this.userId && this.deviceId)
							if (e === h) {
								const e = (0, l.newTimeoutError)();
								this.send(e.getType(), e.getContent())
							} else if (e instanceof s.MatrixEvent) {
							if (e.getSender() !== this.userId) {
								const t = e.getContent();
								e.getType() === o.EventType.KeyVerificationCancel ? (t.code = t.code || "m.unknown", t.reason = t.reason || t.body || "Unknown reason", this.send(o.EventType.KeyVerificationCancel, t)) : this.send(o.EventType.KeyVerificationCancel, {
									code: "m.unknown",
									reason: t.body || "Unknown reason"
								})
							}
						} else this.send(o.EventType.KeyVerificationCancel, {
							code: "m.unknown",
							reason: e.toString()
						});
						null !== this.promise ? this.reject && this.reject(e) : this.promise = Promise.reject(e), this.emit(m.Cancel, e)
					}
				}
				verify() {
					return this.promise ? this.promise : (this.promise = new Promise((e, t) => {
						this.resolve = (...t) => {
							this._done = !0, this.endTimer(), e(...t)
						}, this.reject = e => {
							this._done = !0, this.endTimer(), t(e)
						}
					}), this.doVerification && !this.started && (this.started = !0, this.resetTimer(), new Promise((e, t) => {
						var i;
						(null === (i = this.baseApis.crypto.deviceList.getStoredCrossSigningForUser(this.userId)) || void 0 === i ? void 0 : i.getId()) === this.deviceId && t(new Error("Device ID is the same as the cross-signing ID")), e()
					}).then(() => this.doVerification()).then(this.done.bind(this), this.cancel.bind(this))), this.promise)
				}
				async verifyKeys(e, t, i) {
					const n = [];
					for (const [r, s] of Object.entries(t)) {
						const t = r.split(":", 2)[1],
							o = this.baseApis.getStoredDevice(e, t);
						if (o) i(r, o, s), n.push([t, r, o.keys[r]]);
						else {
							const o = this.baseApis.crypto.deviceList.getStoredCrossSigningForUser(e);
							o && o.getId() === t ? (i(r, d.DeviceInfo.fromStorage({
								keys: {
									[r]: t
								}
							}, t), s), n.push([t, r, t])) : a.logger.warn(`verification: Could not find device ${t} to verify`)
						}
					}
					if (!n.length) throw new Error("No devices could be verified");
					a.logger.info("Verification completed! Marking devices verified: ", n);
					for (const [r, s, o] of n) await this.baseApis.crypto.setDeviceVerification(e, r, !0, null, null, {
						[s]: o
					});
					e == this.baseApis.credentials.userId && await this.baseApis.checkKeyBackup()
				}
				get events() {}
			}
			t.VerificationBase = p
		},
		"./node_modules/matrix-js-sdk/lib/crypto/verification/Error.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.errorFactory = o, t.errorFromEvent = function(e) {
				const t = e.getContent();
				if (t) {
					const {
						code: e,
						reason: i
					} = t;
					return {
						code: e,
						reason: i
					}
				}
				return {
					code: "Unknown error",
					reason: "m.unknown"
				}
			}, t.newUserCancelledError = t.newUnknownMethodError = t.newUnexpectedMessageError = t.newTimeoutError = t.newKeyMismatchError = t.newInvalidMessageError = void 0, t.newVerificationError = s;
			var n = i("./node_modules/matrix-js-sdk/lib/models/event.js"),
				r = i("./node_modules/matrix-js-sdk/lib/@types/event.js");

			function s(e, t, i) {
				const s = Object.assign({}, {
					code: e,
					reason: t
				}, i);
				return new n.MatrixEvent({
					type: r.EventType.KeyVerificationCancel,
					content: s
				})
			}

			function o(e, t) {
				return function(i) {
					return s(e, t, i)
				}
			}
			const a = o("m.user", "Cancelled by user");
			t.newUserCancelledError = a;
			const d = o("m.timeout", "Timed out");
			t.newTimeoutError = d;
			const l = o("m.unknown_method", "Unknown method");
			t.newUnknownMethodError = l;
			const c = o("m.unexpected_message", "Unexpected message");
			t.newUnexpectedMessageError = c;
			const u = o("m.key_mismatch", "Key mismatch");
			t.newKeyMismatchError = u;
			const h = o("m.invalid_message", "Invalid message");
			t.newInvalidMessageError = h
		},
		"./node_modules/matrix-js-sdk/lib/crypto/verification/IllegalMethod.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.IllegalMethod = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/crypto/verification/Base.js");
			class o extends s.VerificationBase {
				constructor(...e) {
					super(...e), (0, r.default)(this, "doVerification", async () => {
						throw new Error("Verification is not possible with this method")
					})
				}
				static factory(e, t, i, n, r, s) {
					return new o(e, t, i, n, r, s)
				}
				static get NAME() {
					return "org.matrix.illegal_method"
				}
			}
			t.IllegalMethod = o
		},
		"./node_modules/matrix-js-sdk/lib/crypto/verification/QRCode.js": function(e, t, i) {
			"use strict";
			(function(e, n) {
				var r = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.SHOW_QR_CODE_METHOD = t.SCAN_QR_CODE_METHOD = t.ReciprocateQRCode = t.QrCodeEvent = t.QRCodeData = void 0;
				var s = r(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
					o = i("./node_modules/matrix-js-sdk/lib/crypto/verification/Base.js"),
					a = i("./node_modules/matrix-js-sdk/lib/crypto/verification/Error.js"),
					d = i("./node_modules/matrix-js-sdk/lib/crypto/olmlib.js"),
					l = i("./node_modules/matrix-js-sdk/lib/logger.js");
				t.SHOW_QR_CODE_METHOD = "m.qr_code.show.v1";
				let c;
				t.SCAN_QR_CODE_METHOD = "m.qr_code.scan.v1", t.QrCodeEvent = c,
					function(e) {
						e.ShowReciprocateQr = "show_reciprocate_qr"
					}(c || (t.QrCodeEvent = c = {}));
				class u extends o.VerificationBase {
					constructor(...e) {
						super(...e), (0, s.default)(this, "reciprocateQREvent", void 0), (0, s.default)(this, "doVerification", async () => {
							if (!this.startEvent) throw new Error("It is not currently possible to start verificationwith this method yet.");
							const {
								qrCodeData: e
							} = this.request;
							if (this.startEvent.getContent().secret !== (null == e ? void 0 : e.encodedSharedSecret)) throw (0, a.newKeyMismatchError)();
							await new Promise((e, t) => {
								this.reciprocateQREvent = {
									confirm: e,
									cancel: () => t((0, a.newUserCancelledError)())
								}, this.emit(c.ShowReciprocateQr, this.reciprocateQREvent)
							});
							const t = {};
							switch (null == e ? void 0 : e.mode) {
								case p.VerifyOtherUser: {
									const i = e.otherUserMasterKey;
									t[`ed25519:${i}`] = i;
									break
								}
								case p.VerifySelfTrusted: {
									const i = this.request.targetDevice.deviceId;
									t[`ed25519:${i}`] = e.otherDeviceKey;
									break
								}
								case p.VerifySelfUntrusted: {
									const i = e.myMasterKey;
									t[`ed25519:${i}`] = i;
									break
								}
							}
							await this.verifyKeys(this.userId, t, (e, i, n) => {
								const r = t[e];
								if (!r) throw (0, a.newKeyMismatchError)();
								if (n !== r) throw l.logger.error("key ID from key info does not match"), (0, a.newKeyMismatchError)();
								for (const s in i.keys) {
									if (!s.startsWith("ed25519")) continue;
									const e = t[s];
									if (!e) throw (0, a.newKeyMismatchError)();
									if (i.keys[s] !== e) throw l.logger.error("master key does not match"), (0, a.newKeyMismatchError)()
								}
							})
						})
					}
					static factory(e, t, i, n, r, s) {
						return new u(e, t, i, n, r, s)
					}
					static get NAME() {
						return "m.reciprocate.v1"
					}
				}
				t.ReciprocateQRCode = u;
				const h = 2,
					m = "MATRIX";
				var p;
				! function(e) {
					e[e.VerifyOtherUser = 0] = "VerifyOtherUser", e[e.VerifySelfTrusted = 1] = "VerifySelfTrusted", e[e.VerifySelfUntrusted = 2] = "VerifySelfUntrusted"
				}(p || (p = {}));
				class g {
					constructor(e, t, i, n, r, s) {
						this.mode = e, this.sharedSecret = t, this.otherUserMasterKey = i, this.otherDeviceKey = n, this.myMasterKey = r, this.buffer = s
					}
					static async create(e, t) {
						const i = g.generateSharedSecret(),
							n = g.determineMode(e, t);
						let r = null,
							s = null,
							o = null;
						if (n === p.VerifyOtherUser) {
							r = t.getStoredCrossSigningForUser(e.otherUserId).getId("master")
						} else if (n === p.VerifySelfTrusted) s = await g.getOtherDeviceKey(e, t);
						else if (n === p.VerifySelfUntrusted) {
							const e = t.getUserId();
							o = t.getStoredCrossSigningForUser(e).getId("master")
						}
						const a = g.generateQrData(e, t, n, i, r, s, o),
							d = g.generateBuffer(a);
						return new g(n, i, r, s, o, d)
					}
					get encodedSharedSecret() {
						return this.sharedSecret
					}
					getBuffer() {
						return this.buffer
					}
					static generateSharedSecret() {
						const t = new Uint8Array(11);
						return e.crypto.getRandomValues(t), (0, d.encodeUnpaddedBase64)(t)
					}
					static async getOtherDeviceKey(e, t) {
						const i = t.getUserId(),
							n = e.targetDevice,
							r = n.deviceId ? t.getStoredDevice(i, n.deviceId) : void 0;
						if (!r) throw new Error("could not find device " + (null == n ? void 0 : n.deviceId));
						return r.getFingerprint()
					}
					static determineMode(e, t) {
						const i = t.getUserId(),
							n = e.otherUserId;
						let r = p.VerifyOtherUser;
						if (i === n) {
							r = t.checkUserTrust(i).isCrossSigningVerified() ? p.VerifySelfTrusted : p.VerifySelfUntrusted
						}
						return r
					}
					static generateQrData(e, t, i, n, r, s, o) {
						const a = t.getUserId(),
							d = e.channel.transactionId,
							l = {
								prefix: m,
								version: h,
								mode: i,
								transactionId: d,
								firstKeyB64: "",
								secondKeyB64: "",
								secretB64: n
							},
							c = t.getStoredCrossSigningForUser(a);
						return i === p.VerifyOtherUser ? (l.firstKeyB64 = c.getId("master"), l.secondKeyB64 = r) : i === p.VerifySelfTrusted ? (l.firstKeyB64 = c.getId("master"), l.secondKeyB64 = s) : i === p.VerifySelfUntrusted && (l.firstKeyB64 = t.getDeviceEd25519Key(), l.secondKeyB64 = o), l
					}
					static generateBuffer(e) {
						let t = n.alloc(0);
						const i = e => {
								const i = n.from([e]);
								t = n.concat([t, i])
							},
							r = (e, i, r = !0) => {
								const s = n.from(e, i);
								r && (e => {
									const i = n.alloc(2);
									i.writeInt16BE(e, 0), t = n.concat([t, i])
								})(s.byteLength), t = n.concat([t, s])
							},
							s = e => {
								const i = (0, d.decodeBase64)(e),
									r = n.from(i);
								t = n.concat([t, r])
							};
						return r(e.prefix, "ascii", !1), i(e.version), i(e.mode), r(e.transactionId, "utf-8"), s(e.firstKeyB64), s(e.secondKeyB64), s(e.secretB64), t
					}
				}
				t.QRCodeData = g
			}).call(this, i("./node_modules/webpack/buildin/global.js"), i("./node_modules/buffer/index.js").Buffer)
		},
		"./node_modules/matrix-js-sdk/lib/crypto/verification/SAS.js": function(e, t, i) {
			"use strict";
			(function(e) {
				var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.SasEvent = t.SAS = void 0;
				var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
					s = n(i("./node_modules/another-json/another-json.js")),
					o = i("./node_modules/matrix-js-sdk/lib/crypto/verification/Base.js"),
					a = i("./node_modules/matrix-js-sdk/lib/crypto/verification/Error.js"),
					d = i("./node_modules/matrix-js-sdk/lib/logger.js"),
					l = i("./node_modules/matrix-js-sdk/lib/crypto/verification/SASDecimal.js"),
					c = i("./node_modules/matrix-js-sdk/lib/@types/event.js");
				const u = c.EventType.KeyVerificationStart,
					h = [c.EventType.KeyVerificationAccept, c.EventType.KeyVerificationKey, c.EventType.KeyVerificationMac];
				let m;
				const p = (0, a.errorFactory)("m.mismatched_sas", "Mismatched short authentication string"),
					g = (0, a.errorFactory)("m.mismatched_commitment", "Mismatched commitment"),
					f = [
						["🐶", "dog"],
						["🐱", "cat"],
						["🦁", "lion"],
						["🐎", "horse"],
						["🦄", "unicorn"],
						["🐷", "pig"],
						["🐘", "elephant"],
						["🐰", "rabbit"],
						["🐼", "panda"],
						["🐓", "rooster"],
						["🐧", "penguin"],
						["🐢", "turtle"],
						["🐟", "fish"],
						["🐙", "octopus"],
						["🦋", "butterfly"],
						["🌷", "flower"],
						["🌳", "tree"],
						["🌵", "cactus"],
						["🍄", "mushroom"],
						["🌏", "globe"],
						["🌙", "moon"],
						["☁️", "cloud"],
						["🔥", "fire"],
						["🍌", "banana"],
						["🍎", "apple"],
						["🍓", "strawberry"],
						["🌽", "corn"],
						["🍕", "pizza"],
						["🎂", "cake"],
						["❤️", "heart"],
						["🙂", "smiley"],
						["🤖", "robot"],
						["🎩", "hat"],
						["👓", "glasses"],
						["🔧", "spanner"],
						["🎅", "santa"],
						["👍", "thumbs up"],
						["☂️", "umbrella"],
						["⌛", "hourglass"],
						["⏰", "clock"],
						["🎁", "gift"],
						["💡", "light bulb"],
						["📕", "book"],
						["✏️", "pencil"],
						["📎", "paperclip"],
						["✂️", "scissors"],
						["🔒", "lock"],
						["🔑", "key"],
						["🔨", "hammer"],
						["☎️", "telephone"],
						["🏁", "flag"],
						["🚂", "train"],
						["🚲", "bicycle"],
						["✈️", "aeroplane"],
						["🚀", "rocket"],
						["🏆", "trophy"],
						["⚽", "ball"],
						["🎸", "guitar"],
						["🎺", "trumpet"],
						["🔔", "bell"],
						["⚓️", "anchor"],
						["🎧", "headphones"],
						["📁", "folder"],
						["📌", "pin"]
					];
				const v = {
					decimal: l.generateDecimalSas,
					emoji: function(e) {
						return [e[0] >> 2, (3 & e[0]) << 4 | e[1] >> 4, (15 & e[1]) << 2 | e[2] >> 6, 63 & e[2], e[3] >> 2, (3 & e[3]) << 4 | e[4] >> 4, (15 & e[4]) << 2 | e[5] >> 6].map(e => f[e])
					}
				};

				function y(e, t) {
					const i = {};
					for (const n of t) n in v && (i[n] = v[n](e));
					return i
				}
				const b = {
					"hkdf-hmac-sha256": "calculate_mac",
					"org.matrix.msc3783.hkdf-hmac-sha256": "calculate_mac_fixed_base64",
					"hmac-sha256": "calculate_mac_long_kdf"
				};

				function _(e, t) {
					return function(...i) {
						const n = e[b[t]].apply(e, i);
						return d.logger.log("SAS calculateMAC:", t, i, n), n
					}
				}
				const S = {
						"curve25519-hkdf-sha256": function(e, t, i) {
							const n = `${e.baseApis.getUserId()}|${e.baseApis.deviceId}|` + `${e.ourSASPubKey}|`,
								r = `${e.userId}|${e.deviceId}|${e.theirSASPubKey}|`,
								s = "MATRIX_KEY_VERIFICATION_SAS|" + (e.initiatedByMe ? n + r : r + n) + e.channel.transactionId;
							return t.generate_bytes(s, i)
						},
						curve25519: function(e, t, i) {
							const n = `${e.baseApis.getUserId()}${e.baseApis.deviceId}`,
								r = `${e.userId}${e.deviceId}`,
								s = "MATRIX_KEY_VERIFICATION_SAS" + (e.initiatedByMe ? n + r : r + n) + e.channel.transactionId;
							return t.generate_bytes(s, i)
						}
					},
					E = ["curve25519-hkdf-sha256", "curve25519"],
					w = ["sha256"],
					k = ["org.matrix.msc3783.hkdf-hmac-sha256", "hkdf-hmac-sha256", "hmac-sha256"],
					T = Object.keys(v),
					I = new Set(E),
					C = new Set(w),
					R = new Set(k),
					j = new Set(T);

				function O(e, t) {
					return Array.isArray(e) ? e.filter(e => t.has(e)) : []
				}
				let x;
				t.SasEvent = x,
					function(e) {
						e.ShowSas = "show_sas"
					}(x || (t.SasEvent = x = {}));
				class M extends o.VerificationBase {
					constructor(...t) {
						super(...t), (0, r.default)(this, "waitingForAccept", void 0), (0, r.default)(this, "ourSASPubKey", void 0), (0, r.default)(this, "theirSASPubKey", void 0), (0, r.default)(this, "sasEvent", void 0), (0, r.default)(this, "doVerification", async () => {
							await e.Olm.init(), m = m || new e.Olm.Utility, await this.baseApis.downloadKeys([this.userId]);
							let t = !1;
							do {
								try {
									return this.initiatedByMe ? await this.doSendVerification() : await this.doRespondVerification()
								} catch (i) {
									if (!(i instanceof o.SwitchStartEventError)) throw i;
									this.startEvent = i.startEvent, t = !0
								}
							} while (t)
						})
					}
					static get NAME() {
						return "m.sas.v1"
					}
					get events() {
						return h
					}
					canSwitchStartEvent(e) {
						if (e.getType() !== u) return !1;
						const t = e.getContent();
						return (null == t ? void 0 : t.method) === M.NAME && !!this.waitingForAccept
					}
					async sendStart() {
						const e = this.channel.completeContent(u, {
							method: M.NAME,
							from_device: this.baseApis.deviceId,
							key_agreement_protocols: E,
							hashes: w,
							message_authentication_codes: k,
							short_authentication_string: T
						});
						return await this.channel.sendCompleted(u, e), e
					}
					async verifyAndCheckMAC(e, t, i, n) {
						const r = S[e](this, i, 6),
							s = new Promise((e, s) => {
								this.sasEvent = {
									sas: y(r, t),
									confirm: async () => {
										try {
											await this.sendMAC(i, n), e()
										} catch (t) {
											s(t)
										}
									},
									cancel: () => s((0, a.newUserCancelledError)()),
									mismatch: () => s(p())
								}, this.emit(x.ShowSas, this.sasEvent)
							}),
							[o] = await Promise.all([this.waitForEvent(c.EventType.KeyVerificationMac).then(e => (this.expectedEvent = c.EventType.KeyVerificationDone, e)), s]),
							d = o.getContent();
						await this.checkMAC(i, d, n)
					}
					async doSendVerification() {
						let t, i;
						if (this.waitingForAccept = !0, t = this.startEvent ? this.channel.completedContentFromEvent(this.startEvent) : await this.sendStart(), !this.initiatedByMe) throw new o.SwitchStartEventError(this.startEvent);
						try {
							i = await this.waitForEvent(c.EventType.KeyVerificationAccept)
						} finally {
							this.waitingForAccept = !1
						}
						let n = i.getContent();
						const r = O(n.short_authentication_string, j);
						if (!(I.has(n.key_agreement_protocol) && C.has(n.hash) && R.has(n.message_authentication_code) && r.length)) throw (0, a.newUnknownMethodError)();
						if ("string" != typeof n.commitment) throw (0, a.newInvalidMessageError)();
						const d = n.key_agreement_protocol,
							l = n.message_authentication_code,
							u = n.commitment,
							h = new e.Olm.SAS;
						try {
							this.ourSASPubKey = h.get_pubkey(), await this.send(c.EventType.KeyVerificationKey, {
								key: this.ourSASPubKey
							});
							const e = (n = (i = await this.waitForEvent(c.EventType.KeyVerificationKey)).getContent()).key + s.default.stringify(t);
							if (m.sha256(e) !== u) throw g();
							this.theirSASPubKey = n.key, h.set_their_key(n.key), await this.verifyAndCheckMAC(d, r, h, l)
						} finally {
							h.free()
						}
					}
					async doRespondVerification() {
						let t = this.channel.completedContentFromEvent(this.startEvent);
						const i = O(E, new Set(t.key_agreement_protocols))[0],
							n = O(w, new Set(t.hashes))[0],
							r = O(k, new Set(t.message_authentication_codes))[0],
							o = O(t.short_authentication_string, j);
						if (void 0 === i || void 0 === n || void 0 === r || !o.length) throw (0, a.newUnknownMethodError)();
						const d = new e.Olm.SAS;
						try {
							const e = d.get_pubkey() + s.default.stringify(t);
							await this.send(c.EventType.KeyVerificationAccept, {
								key_agreement_protocol: i,
								hash: n,
								message_authentication_code: r,
								short_authentication_string: o,
								commitment: m.sha256(e)
							}), t = (await this.waitForEvent(c.EventType.KeyVerificationKey)).getContent(), this.theirSASPubKey = t.key, d.set_their_key(t.key), this.ourSASPubKey = d.get_pubkey(), await this.send(c.EventType.KeyVerificationKey, {
								key: this.ourSASPubKey
							}), await this.verifyAndCheckMAC(i, o, d, r)
						} finally {
							d.free()
						}
					}
					sendMAC(e, t) {
						const i = {},
							n = [],
							r = "MATRIX_KEY_VERIFICATION_MAC" + this.baseApis.getUserId() + this.baseApis.deviceId + this.userId + this.deviceId + this.channel.transactionId,
							s = `ed25519:${this.baseApis.deviceId}`;
						i[s] = _(e, t)(this.baseApis.getDeviceEd25519Key(), r + s), n.push(s);
						const o = this.baseApis.getCrossSigningId();
						if (o) {
							const s = `ed25519:${o}`;
							i[s] = _(e, t)(o, r + s), n.push(s)
						}
						const a = _(e, t)(n.sort().join(","), r + "KEY_IDS");
						return this.send(c.EventType.KeyVerificationMac, {
							mac: i,
							keys: a
						})
					}
					async checkMAC(e, t, i) {
						const n = "MATRIX_KEY_VERIFICATION_MAC" + this.userId + this.deviceId + this.baseApis.getUserId() + this.baseApis.deviceId + this.channel.transactionId;
						if (t.keys !== _(e, i)(Object.keys(t.mac).sort().join(","), n + "KEY_IDS")) throw (0, a.newKeyMismatchError)();
						await this.verifyKeys(this.userId, t.mac, (t, r, s) => {
							if (s !== _(e, i)(r.keys[t], n + t)) throw (0, a.newKeyMismatchError)()
						})
					}
				}
				t.SAS = M
			}).call(this, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/crypto/verification/SASDecimal.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.generateDecimalSas = function(e) {
				return [1e3 + (e[0] << 5 | e[1] >> 3), 1e3 + ((7 & e[1]) << 10 | e[2] << 2 | e[3] >> 6), 1e3 + ((63 & e[3]) << 7 | e[4] >> 1)]
			}
		},
		"./node_modules/matrix-js-sdk/lib/crypto/verification/request/InRoomChannel.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.InRoomRequests = t.InRoomChannel = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/crypto/verification/request/VerificationRequest.js"),
				o = i("./node_modules/matrix-js-sdk/lib/logger.js");
			const a = i("./node_modules/matrix-js-sdk/lib/@types/event.js").EventType.RoomMessage,
				d = "m.reference",
				l = "m.relates_to";
			class c {
				constructor(e, t, i) {
					this.client = e, this.roomId = t, this.userId = i, (0, r.default)(this, "requestEventId", void 0)
				}
				get receiveStartFromOtherDevices() {
					return !0
				}
				get transactionId() {
					return this.requestEventId
				}
				static getOtherPartyUserId(e, t) {
					if (c.getEventType(e) !== s.REQUEST_TYPE) return;
					const i = t.getUserId(),
						n = e.getSender(),
						r = e.getContent().to;
					return n === i ? r : r === i ? n : void 0
				}
				getTimestamp(e) {
					return e.getTs()
				}
				static canCreateRequest(e) {
					return e === s.REQUEST_TYPE
				}
				canCreateRequest(e) {
					return c.canCreateRequest(e)
				}
				static getTransactionId(e) {
					if (c.getEventType(e) === s.REQUEST_TYPE) return e.getId(); {
						const t = e.getRelation();
						if ((null == t ? void 0 : t.rel_type) === d) return t.event_id
					}
				}
				static validateEvent(e, t) {
					const i = c.getTransactionId(e);
					if ("string" != typeof i || 0 === i.length) return !1;
					const n = c.getEventType(e),
						r = e.getContent();
					if (n === s.REQUEST_TYPE) {
						if (!r || "string" != typeof r.to || !r.to.length) return o.logger.log("InRoomChannel: validateEvent: no valid to " + (r && r.to)), !1;
						if (!c.getOtherPartyUserId(e, t)) return o.logger.log("InRoomChannel: validateEvent: " + `not directed to or sent by me: ${e.getSender()}` + `, ${r&&r.to}`), !1
					}
					return s.VerificationRequest.validateEvent(n, e, t)
				}
				static getEventType(e) {
					const t = e.getType();
					if (t === a) {
						const t = e.getContent();
						if (t) {
							const {
								msgtype: e
							} = t;
							if (e === s.REQUEST_TYPE) return s.REQUEST_TYPE
						}
					}
					return t && t !== s.REQUEST_TYPE ? t : ""
				}
				async handleEvent(e, t, i = !1) {
					if (t.hasEventId(e.getId())) return;
					const n = c.getEventType(e);
					if (e.getRoomId() !== this.roomId) return;
					if (!this.userId) {
						const t = c.getOtherPartyUserId(e, this.client);
						t && (this.userId = t)
					}
					const r = this.client.getUserId(),
						s = e.getSender();
					if (this.userId && s !== r && s !== this.userId) return void o.logger.log(`InRoomChannel: ignoring verification event from non-participating sender ${s}`);
					this.requestEventId || (this.requestEventId = c.getTransactionId(e));
					const a = !!e.getUnsigned().transaction_id,
						d = e.getSender() === this.client.getUserId();
					return t.handleEvent(n, e, i, a, d)
				}
				completedContentFromEvent(e) {
					const t = Object.assign({}, e.getContent());
					return t[l] = e.getRelation(), t
				}
				completeContent(e, t) {
					return t = Object.assign({}, t), e !== s.REQUEST_TYPE && e !== s.READY_TYPE && e !== s.START_TYPE || (t.from_device = this.client.getDeviceId()), e === s.REQUEST_TYPE ? t = {
						body: this.client.getUserId() + " is requesting to verify your key, but your client does not support in-chat key verification.  You will need to use legacy key verification to verify keys.",
						msgtype: s.REQUEST_TYPE,
						to: this.userId,
						from_device: t.from_device,
						methods: t.methods
					} : t[l] = {
						rel_type: d,
						event_id: this.transactionId
					}, t
				}
				send(e, t) {
					const i = this.completeContent(e, t);
					return this.sendCompleted(e, i)
				}
				async sendCompleted(e, t) {
					let i = e;
					e === s.REQUEST_TYPE && (i = a);
					const n = await this.client.sendEvent(this.roomId, i, t);
					e === s.REQUEST_TYPE && (this.requestEventId = n.event_id)
				}
			}
			t.InRoomChannel = c;
			t.InRoomRequests = class {
				constructor() {
					(0, r.default)(this, "requestsByRoomId", new Map)
				}
				getRequest(e) {
					const t = e.getRoomId(),
						i = c.getTransactionId(e);
					return this.getRequestByTxnId(t, i)
				}
				getRequestByChannel(e) {
					return this.getRequestByTxnId(e.roomId, e.transactionId)
				}
				getRequestByTxnId(e, t) {
					const i = this.requestsByRoomId.get(e);
					if (i) return i.get(t)
				}
				setRequest(e, t) {
					this.doSetRequest(e.getRoomId(), c.getTransactionId(e), t)
				}
				setRequestByChannel(e, t) {
					this.doSetRequest(e.roomId, e.transactionId, t)
				}
				doSetRequest(e, t, i) {
					let n = this.requestsByRoomId.get(e);
					n || (n = new Map, this.requestsByRoomId.set(e, n)), n.set(t, i)
				}
				removeRequest(e) {
					const t = e.getRoomId(),
						i = this.requestsByRoomId.get(t);
					i && (i.delete(c.getTransactionId(e)), 0 === i.size && this.requestsByRoomId.delete(t))
				}
				findRequestInProgress(e) {
					const t = this.requestsByRoomId.get(e);
					if (t)
						for (const i of t.values())
							if (i.pending) return i
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/crypto/verification/request/ToDeviceChannel.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.ToDeviceRequests = t.ToDeviceChannel = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/randomstring.js"),
				o = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				a = i("./node_modules/matrix-js-sdk/lib/crypto/verification/request/VerificationRequest.js"),
				d = i("./node_modules/matrix-js-sdk/lib/crypto/verification/Error.js"),
				l = i("./node_modules/matrix-js-sdk/lib/models/event.js");
			class c {
				constructor(e, t, i, n, s) {
					this.client = e, this.userId = t, this.devices = i, this.transactionId = n, this.deviceId = s, (0, r.default)(this, "request", void 0)
				}
				isToDevices(e) {
					if (e.length === this.devices.length) {
						for (const t of e)
							if (!this.devices.includes(t)) return !1;
						return !0
					}
					return !1
				}
				static getEventType(e) {
					return e.getType()
				}
				static getTransactionId(e) {
					const t = e.getContent();
					return t && t.transaction_id
				}
				static canCreateRequest(e) {
					return e === a.REQUEST_TYPE || e === a.START_TYPE
				}
				canCreateRequest(e) {
					return c.canCreateRequest(e)
				}
				static validateEvent(e, t) {
					if (e.isCancelled()) return o.logger.warn("Ignoring flagged verification request from " + e.getSender()), !1;
					const i = e.getContent();
					if (!i) return o.logger.warn("ToDeviceChannel.validateEvent: invalid: no content"), !1;
					if (!i.transaction_id) return o.logger.warn("ToDeviceChannel.validateEvent: invalid: no transaction_id"), !1;
					const n = e.getType();
					if (n === a.REQUEST_TYPE) {
						if (!Number.isFinite(i.timestamp)) return o.logger.warn("ToDeviceChannel.validateEvent: invalid: no timestamp"), !1;
						if (e.getSender() === t.getUserId() && i.from_device == t.getDeviceId()) return o.logger.warn("ToDeviceChannel.validateEvent: invalid: from own device"), !1
					}
					return a.VerificationRequest.validateEvent(n, e, t)
				}
				getTimestamp(e) {
					const t = e.getContent();
					return t && t.timestamp
				}
				async handleEvent(e, t, i = !1) {
					const n = e.getType(),
						r = e.getContent();
					if (n === a.REQUEST_TYPE || n === a.READY_TYPE || n === a.START_TYPE) {
						this.transactionId || (this.transactionId = r.transaction_id);
						const e = r.from_device;
						if (!this.deviceId && this.devices.includes(e) && (this.deviceId = e), !this.deviceId || this.deviceId !== e) {
							const t = this.completeContent(a.CANCEL_TYPE, (0, d.errorFromEvent)((0, d.newUnexpectedMessageError)()));
							return this.sendToDevices(a.CANCEL_TYPE, t, [e])
						}
					}
					const s = t.phase === a.PHASE_STARTED || t.phase === a.PHASE_READY;
					await t.handleEvent(e.getType(), e, i, !1, !1);
					const o = t.phase === a.PHASE_STARTED || t.phase === a.PHASE_READY;
					if ((n === a.START_TYPE || n === a.READY_TYPE) && !s && o && this.deviceId) {
						const e = this.devices.filter(e => e !== this.deviceId && e !== this.client.getDeviceId());
						if (e.length) {
							const t = this.completeContent(a.CANCEL_TYPE, {
								code: "m.accepted",
								reason: "Verification request accepted by another device"
							});
							await this.sendToDevices(a.CANCEL_TYPE, t, e)
						}
					}
				}
				completedContentFromEvent(e) {
					return e.getContent()
				}
				completeContent(e, t) {
					return t = Object.assign({}, t), this.transactionId && (t.transaction_id = this.transactionId), e !== a.REQUEST_TYPE && e !== a.READY_TYPE && e !== a.START_TYPE || (t.from_device = this.client.getDeviceId()), e === a.REQUEST_TYPE && (t.timestamp = Date.now()), t
				}
				send(e, t = {}) {
					e !== a.REQUEST_TYPE && e !== a.START_TYPE || this.transactionId || (this.transactionId = c.makeTransactionId());
					const i = this.completeContent(e, t);
					return this.sendCompleted(e, i)
				}
				async sendCompleted(e, t) {
					let i;
					i = e === a.REQUEST_TYPE || e === a.CANCEL_TYPE && !this.deviceId ? await this.sendToDevices(e, t, this.devices) : await this.sendToDevices(e, t, [this.deviceId]);
					const n = new l.MatrixEvent({
						sender: this.client.getUserId(),
						content: t,
						type: e
					});
					return await this.request.handleEvent(e, n, !0, !0, !0), i
				}
				async sendToDevices(e, t, i) {
					if (i.length) {
						const n = {};
						for (const e of i) n[e] = t;
						await this.client.sendToDevice(e, {
							[this.userId]: n
						})
					}
				}
				static makeTransactionId() {
					return (0, s.randomString)(32)
				}
			}
			t.ToDeviceChannel = c;
			t.ToDeviceRequests = class {
				constructor() {
					(0, r.default)(this, "requestsByUserId", new Map)
				}
				getRequest(e) {
					return this.getRequestBySenderAndTxnId(e.getSender(), c.getTransactionId(e))
				}
				getRequestByChannel(e) {
					return this.getRequestBySenderAndTxnId(e.userId, e.transactionId)
				}
				getRequestBySenderAndTxnId(e, t) {
					const i = this.requestsByUserId.get(e);
					if (i) return i.get(t)
				}
				setRequest(e, t) {
					this.setRequestBySenderAndTxnId(e.getSender(), c.getTransactionId(e), t)
				}
				setRequestByChannel(e, t) {
					this.setRequestBySenderAndTxnId(e.userId, e.transactionId, t)
				}
				setRequestBySenderAndTxnId(e, t, i) {
					let n = this.requestsByUserId.get(e);
					n || (n = new Map, this.requestsByUserId.set(e, n)), n.set(t, i)
				}
				removeRequest(e) {
					const t = e.getSender(),
						i = this.requestsByUserId.get(t);
					i && (i.delete(c.getTransactionId(e)), 0 === i.size && this.requestsByUserId.delete(t))
				}
				findRequestInProgress(e, t) {
					const i = this.requestsByUserId.get(e);
					if (i)
						for (const n of i.values())
							if (n.pending && n.channel.isToDevices(t)) return n
				}
				getRequestsInProgress(e) {
					const t = this.requestsByUserId.get(e);
					return t ? Array.from(t.values()).filter(e => e.pending) : []
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/crypto/verification/request/VerificationRequest.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.VerificationRequestEvent = t.VerificationRequest = t.START_TYPE = t.REQUEST_TYPE = t.READY_TYPE = t.Phase = t.PHASE_UNSENT = t.PHASE_STARTED = t.PHASE_REQUESTED = t.PHASE_READY = t.PHASE_DONE = t.PHASE_CANCELLED = t.EVENT_PREFIX = t.DONE_TYPE = t.CANCEL_TYPE = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = i("./node_modules/matrix-js-sdk/lib/crypto/verification/Error.js"),
				a = i("./node_modules/matrix-js-sdk/lib/crypto/verification/QRCode.js"),
				d = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				l = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js");
			const c = 6e5,
				u = 12e4,
				h = 3e3,
				m = "m.key.verification.";
			t.EVENT_PREFIX = m;
			const p = m + "request";
			t.REQUEST_TYPE = p;
			const g = m + "start";
			t.START_TYPE = g;
			const f = m + "cancel";
			t.CANCEL_TYPE = f;
			const v = m + "done";
			t.DONE_TYPE = v;
			const y = m + "ready";
			let b;
			t.READY_TYPE = y, t.Phase = b,
				function(e) {
					e[e.Unsent = 1] = "Unsent", e[e.Requested = 2] = "Requested", e[e.Ready = 3] = "Ready", e[e.Started = 4] = "Started", e[e.Cancelled = 5] = "Cancelled", e[e.Done = 6] = "Done"
				}(b || (t.Phase = b = {}));
			const _ = b.Unsent;
			t.PHASE_UNSENT = _;
			const S = b.Requested;
			t.PHASE_REQUESTED = S;
			const E = b.Ready;
			t.PHASE_READY = E;
			const w = b.Started;
			t.PHASE_STARTED = w;
			const k = b.Cancelled;
			t.PHASE_CANCELLED = k;
			const T = b.Done;
			let I;
			t.PHASE_DONE = T, t.VerificationRequestEvent = I,
				function(e) {
					e.Change = "change"
				}(I || (t.VerificationRequestEvent = I = {}));
			class C extends l.TypedEventEmitter {
				constructor(e, t, i) {
					super(), this.channel = e, this.verificationMethods = t, this.client = i, (0, r.default)(this, "eventsByUs", new Map), (0, r.default)(this, "eventsByThem", new Map), (0, r.default)(this, "_observeOnly", !1), (0, r.default)(this, "timeoutTimer", null), (0, r.default)(this, "_accepting", !1), (0, r.default)(this, "_declining", !1), (0, r.default)(this, "verifierHasFinished", !1), (0, r.default)(this, "_cancelled", !1), (0, r.default)(this, "_chosenMethod", null), (0, r.default)(this, "_qrCodeData", null), (0, r.default)(this, "requestReceivedAt", null), (0, r.default)(this, "commonMethods", []), (0, r.default)(this, "_phase", void 0), (0, r.default)(this, "_cancellingUserId", void 0), (0, r.default)(this, "_verifier", void 0), (0, r.default)(this, "cancelOnTimeout", async () => {
						try {
							this.initiatedByMe ? await this.cancel({
								reason: "Other party didn't accept in time",
								code: "m.timeout"
							}) : await this.cancel({
								reason: "User didn't accept in time",
								code: "m.timeout"
							})
						} catch (e) {
							s.logger.error("Error while cancelling verification request", e)
						}
					}), this.channel.request = this, this.setPhase(_, !1)
				}
				static validateEvent(e, t, i) {
					const n = t.getContent();
					return !(!e || !e.startsWith(m)) && (n ? e !== p && e !== y || Array.isArray(n.methods) ? e !== p && e !== y && e !== g || "string" == typeof n.from_device && 0 !== n.from_device.length || (s.logger.log("VerificationRequest: validateEvent: fail because from_device"), !1) : (s.logger.log("VerificationRequest: validateEvent: fail because methods"), !1) : (s.logger.log("VerificationRequest: validateEvent: no content"), !1))
				}
				get invalid() {
					return this.phase === _
				}
				get requested() {
					return this.phase === S
				}
				get cancelled() {
					return this.phase === k
				}
				get ready() {
					return this.phase === E
				}
				get started() {
					return this.phase === w
				}
				get done() {
					return this.phase === T
				}
				get methods() {
					return this.commonMethods
				}
				get chosenMethod() {
					return this._chosenMethod
				}
				calculateEventTimeout(e) {
					let t = this.channel.getTimestamp(e) + c;
					if (this.requestReceivedAt && !this.initiatedByMe && this.phase <= S) {
						const e = this.requestReceivedAt + u;
						t = Math.min(t, e)
					}
					return Math.max(0, t - Date.now())
				}
				get timeout() {
					const e = this.getEventByEither(p);
					return e ? this.calculateEventTimeout(e) : 0
				}
				get requestEvent() {
					return this.getEventByEither(p)
				}
				get phase() {
					return this._phase
				}
				get verifier() {
					return this._verifier
				}
				get canAccept() {
					return this.phase < E && !this._accepting && !this._declining
				}
				get accepting() {
					return this._accepting
				}
				get declining() {
					return this._declining
				}
				get pending() {
					return !this.observeOnly && this._phase !== T && this._phase !== k
				}
				get qrCodeData() {
					return this._qrCodeData
				}
				otherPartySupportsMethod(e, t = !1) {
					if (!t && !this.ready && !this.started) return !1;
					const i = this.eventsByThem.get(p) || this.eventsByThem.get(y);
					if (!i) {
						if (this.started && this.initiatedByMe) {
							const t = this.eventsByUs.get(g),
								i = t && t.getContent();
							return e == (i && i.method)
						}
						return !1
					}
					const n = i.getContent();
					if (!n) return !1;
					const {
						methods: r
					} = n;
					return !!Array.isArray(r) && r.includes(e)
				}
				get initiatedByMe() {
					const e = this.eventsByUs.size + this.eventsByThem.size === 0;
					if (this._phase === _ && e) return !0;
					const t = this.eventsByUs.has(p),
						i = this.eventsByThem.has(p);
					if (t && !i) return !0;
					if (!t && i) return !1;
					const n = this.eventsByUs.has(g),
						r = this.eventsByThem.has(g);
					return !(!n || r)
				}
				get requestingUserId() {
					return this.initiatedByMe ? this.client.getUserId() : this.otherUserId
				}
				get receivingUserId() {
					return this.initiatedByMe ? this.otherUserId : this.client.getUserId()
				}
				get otherUserId() {
					return this.channel.userId
				}
				get isSelfVerification() {
					return this.client.getUserId() === this.otherUserId
				}
				get cancellingUserId() {
					const e = this.eventsByUs.get(f),
						t = this.eventsByThem.get(f);
					return e && (!t || e.getId() < t.getId()) ? e.getSender() : t ? t.getSender() : void 0
				}
				get cancellationCode() {
					const e = this.getEventByEither(f);
					return e ? e.getContent().code : null
				}
				get observeOnly() {
					return this._observeOnly
				}
				get targetDevice() {
					const e = this.eventsByThem.get(p) || this.eventsByThem.get(y) || this.eventsByThem.get(g),
						t = null == e ? void 0 : e.getContent(),
						i = null == t ? void 0 : t.from_device;
					return {
						userId: this.otherUserId,
						deviceId: i
					}
				}
				beginKeyVerification(e, t = null) {
					if (!this.observeOnly && !this._verifier) {
						if (this.phase === S || this.phase === E || this.phase === _ && this.channel.canCreateRequest(g)) {
							if (this.commonMethods.length && !this.commonMethods.includes(e)) throw (0, o.newUnknownMethodError)();
							if (this._verifier = this.createVerifier(e, null, t), !this._verifier) throw (0, o.newUnknownMethodError)();
							this._chosenMethod = e
						}
					}
					return this._verifier
				}
				async sendRequest() {
					if (!this.observeOnly && this._phase === _) {
						const e = [...this.verificationMethods.keys()];
						await this.channel.send(p, {
							methods: e
						})
					}
				}
				async cancel({
					reason: e = "User declined",
					code: t = "m.user"
				} = {}) {
					if (!this.observeOnly && this._phase !== k) {
						if (this._declining = !0, this.emit(I.Change), this._verifier) return this._verifier.cancel((0, o.errorFactory)(t, e)());
						this._cancellingUserId = this.client.getUserId(), await this.channel.send(f, {
							code: t,
							reason: e
						})
					}
				}
				async accept() {
					if (!this.observeOnly && this.phase === S && !this.initiatedByMe) {
						const e = [...this.verificationMethods.keys()];
						this._accepting = !0, this.emit(I.Change), await this.channel.send(y, {
							methods: e
						})
					}
				}
				waitFor(e) {
					return new Promise((t, i) => {
						const n = () => {
							let r = !1;
							return e(this) ? (t(this), r = !0) : this.cancelled && (i(new Error("cancelled")), r = !0), r && this.off(I.Change, n), r
						};
						n() || this.on(I.Change, n)
					})
				}
				setPhase(e, t = !0) {
					this._phase = e, t && this.emit(I.Change)
				}
				getEventByEither(e) {
					return this.eventsByThem.get(e) || this.eventsByUs.get(e)
				}
				getEventBy(e, t = !1) {
					return t ? this.eventsByThem.get(e) : this.eventsByUs.get(e)
				}
				calculatePhaseTransitions() {
					const e = [{
							phase: _
						}],
						t = () => e[e.length - 1].phase,
						i = this.eventsByThem.has(p),
						n = this.getEventBy(p, i);
					n && e.push({
						phase: S,
						event: n
					});
					const r = n && this.getEventBy(y, !i);
					let s;
					if (r && t() === S && e.push({
							phase: E,
							event: r
						}), r || !n) {
						const e = this.eventsByThem.get(g),
							t = this.eventsByUs.get(g);
						s = e && t ? e.getSender() < t.getSender() ? e : t : e || t
					} else s = this.getEventBy(g, !i);
					if (s) {
						const i = t() === S && (null == n ? void 0 : n.getSender()) !== s.getSender(),
							r = t() === _ && this.channel.canCreateRequest(g);
						(i || t() === E || r) && e.push({
							phase: w,
							event: s
						})
					}
					const o = this.eventsByUs.get(v);
					(this.verifierHasFinished || o && t() === w) && e.push({
						phase: T
					});
					const a = this.getEventByEither(f);
					return (this._cancelled || a) && t() !== T ? (e.push({
						phase: k,
						event: a
					}), e) : e
				}
				transitionToPhase(e) {
					const {
						phase: t,
						event: i
					} = e;
					if ((t === S || t === E) && !this.wasSentByOwnDevice(i)) {
						const e = i.getContent();
						this.commonMethods = e.methods.filter(e => this.verificationMethods.has(e))
					}
					if (this.observeOnly || t !== S && t !== w && t !== E || this.channel.receiveStartFromOtherDevices && this.wasSentByOwnUser(i) && !this.wasSentByOwnDevice(i) && (this._observeOnly = !0), t === w) {
						const {
							method: e
						} = i.getContent();
						this._verifier || this.observeOnly || (this._verifier = this.createVerifier(e, i), this._verifier ? this._chosenMethod = e : this.cancel({
							code: "m.unknown_method",
							reason: `Unknown method: ${e}`
						}))
					}
				}
				applyPhaseTransitions() {
					const e = this.calculatePhaseTransitions(),
						t = e.findIndex(e => e.phase === this.phase),
						i = e.slice(t + 1);
					for (const n of i) this.transitionToPhase(n);
					return i
				}
				isWinningStartRace(e) {
					if (e.getType() !== g) return !1;
					const t = this._verifier.startEvent;
					let i, n;
					if (this.isSelfVerification)
						if (t) {
							const e = t.getContent();
							i = e && e.from_device
						} else i = this.client.getDeviceId();
					else i = t ? t.getSender() : this.client.getUserId();
					if (this.isSelfVerification) {
						const t = e.getContent();
						n = t && t.from_device
					} else n = e.getSender();
					return n < i
				}
				hasEventId(e) {
					for (const t of this.eventsByUs.values())
						if (t.getId() === e) return !0;
					for (const t of this.eventsByThem.values())
						if (t.getId() === e) return !0;
					return !1
				}
				async handleEvent(e, t, i, n, r) {
					if (this.done || this.cancelled) return;
					const o = this._observeOnly;
					if (this.adjustObserveOnly(t, i), !this.observeOnly && !n && await this.cancelOnError(e, t)) return;
					if (r ? this.eventsByUs.has(e) : this.eventsByThem.has(e)) return;
					const d = this.phase;
					this.addEvent(e, t, r);
					const l = this.applyPhaseTransitions();
					try {
						if (this._verifier && !this.observeOnly) {
							const i = this.isWinningStartRace(t);
							if (this._verifier.canSwitchStartEvent(t) && i) this._verifier.switchStartEvent(t);
							else if (!n) {
								var c;
								(e === f || null !== (c = this._verifier.events) && void 0 !== c && c.includes(e)) && this._verifier.handleEvent(t)
							}
						}
						if (l.length) {
							if (i && l.some(e => e.phase === E)) {
								this.otherPartySupportsMethod(a.SCAN_QR_CODE_METHOD, !0) && (this._qrCodeData = await a.QRCodeData.create(this, this.client))
							}
							const e = l[l.length - 1],
								{
									phase: t
								} = e;
							this.setupTimeout(t), this.setPhase(t)
						} else this._observeOnly !== o && this.emit(I.Change)
					} finally {
						s.logger.log(`Verification request ${this.channel.transactionId}: ` + `${e} event with id:${t.getId()}, ` + `content:${JSON.stringify(t.getContent())} ` + `deviceId:${this.channel.deviceId}, ` + `sender:${t.getSender()}, isSentByUs:${r}, ` + `isLiveEvent:${i}, isRemoteEcho:${n}, ` + `phase:${d}=>${this.phase}, ` + `observeOnly:${o}=>${this._observeOnly}`)
					}
				}
				setupTimeout(e) {
					if (!this.timeoutTimer && !this.observeOnly && e === S && (this.timeoutTimer = setTimeout(this.cancelOnTimeout, this.timeout)), this.timeoutTimer) {
						(e === w || e === E || e === T || e === k) && (clearTimeout(this.timeoutTimer), this.timeoutTimer = null)
					}
				}
				async cancelOnError(e, t) {
					if (e === g) {
						const e = t.getContent().method;
						if (!this.verificationMethods.has(e)) return await this.cancel((0, o.errorFromEvent)((0, o.newUnknownMethodError)())), !0
					}
					const i = e === p && this.phase !== _,
						n = e === y && this.phase !== S && this.phase !== w;
					if (this.phase !== _ && (i || n)) {
						s.logger.warn(`Cancelling, unexpected ${e} verification ` + `event from ${t.getSender()}`);
						const i = `Unexpected ${e} event in phase ${this.phase}`;
						return await this.cancel((0, o.errorFromEvent)((0, o.newUnexpectedMessageError)({
							reason: i
						}))), !0
					}
					return !1
				}
				adjustObserveOnly(e, t = !1) {
					t || (this._observeOnly = !0), this.calculateEventTimeout(e) < h && (this._observeOnly = !0)
				}
				addEvent(e, t, i = !1) {
					if (i ? this.eventsByUs.set(e, t) : this.eventsByThem.set(e, t), e === p) {
						for (const [e, t] of this.eventsByThem.entries()) t.getSender() !== this.otherUserId && this.eventsByThem.delete(e);
						this.requestReceivedAt = Date.now()
					}
				}
				createVerifier(e, t = null, i = null) {
					i || (i = this.targetDevice);
					const {
						userId: n,
						deviceId: r
					} = i, o = this.verificationMethods.get(e);
					if (o) return new o(this.channel, this.client, n, r, t, this);
					s.logger.warn("could not find verifier constructor for method", e)
				}
				wasSentByOwnUser(e) {
					return (null == e ? void 0 : e.getSender()) === this.client.getUserId()
				}
				wasSentByOwnDevice(e) {
					if (!this.wasSentByOwnUser(e)) return !1;
					const t = e.getContent();
					return !(!t || t.from_device !== this.client.getDeviceId())
				}
				onVerifierCancelled() {
					this._cancelled = !0;
					const e = this.applyPhaseTransitions();
					e.length && this.setPhase(e[e.length - 1].phase)
				}
				onVerifierFinished() {
					this.channel.send(d.EventType.KeyVerificationDone, {}), this.verifierHasFinished = !0;
					const e = this.applyPhaseTransitions();
					e.length && this.setPhase(e[e.length - 1].phase)
				}
				getEventFromOtherParty(e) {
					return this.eventsByThem.get(e)
				}
			}
			t.VerificationRequest = C
		},
		"./node_modules/matrix-js-sdk/lib/embedded.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.RoomWidgetClient = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-widget-api/lib/index.js"),
				o = i("./node_modules/matrix-js-sdk/lib/models/event.js"),
				a = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				d = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				l = i("./node_modules/matrix-js-sdk/lib/client.js"),
				c = i("./node_modules/matrix-js-sdk/lib/sync.js"),
				u = i("./node_modules/matrix-js-sdk/lib/sliding-sync-sdk.js"),
				h = i("./node_modules/matrix-js-sdk/lib/models/user.js");
			class m extends l.MatrixClient {
				constructor(e, t, i, n) {
					var u, h, m, p, g, f, v, y, b, _;
					super(n), this.widgetApi = e, this.capabilities = t, this.roomId = i, (0, r.default)(this, "room", void 0), (0, r.default)(this, "widgetApiReady", new Promise(e => this.widgetApi.once("ready", e))), (0, r.default)(this, "lifecycle", void 0), (0, r.default)(this, "syncState", null), (0, r.default)(this, "onEvent", async e => {
						if (e.preventDefault(), e.detail.data.room_id === this.roomId) {
							const t = new o.MatrixEvent(e.detail.data);
							await this.syncApi.injectRoomEvents(this.room, [], [t]), this.emit(l.ClientEvent.Event, t), this.setSyncState(c.SyncState.Syncing), d.logger.info(`Received event ${t.getId()} ${t.getType()} ${t.getStateKey()}`)
						} else {
							const {
								event_id: t,
								room_id: i
							} = e.detail.data;
							d.logger.info(`Received event ${t} for a different room ${i}; discarding`)
						}
						await this.ack(e)
					}), (0, r.default)(this, "onToDevice", async e => {
						e.preventDefault();
						const t = new o.MatrixEvent({
							type: e.detail.data.type,
							sender: e.detail.data.sender,
							content: e.detail.data.content
						});
						e.detail.data.encrypted && t.makeEncrypted(a.EventType.RoomMessageEncrypted, {}, "", ""), this.emit(l.ClientEvent.ToDeviceEvent, t), this.setSyncState(c.SyncState.Syncing), await this.ack(e)
					}), (null !== (u = t.sendEvent) && void 0 !== u && u.length || null !== (h = t.receiveEvent) && void 0 !== h && h.length || !0 === t.sendMessage || Array.isArray(t.sendMessage) && t.sendMessage.length || !0 === t.receiveMessage || Array.isArray(t.receiveMessage) && t.receiveMessage.length || null !== (m = t.sendState) && void 0 !== m && m.length || null !== (p = t.receiveState) && void 0 !== p && p.length) && e.requestCapabilityForRoomTimeline(i), null === (g = t.sendEvent) || void 0 === g || g.forEach(t => e.requestCapabilityToSendEvent(t)), null === (f = t.receiveEvent) || void 0 === f || f.forEach(t => e.requestCapabilityToReceiveEvent(t)), !0 === t.sendMessage ? e.requestCapabilityToSendMessage() : Array.isArray(t.sendMessage) && t.sendMessage.forEach(t => e.requestCapabilityToSendMessage(t)), !0 === t.receiveMessage ? e.requestCapabilityToReceiveMessage() : Array.isArray(t.receiveMessage) && t.receiveMessage.forEach(t => e.requestCapabilityToReceiveMessage(t)), null === (v = t.sendState) || void 0 === v || v.forEach(({
						eventType: t,
						stateKey: i
					}) => e.requestCapabilityToSendState(t, i)), null === (y = t.receiveState) || void 0 === y || y.forEach(({
						eventType: t,
						stateKey: i
					}) => e.requestCapabilityToReceiveState(t, i)), null === (b = t.sendToDevice) || void 0 === b || b.forEach(t => e.requestCapabilityToSendToDevice(t)), null === (_ = t.receiveToDevice) || void 0 === _ || _.forEach(t => e.requestCapabilityToReceiveToDevice(t)), t.turnServers && e.requestCapability(s.MatrixCapabilities.MSC3846TurnServers), e.on(`action:${s.WidgetApiToWidgetAction.SendEvent}`, this.onEvent), e.on(`action:${s.WidgetApiToWidgetAction.SendToDevice}`, this.onToDevice), e.start()
				}
				async startClient(e = {}) {
					var t, i;
					this.lifecycle = new AbortController;
					const n = this.getUserId();
					n && this.store.storeUser(new h.User(n)), e.slidingSync ? this.syncApi = new u.SlidingSyncSdk(e.slidingSync, this, e) : this.syncApi = new c.SyncApi(this, e), this.room = this.syncApi.createRoom(this.roomId), this.store.storeRoom(this.room), await this.widgetApiReady, await Promise.all(null !== (t = null === (i = this.capabilities.receiveState) || void 0 === i ? void 0 : i.map(async ({
						eventType: e,
						stateKey: t
					}) => {
						const i = (await this.widgetApi.readStateEvents(e, void 0, t, [this.roomId])).map(e => new o.MatrixEvent(e));
						await this.syncApi.injectRoomEvents(this.room, [], i), i.forEach(e => {
							this.emit(l.ClientEvent.Event, e), d.logger.info(`Backfilled event ${e.getId()} ${e.getType()} ${e.getStateKey()}`)
						})
					})) && void 0 !== t ? t : []), this.setSyncState(c.SyncState.Syncing), d.logger.info("Finished backfilling events"), this.capabilities.turnServers && this.watchTurnServers()
				}
				stopClient() {
					this.widgetApi.off(`action:${s.WidgetApiToWidgetAction.SendEvent}`, this.onEvent), this.widgetApi.off(`action:${s.WidgetApiToWidgetAction.SendToDevice}`, this.onToDevice), super.stopClient(), this.lifecycle.abort()
				}
				async joinRoom(e) {
					if (e === this.roomId) return this.room;
					throw new Error(`Unknown room: ${e}`)
				}
				async encryptAndSendEvent(e, t) {
					let i;
					try {
						i = await this.widgetApi.sendRoomEvent(t.getType(), t.getContent(), e.roomId)
					} catch (n) {
						throw this.updatePendingEventStatus(e, t, o.EventStatus.NOT_SENT), n
					}
					return e.updatePendingEvent(t, o.EventStatus.SENT, i.event_id), {
						event_id: i.event_id
					}
				}
				async sendStateEvent(e, t, i, n = "") {
					return await this.widgetApi.sendStateEvent(t, n, i, e)
				}
				async sendToDevice(e, t) {
					return await this.widgetApi.sendToDevice(e, !1, t), {}
				}
				async queueToDevice({
					eventType: e,
					batch: t
				}) {
					const i = {};
					for (const {
							userId: n,
							deviceId: r,
							payload: s
						} of t) i[n] || (i[n] = {}), i[n][r] = s;
					await this.widgetApi.sendToDevice(e, !1, i)
				}
				async encryptAndSendToDevices(e, t) {
					const i = {};
					for (const {
							userId: n,
							deviceInfo: {
								deviceId: r
							}
						} of e) i[n] || (i[n] = {}), i[n][r] = t;
					await this.widgetApi.sendToDevice(t.type, !0, i)
				}
				async checkTurnServers() {
					return this.turnServers.length > 0
				}
				getSyncState() {
					return this.syncState
				}
				setSyncState(e) {
					const t = this.syncState;
					this.syncState = e, this.emit(l.ClientEvent.Sync, e, t)
				}
				async ack(e) {
					await this.widgetApi.transport.reply(e.detail, {})
				}
				async watchTurnServers() {
					const e = this.widgetApi.getTurnServers(),
						t = () => e.return(void 0);
					this.lifecycle.signal.addEventListener("abort", t);
					try {
						for await (const t of e) this.turnServers = [{
							urls: t.uris,
							username: t.username,
							credential: t.password
						}], this.emit(l.ClientEvent.TurnServers, this.turnServers), d.logger.log(`Received TURN server: ${t.uris}`)
					} catch (i) {
						d.logger.warn("Error watching TURN servers", i)
					} finally {
						this.lifecycle.signal.removeEventListener("abort", t)
					}
				}
			}
			t.RoomWidgetClient = m
		},
		"./node_modules/matrix-js-sdk/lib/errors.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.KeySignatureUploadError = t.InvalidStoreState = t.InvalidStoreError = t.InvalidCryptoStoreState = t.InvalidCryptoStoreError = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js"));
			let s, o;
			t.InvalidStoreState = s,
				function(e) {
					e[e.ToggledLazyLoading = 0] = "ToggledLazyLoading"
				}(s || (t.InvalidStoreState = s = {}));
			class InvalidStoreError extends Error {
				constructor(e, t) {
					super(`Store is invalid because ${e}, ` + "please stop the client, delete all data and start the client again"), this.reason = e, this.value = t, this.name = "InvalidStoreError"
				}
			}
			t.InvalidStoreError = InvalidStoreError, (0, r.default)(InvalidStoreError, "TOGGLED_LAZY_LOADING", s.ToggledLazyLoading), t.InvalidCryptoStoreState = o,
				function(e) {
					e.TooNew = "TOO_NEW"
				}(o || (t.InvalidCryptoStoreState = o = {}));
			class InvalidCryptoStoreError extends Error {
				constructor(e) {
					super(`Crypto store is invalid because ${e}, ` + "please stop the client, delete all data and start the client again"), this.reason = e, this.name = "InvalidCryptoStoreError"
				}
			}
			t.InvalidCryptoStoreError = InvalidCryptoStoreError, (0, r.default)(InvalidCryptoStoreError, "TOO_NEW", o.TooNew);
			class KeySignatureUploadError extends Error {
				constructor(e, t) {
					super(e), this.value = t
				}
			}
			t.KeySignatureUploadError = KeySignatureUploadError
		},
		"./node_modules/matrix-js-sdk/lib/event-mapper.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.eventMapperFor = function(e, t) {
				let i = Boolean(t.preventReEmit);
				const n = !1 !== t.decrypt;
				return function(r) {
					t.toDevice && delete r.room_id;
					const o = e.getRoom(r.room_id);
					let d;
					o && void 0 === r.state_key && (d = o.findEventById(r.event_id)), !d || d.status ? d = new s.MatrixEvent(r) : (d.setUnsigned(a(a({}, d.getUnsigned()), r.unsigned)), i = !0);
					const l = null == o ? void 0 : o.findThreadForEvent(d);
					return l && d.setThread(l), d.isEncrypted() && (i || e.reEmitter.reEmit(d, [s.MatrixEventEvent.Decrypted]), n && e.decryptEventIfNeeded(d)), i || (e.reEmitter.reEmit(d, [s.MatrixEventEvent.Replaced, s.MatrixEventEvent.VisibilityChange]), null == o || o.reEmitter.reEmit(d, [s.MatrixEventEvent.BeforeRedaction])), d
				}
			};
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/models/event.js");

			function o(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function a(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? o(Object(i), !0).forEach((function(t) {
						(0, r.default)(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : o(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}
		},
		"./node_modules/matrix-js-sdk/lib/feature.js": function(e, t, i) {
			"use strict";
			let n, r;
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.ServerSupport = t.Feature = void 0, t.buildFeatureSupportMap = async function(e) {
					const t = new Map;
					for (const [d, l] of Object.entries(s)) {
						var i, r, o, a;
						const s = null !== (i = null === (r = e.versions) || void 0 === r ? void 0 : r.includes(l.matrixVersion || "")) && void 0 !== i && i,
							c = null !== (o = null === (a = l.unstablePrefixes) || void 0 === a ? void 0 : a.every(t => {
								var i;
								return !0 === (null === (i = e.unstable_features) || void 0 === i ? void 0 : i[t])
							})) && void 0 !== o && o;
						s ? t.set(d, n.Stable) : c ? t.set(d, n.Unstable) : t.set(d, n.Unsupported)
					}
					return t
				}, t.ServerSupport = n,
				function(e) {
					e[e.Stable = 0] = "Stable", e[e.Unstable = 1] = "Unstable", e[e.Unsupported = 2] = "Unsupported"
				}(n || (t.ServerSupport = n = {})), t.Feature = r,
				function(e) {
					e.Thread = "Thread", e.ThreadUnreadNotifications = "ThreadUnreadNotifications", e.LoginTokenRequest = "LoginTokenRequest"
				}(r || (t.Feature = r = {}));
			const s = {
				[r.Thread]: {
					unstablePrefixes: ["org.matrix.msc3440"],
					matrixVersion: "v1.3"
				},
				[r.ThreadUnreadNotifications]: {
					unstablePrefixes: ["org.matrix.msc3771", "org.matrix.msc3773"],
					matrixVersion: "v1.4"
				},
				[r.LoginTokenRequest]: {
					unstablePrefixes: ["org.matrix.msc3882"]
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/filter-component.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.FilterComponent = void 0;
			var n = i("./node_modules/matrix-js-sdk/lib/models/thread.js");
			t.FilterComponent = class {
				constructor(e, t) {
					this.filterJson = e, this.userId = t
				}
				check(e) {
					var t, i;
					const r = (null === (t = e.getUnsigned()) || void 0 === t ? void 0 : t["m.relations"]) || {},
						s = Object.keys(r),
						o = [];
					return this.userId && null != r && null !== (i = r[n.THREAD_RELATION_TYPE.name]) && void 0 !== i && i.current_user_participated && o.push(this.userId), this.checkFields(e.getRoomId(), e.getSender(), e.getType(), !!e.getContent() && void 0 !== e.getContent().url, s, o)
				}
				toJSON() {
					return {
						types: this.filterJson.types || null,
						not_types: this.filterJson.not_types || [],
						rooms: this.filterJson.rooms || null,
						not_rooms: this.filterJson.not_rooms || [],
						senders: this.filterJson.senders || null,
						not_senders: this.filterJson.not_senders || [],
						contains_url: this.filterJson.contains_url || null,
						[n.FILTER_RELATED_BY_SENDERS.name]: this.filterJson[n.FILTER_RELATED_BY_SENDERS.name] || [],
						[n.FILTER_RELATED_BY_REL_TYPES.name]: this.filterJson[n.FILTER_RELATED_BY_REL_TYPES.name] || []
					}
				}
				checkFields(e, t, i, r, s, o) {
					const a = {
						rooms: function(t) {
							return e === t
						},
						senders: function(e) {
							return t === e
						},
						types: function(e) {
							return function(e, t) {
								if (t.endsWith("*")) {
									const i = t.slice(0, -1);
									return e.slice(0, i.length) === i
								}
								return e === t
							}(i, e)
						}
					};
					for (const n in a) {
						const e = a[n],
							t = "not_" + n,
							i = this.filterJson[t];
						if (null != i && i.some(e)) return !1;
						const r = this.filterJson[n];
						if (r && !r.some(e)) return !1
					}
					const d = this.filterJson.contains_url;
					if (void 0 !== d && d !== r) return !1;
					const l = this.filterJson[n.FILTER_RELATED_BY_REL_TYPES.name];
					if (void 0 !== l && !this.arrayMatchesFilter(l, s)) return !1;
					const c = this.filterJson[n.FILTER_RELATED_BY_SENDERS.name];
					return !(void 0 !== c && !this.arrayMatchesFilter(c, o))
				}
				arrayMatchesFilter(e, t) {
					return t.length > 0 && e.every(e => t.includes(e))
				}
				filter(e) {
					return e.filter(this.check, this)
				}
				limit() {
					return void 0 !== this.filterJson.limit ? this.filterJson.limit : 10
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/filter.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.Filter = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/@types/sync.js"),
				o = i("./node_modules/matrix-js-sdk/lib/filter-component.js");

			function a(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function d(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? a(Object(i), !0).forEach((function(t) {
						(0, r.default)(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : a(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}

			function l(e, t, i) {
				const n = t.split(".");
				let r = e;
				for (let s = 0; s < n.length - 1; s++) r[n[s]] || (r[n[s]] = {}), r = r[n[s]];
				r[n[n.length - 1]] = i
			}
			class c {
				static fromJson(e, t, i) {
					const n = new c(e, t);
					return n.setDefinition(i), n
				}
				constructor(e, t) {
					this.userId = e, this.filterId = t, (0, r.default)(this, "definition", {}), (0, r.default)(this, "roomFilter", void 0), (0, r.default)(this, "roomTimelineFilter", void 0)
				}
				getFilterId() {
					return this.filterId
				}
				getDefinition() {
					return this.definition
				}
				setDefinition(e) {
					this.definition = e;
					const t = e.room,
						i = {};
					t && (t.rooms && (i.rooms = t.rooms), t.rooms && (i.not_rooms = t.not_rooms)), this.roomFilter = new o.FilterComponent(i, this.userId), this.roomTimelineFilter = new o.FilterComponent((null == t ? void 0 : t.timeline) || {}, this.userId)
				}
				getRoomTimelineFilterComponent() {
					return this.roomTimelineFilter
				}
				filterRoomTimeline(e) {
					return this.roomFilter && (e = this.roomFilter.filter(e)), this.roomTimelineFilter && (e = this.roomTimelineFilter.filter(e)), e
				}
				setTimelineLimit(e) {
					l(this.definition, "room.timeline.limit", e)
				}
				setUnreadThreadNotifications(e) {
					var t, i, n;
					this.definition = d(d({}, this.definition), {}, {
						room: d(d({}, null === (t = this.definition) || void 0 === t ? void 0 : t.room), {}, {
							timeline: d(d({}, null === (i = this.definition) || void 0 === i ? void 0 : null === (n = i.room) || void 0 === n ? void 0 : n.timeline), {}, {
								[s.UNREAD_THREAD_NOTIFICATIONS.name]: e
							})
						})
					})
				}
				setLazyLoadMembers(e) {
					l(this.definition, "room.state.lazy_load_members", e)
				}
				setIncludeLeaveRooms(e) {
					l(this.definition, "room.include_leave", e)
				}
			}
			t.Filter = c, (0, r.default)(c, "LAZY_LOADING_MESSAGES_FILTER", {
				lazy_load_members: !0
			})
		},
		"./node_modules/matrix-js-sdk/lib/http-api/errors.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.MatrixError = t.HTTPError = t.ConnectionError = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js"));
			class HTTPError extends Error {
				constructor(e, t) {
					super(e), this.httpStatus = t
				}
			}
			t.HTTPError = HTTPError;
			t.MatrixError = class MatrixError extends HTTPError {
				constructor(e = {}, t, i, n) {
					let s = e.error || "Unknown message";
					t && (s = `[${t}] ${s}`), i && (s = `${s} (${i})`), super(`MatrixError: ${s}`, t), this.httpStatus = t, this.url = i, this.event = n, (0, r.default)(this, "errcode", void 0), (0, r.default)(this, "data", void 0), this.errcode = e.errcode, this.name = e.errcode || "Unknown error code", this.data = e
				}
			};
			class ConnectionError extends Error {
				constructor(e, t) {
					super(e + (t ? `: ${t.message}` : ""))
				}
				get name() {
					return "ConnectionError"
				}
			}
			t.ConnectionError = ConnectionError
		},
		"./node_modules/matrix-js-sdk/lib/http-api/fetch.js": function(e, t, i) {
			"use strict";
			(function(e) {
				var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.FetchHttpApi = void 0;
				var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
					s = function(e, t) {
						if (!t && e && e.__esModule) return e;
						if (null === e || "object" != typeof e && "function" != typeof e) return {
							default: e
						};
						var i = c(t);
						if (i && i.has(e)) return i.get(e);
						var n = {},
							r = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var s in e)
							if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
								var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
								o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
							} n.default = e, i && i.set(e, n);
						return n
					}(i("./node_modules/matrix-js-sdk/lib/utils.js")),
					o = i("./node_modules/matrix-js-sdk/lib/http-api/method.js"),
					a = i("./node_modules/matrix-js-sdk/lib/http-api/errors.js"),
					d = i("./node_modules/matrix-js-sdk/lib/http-api/interface.js"),
					l = i("./node_modules/matrix-js-sdk/lib/http-api/utils.js");

				function c(e) {
					if ("function" != typeof WeakMap) return null;
					var t = new WeakMap,
						i = new WeakMap;
					return (c = function(e) {
						return e ? i : t
					})(e)
				}
				t.FetchHttpApi = class {
					constructor(e, t) {
						var i;
						this.eventEmitter = e, this.opts = t, (0, r.default)(this, "abortController", new AbortController), s.checkObjectHasKeys(t, ["baseUrl", "prefix"]), t.onlyData = !!t.onlyData, t.useAuthorizationHeader = null === (i = t.useAuthorizationHeader) || void 0 === i || i
					}
					abort() {
						this.abortController.abort(), this.abortController = new AbortController
					}
					fetch(t, i) {
						return this.opts.fetchFn ? this.opts.fetchFn(t, i) : e.fetch(t, i)
					}
					setIdBaseUrl(e) {
						this.opts.idBaseUrl = e
					}
					idServerRequest(e, t, i, n, r) {
						if (!this.opts.idBaseUrl) throw new Error("No identity server base URL set");
						let s = void 0,
							a = void 0;
						e === o.Method.Get ? s = i : a = i;
						const d = this.getUrl(t, s, n, this.opts.idBaseUrl),
							l = {
								json: !0,
								headers: {}
							};
						return r && (l.headers.Authorization = `Bearer ${r}`), this.requestOtherUrl(e, d, a, l)
					}
					authedRequest(e, t, i, n, r = {}) {
						i || (i = {}), this.opts.accessToken && (this.opts.useAuthorizationHeader ? (r.headers || (r.headers = {}), r.headers.Authorization || (r.headers.Authorization = "Bearer " + this.opts.accessToken), i.access_token && delete i.access_token) : i.access_token || (i.access_token = this.opts.accessToken));
						const s = this.request(e, t, i, n, r);
						return s.catch(e => {
							"M_UNKNOWN_TOKEN" != e.errcode || null != r && r.inhibitLogoutEmit ? "M_CONSENT_NOT_GIVEN" == e.errcode && this.eventEmitter.emit(d.HttpApiEvent.NoConsent, e.message, e.data.consent_uri) : this.eventEmitter.emit(d.HttpApiEvent.SessionLoggedOut, e)
						}), s
					}
					request(e, t, i, n, r) {
						const s = this.getUrl(t, i, null == r ? void 0 : r.prefix, null == r ? void 0 : r.baseUrl);
						return this.requestOtherUrl(e, s, n, r)
					}
					async requestOtherUrl(e, t, i, n = {}) {
						var r, s, o, d;
						const c = Object.assign({}, n.headers || {}),
							u = null === (r = n.json) || void 0 === r || r,
							h = u && (null == i ? void 0 : null === (s = i.constructor) || void 0 === s ? void 0 : s.name) === Object.name;
						u && (h && !c["Content-Type"] && (c["Content-Type"] = "application/json"), c.Accept || (c.Accept = "application/json"));
						const m = null !== (o = n.localTimeoutMs) && void 0 !== o ? o : this.opts.localTimeoutMs,
							p = null !== (d = n.keepAlive) && void 0 !== d && d,
							g = [this.abortController.signal];
						let f;
						void 0 !== m && g.push((0, l.timeoutSignal)(m)), n.abortSignal && g.push(n.abortSignal), f = h ? JSON.stringify(i) : i;
						const {
							signal: v,
							cleanup: y
						} = (0, l.anySignal)(g);
						let b;
						try {
							b = await this.fetch(t, {
								signal: v,
								method: e,
								body: f,
								headers: c,
								mode: "cors",
								redirect: "follow",
								referrer: "",
								referrerPolicy: "no-referrer",
								cache: "no-cache",
								credentials: "omit",
								keepalive: p
							})
						} catch (_) {
							if ("AbortError" === _.name) throw _;
							throw new a.ConnectionError("fetch failed", _)
						} finally {
							y()
						}
						if (!b.ok) throw (0, l.parseErrorResponse)(b, await b.text());
						return this.opts.onlyData ? u ? b.json() : b.text() : b
					}
					getUrl(e, t, i, n) {
						const r = new URL((null != n ? n : this.opts.baseUrl) + (null != i ? i : this.opts.prefix) + e);
						return t && s.encodeParams(t, r.searchParams), r
					}
				}
			}).call(this, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/http-api/index.js": function(e, t, i) {
			"use strict";
			(function(e) {
				var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var r = {
					MatrixHttpApi: !0
				};
				t.MatrixHttpApi = void 0;
				var s = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
					o = i("./node_modules/matrix-js-sdk/lib/http-api/fetch.js"),
					a = i("./node_modules/matrix-js-sdk/lib/http-api/prefix.js");
				Object.keys(a).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(r, e) || e in t && t[e] === a[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return a[e]
						}
					}))
				}));
				var d = g(i("./node_modules/matrix-js-sdk/lib/utils.js")),
					l = g(i("./node_modules/matrix-js-sdk/lib/realtime-callbacks.js")),
					c = i("./node_modules/matrix-js-sdk/lib/http-api/method.js");
				Object.keys(c).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(r, e) || e in t && t[e] === c[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return c[e]
						}
					}))
				}));
				var u = i("./node_modules/matrix-js-sdk/lib/http-api/errors.js");
				Object.keys(u).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(r, e) || e in t && t[e] === u[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return u[e]
						}
					}))
				}));
				var h = i("./node_modules/matrix-js-sdk/lib/http-api/utils.js");
				Object.keys(h).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(r, e) || e in t && t[e] === h[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return h[e]
						}
					}))
				}));
				var m = i("./node_modules/matrix-js-sdk/lib/http-api/interface.js");

				function p(e) {
					if ("function" != typeof WeakMap) return null;
					var t = new WeakMap,
						i = new WeakMap;
					return (p = function(e) {
						return e ? i : t
					})(e)
				}

				function g(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = p(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} return n.default = e, i && i.set(e, n), n
				}
				Object.keys(m).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(r, e) || e in t && t[e] === m[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return m[e]
						}
					}))
				}));
				class f extends o.FetchHttpApi {
					constructor(...e) {
						super(...e), (0, s.default)(this, "uploads", [])
					}
					uploadContent(t, i = {}) {
						var n, r, s, o, m;
						const p = null === (n = i.includeFilename) || void 0 === n || n,
							g = null !== (r = i.abortController) && void 0 !== r ? r : new AbortController,
							f = null !== (s = null !== (o = i.type) && void 0 !== o ? o : t.type) && void 0 !== s ? s : "application/octet-stream",
							v = null !== (m = i.name) && void 0 !== m ? m : t.name,
							y = {
								loaded: 0,
								total: 0,
								abortController: g
							},
							b = d.defer();
						if (e.XMLHttpRequest) {
							const n = new e.XMLHttpRequest,
								r = function() {
									n.abort(), b.reject(new Error("Timeout"))
								};
							let s = l.setTimeout(r, 3e4);
							n.onreadystatechange = function() {
								switch (n.readyState) {
									case e.XMLHttpRequest.DONE:
										l.clearTimeout(s);
										try {
											if (0 === n.status) throw new DOMException(n.statusText, "AbortError");
											if (!n.responseText) throw new Error("No response body.");
											n.status >= 400 ? b.reject((0, h.parseErrorResponse)(n, n.responseText)) : b.resolve(JSON.parse(n.responseText))
										} catch (t) {
											if ("AbortError" === t.name) return void b.reject(t);
											b.reject(new u.ConnectionError("request failed", t))
										}
								}
							}, n.upload.onprogress = e => {
								var t;
								l.clearTimeout(s), y.loaded = e.loaded, y.total = e.total, s = l.setTimeout(r, 3e4), null === (t = i.progressHandler) || void 0 === t || t.call(i, {
									loaded: e.loaded,
									total: e.total
								})
							};
							const o = this.getUrl("/upload", void 0, a.MediaPrefix.R0);
							p && v && o.searchParams.set("filename", encodeURIComponent(v)), !this.opts.useAuthorizationHeader && this.opts.accessToken && o.searchParams.set("access_token", encodeURIComponent(this.opts.accessToken)), n.open(c.Method.Post, o.href), this.opts.useAuthorizationHeader && this.opts.accessToken && n.setRequestHeader("Authorization", "Bearer " + this.opts.accessToken), n.setRequestHeader("Content-Type", f), n.send(t), g.signal.addEventListener("abort", () => {
								n.abort()
							})
						} else {
							const e = {};
							p && v && (e.filename = v);
							const i = {
								"Content-Type": f
							};
							this.authedRequest(c.Method.Post, "/upload", e, t, {
								prefix: a.MediaPrefix.R0,
								headers: i,
								abortSignal: g.signal
							}).then(e => this.opts.onlyData ? e : e.json()).then(b.resolve, b.reject)
						}
						return y.promise = b.promise.finally(() => {
							d.removeElement(this.uploads, e => e === y)
						}), g.signal.addEventListener("abort", () => {
							d.removeElement(this.uploads, e => e === y), b.reject(new DOMException("Aborted", "AbortError"))
						}), this.uploads.push(y), y.promise
					}
					cancelUpload(e) {
						const t = this.uploads.find(t => t.promise === e);
						return !!t && (t.abortController.abort(), !0)
					}
					getCurrentUploads() {
						return this.uploads
					}
					getContentUri() {
						return {
							base: this.opts.baseUrl,
							path: a.MediaPrefix.R0 + "/upload",
							params: {
								access_token: this.opts.accessToken
							}
						}
					}
				}
				t.MatrixHttpApi = f
			}).call(this, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/http-api/interface.js": function(e, t, i) {
			"use strict";
			let n;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.HttpApiEvent = void 0, t.HttpApiEvent = n,
				function(e) {
					e.SessionLoggedOut = "Session.logged_out", e.NoConsent = "no_consent"
				}(n || (t.HttpApiEvent = n = {}))
		},
		"./node_modules/matrix-js-sdk/lib/http-api/method.js": function(e, t, i) {
			"use strict";
			let n;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.Method = void 0, t.Method = n,
				function(e) {
					e.Get = "GET", e.Put = "PUT", e.Post = "POST", e.Delete = "DELETE"
				}(n || (t.Method = n = {}))
		},
		"./node_modules/matrix-js-sdk/lib/http-api/prefix.js": function(e, t, i) {
			"use strict";
			let n, r, s;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.MediaPrefix = t.IdentityPrefix = t.ClientPrefix = void 0, t.ClientPrefix = n,
				function(e) {
					e.R0 = "/_matrix/client/r0", e.V1 = "/_matrix/client/v1", e.V3 = "/_matrix/client/v3", e.Unstable = "/_matrix/client/unstable"
				}(n || (t.ClientPrefix = n = {})), t.IdentityPrefix = r,
				function(e) {
					e.V1 = "/_matrix/identity/api/v1", e.V2 = "/_matrix/identity/v2"
				}(r || (t.IdentityPrefix = r = {})), t.MediaPrefix = s,
				function(e) {
					e.R0 = "/_matrix/media/r0"
				}(s || (t.MediaPrefix = s = {}))
		},
		"./node_modules/matrix-js-sdk/lib/http-api/utils.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.anySignal = function(e) {
				const t = new AbortController;

				function i() {
					for (const t of e) t.removeEventListener("abort", n)
				}

				function n() {
					t.abort(), i()
				}
				for (const r of e) {
					if (r.aborted) {
						n();
						break
					}
					r.addEventListener("abort", n)
				}
				return {
					signal: t.signal,
					cleanup: i
				}
			}, t.parseErrorResponse = function(e, t) {
				var i, r;
				let s;
				try {
					s = function(e) {
						let t;
						t = a(e) ? e.getResponseHeader("Content-Type") : e.headers.get("Content-Type");
						if (!t) return null;
						try {
							return (0, n.parse)(t)
						} catch (i) {
							throw new Error(`Error parsing Content-Type '${t}': ${i}`)
						}
					}(e)
				} catch (d) {
					return d
				}
				if ("application/json" === (null === (i = s) || void 0 === i ? void 0 : i.type) && t) return new o.MatrixError(JSON.parse(t), e.status, a(e) ? e.responseURL : e.url);
				if ("text/plain" === (null === (r = s) || void 0 === r ? void 0 : r.type)) return new o.HTTPError(`Server returned ${e.status} error: ${t}`, e.status);
				return new o.HTTPError(`Server returned ${e.status} error`, e.status)
			}, t.retryNetworkOperation = async function(e, t) {
				let i = 0,
					n = null;
				for (; i < e;) try {
					if (i > 0) {
						const e = 1e3 * Math.pow(2, i);
						r.logger.log(`network operation failed ${i} times, retrying in ${e}ms...`), await (0, s.sleep)(e)
					}
					return await t()
				} catch (a) {
					if (!(a instanceof o.ConnectionError)) throw a;
					i += 1, n = a
				}
				throw n
			}, t.timeoutSignal = function(e) {
				const t = new AbortController;
				return setTimeout(() => {
					t.abort()
				}, e), t.signal
			};
			var n = i("./node_modules/content-type/index.js"),
				r = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				s = i("./node_modules/matrix-js-sdk/lib/utils.js"),
				o = i("./node_modules/matrix-js-sdk/lib/http-api/errors.js");

			function a(e) {
				return "getResponseHeader" in e
			}
		},
		"./node_modules/matrix-js-sdk/lib/indexeddb-helpers.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.exists = function(e, t) {
				return new Promise((i, n) => {
					let r = !0;
					const s = e.open(t);
					s.onupgradeneeded = () => {
						r = !1
					}, s.onblocked = () => n(s.error), s.onsuccess = () => {
						s.result.close(), r || e.deleteDatabase(t), i(r)
					}, s.onerror = e => n(s.error)
				})
			}
		},
		"./node_modules/matrix-js-sdk/lib/interactive-auth.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.InteractiveAuth = t.AuthType = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = i("./node_modules/matrix-js-sdk/lib/utils.js");
			const a = "m.login.email.identity",
				d = "m.login.msisdn";
			let l;
			t.AuthType = l,
				function(e) {
					e.Password = "m.login.password", e.Recaptcha = "m.login.recaptcha", e.Terms = "m.login.terms", e.Email = "m.login.email.identity", e.Msisdn = "m.login.msisdn", e.Sso = "m.login.sso", e.SsoUnstable = "org.matrix.login.sso", e.Dummy = "m.login.dummy", e.RegistrationToken = "m.login.registration_token", e.UnstableRegistrationToken = "org.matrix.msc3231.login.registration_token"
				}(l || (t.AuthType = l = {}));
			class NoAuthFlowFoundError extends Error {
				constructor(e, t, i) {
					super(e), this.required_stages = t, this.flows = i, (0, r.default)(this, "name", "NoAuthFlowFoundError")
				}
			}
			t.InteractiveAuth = class {
				constructor(e) {
					(0, r.default)(this, "matrixClient", void 0), (0, r.default)(this, "inputs", void 0), (0, r.default)(this, "clientSecret", void 0), (0, r.default)(this, "requestCallback", void 0), (0, r.default)(this, "busyChangedCallback", void 0), (0, r.default)(this, "stateUpdatedCallback", void 0), (0, r.default)(this, "requestEmailTokenCallback", void 0), (0, r.default)(this, "data", void 0), (0, r.default)(this, "emailSid", void 0), (0, r.default)(this, "requestingEmailToken", !1), (0, r.default)(this, "attemptAuthDeferred", null), (0, r.default)(this, "chosenFlow", null), (0, r.default)(this, "currentStage", null), (0, r.default)(this, "emailAttempt", 1), (0, r.default)(this, "submitPromise", null), (0, r.default)(this, "requestEmailToken", async () => {
						if (this.requestingEmailToken) s.logger.warn("Could not request email token: Already requesting");
						else {
							s.logger.trace("Requesting email token. Attempt: " + this.emailAttempt), this.requestingEmailToken = !0;
							try {
								const e = await this.requestEmailTokenCallback(this.inputs.emailAddress, this.clientSecret, this.emailAttempt++, this.data.session);
								this.emailSid = e.sid, s.logger.trace("Email token request succeeded")
							} finally {
								this.requestingEmailToken = !1
							}
						}
					}), this.matrixClient = e.matrixClient, this.data = e.authData || {}, this.requestCallback = e.doRequest, this.busyChangedCallback = e.busyChanged, this.stateUpdatedCallback = e.stateUpdated || e.startAuthStage, this.requestEmailTokenCallback = e.requestEmailToken, this.inputs = e.inputs || {}, e.sessionId && (this.data.session = e.sessionId), this.clientSecret = e.clientSecret || this.matrixClient.generateClientSecret(), this.emailSid = e.emailSid
				}
				attemptAuth() {
					var e;
					this.attemptAuthDeferred = (0, o.defer)();
					const t = this.attemptAuthDeferred.promise;
					if (null !== (e = this.data) && void 0 !== e && e.flows) this.startNextAuthStage();
					else {
						var i;
						null === (i = this.busyChangedCallback) || void 0 === i || i.call(this, !0);
						const e = this.data.session ? {
							session: this.data.session
						} : null;
						this.doRequest(e).finally(() => {
							var e;
							null === (e = this.busyChangedCallback) || void 0 === e || e.call(this, !1)
						})
					}
					return t
				}
				async poll() {
					if (!this.data.session) return;
					if (!this.attemptAuthDeferred) return;
					if (this.submitPromise) return;
					let e = {};
					if (this.currentStage == a && this.emailSid) {
						const t = {
							sid: this.emailSid,
							client_secret: this.clientSecret
						};
						if (await this.matrixClient.doesServerRequireIdServerParam()) {
							const e = new URL(this.matrixClient.getIdentityServerUrl());
							t.id_server = e.host
						}
						e = {
							type: a,
							threepid_creds: t,
							threepidCreds: t
						}
					}
					this.submitAuthDict(e, !0)
				}
				getSessionId() {
					var e;
					return null === (e = this.data) || void 0 === e ? void 0 : e.session
				}
				getClientSecret() {
					return this.clientSecret
				}
				getStageParams(e) {
					var t;
					return null === (t = this.data.params) || void 0 === t ? void 0 : t[e]
				}
				getChosenFlow() {
					return this.chosenFlow
				}
				async submitAuthDict(e, t = !1) {
					if (!this.attemptAuthDeferred) throw new Error("submitAuthDict() called before attemptAuth()");
					var i;
					t || (null === (i = this.busyChangedCallback) || void 0 === i || i.call(this, !0));
					for (; this.submitPromise;) try {
						await this.submitPromise
					} catch (s) {}
					let n;
					this.data.session ? (n = {
						session: this.data.session
					}, Object.assign(n, e)) : n = e;
					try {
						this.submitPromise = this.doRequest(n, t), await this.submitPromise
					} finally {
						var r;
						if (this.submitPromise = null, !t) null === (r = this.busyChangedCallback) || void 0 === r || r.call(this, !1)
					}
				}
				getEmailSid() {
					return this.emailSid
				}
				setEmailSid(e) {
					this.emailSid = e
				}
				async doRequest(e, t = !1) {
					try {
						const i = await this.requestCallback(e, t);
						this.attemptAuthDeferred.resolve(i), this.attemptAuthDeferred = null
					} catch (a) {
						var i, n, r;
						const e = null !== (i = null === (n = a.data) || void 0 === n ? void 0 : n.flows) && void 0 !== i ? i : null,
							c = this.data.flows || Boolean(e);
						var o;
						if (401 !== a.httpStatus || !a.data || !c)
							if (t) s.logger.log("Background poll request failed doing UI auth: ignoring", a);
							else null === (o = this.attemptAuthDeferred) || void 0 === o || o.reject(a);
						a.data || (a.data = {}), a.data.flows || a.data.completed || a.data.session || (a.data.flows = this.data.flows, a.data.completed = this.data.completed, a.data.session = this.data.session), this.data = a.data;
						try {
							this.startNextAuthStage()
						} catch (d) {
							return this.attemptAuthDeferred.reject(d), void(this.attemptAuthDeferred = null)
						}
						if (!this.emailSid && null !== (r = this.chosenFlow) && void 0 !== r && r.stages.includes(l.Email)) try {
							await this.requestEmailToken()
						} catch (d) {
							this.attemptAuthDeferred.reject(d), this.attemptAuthDeferred = null
						}
					}
				}
				startNextAuthStage() {
					var e, t;
					const i = this.chooseStage();
					if (!i) throw new Error("No incomplete flows from the server");
					var n, r;
					(this.currentStage = i, i !== l.Dummy) ? null !== (e = this.data) && void 0 !== e && e.errcode || null !== (t = this.data) && void 0 !== t && t.error ? this.stateUpdatedCallback(i, {
						errcode: (null === (n = this.data) || void 0 === n ? void 0 : n.errcode) || "",
						error: (null === (r = this.data) || void 0 === r ? void 0 : r.error) || ""
					}) : this.stateUpdatedCallback(i, i === a ? {
						emailSid: this.emailSid
					} : {}): this.submitAuthDict({
						type: "m.login.dummy"
					})
				}
				chooseStage() {
					null === this.chosenFlow && (this.chosenFlow = this.chooseFlow()), s.logger.log("Active flow => %s", JSON.stringify(this.chosenFlow));
					const e = this.firstUncompletedStage(this.chosenFlow);
					return s.logger.log("Next stage: %s", e), e
				}
				chooseFlow() {
					const e = this.data.flows || [],
						t = Boolean(this.inputs.emailAddress) || Boolean(this.emailSid),
						i = Boolean(this.inputs.phoneCountry) && Boolean(this.inputs.phoneNumber);
					for (const r of e) {
						let e = !1,
							n = !1;
						for (const t of r.stages) t === a ? e = !0 : t == d && (n = !0);
						if (e == t && n == i) return r
					}
					const n = [];
					throw t && n.push(a), i && n.push(d), new NoAuthFlowFoundError("No appropriate authentication flow found", n, e)
				}
				firstUncompletedStage(e) {
					const t = this.data.completed || [];
					return e.stages.find(e => !t.includes(e))
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/logger.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.logger = void 0;
			var r = n(i("./node_modules/loglevel/lib/loglevel.js"));
			const s = "matrix";
			r.default.methodFactory = function(e, t, i) {
				return function(...t) {
					return this.prefix && t.unshift(this.prefix), "error" === e || "warn" === e || "trace" === e || "info" === e ? console[e](...t) : console.log(...t)
				}
			};
			const o = r.default.getLogger(s);

			function a(e) {
				e.withPrefix = function(e) {
					return function(e) {
						const t = r.default.getLogger(`${s}-${e}`);
						t.prefix !== e && (a(t), t.prefix = e, t.setLevel(r.default.levels.DEBUG, !1));
						return t
					}((this.prefix || "") + e)
				}
			}
			t.logger = o, o.setLevel(r.default.levels.DEBUG, !1), a(o)
		},
		"./node_modules/matrix-js-sdk/lib/matrix.js": function(e, t, i) {
			"use strict";
			(function(e) {
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = {
					setCryptoStoreFactory: !0,
					createClient: !0,
					createRoomWidgetClient: !0,
					ContentHelpers: !0,
					createNewMatrixCall: !0,
					GroupCallEvent: !0,
					GroupCallIntent: !0,
					GroupCallState: !0,
					GroupCallType: !0
				};
				t.ContentHelpers = void 0, Object.defineProperty(t, "GroupCallEvent", {
					enumerable: !0,
					get: function() {
						return L.GroupCallEvent
					}
				}), Object.defineProperty(t, "GroupCallIntent", {
					enumerable: !0,
					get: function() {
						return L.GroupCallIntent
					}
				}), Object.defineProperty(t, "GroupCallState", {
					enumerable: !0,
					get: function() {
						return L.GroupCallState
					}
				}), Object.defineProperty(t, "GroupCallType", {
					enumerable: !0,
					get: function() {
						return L.GroupCallType
					}
				}), t.createClient = function(e) {
					return new a.MatrixClient(F(e))
				}, Object.defineProperty(t, "createNewMatrixCall", {
					enumerable: !0,
					get: function() {
						return A.createNewMatrixCall
					}
				}), t.createRoomWidgetClient = function(e, t, i, n) {
					return new d.RoomWidgetClient(e, t, i, F(n))
				}, t.setCryptoStoreFactory = function(e) {
					N = e
				};
				var r = i("./node_modules/matrix-js-sdk/lib/crypto/store/memory-crypto-store.js");
				Object.keys(r).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === r[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return r[e]
						}
					}))
				}));
				var s = i("./node_modules/matrix-js-sdk/lib/store/memory.js");
				Object.keys(s).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === s[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return s[e]
						}
					}))
				}));
				var o = i("./node_modules/matrix-js-sdk/lib/scheduler.js");
				Object.keys(o).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === o[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return o[e]
						}
					}))
				}));
				var a = i("./node_modules/matrix-js-sdk/lib/client.js");
				Object.keys(a).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === a[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return a[e]
						}
					}))
				}));
				var d = i("./node_modules/matrix-js-sdk/lib/embedded.js");
				Object.keys(d).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === d[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return d[e]
						}
					}))
				}));
				var l = i("./node_modules/matrix-js-sdk/lib/http-api/index.js");
				Object.keys(l).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === l[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return l[e]
						}
					}))
				}));
				var c = i("./node_modules/matrix-js-sdk/lib/autodiscovery.js");
				Object.keys(c).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === c[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return c[e]
						}
					}))
				}));
				var u = i("./node_modules/matrix-js-sdk/lib/sync-accumulator.js");
				Object.keys(u).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === u[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return u[e]
						}
					}))
				}));
				var h = i("./node_modules/matrix-js-sdk/lib/errors.js");
				Object.keys(h).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === h[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return h[e]
						}
					}))
				}));
				var m = i("./node_modules/matrix-js-sdk/lib/models/beacon.js");
				Object.keys(m).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === m[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return m[e]
						}
					}))
				}));
				var p = i("./node_modules/matrix-js-sdk/lib/models/event.js");
				Object.keys(p).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === p[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return p[e]
						}
					}))
				}));
				var g = i("./node_modules/matrix-js-sdk/lib/models/room.js");
				Object.keys(g).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === g[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return g[e]
						}
					}))
				}));
				var f = i("./node_modules/matrix-js-sdk/lib/models/event-timeline.js");
				Object.keys(f).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === f[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return f[e]
						}
					}))
				}));
				var v = i("./node_modules/matrix-js-sdk/lib/models/event-timeline-set.js");
				Object.keys(v).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === v[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return v[e]
						}
					}))
				}));
				var y = i("./node_modules/matrix-js-sdk/lib/models/room-member.js");
				Object.keys(y).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === y[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return y[e]
						}
					}))
				}));
				var b = i("./node_modules/matrix-js-sdk/lib/models/room-state.js");
				Object.keys(b).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === b[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return b[e]
						}
					}))
				}));
				var _ = i("./node_modules/matrix-js-sdk/lib/models/user.js");
				Object.keys(_).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === _[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return _[e]
						}
					}))
				}));
				var S = i("./node_modules/matrix-js-sdk/lib/filter.js");
				Object.keys(S).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === S[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return S[e]
						}
					}))
				}));
				var E = i("./node_modules/matrix-js-sdk/lib/timeline-window.js");
				Object.keys(E).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === E[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return E[e]
						}
					}))
				}));
				var w = i("./node_modules/matrix-js-sdk/lib/interactive-auth.js");
				Object.keys(w).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === w[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return w[e]
						}
					}))
				}));
				var k = i("./node_modules/matrix-js-sdk/lib/service-types.js");
				Object.keys(k).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === k[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return k[e]
						}
					}))
				}));
				var T = i("./node_modules/matrix-js-sdk/lib/store/indexeddb.js");
				Object.keys(T).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === T[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return T[e]
						}
					}))
				}));
				var I = i("./node_modules/matrix-js-sdk/lib/crypto/store/indexeddb-crypto-store.js");
				Object.keys(I).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === I[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return I[e]
						}
					}))
				}));
				var C = i("./node_modules/matrix-js-sdk/lib/content-repo.js");
				Object.keys(C).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === C[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return C[e]
						}
					}))
				}));
				var R = i("./node_modules/matrix-js-sdk/lib/@types/event.js");
				Object.keys(R).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === R[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return R[e]
						}
					}))
				}));
				var j = i("./node_modules/matrix-js-sdk/lib/@types/PushRules.js");
				Object.keys(j).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === j[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return j[e]
						}
					}))
				}));
				var O = i("./node_modules/matrix-js-sdk/lib/@types/partials.js");
				Object.keys(O).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === O[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return O[e]
						}
					}))
				}));
				var x = i("./node_modules/matrix-js-sdk/lib/@types/requests.js");
				Object.keys(x).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === x[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return x[e]
						}
					}))
				}));
				var M = i("./node_modules/matrix-js-sdk/lib/@types/search.js");
				Object.keys(M).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === M[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return M[e]
						}
					}))
				}));
				var P = i("./node_modules/matrix-js-sdk/lib/models/room-summary.js");
				Object.keys(P).forEach((function(e) {
					"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(n, e) || e in t && t[e] === P[e] || Object.defineProperty(t, e, {
						enumerable: !0,
						get: function() {
							return P[e]
						}
					}))
				}));
				var D = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = U(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/content-helpers.js"));
				t.ContentHelpers = D;
				var A = i("./node_modules/matrix-js-sdk/lib/webrtc/call.js"),
					L = i("./node_modules/matrix-js-sdk/lib/webrtc/groupCall.js");

				function U(e) {
					if ("function" != typeof WeakMap) return null;
					var t = new WeakMap,
						i = new WeakMap;
					return (U = function(e) {
						return e ? i : t
					})(e)
				}
				let N = () => new r.MemoryCryptoStore;

				function F(t) {
					var i, n, r;
					return t.store = null !== (i = t.store) && void 0 !== i ? i : new s.MemoryStore({
						localStorage: e.localStorage
					}), t.scheduler = null !== (n = t.scheduler) && void 0 !== n ? n : new o.MatrixScheduler, t.cryptoStore = null !== (r = t.cryptoStore) && void 0 !== r ? r : N(), t
				}
			}).call(this, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/models/MSC3089Branch.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.MSC3089Branch = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				o = i("./node_modules/matrix-js-sdk/lib/models/event-timeline.js");

			function a(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function d(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? a(Object(i), !0).forEach((function(t) {
						(0, r.default)(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : a(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}
			t.MSC3089Branch = class {
				constructor(e, t, i) {
					this.client = e, this.indexEvent = t, this.directory = i
				}
				get id() {
					const e = this.indexEvent.getStateKey();
					if (!e) throw new Error("State key not found for branch");
					return e
				}
				get isActive() {
					return !0 === this.indexEvent.getContent().active
				}
				get version() {
					var e;
					return null !== (e = this.indexEvent.getContent().version) && void 0 !== e ? e : 1
				}
				get roomId() {
					return this.indexEvent.getRoomId()
				}
				async delete() {
					await this.client.sendStateEvent(this.roomId, s.UNSTABLE_MSC3089_BRANCH.name, {}, this.id), await this.client.redactEvent(this.roomId, this.id);
					const e = (await this.getVersionHistory())[1];
					e && await e.delete()
				}
				getName() {
					return this.indexEvent.getContent().name || "Unnamed File"
				}
				async setName(e) {
					await this.client.sendStateEvent(this.roomId, s.UNSTABLE_MSC3089_BRANCH.name, d(d({}, this.indexEvent.getContent()), {}, {
						name: e
					}), this.id)
				}
				isLocked() {
					return this.indexEvent.getContent().locked || !1
				}
				async setLocked(e) {
					await this.client.sendStateEvent(this.roomId, s.UNSTABLE_MSC3089_BRANCH.name, d(d({}, this.indexEvent.getContent()), {}, {
						locked: e
					}), this.id)
				}
				async getFileInfo() {
					const e = (await this.getFileEvent()).getOriginalContent().file,
						t = this.client.mxcUrlToHttp(e.url);
					if (!t) throw new Error(`No HTTP URL available for ${e.url}`);
					return {
						info: e,
						httpUrl: t
					}
				}
				async getFileEvent() {
					const e = this.client.getRoom(this.roomId);
					if (!e) throw new Error("Unknown room");
					let t = e.getUnfilteredTimelineSet().findEventById(this.id);
					for (; !t && e.getLiveTimeline().getState(o.EventTimeline.BACKWARDS).paginationToken;) await this.client.scrollback(e, 100), t = e.getUnfilteredTimelineSet().findEventById(this.id);
					if (!t) throw new Error("Failed to find event");
					return await this.client.decryptEventIfNeeded(t, {
						emit: !0,
						isRetry: !0
					}), t
				}
				async createNewVersion(e, t, i, n) {
					const r = await this.directory.createFile(e, t, i, d(d({}, null != n ? n : {}), {}, {
						"m.new_content": !0,
						"m.relates_to": {
							rel_type: s.RelationType.Replace,
							event_id: this.id
						}
					}));
					return await this.client.sendStateEvent(this.roomId, s.UNSTABLE_MSC3089_BRANCH.name, {
						active: !0,
						name: e,
						version: this.version + 1
					}, r.event_id), await this.client.sendStateEvent(this.roomId, s.UNSTABLE_MSC3089_BRANCH.name, d(d({}, this.indexEvent.getContent()), {}, {
						active: !1
					}), this.id), r
				}
				async getVersionHistory() {
					const e = [];
					e.push(this);
					const t = this.client.getRoom(this.roomId);
					if (!t) throw new Error("Invalid or unknown room");
					const i = [...t.getLiveTimeline().getEvents()].reverse();
					let n, r = await this.getFileEvent();
					do {
						if (n = i.find(e => e.replacingEventId() === r.getId())) {
							const t = this.directory.getFile(n.getId());
							if (!t) break;
							e.push(t), r = n
						}
					} while (n);
					return e
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/models/MSC3089TreeSpace.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.TreePermissions = t.MSC3089TreeSpace = t.DEFAULT_TREE_POWER_LEVELS_TEMPLATE = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = n(i("./node_modules/p-retry/index.js")),
				o = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				a = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				d = i("./node_modules/matrix-js-sdk/lib/utils.js"),
				l = i("./node_modules/matrix-js-sdk/lib/models/MSC3089Branch.js"),
				c = i("./node_modules/matrix-js-sdk/lib/crypto/algorithms/megolm.js");

			function u(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function h(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? u(Object(i), !0).forEach((function(t) {
						(0, r.default)(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : u(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}
			const m = {
				invite: 100,
				kick: 100,
				ban: 100,
				redact: 50,
				state_default: 50,
				events_default: 50,
				users_default: 0,
				events: {
					[o.EventType.RoomPowerLevels]: 100,
					[o.EventType.RoomHistoryVisibility]: 100,
					[o.EventType.RoomTombstone]: 100,
					[o.EventType.RoomEncryption]: 100,
					[o.EventType.RoomName]: 50,
					[o.EventType.RoomMessage]: 50,
					[o.EventType.RoomMessageEncrypted]: 50,
					[o.EventType.Sticker]: 50
				},
				users: {}
			};
			let p;
			t.DEFAULT_TREE_POWER_LEVELS_TEMPLATE = m, t.TreePermissions = p,
				function(e) {
					e.Viewer = "viewer", e.Editor = "editor", e.Owner = "owner"
				}(p || (t.TreePermissions = p = {}));
			t.MSC3089TreeSpace = class {
				constructor(e, t) {
					if (this.client = e, this.roomId = t, (0, r.default)(this, "room", void 0), this.room = this.client.getRoom(this.roomId), !this.room) throw new Error("Unknown room")
				}
				get id() {
					return this.roomId
				}
				get isTopLevel() {
					const e = this.room.currentState.getStateEvents(o.EventType.SpaceParent);
					return null == e || !e.length || e.every(e => {
						var t;
						return !(null !== (t = e.getContent()) && void 0 !== t && t.via)
					})
				}
				async setName(e) {
					await this.client.sendStateEvent(this.roomId, o.EventType.RoomName, {
						name: e
					}, "")
				}
				async invite(e, t = !0, i = !0) {
					const n = [this.retryInvite(e)];
					return t && n.push(...this.getDirectories().map(n => n.invite(e, t, i))), Promise.all(n).then(() => {
						i && (0, c.isRoomSharedHistory)(this.room) && this.client.sendSharedHistoryKeys(this.roomId, [e])
					})
				}
				retryInvite(e) {
					return (0, d.simpleRetryOperation)(async () => {
						await this.client.invite(this.roomId, e).catch(e => {
							if ("M_FORBIDDEN" === (null == e ? void 0 : e.errcode)) throw new s.default.AbortError(e);
							throw e
						})
					})
				}
				async setPermissions(e, t) {
					var i;
					const n = this.room.currentState.getStateEvents(o.EventType.RoomPowerLevels, "");
					if (Array.isArray(n)) throw new Error("Unexpected return type for power levels");
					const r = n.getContent() || {},
						s = r.users_default || 0,
						a = r.events_default || 50,
						d = (null === (i = r.events) || void 0 === i ? void 0 : i[o.EventType.RoomPowerLevels]) || 100,
						l = r.users || {};
					switch (t) {
						case p.Viewer:
							l[e] = s;
							break;
						case p.Editor:
							l[e] = a;
							break;
						case p.Owner:
							l[e] = d;
							break;
						default:
							throw new Error("Invalid role: " + t)
					}
					r.users = l, await this.client.sendStateEvent(this.roomId, o.EventType.RoomPowerLevels, r, "")
				}
				getPermissions(e) {
					var t, i;
					const n = this.room.currentState.getStateEvents(o.EventType.RoomPowerLevels, "");
					if (Array.isArray(n)) throw new Error("Unexpected return type for power levels");
					const r = n.getContent() || {},
						s = r.users_default || 0,
						a = r.events_default || 50,
						d = (null === (t = r.events) || void 0 === t ? void 0 : t[o.EventType.RoomPowerLevels]) || 100,
						l = (null === (i = r.users) || void 0 === i ? void 0 : i[e]) || s;
					return l >= d ? p.Owner : l >= a ? p.Editor : p.Viewer
				}
				async createDirectory(e) {
					const t = await this.client.unstableCreateFileTree(e);
					return await this.client.sendStateEvent(this.roomId, o.EventType.SpaceChild, {
						via: [this.client.getDomain()]
					}, t.roomId), await this.client.sendStateEvent(t.roomId, o.EventType.SpaceParent, {
						via: [this.client.getDomain()]
					}, this.roomId), t
				}
				getDirectories() {
					const e = [],
						t = this.room.currentState.getStateEvents(o.EventType.SpaceChild);
					for (const n of t) try {
						const t = n.getStateKey();
						if (t) {
							const i = this.client.unstableGetFileTreeSpace(t);
							i && e.push(i)
						}
					} catch (i) {
						a.logger.warn("Unable to create tree space instance for listing. Are we joined?", i)
					}
					return e
				}
				getDirectory(e) {
					return this.getDirectories().find(t => t.roomId === e)
				}
				async delete() {
					const e = this.getDirectories();
					for (const n of e) await n.delete();
					const t = ["invite", "knock", "join"],
						i = this.room.currentState.getStateEvents(o.EventType.RoomMember);
					for (const n of i) {
						if (n.getStateKey() !== this.client.getUserId() && t.includes(n.getContent().membership)) {
							const e = n.getStateKey();
							if (!e) throw new Error("State key not found for branch");
							await this.client.kick(this.roomId, e, "Room deleted")
						}
					}
					await this.client.leave(this.roomId)
				}
				getOrderedChildren(e) {
					const t = e.map(e => ({
						roomId: e.getStateKey(),
						order: e.getContent().order
					})).filter(e => e.roomId);
					return t.sort((e, t) => {
						if (e.order && !t.order) return -1;
						if (!e.order && t.order) return 1;
						if (e.order || t.order) return (0, d.lexicographicCompare)(e.order, t.order); {
							var i, n, r, s;
							const a = this.client.getRoom(e.roomId),
								l = this.client.getRoom(t.roomId);
							if (!a || !l) return (0, d.lexicographicCompare)(e.roomId, t.roomId);
							const c = null !== (i = null === (n = a.currentState.getStateEvents(o.EventType.RoomCreate, "")) || void 0 === n ? void 0 : n.getTs()) && void 0 !== i ? i : 0,
								u = null !== (r = null === (s = l.currentState.getStateEvents(o.EventType.RoomCreate, "")) || void 0 === s ? void 0 : s.getTs()) && void 0 !== r ? r : 0;
							return c === u ? (0, d.lexicographicCompare)(e.roomId, t.roomId) : c - u
						}
					}), t
				}
				getParentRoom() {
					const e = this.room.currentState.getStateEvents(o.EventType.SpaceParent)[0];
					if (!e) throw new Error("Expected to have a parent in a non-top level space");
					const t = e.getStateKey();
					if (!t) throw new Error("No state key found for parent");
					const i = this.client.getRoom(t);
					if (!i) throw new Error("Unable to locate room for parent");
					return i
				}
				getOrder() {
					if (this.isTopLevel) return -1;
					const e = this.getParentRoom().currentState.getStateEvents(o.EventType.SpaceChild);
					return this.getOrderedChildren(e).findIndex(e => e.roomId === this.roomId)
				}
				async setOrder(e) {
					var t;
					if (this.isTopLevel) throw new Error("Cannot set order of top level spaces currently");
					const i = this.getParentRoom(),
						n = i.currentState.getStateEvents(o.EventType.SpaceChild),
						r = this.getOrderedChildren(n);
					e = Math.max(Math.min(e, r.length - 1), 0);
					const s = this.getOrder() < e;
					s && e === r.length - 1 ? e-- : s || 0 !== e || e++;
					const a = r[s ? e : e - 1],
						l = r[s ? e + 1 : e];
					let c = d.DEFAULT_ALPHABET[0],
						u = !1;
					if (a)
						if (e === r.length - 1) null != l && l.order && (c = (0, d.nextString)(l.order));
						else {
							const e = null == a ? void 0 : a.order,
								t = null == l ? void 0 : l.order;
							e && t ? c = e === t ? (0, d.nextString)(e) : (0, d.averageBetweenStrings)(e, t) : e ? c = (0, d.nextString)(e) : t ? c = (0, d.prevString)(t) : u = !0
						}
					else null != l && l.order && (c = (0, d.prevString)(l.order));
					if (u) {
						let t;
						for (let n = 0; n <= e; n++) {
							const e = r[n];
							if (0 === n && (t = e.order), e.order) t = e.order;
							else {
								var m;
								t = t ? (0, d.nextString)(t) : d.DEFAULT_ALPHABET[0];
								const n = i.currentState.getStateEvents(o.EventType.SpaceChild, e.roomId),
									r = null !== (m = null == n ? void 0 : n.getContent()) && void 0 !== m ? m : {
										via: [this.client.getDomain()]
									};
								await this.client.sendStateEvent(i.roomId, o.EventType.SpaceChild, h(h({}, r), {}, {
									order: t
								}), e.roomId)
							}
						}
						t && (c = (0, d.nextString)(t))
					}
					const p = i.currentState.getStateEvents(o.EventType.SpaceChild, this.roomId),
						g = null !== (t = null == p ? void 0 : p.getContent()) && void 0 !== t ? t : {
							via: [this.client.getDomain()]
						};
					await this.client.sendStateEvent(i.roomId, o.EventType.SpaceChild, h(h({}, g), {}, {
						order: c
					}), this.roomId)
				}
				async createFile(e, t, i, n) {
					var r;
					const {
						content_uri: s
					} = await this.client.uploadContent(t, {
						includeFilename: !1
					});
					i.url = s;
					const a = {
						msgtype: o.MsgType.File,
						body: e,
						url: s,
						file: i
					};
					(n = null !== (r = n) && void 0 !== r ? r : {})["m.new_content"] && (n["m.new_content"] = a);
					const d = await this.client.sendMessage(this.roomId, h(h(h({}, n), a), {}, {
						[o.UNSTABLE_MSC3089_LEAF.name]: {}
					}));
					return await this.client.sendStateEvent(this.roomId, o.UNSTABLE_MSC3089_BRANCH.name, {
						active: !0,
						name: e
					}, d.event_id), d
				}
				getFile(e) {
					const t = this.room.currentState.getStateEvents(o.UNSTABLE_MSC3089_BRANCH.name, e);
					return t ? new l.MSC3089Branch(this.client, t, this) : null
				}
				listFiles() {
					return this.listAllFiles().filter(e => e.isActive)
				}
				listAllFiles() {
					var e;
					return (null !== (e = this.room.currentState.getStateEvents(o.UNSTABLE_MSC3089_BRANCH.name)) && void 0 !== e ? e : []).map(e => new l.MSC3089Branch(this.client, e, this))
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/models/beacon.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.isTimestampInDuration = t.getBeaconInfoIdentifier = t.BeaconEvent = t.Beacon = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/content-helpers.js"),
				o = i("./node_modules/matrix-js-sdk/lib/utils.js"),
				a = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js");
			let d;
			t.BeaconEvent = d,
				function(e) {
					e.New = "Beacon.new", e.Update = "Beacon.update", e.LivenessChange = "Beacon.LivenessChange", e.Destroy = "Beacon.Destroy", e.LocationUpdate = "Beacon.LocationUpdate"
				}(d || (t.BeaconEvent = d = {}));
			const l = (e, t, i) => i >= e && e + t >= i;
			t.isTimestampInDuration = l;
			const c = e => `${e.getRoomId()}_${e.getStateKey()}`;
			t.getBeaconInfoIdentifier = c;
			class u extends a.TypedEventEmitter {
				constructor(e) {
					super(), this.rootEvent = e, (0, r.default)(this, "roomId", void 0), (0, r.default)(this, "_beaconInfo", void 0), (0, r.default)(this, "_isLive", void 0), (0, r.default)(this, "livenessWatchTimeout", void 0), (0, r.default)(this, "_latestLocationEvent", void 0), (0, r.default)(this, "clearLatestLocation", () => {
						this._latestLocationEvent = void 0, this.emit(d.LocationUpdate, this.latestLocationState)
					}), this.setBeaconInfo(this.rootEvent), this.roomId = this.rootEvent.getRoomId()
				}
				get isLive() {
					return !!this._isLive
				}
				get identifier() {
					return c(this.rootEvent)
				}
				get beaconInfoId() {
					return this.rootEvent.getId()
				}
				get beaconInfoOwner() {
					return this.rootEvent.getStateKey()
				}
				get beaconInfoEventType() {
					return this.rootEvent.getType()
				}
				get beaconInfo() {
					return this._beaconInfo
				}
				get latestLocationState() {
					return this._latestLocationEvent && (0, s.parseBeaconContent)(this._latestLocationEvent.getContent())
				}
				get latestLocationEvent() {
					return this._latestLocationEvent
				}
				update(e) {
					if (c(e) !== this.identifier) throw new Error("Invalid updating event");
					e.getTs() < this.rootEvent.getTs() || (this.rootEvent = e, this.setBeaconInfo(this.rootEvent), this.emit(d.Update, e, this), this.clearLatestLocation())
				}
				destroy() {
					this.livenessWatchTimeout && clearTimeout(this.livenessWatchTimeout), this._isLive = !1, this.emit(d.Destroy, this.identifier)
				}
				monitorLiveness() {
					if (this.livenessWatchTimeout && clearTimeout(this.livenessWatchTimeout), this.checkLiveness(), this.beaconInfo)
						if (this.isLive) {
							const e = this.beaconInfo.timestamp + this.beaconInfo.timeout - Date.now();
							e > 1 && (this.livenessWatchTimeout = setTimeout(() => {
								this.monitorLiveness()
							}, e))
						} else this.beaconInfo.timestamp > Date.now() && (this.livenessWatchTimeout = setTimeout(() => {
							this.monitorLiveness()
						}, this.beaconInfo.timestamp - Date.now()))
				}
				addLocations(e) {
					var t;
					if (!this.isLive) return;
					const i = null === (t = e.filter(e => {
						const t = e.getContent(),
							i = (0, s.parseBeaconContent)(t);
						if (!i.uri || !i.timestamp) return !1;
						const {
							timestamp: n
						} = i;
						return this._beaconInfo.timestamp && l(this._beaconInfo.timestamp, this._beaconInfo.timeout, n) && (!this.latestLocationState || n > this.latestLocationState.timestamp)
					}).sort(o.sortEventsByLatestContentTimestamp)) || void 0 === t ? void 0 : t[0];
					i && (this._latestLocationEvent = i, this.emit(d.LocationUpdate, this.latestLocationState))
				}
				setBeaconInfo(e) {
					this._beaconInfo = (0, s.parseBeaconInfoContent)(e.getContent()), this.checkLiveness()
				}
				checkLiveness() {
					var e, t;
					const i = this.isLive;
					if (!this.beaconInfo) return;
					const n = this.beaconInfo.timestamp > Date.now() ? this.beaconInfo.timestamp - 36e4 : this.beaconInfo.timestamp;
					this._isLive = !(null === (e = this._beaconInfo) || void 0 === e || !e.live) && !!n && l(n, null === (t = this._beaconInfo) || void 0 === t ? void 0 : t.timeout, Date.now()), i !== this.isLive && this.emit(d.LivenessChange, this.isLive, this)
				}
			}
			t.Beacon = u
		},
		"./node_modules/matrix-js-sdk/lib/models/event-context.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.EventContext = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/models/event-timeline.js");
			t.EventContext = class {
				constructor(e) {
					this.ourEvent = e, (0, r.default)(this, "timeline", void 0), (0, r.default)(this, "ourEventIndex", 0), (0, r.default)(this, "paginateTokens", {
						[s.Direction.Backward]: null,
						[s.Direction.Forward]: null
					}), this.timeline = [e]
				}
				getEvent() {
					return this.timeline[this.ourEventIndex]
				}
				getTimeline() {
					return this.timeline
				}
				getOurEventIndex() {
					return this.ourEventIndex
				}
				getPaginateToken(e = !1) {
					return this.paginateTokens[e ? s.Direction.Backward : s.Direction.Forward]
				}
				setPaginateToken(e, t = !1) {
					this.paginateTokens[t ? s.Direction.Backward : s.Direction.Forward] = null != e ? e : null
				}
				addEvents(e, t = !1) {
					t ? (this.timeline = e.concat(this.timeline), this.ourEventIndex += e.length) : this.timeline = this.timeline.concat(e)
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/models/event-status.js": function(e, t, i) {
			"use strict";
			let n;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.EventStatus = void 0, t.EventStatus = n,
				function(e) {
					e.NOT_SENT = "not_sent", e.ENCRYPTING = "encrypting", e.SENDING = "sending", e.QUEUED = "queued", e.SENT = "sent", e.CANCELLED = "cancelled"
				}(n || (t.EventStatus = n = {}))
		},
		"./node_modules/matrix-js-sdk/lib/models/event-timeline-set.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.EventTimelineSet = t.DuplicateStrategy = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/models/event-timeline.js"),
				o = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				a = i("./node_modules/matrix-js-sdk/lib/models/room.js"),
				d = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js"),
				l = i("./node_modules/matrix-js-sdk/lib/models/relations-container.js");
			let c, u;
			c = o.logger.log.bind(o.logger), t.DuplicateStrategy = u,
				function(e) {
					e.Ignore = "ignore", e.Replace = "replace"
				}(u || (t.DuplicateStrategy = u = {}));
			class h extends d.TypedEventEmitter {
				constructor(e, t = {}, i, n, o = null) {
					var a, d, c;
					super(), this.room = e, this.thread = n, this.threadListType = o, (0, r.default)(this, "relations", void 0), (0, r.default)(this, "timelineSupport", void 0), (0, r.default)(this, "displayPendingEvents", void 0), (0, r.default)(this, "liveTimeline", void 0), (0, r.default)(this, "timelines", void 0), (0, r.default)(this, "_eventIdToTimeline", new Map), (0, r.default)(this, "filter", void 0), this.timelineSupport = Boolean(t.timelineSupport), this.liveTimeline = new s.EventTimeline(this), this.displayPendingEvents = !1 !== t.pendingEvents, this.timelines = [this.liveTimeline], this._eventIdToTimeline = new Map, this.filter = t.filter, this.relations = null !== (a = null === (d = this.room) || void 0 === d ? void 0 : d.relations) && void 0 !== a ? a : new l.RelationsContainer(null !== (c = null == e ? void 0 : e.client) && void 0 !== c ? c : i)
				}
				getTimelines() {
					return this.timelines
				}
				getFilter() {
					return this.filter
				}
				setFilter(e) {
					this.filter = e
				}
				getPendingEvents() {
					return this.room && this.displayPendingEvents ? this.room.getPendingEvents() : []
				}
				getLiveTimeline() {
					return this.liveTimeline
				}
				setLiveTimeline(e) {
					this.liveTimeline = e
				}
				eventIdToTimeline(e) {
					return this._eventIdToTimeline.get(e)
				}
				replaceEventId(e, t) {
					const i = this._eventIdToTimeline.get(e);
					i && (this._eventIdToTimeline.delete(e), this._eventIdToTimeline.set(t, i))
				}
				resetLiveTimeline(e, t) {
					const i = !this.timelineSupport || !t,
						n = this.liveTimeline,
						r = i ? n.forkLive(s.EventTimeline.FORWARDS) : n.fork(s.EventTimeline.FORWARDS);
					i ? (this.timelines = [r], this._eventIdToTimeline = new Map) : this.timelines.push(r), t && n.setPaginationToken(t, s.EventTimeline.FORWARDS), r.setPaginationToken(null != e ? e : null, s.EventTimeline.BACKWARDS), this.liveTimeline = r, this.emit(a.RoomEvent.TimelineReset, this.room, this, i)
				}
				getTimelineForEvent(e) {
					if (null == e) return null;
					const t = this._eventIdToTimeline.get(e);
					return void 0 === t ? null : t
				}
				findEventById(e) {
					const t = this.getTimelineForEvent(e);
					if (t) return t.getEvents().find((function(t) {
						return t.getId() == e
					}))
				}
				addTimeline() {
					if (!this.timelineSupport) throw new Error("timeline support is disabled. Set the 'timelineSupport' parameter to true when creating MatrixClient to enable it.");
					const e = new s.EventTimeline(this);
					return this.timelines.push(e), e
				}
				addEventsToTimeline(e, t, i, n) {
					if (!i) throw new Error("'timeline' not specified for EventTimelineSet.addEventsToTimeline");
					if (!t && i == this.liveTimeline) throw new Error("EventTimelineSet.addEventsToTimeline cannot be used for adding events to the live timeline - use Room.addLiveEvents instead");
					if (this.filter && !(e = this.filter.filterRoomTimeline(e)).length) return;
					const r = t ? s.EventTimeline.BACKWARDS : s.EventTimeline.FORWARDS,
						a = t ? s.EventTimeline.FORWARDS : s.EventTimeline.BACKWARDS;
					let d = !1,
						l = !1;
					for (const u of e) {
						const e = u.getId(),
							n = this._eventIdToTimeline.get(e);
						if (!n) {
							this.addEventToTimeline(u, i, {
								toStartOfTimeline: t
							}), l = !0, d = !0;
							continue
						}
						if (l = !1, n == i) {
							c("Event " + e + " already in timeline " + i);
							continue
						}
						const h = i.getNeighbouringTimeline(r);
						if (h) {
							c(n == h ? "Event " + e + " in neighbouring timeline - switching to " + n : "Event " + e + " already in a different timeline " + n), i = n;
							continue
						}
						o.logger.info("Already have timeline for " + e + " - joining timeline " + i + " to " + n);
						const m = n === this.liveTimeline,
							p = i === this.liveTimeline,
							g = r === s.EventTimeline.BACKWARDS && m,
							f = r === s.EventTimeline.FORWARDS && p;
						g || f ? (g && o.logger.warn("Refusing to set a preceding existingTimeLine on our timeline as the existingTimeLine is live (" + n + ")"), f && o.logger.warn("Refusing to set our preceding timeline on a existingTimeLine as our timeline is live (" + i + ")")) : (i.setNeighbouringTimeline(n, r), n.setNeighbouringTimeline(i, a), i = n, d = !0)
					}
					if (l || !d) {
						if (r === s.EventTimeline.FORWARDS && i === this.liveTimeline) return o.logger.warn({
							lastEventWasNew: l,
							didUpdate: d
						}), void o.logger.warn("Refusing to set forwards pagination token of live timeline " + `${i} to ${n}`);
						i.setPaginationToken(null != n ? n : null, r)
					}
				}
				addLiveEvent(e, t, i = !1, n) {
					let r, a = t || u.Ignore;
					if ("object" == typeof t ? ({
							duplicateStrategy: a = u.Ignore,
							fromCache: i = !1,
							roomState: n,
							timelineWasEmpty: r
						} = t) : void 0 !== t && o.logger.warn("Overload deprecated: `EventTimelineSet.addLiveEvent(event, duplicateStrategy?, fromCache?, roomState?)` is deprecated in favor of the overload with `EventTimelineSet.addLiveEvent(event, IAddLiveEventOptions)`"), this.filter) {
						if (!this.filter.filterRoomTimeline([e]).length) return
					}
					const d = this._eventIdToTimeline.get(e.getId());
					if (d)
						if (a === u.Replace) {
							c("EventTimelineSet.addLiveEvent: replacing duplicate event " + e.getId());
							const t = d.getEvents();
							for (let i = 0; i < t.length; i++)
								if (t[i].getId() === e.getId()) {
									n || (n = d.getState(s.EventTimeline.FORWARDS)), s.EventTimeline.setEventMetadata(e, n, !1), t[i] = e;
									break
								}
						} else c("EventTimelineSet.addLiveEvent: ignoring duplicate event " + e.getId());
					else this.addEventToTimeline(e, this.liveTimeline, {
						toStartOfTimeline: !1,
						fromCache: i,
						roomState: n,
						timelineWasEmpty: r
					})
				}
				addEventToTimeline(e, t, i, n = !1, r) {
					let s, d = !!i;
					var l;
					if ("object" == typeof i ? ({
							toStartOfTimeline: d,
							fromCache: n = !1,
							roomState: r,
							timelineWasEmpty: s
						} = i) : void 0 !== i && o.logger.warn("Overload deprecated: `EventTimelineSet.addEventToTimeline(event, timeline, toStartOfTimeline, fromCache?, roomState?)` is deprecated in favor of the overload with `EventTimelineSet.addEventToTimeline(event, timeline, IAddEventToTimelineOptions)`"), t.getTimelineSet() !== this) throw new Error(`EventTimelineSet.addEventToTimeline: Timeline=${t.toString()} does not belong " + \n                "in timelineSet(threadId=${null===(l=this.thread)||void 0===l?void 0:l.id})`);
					if (this.room && !this.canContain(e)) {
						var c;
						let i = `event=${e.getId()}`;
						return e.threadRootId && (i += `(belongs to thread=${e.threadRootId})`), void o.logger.warn(`EventTimelineSet.addEventToTimeline: Ignoring ${i} that does not belong ` + `in timeline=${t.toString()} timelineSet(threadId=${null===(c=this.thread)||void 0===c?void 0:c.id})`)
					}
					const u = e.getId();
					t.addEvent(e, {
						toStartOfTimeline: d,
						roomState: r,
						timelineWasEmpty: s
					}), this._eventIdToTimeline.set(u, t), this.relations.aggregateParentEvent(e), this.relations.aggregateChildEvent(e, this);
					const h = {
						timeline: t,
						liveEvent: !d && t == this.liveTimeline && !n
					};
					this.emit(a.RoomEvent.Timeline, e, this.room, Boolean(d), !1, h)
				}
				handleRemoteEcho(e, t, i) {
					const n = this._eventIdToTimeline.get(t);
					n ? (this._eventIdToTimeline.delete(t), this._eventIdToTimeline.set(i, n)) : this.filter && !this.filter.filterRoomTimeline([e]).length || this.addEventToTimeline(e, this.liveTimeline, {
						toStartOfTimeline: !1
					})
				}
				removeEvent(e) {
					const t = this._eventIdToTimeline.get(e);
					if (!t) return null;
					const i = t.removeEvent(e);
					if (i) {
						this._eventIdToTimeline.delete(e);
						const n = {
							timeline: t
						};
						this.emit(a.RoomEvent.Timeline, i, this.room, void 0, !0, n)
					}
					return i
				}
				compareEventOrdering(e, t) {
					if (e == t) return 0;
					const i = this._eventIdToTimeline.get(e),
						n = this._eventIdToTimeline.get(t);
					if (void 0 === i) return null;
					if (void 0 === n) return null;
					if (i === n) {
						let n = void 0,
							r = void 0;
						const s = i.getEvents();
						for (let i = 0; i < s.length && (void 0 === n || void 0 === r); i++) {
							const o = s[i].getId();
							o == e && (n = i), o == t && (r = i)
						}
						return n - r
					}
					let r = i;
					for (; r;) {
						if (r === n) return -1;
						r = r.getNeighbouringTimeline(s.EventTimeline.FORWARDS)
					}
					for (r = i; r;) {
						if (r === n) return 1;
						r = r.getNeighbouringTimeline(s.EventTimeline.BACKWARDS)
					}
					return null
				}
				canContain(e) {
					if (!this.room) throw new Error("Cannot call `EventTimelineSet::canContain without a `room` set. Set the room when creating the EventTimelineSet to call this method.");
					const {
						threadId: t,
						shouldLiveInRoom: i
					} = this.room.eventShouldLiveIn(e);
					return this.thread ? this.thread.id === t : i
				}
			}
			t.EventTimelineSet = h
		},
		"./node_modules/matrix-js-sdk/lib/models/event-timeline.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.EventTimeline = t.Direction = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = i("./node_modules/matrix-js-sdk/lib/models/room-state.js"),
				a = i("./node_modules/matrix-js-sdk/lib/@types/event.js");
			let d;
			t.Direction = d,
				function(e) {
					e.Backward = "b", e.Forward = "f"
				}(d || (t.Direction = d = {}));
			class l {
				static setEventMetadata(e, t, i) {
					var n, r, s, o;
					null !== (n = e.sender) && void 0 !== n && null !== (r = n.events) && void 0 !== r && r.member || (e.sender = t.getSentinelMember(e.getSender())), null !== (s = e.target) && void 0 !== s && null !== (o = s.events) && void 0 !== o && o.member || e.getType() !== a.EventType.RoomMember || (e.target = t.getSentinelMember(e.getStateKey())), e.isState() && i && (e.forwardLooking = !1)
				}
				constructor(e) {
					var t, i;
					this.eventTimelineSet = e, (0, r.default)(this, "roomId", void 0), (0, r.default)(this, "name", void 0), (0, r.default)(this, "events", []), (0, r.default)(this, "baseIndex", 0), (0, r.default)(this, "startState", void 0), (0, r.default)(this, "endState", void 0), (0, r.default)(this, "startToken", null), (0, r.default)(this, "endToken", null), (0, r.default)(this, "prevTimeline", null), (0, r.default)(this, "nextTimeline", null), (0, r.default)(this, "paginationRequests", {
						[d.Backward]: null,
						[d.Forward]: null
					}), this.roomId = null !== (t = null === (i = e.room) || void 0 === i ? void 0 : i.roomId) && void 0 !== t ? t : null, this.roomId && (this.startState = new o.RoomState(this.roomId), this.endState = new o.RoomState(this.roomId)), this.paginationRequests = {
						b: null,
						f: null
					}, this.name = this.roomId + ":" + (new Date).toISOString()
				}
				initialiseState(e, {
					timelineWasEmpty: t
				} = {}) {
					var i, n;
					if (this.events.length > 0) throw new Error("Cannot initialise state after events are added");
					null === (i = this.startState) || void 0 === i || i.setStateEvents(e, {
						timelineWasEmpty: t
					}), null === (n = this.endState) || void 0 === n || n.setStateEvents(e, {
						timelineWasEmpty: t
					})
				}
				forkLive(e) {
					const t = this.getState(e),
						i = new l(this.eventTimelineSet);
					return i.startState = null == t ? void 0 : t.clone(), i.endState = t, this.endState = null == t ? void 0 : t.clone(), i
				}
				fork(e) {
					const t = this.getState(e),
						i = new l(this.eventTimelineSet);
					return i.startState = null == t ? void 0 : t.clone(), i.endState = null == t ? void 0 : t.clone(), i
				}
				getRoomId() {
					return this.roomId
				}
				getFilter() {
					return this.eventTimelineSet.getFilter()
				}
				getTimelineSet() {
					return this.eventTimelineSet
				}
				getBaseIndex() {
					return this.baseIndex
				}
				getEvents() {
					return this.events
				}
				getState(e) {
					if (e == l.BACKWARDS) return this.startState;
					if (e == l.FORWARDS) return this.endState;
					throw new Error("Invalid direction '" + e + "'")
				}
				getPaginationToken(e) {
					return this.roomId ? this.getState(e).paginationToken : e === d.Backward ? this.startToken : this.endToken
				}
				setPaginationToken(e, t) {
					this.roomId ? this.getState(t).paginationToken = e : t === d.Backward ? this.startToken = e : this.endToken = e
				}
				getNeighbouringTimeline(e) {
					if (e == l.BACKWARDS) return this.prevTimeline;
					if (e == l.FORWARDS) return this.nextTimeline;
					throw new Error("Invalid direction '" + e + "'")
				}
				setNeighbouringTimeline(e, t) {
					if (this.getNeighbouringTimeline(t)) throw new Error("timeline already has a neighbouring timeline - cannot reset neighbour (direction: " + t + ")");
					if (t == l.BACKWARDS) this.prevTimeline = e;
					else {
						if (t != l.FORWARDS) throw new Error("Invalid direction '" + t + "'");
						this.nextTimeline = e
					}
					this.setPaginationToken(null, t)
				}
				addEvent(e, t, i) {
					let n, r = !!t;
					"object" == typeof t ? ({
						toStartOfTimeline: r,
						roomState: i,
						timelineWasEmpty: n
					} = t) : void 0 !== t && s.logger.warn("Overload deprecated: `EventTimeline.addEvent(event, toStartOfTimeline, roomState?)` is deprecated in favor of the overload with `EventTimeline.addEvent(event, IAddEventOptions)`"), i || (i = r ? this.startState : this.endState);
					const o = this.getTimelineSet();
					var d;
					o.room && (l.setEventMetadata(e, i, r), e.isState() && o.room.getUnfilteredTimelineSet() === o && (null === (d = i) || void 0 === d || d.setStateEvents([e], {
						timelineWasEmpty: n
					}), e.sender && (e.getType() !== a.EventType.RoomMember || r) || l.setEventMetadata(e, i, r)));
					let c;
					c = r ? 0 : this.events.length, this.events.splice(c, 0, e), r && this.baseIndex++
				}
				removeEvent(e) {
					for (let t = this.events.length - 1; t >= 0; t--) {
						const i = this.events[t];
						if (i.getId() == e) return this.events.splice(t, 1), t < this.baseIndex && this.baseIndex--, i
					}
					return null
				}
				toString() {
					return this.name
				}
			}
			t.EventTimeline = l, (0, r.default)(l, "BACKWARDS", d.Backward), (0, r.default)(l, "FORWARDS", d.Forward)
		},
		"./node_modules/matrix-js-sdk/lib/models/event.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), Object.defineProperty(t, "EventStatus", {
				enumerable: !0,
				get: function() {
					return h.EventStatus
				}
			}), t.MatrixEventEvent = t.MatrixEvent = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-events-sdk/lib/index.js"),
				o = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				a = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				d = i("./node_modules/matrix-js-sdk/lib/utils.js"),
				l = i("./node_modules/matrix-js-sdk/lib/models/thread.js"),
				c = i("./node_modules/matrix-js-sdk/lib/ReEmitter.js"),
				u = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js"),
				h = i("./node_modules/matrix-js-sdk/lib/models/event-status.js");
			const m = Object.freeze({
				visible: !0
			});
			let p;
			t.MatrixEventEvent = p,
				function(e) {
					e.Decrypted = "Event.decrypted", e.BeforeRedaction = "Event.beforeRedaction", e.VisibilityChange = "Event.visibilityChange", e.LocalEventIdReplaced = "Event.localEventIdReplaced", e.Status = "Event.status", e.Replaced = "Event.replaced", e.RelationsCreated = "Event.relationsCreated"
				}(p || (t.MatrixEventEvent = p = {}));
			class g extends u.TypedEventEmitter {
				constructor(e = {}) {
					var t;
					super(), this.event = e, (0, r.default)(this, "pushActions", null), (0, r.default)(this, "_replacingEvent", null), (0, r.default)(this, "_localRedactionEvent", null), (0, r.default)(this, "_isCancelled", !1), (0, r.default)(this, "clearEvent", void 0), (0, r.default)(this, "visibility", m), (0, r.default)(this, "_hasCachedExtEv", !1), (0, r.default)(this, "_cachedExtEv", void 0), (0, r.default)(this, "senderCurve25519Key", null), (0, r.default)(this, "claimedEd25519Key", null), (0, r.default)(this, "forwardingCurve25519KeyChain", []), (0, r.default)(this, "untrusted", null), (0, r.default)(this, "decryptionPromise", null), (0, r.default)(this, "retryDecryption", !1), (0, r.default)(this, "txnId", void 0), (0, r.default)(this, "thread", void 0), (0, r.default)(this, "threadId", void 0), (0, r.default)(this, "localTimestamp", void 0), (0, r.default)(this, "sender", null), (0, r.default)(this, "target", null), (0, r.default)(this, "status", null), (0, r.default)(this, "error", null), (0, r.default)(this, "forwardLooking", !0), (0, r.default)(this, "verificationRequest", void 0), (0, r.default)(this, "reEmitter", void 0), ["state_key", "type", "sender", "room_id", "membership"].forEach(t => {
						"string" == typeof e[t] && (e[t] = (0, d.internaliseString)(e[t]))
					}), ["membership", "avatar_url", "displayname"].forEach(t => {
						var i;
						"string" == typeof(null === (i = e.content) || void 0 === i ? void 0 : i[t]) && (e.content[t] = (0, d.internaliseString)(e.content[t]))
					}), ["rel_type"].forEach(t => {
						var i, n;
						"string" == typeof(null === (i = e.content) || void 0 === i ? void 0 : null === (n = i["m.relates_to"]) || void 0 === n ? void 0 : n[t]) && (e.content["m.relates_to"][t] = (0, d.internaliseString)(e.content["m.relates_to"][t]))
					}), this.txnId = e.txn_id, this.localTimestamp = Date.now() - (null !== (t = this.getAge()) && void 0 !== t ? t : 0), this.reEmitter = new c.TypedReEmitter(this)
				}
				get unstableExtensibleEvent() {
					return this._hasCachedExtEv || (this._cachedExtEv = s.ExtensibleEvents.parse(this.getEffectiveEvent())), this._cachedExtEv
				}
				invalidateExtensibleEvent() {
					this._hasCachedExtEv = !1
				}
				getEffectiveEvent() {
					const e = Object.assign({}, this.getContent());
					if (this.getWireType() === a.EventType.RoomMessageEncrypted)
						for (const [t, i] of Object.entries(this.getWireContent()))["algorithm", "ciphertext", "device_id", "sender_key", "session_id"].includes(t) || void 0 === e[t] && (e[t] = i);
					return Object.assign({}, this.event, this.clearEvent, {
						content: e
					})
				}
				getId() {
					return this.event.event_id
				}
				getSender() {
					return this.event.sender || this.event.user_id
				}
				getType() {
					return this.clearEvent ? this.clearEvent.type : this.event.type
				}
				getWireType() {
					return this.event.type
				}
				getRoomId() {
					return this.event.room_id
				}
				getTs() {
					return this.event.origin_server_ts
				}
				getDate() {
					return this.event.origin_server_ts ? new Date(this.event.origin_server_ts) : null
				}
				getDetails() {
					let e = `id=${this.getId()} type=${this.getWireType()} sender=${this.getSender()}`;
					const t = this.getRoomId();
					t && (e += ` room=${t}`);
					const i = this.getDate();
					return i && (e += ` ts=${i.toISOString()}`), e
				}
				getOriginalContent() {
					return this._localRedactionEvent ? {} : this.clearEvent ? this.clearEvent.content || {} : this.event.content || {}
				}
				getContent() {
					return this._localRedactionEvent ? {} : this._replacingEvent ? this._replacingEvent.getContent()["m.new_content"] || {} : this.getOriginalContent()
				}
				getWireContent() {
					return this.event.content || {}
				}
				get threadRootId() {
					var e;
					const t = null === (e = this.getWireContent()) || void 0 === e ? void 0 : e["m.relates_to"];
					return (null == t ? void 0 : t.rel_type) === l.THREAD_RELATION_TYPE.name ? t.event_id : (null === (i = this.getThread()) || void 0 === i ? void 0 : i.id) || this.threadId;
					var i
				}
				get isThreadRoot() {
					var e;
					return !!this.getServerAggregatedRelation(l.THREAD_RELATION_TYPE.name) || (null === (e = this.getThread()) || void 0 === e ? void 0 : e.id) === this.getId()
				}
				get replyEventId() {
					var e;
					const t = this.getContent()["m.relates_to"] || this.getWireContent()["m.relates_to"];
					return null == t ? void 0 : null === (e = t["m.in_reply_to"]) || void 0 === e ? void 0 : e.event_id
				}
				get relationEventId() {
					var e, t;
					return null === (e = this.getWireContent()) || void 0 === e ? void 0 : null === (t = e["m.relates_to"]) || void 0 === t ? void 0 : t.event_id
				}
				getPrevContent() {
					return this.getUnsigned().prev_content || this.event.prev_content || {}
				}
				getDirectionalContent() {
					return this.forwardLooking ? this.getContent() : this.getPrevContent()
				}
				getAge() {
					return this.getUnsigned().age || this.event.age
				}
				getLocalAge() {
					return Date.now() - this.localTimestamp
				}
				getStateKey() {
					return this.event.state_key
				}
				isState() {
					return void 0 !== this.event.state_key
				}
				makeEncrypted(e, t, i, n) {
					this.clearEvent = {
						type: this.event.type,
						content: this.event.content
					}, this.event.type = e, this.event.content = t, this.senderCurve25519Key = i, this.claimedEd25519Key = n
				}
				isBeingDecrypted() {
					return null != this.decryptionPromise
				}
				getDecryptionPromise() {
					return this.decryptionPromise
				}
				isDecryptionFailure() {
					var e, t;
					return "m.bad.encrypted" === (null === (e = this.clearEvent) || void 0 === e ? void 0 : null === (t = e.content) || void 0 === t ? void 0 : t.msgtype)
				}
				shouldAttemptDecryption() {
					return !this.isRedacted() && (!this.isBeingDecrypted() && (!this.clearEvent && !!this.isEncrypted()))
				}
				async attemptDecryption(e, t = {}) {
					if (!this.isEncrypted()) throw new Error("Attempt to decrypt event which isn't encrypted");
					const i = this.clearEvent && !this.isDecryptionFailure(),
						n = t.forceRedecryptIfUntrusted && this.isKeySourceUntrusted();
					if (i && !n) throw new Error("Attempt to decrypt event which has already been decrypted");
					return this.decryptionPromise ? (o.logger.log(`Event ${this.getId()} already being decrypted; queueing a retry`), this.retryDecryption = !0, this.decryptionPromise) : (this.decryptionPromise = this.decryptionLoop(e, t), this.decryptionPromise)
				}
				cancelAndResendKeyRequest(e, t) {
					const i = this.getWireContent();
					return e.requestRoomKey({
						algorithm: i.algorithm,
						room_id: this.getRoomId(),
						session_id: i.session_id,
						sender_key: i.sender_key
					}, this.getKeyRequestRecipients(t), !0)
				}
				getKeyRequestRecipients(e) {
					const t = this.getWireContent(),
						i = [{
							userId: e,
							deviceId: "*"
						}],
						n = this.getSender();
					return n !== e && i.push({
						userId: n,
						deviceId: t.device_id
					}), i
				}
				async decryptionLoop(e, t = {}) {
					for (await Promise.resolve();;) {
						let n;
						this.retryDecryption = !1;
						let r = void 0;
						try {
							e ? (n = await e.decryptEvent(this), !0 === t.isRetry && o.logger.info(`Decrypted event on retry (${this.getDetails()})`)) : n = this.badEncryptedMessage("Encryption not enabled")
						} catch (i) {
							if ("DecryptionError" !== i.name) {
								const e = t.isRetry ? "re" : "";
								return o.logger.error(`Error ${e}decrypting event (${this.getDetails()})`, i), this.decryptionPromise = null, void(this.retryDecryption = !1)
							}
							if (r = i, this.retryDecryption) {
								o.logger.log(`Error decrypting event (${this.getDetails()}), but retrying: ` + i.detailedString);
								continue
							}
							o.logger.warn(`Error decrypting event (${this.getDetails()}): ` + i.detailedString), n = this.badEncryptedMessage(i.message)
						}
						return this.decryptionPromise = null, this.retryDecryption = !1, this.setClearData(n), this.setPushActions(null), void(!1 !== t.emit && this.emit(p.Decrypted, this, r))
					}
				}
				badEncryptedMessage(e) {
					return {
						clearEvent: {
							type: a.EventType.RoomMessage,
							content: {
								msgtype: "m.bad.encrypted",
								body: "** Unable to decrypt: " + e + " **"
							}
						}
					}
				}
				setClearData(e) {
					var t, i;
					this.clearEvent = e.clearEvent, this.senderCurve25519Key = null !== (t = e.senderCurve25519Key) && void 0 !== t ? t : null, this.claimedEd25519Key = null !== (i = e.claimedEd25519Key) && void 0 !== i ? i : null, this.forwardingCurve25519KeyChain = e.forwardingCurve25519KeyChain || [], this.untrusted = e.untrusted || !1, this.invalidateExtensibleEvent()
				}
				getClearContent() {
					return this.clearEvent ? this.clearEvent.content : null
				}
				isEncrypted() {
					return !this.isState() && this.event.type === a.EventType.RoomMessageEncrypted
				}
				getSenderKey() {
					return this.senderCurve25519Key
				}
				getKeysClaimed() {
					return this.claimedEd25519Key ? {
						ed25519: this.claimedEd25519Key
					} : {}
				}
				getClaimedEd25519Key() {
					return this.claimedEd25519Key
				}
				getForwardingCurve25519KeyChain() {
					return this.forwardingCurve25519KeyChain
				}
				isKeySourceUntrusted() {
					return !!this.untrusted
				}
				getUnsigned() {
					return this.event.unsigned || {}
				}
				setUnsigned(e) {
					this.event.unsigned = e
				}
				unmarkLocallyRedacted() {
					const e = this._localRedactionEvent;
					return this._localRedactionEvent = null, this.event.unsigned && (this.event.unsigned.redacted_because = void 0), !!e
				}
				markLocallyRedacted(e) {
					this._localRedactionEvent || (this.emit(p.BeforeRedaction, this, e), this._localRedactionEvent = e, this.event.unsigned || (this.event.unsigned = {}), this.event.unsigned.redacted_because = e.event)
				}
				applyVisibilityEvent(e) {
					var t, i;
					const n = null === (t = null == e ? void 0 : e.visible) || void 0 === t || t,
						r = null !== (i = null == e ? void 0 : e.reason) && void 0 !== i ? i : null;
					let s = !1;
					this.visibility.visible !== n ? s = !0 : this.visibility.visible || this.visibility.reason === r || (s = !0), s && (this.visibility = n ? m : Object.freeze({
						visible: !1,
						reason: r
					}), this.emit(p.VisibilityChange, this, n))
				}
				messageVisibility() {
					return this.visibility
				}
				makeRedacted(e) {
					if (!e.event) throw new Error("invalid redactionEvent in makeRedacted");
					this._localRedactionEvent = null, this.emit(p.BeforeRedaction, this, e), this._replacingEvent = null, this.event.unsigned || (this.event.unsigned = {}), this.event.unsigned.redacted_because = e.event;
					for (const n in this.event) this.event.hasOwnProperty(n) && !f.has(n) && delete this.event[n];
					this.isEncrypted() && (this.clearEvent = void 0);
					const t = v[this.getType()] || {},
						i = this.getContent();
					for (const n in i) i.hasOwnProperty(n) && !t[n] && delete i[n];
					this.invalidateExtensibleEvent()
				}
				isRedacted() {
					return Boolean(this.getUnsigned().redacted_because)
				}
				isRedaction() {
					return this.getType() === a.EventType.RoomRedaction
				}
				asVisibilityChange() {
					if (!a.EVENT_VISIBILITY_CHANGE_TYPE.matches(this.getType())) return null;
					const e = this.getRelation();
					if (!e || "m.reference" != e.rel_type) return null;
					const t = e.event_id;
					if (!t) return null;
					const i = this.getWireContent(),
						n = !!i.visible,
						r = i.reason;
					return r && "string" != typeof r ? null : {
						visible: n,
						reason: r,
						eventId: t
					}
				}
				isVisibilityEvent() {
					return a.EVENT_VISIBILITY_CHANGE_TYPE.matches(this.getType())
				}
				getRedactionEvent() {
					var e, t, i, n;
					return this.isRedacted() ? null !== (e = this.clearEvent) && void 0 !== e && e.unsigned ? null !== (i = null === (n = this.clearEvent) || void 0 === n ? void 0 : n.unsigned.redacted_because) && void 0 !== i ? i : null : null !== (t = this.event.unsigned) && void 0 !== t && t.redacted_because ? this.event.unsigned.redacted_because : {} : null
				}
				getPushActions() {
					return this.pushActions
				}
				setPushActions(e) {
					this.pushActions = e
				}
				handleRemoteEcho(e) {
					const t = this.getUnsigned(),
						i = this.getId();
					this.event = e, t.redacted_because && (this.event.unsigned || (this.event.unsigned = {}), this.event.unsigned.redacted_because = t.redacted_because), this.setStatus(null), this.getId() !== i && this.emit(p.LocalEventIdReplaced, this), this.localTimestamp = Date.now() - this.getAge()
				}
				isSending() {
					return !!this.status
				}
				setStatus(e) {
					this.status = e, this.emit(p.Status, this, e)
				}
				replaceLocalEventId(e) {
					this.event.event_id = e, this.emit(p.LocalEventIdReplaced, this)
				}
				isRelation(e) {
					var t;
					const i = null === (t = this.getWireContent()) || void 0 === t ? void 0 : t["m.relates_to"];
					return (!this.isState() || (null == i ? void 0 : i.rel_type) !== a.RelationType.Replace) && !(null == i || !i.rel_type || !i.event_id || e && i.rel_type !== e)
				}
				getRelation() {
					var e;
					return this.isRelation() && null !== (e = this.getWireContent()["m.relates_to"]) && void 0 !== e ? e : null
				}
				makeReplaced(e) {
					this.isRedacted() && e || this.isState() || this._replacingEvent !== e && (this._replacingEvent = null != e ? e : null, this.emit(p.Replaced, this), this.invalidateExtensibleEvent())
				}
				getAssociatedStatus() {
					return this._replacingEvent ? this._replacingEvent.status : this._localRedactionEvent ? this._localRedactionEvent.status : this.status
				}
				getServerAggregatedRelation(e) {
					var t;
					return null === (t = this.getUnsigned()["m.relations"]) || void 0 === t ? void 0 : t[e]
				}
				replacingEventId() {
					const e = this.getServerAggregatedRelation(a.RelationType.Replace);
					return e ? e.event_id : this._replacingEvent ? this._replacingEvent.getId() : void 0
				}
				replacingEvent() {
					return this._replacingEvent
				}
				replacingEventDate() {
					const e = this.getServerAggregatedRelation(a.RelationType.Replace);
					if (e) {
						const t = e.origin_server_ts;
						if (Number.isFinite(t)) return new Date(t)
					} else if (this._replacingEvent) {
						var t;
						return null !== (t = this._replacingEvent.getDate()) && void 0 !== t ? t : void 0
					}
				}
				localRedactionEvent() {
					return this._localRedactionEvent
				}
				getAssociatedId() {
					const e = this.getRelation();
					return this.replyEventId ? this.replyEventId : e ? e.event_id : this.isRedaction() ? this.event.redacts : void 0
				}
				hasAssocation() {
					return !!this.getAssociatedId()
				}
				updateAssociatedId(e) {
					const t = this.getRelation();
					t ? t.event_id = e : this.isRedaction() && (this.event.redacts = e)
				}
				flagCancelled(e = !0) {
					this._isCancelled = e
				}
				isCancelled() {
					return this._isCancelled
				}
				toSnapshot() {
					const e = new g(JSON.parse(JSON.stringify(this.event)));
					for (const [t, i] of Object.entries(this)) "event" !== t && (e[t] = i);
					return e
				}
				isEquivalentTo(e) {
					if (!e) return !1;
					if (e === this) return !0;
					const t = (0, d.deepSortedObjectEntries)(this.event),
						i = (0, d.deepSortedObjectEntries)(e.event);
					return JSON.stringify(t) === JSON.stringify(i)
				}
				toJSON() {
					const e = this.getEffectiveEvent();
					return this.isEncrypted() ? {
						decrypted: e,
						encrypted: this.event
					} : e
				}
				setVerificationRequest(e) {
					this.verificationRequest = e
				}
				setTxnId(e) {
					this.txnId = e
				}
				getTxnId() {
					return this.txnId
				}
				setThread(e) {
					this.thread && this.reEmitter.stopReEmitting(this.thread, [l.ThreadEvent.Update]), this.thread = e, this.setThreadId(null == e ? void 0 : e.id), e && this.reEmitter.reEmit(e, [l.ThreadEvent.Update])
				}
				getThread() {
					return this.thread
				}
				setThreadId(e) {
					this.threadId = e
				}
			}
			t.MatrixEvent = g;
			const f = new Set(["event_id", "type", "room_id", "user_id", "sender", "state_key", "prev_state", "content", "unsigned", "origin_server_ts"]),
				v = {
					[a.EventType.RoomMember]: {
						membership: 1
					},
					[a.EventType.RoomCreate]: {
						creator: 1
					},
					[a.EventType.RoomJoinRules]: {
						join_rule: 1
					},
					[a.EventType.RoomPowerLevels]: {
						ban: 1,
						events: 1,
						events_default: 1,
						kick: 1,
						redact: 1,
						state_default: 1,
						users: 1,
						users_default: 1
					}
				}
		},
		"./node_modules/matrix-js-sdk/lib/models/invites-ignorer.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.PolicyScope = t.POLICIES_ACCOUNT_EVENT_TYPE = t.IgnoredInvites = t.IGNORE_INVITES_ACCOUNT_EVENT_KEY = void 0;
			var n = i("./node_modules/matrix-events-sdk/lib/index.js"),
				r = i("./node_modules/matrix-js-sdk/lib/models/event-timeline.js"),
				s = i("./node_modules/matrix-js-sdk/lib/@types/partials.js"),
				o = i("./node_modules/matrix-js-sdk/lib/utils.js");
			const a = new n.UnstableValue("m.policies", "org.matrix.msc3847.policies");
			t.POLICIES_ACCOUNT_EVENT_TYPE = a;
			const d = new n.UnstableValue("m.ignore.invites", "org.matrix.msc3847.ignore.invites");
			var l;
			let c;
			t.IGNORE_INVITES_ACCOUNT_EVENT_KEY = d,
				function(e) {
					e.Ban = "m.ban"
				}(l || (l = {})), t.PolicyScope = c,
				function(e) {
					e.User = "m.policy.user", e.Room = "m.policy.room", e.Server = "m.policy.server"
				}(c || (t.PolicyScope = c = {}));
			t.IgnoredInvites = class {
				constructor(e) {
					this.client = e
				}
				async addRule(e, t, i) {
					const n = await this.getOrCreateTargetRoom();
					return (await this.client.sendStateEvent(n.roomId, e, {
						entity: t,
						reason: i,
						recommendation: l.Ban
					})).event_id
				}
				async removeRule(e) {
					await this.client.redactEvent(e.getRoomId(), e.getId())
				}
				async addSource(e) {
					await this.client.joinRoom(e);
					const t = (await this.getOrCreateSourceRooms()).map(e => e.roomId);
					return !t.includes(e) && (t.push(e), await this.withIgnoreInvitesPolicies(e => {
						e.sources = t
					}), !0)
				}
				async getRuleForInvite({
					sender: e,
					roomId: t
				}) {
					const i = await this.getOrCreateSourceRooms(),
						n = e.split(":")[1],
						s = t.split(":")[1];
					for (const d of i) {
						const i = d.getUnfilteredTimelineSet().getLiveTimeline().getState(r.EventTimeline.FORWARDS);
						for (const {
								scope: r,
								entities: d
							} of [{
								scope: c.Room,
								entities: [t]
							}, {
								scope: c.User,
								entities: [e]
							}, {
								scope: c.Server,
								entities: [n, s]
							}]) {
							const e = i.getStateEvents(r);
							for (const t of e) {
								const e = t.getContent();
								if ((null == e ? void 0 : e.recommendation) != l.Ban) continue;
								const i = null == e ? void 0 : e.entity;
								if (!i) continue;
								let n;
								try {
									n = new RegExp((0, o.globToRegexp)(i, !1))
								} catch (a) {
									continue
								}
								for (const r of d)
									if (r && n.test(r)) return t
							}
						}
					}
					return null
				}
				async getOrCreateTargetRoom() {
					let e = this.getIgnoreInvitesPolicies().target;
					if ("string" != typeof e && (e = null), e) {
						const t = this.client.getRoom(e);
						if (t) return t;
						e = null
					}
					return e = (await this.client.createRoom({
						name: "Individual Policy Room",
						preset: s.Preset.PrivateChat
					})).room_id, await this.withIgnoreInvitesPolicies(t => {
						t.target = e
					}), this.client.getRoom(e)
				}
				async getOrCreateSourceRooms() {
					let e = this.getIgnoreInvitesPolicies().sources,
						t = !1;
					Array.isArray(e) || (t = !0, e = []);
					let i = e.filter(e => "string" == typeof e).map(e => this.client.getRoom(e)).filter(e => !!e);
					if (i.length != e.length && (t = !0), 0 == i.length) {
						t = !0, i = [await this.getOrCreateTargetRoom()]
					}
					return t && await this.withIgnoreInvitesPolicies(t => {
						t.sources = e
					}), i
				}
				getIgnoreInvitesPolicies() {
					return this.getPoliciesAndIgnoreInvitesPolicies().ignoreInvitesPolicies
				}
				async withIgnoreInvitesPolicies(e) {
					const {
						policies: t,
						ignoreInvitesPolicies: i
					} = this.getPoliciesAndIgnoreInvitesPolicies();
					e(i), t[d.name] = i, await this.client.setAccountData(a.name, t)
				}
				getPoliciesAndIgnoreInvitesPolicies() {
					let e = {};
					for (const r of [a.name, a.altName]) {
						var t;
						if (!r) continue;
						const i = null === (t = this.client.getAccountData(r)) || void 0 === t ? void 0 : t.getContent();
						if (i) {
							e = i;
							break
						}
					}
					let i = {},
						n = !1;
					for (const r of [d.name, d.altName]) {
						if (!r) continue;
						const t = e[r];
						if (t && "object" == typeof t) {
							i = t, n = !0;
							break
						}
					}
					return n || (e[d.name] = i), {
						policies: e,
						ignoreInvitesPolicies: i
					}
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/models/read-receipt.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.ReadReceipt = t.MAIN_ROOM_TIMELINE = void 0, t.synthesizeReceipt = h;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/@types/read_receipts.js"),
				o = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js"),
				a = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = c(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/utils.js")),
				d = i("./node_modules/matrix-js-sdk/lib/models/event.js"),
				l = i("./node_modules/matrix-js-sdk/lib/@types/event.js");

			function c(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (c = function(e) {
					return e ? i : t
				})(e)
			}
			const u = "main";

			function h(e, t, i) {
				var n;
				return new d.MatrixEvent({
					content: {
						[t.getId()]: {
							[i]: {
								[e]: {
									ts: t.getTs(),
									threadId: null !== (n = t.threadRootId) && void 0 !== n ? n : u
								}
							}
						}
					},
					type: l.EventType.Receipt,
					room_id: t.getRoomId()
				})
			}
			t.MAIN_ROOM_TIMELINE = u;
			const m = 0,
				p = 1;
			class g extends o.TypedEventEmitter {
				constructor(...e) {
					super(...e), (0, r.default)(this, "receipts", {}), (0, r.default)(this, "receiptCacheByEventId", {}), (0, r.default)(this, "timeline", void 0)
				}
				getReadReceiptForUserId(e, t = !1, i = s.ReceiptType.Read) {
					var n, r;
					const [o, a] = null !== (n = null === (r = this.receipts[i]) || void 0 === r ? void 0 : r[e]) && void 0 !== n ? n : [];
					return t ? o : null != a ? a : o
				}
				getEventReadUpTo(e, t = !1) {
					var i, n, r, o, a;
					const d = this.getUnfilteredTimelineSet(),
						l = this.getReadReceiptForUserId(e, t, s.ReceiptType.Read),
						c = this.getReadReceiptForUserId(e, t, s.ReceiptType.ReadPrivate);
					let u;
					var h, m;
					(null != l && l.eventId && null != c && c.eventId && (u = d.compareEventOrdering(null == l ? void 0 : l.eventId, null == c ? void 0 : c.eventId)), !u && null != l && null !== (i = l.data) && void 0 !== i && i.ts && null != c && null !== (n = c.data) && void 0 !== n && n.ts) && (u = (null == l ? void 0 : null === (h = l.data) || void 0 === h ? void 0 : h.ts) - (null == c ? void 0 : null === (m = c.data) || void 0 === m ? void 0 : m.ts));
					return u ? null !== (a = u < 0 ? null == c ? void 0 : c.eventId : null == l ? void 0 : l.eventId) && void 0 !== a ? a : null : null !== (r = null !== (o = null == c ? void 0 : c.eventId) && void 0 !== o ? o : null == l ? void 0 : l.eventId) && void 0 !== r ? r : null
				}
				addReceiptToStructure(e, t, i, n, r) {
					var s, o;
					this.receipts[t] || (this.receipts[t] = {}), this.receipts[t][i] || (this.receipts[t][i] = [null, null]);
					const a = this.receipts[t][i];
					let d = a[m];
					var l;
					r && (d = null !== (l = a[p]) && void 0 !== l ? l : a[m]);
					if (d) {
						const t = this.getUnfilteredTimelineSet().compareEventOrdering(d.eventId, e);
						if (null !== t && t >= 0) return
					}
					const c = {
							eventId: e,
							data: n
						},
						u = r ? a[m] : c,
						h = r ? c : a[p];
					let g = null;
					u && h && (g = this.getUnfilteredTimelineSet().compareEventOrdering(u.eventId, h.eventId));
					const f = null === g || g < 0,
						v = null !== (s = a[p]) && void 0 !== s ? s : a[m];
					if (r && f ? a[p] = c : r || (a[m] = c, f || (a[p] = null)), v !== (null !== (o = a[p]) && void 0 !== o ? o : a[m])) {
						if (v && this.receiptCacheByEventId[v.eventId]) {
							const e = v.eventId;
							this.receiptCacheByEventId[e] = this.receiptCacheByEventId[e].filter(e => e.type !== t || e.userId !== i), this.receiptCacheByEventId[e].length < 1 && delete this.receiptCacheByEventId[e]
						}
						this.receiptCacheByEventId[e] || (this.receiptCacheByEventId[e] = []), this.receiptCacheByEventId[e].push({
							userId: i,
							type: t,
							data: n
						})
					}
				}
				getReceiptsForEvent(e) {
					return this.receiptCacheByEventId[e.getId()] || []
				}
				addLocalEchoReceipt(e, t, i) {
					this.addReceipt(h(e, t, i), !0)
				}
				getUsersReadUpTo(e) {
					return this.getReceiptsForEvent(e).filter((function(e) {
						return a.isSupportedReceiptType(e.type)
					})).map((function(e) {
						return e.userId
					}))
				}
				hasUserReadEvent(e, t) {
					var i;
					const n = this.getEventReadUpTo(e, !1);
					if (n === t) return !0;
					if (null !== (i = this.timeline) && void 0 !== i && i.length && this.timeline[this.timeline.length - 1].getSender() && this.timeline[this.timeline.length - 1].getSender() === e) return !0;
					for (let s = (null === (r = this.timeline) || void 0 === r ? void 0 : r.length) - 1; s >= 0; --s) {
						var r;
						const e = this.timeline[s];
						if (e.getId() === t) return !1;
						if (e.getId() === n) return !0
					}
					return !1
				}
			}
			t.ReadReceipt = g
		},
		"./node_modules/matrix-js-sdk/lib/models/relations-container.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.RelationsContainer = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/models/relations.js"),
				o = i("./node_modules/matrix-js-sdk/lib/models/event.js");
			t.RelationsContainer = class {
				constructor(e, t) {
					this.client = e, this.room = t, (0, r.default)(this, "relations", new Map)
				}
				getChildEventsForEvent(e, t, i) {
					var n, r;
					return null === (n = this.relations.get(e)) || void 0 === n ? void 0 : null === (r = n.get(t)) || void 0 === r ? void 0 : r.get(i)
				}
				getAllChildEventsForEvent(e) {
					var t;
					const i = null !== (t = this.relations.get(e)) && void 0 !== t ? t : new Map,
						n = [];
					for (const r of i.values())
						for (const e of r.values()) n.push(...e.getRelations());
					return n
				}
				aggregateParentEvent(e) {
					const t = this.relations.get(e.getId());
					if (t)
						for (const i of t.values())
							for (const t of i.values()) t.setTargetEvent(e)
				}
				aggregateChildEvent(e, t) {
					if (e.isRedacted() || e.status === o.EventStatus.CANCELLED) return;
					const i = e.getRelation();
					if (!i) return;
					const n = () => {
						e.isDecryptionFailure() ? e.once(o.MatrixEventEvent.Decrypted, n) : this.aggregateChildEvent(e, t)
					};
					if (e.isBeingDecrypted() || e.shouldAttemptDecryption()) return void e.once(o.MatrixEventEvent.Decrypted, n);
					const {
						event_id: r,
						rel_type: a
					} = i, d = e.getType();
					let l = this.relations.get(r);
					l || (l = new Map, this.relations.set(r, l));
					let c = l.get(a);
					c || (c = new Map, l.set(a, c));
					let u = c.get(d);
					if (!u) {
						var h, m, p;
						u = new s.Relations(a, d, this.client), c.set(d, u);
						const e = null !== (h = this.room) && void 0 !== h ? h : null == t ? void 0 : t.room,
							i = null !== (m = null !== (p = null == t ? void 0 : t.findEventById(r)) && void 0 !== p ? p : null == e ? void 0 : e.findEventById(r)) && void 0 !== m ? m : null == e ? void 0 : e.getPendingEvent(r);
						i && u.setTargetEvent(i)
					}
					u.addEvent(e)
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/models/relations.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.RelationsEvent = t.Relations = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/models/event.js"),
				o = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				a = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				d = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js"),
				l = i("./node_modules/matrix-js-sdk/lib/models/room.js");
			let c;
			t.RelationsEvent = c,
				function(e) {
					e.Add = "Relations.add", e.Remove = "Relations.remove", e.Redaction = "Relations.redaction"
				}(c || (t.RelationsEvent = c = {}));
			class u extends d.TypedEventEmitter {
				constructor(e, t, i) {
					super(), this.relationType = e, this.eventType = t, (0, r.default)(this, "relationEventIds", new Set), (0, r.default)(this, "relations", new Set), (0, r.default)(this, "annotationsByKey", {}), (0, r.default)(this, "annotationsBySender", {}), (0, r.default)(this, "sortedAnnotationsByKey", []), (0, r.default)(this, "targetEvent", null), (0, r.default)(this, "creationEmitted", !1), (0, r.default)(this, "client", void 0), (0, r.default)(this, "onEventStatus", (e, t) => {
						e.isSending() ? t === s.EventStatus.CANCELLED && (e.removeListener(s.MatrixEventEvent.Status, this.onEventStatus), this.removeEvent(e)) : e.removeListener(s.MatrixEventEvent.Status, this.onEventStatus)
					}), (0, r.default)(this, "onBeforeRedaction", async e => {
						if (this.relations.has(e)) {
							if (this.relations.delete(e), this.relationType === a.RelationType.Annotation) this.removeAnnotationFromAggregation(e);
							else if (this.relationType === a.RelationType.Replace && this.targetEvent && !this.targetEvent.isState()) {
								const e = await this.getLastReplacement();
								this.targetEvent.makeReplaced(e)
							}
							e.removeListener(s.MatrixEventEvent.BeforeRedaction, this.onBeforeRedaction), this.emit(c.Redaction, e)
						}
					}), this.client = i instanceof l.Room ? i.client : i
				}
				async addEvent(e) {
					if (this.relationEventIds.has(e.getId())) return;
					const t = e.getRelation();
					if (!t) return void o.logger.error("Event must have relation info");
					const i = t.rel_type,
						n = e.getType();
					if (this.relationType === i && this.eventType === n) {
						if (e.isSending() && e.on(s.MatrixEventEvent.Status, this.onEventStatus), this.relations.add(e), this.relationEventIds.add(e.getId()), this.relationType === a.RelationType.Annotation) this.addAnnotationToAggregation(e);
						else if (this.relationType === a.RelationType.Replace && this.targetEvent && !this.targetEvent.isState()) {
							const e = await this.getLastReplacement();
							this.targetEvent.makeReplaced(e)
						}
						e.on(s.MatrixEventEvent.BeforeRedaction, this.onBeforeRedaction), this.emit(c.Add, e), this.maybeEmitCreated()
					} else o.logger.error("Event relation info doesn't match this container")
				}
				async removeEvent(e) {
					if (!this.relations.has(e)) return;
					const t = e.getRelation();
					if (!t) return void o.logger.error("Event must have relation info");
					const i = t.rel_type,
						n = e.getType();
					if (this.relationType === i && this.eventType === n) {
						if (this.relations.delete(e), this.relationType === a.RelationType.Annotation) this.removeAnnotationFromAggregation(e);
						else if (this.relationType === a.RelationType.Replace && this.targetEvent && !this.targetEvent.isState()) {
							const e = await this.getLastReplacement();
							this.targetEvent.makeReplaced(e)
						}
						this.emit(c.Remove, e)
					} else o.logger.error("Event relation info doesn't match this container")
				}
				getRelations() {
					return [...this.relations]
				}
				addAnnotationToAggregation(e) {
					var t;
					const {
						key: i
					} = null !== (t = e.getRelation()) && void 0 !== t ? t : {};
					if (!i) return;
					let n = this.annotationsByKey[i];
					n || (n = this.annotationsByKey[i] = new Set, this.sortedAnnotationsByKey.push([i, n])), n.add(e), this.sortedAnnotationsByKey.sort((e, t) => {
						const i = e[1];
						return t[1].size - i.size
					});
					const r = e.getSender();
					let s = this.annotationsBySender[r];
					s || (s = this.annotationsBySender[r] = new Set), s.add(e)
				}
				removeAnnotationFromAggregation(e) {
					var t;
					const {
						key: i
					} = null !== (t = e.getRelation()) && void 0 !== t ? t : {};
					if (!i) return;
					const n = this.annotationsByKey[i];
					n && (n.delete(e), this.sortedAnnotationsByKey.sort((e, t) => {
						const i = e[1];
						return t[1].size - i.size
					}));
					const r = e.getSender(),
						s = this.annotationsBySender[r];
					s && s.delete(e)
				}
				getSortedAnnotationsByKey() {
					return this.relationType !== a.RelationType.Annotation ? null : this.sortedAnnotationsByKey
				}
				getAnnotationsBySender() {
					return this.relationType !== a.RelationType.Annotation ? null : this.annotationsBySender
				}
				async getLastReplacement() {
					if (this.relationType !== a.RelationType.Replace) return null;
					if (!this.targetEvent) return null;
					const e = this.targetEvent.getServerAggregatedRelation(a.RelationType.Replace),
						t = null == e ? void 0 : e.origin_server_ts,
						i = this.getRelations().reduce((e, i) => i.getSender() !== this.targetEvent.getSender() ? e : t && t > i.getTs() ? e : e && e.getTs() > i.getTs() ? e : i, null);
					return null != i && i.shouldAttemptDecryption() && this.client.isCryptoEnabled() ? await i.attemptDecryption(this.client.crypto) : null != i && i.isBeingDecrypted() && await i.getDecryptionPromise(), i
				}
				async setTargetEvent(e) {
					if (!this.targetEvent) {
						if (this.targetEvent = e, this.relationType === a.RelationType.Replace && !this.targetEvent.isState()) {
							const e = await this.getLastReplacement();
							e && this.targetEvent.makeReplaced(e)
						}
						this.maybeEmitCreated()
					}
				}
				maybeEmitCreated() {
					this.creationEmitted || this.targetEvent && this.relations.size && (this.creationEmitted = !0, this.targetEvent.emit(s.MatrixEventEvent.RelationsCreated, this.relationType, this.eventType))
				}
			}
			t.Relations = u
		},
		"./node_modules/matrix-js-sdk/lib/models/room-member.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.RoomMemberEvent = t.RoomMember = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/content-repo.js"),
				o = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = c(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/utils.js")),
				a = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				d = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js"),
				l = i("./node_modules/matrix-js-sdk/lib/@types/event.js");

			function c(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (c = function(e) {
					return e ? i : t
				})(e)
			}
			let u;
			t.RoomMemberEvent = u,
				function(e) {
					e.Membership = "RoomMember.membership", e.Name = "RoomMember.name", e.PowerLevel = "RoomMember.powerLevel", e.Typing = "RoomMember.typing"
				}(u || (t.RoomMemberEvent = u = {}));
			class h extends d.TypedEventEmitter {
				constructor(e, t) {
					super(), this.roomId = e, this.userId = t, (0, r.default)(this, "_isOutOfBand", !1), (0, r.default)(this, "modified", -1), (0, r.default)(this, "requestedProfileInfo", !1), (0, r.default)(this, "typing", !1), (0, r.default)(this, "name", void 0), (0, r.default)(this, "rawDisplayName", void 0), (0, r.default)(this, "powerLevel", 0), (0, r.default)(this, "powerLevelNorm", 0), (0, r.default)(this, "user", void 0), (0, r.default)(this, "membership", void 0), (0, r.default)(this, "disambiguate", !1), (0, r.default)(this, "events", {}), this.name = t, this.rawDisplayName = t, this.updateModifiedTime()
				}
				markOutOfBand() {
					this._isOutOfBand = !0
				}
				isOutOfBand() {
					return this._isOutOfBand
				}
				setMembershipEvent(e, t) {
					var i, n;
					const r = null !== (i = e.getDirectionalContent().displayname) && void 0 !== i ? i : "";
					if (e.getType() !== l.EventType.RoomMember) return;
					this._isOutOfBand = !1, this.events.member = e;
					const s = this.membership;
					this.membership = e.getDirectionalContent().membership, void 0 === this.membership && a.logger.trace(`membership event with membership undefined (forwardLooking: ${e.forwardLooking})!`, e.getContent(), "prevcontent is ", e.getPrevContent()), this.disambiguate = function(e, t, i) {
						if (!t || t === e) return !1;
						if (!o.removeHiddenChars(t)) return !1;
						if (!i) return !1;
						if (m.test(t)) return !0;
						if (p.test(t)) return !0;
						return !!i.getUserIdsWithDisplayName(t).some(t => t !== e)
					}(this.userId, r, t);
					const d = this.name;
					this.name = function(e, t, i) {
						return t && t !== e ? i ? o.removeDirectionOverrideChars(t) + " (" + e + ")" : o.removeHiddenChars(t) ? o.removeDirectionOverrideChars(t) : e : e
					}(this.userId, r, this.disambiguate), this.rawDisplayName = o.removeDirectionOverrideChars(null !== (n = e.getDirectionalContent().displayname) && void 0 !== n ? n : ""), this.rawDisplayName && o.removeHiddenChars(this.rawDisplayName) || (this.rawDisplayName = this.userId), s !== this.membership && (this.updateModifiedTime(), this.emit(u.Membership, e, this, s)), d !== this.name && (this.updateModifiedTime(), this.emit(u.Name, e, this, d))
				}
				setPowerLevelEvent(e) {
					if (e.getType() !== l.EventType.RoomPowerLevels || "" !== e.getStateKey()) return;
					const t = e.getDirectionalContent();
					let i = t.users_default || 0;
					const n = t.users || {};
					Object.values(n).forEach(e => {
						i = Math.max(i, e)
					});
					const r = this.powerLevel,
						s = this.powerLevelNorm;
					void 0 !== n[this.userId] && Number.isInteger(n[this.userId]) ? this.powerLevel = n[this.userId] : void 0 !== t.users_default ? this.powerLevel = t.users_default : this.powerLevel = 0, this.powerLevelNorm = 0, i > 0 && (this.powerLevelNorm = 100 * this.powerLevel / i), r === this.powerLevel && s === this.powerLevelNorm || (this.updateModifiedTime(), this.emit(u.PowerLevel, e, this))
				}
				setTypingEvent(e) {
					if ("m.typing" !== e.getType()) return;
					const t = this.typing;
					this.typing = !1;
					const i = e.getContent().user_ids;
					Array.isArray(i) && (-1 !== i.indexOf(this.userId) && (this.typing = !0), t !== this.typing && (this.updateModifiedTime(), this.emit(u.Typing, e, this)))
				}
				updateModifiedTime() {
					this.modified = Date.now()
				}
				getLastModifiedTime() {
					return this.modified
				}
				isKicked() {
					return "leave" === this.membership && void 0 !== this.events.member && this.events.member.getSender() !== this.events.member.getStateKey()
				}
				getDMInviter() {
					if (this.events.member) {
						const e = this.events.member;
						let t = e.getContent(),
							i = e.getSender();
						if ("join" === t.membership && (t = e.getPrevContent(), i = e.getUnsigned().prev_sender), "invite" === t.membership && t.is_direct) return i
					}
				}
				getAvatarUrl(e, t, i, n, r = !0, o) {
					const a = this.getMxcAvatarUrl();
					if (!a && !r) return null;
					const d = (0, s.getHttpUriForMxc)(e, a, t, i, n, o);
					return d || null
				}
				getMxcAvatarUrl() {
					return this.events.member ? this.events.member.getDirectionalContent().avatar_url : this.user ? this.user.avatarUrl : void 0
				}
			}
			t.RoomMember = h;
			const m = /@.+:.+/,
				p = /[\u200E\u200F\u202A-\u202F]/
		},
		"./node_modules/matrix-js-sdk/lib/models/room-state.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.RoomStateEvent = t.RoomState = void 0;
			var r, s = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				o = i("./node_modules/matrix-js-sdk/lib/models/room-member.js"),
				a = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				d = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = f(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/utils.js")),
				l = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				c = i("./node_modules/matrix-js-sdk/lib/models/event.js"),
				u = i("./node_modules/matrix-js-sdk/lib/@types/partials.js"),
				h = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js"),
				m = i("./node_modules/matrix-js-sdk/lib/models/beacon.js"),
				p = i("./node_modules/matrix-js-sdk/lib/ReEmitter.js"),
				g = i("./node_modules/matrix-js-sdk/lib/@types/beacon.js");

			function f(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (f = function(e) {
					return e ? i : t
				})(e)
			}

			function v(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function y(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? v(Object(i), !0).forEach((function(t) {
						(0, s.default)(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : v(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}
			let b;
			! function(e) {
				e[e.NotStarted = 0] = "NotStarted", e[e.InProgress = 1] = "InProgress", e[e.Finished = 2] = "Finished"
			}(r || (r = {})), t.RoomStateEvent = b,
				function(e) {
					e.Events = "RoomState.events", e.Members = "RoomState.members", e.NewMember = "RoomState.newMember", e.Update = "RoomState.update", e.BeaconLiveness = "RoomState.BeaconLiveness", e.Marker = "RoomState.Marker"
				}(b || (t.RoomStateEvent = b = {}));
			class _ extends h.TypedEventEmitter {
				constructor(e, t = {
					status: r.NotStarted
				}) {
					super(), this.roomId = e, this.oobMemberFlags = t, (0, s.default)(this, "reEmitter", new p.TypedReEmitter(this)), (0, s.default)(this, "sentinels", {}), (0, s.default)(this, "displayNameToUserIds", new Map), (0, s.default)(this, "userIdsToDisplayNames", {}), (0, s.default)(this, "tokenToInvite", {}), (0, s.default)(this, "joinedMemberCount", null), (0, s.default)(this, "summaryJoinedMemberCount", null), (0, s.default)(this, "invitedMemberCount", null), (0, s.default)(this, "summaryInvitedMemberCount", null), (0, s.default)(this, "modified", -1), (0, s.default)(this, "members", {}), (0, s.default)(this, "events", new Map), (0, s.default)(this, "paginationToken", null), (0, s.default)(this, "beacons", new Map), (0, s.default)(this, "_liveBeaconIds", []), this.updateModifiedTime()
				}
				getJoinedMemberCount() {
					return null !== this.summaryJoinedMemberCount ? this.summaryJoinedMemberCount : (null === this.joinedMemberCount && (this.joinedMemberCount = this.getMembers().reduce((e, t) => "join" === t.membership ? e + 1 : e, 0)), this.joinedMemberCount)
				}
				setJoinedMemberCount(e) {
					this.summaryJoinedMemberCount = e
				}
				getInvitedMemberCount() {
					return null !== this.summaryInvitedMemberCount ? this.summaryInvitedMemberCount : (null === this.invitedMemberCount && (this.invitedMemberCount = this.getMembers().reduce((e, t) => "invite" === t.membership ? e + 1 : e, 0)), this.invitedMemberCount)
				}
				setInvitedMemberCount(e) {
					this.summaryInvitedMemberCount = e
				}
				getMembers() {
					return Object.values(this.members)
				}
				getMembersExcept(e) {
					return this.getMembers().filter(t => !e.includes(t.userId))
				}
				getMember(e) {
					return this.members[e] || null
				}
				getSentinelMember(e) {
					if (!e) return null;
					let t = this.sentinels[e];
					if (void 0 === t) {
						t = new o.RoomMember(this.roomId, e);
						const i = this.members[e];
						null != i && i.events.member && t.setMembershipEvent(i.events.member, this), this.sentinels[e] = t
					}
					return t
				}
				getStateEvents(e, t) {
					if (!this.events.has(e)) return void 0 === t ? [] : null;
					if (void 0 === t) return Array.from(this.events.get(e).values());
					const i = this.events.get(e).get(t);
					return i || null
				}
				get hasLiveBeacons() {
					var e;
					return !(null === (e = this.liveBeaconIds) || void 0 === e || !e.length)
				}
				get liveBeaconIds() {
					return this._liveBeaconIds
				}
				clone() {
					const e = new _(this.roomId, this.oobMemberFlags),
						t = this.oobMemberFlags.status;
					return this.oobMemberFlags.status = r.NotStarted, Array.from(this.events.values()).forEach(t => {
						e.setStateEvents(Array.from(t.values()))
					}), this.oobMemberFlags.status = t, null !== this.summaryInvitedMemberCount && e.setInvitedMemberCount(this.getInvitedMemberCount()), null !== this.summaryJoinedMemberCount && e.setJoinedMemberCount(this.getJoinedMemberCount()), this.oobMemberFlags.status == r.Finished && this.getMembers().forEach(t => {
						var i;
						t.isOutOfBand() && (null === (i = e.getMember(t.userId)) || void 0 === i || i.markOutOfBand())
					}), e
				}
				setUnknownStateEvents(e) {
					const t = e.filter(e => !this.events.has(e.getType()) || !this.events.get(e.getType()).has(e.getStateKey()));
					this.setStateEvents(t)
				}
				setStateEvents(e, t) {
					this.updateModifiedTime(), e.forEach(e => {
						if (e.getRoomId() !== this.roomId || !e.isState()) return;
						g.M_BEACON_INFO.matches(e.getType()) && this.setBeacon(e);
						const t = this.getStateEventMatching(e);
						var i;
						(this.setStateEvent(e), e.getType() === l.EventType.RoomMember) && (this.updateDisplayNameCache(e.getStateKey(), null !== (i = e.getContent().displayname) && void 0 !== i ? i : ""), this.updateThirdPartyTokenCache(e));
						this.emit(b.Events, e, this, t)
					}), this.onBeaconLivenessChange(), e.forEach(e => {
						if (e.getRoomId() === this.roomId && e.isState())
							if (e.getType() === l.EventType.RoomMember) {
								const t = e.getStateKey();
								"leave" !== e.getContent().membership && "ban" !== e.getContent().membership || (e.getContent().avatar_url = e.getContent().avatar_url || e.getPrevContent().avatar_url, e.getContent().displayname = e.getContent().displayname || e.getPrevContent().displayname);
								const i = this.getOrCreateMember(t, e);
								i.setMembershipEvent(e, this), this.updateMember(i), this.emit(b.Members, e, this, i)
							} else if (e.getType() === l.EventType.RoomPowerLevels) {
							if ("" !== e.getStateKey()) return;
							Object.values(this.members).forEach(t => {
								const i = t.getLastModifiedTime();
								t.setPowerLevelEvent(e), i !== t.getLastModifiedTime() && this.emit(b.Members, e, this, t)
							}), this.sentinels = {}
						} else l.UNSTABLE_MSC2716_MARKER.matches(e.getType()) && this.emit(b.Marker, e, t)
					}), this.emit(b.Update, this)
				}
				processBeaconEvents(e, t) {
					if (!e.length || !this.beacons.size) return;
					const i = [...this.beacons.values()].reduce((e, t) => y(y({}, e), {}, {
							[t.beaconInfoId]: t
						}), {}),
						n = (e, t) => {
							if (!g.M_BEACON.matches(t.getType())) return;
							const n = i[e];
							n && n.addLocations([t])
						};
					e.forEach(e => {
						var r;
						const s = null === (r = e.getRelation()) || void 0 === r ? void 0 : r.event_id;
						s && i[s] && (t.decryptEventIfNeeded(e), e.isBeingDecrypted() || e.isDecryptionFailure() ? e.once(c.MatrixEventEvent.Decrypted, async () => {
							n(s, e)
						}) : n(s, e))
					})
				}
				getOrCreateMember(e, t) {
					let i = this.members[e];
					return i || (i = new o.RoomMember(this.roomId, e), this.members[e] = i, this.emit(b.NewMember, t, this, i)), i
				}
				setStateEvent(e) {
					this.events.has(e.getType()) || this.events.set(e.getType(), new Map), this.events.get(e.getType()).set(e.getStateKey(), e)
				}
				setBeacon(e) {
					const t = (0, m.getBeaconInfoIdentifier)(e);
					if (this.beacons.has(t)) {
						const n = this.beacons.get(t);
						var i;
						return e.isRedacted() ? void(n.beaconInfoId === (null === (i = e.getRedactionEvent()) || void 0 === i ? void 0 : i.redacts) && (n.destroy(), this.beacons.delete(t))) : n.update(e)
					}
					if (e.isRedacted()) return;
					const n = new m.Beacon(e);
					this.reEmitter.reEmit(n, [m.BeaconEvent.New, m.BeaconEvent.Update, m.BeaconEvent.Destroy, m.BeaconEvent.LivenessChange]), this.emit(m.BeaconEvent.New, e, n), n.on(m.BeaconEvent.LivenessChange, this.onBeaconLivenessChange.bind(this)), n.on(m.BeaconEvent.Destroy, this.onBeaconLivenessChange.bind(this)), this.beacons.set(n.identifier, n)
				}
				onBeaconLivenessChange() {
					this._liveBeaconIds = Array.from(this.beacons.values()).filter(e => e.isLive).map(e => e.identifier), this.emit(b.BeaconLiveness, this, this.hasLiveBeacons)
				}
				getStateEventMatching(e) {
					var t, i;
					return null !== (t = null === (i = this.events.get(e.getType())) || void 0 === i ? void 0 : i.get(e.getStateKey())) && void 0 !== t ? t : null
				}
				updateMember(e) {
					const t = this.getStateEvents(l.EventType.RoomPowerLevels, "");
					t && e.setPowerLevelEvent(t), delete this.sentinels[e.userId], this.members[e.userId] = e, this.joinedMemberCount = null, this.invitedMemberCount = null
				}
				needsOutOfBandMembers() {
					return this.oobMemberFlags.status === r.NotStarted
				}
				markOutOfBandMembersStarted() {
					this.oobMemberFlags.status === r.NotStarted && (this.oobMemberFlags.status = r.InProgress)
				}
				markOutOfBandMembersFailed() {
					this.oobMemberFlags.status === r.InProgress && (this.oobMemberFlags.status = r.NotStarted)
				}
				clearOutOfBandMembers() {
					let e = 0;
					Object.keys(this.members).forEach(t => {
						this.members[t].isOutOfBand() && (++e, delete this.members[t])
					}), a.logger.log(`LL: RoomState removed ${e} members...`), this.oobMemberFlags.status = r.NotStarted
				}
				setOutOfBandMembers(e) {
					a.logger.log(`LL: RoomState about to set ${e.length} OOB members ...`), this.oobMemberFlags.status === r.InProgress && (a.logger.log("LL: RoomState put in finished state ..."), this.oobMemberFlags.status = r.Finished, e.forEach(e => this.setOutOfBandMember(e)), this.emit(b.Update, this))
				}
				setOutOfBandMember(e) {
					if (e.getType() !== l.EventType.RoomMember) return;
					const t = e.getStateKey(),
						i = this.getMember(t);
					if (i && !i.isOutOfBand()) return;
					const n = this.getOrCreateMember(t, e);
					n.setMembershipEvent(e, this), n.markOutOfBand(), this.updateDisplayNameCache(n.userId, n.name), this.setStateEvent(e), this.updateMember(n), this.emit(b.Members, e, this, n)
				}
				setTypingEvent(e) {
					Object.values(this.members).forEach((function(t) {
						t.setTypingEvent(e)
					}))
				}
				getInviteForThreePidToken(e) {
					return this.tokenToInvite[e] || null
				}
				updateModifiedTime() {
					this.modified = Date.now()
				}
				getLastModifiedTime() {
					return this.modified
				}
				getUserIdsWithDisplayName(e) {
					var t;
					return null !== (t = this.displayNameToUserIds.get(d.removeHiddenChars(e))) && void 0 !== t ? t : []
				}
				maySendRedactionForEvent(e, t) {
					const i = this.getMember(t);
					if (!i || "leave" === i.membership) return !1;
					if (e.status || e.isRedacted()) return !1;
					const n = this.maySendEvent(l.EventType.RoomRedaction, t);
					return e.getSender() === t ? n : this.hasSufficientPowerLevelFor("redact", i.powerLevel)
				}
				hasSufficientPowerLevelFor(e, t) {
					const i = this.getStateEvents(l.EventType.RoomPowerLevels, "");
					let n = {};
					i && (n = i.getContent());
					let r = 50;
					return d.isNumber(n[e]) && (r = n[e]), t >= r
				}
				maySendMessage(e) {
					return this.maySendEventOfType(l.EventType.RoomMessage, e, !1)
				}
				maySendEvent(e, t) {
					return this.maySendEventOfType(e, t, !1)
				}
				mayClientSendStateEvent(e, t) {
					return !(t.isGuest() || !t.credentials.userId) && this.maySendStateEvent(e, t.credentials.userId)
				}
				maySendStateEvent(e, t) {
					return this.maySendEventOfType(e, t, !0)
				}
				maySendEventOfType(e, t, i) {
					const n = this.getStateEvents(l.EventType.RoomPowerLevels, "");
					let r, s = {},
						o = 0,
						a = 0,
						d = 0;
					if (n) {
						s = (r = n.getContent()).events || {}, o = Number.isSafeInteger(r.state_default) ? r.state_default : 50;
						const e = r.users && r.users[t];
						Number.isSafeInteger(e) ? d = e : Number.isSafeInteger(r.users_default) && (d = r.users_default), Number.isSafeInteger(r.events_default) && (a = r.events_default)
					}
					let c = i ? o : a;
					return Number.isSafeInteger(s[e]) && (c = s[e]), d >= c
				}
				mayTriggerNotifOfType(e, t) {
					const i = this.getMember(t);
					if (!i) return !1;
					const n = this.getStateEvents(l.EventType.RoomPowerLevels, "");
					let r = 50;
					return n && n.getContent() && n.getContent().notifications && d.isNumber(n.getContent().notifications[e]) && (r = n.getContent().notifications[e]), i.powerLevel >= r
				}
				getJoinRule() {
					var e;
					const t = this.getStateEvents(l.EventType.RoomJoinRules, "");
					return (null !== (e = null == t ? void 0 : t.getContent()) && void 0 !== e ? e : {}).join_rule || u.JoinRule.Invite
				}
				getHistoryVisibility() {
					var e;
					const t = this.getStateEvents(l.EventType.RoomHistoryVisibility, "");
					return (null !== (e = null == t ? void 0 : t.getContent()) && void 0 !== e ? e : {}).history_visibility || u.HistoryVisibility.Shared
				}
				getGuestAccess() {
					var e;
					const t = this.getStateEvents(l.EventType.RoomGuestAccess, "");
					return (null !== (e = null == t ? void 0 : t.getContent()) && void 0 !== e ? e : {}).guest_access || u.GuestAccess.Forbidden
				}
				updateThirdPartyTokenCache(e) {
					if (!e.getContent().third_party_invite) return;
					const t = (e.getContent().third_party_invite.signed || {}).token;
					t && this.getStateEvents(l.EventType.RoomThirdPartyInvite, t) && (this.tokenToInvite[t] = e)
				}
				updateDisplayNameCache(e, t) {
					const i = this.userIdsToDisplayNames[e];
					if (delete this.userIdsToDisplayNames[e], i) {
						const t = d.removeHiddenChars(i),
							n = this.displayNameToUserIds.get(t);
						if (n) {
							const i = n.filter(t => t !== e);
							this.displayNameToUserIds.set(t, i)
						}
					}
					this.userIdsToDisplayNames[e] = t;
					const n = t && d.removeHiddenChars(t);
					if (n) {
						var r;
						const t = null !== (r = this.displayNameToUserIds.get(n)) && void 0 !== r ? r : [];
						t.push(e), this.displayNameToUserIds.set(n, t)
					}
				}
			}
			t.RoomState = _
		},
		"./node_modules/matrix-js-sdk/lib/models/room-summary.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.RoomSummary = void 0;
			t.RoomSummary = class {
				constructor(e, t) {
					this.roomId = e
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/models/room.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.RoomNameType = t.RoomEvent = t.Room = t.NotificationCountType = t.KNOWN_SAFE_ROOM_VERSION = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/models/event-timeline-set.js"),
				o = i("./node_modules/matrix-js-sdk/lib/models/event-timeline.js"),
				a = i("./node_modules/matrix-js-sdk/lib/content-repo.js"),
				d = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = T(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/utils.js")),
				l = i("./node_modules/matrix-js-sdk/lib/models/event.js"),
				c = i("./node_modules/matrix-js-sdk/lib/models/event-status.js"),
				u = i("./node_modules/matrix-js-sdk/lib/models/room-member.js"),
				h = i("./node_modules/matrix-js-sdk/lib/models/room-summary.js"),
				m = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				p = i("./node_modules/matrix-js-sdk/lib/ReEmitter.js"),
				g = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				f = i("./node_modules/matrix-js-sdk/lib/client.js"),
				v = i("./node_modules/matrix-js-sdk/lib/filter.js"),
				y = i("./node_modules/matrix-js-sdk/lib/models/room-state.js"),
				b = i("./node_modules/matrix-js-sdk/lib/models/beacon.js"),
				_ = i("./node_modules/matrix-js-sdk/lib/models/thread.js"),
				S = i("./node_modules/matrix-js-sdk/lib/@types/read_receipts.js"),
				E = i("./node_modules/matrix-js-sdk/lib/models/relations-container.js"),
				w = i("./node_modules/matrix-js-sdk/lib/models/read-receipt.js"),
				k = i("./node_modules/matrix-js-sdk/lib/feature.js");

			function T(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (T = function(e) {
					return e ? i : t
				})(e)
			}

			function I(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function C(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? I(Object(i), !0).forEach((function(t) {
						(0, r.default)(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : I(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}
			const R = "9";
			t.KNOWN_SAFE_ROOM_VERSION = R;
			const j = ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
				O = 30;
			let x, M;
			t.NotificationCountType = x,
				function(e) {
					e.Highlight = "highlight", e.Total = "total"
				}(x || (t.NotificationCountType = x = {})), t.RoomEvent = M,
				function(e) {
					e.MyMembership = "Room.myMembership", e.Tags = "Room.tags", e.AccountData = "Room.accountData", e.Receipt = "Room.receipt", e.Name = "Room.name", e.Redaction = "Room.redaction", e.RedactionCancelled = "Room.redactionCancelled", e.LocalEchoUpdated = "Room.localEchoUpdated", e.Timeline = "Room.timeline", e.TimelineReset = "Room.timelineReset", e.TimelineRefresh = "Room.TimelineRefresh", e.OldStateUpdated = "Room.OldStateUpdated", e.CurrentStateUpdated = "Room.CurrentStateUpdated", e.HistoryImportedWithinTimeline = "Room.historyImportedWithinTimeline", e.UnreadNotifications = "Room.UnreadNotifications"
				}(M || (t.RoomEvent = M = {}));
			class P extends w.ReadReceipt {
				constructor(e, t, i, n = {}) {
					super(), this.roomId = e, this.client = t, this.myUserId = i, this.opts = n, (0, r.default)(this, "reEmitter", void 0), (0, r.default)(this, "txnToEvent", {}), (0, r.default)(this, "notificationCounts", {}), (0, r.default)(this, "threadNotifications", new Map), (0, r.default)(this, "timelineSets", void 0), (0, r.default)(this, "threadsTimelineSets", []), (0, r.default)(this, "filteredTimelineSets", {}), (0, r.default)(this, "timelineNeedsRefresh", !1), (0, r.default)(this, "pendingEventList", void 0), (0, r.default)(this, "blacklistUnverifiedDevices", void 0), (0, r.default)(this, "selfMembership", void 0), (0, r.default)(this, "summaryHeroes", null), (0, r.default)(this, "getTypeWarning", !1), (0, r.default)(this, "getVersionWarning", !1), (0, r.default)(this, "membersPromise", void 0), (0, r.default)(this, "name", void 0), (0, r.default)(this, "normalizedName", void 0), (0, r.default)(this, "tags", {}), (0, r.default)(this, "accountData", {}), (0, r.default)(this, "summary", null), (0, r.default)(this, "timeline", void 0), (0, r.default)(this, "oldState", void 0), (0, r.default)(this, "currentState", void 0), (0, r.default)(this, "relations", new E.RelationsContainer(this.client, this)), (0, r.default)(this, "threads", new Map), (0, r.default)(this, "lastThread", void 0), (0, r.default)(this, "visibilityEvents", new Map), (0, r.default)(this, "threadTimelineSetsPromise", null), (0, r.default)(this, "threadsReady", !1), (0, r.default)(this, "updateThreadRootEvents", (e, t) => {
						var i, n;
						e.length && (this.updateThreadRootEvent(null === (i = this.threadsTimelineSets) || void 0 === i ? void 0 : i[0], e, t), e.hasCurrentUserParticipated && this.updateThreadRootEvent(null === (n = this.threadsTimelineSets) || void 0 === n ? void 0 : n[1], e, t))
					}), (0, r.default)(this, "updateThreadRootEvent", (e, t, i) => {
						e && t.rootEvent && (_.Thread.hasServerSideSupport ? e.addLiveEvent(t.rootEvent, {
							duplicateStrategy: s.DuplicateStrategy.Replace,
							fromCache: !1,
							roomState: this.currentState
						}) : e.addEventToTimeline(t.rootEvent, e.getLiveTimeline(), {
							toStartOfTimeline: i
						}))
					}), (0, r.default)(this, "applyRedaction", e => {
						if (e.isRedaction()) {
							const t = e.event.redacts,
								i = t ? this.findEventById(t) : void 0;
							if (i) {
								if (i.makeRedacted(e), i.isState()) {
									this.currentState.getStateEvents(i.getType(), i.getStateKey()).getId() === i.getId() && this.currentState.setStateEvents([i])
								}
								this.emit(M.Redaction, e, this), this.visibilityEvents.delete(t), i.isVisibilityEvent() && this.redactVisibilityChangeEvent(e)
							}
						}
					}), this.setMaxListeners(100), this.reEmitter = new p.TypedReEmitter(this), n.pendingEventOrdering = n.pendingEventOrdering || f.PendingEventOrdering.Chronological, this.name = e, this.normalizedName = e, this.timelineSets = [new s.EventTimelineSet(this, n)], this.reEmitter.reEmit(this.getUnfilteredTimelineSet(), [M.Timeline, M.TimelineReset]), this.fixUpLegacyTimelineFields(), this.opts.pendingEventOrdering === f.PendingEventOrdering.Detached && (this.pendingEventList = [], this.client.store.getPendingEvents(this.roomId).then(e => {
						const t = this.client.getEventMapper({
							toDevice: !1,
							decrypt: !1
						});
						e.forEach(async e => {
							const i = t(e);
							i.getType() === g.EventType.RoomMessageEncrypted && this.client.isCryptoEnabled() && await i.attemptDecryption(this.client.crypto), i.setStatus(c.EventStatus.NOT_SENT), this.addPendingEvent(i, i.getTxnId())
						})
					})), this.opts.lazyLoadMembers ? this.membersPromise = void 0 : this.membersPromise = Promise.resolve(!1)
				}
				async createThreadsTimelineSets() {
					var e;
					if (this.threadTimelineSetsPromise) return this.threadTimelineSetsPromise;
					if (null !== (e = this.client) && void 0 !== e && e.supportsExperimentalThreads()) try {
						this.threadTimelineSetsPromise = Promise.all([this.createThreadTimelineSet(), this.createThreadTimelineSet(_.ThreadFilterType.My)]);
						const e = await this.threadTimelineSetsPromise;
						return this.threadsTimelineSets.push(...e), e
					} catch (t) {
						return this.threadTimelineSetsPromise = null, null
					}
					return null
				}
				async decryptCriticalEvents() {
					if (!this.client.isCryptoEnabled()) return;
					const e = this.getEventReadUpTo(this.client.getUserId(), !0),
						t = this.getLiveTimeline().getEvents(),
						i = t.findIndex(t => t.event.event_id === e),
						n = t.slice(i).filter(e => e.shouldAttemptDecryption()).reverse().map(e => e.attemptDecryption(this.client.crypto, {
							isRetry: !0
						}));
					await Promise.allSettled(n)
				}
				async decryptAllEvents() {
					if (!this.client.isCryptoEnabled()) return;
					const e = this.getUnfilteredTimelineSet().getLiveTimeline().getEvents().filter(e => e.shouldAttemptDecryption()).reverse().map(e => e.attemptDecryption(this.client.crypto, {
						isRetry: !0
					}));
					await Promise.allSettled(e)
				}
				getCreator() {
					var e;
					const t = this.currentState.getStateEvents(g.EventType.RoomCreate, "");
					return null !== (e = null == t ? void 0 : t.getContent().creator) && void 0 !== e ? e : null
				}
				getVersion() {
					var e;
					const t = this.currentState.getStateEvents(g.EventType.RoomCreate, "");
					return t ? null !== (e = t.getContent().room_version) && void 0 !== e ? e : "1" : (this.getVersionWarning || (m.logger.warn("[getVersion] Room " + this.roomId + " does not have an m.room.create event"), this.getVersionWarning = !0), "1")
				}
				shouldUpgradeToVersion() {
					return j.includes(this.getVersion()) ? null : R
				}
				async getRecommendedVersion() {
					let e = (await this.client.getCapabilities())["m.room_versions"];
					if (!e) {
						e = {
							default: R,
							available: {}
						};
						for (const t of j) e.available[t] = f.RoomVersionStability.Stable
					}
					let t = this.checkVersionAgainstCapability(e);
					if (t.urgent && t.needsUpgrade) {
						if (m.logger.warn("Refreshing room version capability because the server looks to be supporting a newer room version we don't know about."), !(e = (await this.client.getCapabilities(!0))["m.room_versions"])) return m.logger.warn("No room version capability - assuming upgrade required."), t;
						t = this.checkVersionAgainstCapability(e)
					}
					return t
				}
				checkVersionAgainstCapability(e) {
					const t = this.getVersion();
					m.logger.log(`[${this.roomId}] Current version: ${t}`), m.logger.log(`[${this.roomId}] Version capability: `, e);
					const i = {
						version: t,
						needsUpgrade: !1,
						urgent: !1
					};
					return t === e.default ? i : Object.keys(e.available).filter(t => "stable" === e.available[t]).includes(t) ? i : (i.version = e.default, i.needsUpgrade = !0, i.urgent = !!this.getVersion().match(/^[0-9]+[0-9.]*$/g), i.urgent ? m.logger.warn(`URGENT upgrade required on ${this.roomId}`) : m.logger.warn(`Non-urgent upgrade required on ${this.roomId}`), i)
				}
				userMayUpgradeRoom(e) {
					return this.currentState.maySendStateEvent(g.EventType.RoomTombstone, e)
				}
				getPendingEvents() {
					if (!this.pendingEventList) throw new Error("Cannot call getPendingEvents with pendingEventOrdering == " + this.opts.pendingEventOrdering);
					return this.pendingEventList
				}
				removePendingEvent(e) {
					if (!this.pendingEventList) throw new Error("Cannot call removePendingEvent with pendingEventOrdering == " + this.opts.pendingEventOrdering);
					const t = d.removeElement(this.pendingEventList, (function(t) {
						return t.getId() == e
					}), !1);
					return this.savePendingEvents(), t
				}
				hasPendingEvent(e) {
					var t, i;
					return null !== (t = null === (i = this.pendingEventList) || void 0 === i ? void 0 : i.some(t => t.getId() === e)) && void 0 !== t && t
				}
				getPendingEvent(e) {
					var t, i;
					return null !== (t = null === (i = this.pendingEventList) || void 0 === i ? void 0 : i.find(t => t.getId() === e)) && void 0 !== t ? t : null
				}
				getLiveTimeline() {
					return this.getUnfilteredTimelineSet().getLiveTimeline()
				}
				getLastActiveTimestamp() {
					const e = this.getLiveTimeline().getEvents();
					if (e.length) {
						return e[e.length - 1].getTs()
					}
					return Number.MIN_SAFE_INTEGER
				}
				getMyMembership() {
					var e;
					return null !== (e = this.selfMembership) && void 0 !== e ? e : "leave"
				}
				getDMInviter() {
					const e = this.getMember(this.myUserId);
					if (e) return e.getDMInviter();
					if ("invite" === this.selfMembership) {
						var t;
						if (2 === this.getInvitedAndJoinedMemberCount()) return null === (t = this.summaryHeroes) || void 0 === t ? void 0 : t[0]
					}
				}
				guessDMUserId() {
					const e = this.getMember(this.myUserId);
					if (e) {
						const t = e.getDMInviter();
						if (t) return t
					}
					if (Array.isArray(this.summaryHeroes) && this.summaryHeroes.length) return this.summaryHeroes[0];
					const t = this.currentState.getMembers().find(e => e.userId !== this.myUserId);
					return t ? t.userId : this.myUserId
				}
				getAvatarFallbackMember() {
					if (this.getInvitedAndJoinedMemberCount() > 2) return;
					const e = Array.isArray(this.summaryHeroes) && this.summaryHeroes.length;
					if (e) {
						const e = this.summaryHeroes.map(e => this.getMember(e)).find(e => !!e);
						if (e) return e
					}
					const t = this.currentState.getMembers();
					if (t.length <= 2) {
						const e = t.find(e => e.userId !== this.myUserId);
						if (e) return e
					}
					if (e) {
						const e = this.summaryHeroes.map(e => this.client.getUser(e)).find(e => !!e);
						if (e) {
							const t = new u.RoomMember(this.roomId, e.userId);
							return t.user = e, t
						}
					}
				}
				updateMyMembership(e) {
					const t = this.selfMembership;
					this.selfMembership = e, t !== e && ("leave" === e && this.cleanupAfterLeaving(), this.emit(M.MyMembership, this, e, t))
				}
				async loadMembersFromServer() {
					const e = this.client.store.getSyncToken();
					return (await this.client.members(this.roomId, void 0, "leave", null != e ? e : void 0)).chunk
				}
				async loadMembers() {
					let e = !1,
						t = await this.client.store.getOutOfBandMembers(this.roomId);
					return (null === t || this.client.isCryptoEnabled() && this.client.isRoomEncrypted(this.roomId)) && (e = !0, t = await this.loadMembersFromServer(), m.logger.log(`LL: got ${t.length} ` + `members from server for room ${this.roomId}`)), {
						memberEvents: t.map(this.client.getEventMapper()),
						fromServer: e
					}
				}
				loadMembersIfNeeded() {
					if (this.membersPromise) return this.membersPromise;
					this.currentState.markOutOfBandMembersStarted();
					const e = this.loadMembers().then(e => (this.currentState.setOutOfBandMembers(e.memberEvents), this.client.isCryptoEnabled() && this.client.isRoomEncrypted(this.roomId) && this.client.crypto.trackRoomDevices(this.roomId), e.fromServer)).catch(e => {
						throw this.membersPromise = void 0, this.currentState.markOutOfBandMembersFailed(), e
					});
					return e.then(e => {
						if (e) {
							const e = this.currentState.getMembers().filter(e => e.isOutOfBand()).map(e => {
								var t;
								return null === (t = e.events.member) || void 0 === t ? void 0 : t.event
							});
							return m.logger.log(`LL: telling store to write ${e.length}` + ` members for room ${this.roomId}`), this.client.store.setOutOfBandMembers(this.roomId, e).catch(e => {
								m.logger.log("LL: storing OOB room members failed, oh well", e)
							})
						}
					}).catch(e => {
						m.logger.error(e)
					}), this.membersPromise = e, this.membersPromise
				}
				async clearLoadedMembersIfNeeded() {
					this.opts.lazyLoadMembers && this.membersPromise && (await this.loadMembersIfNeeded(), await this.client.store.clearOutOfBandMembers(this.roomId), this.currentState.clearOutOfBandMembers(), this.membersPromise = void 0)
				}
				cleanupAfterLeaving() {
					this.clearLoadedMembersIfNeeded().catch(e => {
						m.logger.error("error after clearing loaded members from " + `room ${this.roomId} after leaving`), m.logger.log(e)
					})
				}
				async refreshLiveTimeline() {
					const e = this.getLiveTimeline(),
						t = e.getPaginationToken(o.EventTimeline.FORWARDS),
						i = e.getPaginationToken(o.EventTimeline.BACKWARDS),
						n = e.getEvents(),
						r = n[n.length - 1];
					m.logger.log(`[refreshLiveTimeline for ${this.roomId}] at ` + `mostRecentEventInTimeline=${r&&r.getId()} ` + `liveTimelineBefore=${e.toString()} ` + `forwardPaginationToken=${t} ` + `backwardPaginationToken=${i}`);
					const s = this.getUnfilteredTimelineSet();
					let a;
					r ? (this.resetLiveTimeline(null, null), this.emit(M.TimelineRefresh, this, s), a = await this.client.getEventTimeline(s, r.getId())) : a = await this.client.getLatestTimeline(s);
					const d = s.getLiveTimeline();
					!d || null === d.getPaginationToken(o.Direction.Forward) && null === d.getPaginationToken(o.Direction.Backward) && 0 === d.getEvents().length ? (m.logger.log(`[refreshLiveTimeline for ${this.roomId}] using our new live timeline`), a.setPaginationToken(t, o.EventTimeline.FORWARDS), s.setLiveTimeline(a), this.fixUpLegacyTimelineFields()) : m.logger.log(`[refreshLiveTimeline for ${this.roomId}] \`/sync\` or some other request beat us to creating a new ` + "live timeline after we reset it. We'll use that instead since any events in the scrollback from this timeline will include the history."), this.setTimelineNeedsRefresh(!1), this.emit(M.TimelineRefresh, this, s)
				}
				resetLiveTimeline(e, t) {
					for (const i of this.timelineSets) i.resetLiveTimeline(null != e ? e : void 0, null != t ? t : void 0);
					this.fixUpLegacyTimelineFields()
				}
				fixUpLegacyTimelineFields() {
					const e = this.oldState,
						t = this.currentState;
					this.timeline = this.getLiveTimeline().getEvents(), this.oldState = this.getLiveTimeline().getState(o.EventTimeline.BACKWARDS), this.currentState = this.getLiveTimeline().getState(o.EventTimeline.FORWARDS), e !== this.oldState && this.emit(M.OldStateUpdated, this, e, this.oldState), t !== this.currentState && (this.emit(M.CurrentStateUpdated, this, t, this.currentState), this.reEmitter.stopReEmitting(t, [y.RoomStateEvent.Events, y.RoomStateEvent.Members, y.RoomStateEvent.NewMember, y.RoomStateEvent.Update, y.RoomStateEvent.Marker, b.BeaconEvent.New, b.BeaconEvent.Update, b.BeaconEvent.Destroy, b.BeaconEvent.LivenessChange]), this.reEmitter.reEmit(this.currentState, [y.RoomStateEvent.Events, y.RoomStateEvent.Members, y.RoomStateEvent.NewMember, y.RoomStateEvent.Update, y.RoomStateEvent.Marker, b.BeaconEvent.New, b.BeaconEvent.Update, b.BeaconEvent.Destroy, b.BeaconEvent.LivenessChange]))
				}
				async hasUnverifiedDevices() {
					if (!this.client.isRoomEncrypted(this.roomId)) return !1;
					const e = await this.getEncryptionTargetMembers();
					for (const t of e) {
						if (this.client.getStoredDevicesForUser(t.userId).some(e => e.isUnverified())) return !0
					}
					return !1
				}
				getTimelineSets() {
					return this.timelineSets
				}
				getUnfilteredTimelineSet() {
					return this.timelineSets[0]
				}
				getTimelineForEvent(e) {
					const t = this.findEventById(e),
						i = this.findThreadForEvent(t);
					return i ? i.timelineSet.getLiveTimeline() : this.getUnfilteredTimelineSet().getTimelineForEvent(e)
				}
				addTimeline() {
					return this.getUnfilteredTimelineSet().addTimeline()
				}
				setTimelineNeedsRefresh(e) {
					this.timelineNeedsRefresh = e
				}
				getTimelineNeedsRefresh() {
					return this.timelineNeedsRefresh
				}
				findEventById(e) {
					let t = this.getUnfilteredTimelineSet().findEventById(e);
					if (!t) {
						const i = this.getThreads();
						for (let n = 0; n < i.length; n++) {
							if (t = i[n].findEventById(e)) return t
						}
					}
					return t
				}
				getUnreadNotificationCount(e = x.Total) {
					var t;
					let i = null !== (t = this.notificationCounts[e]) && void 0 !== t ? t : 0;
					if (this.client.canSupport.get(k.Feature.ThreadUnreadNotifications) !== k.ServerSupport.Unsupported)
						for (const r of this.threadNotifications.values()) {
							var n;
							i += null !== (n = r[e]) && void 0 !== n ? n : 0
						}
					return i
				}
				getThreadUnreadNotificationCount(e, t = x.Total) {
					var i, n;
					return null !== (i = null === (n = this.threadNotifications.get(e)) || void 0 === n ? void 0 : n[t]) && void 0 !== i ? i : 0
				}
				hasThreadUnreadNotification() {
					for (const i of this.threadNotifications.values()) {
						var e, t;
						if ((null !== (e = i.highlight) && void 0 !== e ? e : 0) > 0 || (null !== (t = i.total) && void 0 !== t ? t : 0) > 0) return !0
					}
					return !1
				}
				setThreadUnreadNotificationCount(e, t, i) {
					var n, r;
					const s = C({
						highlight: null === (n = this.threadNotifications.get(e)) || void 0 === n ? void 0 : n.highlight,
						total: null === (r = this.threadNotifications.get(e)) || void 0 === r ? void 0 : r.total
					}, {
						[t]: i
					});
					this.threadNotifications.set(e, s), this.emit(M.UnreadNotifications, s, e)
				}
				get threadsAggregateNotificationType() {
					let e = null;
					for (const n of this.threadNotifications.values()) {
						var t, i;
						if ((null !== (t = n.highlight) && void 0 !== t ? t : 0) > 0) return x.Highlight;
						(null !== (i = n.total) && void 0 !== i ? i : 0) > 0 && !e && (e = x.Total)
					}
					return e
				}
				resetThreadUnreadNotificationCount(e) {
					if (e)
						for (const [t] of this.threadNotifications) e.includes(t) || this.threadNotifications.delete(t);
					else this.threadNotifications.clear();
					this.emit(M.UnreadNotifications)
				}
				setUnreadNotificationCount(e, t) {
					this.notificationCounts[e] = t, this.emit(M.UnreadNotifications, this.notificationCounts)
				}
				setSummary(e) {
					const t = e["m.heroes"],
						i = e["m.joined_member_count"],
						n = e["m.invited_member_count"];
					Number.isInteger(i) && this.currentState.setJoinedMemberCount(i), Number.isInteger(n) && this.currentState.setInvitedMemberCount(n), Array.isArray(t) && (this.summaryHeroes = t.filter(e => e !== this.myUserId))
				}
				setBlacklistUnverifiedDevices(e) {
					this.blacklistUnverifiedDevices = e
				}
				getBlacklistUnverifiedDevices() {
					return void 0 === this.blacklistUnverifiedDevices ? null : this.blacklistUnverifiedDevices
				}
				getAvatarUrl(e, t, i, n, r = !0) {
					const s = this.currentState.getStateEvents(g.EventType.RoomAvatar, "");
					if (!s && !r) return null;
					const o = s ? s.getContent().url : null;
					return o ? (0, a.getHttpUriForMxc)(e, o, t, i, n) : null
				}
				getMxcAvatarUrl() {
					var e, t;
					return (null === (e = this.currentState.getStateEvents(g.EventType.RoomAvatar, "")) || void 0 === e ? void 0 : null === (t = e.getContent()) || void 0 === t ? void 0 : t.url) || null
				}
				getCanonicalAlias() {
					const e = this.currentState.getStateEvents(g.EventType.RoomCanonicalAlias, "");
					return e && e.getContent().alias || null
				}
				getAltAliases() {
					const e = this.currentState.getStateEvents(g.EventType.RoomCanonicalAlias, "");
					return e && e.getContent().alt_aliases || []
				}
				addEventsToTimeline(e, t, i, n) {
					i.getTimelineSet().addEventsToTimeline(e, t, i, n)
				}
				getThread(e) {
					var t;
					return null !== (t = this.threads.get(e)) && void 0 !== t ? t : null
				}
				getThreads() {
					return Array.from(this.threads.values())
				}
				getMember(e) {
					return this.currentState.getMember(e)
				}
				getMembers() {
					return this.currentState.getMembers()
				}
				getJoinedMembers() {
					return this.getMembersWithMembership("join")
				}
				getJoinedMemberCount() {
					return this.currentState.getJoinedMemberCount()
				}
				getInvitedMemberCount() {
					return this.currentState.getInvitedMemberCount()
				}
				getInvitedAndJoinedMemberCount() {
					return this.getInvitedMemberCount() + this.getJoinedMemberCount()
				}
				getMembersWithMembership(e) {
					return this.currentState.getMembers().filter((function(t) {
						return t.membership === e
					}))
				}
				async getEncryptionTargetMembers() {
					await this.loadMembersIfNeeded();
					let e = this.getMembersWithMembership("join");
					return this.shouldEncryptForInvitedMembers() && (e = e.concat(this.getMembersWithMembership("invite"))), e
				}
				shouldEncryptForInvitedMembers() {
					var e;
					const t = this.currentState.getStateEvents(g.EventType.RoomHistoryVisibility, "");
					return "joined" !== (null == t ? void 0 : null === (e = t.getContent()) || void 0 === e ? void 0 : e.history_visibility)
				}
				getDefaultRoomName(e) {
					return this.calculateRoomName(e, !0)
				}
				hasMembershipState(e, t) {
					const i = this.getMember(e);
					return !!i && i.membership === t
				}
				getOrCreateFilteredTimelineSet(e, {
					prepopulateTimeline: t = !0,
					useSyncEvents: i = !0,
					pendingEvents: n = !0
				} = {}) {
					if (this.filteredTimelineSets[e.filterId]) return this.filteredTimelineSets[e.filterId];
					const r = Object.assign({
							filter: e,
							pendingEvents: n
						}, this.opts),
						a = new s.EventTimelineSet(this, r);
					this.reEmitter.reEmit(a, [M.Timeline, M.TimelineReset]), i && (this.filteredTimelineSets[e.filterId] = a, this.timelineSets.push(a));
					const d = this.getLiveTimeline();
					if (t) {
						d.getEvents().forEach((function(e) {
							a.addLiveEvent(e)
						}));
						let e = d;
						for (; e.getNeighbouringTimeline(o.EventTimeline.BACKWARDS);) e = e.getNeighbouringTimeline(o.EventTimeline.BACKWARDS);
						a.getLiveTimeline().setPaginationToken(e.getPaginationToken(o.EventTimeline.BACKWARDS), o.EventTimeline.BACKWARDS)
					} else if (i) {
						const e = d.getPaginationToken(o.Direction.Forward);
						a.getLiveTimeline().setPaginationToken(e, o.Direction.Backward)
					}
					return a
				}
				async getThreadListFilter(e = _.ThreadFilterType.All) {
					const t = this.client.getUserId(),
						i = new v.Filter(t),
						n = {
							room: {
								timeline: {
									[_.FILTER_RELATED_BY_REL_TYPES.name]: [_.THREAD_RELATION_TYPE.name]
								}
							}
						};
					e === _.ThreadFilterType.My && (n.room.timeline[_.FILTER_RELATED_BY_SENDERS.name] = [t]), i.setDefinition(n);
					const r = await this.client.getOrCreateFilter(`THREAD_PANEL_${this.roomId}_${e}`, i);
					return i.filterId = r, i
				}
				async createThreadTimelineSet(e) {
					let t;
					if (_.Thread.hasServerSideListSupport) t = new s.EventTimelineSet(this, C(C({}, this.opts), {}, {
						pendingEvents: !1
					}), void 0, void 0, null != e ? e : _.ThreadFilterType.All), this.reEmitter.reEmit(t, [M.Timeline, M.TimelineReset]);
					else if (_.Thread.hasServerSideSupport) {
						const i = await this.getThreadListFilter(e);
						t = this.getOrCreateFilteredTimelineSet(i, {
							prepopulateTimeline: !1,
							useSyncEvents: !1,
							pendingEvents: !1
						})
					} else t = new s.EventTimelineSet(this, {
						pendingEvents: !1
					}), Array.from(this.threads).forEach(([, i]) => {
						if (0 === i.length) return;
						const n = i.events.some(e => e.getSender() === this.client.getUserId());
						(e !== _.ThreadFilterType.My || n) && t.getLiveTimeline().addEvent(i.rootEvent, {
							toStartOfTimeline: !1
						})
					});
					return t
				}
				processThreadRoots(e, t) {
					for (const i of e) o.EventTimeline.setEventMetadata(i, this.currentState, t), this.getThread(i.getId()) || this.createThread(i.getId(), i, [], t)
				}
				async fetchRoomThreads() {
					if (!this.threadsReady && this.client.supportsExperimentalThreads()) {
						if (_.Thread.hasServerSideListSupport) await Promise.all([this.fetchRoomThreadList(_.ThreadFilterType.All), this.fetchRoomThreadList(_.ThreadFilterType.My)]);
						else {
							const i = await this.getThreadListFilter(),
								{
									chunk: n
								} = await this.client.createMessagesRequest(this.roomId, "", Number.MAX_SAFE_INTEGER, o.Direction.Backward, i);
							if (!n.length) return;
							const r = n.map(this.client.getEventMapper()).sort((e, t) => {
								const i = e.getServerAggregatedRelation(_.THREAD_RELATION_TYPE.name),
									n = t.getServerAggregatedRelation(_.THREAD_RELATION_TYPE.name);
								return i.latest_event.origin_server_ts - n.latest_event.origin_server_ts
							});
							let a;
							const d = this.getLiveTimeline().getState(o.EventTimeline.FORWARDS);
							for (const o of r) {
								var e;
								null === (e = this.threadsTimelineSets[0]) || void 0 === e || e.addLiveEvent(o, {
									duplicateStrategy: s.DuplicateStrategy.Ignore,
									fromCache: !1,
									roomState: d
								});
								const i = o.getServerAggregatedRelation(_.THREAD_RELATION_TYPE.name);
								var t;
								if (null != i && i.current_user_participated) null === (t = this.threadsTimelineSets[1]) || void 0 === t || t.addLiveEvent(o, {
									duplicateStrategy: s.DuplicateStrategy.Ignore,
									fromCache: !1,
									roomState: d
								}), a = o
							}
							this.processThreadRoots(r, !0), this.client.decryptEventIfNeeded(r[r.length - 1]), a && this.client.decryptEventIfNeeded(a)
						}
						this.on(_.ThreadEvent.NewReply, this.onThreadNewReply), this.on(_.ThreadEvent.Delete, this.onThreadDelete), this.threadsReady = !0
					}
				}
				async fetchRoomThreadList(e) {
					const t = e === _.ThreadFilterType.My ? this.threadsTimelineSets[1] : this.threadsTimelineSets[0],
						{
							chunk: i,
							end: n
						} = await this.client.createThreadListMessagesRequest(this.roomId, null, void 0, o.Direction.Backward, t.threadListType, t.getFilter());
					if (t.getLiveTimeline().setPaginationToken(n, o.Direction.Backward), !i.length) return;
					const r = i.map(this.client.getEventMapper());
					this.processThreadRoots(r, !0);
					const a = this.getLiveTimeline().getState(o.EventTimeline.FORWARDS);
					for (const o of r) t.addLiveEvent(o, {
						duplicateStrategy: s.DuplicateStrategy.Replace,
						fromCache: !1,
						roomState: a
					})
				}
				onThreadNewReply(e) {
					this.updateThreadRootEvents(e, !1)
				}
				onThreadDelete(e) {
					var t;
					this.threads.delete(e.id);
					const i = this.getTimelineForEvent(e.id),
						n = null == i ? void 0 : null === (t = i.getEvents()) || void 0 === t ? void 0 : t.find(t => t.getId() === e.id);
					n ? e.clearEventMetadata(n) : m.logger.debug("onThreadDelete: Could not find root event in room timeline");
					for (const r of this.threadsTimelineSets) r.removeEvent(e.id)
				}
				removeFilteredTimelineSet(e) {
					const t = this.filteredTimelineSets[e.filterId];
					delete this.filteredTimelineSets[e.filterId];
					const i = this.timelineSets.indexOf(t);
					i > -1 && this.timelineSets.splice(i, 1)
				}
				eventShouldLiveIn(e, t, i) {
					var n, r;
					if (null === (n = this.client) || void 0 === n || !n.supportsExperimentalThreads()) return {
						shouldLiveInRoom: !0,
						shouldLiveInThread: !1
					};
					if (e.isThreadRoot || null != i && i.has(e.getId())) return {
						shouldLiveInRoom: !0,
						shouldLiveInThread: !0,
						threadId: e.getId()
					};
					if (e.isRelation(_.THREAD_RELATION_TYPE.name)) return {
						shouldLiveInRoom: !1,
						shouldLiveInThread: !0,
						threadId: e.threadRootId
					};
					const s = e.getAssociatedId(),
						o = null !== (r = this.findEventById(s)) && void 0 !== r ? r : null == t ? void 0 : t.find(e => e.getId() === s);
					return o && (e.isRelation() || e.isRedaction()) ? this.eventShouldLiveIn(o, t, i) : null != i && i.has(e.relationEventId) ? {
						shouldLiveInRoom: !0,
						shouldLiveInThread: !0,
						threadId: e.relationEventId
					} : {
						shouldLiveInRoom: !0,
						shouldLiveInThread: !1
					}
				}
				findThreadForEvent(e) {
					if (!e) return null;
					const {
						threadId: t
					} = this.eventShouldLiveIn(e);
					return t ? this.getThread(t) : null
				}
				addThreadedEvents(e, t, i = !1) {
					let n = this.getThread(e);
					if (!n) {
						var r;
						const s = null !== (r = this.findEventById(e)) && void 0 !== r ? r : t.find(t => t.getId() === e);
						n = this.createThread(e, s, t, i)
					}
					n.addEvents(t, i)
				}
				processThreadedEvents(e, t) {
					e.forEach(this.applyRedaction);
					const i = {};
					for (const r of e) {
						var n;
						const {
							threadId: e,
							shouldLiveInThread: t
						} = this.eventShouldLiveIn(r);
						t && !i[e] && (i[e] = []), null === (n = i[e]) || void 0 === n || n.push(r)
					}
					Object.entries(i).map(([e, i]) => this.addThreadedEvents(e, i, t))
				}
				createThread(e, t, i = [], n) {
					var r, s;
					if (t) {
						const e = this.relations.getAllChildEventsForEvent(t.getId());
						null != e && e.length && (i = i.concat(e.filter(e => !e.isRelation(g.RelationType.Replace))))
					}
					const o = new _.Thread(e, t, {
						room: this,
						client: this.client
					});
					for (const d of i) o.setEventMetadata(d);
					this.threads.set(o.id, o), this.reEmitter.reEmit(o, [_.ThreadEvent.Delete, _.ThreadEvent.Update, _.ThreadEvent.NewReply, M.Timeline, M.TimelineReset]);
					const a = (null === (r = this.lastThread) || void 0 === r ? void 0 : r.rootEvent) && (null == t ? void 0 : t.localTimestamp) && (null === (s = this.lastThread.rootEvent) || void 0 === s ? void 0 : s.localTimestamp) < (null == t ? void 0 : t.localTimestamp);
					return this.lastThread && !a || (this.lastThread = o), this.threadsReady && this.updateThreadRootEvents(o, n), this.emit(_.ThreadEvent.New, o, n), o
				}
				processLiveEvent(e) {
					if (this.applyRedaction(e), e.isVisibilityEvent() && this.applyNewVisibilityEvent(e), this.applyPendingVisibilityEvents(e), !e.getUnsigned().transaction_id && e.getSender() === this.myUserId)
						for (const t in this.txnToEvent) {
							if (this.txnToEvent[t].getId() === e.getId()) {
								m.logger.debug("processLiveEvent: found sent event without txn ID: ", t, e.getId());
								const i = e.getUnsigned();
								i.transaction_id = t, e.setUnsigned(i);
								break
							}
						}
				}
				addLiveEvent(e, t) {
					const {
						duplicateStrategy: i,
						timelineWasEmpty: n,
						fromCache: r
					} = t;
					for (const s of this.timelineSets) s.addLiveEvent(e, {
						duplicateStrategy: i,
						fromCache: r,
						timelineWasEmpty: n
					});
					e.sender && e.getType() !== g.EventType.RoomRedaction && this.addReceipt((0, w.synthesizeReceipt)(e.sender.userId, e, S.ReceiptType.Read), !0)
				}
				addPendingEvent(e, t) {
					if (e.status !== c.EventStatus.SENDING && e.status !== c.EventStatus.NOT_SENT) throw new Error("addPendingEvent called on an event with status " + e.status);
					if (this.txnToEvent[t]) throw new Error("addPendingEvent called on an event with known txnId " + t);
					if (o.EventTimeline.setEventMetadata(e, this.getLiveTimeline().getState(o.EventTimeline.FORWARDS), !1), this.txnToEvent[t] = e, this.pendingEventList) {
						if (this.pendingEventList.some(e => e.status === c.EventStatus.NOT_SENT) && (m.logger.warn("Setting event as NOT_SENT due to messages in the same state"), e.setStatus(c.EventStatus.NOT_SENT)), this.pendingEventList.push(e), this.savePendingEvents(), e.isRelation() && this.aggregateNonLiveRelation(e), e.isRedaction()) {
							const t = e.event.redacts;
							let i = this.pendingEventList.find(e => e.getId() === t);
							!i && t && (i = this.findEventById(t)), i && (i.markLocallyRedacted(e), this.emit(M.Redaction, e, this))
						}
					} else
						for (const i of this.timelineSets) i.getFilter() ? i.getFilter().filterRoomTimeline([e]).length && i.addEventToTimeline(e, i.getLiveTimeline(), {
							toStartOfTimeline: !1
						}) : i.addEventToTimeline(e, i.getLiveTimeline(), {
							toStartOfTimeline: !1
						});
					this.emit(M.LocalEchoUpdated, e, this)
				}
				savePendingEvents() {
					if (this.pendingEventList) {
						const e = this.pendingEventList.map(e => C(C({}, e.event), {}, {
							txn_id: e.getTxnId()
						})).filter(e => {
							const t = e.type === g.EventType.RoomMessageEncrypted,
								i = this.client.isRoomEncrypted(this.roomId);
							return t || !i
						});
						this.client.store.setPendingEvents(this.roomId, e)
					}
				}
				aggregateNonLiveRelation(e) {
					this.relations.aggregateChildEvent(e)
				}
				getEventForTxnId(e) {
					return this.txnToEvent[e]
				}
				handleRemoteEcho(e, t) {
					const i = t.getId(),
						n = e.getId(),
						r = t.status;
					m.logger.debug(`Got remote echo for event ${i} -> ${n} old status ${r}`), delete this.txnToEvent[e.getUnsigned().transaction_id], this.pendingEventList && this.removePendingEvent(i), t.handleRemoteEcho(e.event);
					const {
						shouldLiveInRoom: s,
						threadId: o
					} = this.eventShouldLiveIn(e), a = o ? this.getThread(o) : null;
					if (null == a || a.timelineSet.handleRemoteEcho(t, i, n), s)
						for (const d of this.timelineSets) d.handleRemoteEcho(t, i, n);
					this.emit(M.LocalEchoUpdated, t, this, i, r)
				}
				updatePendingEvent(e, t, i) {
					if (m.logger.log(`setting pendingEvent status to ${t} in ${e.getRoomId()} ` + `event ID ${e.getId()} -> ${i}`), t == c.EventStatus.SENT && !i) throw new Error("updatePendingEvent called with status=SENT, but no new event id");
					if (t == c.EventStatus.SENT) {
						if (this.getTimelineForEvent(i)) {
							const t = this.findEventById(i);
							if (!(null == t ? void 0 : t.getUnsigned().transaction_id) && t) {
								const i = t.getUnsigned();
								i.transaction_id = e.getTxnId(), t.setUnsigned(i), this.removeEvent(t.getId()), this.handleRemoteEcho(t, e)
							}
							return
						}
					}
					const n = e.status,
						r = e.getId();
					if (!n) throw new Error("updatePendingEventStatus called on an event which is not a local echo.");
					const s = D[n];
					if (null == s || !s.includes(t)) throw new Error(`Invalid EventStatus transition ${n}->${t}`);
					if (e.setStatus(t), t == c.EventStatus.SENT) {
						e.replaceLocalEventId(i);
						const {
							shouldLiveInRoom: t,
							threadId: n
						} = this.eventShouldLiveIn(e), s = n ? this.getThread(n) : void 0;
						if (null == s || s.timelineSet.replaceEventId(r, i), t)
							for (const e of this.timelineSets) e.replaceEventId(r, i)
					} else if (t == c.EventStatus.CANCELLED) {
						if (this.pendingEventList) {
							const e = this.getPendingEvent(r);
							this.removePendingEvent(r), null != e && e.isRedaction() && this.revertRedactionLocalEcho(e)
						}
						this.removeEvent(r)
					}
					this.savePendingEvents(), this.emit(M.LocalEchoUpdated, e, this, r, n)
				}
				revertRedactionLocalEcho(e) {
					const t = e.event.redacts;
					if (!t) return;
					const i = this.getUnfilteredTimelineSet().findEventById(t);
					i && (i.unmarkLocallyRedacted(), this.emit(M.RedactionCancelled, e, this), i.isRelation() && this.aggregateNonLiveRelation(i))
				}
				addLiveEvents(e, t, i = !1) {
					let n = t,
						r = !1;
					if ("object" == typeof t ? ({
							duplicateStrategy: n,
							fromCache: i = !1,
							timelineWasEmpty: r
						} = t) : void 0 !== t && m.logger.warn("Overload deprecated: `Room.addLiveEvents(events, duplicateStrategy?, fromCache?)` is deprecated in favor of the overload with `Room.addLiveEvents(events, IAddLiveEventOptions)`"), n && -1 === ["replace", "ignore"].indexOf(n)) throw new Error("duplicateStrategy MUST be either 'replace' or 'ignore'");
					for (let c = 0; c < this.timelineSets.length; c++) {
						const e = this.timelineSets[c].getLiveTimeline();
						if (e.getPaginationToken(o.EventTimeline.FORWARDS)) throw new Error("live timeline " + c + " is no longer live - it has a pagination token (" + e.getPaginationToken(o.EventTimeline.FORWARDS) + ")");
						if (e.getNeighbouringTimeline(o.EventTimeline.FORWARDS)) throw new Error(`live timeline ${c} is no longer live - it has a neighbouring timeline`)
					}
					const s = this.findThreadRoots(e),
						a = {},
						d = {
							duplicateStrategy: n,
							fromCache: i,
							timelineWasEmpty: r
						};
					for (const o of e) {
						var l;
						if (this.processLiveEvent(o), o.getUnsigned().transaction_id) {
							const e = this.txnToEvent[o.getUnsigned().transaction_id];
							if (e) {
								this.handleRemoteEcho(o, e);
								continue
							}
						}
						const {
							shouldLiveInRoom: t,
							shouldLiveInThread: i,
							threadId: n
						} = this.eventShouldLiveIn(o, e, s);
						i && !a[null != n ? n : ""] && (a[null != n ? n : ""] = []), null === (l = a[null != n ? n : ""]) || void 0 === l || l.push(o), t && this.addLiveEvent(o, d)
					}
					Object.entries(a).forEach(([e, t]) => {
						this.addThreadedEvents(e, t, !1)
					})
				}
				partitionThreadedEvents(e) {
					if (this.client.supportsExperimentalThreads()) {
						const t = this.findThreadRoots(e);
						return e.reduce((i, n) => {
							const {
								shouldLiveInRoom: r,
								shouldLiveInThread: s,
								threadId: o
							} = this.eventShouldLiveIn(n, e, t);
							return r && i[0].push(n), s && (n.setThreadId(null != o ? o : ""), i[1].push(n)), i
						}, [
							[],
							[]
						])
					}
					return [e, []]
				}
				findThreadRoots(e) {
					const t = new Set;
					for (const n of e) {
						var i;
						if (n.isRelation(_.THREAD_RELATION_TYPE.name)) t.add(null !== (i = n.relationEventId) && void 0 !== i ? i : "")
					}
					return t
				}
				addReceipt(e, t = !1) {
					const i = e.getContent();
					Object.keys(i).forEach(e => {
						Object.keys(i[e]).forEach(n => {
							Object.keys(i[e][n]).forEach(r => {
								var s;
								const o = i[e][n][r],
									a = !o.thread_id || o.thread_id === w.MAIN_ROOM_TIMELINE ? this : this.threads.get(null !== (s = o.thread_id) && void 0 !== s ? s : "");
								null == a || a.addReceiptToStructure(e, n, r, o, t)
							})
						})
					}), this.emit(M.Receipt, e, this)
				}
				addEphemeralEvents(e) {
					for (const t of e) t.getType() === g.EventType.Typing ? this.currentState.setTypingEvent(t) : t.getType() === g.EventType.Receipt && this.addReceipt(t)
				}
				removeEvents(e) {
					for (const t of e) this.removeEvent(t)
				}
				removeEvent(e) {
					let t = !1;
					for (const i of this.timelineSets) {
						const n = i.removeEvent(e);
						n && (n.isRedaction() && this.revertRedactionLocalEcho(n), t = !0)
					}
					return t
				}
				recalculate() {
					const e = this.currentState.getStateEvents(g.EventType.RoomMember, this.myUserId);
					if (e) {
						const t = e.getContent().membership;
						if (this.updateMyMembership(t), "invite" === t) {
							(e.getUnsigned().invite_room_state || []).forEach(e => {
								this.currentState.getStateEvents(e.type, e.state_key) || this.currentState.setStateEvents([new l.MatrixEvent({
									type: e.type,
									state_key: e.state_key,
									content: e.content,
									event_id: "$fake" + Date.now(),
									room_id: this.roomId,
									user_id: this.myUserId
								})])
							})
						}
					}
					const t = this.name;
					this.name = this.calculateRoomName(this.myUserId), this.normalizedName = (0, d.normalize)(this.name), this.summary = new h.RoomSummary(this.roomId, {
						title: this.name
					}), t !== this.name && this.emit(M.Name, this)
				}
				addTags(e) {
					this.tags = e.getContent().tags || {}, this.emit(M.Tags, e, this)
				}
				addAccountData(e) {
					for (const t of e) {
						"m.tag" === t.getType() && this.addTags(t);
						const e = this.accountData[t.getType()];
						this.accountData[t.getType()] = t, this.emit(M.AccountData, t, this, e)
					}
				}
				getAccountData(e) {
					return this.accountData[e]
				}
				maySendMessage() {
					return "join" === this.getMyMembership() && (this.client.isRoomEncrypted(this.roomId) ? this.currentState.maySendEvent(g.EventType.RoomMessageEncrypted, this.myUserId) : this.currentState.maySendEvent(g.EventType.RoomMessage, this.myUserId))
				}
				canInvite(e) {
					let t = "join" === this.getMyMembership();
					const i = this.currentState.getStateEvents(g.EventType.RoomPowerLevels, ""),
						n = i && i.getContent(),
						r = this.getMember(e);
					return n && r && n.invite > r.powerLevel && (t = !1), t
				}
				getJoinRule() {
					return this.currentState.getJoinRule()
				}
				getHistoryVisibility() {
					return this.currentState.getHistoryVisibility()
				}
				getGuestAccess() {
					return this.currentState.getGuestAccess()
				}
				getType() {
					const e = this.currentState.getStateEvents(g.EventType.RoomCreate, "");
					if (e) return e.getContent()[g.RoomCreateTypeField];
					this.getTypeWarning || (m.logger.warn("[getType] Room " + this.roomId + " does not have an m.room.create event"), this.getTypeWarning = !0)
				}
				isSpaceRoom() {
					return this.getType() === g.RoomType.Space
				}
				isCallRoom() {
					return this.getType() === g.RoomType.UnstableCall
				}
				isElementVideoRoom() {
					return this.getType() === g.RoomType.ElementVideo
				}
				roomNameGenerator(e) {
					if (this.client.roomNameGenerator) {
						const t = this.client.roomNameGenerator(this.roomId, e);
						if (null !== t) return t
					}
					switch (e.type) {
						case A.Actual:
							return e.name;
						case A.Generated:
							switch (e.subtype) {
								case "Inviting":
									return `Inviting ${L(e.names,e.count)}`;
								default:
									return L(e.names, e.count)
							}
							case A.EmptyRoom:
								return e.oldName ? `Empty room (was ${e.oldName})` : "Empty room"
					}
				}
				calculateRoomName(e, t = !1) {
					if (!t) {
						const e = this.currentState.getStateEvents(g.EventType.RoomName, "");
						if (null != e && e.getContent().name) return this.roomNameGenerator({
							type: A.Actual,
							name: e.getContent().name
						})
					}
					const i = this.getCanonicalAlias();
					if (i) return this.roomNameGenerator({
						type: A.Actual,
						name: i
					});
					let n = this.currentState.getJoinedMemberCount() + this.currentState.getInvitedMemberCount() - 1,
						r = [];
					const s = this.currentState.getStateEvents(g.UNSTABLE_ELEMENT_FUNCTIONAL_USERS.name, "");
					Array.isArray(null == s ? void 0 : s.getContent().service_members) && (r = s.getContent().service_members);
					let o = [];
					if (this.summaryHeroes) this.summaryHeroes.forEach(e => {
						if (r.includes(e)) return void n--;
						const t = this.getMember(e);
						o.push(t ? t.name : e)
					});
					else {
						let t = this.currentState.getMembers().filter(t => t.userId !== e && ("invite" === t.membership || "join" === t.membership));
						(t = t.filter(({
							userId: e
						}) => !r.includes(e) || (n--, !1))).sort((e, t) => d.compare(e.userId, t.userId)), t = t.slice(0, 5), o = t.map(e => e.name)
					}
					if (n) return this.roomNameGenerator({
						type: A.Generated,
						names: o,
						count: n
					});
					if ("join" == this.getMyMembership()) {
						const e = this.currentState.getStateEvents(g.EventType.RoomThirdPartyInvite);
						if (null != e && e.length) {
							const t = e.map(e => e.getContent().display_name);
							return this.roomNameGenerator({
								type: A.Generated,
								subtype: "Inviting",
								names: t,
								count: t.length + 1
							})
						}
					}
					let a, l = o;
					return l.length || (l = this.currentState.getMembers().filter(t => t.userId !== e && "invite" !== t.membership && "join" !== t.membership).map(e => e.name)), l.length && (a = this.roomNameGenerator({
						type: A.Generated,
						names: l,
						count: l.length + 1
					})), this.roomNameGenerator({
						type: A.EmptyRoom,
						oldName: a
					})
				}
				applyNewVisibilityEvent(e) {
					const t = e.asVisibilityChange();
					if (!t) return;
					const i = e.getSender();
					if (!i) return;
					if (!(g.EVENT_VISIBILITY_CHANGE_TYPE.name && this.currentState.maySendStateEvent(g.EVENT_VISIBILITY_CHANGE_TYPE.name, i) || g.EVENT_VISIBILITY_CHANGE_TYPE.altName && this.currentState.maySendStateEvent(g.EVENT_VISIBILITY_CHANGE_TYPE.altName, i))) return;
					const n = this.visibilityEvents.get(t.eventId);
					if (n) {
						let t = n.length - 1;
						const i = Math.max(0, n.length - O);
						for (; t >= i; --t) {
							if (n[t].getTs() < e.getTs()) break
						} - 1 === t ? n.unshift(e) : n.splice(t + 1, 0, e)
					} else this.visibilityEvents.set(t.eventId, [e]);
					const r = this.findEventById(t.eventId);
					r && r.applyVisibilityEvent(t)
				}
				redactVisibilityChangeEvent(e) {
					if (!e.isVisibilityEvent) throw new Error("expected a visibility change event");
					const t = e.getRelation(),
						i = null == t ? void 0 : t.event_id,
						n = this.visibilityEvents.get(i);
					if (!n) return;
					const r = n.findIndex(t => t.getId() === e.getId());
					if (-1 !== r && (n.splice(r, 1), r === n.length)) {
						const e = this.findEventById(i);
						if (!e) return;
						if (0 === r) this.visibilityEvents.delete(i), e.applyVisibilityEvent();
						else {
							const t = n[n.length - 1].asVisibilityChange();
							if (!t) throw new Error("at this stage, visibility changes should be well-formed");
							e.applyVisibilityEvent(t)
						}
					}
				}
				applyPendingVisibilityEvents(e) {
					const t = this.visibilityEvents.get(e.getId());
					if (!t || 0 == t.length) return;
					const i = t[t.length - 1],
						n = i.asVisibilityChange();
					n && (n.visible, i.getTs() < e.getTs() || e.applyVisibilityEvent(n))
				}
			}
			t.Room = P;
			const D = {
				[c.EventStatus.ENCRYPTING]: [c.EventStatus.SENDING, c.EventStatus.NOT_SENT, c.EventStatus.CANCELLED],
				[c.EventStatus.SENDING]: [c.EventStatus.ENCRYPTING, c.EventStatus.QUEUED, c.EventStatus.NOT_SENT, c.EventStatus.SENT],
				[c.EventStatus.QUEUED]: [c.EventStatus.SENDING, c.EventStatus.CANCELLED],
				[c.EventStatus.SENT]: [],
				[c.EventStatus.NOT_SENT]: [c.EventStatus.SENDING, c.EventStatus.QUEUED, c.EventStatus.CANCELLED],
				[c.EventStatus.CANCELLED]: []
			};
			let A;

			function L(e, t) {
				const i = t - 1;
				if (e.length) {
					if (1 === e.length && i <= 1) return e[0];
					if (2 === e.length && i <= 2) return `${e[0]} and ${e[1]}`;
					return i > 1 ? `${e[0]} and ${i} others` : `${e[0]} and 1 other`
				}
				return "Empty room"
			}
			t.RoomNameType = A,
				function(e) {
					e[e.EmptyRoom = 0] = "EmptyRoom", e[e.Generated = 1] = "Generated", e[e.Actual = 2] = "Actual"
				}(A || (t.RoomNameType = A = {}))
		},
		"./node_modules/matrix-js-sdk/lib/models/search-result.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.SearchResult = void 0;
			var n = i("./node_modules/matrix-js-sdk/lib/models/event-context.js");
			class r {
				static fromJson(e, t) {
					const i = e.context || {};
					let s = (i.events_before || []).map(t),
						o = (i.events_after || []).map(t);
					const a = new n.EventContext(t(e.result)),
						d = a.ourEvent.threadRootId;
					return s = s.filter(e => e.threadRootId === d), o = o.filter(e => e.threadRootId === d), a.setPaginateToken(i.start, !0), a.addEvents(s, !0), a.addEvents(o, !1), a.setPaginateToken(i.end, !1), new r(e.rank, a)
				}
				constructor(e, t) {
					this.rank = e, this.context = t
				}
			}
			t.SearchResult = r
		},
		"./node_modules/matrix-js-sdk/lib/models/thread.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.ThreadFilterType = t.ThreadEvent = t.Thread = t.THREAD_RELATION_TYPE = t.FeatureSupport = t.FILTER_RELATED_BY_SENDERS = t.FILTER_RELATED_BY_REL_TYPES = void 0, t.determineFeatureSupport = function(e, t) {
				return e ? f.Stable : t ? f.Experimental : f.None
			}, t.threadFilterTypeToFilter = function(e) {
				switch (e) {
					case S.My:
						return "participated";
					default:
						return "all"
				}
			};
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/ReEmitter.js"),
				o = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				a = i("./node_modules/matrix-js-sdk/lib/models/event.js"),
				d = i("./node_modules/matrix-js-sdk/lib/models/event-timeline.js"),
				l = i("./node_modules/matrix-js-sdk/lib/models/event-timeline-set.js"),
				c = i("./node_modules/matrix-js-sdk/lib/models/room.js"),
				u = i("./node_modules/matrix-js-sdk/lib/NamespacedValue.js"),
				h = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				m = i("./node_modules/matrix-js-sdk/lib/models/read-receipt.js"),
				p = i("./node_modules/matrix-js-sdk/lib/@types/read_receipts.js");
			let g, f;
			t.ThreadEvent = g,
				function(e) {
					e.New = "Thread.new", e.Update = "Thread.update", e.NewReply = "Thread.newReply", e.ViewThread = "Thread.viewThread", e.Delete = "Thread.delete"
				}(g || (t.ThreadEvent = g = {})), t.FeatureSupport = f,
				function(e) {
					e[e.None = 0] = "None", e[e.Experimental = 1] = "Experimental", e[e.Stable = 2] = "Stable"
				}(f || (t.FeatureSupport = f = {}));
			class v extends m.ReadReceipt {
				constructor(e, t, i) {
					if (super(), this.id = e, this.rootEvent = t, (0, r.default)(this, "timelineSet", void 0), (0, r.default)(this, "_currentUserParticipated", !1), (0, r.default)(this, "reEmitter", void 0), (0, r.default)(this, "lastEvent", void 0), (0, r.default)(this, "replyCount", 0), (0, r.default)(this, "room", void 0), (0, r.default)(this, "client", void 0), (0, r.default)(this, "initialEventsFetched", !v.hasServerSideSupport), (0, r.default)(this, "onBeforeRedaction", (e, t) => {
							null != e && e.isRelation(_.name) && this.room.eventShouldLiveIn(e).threadId === this.id && e.getId() !== this.id && !t.status && (this.replyCount--, this.emit(g.Update, this))
						}), (0, r.default)(this, "onRedaction", async e => {
							if (e.threadRootId === this.id)
								if (this.replyCount <= 0) {
									for (const e of this.events) this.clearEventMetadata(e);
									this.lastEvent = this.rootEvent, this._currentUserParticipated = !1, this.emit(g.Delete, this)
								} else await this.initialiseThread()
						}), (0, r.default)(this, "onEcho", async e => {
							e.threadRootId === this.id && this.lastEvent !== e && e.isRelation(_.name) && (await this.initialiseThread(), this.emit(g.NewReply, this, e))
						}), null == i || !i.room) throw new Error("element-web#22141: A thread requires a room in order to function");
					this.room = i.room, this.client = i.client, this.timelineSet = new l.EventTimelineSet(this.room, {
						timelineSupport: !0,
						pendingEvents: !0
					}, this.client, this), this.reEmitter = new s.TypedReEmitter(this), this.reEmitter.reEmit(this.timelineSet, [c.RoomEvent.Timeline, c.RoomEvent.TimelineReset]), this.room.on(a.MatrixEventEvent.BeforeRedaction, this.onBeforeRedaction), this.room.on(c.RoomEvent.Redaction, this.onRedaction), this.room.on(c.RoomEvent.LocalEchoUpdated, this.onEcho), this.timelineSet.on(c.RoomEvent.Timeline, this.onEcho), this.initialiseThread(), this.setEventMetadata(this.rootEvent)
				}
				async fetchRootEvent() {
					this.rootEvent = this.room.findEventById(this.id);
					try {
						const e = await this.client.fetchRoomEvent(this.roomId, this.id),
							t = this.client.getEventMapper();
						this.rootEvent = t(e)
					} catch (e) {
						h.logger.error("Failed to fetch thread root to construct thread with", e)
					}
					await this.processEvent(this.rootEvent)
				}
				static setServerSideSupport(e) {
					v.hasServerSideSupport = e, e !== f.Stable && (y.setPreferUnstable(!0), b.setPreferUnstable(!0), _.setPreferUnstable(!0))
				}
				static setServerSideListSupport(e) {
					v.hasServerSideListSupport = e
				}
				static setServerSideFwdPaginationSupport(e) {
					v.hasServerSideFwdPaginationSupport = e
				}
				get roomState() {
					return this.room.getLiveTimeline().getState(d.EventTimeline.FORWARDS)
				}
				addEventToTimeline(e, t) {
					this.findEventById(e.getId()) || this.timelineSet.addEventToTimeline(e, this.liveTimeline, {
						toStartOfTimeline: t,
						fromCache: !1,
						roomState: this.roomState
					})
				}
				addEvents(e, t) {
					e.forEach(e => this.addEvent(e, t, !1)), this.initialiseThread()
				}
				async addEvent(e, t, i = !0) {
					this.setEventMetadata(e);
					const n = this.lastReply(),
						r = !n || e.localTimestamp > n.localTimestamp;
					if (v.hasServerSideSupport) {
						if (!t && this.initialEventsFetched && r) await this.fetchEditsWhereNeeded(e), this.addEventToTimeline(e, !1);
						else if (e.isRelation(o.RelationType.Annotation) || e.isRelation(o.RelationType.Replace)) {
							var s, a;
							return null === (s = this.timelineSet.relations) || void 0 === s || s.aggregateParentEvent(e), void(null === (a = this.timelineSet.relations) || void 0 === a || a.aggregateChildEvent(e, this.timelineSet))
						}
					} else this.addEventToTimeline(e, t), this.client.decryptEventIfNeeded(e, {});
					v.hasServerSideSupport && this.rootEvent || !e.isRelation(_.name) || this.replyCount++, i && (this.emit(g.NewReply, this, e), this.initialiseThread())
				}
				async processEvent(e) {
					e && (this.setEventMetadata(e), await this.fetchEditsWhereNeeded(e))
				}
				getRootEventBundledRelationship(e = this.rootEvent) {
					return null == e ? void 0 : e.getServerAggregatedRelation(_.name)
				}
				async initialiseThread() {
					let e = this.getRootEventBundledRelationship();
					if (v.hasServerSideSupport && (await this.fetchRootEvent(), e = this.getRootEventBundledRelationship()), v.hasServerSideSupport && e) {
						this.replyCount = e.count, this._currentUserParticipated = !!e.current_user_participated;
						const t = this.client.getEventMapper();
						this.lastEvent = t(e.latest_event), await this.processEvent(this.lastEvent)
					}
					if (!this.initialEventsFetched) {
						this.initialEventsFetched = !0;
						try {
							await this.client.paginateEventTimeline(this.liveTimeline, {
								backwards: !0,
								limit: 1
							}), this.emit(c.RoomEvent.TimelineReset, this.room, this.timelineSet, !0)
						} catch (t) {
							h.logger.error("Failed to load start of newly created thread: ", t), this.initialEventsFetched = !1
						}
					}
					this.emit(g.Update, this)
				}
				async fetchEditsWhereNeeded(...e) {
					return Promise.all(e.filter(e => e.isEncrypted()).map(e => {
						if (!e.isRelation()) return this.client.relations(this.roomId, e.getId(), o.RelationType.Replace, e.getType(), {
							limit: 1
						}).then(t => {
							t.events.length && e.makeReplaced(t.events[0])
						}).catch(e => {
							h.logger.error("Failed to load edits for encrypted thread event", e)
						})
					}))
				}
				setEventMetadata(e) {
					e && (d.EventTimeline.setEventMetadata(e, this.roomState, !1), e.setThread(this))
				}
				clearEventMetadata(e) {
					var t, i, n;
					e && (e.setThread(void 0), null === (t = e.event) || void 0 === t || (null === (i = t.unsigned) || void 0 === i || (null === (n = i["m.relations"]) || void 0 === n || delete n[_.name])))
				}
				findEventById(e) {
					var t;
					return (null === (t = this.lastEvent) || void 0 === t ? void 0 : t.getId()) === e ? this.lastEvent : this.timelineSet.findEventById(e)
				}
				lastReply(e = (() => !0)) {
					for (let t = this.events.length - 1; t >= 0; t--) {
						const i = this.events[t];
						if (e(i)) return i
					}
					return null
				}
				get roomId() {
					return this.room.roomId
				}
				get length() {
					return this.replyCount
				}
				get replyToEvent() {
					var e;
					return null !== (e = this.lastEvent) && void 0 !== e ? e : this.lastReply()
				}
				get events() {
					return this.liveTimeline.getEvents()
				}
				has(e) {
					return this.timelineSet.findEventById(e) instanceof a.MatrixEvent
				}
				get hasCurrentUserParticipated() {
					return this._currentUserParticipated
				}
				get liveTimeline() {
					return this.timelineSet.getLiveTimeline()
				}
				getUnfilteredTimelineSet() {
					return this.timelineSet
				}
				get timeline() {
					return this.events
				}
				addReceipt(e, t) {
					throw new Error("Unsupported function on the thread model")
				}
				hasUserReadEvent(e, t) {
					if (e === this.client.getUserId()) {
						const t = this.getReadReceiptForUserId(e, !1, p.ReceiptType.Read),
							i = this.getReadReceiptForUserId(e, !1, p.ReceiptType.ReadPrivate),
							n = this.room.getThreadUnreadNotificationCount(this.id, c.NotificationCountType.Total) > 0;
						if (!t && !i && !n) return !0
					}
					return super.hasUserReadEvent(e, t)
				}
			}
			t.Thread = v, (0, r.default)(v, "hasServerSideSupport", f.None), (0, r.default)(v, "hasServerSideListSupport", f.None), (0, r.default)(v, "hasServerSideFwdPaginationSupport", f.None);
			const y = new u.ServerControlledNamespacedValue("related_by_senders", "io.element.relation_senders");
			t.FILTER_RELATED_BY_SENDERS = y;
			const b = new u.ServerControlledNamespacedValue("related_by_rel_types", "io.element.relation_types");
			t.FILTER_RELATED_BY_REL_TYPES = b;
			const _ = new u.ServerControlledNamespacedValue("m.thread", "io.element.thread");
			let S;
			t.THREAD_RELATION_TYPE = _, t.ThreadFilterType = S,
				function(e) {
					e[e.My = 0] = "My", e[e.All = 1] = "All"
				}(S || (t.ThreadFilterType = S = {}))
		},
		"./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.TypedEventEmitter = t.EventEmitterEvents = void 0;
			var n = i("./node_modules/node-libs-browser/node_modules/events/events.js");
			let r;
			t.EventEmitterEvents = r,
				function(e) {
					e.NewListener = "newListener", e.RemoveListener = "removeListener", e.Error = "error"
				}(r || (t.EventEmitterEvents = r = {}));
			class s extends n.EventEmitter {
				addListener(e, t) {
					return super.addListener(e, t)
				}
				emit(e, ...t) {
					return super.emit(e, ...t)
				}
				eventNames() {
					return super.eventNames()
				}
				listenerCount(e) {
					return super.listenerCount(e)
				}
				listeners(e) {
					return super.listeners(e)
				}
				off(e, t) {
					return super.off(e, t)
				}
				on(e, t) {
					return super.on(e, t)
				}
				once(e, t) {
					return super.once(e, t)
				}
				prependListener(e, t) {
					return super.prependListener(e, t)
				}
				prependOnceListener(e, t) {
					return super.prependOnceListener(e, t)
				}
				removeAllListeners(e) {
					return super.removeAllListeners(e)
				}
				removeListener(e, t) {
					return super.removeListener(e, t)
				}
				rawListeners(e) {
					return super.rawListeners(e)
				}
			}
			t.TypedEventEmitter = s
		},
		"./node_modules/matrix-js-sdk/lib/models/user.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.UserEvent = t.User = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js");
			let o;
			t.UserEvent = o,
				function(e) {
					e.DisplayName = "User.displayName", e.AvatarUrl = "User.avatarUrl", e.Presence = "User.presence", e.CurrentlyActive = "User.currentlyActive", e.LastPresenceTs = "User.lastPresenceTs"
				}(o || (t.UserEvent = o = {}));
			class a extends s.TypedEventEmitter {
				constructor(e) {
					super(), this.userId = e, (0, r.default)(this, "modified", -1), (0, r.default)(this, "displayName", void 0), (0, r.default)(this, "rawDisplayName", void 0), (0, r.default)(this, "avatarUrl", void 0), (0, r.default)(this, "presenceStatusMsg", void 0), (0, r.default)(this, "presence", "offline"), (0, r.default)(this, "lastActiveAgo", 0), (0, r.default)(this, "lastPresenceTs", 0), (0, r.default)(this, "currentlyActive", !1), (0, r.default)(this, "events", {}), this.displayName = e, this.rawDisplayName = e, this.updateModifiedTime()
				}
				setPresenceEvent(e) {
					if ("m.presence" !== e.getType()) return;
					const t = null === this.events.presence;
					this.events.presence = e;
					const i = [];
					(e.getContent().presence !== this.presence || t) && i.push(o.Presence), e.getContent().avatar_url && e.getContent().avatar_url !== this.avatarUrl && i.push(o.AvatarUrl), e.getContent().displayname && e.getContent().displayname !== this.displayName && i.push(o.DisplayName), void 0 !== e.getContent().currently_active && e.getContent().currently_active !== this.currentlyActive && i.push(o.CurrentlyActive), this.presence = e.getContent().presence, i.push(o.LastPresenceTs), e.getContent().status_msg && (this.presenceStatusMsg = e.getContent().status_msg), e.getContent().displayname && (this.displayName = e.getContent().displayname), e.getContent().avatar_url && (this.avatarUrl = e.getContent().avatar_url), this.lastActiveAgo = e.getContent().last_active_ago, this.lastPresenceTs = Date.now(), this.currentlyActive = e.getContent().currently_active, this.updateModifiedTime();
					for (const n of i) this.emit(n, e, this)
				}
				setDisplayName(e) {
					const t = this.displayName;
					this.displayName = e, e !== t && this.updateModifiedTime()
				}
				setRawDisplayName(e) {
					this.rawDisplayName = e
				}
				setAvatarUrl(e) {
					const t = this.avatarUrl;
					this.avatarUrl = e, e !== t && this.updateModifiedTime()
				}
				updateModifiedTime() {
					this.modified = Date.now()
				}
				getLastModifiedTime() {
					return this.modified
				}
				getLastActiveTs() {
					return this.lastPresenceTs - this.lastActiveAgo
				}
			}
			t.User = a
		},
		"./node_modules/matrix-js-sdk/lib/pushprocessor.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.PushProcessor = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/utils.js"),
				o = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				a = i("./node_modules/matrix-js-sdk/lib/@types/PushRules.js"),
				d = i("./node_modules/matrix-js-sdk/lib/@types/event.js");

			function l(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function c(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? l(Object(i), !0).forEach((function(t) {
						(0, r.default)(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : l(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}
			const u = [a.PushRuleKind.Override, a.PushRuleKind.ContentSpecific, a.PushRuleKind.RoomSpecific, a.PushRuleKind.SenderSpecific, a.PushRuleKind.Underride],
				h = [{
					rule_id: ".m.rule.reaction",
					default: !0,
					enabled: !0,
					conditions: [{
						kind: a.ConditionKind.EventMatch,
						key: "type",
						pattern: "m.reaction"
					}],
					actions: [a.PushRuleActionName.DontNotify]
				}, {
					rule_id: ".org.matrix.msc3786.rule.room.server_acl",
					default: !0,
					enabled: !0,
					conditions: [{
						kind: a.ConditionKind.EventMatch,
						key: "type",
						pattern: d.EventType.RoomServerAcl
					}, {
						kind: a.ConditionKind.EventMatch,
						key: "state_key",
						pattern: ""
					}],
					actions: []
				}],
				m = [{
					rule_id: ".org.matrix.msc3914.rule.room.call",
					default: !0,
					enabled: !0,
					conditions: [{
						kind: a.ConditionKind.EventMatch,
						key: "type",
						pattern: "org.matrix.msc3401.call"
					}, {
						kind: a.ConditionKind.CallStarted
					}],
					actions: [a.PushRuleActionName.Notify, {
						set_tweak: a.TweakName.Sound,
						value: "default"
					}]
				}];
			class p {
				constructor(e) {
					this.client = e
				}
				static actionListToActionsObject(e) {
					const t = {
						notify: !1,
						tweaks: {}
					};
					for (const i of e) i === a.PushRuleActionName.Notify ? t.notify = !0 : "object" == typeof i && (void 0 === i.value && (i.value = !0), t.tweaks[i.set_tweak] = i.value);
					return t
				}
				static rewriteDefaultRules(e) {
					var t;
					let i = JSON.parse(JSON.stringify(e));
					i || (i = {}), i.global || (i.global = {}), i.global.override || (i.global.override = []), i.global.override || (i.global.underride = []);
					const n = i.global.override;
					for (const s of h) {
						const e = n.find(e => e.rule_id === s.rule_id);
						if (e) e.default = s.default, e.conditions = s.conditions, e.actions = s.actions;
						else {
							const e = s.rule_id;
							o.logger.warn(`Adding default global override for ${e}`), n.push(s)
						}
					}
					const r = null !== (t = i.global.underride) && void 0 !== t ? t : [];
					for (const s of m) {
						const e = r.find(e => e.rule_id === s.rule_id);
						if (e) e.default = s.default, e.conditions = s.conditions, e.actions = s.actions;
						else {
							const e = s.rule_id;
							o.logger.warn(`Adding default global underride for ${e}`), r.push(s)
						}
					}
					return i
				}
				matchingRuleFromKindSet(e, t) {
					for (const i of u) {
						const n = t[i];
						if (n)
							for (const t of n) {
								if (!t.enabled) continue;
								const n = this.templateRuleToRaw(i, t);
								if (n && this.ruleMatchesEvent(n, e)) return c(c({}, t), {}, {
									kind: i
								})
							}
					}
					return null
				}
				templateRuleToRaw(e, t) {
					const i = {
						rule_id: t.rule_id,
						actions: t.actions,
						conditions: []
					};
					switch (e) {
						case a.PushRuleKind.Underride:
						case a.PushRuleKind.Override:
							i.conditions = t.conditions;
							break;
						case a.PushRuleKind.RoomSpecific:
							if (!t.rule_id) return null;
							i.conditions.push({
								kind: a.ConditionKind.EventMatch,
								key: "room_id",
								value: t.rule_id
							});
							break;
						case a.PushRuleKind.SenderSpecific:
							if (!t.rule_id) return null;
							i.conditions.push({
								kind: a.ConditionKind.EventMatch,
								key: "user_id",
								value: t.rule_id
							});
							break;
						case a.PushRuleKind.ContentSpecific:
							if (!t.pattern) return null;
							i.conditions.push({
								kind: a.ConditionKind.EventMatch,
								key: "content.body",
								pattern: t.pattern
							})
					}
					return i
				}
				eventFulfillsCondition(e, t) {
					switch (e.kind) {
						case a.ConditionKind.EventMatch:
							return this.eventFulfillsEventMatchCondition(e, t);
						case a.ConditionKind.ContainsDisplayName:
							return this.eventFulfillsDisplayNameCondition(e, t);
						case a.ConditionKind.RoomMemberCount:
							return this.eventFulfillsRoomMemberCountCondition(e, t);
						case a.ConditionKind.SenderNotificationPermission:
							return this.eventFulfillsSenderNotifPermCondition(e, t);
						case a.ConditionKind.CallStarted:
						case a.ConditionKind.CallStartedPrefix:
							return this.eventFulfillsCallStartedCondition(e, t)
					}
					return !1
				}
				eventFulfillsSenderNotifPermCondition(e, t) {
					const i = e.key;
					if (!i) return !1;
					const n = this.client.getRoom(t.getRoomId());
					return !(null == n || !n.currentState) && n.currentState.mayTriggerNotifOfType(i, t.getSender())
				}
				eventFulfillsRoomMemberCountCondition(e, t) {
					if (!e.is) return !1;
					const i = this.client.getRoom(t.getRoomId());
					if (!i || !i.currentState || !i.currentState.members) return !1;
					const n = i.currentState.getJoinedMemberCount(),
						r = e.is.match(/^([=<>]*)(\d*)$/);
					if (!r) return !1;
					const s = r[1],
						o = parseInt(r[2]);
					if (isNaN(o)) return !1;
					switch (s) {
						case "":
						case "==":
							return n == o;
						case "<":
							return n < o;
						case ">":
							return n > o;
						case "<=":
							return n <= o;
						case ">=":
							return n >= o;
						default:
							return !1
					}
				}
				eventFulfillsDisplayNameCondition(e, t) {
					var i;
					let n = t.getContent();
					if (t.isEncrypted() && t.getClearContent() && (n = t.getClearContent()), !n || !n.body || "string" != typeof n.body) return !1;
					const r = this.client.getRoom(t.getRoomId()),
						o = null == r ? void 0 : null === (i = r.currentState) || void 0 === i ? void 0 : i.getMember(this.client.credentials.userId);
					if (!o) return !1;
					const a = o.name,
						d = new RegExp("(^|\\W)" + (0, s.escapeRegExp)(a) + "(\\W|$)", "i");
					return n.body.search(d) > -1
				}
				eventFulfillsEventMatchCondition(e, t) {
					if (!e.key) return !1;
					const i = this.valueForDottedKey(e.key, t);
					if ("string" != typeof i) return !1;
					if (e.value) return e.value === i;
					if ("string" != typeof e.pattern) return !1;
					const n = "content.body" === e.key ? this.createCachedRegex("(^|\\W)", e.pattern, "(\\W|$)") : this.createCachedRegex("^", e.pattern, "$");
					return !!i.match(n)
				}
				eventFulfillsCallStartedCondition(e, t) {
					return ["m.ring", "m.prompt"].includes(t.getContent()["m.intent"]) && !("m.terminated" in t.getContent()) && (t.getPrevContent()["m.terminated"] !== t.getContent()["m.terminated"] || (0, s.deepCompare)(t.getPrevContent(), {}))
				}
				createCachedRegex(e, t, i) {
					return p.cachedGlobToRegex[t] ? p.cachedGlobToRegex[t] : (p.cachedGlobToRegex[t] = new RegExp(e + (0, s.globToRegexp)(t) + i, "i"), p.cachedGlobToRegex[t])
				}
				valueForDottedKey(e, t) {
					const i = e.split(".");
					let n;
					const r = i[0];
					for ("content" === r ? (n = t.getContent(), i.shift()) : "type" === r ? (n = t.getType(), i.shift()) : n = t.event; i.length > 0;) {
						const e = i.shift();
						if ((0, s.isNullOrUndefined)(n[e])) return null;
						n = n[e]
					}
					return n
				}
				matchingRuleForEventWithRulesets(e, t) {
					return t ? e.getSender() === this.client.credentials.userId ? null : this.matchingRuleFromKindSet(e, t.global) : null
				}
				pushActionsForEventAndRulesets(e, t) {
					const i = this.matchingRuleForEventWithRulesets(e, t);
					if (!i) return {};
					const n = p.actionListToActionsObject(i.actions);
					return void 0 === n.tweaks.highlight && (n.tweaks.highlight = i.kind == a.PushRuleKind.ContentSpecific), n
				}
				ruleMatchesEvent(e, t) {
					var i;
					return !(null !== (i = e.conditions) && void 0 !== i && i.some(e => !this.eventFulfillsCondition(e, t)))
				}
				actionsForEvent(e) {
					return this.pushActionsForEventAndRulesets(e, this.client.pushRules)
				}
				getPushRuleById(e) {
					for (const i of ["global"]) {
						var t;
						if (void 0 !== (null === (t = this.client.pushRules) || void 0 === t ? void 0 : t[i]))
							for (const t of u)
								if (void 0 !== this.client.pushRules[i][t])
									for (const n of this.client.pushRules[i][t])
										if (n.rule_id === e) return n
					}
					return null
				}
			}
			t.PushProcessor = p, (0, r.default)(p, "cachedGlobToRegex", {})
		},
		"./node_modules/matrix-js-sdk/lib/randomstring.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.randomLowercaseString = function(e) {
				return o(e, n)
			}, t.randomString = function(e) {
				return o(e, r + n + s)
			}, t.randomUppercaseString = function(e) {
				return o(e, r)
			};
			const n = "abcdefghijklmnopqrstuvwxyz",
				r = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
				s = "0123456789";

			function o(e, t) {
				let i = "";
				for (let n = 0; n < e; ++n) i += t.charAt(Math.floor(Math.random() * t.length));
				return i
			}
		},
		"./node_modules/matrix-js-sdk/lib/realtime-callbacks.js": function(e, t, i) {
			"use strict";
			(function(e) {
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.clearTimeout = function(e) {
					if (0 === a.length) return;
					let t;
					for (t = 0; t < a.length; t++) {
						if (a[t].key == e) {
							a.splice(t, 1);
							break
						}
					}
					0 === t && l()
				}, t.setTimeout = function(e, t, ...i) {
					(t = t || 0) < 0 && (t = 0);
					const n = Date.now() + t,
						r = o++;
					d("setTimeout: scheduling cb", r, "at", n, "(delay", t, ")");
					const s = {
							runAt: n,
							func: e,
							params: i,
							key: r
						},
						c = function(e, t) {
							let i = 0,
								n = e.length;
							for (; i < n;) {
								const r = i + n >> 1;
								t(e[r]) > 0 ? n = r : i = r + 1
							}
							return i
						}(a, (function(e) {
							return e.runAt - n
						}));
					return a.splice(c, 0, s), l(), r
				};
				var n = i("./node_modules/matrix-js-sdk/lib/logger.js");
				const r = 1e3;
				let s, o = 0;
				const a = [],
					d = function(...e) {};

				function l() {
					s && e.clearTimeout(s);
					const t = a[0];
					if (!t) return void d("scheduleRealCallback: no more callbacks, not rescheduling");
					const i = Date.now(),
						n = Math.min(t.runAt - i, r);
					d("scheduleRealCallback: now:", i, "delay:", n), s = e.setTimeout(c, n)
				}

				function c() {
					const t = Date.now();
					d("runCallbacks: now:", t);
					const i = [];
					for (;;) {
						const e = a[0];
						if (!e || e.runAt > t) break;
						const n = a.shift();
						d("runCallbacks: popping", n.key), i.push(n)
					}
					l();
					for (const s of i) try {
						s.func.apply(e, s.params)
					} catch (r) {
						n.logger.error("Uncaught exception in callback function", r)
					}
				}
			}).call(this, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/scheduler.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.MatrixScheduler = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = l(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/utils.js")),
				o = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				a = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				d = i("./node_modules/matrix-js-sdk/lib/http-api/index.js");

			function l(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (l = function(e) {
					return e ? i : t
				})(e)
			}
			const c = !1;
			class u {
				static RETRY_BACKOFF_RATELIMIT(e, t, i) {
					if (400 === i.httpStatus || 403 === i.httpStatus || 401 === i.httpStatus) return -1;
					if (i instanceof d.ConnectionError) return -1;
					if ("M_TOO_LARGE" === i.name) return -1;
					if ("M_LIMIT_EXCEEDED" === i.name) {
						const e = i.data.retry_after_ms;
						if (e > 0) return e
					}
					return t > 4 ? -1 : 1e3 * Math.pow(2, t)
				}
				static QUEUE_MESSAGES(e) {
					return e.getType() === a.EventType.RoomMessage || e.hasAssocation() ? "message" : null
				}
				constructor(e = u.RETRY_BACKOFF_RATELIMIT, t = u.QUEUE_MESSAGES) {
					this.retryAlgorithm = e, this.queueAlgorithm = t, (0, r.default)(this, "queues", {}), (0, r.default)(this, "activeQueues", []), (0, r.default)(this, "procFn", null), (0, r.default)(this, "processQueue", e => {
						const t = this.peekNextEvent(e);
						if (!t) {
							const t = this.activeQueues.indexOf(e);
							return t >= 0 && this.activeQueues.splice(t, 1), void h("Stopping queue '%s' as it is now empty", e)
						}
						h("Queue '%s' has %s pending events", e, this.queues[e].length), Promise.resolve().then(() => this.procFn(t.event)).then(i => {
							this.removeNextEvent(e), h("Queue '%s' sent event %s", e, t.event.getId()), t.defer.resolve(i), this.processQueue(e)
						}, i => {
							t.attempts += 1;
							const n = this.retryAlgorithm(t.event, t.attempts, i);
							h("retry(%s) err=%s event_id=%s waitTime=%s", t.attempts, i, t.event.getId(), n), -1 === n ? (h("Queue '%s' giving up on event %s", e, t.event.getId()), this.removeNextEvent(e), t.defer.reject(i), this.processQueue(e)) : setTimeout(this.processQueue, n, e)
						})
					})
				}
				getQueueForEvent(e) {
					const t = this.queueAlgorithm(e);
					return t && this.queues[t] ? this.queues[t].map((function(e) {
						return e.event
					})) : null
				}
				removeEventFromQueue(e) {
					const t = this.queueAlgorithm(e);
					if (!t || !this.queues[t]) return !1;
					let i = !1;
					return s.removeElement(this.queues[t], t => t.event.getId() === e.getId() && (i = !0, !0)), i
				}
				setProcessFunction(e) {
					this.procFn = e, this.startProcessingQueues()
				}
				queueEvent(e) {
					const t = this.queueAlgorithm(e);
					if (!t) return null;
					this.queues[t] || (this.queues[t] = []);
					const i = s.defer();
					return this.queues[t].push({
						event: e,
						defer: i,
						attempts: 0
					}), h("Queue algorithm dumped event %s into queue '%s'", e.getId(), t), this.startProcessingQueues(), i.promise
				}
				startProcessingQueues() {
					this.procFn && Object.keys(this.queues).filter(e => -1 === this.activeQueues.indexOf(e) && this.queues[e].length > 0).forEach(e => {
						this.activeQueues.push(e), h("Spinning up queue: '%s'", e), this.processQueue(e)
					})
				}
				peekNextEvent(e) {
					const t = this.queues[e];
					if (Array.isArray(t)) return t[0]
				}
				removeNextEvent(e) {
					const t = this.queues[e];
					if (Array.isArray(t)) return t.shift()
				}
			}

			function h(...e) {
				c && o.logger.log(...e)
			}
			t.MatrixScheduler = u
		},
		"./node_modules/matrix-js-sdk/lib/service-types.js": function(e, t, i) {
			"use strict";
			let n;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.SERVICE_TYPES = void 0, t.SERVICE_TYPES = n,
				function(e) {
					e.IS = "SERVICE_TYPE_IS", e.IM = "SERVICE_TYPE_IM"
				}(n || (t.SERVICE_TYPES = n = {}))
		},
		"./node_modules/matrix-js-sdk/lib/sliding-sync-sdk.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.SlidingSyncSdk = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/models/room.js"),
				o = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				a = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = v(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/utils.js")),
				d = i("./node_modules/matrix-js-sdk/lib/models/event-timeline.js"),
				l = i("./node_modules/matrix-js-sdk/lib/client.js"),
				c = i("./node_modules/matrix-js-sdk/lib/sync.js"),
				u = i("./node_modules/matrix-js-sdk/lib/http-api/index.js"),
				h = i("./node_modules/matrix-js-sdk/lib/sliding-sync.js"),
				m = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				p = i("./node_modules/matrix-js-sdk/lib/pushprocessor.js"),
				g = i("./node_modules/matrix-js-sdk/lib/models/room-state.js"),
				f = i("./node_modules/matrix-js-sdk/lib/models/room-member.js");

			function v(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (v = function(e) {
					return e ? i : t
				})(e)
			}
			const y = 3;
			class b {
				constructor(e) {
					this.crypto = e
				}
				name() {
					return "e2ee"
				}
				when() {
					return h.ExtensionState.PreProcess
				}
				onRequest(e) {
					if (e) return {
						enabled: !0
					}
				}
				async onResponse(e) {
					if (e.device_lists && await this.crypto.handleDeviceListChanges({
							oldSyncToken: "yep"
						}, e.device_lists), e.device_one_time_keys_count) {
						const t = e.device_one_time_keys_count.signed_curve25519 || 0;
						this.crypto.updateOneTimeKeyCount(t)
					}
					if (e.device_unused_fallback_key_types || e["org.matrix.msc2732.device_unused_fallback_key_types"]) {
						const t = e.device_unused_fallback_key_types || e["org.matrix.msc2732.device_unused_fallback_key_types"];
						this.crypto.setNeedsNewFallback(Array.isArray(t) && !t.includes("signed_curve25519"))
					}
				}
			}
			class _ {
				constructor(e) {
					this.client = e, (0, r.default)(this, "nextBatch", null)
				}
				name() {
					return "to_device"
				}
				when() {
					return h.ExtensionState.PreProcess
				}
				onRequest(e) {
					const t = {
						since: null !== this.nextBatch ? this.nextBatch : void 0
					};
					return e && (t.limit = 100, t.enabled = !0), t
				}
				async onResponse(e) {
					const t = [];
					e.events = e.events || [], e.events.map(this.client.getEventMapper()).map(e => {
						if ("m.key.verification.cancel" === e.getType()) {
							const i = e.getContent().transaction_id;
							i && t.push(i)
						}
						return e
					}).forEach(e => {
						const i = e.getContent();
						if ("m.room.message" != e.getType() || "m.bad.encrypted" != i.msgtype) {
							if ("m.key.verification.start" === e.getType() || "m.key.verification.request" === e.getType()) {
								const n = i.transaction_id;
								t.includes(n) && e.flagCancelled()
							}
							this.client.emit(l.ClientEvent.ToDeviceEvent, e)
						} else o.logger.log("Ignoring undecryptable to-device event from " + e.getSender())
					}), this.nextBatch = e.next_batch
				}
			}
			class S {
				constructor(e) {
					this.client = e
				}
				name() {
					return "account_data"
				}
				when() {
					return h.ExtensionState.PostProcess
				}
				onRequest(e) {
					if (e) return {
						enabled: !0
					}
				}
				onResponse(e) {
					e.global && e.global.length > 0 && this.processGlobalAccountData(e.global);
					for (const t in e.rooms) {
						const i = E(this.client, t, e.rooms[t]),
							n = this.client.getRoom(t);
						n ? (n.addAccountData(i), i.forEach(e => {
							this.client.emit(l.ClientEvent.Event, e)
						})) : o.logger.warn("got account data for room but room doesn't exist on client:", t)
					}
				}
				processGlobalAccountData(e) {
					const t = E(this.client, void 0, e),
						i = t.reduce((e, t) => (e[t.getType()] = this.client.store.getAccountData(t.getType()), e), {});
					this.client.store.storeAccountDataEvents(t), t.forEach(e => {
						if (e.getType() === m.EventType.PushRules) {
							const t = e.getContent();
							this.client.pushRules = p.PushProcessor.rewriteDefaultRules(t)
						}
						const t = i[e.getType()];
						return this.client.emit(l.ClientEvent.AccountData, e, t), e
					})
				}
			}

			function E(e, t, i, n = !0) {
				const r = e.getEventMapper({
					decrypt: n
				});
				return i.map((function(e) {
					return e.room_id = t, r(e)
				}))
			}
			t.SlidingSyncSdk = class {
				constructor(e, t, i = {}) {
					var n;
					this.slidingSync = e, this.client = t, this.opts = i, (0, r.default)(this, "syncState", null), (0, r.default)(this, "syncStateData", void 0), (0, r.default)(this, "lastPos", null), (0, r.default)(this, "failCount", 0), (0, r.default)(this, "notifEvents", []), this.opts.initialSyncLimit = null !== (n = this.opts.initialSyncLimit) && void 0 !== n ? n : 8, this.opts.resolveInvitesToProfiles = this.opts.resolveInvitesToProfiles || !1, this.opts.pollTimeout = this.opts.pollTimeout || 3e4, this.opts.pendingEventOrdering = this.opts.pendingEventOrdering || l.PendingEventOrdering.Chronological, this.opts.experimentalThreadSupport = !0 === this.opts.experimentalThreadSupport, i.canResetEntireTimeline || (i.canResetEntireTimeline = e => !1), t.getNotifTimelineSet() && t.reEmitter.reEmit(t.getNotifTimelineSet(), [s.RoomEvent.Timeline, s.RoomEvent.TimelineReset]), this.slidingSync.on(h.SlidingSyncEvent.Lifecycle, this.onLifecycle.bind(this)), this.slidingSync.on(h.SlidingSyncEvent.RoomData, this.onRoomData.bind(this));
					const o = [new _(this.client), new S(this.client)];
					this.opts.crypto && o.push(new b(this.opts.crypto)), o.forEach(e => {
						this.slidingSync.registerExtension(e)
					})
				}
				onRoomData(e, t) {
					let i = this.client.store.getRoom(e);
					if (!i) {
						if (!t.initial) return void o.logger.debug("initial flag not set but no stored room exists for room ", e, t);
						i = (0, c._createAndReEmitRoom)(this.client, e, this.opts)
					}
					this.processRoomData(this.client, i, t)
				}
				onLifecycle(e, t, i) {
					switch (i && o.logger.debug("onLifecycle", e, i), e) {
						case h.SlidingSyncState.Complete:
							if (this.purgeNotifications(), !t) break;
							this.lastPos || this.updateSyncState(c.SyncState.Prepared, {
								oldSyncToken: void 0,
								nextSyncToken: t.pos,
								catchingUp: !1,
								fromCache: !1
							}), this.updateSyncState(c.SyncState.Syncing, {
								oldSyncToken: this.lastPos,
								nextSyncToken: t.pos,
								catchingUp: !1,
								fromCache: !1
							}), this.lastPos = t.pos;
							break;
						case h.SlidingSyncState.RequestFinished:
							if (i) {
								if (this.failCount += 1, this.updateSyncState(this.failCount > y ? c.SyncState.Error : c.SyncState.Reconnecting, {
										error: new u.MatrixError(i)
									}), this.shouldAbortSync(new u.MatrixError(i))) return
							} else this.failCount = 0
					}
				}
				async syncLeftRooms() {
					return []
				}
				async peek(e) {
					return null
				}
				stopPeeking() {}
				getSyncState() {
					return this.syncState
				}
				getSyncStateData() {
					var e;
					return null !== (e = this.syncStateData) && void 0 !== e ? e : null
				}
				createRoom(e) {
					const {
						timelineSupport: t
					} = this.client, i = new s.Room(e, this.client, this.client.getUserId(), {
						lazyLoadMembers: this.opts.lazyLoadMembers,
						pendingEventOrdering: this.opts.pendingEventOrdering,
						timelineSupport: t
					});
					return this.client.reEmitter.reEmit(i, [s.RoomEvent.Name, s.RoomEvent.Redaction, s.RoomEvent.RedactionCancelled, s.RoomEvent.Receipt, s.RoomEvent.Tags, s.RoomEvent.LocalEchoUpdated, s.RoomEvent.AccountData, s.RoomEvent.MyMembership, s.RoomEvent.Timeline, s.RoomEvent.TimelineReset]), this.registerStateListeners(i), i
				}
				registerStateListeners(e) {
					this.client.reEmitter.reEmit(e.currentState, [g.RoomStateEvent.Events, g.RoomStateEvent.Members, g.RoomStateEvent.NewMember, g.RoomStateEvent.Update]), e.currentState.on(g.RoomStateEvent.NewMember, (e, t, i) => {
						var n;
						i.user = null !== (n = this.client.getUser(i.userId)) && void 0 !== n ? n : void 0, this.client.reEmitter.reEmit(i, [f.RoomMemberEvent.Name, f.RoomMemberEvent.Typing, f.RoomMemberEvent.PowerLevel, f.RoomMemberEvent.Membership])
					})
				}
				shouldAbortSync(e) {
					return "M_UNKNOWN_TOKEN" === e.errcode && (o.logger.warn("Token no longer valid - assuming logout"), this.stop(), this.updateSyncState(c.SyncState.Error, {
						error: e
					}), !0)
				}
				async processRoomData(e, t, i) {
					i = function(e, t, i) {
						if (!i.name) return i;
						for (const n of i.required_state)
							if (n.type === m.EventType.RoomName && "" === n.state_key) return n.content = {
								name: i.name
							}, i;
						return i.required_state.push({
							event_id: "$fake-sliding-sync-name-event-" + t,
							state_key: "",
							type: m.EventType.RoomName,
							content: {
								name: i.name
							},
							sender: e.getUserId(),
							origin_server_ts: (new Date).getTime()
						}), i
					}(e, t.roomId, i);
					const n = E(this.client, t.roomId, i.required_state);
					let r = E(this.client, t.roomId, i.timeline, !1);
					const o = [];
					if (i.initial) {
						const e = new Set;
						t.getLiveTimeline().getEvents().forEach(t => {
							e.add(t.getId())
						});
						const n = [],
							s = [];
						let o = !1;
						for (let t = r.length - 1; t >= 0; t--) {
							const i = r[t];
							e.has(i.getId()) ? o = !0 : o ? n.push(i) : s.unshift(i)
						}
						r = s, n.length > 0 && t.addEventsToTimeline(n, !0, t.getLiveTimeline(), i.prev_batch)
					}
					const c = this.client.isRoomEncrypted(t.roomId);
					if (null != i.notification_count && t.setUnreadNotificationCount(s.NotificationCountType.Total, i.notification_count), null != i.highlight_count && (!c || c && t.getUnreadNotificationCount(s.NotificationCountType.Highlight) <= 0) && t.setUnreadNotificationCount(s.NotificationCountType.Highlight, i.highlight_count), Number.isInteger(i.invited_count) && t.currentState.setInvitedMemberCount(i.invited_count), Number.isInteger(i.joined_count) && t.currentState.setJoinedMemberCount(i.joined_count), i.invite_state) {
						const e = E(this.client, t.roomId, i.invite_state);
						return this.injectRoomEvents(t, e), i.initial && (t.recalculate(), this.client.store.storeRoom(t), this.client.emit(l.ClientEvent.Room, t)), e.forEach(e => {
							this.client.emit(l.ClientEvent.Event, e)
						}), void t.updateMyMembership("invite")
					}
					var u;
					i.initial && t.getLiveTimeline().setPaginationToken(null !== (u = i.prev_batch) && void 0 !== u ? u : null, d.EventTimeline.BACKWARDS);
					this.injectRoomEvents(t, n, r, !1), t.addEphemeralEvents(o), t.updateMyMembership("join"), t.recalculate(), i.initial && (e.store.storeRoom(t), e.emit(l.ClientEvent.Room, t)), this.addNotifications(r);
					const h = async t => {
						e.emit(l.ClientEvent.Event, t), t.isState() && t.getType() == m.EventType.RoomEncryption && this.opts.crypto && await this.opts.crypto.onCryptoEvent(t)
					};
					await a.promiseMapSeries(n, h), await a.promiseMapSeries(r, h), o.forEach((function(t) {
						e.emit(l.ClientEvent.Event, t)
					})), t.decryptCriticalEvents()
				}
				injectRoomEvents(e, t, i, n = !1) {
					i = i || [], t = t || [];
					const r = e.getLiveTimeline(),
						s = 0 == r.getEvents().length;
					if (s) {
						for (const e of t) this.client.getPushActionsForEvent(e);
						r.initialiseState(t)
					}
					s || (e.oldState.setStateEvents(t), e.currentState.setStateEvents(t)), e.addLiveEvents(i, {
						fromCache: n
					}), e.recalculate(), this.resolveInvites(e)
				}
				resolveInvites(e) {
					if (!e || !this.opts.resolveInvitesToProfiles) return;
					const t = this.client;
					e.getMembersWithMembership("invite").forEach((function(i) {
						if (i.requestedProfileInfo) return;
						i.requestedProfileInfo = !0;
						const n = t.getUser(i.userId);
						let r;
						(r = n ? Promise.resolve({
							avatar_url: n.avatarUrl,
							displayname: n.displayName
						}) : t.getProfileInfo(i.userId)).then((function(t) {
							const n = i.events.member;
							"invite" === n.getContent().membership && (n.getContent().avatar_url = t.avatar_url, n.getContent().displayname = t.displayname, i.setMembershipEvent(n, e.currentState))
						}), (function(e) {}))
					}))
				}
				retryImmediately() {
					return !0
				}
				async sync() {
					for (o.logger.debug("Sliding sync init loop"); !this.client.isGuest();) try {
						o.logger.debug("Getting push rules...");
						const e = await this.client.getPushRules();
						o.logger.debug("Got push rules"), this.client.pushRules = e;
						break
					} catch (e) {
						if (o.logger.error("Getting push rules failed", e), this.shouldAbortSync(e)) return
					}
					await this.slidingSync.start()
				}
				stop() {
					o.logger.debug("SyncApi.stop"), this.slidingSync.stop()
				}
				updateSyncState(e, t) {
					const i = this.syncState;
					this.syncState = e, this.syncStateData = t, this.client.emit(l.ClientEvent.Sync, this.syncState, i, t)
				}
				addNotifications(e) {
					if (this.client.getNotifTimelineSet())
						for (const t of e) {
							const e = this.client.getPushActionsForEvent(t);
							e && e.notify && e.tweaks && e.tweaks.highlight && this.notifEvents.push(t)
						}
				}
				purgeNotifications() {
					this.notifEvents.sort((function(e, t) {
						return e.getTs() - t.getTs()
					})), this.notifEvents.forEach(e => {
						var t;
						null === (t = this.client.getNotifTimelineSet()) || void 0 === t || t.addLiveEvent(e)
					}), this.notifEvents = []
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/sliding-sync.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.SlidingSyncState = t.SlidingSyncEvent = t.SlidingSync = t.ExtensionState = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js"),
				a = i("./node_modules/matrix-js-sdk/lib/utils.js");

			function d(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function l(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? d(Object(i), !0).forEach((function(t) {
						(0, r.default)(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : d(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}
			const c = 1e4;
			let u, h, m;
			t.SlidingSyncState = u,
				function(e) {
					e.RequestFinished = "FINISHED", e.Complete = "COMPLETE"
				}(u || (t.SlidingSyncState = u = {}));
			class p {
				constructor(e) {
					(0, r.default)(this, "list", void 0), (0, r.default)(this, "isModified", void 0), (0, r.default)(this, "roomIndexToRoomId", {}), (0, r.default)(this, "joinedCount", 0), this.replaceList(e)
				}
				setModified(e) {
					this.isModified = e
				}
				updateListRange(e) {
					this.list.ranges = JSON.parse(JSON.stringify(e))
				}
				replaceList(e) {
					e.filters = e.filters || {}, e.ranges = e.ranges || [], this.list = JSON.parse(JSON.stringify(e)), this.isModified = !0, this.roomIndexToRoomId = {}, this.joinedCount = 0
				}
				getList(e) {
					let t = {
						ranges: JSON.parse(JSON.stringify(this.list.ranges))
					};
					return (this.isModified || e) && (t = JSON.parse(JSON.stringify(this.list))), t
				}
				isIndexInRange(e) {
					for (const t of this.list.ranges)
						if (t[0] <= e && e <= t[1]) return !0;
					return !1
				}
			}
			t.ExtensionState = h,
				function(e) {
					e.PreProcess = "ExtState.PreProcess", e.PostProcess = "ExtState.PostProcess"
				}(h || (t.ExtensionState = h = {})), t.SlidingSyncEvent = m,
				function(e) {
					e.RoomData = "SlidingSync.RoomData", e.Lifecycle = "SlidingSync.Lifecycle", e.List = "SlidingSync.List"
				}(m || (t.SlidingSyncEvent = m = {}));
			class g extends o.TypedEventEmitter {
				constructor(e, t, i, n, s) {
					super(), this.proxyBaseUrl = e, this.roomSubscriptionInfo = i, this.client = n, this.timeoutMS = s, (0, r.default)(this, "lists", void 0), (0, r.default)(this, "listModifiedCount", 0), (0, r.default)(this, "terminated", !1), (0, r.default)(this, "needsResend", !1), (0, r.default)(this, "txnId", null), (0, r.default)(this, "txnIdDefers", []), (0, r.default)(this, "extensions", {}), (0, r.default)(this, "desiredRoomSubscriptions", new Set), (0, r.default)(this, "confirmedRoomSubscriptions", new Set), (0, r.default)(this, "customSubscriptions", new Map), (0, r.default)(this, "roomIdToCustomSubscription", new Map), (0, r.default)(this, "pendingReq", void 0), (0, r.default)(this, "abortController", void 0), this.lists = t.map(e => new p(e))
				}
				addCustomSubscription(e, t) {
					this.customSubscriptions.set(e, t)
				}
				useCustomSubscription(e, t) {
					this.roomIdToCustomSubscription.set(e, t), this.confirmedRoomSubscriptions.delete(e)
				}
				listLength() {
					return this.lists.length
				}
				getListData(e) {
					return this.lists[e] ? {
						joinedCount: this.lists[e].joinedCount,
						roomIndexToRoomId: Object.assign({}, this.lists[e].roomIndexToRoomId)
					} : null
				}
				getList(e) {
					return this.lists[e] ? this.lists[e].getList(!0) : null
				}
				setListRanges(e, t) {
					return this.lists[e].updateListRange(t), this.resend()
				}
				setList(e, t) {
					return this.lists[e] ? this.lists[e].replaceList(t) : this.lists[e] = new p(t), this.listModifiedCount += 1, this.resend()
				}
				getRoomSubscriptions() {
					return new Set(Array.from(this.desiredRoomSubscriptions))
				}
				modifyRoomSubscriptions(e) {
					return this.desiredRoomSubscriptions = e, this.resend()
				}
				modifyRoomSubscriptionInfo(e) {
					return this.roomSubscriptionInfo = e, this.confirmedRoomSubscriptions = new Set, this.resend()
				}
				registerExtension(e) {
					if (this.extensions[e.name()]) throw new Error(`registerExtension: ${e.name()} already exists as an extension`);
					this.extensions[e.name()] = e
				}
				getExtensionRequest(e) {
					const t = {};
					return Object.keys(this.extensions).forEach(i => {
						t[i] = this.extensions[i].onRequest(e)
					}), t
				}
				onPreExtensionsResponse(e) {
					Object.keys(e).forEach(t => {
						this.extensions[t].when() == h.PreProcess && this.extensions[t].onResponse(e[t])
					})
				}
				onPostExtensionsResponse(e) {
					Object.keys(e).forEach(t => {
						this.extensions[t].when() == h.PostProcess && this.extensions[t].onResponse(e[t])
					})
				}
				invokeRoomDataListeners(e, t) {
					t.required_state || (t.required_state = []), t.timeline || (t.timeline = []), this.emit(m.RoomData, e, t)
				}
				invokeLifecycleListeners(e, t, i) {
					this.emit(m.Lifecycle, e, t, i)
				}
				shiftRight(e, t, i) {
					for (let n = t; n > i; n--) this.lists[e].isIndexInRange(n) && (this.lists[e].roomIndexToRoomId[n] = this.lists[e].roomIndexToRoomId[n - 1])
				}
				shiftLeft(e, t, i) {
					for (let n = i; n < t; n++) this.lists[e].isIndexInRange(n) && (this.lists[e].roomIndexToRoomId[n] = this.lists[e].roomIndexToRoomId[n + 1])
				}
				removeEntry(e, t) {
					let i = -1;
					for (const n in this.lists[e].roomIndexToRoomId) Number(n) > i && (i = Number(n));
					i < 0 || t > i || (this.shiftLeft(e, i, t), delete this.lists[e].roomIndexToRoomId[i])
				}
				addEntry(e, t) {
					let i = -1;
					for (const n in this.lists[e].roomIndexToRoomId) Number(n) > i && (i = Number(n));
					i < 0 || t > i || this.shiftRight(e, i + 1, t)
				}
				processListOps(e, t) {
					let i = -1;
					e.ops.forEach(e => {
						switch (e.op) {
							case "DELETE":
								s.logger.debug("DELETE", t, e.index, ";"), delete this.lists[t].roomIndexToRoomId[e.index], -1 !== i && this.removeEntry(t, i), i = e.index;
								break;
							case "INSERT":
								s.logger.debug("INSERT", t, e.index, e.room_id, ";"), this.lists[t].roomIndexToRoomId[e.index] && (i < 0 ? this.addEntry(t, e.index) : i > e.index ? this.shiftRight(t, i, e.index) : i < e.index && this.shiftLeft(t, e.index, i)), i = -1, this.lists[t].roomIndexToRoomId[e.index] = e.room_id;
								break;
							case "INVALIDATE":
								for (let i = e.range[0]; i <= e.range[1]; i++) delete this.lists[t].roomIndexToRoomId[i];
								s.logger.debug("INVALIDATE", t, e.range[0], e.range[1], ";");
								break;
							case "SYNC": {
								const i = e.range[0];
								for (let n = i; n <= e.range[1]; n++) {
									const r = e.room_ids[n - i];
									if (!r) break;
									this.lists[t].roomIndexToRoomId[n] = r
								}
								s.logger.debug("SYNC", t, e.range[0], e.range[1], (e.room_ids || []).join(" "), ";");
								break
							}
						}
					}), -1 !== i && this.removeEntry(t, i)
				}
				resend() {
					var e;
					if (this.needsResend && this.txnIdDefers.length > 0) return this.txnIdDefers[this.txnIdDefers.length - 1].promise;
					this.needsResend = !0, this.txnId = this.client.makeTxnId();
					const t = (0, a.defer)();
					return this.txnIdDefers.push(l(l({}, t), {}, {
						txnId: this.txnId
					})), null === (e = this.abortController) || void 0 === e || e.abort(), this.abortController = new AbortController, t.promise
				}
				resolveTransactionDefers(e) {
					if (!e) return;
					let t = -1;
					for (let i = 0; i < this.txnIdDefers.length; i++)
						if (this.txnIdDefers[i].txnId === e) {
							t = i;
							break
						} if (-1 !== t) {
						for (let e = 0; e < t; e++) this.txnIdDefers[e].reject(this.txnIdDefers[e].txnId);
						this.txnIdDefers[t].resolve(e), this.txnIdDefers = this.txnIdDefers.slice(t + 1)
					} else s.logger.warn(`resolveTransactionDefers: seen ${e} but it isn't a pending txn, ignoring.`)
				}
				stop() {
					var e;
					this.terminated = !0, null === (e = this.abortController) || void 0 === e || e.abort(), this.removeAllListeners(m.Lifecycle), this.removeAllListeners(m.List), this.removeAllListeners(m.RoomData)
				}
				resetup() {
					var e;
					s.logger.warn("SlidingSync: resetting connection info"), this.txnIdDefers.forEach(e => {
						e.reject(e.txnId)
					}), this.txnIdDefers = [], this.lists.forEach(e => {
						e.setModified(!0)
					}), this.confirmedRoomSubscriptions = new Set, this.needsResend = !0, null === (e = this.abortController) || void 0 === e || e.abort(), this.abortController = new AbortController
				}
				async start() {
					let e;
					for (this.abortController = new AbortController; !this.terminated;) {
						this.needsResend = !1;
						let i, n = !1;
						try {
							const t = this.listModifiedCount,
								r = {
									lists: this.lists.map(e => e.getList(!1)),
									pos: e,
									timeout: this.timeoutMS,
									clientTimeout: this.timeoutMS + c,
									extensions: this.getExtensionRequest(void 0 === e)
								},
								o = f(this.desiredRoomSubscriptions, this.confirmedRoomSubscriptions),
								a = f(this.confirmedRoomSubscriptions, this.desiredRoomSubscriptions);
							if (a.size > 0 && (r.unsubscribe_rooms = Array.from(a)), o.size > 0) {
								r.room_subscriptions = {};
								for (const e of o) {
									const t = this.roomIdToCustomSubscription.get(e);
									let i = this.roomSubscriptionInfo;
									t && this.customSubscriptions.has(t) && (i = this.customSubscriptions.get(t)), r.room_subscriptions[e] = i
								}
							}
							this.txnId && (r.txn_id = this.txnId, this.txnId = null), this.pendingReq = this.client.slidingSync(r, this.proxyBaseUrl, this.abortController.signal), e = (i = await this.pendingReq).pos;
							for (const e of o) this.confirmedRoomSubscriptions.add(e);
							for (const e of a) this.confirmedRoomSubscriptions.delete(e);
							t !== this.listModifiedCount && (s.logger.debug("list modified during await call, not updating list"), n = !0), this.lists.forEach(e => {
								e.setModified(!1)
							}), i.lists = i.lists || [], i.rooms = i.rooms || {}, i.extensions = i.extensions || {}, i.lists.forEach((e, t) => {
								this.lists[t].joinedCount = e.count
							}), this.invokeLifecycleListeners(u.RequestFinished, i)
						} catch (t) {
							if (t.httpStatus) {
								if (this.invokeLifecycleListeners(u.RequestFinished, null, t), 400 === t.httpStatus) {
									this.resetup(), e = void 0, await (0, a.sleep)(50);
									continue
								}
							} else if (this.needsResend || "AbortError" === t.name) continue;
							s.logger.error(t), await (0, a.sleep)(5e3)
						}
						if (!i) continue;
						this.onPreExtensionsResponse(i.extensions), Object.keys(i.rooms).forEach(e => {
							this.invokeRoomDataListeners(e, i.rooms[e])
						});
						const r = new Set;
						n || i.lists.forEach((e, t) => {
							e.ops = e.ops || [], e.ops.length > 0 && r.add(t), this.processListOps(e, t)
						}), this.invokeLifecycleListeners(u.Complete, i), this.onPostExtensionsResponse(i.extensions), r.forEach(e => {
							this.emit(m.List, e, this.lists[e].joinedCount, Object.assign({}, this.lists[e].roomIndexToRoomId))
						}), this.resolveTransactionDefers(i.txn_id)
					}
				}
			}
			t.SlidingSync = g;
			const f = (e, t) => {
				const i = new Set(e);
				for (const n of t) i.delete(n);
				return i
			}
		},
		"./node_modules/matrix-js-sdk/lib/store/indexeddb-local-backend.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.LocalIndexedDBStoreBackend = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/sync-accumulator.js"),
				o = c(i("./node_modules/matrix-js-sdk/lib/utils.js")),
				a = c(i("./node_modules/matrix-js-sdk/lib/indexeddb-helpers.js")),
				d = i("./node_modules/matrix-js-sdk/lib/logger.js");

			function l(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (l = function(e) {
					return e ? i : t
				})(e)
			}

			function c(e, t) {
				if (!t && e && e.__esModule) return e;
				if (null === e || "object" != typeof e && "function" != typeof e) return {
					default: e
				};
				var i = l(t);
				if (i && i.has(e)) return i.get(e);
				var n = {},
					r = Object.defineProperty && Object.getOwnPropertyDescriptor;
				for (var s in e)
					if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
						var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
						o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
					} return n.default = e, i && i.set(e, n), n
			}
			const u = [e => {
					e.createObjectStore("users", {
						keyPath: ["userId"]
					}), e.createObjectStore("accountData", {
						keyPath: ["type"]
					}), e.createObjectStore("sync", {
						keyPath: ["clobber"]
					})
				}, e => {
					e.createObjectStore("oob_membership_events", {
						keyPath: ["room_id", "state_key"]
					}).createIndex("room", "room_id")
				}, e => {
					e.createObjectStore("client_options", {
						keyPath: ["clobber"]
					})
				}, e => {
					e.createObjectStore("to_device_queue", {
						autoIncrement: !0
					})
				}],
				h = u.length;

			function m(e, t, i) {
				const n = e.openCursor(t);
				return new Promise((e, t) => {
					const r = [];
					n.onerror = () => {
						t(new Error("Query failed: " + n.error))
					}, n.onsuccess = () => {
						const t = n.result;
						t ? (r.push(i(t)), t.continue()) : e(r)
					}
				})
			}

			function p(e) {
				return new Promise((t, i) => {
					e.oncomplete = function(e) {
						t(e)
					}, e.onerror = function() {
						i(e.error)
					}
				})
			}

			function g(e) {
				return new Promise((t, i) => {
					e.onsuccess = function(e) {
						t(e)
					}, e.onerror = function() {
						i(e.error)
					}
				})
			}

			function f(e) {
				return g(e).then(t => e.result)
			}
			t.LocalIndexedDBStoreBackend = class {
				static exists(e, t) {
					return t = "matrix-js-sdk:" + (t || "default"), a.exists(e, t)
				}
				constructor(e, t = "default") {
					this.indexedDB = e, (0, r.default)(this, "dbName", void 0), (0, r.default)(this, "syncAccumulator", void 0), (0, r.default)(this, "db", void 0), (0, r.default)(this, "disconnected", !0), (0, r.default)(this, "_isNewlyCreated", !1), (0, r.default)(this, "isPersisting", !1), (0, r.default)(this, "pendingUserPresenceData", []), this.dbName = "matrix-js-sdk:" + t, this.syncAccumulator = new s.SyncAccumulator
				}
				connect() {
					if (!this.disconnected) return d.logger.log("LocalIndexedDBStoreBackend.connect: already connected or connecting"), Promise.resolve();
					this.disconnected = !1, d.logger.log("LocalIndexedDBStoreBackend.connect: connecting...");
					const e = this.indexedDB.open(this.dbName, h);
					return e.onupgradeneeded = t => {
						const i = e.result,
							n = t.oldVersion;
						d.logger.log(`LocalIndexedDBStoreBackend.connect: upgrading from ${n}`), n < 1 && (this._isNewlyCreated = !0), u.forEach((e, t) => {
							n <= t && e(i)
						})
					}, e.onblocked = () => {
						d.logger.log("can't yet open LocalIndexedDBStoreBackend because it is open elsewhere")
					}, d.logger.log("LocalIndexedDBStoreBackend.connect: awaiting connection..."), g(e).then(() => (d.logger.log("LocalIndexedDBStoreBackend.connect: connected"), this.db = e.result, this.db.onversionchange = () => {
						var e;
						null === (e = this.db) || void 0 === e || e.close()
					}, this.init()))
				}
				isNewlyCreated() {
					return Promise.resolve(this._isNewlyCreated)
				}
				init() {
					return Promise.all([this.loadAccountData(), this.loadSyncData()]).then(([e, t]) => {
						d.logger.log("LocalIndexedDBStoreBackend: loaded initial data"), this.syncAccumulator.accumulate({
							next_batch: t.nextBatch,
							rooms: t.roomsData,
							account_data: {
								events: e
							}
						}, !0)
					})
				}
				getOutOfBandMembers(e) {
					return new Promise((t, i) => {
						const n = this.db.transaction(["oob_membership_events"], "readonly").objectStore("oob_membership_events").index("room"),
							r = IDBKeyRange.only(e),
							s = n.openCursor(r),
							o = [];
						let a = !1;
						s.onsuccess = () => {
							const e = s.result;
							if (!e) return o.length || a ? t(o) : t(null);
							const i = e.value;
							i.oob_written ? a = !0 : o.push(i), e.continue()
						}, s.onerror = e => {
							i(e)
						}
					}).then(t => (d.logger.log(`LL: got ${null==t?void 0:t.length} membershipEvents from storage for room ${e} ...`), t))
				}
				async setOutOfBandMembers(e, t) {
					d.logger.log(`LL: backend about to store ${t.length}` + ` members for ${e}`);
					const i = this.db.transaction(["oob_membership_events"], "readwrite"),
						n = i.objectStore("oob_membership_events");
					t.forEach(e => {
						n.put(e)
					});
					const r = {
						room_id: e,
						oob_written: !0,
						state_key: 0
					};
					n.put(r), await p(i), d.logger.log(`LL: backend done storing for ${e}!`)
				}
				async clearOutOfBandMembers(e) {
					const t = this.db.transaction(["oob_membership_events"], "readonly").objectStore("oob_membership_events").index("room"),
						i = IDBKeyRange.only(e),
						n = f(t.openKeyCursor(i, "next")).then(e => e && e.primaryKey[1]),
						r = f(t.openKeyCursor(i, "prev")).then(e => e && e.primaryKey[1]),
						[s, o] = await Promise.all([n, r]),
						a = this.db.transaction(["oob_membership_events"], "readwrite").objectStore("oob_membership_events"),
						l = IDBKeyRange.bound([e, s], [e, o]);
					var c;
					d.logger.log(`LL: Deleting all users + marker in storage for room ${e}, with key range:`, [e, s], [e, o]), await (c = a.delete(l), new Promise((e, t) => {
						c.onsuccess = () => e(c), c.onerror = e => t(e)
					}))
				}
				clearDatabase() {
					return new Promise(e => {
						d.logger.log(`Removing indexeddb instance: ${this.dbName}`);
						const t = this.indexedDB.deleteDatabase(this.dbName);
						t.onblocked = () => {
							d.logger.log(`can't yet delete indexeddb ${this.dbName} because it is open elsewhere`)
						}, t.onerror = () => {
							d.logger.warn(`unable to delete js-sdk store indexeddb: ${t.error}`), e()
						}, t.onsuccess = () => {
							d.logger.log(`Removed indexeddb instance: ${this.dbName}`), e()
						}
					})
				}
				getSavedSync(e = !0) {
					const t = this.syncAccumulator.getJSON();
					return t.nextBatch ? e ? Promise.resolve(o.deepCopy(t)) : Promise.resolve(t) : Promise.resolve(null)
				}
				getNextBatchToken() {
					return Promise.resolve(this.syncAccumulator.getNextBatchToken())
				}
				setSyncData(e) {
					return Promise.resolve().then(() => {
						this.syncAccumulator.accumulate(e)
					})
				}
				async syncToDatabase(e) {
					if (this.isPersisting) return d.logger.warn("Skipping syncToDatabase() as persist already in flight"), void this.pendingUserPresenceData.push(...e);
					e.unshift(...this.pendingUserPresenceData), this.isPersisting = !0;
					try {
						const t = this.syncAccumulator.getJSON(!0);
						await Promise.all([this.persistUserPresenceEvents(e), this.persistAccountData(t.accountData), this.persistSyncData(t.nextBatch, t.roomsData)])
					} finally {
						this.isPersisting = !1
					}
				}
				persistSyncData(e, t) {
					return d.logger.log("Persisting sync data up to", e), o.promiseTry(() => {
						const i = this.db.transaction(["sync"], "readwrite");
						return i.objectStore("sync").put({
							clobber: "-",
							nextBatch: e,
							roomsData: t
						}), p(i).then(() => {
							d.logger.log("Persisted sync data up to", e)
						})
					})
				}
				persistAccountData(e) {
					return o.promiseTry(() => {
						const t = this.db.transaction(["accountData"], "readwrite"),
							i = t.objectStore("accountData");
						for (const n of e) i.put(n);
						return p(t).then()
					})
				}
				persistUserPresenceEvents(e) {
					return o.promiseTry(() => {
						const t = this.db.transaction(["users"], "readwrite"),
							i = t.objectStore("users");
						for (const n of e) i.put({
							userId: n[0],
							event: n[1]
						});
						return p(t).then()
					})
				}
				getUserPresenceEvents() {
					return o.promiseTry(() => {
						return m(this.db.transaction(["users"], "readonly").objectStore("users"), void 0, e => [e.value.userId, e.value.event])
					})
				}
				loadAccountData() {
					return d.logger.log("LocalIndexedDBStoreBackend: loading account data..."), o.promiseTry(() => {
						return m(this.db.transaction(["accountData"], "readonly").objectStore("accountData"), void 0, e => e.value).then(e => (d.logger.log("LocalIndexedDBStoreBackend: loaded account data"), e))
					})
				}
				loadSyncData() {
					return d.logger.log("LocalIndexedDBStoreBackend: loading sync data..."), o.promiseTry(() => {
						return m(this.db.transaction(["sync"], "readonly").objectStore("sync"), void 0, e => e.value).then(e => (d.logger.log("LocalIndexedDBStoreBackend: loaded sync data"), e.length > 1 && d.logger.warn("loadSyncData: More than 1 sync row found."), e.length > 0 ? e[0] : {}))
					})
				}
				getClientOptions() {
					return Promise.resolve().then(() => {
						return m(this.db.transaction(["client_options"], "readonly").objectStore("client_options"), void 0, e => {
							var t;
							return null === (t = e.value) || void 0 === t ? void 0 : t.options
						}).then(e => e[0])
					})
				}
				async storeClientOptions(e) {
					const t = this.db.transaction(["client_options"], "readwrite");
					t.objectStore("client_options").put({
						clobber: "-",
						options: e
					}), await p(t)
				}
				async saveToDeviceBatches(e) {
					const t = this.db.transaction(["to_device_queue"], "readwrite"),
						i = t.objectStore("to_device_queue");
					for (const n of e) i.add(n);
					await p(t)
				}
				async getOldestToDeviceBatch() {
					const e = this.db.transaction(["to_device_queue"], "readonly").objectStore("to_device_queue"),
						t = await f(e.openCursor());
					if (!t) return null;
					const i = t.value;
					return {
						id: t.key,
						txnId: i.txnId,
						eventType: i.eventType,
						batch: i.batch
					}
				}
				async removeToDeviceBatch(e) {
					const t = this.db.transaction(["to_device_queue"], "readwrite");
					t.objectStore("to_device_queue").delete(e), await p(t)
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/store/indexeddb-remote-backend.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.RemoteIndexedDBStoreBackend = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = i("./node_modules/matrix-js-sdk/lib/utils.js");
			t.RemoteIndexedDBStoreBackend = class {
				constructor(e, t) {
					this.workerFactory = e, this.dbName = t, (0, r.default)(this, "worker", void 0), (0, r.default)(this, "nextSeq", 0), (0, r.default)(this, "inFlight", {}), (0, r.default)(this, "startPromise", void 0), (0, r.default)(this, "onWorkerMessage", e => {
						const t = e.data;
						if ("cmd_success" == t.command || "cmd_fail" == t.command) {
							if (void 0 === t.seq) return void s.logger.error("Got reply from worker with no seq");
							const e = this.inFlight[t.seq];
							if (void 0 === e) return void s.logger.error("Got reply for unknown seq " + t.seq);
							if (delete this.inFlight[t.seq], "cmd_success" == t.command) e.resolve(t.result);
							else {
								const i = new Error(t.error.message);
								i.name = t.error.name, e.reject(i)
							}
						} else s.logger.warn("Unrecognised message from worker: ", t)
					})
				}
				connect() {
					return this.ensureStarted().then(() => this.doCmd("connect"))
				}
				clearDatabase() {
					return this.ensureStarted().then(() => this.doCmd("clearDatabase"))
				}
				isNewlyCreated() {
					return this.doCmd("isNewlyCreated")
				}
				getSavedSync() {
					return this.doCmd("getSavedSync")
				}
				getNextBatchToken() {
					return this.doCmd("getNextBatchToken")
				}
				setSyncData(e) {
					return this.doCmd("setSyncData", [e])
				}
				syncToDatabase(e) {
					return this.doCmd("syncToDatabase", [e])
				}
				getOutOfBandMembers(e) {
					return this.doCmd("getOutOfBandMembers", [e])
				}
				setOutOfBandMembers(e, t) {
					return this.doCmd("setOutOfBandMembers", [e, t])
				}
				clearOutOfBandMembers(e) {
					return this.doCmd("clearOutOfBandMembers", [e])
				}
				getClientOptions() {
					return this.doCmd("getClientOptions")
				}
				storeClientOptions(e) {
					return this.doCmd("storeClientOptions", [e])
				}
				getUserPresenceEvents() {
					return this.doCmd("getUserPresenceEvents")
				}
				async saveToDeviceBatches(e) {
					return this.doCmd("saveToDeviceBatches", [e])
				}
				async getOldestToDeviceBatch() {
					return this.doCmd("getOldestToDeviceBatch")
				}
				async removeToDeviceBatch(e) {
					return this.doCmd("removeToDeviceBatch", [e])
				}
				ensureStarted() {
					return this.startPromise || (this.worker = this.workerFactory(), this.worker.onmessage = this.onWorkerMessage, this.startPromise = this.doCmd("setupWorker", [this.dbName]).then(() => {
						s.logger.log("IndexedDB worker is ready")
					})), this.startPromise
				}
				doCmd(e, t) {
					return Promise.resolve().then(() => {
						var i;
						const n = this.nextSeq++,
							r = (0, o.defer)();
						return this.inFlight[n] = r, null === (i = this.worker) || void 0 === i || i.postMessage({
							command: e,
							seq: n,
							args: t
						}), r.promise
					})
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/store/indexeddb.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.IndexedDBStore = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/store/memory.js"),
				o = i("./node_modules/matrix-js-sdk/lib/store/indexeddb-local-backend.js"),
				a = i("./node_modules/matrix-js-sdk/lib/store/indexeddb-remote-backend.js"),
				d = i("./node_modules/matrix-js-sdk/lib/models/user.js"),
				l = i("./node_modules/matrix-js-sdk/lib/models/event.js"),
				c = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				u = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js");
			const h = 3e5;
			class m extends s.MemoryStore {
				static exists(e, t) {
					return o.LocalIndexedDBStoreBackend.exists(e, t)
				}
				constructor(e) {
					if (super(e), (0, r.default)(this, "backend", void 0), (0, r.default)(this, "startedUp", !1), (0, r.default)(this, "syncTs", 0), (0, r.default)(this, "userModifiedMap", {}), (0, r.default)(this, "emitter", new u.TypedEventEmitter), (0, r.default)(this, "on", this.emitter.on.bind(this.emitter)), (0, r.default)(this, "getSavedSync", this.degradable(() => this.backend.getSavedSync(), "getSavedSync")), (0, r.default)(this, "isNewlyCreated", this.degradable(() => this.backend.isNewlyCreated(), "isNewlyCreated")), (0, r.default)(this, "getSavedSyncToken", this.degradable(() => this.backend.getNextBatchToken(), "getSavedSyncToken")), (0, r.default)(this, "deleteAllData", this.degradable(() => (super.deleteAllData(), this.backend.clearDatabase().then(() => {
							c.logger.log("Deleted indexeddb data.")
						}, e => {
							throw c.logger.error(`Failed to delete indexeddb data: ${e}`), e
						})))), (0, r.default)(this, "reallySave", this.degradable(() => {
							this.syncTs = Date.now();
							const e = [];
							for (const t of this.getUsers()) this.userModifiedMap[t.userId] !== t.getLastModifiedTime() && t.events.presence && (e.push([t.userId, t.events.presence.event]), this.userModifiedMap[t.userId] = t.getLastModifiedTime());
							return this.backend.syncToDatabase(e)
						})), (0, r.default)(this, "setSyncData", this.degradable(e => this.backend.setSyncData(e), "setSyncData")), (0, r.default)(this, "getOutOfBandMembers", this.degradable(e => this.backend.getOutOfBandMembers(e), "getOutOfBandMembers")), (0, r.default)(this, "setOutOfBandMembers", this.degradable((e, t) => (super.setOutOfBandMembers(e, t), this.backend.setOutOfBandMembers(e, t)), "setOutOfBandMembers")), (0, r.default)(this, "clearOutOfBandMembers", this.degradable(e => (super.clearOutOfBandMembers(e), this.backend.clearOutOfBandMembers(e)), "clearOutOfBandMembers")), (0, r.default)(this, "getClientOptions", this.degradable(() => this.backend.getClientOptions(), "getClientOptions")), (0, r.default)(this, "storeClientOptions", this.degradable(e => (super.storeClientOptions(e), this.backend.storeClientOptions(e)), "storeClientOptions")), !e.indexedDB) throw new Error("Missing required option: indexedDB");
					e.workerFactory ? this.backend = new a.RemoteIndexedDBStoreBackend(e.workerFactory, e.dbName) : this.backend = new o.LocalIndexedDBStoreBackend(e.indexedDB, e.dbName)
				}
				startup() {
					return this.startedUp ? (c.logger.log("IndexedDBStore.startup: already started"), Promise.resolve()) : (c.logger.log("IndexedDBStore.startup: connecting to backend"), this.backend.connect().then(() => (c.logger.log("IndexedDBStore.startup: loading presence events"), this.backend.getUserPresenceEvents())).then(e => {
						c.logger.log("IndexedDBStore.startup: processing presence events"), e.forEach(([e, t]) => {
							const i = new d.User(e);
							t && i.setPresenceEvent(new l.MatrixEvent(t)), this.userModifiedMap[i.userId] = i.getLastModifiedTime(), this.storeUser(i)
						})
					}))
				}
				wantsSave() {
					return Date.now() - this.syncTs > h
				}
				save(e = !1) {
					return e || this.wantsSave() ? this.reallySave() : Promise.resolve()
				}
				degradable(e, t) {
					const i = t ? super[t] : null;
					return async (...t) => {
						try {
							return await e.call(this, ...t)
						} catch (n) {
							c.logger.error("IndexedDBStore failure, degrading to MemoryStore", n), this.emitter.emit("degraded", n);
							try {
								c.logger.log("IndexedDBStore trying to delete degraded data"), await this.backend.clearDatabase(), c.logger.log("IndexedDBStore delete after degrading succeeded")
							} catch (n) {
								c.logger.warn("IndexedDBStore delete after degrading failed", n)
							}
							if (i) return i.call(this, ...t)
						}
					}
				}
				async getPendingEvents(e) {
					if (!this.localStorage) return super.getPendingEvents(e);
					const t = this.localStorage.getItem(p(e));
					if (t) try {
						return JSON.parse(t)
					} catch (i) {
						c.logger.error("Could not parse persisted pending events", i)
					}
					return []
				}
				async setPendingEvents(e, t) {
					if (!this.localStorage) return super.setPendingEvents(e, t);
					t.length > 0 ? this.localStorage.setItem(p(e), JSON.stringify(t)) : this.localStorage.removeItem(p(e))
				}
				saveToDeviceBatches(e) {
					return this.backend.saveToDeviceBatches(e)
				}
				getOldestToDeviceBatch() {
					return this.backend.getOldestToDeviceBatch()
				}
				removeToDeviceBatch(e) {
					return this.backend.removeToDeviceBatch(e)
				}
			}

			function p(e) {
				return `mx_pending_events_${e}`
			}
			t.IndexedDBStore = m
		},
		"./node_modules/matrix-js-sdk/lib/store/memory.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.MemoryStore = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/models/user.js"),
				o = i("./node_modules/matrix-js-sdk/lib/models/room-state.js");

			function a(e) {
				return "string" == typeof e && !!e && "undefined" !== e && "null" !== e || "number" == typeof e
			}
			t.MemoryStore = class {
				constructor(e = {}) {
					(0, r.default)(this, "rooms", {}), (0, r.default)(this, "users", {}), (0, r.default)(this, "syncToken", null), (0, r.default)(this, "filters", {}), (0, r.default)(this, "accountData", {}), (0, r.default)(this, "localStorage", void 0), (0, r.default)(this, "oobMembers", {}), (0, r.default)(this, "pendingEvents", {}), (0, r.default)(this, "clientOptions", void 0), (0, r.default)(this, "pendingToDeviceBatches", []), (0, r.default)(this, "nextToDeviceBatchId", 0), (0, r.default)(this, "onRoomMember", (e, t, i) => {
						if ("invite" === i.membership) return;
						const n = this.users[i.userId] || new s.User(i.userId);
						i.name && (n.setDisplayName(i.name), i.events.member && n.setRawDisplayName(i.events.member.getDirectionalContent().displayname)), i.events.member && i.events.member.getContent().avatar_url && n.setAvatarUrl(i.events.member.getContent().avatar_url), this.users[n.userId] = n
					}), this.localStorage = e.localStorage
				}
				getSyncToken() {
					return this.syncToken
				}
				isNewlyCreated() {
					return Promise.resolve(!0)
				}
				setSyncToken(e) {
					this.syncToken = e
				}
				storeRoom(e) {
					this.rooms[e.roomId] = e, e.currentState.on(o.RoomStateEvent.Members, this.onRoomMember), e.currentState.getMembers().forEach(t => {
						this.onRoomMember(null, e.currentState, t)
					})
				}
				getRoom(e) {
					return this.rooms[e] || null
				}
				getRooms() {
					return Object.values(this.rooms)
				}
				removeRoom(e) {
					this.rooms[e] && this.rooms[e].currentState.removeListener(o.RoomStateEvent.Members, this.onRoomMember), delete this.rooms[e]
				}
				getRoomSummaries() {
					return Object.values(this.rooms).map((function(e) {
						return e.summary
					}))
				}
				storeUser(e) {
					this.users[e.userId] = e
				}
				getUser(e) {
					return this.users[e] || null
				}
				getUsers() {
					return Object.values(this.users)
				}
				scrollback(e, t) {
					return []
				}
				storeEvents(e, t, i, n) {}
				storeFilter(e) {
					null != e && e.userId && null != e && e.filterId && (this.filters[e.userId] || (this.filters[e.userId] = {}), this.filters[e.userId][e.filterId] = e)
				}
				getFilter(e, t) {
					return this.filters[e] && this.filters[e][t] ? this.filters[e][t] : null
				}
				getFilterIdByName(e) {
					if (!this.localStorage) return null;
					const t = "mxjssdk_memory_filter_" + e;
					try {
						const e = this.localStorage.getItem(t);
						if (a(e)) return e
					} catch (i) {}
					return null
				}
				setFilterIdByName(e, t) {
					if (!this.localStorage) return;
					const i = "mxjssdk_memory_filter_" + e;
					try {
						a(t) ? this.localStorage.setItem(i, t) : this.localStorage.removeItem(i)
					} catch (n) {}
				}
				storeAccountDataEvents(e) {
					e.forEach(e => {
						this.accountData[e.getType()] = e
					})
				}
				getAccountData(e) {
					return this.accountData[e]
				}
				setSyncData(e) {
					return Promise.resolve()
				}
				wantsSave() {
					return !1
				}
				save(e) {}
				startup() {
					return Promise.resolve()
				}
				getSavedSync() {
					return Promise.resolve(null)
				}
				getSavedSyncToken() {
					return Promise.resolve(null)
				}
				deleteAllData() {
					return this.rooms = {}, this.users = {}, this.syncToken = null, this.filters = {}, this.accountData = {}, Promise.resolve()
				}
				getOutOfBandMembers(e) {
					return Promise.resolve(this.oobMembers[e] || null)
				}
				setOutOfBandMembers(e, t) {
					return this.oobMembers[e] = t, Promise.resolve()
				}
				clearOutOfBandMembers(e) {
					return this.oobMembers = {}, Promise.resolve()
				}
				getClientOptions() {
					return Promise.resolve(this.clientOptions)
				}
				storeClientOptions(e) {
					return this.clientOptions = Object.assign({}, e), Promise.resolve()
				}
				async getPendingEvents(e) {
					var t;
					return null !== (t = this.pendingEvents[e]) && void 0 !== t ? t : []
				}
				async setPendingEvents(e, t) {
					this.pendingEvents[e] = t
				}
				saveToDeviceBatches(e) {
					for (const t of e) this.pendingToDeviceBatches.push({
						id: this.nextToDeviceBatchId++,
						eventType: t.eventType,
						txnId: t.txnId,
						batch: t.batch
					});
					return Promise.resolve()
				}
				async getOldestToDeviceBatch() {
					return 0 === this.pendingToDeviceBatches.length ? null : this.pendingToDeviceBatches[0]
				}
				removeToDeviceBatch(e) {
					return this.pendingToDeviceBatches = this.pendingToDeviceBatches.filter(t => t.id !== e), Promise.resolve()
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/store/stub.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.StubStore = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js"));
			t.StubStore = class {
				constructor() {
					(0, r.default)(this, "accountData", {}), (0, r.default)(this, "fromToken", null)
				}
				isNewlyCreated() {
					return Promise.resolve(!0)
				}
				getSyncToken() {
					return this.fromToken
				}
				setSyncToken(e) {
					this.fromToken = e
				}
				storeRoom(e) {}
				getRoom(e) {
					return null
				}
				getRooms() {
					return []
				}
				removeRoom(e) {}
				getRoomSummaries() {
					return []
				}
				storeUser(e) {}
				getUser(e) {
					return null
				}
				getUsers() {
					return []
				}
				scrollback(e, t) {
					return []
				}
				storeEvents(e, t, i, n) {}
				storeFilter(e) {}
				getFilter(e, t) {
					return null
				}
				getFilterIdByName(e) {
					return null
				}
				setFilterIdByName(e, t) {}
				storeAccountDataEvents(e) {}
				getAccountData(e) {}
				setSyncData(e) {
					return Promise.resolve()
				}
				wantsSave() {
					return !1
				}
				save() {}
				startup() {
					return Promise.resolve()
				}
				getSavedSync() {
					return Promise.resolve(null)
				}
				getSavedSyncToken() {
					return Promise.resolve(null)
				}
				deleteAllData() {
					return Promise.resolve()
				}
				getOutOfBandMembers() {
					return Promise.resolve(null)
				}
				setOutOfBandMembers(e, t) {
					return Promise.resolve()
				}
				clearOutOfBandMembers() {
					return Promise.resolve()
				}
				getClientOptions() {
					return Promise.resolve(void 0)
				}
				storeClientOptions(e) {
					return Promise.resolve()
				}
				async getPendingEvents(e) {
					return []
				}
				setPendingEvents(e, t) {
					return Promise.resolve()
				}
				async saveToDeviceBatches(e) {
					return Promise.resolve()
				}
				getOldestToDeviceBatch() {
					return Promise.resolve(null)
				}
				async removeToDeviceBatch(e) {
					return Promise.resolve()
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/sync-accumulator.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.SyncAccumulator = t.Category = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = i("./node_modules/matrix-js-sdk/lib/utils.js"),
				a = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				d = i("./node_modules/matrix-js-sdk/lib/@types/sync.js");
			let l;
			t.Category = l,
				function(e) {
					e.Invite = "invite", e.Leave = "leave", e.Join = "join"
				}(l || (t.Category = l = {}));

			function c(e, t) {
				null !== t.state_key && void 0 !== t.state_key && t.type && (e[t.type] || (e[t.type] = Object.create(null)), e[t.type][t.state_key] = t)
			}
			t.SyncAccumulator = class {
				constructor(e = {}) {
					this.opts = e, (0, r.default)(this, "accountData", {}), (0, r.default)(this, "inviteRooms", {}), (0, r.default)(this, "joinRooms", {}), (0, r.default)(this, "nextBatch", null), this.opts.maxTimelineEntries = this.opts.maxTimelineEntries || 50
				}
				accumulate(e, t = !1) {
					this.accumulateRooms(e, t), this.accumulateAccountData(e), this.nextBatch = e.next_batch
				}
				accumulateAccountData(e) {
					e.account_data && e.account_data.events && e.account_data.events.forEach(e => {
						this.accountData[e.type] = e
					})
				}
				accumulateRooms(e, t = !1) {
					e.rooms && (e.rooms.invite && Object.keys(e.rooms.invite).forEach(i => {
						this.accumulateRoom(i, l.Invite, e.rooms.invite[i], t)
					}), e.rooms.join && Object.keys(e.rooms.join).forEach(i => {
						this.accumulateRoom(i, l.Join, e.rooms.join[i], t)
					}), e.rooms.leave && Object.keys(e.rooms.leave).forEach(i => {
						this.accumulateRoom(i, l.Leave, e.rooms.leave[i], t)
					}))
				}
				accumulateRoom(e, t, i, n = !1) {
					switch (t) {
						case l.Invite:
							this.accumulateInviteState(e, i);
							break;
						case l.Join:
							this.inviteRooms[e] && delete this.inviteRooms[e], this.accumulateJoinState(e, i, n);
							break;
						case l.Leave:
							this.inviteRooms[e] ? delete this.inviteRooms[e] : delete this.joinRooms[e];
							break;
						default:
							s.logger.error("Unknown cateogory: ", t)
					}
				}
				accumulateInviteState(e, t) {
					if (!t.invite_state || !t.invite_state.events) return;
					if (!this.inviteRooms[e]) return void(this.inviteRooms[e] = {
						invite_state: t.invite_state
					});
					const i = this.inviteRooms[e];
					t.invite_state.events.forEach(e => {
						let t = !1;
						for (let n = 0; n < i.invite_state.events.length; n++) {
							const r = i.invite_state.events[n];
							r.type === e.type && r.state_key == e.state_key && (i.invite_state.events[n] = e, t = !0)
						}
						t || i.invite_state.events.push(e)
					})
				}
				accumulateJoinState(e, t, i = !1) {
					var n, r, s, l;
					this.joinRooms[e] || (this.joinRooms[e] = {
						_currentState: Object.create(null),
						_timeline: [],
						_accountData: Object.create(null),
						_unreadNotifications: {},
						_unreadThreadNotifications: {},
						_summary: {},
						_readReceipts: {}
					});
					const u = this.joinRooms[e];
					if (t.account_data && t.account_data.events && t.account_data.events.forEach(e => {
							u._accountData[e.type] = e
						}), t.unread_notifications && (u._unreadNotifications = t.unread_notifications), u._unreadThreadNotifications = null !== (n = null !== (r = t[d.UNREAD_THREAD_NOTIFICATIONS.stable]) && void 0 !== r ? r : t[d.UNREAD_THREAD_NOTIFICATIONS.unstable]) && void 0 !== n ? n : void 0, t.summary) {
						const e = "m.heroes",
							i = "m.invited_member_count",
							n = "m.joined_member_count",
							r = u._summary,
							s = t.summary;
						r[e] = s[e] || r[e], r[n] = s[n] || r[n], r[i] = s[i] || r[i]
					}
					if (null === (s = t.ephemeral) || void 0 === s || null === (l = s.events) || void 0 === l || l.forEach(e => {
							e.type === a.EventType.Receipt && e.content && Object.keys(e.content).forEach(t => {
								Object.entries(e.content[t]).forEach(([i, n]) => {
									(0, o.isSupportedReceiptType)(i) && Object.keys(n).forEach(n => {
										u._readReceipts[n] = {
											data: e.content[t][i][n],
											type: i,
											eventId: t
										}
									})
								})
							})
						}), t.timeline && t.timeline.limited && (u._timeline = []), t.state && t.state.events && t.state.events.forEach(e => {
							c(u._currentState, e)
						}), t.timeline && t.timeline.events && t.timeline.events.forEach((e, n) => {
							var r;
							let s;
							if (c(u._currentState, e), i) s = e;
							else {
								void 0 !== (s = Object.assign({}, e)).unsigned && (s.unsigned = Object.assign({}, s.unsigned));
								const t = e.unsigned ? e.unsigned.age : e.age;
								void 0 !== t && (s._localTs = Date.now() - t)
							}
							u._timeline.push({
								event: s,
								token: 0 === n && null !== (r = t.timeline.prev_batch) && void 0 !== r ? r : null
							})
						}), u._timeline.length > this.opts.maxTimelineEntries) {
						for (let e = u._timeline.length - this.opts.maxTimelineEntries; e < u._timeline.length; e++)
							if (u._timeline[e].token) {
								u._timeline = u._timeline.slice(e, u._timeline.length);
								break
							}
					}
				}
				getJSON(e = !1) {
					const t = {
						join: {},
						invite: {},
						leave: {}
					};
					Object.keys(this.inviteRooms).forEach(e => {
						t.invite[e] = this.inviteRooms[e]
					}), Object.keys(this.joinRooms).forEach(i => {
						const n = this.joinRooms[i],
							r = {
								ephemeral: {
									events: []
								},
								account_data: {
									events: []
								},
								state: {
									events: []
								},
								timeline: {
									events: [],
									prev_batch: null
								},
								unread_notifications: n._unreadNotifications,
								unread_thread_notifications: n._unreadThreadNotifications,
								summary: n._summary
							};
						Object.keys(n._accountData).forEach(e => {
							r.account_data.events.push(n._accountData[e])
						});
						const s = {
							type: a.EventType.Receipt,
							room_id: i,
							content: {}
						};
						Object.keys(n._readReceipts).forEach(e => {
							const t = n._readReceipts[e];
							s.content[t.eventId] || (s.content[t.eventId] = {}), s.content[t.eventId][t.type] || (s.content[t.eventId][t.type] = {}), s.content[t.eventId][t.type][e] = t.data
						}), Object.keys(s.content).length > 0 && r.ephemeral.events.push(s), n._timeline.forEach(t => {
							if (!r.timeline.prev_batch) {
								if (!t.token) return;
								r.timeline.prev_batch = t.token
							}
							let i;
							!e && t.event._localTs ? (void 0 !== (i = Object.assign({}, t.event)).unsigned && (i.unsigned = Object.assign({}, i.unsigned)), delete i._localTs, i.unsigned = i.unsigned || {}, i.unsigned.age = Date.now() - t.event._localTs) : i = t.event, r.timeline.events.push(i)
						});
						const d = Object.create(null);
						for (let e = r.timeline.events.length - 1; e >= 0; e--) {
							const t = r.timeline.events[e];
							if (null === t.state_key || void 0 === t.state_key) continue;
							const i = (0, o.deepCopy)(t);
							i.unsigned && (i.unsigned.prev_content && (i.content = i.unsigned.prev_content), i.unsigned.prev_sender && (i.sender = i.unsigned.prev_sender)), c(d, i)
						}
						Object.keys(n._currentState).forEach(e => {
							Object.keys(n._currentState[e]).forEach(t => {
								let i = n._currentState[e][t];
								d[e] && d[e][t] && (i = d[e][t]), r.state.events.push(i)
							})
						}), t.join[i] = r
					});
					const i = [];
					return Object.keys(this.accountData).forEach(e => {
						i.push(this.accountData[e])
					}), {
						nextBatch: this.nextBatch,
						roomsData: t,
						accountData: i
					}
				}
				getNextBatchToken() {
					return this.nextBatch
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/sync.js": function(e, t, i) {
			"use strict";
			(function(e) {
				var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.SyncState = t.SyncApi = void 0, t._createAndReEmitRoom = x;
				var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
					s = i("./node_modules/matrix-js-sdk/lib/models/user.js"),
					o = i("./node_modules/matrix-js-sdk/lib/models/room.js"),
					a = function(e, t) {
						if (!t && e && e.__esModule) return e;
						if (null === e || "object" != typeof e && "function" != typeof e) return {
							default: e
						};
						var i = S(t);
						if (i && i.has(e)) return i.get(e);
						var n = {},
							r = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var s in e)
							if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
								var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
								o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
							} n.default = e, i && i.set(e, n);
						return n
					}(i("./node_modules/matrix-js-sdk/lib/utils.js")),
					d = i("./node_modules/matrix-js-sdk/lib/filter.js"),
					l = i("./node_modules/matrix-js-sdk/lib/models/event-timeline.js"),
					c = i("./node_modules/matrix-js-sdk/lib/pushprocessor.js"),
					u = i("./node_modules/matrix-js-sdk/lib/logger.js"),
					h = i("./node_modules/matrix-js-sdk/lib/errors.js"),
					m = i("./node_modules/matrix-js-sdk/lib/client.js"),
					p = i("./node_modules/matrix-js-sdk/lib/http-api/index.js"),
					g = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
					f = i("./node_modules/matrix-js-sdk/lib/models/room-state.js"),
					v = i("./node_modules/matrix-js-sdk/lib/models/room-member.js"),
					y = i("./node_modules/matrix-js-sdk/lib/models/beacon.js"),
					b = i("./node_modules/matrix-js-sdk/lib/@types/sync.js"),
					_ = i("./node_modules/matrix-js-sdk/lib/feature.js");

				function S(e) {
					if ("function" != typeof WeakMap) return null;
					var t = new WeakMap,
						i = new WeakMap;
					return (S = function(e) {
						return e ? i : t
					})(e)
				}
				const E = !0,
					w = 8e4,
					k = 3;
				let T;
				t.SyncState = T,
					function(e) {
						e.Error = "ERROR", e.Prepared = "PREPARED", e.Stopped = "STOPPED", e.Syncing = "SYNCING", e.Catchup = "CATCHUP", e.Reconnecting = "RECONNECTING"
					}(T || (t.SyncState = T = {}));
				const I = ["org.matrix.msc2716v3"];

				function C(e, t) {
					return `FILTER_SYNC_${e}` + (t ? "_" + t : "")
				}

				function R(...e) {
					E && u.logger.log(...e)
				}
				var j;
				! function(e) {
					e.Offline = "offline", e.Online = "online", e.Unavailable = "unavailable"
				}(j || (j = {}));

				function O(e, t) {
					const i = new s.User(t);
					return e.reEmitter.reEmit(i, [s.UserEvent.AvatarUrl, s.UserEvent.DisplayName, s.UserEvent.Presence, s.UserEvent.CurrentlyActive, s.UserEvent.LastPresenceTs]), i
				}

				function x(e, t, i) {
					const {
						timelineSupport: n
					} = e, r = new o.Room(t, e, e.getUserId(), {
						lazyLoadMembers: i.lazyLoadMembers,
						pendingEventOrdering: i.pendingEventOrdering,
						timelineSupport: n
					});
					return e.reEmitter.reEmit(r, [o.RoomEvent.Name, o.RoomEvent.Redaction, o.RoomEvent.RedactionCancelled, o.RoomEvent.Receipt, o.RoomEvent.Tags, o.RoomEvent.LocalEchoUpdated, o.RoomEvent.AccountData, o.RoomEvent.MyMembership, o.RoomEvent.Timeline, o.RoomEvent.TimelineReset, f.RoomStateEvent.Events, f.RoomStateEvent.Members, f.RoomStateEvent.NewMember, f.RoomStateEvent.Update, y.BeaconEvent.New, y.BeaconEvent.Update, y.BeaconEvent.Destroy, y.BeaconEvent.LivenessChange]), r.on(f.RoomStateEvent.NewMember, (t, i, n) => {
						var r;
						n.user = null !== (r = e.getUser(n.userId)) && void 0 !== r ? r : void 0, e.reEmitter.reEmit(n, [v.RoomMemberEvent.Name, v.RoomMemberEvent.Typing, v.RoomMemberEvent.PowerLevel, v.RoomMemberEvent.Membership])
					}), r
				}
				t.SyncApi = class {
					constructor(e, t = {}) {
						var i;
						this.client = e, this.opts = t, (0, r.default)(this, "_peekRoom", null), (0, r.default)(this, "currentSyncRequest", void 0), (0, r.default)(this, "abortController", void 0), (0, r.default)(this, "syncState", null), (0, r.default)(this, "syncStateData", void 0), (0, r.default)(this, "catchingUp", !1), (0, r.default)(this, "running", !1), (0, r.default)(this, "keepAliveTimer", void 0), (0, r.default)(this, "connectionReturnedDefer", void 0), (0, r.default)(this, "notifEvents", []), (0, r.default)(this, "failedSyncCount", 0), (0, r.default)(this, "storeIsInvalid", !1), (0, r.default)(this, "getPushRules", async () => {
							try {
								R("Getting push rules...");
								const e = await this.client.getPushRules();
								R("Got push rules"), this.client.pushRules = e
							} catch (e) {
								if (u.logger.error("Getting push rules failed", e), this.shouldAbortSync(e)) return;
								return R("Waiting for saved sync before retrying push rules..."), await this.recoverFromSyncStartupError(this.savedSyncPromise, e), this.getPushRules()
							}
						}), (0, r.default)(this, "buildDefaultFilter", () => {
							const e = new d.Filter(this.client.credentials.userId);
							return this.client.canSupport.get(_.Feature.ThreadUnreadNotifications) !== _.ServerSupport.Unsupported && e.setUnreadThreadNotifications(!0), e
						}), (0, r.default)(this, "checkLazyLoadStatus", async () => {
							if (R("Checking lazy load status..."), this.opts.lazyLoadMembers && this.client.isGuest() && (this.opts.lazyLoadMembers = !1), this.opts.lazyLoadMembers) {
								R("Checking server lazy load support..."), await this.client.doesServerSupportLazyLoading() ? (R("Enabling lazy load on sync filter..."), this.opts.filter || (this.opts.filter = this.buildDefaultFilter()), this.opts.filter.setLazyLoadMembers(!0)) : (R("LL: lazy loading requested but not supported by server, so disabling"), this.opts.lazyLoadMembers = !1)
							}
							if (R("Checking whether lazy loading has changed in store..."), await this.wasLazyLoadingToggled(this.opts.lazyLoadMembers)) {
								this.storeIsInvalid = !0;
								const e = new h.InvalidStoreError(h.InvalidStoreState.ToggledLazyLoading, !!this.opts.lazyLoadMembers);
								return this.updateSyncState(T.Error, {
									error: e
								}), void u.logger.warn("InvalidStoreError: store is not usable: stopping sync.")
							}
							var e;
							this.opts.lazyLoadMembers && (null === (e = this.opts.crypto) || void 0 === e || e.enableLazyLoading());
							try {
								R("Storing client options..."), await this.client.storeClientOptions(), R("Stored client options")
							} catch (t) {
								throw u.logger.error("Storing client options failed", t), t
							}
						}), (0, r.default)(this, "getFilter", async () => {
							let e, t;
							R("Getting filter..."), e = this.opts.filter ? this.opts.filter : this.buildDefaultFilter();
							try {
								t = await this.client.getOrCreateFilter(C(this.client.credentials.userId), e)
							} catch (i) {
								return u.logger.error("Getting filter failed", i), this.shouldAbortSync(i) ? {} : (R("Waiting for saved sync before retrying filter..."), await this.recoverFromSyncStartupError(this.savedSyncPromise, i), this.getFilter())
							}
							return {
								filter: e,
								filterId: t
							}
						}), (0, r.default)(this, "savedSyncPromise", void 0), (0, r.default)(this, "onOnline", () => {
							R("Browser thinks we are back online"), this.startKeepAlives(0)
						}), this.opts.initialSyncLimit = null !== (i = this.opts.initialSyncLimit) && void 0 !== i ? i : 8, this.opts.resolveInvitesToProfiles = this.opts.resolveInvitesToProfiles || !1, this.opts.pollTimeout = this.opts.pollTimeout || 3e4, this.opts.pendingEventOrdering = this.opts.pendingEventOrdering || m.PendingEventOrdering.Chronological, this.opts.experimentalThreadSupport = !0 === this.opts.experimentalThreadSupport, t.canResetEntireTimeline || (t.canResetEntireTimeline = e => !1), e.getNotifTimelineSet() && e.reEmitter.reEmit(e.getNotifTimelineSet(), [o.RoomEvent.Timeline, o.RoomEvent.TimelineReset])
					}
					createRoom(e) {
						const t = x(this.client, e, this.opts);
						return t.on(f.RoomStateEvent.Marker, (e, i) => {
							this.onMarkerStateEvent(t, e, i)
						}), t
					}
					onMarkerStateEvent(e, t, {
						timelineWasEmpty: i
					} = {}) {
						if (i) return void u.logger.debug(`MarkerState: Ignoring markerEventId=${t.getId()} in roomId=${e.roomId} ` + "because the timeline was empty before the marker arrived which means there is nothing to refresh.");
						I.includes(e.getVersion()) || t.getSender() === e.getCreator() ? (u.logger.debug("MarkerState: Timeline needs to be refreshed because " + `a new markerEventId=${t.getId()} was sent in roomId=${e.roomId}`), e.setTimelineNeedsRefresh(!0), e.emit(o.RoomEvent.HistoryImportedWithinTimeline, t, e)) : u.logger.debug(`MarkerState: Ignoring markerEventId=${t.getId()} in roomId=${e.roomId} because ` + "MSC2716 is not supported in the room version or for any room version, the marker wasn't sent by the room creator.")
					}
					async syncLeftRooms() {
						var e;
						const t = this.client,
							i = new d.Filter(this.client.credentials.userId);
						i.setTimelineLimit(1), i.setIncludeLeaveRooms(!0);
						const n = this.opts.pollTimeout + w,
							r = {
								timeout: 0,
								filter: await t.getOrCreateFilter(C(t.credentials.userId, "LEFT_ROOMS"), i)
							},
							s = await t.http.authedRequest(p.Method.Get, "/sync", r, void 0, {
								localTimeoutMs: n
							});
						let o = [];
						return null !== (e = s.rooms) && void 0 !== e && e.leave && (o = this.mapSyncResponseToRoomArray(s.rooms.leave)), (await Promise.all(o.map(async e => {
							const i = e.room;
							if (!e.isBrandNewRoom) return;
							e.timeline = e.timeline || {
								prev_batch: null,
								events: []
							};
							const n = this.mapSyncEventsFormat(e.timeline, i),
								r = this.mapSyncEventsFormat(e.state, i);
							return i.getLiveTimeline().setPaginationToken(e.timeline.prev_batch, l.EventTimeline.BACKWARDS), await this.injectRoomEvents(i, r, n), i.recalculate(), t.store.storeRoom(i), t.emit(m.ClientEvent.Room, i), this.processEventsForNotifs(i, n), i
						}))).filter(Boolean)
					}
					peek(e) {
						var t;
						if ((null === (t = this._peekRoom) || void 0 === t ? void 0 : t.roomId) === e) return Promise.resolve(this._peekRoom);
						const i = this.client;
						return this._peekRoom = this.createRoom(e), this.client.roomInitialSync(e, 20).then(e => {
							e.messages = e.messages || {
								chunk: []
							}, e.messages.chunk = e.messages.chunk || [], e.state = e.state || [];
							const t = a.deepCopy(e.state).map(i.getEventMapper()),
								n = e.state.map(i.getEventMapper()),
								r = e.messages.chunk.map(i.getEventMapper());
							return Array.isArray(e.presence) && e.presence.map(i.getEventMapper()).forEach((function(e) {
								let t = i.store.getUser(e.getContent().user_id);
								t ? t.setPresenceEvent(e) : ((t = O(i, e.getContent().user_id)).setPresenceEvent(e), i.store.storeUser(t)), i.emit(m.ClientEvent.Event, e)
							})), e.messages.start && (this._peekRoom.oldState.paginationToken = e.messages.start), this._peekRoom.oldState.setStateEvents(t), this._peekRoom.currentState.setStateEvents(n), this.resolveInvites(this._peekRoom), this._peekRoom.recalculate(), this._peekRoom.addEventsToTimeline(r.reverse(), !0, this._peekRoom.getLiveTimeline(), e.messages.start), i.store.storeRoom(this._peekRoom), i.emit(m.ClientEvent.Room, this._peekRoom), this.peekPoll(this._peekRoom), this._peekRoom
						})
					}
					stopPeeking() {
						this._peekRoom = null
					}
					peekPoll(e, t) {
						var i;
						this._peekRoom === e ? this.client.http.authedRequest(p.Method.Get, "/events", {
							room_id: e.roomId,
							timeout: String(3e4),
							from: t
						}, void 0, {
							localTimeoutMs: 5e4,
							abortSignal: null === (i = this.abortController) || void 0 === i ? void 0 : i.signal
						}).then(t => {
							if (this._peekRoom !== e) return void R("Stopped peeking in room %s", e.roomId);
							t.chunk.filter((function(e) {
								return "m.presence" === e.type
							})).map(this.client.getEventMapper()).forEach(e => {
								let t = this.client.store.getUser(e.getContent().user_id);
								t ? t.setPresenceEvent(e) : ((t = O(this.client, e.getContent().user_id)).setPresenceEvent(e), this.client.store.storeUser(t)), this.client.emit(m.ClientEvent.Event, e)
							});
							const i = t.chunk.filter((function(t) {
								return t.room_id === e.roomId && t.event_id
							})).map(this.client.getEventMapper());
							e.addLiveEvents(i), this.peekPoll(e, t.end)
						}, i => {
							u.logger.error("[%s] Peek poll failed: %s", e.roomId, i), setTimeout(() => {
								this.peekPoll(e, t)
							}, 3e4)
						}) : R("Stopped peeking in room %s", e.roomId)
					}
					getSyncState() {
						return this.syncState
					}
					getSyncStateData() {
						var e;
						return null !== (e = this.syncStateData) && void 0 !== e ? e : null
					}
					async recoverFromSyncStartupError(e, t) {
						await e;
						const i = this.startKeepAlives();
						this.updateSyncState(T.Error, {
							error: t
						}), await i
					}
					async wasLazyLoadingToggled(e = !1) {
						let t = !1;
						if (!(await this.client.store.isNewlyCreated())) {
							const i = await this.client.store.getClientOptions();
							return i && (t = !!i.lazyLoadMembers), t !== e
						}
						return !1
					}
					shouldAbortSync(e) {
						return "M_UNKNOWN_TOKEN" === e.errcode && (u.logger.warn("Token no longer valid - assuming logout"), this.stop(), this.updateSyncState(T.Error, {
							error: e
						}), !0)
					}
					async sync() {
						var t, i;
						if (this.running = !0, this.abortController = new AbortController, null === (t = e.window) || void 0 === t || null === (i = t.addEventListener) || void 0 === i || i.call(t, "online", this.onOnline, !1), this.client.isGuest()) return this.doSync({});
						R("Getting saved sync token...");
						const n = this.client.store.getSavedSyncToken().then(e => (R("Got saved sync token"), e));
						this.savedSyncPromise = this.client.store.getSavedSync().then(e => {
							if (R(`Got reply from saved sync, exists? ${!!e}`), e) return this.syncFromCache(e)
						}).catch(e => {
							u.logger.error("Getting saved sync failed", e)
						}), await this.getPushRules(), await this.checkLazyLoadStatus();
						const {
							filterId: r,
							filter: s
						} = await this.getFilter();
						if (s) {
							if (this.client.resetNotifTimelineSet(), !this.currentSyncRequest) {
								let e = r;
								const t = await n;
								if (t) R("Sending first sync request...");
								else {
									R("Sending initial sync request...");
									const t = this.buildDefaultFilter();
									t.setDefinition(s.getDefinition()), t.setTimelineLimit(this.opts.initialSyncLimit), e = JSON.stringify(t.getDefinition())
								}
								this.currentSyncRequest = this.doSyncRequest({
									filter: e
								}, t)
							}
							return R("Waiting for saved sync before starting sync processing..."), await this.savedSyncPromise, this.doSync({
								filter: r
							})
						}
					}
					stop() {
						var t, i, n;
						R("SyncApi.stop"), null === (t = e.window) || void 0 === t || null === (i = t.removeEventListener) || void 0 === i || i.call(t, "online", this.onOnline, !1), this.running = !1, null === (n = this.abortController) || void 0 === n || n.abort(), this.keepAliveTimer && (clearTimeout(this.keepAliveTimer), this.keepAliveTimer = void 0)
					}
					retryImmediately() {
						return !!this.connectionReturnedDefer && (this.startKeepAlives(0), !0)
					}
					async syncFromCache(e) {
						R("sync(): not doing HTTP hit, instead returning stored /sync data");
						const t = e.nextBatch;
						this.client.store.setSyncToken(t);
						const i = {
								nextSyncToken: t,
								catchingUp: !1,
								fromCache: !0
							},
							n = {
								next_batch: t,
								rooms: e.roomsData,
								account_data: {
									events: e.accountData
								}
							};
						try {
							await this.processSyncResponse(i, n)
						} catch (r) {
							u.logger.error("Error processing cached sync", r)
						}
						this.storeIsInvalid || this.updateSyncState(T.Prepared, i)
					}
					async doSync(e) {
						for (; this.running;) {
							const i = this.client.store.getSyncToken();
							let n;
							try {
								this.currentSyncRequest || (this.currentSyncRequest = this.doSyncRequest(e, i)), n = await this.currentSyncRequest
							} catch (t) {
								if (await this.onSyncError(t)) return;
								continue
							} finally {
								this.currentSyncRequest = void 0
							}
							this.client.store.setSyncToken(n.next_batch), this.failedSyncCount = 0, await this.client.store.setSyncData(n);
							const r = {
								oldSyncToken: null != i ? i : void 0,
								nextSyncToken: n.next_batch,
								catchingUp: this.catchingUp
							};
							this.opts.crypto && await this.opts.crypto.onSyncWillProcess(r);
							try {
								await this.processSyncResponse(r, n)
							} catch (t) {
								u.logger.error("Caught /sync error", t), this.client.emit(m.ClientEvent.SyncUnexpectedError, t)
							}
							r.catchingUp = this.catchingUp, e.hasSyncedBefore || (this.updateSyncState(T.Prepared, r), e.hasSyncedBefore = !0), this.opts.crypto && await this.opts.crypto.onSyncCompleted(r), this.updateSyncState(T.Syncing, r), this.client.store.wantsSave() && (this.opts.crypto && await this.opts.crypto.saveDeviceList(0), this.client.store.save())
						}
						this.running || (R("Sync no longer running: exiting."), this.connectionReturnedDefer && (this.connectionReturnedDefer.reject(), this.connectionReturnedDefer = void 0), this.updateSyncState(T.Stopped))
					}
					doSyncRequest(e, t) {
						var i;
						const n = this.getSyncParams(e, t);
						return this.client.http.authedRequest(p.Method.Get, "/sync", n, void 0, {
							localTimeoutMs: n.timeout + w,
							abortSignal: null === (i = this.abortController) || void 0 === i ? void 0 : i.signal
						})
					}
					getSyncParams(e, t) {
						let i = this.opts.pollTimeout;
						(this.getSyncState() !== T.Syncing || this.catchingUp) && (this.catchingUp = !0, i = 0);
						let n = e.filter;
						this.client.isGuest() && !n && (n = this.getGuestFilter());
						const r = {
							filter: n,
							timeout: i
						};
						return this.opts.disablePresence && (r.set_presence = j.Offline), t ? r.since = t : r._cacheBuster = Date.now(), [T.Reconnecting, T.Error].includes(this.getSyncState()) && (r.timeout = 0), r
					}
					async onSyncError(e) {
						if (!this.running) return R("Sync no longer running: exiting"), this.connectionReturnedDefer && (this.connectionReturnedDefer.reject(), this.connectionReturnedDefer = void 0), this.updateSyncState(T.Stopped), !0;
						if (u.logger.error("/sync error %s", e), this.shouldAbortSync(e)) return !0;
						this.failedSyncCount++, u.logger.log("Number of consecutive failed sync requests:", this.failedSyncCount), R("Starting keep-alive");
						const t = this.startKeepAlives();
						return this.currentSyncRequest = void 0, this.updateSyncState(this.failedSyncCount >= k ? T.Error : T.Reconnecting, {
							error: e
						}), await t && this.getSyncState() === T.Error && this.updateSyncState(T.Catchup, {
							catchingUp: !0
						}), !1
					}
					async processSyncResponse(e, t) {
						var i, n, r;
						const s = this.client;
						if (Array.isArray(null === (i = t.presence) || void 0 === i ? void 0 : i.events) && t.presence.events.map(s.getEventMapper()).forEach((function(e) {
								let t = s.store.getUser(e.getSender());
								t ? t.setPresenceEvent(e) : ((t = O(s, e.getSender())).setPresenceEvent(e), s.store.storeUser(t)), s.emit(m.ClientEvent.Event, e)
							})), Array.isArray(null === (n = t.account_data) || void 0 === n ? void 0 : n.events)) {
							const e = t.account_data.events.map(s.getEventMapper()),
								i = e.reduce((e, t) => (e[t.getType()] = s.store.getAccountData(t.getType()), e), {});
							s.store.storeAccountDataEvents(e), e.forEach((function(e) {
								if (e.getType() === g.EventType.PushRules) {
									const t = e.getContent();
									s.pushRules = c.PushProcessor.rewriteDefaultRules(t)
								}
								const t = i[e.getType()];
								return s.emit(m.ClientEvent.AccountData, e, t), e
							}))
						}
						if (Array.isArray(null === (r = t.to_device) || void 0 === r ? void 0 : r.events) && t.to_device.events.length > 0) {
							const e = [];
							t.to_device.events.filter(e => {
								var t;
								return !(e.type === g.EventType.RoomMessageEncrypted && !["m.olm.v1.curve25519-aes-sha2"].includes(null === (t = e.content) || void 0 === t ? void 0 : t.algorithm)) || (u.logger.log("Ignoring invalid encrypted to-device event from " + e.sender), !1)
							}).map(s.getEventMapper({
								toDevice: !0
							})).map(t => {
								if ("m.key.verification.cancel" === t.getType()) {
									const i = t.getContent().transaction_id;
									i && e.push(i)
								}
								return t
							}).forEach((function(t) {
								const i = t.getContent();
								if ("m.room.message" != t.getType() || "m.bad.encrypted" != i.msgtype) {
									if ("m.key.verification.start" === t.getType() || "m.key.verification.request" === t.getType()) {
										const n = i.transaction_id;
										e.includes(n) && t.flagCancelled()
									}
									s.emit(m.ClientEvent.ToDeviceEvent, t)
								} else u.logger.log("Ignoring undecryptable to-device event from " + t.getSender())
							}))
						} else this.catchingUp = !1;
						let d = [],
							h = [],
							p = [];
						if (t.rooms && (t.rooms.invite && (d = this.mapSyncResponseToRoomArray(t.rooms.invite)), t.rooms.join && (h = this.mapSyncResponseToRoomArray(t.rooms.join)), t.rooms.leave && (p = this.mapSyncResponseToRoomArray(t.rooms.leave))), this.notifEvents = [], await a.promiseMapSeries(d, async e => {
								var t;
								const i = e.room,
									n = this.mapSyncEventsFormat(e.invite_state, i);
								await this.injectRoomEvents(i, n);
								const r = null === (t = i.currentState.getStateEvents(g.EventType.RoomMember, s.getUserId())) || void 0 === t ? void 0 : t.getSender();
								if (s.isCryptoEnabled()) {
									const e = await s.crypto.cryptoStore.takeParkedSharedHistory(i.roomId);
									for (const t of e) t.senderId === r && await s.crypto.olmDevice.addInboundGroupSession(i.roomId, t.senderKey, t.forwardingCurve25519KeyChain, t.sessionId, t.sessionKey, t.keysClaimed, !0, {
										sharedHistory: !0,
										untrusted: !0
									})
								}
								e.isBrandNewRoom ? (i.recalculate(), s.store.storeRoom(i), s.emit(m.ClientEvent.Room, i)) : i.recalculate(), n.forEach((function(e) {
									s.emit(m.ClientEvent.Event, e)
								}))
							}), await a.promiseMapSeries(h, async t => {
								var i;
								const n = t.room,
									r = this.mapSyncEventsFormat(t.state, n),
									d = this.mapSyncEventsFormat(t.timeline, n, !1),
									c = this.mapSyncEventsFormat(t.ephemeral),
									h = this.mapSyncEventsFormat(t.account_data),
									p = s.isRoomEncrypted(n.roomId);
								var g, f;
								t.unread_notifications && (n.setUnreadNotificationCount(o.NotificationCountType.Total, null !== (g = t.unread_notifications.notification_count) && void 0 !== g ? g : 0), (!p || n.getUnreadNotificationCount(o.NotificationCountType.Highlight) <= 0) && n.setUnreadNotificationCount(o.NotificationCountType.Highlight, null !== (f = t.unread_notifications.highlight_count) && void 0 !== f ? f : 0));
								const v = null !== (i = t[b.UNREAD_THREAD_NOTIFICATIONS.name]) && void 0 !== i ? i : t[b.UNREAD_THREAD_NOTIFICATIONS.altName];
								if (v) {
									n.resetThreadUnreadNotificationCount(Object.keys(v));
									for (const [e, t] of Object.entries(v)) {
										var y;
										n.setThreadUnreadNotificationCount(e, o.NotificationCountType.Total, null !== (y = t.notification_count) && void 0 !== y ? y : 0);
										const i = n.getThreadUnreadNotificationCount(e, o.NotificationCountType.Highlight) <= 0;
										var _;
										if (!p || p && i) n.setThreadUnreadNotificationCount(e, o.NotificationCountType.Highlight, null !== (_ = t.highlight_count) && void 0 !== _ ? _ : 0)
									}
								} else n.resetThreadUnreadNotificationCount();
								if (t.timeline = t.timeline || {}, t.isBrandNewRoom) null !== t.timeline.prev_batch && n.getLiveTimeline().setPaginationToken(t.timeline.prev_batch, l.EventTimeline.BACKWARDS);
								else if (t.timeline.limited) {
									let i = !0;
									for (let e = d.length - 1; e >= 0; e--) {
										const t = d[e].getId();
										if (n.getTimelineForEvent(t)) {
											R(`Already have event ${t} in limited sync - not resetting`), i = !1, d.splice(0, e);
											break
										}
									}
									var S;
									if (i) n.resetLiveTimeline(t.timeline.prev_batch, this.opts.canResetEntireTimeline(n.roomId) ? null : null !== (S = e.oldSyncToken) && void 0 !== S ? S : null), s.resetNotifTimelineSet()
								}
								try {
									await this.injectRoomEvents(n, r, d, e.fromCache)
								} catch (w) {
									u.logger.error(`Failed to process events on room ${n.roomId}:`, w)
								}
								t.summary && n.setSummary(t.summary), n.addEphemeralEvents(c), n.addAccountData(h), n.recalculate(), t.isBrandNewRoom && (s.store.storeRoom(n), s.emit(m.ClientEvent.Room, n)), this.processEventsForNotifs(n, d);
								const E = async e => {
									s.emit(m.ClientEvent.Event, e), e.isState() && "m.room.encryption" == e.getType() && this.opts.crypto && await this.opts.crypto.onCryptoEvent(e)
								};
								await a.promiseMapSeries(r, E), await a.promiseMapSeries(d, E), c.forEach((function(e) {
									s.emit(m.ClientEvent.Event, e)
								})), h.forEach((function(e) {
									s.emit(m.ClientEvent.Event, e)
								})), n.decryptCriticalEvents()
							}), await a.promiseMapSeries(p, async e => {
								const t = e.room,
									i = this.mapSyncEventsFormat(e.state, t),
									n = this.mapSyncEventsFormat(e.timeline, t),
									r = this.mapSyncEventsFormat(e.account_data);
								await this.injectRoomEvents(t, i, n), t.addAccountData(r), t.recalculate(), e.isBrandNewRoom && (s.store.storeRoom(t), s.emit(m.ClientEvent.Room, t)), this.processEventsForNotifs(t, n), i.forEach((function(e) {
									s.emit(m.ClientEvent.Event, e)
								})), n.forEach((function(e) {
									s.emit(m.ClientEvent.Event, e)
								})), r.forEach((function(e) {
									s.emit(m.ClientEvent.Event, e)
								}))
							}), e.oldSyncToken && this.notifEvents.length && (this.notifEvents.sort((function(e, t) {
								return e.getTs() - t.getTs()
							})), this.notifEvents.forEach((function(e) {
								var t;
								null === (t = s.getNotifTimelineSet()) || void 0 === t || t.addLiveEvent(e)
							}))), t.device_lists && this.opts.crypto && await this.opts.crypto.handleDeviceListChanges(e, t.device_lists), this.opts.crypto && t.device_one_time_keys_count) {
							const e = t.device_one_time_keys_count.signed_curve25519 || 0;
							this.opts.crypto.updateOneTimeKeyCount(e)
						}
						if (this.opts.crypto && (t.device_unused_fallback_key_types || t["org.matrix.msc2732.device_unused_fallback_key_types"])) {
							const e = t.device_unused_fallback_key_types || t["org.matrix.msc2732.device_unused_fallback_key_types"];
							this.opts.crypto.setNeedsNewFallback(Array.isArray(e) && !e.includes("signed_curve25519"))
						}
					}
					startKeepAlives(e) {
						return void 0 === e && (e = 2e3 + Math.floor(5e3 * Math.random())), null !== this.keepAliveTimer && clearTimeout(this.keepAliveTimer), e > 0 ? this.keepAliveTimer = setTimeout(this.pokeKeepAlive.bind(this), e) : this.pokeKeepAlive(), this.connectionReturnedDefer || (this.connectionReturnedDefer = a.defer()), this.connectionReturnedDefer.promise
					}
					pokeKeepAlive(e = !1) {
						var t;
						const i = () => {
							clearTimeout(this.keepAliveTimer), this.connectionReturnedDefer && (this.connectionReturnedDefer.resolve(e), this.connectionReturnedDefer = void 0)
						};
						this.client.http.request(p.Method.Get, "/_matrix/client/versions", void 0, void 0, {
							prefix: "",
							localTimeoutMs: 15e3,
							abortSignal: null === (t = this.abortController) || void 0 === t ? void 0 : t.signal
						}).then(() => {
							i()
						}, t => {
							400 == t.httpStatus || 404 == t.httpStatus ? this.keepAliveTimer = setTimeout(i, 2e3) : (e = !0, this.keepAliveTimer = setTimeout(this.pokeKeepAlive.bind(this, e), 5e3 + Math.floor(5e3 * Math.random())), this.updateSyncState(T.Error, {
								error: t
							}))
						})
					}
					mapSyncResponseToRoomArray(e) {
						const t = this.client;
						return Object.keys(e).map(i => {
							const n = e[i];
							let r = t.store.getRoom(i),
								s = !1;
							return r || (r = this.createRoom(i), s = !0), n.room = r, n.isBrandNewRoom = s, n
						})
					}
					mapSyncEventsFormat(e, t, i = !0) {
						if (!e || !Array.isArray(e.events)) return [];
						const n = this.client.getEventMapper({
							decrypt: i
						});
						return e.events.map((function(e) {
							return t && (e.room_id = t.roomId), n(e)
						}))
					}
					resolveInvites(e) {
						if (!e || !this.opts.resolveInvitesToProfiles) return;
						const t = this.client;
						e.getMembersWithMembership("invite").forEach((function(i) {
							if (i.requestedProfileInfo) return;
							i.requestedProfileInfo = !0;
							const n = t.getUser(i.userId);
							let r;
							(r = n ? Promise.resolve({
								avatar_url: n.avatarUrl,
								displayname: n.displayName
							}) : t.getProfileInfo(i.userId)).then((function(t) {
								const n = i.events.member;
								"invite" === (null == n ? void 0 : n.getContent().membership) && (n.getContent().avatar_url = t.avatar_url, n.getContent().displayname = t.displayname, i.setMembershipEvent(n, e.currentState))
							}), (function(e) {}))
						}))
					}
					async injectRoomEvents(e, t, i, n = !1) {
						const r = e.getLiveTimeline(),
							s = 0 == r.getEvents().length;
						if (s) {
							for (const e of t) this.client.getPushActionsForEvent(e);
							r.initialiseState(t, {
								timelineWasEmpty: s
							})
						}
						this.resolveInvites(e), e.recalculate(), s || (e.oldState.setStateEvents(t || []), e.currentState.setStateEvents(t || [])), e.addLiveEvents(i || [], {
							fromCache: n,
							timelineWasEmpty: s
						}), this.client.processBeaconEvents(e, i)
					}
					processEventsForNotifs(e, t) {
						if (this.client.getNotifTimelineSet())
							for (const n of t) {
								var i;
								const e = this.client.getPushActionsForEvent(n);
								null != e && e.notify && null !== (i = e.tweaks) && void 0 !== i && i.highlight && this.notifEvents.push(n)
							}
					}
					getGuestFilter() {
						return "{}"
					}
					updateSyncState(e, t) {
						const i = this.syncState;
						this.syncState = e, this.syncStateData = t, this.client.emit(m.ClientEvent.Sync, this.syncState, i, t)
					}
				}
			}).call(this, i("./node_modules/webpack/buildin/global.js"))
		},
		"./node_modules/matrix-js-sdk/lib/timeline-window.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.TimelineWindow = t.TimelineIndex = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/models/event-timeline.js");
			i("./node_modules/matrix-js-sdk/lib/logger.js");
			const o = function() {},
				a = 5;
			t.TimelineWindow = class {
				constructor(e, t, i = {}) {
					this.client = e, this.timelineSet = t, (0, r.default)(this, "windowLimit", void 0), (0, r.default)(this, "start", void 0), (0, r.default)(this, "end", void 0), (0, r.default)(this, "eventCount", 0), this.windowLimit = i.windowLimit || 1e3
				}
				load(e, t = 20) {
					const i = i => {
						if (!i) throw new Error("No timeline given to initFields");
						let n;
						const r = i.getEvents();
						if (e) {
							if ((n = r.findIndex(t => t.getId() === e)) < 0) throw new Error("getEventTimeline result didn't include requested event")
						} else n = r.length;
						const s = Math.min(r.length, n + Math.ceil(t / 2)),
							o = Math.max(0, s - t);
						this.start = new d(i, o - i.getBaseIndex()), this.end = new d(i, s - i.getBaseIndex()), this.eventCount = s - o
					};
					return this.timelineSet.getTimelineForEvent(e) ? (i(this.timelineSet.getTimelineForEvent(e)), Promise.resolve()) : e ? this.client.getEventTimeline(this.timelineSet, e).then(i) : (i(this.timelineSet.getLiveTimeline()), Promise.resolve())
				}
				getTimelineIndex(e) {
					var t, i;
					if (e == s.EventTimeline.BACKWARDS) return null !== (t = this.start) && void 0 !== t ? t : null;
					if (e == s.EventTimeline.FORWARDS) return null !== (i = this.end) && void 0 !== i ? i : null;
					throw new Error("Invalid direction '" + e + "'")
				}
				extend(e, t) {
					const i = this.getTimelineIndex(e);
					if (!i) return o("TimelineWindow: no timeline yet"), !1;
					const n = e == s.EventTimeline.BACKWARDS ? i.retreat(t) : i.advance(t);
					if (n) {
						this.eventCount += n, o("TimelineWindow: increased cap by " + n + " (now " + this.eventCount + ")");
						const t = this.eventCount - this.windowLimit;
						return t > 0 && this.unpaginate(t, e != s.EventTimeline.BACKWARDS), !0
					}
					return !1
				}
				canPaginate(e) {
					const t = this.getTimelineIndex(e);
					if (!t) return o("TimelineWindow: no timeline yet"), !1;
					if (e == s.EventTimeline.BACKWARDS) {
						if (t.index > t.minIndex()) return !0
					} else if (t.index < t.maxIndex()) return !0;
					const i = t.timeline.getNeighbouringTimeline(e),
						n = t.timeline.getPaginationToken(e);
					return Boolean(i) || Boolean(n)
				}
				async paginate(e, t, i = !0, n = a) {
					const r = this.getTimelineIndex(e);
					if (!r) return o("TimelineWindow: no timeline yet"), !1;
					if (r.pendingPaginate) return r.pendingPaginate;
					if (this.extend(e, t)) return !0;
					if (!i || 0 === n) return !1;
					if (!r.timeline.getPaginationToken(e)) return o("TimelineWindow: no token"), !1;
					o("TimelineWindow: starting request");
					const d = this.client.paginateEventTimeline(r.timeline, {
						backwards: e == s.EventTimeline.BACKWARDS,
						limit: t
					}).finally((function() {
						r.pendingPaginate = void 0
					})).then(i => (o("TimelineWindow: request completed with result " + i), i ? this.paginate(e, t, !0, n - 1) : this.paginate(e, t, !1, 0)));
					return r.pendingPaginate = d, d
				}
				unpaginate(e, t) {
					const i = t ? this.start : this.end;
					if (!i) throw new Error(`Attempting to unpaginate startOfTimeline=${t} but don't have this direction`);
					if (e > this.eventCount || e < 0) throw new Error(`Attemting to unpaginate ${e} events, but only have ${this.eventCount} in the timeline`);
					for (; e > 0;) {
						const n = t ? i.advance(e) : i.retreat(e);
						if (n <= 0) throw new Error("Unable to unpaginate any further, but still have " + this.eventCount + " events");
						e -= n, this.eventCount -= n, o("TimelineWindow.unpaginate: dropped " + n + " (now " + this.eventCount + ")")
					}
				}
				getEvents() {
					if (!this.start) return [];
					const e = [];
					let t = this.start.timeline;
					for (;;) {
						var i, n;
						const r = t.getEvents();
						let o = 0,
							a = r.length;
						t === this.start.timeline && (o = this.start.index + t.getBaseIndex()), t === (null === (i = this.end) || void 0 === i ? void 0 : i.timeline) && (a = this.end.index + t.getBaseIndex());
						for (let t = o; t < a; t++) e.push(r[t]);
						if (t === (null === (n = this.end) || void 0 === n ? void 0 : n.timeline)) break;
						t = t.getNeighbouringTimeline(s.EventTimeline.FORWARDS)
					}
					return e
				}
			};
			class d {
				constructor(e, t) {
					this.timeline = e, this.index = t, (0, r.default)(this, "pendingPaginate", void 0)
				}
				minIndex() {
					return -1 * this.timeline.getBaseIndex()
				}
				maxIndex() {
					return this.timeline.getEvents().length - this.timeline.getBaseIndex()
				}
				advance(e) {
					if (!e) return 0;
					let t;
					if (e < 0) {
						if ((t = Math.max(e, this.minIndex() - this.index)) < 0) return this.index += t, t
					} else if ((t = Math.min(e, this.maxIndex() - this.index)) > 0) return this.index += t, t;
					const i = this.timeline.getNeighbouringTimeline(e < 0 ? s.EventTimeline.BACKWARDS : s.EventTimeline.FORWARDS);
					return i ? (this.timeline = i, this.index = e < 0 ? this.maxIndex() : this.minIndex(), o("paginate: switched to new neighbour"), this.advance(e)) : 0
				}
				retreat(e) {
					return -1 * this.advance(-1 * e)
				}
			}
			t.TimelineIndex = d
		},
		"./node_modules/matrix-js-sdk/lib/utils.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.DEFAULT_ALPHABET = void 0, t.alphabetPad = f, t.averageBetweenStrings = function(e, t, i = g) {
				const n = Math.max(e.length, t.length),
					r = y(f(e, n, i), i),
					s = y(f(t, n, i), i),
					o = (r + s) / BigInt(2);
				if (o === r || o == s) return v(o, i) + i[0];
				return v(o, i)
			}, t.baseToString = v, t.checkObjectHasKeys = function(e, t) {
				for (const i of t)
					if (!e.hasOwnProperty(i)) throw new Error("Missing required key: " + i)
			}, t.chunkPromises = async function(e, t) {
				const i = [];
				for (let n = 0; n < e.length; n += t) i.push(...await Promise.all(e.slice(n, n + t).map(e => e())));
				return i
			}, t.compare = function(e, t) {
				return _.compare(e, t)
			}, t.decodeParams = function(e) {
				const t = {},
					i = new URLSearchParams(e);
				for (const n of i.keys()) {
					const e = i.getAll(n);
					t[n] = 1 === e.length ? e[0] : e
				}
				return t
			}, t.deepCompare = function e(t, i) {
				if (t === i) return !0;
				if (typeof t != typeof i) return !1;
				if ("number" == typeof t && isNaN(t) && isNaN(i)) return !0;
				if (null === t || null === i) return t === i;
				if (!(t instanceof Object)) return !1;
				if (t.constructor !== i.constructor || t.prototype !== i.prototype) return !1;
				if (t instanceof RegExp || t instanceof Date) return t.toString() === i.toString();
				if (Array.isArray(t)) {
					if (t.length !== i.length) return !1;
					for (let n = 0; n < t.length; n++)
						if (!e(t[n], i[n])) return !1
				} else {
					for (const e in i)
						if (i.hasOwnProperty(e) !== t.hasOwnProperty(e)) return !1;
					for (const n in t)
						if (i.hasOwnProperty(n) !== t.hasOwnProperty(n) || !e(t[n], i[n])) return !1
				}
				return !0
			}, t.deepCopy = function(e) {
				return JSON.parse(JSON.stringify(e))
			}, t.deepSortedObjectEntries = function e(t) {
				if ("object" != typeof t) return t;
				if (null == t || Array.isArray(t)) return t;
				const i = [];
				for (const [n, r] of Object.entries(t)) i.push([n, e(r)]);
				i.sort((e, t) => b(e[0], t[0]));
				return i
			}, t.defer = function() {
				let e, t;
				const i = new Promise((i, n) => {
					e = i, t = n
				});
				return {
					resolve: e,
					reject: t,
					promise: i
				}
			}, t.encodeParams = function(e, t) {
				const i = null != t ? t : new URLSearchParams;
				for (const [n, r] of Object.entries(e)) null != r && (Array.isArray(r) ? r.forEach(e => {
					i.append(n, String(e))
				}) : i.append(n, String(r)));
				return i
			}, t.encodeUri = function(e, t) {
				for (const i in t) {
					if (!t.hasOwnProperty(i)) continue;
					const n = t[i];
					null != n && (e = e.replace(i, encodeURIComponent(n)))
				}
				return e
			}, t.ensureNoTrailingSlash = function(e) {
				return null != e && e.endsWith("/") ? e.slice(0, -1) : e
			}, t.escapeRegExp = p, t.globToRegexp = function(e, t = !1) {
				const i = [
					[/\\\*/g, ".*"],
					[/\?/g, "."]
				];
				t || i.push([/\\\[(!|)(.*)\\]/g, (e, t, i) => ["[", t ? "^" : "", i.replace(/\\-/, "-"), "]"].join("")]);
				return i.reduce((e, t) => t ? e.replace(t[0], t[1]) : e, p(e))
			}, t.internaliseString = function(e) {
				e instanceof String && (e = e.toString());
				u.has(e) || u.set(e, e);
				return u.get(e)
			}, t.isFunction = function(e) {
				return "[object Function]" === Object.prototype.toString.call(e)
			}, t.isNullOrUndefined = function(e) {
				return null == e
			}, t.isNumber = function(e) {
				return "number" == typeof e && isFinite(e)
			}, t.isSupportedReceiptType = function(e) {
				return [d.ReceiptType.Read, d.ReceiptType.ReadPrivate].includes(e)
			}, t.lexicographicCompare = b, t.nextString = function(e, t = g) {
				return v(y(e, t) + BigInt(1), t)
			}, t.normalize = function(e) {
				return h(e.toLowerCase()).replace(/[\\'!"#$%&()*+,\-./:;<=>?@[\]^_`{|}~\u2000-\u206f\u2e00-\u2e7f]/g, "").toLowerCase()
			}, t.prevString = function(e, t = g) {
				return v(y(e, t) - BigInt(1), t)
			}, t.promiseMapSeries = async function(e, t) {
				for (const i of e) await t(await i)
			}, t.promiseTry = function(e) {
				return Promise.resolve(e())
			}, t.recursivelyAssign = function e(t, i, n = !1) {
				for (const [r, s] of Object.entries(i)) t[r] instanceof Object && s ? e(t[r], s) : null == s && n || (t[r] = s);
				return t
			}, t.removeDirectionOverrideChars = function(e) {
				if ("string" == typeof e) return e.replace(/[\u202d-\u202e]/g, "");
				return ""
			}, t.removeElement = function(e, t, i) {
				let n;
				if (i) {
					for (n = e.length - 1; n >= 0; n--)
						if (t(e[n], n, e)) return e.splice(n, 1), !0
				} else
					for (n = 0; n < e.length; n++)
						if (t(e[n], n, e)) return e.splice(n, 1), !0;
				return !1
			}, t.removeHiddenChars = h, t.replaceParam = function(e, t, i) {
				const n = c(c({}, i), {}, {
					[t]: i[e]
				});
				return delete n[e], n
			}, t.simpleRetryOperation = function(e) {
				return (0, o.default)(t => e(t), {
					forever: !0,
					factor: 2,
					minTimeout: 3e3,
					maxTimeout: 15e3
				})
			}, t.sleep = function(e, t) {
				return new Promise(i => {
					setTimeout(i, e, t)
				})
			}, t.sortEventsByLatestContentTimestamp = function(e, t) {
				return S(t) - S(e)
			}, t.stringToBase = y;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = n(i("./node_modules/unhomoglyph/index.js")),
				o = n(i("./node_modules/p-retry/index.js")),
				a = i("./node_modules/matrix-js-sdk/lib/@types/location.js"),
				d = i("./node_modules/matrix-js-sdk/lib/@types/read_receipts.js");

			function l(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function c(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? l(Object(i), !0).forEach((function(t) {
						(0, r.default)(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : l(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}
			const u = new Map;

			function h(e) {
				return "string" == typeof e ? (0, s.default)(e.normalize("NFD").replace(m, "")) : ""
			}
			const m = /[\u2000-\u200F\u202A-\u202F\u0300-\u036F\uFEFF\u061C\u2800\u2062-\u2063\s]/g;

			function p(e) {
				return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
			}
			const g = (() => {
				let e = "";
				for (let t = 32; t <= 126; t++) e += String.fromCharCode(t);
				return e
			})();

			function f(e, t, i = g) {
				return e.padEnd(t, i[0])
			}

			function v(e, t = g) {
				const i = BigInt(t.length);
				var n;
				if (e <= i) return null !== (n = t[Number(e) - 1]) && void 0 !== n ? n : "";
				let r = e / i,
					s = Number(e % i) - 1;
				return s < 0 && (r -= BigInt(Math.abs(s)), s = Number(i) - 1), v(r, t) + t[s]
			}

			function y(e, t = g) {
				const i = BigInt(t.length);
				let n = BigInt(0);
				for (let r = e.length - 1, s = BigInt(0); r >= 0; r--, s++) {
					const o = e.charCodeAt(r) - t.charCodeAt(0);
					n += BigInt(1 + o) * i ** s
				}
				return n
			}

			function b(e, t) {
				return e < t ? -1 : e > t ? 1 : 0
			}
			t.DEFAULT_ALPHABET = g;
			const _ = new Intl.Collator;

			function S(e) {
				var t;
				return null !== (t = a.M_TIMESTAMP.findIn(e.getContent())) && void 0 !== t ? t : -1
			}
		},
		"./node_modules/matrix-js-sdk/lib/webrtc/audioContext.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.releaseContext = t.acquireContext = void 0;
			let n = null,
				r = 0;
			t.acquireContext = () => (null === n && (n = new AudioContext), r++, n);
			t.releaseContext = () => {
				var e;
				0 === --r && (null === (e = n) || void 0 === e || e.close(), n = null)
			}
		},
		"./node_modules/matrix-js-sdk/lib/webrtc/call.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.MatrixCall = t.CallType = t.CallState = t.CallParty = t.CallEvent = t.CallErrorCode = t.CallError = t.CallDirection = void 0, t.createNewMatrixCall = function(e, t, i) {
				if (!A()) return null;
				const n = !!i && i.forceTURN,
					r = {
						client: e,
						roomId: t,
						invitee: null == i ? void 0 : i.invitee,
						turnServers: e.getTurnServers(),
						forceTURN: e.forceTURN || n,
						opponentDeviceId: null == i ? void 0 : i.opponentDeviceId,
						opponentSessionId: null == i ? void 0 : i.opponentSessionId,
						groupCallId: null == i ? void 0 : i.groupCallId
					},
					s = new P(r);
				return e.reEmitter.reEmit(s, Object.values(T)), s
			}, t.genCallID = O, t.setTracksEnabled = D, t.supportsMatrixCall = A;
			var r, s, o = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				a = i("./node_modules/sdp-transform/lib/index.js"),
				d = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				l = function(e, t) {
					if (!t && e && e.__esModule) return e;
					if (null === e || "object" != typeof e && "function" != typeof e) return {
						default: e
					};
					var i = y(t);
					if (i && i.has(e)) return i.get(e);
					var n = {},
						r = Object.defineProperty && Object.getOwnPropertyDescriptor;
					for (var s in e)
						if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
							var o = r ? Object.getOwnPropertyDescriptor(e, s) : null;
							o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = e[s]
						} n.default = e, i && i.set(e, n);
					return n
				}(i("./node_modules/matrix-js-sdk/lib/utils.js")),
				c = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				u = i("./node_modules/matrix-js-sdk/lib/randomstring.js"),
				h = i("./node_modules/matrix-js-sdk/lib/webrtc/callEventTypes.js"),
				m = i("./node_modules/matrix-js-sdk/lib/webrtc/callFeed.js"),
				p = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js"),
				g = i("./node_modules/matrix-js-sdk/lib/crypto/deviceinfo.js"),
				f = i("./node_modules/matrix-js-sdk/lib/webrtc/groupCall.js"),
				v = i("./node_modules/matrix-js-sdk/lib/http-api/index.js");

			function y(e) {
				if ("function" != typeof WeakMap) return null;
				var t = new WeakMap,
					i = new WeakMap;
				return (y = function(e) {
					return e ? i : t
				})(e)
			}

			function b(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function _(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? b(Object(i), !0).forEach((function(t) {
						(0, o.default)(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : b(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}
			let S, E, w, k, T, I;
			! function(e) {
				e.AUDIO = "audio", e.VIDEO = "video"
			}(r || (r = {})),
			function(e) {
				e.OPUS = "opus"
			}(s || (s = {})), t.CallState = S,
				function(e) {
					e.Fledgling = "fledgling", e.InviteSent = "invite_sent", e.WaitLocalMedia = "wait_local_media", e.CreateOffer = "create_offer", e.CreateAnswer = "create_answer", e.Connecting = "connecting", e.Connected = "connected", e.Ringing = "ringing", e.Ended = "ended"
				}(S || (t.CallState = S = {})), t.CallType = E,
				function(e) {
					e.Voice = "voice", e.Video = "video"
				}(E || (t.CallType = E = {})), t.CallDirection = w,
				function(e) {
					e.Inbound = "inbound", e.Outbound = "outbound"
				}(w || (t.CallDirection = w = {})), t.CallParty = k,
				function(e) {
					e.Local = "local", e.Remote = "remote"
				}(k || (t.CallParty = k = {})), t.CallEvent = T,
				function(e) {
					e.Hangup = "hangup", e.State = "state", e.Error = "error", e.Replaced = "replaced", e.LocalHoldUnhold = "local_hold_unhold", e.RemoteHoldUnhold = "remote_hold_unhold", e.HoldUnhold = "hold_unhold", e.FeedsChanged = "feeds_changed", e.AssertedIdentityChanged = "asserted_identity_changed", e.LengthChanged = "length_changed", e.DataChannel = "datachannel", e.SendVoipEvent = "send_voip_event"
				}(T || (t.CallEvent = T = {})), t.CallErrorCode = I,
				function(e) {
					e.UserHangup = "user_hangup", e.LocalOfferFailed = "local_offer_failed", e.NoUserMedia = "no_user_media", e.UnknownDevices = "unknown_devices", e.SendInvite = "send_invite", e.CreateAnswer = "create_answer", e.CreateOffer = "create_offer", e.SendAnswer = "send_answer", e.SetRemoteDescription = "set_remote_description", e.SetLocalDescription = "set_local_description", e.AnsweredElsewhere = "answered_elsewhere", e.IceFailed = "ice_failed", e.InviteTimeout = "invite_timeout", e.Replaced = "replaced", e.SignallingFailed = "signalling_timeout", e.UserBusy = "user_busy", e.Transfered = "transferred", e.NewSession = "new_session"
				}(I || (t.CallErrorCode = I = {}));
			const C = "1",
				R = "stun:turn.matrix.org",
				j = 6e4;
			class CallError extends Error {
				constructor(e, t, i) {
					super(t + ": " + i), (0, o.default)(this, "code", void 0), this.code = e
				}
			}

			function O() {
				return Date.now().toString() + (0, u.randomString)(16)
			}

			function x(e) {
				return [{
					mediaType: "audio",
					codec: "opus",
					enableDtx: !0,
					maxAverageBitrate: e ? 12e3 : void 0
				}]
			}

			function M(e, t) {
				return e + ":" + t
			}
			t.CallError = CallError;
			class P extends p.TypedEventEmitter {
				constructor(e) {
					var t;
					if (super(), (0, o.default)(this, "roomId", void 0), (0, o.default)(this, "callId", void 0), (0, o.default)(this, "invitee", void 0), (0, o.default)(this, "state", S.Fledgling), (0, o.default)(this, "hangupParty", void 0), (0, o.default)(this, "hangupReason", void 0), (0, o.default)(this, "direction", void 0), (0, o.default)(this, "ourPartyId", void 0), (0, o.default)(this, "peerConn", void 0), (0, o.default)(this, "toDeviceSeq", 0), (0, o.default)(this, "isPtt", !1), (0, o.default)(this, "client", void 0), (0, o.default)(this, "forceTURN", void 0), (0, o.default)(this, "turnServers", void 0), (0, o.default)(this, "candidateSendQueue", []), (0, o.default)(this, "candidateSendTries", 0), (0, o.default)(this, "candidatesEnded", !1), (0, o.default)(this, "feeds", []), (0, o.default)(this, "transceivers", new Map), (0, o.default)(this, "inviteOrAnswerSent", !1), (0, o.default)(this, "waitForLocalAVStream", !1), (0, o.default)(this, "successor", void 0), (0, o.default)(this, "opponentMember", void 0), (0, o.default)(this, "opponentVersion", void 0), (0, o.default)(this, "opponentPartyId", void 0), (0, o.default)(this, "opponentCaps", void 0), (0, o.default)(this, "iceDisconnectedTimeout", void 0), (0, o.default)(this, "inviteTimeout", void 0), (0, o.default)(this, "removeTrackListeners", new Map), (0, o.default)(this, "remoteOnHold", !1), (0, o.default)(this, "callStatsAtEnd", void 0), (0, o.default)(this, "makingOffer", !1), (0, o.default)(this, "ignoreOffer", !1), (0, o.default)(this, "responsePromiseChain", void 0), (0, o.default)(this, "remoteCandidateBuffer", new Map), (0, o.default)(this, "remoteAssertedIdentity", void 0), (0, o.default)(this, "remoteSDPStreamMetadata", void 0), (0, o.default)(this, "callLengthInterval", void 0), (0, o.default)(this, "callLength", 0), (0, o.default)(this, "opponentDeviceId", void 0), (0, o.default)(this, "opponentDeviceInfo", void 0), (0, o.default)(this, "opponentSessionId", void 0), (0, o.default)(this, "groupCallId", void 0), (0, o.default)(this, "gotLocalIceCandidate", e => {
							if (e.candidate) {
								if (this.candidatesEnded) return void d.logger.warn("Got candidate after candidates have ended - ignoring!");
								if (d.logger.debug("Call " + this.callId + " got local ICE " + e.candidate.sdpMid + " candidate: " + e.candidate.candidate), this.callHasEnded()) return;
								"" === e.candidate.candidate ? this.queueCandidate(null) : this.queueCandidate(e.candidate)
							}
						}), (0, o.default)(this, "onIceGatheringStateChange", e => {
							var t;
							d.logger.debug(`Call ${this.callId} ice gathering state changed to  ${this.peerConn.iceGatheringState}`), "complete" === (null === (t = this.peerConn) || void 0 === t ? void 0 : t.iceGatheringState) && this.queueCandidate(null)
						}), (0, o.default)(this, "getLocalOfferFailed", e => {
							d.logger.error(`Call ${this.callId} Failed to get local offer`, e), this.emit(T.Error, new CallError(I.LocalOfferFailed, "Failed to get local offer!", e)), this.terminate(k.Local, I.LocalOfferFailed, !1)
						}), (0, o.default)(this, "getUserMediaFailed", e => {
							this.successor ? this.successor.getUserMediaFailed(e) : (d.logger.warn(`Failed to get user media - ending call ${this.callId}`, e), this.emit(T.Error, new CallError(I.NoUserMedia, "Couldn't start capturing media! Is your microphone set up and does this app have permission?", e)), this.terminate(k.Local, I.NoUserMedia, !1))
						}), (0, o.default)(this, "onIceConnectionStateChanged", () => {
							var e, t, i, n, r;
							if (!this.callHasEnded()) {
								if (d.logger.debug("Call ID " + this.callId + ": ICE connection state changed to: " + (null === (e = this.peerConn) || void 0 === e ? void 0 : e.iceConnectionState)), ["connected", "completed"].includes(null !== (t = null === (i = this.peerConn) || void 0 === i ? void 0 : i.iceConnectionState) && void 0 !== t ? t : "")) clearTimeout(this.iceDisconnectedTimeout), this.setState(S.Connected), this.callLengthInterval || (this.callLengthInterval = setInterval(() => {
									this.callLength++, this.emit(T.LengthChanged, this.callLength)
								}, 1e3));
								else if ("failed" == (null === (n = this.peerConn) || void 0 === n ? void 0 : n.iceConnectionState)) {
									var s;
									null !== (s = this.peerConn) && void 0 !== s && s.restartIce ? (this.candidatesEnded = !1, this.peerConn.restartIce()) : (d.logger.info(`Hanging up call ${this.callId} (ICE failed and no ICE restart method)`), this.hangup(I.IceFailed, !1))
								} else "disconnected" == (null === (r = this.peerConn) || void 0 === r ? void 0 : r.iceConnectionState) && (this.iceDisconnectedTimeout = setTimeout(() => {
									d.logger.info(`Hanging up call ${this.callId} (ICE disconnected for too long)`), this.hangup(I.IceFailed, !1)
								}, 3e4), this.setState(S.Connecting));
								if (this.isPtt && ["failed", "disconnected"].includes(this.peerConn.iceConnectionState))
									for (const e of this.getRemoteFeeds()) e.setAudioVideoMuted(!0, !0)
							}
						}), (0, o.default)(this, "onSignallingStateChanged", () => {
							var e;
							d.logger.debug(`call ${this.callId}: Signalling state changed to: ${null===(e=this.peerConn)||void 0===e?void 0:e.signalingState}`)
						}), (0, o.default)(this, "onTrack", e => {
							if (0 === e.streams.length) return void d.logger.warn(`Call ${this.callId} Streamless ${e.track.kind} found: ignoring.`);
							const t = e.streams[0];
							if (this.pushRemoteFeed(t), !this.removeTrackListeners.has(t)) {
								const e = () => {
									0 === t.getTracks().length && (d.logger.info(`Call ${this.callId} removing track streamId: ${t.id}`), this.deleteFeedByStream(t), t.removeEventListener("removetrack", e), this.removeTrackListeners.delete(t))
								};
								t.addEventListener("removetrack", e), this.removeTrackListeners.set(t, e)
							}
						}), (0, o.default)(this, "onDataChannel", e => {
							this.emit(T.DataChannel, e.channel)
						}), (0, o.default)(this, "onNegotiationNeeded", async () => {
							d.logger.info(`Call ${this.callId} Negotiation is needed!`), this.state === S.CreateOffer || 0 !== this.opponentVersion ? this.queueGotLocalOffer() : d.logger.info(`Call ${this.callId} Opponent does not support renegotiation: ignoring negotiationneeded event`)
						}), (0, o.default)(this, "onHangupReceived", e => {
							d.logger.debug("Hangup received for call ID " + this.callId), this.partyIdMatches(e) || this.state === S.Ringing ? this.terminate(k.Remote, e.reason || I.UserHangup, !0) : d.logger.info(`Call ${this.callId} Ignoring message from party ID ${e.party_id}: our partner is ${this.opponentPartyId}`)
						}), (0, o.default)(this, "onRejectReceived", e => {
							d.logger.debug("Reject received for call ID " + this.callId), [S.InviteSent, S.Ringing].includes(this.state) || this.state === S.Fledgling && this.direction === w.Inbound ? this.terminate(k.Remote, e.reason || I.UserHangup, !0) : d.logger.debug(`Call ${this.callId} is in state: ${this.state}: ignoring reject`)
						}), (0, o.default)(this, "onAnsweredElsewhere", e => {
							d.logger.debug("Call " + this.callId + " answered elsewhere"), this.terminate(k.Remote, I.AnsweredElsewhere, !0)
						}), this.roomId = e.roomId, this.invitee = e.invitee, this.client = e.client, !this.client.deviceId) throw new Error("Client must have a device ID to start calls");
					this.forceTURN = null !== (t = e.forceTURN) && void 0 !== t && t, this.ourPartyId = this.client.deviceId, this.opponentDeviceId = e.opponentDeviceId, this.opponentSessionId = e.opponentSessionId, this.groupCallId = e.groupCallId, this.turnServers = e.turnServers || [], 0 === this.turnServers.length && this.client.isFallbackICEServerAllowed() && this.turnServers.push({
						urls: [R]
					});
					for (const i of this.turnServers) l.checkObjectHasKeys(i, ["urls"]);
					this.callId = O()
				}
				async placeVoiceCall() {
					await this.placeCall(!0, !1)
				}
				async placeVideoCall() {
					await this.placeCall(!0, !0)
				}
				createDataChannel(e, t) {
					const i = this.peerConn.createDataChannel(e, t);
					return this.emit(T.DataChannel, i), i
				}
				getOpponentMember() {
					return this.opponentMember
				}
				getOpponentSessionId() {
					return this.opponentSessionId
				}
				opponentCanBeTransferred() {
					return Boolean(this.opponentCaps && this.opponentCaps["m.call.transferee"])
				}
				opponentSupportsDTMF() {
					return Boolean(this.opponentCaps && this.opponentCaps["m.call.dtmf"])
				}
				getRemoteAssertedIdentity() {
					return this.remoteAssertedIdentity
				}
				get type() {
					return this.hasLocalUserMediaVideoTrack || this.hasRemoteUserMediaVideoTrack ? E.Video : E.Voice
				}
				get hasLocalUserMediaVideoTrack() {
					var e;
					return !(null === (e = this.localUsermediaStream) || void 0 === e || !e.getVideoTracks().length)
				}
				get hasRemoteUserMediaVideoTrack() {
					return this.getRemoteFeeds().some(e => {
						var t;
						return e.purpose === h.SDPStreamMetadataPurpose.Usermedia && (null === (t = e.stream) || void 0 === t ? void 0 : t.getVideoTracks().length)
					})
				}
				get hasLocalUserMediaAudioTrack() {
					var e;
					return !(null === (e = this.localUsermediaStream) || void 0 === e || !e.getAudioTracks().length)
				}
				get hasRemoteUserMediaAudioTrack() {
					return this.getRemoteFeeds().some(e => {
						var t;
						return e.purpose === h.SDPStreamMetadataPurpose.Usermedia && !(null === (t = e.stream) || void 0 === t || !t.getAudioTracks().length)
					})
				}
				get localUsermediaFeed() {
					return this.getLocalFeeds().find(e => e.purpose === h.SDPStreamMetadataPurpose.Usermedia)
				}
				get localScreensharingFeed() {
					return this.getLocalFeeds().find(e => e.purpose === h.SDPStreamMetadataPurpose.Screenshare)
				}
				get localUsermediaStream() {
					var e;
					return null === (e = this.localUsermediaFeed) || void 0 === e ? void 0 : e.stream
				}
				get localScreensharingStream() {
					var e;
					return null === (e = this.localScreensharingFeed) || void 0 === e ? void 0 : e.stream
				}
				get remoteUsermediaFeed() {
					return this.getRemoteFeeds().find(e => e.purpose === h.SDPStreamMetadataPurpose.Usermedia)
				}
				get remoteScreensharingFeed() {
					return this.getRemoteFeeds().find(e => e.purpose === h.SDPStreamMetadataPurpose.Screenshare)
				}
				get remoteUsermediaStream() {
					var e;
					return null === (e = this.remoteUsermediaFeed) || void 0 === e ? void 0 : e.stream
				}
				get remoteScreensharingStream() {
					var e;
					return null === (e = this.remoteScreensharingFeed) || void 0 === e ? void 0 : e.stream
				}
				getFeedByStreamId(e) {
					return this.getFeeds().find(t => t.stream.id === e)
				}
				getFeeds() {
					return this.feeds
				}
				getLocalFeeds() {
					return this.feeds.filter(e => e.isLocal())
				}
				getRemoteFeeds() {
					return this.feeds.filter(e => !e.isLocal())
				}
				async initOpponentCrypto() {
					var e;
					if (!this.opponentDeviceId) return;
					if (!this.client.getUseE2eForGroupCall()) return;
					if (!this.client.isCryptoEnabled()) return void(this.opponentDeviceInfo = new g.DeviceInfo(this.opponentDeviceId));
					if (!this.client.crypto) throw new Error("Crypto is not initialised.");
					const t = this.invitee || (null === (e = this.getOpponentMember()) || void 0 === e ? void 0 : e.userId);
					if (!t) throw new Error("Couldn't find opponent user ID to init crypto");
					const i = await this.client.crypto.deviceList.downloadKeys([t], !1);
					if (this.opponentDeviceInfo = i[t][this.opponentDeviceId], void 0 === this.opponentDeviceInfo) throw new f.GroupCallUnknownDeviceError(t)
				}
				getLocalSDPStreamMetadata(e = !1) {
					const t = {};
					for (const i of this.getLocalFeeds()) e && (i.sdpMetadataStreamId = i.stream.id), t[i.sdpMetadataStreamId] = {
						purpose: i.purpose,
						audio_muted: i.isAudioMuted(),
						video_muted: i.isVideoMuted()
					};
					return t
				}
				noIncomingFeeds() {
					return !this.feeds.some(e => !e.isLocal())
				}
				pushRemoteFeed(e) {
					if (!this.opponentSupportsSDPStreamMetadata()) return void this.pushRemoteFeedWithoutMetadata(e);
					const t = this.getOpponentMember().userId,
						i = this.remoteSDPStreamMetadata[e.id].purpose,
						n = this.remoteSDPStreamMetadata[e.id].audio_muted,
						r = this.remoteSDPStreamMetadata[e.id].video_muted;
					i ? this.getFeedByStreamId(e.id) ? d.logger.warn(`Ignoring stream with id ${e.id} because we already have a feed for it`) : (this.feeds.push(new m.CallFeed({
						client: this.client,
						roomId: this.roomId,
						userId: t,
						stream: e,
						purpose: i,
						audioMuted: n,
						videoMuted: r
					})), this.emit(T.FeedsChanged, this.feeds), d.logger.info(`Call ${this.callId} pushed remote stream (id="${e.id}", ` + `active="${e.active}", purpose=${i})`)) : d.logger.warn(`Call ${this.callId} Ignoring stream with id ${e.id} because we didn't get any metadata about it`)
				}
				pushRemoteFeedWithoutMetadata(e) {
					var t;
					const i = this.getOpponentMember().userId,
						n = h.SDPStreamMetadataPurpose.Usermedia,
						r = null === (t = this.feeds.find(e => !e.isLocal())) || void 0 === t ? void 0 : t.stream;
					r && e.id !== r.id ? d.logger.warn(`Call ${this.callId} Ignoring new stream ID ${e.id}: we already have stream ID ${r.id}`) : this.getFeedByStreamId(e.id) ? d.logger.warn(`Ignoring stream with id ${e.id} because we already have a feed for it`) : (this.feeds.push(new m.CallFeed({
						client: this.client,
						roomId: this.roomId,
						audioMuted: !1,
						videoMuted: !1,
						userId: i,
						stream: e,
						purpose: n
					})), this.emit(T.FeedsChanged, this.feeds), d.logger.info(`Call ${this.callId} pushed remote stream (id="${e.id}", active="${e.active}")`))
				}
				pushNewLocalFeed(e, t, i = !0) {
					const n = this.client.getUserId();
					D(e.getAudioTracks(), !0), D(e.getVideoTracks(), !0), this.getFeedByStreamId(e.id) ? d.logger.warn(`Ignoring stream with id ${e.id} because we already have a feed for it`) : this.pushLocalFeed(new m.CallFeed({
						client: this.client,
						roomId: this.roomId,
						audioMuted: !1,
						videoMuted: !1,
						userId: n,
						stream: e,
						purpose: t
					}), i)
				}
				pushLocalFeed(e, t = !0) {
					if (this.feeds.some(t => e.stream.id === t.stream.id)) d.logger.info(`Ignoring duplicate local stream ${e.stream.id} in call ${this.callId}`);
					else {
						if (this.feeds.push(e), t)
							for (const t of e.stream.getTracks()) {
								d.logger.info(`Call ${this.callId} ` + "Adding track (" + `id="${t.id}", ` + `kind="${t.kind}", ` + `streamId="${e.stream.id}", ` + `streamPurpose="${e.purpose}", ` + `enabled=${t.enabled}` + ") to peer connection");
								const i = M(e.purpose, t.kind);
								if (this.transceivers.has(i)) {
									const n = this.transceivers.get(i);
									n.sender.setStreams && n.sender.setStreams(e.stream), n.sender.replaceTrack(t), n.direction = "inactive" === n.direction ? "sendonly" : "sendrecv"
								} else {
									const n = this.peerConn.addTrack(t, e.stream),
										r = this.peerConn.getTransceivers().find(e => e.sender === n);
									r ? this.transceivers.set(i, r) : d.logger.warn("Didn't find a matching transceiver after adding track!")
								}
							}
						d.logger.info(`Call ${this.callId} ` + "Pushed local stream " + `(id="${e.stream.id}", ` + `active="${e.stream.active}", ` + `purpose="${e.purpose}")`), this.emit(T.FeedsChanged, this.feeds)
					}
				}
				removeLocalFeed(e) {
					const t = M(e.purpose, "audio"),
						i = M(e.purpose, "video");
					for (const n of [t, i])
						if (this.transceivers.has(n)) {
							const e = this.transceivers.get(n);
							e.sender && this.peerConn.removeTrack(e.sender)
						} e.purpose === h.SDPStreamMetadataPurpose.Screenshare && this.client.getMediaHandler().stopScreensharingStream(e.stream), this.deleteFeed(e)
				}
				deleteAllFeeds() {
					for (const e of this.feeds) e.isLocal() && this.groupCallId || e.dispose();
					this.feeds = [], this.emit(T.FeedsChanged, this.feeds)
				}
				deleteFeedByStream(e) {
					const t = this.getFeedByStreamId(e.id);
					t ? this.deleteFeed(t) : d.logger.warn(`Call ${this.callId} Didn't find the feed with stream id ${e.id} to delete`)
				}
				deleteFeed(e) {
					e.dispose(), this.feeds.splice(this.feeds.indexOf(e), 1), this.emit(T.FeedsChanged, this.feeds)
				}
				async getCurrentCallStats() {
					return this.callHasEnded() ? this.callStatsAtEnd : this.collectCallStats()
				}
				async collectCallStats() {
					if (!this.peerConn) return;
					const e = await this.peerConn.getStats(),
						t = [];
					return e.forEach(e => {
						t.push(e)
					}), t
				}
				async initWithInvite(e) {
					var t;
					const i = e.getContent();
					this.direction = w.Inbound, await this.client.checkTurnServers() || d.logger.warn(`Call ${this.callId} Failed to get TURN credentials! Proceeding with call anyway...`);
					const n = i[h.SDPStreamMetadataKey];
					n ? this.updateRemoteSDPStreamMetadata(n) : d.logger.debug(`Call ${this.callId} did not get any SDPStreamMetadata! Can not send/receive multiple streams`), this.peerConn = this.createPeerConnection(), this.chooseOpponent(e), await this.initOpponentCrypto();
					try {
						await this.peerConn.setRemoteDescription(i.offer), await this.addBufferedIceCandidates()
					} catch (s) {
						return d.logger.debug(`Call ${this.callId} failed to set remote description`, s), void this.terminate(k.Local, I.SetRemoteDescription, !1)
					}
					const r = null === (t = this.feeds.find(e => !e.isLocal())) || void 0 === t ? void 0 : t.stream;
					if (!r || 0 === r.getTracks().length) return d.logger.error(`Call ${this.callId} no remote stream or no tracks after setting remote description!`), void this.terminate(k.Local, I.SetRemoteDescription, !1);
					if (this.setState(S.Ringing), e.getLocalAge()) {
						const t = setTimeout(() => {
								this.state == S.Ringing && (d.logger.debug(`Call ${this.callId} invite has expired. Hanging up.`), this.hangupParty = k.Remote, this.setState(S.Ended), this.stopAllMedia(), "closed" != this.peerConn.signalingState && this.peerConn.close(), this.emit(T.Hangup, this))
							}, i.lifetime - e.getLocalAge()),
							n = e => {
								e !== S.Ringing && (clearTimeout(t), this.off(T.State, n))
							};
						this.on(T.State, n)
					}
				}
				initWithHangup(e) {
					this.setState(S.Ended)
				}
				shouldAnswerWithMediaType(e, t, i) {
					return e && !t ? (d.logger.warn(`Call ${this.callId} Unable to answer with ${i} because the other side isn't sending it either.`), !1) : l.isNullOrUndefined(e) || e === t || this.opponentSupportsSDPStreamMetadata() ? null != e ? e : t : (d.logger.warn(`Call ${this.callId} Unable to answer with ${i}=${e} because the other side doesn't support it. Answering with ${i}=${t}.`), t)
				}
				async answer(e, t) {
					if (!this.inviteOrAnswerSent) {
						if (!1 === e && !1 === t) throw new Error("You CANNOT answer a call without media");
						if (this.localUsermediaStream || this.waitForLocalAVStream) this.waitForLocalAVStream && this.setState(S.WaitLocalMedia);
						else {
							const n = this.state,
								r = this.shouldAnswerWithMediaType(e, this.hasRemoteUserMediaAudioTrack, "audio"),
								s = this.shouldAnswerWithMediaType(t, this.hasRemoteUserMediaVideoTrack, "video");
							this.setState(S.WaitLocalMedia), this.waitForLocalAVStream = !0;
							try {
								const e = await this.client.getMediaHandler().getUserMediaStream(r, s);
								this.waitForLocalAVStream = !1;
								const t = [new m.CallFeed({
									client: this.client,
									roomId: this.roomId,
									userId: this.client.getUserId(),
									stream: e,
									purpose: h.SDPStreamMetadataPurpose.Usermedia,
									audioMuted: !1,
									videoMuted: !1
								})];
								this.localScreensharingFeed && t.push(this.localScreensharingFeed), this.answerWithCallFeeds(t)
							} catch (i) {
								if (!s) return void this.getUserMediaFailed(i);
								d.logger.warn(`Call ${this.callId} Failed to getUserMedia(), trying to getUserMedia() without video`), this.setState(n), this.waitForLocalAVStream = !1, await this.answer(r, !1)
							}
						}
					}
				}
				answerWithCallFeeds(e) {
					this.inviteOrAnswerSent || this.queueGotCallFeedsForAnswer(e)
				}
				replacedBy(e) {
					d.logger.debug(`Call ${this.callId} replaced by ${e.callId}`), this.state === S.WaitLocalMedia ? (d.logger.debug(`Call ${this.callId} telling new call ${e.callId} to wait for local media`), e.waitForLocalAVStream = !0) : [S.CreateOffer, S.InviteSent].includes(this.state) && (e.direction === w.Outbound ? e.queueGotCallFeedsForAnswer([]) : (d.logger.debug(`Call ${this.callId} handing local stream to new call ${e.callId}`), e.queueGotCallFeedsForAnswer(this.getLocalFeeds().map(e => e.clone())))), this.successor = e, this.emit(T.Replaced, e), this.hangup(I.Replaced, !0)
				}
				hangup(e, t) {
					if (this.callHasEnded()) return;
					if (d.logger.debug(`Ending call ${this.callId} with reason ${e}`), this.terminate(k.Local, e, !t), this.state === S.WaitLocalMedia) return;
					const i = {};
					(this.opponentVersion && 0 !== this.opponentVersion || e !== I.UserHangup) && (i.reason = e), this.sendVoipEvent(c.EventType.CallHangup, i)
				}
				reject() {
					if (this.state !== S.Ringing) throw Error("Call must be in 'ringing' state to reject!");
					if (0 === this.opponentVersion) return d.logger.info(`Call ${this.callId} Opponent version is less than 1 (${this.opponentVersion}): sending hangup instead of reject`), void this.hangup(I.UserHangup, !0);
					d.logger.debug("Rejecting call: " + this.callId), this.terminate(k.Local, I.UserHangup, !0), this.sendVoipEvent(c.EventType.CallReject, {})
				}
				async upgradeCall(e, t) {
					if ((e || t) && this.opponentSupportsSDPStreamMetadata()) try {
						d.logger.debug(`Upgrading call ${this.callId}: audio?=${e} video?=${t}`);
						const i = e || this.hasLocalUserMediaAudioTrack,
							n = t || this.hasLocalUserMediaVideoTrack,
							r = await this.client.getMediaHandler().getUserMediaStream(i, n, !1);
						await this.updateLocalUsermediaStream(r, e, t)
					} catch (i) {
						d.logger.error(`Call ${this.callId} Failed to upgrade the call`, i), this.emit(T.Error, new CallError(I.NoUserMedia, "Failed to get camera access: ", i))
					}
				}
				opponentSupportsSDPStreamMetadata() {
					return Boolean(this.remoteSDPStreamMetadata)
				}
				isScreensharing() {
					return Boolean(this.localScreensharingStream)
				}
				async setScreensharingEnabled(e, t) {
					if (e && this.isScreensharing()) return d.logger.warn(`Call ${this.callId} There is already a screensharing stream - there is nothing to do!`), !0;
					if (!e && !this.isScreensharing()) return d.logger.warn(`Call ${this.callId} There already isn't a screensharing stream - there is nothing to do!`), !1;
					if (!this.opponentSupportsSDPStreamMetadata()) return this.setScreensharingEnabledWithoutMetadataSupport(e, t);
					if (d.logger.debug(`Call ${this.callId} set screensharing enabled? ${e}`), !e) {
						const e = this.transceivers.get(M(h.SDPStreamMetadataPurpose.Screenshare, "audio")),
							t = this.transceivers.get(M(h.SDPStreamMetadataPurpose.Screenshare, "video"));
						for (const i of [e, t]) i && i.sender && this.peerConn.removeTrack(i.sender);
						return this.client.getMediaHandler().stopScreensharingStream(this.localScreensharingStream), this.deleteFeedByStream(this.localScreensharingStream), !1
					}
					try {
						const e = await this.client.getMediaHandler().getScreensharingStream(t);
						return !!e && (this.pushNewLocalFeed(e, h.SDPStreamMetadataPurpose.Screenshare), !0)
					} catch (i) {
						return d.logger.error(`Call ${this.callId} Failed to get screen-sharing stream:`, i), !1
					}
				}
				async setScreensharingEnabledWithoutMetadataSupport(e, t) {
					if (d.logger.debug(`Call ${this.callId} Set screensharing enabled? ${e} using replaceTrack()`), !e) {
						var i, n;
						const e = null === (i = this.localUsermediaStream) || void 0 === i ? void 0 : i.getTracks().find(e => "video" === e.kind),
							t = null === (n = this.transceivers.get(M(h.SDPStreamMetadataPurpose.Usermedia, "video"))) || void 0 === n ? void 0 : n.sender;
						return null == t || t.replaceTrack(null != e ? e : null), this.client.getMediaHandler().stopScreensharingStream(this.localScreensharingStream), this.deleteFeedByStream(this.localScreensharingStream), !1
					}
					try {
						var r;
						const e = await this.client.getMediaHandler().getScreensharingStream(t);
						if (!e) return !1;
						const i = e.getTracks().find(e => "video" === e.kind),
							n = null === (r = this.transceivers.get(M(h.SDPStreamMetadataPurpose.Usermedia, "video"))) || void 0 === r ? void 0 : r.sender;
						return null == n || n.replaceTrack(null != i ? i : null), this.pushNewLocalFeed(e, h.SDPStreamMetadataPurpose.Screenshare, !1), !0
					} catch (s) {
						return d.logger.error(`Call ${this.callId} Failed to get screen-sharing stream:`, s), !1
					}
				}
				async updateLocalUsermediaStream(e, t = !1, i = !1) {
					const n = this.localUsermediaFeed,
						r = t || !n.isAudioMuted() && !this.remoteOnHold,
						s = i || !n.isVideoMuted() && !this.remoteOnHold;
					d.logger.log(`call ${this.callId} updateLocalUsermediaStream stream ${e.id} audioEnabled ${r} videoEnabled ${s}`), D(e.getAudioTracks(), r), D(e.getVideoTracks(), s);
					for (const d of this.localUsermediaStream.getTracks()) this.localUsermediaStream.removeTrack(d), d.stop();
					for (const d of e.getTracks()) this.localUsermediaStream.addTrack(d);
					for (const l of e.getTracks()) {
						var o;
						const t = M(h.SDPStreamMetadataPurpose.Usermedia, l.kind),
							i = null === (o = this.transceivers.get(t)) || void 0 === o ? void 0 : o.sender;
						let r = !1;
						if (i) try {
							d.logger.info(`Call ${this.callId} ` + "Replacing track (" + `id="${l.id}", ` + `kind="${l.kind}", ` + `streamId="${e.id}", ` + `streamPurpose="${n.purpose}"` + ") to peer connection"), await i.replaceTrack(l), r = !0
						} catch (a) {
							d.logger.warn("replaceTrack failed: adding new transceiver instead", a)
						}
						if (!r) {
							d.logger.info(`Call ${this.callId} ` + "Adding track (" + `id="${l.id}", ` + `kind="${l.kind}", ` + `streamId="${e.id}", ` + `streamPurpose="${n.purpose}"` + ") to peer connection");
							const i = this.peerConn.addTrack(l, this.localUsermediaStream),
								r = this.peerConn.getTransceivers().find(e => e.sender === i);
							r ? this.transceivers.set(t, r) : d.logger.warn("Couldn't find matching transceiver for newly added track!")
						}
					}
				}
				async setLocalVideoMuted(e) {
					var t;
					return d.logger.log(`call ${this.callId} setLocalVideoMuted ${e}`), await this.client.getMediaHandler().hasVideoDevice() ? this.hasLocalUserMediaVideoTrack || e ? (null === (t = this.localUsermediaFeed) || void 0 === t || t.setAudioVideoMuted(null, e), this.updateMuteStatus(), await this.sendMetadataUpdate(), this.isLocalVideoMuted()) : (await this.upgradeCall(!1, !0), this.isLocalVideoMuted()) : this.isLocalVideoMuted()
				}
				isLocalVideoMuted() {
					var e, t;
					return null !== (e = null === (t = this.localUsermediaFeed) || void 0 === t ? void 0 : t.isVideoMuted()) && void 0 !== e && e
				}
				async setMicrophoneMuted(e) {
					var t;
					return d.logger.log(`call ${this.callId} setMicrophoneMuted ${e}`), await this.client.getMediaHandler().hasAudioDevice() ? this.hasLocalUserMediaAudioTrack || e ? (null === (t = this.localUsermediaFeed) || void 0 === t || t.setAudioVideoMuted(e, null), this.updateMuteStatus(), await this.sendMetadataUpdate(), this.isMicrophoneMuted()) : (await this.upgradeCall(!0, !1), this.isMicrophoneMuted()) : this.isMicrophoneMuted()
				}
				isMicrophoneMuted() {
					var e, t;
					return null !== (e = null === (t = this.localUsermediaFeed) || void 0 === t ? void 0 : t.isAudioMuted()) && void 0 !== e && e
				}
				isRemoteOnHold() {
					return this.remoteOnHold
				}
				setRemoteOnHold(e) {
					if (this.isRemoteOnHold() !== e) {
						this.remoteOnHold = e;
						for (const t of this.peerConn.getTransceivers()) t.direction = e ? "sendonly" : "sendrecv";
						this.updateMuteStatus(), this.sendMetadataUpdate(), this.emit(T.RemoteHoldUnhold, this.remoteOnHold)
					}
				}
				isLocalOnHold() {
					if (this.state !== S.Connected) return !1;
					let e = !0;
					for (const t of this.peerConn.getTransceivers()) {
						["inactive", "recvonly"].includes(t.currentDirection) || (e = !1)
					}
					return e
				}
				sendDtmfDigit(e) {
					for (const i of this.peerConn.getSenders()) {
						var t;
						if ("audio" === (null === (t = i.track) || void 0 === t ? void 0 : t.kind) && i.dtmf) return void i.dtmf.insertDTMF(e)
					}
					throw new Error("Unable to find a track to send DTMF on")
				}
				updateMuteStatus() {
					const e = this.isMicrophoneMuted() || this.remoteOnHold,
						t = this.isLocalVideoMuted() || this.remoteOnHold;
					d.logger.log(`call ${this.callId} updateMuteStatus stream ${this.localUsermediaStream.id} micShouldBeMuted ${e} vidShouldBeMuted ${t}`), D(this.localUsermediaStream.getAudioTracks(), !e), D(this.localUsermediaStream.getVideoTracks(), !t)
				}
				async sendMetadataUpdate() {
					await this.sendVoipEvent(c.EventType.CallSDPStreamMetadataChangedPrefix, {
						[h.SDPStreamMetadataKey]: this.getLocalSDPStreamMetadata()
					})
				}
				gotCallFeedsForInvite(e, t = !1) {
					if (this.successor) this.successor.queueGotCallFeedsForAnswer(e);
					else if (this.callHasEnded()) this.stopAllMedia();
					else {
						for (const t of e) this.pushLocalFeed(t);
						t && this.peerConn.addTransceiver("video", {
							direction: "recvonly"
						}), this.setState(S.CreateOffer), d.logger.debug(`Call ${this.callId} gotUserMediaForInvite`)
					}
				}
				async sendAnswer() {
					const e = {
						answer: {
							sdp: this.peerConn.localDescription.sdp,
							type: this.peerConn.localDescription.type
						},
						[h.SDPStreamMetadataKey]: this.getLocalSDPStreamMetadata(!0)
					};
					e.capabilities = {
						"m.call.transferee": this.client.supportsCallTransfer,
						"m.call.dtmf": !1
					};
					const t = this.discardDuplicateCandidates();
					d.logger.info(`Call ${this.callId} Discarding ${t} candidates that will be sent in answer`);
					try {
						await this.sendVoipEvent(c.EventType.CallAnswer, e), this.inviteOrAnswerSent = !0
					} catch (i) {
						this.setState(S.Ringing), i instanceof v.MatrixError && i.event && this.client.cancelPendingEvent(i.event);
						let e = I.SendAnswer,
							t = "Failed to send answer";
						throw "UnknownDeviceError" == i.name && (e = I.UnknownDevices, t = "Unknown devices present in the room"), this.emit(T.Error, new CallError(e, t, i)), i
					}
					this.sendCandidateQueue()
				}
				queueGotCallFeedsForAnswer(e) {
					this.responsePromiseChain ? this.responsePromiseChain = this.responsePromiseChain.then(() => this.gotCallFeedsForAnswer(e)) : this.responsePromiseChain = this.gotCallFeedsForAnswer(e)
				}
				mungeSdp(e, t) {
					const i = (0, a.parse)(e.sdp);
					i.media.forEach(e => {
						const i = new Map,
							n = new Map;
						for (const t of e.rtp) i.set(t.payload, t.codec), n.set(t.codec, t.payload);
						for (const r of t) {
							if (r.mediaType !== e.type) continue;
							if (!n.has(r.codec)) {
								d.logger.info(`Ignoring SDP modifications for ${r.codec} as it's not present.`);
								continue
							}
							const t = [];
							void 0 !== r.enableDtx && t.push(`usedtx=${r.enableDtx?"1":"0"}`), void 0 !== r.maxAverageBitrate && t.push(`maxaveragebitrate=${r.maxAverageBitrate}`);
							let s = !1;
							for (const n of e.fmtp) i.get(n.payload) === r.codec && (s = !0, n.config += ";" + t.join(";"));
							s || e.fmtp.push({
								payload: n.get(r.codec),
								config: t.join(";")
							})
						}
					}), e.sdp = (0, a.write)(i)
				}
				async createOffer() {
					const e = await this.peerConn.createOffer();
					return this.mungeSdp(e, x(this.isPtt)), e
				}
				async createAnswer() {
					const e = await this.peerConn.createAnswer();
					return this.mungeSdp(e, x(this.isPtt)), e
				}
				async gotCallFeedsForAnswer(e) {
					if (this.callHasEnded()) return;
					this.waitForLocalAVStream = !1;
					for (const n of e) this.pushLocalFeed(n);
					let t;
					this.setState(S.CreateAnswer);
					try {
						this.getRidOfRTXCodecs(), t = await this.createAnswer()
					} catch (i) {
						return d.logger.debug(`Call ${this.callId} Failed to create answer: `, i), void this.terminate(k.Local, I.CreateAnswer, !0)
					}
					try {
						if (await this.peerConn.setLocalDescription(t), this.callHasEnded()) return;
						if (this.setState(S.Connecting), await new Promise(e => {
								setTimeout(e, 200)
							}), this.callHasEnded()) return;
						this.sendAnswer()
					} catch (i) {
						return d.logger.debug(`Call ${this.callId} Error setting local description!`, i), void this.terminate(k.Local, I.SetLocalDescription, !0)
					}
				}
				async onRemoteIceCandidatesReceived(e) {
					if (this.callHasEnded()) return;
					const t = e.getContent(),
						i = t.candidates;
					if (!i) return void d.logger.info(`Call ${this.callId} Ignoring candidates event with no candidates!`);
					const n = 0 === t.version ? null : t.party_id || null;
					if (void 0 !== this.opponentPartyId) this.partyIdMatches(t) ? await this.addIceCandidates(i) : d.logger.info(`Call ${this.callId} ` + `Ignoring candidates from party ID ${t.party_id}: ` + `we have chosen party ID ${this.opponentPartyId}`);
					else if (n) {
						d.logger.info(`Call ${this.callId} Buffering ${i.length} candidates until we pick an opponent`);
						const e = this.remoteCandidateBuffer.get(n) || [];
						e.push(...i), this.remoteCandidateBuffer.set(n, e)
					}
				}
				async onAnswerReceived(e) {
					const t = e.getContent();
					if (d.logger.debug(`Got answer for call ID ${this.callId} from party ID ${t.party_id}`), this.callHasEnded()) return void d.logger.debug(`Ignoring answer because call ID ${this.callId} has ended`);
					if (void 0 !== this.opponentPartyId) return void d.logger.info(`Call ${this.callId} ` + `Ignoring answer from party ID ${t.party_id}: ` + `we already have an answer/reject from ${this.opponentPartyId}`);
					this.chooseOpponent(e), await this.addBufferedIceCandidates(), this.setState(S.Connecting);
					const i = t[h.SDPStreamMetadataKey];
					i ? this.updateRemoteSDPStreamMetadata(i) : d.logger.warn(`Call ${this.callId} Did not get any SDPStreamMetadata! Can not send/receive multiple streams`);
					try {
						await this.peerConn.setRemoteDescription(t.answer)
					} catch (n) {
						return d.logger.debug(`Call ${this.callId} Failed to set remote description`, n), void this.terminate(k.Local, I.SetRemoteDescription, !1)
					}
					if (null !== this.opponentPartyId) try {
						await this.sendVoipEvent(c.EventType.CallSelectAnswer, {
							selected_party_id: this.opponentPartyId
						})
					} catch (r) {
						d.logger.warn(`Call ${this.callId} Failed to send select_answer event`, r)
					}
				}
				async onSelectAnswerReceived(e) {
					if (this.direction !== w.Inbound) return void d.logger.warn(`Call ${this.callId} Got select_answer for an outbound call: ignoring`);
					const t = e.getContent().selected_party_id;
					null != t ? t !== this.ourPartyId && (d.logger.info(`Call ${this.callId} Got select_answer for party ID ${t}: we are party ID ${this.ourPartyId}.`), await this.terminate(k.Remote, I.AnsweredElsewhere, !0)) : d.logger.warn(`Call ${this.callId} Got nonsensical select_answer with null/undefined selected_party_id: ignoring`)
				}
				async onNegotiateReceived(e) {
					const t = e.getContent(),
						i = t.description;
					if (!i || !i.sdp || !i.type) return void d.logger.info(`Call ${this.callId} Ignoring invalid m.call.negotiate event`);
					const n = this.direction === w.Inbound,
						r = "offer" === i.type && (this.makingOffer || "stable" !== this.peerConn.signalingState);
					if (this.ignoreOffer = !n && r, this.ignoreOffer) return void d.logger.info(`Call ${this.callId} Ignoring colliding negotiate event because we're impolite`);
					const s = this.isLocalOnHold(),
						o = t[h.SDPStreamMetadataKey];
					o ? this.updateRemoteSDPStreamMetadata(o) : d.logger.warn(`Call ${this.callId} Received negotiation event without SDPStreamMetadata!`);
					try {
						if (await this.peerConn.setRemoteDescription(i), "offer" === i.type) {
							var a;
							let e;
							try {
								this.getRidOfRTXCodecs(), e = await this.createAnswer()
							} catch (u) {
								return d.logger.debug(`Call ${this.callId} Failed to create answer: `, u), void this.terminate(k.Local, I.CreateAnswer, !0)
							}
							await this.peerConn.setLocalDescription(e), this.sendVoipEvent(c.EventType.CallNegotiate, {
								description: null === (a = this.peerConn.localDescription) || void 0 === a ? void 0 : a.toJSON(),
								[h.SDPStreamMetadataKey]: this.getLocalSDPStreamMetadata(!0)
							})
						}
					} catch (u) {
						d.logger.warn(`Call ${this.callId} Failed to complete negotiation`, u)
					}
					const l = this.isLocalOnHold();
					s !== l && (this.emit(T.LocalHoldUnhold, l), this.emit(T.HoldUnhold, l))
				}
				updateRemoteSDPStreamMetadata(e) {
					this.remoteSDPStreamMetadata = l.recursivelyAssign(this.remoteSDPStreamMetadata || {}, e, !0);
					for (const i of this.getRemoteFeeds()) {
						var t;
						const e = i.stream.id,
							n = this.remoteSDPStreamMetadata[e];
						i.setAudioVideoMuted(null == n ? void 0 : n.audio_muted, null == n ? void 0 : n.video_muted), i.purpose = null === (t = this.remoteSDPStreamMetadata[e]) || void 0 === t ? void 0 : t.purpose
					}
				}
				onSDPStreamMetadataChangedReceived(e) {
					const t = e.getContent()[h.SDPStreamMetadataKey];
					this.updateRemoteSDPStreamMetadata(t)
				}
				async onAssertedIdentityReceived(e) {
					const t = e.getContent();
					t.asserted_identity && (this.remoteAssertedIdentity = {
						id: t.asserted_identity.id,
						displayName: t.asserted_identity.display_name
					}, this.emit(T.AssertedIdentityChanged))
				}
				callHasEnded() {
					return this.state === S.Ended
				}
				queueGotLocalOffer() {
					this.responsePromiseChain ? this.responsePromiseChain = this.responsePromiseChain.then(() => this.wrappedGotLocalOffer()) : this.responsePromiseChain = this.wrappedGotLocalOffer()
				}
				async wrappedGotLocalOffer() {
					this.makingOffer = !0;
					try {
						await this.gotLocalOffer()
					} catch (e) {
						return void this.getLocalOfferFailed(e)
					} finally {
						this.makingOffer = !1
					}
				}
				async gotLocalOffer() {
					if (d.logger.debug(`Call ${this.callId} Setting local description`), this.callHasEnded()) return void d.logger.debug("Ignoring newly created offer on call ID " + this.callId + " because the call has ended");
					let e;
					try {
						this.getRidOfRTXCodecs(), e = await this.createOffer()
					} catch (o) {
						return d.logger.debug(`Call ${this.callId} Failed to create offer: `, o), void this.terminate(k.Local, I.CreateOffer, !0)
					}
					try {
						await this.peerConn.setLocalDescription(e)
					} catch (o) {
						return d.logger.debug(`Call ${this.callId} Error setting local description!`, o), void this.terminate(k.Local, I.SetLocalDescription, !0)
					}
					if ("gathering" === this.peerConn.iceGatheringState && await new Promise(e => {
							setTimeout(e, 200)
						}), this.callHasEnded()) return;
					const t = this.state === S.CreateOffer ? c.EventType.CallInvite : c.EventType.CallNegotiate,
						i = {
							lifetime: j
						};
					var n, r;
					(t === c.EventType.CallInvite && this.invitee && (i.invitee = this.invitee), this.state === S.CreateOffer) ? i.offer = null === (n = this.peerConn.localDescription) || void 0 === n ? void 0 : n.toJSON(): i.description = null === (r = this.peerConn.localDescription) || void 0 === r ? void 0 : r.toJSON();
					i.capabilities = {
						"m.call.transferee": this.client.supportsCallTransfer,
						"m.call.dtmf": !1
					}, i[h.SDPStreamMetadataKey] = this.getLocalSDPStreamMetadata(!0);
					const s = this.discardDuplicateCandidates();
					d.logger.info(`Call ${this.callId} Discarding ${s} candidates that will be sent in offer`);
					try {
						await this.sendVoipEvent(t, i)
					} catch (a) {
						d.logger.error(`Call ${this.callId} Failed to send invite`, a), a instanceof v.MatrixError && a.event && this.client.cancelPendingEvent(a.event);
						let e = I.SignallingFailed,
							t = "Signalling failed";
						return this.state === S.CreateOffer && (e = I.SendInvite, t = "Failed to send invite"), "UnknownDeviceError" == a.name && (e = I.UnknownDevices, t = "Unknown devices present in the room"), this.emit(T.Error, new CallError(e, t, a)), void this.terminate(k.Local, e, !1)
					}
					this.sendCandidateQueue(), this.state === S.CreateOffer && (this.inviteOrAnswerSent = !0, this.setState(S.InviteSent), this.inviteTimeout = setTimeout(() => {
						this.inviteTimeout = void 0, this.state === S.InviteSent && this.hangup(I.InviteTimeout, !1)
					}, j))
				}
				getRidOfRTXCodecs() {
					if (!RTCRtpReceiver.getCapabilities || !RTCRtpSender.getCapabilities) return;
					const e = RTCRtpReceiver.getCapabilities("video").codecs,
						t = [...RTCRtpSender.getCapabilities("video").codecs, ...e];
					for (const n of t)
						if ("video/rtx" === n.mimeType) {
							const e = t.indexOf(n);
							t.splice(e, 1)
						} const i = this.transceivers.get(M(h.SDPStreamMetadataPurpose.Screenshare, "video"));
					i && i.setCodecPreferences(t)
				}
				setState(e) {
					const t = this.state;
					this.state = e, this.emit(T.State, e, t)
				}
				async sendVoipEvent(e, t) {
					const i = Object.assign({}, t, {
						version: C,
						call_id: this.callId,
						party_id: this.ourPartyId,
						conf_id: this.groupCallId
					});
					if (this.opponentDeviceId) {
						var n;
						const t = this.toDeviceSeq++,
							r = _(_({}, i), {}, {
								device_id: this.client.deviceId,
								sender_session_id: this.client.getSessionId(),
								dest_session_id: this.opponentSessionId,
								seq: t
							});
						this.emit(T.SendVoipEvent, {
							type: "toDevice",
							eventType: e,
							userId: this.invitee || (null === (n = this.getOpponentMember()) || void 0 === n ? void 0 : n.userId),
							opponentDeviceId: this.opponentDeviceId,
							content: r
						});
						const s = this.invitee || this.getOpponentMember().userId;
						this.client.getUseE2eForGroupCall() ? await this.client.encryptAndSendToDevices([{
							userId: s,
							deviceInfo: this.opponentDeviceInfo
						}], {
							type: e,
							content: r
						}) : await this.client.sendToDevice(e, {
							[s]: {
								[this.opponentDeviceId]: r
							}
						})
					} else {
						var r;
						this.emit(T.SendVoipEvent, {
							type: "sendEvent",
							eventType: e,
							roomId: this.roomId,
							content: i,
							userId: this.invitee || (null === (r = this.getOpponentMember()) || void 0 === r ? void 0 : r.userId)
						}), await this.client.sendEvent(this.roomId, e, i)
					}
				}
				queueCandidate(e) {
					if (e ? this.candidateSendQueue.push(e) : this.candidatesEnded = !0, this.state === S.Ringing || !this.inviteOrAnswerSent) return;
					const t = this.direction === w.Inbound ? 500 : 2e3;
					0 === this.candidateSendTries && setTimeout(() => {
						this.sendCandidateQueue()
					}, t)
				}
				discardDuplicateCandidates() {
					let e = 0;
					const t = [];
					for (let i = 0; i < this.candidateSendQueue.length; i++) {
						const n = this.candidateSendQueue[i];
						"" === n.candidate ? t.push(n) : e++
					}
					return this.candidateSendQueue = t, e
				}
				async transfer(e) {
					const t = await this.client.getProfileInfo(e),
						i = O(),
						n = {
							replacement_id: O(),
							target_user: {
								id: e,
								display_name: t.displayname,
								avatar_url: t.avatar_url
							},
							create_call: i
						};
					await this.sendVoipEvent(c.EventType.CallReplaces, n), await this.terminate(k.Local, I.Transfered, !0)
				}
				async transferToCall(e) {
					var t, i;
					const n = null === (t = e.getOpponentMember()) || void 0 === t ? void 0 : t.userId,
						r = n ? await this.client.getProfileInfo(n) : void 0,
						s = null === (i = this.getOpponentMember()) || void 0 === i ? void 0 : i.userId,
						o = s ? await this.client.getProfileInfo(s) : void 0,
						a = O(),
						d = {
							replacement_id: O(),
							target_user: {
								id: s,
								display_name: null == o ? void 0 : o.displayname,
								avatar_url: null == o ? void 0 : o.avatar_url
							},
							await_call: a
						};
					await e.sendVoipEvent(c.EventType.CallReplaces, d);
					const l = {
						replacement_id: O(),
						target_user: {
							id: n,
							display_name: null == r ? void 0 : r.displayname,
							avatar_url: null == r ? void 0 : r.avatar_url
						},
						create_call: a
					};
					await this.sendVoipEvent(c.EventType.CallReplaces, l), await this.terminate(k.Local, I.Transfered, !0), await e.terminate(k.Local, I.Transfered, !0)
				}
				async terminate(e, t, i) {
					if (!this.callHasEnded()) {
						this.hangupParty = e, this.hangupReason = t, this.setState(S.Ended), this.inviteTimeout && (clearTimeout(this.inviteTimeout), this.inviteTimeout = void 0), this.callLengthInterval && (clearInterval(this.callLengthInterval), this.callLengthInterval = void 0);
						for (const [e, t] of this.removeTrackListeners) e.removeEventListener("removetrack", t);
						this.removeTrackListeners.clear(), this.callStatsAtEnd = await this.collectCallStats(), this.stopAllMedia(), this.deleteAllFeeds(), this.peerConn && "closed" !== this.peerConn.signalingState && this.peerConn.close(), i && this.emit(T.Hangup, this), this.client.callEventHandler.calls.delete(this.callId)
					}
				}
				stopAllMedia() {
					d.logger.debug(this.groupCallId ? `Call ${this.callId} stopping all media except local feeds` : `Call ${this.callId} stopping all media`);
					for (const e of this.feeds)
						if (e.isLocal() && e.purpose === h.SDPStreamMetadataPurpose.Usermedia && !this.groupCallId) this.client.getMediaHandler().stopUserMediaStream(e.stream);
						else if (e.isLocal() && e.purpose === h.SDPStreamMetadataPurpose.Screenshare && !this.groupCallId) this.client.getMediaHandler().stopScreensharingStream(e.stream);
					else if (!e.isLocal() || !this.groupCallId) {
						d.logger.debug("Stopping remote stream", e.stream.id);
						for (const t of e.stream.getTracks()) t.stop()
					}
				}
				checkForErrorListener() {
					if (0 === this.listeners(p.EventEmitterEvents.Error).length) throw new Error("You MUST attach an error listener using call.on('error', function() {})")
				}
				async sendCandidateQueue() {
					if (0 === this.candidateSendQueue.length || this.callHasEnded()) return;
					const e = this.candidateSendQueue;
					this.candidateSendQueue = [], ++this.candidateSendTries;
					const t = {
						candidates: e.map(e => e.toJSON())
					};
					this.candidatesEnded && t.candidates.push({
						candidate: ""
					}), d.logger.debug(`Call ${this.callId} attempting to send ${e.length} candidates`);
					try {
						await this.sendVoipEvent(c.EventType.CallCandidates, t), this.candidateSendTries = 0, this.sendCandidateQueue()
					} catch (i) {
						if (i instanceof v.MatrixError && i.event && this.client.cancelPendingEvent(i.event), this.candidateSendQueue.push(...e), this.candidateSendTries > 5) {
							d.logger.debug(`Call ${this.callId} failed to send candidates on attempt ${this.candidateSendTries}. Giving up on this call.`, i);
							const e = I.SignallingFailed,
								t = "Signalling failed";
							return this.emit(T.Error, new CallError(e, t, i)), void this.hangup(e, !1)
						}
						const t = 500 * Math.pow(2, this.candidateSendTries);
						++this.candidateSendTries, d.logger.debug(`Call ${this.callId} failed to send candidates. Retrying in ${t}ms`, i), setTimeout(() => {
							this.sendCandidateQueue()
						}, t)
					}
				}
				async placeCall(e, t) {
					if (!e) throw new Error("You CANNOT start a call without audio");
					this.setState(S.WaitLocalMedia);
					try {
						const i = await this.client.getMediaHandler().getUserMediaStream(e, t);
						D(i.getAudioTracks(), !0), D(i.getVideoTracks(), !0);
						const n = new m.CallFeed({
							client: this.client,
							roomId: this.roomId,
							userId: this.client.getUserId(),
							stream: i,
							purpose: h.SDPStreamMetadataPurpose.Usermedia,
							audioMuted: !1,
							videoMuted: !1
						});
						await this.placeCallWithCallFeeds([n])
					} catch (i) {
						return void this.getUserMediaFailed(i)
					}
				}
				async placeCallWithCallFeeds(e, t = !1) {
					this.checkForErrorListener(), this.direction = w.Outbound, await this.initOpponentCrypto(), this.client.callEventHandler.calls.set(this.callId, this), await this.client.checkTurnServers() || d.logger.warn(`Call ${this.callId} Failed to get TURN credentials! Proceeding with call anyway...`), this.peerConn = this.createPeerConnection(), this.gotCallFeedsForInvite(e, t)
				}
				createPeerConnection() {
					const e = new window.RTCPeerConnection({
						iceTransportPolicy: this.forceTURN ? "relay" : void 0,
						iceServers: this.turnServers,
						iceCandidatePoolSize: this.client.iceCandidatePoolSize,
						bundlePolicy: "max-bundle"
					});
					return e.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChanged), e.addEventListener("signalingstatechange", this.onSignallingStateChanged), e.addEventListener("icecandidate", this.gotLocalIceCandidate), e.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange), e.addEventListener("track", this.onTrack), e.addEventListener("negotiationneeded", this.onNegotiationNeeded), e.addEventListener("datachannel", this.onDataChannel), e
				}
				partyIdMatches(e) {
					return (0 === e.version ? null : e.party_id || null) === this.opponentPartyId
				}
				chooseOpponent(e) {
					var t;
					const i = e.getContent();
					d.logger.debug(`Call ${this.callId} choosing opponent party ID ${i.party_id}`), this.opponentVersion = i.version, 0 === this.opponentVersion ? this.opponentPartyId = null : this.opponentPartyId = i.party_id || null, this.opponentCaps = i.capabilities || {}, this.opponentMember = null !== (t = this.client.getRoom(this.roomId).getMember(e.getSender())) && void 0 !== t ? t : void 0
				}
				async addBufferedIceCandidates() {
					const e = this.remoteCandidateBuffer.get(this.opponentPartyId);
					e && (d.logger.info(`Call ${this.callId} Adding ${e.length} buffered candidates for opponent ${this.opponentPartyId}`), await this.addIceCandidates(e)), this.remoteCandidateBuffer.clear()
				}
				async addIceCandidates(e) {
					for (const i of e) {
						null !== i.sdpMid && void 0 !== i.sdpMid || null !== i.sdpMLineIndex && void 0 !== i.sdpMLineIndex ? d.logger.debug(`Call ${this.callId} got remote ICE ${i.sdpMid} candidate: ${i.candidate}`) : d.logger.debug(`Call ${this.callId} got remote ICE end-of-candidates`);
						try {
							await this.peerConn.addIceCandidate(i)
						} catch (t) {
							this.ignoreOffer || d.logger.info(`Call ${this.callId} failed to add remote ICE candidate`, t)
						}
					}
				}
				get hasPeerConnection() {
					return Boolean(this.peerConn)
				}
			}

			function D(e, t) {
				for (const i of e) i.enabled = t
			}

			function A() {
				if ("undefined" == typeof window || "undefined" == typeof document) return !1;
				try {
					if (!Boolean(window.RTCPeerConnection || window.RTCSessionDescription || window.RTCIceCandidate || navigator.mediaDevices)) return d.logger.error("WebRTC is not supported in this browser / environment"), !1
				} catch (e) {
					return d.logger.error("Exception thrown when trying to access WebRTC", e), !1
				}
				return !0
			}
			t.MatrixCall = P
		},
		"./node_modules/matrix-js-sdk/lib/webrtc/callEventHandler.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.CallEventHandlerEvent = t.CallEventHandler = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				o = i("./node_modules/matrix-js-sdk/lib/webrtc/call.js"),
				a = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				d = i("./node_modules/matrix-js-sdk/lib/client.js"),
				l = i("./node_modules/matrix-js-sdk/lib/webrtc/groupCall.js"),
				c = i("./node_modules/matrix-js-sdk/lib/models/room.js");
			const u = 3e3;
			let h;
			t.CallEventHandlerEvent = h,
				function(e) {
					e.Incoming = "Call.incoming"
				}(h || (t.CallEventHandlerEvent = h = {}));
			t.CallEventHandler = class {
				constructor(e) {
					(0, r.default)(this, "calls", void 0), (0, r.default)(this, "callEventBuffer", void 0), (0, r.default)(this, "nextSeqByCall", new Map), (0, r.default)(this, "toDeviceEventBuffers", new Map), (0, r.default)(this, "client", void 0), (0, r.default)(this, "candidateEventsByCall", void 0), (0, r.default)(this, "eventBufferPromiseChain", void 0), (0, r.default)(this, "onSync", () => {
						const e = this.callEventBuffer;
						this.callEventBuffer = [], this.eventBufferPromiseChain ? this.eventBufferPromiseChain = this.eventBufferPromiseChain.then(() => this.evaluateEventBuffer(e)) : this.eventBufferPromiseChain = this.evaluateEventBuffer(e)
					}), (0, r.default)(this, "onRoomTimeline", e => {
						this.callEventBuffer.push(e)
					}), (0, r.default)(this, "onToDeviceEvent", e => {
						const t = e.getContent();
						if (!t.call_id) return void this.callEventBuffer.push(e);
						if (this.nextSeqByCall.has(t.call_id) || this.nextSeqByCall.set(t.call_id, 0), void 0 === t.seq) return void this.callEventBuffer.push(e);
						const i = this.nextSeqByCall.get(t.call_id) || 0;
						if (t.seq !== i) {
							this.toDeviceEventBuffers.has(t.call_id) || this.toDeviceEventBuffers.set(t.call_id, []);
							const i = this.toDeviceEventBuffers.get(t.call_id),
								n = i.findIndex(e => e.getContent().seq > t.seq); - 1 === n ? i.push(e) : i.splice(n, 0, e)
						} else {
							const i = t.call_id;
							this.callEventBuffer.push(e), this.nextSeqByCall.set(i, t.seq + 1);
							const n = this.toDeviceEventBuffers.get(i);
							let r = n && n.shift();
							for (; r && r.getContent().seq === this.nextSeqByCall.get(i);) this.callEventBuffer.push(r), this.nextSeqByCall.set(i, r.getContent().seq + 1), r = n.shift()
						}
					}), this.client = e, this.calls = new Map, this.callEventBuffer = [], this.candidateEventsByCall = new Map
				}
				start() {
					this.client.on(d.ClientEvent.Sync, this.onSync), this.client.on(c.RoomEvent.Timeline, this.onRoomTimeline), this.client.on(d.ClientEvent.ToDeviceEvent, this.onToDeviceEvent)
				}
				stop() {
					this.client.removeListener(d.ClientEvent.Sync, this.onSync), this.client.removeListener(c.RoomEvent.Timeline, this.onRoomTimeline), this.client.removeListener(d.ClientEvent.ToDeviceEvent, this.onToDeviceEvent)
				}
				async evaluateEventBuffer(e) {
					await Promise.all(e.map(e => this.client.decryptEventIfNeeded(e)));
					const t = e.filter(e => {
							const t = e.getType();
							return t.startsWith("m.call.") || t.startsWith("org.matrix.call.")
						}),
						i = new Set;
					for (const r of t) {
						const e = r.getType();
						e !== a.EventType.CallAnswer && e !== a.EventType.CallHangup || i.add(r.getContent().call_id)
					}
					for (const r of t) {
						const e = r.getType(),
							t = r.getContent().call_id;
						if (e !== a.EventType.CallInvite || !i.has(t)) try {
							await this.handleCallEvent(r)
						} catch (n) {
							s.logger.error("Caught exception handling call event", n)
						}
					}
				}
				async handleCallEvent(e) {
					var t, i;
					this.client.emit(d.ClientEvent.ReceivedVoipEvent, e);
					const n = e.getContent(),
						r = e.getRoomId() || (null === (t = this.client.groupCallEventHandler.getGroupCallById(n.conf_id)) || void 0 === t ? void 0 : null === (i = t.room) || void 0 === i ? void 0 : i.roomId),
						c = n.conf_id,
						m = e.getType(),
						p = e.getSender(),
						g = p === this.client.credentials.userId;
					let f, v, y = n.call_id ? this.calls.get(n.call_id) : void 0;
					if (c) {
						if (!(v = this.client.groupCallEventHandler.getGroupCallById(c))) return void s.logger.warn(`Cannot find a group call ${c} for event ${m}. Ignoring event.`);
						if (!(f = n.device_id)) return s.logger.warn(`Cannot find a device id for ${p}. Ignoring event.`), void v.emit(l.GroupCallEvent.Error, new l.GroupCallUnknownDeviceError(p));
						if (n.dest_session_id !== this.client.getSessionId()) return void s.logger.warn("Call event does not match current session id, ignoring.")
					}
					if (r)
						if (m !== a.EventType.CallInvite)
							if (m !== a.EventType.CallCandidates) {
								var b;
								if ([a.EventType.CallHangup, a.EventType.CallReject].includes(m)) y ? y.state !== o.CallState.Ended && (m === a.EventType.CallHangup ? y.onHangupReceived(n) : y.onRejectReceived(n), y.state === o.CallState.Ended && this.calls.delete(n.call_id)) : (y = null !== (b = (0, o.createNewMatrixCall)(this.client, r, {
									opponentDeviceId: f,
									opponentSessionId: n.sender_session_id
								})) && void 0 !== b ? b : void 0) && (y.callId = n.call_id, y.initWithHangup(e), this.calls.set(n.call_id, y));
								else if (y && y.hasPeerConnection) {
									if (e.getContent().party_id !== y.ourPartyId) switch (m) {
										case a.EventType.CallAnswer:
											g ? y.state === o.CallState.Ringing && y.onAnsweredElsewhere(n) : y.onAnswerReceived(e);
											break;
										case a.EventType.CallSelectAnswer:
											y.onSelectAnswerReceived(e);
											break;
										case a.EventType.CallNegotiate:
											y.onNegotiateReceived(e);
											break;
										case a.EventType.CallAssertedIdentity:
										case a.EventType.CallAssertedIdentityPrefix:
											y.onAssertedIdentityReceived(e);
											break;
										case a.EventType.CallSDPStreamMetadataChanged:
										case a.EventType.CallSDPStreamMetadataChangedPrefix:
											y.onSDPStreamMetadataChangedReceived(e)
									}
								} else s.logger.info(`Discarding possible call event ${e.getId()} as we don't have a call/peerConn`, m)
							} else {
								if (g) return;
								y ? y.onRemoteIceCandidatesReceived(e) : (this.candidateEventsByCall.has(n.call_id) || this.candidateEventsByCall.set(n.call_id, []), this.candidateEventsByCall.get(n.call_id).push(e))
							}
					else {
						var _, S;
						if (g) return;
						if (e.getLocalAge() > n.lifetime - u) return;
						if (y && y.state === o.CallState.Ended) return;
						if (y && s.logger.log(`WARN: Already have a MatrixCall with id ${n.call_id} but got an ` + "invite. Clobbering."), n.invitee && n.invitee !== this.client.getUserId()) return;
						const t = (null !== (_ = this.client.getTurnServersExpiry()) && void 0 !== _ ? _ : 0) - Date.now();
						if (s.logger.info("Current turn creds expire in " + t + " ms"), !(y = null !== (S = (0, o.createNewMatrixCall)(this.client, r, {
								forceTURN: this.client.forceTURN,
								opponentDeviceId: f,
								groupCallId: c,
								opponentSessionId: n.sender_session_id
							})) && void 0 !== S ? S : void 0)) return void s.logger.log("Incoming call ID " + n.call_id + " but this client doesn't support WebRTC");
						y.callId = n.call_id;
						try {
							await y.initWithInvite(e)
						} catch (k) {
							var E;
							if (k instanceof o.CallError)
								if (k.code === l.GroupCallErrorCode.UnknownDevice) null === (E = v) || void 0 === E || E.emit(l.GroupCallEvent.Error, k);
								else s.logger.error(k)
						}
						if (this.calls.set(y.callId, y), this.candidateEventsByCall.get(y.callId))
							for (const e of this.candidateEventsByCall.get(y.callId)) y.onRemoteIceCandidatesReceived(e);
						let i;
						for (const e of this.calls.values()) {
							var w;
							const t = [o.CallState.WaitLocalMedia, o.CallState.CreateOffer, o.CallState.InviteSent].includes(e.state);
							if (y.roomId === e.roomId && e.direction === o.CallDirection.Outbound && (null === (w = y.getOpponentMember()) || void 0 === w ? void 0 : w.userId) === e.invitee && t) {
								i = e;
								break
							}
						}
						i ? i.callId > y.callId ? (s.logger.log("Glare detected: answering incoming call " + y.callId + " and canceling outgoing call " + i.callId), i.replacedBy(y)) : (s.logger.log("Glare detected: rejecting incoming call " + y.callId + " and keeping outgoing call " + i.callId), y.hangup(o.CallErrorCode.Replaced, !0)) : this.client.emit(h.Incoming, y)
					}
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/webrtc/callEventTypes.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.SDPStreamMetadataPurpose = t.SDPStreamMetadataKey = void 0;
			let n;
			t.SDPStreamMetadataKey = "org.matrix.msc3077.sdp_stream_metadata", t.SDPStreamMetadataPurpose = n,
				function(e) {
					e.Usermedia = "m.usermedia", e.Screenshare = "m.screenshare"
				}(n || (t.SDPStreamMetadataPurpose = n = {}))
		},
		"./node_modules/matrix-js-sdk/lib/webrtc/callFeed.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.SPEAKING_THRESHOLD = t.CallFeedEvent = t.CallFeed = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/webrtc/callEventTypes.js"),
				o = i("./node_modules/matrix-js-sdk/lib/webrtc/audioContext.js"),
				a = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				d = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js");
			const l = 200,
				c = -60;
			t.SPEAKING_THRESHOLD = c;
			const u = 8;
			let h;
			t.CallFeedEvent = h,
				function(e) {
					e.NewStream = "new_stream", e.MuteStateChanged = "mute_state_changed", e.LocalVolumeChanged = "local_volume_changed", e.VolumeChanged = "volume_changed", e.Speaking = "speaking", e.Disposed = "disposed"
				}(h || (t.CallFeedEvent = h = {}));
			class m extends d.TypedEventEmitter {
				constructor(e) {
					super(), (0, r.default)(this, "stream", void 0), (0, r.default)(this, "sdpMetadataStreamId", void 0), (0, r.default)(this, "userId", void 0), (0, r.default)(this, "purpose", void 0), (0, r.default)(this, "speakingVolumeSamples", void 0), (0, r.default)(this, "client", void 0), (0, r.default)(this, "roomId", void 0), (0, r.default)(this, "audioMuted", void 0), (0, r.default)(this, "videoMuted", void 0), (0, r.default)(this, "localVolume", 1), (0, r.default)(this, "measuringVolumeActivity", !1), (0, r.default)(this, "audioContext", void 0), (0, r.default)(this, "analyser", void 0), (0, r.default)(this, "frequencyBinCount", void 0), (0, r.default)(this, "speakingThreshold", c), (0, r.default)(this, "speaking", !1), (0, r.default)(this, "volumeLooperTimeout", void 0), (0, r.default)(this, "_disposed", !1), (0, r.default)(this, "onAddTrack", () => {
						this.emit(h.NewStream, this.stream)
					}), (0, r.default)(this, "volumeLooper", () => {
						if (!this.analyser) return;
						if (!this.measuringVolumeActivity) return;
						this.analyser.getFloatFrequencyData(this.frequencyBinCount);
						let e = -1 / 0;
						for (const i of this.frequencyBinCount) i > e && (e = i);
						this.speakingVolumeSamples.shift(), this.speakingVolumeSamples.push(e), this.emit(h.VolumeChanged, e);
						let t = !1;
						for (const i of this.speakingVolumeSamples)
							if (i > this.speakingThreshold) {
								t = !0;
								break
							} this.speaking !== t && (this.speaking = t, this.emit(h.Speaking, this.speaking)), this.volumeLooperTimeout = setTimeout(this.volumeLooper, l)
					}), this.client = e.client, this.roomId = e.roomId, this.userId = e.userId, this.purpose = e.purpose, this.audioMuted = e.audioMuted, this.videoMuted = e.videoMuted, this.speakingVolumeSamples = new Array(u).fill(-1 / 0), this.sdpMetadataStreamId = e.stream.id, this.updateStream(null, e.stream), this.stream = e.stream, this.hasAudioTrack && this.initVolumeMeasuring()
				}
				get hasAudioTrack() {
					return this.stream.getAudioTracks().length > 0
				}
				updateStream(e, t) {
					t !== e && (e && (e.removeEventListener("addtrack", this.onAddTrack), this.measureVolumeActivity(!1)), this.stream = t, t.addEventListener("addtrack", this.onAddTrack), this.hasAudioTrack ? this.initVolumeMeasuring() : this.measureVolumeActivity(!1), this.emit(h.NewStream, this.stream))
				}
				initVolumeMeasuring() {
					if (!this.hasAudioTrack) return;
					this.audioContext || (this.audioContext = (0, o.acquireContext)()), this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 512, this.analyser.smoothingTimeConstant = .1, this.audioContext.createMediaStreamSource(this.stream).connect(this.analyser), this.frequencyBinCount = new Float32Array(this.analyser.frequencyBinCount)
				}
				getMember() {
					var e;
					const t = this.client.getRoom(this.roomId);
					return null !== (e = null == t ? void 0 : t.getMember(this.userId)) && void 0 !== e ? e : null
				}
				isLocal() {
					return this.userId === this.client.getUserId()
				}
				isAudioMuted() {
					return 0 === this.stream.getAudioTracks().length || this.audioMuted
				}
				isVideoMuted() {
					return 0 === this.stream.getVideoTracks().length || this.videoMuted
				}
				isSpeaking() {
					return this.speaking
				}
				setNewStream(e) {
					this.updateStream(this.stream, e)
				}
				setAudioVideoMuted(e, t) {
					null !== e && (this.audioMuted !== e && this.speakingVolumeSamples.fill(-1 / 0), this.audioMuted = e), null !== t && (this.videoMuted = t), this.emit(h.MuteStateChanged, this.audioMuted, this.videoMuted)
				}
				measureVolumeActivity(e) {
					if (e) {
						if (!this.analyser || !this.frequencyBinCount || !this.hasAudioTrack) return;
						this.measuringVolumeActivity = !0, this.volumeLooper()
					} else this.measuringVolumeActivity = !1, this.speakingVolumeSamples.fill(-1 / 0), this.emit(h.VolumeChanged, -1 / 0)
				}
				setSpeakingThreshold(e) {
					this.speakingThreshold = e
				}
				clone() {
					const e = this.client.getMediaHandler(),
						t = this.stream.clone();
					return a.logger.log(`callFeed cloning stream ${this.stream.id} newStream ${t.id}`), this.purpose === s.SDPStreamMetadataPurpose.Usermedia ? e.userMediaStreams.push(t) : e.screensharingStreams.push(t), new m({
						client: this.client,
						roomId: this.roomId,
						userId: this.userId,
						stream: t,
						purpose: this.purpose,
						audioMuted: this.audioMuted,
						videoMuted: this.videoMuted
					})
				}
				dispose() {
					var e;
					clearTimeout(this.volumeLooperTimeout), null === (e = this.stream) || void 0 === e || e.removeEventListener("addtrack", this.onAddTrack), this.audioContext && (this.audioContext = void 0, this.analyser = void 0, (0, o.releaseContext)()), this._disposed = !0, this.emit(h.Disposed)
				}
				get disposed() {
					return this._disposed
				}
				set disposed(e) {
					this._disposed = e
				}
				getLocalVolume() {
					return this.localVolume
				}
				setLocalVolume(e) {
					this.localVolume = e, this.emit(h.LocalVolumeChanged, e)
				}
			}
			t.CallFeed = m
		},
		"./node_modules/matrix-js-sdk/lib/webrtc/groupCall.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.OtherUserSpeakingError = t.GroupCallUnknownDeviceError = t.GroupCallType = t.GroupCallTerminationReason = t.GroupCallState = t.GroupCallIntent = t.GroupCallEvent = t.GroupCallErrorCode = t.GroupCallError = t.GroupCall = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js"),
				o = i("./node_modules/matrix-js-sdk/lib/webrtc/callFeed.js"),
				a = i("./node_modules/matrix-js-sdk/lib/webrtc/call.js"),
				d = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				l = i("./node_modules/matrix-js-sdk/lib/ReEmitter.js"),
				c = i("./node_modules/matrix-js-sdk/lib/webrtc/callEventTypes.js"),
				u = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				h = i("./node_modules/matrix-js-sdk/lib/webrtc/callEventHandler.js"),
				m = i("./node_modules/matrix-js-sdk/lib/webrtc/groupCallEventHandler.js");

			function p(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function g(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? p(Object(i), !0).forEach((function(t) {
						(0, r.default)(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : p(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}
			let f, v, y, b, _, S;
			t.GroupCallIntent = f,
				function(e) {
					e.Ring = "m.ring", e.Prompt = "m.prompt", e.Room = "m.room"
				}(f || (t.GroupCallIntent = f = {})), t.GroupCallType = v,
				function(e) {
					e.Video = "m.video", e.Voice = "m.voice"
				}(v || (t.GroupCallType = v = {})), t.GroupCallTerminationReason = y,
				function(e) {
					e.CallEnded = "call_ended"
				}(y || (t.GroupCallTerminationReason = y = {})), t.GroupCallEvent = b,
				function(e) {
					e.GroupCallStateChanged = "group_call_state_changed", e.ActiveSpeakerChanged = "active_speaker_changed", e.CallsChanged = "calls_changed", e.UserMediaFeedsChanged = "user_media_feeds_changed", e.ScreenshareFeedsChanged = "screenshare_feeds_changed", e.LocalScreenshareStateChanged = "local_screenshare_state_changed", e.LocalMuteStateChanged = "local_mute_state_changed", e.ParticipantsChanged = "participants_changed", e.Error = "error"
				}(b || (t.GroupCallEvent = b = {})), t.GroupCallErrorCode = _,
				function(e) {
					e.NoUserMedia = "no_user_media", e.UnknownDevice = "unknown_device", e.PlaceCallFailed = "place_call_failed"
				}(_ || (t.GroupCallErrorCode = _ = {}));
			class GroupCallError extends Error {
				constructor(e, t, i) {
					i ? (super(t + ": " + i), (0, r.default)(this, "code", void 0)) : (super(t), (0, r.default)(this, "code", void 0)), this.code = e
				}
			}
			t.GroupCallError = GroupCallError;
			class GroupCallUnknownDeviceError extends GroupCallError {
				constructor(e) {
					super(_.UnknownDevice, "No device found for " + e), this.userId = e
				}
			}
			t.GroupCallUnknownDeviceError = GroupCallUnknownDeviceError;
			class OtherUserSpeakingError extends Error {
				constructor() {
					super("Cannot unmute: another user is speaking")
				}
			}
			t.OtherUserSpeakingError = OtherUserSpeakingError, t.GroupCallState = S,
				function(e) {
					e.LocalCallFeedUninitialized = "local_call_feed_uninitialized", e.InitializingLocalCallFeed = "initializing_local_call_feed", e.LocalCallFeedInitialized = "local_call_feed_initialized", e.Entering = "entering", e.Entered = "entered", e.Ended = "ended"
				}(S || (t.GroupCallState = S = {}));
			const E = 36e5,
				w = e => {
					var t;
					const i = Date.now(),
						n = null !== (t = null == e ? void 0 : e.getContent()) && void 0 !== t ? t : {};
					return ("number" == typeof n["m.expires_ts"] ? n["m.expires_ts"] : -1 / 0) <= i
				};

			function k(e) {
				var t;
				return (null === (t = e.getOpponentMember()) || void 0 === t ? void 0 : t.userId) || e.invitee || null
			}
			class T extends s.TypedEventEmitter {
				constructor(e, t, i, n, s, u, h, m) {
					super(), this.client = e, this.room = t, this.type = i, this.isPtt = n, this.intent = s, this.dataChannelsEnabled = h, this.dataChannelOptions = m, (0, r.default)(this, "activeSpeakerInterval", 1e3), (0, r.default)(this, "retryCallInterval", 5e3), (0, r.default)(this, "participantTimeout", 15e3), (0, r.default)(this, "pttMaxTransmitTime", 2e4), (0, r.default)(this, "state", S.LocalCallFeedUninitialized), (0, r.default)(this, "activeSpeaker", void 0), (0, r.default)(this, "localCallFeed", void 0), (0, r.default)(this, "localScreenshareFeed", void 0), (0, r.default)(this, "localDesktopCapturerSourceId", void 0), (0, r.default)(this, "calls", []), (0, r.default)(this, "participants", []), (0, r.default)(this, "userMediaFeeds", []), (0, r.default)(this, "screenshareFeeds", []), (0, r.default)(this, "groupCallId", void 0), (0, r.default)(this, "callHandlers", new Map), (0, r.default)(this, "activeSpeakerLoopTimeout", void 0), (0, r.default)(this, "retryCallLoopTimeout", void 0), (0, r.default)(this, "retryCallCounts", new Map), (0, r.default)(this, "reEmitter", void 0), (0, r.default)(this, "transmitTimer", null), (0, r.default)(this, "memberStateExpirationTimers", new Map), (0, r.default)(this, "resendMemberStateTimer", null), (0, r.default)(this, "initWithAudioMuted", !1), (0, r.default)(this, "initWithVideoMuted", !1), (0, r.default)(this, "onIncomingCall", e => {
						var t;
						if (e.roomId !== this.room.roomId) return;
						if (e.state !== a.CallState.Ringing) return void d.logger.warn("Incoming call no longer in ringing state. Ignoring.");
						if (!e.groupCallId || e.groupCallId !== this.groupCallId) return d.logger.log(`Incoming call with groupCallId ${e.groupCallId} ignored because it doesn't match the current group call`), void e.reject();
						const i = null === (t = e.getOpponentMember()) || void 0 === t ? void 0 : t.userId,
							n = i ? this.getCallByUserId(i) : null;
						n && n.callId === e.callId || (d.logger.log(`GroupCall: incoming call from: ${i} with ID ${e.callId}`), e.isPtt = this.isPtt, n ? this.replaceCall(n, e) : this.addCall(e), e.answerWithCallFeeds(this.getLocalFeeds().map(e => e.clone())))
					}), (0, r.default)(this, "onMemberStateChanged", async e => {
						if (this.state !== S.Entered) return;
						if (e.getRoomId() !== this.room.roomId) return;
						const t = this.room.getMember(e.getStateKey());
						if (!t) return void d.logger.warn(`Couldn't find room member for ${e.getStateKey()}: ignoring member state event!`);
						const i = this.client.getUserId();
						if (t.userId === i) return;
						d.logger.debug(`Processing member state event for ${t.userId}`);
						const n = () => {
								this.removeParticipant(t), clearTimeout(this.memberStateExpirationTimers.get(t.userId)), this.memberStateExpirationTimers.delete(t.userId)
							},
							r = e.getContent(),
							s = !w(e) && Array.isArray(r["m.calls"]) ? r["m.calls"].filter(e => e) : [];
						if (0 === s.length) return d.logger.info(`Ignoring member state from ${t.userId} member not in any calls.`), void n();
						const o = s[0]["m.call_id"];
						if (!o) return d.logger.warn(`Room member ${t.userId} does not have a valid m.call_id set. Ignoring.`), void n();
						if (o !== this.groupCallId) return d.logger.warn(`Call id ${o} does not match group call id ${this.groupCallId}, ignoring.`), void n();
						if (this.addParticipant(t), clearTimeout(this.memberStateExpirationTimers.get(t.userId)), this.memberStateExpirationTimers.set(t.userId, setTimeout(() => {
								d.logger.warn(`Call member state for ${t.userId} has expired`), this.removeParticipant(t)
							}, r["m.expires_ts"] - Date.now())), t.userId < i) return void d.logger.debug(`Waiting for ${t.userId} to send call invite.`);
						const l = this.getDeviceForMember(t.userId);
						if (!l) return d.logger.warn(`No opponent device found for ${t.userId}, ignoring.`), void this.emit(b.Error, new GroupCallUnknownDeviceError(t.userId));
						const u = this.getCallByUserId(t.userId);
						if (u && u.getOpponentSessionId() === l.session_id) return;
						const h = (0, a.createNewMatrixCall)(this.client, this.room.roomId, {
							invitee: t.userId,
							opponentDeviceId: l.device_id,
							opponentSessionId: l.session_id,
							groupCallId: this.groupCallId
						});
						if (!h) return void d.logger.error("Failed to create call!");
						u ? (d.logger.debug(`Replacing call ${u.callId} to ${t.userId} with ${h.callId}`), this.replaceCall(u, h, a.CallErrorCode.NewSession)) : (d.logger.debug(`Adding call ${h.callId} to ${t.userId}`), this.addCall(h)), h.isPtt = this.isPtt;
						const m = l.feeds.some(e => e.purpose === c.SDPStreamMetadataPurpose.Screenshare);
						d.logger.debug(`Placing call to ${t.userId}/${l.device_id} session ID ${l.session_id}.`);
						try {
							await h.placeCallWithCallFeeds(this.getLocalFeeds().map(e => e.clone()), m)
						} catch (p) {
							return d.logger.warn(`Failed to place call to ${t.userId}!`, p), p instanceof a.CallError && p.code === _.UnknownDevice ? this.emit(b.Error, p) : this.emit(b.Error, new GroupCallError(_.PlaceCallFailed, `Failed to place call to ${t.userId}.`)), void this.removeCall(h, a.CallErrorCode.SignallingFailed)
						}
						this.dataChannelsEnabled && h.createDataChannel("datachannel", this.dataChannelOptions)
					}), (0, r.default)(this, "onRetryCallLoop", () => {
						for (const e of this.getMemberStateEvents()) {
							const t = e.getStateKey(),
								i = this.calls.find(e => k(e) === t),
								n = this.retryCallCounts.get(t) || 0;
							!i && n < 3 && (this.retryCallCounts.set(t, n + 1), this.onMemberStateChanged(e))
						}
						this.retryCallLoopTimeout = setTimeout(this.onRetryCallLoop, this.retryCallInterval)
					}), (0, r.default)(this, "onCallFeedsChanged", e => {
						const t = k(e);
						if (!t) throw new Error("Cannot change call feeds without user id");
						const i = this.getUserMediaFeedByUserId(t),
							n = e.remoteUsermediaFeed;
						n !== i && (!i && n ? this.addUserMediaFeed(n) : i && n ? this.replaceUserMediaFeed(i, n) : i && !n && this.removeUserMediaFeed(i));
						const r = this.getScreenshareFeedByUserId(t),
							s = e.remoteScreensharingFeed;
						s !== r && (!r && s ? this.addScreenshareFeed(s) : r && s ? this.replaceScreenshareFeed(r, s) : r && !s && this.removeScreenshareFeed(r))
					}), (0, r.default)(this, "onCallStateChanged", (e, t, i) => {
						const n = this.localCallFeed.isAudioMuted();
						e.localUsermediaStream && e.isMicrophoneMuted() !== n && e.setMicrophoneMuted(n);
						const r = this.localCallFeed.isVideoMuted();
						e.localUsermediaStream && e.isLocalVideoMuted() !== r && e.setLocalVideoMuted(r), t === a.CallState.Connected && this.retryCallCounts.delete(k(e))
					}), (0, r.default)(this, "onCallHangup", e => {
						e.hangupReason !== a.CallErrorCode.Replaced && this.removeCall(e, e.hangupReason)
					}), (0, r.default)(this, "onActiveSpeakerLoop", () => {
						let e = void 0,
							t = void 0;
						for (const i of this.userMediaFeeds) {
							if (i.userId === this.client.getUserId() && this.userMediaFeeds.length > 1) continue;
							let n = 0;
							for (let e = 0; e < i.speakingVolumeSamples.length; e++) {
								const t = i.speakingVolumeSamples[e];
								n += Math.max(t, o.SPEAKING_THRESHOLD)
							}
							const r = n / i.speakingVolumeSamples.length;
							(!e || r > e) && (e = r, t = i.userId)
						}
						t && this.activeSpeaker !== t && e && e > o.SPEAKING_THRESHOLD && (this.activeSpeaker = t, this.emit(b.ActiveSpeakerChanged, this.activeSpeaker)), this.activeSpeakerLoopTimeout = setTimeout(this.onActiveSpeakerLoop, this.activeSpeakerInterval)
					}), this.reEmitter = new l.ReEmitter(this), this.groupCallId = u || (0, a.genCallID)();
					for (const r of this.getMemberStateEvents()) this.onMemberStateChanged(r)
				}
				async create() {
					return this.client.groupCallEventHandler.groupCalls.set(this.room.roomId, this), await this.client.sendStateEvent(this.room.roomId, u.EventType.GroupCallPrefix, {
						"m.intent": this.intent,
						"m.type": this.type,
						"io.element.ptt": this.isPtt,
						dataChannelsEnabled: this.dataChannelsEnabled,
						dataChannelOptions: this.dataChannelOptions
					}, this.groupCallId), this
				}
				setState(e) {
					const t = this.state;
					this.state = e, this.emit(b.GroupCallStateChanged, e, t)
				}
				getLocalFeeds() {
					const e = [];
					return this.localCallFeed && e.push(this.localCallFeed), this.localScreenshareFeed && e.push(this.localScreenshareFeed), e
				}
				hasLocalParticipant() {
					const e = this.client.getUserId();
					return this.participants.some(t => t.userId === e)
				}
				async initLocalCallFeed() {
					if (d.logger.log(`groupCall ${this.groupCallId} initLocalCallFeed`), this.state !== S.LocalCallFeedUninitialized) throw new Error(`Cannot initialize local call feed in the "${this.state}" state.`);
					let e;
					this.setState(S.InitializingLocalCallFeed);
					let t = !1;
					const i = e => {
						e === S.LocalCallFeedUninitialized && (t = !0)
					};
					this.on(b.GroupCallStateChanged, i);
					try {
						e = await this.client.getMediaHandler().getUserMediaStream(!0, this.type === v.Video)
					} catch (s) {
						throw this.setState(S.LocalCallFeedUninitialized), s
					} finally {
						this.off(b.GroupCallStateChanged, i)
					}
					if (t) throw new Error("Group call disposed");
					const n = this.client.getUserId(),
						r = new o.CallFeed({
							client: this.client,
							roomId: this.room.roomId,
							userId: n,
							stream: e,
							purpose: c.SDPStreamMetadataPurpose.Usermedia,
							audioMuted: this.initWithAudioMuted || 0 === e.getAudioTracks().length || this.isPtt,
							videoMuted: this.initWithVideoMuted || 0 === e.getVideoTracks().length
						});
					return (0, a.setTracksEnabled)(e.getAudioTracks(), !r.isAudioMuted()), (0, a.setTracksEnabled)(e.getVideoTracks(), !r.isVideoMuted()), this.localCallFeed = r, this.addUserMediaFeed(r), this.setState(S.LocalCallFeedInitialized), r
				}
				async updateLocalUsermediaStream(e) {
					if (this.localCallFeed) {
						const t = this.localCallFeed.stream;
						this.localCallFeed.setNewStream(e);
						const i = this.localCallFeed.isAudioMuted(),
							n = this.localCallFeed.isVideoMuted();
						d.logger.log(`groupCall ${this.groupCallId} updateLocalUsermediaStream oldStream ${t.id} newStream ${e.id} micShouldBeMuted ${i} vidShouldBeMuted ${n}`), (0, a.setTracksEnabled)(e.getAudioTracks(), !i), (0, a.setTracksEnabled)(e.getVideoTracks(), !n), this.client.getMediaHandler().stopUserMediaStream(t)
					}
				}
				async enter() {
					if (this.state !== S.LocalCallFeedUninitialized && this.state !== S.LocalCallFeedInitialized) throw new Error(`Cannot enter call in the "${this.state}" state`);
					this.state === S.LocalCallFeedUninitialized && await this.initLocalCallFeed(), this.addParticipant(this.room.getMember(this.client.getUserId())), await this.sendMemberStateEvent(), this.activeSpeaker = void 0, this.setState(S.Entered), d.logger.log(`Entered group call ${this.groupCallId}`), this.client.on(h.CallEventHandlerEvent.Incoming, this.onIncomingCall);
					const e = this.client.callEventHandler.calls.values();
					for (const t of e) this.onIncomingCall(t);
					for (const t of this.getMemberStateEvents()) this.onMemberStateChanged(t);
					this.retryCallLoopTimeout = setTimeout(this.onRetryCallLoop, this.retryCallInterval), this.onActiveSpeakerLoop()
				}
				dispose() {
					if (this.localCallFeed && (this.removeUserMediaFeed(this.localCallFeed), this.localCallFeed = void 0), this.localScreenshareFeed && (this.client.getMediaHandler().stopScreensharingStream(this.localScreenshareFeed.stream), this.removeScreenshareFeed(this.localScreenshareFeed), this.localScreenshareFeed = void 0, this.localDesktopCapturerSourceId = void 0), this.client.getMediaHandler().stopAllStreams(), this.state === S.Entered) {
						for (this.removeParticipant(this.room.getMember(this.client.getUserId())), this.removeMemberStateEvent(); this.calls.length > 0;) this.removeCall(this.calls[this.calls.length - 1], a.CallErrorCode.UserHangup);
						this.activeSpeaker = void 0, clearTimeout(this.activeSpeakerLoopTimeout), this.retryCallCounts.clear(), clearTimeout(this.retryCallLoopTimeout);
						for (const [e] of this.memberStateExpirationTimers) clearTimeout(this.memberStateExpirationTimers.get(e)), this.memberStateExpirationTimers.delete(e);
						null !== this.transmitTimer && (clearTimeout(this.transmitTimer), this.transmitTimer = null), this.client.removeListener(h.CallEventHandlerEvent.Incoming, this.onIncomingCall)
					}
				}
				leave() {
					null !== this.transmitTimer && (clearTimeout(this.transmitTimer), this.transmitTimer = null), this.dispose(), this.setState(S.LocalCallFeedUninitialized)
				}
				async terminate(e = !0) {
					if (this.dispose(), null !== this.transmitTimer && (clearTimeout(this.transmitTimer), this.transmitTimer = null), this.participants = [], this.client.groupCallEventHandler.groupCalls.delete(this.room.roomId), e) {
						const e = this.room.currentState.getStateEvents(u.EventType.GroupCallPrefix, this.groupCallId);
						await this.client.sendStateEvent(this.room.roomId, u.EventType.GroupCallPrefix, g(g({}, e.getContent()), {}, {
							"m.terminated": y.CallEnded
						}), this.groupCallId)
					}
					this.client.emit(m.GroupCallEventHandlerEvent.Ended, this), this.setState(S.Ended)
				}
				isLocalVideoMuted() {
					return !this.localCallFeed || this.localCallFeed.isVideoMuted()
				}
				isMicrophoneMuted() {
					return !this.localCallFeed || this.localCallFeed.isAudioMuted()
				}
				async setMicrophoneMuted(e) {
					if (!e && !(await this.client.getMediaHandler().hasAudioDevice())) return !1;
					const t = !e && this.isPtt;
					this.isPtt && (!e && this.isMicrophoneMuted() ? this.transmitTimer = setTimeout(() => {
						this.setMicrophoneMuted(!0)
					}, this.pttMaxTransmitTime) : e && !this.isMicrophoneMuted() && (null !== this.transmitTimer && clearTimeout(this.transmitTimer), this.transmitTimer = null));
					for (const r of this.calls) {
						var i;
						null === (i = r.localUsermediaFeed) || void 0 === i || i.setAudioVideoMuted(e, null)
					}
					if (t) try {
						await Promise.all(this.calls.map(e => e.sendMetadataUpdate()))
					} catch (n) {
						d.logger.info("Failed to send one or more metadata updates", n)
					}
					this.localCallFeed ? (d.logger.log(`groupCall ${this.groupCallId} setMicrophoneMuted stream ${this.localCallFeed.stream.id} muted ${e}`), this.localCallFeed.setAudioVideoMuted(e, null), (0, a.setTracksEnabled)(this.localCallFeed.stream.getAudioTracks(), !e)) : (d.logger.log(`groupCall ${this.groupCallId} setMicrophoneMuted no stream muted ${e}`), this.initWithAudioMuted = e);
					for (const r of this.calls)(0, a.setTracksEnabled)(r.localUsermediaFeed.stream.getAudioTracks(), !e);
					if (this.emit(b.LocalMuteStateChanged, e, this.isLocalVideoMuted()), !t) try {
						await Promise.all(this.calls.map(e => e.sendMetadataUpdate()))
					} catch (n) {
						d.logger.info("Failed to send one or more metadata updates", n)
					}
					return !0
				}
				async setLocalVideoMuted(e) {
					if (!e && !(await this.client.getMediaHandler().hasVideoDevice())) return !1;
					this.localCallFeed ? (d.logger.log(`groupCall ${this.groupCallId} setLocalVideoMuted stream ${this.localCallFeed.stream.id} muted ${e}`), this.localCallFeed.setAudioVideoMuted(null, e), (0, a.setTracksEnabled)(this.localCallFeed.stream.getVideoTracks(), !e)) : (d.logger.log(`groupCall ${this.groupCallId} setLocalVideoMuted no stream muted ${e}`), this.initWithVideoMuted = e);
					for (const t of this.calls) t.setLocalVideoMuted(e);
					return this.emit(b.LocalMuteStateChanged, this.isMicrophoneMuted(), e), !0
				}
				async setScreensharingEnabled(e, t = {}) {
					if (e === this.isScreensharing()) return e;
					if (!e) return await Promise.all(this.calls.map(e => {
						e.localScreensharingFeed && e.removeLocalFeed(e.localScreensharingFeed)
					})), this.client.getMediaHandler().stopScreensharingStream(this.localScreenshareFeed.stream), this.removeScreenshareFeed(this.localScreenshareFeed), this.localScreenshareFeed = void 0, this.localDesktopCapturerSourceId = void 0, await this.sendMemberStateEvent(), this.emit(b.LocalScreenshareStateChanged, !1, void 0, void 0), !1;
					try {
						d.logger.log("Asking for screensharing permissions...");
						const e = await this.client.getMediaHandler().getScreensharingStream(t);
						for (const t of e.getTracks()) {
							const e = () => {
								this.setScreensharingEnabled(!1), t.removeEventListener("ended", e)
							};
							t.addEventListener("ended", e)
						}
						return d.logger.log("Screensharing permissions granted. Setting screensharing enabled on all calls"), this.localDesktopCapturerSourceId = t.desktopCapturerSourceId, this.localScreenshareFeed = new o.CallFeed({
							client: this.client,
							roomId: this.room.roomId,
							userId: this.client.getUserId(),
							stream: e,
							purpose: c.SDPStreamMetadataPurpose.Screenshare,
							audioMuted: !1,
							videoMuted: !1
						}), this.addScreenshareFeed(this.localScreenshareFeed), this.emit(b.LocalScreenshareStateChanged, !0, this.localScreenshareFeed, this.localDesktopCapturerSourceId), await Promise.all(this.calls.map(e => e.pushLocalFeed(this.localScreenshareFeed.clone()))), await this.sendMemberStateEvent(), !0
					} catch (i) {
						if (t.throwOnFail) throw i;
						return d.logger.error("Enabling screensharing error", i), this.emit(b.Error, new GroupCallError(_.NoUserMedia, "Failed to get screen-sharing stream: ", i)), !1
					}
				}
				isScreensharing() {
					return !!this.localScreenshareFeed
				}
				getMemberStateEvents(e) {
					if (null != e) {
						const t = this.room.currentState.getStateEvents(u.EventType.GroupCallMemberPrefix, e);
						return w(t) ? null : t
					}
					return this.room.currentState.getStateEvents(u.EventType.GroupCallMemberPrefix).filter(e => !w(e))
				}
				async sendMemberStateEvent() {
					const e = () => this.updateMemberCallState({
							"m.call_id": this.groupCallId,
							"m.devices": [{
								device_id: this.client.getDeviceId(),
								session_id: this.client.getSessionId(),
								feeds: this.getLocalFeeds().map(e => ({
									purpose: e.purpose
								}))
							}]
						}),
						t = await e();
					return null !== this.resendMemberStateTimer && clearInterval(this.resendMemberStateTimer), this.resendMemberStateTimer = setInterval(async () => {
						d.logger.log("Resending call member state"), await e()
					}, 3 * E / 4), t
				}
				async removeMemberStateEvent() {
					return null !== this.resendMemberStateTimer && clearInterval(this.resendMemberStateTimer), this.resendMemberStateTimer = null, await this.updateMemberCallState(void 0, !0)
				}
				async updateMemberCallState(e, t = !1) {
					var i;
					const n = this.client.getUserId(),
						r = null === (i = this.getMemberStateEvents(n)) || void 0 === i ? void 0 : i.getContent();
					let s = [];
					r && Array.isArray(r["m.calls"]) && (s = r["m.calls"].filter(e => !!e));
					const o = s.findIndex(e => e && e["m.call_id"] === this.groupCallId); - 1 !== o ? e ? s.splice(o, 1, e) : s.splice(o, 1) : e && s.push(e);
					const a = {
						"m.calls": s,
						"m.expires_ts": Date.now() + E
					};
					return this.client.sendStateEvent(this.room.roomId, u.EventType.GroupCallMemberPrefix, a, n, {
						keepAlive: t
					})
				}
				getDeviceForMember(e) {
					var t;
					const i = this.getMemberStateEvents(e);
					if (!i) return;
					const n = null === (t = i.getContent()["m.calls"]) || void 0 === t ? void 0 : t.find(e => e && e["m.call_id"] === this.groupCallId);
					if (!n) return;
					const r = n["m.devices"];
					return r && 0 !== r.length ? r[0] : void 0
				}
				getCallByUserId(e) {
					return this.calls.find(t => k(t) === e)
				}
				addCall(e) {
					this.calls.push(e), this.initCall(e), this.emit(b.CallsChanged, this.calls)
				}
				replaceCall(e, t, i = a.CallErrorCode.Replaced) {
					const n = this.calls.indexOf(e);
					if (-1 === n) throw new Error("Couldn't find call to replace");
					this.calls.splice(n, 1, t), this.disposeCall(e, i), this.initCall(t), this.emit(b.CallsChanged, this.calls)
				}
				removeCall(e, t) {
					this.disposeCall(e, t);
					const i = this.calls.indexOf(e);
					if (-1 === i) throw new Error("Couldn't find call to remove");
					this.calls.splice(i, 1), this.emit(b.CallsChanged, this.calls)
				}
				initCall(e) {
					const t = k(e);
					if (!t) throw new Error("Cannot init call without user id");
					const i = () => this.onCallFeedsChanged(e),
						n = (t, i) => this.onCallStateChanged(e, t, i),
						r = this.onCallHangup,
						s = t => this.replaceCall(e, t);
					this.callHandlers.set(t, {
						onCallFeedsChanged: i,
						onCallStateChanged: n,
						onCallHangup: r,
						onCallReplaced: s
					}), e.on(a.CallEvent.FeedsChanged, i), e.on(a.CallEvent.State, n), e.on(a.CallEvent.Hangup, r), e.on(a.CallEvent.Replaced, s), this.reEmitter.reEmit(e, Object.values(a.CallEvent)), i()
				}
				disposeCall(e, t) {
					const i = k(e);
					if (!i) throw new Error("Cannot dispose call without user id");
					const {
						onCallFeedsChanged: n,
						onCallStateChanged: r,
						onCallHangup: s,
						onCallReplaced: o
					} = this.callHandlers.get(i);
					if (e.removeListener(a.CallEvent.FeedsChanged, n), e.removeListener(a.CallEvent.State, r), e.removeListener(a.CallEvent.Hangup, s), e.removeListener(a.CallEvent.Replaced, o), this.callHandlers.delete(i), e.hangupReason === a.CallErrorCode.Replaced) return;
					e.state !== a.CallState.Ended && e.hangup(t, !1);
					const d = this.getUserMediaFeedByUserId(i);
					d && this.removeUserMediaFeed(d);
					const l = this.getScreenshareFeedByUserId(i);
					l && this.removeScreenshareFeed(l)
				}
				getUserMediaFeedByUserId(e) {
					return this.userMediaFeeds.find(t => t.userId === e)
				}
				addUserMediaFeed(e) {
					this.userMediaFeeds.push(e), e.measureVolumeActivity(!0), this.emit(b.UserMediaFeedsChanged, this.userMediaFeeds)
				}
				replaceUserMediaFeed(e, t) {
					const i = this.userMediaFeeds.findIndex(t => t.userId === e.userId);
					if (-1 === i) throw new Error("Couldn't find user media feed to replace");
					this.userMediaFeeds.splice(i, 1, t), e.dispose(), t.measureVolumeActivity(!0), this.emit(b.UserMediaFeedsChanged, this.userMediaFeeds)
				}
				removeUserMediaFeed(e) {
					const t = this.userMediaFeeds.findIndex(t => t.userId === e.userId);
					if (-1 === t) throw new Error("Couldn't find user media feed to remove");
					this.userMediaFeeds.splice(t, 1), e.dispose(), this.emit(b.UserMediaFeedsChanged, this.userMediaFeeds), this.activeSpeaker === e.userId && this.userMediaFeeds.length > 0 && (this.activeSpeaker = this.userMediaFeeds[0].userId, this.emit(b.ActiveSpeakerChanged, this.activeSpeaker))
				}
				getScreenshareFeedByUserId(e) {
					return this.screenshareFeeds.find(t => t.userId === e)
				}
				addScreenshareFeed(e) {
					this.screenshareFeeds.push(e), this.emit(b.ScreenshareFeedsChanged, this.screenshareFeeds)
				}
				replaceScreenshareFeed(e, t) {
					const i = this.screenshareFeeds.findIndex(t => t.userId === e.userId);
					if (-1 === i) throw new Error("Couldn't find screenshare feed to replace");
					this.screenshareFeeds.splice(i, 1, t), e.dispose(), this.emit(b.ScreenshareFeedsChanged, this.screenshareFeeds)
				}
				removeScreenshareFeed(e) {
					const t = this.screenshareFeeds.findIndex(t => t.userId === e.userId);
					if (-1 === t) throw new Error("Couldn't find screenshare feed to remove");
					this.screenshareFeeds.splice(t, 1), e.dispose(), this.emit(b.ScreenshareFeedsChanged, this.screenshareFeeds)
				}
				addParticipant(e) {
					this.participants.find(t => t.userId === e.userId) || (this.participants.push(e), this.emit(b.ParticipantsChanged, this.participants), this.client.emit(m.GroupCallEventHandlerEvent.Participants, this.participants, this))
				}
				removeParticipant(e) {
					const t = this.participants.findIndex(t => t.userId === e.userId); - 1 !== t && (this.participants.splice(t, 1), this.emit(b.ParticipantsChanged, this.participants), this.client.emit(m.GroupCallEventHandlerEvent.Participants, this.participants, this))
				}
			}
			t.GroupCall = T
		},
		"./node_modules/matrix-js-sdk/lib/webrtc/groupCallEventHandler.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.GroupCallEventHandlerEvent = t.GroupCallEventHandler = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/client.js"),
				o = i("./node_modules/matrix-js-sdk/lib/webrtc/groupCall.js"),
				a = i("./node_modules/matrix-js-sdk/lib/models/room-state.js"),
				d = i("./node_modules/matrix-js-sdk/lib/logger.js"),
				l = i("./node_modules/matrix-js-sdk/lib/@types/event.js"),
				c = i("./node_modules/matrix-js-sdk/lib/sync.js");
			let u;
			t.GroupCallEventHandlerEvent = u,
				function(e) {
					e.Incoming = "GroupCall.incoming", e.Ended = "GroupCall.ended", e.Participants = "GroupCall.participants"
				}(u || (t.GroupCallEventHandlerEvent = u = {}));
			t.GroupCallEventHandler = class {
				constructor(e) {
					this.client = e, (0, r.default)(this, "groupCalls", new Map), (0, r.default)(this, "roomDeferreds", new Map), (0, r.default)(this, "onRoomsChanged", e => {
						this.createGroupCallForRoom(e)
					}), (0, r.default)(this, "onRoomStateChanged", (e, t) => {
						const i = e.getType();
						if (i === l.EventType.GroupCallPrefix) {
							const i = e.getStateKey(),
								n = e.getContent(),
								r = this.groupCalls.get(t.roomId);
							r || n["m.terminated"] ? r && r.groupCallId === i ? n["m.terminated"] ? r.terminate(!1) : n["m.type"] !== r.type && d.logger.warn(`The group call type changed for room: ${t.roomId}. Changing the group call type is currently unsupported.`) : r && r.groupCallId !== i && d.logger.warn(`Multiple group calls detected for room: ${t.roomId}. Multiple group calls are currently unsupported.`) : this.createGroupCallFromRoomStateEvent(e)
						} else if (i === l.EventType.GroupCallMemberPrefix) {
							const i = this.groupCalls.get(t.roomId);
							if (!i) return;
							i.onMemberStateChanged(e)
						}
					})
				}
				async start() {
					this.client.getSyncState() !== c.SyncState.Syncing && (d.logger.debug("Waiting for client to start syncing..."), await new Promise(e => {
						const t = () => {
							if (this.client.getSyncState() === c.SyncState.Syncing) return this.client.off(s.ClientEvent.Sync, t), e()
						};
						this.client.on(s.ClientEvent.Sync, t)
					}));
					const e = this.client.getRooms();
					for (const t of e) this.createGroupCallForRoom(t);
					this.client.on(s.ClientEvent.Room, this.onRoomsChanged), this.client.on(a.RoomStateEvent.Events, this.onRoomStateChanged)
				}
				stop() {
					this.client.removeListener(a.RoomStateEvent.Events, this.onRoomStateChanged)
				}
				getRoomDeferred(e) {
					let t = this.roomDeferreds.get(e);
					if (void 0 === t) {
						let i;
						(t = {
							prom: new Promise(e => {
								i = e
							})
						}).resolve = i, this.roomDeferreds.set(e, t)
					}
					return t
				}
				waitUntilRoomReadyForGroupCalls(e) {
					return this.getRoomDeferred(e).prom
				}
				getGroupCallById(e) {
					return [...this.groupCalls.values()].find(t => t.groupCallId === e)
				}
				createGroupCallForRoom(e) {
					const t = e.currentState.getStateEvents(l.EventType.GroupCallPrefix),
						i = t.sort((e, t) => t.getTs() - e.getTs());
					for (const n of i) {
						if (!n.getContent()["m.terminated"]) {
							d.logger.debug(`Choosing group call ${n.getStateKey()} with TS ` + `${n.getTs()} for room ${e.roomId} from ${t.length} possible calls.`), this.createGroupCallFromRoomStateEvent(n);
							break
						}
					}
					d.logger.info("Group call event handler processed room", e.roomId), this.getRoomDeferred(e.roomId).resolve()
				}
				createGroupCallFromRoomStateEvent(e) {
					const t = e.getRoomId(),
						i = e.getContent(),
						n = this.client.getRoom(t);
					if (!n) return void d.logger.warn(`Couldn't find room ${t} for GroupCall`);
					const r = e.getStateKey(),
						s = i["m.type"];
					if (!Object.values(o.GroupCallType).includes(s)) return void d.logger.warn(`Received invalid group call type ${s} for room ${t}.`);
					const a = i["m.intent"];
					if (!Object.values(o.GroupCallIntent).includes(a)) return void d.logger.warn(`Received invalid group call intent ${s} for room ${t}.`);
					const l = Boolean(i["io.element.ptt"]);
					let c;
					if (null != i && i.dataChannelsEnabled && null != i && i.dataChannelOptions) {
						const {
							ordered: e,
							maxPacketLifeTime: t,
							maxRetransmits: n,
							protocol: r
						} = i.dataChannelOptions;
						c = {
							ordered: e,
							maxPacketLifeTime: t,
							maxRetransmits: n,
							protocol: r
						}
					}
					const h = new o.GroupCall(this.client, n, s, l, a, r, null == i ? void 0 : i.dataChannelsEnabled, c);
					return this.groupCalls.set(n.roomId, h), this.client.emit(u.Incoming, h), h
				}
			}
		},
		"./node_modules/matrix-js-sdk/lib/webrtc/mediaHandler.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js");
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.MediaHandlerEvent = t.MediaHandler = void 0;
			var r = n(i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js")),
				s = i("./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js"),
				o = i("./node_modules/matrix-js-sdk/lib/webrtc/groupCall.js"),
				a = i("./node_modules/matrix-js-sdk/lib/logger.js");
			let d;
			t.MediaHandlerEvent = d,
				function(e) {
					e.LocalStreamsChanged = "local_streams_changed"
				}(d || (t.MediaHandlerEvent = d = {}));
			class l extends s.TypedEventEmitter {
				constructor(e) {
					super(), this.client = e, (0, r.default)(this, "audioInput", void 0), (0, r.default)(this, "audioSettings", void 0), (0, r.default)(this, "videoInput", void 0), (0, r.default)(this, "localUserMediaStream", void 0), (0, r.default)(this, "userMediaStreams", []), (0, r.default)(this, "screensharingStreams", [])
				}
				restoreMediaSettings(e, t) {
					this.audioInput = e, this.videoInput = t
				}
				async setAudioInput(e) {
					a.logger.info("Setting audio input to", e), this.audioInput !== e && (this.audioInput = e, await this.updateLocalUsermediaStreams())
				}
				async setAudioSettings(e) {
					a.logger.info("Setting audio settings to", e), this.audioSettings = Object.assign({}, e), await this.updateLocalUsermediaStreams()
				}
				async setVideoInput(e) {
					a.logger.info("Setting video input to", e), this.videoInput !== e && (this.videoInput = e, await this.updateLocalUsermediaStreams())
				}
				async setMediaInputs(e, t) {
					a.logger.log(`mediaHandler setMediaInputs audioInput: ${e} videoInput: ${t}`), this.audioInput = e, this.videoInput = t, await this.updateLocalUsermediaStreams()
				}
				async updateLocalUsermediaStreams() {
					if (0 === this.userMediaStreams.length) return;
					const e = new Map;
					for (const t of this.client.callEventHandler.calls.values()) e.set(t.callId, {
						audio: t.hasLocalUserMediaAudioTrack,
						video: t.hasLocalUserMediaVideoTrack
					});
					for (const t of this.userMediaStreams) {
						a.logger.log(`mediaHandler stopping all tracks for stream ${t.id}`);
						for (const e of t.getTracks()) e.stop()
					}
					this.userMediaStreams = [], this.localUserMediaStream = void 0;
					for (const t of this.client.callEventHandler.calls.values()) {
						if (t.callHasEnded() || !e.has(t.callId)) continue;
						const {
							audio: i,
							video: n
						} = e.get(t.callId);
						a.logger.log(`mediaHandler updateLocalUsermediaStreams getUserMediaStream call ${t.callId}`);
						const r = await this.getUserMediaStream(i, n);
						t.callHasEnded() || await t.updateLocalUsermediaStream(r)
					}
					for (const t of this.client.groupCallEventHandler.groupCalls.values()) {
						if (!t.localCallFeed) continue;
						a.logger.log(`mediaHandler updateLocalUsermediaStreams getUserMediaStream groupCall ${t.groupCallId}`);
						const e = await this.getUserMediaStream(!0, t.type === o.GroupCallType.Video);
						t.state !== o.GroupCallState.Ended && await t.updateLocalUsermediaStream(e)
					}
					this.emit(d.LocalStreamsChanged)
				}
				async hasAudioDevice() {
					return (await navigator.mediaDevices.enumerateDevices()).filter(e => "audioinput" === e.kind).length > 0
				}
				async hasVideoDevice() {
					return (await navigator.mediaDevices.enumerateDevices()).filter(e => "videoinput" === e.kind).length > 0
				}
				async getUserMediaStream(e, t, i = !0) {
					const n = e && await this.hasAudioDevice(),
						r = t && await this.hasVideoDevice();
					let s, o = !0;
					if (this.localUserMediaStream) {
						var l, c, u, h;
						if (n) 0 !== this.localUserMediaStream.getAudioTracks().length && (null === (l = this.localUserMediaStream.getAudioTracks()[0]) || void 0 === l ? void 0 : null === (c = l.getSettings()) || void 0 === c ? void 0 : c.deviceId) === this.audioInput || (o = !1);
						if (r) 0 !== this.localUserMediaStream.getVideoTracks().length && (null === (u = this.localUserMediaStream.getVideoTracks()[0]) || void 0 === u ? void 0 : null === (h = u.getSettings()) || void 0 === h ? void 0 : h.deviceId) === this.videoInput || (o = !1)
					} else o = !1;
					if (o) {
						var m;
						if (s = this.localUserMediaStream.clone(), a.logger.log(`mediaHandler clone userMediaStream ${null===(m=this.localUserMediaStream)||void 0===m?void 0:m.id} new stream ${s.id} shouldRequestAudio ${n} shouldRequestVideo ${r}`), !n)
							for (const e of s.getAudioTracks()) s.removeTrack(e);
						if (!r)
							for (const e of s.getVideoTracks()) s.removeTrack(e)
					} else {
						const e = this.getUserMediaContraints(n, r);
						s = await navigator.mediaDevices.getUserMedia(e), a.logger.log(`mediaHandler getUserMediaStream streamId ${s.id} shouldRequestAudio ${n} shouldRequestVideo ${r}`, e);
						for (const t of s.getTracks()) {
							const e = t.getSettings();
							"audio" === t.kind ? this.audioInput = e.deviceId : "video" === t.kind && (this.videoInput = e.deviceId)
						}
						i && (this.localUserMediaStream = s)
					}
					return i && this.userMediaStreams.push(s), this.emit(d.LocalStreamsChanged), s
				}
				stopUserMediaStream(e) {
					a.logger.log(`mediaHandler stopUserMediaStream stopping stream ${e.id}`);
					for (const i of e.getTracks()) i.stop();
					const t = this.userMediaStreams.indexOf(e); - 1 !== t && (a.logger.debug("Splicing usermedia stream out stream array", e.id), this.userMediaStreams.splice(t, 1)), this.emit(d.LocalStreamsChanged), this.localUserMediaStream === e && (this.localUserMediaStream = void 0)
				}
				async getScreensharingStream(e = {}, t = !0) {
					let i;
					if (0 === this.screensharingStreams.length) {
						const t = this.getScreenshareContraints(e);
						e.desktopCapturerSourceId ? (a.logger.debug("Getting screensharing stream using getUserMedia()", e), i = await navigator.mediaDevices.getUserMedia(t)) : (a.logger.debug("Getting screensharing stream using getDisplayMedia()", e), i = await navigator.mediaDevices.getDisplayMedia(t))
					} else {
						const e = this.screensharingStreams[this.screensharingStreams.length - 1];
						a.logger.log("Cloning screensharing stream", e.id), i = e.clone()
					}
					return t && this.screensharingStreams.push(i), this.emit(d.LocalStreamsChanged), i
				}
				stopScreensharingStream(e) {
					a.logger.debug("Stopping screensharing stream", e.id);
					for (const i of e.getTracks()) i.stop();
					const t = this.screensharingStreams.indexOf(e); - 1 !== t && (a.logger.debug("Splicing screensharing stream out stream array", e.id), this.screensharingStreams.splice(t, 1)), this.emit(d.LocalStreamsChanged)
				}
				stopAllStreams() {
					for (const e of this.userMediaStreams) {
						a.logger.log(`mediaHandler stopAllStreams stopping stream ${e.id}`);
						for (const t of e.getTracks()) t.stop()
					}
					for (const e of this.screensharingStreams)
						for (const t of e.getTracks()) t.stop();
					this.userMediaStreams = [], this.screensharingStreams = [], this.localUserMediaStream = void 0, this.emit(d.LocalStreamsChanged)
				}
				getUserMediaContraints(e, t) {
					const i = !!navigator.webkitGetUserMedia;
					return {
						audio: !!e && {
							deviceId: this.audioInput ? {
								ideal: this.audioInput
							} : void 0,
							autoGainControl: this.audioSettings ? {
								ideal: this.audioSettings.autoGainControl
							} : void 0,
							echoCancellation: this.audioSettings ? {
								ideal: this.audioSettings.echoCancellation
							} : void 0,
							noiseSuppression: this.audioSettings ? {
								ideal: this.audioSettings.noiseSuppression
							} : void 0
						},
						video: !!t && {
							deviceId: this.videoInput ? {
								ideal: this.videoInput
							} : void 0,
							width: i ? {
								exact: 640
							} : {
								ideal: 640
							},
							height: i ? {
								exact: 360
							} : {
								ideal: 360
							}
						}
					}
				}
				getScreenshareContraints(e) {
					const {
						desktopCapturerSourceId: t,
						audio: i
					} = e;
					return t ? (a.logger.debug("Using desktop capturer source", t), {
						audio: null != i && i,
						video: {
							mandatory: {
								chromeMediaSource: "desktop",
								chromeMediaSourceId: t
							}
						}
					}) : (a.logger.debug("Not using desktop capturer source"), {
						audio: null != i && i,
						video: !0
					})
				}
			}
			t.MediaHandler = l
		},
		"./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/defineProperty.js": function(e, t) {
			e.exports = function(e, t, i) {
				return t in e ? Object.defineProperty(e, t, {
					value: i,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = i, e
			}, e.exports.default = e.exports, e.exports.__esModule = !0
		},
		"./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/interopRequireDefault.js": function(e, t) {
			e.exports = function(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}, e.exports.default = e.exports, e.exports.__esModule = !0
		},
		"./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/objectWithoutProperties.js": function(e, t, i) {
			var n = i("./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js");
			e.exports = function(e, t) {
				if (null == e) return {};
				var i, r, s = n(e, t);
				if (Object.getOwnPropertySymbols) {
					var o = Object.getOwnPropertySymbols(e);
					for (r = 0; r < o.length; r++) i = o[r], t.indexOf(i) >= 0 || Object.prototype.propertyIsEnumerable.call(e, i) && (s[i] = e[i])
				}
				return s
			}, e.exports.default = e.exports, e.exports.__esModule = !0
		},
		"./node_modules/matrix-js-sdk/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js": function(e, t) {
			e.exports = function(e, t) {
				if (null == e) return {};
				var i, n, r = {},
					s = Object.keys(e);
				for (n = 0; n < s.length; n++) i = s[n], t.indexOf(i) >= 0 || (r[i] = e[i]);
				return r
			}, e.exports.default = e.exports, e.exports.__esModule = !0
		},
		"./node_modules/matrix-widget-api/lib/ClientWidgetApi.js": function(e, t, i) {
			"use strict";

			function n(e) {
				return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				})(e)
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.ClientWidgetApi = void 0;
			var r = i("./node_modules/node-libs-browser/node_modules/events/events.js"),
				s = i("./node_modules/matrix-widget-api/lib/transport/PostmessageTransport.js"),
				o = i("./node_modules/matrix-widget-api/lib/interfaces/WidgetApiDirection.js"),
				a = i("./node_modules/matrix-widget-api/lib/interfaces/WidgetApiAction.js"),
				d = i("./node_modules/matrix-widget-api/lib/interfaces/Capabilities.js"),
				l = i("./node_modules/matrix-widget-api/lib/interfaces/ApiVersion.js"),
				c = i("./node_modules/matrix-widget-api/lib/models/WidgetEventCapability.js"),
				u = i("./node_modules/matrix-widget-api/lib/interfaces/GetOpenIDAction.js"),
				h = i("./node_modules/matrix-widget-api/lib/util/SimpleObservable.js"),
				m = i("./node_modules/matrix-widget-api/lib/Symbols.js");

			function p() {
				p = function() {
					return e
				};
				var e = {},
					t = Object.prototype,
					i = t.hasOwnProperty,
					r = "function" == typeof Symbol ? Symbol : {},
					s = r.iterator || "@@iterator",
					o = r.asyncIterator || "@@asyncIterator",
					a = r.toStringTag || "@@toStringTag";

				function d(e, t, i) {
					return Object.defineProperty(e, t, {
						value: i,
						enumerable: !0,
						configurable: !0,
						writable: !0
					}), e[t]
				}
				try {
					d({}, "")
				} catch (R) {
					d = function(e, t, i) {
						return e[t] = i
					}
				}

				function l(e, t, i, n) {
					var r = t && t.prototype instanceof h ? t : h,
						s = Object.create(r.prototype),
						o = new T(n || []);
					return s._invoke = function(e, t, i) {
						var n = "suspendedStart";
						return function(r, s) {
							if ("executing" === n) throw new Error("Generator is already running");
							if ("completed" === n) {
								if ("throw" === r) throw s;
								return C()
							}
							for (i.method = r, i.arg = s;;) {
								var o = i.delegate;
								if (o) {
									var a = E(o, i);
									if (a) {
										if (a === u) continue;
										return a
									}
								}
								if ("next" === i.method) i.sent = i._sent = i.arg;
								else if ("throw" === i.method) {
									if ("suspendedStart" === n) throw n = "completed", i.arg;
									i.dispatchException(i.arg)
								} else "return" === i.method && i.abrupt("return", i.arg);
								n = "executing";
								var d = c(e, t, i);
								if ("normal" === d.type) {
									if (n = i.done ? "completed" : "suspendedYield", d.arg === u) continue;
									return {
										value: d.arg,
										done: i.done
									}
								}
								"throw" === d.type && (n = "completed", i.method = "throw", i.arg = d.arg)
							}
						}
					}(e, i, o), s
				}

				function c(e, t, i) {
					try {
						return {
							type: "normal",
							arg: e.call(t, i)
						}
					} catch (R) {
						return {
							type: "throw",
							arg: R
						}
					}
				}
				e.wrap = l;
				var u = {};

				function h() {}

				function m() {}

				function g() {}
				var f = {};
				d(f, s, (function() {
					return this
				}));
				var v = Object.getPrototypeOf,
					y = v && v(v(I([])));
				y && y !== t && i.call(y, s) && (f = y);
				var b = g.prototype = h.prototype = Object.create(f);

				function _(e) {
					["next", "throw", "return"].forEach((function(t) {
						d(e, t, (function(e) {
							return this._invoke(t, e)
						}))
					}))
				}

				function S(e, t) {
					var r;
					this._invoke = function(s, o) {
						function a() {
							return new t((function(r, a) {
								! function r(s, o, a, d) {
									var l = c(e[s], e, o);
									if ("throw" !== l.type) {
										var u = l.arg,
											h = u.value;
										return h && "object" == n(h) && i.call(h, "__await") ? t.resolve(h.__await).then((function(e) {
											r("next", e, a, d)
										}), (function(e) {
											r("throw", e, a, d)
										})) : t.resolve(h).then((function(e) {
											u.value = e, a(u)
										}), (function(e) {
											return r("throw", e, a, d)
										}))
									}
									d(l.arg)
								}(s, o, r, a)
							}))
						}
						return r = r ? r.then(a, a) : a()
					}
				}

				function E(e, t) {
					var i = e.iterator[t.method];
					if (void 0 === i) {
						if (t.delegate = null, "throw" === t.method) {
							if (e.iterator.return && (t.method = "return", t.arg = void 0, E(e, t), "throw" === t.method)) return u;
							t.method = "throw", t.arg = new TypeError("The iterator does not provide a 'throw' method")
						}
						return u
					}
					var n = c(i, e.iterator, t.arg);
					if ("throw" === n.type) return t.method = "throw", t.arg = n.arg, t.delegate = null, u;
					var r = n.arg;
					return r ? r.done ? (t[e.resultName] = r.value, t.next = e.nextLoc, "return" !== t.method && (t.method = "next", t.arg = void 0), t.delegate = null, u) : r : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, u)
				}

				function w(e) {
					var t = {
						tryLoc: e[0]
					};
					1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
				}

				function k(e) {
					var t = e.completion || {};
					t.type = "normal", delete t.arg, e.completion = t
				}

				function T(e) {
					this.tryEntries = [{
						tryLoc: "root"
					}], e.forEach(w, this), this.reset(!0)
				}

				function I(e) {
					if (e) {
						var t = e[s];
						if (t) return t.call(e);
						if ("function" == typeof e.next) return e;
						if (!isNaN(e.length)) {
							var n = -1,
								r = function t() {
									for (; ++n < e.length;)
										if (i.call(e, n)) return t.value = e[n], t.done = !1, t;
									return t.value = void 0, t.done = !0, t
								};
							return r.next = r
						}
					}
					return {
						next: C
					}
				}

				function C() {
					return {
						value: void 0,
						done: !0
					}
				}
				return m.prototype = g, d(b, "constructor", g), d(g, "constructor", m), m.displayName = d(g, a, "GeneratorFunction"), e.isGeneratorFunction = function(e) {
					var t = "function" == typeof e && e.constructor;
					return !!t && (t === m || "GeneratorFunction" === (t.displayName || t.name))
				}, e.mark = function(e) {
					return Object.setPrototypeOf ? Object.setPrototypeOf(e, g) : (e.__proto__ = g, d(e, a, "GeneratorFunction")), e.prototype = Object.create(b), e
				}, e.awrap = function(e) {
					return {
						__await: e
					}
				}, _(S.prototype), d(S.prototype, o, (function() {
					return this
				})), e.AsyncIterator = S, e.async = function(t, i, n, r, s) {
					void 0 === s && (s = Promise);
					var o = new S(l(t, i, n, r), s);
					return e.isGeneratorFunction(i) ? o : o.next().then((function(e) {
						return e.done ? e.value : o.next()
					}))
				}, _(b), d(b, a, "Generator"), d(b, s, (function() {
					return this
				})), d(b, "toString", (function() {
					return "[object Generator]"
				})), e.keys = function(e) {
					var t = [];
					for (var i in e) t.push(i);
					return t.reverse(),
						function i() {
							for (; t.length;) {
								var n = t.pop();
								if (n in e) return i.value = n, i.done = !1, i
							}
							return i.done = !0, i
						}
				}, e.values = I, T.prototype = {
					constructor: T,
					reset: function(e) {
						if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(k), !e)
							for (var t in this) "t" === t.charAt(0) && i.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0)
					},
					stop: function() {
						this.done = !0;
						var e = this.tryEntries[0].completion;
						if ("throw" === e.type) throw e.arg;
						return this.rval
					},
					dispatchException: function(e) {
						if (this.done) throw e;
						var t = this;

						function n(i, n) {
							return o.type = "throw", o.arg = e, t.next = i, n && (t.method = "next", t.arg = void 0), !!n
						}
						for (var r = this.tryEntries.length - 1; r >= 0; --r) {
							var s = this.tryEntries[r],
								o = s.completion;
							if ("root" === s.tryLoc) return n("end");
							if (s.tryLoc <= this.prev) {
								var a = i.call(s, "catchLoc"),
									d = i.call(s, "finallyLoc");
								if (a && d) {
									if (this.prev < s.catchLoc) return n(s.catchLoc, !0);
									if (this.prev < s.finallyLoc) return n(s.finallyLoc)
								} else if (a) {
									if (this.prev < s.catchLoc) return n(s.catchLoc, !0)
								} else {
									if (!d) throw new Error("try statement without catch or finally");
									if (this.prev < s.finallyLoc) return n(s.finallyLoc)
								}
							}
						}
					},
					abrupt: function(e, t) {
						for (var n = this.tryEntries.length - 1; n >= 0; --n) {
							var r = this.tryEntries[n];
							if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
								var s = r;
								break
							}
						}
						s && ("break" === e || "continue" === e) && s.tryLoc <= t && t <= s.finallyLoc && (s = null);
						var o = s ? s.completion : {};
						return o.type = e, o.arg = t, s ? (this.method = "next", this.next = s.finallyLoc, u) : this.complete(o)
					},
					complete: function(e, t) {
						if ("throw" === e.type) throw e.arg;
						return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), u
					},
					finish: function(e) {
						for (var t = this.tryEntries.length - 1; t >= 0; --t) {
							var i = this.tryEntries[t];
							if (i.finallyLoc === e) return this.complete(i.completion, i.afterLoc), k(i), u
						}
					},
					catch: function(e) {
						for (var t = this.tryEntries.length - 1; t >= 0; --t) {
							var i = this.tryEntries[t];
							if (i.tryLoc === e) {
								var n = i.completion;
								if ("throw" === n.type) {
									var r = n.arg;
									k(i)
								}
								return r
							}
						}
						throw new Error("illegal catch attempt")
					},
					delegateYield: function(e, t, i) {
						return this.delegate = {
							iterator: I(e),
							resultName: t,
							nextLoc: i
						}, "next" === this.method && (this.arg = void 0), u
					}
				}, e
			}

			function g(e, t, i, n, r, s, o) {
				try {
					var a = e[s](o),
						d = a.value
				} catch (l) {
					return void i(l)
				}
				a.done ? t(d) : Promise.resolve(d).then(n, r)
			}

			function f(e) {
				return function() {
					var t = this,
						i = arguments;
					return new Promise((function(n, r) {
						var s = e.apply(t, i);

						function o(e) {
							g(s, n, r, o, a, "next", e)
						}

						function a(e) {
							g(s, n, r, o, a, "throw", e)
						}
						o(void 0)
					}))
				}
			}

			function v(e, t) {
				var i = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
				if (!i) {
					if (Array.isArray(e) || (i = function(e, t) {
							if (!e) return;
							if ("string" == typeof e) return y(e, t);
							var i = Object.prototype.toString.call(e).slice(8, -1);
							"Object" === i && e.constructor && (i = e.constructor.name);
							if ("Map" === i || "Set" === i) return Array.from(e);
							if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return y(e, t)
						}(e)) || t && e && "number" == typeof e.length) {
						i && (e = i);
						var n = 0,
							r = function() {};
						return {
							s: r,
							n: function() {
								return n >= e.length ? {
									done: !0
								} : {
									done: !1,
									value: e[n++]
								}
							},
							e: function(e) {
								throw e
							},
							f: r
						}
					}
					throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
				}
				var s, o = !0,
					a = !1;
				return {
					s: function() {
						i = i.call(e)
					},
					n: function() {
						var e = i.next();
						return o = e.done, e
					},
					e: function(e) {
						a = !0, s = e
					},
					f: function() {
						try {
							o || null == i.return || i.return()
						} finally {
							if (a) throw s
						}
					}
				}
			}

			function y(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var i = 0, n = new Array(t); i < t; i++) n[i] = e[i];
				return n
			}

			function b(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function _(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? b(Object(i), !0).forEach((function(t) {
						C(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : b(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}

			function S(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}

			function E(e, t) {
				return (E = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
					return e.__proto__ = t, e
				})(e, t)
			}

			function w(e) {
				var t = function() {
					if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
					if (Reflect.construct.sham) return !1;
					if ("function" == typeof Proxy) return !0;
					try {
						return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
					} catch (e) {
						return !1
					}
				}();
				return function() {
					var i, n = I(e);
					if (t) {
						var r = I(this).constructor;
						i = Reflect.construct(n, arguments, r)
					} else i = n.apply(this, arguments);
					return k(this, i)
				}
			}

			function k(e, t) {
				if (t && ("object" === n(t) || "function" == typeof t)) return t;
				if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
				return T(e)
			}

			function T(e) {
				if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				return e
			}

			function I(e) {
				return (I = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
					return e.__proto__ || Object.getPrototypeOf(e)
				})(e)
			}

			function C(e, t, i) {
				return t in e ? Object.defineProperty(e, t, {
					value: i,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = i, e
			}

			function R(e) {
				var t, i, n, r = 2;
				for ("undefined" != typeof Symbol && (i = Symbol.asyncIterator, n = Symbol.iterator); r--;) {
					if (i && null != (t = e[i])) return t.call(e);
					if (n && null != (t = e[n])) return new j(t.call(e));
					i = "@@asyncIterator", n = "@@iterator"
				}
				throw new TypeError("Object is not async iterable")
			}

			function j(e) {
				function t(e) {
					if (Object(e) !== e) return Promise.reject(new TypeError(e + " is not an object."));
					var t = e.done;
					return Promise.resolve(e.value).then((function(e) {
						return {
							value: e,
							done: t
						}
					}))
				}
				return (j = function(e) {
					this.s = e, this.n = e.next
				}).prototype = {
					s: null,
					n: null,
					next: function() {
						return t(this.n.apply(this.s, arguments))
					},
					return: function(e) {
						var i = this.s.return;
						return void 0 === i ? Promise.resolve({
							value: e,
							done: !0
						}) : t(i.apply(this.s, arguments))
					},
					throw: function(e) {
						var i = this.s.return;
						return void 0 === i ? Promise.reject(e) : t(i.apply(this.s, arguments))
					}
				}, new j(e)
			}
			var O = function(e) {
				! function(e, t) {
					if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
					e.prototype = Object.create(t && t.prototype, {
						constructor: {
							value: e,
							writable: !0,
							configurable: !0
						}
					}), Object.defineProperty(e, "prototype", {
						writable: !1
					}), t && E(e, t)
				}(x, e);
				var t, i, n, r, g, y, b, k, I, j, O = w(x);

				function x(e, t, i) {
					var n;
					if (function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, x), (n = O.call(this)).widget = e, n.iframe = t, n.driver = i, C(T(n), "transport", void 0), C(T(n), "contentLoadedActionSent", !1), C(T(n), "allowedCapabilities", new Set), C(T(n), "allowedEvents", []), C(T(n), "isStopped", !1), C(T(n), "turnServers", null), null == t || !t.contentWindow) throw new Error("No iframe supplied");
					if (!e) throw new Error("Invalid widget");
					if (!i) throw new Error("Invalid driver");
					return n.transport = new s.PostmessageTransport(o.WidgetApiDirection.ToWidget, e.id, t.contentWindow, window), n.transport.targetOrigin = e.origin, n.transport.on("message", n.handleMessage.bind(T(n))), t.addEventListener("load", n.onIframeLoad.bind(T(n))), n.transport.start(), n
				}
				return t = x, (i = [{
					key: "hasCapability",
					value: function(e) {
						return this.allowedCapabilities.has(e)
					}
				}, {
					key: "canUseRoomTimeline",
					value: function(e) {
						return this.hasCapability("org.matrix.msc2762.timeline:".concat(m.Symbols.AnyRoom)) || this.hasCapability("org.matrix.msc2762.timeline:".concat(e))
					}
				}, {
					key: "canSendRoomEvent",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
						return this.allowedEvents.some((function(i) {
							return i.matchesAsRoomEvent(c.EventDirection.Send, e, t)
						}))
					}
				}, {
					key: "canSendStateEvent",
					value: function(e, t) {
						return this.allowedEvents.some((function(i) {
							return i.matchesAsStateEvent(c.EventDirection.Send, e, t)
						}))
					}
				}, {
					key: "canSendToDeviceEvent",
					value: function(e) {
						return this.allowedEvents.some((function(t) {
							return t.matchesAsToDeviceEvent(c.EventDirection.Send, e)
						}))
					}
				}, {
					key: "canReceiveRoomEvent",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
						return this.allowedEvents.some((function(i) {
							return i.matchesAsRoomEvent(c.EventDirection.Receive, e, t)
						}))
					}
				}, {
					key: "canReceiveStateEvent",
					value: function(e, t) {
						return this.allowedEvents.some((function(i) {
							return i.matchesAsStateEvent(c.EventDirection.Receive, e, t)
						}))
					}
				}, {
					key: "canReceiveToDeviceEvent",
					value: function(e) {
						return this.allowedEvents.some((function(t) {
							return t.matchesAsToDeviceEvent(c.EventDirection.Receive, e)
						}))
					}
				}, {
					key: "stop",
					value: function() {
						this.isStopped = !0, this.transport.stop()
					}
				}, {
					key: "beginCapabilities",
					value: function() {
						var e, t = this;
						this.emit("preparing"), this.transport.send(a.WidgetApiToWidgetAction.Capabilities, {}).then((function(i) {
							return e = i.capabilities, t.driver.validateCapabilities(new Set(i.capabilities))
						})).then((function(i) {
							console.log("Widget ".concat(t.widget.id, " is allowed capabilities:"), Array.from(i)), t.allowedCapabilities = i, t.allowedEvents = c.WidgetEventCapability.findEventCapabilities(i), t.notifyCapabilities(e), t.emit("ready")
						}))
					}
				}, {
					key: "notifyCapabilities",
					value: function(e) {
						var t = this;
						this.transport.send(a.WidgetApiToWidgetAction.NotifyCapabilities, {
							requested: e,
							approved: Array.from(this.allowedCapabilities)
						}).catch((function(e) {
							console.warn("non-fatal error notifying widget of approved capabilities:", e)
						})).then((function() {
							t.emit("capabilitiesNotified")
						}))
					}
				}, {
					key: "onIframeLoad",
					value: function(e) {
						this.widget.waitForIframeLoad ? this.beginCapabilities() : this.contentLoadedActionSent = !1
					}
				}, {
					key: "handleContentLoadedAction",
					value: function(e) {
						if (this.contentLoadedActionSent) throw new Error("Improper sequence: ContentLoaded Action can only be send once after the widget loaded and should only be used if waitForIframeLoad is false (default=true)");
						this.widget.waitForIframeLoad ? this.transport.reply(e, {
							error: {
								message: "Improper sequence: not expecting ContentLoaded event if waitForIframLoad is true (default=true)"
							}
						}) : (this.transport.reply(e, {}), this.beginCapabilities()), this.contentLoadedActionSent = !0
					}
				}, {
					key: "replyVersions",
					value: function(e) {
						this.transport.reply(e, {
							supported_versions: l.CurrentApiVersions
						})
					}
				}, {
					key: "handleCapabilitiesRenegotiate",
					value: function(e) {
						var t, i = this;
						this.transport.reply(e, {});
						var n = (null === (t = e.data) || void 0 === t ? void 0 : t.capabilities) || [],
							r = new Set(n.filter((function(e) {
								return !i.hasCapability(e)
							})));
						if (0 === r.size) return this.notifyCapabilities([]);
						this.driver.validateCapabilities(r).then((function(e) {
							return e.forEach((function(e) {
								return i.allowedCapabilities.add(e)
							})), c.WidgetEventCapability.findEventCapabilities(e).forEach((function(e) {
								return i.allowedEvents.push(e)
							})), i.notifyCapabilities(Array.from(r))
						}))
					}
				}, {
					key: "handleNavigate",
					value: function(e) {
						var t, i, n = this;
						if (!this.hasCapability(d.MatrixCapabilities.MSC2931Navigate)) return this.transport.reply(e, {
							error: {
								message: "Missing capability"
							}
						});
						if (null === (t = e.data) || void 0 === t || !t.uri || null === (i = e.data) || void 0 === i || !i.uri.toString().startsWith("https://matrix.to/#")) return this.transport.reply(e, {
							error: {
								message: "Invalid matrix.to URI"
							}
						});
						var r = function(t) {
							return console.error("[ClientWidgetApi] Failed to handle navigation: ", t), n.transport.reply(e, {
								error: {
									message: "Error handling navigation"
								}
							})
						};
						try {
							this.driver.navigate(e.data.uri.toString()).catch((function(e) {
								return r(e)
							})).then((function() {
								return n.transport.reply(e, {})
							}))
						} catch (s) {
							return r(s)
						}
					}
				}, {
					key: "handleOIDC",
					value: function(e) {
						var t = this,
							i = 1,
							n = function(n, r) {
								return r = r || {}, i > 1 ? t.transport.send(a.WidgetApiToWidgetAction.OpenIDCredentials, _({
									state: n,
									original_request_id: e.requestId
								}, r)) : t.transport.reply(e, _({
									state: n
								}, r))
							},
							r = function(r) {
								return console.error("[ClientWidgetApi] Failed to handle OIDC: ", r), i > 1 ? n(u.OpenIDRequestState.Blocked) : t.transport.reply(e, {
									error: {
										message: r
									}
								})
							},
							s = new h.SimpleObservable((function(e) {
								return e.state === u.OpenIDRequestState.PendingUserConfirmation && i > 1 ? (s.close(), r("client provided out-of-phase response to OIDC flow")) : e.state === u.OpenIDRequestState.PendingUserConfirmation ? (n(e.state), void i++) : e.state !== u.OpenIDRequestState.Allowed || e.token ? (e.state === u.OpenIDRequestState.Blocked && (e.token = null), s.close(), n(e.state, e.token)) : r("client provided invalid OIDC token for an allowed request")
							}));
						this.driver.askOpenID(s)
					}
				}, {
					key: "handleReadEvents",
					value: function(e) {
						var t = this;
						if (!e.data.type) return this.transport.reply(e, {
							error: {
								message: "Invalid request - missing event type"
							}
						});
						if (void 0 !== e.data.limit && (!e.data.limit || e.data.limit < 0)) return this.transport.reply(e, {
							error: {
								message: "Invalid request - limit out of range"
							}
						});
						var i = null;
						if (e.data.room_ids) {
							i = e.data.room_ids, Array.isArray(i) || (i = [i]);
							var n, r = v(i);
							try {
								for (r.s(); !(n = r.n()).done;) {
									var s = n.value;
									if (!this.canUseRoomTimeline(s)) return this.transport.reply(e, {
										error: {
											message: "Unable to access room timeline: ".concat(s)
										}
									})
								}
							} catch (l) {
								r.e(l)
							} finally {
								r.f()
							}
						}
						var o = e.data.limit || 0,
							a = Promise.resolve([]);
						if (void 0 !== e.data.state_key) {
							var d = !0 === e.data.state_key ? void 0 : e.data.state_key.toString();
							if (!this.canReceiveStateEvent(e.data.type, d)) return this.transport.reply(e, {
								error: {
									message: "Cannot read state events of this type"
								}
							});
							a = this.driver.readStateEvents(e.data.type, d, o, i)
						} else {
							if (!this.canReceiveRoomEvent(e.data.type, e.data.msgtype)) return this.transport.reply(e, {
								error: {
									message: "Cannot read room events of this type"
								}
							});
							a = this.driver.readRoomEvents(e.data.type, e.data.msgtype, o, i)
						}
						return a.then((function(i) {
							return t.transport.reply(e, {
								events: i
							})
						}))
					}
				}, {
					key: "handleSendEvent",
					value: function(e) {
						var t, i = this;
						if (!e.data.type) return this.transport.reply(e, {
							error: {
								message: "Invalid request - missing event type"
							}
						});
						if (e.data.room_id && !this.canUseRoomTimeline(e.data.room_id)) return this.transport.reply(e, {
							error: {
								message: "Unable to access room timeline: ".concat(e.data.room_id)
							}
						});
						if (null !== e.data.state_key && void 0 !== e.data.state_key) {
							if (!this.canSendStateEvent(e.data.type, e.data.state_key)) return this.transport.reply(e, {
								error: {
									message: "Cannot send state events of this type"
								}
							});
							t = this.driver.sendEvent(e.data.type, e.data.content || {}, e.data.state_key, e.data.room_id)
						} else {
							var n = e.data.content || {},
								r = n.msgtype;
							if (!this.canSendRoomEvent(e.data.type, r)) return this.transport.reply(e, {
								error: {
									message: "Cannot send room events of this type"
								}
							});
							t = this.driver.sendEvent(e.data.type, n, null, e.data.room_id)
						}
						t.then((function(t) {
							return i.transport.reply(e, {
								room_id: t.roomId,
								event_id: t.eventId
							})
						})).catch((function(t) {
							return console.error("error sending event: ", t), i.transport.reply(e, {
								error: {
									message: "Error sending event"
								}
							})
						}))
					}
				}, {
					key: "handleSendToDevice",
					value: (j = f(p().mark((function e(t) {
						return p().wrap((function(e) {
							for (;;) switch (e.prev = e.next) {
								case 0:
									if (t.data.type) {
										e.next = 5;
										break
									}
									return e.next = 3, this.transport.reply(t, {
										error: {
											message: "Invalid request - missing event type"
										}
									});
								case 3:
									e.next = 32;
									break;
								case 5:
									if (t.data.messages) {
										e.next = 10;
										break
									}
									return e.next = 8, this.transport.reply(t, {
										error: {
											message: "Invalid request - missing event contents"
										}
									});
								case 8:
									e.next = 32;
									break;
								case 10:
									if ("boolean" == typeof t.data.encrypted) {
										e.next = 15;
										break
									}
									return e.next = 13, this.transport.reply(t, {
										error: {
											message: "Invalid request - missing encryption flag"
										}
									});
								case 13:
									e.next = 32;
									break;
								case 15:
									if (this.canSendToDeviceEvent(t.data.type)) {
										e.next = 20;
										break
									}
									return e.next = 18, this.transport.reply(t, {
										error: {
											message: "Cannot send to-device events of this type"
										}
									});
								case 18:
									e.next = 32;
									break;
								case 20:
									return e.prev = 20, e.next = 23, this.driver.sendToDevice(t.data.type, t.data.encrypted, t.data.messages);
								case 23:
									return e.next = 25, this.transport.reply(t, {});
								case 25:
									e.next = 32;
									break;
								case 27:
									return e.prev = 27, e.t0 = e.catch(20), console.error("error sending to-device event", e.t0), e.next = 32, this.transport.reply(t, {
										error: {
											message: "Error sending event"
										}
									});
								case 32:
								case "end":
									return e.stop()
							}
						}), e, this, [
							[20, 27]
						])
					}))), function(e) {
						return j.apply(this, arguments)
					})
				}, {
					key: "pollTurnServers",
					value: (I = f(p().mark((function e(t, i) {
						var n, r, s, o, d, l;
						return p().wrap((function(e) {
							for (;;) switch (e.prev = e.next) {
								case 0:
									return e.prev = 0, e.next = 3, this.transport.send(a.WidgetApiToWidgetAction.UpdateTurnServers, i);
								case 3:
									n = !1, r = !1, e.prev = 5, o = R(t);
								case 7:
									return e.next = 9, o.next();
								case 9:
									if (!(n = !(d = e.sent).done)) {
										e.next = 16;
										break
									}
									return l = d.value, e.next = 13, this.transport.send(a.WidgetApiToWidgetAction.UpdateTurnServers, l);
								case 13:
									n = !1, e.next = 7;
									break;
								case 16:
									e.next = 22;
									break;
								case 18:
									e.prev = 18, e.t0 = e.catch(5), r = !0, s = e.t0;
								case 22:
									if (e.prev = 22, e.prev = 23, !n || null == o.return) {
										e.next = 27;
										break
									}
									return e.next = 27, o.return();
								case 27:
									if (e.prev = 27, !r) {
										e.next = 30;
										break
									}
									throw s;
								case 30:
									return e.finish(27);
								case 31:
									return e.finish(22);
								case 32:
									e.next = 37;
									break;
								case 34:
									e.prev = 34, e.t1 = e.catch(0), console.error("error polling for TURN servers", e.t1);
								case 37:
								case "end":
									return e.stop()
							}
						}), e, this, [
							[0, 34],
							[5, 18, 22, 32],
							[23, , 27, 31]
						])
					}))), function(e, t) {
						return I.apply(this, arguments)
					})
				}, {
					key: "handleWatchTurnServers",
					value: (k = f(p().mark((function e(t) {
						var i, n, r, s;
						return p().wrap((function(e) {
							for (;;) switch (e.prev = e.next) {
								case 0:
									if (this.hasCapability(d.MatrixCapabilities.MSC3846TurnServers)) {
										e.next = 5;
										break
									}
									return e.next = 3, this.transport.reply(t, {
										error: {
											message: "Missing capability"
										}
									});
								case 3:
									e.next = 30;
									break;
								case 5:
									if (!this.turnServers) {
										e.next = 10;
										break
									}
									return e.next = 8, this.transport.reply(t, {});
								case 8:
									e.next = 30;
									break;
								case 10:
									return e.prev = 10, i = this.driver.getTurnServers(), e.next = 14, i.next();
								case 14:
									if (n = e.sent, r = n.done, s = n.value, !r) {
										e.next = 19;
										break
									}
									throw new Error("Client refuses to provide any TURN servers");
								case 19:
									return e.next = 21, this.transport.reply(t, {});
								case 21:
									this.pollTurnServers(i, s), this.turnServers = i, e.next = 30;
									break;
								case 25:
									return e.prev = 25, e.t0 = e.catch(10), console.error("error getting first TURN server results", e.t0), e.next = 30, this.transport.reply(t, {
										error: {
											message: "TURN servers not available"
										}
									});
								case 30:
								case "end":
									return e.stop()
							}
						}), e, this, [
							[10, 25]
						])
					}))), function(e) {
						return k.apply(this, arguments)
					})
				}, {
					key: "handleUnwatchTurnServers",
					value: (b = f(p().mark((function e(t) {
						return p().wrap((function(e) {
							for (;;) switch (e.prev = e.next) {
								case 0:
									if (this.hasCapability(d.MatrixCapabilities.MSC3846TurnServers)) {
										e.next = 5;
										break
									}
									return e.next = 3, this.transport.reply(t, {
										error: {
											message: "Missing capability"
										}
									});
								case 3:
									e.next = 15;
									break;
								case 5:
									if (this.turnServers) {
										e.next = 10;
										break
									}
									return e.next = 8, this.transport.reply(t, {});
								case 8:
									e.next = 15;
									break;
								case 10:
									return e.next = 12, this.turnServers.return(void 0);
								case 12:
									return this.turnServers = null, e.next = 15, this.transport.reply(t, {});
								case 15:
								case "end":
									return e.stop()
							}
						}), e, this)
					}))), function(e) {
						return b.apply(this, arguments)
					})
				}, {
					key: "handleReadRelations",
					value: (y = f(p().mark((function e(t) {
						var i, n, r = this;
						return p().wrap((function(e) {
							for (;;) switch (e.prev = e.next) {
								case 0:
									if (t.data.event_id) {
										e.next = 2;
										break
									}
									return e.abrupt("return", this.transport.reply(t, {
										error: {
											message: "Invalid request - missing event ID"
										}
									}));
								case 2:
									if (!(void 0 !== t.data.limit && t.data.limit < 0)) {
										e.next = 4;
										break
									}
									return e.abrupt("return", this.transport.reply(t, {
										error: {
											message: "Invalid request - limit out of range"
										}
									}));
								case 4:
									if (void 0 === t.data.room_id || this.canUseRoomTimeline(t.data.room_id)) {
										e.next = 6;
										break
									}
									return e.abrupt("return", this.transport.reply(t, {
										error: {
											message: "Unable to access room timeline: ".concat(t.data.room_id)
										}
									}));
								case 6:
									return e.prev = 6, e.next = 9, this.driver.readEventRelations(t.data.event_id, t.data.room_id, t.data.rel_type, t.data.event_type, t.data.from, t.data.to, t.data.limit, t.data.direction);
								case 9:
									if (!(i = e.sent).originalEvent) {
										e.next = 18;
										break
									}
									if (void 0 === i.originalEvent.state_key) {
										e.next = 16;
										break
									}
									if (this.canReceiveStateEvent(i.originalEvent.type, i.originalEvent.state_key)) {
										e.next = 14;
										break
									}
									return e.abrupt("return", this.transport.reply(t, {
										error: {
											message: "Cannot read state events of this type"
										}
									}));
								case 14:
									e.next = 18;
									break;
								case 16:
									if (this.canReceiveRoomEvent(i.originalEvent.type, i.originalEvent.content.msgtype)) {
										e.next = 18;
										break
									}
									return e.abrupt("return", this.transport.reply(t, {
										error: {
											message: "Cannot read room events of this type"
										}
									}));
								case 18:
									return n = i.chunk.filter((function(e) {
										return void 0 !== e.state_key ? r.canReceiveStateEvent(e.type, e.state_key) : r.canReceiveRoomEvent(e.type, e.content.msgtype)
									})), e.abrupt("return", this.transport.reply(t, {
										original_event: i.originalEvent,
										chunk: n,
										prev_batch: i.prevBatch,
										next_batch: i.nextBatch
									}));
								case 22:
									return e.prev = 22, e.t0 = e.catch(6), console.error("error getting the relations", e.t0), e.next = 27, this.transport.reply(t, {
										error: {
											message: "Unexpected error while reading relations"
										}
									});
								case 27:
								case "end":
									return e.stop()
							}
						}), e, this, [
							[6, 22]
						])
					}))), function(e) {
						return y.apply(this, arguments)
					})
				}, {
					key: "handleMessage",
					value: function(e) {
						if (!this.isStopped) {
							var t = new CustomEvent("action:".concat(e.detail.action), {
								detail: e.detail,
								cancelable: !0
							});
							if (this.emit("action:".concat(e.detail.action), t), !t.defaultPrevented) switch (e.detail.action) {
								case a.WidgetApiFromWidgetAction.ContentLoaded:
									return this.handleContentLoadedAction(e.detail);
								case a.WidgetApiFromWidgetAction.SupportedApiVersions:
									return this.replyVersions(e.detail);
								case a.WidgetApiFromWidgetAction.SendEvent:
									return this.handleSendEvent(e.detail);
								case a.WidgetApiFromWidgetAction.SendToDevice:
									return this.handleSendToDevice(e.detail);
								case a.WidgetApiFromWidgetAction.GetOpenIDCredentials:
									return this.handleOIDC(e.detail);
								case a.WidgetApiFromWidgetAction.MSC2931Navigate:
									return this.handleNavigate(e.detail);
								case a.WidgetApiFromWidgetAction.MSC2974RenegotiateCapabilities:
									return this.handleCapabilitiesRenegotiate(e.detail);
								case a.WidgetApiFromWidgetAction.MSC2876ReadEvents:
									return this.handleReadEvents(e.detail);
								case a.WidgetApiFromWidgetAction.WatchTurnServers:
									return this.handleWatchTurnServers(e.detail);
								case a.WidgetApiFromWidgetAction.UnwatchTurnServers:
									return this.handleUnwatchTurnServers(e.detail);
								case a.WidgetApiFromWidgetAction.MSC3869ReadRelations:
									return this.handleReadRelations(e.detail);
								default:
									return this.transport.reply(e.detail, {
										error: {
											message: "Unknown or unsupported action: " + e.detail.action
										}
									})
							}
						}
					}
				}, {
					key: "takeScreenshot",
					value: function() {
						return this.transport.send(a.WidgetApiToWidgetAction.TakeScreenshot, {})
					}
				}, {
					key: "updateVisibility",
					value: function(e) {
						return this.transport.send(a.WidgetApiToWidgetAction.UpdateVisibility, {
							visible: e
						})
					}
				}, {
					key: "sendWidgetConfig",
					value: function(e) {
						return this.transport.send(a.WidgetApiToWidgetAction.WidgetConfig, e).then()
					}
				}, {
					key: "notifyModalWidgetButtonClicked",
					value: function(e) {
						return this.transport.send(a.WidgetApiToWidgetAction.ButtonClicked, {
							id: e
						}).then()
					}
				}, {
					key: "notifyModalWidgetClose",
					value: function(e) {
						return this.transport.send(a.WidgetApiToWidgetAction.CloseModalWidget, e).then()
					}
				}, {
					key: "feedEvent",
					value: (g = f(p().mark((function e(t, i) {
						var n;
						return p().wrap((function(e) {
							for (;;) switch (e.prev = e.next) {
								case 0:
									if (t.room_id === i || this.canUseRoomTimeline(t.room_id)) {
										e.next = 2;
										break
									}
									return e.abrupt("return");
								case 2:
									if (void 0 === t.state_key || null === t.state_key) {
										e.next = 7;
										break
									}
									if (this.canReceiveStateEvent(t.type, t.state_key)) {
										e.next = 5;
										break
									}
									return e.abrupt("return");
								case 5:
									e.next = 9;
									break;
								case 7:
									if (this.canReceiveRoomEvent(t.type, null === (n = t.content) || void 0 === n ? void 0 : n.msgtype)) {
										e.next = 9;
										break
									}
									return e.abrupt("return");
								case 9:
									return e.next = 11, this.transport.send(a.WidgetApiToWidgetAction.SendEvent, t);
								case 11:
								case "end":
									return e.stop()
							}
						}), e, this)
					}))), function(e, t) {
						return g.apply(this, arguments)
					})
				}, {
					key: "feedToDevice",
					value: (r = f(p().mark((function e(t, i) {
						return p().wrap((function(e) {
							for (;;) switch (e.prev = e.next) {
								case 0:
									if (!this.canReceiveToDeviceEvent(t.type)) {
										e.next = 3;
										break
									}
									return e.next = 3, this.transport.send(a.WidgetApiToWidgetAction.SendToDevice, _(_({}, t), {}, {
										encrypted: i
									}));
								case 3:
								case "end":
									return e.stop()
							}
						}), e, this)
					}))), function(e, t) {
						return r.apply(this, arguments)
					})
				}]) && S(t.prototype, i), n && S(t, n), Object.defineProperty(t, "prototype", {
					writable: !1
				}), x
			}(r.EventEmitter);
			t.ClientWidgetApi = O
		},
		"./node_modules/matrix-widget-api/lib/Symbols.js": function(e, t, i) {
			"use strict";
			var n;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.Symbols = void 0, t.Symbols = n,
				function(e) {
					e.AnyRoom = "*"
				}(n || (t.Symbols = n = {}))
		},
		"./node_modules/matrix-widget-api/lib/WidgetApi.js": function(e, t, i) {
			"use strict";

			function n(e) {
				return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				})(e)
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.WidgetApi = void 0;
			var r = i("./node_modules/node-libs-browser/node_modules/events/events.js"),
				s = i("./node_modules/matrix-widget-api/lib/interfaces/WidgetApiDirection.js"),
				o = i("./node_modules/matrix-widget-api/lib/interfaces/ApiVersion.js"),
				a = i("./node_modules/matrix-widget-api/lib/transport/PostmessageTransport.js"),
				d = i("./node_modules/matrix-widget-api/lib/interfaces/WidgetApiAction.js"),
				l = i("./node_modules/matrix-widget-api/lib/interfaces/GetOpenIDAction.js"),
				c = i("./node_modules/matrix-widget-api/lib/interfaces/WidgetType.js"),
				u = i("./node_modules/matrix-widget-api/lib/interfaces/ModalWidgetActions.js"),
				h = i("./node_modules/matrix-widget-api/lib/models/WidgetEventCapability.js"),
				m = i("./node_modules/matrix-widget-api/lib/Symbols.js");

			function p() {
				p = function() {
					return e
				};
				var e = {},
					t = Object.prototype,
					i = t.hasOwnProperty,
					r = "function" == typeof Symbol ? Symbol : {},
					s = r.iterator || "@@iterator",
					o = r.asyncIterator || "@@asyncIterator",
					a = r.toStringTag || "@@toStringTag";

				function d(e, t, i) {
					return Object.defineProperty(e, t, {
						value: i,
						enumerable: !0,
						configurable: !0,
						writable: !0
					}), e[t]
				}
				try {
					d({}, "")
				} catch (R) {
					d = function(e, t, i) {
						return e[t] = i
					}
				}

				function l(e, t, i, n) {
					var r = t && t.prototype instanceof h ? t : h,
						s = Object.create(r.prototype),
						o = new T(n || []);
					return s._invoke = function(e, t, i) {
						var n = "suspendedStart";
						return function(r, s) {
							if ("executing" === n) throw new Error("Generator is already running");
							if ("completed" === n) {
								if ("throw" === r) throw s;
								return C()
							}
							for (i.method = r, i.arg = s;;) {
								var o = i.delegate;
								if (o) {
									var a = E(o, i);
									if (a) {
										if (a === u) continue;
										return a
									}
								}
								if ("next" === i.method) i.sent = i._sent = i.arg;
								else if ("throw" === i.method) {
									if ("suspendedStart" === n) throw n = "completed", i.arg;
									i.dispatchException(i.arg)
								} else "return" === i.method && i.abrupt("return", i.arg);
								n = "executing";
								var d = c(e, t, i);
								if ("normal" === d.type) {
									if (n = i.done ? "completed" : "suspendedYield", d.arg === u) continue;
									return {
										value: d.arg,
										done: i.done
									}
								}
								"throw" === d.type && (n = "completed", i.method = "throw", i.arg = d.arg)
							}
						}
					}(e, i, o), s
				}

				function c(e, t, i) {
					try {
						return {
							type: "normal",
							arg: e.call(t, i)
						}
					} catch (R) {
						return {
							type: "throw",
							arg: R
						}
					}
				}
				e.wrap = l;
				var u = {};

				function h() {}

				function m() {}

				function g() {}
				var f = {};
				d(f, s, (function() {
					return this
				}));
				var v = Object.getPrototypeOf,
					y = v && v(v(I([])));
				y && y !== t && i.call(y, s) && (f = y);
				var b = g.prototype = h.prototype = Object.create(f);

				function _(e) {
					["next", "throw", "return"].forEach((function(t) {
						d(e, t, (function(e) {
							return this._invoke(t, e)
						}))
					}))
				}

				function S(e, t) {
					var r;
					this._invoke = function(s, o) {
						function a() {
							return new t((function(r, a) {
								! function r(s, o, a, d) {
									var l = c(e[s], e, o);
									if ("throw" !== l.type) {
										var u = l.arg,
											h = u.value;
										return h && "object" == n(h) && i.call(h, "__await") ? t.resolve(h.__await).then((function(e) {
											r("next", e, a, d)
										}), (function(e) {
											r("throw", e, a, d)
										})) : t.resolve(h).then((function(e) {
											u.value = e, a(u)
										}), (function(e) {
											return r("throw", e, a, d)
										}))
									}
									d(l.arg)
								}(s, o, r, a)
							}))
						}
						return r = r ? r.then(a, a) : a()
					}
				}

				function E(e, t) {
					var i = e.iterator[t.method];
					if (void 0 === i) {
						if (t.delegate = null, "throw" === t.method) {
							if (e.iterator.return && (t.method = "return", t.arg = void 0, E(e, t), "throw" === t.method)) return u;
							t.method = "throw", t.arg = new TypeError("The iterator does not provide a 'throw' method")
						}
						return u
					}
					var n = c(i, e.iterator, t.arg);
					if ("throw" === n.type) return t.method = "throw", t.arg = n.arg, t.delegate = null, u;
					var r = n.arg;
					return r ? r.done ? (t[e.resultName] = r.value, t.next = e.nextLoc, "return" !== t.method && (t.method = "next", t.arg = void 0), t.delegate = null, u) : r : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, u)
				}

				function w(e) {
					var t = {
						tryLoc: e[0]
					};
					1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
				}

				function k(e) {
					var t = e.completion || {};
					t.type = "normal", delete t.arg, e.completion = t
				}

				function T(e) {
					this.tryEntries = [{
						tryLoc: "root"
					}], e.forEach(w, this), this.reset(!0)
				}

				function I(e) {
					if (e) {
						var t = e[s];
						if (t) return t.call(e);
						if ("function" == typeof e.next) return e;
						if (!isNaN(e.length)) {
							var n = -1,
								r = function t() {
									for (; ++n < e.length;)
										if (i.call(e, n)) return t.value = e[n], t.done = !1, t;
									return t.value = void 0, t.done = !0, t
								};
							return r.next = r
						}
					}
					return {
						next: C
					}
				}

				function C() {
					return {
						value: void 0,
						done: !0
					}
				}
				return m.prototype = g, d(b, "constructor", g), d(g, "constructor", m), m.displayName = d(g, a, "GeneratorFunction"), e.isGeneratorFunction = function(e) {
					var t = "function" == typeof e && e.constructor;
					return !!t && (t === m || "GeneratorFunction" === (t.displayName || t.name))
				}, e.mark = function(e) {
					return Object.setPrototypeOf ? Object.setPrototypeOf(e, g) : (e.__proto__ = g, d(e, a, "GeneratorFunction")), e.prototype = Object.create(b), e
				}, e.awrap = function(e) {
					return {
						__await: e
					}
				}, _(S.prototype), d(S.prototype, o, (function() {
					return this
				})), e.AsyncIterator = S, e.async = function(t, i, n, r, s) {
					void 0 === s && (s = Promise);
					var o = new S(l(t, i, n, r), s);
					return e.isGeneratorFunction(i) ? o : o.next().then((function(e) {
						return e.done ? e.value : o.next()
					}))
				}, _(b), d(b, a, "Generator"), d(b, s, (function() {
					return this
				})), d(b, "toString", (function() {
					return "[object Generator]"
				})), e.keys = function(e) {
					var t = [];
					for (var i in e) t.push(i);
					return t.reverse(),
						function i() {
							for (; t.length;) {
								var n = t.pop();
								if (n in e) return i.value = n, i.done = !1, i
							}
							return i.done = !0, i
						}
				}, e.values = I, T.prototype = {
					constructor: T,
					reset: function(e) {
						if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(k), !e)
							for (var t in this) "t" === t.charAt(0) && i.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0)
					},
					stop: function() {
						this.done = !0;
						var e = this.tryEntries[0].completion;
						if ("throw" === e.type) throw e.arg;
						return this.rval
					},
					dispatchException: function(e) {
						if (this.done) throw e;
						var t = this;

						function n(i, n) {
							return o.type = "throw", o.arg = e, t.next = i, n && (t.method = "next", t.arg = void 0), !!n
						}
						for (var r = this.tryEntries.length - 1; r >= 0; --r) {
							var s = this.tryEntries[r],
								o = s.completion;
							if ("root" === s.tryLoc) return n("end");
							if (s.tryLoc <= this.prev) {
								var a = i.call(s, "catchLoc"),
									d = i.call(s, "finallyLoc");
								if (a && d) {
									if (this.prev < s.catchLoc) return n(s.catchLoc, !0);
									if (this.prev < s.finallyLoc) return n(s.finallyLoc)
								} else if (a) {
									if (this.prev < s.catchLoc) return n(s.catchLoc, !0)
								} else {
									if (!d) throw new Error("try statement without catch or finally");
									if (this.prev < s.finallyLoc) return n(s.finallyLoc)
								}
							}
						}
					},
					abrupt: function(e, t) {
						for (var n = this.tryEntries.length - 1; n >= 0; --n) {
							var r = this.tryEntries[n];
							if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
								var s = r;
								break
							}
						}
						s && ("break" === e || "continue" === e) && s.tryLoc <= t && t <= s.finallyLoc && (s = null);
						var o = s ? s.completion : {};
						return o.type = e, o.arg = t, s ? (this.method = "next", this.next = s.finallyLoc, u) : this.complete(o)
					},
					complete: function(e, t) {
						if ("throw" === e.type) throw e.arg;
						return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), u
					},
					finish: function(e) {
						for (var t = this.tryEntries.length - 1; t >= 0; --t) {
							var i = this.tryEntries[t];
							if (i.finallyLoc === e) return this.complete(i.completion, i.afterLoc), k(i), u
						}
					},
					catch: function(e) {
						for (var t = this.tryEntries.length - 1; t >= 0; --t) {
							var i = this.tryEntries[t];
							if (i.tryLoc === e) {
								var n = i.completion;
								if ("throw" === n.type) {
									var r = n.arg;
									k(i)
								}
								return r
							}
						}
						throw new Error("illegal catch attempt")
					},
					delegateYield: function(e, t, i) {
						return this.delegate = {
							iterator: I(e),
							resultName: t,
							nextLoc: i
						}, "next" === this.method && (this.arg = void 0), u
					}
				}, e
			}

			function g(e, t, i, n, r, s, o) {
				try {
					var a = e[s](o),
						d = a.value
				} catch (l) {
					return void i(l)
				}
				a.done ? t(d) : Promise.resolve(d).then(n, r)
			}

			function f(e) {
				return function() {
					var t = this,
						i = arguments;
					return new Promise((function(n, r) {
						var s = e.apply(t, i);

						function o(e) {
							g(s, n, r, o, a, "next", e)
						}

						function a(e) {
							g(s, n, r, o, a, "throw", e)
						}
						o(void 0)
					}))
				}
			}

			function v(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}

			function y(e, t) {
				return (y = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
					return e.__proto__ = t, e
				})(e, t)
			}

			function b(e) {
				var t = function() {
					if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
					if (Reflect.construct.sham) return !1;
					if ("function" == typeof Proxy) return !0;
					try {
						return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
					} catch (e) {
						return !1
					}
				}();
				return function() {
					var i, n = E(e);
					if (t) {
						var r = E(this).constructor;
						i = Reflect.construct(n, arguments, r)
					} else i = n.apply(this, arguments);
					return _(this, i)
				}
			}

			function _(e, t) {
				if (t && ("object" === n(t) || "function" == typeof t)) return t;
				if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
				return S(e)
			}

			function S(e) {
				if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				return e
			}

			function E(e) {
				return (E = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
					return e.__proto__ || Object.getPrototypeOf(e)
				})(e)
			}

			function w(e, t, i) {
				return t in e ? Object.defineProperty(e, t, {
					value: i,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = i, e
			}

			function k(e) {
				return new I(e)
			}

			function T(e) {
				var t, i;

				function n(t, i) {
					try {
						var s = e[t](i),
							o = s.value,
							a = o instanceof I;
						Promise.resolve(a ? o.wrapped : o).then((function(e) {
							a ? n("return" === t ? "return" : "next", e) : r(s.done ? "return" : "normal", e)
						}), (function(e) {
							n("throw", e)
						}))
					} catch (d) {
						r("throw", d)
					}
				}

				function r(e, r) {
					switch (e) {
						case "return":
							t.resolve({
								value: r,
								done: !0
							});
							break;
						case "throw":
							t.reject(r);
							break;
						default:
							t.resolve({
								value: r,
								done: !1
							})
					}(t = t.next) ? n(t.key, t.arg): i = null
				}
				this._invoke = function(e, r) {
					return new Promise((function(s, o) {
						var a = {
							key: e,
							arg: r,
							resolve: s,
							reject: o,
							next: null
						};
						i ? i = i.next = a : (t = i = a, n(e, r))
					}))
				}, "function" != typeof e.return && (this.return = void 0)
			}

			function I(e) {
				this.wrapped = e
			}
			T.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
				return this
			}, T.prototype.next = function(e) {
				return this._invoke("next", e)
			}, T.prototype.throw = function(e) {
				return this._invoke("throw", e)
			}, T.prototype.return = function(e) {
				return this._invoke("return", e)
			};
			var C = function(e) {
				! function(e, t) {
					if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
					e.prototype = Object.create(t && t.prototype, {
						constructor: {
							value: e,
							writable: !0,
							configurable: !0
						}
					}), Object.defineProperty(e, "prototype", {
						writable: !1
					}), t && y(e, t)
				}(_, e);
				var t, i, n, r, g = b(_);

				function _() {
					var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
					if (function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, _), (e = g.call(this)).clientOrigin = i, w(S(e), "transport", void 0), w(S(e), "capabilitiesFinished", !1), w(S(e), "supportsMSC2974Renegotiate", !1), w(S(e), "requestedCapabilities", []), w(S(e), "approvedCapabilities", void 0), w(S(e), "cachedClientVersions", void 0), w(S(e), "turnServerWatchers", 0), !window.parent) throw new Error("No parent window. This widget doesn't appear to be embedded properly.");
					return e.transport = new a.PostmessageTransport(s.WidgetApiDirection.FromWidget, t, window.parent, window), e.transport.targetOrigin = i, e.transport.on("message", e.handleMessage.bind(S(e))), e
				}
				return t = _, (i = [{
					key: "hasCapability",
					value: function(e) {
						return Array.isArray(this.approvedCapabilities) ? this.approvedCapabilities.includes(e) : this.requestedCapabilities.includes(e)
					}
				}, {
					key: "requestCapability",
					value: function(e) {
						if (this.capabilitiesFinished && !this.supportsMSC2974Renegotiate) throw new Error("Capabilities have already been negotiated");
						this.requestedCapabilities.push(e)
					}
				}, {
					key: "requestCapabilities",
					value: function(e) {
						var t = this;
						e.forEach((function(e) {
							return t.requestCapability(e)
						}))
					}
				}, {
					key: "requestCapabilityForRoomTimeline",
					value: function(e) {
						this.requestCapability("org.matrix.msc2762.timeline:".concat(e))
					}
				}, {
					key: "requestCapabilityToSendState",
					value: function(e, t) {
						this.requestCapability(h.WidgetEventCapability.forStateEvent(h.EventDirection.Send, e, t).raw)
					}
				}, {
					key: "requestCapabilityToReceiveState",
					value: function(e, t) {
						this.requestCapability(h.WidgetEventCapability.forStateEvent(h.EventDirection.Receive, e, t).raw)
					}
				}, {
					key: "requestCapabilityToSendToDevice",
					value: function(e) {
						this.requestCapability(h.WidgetEventCapability.forToDeviceEvent(h.EventDirection.Send, e).raw)
					}
				}, {
					key: "requestCapabilityToReceiveToDevice",
					value: function(e) {
						this.requestCapability(h.WidgetEventCapability.forToDeviceEvent(h.EventDirection.Receive, e).raw)
					}
				}, {
					key: "requestCapabilityToSendEvent",
					value: function(e) {
						this.requestCapability(h.WidgetEventCapability.forRoomEvent(h.EventDirection.Send, e).raw)
					}
				}, {
					key: "requestCapabilityToReceiveEvent",
					value: function(e) {
						this.requestCapability(h.WidgetEventCapability.forRoomEvent(h.EventDirection.Receive, e).raw)
					}
				}, {
					key: "requestCapabilityToSendMessage",
					value: function(e) {
						this.requestCapability(h.WidgetEventCapability.forRoomMessageEvent(h.EventDirection.Send, e).raw)
					}
				}, {
					key: "requestCapabilityToReceiveMessage",
					value: function(e) {
						this.requestCapability(h.WidgetEventCapability.forRoomMessageEvent(h.EventDirection.Receive, e).raw)
					}
				}, {
					key: "requestOpenIDConnectToken",
					value: function() {
						var e = this;
						return new Promise((function(t, i) {
							e.transport.sendComplete(d.WidgetApiFromWidgetAction.GetOpenIDCredentials, {}).then((function(n) {
								var r = n.response;
								r.state === l.OpenIDRequestState.Allowed ? t(r) : r.state === l.OpenIDRequestState.Blocked ? i(new Error("User declined to verify their identity")) : r.state === l.OpenIDRequestState.PendingUserConfirmation ? e.on("action:".concat(d.WidgetApiToWidgetAction.OpenIDCredentials), (function s(o) {
									o.preventDefault();
									var a = o.detail;
									a.data.original_request_id === n.requestId && (a.data.state === l.OpenIDRequestState.Allowed ? (t(a.data), e.transport.reply(a, {})) : a.data.state === l.OpenIDRequestState.Blocked ? (i(new Error("User declined to verify their identity")), e.transport.reply(a, {})) : (i(new Error("Invalid state on reply: " + r.state)), e.transport.reply(a, {
										error: {
											message: "Invalid state"
										}
									})), e.off("action:".concat(d.WidgetApiToWidgetAction.OpenIDCredentials), s))
								})) : i(new Error("Invalid state: " + r.state))
							})).catch(i)
						}))
					}
				}, {
					key: "updateRequestedCapabilities",
					value: function() {
						return this.transport.send(d.WidgetApiFromWidgetAction.MSC2974RenegotiateCapabilities, {
							capabilities: this.requestedCapabilities
						}).then()
					}
				}, {
					key: "sendContentLoaded",
					value: function() {
						return this.transport.send(d.WidgetApiFromWidgetAction.ContentLoaded, {}).then()
					}
				}, {
					key: "sendSticker",
					value: function(e) {
						return this.transport.send(d.WidgetApiFromWidgetAction.SendSticker, e).then()
					}
				}, {
					key: "setAlwaysOnScreen",
					value: function(e) {
						return this.transport.send(d.WidgetApiFromWidgetAction.UpdateAlwaysOnScreen, {
							value: e
						}).then((function(e) {
							return e.success
						}))
					}
				}, {
					key: "openModalWidget",
					value: function(e, t) {
						var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [],
							n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
							r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : c.MatrixWidgetType.Custom;
						return this.transport.send(d.WidgetApiFromWidgetAction.OpenModalWidget, {
							type: r,
							url: e,
							name: t,
							buttons: i,
							data: n
						}).then()
					}
				}, {
					key: "closeModalWidget",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
						return this.transport.send(d.WidgetApiFromWidgetAction.CloseModalWidget, e).then()
					}
				}, {
					key: "sendRoomEvent",
					value: function(e, t, i) {
						return this.transport.send(d.WidgetApiFromWidgetAction.SendEvent, {
							type: e,
							content: t,
							room_id: i
						})
					}
				}, {
					key: "sendStateEvent",
					value: function(e, t, i, n) {
						return this.transport.send(d.WidgetApiFromWidgetAction.SendEvent, {
							type: e,
							content: i,
							state_key: t,
							room_id: n
						})
					}
				}, {
					key: "sendToDevice",
					value: function(e, t, i) {
						return this.transport.send(d.WidgetApiFromWidgetAction.SendToDevice, {
							type: e,
							encrypted: t,
							messages: i
						})
					}
				}, {
					key: "readRoomEvents",
					value: function(e, t, i, n) {
						var r = {
							type: e,
							msgtype: i
						};
						return void 0 !== t && (r.limit = t), n && (n.includes(m.Symbols.AnyRoom) ? r.room_ids = m.Symbols.AnyRoom : r.room_ids = n), this.transport.send(d.WidgetApiFromWidgetAction.MSC2876ReadEvents, r).then((function(e) {
							return e.events
						}))
					}
				}, {
					key: "readEventRelations",
					value: (r = f(p().mark((function e(t, i, n, r, s, a, l, c) {
						var u;
						return p().wrap((function(e) {
							for (;;) switch (e.prev = e.next) {
								case 0:
									return e.next = 2, this.getClientVersions();
								case 2:
									if (e.sent.includes(o.UnstableApiVersion.MSC3869)) {
										e.next = 5;
										break
									}
									throw new Error("The read_relations action is not supported by the client.");
								case 5:
									return u = {
										event_id: t,
										rel_type: n,
										event_type: r,
										room_id: i,
										to: l,
										from: a,
										limit: s,
										direction: c
									}, e.abrupt("return", this.transport.send(d.WidgetApiFromWidgetAction.MSC3869ReadRelations, u));
								case 7:
								case "end":
									return e.stop()
							}
						}), e, this)
					}))), function(e, t, i, n, s, o, a, d) {
						return r.apply(this, arguments)
					})
				}, {
					key: "readStateEvents",
					value: function(e, t, i, n) {
						var r = {
							type: e,
							state_key: void 0 === i || i
						};
						return void 0 !== t && (r.limit = t), n && (n.includes(m.Symbols.AnyRoom) ? r.room_ids = m.Symbols.AnyRoom : r.room_ids = n), this.transport.send(d.WidgetApiFromWidgetAction.MSC2876ReadEvents, r).then((function(e) {
							return e.events
						}))
					}
				}, {
					key: "setModalButtonEnabled",
					value: function(e, t) {
						if (e === u.BuiltInModalButtonID.Close) throw new Error("The close button cannot be disabled");
						return this.transport.send(d.WidgetApiFromWidgetAction.SetModalButtonEnabled, {
							button: e,
							enabled: t
						}).then()
					}
				}, {
					key: "navigateTo",
					value: function(e) {
						if (!e || !e.startsWith("https://matrix.to/#")) throw new Error("Invalid matrix.to URI");
						return this.transport.send(d.WidgetApiFromWidgetAction.MSC2931Navigate, {
							uri: e
						}).then()
					}
				}, {
					key: "getTurnServers",
					value: function() {
						var e, t = this;
						return (e = p().mark((function e() {
							var i, n;
							return p().wrap((function(e) {
								for (;;) switch (e.prev = e.next) {
									case 0:
										if (n = function() {
												var e = f(p().mark((function e(n) {
													return p().wrap((function(e) {
														for (;;) switch (e.prev = e.next) {
															case 0:
																return n.preventDefault(), i(n.detail.data), e.next = 4, t.transport.reply(n.detail, {});
															case 4:
															case "end":
																return e.stop()
														}
													}), e)
												})));
												return function(t) {
													return e.apply(this, arguments)
												}
											}(), t.on("action:".concat(d.WidgetApiToWidgetAction.UpdateTurnServers), n), 0 !== t.turnServerWatchers) {
											e.next = 12;
											break
										}
										return e.prev = 3, e.next = 6, k(t.transport.send(d.WidgetApiFromWidgetAction.WatchTurnServers, {}));
									case 6:
										e.next = 12;
										break;
									case 8:
										throw e.prev = 8, e.t0 = e.catch(3), t.off("action:".concat(d.WidgetApiToWidgetAction.UpdateTurnServers), n), e.t0;
									case 12:
										t.turnServerWatchers++, e.prev = 13;
									case 14:
										return e.next = 17, k(new Promise((function(e) {
											return i = e
										})));
									case 17:
										return e.next = 19, e.sent;
									case 19:
										e.next = 14;
										break;
									case 21:
										if (e.prev = 21, t.off("action:".concat(d.WidgetApiToWidgetAction.UpdateTurnServers), n), t.turnServerWatchers--, 0 !== t.turnServerWatchers) {
											e.next = 27;
											break
										}
										return e.next = 27, k(t.transport.send(d.WidgetApiFromWidgetAction.UnwatchTurnServers, {}));
									case 27:
										return e.finish(21);
									case 28:
									case "end":
										return e.stop()
								}
							}), e, null, [
								[3, 8],
								[13, , 21, 28]
							])
						})), function() {
							return new T(e.apply(this, arguments))
						})()
					}
				}, {
					key: "start",
					value: function() {
						var e = this;
						this.transport.start(), this.getClientVersions().then((function(t) {
							t.includes(o.UnstableApiVersion.MSC2974) && (e.supportsMSC2974Renegotiate = !0)
						}))
					}
				}, {
					key: "handleMessage",
					value: function(e) {
						var t = new CustomEvent("action:".concat(e.detail.action), {
							detail: e.detail,
							cancelable: !0
						});
						if (this.emit("action:".concat(e.detail.action), t), !t.defaultPrevented) switch (e.detail.action) {
							case d.WidgetApiToWidgetAction.SupportedApiVersions:
								return this.replyVersions(e.detail);
							case d.WidgetApiToWidgetAction.Capabilities:
								return this.handleCapabilities(e.detail);
							case d.WidgetApiToWidgetAction.UpdateVisibility:
							case d.WidgetApiToWidgetAction.NotifyCapabilities:
								return this.transport.reply(e.detail, {});
							default:
								return this.transport.reply(e.detail, {
									error: {
										message: "Unknown or unsupported action: " + e.detail.action
									}
								})
						}
					}
				}, {
					key: "replyVersions",
					value: function(e) {
						this.transport.reply(e, {
							supported_versions: o.CurrentApiVersions
						})
					}
				}, {
					key: "getClientVersions",
					value: function() {
						var e = this;
						return Array.isArray(this.cachedClientVersions) ? Promise.resolve(this.cachedClientVersions) : this.transport.send(d.WidgetApiFromWidgetAction.SupportedApiVersions, {}).then((function(t) {
							return e.cachedClientVersions = t.supported_versions, t.supported_versions
						})).catch((function(e) {
							return console.warn("non-fatal error getting supported client versions: ", e), []
						}))
					}
				}, {
					key: "handleCapabilities",
					value: function(e) {
						var t = this;
						return this.capabilitiesFinished ? this.transport.reply(e, {
							error: {
								message: "Capability negotiation already completed"
							}
						}) : this.getClientVersions().then((function(i) {
							return i.includes(o.UnstableApiVersion.MSC2871) ? t.once("action:".concat(d.WidgetApiToWidgetAction.NotifyCapabilities), (function(e) {
								t.approvedCapabilities = e.detail.data.approved, t.emit("ready")
							})) : t.emit("ready"), t.capabilitiesFinished = !0, t.transport.reply(e, {
								capabilities: t.requestedCapabilities
							})
						}))
					}
				}]) && v(t.prototype, i), n && v(t, n), Object.defineProperty(t, "prototype", {
					writable: !1
				}), _
			}(r.EventEmitter);
			t.WidgetApi = C
		},
		"./node_modules/matrix-widget-api/lib/driver/WidgetDriver.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.WidgetDriver = void 0;
			var n = i("./node_modules/matrix-widget-api/lib/index.js");

			function r(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}
			var s = function() {
				function e() {
					! function(e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
					}(this, e)
				}
				var t, i, s;
				return t = e, (i = [{
					key: "validateCapabilities",
					value: function(e) {
						return Promise.resolve(new Set)
					}
				}, {
					key: "sendEvent",
					value: function(e, t) {
						return arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], Promise.reject(new Error("Failed to override function"))
					}
				}, {
					key: "sendToDevice",
					value: function(e, t, i) {
						return Promise.reject(new Error("Failed to override function"))
					}
				}, {
					key: "readRoomEvents",
					value: function(e, t, i) {
						return arguments.length > 3 && void 0 !== arguments[3] && arguments[3], Promise.resolve([])
					}
				}, {
					key: "readStateEvents",
					value: function(e, t, i) {
						return arguments.length > 3 && void 0 !== arguments[3] && arguments[3], Promise.resolve([])
					}
				}, {
					key: "readEventRelations",
					value: function(e, t, i, n, r, s, o, a) {
						return Promise.resolve({
							chunk: []
						})
					}
				}, {
					key: "askOpenID",
					value: function(e) {
						e.update({
							state: n.OpenIDRequestState.Blocked
						})
					}
				}, {
					key: "navigate",
					value: function(e) {
						throw new Error("Navigation is not implemented")
					}
				}, {
					key: "getTurnServers",
					value: function() {
						throw new Error("TURN server support is not implemented")
					}
				}]) && r(t.prototype, i), s && r(t, s), Object.defineProperty(t, "prototype", {
					writable: !1
				}), e
			}();
			t.WidgetDriver = s
		},
		"./node_modules/matrix-widget-api/lib/index.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			});
			var n = i("./node_modules/matrix-widget-api/lib/WidgetApi.js");
			Object.keys(n).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === n[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return n[e]
					}
				}))
			}));
			var r = i("./node_modules/matrix-widget-api/lib/ClientWidgetApi.js");
			Object.keys(r).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === r[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return r[e]
					}
				}))
			}));
			var s = i("./node_modules/matrix-widget-api/lib/Symbols.js");
			Object.keys(s).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === s[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return s[e]
					}
				}))
			}));
			var o = i("./node_modules/matrix-widget-api/lib/transport/ITransport.js");
			Object.keys(o).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === o[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return o[e]
					}
				}))
			}));
			var a = i("./node_modules/matrix-widget-api/lib/transport/PostmessageTransport.js");
			Object.keys(a).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === a[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return a[e]
					}
				}))
			}));
			var d = i("./node_modules/matrix-widget-api/lib/interfaces/ICustomWidgetData.js");
			Object.keys(d).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === d[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return d[e]
					}
				}))
			}));
			var l = i("./node_modules/matrix-widget-api/lib/interfaces/IJitsiWidgetData.js");
			Object.keys(l).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === l[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return l[e]
					}
				}))
			}));
			var c = i("./node_modules/matrix-widget-api/lib/interfaces/IStickerpickerWidgetData.js");
			Object.keys(c).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === c[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return c[e]
					}
				}))
			}));
			var u = i("./node_modules/matrix-widget-api/lib/interfaces/IWidget.js");
			Object.keys(u).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === u[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return u[e]
					}
				}))
			}));
			var h = i("./node_modules/matrix-widget-api/lib/interfaces/WidgetType.js");
			Object.keys(h).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === h[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return h[e]
					}
				}))
			}));
			var m = i("./node_modules/matrix-widget-api/lib/interfaces/IWidgetApiErrorResponse.js");
			Object.keys(m).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === m[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return m[e]
					}
				}))
			}));
			var p = i("./node_modules/matrix-widget-api/lib/interfaces/IWidgetApiRequest.js");
			Object.keys(p).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === p[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return p[e]
					}
				}))
			}));
			var g = i("./node_modules/matrix-widget-api/lib/interfaces/IWidgetApiResponse.js");
			Object.keys(g).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === g[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return g[e]
					}
				}))
			}));
			var f = i("./node_modules/matrix-widget-api/lib/interfaces/WidgetApiAction.js");
			Object.keys(f).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === f[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return f[e]
					}
				}))
			}));
			var v = i("./node_modules/matrix-widget-api/lib/interfaces/WidgetApiDirection.js");
			Object.keys(v).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === v[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return v[e]
					}
				}))
			}));
			var y = i("./node_modules/matrix-widget-api/lib/interfaces/ApiVersion.js");
			Object.keys(y).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === y[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return y[e]
					}
				}))
			}));
			var b = i("./node_modules/matrix-widget-api/lib/interfaces/Capabilities.js");
			Object.keys(b).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === b[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return b[e]
					}
				}))
			}));
			var _ = i("./node_modules/matrix-widget-api/lib/interfaces/CapabilitiesAction.js");
			Object.keys(_).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === _[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return _[e]
					}
				}))
			}));
			var S = i("./node_modules/matrix-widget-api/lib/interfaces/ContentLoadedAction.js");
			Object.keys(S).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === S[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return S[e]
					}
				}))
			}));
			var E = i("./node_modules/matrix-widget-api/lib/interfaces/ScreenshotAction.js");
			Object.keys(E).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === E[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return E[e]
					}
				}))
			}));
			var w = i("./node_modules/matrix-widget-api/lib/interfaces/StickerAction.js");
			Object.keys(w).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === w[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return w[e]
					}
				}))
			}));
			var k = i("./node_modules/matrix-widget-api/lib/interfaces/StickyAction.js");
			Object.keys(k).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === k[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return k[e]
					}
				}))
			}));
			var T = i("./node_modules/matrix-widget-api/lib/interfaces/SupportedVersionsAction.js");
			Object.keys(T).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === T[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return T[e]
					}
				}))
			}));
			var I = i("./node_modules/matrix-widget-api/lib/interfaces/VisibilityAction.js");
			Object.keys(I).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === I[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return I[e]
					}
				}))
			}));
			var C = i("./node_modules/matrix-widget-api/lib/interfaces/GetOpenIDAction.js");
			Object.keys(C).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === C[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return C[e]
					}
				}))
			}));
			var R = i("./node_modules/matrix-widget-api/lib/interfaces/OpenIDCredentialsAction.js");
			Object.keys(R).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === R[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return R[e]
					}
				}))
			}));
			var j = i("./node_modules/matrix-widget-api/lib/interfaces/WidgetKind.js");
			Object.keys(j).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === j[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return j[e]
					}
				}))
			}));
			var O = i("./node_modules/matrix-widget-api/lib/interfaces/ModalButtonKind.js");
			Object.keys(O).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === O[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return O[e]
					}
				}))
			}));
			var x = i("./node_modules/matrix-widget-api/lib/interfaces/ModalWidgetActions.js");
			Object.keys(x).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === x[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return x[e]
					}
				}))
			}));
			var M = i("./node_modules/matrix-widget-api/lib/interfaces/SetModalButtonEnabledAction.js");
			Object.keys(M).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === M[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return M[e]
					}
				}))
			}));
			var P = i("./node_modules/matrix-widget-api/lib/interfaces/WidgetConfigAction.js");
			Object.keys(P).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === P[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return P[e]
					}
				}))
			}));
			var D = i("./node_modules/matrix-widget-api/lib/interfaces/SendEventAction.js");
			Object.keys(D).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === D[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return D[e]
					}
				}))
			}));
			var A = i("./node_modules/matrix-widget-api/lib/interfaces/SendToDeviceAction.js");
			Object.keys(A).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === A[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return A[e]
					}
				}))
			}));
			var L = i("./node_modules/matrix-widget-api/lib/interfaces/ReadEventAction.js");
			Object.keys(L).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === L[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return L[e]
					}
				}))
			}));
			var U = i("./node_modules/matrix-widget-api/lib/interfaces/IRoomEvent.js");
			Object.keys(U).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === U[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return U[e]
					}
				}))
			}));
			var N = i("./node_modules/matrix-widget-api/lib/interfaces/NavigateAction.js");
			Object.keys(N).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === N[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return N[e]
					}
				}))
			}));
			var F = i("./node_modules/matrix-widget-api/lib/interfaces/TurnServerActions.js");
			Object.keys(F).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === F[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return F[e]
					}
				}))
			}));
			var B = i("./node_modules/matrix-widget-api/lib/interfaces/ReadRelationsAction.js");
			Object.keys(B).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === B[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return B[e]
					}
				}))
			}));
			var K = i("./node_modules/matrix-widget-api/lib/models/WidgetEventCapability.js");
			Object.keys(K).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === K[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return K[e]
					}
				}))
			}));
			var q = i("./node_modules/matrix-widget-api/lib/models/validation/url.js");
			Object.keys(q).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === q[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return q[e]
					}
				}))
			}));
			var $ = i("./node_modules/matrix-widget-api/lib/models/validation/utils.js");
			Object.keys($).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === $[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return $[e]
					}
				}))
			}));
			var V = i("./node_modules/matrix-widget-api/lib/models/Widget.js");
			Object.keys(V).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === V[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return V[e]
					}
				}))
			}));
			var W = i("./node_modules/matrix-widget-api/lib/models/WidgetParser.js");
			Object.keys(W).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === W[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return W[e]
					}
				}))
			}));
			var G = i("./node_modules/matrix-widget-api/lib/templating/url-template.js");
			Object.keys(G).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === G[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return G[e]
					}
				}))
			}));
			var H = i("./node_modules/matrix-widget-api/lib/util/SimpleObservable.js");
			Object.keys(H).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === H[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return H[e]
					}
				}))
			}));
			var z = i("./node_modules/matrix-widget-api/lib/driver/WidgetDriver.js");
			Object.keys(z).forEach((function(e) {
				"default" !== e && "__esModule" !== e && (e in t && t[e] === z[e] || Object.defineProperty(t, e, {
					enumerable: !0,
					get: function() {
						return z[e]
					}
				}))
			}))
		},
		"./node_modules/matrix-widget-api/lib/interfaces/ApiVersion.js": function(e, t, i) {
			"use strict";
			var n, r;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.UnstableApiVersion = t.MatrixApiVersion = t.CurrentApiVersions = void 0, t.MatrixApiVersion = n,
				function(e) {
					e.Prerelease1 = "0.0.1", e.Prerelease2 = "0.0.2"
				}(n || (t.MatrixApiVersion = n = {})), t.UnstableApiVersion = r,
				function(e) {
					e.MSC2762 = "org.matrix.msc2762", e.MSC2871 = "org.matrix.msc2871", e.MSC2931 = "org.matrix.msc2931", e.MSC2974 = "org.matrix.msc2974", e.MSC2876 = "org.matrix.msc2876", e.MSC3819 = "org.matrix.msc3819", e.MSC3846 = "town.robin.msc3846", e.MSC3869 = "org.matrix.msc3869"
				}(r || (t.UnstableApiVersion = r = {}));
			var s = [n.Prerelease1, n.Prerelease2, r.MSC2762, r.MSC2871, r.MSC2931, r.MSC2974, r.MSC2876, r.MSC3819, r.MSC3846, r.MSC3869];
			t.CurrentApiVersions = s
		},
		"./node_modules/matrix-widget-api/lib/interfaces/Capabilities.js": function(e, t, i) {
			"use strict";
			var n;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.VideoConferenceCapabilities = t.StickerpickerCapabilities = t.MatrixCapabilities = void 0, t.getTimelineRoomIDFromCapability = function(e) {
					return e.substring(e.indexOf(":") + 1)
				}, t.isTimelineCapability = function(e) {
					return null == e ? void 0 : e.startsWith("org.matrix.msc2762.timeline:")
				}, t.isTimelineCapabilityFor = function(e, t) {
					return e === "org.matrix.msc2762.timeline:".concat(t)
				}, t.MatrixCapabilities = n,
				function(e) {
					e.Screenshots = "m.capability.screenshot", e.StickerSending = "m.sticker", e.AlwaysOnScreen = "m.always_on_screen", e.RequiresClient = "io.element.requires_client", e.MSC2931Navigate = "org.matrix.msc2931.navigate", e.MSC3846TurnServers = "town.robin.msc3846.turn_servers"
				}(n || (t.MatrixCapabilities = n = {}));
			var r = [n.StickerSending];
			t.StickerpickerCapabilities = r;
			var s = [n.AlwaysOnScreen];
			t.VideoConferenceCapabilities = s
		},
		"./node_modules/matrix-widget-api/lib/interfaces/CapabilitiesAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/ContentLoadedAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/GetOpenIDAction.js": function(e, t, i) {
			"use strict";
			var n;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.OpenIDRequestState = void 0, t.OpenIDRequestState = n,
				function(e) {
					e.Allowed = "allowed", e.Blocked = "blocked", e.PendingUserConfirmation = "request"
				}(n || (t.OpenIDRequestState = n = {}))
		},
		"./node_modules/matrix-widget-api/lib/interfaces/ICustomWidgetData.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/IJitsiWidgetData.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/IRoomEvent.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/IStickerpickerWidgetData.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/IWidget.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/IWidgetApiErrorResponse.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.isErrorResponse = function(e) {
				if ("error" in e) {
					return !!e.error.message
				}
				return !1
			}
		},
		"./node_modules/matrix-widget-api/lib/interfaces/IWidgetApiRequest.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/IWidgetApiResponse.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/ModalButtonKind.js": function(e, t, i) {
			"use strict";
			var n;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.ModalButtonKind = void 0, t.ModalButtonKind = n,
				function(e) {
					e.Primary = "m.primary", e.Secondary = "m.secondary", e.Warning = "m.warning", e.Danger = "m.danger", e.Link = "m.link"
				}(n || (t.ModalButtonKind = n = {}))
		},
		"./node_modules/matrix-widget-api/lib/interfaces/ModalWidgetActions.js": function(e, t, i) {
			"use strict";
			var n;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.BuiltInModalButtonID = void 0, t.BuiltInModalButtonID = n,
				function(e) {
					e.Close = "m.close"
				}(n || (t.BuiltInModalButtonID = n = {}))
		},
		"./node_modules/matrix-widget-api/lib/interfaces/NavigateAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/OpenIDCredentialsAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/ReadEventAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/ReadRelationsAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/ScreenshotAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/SendEventAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/SendToDeviceAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/SetModalButtonEnabledAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/StickerAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/StickyAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/SupportedVersionsAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/TurnServerActions.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/VisibilityAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/WidgetApiAction.js": function(e, t, i) {
			"use strict";
			var n, r;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.WidgetApiToWidgetAction = t.WidgetApiFromWidgetAction = void 0, t.WidgetApiToWidgetAction = n,
				function(e) {
					e.SupportedApiVersions = "supported_api_versions", e.Capabilities = "capabilities", e.NotifyCapabilities = "notify_capabilities", e.TakeScreenshot = "screenshot", e.UpdateVisibility = "visibility", e.OpenIDCredentials = "openid_credentials", e.WidgetConfig = "widget_config", e.CloseModalWidget = "close_modal", e.ButtonClicked = "button_clicked", e.SendEvent = "send_event", e.SendToDevice = "send_to_device", e.UpdateTurnServers = "update_turn_servers"
				}(n || (t.WidgetApiToWidgetAction = n = {})), t.WidgetApiFromWidgetAction = r,
				function(e) {
					e.SupportedApiVersions = "supported_api_versions", e.ContentLoaded = "content_loaded", e.SendSticker = "m.sticker", e.UpdateAlwaysOnScreen = "set_always_on_screen", e.GetOpenIDCredentials = "get_openid", e.CloseModalWidget = "close_modal", e.OpenModalWidget = "open_modal", e.SetModalButtonEnabled = "set_button_enabled", e.SendEvent = "send_event", e.SendToDevice = "send_to_device", e.WatchTurnServers = "watch_turn_servers", e.UnwatchTurnServers = "unwatch_turn_servers", e.MSC2876ReadEvents = "org.matrix.msc2876.read_events", e.MSC2931Navigate = "org.matrix.msc2931.navigate", e.MSC2974RenegotiateCapabilities = "org.matrix.msc2974.request_capabilities", e.MSC3869ReadRelations = "org.matrix.msc3869.read_relations"
				}(r || (t.WidgetApiFromWidgetAction = r = {}))
		},
		"./node_modules/matrix-widget-api/lib/interfaces/WidgetApiDirection.js": function(e, t, i) {
			"use strict";
			var n;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.WidgetApiDirection = void 0, t.invertedDirection = function(e) {
					if (e === n.ToWidget) return n.FromWidget;
					if (e === n.FromWidget) return n.ToWidget;
					throw new Error("Invalid direction")
				}, t.WidgetApiDirection = n,
				function(e) {
					e.ToWidget = "toWidget", e.FromWidget = "fromWidget"
				}(n || (t.WidgetApiDirection = n = {}))
		},
		"./node_modules/matrix-widget-api/lib/interfaces/WidgetConfigAction.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/interfaces/WidgetKind.js": function(e, t, i) {
			"use strict";
			var n;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.WidgetKind = void 0, t.WidgetKind = n,
				function(e) {
					e.Room = "room", e.Account = "account", e.Modal = "modal"
				}(n || (t.WidgetKind = n = {}))
		},
		"./node_modules/matrix-widget-api/lib/interfaces/WidgetType.js": function(e, t, i) {
			"use strict";
			var n;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.MatrixWidgetType = void 0, t.MatrixWidgetType = n,
				function(e) {
					e.Custom = "m.custom", e.JitsiMeet = "m.jitsi", e.Stickerpicker = "m.stickerpicker"
				}(n || (t.MatrixWidgetType = n = {}))
		},
		"./node_modules/matrix-widget-api/lib/models/Widget.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.Widget = void 0;
			var n = i("./node_modules/matrix-widget-api/lib/models/validation/utils.js"),
				r = i("./node_modules/matrix-widget-api/lib/index.js");

			function s(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}
			var o = function() {
				function e(t) {
					if (function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, e), this.definition = t, !this.definition) throw new Error("Definition is required");
					(0, n.assertPresent)(t, "id"), (0, n.assertPresent)(t, "creatorUserId"), (0, n.assertPresent)(t, "type"), (0, n.assertPresent)(t, "url")
				}
				var t, i, o;
				return t = e, (i = [{
					key: "creatorUserId",
					get: function() {
						return this.definition.creatorUserId
					}
				}, {
					key: "type",
					get: function() {
						return this.definition.type
					}
				}, {
					key: "id",
					get: function() {
						return this.definition.id
					}
				}, {
					key: "name",
					get: function() {
						return this.definition.name || null
					}
				}, {
					key: "title",
					get: function() {
						return this.rawData.title || null
					}
				}, {
					key: "templateUrl",
					get: function() {
						return this.definition.url
					}
				}, {
					key: "origin",
					get: function() {
						return new URL(this.templateUrl).origin
					}
				}, {
					key: "waitForIframeLoad",
					get: function() {
						return !1 !== this.definition.waitForIframeLoad && (this.definition.waitForIframeLoad, !0)
					}
				}, {
					key: "rawData",
					get: function() {
						return this.definition.data || {}
					}
				}, {
					key: "getCompleteUrl",
					value: function(e) {
						return (0, r.runTemplate)(this.templateUrl, this.definition, e)
					}
				}]) && s(t.prototype, i), o && s(t, o), Object.defineProperty(t, "prototype", {
					writable: !1
				}), e
			}();
			t.Widget = o
		},
		"./node_modules/matrix-widget-api/lib/models/WidgetEventCapability.js": function(e, t, i) {
			"use strict";

			function n(e, t) {
				var i = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
				if (!i) {
					if (Array.isArray(e) || (i = function(e, t) {
							if (!e) return;
							if ("string" == typeof e) return r(e, t);
							var i = Object.prototype.toString.call(e).slice(8, -1);
							"Object" === i && e.constructor && (i = e.constructor.name);
							if ("Map" === i || "Set" === i) return Array.from(e);
							if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return r(e, t)
						}(e)) || t && e && "number" == typeof e.length) {
						i && (e = i);
						var n = 0,
							s = function() {};
						return {
							s,
							n: function() {
								return n >= e.length ? {
									done: !0
								} : {
									done: !1,
									value: e[n++]
								}
							},
							e: function(e) {
								throw e
							},
							f: s
						}
					}
					throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
				}
				var o, a = !0,
					d = !1;
				return {
					s: function() {
						i = i.call(e)
					},
					n: function() {
						var e = i.next();
						return a = e.done, e
					},
					e: function(e) {
						d = !0, o = e
					},
					f: function() {
						try {
							a || null == i.return || i.return()
						} finally {
							if (d) throw o
						}
					}
				}
			}

			function r(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var i = 0, n = new Array(t); i < t; i++) n[i] = e[i];
				return n
			}

			function s(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}
			var o, a;
			Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.WidgetEventCapability = t.EventKind = t.EventDirection = void 0, t.EventKind = o,
				function(e) {
					e.Event = "event", e.State = "state_event", e.ToDevice = "to_device"
				}(o || (t.EventKind = o = {})), t.EventDirection = a,
				function(e) {
					e.Send = "send", e.Receive = "receive"
				}(a || (t.EventDirection = a = {}));
			var d = function() {
				function e(t, i, n, r, s) {
					! function(e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
					}(this, e), this.direction = t, this.eventType = i, this.kind = n, this.keyStr = r, this.raw = s
				}
				var t, i, r;
				return t = e, r = [{
					key: "forStateEvent",
					value: function(t, i, n) {
						i = i.replace(/#/g, "\\#"), n = null != n ? "#".concat(n) : "";
						var r = "org.matrix.msc2762.".concat(t, ".state_event:").concat(i).concat(n);
						return e.findEventCapabilities([r])[0]
					}
				}, {
					key: "forToDeviceEvent",
					value: function(t, i) {
						var n = "org.matrix.msc3819.".concat(t, ".to_device:").concat(i);
						return e.findEventCapabilities([n])[0]
					}
				}, {
					key: "forRoomEvent",
					value: function(t, i) {
						var n = "org.matrix.msc2762.".concat(t, ".event:").concat(i);
						return e.findEventCapabilities([n])[0]
					}
				}, {
					key: "forRoomMessageEvent",
					value: function(t, i) {
						i = null == i ? "" : i;
						var n = "org.matrix.msc2762.".concat(t, ".event:m.room.message#").concat(i);
						return e.findEventCapabilities([n])[0]
					}
				}, {
					key: "findEventCapabilities",
					value: function(t) {
						var i, r = [],
							s = n(t);
						try {
							for (s.s(); !(i = s.n()).done;) {
								var d = i.value,
									l = null,
									c = void 0,
									u = null;
								if (d.startsWith("org.matrix.msc2762.send.event:") ? (l = a.Send, u = o.Event, c = d.substring("org.matrix.msc2762.send.event:".length)) : d.startsWith("org.matrix.msc2762.send.state_event:") ? (l = a.Send, u = o.State, c = d.substring("org.matrix.msc2762.send.state_event:".length)) : d.startsWith("org.matrix.msc3819.send.to_device:") ? (l = a.Send, u = o.ToDevice, c = d.substring("org.matrix.msc3819.send.to_device:".length)) : d.startsWith("org.matrix.msc2762.receive.event:") ? (l = a.Receive, u = o.Event, c = d.substring("org.matrix.msc2762.receive.event:".length)) : d.startsWith("org.matrix.msc2762.receive.state_event:") ? (l = a.Receive, u = o.State, c = d.substring("org.matrix.msc2762.receive.state_event:".length)) : d.startsWith("org.matrix.msc3819.receive.to_device:") && (l = a.Receive, u = o.ToDevice, c = d.substring("org.matrix.msc3819.receive.to_device:".length)), null !== l && null !== u) {
									var h = c.startsWith("m.room.message#") || u === o.State,
										m = null;
									if (c.includes("#") && h) {
										var p = c.split("#"),
											g = p.findIndex((function(e) {
												return !e.endsWith("\\")
											}));
										c = p.slice(0, g + 1).map((function(e) {
											return e.endsWith("\\") ? e.substring(0, e.length - 1) : e
										})).join("#"), m = p.slice(g + 1).join("#")
									}
									r.push(new e(l, c, u, m, d))
								}
							}
						} catch (f) {
							s.e(f)
						} finally {
							s.f()
						}
						return r
					}
				}], (i = [{
					key: "matchesAsStateEvent",
					value: function(e, t, i) {
						return this.kind === o.State && this.direction === e && this.eventType === t && (null === this.keyStr || this.keyStr === i)
					}
				}, {
					key: "matchesAsToDeviceEvent",
					value: function(e, t) {
						return this.kind === o.ToDevice && this.direction === e && this.eventType === t
					}
				}, {
					key: "matchesAsRoomEvent",
					value: function(e, t) {
						var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
						return this.kind === o.Event && this.direction === e && this.eventType === t && ("m.room.message" !== this.eventType || null === this.keyStr || this.keyStr === i)
					}
				}]) && s(t.prototype, i), r && s(t, r), Object.defineProperty(t, "prototype", {
					writable: !1
				}), e
			}();
			t.WidgetEventCapability = d
		},
		"./node_modules/matrix-widget-api/lib/models/WidgetParser.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.WidgetParser = void 0;
			var n = i("./node_modules/matrix-widget-api/lib/models/Widget.js"),
				r = i("./node_modules/matrix-widget-api/lib/models/validation/url.js");

			function s(e, t) {
				var i = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
				if (!i) {
					if (Array.isArray(e) || (i = function(e, t) {
							if (!e) return;
							if ("string" == typeof e) return o(e, t);
							var i = Object.prototype.toString.call(e).slice(8, -1);
							"Object" === i && e.constructor && (i = e.constructor.name);
							if ("Map" === i || "Set" === i) return Array.from(e);
							if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return o(e, t)
						}(e)) || t && e && "number" == typeof e.length) {
						i && (e = i);
						var n = 0,
							r = function() {};
						return {
							s: r,
							n: function() {
								return n >= e.length ? {
									done: !0
								} : {
									done: !1,
									value: e[n++]
								}
							},
							e: function(e) {
								throw e
							},
							f: r
						}
					}
					throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
				}
				var s, a = !0,
					d = !1;
				return {
					s: function() {
						i = i.call(e)
					},
					n: function() {
						var e = i.next();
						return a = e.done, e
					},
					e: function(e) {
						d = !0, s = e
					},
					f: function() {
						try {
							a || null == i.return || i.return()
						} finally {
							if (d) throw s
						}
					}
				}
			}

			function o(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var i = 0, n = new Array(t); i < t; i++) n[i] = e[i];
				return n
			}

			function a(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}
			var d = function() {
				function e() {
					! function(e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
					}(this, e)
				}
				var t, i, o;
				return t = e, o = [{
					key: "parseAccountData",
					value: function(t) {
						if (!t) return [];
						for (var i = [], n = 0, r = Object.keys(t); n < r.length; n++) {
							var s = r[n],
								o = t[s];
							if (o && ("m.widget" === o.type || "im.vector.modular.widgets" === o.type) && o.sender && (o.state_key || o.id) === s) {
								var a = {
										content: o.content,
										sender: o.sender,
										type: "m.widget",
										state_key: s,
										event_id: "$example",
										room_id: "!example",
										origin_server_ts: 1
									},
									d = e.parseRoomWidget(a);
								d && i.push(d)
							}
						}
						return i
					}
				}, {
					key: "parseWidgetsFromRoomState",
					value: function(t) {
						if (!t) return [];
						var i, n = [],
							r = s(t);
						try {
							for (r.s(); !(i = r.n()).done;) {
								var o = i.value,
									a = e.parseRoomWidget(o);
								a && n.push(a)
							}
						} catch (d) {
							r.e(d)
						} finally {
							r.f()
						}
						return n
					}
				}, {
					key: "parseRoomWidget",
					value: function(t) {
						if (!t) return null;
						if ("m.widget" !== t.type && "im.vector.modular.widgets" !== t.type) return null;
						var i = t.content || {},
							n = {
								id: t.state_key,
								creatorUserId: i.creatorUserId || t.sender,
								name: i.name,
								type: i.type,
								url: i.url,
								waitForIframeLoad: i.waitForIframeLoad,
								data: i.data
							};
						return e.processEstimatedWidget(n)
					}
				}, {
					key: "processEstimatedWidget",
					value: function(e) {
						return e.id && e.creatorUserId && e.type && (0, r.isValidUrl)(e.url) ? new n.Widget(e) : null
					}
				}], (i = null) && a(t.prototype, i), o && a(t, o), Object.defineProperty(t, "prototype", {
					writable: !1
				}), e
			}();
			t.WidgetParser = d
		},
		"./node_modules/matrix-widget-api/lib/models/validation/url.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.isValidUrl = function(e) {
				if (!e) return !1;
				try {
					var t = new URL(e);
					return "http" === t.protocol || "https" === t.protocol
				} catch (i) {
					if (i instanceof TypeError) return !1;
					throw i
				}
			}
		},
		"./node_modules/matrix-widget-api/lib/models/validation/utils.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.assertPresent = function(e, t) {
				if (!e[t]) throw new Error("".concat(t, " is required"))
			}
		},
		"./node_modules/matrix-widget-api/lib/templating/url-template.js": function(e, t, i) {
			"use strict";

			function n(e) {
				return null == e ? "".concat(e) : e.toString()
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.runTemplate = function(e, t, i) {
				for (var r = Object.assign({}, t.data, {
						matrix_room_id: i.widgetRoomId || "",
						matrix_user_id: i.currentUserId,
						matrix_display_name: i.userDisplayName || i.currentUserId,
						matrix_avatar_url: i.userHttpAvatarUrl || "",
						matrix_widget_id: t.id,
						"org.matrix.msc2873.client_id": i.clientId || "",
						"org.matrix.msc2873.client_theme": i.clientTheme || "",
						"org.matrix.msc2873.client_language": i.clientLanguage || ""
					}), s = e, o = 0, a = Object.keys(r); o < a.length; o++) {
					var d = a[o],
						l = "$".concat(d).replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),
						c = new RegExp(l, "g");
					s = s.replace(c, encodeURIComponent(n(r[d])))
				}
				return s
			}, t.toString = n
		},
		"./node_modules/matrix-widget-api/lib/transport/ITransport.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
		},
		"./node_modules/matrix-widget-api/lib/transport/PostmessageTransport.js": function(e, t, i) {
			"use strict";

			function n(e) {
				return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				})(e)
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.PostmessageTransport = void 0;
			var r = i("./node_modules/node-libs-browser/node_modules/events/events.js"),
				s = i("./node_modules/matrix-widget-api/lib/index.js");

			function o(e, t) {
				var i = Object.keys(e);
				if (Object.getOwnPropertySymbols) {
					var n = Object.getOwnPropertySymbols(e);
					t && (n = n.filter((function(t) {
						return Object.getOwnPropertyDescriptor(e, t).enumerable
					}))), i.push.apply(i, n)
				}
				return i
			}

			function a(e) {
				for (var t = 1; t < arguments.length; t++) {
					var i = null != arguments[t] ? arguments[t] : {};
					t % 2 ? o(Object(i), !0).forEach((function(t) {
						p(e, t, i[t])
					})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : o(Object(i)).forEach((function(t) {
						Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
					}))
				}
				return e
			}

			function d(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}

			function l(e, t) {
				return (l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
					return e.__proto__ = t, e
				})(e, t)
			}

			function c(e) {
				var t = function() {
					if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
					if (Reflect.construct.sham) return !1;
					if ("function" == typeof Proxy) return !0;
					try {
						return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
					} catch (e) {
						return !1
					}
				}();
				return function() {
					var i, n = m(e);
					if (t) {
						var r = m(this).constructor;
						i = Reflect.construct(n, arguments, r)
					} else i = n.apply(this, arguments);
					return u(this, i)
				}
			}

			function u(e, t) {
				if (t && ("object" === n(t) || "function" == typeof t)) return t;
				if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
				return h(e)
			}

			function h(e) {
				if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				return e
			}

			function m(e) {
				return (m = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
					return e.__proto__ || Object.getPrototypeOf(e)
				})(e)
			}

			function p(e, t, i) {
				return t in e ? Object.defineProperty(e, t, {
					value: i,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = i, e
			}
			var g = function(e) {
				! function(e, t) {
					if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
					e.prototype = Object.create(t && t.prototype, {
						constructor: {
							value: e,
							writable: !0,
							configurable: !0
						}
					}), Object.defineProperty(e, "prototype", {
						writable: !1
					}), t && l(e, t)
				}(o, e);
				var t, i, n, r = c(o);

				function o(e, t, i, n) {
					var s;
					return function(e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
					}(this, o), (s = r.call(this)).sendDirection = e, s.initialWidgetId = t, s.transportWindow = i, s.inboundWindow = n, p(h(s), "strictOriginCheck", void 0), p(h(s), "targetOrigin", void 0), p(h(s), "timeoutSeconds", 10), p(h(s), "_ready", !1), p(h(s), "_widgetId", null), p(h(s), "outboundRequests", new Map), p(h(s), "stopController", new AbortController), s._widgetId = t, s
				}
				return t = o, (i = [{
					key: "ready",
					get: function() {
						return this._ready
					}
				}, {
					key: "widgetId",
					get: function() {
						return this._widgetId || null
					}
				}, {
					key: "nextRequestId",
					get: function() {
						for (var e = "widgetapi-".concat(Date.now()), t = 0, i = e; this.outboundRequests.has(i);) i = "".concat(e, "-").concat(t++);
						return this.outboundRequests.set(i, null), i
					}
				}, {
					key: "sendInternal",
					value: function(e) {
						var t = this.targetOrigin || "*";
						console.log("[PostmessageTransport] Sending object to ".concat(t, ": "), e), this.transportWindow.postMessage(e, t)
					}
				}, {
					key: "reply",
					value: function(e, t) {
						return this.sendInternal(a(a({}, e), {}, {
							response: t
						}))
					}
				}, {
					key: "send",
					value: function(e, t) {
						return this.sendComplete(e, t).then((function(e) {
							return e.response
						}))
					}
				}, {
					key: "sendComplete",
					value: function(e, t) {
						var i = this;
						if (!this.ready || !this.widgetId) return Promise.reject(new Error("Not ready or unknown widget ID"));
						var n = {
							api: this.sendDirection,
							widgetId: this.widgetId,
							requestId: this.nextRequestId,
							action: e,
							data: t
						};
						return e === s.WidgetApiToWidgetAction.UpdateVisibility && (n.visible = t.visible), new Promise((function(e, t) {
							var r = function(e) {
									a(), t(e)
								},
								s = setTimeout((function() {
									return r(new Error("Request timed out"))
								}), 1e3 * (i.timeoutSeconds || 1)),
								o = function() {
									return r(new Error("Transport stopped"))
								};
							i.stopController.signal.addEventListener("abort", o);
							var a = function() {
								i.outboundRequests.delete(n.requestId), clearTimeout(s), i.stopController.signal.removeEventListener("abort", o)
							};
							i.outboundRequests.set(n.requestId, {
								request: n,
								resolve: function(t) {
									a(), e(t)
								},
								reject: r
							}), i.sendInternal(n)
						}))
					}
				}, {
					key: "start",
					value: function() {
						var e = this;
						this.inboundWindow.addEventListener("message", (function(t) {
							e.handleMessage(t)
						})), this._ready = !0
					}
				}, {
					key: "stop",
					value: function() {
						this._ready = !1, this.stopController.abort()
					}
				}, {
					key: "handleMessage",
					value: function(e) {
						if (!this.stopController.signal.aborted && e.data && (!this.strictOriginCheck || e.origin === window.origin)) {
							var t = e.data;
							if (t.action && t.requestId && t.widgetId)
								if (t.response) {
									if (t.api !== this.sendDirection) return;
									this.handleResponse(t)
								} else {
									var i = t;
									if (i.api !== (0, s.invertedDirection)(this.sendDirection)) return;
									this.handleRequest(i)
								}
						}
					}
				}, {
					key: "handleRequest",
					value: function(e) {
						if (this.widgetId) {
							if (this.widgetId !== e.widgetId) return
						} else this._widgetId = e.widgetId;
						this.emit("message", new CustomEvent("message", {
							detail: e
						}))
					}
				}, {
					key: "handleResponse",
					value: function(e) {
						if (e.widgetId === this.widgetId) {
							var t = this.outboundRequests.get(e.requestId);
							if (t)
								if ((0, s.isErrorResponse)(e.response)) {
									var i = e.response;
									t.reject(new Error(i.error.message))
								} else t.resolve(e)
						}
					}
				}]) && d(t.prototype, i), n && d(t, n), Object.defineProperty(t, "prototype", {
					writable: !1
				}), o
			}(r.EventEmitter);
			t.PostmessageTransport = g
		},
		"./node_modules/matrix-widget-api/lib/util/SimpleObservable.js": function(e, t, i) {
			"use strict";

			function n(e, t) {
				var i = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
				if (!i) {
					if (Array.isArray(e) || (i = function(e, t) {
							if (!e) return;
							if ("string" == typeof e) return r(e, t);
							var i = Object.prototype.toString.call(e).slice(8, -1);
							"Object" === i && e.constructor && (i = e.constructor.name);
							if ("Map" === i || "Set" === i) return Array.from(e);
							if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return r(e, t)
						}(e)) || t && e && "number" == typeof e.length) {
						i && (e = i);
						var n = 0,
							s = function() {};
						return {
							s,
							n: function() {
								return n >= e.length ? {
									done: !0
								} : {
									done: !1,
									value: e[n++]
								}
							},
							e: function(e) {
								throw e
							},
							f: s
						}
					}
					throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
				}
				var o, a = !0,
					d = !1;
				return {
					s: function() {
						i = i.call(e)
					},
					n: function() {
						var e = i.next();
						return a = e.done, e
					},
					e: function(e) {
						d = !0, o = e
					},
					f: function() {
						try {
							a || null == i.return || i.return()
						} finally {
							if (d) throw o
						}
					}
				}
			}

			function r(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var i = 0, n = new Array(t); i < t; i++) n[i] = e[i];
				return n
			}

			function s(e, t) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
				}
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.SimpleObservable = void 0;
			var o = function() {
				function e(t) {
					var i, n, r;
					! function(e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
					}(this, e), r = [], (n = "listeners") in (i = this) ? Object.defineProperty(i, n, {
						value: r,
						enumerable: !0,
						configurable: !0,
						writable: !0
					}) : i[n] = r, t && this.listeners.push(t)
				}
				var t, i, r;
				return t = e, (i = [{
					key: "onUpdate",
					value: function(e) {
						this.listeners.push(e)
					}
				}, {
					key: "update",
					value: function(e) {
						var t, i = n(this.listeners);
						try {
							for (i.s(); !(t = i.n()).done;)(0, t.value)(e)
						} catch (r) {
							i.e(r)
						} finally {
							i.f()
						}
					}
				}, {
					key: "close",
					value: function() {
						this.listeners = []
					}
				}]) && s(t.prototype, i), r && s(t, r), Object.defineProperty(t, "prototype", {
					writable: !1
				}), e
			}();
			t.SimpleObservable = o
		},
		"./node_modules/p-retry/index.js": function(e, t, i) {
			"use strict";
			const n = i("./node_modules/p-retry/node_modules/retry/index.js"),
				r = ["Failed to fetch", "NetworkError when attempting to fetch resource.", "The Internet connection appears to be offline.", "Network request failed"];
			class AbortError extends Error {
				constructor(e) {
					super(), e instanceof Error ? (this.originalError = e, ({
						message: e
					} = e)) : (this.originalError = new Error(e), this.originalError.stack = this.stack), this.name = "AbortError", this.message = e
				}
			}
			const s = (e, t) => new Promise((i, s) => {
				t = {
					onFailedAttempt: () => {},
					retries: 10,
					...t
				};
				const o = n.operation(t);
				o.attempt(async n => {
					try {
						i(await e(n))
					} catch (a) {
						if (!(a instanceof Error)) return void s(new TypeError(`Non-error was thrown: "${a}". You should only throw errors.`));
						if (a instanceof AbortError) o.stop(), s(a.originalError);
						else if (a instanceof TypeError && !(e => r.includes(e))(a.message)) o.stop(), s(a);
						else {
							((e, t, i) => {
								const n = i.retries - (t - 1);
								e.attemptNumber = t, e.retriesLeft = n
							})(a, n, t);
							try {
								await t.onFailedAttempt(a)
							} catch (a) {
								return void s(a)
							}
							o.retry(a) || s(o.mainError())
						}
					}
				})
			});
			e.exports = s, e.exports.default = s, e.exports.AbortError = AbortError
		},
		"./node_modules/p-retry/node_modules/retry/index.js": function(e, t, i) {
			e.exports = i("./node_modules/p-retry/node_modules/retry/lib/retry.js")
		},
		"./node_modules/p-retry/node_modules/retry/lib/retry.js": function(e, t, i) {
			var n = i("./node_modules/p-retry/node_modules/retry/lib/retry_operation.js");
			t.operation = function(e) {
				var i = t.timeouts(e);
				return new n(i, {
					forever: e && (e.forever || e.retries === 1 / 0),
					unref: e && e.unref,
					maxRetryTime: e && e.maxRetryTime
				})
			}, t.timeouts = function(e) {
				if (e instanceof Array) return [].concat(e);
				var t = {
					retries: 10,
					factor: 2,
					minTimeout: 1e3,
					maxTimeout: 1 / 0,
					randomize: !1
				};
				for (var i in e) t[i] = e[i];
				if (t.minTimeout > t.maxTimeout) throw new Error("minTimeout is greater than maxTimeout");
				for (var n = [], r = 0; r < t.retries; r++) n.push(this.createTimeout(r, t));
				return e && e.forever && !n.length && n.push(this.createTimeout(r, t)), n.sort((function(e, t) {
					return e - t
				})), n
			}, t.createTimeout = function(e, t) {
				var i = t.randomize ? Math.random() + 1 : 1,
					n = Math.round(i * Math.max(t.minTimeout, 1) * Math.pow(t.factor, e));
				return n = Math.min(n, t.maxTimeout)
			}, t.wrap = function(e, i, n) {
				if (i instanceof Array && (n = i, i = null), !n)
					for (var r in n = [], e) "function" == typeof e[r] && n.push(r);
				for (var s = 0; s < n.length; s++) {
					var o = n[s],
						a = e[o];
					e[o] = function(n) {
						var r = t.operation(i),
							s = Array.prototype.slice.call(arguments, 1),
							o = s.pop();
						s.push((function(e) {
							r.retry(e) || (e && (arguments[0] = r.mainError()), o.apply(this, arguments))
						})), r.attempt((function() {
							n.apply(e, s)
						}))
					}.bind(e, a), e[o].options = i
				}
			}
		},
		"./node_modules/p-retry/node_modules/retry/lib/retry_operation.js": function(e, t) {
			function i(e, t) {
				"boolean" == typeof t && (t = {
					forever: t
				}), this._originalTimeouts = JSON.parse(JSON.stringify(e)), this._timeouts = e, this._options = t || {}, this._maxRetryTime = t && t.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0))
			}
			e.exports = i, i.prototype.reset = function() {
				this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0)
			}, i.prototype.stop = function() {
				this._timeout && clearTimeout(this._timeout), this._timer && clearTimeout(this._timer), this._timeouts = [], this._cachedTimeouts = null
			}, i.prototype.retry = function(e) {
				if (this._timeout && clearTimeout(this._timeout), !e) return !1;
				var t = (new Date).getTime();
				if (e && t - this._operationStart >= this._maxRetryTime) return this._errors.push(e), this._errors.unshift(new Error("RetryOperation timeout occurred")), !1;
				this._errors.push(e);
				var i = this._timeouts.shift();
				if (void 0 === i) {
					if (!this._cachedTimeouts) return !1;
					this._errors.splice(0, this._errors.length - 1), i = this._cachedTimeouts.slice(-1)
				}
				var n = this;
				return this._timer = setTimeout((function() {
					n._attempts++, n._operationTimeoutCb && (n._timeout = setTimeout((function() {
						n._operationTimeoutCb(n._attempts)
					}), n._operationTimeout), n._options.unref && n._timeout.unref()), n._fn(n._attempts)
				}), i), this._options.unref && this._timer.unref(), !0
			}, i.prototype.attempt = function(e, t) {
				this._fn = e, t && (t.timeout && (this._operationTimeout = t.timeout), t.cb && (this._operationTimeoutCb = t.cb));
				var i = this;
				this._operationTimeoutCb && (this._timeout = setTimeout((function() {
					i._operationTimeoutCb()
				}), i._operationTimeout)), this._operationStart = (new Date).getTime(), this._fn(this._attempts)
			}, i.prototype.try = function(e) {
				console.log("Using RetryOperation.try() is deprecated"), this.attempt(e)
			}, i.prototype.start = function(e) {
				console.log("Using RetryOperation.start() is deprecated"), this.attempt(e)
			}, i.prototype.start = i.prototype.try, i.prototype.errors = function() {
				return this._errors
			}, i.prototype.attempts = function() {
				return this._attempts
			}, i.prototype.mainError = function() {
				if (0 === this._errors.length) return null;
				for (var e = {}, t = null, i = 0, n = 0; n < this._errors.length; n++) {
					var r = this._errors[n],
						s = r.message,
						o = (e[s] || 0) + 1;
					e[s] = o, o >= i && (t = r, i = o)
				}
				return t
			}
		},
		"./node_modules/react-autosize-textarea/lib/TextareaAutosize.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.default = void 0;
			var n, r, s = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var i = arguments[t];
						for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
					}
					return e
				},
				o = function() {
					function e(e, t) {
						for (var i = 0; i < t.length; i++) {
							var n = t[i];
							n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
						}
					}
					return function(t, i, n) {
						return i && e(t.prototype, i), n && e(t, n), t
					}
				}(),
				a = u(i("./node_modules/react/index.js")),
				d = u(i("./node_modules/react-autosize-textarea/node_modules/prop-types/index.js")),
				l = u(i("./node_modules/autosize/dist/autosize.js")),
				c = u(i("./node_modules/line-height/lib/line-height.js"));

			function u(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}

			function h(e, t) {
				var i = {};
				for (var n in e) t.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(e, n) && (i[n] = e[n]);
				return i
			}

			function m(e, t) {
				if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				return !t || "object" != typeof t && "function" != typeof t ? e : t
			}
			var p = (r = n = function(e) {
				function t() {
					var e, i, n;
					! function(e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
					}(this, t);
					for (var r = arguments.length, o = Array(r), a = 0; a < r; a++) o[a] = arguments[a];
					return i = n = m(this, (e = t.__proto__ || Object.getPrototypeOf(t)).call.apply(e, [this].concat(o))), n.state = {
						lineHeight: null
					}, n.dispatchEvent = function(e) {
						var t = document.createEvent("Event");
						t.initEvent(e, !0, !1), n.textarea.dispatchEvent(t)
					}, n.getValue = function(e) {
						var t = e.valueLink,
							i = e.value;
						return t ? t.value : i
					}, n.updateLineHeight = function() {
						n.setState({
							lineHeight: (0, c.default)(n.textarea)
						})
					}, n.onChange = function(e) {
						n.currentValue = e.target.value, n.props.onChange && n.props.onChange(e)
					}, n.saveDOMNodeRef = function(e) {
						var t = n.props.innerRef;
						t && t(e), n.textarea = e
					}, n.getLocals = function() {
						var e = n,
							t = e.props,
							i = (t.onResize, t.maxRows),
							r = (t.onChange, t.style),
							o = (t.innerRef, h(t, ["onResize", "maxRows", "onChange", "style", "innerRef"])),
							a = e.state.lineHeight,
							d = e.saveDOMNodeRef,
							l = i && a ? a * i : null;
						return s({}, o, {
							saveDOMNodeRef: d,
							style: l ? s({}, r, {
								maxHeight: l
							}) : r,
							onChange: n.onChange
						})
					}, m(n, i)
				}
				return function(e, t) {
					if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
					e.prototype = Object.create(t && t.prototype, {
						constructor: {
							value: e,
							enumerable: !1,
							writable: !0,
							configurable: !0
						}
					}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
				}(t, e), o(t, [{
					key: "componentDidMount",
					value: function() {
						var e = this,
							t = this.props,
							i = t.onResize;
						"number" == typeof t.maxRows ? (this.updateLineHeight(), setTimeout((function() {
							return (0, l.default)(e.textarea)
						}))) : (0, l.default)(this.textarea), i && this.textarea.addEventListener("autosize:resized", this.props.onResize)
					}
				}, {
					key: "componentWillUnmount",
					value: function() {
						this.props.onResize && this.textarea.removeEventListener("autosize:resized", this.props.onResize), this.dispatchEvent("autosize:destroy")
					}
				}, {
					key: "render",
					value: function() {
						var e = this.getLocals(),
							t = e.children,
							i = e.saveDOMNodeRef,
							n = h(e, ["children", "saveDOMNodeRef"]);
						return a.default.createElement("textarea", s({}, n, {
							ref: i
						}), t)
					}
				}, {
					key: "componentDidUpdate",
					value: function() {
						this.getValue(this.props) !== this.currentValue && this.dispatchEvent("autosize:update")
					}
				}]), t
			}(a.default.Component), n.defaultProps = {
				rows: 1
			}, r);
			t.default = p, p.propTypes = {
				rows: d.default.number,
				maxRows: d.default.number,
				onResize: d.default.func,
				innerRef: d.default.func
			}
		},
		"./node_modules/react-autosize-textarea/lib/index.js": function(e, t, i) {
			"use strict";
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.default = void 0;
			var n, r = i("./node_modules/react-autosize-textarea/lib/TextareaAutosize.js"),
				s = (n = r) && n.__esModule ? n : {
					default: n
				};
			t.default = s.default
		},
		"./node_modules/react-autosize-textarea/node_modules/prop-types/factoryWithThrowingShims.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/react-autosize-textarea/node_modules/prop-types/lib/ReactPropTypesSecret.js");

			function r() {}

			function s() {}
			s.resetWarningCache = r, e.exports = function() {
				function e(e, t, i, r, s, o) {
					if (o !== n) {
						var a = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
						throw a.name = "Invariant Violation", a
					}
				}

				function t() {
					return e
				}
				e.isRequired = e;
				var i = {
					array: e,
					bool: e,
					func: e,
					number: e,
					object: e,
					string: e,
					symbol: e,
					any: e,
					arrayOf: t,
					element: e,
					elementType: e,
					instanceOf: t,
					node: e,
					objectOf: t,
					oneOf: t,
					oneOfType: t,
					shape: t,
					exact: t,
					checkPropTypes: s,
					resetWarningCache: r
				};
				return i.PropTypes = i, i
			}
		},
		"./node_modules/react-autosize-textarea/node_modules/prop-types/index.js": function(e, t, i) {
			e.exports = i("./node_modules/react-autosize-textarea/node_modules/prop-types/factoryWithThrowingShims.js")()
		},
		"./node_modules/react-autosize-textarea/node_modules/prop-types/lib/ReactPropTypesSecret.js": function(e, t, i) {
			"use strict";
			e.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
		},
		"./node_modules/sdp-transform/lib/grammar.js": function(e, t) {
			var i = e.exports = {
				v: [{
					name: "version",
					reg: /^(\d*)$/
				}],
				o: [{
					name: "origin",
					reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
					names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
					format: "%s %s %d %s IP%d %s"
				}],
				s: [{
					name: "name"
				}],
				i: [{
					name: "description"
				}],
				u: [{
					name: "uri"
				}],
				e: [{
					name: "email"
				}],
				p: [{
					name: "phone"
				}],
				z: [{
					name: "timezones"
				}],
				r: [{
					name: "repeats"
				}],
				t: [{
					name: "timing",
					reg: /^(\d*) (\d*)/,
					names: ["start", "stop"],
					format: "%d %d"
				}],
				c: [{
					name: "connection",
					reg: /^IN IP(\d) (\S*)/,
					names: ["version", "ip"],
					format: "IN IP%d %s"
				}],
				b: [{
					push: "bandwidth",
					reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
					names: ["type", "limit"],
					format: "%s:%s"
				}],
				m: [{
					reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
					names: ["type", "port", "protocol", "payloads"],
					format: "%s %d %s %s"
				}],
				a: [{
					push: "rtp",
					reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
					names: ["payload", "codec", "rate", "encoding"],
					format: function(e) {
						return e.encoding ? "rtpmap:%d %s/%s/%s" : e.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s"
					}
				}, {
					push: "fmtp",
					reg: /^fmtp:(\d*) ([\S| ]*)/,
					names: ["payload", "config"],
					format: "fmtp:%d %s"
				}, {
					name: "control",
					reg: /^control:(.*)/,
					format: "control:%s"
				}, {
					name: "rtcp",
					reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
					names: ["port", "netType", "ipVer", "address"],
					format: function(e) {
						return null != e.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d"
					}
				}, {
					push: "rtcpFbTrrInt",
					reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
					names: ["payload", "value"],
					format: "rtcp-fb:%s trr-int %d"
				}, {
					push: "rtcpFb",
					reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
					names: ["payload", "type", "subtype"],
					format: function(e) {
						return null != e.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s"
					}
				}, {
					push: "ext",
					reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
					names: ["value", "direction", "encrypt-uri", "uri", "config"],
					format: function(e) {
						return "extmap:%d" + (e.direction ? "/%s" : "%v") + (e["encrypt-uri"] ? " %s" : "%v") + " %s" + (e.config ? " %s" : "")
					}
				}, {
					name: "extmapAllowMixed",
					reg: /^(extmap-allow-mixed)/
				}, {
					push: "crypto",
					reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
					names: ["id", "suite", "config", "sessionConfig"],
					format: function(e) {
						return null != e.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s"
					}
				}, {
					name: "setup",
					reg: /^setup:(\w*)/,
					format: "setup:%s"
				}, {
					name: "connectionType",
					reg: /^connection:(new|existing)/,
					format: "connection:%s"
				}, {
					name: "mid",
					reg: /^mid:([^\s]*)/,
					format: "mid:%s"
				}, {
					name: "msid",
					reg: /^msid:(.*)/,
					format: "msid:%s"
				}, {
					name: "ptime",
					reg: /^ptime:(\d*(?:\.\d*)*)/,
					format: "ptime:%d"
				}, {
					name: "maxptime",
					reg: /^maxptime:(\d*(?:\.\d*)*)/,
					format: "maxptime:%d"
				}, {
					name: "direction",
					reg: /^(sendrecv|recvonly|sendonly|inactive)/
				}, {
					name: "icelite",
					reg: /^(ice-lite)/
				}, {
					name: "iceUfrag",
					reg: /^ice-ufrag:(\S*)/,
					format: "ice-ufrag:%s"
				}, {
					name: "icePwd",
					reg: /^ice-pwd:(\S*)/,
					format: "ice-pwd:%s"
				}, {
					name: "fingerprint",
					reg: /^fingerprint:(\S*) (\S*)/,
					names: ["type", "hash"],
					format: "fingerprint:%s %s"
				}, {
					push: "candidates",
					reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
					names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
					format: function(e) {
						var t = "candidate:%s %d %s %d %s %d typ %s";
						return t += null != e.raddr ? " raddr %s rport %d" : "%v%v", t += null != e.tcptype ? " tcptype %s" : "%v", null != e.generation && (t += " generation %d"), t += null != e["network-id"] ? " network-id %d" : "%v", t += null != e["network-cost"] ? " network-cost %d" : "%v"
					}
				}, {
					name: "endOfCandidates",
					reg: /^(end-of-candidates)/
				}, {
					name: "remoteCandidates",
					reg: /^remote-candidates:(.*)/,
					format: "remote-candidates:%s"
				}, {
					name: "iceOptions",
					reg: /^ice-options:(\S*)/,
					format: "ice-options:%s"
				}, {
					push: "ssrcs",
					reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
					names: ["id", "attribute", "value"],
					format: function(e) {
						var t = "ssrc:%d";
						return null != e.attribute && (t += " %s", null != e.value && (t += ":%s")), t
					}
				}, {
					push: "ssrcGroups",
					reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
					names: ["semantics", "ssrcs"],
					format: "ssrc-group:%s %s"
				}, {
					name: "msidSemantic",
					reg: /^msid-semantic:\s?(\w*) (\S*)/,
					names: ["semantic", "token"],
					format: "msid-semantic: %s %s"
				}, {
					push: "groups",
					reg: /^group:(\w*) (.*)/,
					names: ["type", "mids"],
					format: "group:%s %s"
				}, {
					name: "rtcpMux",
					reg: /^(rtcp-mux)/
				}, {
					name: "rtcpRsize",
					reg: /^(rtcp-rsize)/
				}, {
					name: "sctpmap",
					reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
					names: ["sctpmapNumber", "app", "maxMessageSize"],
					format: function(e) {
						return null != e.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s"
					}
				}, {
					name: "xGoogleFlag",
					reg: /^x-google-flag:([^\s]*)/,
					format: "x-google-flag:%s"
				}, {
					push: "rids",
					reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
					names: ["id", "direction", "params"],
					format: function(e) {
						return e.params ? "rid:%s %s %s" : "rid:%s %s"
					}
				}, {
					push: "imageattrs",
					reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
					names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
					format: function(e) {
						return "imageattr:%s %s %s" + (e.dir2 ? " %s %s" : "")
					}
				}, {
					name: "simulcast",
					reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
					names: ["dir1", "list1", "dir2", "list2"],
					format: function(e) {
						return "simulcast:%s %s" + (e.dir2 ? " %s %s" : "")
					}
				}, {
					name: "simulcast_03",
					reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
					names: ["value"],
					format: "simulcast: %s"
				}, {
					name: "framerate",
					reg: /^framerate:(\d+(?:$|\.\d+))/,
					format: "framerate:%s"
				}, {
					name: "sourceFilter",
					reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
					names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
					format: "source-filter: %s %s %s %s %s"
				}, {
					name: "bundleOnly",
					reg: /^(bundle-only)/
				}, {
					name: "label",
					reg: /^label:(.+)/,
					format: "label:%s"
				}, {
					name: "sctpPort",
					reg: /^sctp-port:(\d+)$/,
					format: "sctp-port:%s"
				}, {
					name: "maxMessageSize",
					reg: /^max-message-size:(\d+)$/,
					format: "max-message-size:%s"
				}, {
					push: "tsRefClocks",
					reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
					names: ["clksrc", "clksrcExt"],
					format: function(e) {
						return "ts-refclk:%s" + (null != e.clksrcExt ? "=%s" : "")
					}
				}, {
					name: "mediaClk",
					reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
					names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
					format: function(e) {
						var t = "mediaclk:";
						return t += null != e.id ? "id=%s %s" : "%v%s", t += null != e.mediaClockValue ? "=%s" : "", t += null != e.rateNumerator ? " rate=%s" : "", t += null != e.rateDenominator ? "/%s" : ""
					}
				}, {
					name: "keywords",
					reg: /^keywds:(.+)$/,
					format: "keywds:%s"
				}, {
					name: "content",
					reg: /^content:(.+)/,
					format: "content:%s"
				}, {
					name: "bfcpFloorCtrl",
					reg: /^floorctrl:(c-only|s-only|c-s)/,
					format: "floorctrl:%s"
				}, {
					name: "bfcpConfId",
					reg: /^confid:(\d+)/,
					format: "confid:%s"
				}, {
					name: "bfcpUserId",
					reg: /^userid:(\d+)/,
					format: "userid:%s"
				}, {
					name: "bfcpFloorId",
					reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
					names: ["id", "mStream"],
					format: "floorid:%s mstrm:%s"
				}, {
					push: "invalid",
					names: ["value"]
				}]
			};
			Object.keys(i).forEach((function(e) {
				i[e].forEach((function(e) {
					e.reg || (e.reg = /(.*)/), e.format || (e.format = "%s")
				}))
			}))
		},
		"./node_modules/sdp-transform/lib/index.js": function(e, t, i) {
			var n = i("./node_modules/sdp-transform/lib/parser.js"),
				r = i("./node_modules/sdp-transform/lib/writer.js");
			t.write = r, t.parse = n.parse, t.parseParams = n.parseParams, t.parseFmtpConfig = n.parseFmtpConfig, t.parsePayloads = n.parsePayloads, t.parseRemoteCandidates = n.parseRemoteCandidates, t.parseImageAttributes = n.parseImageAttributes, t.parseSimulcastStreamList = n.parseSimulcastStreamList
		},
		"./node_modules/sdp-transform/lib/parser.js": function(e, t, i) {
			var n = function(e) {
					return String(Number(e)) === e ? Number(e) : e
				},
				r = function(e, t, i) {
					var r = e.name && e.names;
					e.push && !t[e.push] ? t[e.push] = [] : r && !t[e.name] && (t[e.name] = {});
					var s = e.push ? {} : r ? t[e.name] : t;
					! function(e, t, i, r) {
						if (r && !i) t[r] = n(e[1]);
						else
							for (var s = 0; s < i.length; s += 1) null != e[s + 1] && (t[i[s]] = n(e[s + 1]))
					}(i.match(e.reg), s, e.names, e.name), e.push && t[e.push].push(s)
				},
				s = i("./node_modules/sdp-transform/lib/grammar.js"),
				o = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
			t.parse = function(e) {
				var t = {},
					i = [],
					n = t;
				return e.split(/(\r\n|\r|\n)/).filter(o).forEach((function(e) {
					var t = e[0],
						o = e.slice(2);
					"m" === t && (i.push({
						rtp: [],
						fmtp: []
					}), n = i[i.length - 1]);
					for (var a = 0; a < (s[t] || []).length; a += 1) {
						var d = s[t][a];
						if (d.reg.test(o)) return r(d, n, o)
					}
				})), t.media = i, t
			};
			var a = function(e, t) {
				var i = t.split(/=(.+)/, 2);
				return 2 === i.length ? e[i[0]] = n(i[1]) : 1 === i.length && t.length > 1 && (e[i[0]] = void 0), e
			};
			t.parseParams = function(e) {
				return e.split(/;\s?/).reduce(a, {})
			}, t.parseFmtpConfig = t.parseParams, t.parsePayloads = function(e) {
				return e.toString().split(" ").map(Number)
			}, t.parseRemoteCandidates = function(e) {
				for (var t = [], i = e.split(" ").map(n), r = 0; r < i.length; r += 3) t.push({
					component: i[r],
					ip: i[r + 1],
					port: i[r + 2]
				});
				return t
			}, t.parseImageAttributes = function(e) {
				return e.split(" ").map((function(e) {
					return e.substring(1, e.length - 1).split(",").reduce(a, {})
				}))
			}, t.parseSimulcastStreamList = function(e) {
				return e.split(";").map((function(e) {
					return e.split(",").map((function(e) {
						var t, i = !1;
						return "~" !== e[0] ? t = n(e) : (t = n(e.substring(1, e.length)), i = !0), {
							scid: t,
							paused: i
						}
					}))
				}))
			}
		},
		"./node_modules/sdp-transform/lib/writer.js": function(e, t, i) {
			var n = i("./node_modules/sdp-transform/lib/grammar.js"),
				r = /%[sdv%]/g,
				s = function(e) {
					var t = 1,
						i = arguments,
						n = i.length;
					return e.replace(r, (function(e) {
						if (t >= n) return e;
						var r = i[t];
						switch (t += 1, e) {
							case "%%":
								return "%";
							case "%s":
								return String(r);
							case "%d":
								return Number(r);
							case "%v":
								return ""
						}
					}))
				},
				o = function(e, t, i) {
					var n = [e + "=" + (t.format instanceof Function ? t.format(t.push ? i : i[t.name]) : t.format)];
					if (t.names)
						for (var r = 0; r < t.names.length; r += 1) {
							var o = t.names[r];
							t.name ? n.push(i[t.name][o]) : n.push(i[t.names[r]])
						} else n.push(i[t.name]);
					return s.apply(null, n)
				},
				a = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
				d = ["i", "c", "b", "a"];
			e.exports = function(e, t) {
				t = t || {}, null == e.version && (e.version = 0), null == e.name && (e.name = " "), e.media.forEach((function(e) {
					null == e.payloads && (e.payloads = "")
				}));
				var i = t.outerOrder || a,
					r = t.innerOrder || d,
					s = [];
				return i.forEach((function(t) {
					n[t].forEach((function(i) {
						i.name in e && null != e[i.name] ? s.push(o(t, i, e)) : i.push in e && null != e[i.push] && e[i.push].forEach((function(e) {
							s.push(o(t, i, e))
						}))
					}))
				})), e.media.forEach((function(e) {
					s.push(o("m", n.m[0], e)), r.forEach((function(t) {
						n[t].forEach((function(i) {
							i.name in e && null != e[i.name] ? s.push(o(t, i, e)) : i.push in e && null != e[i.push] && e[i.push].forEach((function(e) {
								s.push(o(t, i, e))
							}))
						}))
					}))
				})), s.join("\r\n") + "\r\n"
			}
		},
		"./node_modules/tlds/index.js": function(e, t) {
			e.exports = ["aaa", "aarp", "abarth", "abb", "abbott", "abbvie", "abc", "able", "abogado", "abudhabi", "ac", "academy", "accenture", "accountant", "accountants", "aco", "active", "actor", "ad", "adac", "ads", "adult", "ae", "aeg", "aero", "aetna", "af", "afamilycompany", "afl", "africa", "ag", "agakhan", "agency", "ai", "aig", "aigo", "airbus", "airforce", "airtel", "akdn", "al", "alfaromeo", "alibaba", "alipay", "allfinanz", "allstate", "ally", "alsace", "alstom", "am", "americanexpress", "americanfamily", "amex", "amfam", "amica", "amsterdam", "analytics", "android", "anquan", "anz", "ao", "aol", "apartments", "app", "apple", "aq", "aquarelle", "ar", "arab", "aramco", "archi", "army", "arpa", "art", "arte", "as", "asda", "asia", "associates", "at", "athleta", "attorney", "au", "auction", "audi", "audible", "audio", "auspost", "author", "auto", "autos", "avianca", "aw", "aws", "ax", "axa", "az", "azure", "ba", "baby", "baidu", "banamex", "bananarepublic", "band", "bank", "bar", "barcelona", "barclaycard", "barclays", "barefoot", "bargains", "baseball", "basketball", "bauhaus", "bayern", "bb", "bbc", "bbt", "bbva", "bcg", "bcn", "bd", "be", "beats", "beauty", "beer", "bentley", "berlin", "best", "bestbuy", "bet", "bf", "bg", "bh", "bharti", "bi", "bible", "bid", "bike", "bing", "bingo", "bio", "biz", "bj", "black", "blackfriday", "blanco", "blockbuster", "blog", "bloomberg", "blue", "bm", "bms", "bmw", "bn", "bnl", "bnpparibas", "bo", "boats", "boehringer", "bofa", "bom", "bond", "boo", "book", "booking", "boots", "bosch", "bostik", "boston", "bot", "boutique", "box", "br", "bradesco", "bridgestone", "broadway", "broker", "brother", "brussels", "bs", "bt", "budapest", "bugatti", "build", "builders", "business", "buy", "buzz", "bv", "bw", "by", "bz", "bzh", "ca", "cab", "cafe", "cal", "call", "calvinklein", "cam", "camera", "camp", "cancerresearch", "canon", "capetown", "capital", "capitalone", "car", "caravan", "cards", "care", "career", "careers", "cars", "cartier", "casa", "case", "caseih", "cash", "casino", "cat", "catering", "catholic", "cba", "cbn", "cbre", "cbs", "cc", "cd", "ceb", "center", "ceo", "cern", "cf", "cfa", "cfd", "cg", "ch", "chanel", "channel", "chase", "chat", "cheap", "chintai", "chloe", "christmas", "chrome", "chrysler", "church", "ci", "cipriani", "circle", "cisco", "citadel", "citi", "citic", "city", "cityeats", "ck", "cl", "claims", "cleaning", "click", "clinic", "clinique", "clothing", "cloud", "club", "clubmed", "cm", "cn", "co", "coach", "codes", "coffee", "college", "cologne", "com", "comcast", "commbank", "community", "company", "compare", "computer", "comsec", "condos", "construction", "consulting", "contact", "contractors", "cooking", "cookingchannel", "cool", "coop", "corsica", "country", "coupon", "coupons", "courses", "cr", "credit", "creditcard", "creditunion", "cricket", "crown", "crs", "cruise", "cruises", "csc", "cu", "cuisinella", "cv", "cw", "cx", "cy", "cymru", "cyou", "cz", "dabur", "dad", "dance", "data", "date", "dating", "datsun", "day", "dclk", "dds", "de", "deal", "dealer", "deals", "degree", "delivery", "dell", "deloitte", "delta", "democrat", "dental", "dentist", "desi", "design", "dev", "dhl", "diamonds", "diet", "digital", "direct", "directory", "discount", "discover", "dish", "diy", "dj", "dk", "dm", "dnp", "do", "docs", "doctor", "dodge", "dog", "doha", "domains", "dot", "download", "drive", "dtv", "dubai", "duck", "dunlop", "duns", "dupont", "durban", "dvag", "dvr", "dz", "earth", "eat", "ec", "eco", "edeka", "edu", "education", "ee", "eg", "email", "emerck", "energy", "engineer", "engineering", "enterprises", "epost", "epson", "equipment", "er", "ericsson", "erni", "es", "esq", "estate", "esurance", "et", "etisalat", "eu", "eurovision", "eus", "events", "everbank", "exchange", "expert", "exposed", "express", "extraspace", "fage", "fail", "fairwinds", "faith", "family", "fan", "fans", "farm", "farmers", "fashion", "fast", "fedex", "feedback", "ferrari", "ferrero", "fi", "fiat", "fidelity", "fido", "film", "final", "finance", "financial", "fire", "firestone", "firmdale", "fish", "fishing", "fit", "fitness", "fj", "fk", "flickr", "flights", "flir", "florist", "flowers", "fly", "fm", "fo", "foo", "food", "foodnetwork", "football", "ford", "forex", "forsale", "forum", "foundation", "fox", "fr", "free", "fresenius", "frl", "frogans", "frontdoor", "frontier", "ftr", "fujitsu", "fujixerox", "fun", "fund", "furniture", "futbol", "fyi", "ga", "gal", "gallery", "gallo", "gallup", "game", "games", "gap", "garden", "gb", "gbiz", "gd", "gdn", "ge", "gea", "gent", "genting", "george", "gf", "gg", "ggee", "gh", "gi", "gift", "gifts", "gives", "giving", "gl", "glade", "glass", "gle", "global", "globo", "gm", "gmail", "gmbh", "gmo", "gmx", "gn", "godaddy", "gold", "goldpoint", "golf", "goo", "goodhands", "goodyear", "goog", "google", "gop", "got", "gov", "gp", "gq", "gr", "grainger", "graphics", "gratis", "green", "gripe", "group", "gs", "gt", "gu", "guardian", "gucci", "guge", "guide", "guitars", "guru", "gw", "gy", "hair", "hamburg", "hangout", "haus", "hbo", "hdfc", "hdfcbank", "health", "healthcare", "help", "helsinki", "here", "hermes", "hgtv", "hiphop", "hisamitsu", "hitachi", "hiv", "hk", "hkt", "hm", "hn", "hockey", "holdings", "holiday", "homedepot", "homegoods", "homes", "homesense", "honda", "honeywell", "horse", "hospital", "host", "hosting", "hot", "hoteles", "hotels", "hotmail", "house", "how", "hr", "hsbc", "ht", "htc", "hu", "hughes", "hyatt", "hyundai", "ibm", "icbc", "ice", "icu", "id", "ie", "ieee", "ifm", "ikano", "il", "im", "imamat", "imdb", "immo", "immobilien", "in", "industries", "infiniti", "info", "ing", "ink", "institute", "insurance", "insure", "int", "intel", "international", "intuit", "investments", "io", "ipiranga", "iq", "ir", "irish", "is", "iselect", "ismaili", "ist", "istanbul", "it", "itau", "itv", "iveco", "iwc", "jaguar", "java", "jcb", "jcp", "je", "jeep", "jetzt", "jewelry", "jio", "jlc", "jll", "jm", "jmp", "jnj", "jo", "jobs", "joburg", "jot", "joy", "jp", "jpmorgan", "jprs", "juegos", "juniper", "kaufen", "kddi", "ke", "kerryhotels", "kerrylogistics", "kerryproperties", "kfh", "kg", "kh", "ki", "kia", "kim", "kinder", "kindle", "kitchen", "kiwi", "km", "kn", "koeln", "komatsu", "kosher", "kp", "kpmg", "kpn", "kr", "krd", "kred", "kuokgroup", "kw", "ky", "kyoto", "kz", "la", "lacaixa", "ladbrokes", "lamborghini", "lamer", "lancaster", "lancia", "lancome", "land", "landrover", "lanxess", "lasalle", "lat", "latino", "latrobe", "law", "lawyer", "lb", "lc", "lds", "lease", "leclerc", "lefrak", "legal", "lego", "lexus", "lgbt", "li", "liaison", "lidl", "life", "lifeinsurance", "lifestyle", "lighting", "like", "lilly", "limited", "limo", "lincoln", "linde", "link", "lipsy", "live", "living", "lixil", "lk", "loan", "loans", "locker", "locus", "loft", "lol", "london", "lotte", "lotto", "love", "lpl", "lplfinancial", "lr", "ls", "lt", "ltd", "ltda", "lu", "lundbeck", "lupin", "luxe", "luxury", "lv", "ly", "ma", "macys", "madrid", "maif", "maison", "makeup", "man", "management", "mango", "market", "marketing", "markets", "marriott", "marshalls", "maserati", "mattel", "mba", "mc", "mcd", "mcdonalds", "mckinsey", "md", "me", "med", "media", "meet", "melbourne", "meme", "memorial", "men", "menu", "meo", "metlife", "mg", "mh", "miami", "microsoft", "mil", "mini", "mint", "mit", "mitsubishi", "mk", "ml", "mlb", "mls", "mm", "mma", "mn", "mo", "mobi", "mobile", "mobily", "moda", "moe", "moi", "mom", "monash", "money", "monster", "montblanc", "mopar", "mormon", "mortgage", "moscow", "moto", "motorcycles", "mov", "movie", "movistar", "mp", "mq", "mr", "ms", "msd", "mt", "mtn", "mtr", "mu", "museum", "mutual", "mv", "mw", "mx", "my", "mz", "na", "nab", "nadex", "nagoya", "name", "nationwide", "natura", "navy", "nba", "nc", "ne", "nec", "net", "netbank", "netflix", "network", "neustar", "new", "newholland", "news", "next", "nextdirect", "nexus", "nf", "nfl", "ng", "ngo", "nhk", "ni", "nico", "nike", "nikon", "ninja", "nissan", "nissay", "nl", "no", "nokia", "northwesternmutual", "norton", "now", "nowruz", "nowtv", "np", "nr", "nra", "nrw", "ntt", "nu", "nyc", "nz", "obi", "observer", "off", "office", "okinawa", "olayan", "olayangroup", "oldnavy", "ollo", "om", "omega", "one", "ong", "onl", "online", "onyourside", "ooo", "open", "oracle", "orange", "org", "organic", "origins", "osaka", "otsuka", "ott", "ovh", "pa", "page", "pamperedchef", "panasonic", "panerai", "paris", "pars", "partners", "parts", "party", "passagens", "pay", "pccw", "pe", "pet", "pf", "pfizer", "pg", "ph", "pharmacy", "philips", "phone", "photo", "photography", "photos", "physio", "piaget", "pics", "pictet", "pictures", "pid", "pin", "ping", "pink", "pioneer", "pizza", "pk", "pl", "place", "play", "playstation", "plumbing", "plus", "pm", "pn", "pnc", "pohl", "poker", "politie", "porn", "post", "pr", "pramerica", "praxi", "press", "prime", "pro", "prod", "productions", "prof", "progressive", "promo", "properties", "property", "protection", "pru", "prudential", "ps", "pt", "pub", "pw", "pwc", "py", "qa", "qpon", "quebec", "quest", "qvc", "racing", "radio", "raid", "re", "read", "realestate", "realtor", "realty", "recipes", "red", "redstone", "redumbrella", "rehab", "reise", "reisen", "reit", "reliance", "ren", "rent", "rentals", "repair", "report", "republican", "rest", "restaurant", "review", "reviews", "rexroth", "rich", "richardli", "ricoh", "rightathome", "ril", "rio", "rip", "rmit", "ro", "rocher", "rocks", "rodeo", "rogers", "room", "rs", "rsvp", "ru", "rugby", "ruhr", "run", "rw", "rwe", "ryukyu", "sa", "saarland", "safe", "safety", "sakura", "sale", "salon", "samsclub", "samsung", "sandvik", "sandvikcoromant", "sanofi", "sap", "sapo", "sarl", "sas", "save", "saxo", "sb", "sbi", "sbs", "sc", "sca", "scb", "schaeffler", "schmidt", "scholarships", "school", "schule", "schwarz", "science", "scjohnson", "scor", "scot", "sd", "se", "seat", "secure", "security", "seek", "select", "sener", "services", "ses", "seven", "sew", "sex", "sexy", "sfr", "sg", "sh", "shangrila", "sharp", "shaw", "shell", "shia", "shiksha", "shoes", "shop", "shopping", "shouji", "show", "showtime", "shriram", "si", "silk", "sina", "singles", "site", "sj", "sk", "ski", "skin", "sky", "skype", "sl", "sling", "sm", "smart", "smile", "sn", "sncf", "so", "soccer", "social", "softbank", "software", "sohu", "solar", "solutions", "song", "sony", "soy", "space", "spiegel", "spot", "spreadbetting", "sr", "srl", "srt", "st", "stada", "staples", "star", "starhub", "statebank", "statefarm", "statoil", "stc", "stcgroup", "stockholm", "storage", "store", "stream", "studio", "study", "style", "su", "sucks", "supplies", "supply", "support", "surf", "surgery", "suzuki", "sv", "swatch", "swiftcover", "swiss", "sx", "sy", "sydney", "symantec", "systems", "sz", "tab", "taipei", "talk", "taobao", "target", "tatamotors", "tatar", "tattoo", "tax", "taxi", "tc", "tci", "td", "tdk", "team", "tech", "technology", "tel", "telecity", "telefonica", "temasek", "tennis", "teva", "tf", "tg", "th", "thd", "theater", "theatre", "tiaa", "tickets", "tienda", "tiffany", "tips", "tires", "tirol", "tj", "tjmaxx", "tjx", "tk", "tkmaxx", "tl", "tm", "tmall", "tn", "to", "today", "tokyo", "tools", "top", "toray", "toshiba", "total", "tours", "town", "toyota", "toys", "tr", "trade", "trading", "training", "travel", "travelchannel", "travelers", "travelersinsurance", "trust", "trv", "tt", "tube", "tui", "tunes", "tushu", "tv", "tvs", "tw", "tz", "ua", "ubank", "ubs", "uconnect", "ug", "uk", "unicom", "university", "uno", "uol", "ups", "us", "uy", "uz", "va", "vacations", "vana", "vanguard", "vc", "ve", "vegas", "ventures", "verisign", "versicherung", "vet", "vg", "vi", "viajes", "video", "vig", "viking", "villas", "vin", "vip", "virgin", "visa", "vision", "vista", "vistaprint", "viva", "vivo", "vlaanderen", "vn", "vodka", "volkswagen", "volvo", "vote", "voting", "voto", "voyage", "vu", "vuelos", "wales", "walmart", "walter", "wang", "wanggou", "warman", "watch", "watches", "weather", "weatherchannel", "webcam", "weber", "website", "wed", "wedding", "weibo", "weir", "wf", "whoswho", "wien", "wiki", "williamhill", "win", "windows", "wine", "winners", "wme", "wolterskluwer", "woodside", "work", "works", "world", "wow", "ws", "wtc", "wtf", "xbox", "xerox", "xfinity", "xihuan", "xin", "कॉम", "セール", "佛山", "慈善", "集团", "在线", "한국", "大众汽车", "点看", "คอม", "ভারত", "八卦", "موقع", "বাংলা", "公益", "公司", "香格里拉", "网站", "移动", "我爱你", "москва", "қаз", "католик", "онлайн", "сайт", "联通", "срб", "бг", "бел", "קום", "时尚", "微博", "淡马锡", "ファッション", "орг", "नेट", "ストア", "삼성", "சிங்கப்பூர்", "商标", "商店", "商城", "дети", "мкд", "ею", "ポイント", "新闻", "工行", "家電", "كوم", "中文网", "中信", "中国", "中國", "娱乐", "谷歌", "భారత్", "ලංකා", "電訊盈科", "购物", "クラウド", "ભારત", "通販", "भारत", "网店", "संगठन", "餐厅", "网络", "ком", "укр", "香港", "诺基亚", "食品", "飞利浦", "台湾", "台灣", "手表", "手机", "мон", "الجزائر", "عمان", "ارامكو", "ایران", "العليان", "اتصالات", "امارات", "بازار", "پاکستان", "الاردن", "موبايلي", "بھارت", "المغرب", "ابوظبي", "السعودية", "كاثوليك", "سودان", "همراه", "عراق", "مليسيا", "澳門", "닷컴", "政府", "شبكة", "بيتك", "عرب", "გე", "机构", "组织机构", "健康", "ไทย", "سورية", "рус", "рф", "珠宝", "تونس", "大拿", "みんな", "グーグル", "ελ", "世界", "書籍", "ਭਾਰਤ", "网址", "닷넷", "コム", "天主教", "游戏", "vermögensberater", "vermögensberatung", "企业", "信息", "嘉里大酒店", "嘉里", "مصر", "قطر", "广东", "இலங்கை", "இந்தியா", "հայ", "新加坡", "فلسطين", "政务", "xperia", "xxx", "xyz", "yachts", "yahoo", "yamaxun", "yandex", "ye", "yodobashi", "yoga", "yokohama", "you", "youtube", "yt", "yun", "za", "zappos", "zara", "zero", "zip", "zippo", "zm", "zone", "zuerich", "zw"]
		},
		"./node_modules/uc.micro/categories/Cc/regex.js": function(e, t) {
			e.exports = /[\0-\x1F\x7F-\x9F]/
		},
		"./node_modules/uc.micro/categories/P/regex.js": function(e, t) {
			e.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/
		},
		"./node_modules/uc.micro/categories/Z/regex.js": function(e, t) {
			e.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/
		},
		"./node_modules/uc.micro/properties/Any/regex.js": function(e, t) {
			e.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
		},
		"./node_modules/unhomoglyph/data.json": function(e) {
			e.exports = JSON.parse('{"0":"O","1":"l","֭":"֖","֮":"֘","֨":"֙","֤":"֚","᪴":"ۛ","⃛":"ۛ","ؙ":"̓","ࣳ":"̓","̓":"̓","̕":"̓","ُ":"̓","ٝ":"̔","֜":"́","֝":"́","ؘ":"́","݇":"́","́":"́","॔":"́","َ":"́","̀":"̀","॓":"̀","̌":"̆","꙼":"̆","٘":"̆","ٚ":"̆","ͮ":"̆","ۨ":"̆̇","̐":"̆̇","ँ":"̆̇","ঁ":"̆̇","ઁ":"̆̇","ଁ":"̆̇","ఀ":"̆̇","ಁ":"̆̇","ഁ":"̆̇","𑒿":"̆̇","᳐":"̂","̑":"̂","ٛ":"̂","߮":"̂","꛰":"̂","֯":"̊","۟":"̊","៓":"̊","゚":"̊","ْ":"̊","ஂ":"̊","ံ":"̊","ំ":"̊","𑌀":"̊","ํ":"̊","ໍ":"̊","ͦ":"̊","ⷪ":"̊","࣫":"̈","߳":"̈","ً":"̋","ࣰ":"̋","͂":"̃","ٓ":"̃","ׄ":"̇","۬":"̇","݀":"̇","࣪":"̇","݁":"̇","͘":"̇","ֹ":"̇","ֺ":"̇","ׂ":"̇","ׁ":"̇","߭":"̇","ं":"̇","ਂ":"̇","ં":"̇","்":"̇","̷":"̸","᪷":"̨","̢":"̨","ͅ":"̨","᳒":"̄","̅":"̄","ٙ":"̄","߫":"̄","꛱":"̄","᳚":"̎","ٗ":"̒","͗":"͐","ࣿ":"͐","ࣸ":"͐","ऀ":"͒","᳭":"̖","᳜":"̩","ٖ":"̩","᳕":"̫","͇":"̳","ࣹ":"͔","ࣺ":"͕","゛":"ﾞ","゜":"ﾟ","̶":"̵","〬":"̉","ׅ":"̣","࣭":"̣","᳝":"̣","ִ":"̣","ٜ":"̣","़":"̣","়":"̣","਼":"̣","઼":"̣","଼":"̣","𑇊":"̣","𑓃":"̣","𐨺":"̣","࣮":"̤","᳞":"̤","༷":"̥","〭":"̥","̧":"̦","̡":"̦","̹":"̦","᳙":"̭","᳘":"̮","॒":"̱","̠":"̱","ࣱ":"ٌ","ࣨ":"ٌ","ࣥ":"ٌ","ﱞ":"ﹲّ","ࣲ":"ٍ","ﱟ":"ﹴّ","ﳲ":"ﹷّ","ﱠ":"ﹶّ","ﳳ":"ﹹّ","ﱡ":"ﹸّ","ؚ":"ِ","̗":"ِ","ﳴ":"ﹻّ","ﱢ":"ﹺّ","ﱣ":"ﹼٰ","ٟ":"ٕ","̍":"ٰ","݂":"ܼ","ਃ":"ঃ","ః":"ঃ","ಃ":"ঃ","ഃ":"ঃ","ඃ":"ঃ","း":"ঃ","𑓁":"ঃ","់":"่","່":"่","້":"้","໊":"๊","໋":"๋","꙯":"⃩","\\u2028":" ","\\u2029":" "," ":" "," ":" "," ":" "," ":" "," ":" "," ":" "," ":" "," ":" "," ":" "," ":" "," ":" "," ":" "," ":" "," ":" "," ":" ","ߺ":"_","﹍":"_","﹎":"_","﹏":"_","‐":"-","‑":"-","‒":"-","–":"-","﹘":"-","۔":"-","⁃":"-","˗":"-","−":"-","➖":"-","Ⲻ":"-","⨩":"-̓","⸚":"-̈","﬩":"-̇","∸":"-̇","⨪":"-̣","꓾":"-.","～":"〜","؍":",","٫":",","‚":",","¸":",","ꓹ":",","⸲":"،","٬":"،",";":";","⸵":"؛","ः":":","ઃ":":","：":":","։":":","܃":":","܄":":","᛬":":","︰":":","᠃":":","᠉":":","⁚":":","׃":":","˸":":","꞉":":","∶":":","ː":":","ꓽ":":","⩴":"::=","⧴":":→","！":"!","ǃ":"!","ⵑ":"!","‼":"!!","⁉":"!?","ʔ":"?","Ɂ":"?","ॽ":"?","Ꭾ":"?","ꛫ":"?","⁈":"?!","⁇":"??","⸮":"؟","𝅭":".","․":".","܁":".","܂":".","꘎":".","𐩐":".","٠":".","۰":".","ꓸ":".","ꓻ":".,","‥":"..","ꓺ":"..","…":"...","꛴":"꛳꛳","・":"·","･":"·","᛫":"·","·":"·","⸱":"·","𐄁":"·","•":"·","‧":"·","∙":"·","⋅":"·","ꞏ":"·","ᐧ":"·","⋯":"···","ⵈ":"···","ᑄ":"·<","⋗":"·>","ᐷ":"·>","ᑀ":"·>","ᔯ":"·4","ᑾ":"·b","ᒀ":"·ḃ","ᑺ":"·d","ᒘ":"·J","ᒶ":"·L","ᑶ":"·P","ᑗ":"·U","ᐺ":"·V","ᐼ":"·Ʌ","ᒮ":"·Γ","ᐎ":"·Δ","ᑙ":"·Ո","ᐌ":"·ᐁ","ᐐ":"·ᐄ","ᐒ":"·ᐅ","ᐔ":"·ᐆ","ᐗ":"·ᐊ","ᐙ":"·ᐋ","ᐾ":"·ᐲ","ᑂ":"·ᐴ","ᑆ":"·ᐹ","ᑛ":"·ᑏ","ᑔ":"·ᑐ","ᑝ":"·ᑐ","ᑟ":"·ᑑ","ᑡ":"·ᑕ","ᑣ":"·ᑖ","ᑴ":"·ᑫ","ᑸ":"·ᑮ","ᑼ":"·ᑰ","ᒒ":"·ᒉ","ᒔ":"·ᒋ","ᒖ":"·ᒌ","ᒚ":"·ᒎ","ᒜ":"·ᒐ","ᒞ":"·ᒑ","ᒬ":"·ᒣ","ᒰ":"·ᒦ","ᒲ":"·ᒧ","ᒴ":"·ᒨ","ᒸ":"·ᒫ","ᓉ":"·ᓀ","ᣆ":"·ᓂ","ᣈ":"·ᓃ","ᣊ":"·ᓄ","ᣌ":"·ᓅ","ᓋ":"·ᓇ","ᓍ":"·ᓈ","ᓜ":"·ᓓ","ᓞ":"·ᓕ","ᓠ":"·ᓖ","ᓢ":"·ᓗ","ᓤ":"·ᓘ","ᓦ":"·ᓚ","ᓨ":"·ᓛ","ᓶ":"·ᓭ","ᓸ":"·ᓯ","ᓺ":"·ᓰ","ᓼ":"·ᓱ","ᓾ":"·ᓲ","ᔀ":"·ᓴ","ᔂ":"·ᓵ","ᔗ":"·ᔐ","ᔙ":"·ᔑ","ᔛ":"·ᔒ","ᔝ":"·ᔓ","ᔟ":"·ᔔ","ᔡ":"·ᔕ","ᔣ":"·ᔖ","ᔱ":"·ᔨ","ᔳ":"·ᔩ","ᔵ":"·ᔪ","ᔷ":"·ᔫ","ᔹ":"·ᔭ","ᔻ":"·ᔮ","ᣎ":"·ᕃ","ᣏ":"·ᕆ","ᣐ":"·ᕇ","ᣑ":"·ᕈ","ᣒ":"·ᕉ","ᣓ":"·ᕋ","ᕎ":"·ᕌ","ᕛ":"·ᕚ","ᕨ":"·ᕧ","ᢳ":"·ᢱ","ᢶ":"·ᢴ","ᢹ":"·ᢸ","ᣂ":"·ᣀ","꠰":"।","॥":"।।","᰼":"᰻᰻","။":"၊၊","᪩":"᪨᪨","᪫":"᪪᪨","᭟":"᭞᭞","𐩗":"𐩖𐩖","𑑌":"𑑋𑑋","𑙂":"𑙁𑙁","𑱂":"𑱁𑱁","᱿":"᱾᱾","՝":"\'","＇":"\'","‘":"\'","’":"\'","‛":"\'","′":"\'","‵":"\'","՚":"\'","׳":"\'","`":"\'","`":"\'","｀":"\'","´":"\'","΄":"\'","´":"\'","᾽":"\'","᾿":"\'","῾":"\'","ʹ":"\'","ʹ":"\'","ˈ":"\'","ˊ":"\'","ˋ":"\'","˴":"\'","ʻ":"\'","ʽ":"\'","ʼ":"\'","ʾ":"\'","ꞌ":"\'","י":"\'","ߴ":"\'","ߵ":"\'","ᑊ":"\'","ᛌ":"\'","𖽑":"\'","𖽒":"\'","᳓":"\'\'","\\"":"\'\'","＂":"\'\'","“":"\'\'","”":"\'\'","‟":"\'\'","″":"\'\'","‶":"\'\'","〃":"\'\'","״":"\'\'","˝":"\'\'","ʺ":"\'\'","˶":"\'\'","ˮ":"\'\'","ײ":"\'\'","‴":"\'\'\'","‷":"\'\'\'","⁗":"\'\'\'\'","Ɓ":"\'B","Ɗ":"\'D","ŉ":"\'n","Ƥ":"\'P","Ƭ":"\'T","Ƴ":"\'Y","［":"(","❨":"(","❲":"(","〔":"(","﴾":"(","⸨":"((","㈠":"(ー)","⑵":"(2)","⒇":"(2O)","⑶":"(3)","⑷":"(4)","⑸":"(5)","⑹":"(6)","⑺":"(7)","⑻":"(8)","⑼":"(9)","⒜":"(a)","🄐":"(A)","⒝":"(b)","🄑":"(B)","⒞":"(c)","🄒":"(C)","⒟":"(d)","🄓":"(D)","⒠":"(e)","🄔":"(E)","⒡":"(f)","🄕":"(F)","⒢":"(g)","🄖":"(G)","⒣":"(h)","🄗":"(H)","⒤":"(i)","⒥":"(j)","🄙":"(J)","⒦":"(k)","🄚":"(K)","⑴":"(l)","🄘":"(l)","⒧":"(l)","🄛":"(L)","⑿":"(l2)","⒀":"(l3)","⒁":"(l4)","⒂":"(l5)","⒃":"(l6)","⒄":"(l7)","⒅":"(l8)","⒆":"(l9)","⑾":"(ll)","⑽":"(lO)","🄜":"(M)","⒩":"(n)","🄝":"(N)","⒪":"(o)","🄞":"(O)","⒫":"(p)","🄟":"(P)","⒬":"(q)","🄠":"(Q)","⒭":"(r)","🄡":"(R)","⒨":"(rn)","⒮":"(s)","🄢":"(S)","🄪":"(S)","⒯":"(t)","🄣":"(T)","⒰":"(u)","🄤":"(U)","⒱":"(v)","🄥":"(V)","⒲":"(w)","🄦":"(W)","⒳":"(x)","🄧":"(X)","⒴":"(y)","🄨":"(Y)","⒵":"(z)","🄩":"(Z)","㈀":"(ᄀ)","㈎":"(가)","㈁":"(ᄂ)","㈏":"(나)","㈂":"(ᄃ)","㈐":"(다)","㈃":"(ᄅ)","㈑":"(라)","㈄":"(ᄆ)","㈒":"(마)","㈅":"(ᄇ)","㈓":"(바)","㈆":"(ᄉ)","㈔":"(사)","㈇":"(ᄋ)","㈕":"(아)","㈝":"(오전)","㈞":"(오후)","㈈":"(ᄌ)","㈖":"(자)","㈜":"(주)","㈉":"(ᄎ)","㈗":"(차)","㈊":"(ᄏ)","㈘":"(카)","㈋":"(ᄐ)","㈙":"(타)","㈌":"(ᄑ)","㈚":"(파)","㈍":"(ᄒ)","㈛":"(하)","㈦":"(七)","㈢":"(三)","🉁":"(三)","㈨":"(九)","㈡":"(二)","🉂":"(二)","㈤":"(五)","㈹":"(代)","㈽":"(企)","㉁":"(休)","㈧":"(八)","㈥":"(六)","㈸":"(労)","🉇":"(勝)","㈩":"(十)","㈿":"(協)","㈴":"(名)","㈺":"(呼)","㈣":"(四)","㈯":"(土)","㈻":"(学)","🉃":"(安)","🉅":"(打)","🉈":"(敗)","㈰":"(日)","㈪":"(月)","㈲":"(有)","㈭":"(木)","🉀":"(本)","㈱":"(株)","㈬":"(水)","㈫":"(火)","🉄":"(点)","㈵":"(特)","🉆":"(盗)","㈼":"(監)","㈳":"(社)","㈷":"(祝)","㉀":"(祭)","㉂":"(自)","㉃":"(至)","㈶":"(財)","㈾":"(資)","㈮":"(金)","］":")","❩":")","❳":")","〕":")","﴿":")","⸩":"))","❴":"{","𝄔":"{","❵":"}","〚":"⟦","〛":"⟧","⟨":"❬","〈":"❬","〈":"❬","㇛":"❬","く":"❬","𡿨":"❬","⟩":"❭","〉":"❭","〉":"❭","＾":"︿","⸿":"¶","⁎":"*","٭":"*","∗":"*","𐌟":"*","᜵":"/","⁁":"/","∕":"/","⁄":"/","╱":"/","⟋":"/","⧸":"/","𝈺":"/","㇓":"/","〳":"/","Ⳇ":"/","ノ":"/","丿":"/","⼃":"/","⧶":"/̄","⫽":"//","⫻":"///","＼":"\\\\","﹨":"\\\\","∖":"\\\\","⟍":"\\\\","⧵":"\\\\","⧹":"\\\\","𝈏":"\\\\","𝈻":"\\\\","㇔":"\\\\","丶":"\\\\","⼂":"\\\\","⳹":"\\\\\\\\","⑊":"\\\\\\\\","⟈":"\\\\ᑕ","ꝸ":"&","૰":"॰","𑂻":"॰","𑇇":"॰","⚬":"॰","𑇛":"꣼","៙":"๏","៕":"๚","៚":"๛","༌":"་","༎":"།།","˄":"^","ˆ":"^","꙾":"ˇ","˘":"ˇ","‾":"ˉ","﹉":"ˉ","﹊":"ˉ","﹋":"ˉ","﹌":"ˉ","¯":"ˉ","￣":"ˉ","▔":"ˉ","ъ":"ˉb","ꙑ":"ˉbi","͵":"ˏ","˻":"˪","꜖":"˪","꜔":"˫","。":"˳","⸰":"°","˚":"°","∘":"°","○":"°","◦":"°","⍜":"°̲","⍤":"°̈","℃":"°C","℉":"°F","௵":"௳","༛":"༚༚","༟":"༚༝","࿎":"༝༚","༞":"༝༝","Ⓒ":"©","Ⓡ":"®","Ⓟ":"℗","𝈛":"⅄","⯬":"↞","⯭":"↟","⯮":"↠","⯯":"↡","↵":"↲","⥥":"⇃⇂","⥯":"⇃ᛚ","𝛛":"∂","𝜕":"∂","𝝏":"∂","𝞉":"∂","𝟃":"∂","𞣌":"∂","𞣍":"∂̵","ð":"∂̵","⌀":"∅","𝛁":"∇","𝛻":"∇","𝜵":"∇","𝝯":"∇","𝞩":"∇","𑢨":"∇","⍢":"∇̈","⍫":"∇̴","█":"∎","■":"∎","⨿":"∐","᛭":"+","➕":"+","𐊛":"+","⨣":"+̂","⨢":"+̊","⨤":"+̃","∔":"+̇","⨥":"+̣","⨦":"+̰","⨧":"+₂","➗":"÷","‹":"<","❮":"<","˂":"<","𝈶":"<","ᐸ":"<","ᚲ":"<","⋖":"<·","Ⲵ":"<·","ᑅ":"<·","≪":"<<","⋘":"<<<","᐀":"=","⹀":"=","゠":"=","꓿":"=","≚":"=̆","≙":"=̂","≗":"=̊","≐":"=̇","≑":"=̣̇","⩮":"=⃰","⩵":"==","⩶":"===","≞":"=ͫ","›":">","❯":">","˃":">","𝈷":">","ᐳ":">","𖼿":">","ᑁ":">·","⪥":"><","≫":">>","⨠":">>","⋙":">>>","⁓":"~","˜":"~","῀":"~","∼":"~","⍨":"~̈","⸞":"~̇","⩪":"~̇","⸟":"~̣","𞣈":"∠","⋀":"∧","∯":"∮∮","∰":"∮∮∮","⸫":"∴","⸪":"∵","⸬":"∷","𑇞":"≈","♎":"≏","🝞":"≏","≣":"≡","⨃":"⊍","⨄":"⊎","𝈸":"⊏","𝈹":"⊐","⨅":"⊓","⨆":"⊔","⨂":"⊗","⍟":"⊛","🝱":"⊠","🝕":"⊡","◁":"⊲","▷":"⊳","⍣":"⋆̈","︴":"⌇","◠":"⌒","⨽":"⌙","⌥":"⌤","⧇":"⌻","◎":"⌾","⦾":"⌾","⧅":"⍂","⦰":"⍉","⏃":"⍋","⏂":"⍎","⏁":"⍕","⏆":"⍭","☸":"⎈","︵":"⏜","︶":"⏝","︷":"⏞","︸":"⏟","︹":"⏠","︺":"⏡","▱":"⏥","⏼":"⏻","︱":"│","｜":"│","┃":"│","┏":"┌","┣":"├","▐":"▌","▗":"▖","▝":"▘","☐":"□","￭":"▪","▸":"▶","►":"▶","⳩":"☧","🜊":"☩","🌒":"☽","🌙":"☽","⏾":"☾","🌘":"☾","⧙":"⦚","🜺":"⧟","⨾":"⨟","𐆠":"⳨","♩":"𝅘𝅥","♪":"𝅘𝅥𝅮","⓪":"🄍","↺":"🄎","˙":"ॱ","ൎ":"ॱ","－":"ー","—":"ー","―":"ー","─":"ー","━":"ー","㇐":"ー","ꟷ":"ー","ᅳ":"ー","ㅡ":"ー","一":"ー","⼀":"ー","ᆖ":"ーー","ힹ":"ーᅡ","ힺ":"ーᅥ","ힻ":"ーᅥ丨","ힼ":"ーᅩ","ᆕ":"ーᅮ","ᅴ":"ー丨","ㅢ":"ー丨","ᆗ":"ー丨ᅮ","🄏":"$⃠","₤":"£","〒":"₸","〶":"₸","᭜":"᭐","꧆":"꧐","𑓑":"১","೧":"౧","ၥ":"၁","①":"➀","⑩":"➉","⏨":"₁₀","𝟐":"2","𝟚":"2","𝟤":"2","𝟮":"2","𝟸":"2","🯲":"2","Ꝛ":"2","Ƨ":"2","Ϩ":"2","Ꙅ":"2","ᒿ":"2","ꛯ":"2","ꧏ":"٢","۲":"٢","૨":"२","𑓒":"২","೨":"౨","②":"➁","ƻ":"2̵","🄃":"2,","⒉":"2.","㏵":"22日","㍮":"22点","㏶":"23日","㍯":"23点","㏷":"24日","㍰":"24点","㏸":"25日","㏹":"26日","㏺":"27日","㏻":"28日","㏼":"29日","㏴":"2l日","㍭":"2l点","⒛":"2O.","㏳":"2O日","㍬":"2O点","෩":"෨ා","෯":"෨ී","㏡":"2日","㋁":"2月","㍚":"2点","𝈆":"3","𝟑":"3","𝟛":"3","𝟥":"3","𝟯":"3","𝟹":"3","🯳":"3","Ɜ":"3","Ȝ":"3","Ʒ":"3","Ꝫ":"3","Ⳍ":"3","З":"3","Ӡ":"3","𖼻":"3","𑣊":"3","۳":"٣","𞣉":"٣","૩":"३","③":"➂","Ҙ":"3̦","🄄":"3,","⒊":"3.","㏾":"3l日","㏽":"3O日","㏢":"3日","㋂":"3月","㍛":"3点","𝟒":"4","𝟜":"4","𝟦":"4","𝟰":"4","𝟺":"4","🯴":"4","Ꮞ":"4","𑢯":"4","۴":"٤","૪":"४","④":"➃","🄅":"4,","⒋":"4.","ᔰ":"4·","㏣":"4日","㋃":"4月","㍜":"4点","𝟓":"5","𝟝":"5","𝟧":"5","𝟱":"5","𝟻":"5","🯵":"5","Ƽ":"5","𑢻":"5","⑤":"➄","🄆":"5,","⒌":"5.","㏤":"5日","㋄":"5月","㍝":"5点","𝟔":"6","𝟞":"6","𝟨":"6","𝟲":"6","𝟼":"6","🯶":"6","Ⳓ":"6","б":"6","Ꮾ":"6","𑣕":"6","۶":"٦","𑓖":"৬","⑥":"➅","🄇":"6,","⒍":"6.","㏥":"6日","㋅":"6月","㍞":"6点","𝈒":"7","𝟕":"7","𝟟":"7","𝟩":"7","𝟳":"7","𝟽":"7","🯷":"7","𐓒":"7","𑣆":"7","⑦":"➆","🄈":"7,","⒎":"7.","㏦":"7日","㋆":"7月","㍟":"7点","ଃ":"8","৪":"8","੪":"8","𞣋":"8","𝟖":"8","𝟠":"8","𝟪":"8","𝟴":"8","𝟾":"8","🯸":"8","ȣ":"8","Ȣ":"8","𐌚":"8","૮":"८","⑧":"➇","🄉":"8,","⒏":"8.","㏧":"8日","㋇":"8月","㍠":"8点","੧":"9","୨":"9","৭":"9","൭":"9","𝟗":"9","𝟡":"9","𝟫":"9","𝟵":"9","𝟿":"9","🯹":"9","Ꝯ":"9","Ⳋ":"9","𑣌":"9","𑢬":"9","𑣖":"9","१":"٩","𑣤":"٩","۹":"٩","೯":"౯","⑨":"➈","🄊":"9,","⒐":"9.","㏨":"9日","㋈":"9月","㍡":"9点","⍺":"a","ａ":"a","𝐚":"a","𝑎":"a","𝒂":"a","𝒶":"a","𝓪":"a","𝔞":"a","𝕒":"a","𝖆":"a","𝖺":"a","𝗮":"a","𝘢":"a","𝙖":"a","𝚊":"a","ɑ":"a","α":"a","𝛂":"a","𝛼":"a","𝜶":"a","𝝰":"a","𝞪":"a","а":"a","ⷶ":"ͣ","Ａ":"A","𝐀":"A","𝐴":"A","𝑨":"A","𝒜":"A","𝓐":"A","𝔄":"A","𝔸":"A","𝕬":"A","𝖠":"A","𝗔":"A","𝘈":"A","𝘼":"A","𝙰":"A","Α":"A","𝚨":"A","𝛢":"A","𝜜":"A","𝝖":"A","𝞐":"A","А":"A","Ꭺ":"A","ᗅ":"A","ꓮ":"A","𖽀":"A","𐊠":"A","⍶":"a̲","ǎ":"ă","Ǎ":"Ă","ȧ":"å","Ȧ":"Å","ẚ":"ả","℀":"a/c","℁":"a/s","ꜳ":"aa","Ꜳ":"AA","æ":"ae","ӕ":"ae","Æ":"AE","Ӕ":"AE","ꜵ":"ao","Ꜵ":"AO","🜇":"AR","ꜷ":"au","Ꜷ":"AU","ꜹ":"av","ꜻ":"av","Ꜹ":"AV","Ꜻ":"AV","ꜽ":"ay","Ꜽ":"AY","ꭺ":"ᴀ","∀":"Ɐ","𝈗":"Ɐ","ᗄ":"Ɐ","ꓯ":"Ɐ","𐐟":"Ɒ","𝐛":"b","𝑏":"b","𝒃":"b","𝒷":"b","𝓫":"b","𝔟":"b","𝕓":"b","𝖇":"b","𝖻":"b","𝗯":"b","𝘣":"b","𝙗":"b","𝚋":"b","Ƅ":"b","Ь":"b","Ꮟ":"b","ᑲ":"b","ᖯ":"b","Ｂ":"B","ℬ":"B","𝐁":"B","𝐵":"B","𝑩":"B","𝓑":"B","𝔅":"B","𝔹":"B","𝕭":"B","𝖡":"B","𝗕":"B","𝘉":"B","𝘽":"B","𝙱":"B","Ꞵ":"B","Β":"B","𝚩":"B","𝛣":"B","𝜝":"B","𝝗":"B","𝞑":"B","В":"B","Ᏼ":"B","ᗷ":"B","ꓐ":"B","𐊂":"B","𐊡":"B","𐌁":"B","ɓ":"b̔","ᑳ":"ḃ","ƃ":"b̄","Ƃ":"b̄","Б":"b̄","ƀ":"b̵","ҍ":"b̵","Ҍ":"b̵","ѣ":"b̵","Ѣ":"b̵","ᑿ":"b·","ᒁ":"ḃ·","ᒈ":"b\'","Ы":"bl","в":"ʙ","ᏼ":"ʙ","ｃ":"c","ⅽ":"c","𝐜":"c","𝑐":"c","𝒄":"c","𝒸":"c","𝓬":"c","𝔠":"c","𝕔":"c","𝖈":"c","𝖼":"c","𝗰":"c","𝘤":"c","𝙘":"c","𝚌":"c","ᴄ":"c","ϲ":"c","ⲥ":"c","с":"c","ꮯ":"c","𐐽":"c","ⷭ":"ͨ","🝌":"C","𑣲":"C","𑣩":"C","Ｃ":"C","Ⅽ":"C","ℂ":"C","ℭ":"C","𝐂":"C","𝐶":"C","𝑪":"C","𝒞":"C","𝓒":"C","𝕮":"C","𝖢":"C","𝗖":"C","𝘊":"C","𝘾":"C","𝙲":"C","Ϲ":"C","Ⲥ":"C","С":"C","Ꮯ":"C","ꓚ":"C","𐊢":"C","𐌂":"C","𐐕":"C","𐔜":"C","¢":"c̸","ȼ":"c̸","₡":"C⃫","🅮":"C⃠","ç":"c̦","ҫ":"c̦","Ç":"C̦","Ҫ":"C̦","Ƈ":"C\'","℅":"c/o","℆":"c/u","🅭":"㏄\\t⃝","⋴":"ꞓ","ɛ":"ꞓ","ε":"ꞓ","ϵ":"ꞓ","𝛆":"ꞓ","𝛜":"ꞓ","𝜀":"ꞓ","𝜖":"ꞓ","𝜺":"ꞓ","𝝐":"ꞓ","𝝴":"ꞓ","𝞊":"ꞓ","𝞮":"ꞓ","𝟄":"ꞓ","ⲉ":"ꞓ","є":"ꞓ","ԑ":"ꞓ","ꮛ":"ꞓ","𑣎":"ꞓ","𐐩":"ꞓ","€":"Ꞓ","Ⲉ":"Ꞓ","Є":"Ꞓ","⍷":"ꞓ̲","ͽ":"ꜿ","Ͽ":"Ꜿ","ⅾ":"d","ⅆ":"d","𝐝":"d","𝑑":"d","𝒅":"d","𝒹":"d","𝓭":"d","𝔡":"d","𝕕":"d","𝖉":"d","𝖽":"d","𝗱":"d","𝘥":"d","𝙙":"d","𝚍":"d","ԁ":"d","Ꮷ":"d","ᑯ":"d","ꓒ":"d","Ⅾ":"D","ⅅ":"D","𝐃":"D","𝐷":"D","𝑫":"D","𝒟":"D","𝓓":"D","𝔇":"D","𝔻":"D","𝕯":"D","𝖣":"D","𝗗":"D","𝘋":"D","𝘿":"D","𝙳":"D","Ꭰ":"D","ᗞ":"D","ᗪ":"D","ꓓ":"D","ɗ":"d̔","ɖ":"d̨","ƌ":"d̄","đ":"d̵","Đ":"D̵","Ð":"D̵","Ɖ":"D̵","₫":"ḏ̵","ꝺ":"Ꝺ","ᑻ":"d·","ᒇ":"d\'","ʤ":"dȝ","ǳ":"dz","ʣ":"dz","ǲ":"Dz","Ǳ":"DZ","ǆ":"dž","ǅ":"Dž","Ǆ":"DŽ","ʥ":"dʑ","ꭰ":"ᴅ","⸹":"ẟ","δ":"ẟ","𝛅":"ẟ","𝛿":"ẟ","𝜹":"ẟ","𝝳":"ẟ","𝞭":"ẟ","ծ":"ẟ","ᕷ":"ẟ","℮":"e","ｅ":"e","ℯ":"e","ⅇ":"e","𝐞":"e","𝑒":"e","𝒆":"e","𝓮":"e","𝔢":"e","𝕖":"e","𝖊":"e","𝖾":"e","𝗲":"e","𝘦":"e","𝙚":"e","𝚎":"e","ꬲ":"e","е":"e","ҽ":"e","ⷷ":"ͤ","⋿":"E","Ｅ":"E","ℰ":"E","𝐄":"E","𝐸":"E","𝑬":"E","𝓔":"E","𝔈":"E","𝔼":"E","𝕰":"E","𝖤":"E","𝗘":"E","𝘌":"E","𝙀":"E","𝙴":"E","Ε":"E","𝚬":"E","𝛦":"E","𝜠":"E","𝝚":"E","𝞔":"E","Е":"E","ⴹ":"E","Ꭼ":"E","ꓰ":"E","𑢦":"E","𑢮":"E","𐊆":"E","ě":"ĕ","Ě":"Ĕ","ɇ":"e̸","Ɇ":"E̸","ҿ":"ę","ꭼ":"ᴇ","ə":"ǝ","ә":"ǝ","∃":"Ǝ","ⴺ":"Ǝ","ꓱ":"Ǝ","ɚ":"ǝ˞","ᴔ":"ǝo","ꭁ":"ǝo̸","ꭂ":"ǝo̵","Ә":"Ə","𝈡":"Ɛ","ℇ":"Ɛ","Ԑ":"Ɛ","Ꮛ":"Ɛ","𖼭":"Ɛ","𐐁":"Ɛ","ᶟ":"ᵋ","ᴈ":"ɜ","з":"ɜ","ҙ":"ɜ̦","𐑂":"ɞ","ꞝ":"ʚ","𐐪":"ʚ","𝐟":"f","𝑓":"f","𝒇":"f","𝒻":"f","𝓯":"f","𝔣":"f","𝕗":"f","𝖋":"f","𝖿":"f","𝗳":"f","𝘧":"f","𝙛":"f","𝚏":"f","ꬵ":"f","ꞙ":"f","ſ":"f","ẝ":"f","ք":"f","𝈓":"F","ℱ":"F","𝐅":"F","𝐹":"F","𝑭":"F","𝓕":"F","𝔉":"F","𝔽":"F","𝕱":"F","𝖥":"F","𝗙":"F","𝘍":"F","𝙁":"F","𝙵":"F","Ꞙ":"F","Ϝ":"F","𝟊":"F","ᖴ":"F","ꓝ":"F","𑣂":"F","𑢢":"F","𐊇":"F","𐊥":"F","𐔥":"F","ƒ":"f̦","Ƒ":"F̦","ᵮ":"f̴","℻":"FAX","ﬀ":"ff","ﬃ":"ffi","ﬄ":"ffl","ﬁ":"fi","ﬂ":"fl","ʩ":"fŋ","ᖵ":"Ⅎ","ꓞ":"Ⅎ","𝈰":"ꟻ","ᖷ":"ꟻ","ｇ":"g","ℊ":"g","𝐠":"g","𝑔":"g","𝒈":"g","𝓰":"g","𝔤":"g","𝕘":"g","𝖌":"g","𝗀":"g","𝗴":"g","𝘨":"g","𝙜":"g","𝚐":"g","ɡ":"g","ᶃ":"g","ƍ":"g","ց":"g","𝐆":"G","𝐺":"G","𝑮":"G","𝒢":"G","𝓖":"G","𝔊":"G","𝔾":"G","𝕲":"G","𝖦":"G","𝗚":"G","𝘎":"G","𝙂":"G","𝙶":"G","Ԍ":"G","Ꮐ":"G","Ᏻ":"G","ꓖ":"G","ᶢ":"ᵍ","ɠ":"g̔","ǧ":"ğ","Ǧ":"Ğ","ǵ":"ģ","ǥ":"g̵","Ǥ":"G̵","Ɠ":"G\'","ԍ":"ɢ","ꮐ":"ɢ","ᏻ":"ɢ","ｈ":"h","ℎ":"h","𝐡":"h","𝒉":"h","𝒽":"h","𝓱":"h","𝔥":"h","𝕙":"h","𝖍":"h","𝗁":"h","𝗵":"h","𝘩":"h","𝙝":"h","𝚑":"h","һ":"h","հ":"h","Ꮒ":"h","Ｈ":"H","ℋ":"H","ℌ":"H","ℍ":"H","𝐇":"H","𝐻":"H","𝑯":"H","𝓗":"H","𝕳":"H","𝖧":"H","𝗛":"H","𝘏":"H","𝙃":"H","𝙷":"H","Η":"H","𝚮":"H","𝛨":"H","𝜢":"H","𝝜":"H","𝞖":"H","Ⲏ":"H","Н":"H","Ꮋ":"H","ᕼ":"H","ꓧ":"H","𐋏":"H","ᵸ":"ᴴ","ɦ":"h̔","ꚕ":"h̔","Ᏺ":"h̔","Ⱨ":"H̩","Ң":"H̩","ħ":"h̵","ℏ":"h̵","ћ":"h̵","Ħ":"H̵","Ӊ":"H̦","Ӈ":"H̦","н":"ʜ","ꮋ":"ʜ","ң":"ʜ̩","ӊ":"ʜ̦","ӈ":"ʜ̦","Ԋ":"Ƕ","ꮀ":"ⱶ","Ͱ":"Ⱶ","Ꭸ":"Ⱶ","Ꮀ":"Ⱶ","ꚱ":"Ⱶ","ꞕ":"ꜧ","˛":"i","⍳":"i","ｉ":"i","ⅰ":"i","ℹ":"i","ⅈ":"i","𝐢":"i","𝑖":"i","𝒊":"i","𝒾":"i","𝓲":"i","𝔦":"i","𝕚":"i","𝖎":"i","𝗂":"i","𝗶":"i","𝘪":"i","𝙞":"i","𝚒":"i","ı":"i","𝚤":"i","ɪ":"i","ɩ":"i","ι":"i","ι":"i","ͺ":"i","𝛊":"i","𝜄":"i","𝜾":"i","𝝸":"i","𝞲":"i","і":"i","ꙇ":"i","ӏ":"i","ꭵ":"i","Ꭵ":"i","𑣃":"i","ⓛ":"Ⓘ","⍸":"i̲","ǐ":"ĭ","Ǐ":"Ĭ","ɨ":"i̵","ᵻ":"i̵","ᵼ":"i̵","ⅱ":"ii","ⅲ":"iii","ĳ":"ij","ⅳ":"iv","ⅸ":"ix","ｊ":"j","ⅉ":"j","𝐣":"j","𝑗":"j","𝒋":"j","𝒿":"j","𝓳":"j","𝔧":"j","𝕛":"j","𝖏":"j","𝗃":"j","𝗷":"j","𝘫":"j","𝙟":"j","𝚓":"j","ϳ":"j","ј":"j","Ｊ":"J","𝐉":"J","𝐽":"J","𝑱":"J","𝒥":"J","𝓙":"J","𝔍":"J","𝕁":"J","𝕵":"J","𝖩":"J","𝗝":"J","𝘑":"J","𝙅":"J","𝙹":"J","Ʝ":"J","Ϳ":"J","Ј":"J","Ꭻ":"J","ᒍ":"J","ꓙ":"J","ɉ":"j̵","Ɉ":"J̵","ᒙ":"J·","𝚥":"ȷ","յ":"ȷ","ꭻ":"ᴊ","𝐤":"k","𝑘":"k","𝒌":"k","𝓀":"k","𝓴":"k","𝔨":"k","𝕜":"k","𝖐":"k","𝗄":"k","𝗸":"k","𝘬":"k","𝙠":"k","𝚔":"k","K":"K","Ｋ":"K","𝐊":"K","𝐾":"K","𝑲":"K","𝒦":"K","𝓚":"K","𝔎":"K","𝕂":"K","𝕶":"K","𝖪":"K","𝗞":"K","𝘒":"K","𝙆":"K","𝙺":"K","Κ":"K","𝚱":"K","𝛫":"K","𝜥":"K","𝝟":"K","𝞙":"K","Ⲕ":"K","К":"K","Ꮶ":"K","ᛕ":"K","ꓗ":"K","𐔘":"K","ƙ":"k̔","Ⱪ":"K̩","Қ":"K̩","₭":"K̵","Ꝁ":"K̵","Ҟ":"K̵","Ƙ":"K\'","׀":"l","|":"l","∣":"l","⏽":"l","￨":"l","١":"l","۱":"l","𐌠":"l","𞣇":"l","𝟏":"l","𝟙":"l","𝟣":"l","𝟭":"l","𝟷":"l","🯱":"l","I":"l","Ｉ":"l","Ⅰ":"l","ℐ":"l","ℑ":"l","𝐈":"l","𝐼":"l","𝑰":"l","𝓘":"l","𝕀":"l","𝕴":"l","𝖨":"l","𝗜":"l","𝘐":"l","𝙄":"l","𝙸":"l","Ɩ":"l","ｌ":"l","ⅼ":"l","ℓ":"l","𝐥":"l","𝑙":"l","𝒍":"l","𝓁":"l","𝓵":"l","𝔩":"l","𝕝":"l","𝖑":"l","𝗅":"l","𝗹":"l","𝘭":"l","𝙡":"l","𝚕":"l","ǀ":"l","Ι":"l","𝚰":"l","𝛪":"l","𝜤":"l","𝝞":"l","𝞘":"l","Ⲓ":"l","І":"l","Ӏ":"l","ו":"l","ן":"l","ا":"l","𞸀":"l","𞺀":"l","ﺎ":"l","ﺍ":"l","ߊ":"l","ⵏ":"l","ᛁ":"l","ꓲ":"l","𖼨":"l","𐊊":"l","𐌉":"l","𝈪":"L","Ⅼ":"L","ℒ":"L","𝐋":"L","𝐿":"L","𝑳":"L","𝓛":"L","𝔏":"L","𝕃":"L","𝕷":"L","𝖫":"L","𝗟":"L","𝘓":"L","𝙇":"L","𝙻":"L","Ⳑ":"L","Ꮮ":"L","ᒪ":"L","ꓡ":"L","𖼖":"L","𑢣":"L","𑢲":"L","𐐛":"L","𐔦":"L","ﴼ":"l̋","ﴽ":"l̋","ł":"l̸","Ł":"L̸","ɭ":"l̨","Ɨ":"l̵","ƚ":"l̵","ɫ":"l̴","إ":"lٕ","ﺈ":"lٕ","ﺇ":"lٕ","ٳ":"lٕ","ŀ":"l·","Ŀ":"l·","ᒷ":"l·","🄂":"l,","⒈":"l.","ױ":"l\'","⒓":"l2.","㏫":"l2日","㋋":"l2月","㍤":"l2点","⒔":"l3.","㏬":"l3日","㍥":"l3点","⒕":"l4.","㏭":"l4日","㍦":"l4点","⒖":"l5.","㏮":"l5日","㍧":"l5点","⒗":"l6.","㏯":"l6日","㍨":"l6点","⒘":"l7.","㏰":"l7日","㍩":"l7点","⒙":"l8.","㏱":"l8日","㍪":"l8点","⒚":"l9.","㏲":"l9日","㍫":"l9点","ǉ":"lj","Ĳ":"lJ","ǈ":"Lj","Ǉ":"LJ","‖":"ll","∥":"ll","Ⅱ":"ll","ǁ":"ll","װ":"ll","𐆙":"l̵l̵","⒒":"ll.","Ⅲ":"lll","𐆘":"l̵l̵S̵","㏪":"ll日","㋊":"ll月","㍣":"ll点","Ю":"lO","⒑":"lO.","㏩":"lO日","㋉":"lO月","㍢":"lO点","ʪ":"ls","₶":"lt","Ⅳ":"lV","Ⅸ":"lX","ɮ":"lȝ","ʫ":"lz","أ":"lٴ","ﺄ":"lٴ","ﺃ":"lٴ","ٲ":"lٴ","ٵ":"lٴ","ﷳ":"lكبر","ﷲ":"lللّٰo","㏠":"l日","㋀":"l月","㍙":"l点","ⳑ":"ʟ","ꮮ":"ʟ","𐑃":"ʟ","Ｍ":"M","Ⅿ":"M","ℳ":"M","𝐌":"M","𝑀":"M","𝑴":"M","𝓜":"M","𝔐":"M","𝕄":"M","𝕸":"M","𝖬":"M","𝗠":"M","𝘔":"M","𝙈":"M","𝙼":"M","Μ":"M","𝚳":"M","𝛭":"M","𝜧":"M","𝝡":"M","𝞛":"M","Ϻ":"M","Ⲙ":"M","М":"M","Ꮇ":"M","ᗰ":"M","ᛖ":"M","ꓟ":"M","𐊰":"M","𐌑":"M","Ӎ":"M̦","🝫":"MB","ⷨ":"ᷟ","𝐧":"n","𝑛":"n","𝒏":"n","𝓃":"n","𝓷":"n","𝔫":"n","𝕟":"n","𝖓":"n","𝗇":"n","𝗻":"n","𝘯":"n","𝙣":"n","𝚗":"n","ո":"n","ռ":"n","Ｎ":"N","ℕ":"N","𝐍":"N","𝑁":"N","𝑵":"N","𝒩":"N","𝓝":"N","𝔑":"N","𝕹":"N","𝖭":"N","𝗡":"N","𝘕":"N","𝙉":"N","𝙽":"N","Ν":"N","𝚴":"N","𝛮":"N","𝜨":"N","𝝢":"N","𝞜":"N","Ⲛ":"N","ꓠ":"N","𐔓":"N","𐆎":"N̊","ɳ":"n̨","ƞ":"n̩","η":"n̩","𝛈":"n̩","𝜂":"n̩","𝜼":"n̩","𝝶":"n̩","𝞰":"n̩","Ɲ":"N̦","ᵰ":"n̴","ǌ":"nj","ǋ":"Nj","Ǌ":"NJ","№":"No","ͷ":"ᴎ","и":"ᴎ","𐑍":"ᴎ","ņ":"ɲ","ం":"o","ಂ":"o","ം":"o","ං":"o","०":"o","੦":"o","૦":"o","௦":"o","౦":"o","೦":"o","൦":"o","๐":"o","໐":"o","၀":"o","٥":"o","۵":"o","ｏ":"o","ℴ":"o","𝐨":"o","𝑜":"o","𝒐":"o","𝓸":"o","𝔬":"o","𝕠":"o","𝖔":"o","𝗈":"o","𝗼":"o","𝘰":"o","𝙤":"o","𝚘":"o","ᴏ":"o","ᴑ":"o","ꬽ":"o","ο":"o","𝛐":"o","𝜊":"o","𝝄":"o","𝝾":"o","𝞸":"o","σ":"o","𝛔":"o","𝜎":"o","𝝈":"o","𝞂":"o","𝞼":"o","ⲟ":"o","о":"o","ჿ":"o","օ":"o","ס":"o","ه":"o","𞸤":"o","𞹤":"o","𞺄":"o","ﻫ":"o","ﻬ":"o","ﻪ":"o","ﻩ":"o","ھ":"o","ﮬ":"o","ﮭ":"o","ﮫ":"o","ﮪ":"o","ہ":"o","ﮨ":"o","ﮩ":"o","ﮧ":"o","ﮦ":"o","ە":"o","ഠ":"o","ဝ":"o","𐓪":"o","𑣈":"o","𑣗":"o","𐐬":"o","߀":"O","০":"O","୦":"O","〇":"O","𑓐":"O","𑣠":"O","𝟎":"O","𝟘":"O","𝟢":"O","𝟬":"O","𝟶":"O","🯰":"O","Ｏ":"O","𝐎":"O","𝑂":"O","𝑶":"O","𝒪":"O","𝓞":"O","𝔒":"O","𝕆":"O","𝕺":"O","𝖮":"O","𝗢":"O","𝘖":"O","𝙊":"O","𝙾":"O","Ο":"O","𝚶":"O","𝛰":"O","𝜪":"O","𝝤":"O","𝞞":"O","Ⲟ":"O","О":"O","Օ":"O","ⵔ":"O","ዐ":"O","ଠ":"O","𐓂":"O","ꓳ":"O","𑢵":"O","𐊒":"O","𐊫":"O","𐐄":"O","𐔖":"O","⁰":"º","ᵒ":"º","ǒ":"ŏ","Ǒ":"Ŏ","ۿ":"ô","Ő":"Ö","ø":"o̸","ꬾ":"o̸","Ø":"O̸","ⵁ":"O̸","Ǿ":"Ó̸","ɵ":"o̵","ꝋ":"o̵","ө":"o̵","ѳ":"o̵","ꮎ":"o̵","ꮻ":"o̵","⊖":"O̵","⊝":"O̵","⍬":"O̵","𝈚":"O̵","🜔":"O̵","Ɵ":"O̵","Ꝋ":"O̵","θ":"O̵","ϑ":"O̵","𝛉":"O̵","𝛝":"O̵","𝜃":"O̵","𝜗":"O̵","𝜽":"O̵","𝝑":"O̵","𝝷":"O̵","𝞋":"O̵","𝞱":"O̵","𝟅":"O̵","Θ":"O̵","ϴ":"O̵","𝚯":"O̵","𝚹":"O̵","𝛩":"O̵","𝛳":"O̵","𝜣":"O̵","𝜭":"O̵","𝝝":"O̵","𝝧":"O̵","𝞗":"O̵","𝞡":"O̵","Ө":"O̵","Ѳ":"O̵","ⴱ":"O̵","Ꮎ":"O̵","Ꮻ":"O̵","ꭴ":"ơ","ﳙ":"oٰ","🄁":"O,","🄀":"O.","ơ":"o\'","Ơ":"O\'","Ꭴ":"O\'","%":"º/₀","٪":"º/₀","⁒":"º/₀","‰":"º/₀₀","؉":"º/₀₀","‱":"º/₀₀₀","؊":"º/₀₀₀","œ":"oe","Œ":"OE","ɶ":"oᴇ","∞":"oo","ꝏ":"oo","ꚙ":"oo","Ꝏ":"OO","Ꚙ":"OO","ﳗ":"oج","ﱑ":"oج","ﳘ":"oم","ﱒ":"oم","ﶓ":"oمج","ﶔ":"oمم","ﱓ":"oى","ﱔ":"oى","ൟ":"oരo","တ":"oာ","㍘":"O点","ↄ":"ɔ","ᴐ":"ɔ","ͻ":"ɔ","𐑋":"ɔ","Ↄ":"Ɔ","Ͻ":"Ɔ","ꓛ":"Ɔ","𐐣":"Ɔ","ꬿ":"ɔ̸","ꭢ":"ɔe","𐐿":"ɷ","⍴":"p","ｐ":"p","𝐩":"p","𝑝":"p","𝒑":"p","𝓅":"p","𝓹":"p","𝔭":"p","𝕡":"p","𝖕":"p","𝗉":"p","𝗽":"p","𝘱":"p","𝙥":"p","𝚙":"p","ρ":"p","ϱ":"p","𝛒":"p","𝛠":"p","𝜌":"p","𝜚":"p","𝝆":"p","𝝔":"p","𝞀":"p","𝞎":"p","𝞺":"p","𝟈":"p","ⲣ":"p","р":"p","Ｐ":"P","ℙ":"P","𝐏":"P","𝑃":"P","𝑷":"P","𝒫":"P","𝓟":"P","𝔓":"P","𝕻":"P","𝖯":"P","𝗣":"P","𝘗":"P","𝙋":"P","𝙿":"P","Ρ":"P","𝚸":"P","𝛲":"P","𝜬":"P","𝝦":"P","𝞠":"P","Ⲣ":"P","Р":"P","Ꮲ":"P","ᑭ":"P","ꓑ":"P","𐊕":"P","ƥ":"p̔","ᵽ":"p̵","ᑷ":"p·","ᒆ":"P\'","ᴩ":"ᴘ","ꮲ":"ᴘ","φ":"ɸ","ϕ":"ɸ","𝛗":"ɸ","𝛟":"ɸ","𝜑":"ɸ","𝜙":"ɸ","𝝋":"ɸ","𝝓":"ɸ","𝞅":"ɸ","𝞍":"ɸ","𝞿":"ɸ","𝟇":"ɸ","ⲫ":"ɸ","ф":"ɸ","𝐪":"q","𝑞":"q","𝒒":"q","𝓆":"q","𝓺":"q","𝔮":"q","𝕢":"q","𝖖":"q","𝗊":"q","𝗾":"q","𝘲":"q","𝙦":"q","𝚚":"q","ԛ":"q","գ":"q","զ":"q","ℚ":"Q","𝐐":"Q","𝑄":"Q","𝑸":"Q","𝒬":"Q","𝓠":"Q","𝔔":"Q","𝕼":"Q","𝖰":"Q","𝗤":"Q","𝘘":"Q","𝙌":"Q","𝚀":"Q","ⵕ":"Q","ʠ":"q̔","🜀":"QE","ᶐ":"ɋ","ᴋ":"ĸ","κ":"ĸ","ϰ":"ĸ","𝛋":"ĸ","𝛞":"ĸ","𝜅":"ĸ","𝜘":"ĸ","𝜿":"ĸ","𝝒":"ĸ","𝝹":"ĸ","𝞌":"ĸ","𝞳":"ĸ","𝟆":"ĸ","ⲕ":"ĸ","к":"ĸ","ꮶ":"ĸ","қ":"ĸ̩","ҟ":"ĸ̵","𝐫":"r","𝑟":"r","𝒓":"r","𝓇":"r","𝓻":"r","𝔯":"r","𝕣":"r","𝖗":"r","𝗋":"r","𝗿":"r","𝘳":"r","𝙧":"r","𝚛":"r","ꭇ":"r","ꭈ":"r","ᴦ":"r","ⲅ":"r","г":"r","ꮁ":"r","𝈖":"R","ℛ":"R","ℜ":"R","ℝ":"R","𝐑":"R","𝑅":"R","𝑹":"R","𝓡":"R","𝕽":"R","𝖱":"R","𝗥":"R","𝘙":"R","𝙍":"R","𝚁":"R","Ʀ":"R","Ꭱ":"R","Ꮢ":"R","𐒴":"R","ᖇ":"R","ꓣ":"R","𖼵":"R","ɽ":"r̨","ɼ":"r̩","ɍ":"r̵","ғ":"r̵","ᵲ":"r̴","ґ":"r\'","𑣣":"rn","m":"rn","ⅿ":"rn","𝐦":"rn","𝑚":"rn","𝒎":"rn","𝓂":"rn","𝓶":"rn","𝔪":"rn","𝕞":"rn","𝖒":"rn","𝗆":"rn","𝗺":"rn","𝘮":"rn","𝙢":"rn","𝚖":"rn","𑜀":"rn","₥":"rn̸","ɱ":"rn̦","ᵯ":"rn̴","₨":"Rs","ꭱ":"ʀ","ꮢ":"ʀ","я":"ᴙ","ᵳ":"ɾ̴","℩":"ɿ","ｓ":"s","𝐬":"s","𝑠":"s","𝒔":"s","𝓈":"s","𝓼":"s","𝔰":"s","𝕤":"s","𝖘":"s","𝗌":"s","𝘀":"s","𝘴":"s","𝙨":"s","𝚜":"s","ꜱ":"s","ƽ":"s","ѕ":"s","ꮪ":"s","𑣁":"s","𐑈":"s","Ｓ":"S","𝐒":"S","𝑆":"S","𝑺":"S","𝒮":"S","𝓢":"S","𝔖":"S","𝕊":"S","𝕾":"S","𝖲":"S","𝗦":"S","𝘚":"S","𝙎":"S","𝚂":"S","Ѕ":"S","Տ":"S","Ꮥ":"S","Ꮪ":"S","ꓢ":"S","𖼺":"S","𐊖":"S","𐐠":"S","ʂ":"s̨","ᵴ":"s̴","ꞵ":"ß","β":"ß","ϐ":"ß","𝛃":"ß","𝛽":"ß","𝜷":"ß","𝝱":"ß","𝞫":"ß","Ᏸ":"ß","🝜":"sss","ﬆ":"st","∫":"ʃ","ꭍ":"ʃ","∑":"Ʃ","⅀":"Ʃ","Σ":"Ʃ","𝚺":"Ʃ","𝛴":"Ʃ","𝜮":"Ʃ","𝝨":"Ʃ","𝞢":"Ʃ","ⵉ":"Ʃ","∬":"ʃʃ","∭":"ʃʃʃ","⨌":"ʃʃʃʃ","𝐭":"t","𝑡":"t","𝒕":"t","𝓉":"t","𝓽":"t","𝔱":"t","𝕥":"t","𝖙":"t","𝗍":"t","𝘁":"t","𝘵":"t","𝙩":"t","𝚝":"t","⊤":"T","⟙":"T","🝨":"T","Ｔ":"T","𝐓":"T","𝑇":"T","𝑻":"T","𝒯":"T","𝓣":"T","𝔗":"T","𝕋":"T","𝕿":"T","𝖳":"T","𝗧":"T","𝘛":"T","𝙏":"T","𝚃":"T","Τ":"T","𝚻":"T","𝛵":"T","𝜯":"T","𝝩":"T","𝞣":"T","Ⲧ":"T","Т":"T","Ꭲ":"T","ꓔ":"T","𖼊":"T","𑢼":"T","𐊗":"T","𐊱":"T","𐌕":"T","ƭ":"t̔","⍡":"T̈","Ⱦ":"T̸","Ț":"Ţ","Ʈ":"T̨","Ҭ":"T̩","₮":"T⃫","ŧ":"t̵","Ŧ":"T̵","ᵵ":"t̴","Ⴀ":"Ꞇ","Ꜩ":"T3","ʨ":"tɕ","℡":"TEL","ꝷ":"tf","ʦ":"ts","ʧ":"tʃ","ꜩ":"tȝ","τ":"ᴛ","𝛕":"ᴛ","𝜏":"ᴛ","𝝉":"ᴛ","𝞃":"ᴛ","𝞽":"ᴛ","т":"ᴛ","ꭲ":"ᴛ","ҭ":"ᴛ̩","ţ":"ƫ","ț":"ƫ","Ꮏ":"ƫ","𝐮":"u","𝑢":"u","𝒖":"u","𝓊":"u","𝓾":"u","𝔲":"u","𝕦":"u","𝖚":"u","𝗎":"u","𝘂":"u","𝘶":"u","𝙪":"u","𝚞":"u","ꞟ":"u","ᴜ":"u","ꭎ":"u","ꭒ":"u","ʋ":"u","υ":"u","𝛖":"u","𝜐":"u","𝝊":"u","𝞄":"u","𝞾":"u","ս":"u","𐓶":"u","𑣘":"u","∪":"U","⋃":"U","𝐔":"U","𝑈":"U","𝑼":"U","𝒰":"U","𝓤":"U","𝔘":"U","𝕌":"U","𝖀":"U","𝖴":"U","𝗨":"U","𝘜":"U","𝙐":"U","𝚄":"U","Ս":"U","ሀ":"U","𐓎":"U","ᑌ":"U","ꓴ":"U","𖽂":"U","𑢸":"U","ǔ":"ŭ","Ǔ":"Ŭ","ᵾ":"u̵","ꮜ":"u̵","Ʉ":"U̵","Ꮜ":"U̵","ᑘ":"U·","ᑧ":"U\'","ᵫ":"ue","ꭣ":"uo","ṃ":"ꭑ","պ":"ɰ","ሣ":"ɰ","℧":"Ʊ","ᘮ":"Ʊ","ᘴ":"Ʊ","ᵿ":"ʊ̵","∨":"v","⋁":"v","ｖ":"v","ⅴ":"v","𝐯":"v","𝑣":"v","𝒗":"v","𝓋":"v","𝓿":"v","𝔳":"v","𝕧":"v","𝖛":"v","𝗏":"v","𝘃":"v","𝘷":"v","𝙫":"v","𝚟":"v","ᴠ":"v","ν":"v","𝛎":"v","𝜈":"v","𝝂":"v","𝝼":"v","𝞶":"v","ѵ":"v","ט":"v","𑜆":"v","ꮩ":"v","𑣀":"v","𝈍":"V","٧":"V","۷":"V","Ⅴ":"V","𝐕":"V","𝑉":"V","𝑽":"V","𝒱":"V","𝓥":"V","𝔙":"V","𝕍":"V","𝖁":"V","𝖵":"V","𝗩":"V","𝘝":"V","𝙑":"V","𝚅":"V","Ѵ":"V","ⴸ":"V","Ꮩ":"V","ᐯ":"V","ꛟ":"V","ꓦ":"V","𖼈":"V","𑢠":"V","𐔝":"V","𐆗":"V̵","ᐻ":"V·","🝬":"VB","ⅵ":"vi","ⅶ":"vii","ⅷ":"viii","Ⅵ":"Vl","Ⅶ":"Vll","Ⅷ":"Vlll","🜈":"Vᷤ","ᴧ":"ʌ","𐓘":"ʌ","٨":"Ʌ","۸":"Ʌ","Λ":"Ʌ","𝚲":"Ʌ","𝛬":"Ʌ","𝜦":"Ʌ","𝝠":"Ʌ","𝞚":"Ʌ","Л":"Ʌ","ⴷ":"Ʌ","𐒰":"Ʌ","ᐱ":"Ʌ","ꛎ":"Ʌ","ꓥ":"Ʌ","𖼽":"Ʌ","𐊍":"Ʌ","Ӆ":"Ʌ̦","ᐽ":"Ʌ·","ɯ":"w","𝐰":"w","𝑤":"w","𝒘":"w","𝓌":"w","𝔀":"w","𝔴":"w","𝕨":"w","𝖜":"w","𝗐":"w","𝘄":"w","𝘸":"w","𝙬":"w","𝚠":"w","ᴡ":"w","ѡ":"w","ԝ":"w","ա":"w","𑜊":"w","𑜎":"w","𑜏":"w","ꮃ":"w","𑣯":"W","𑣦":"W","𝐖":"W","𝑊":"W","𝑾":"W","𝒲":"W","𝓦":"W","𝔚":"W","𝕎":"W","𝖂":"W","𝖶":"W","𝗪":"W","𝘞":"W","𝙒":"W","𝚆":"W","Ԝ":"W","Ꮃ":"W","Ꮤ":"W","ꓪ":"W","ѽ":"w҆҇","𑓅":"ẇ","₩":"W̵","ꝡ":"w̦","ᴍ":"ʍ","м":"ʍ","ꮇ":"ʍ","ӎ":"ʍ̦","᙮":"x","×":"x","⤫":"x","⤬":"x","⨯":"x","ｘ":"x","ⅹ":"x","𝐱":"x","𝑥":"x","𝒙":"x","𝓍":"x","𝔁":"x","𝔵":"x","𝕩":"x","𝖝":"x","𝗑":"x","𝘅":"x","𝘹":"x","𝙭":"x","𝚡":"x","х":"x","ᕁ":"x","ᕽ":"x","ⷯ":"ͯ","᙭":"X","╳":"X","𐌢":"X","𑣬":"X","Ｘ":"X","Ⅹ":"X","𝐗":"X","𝑋":"X","𝑿":"X","𝒳":"X","𝓧":"X","𝔛":"X","𝕏":"X","𝖃":"X","𝖷":"X","𝗫":"X","𝘟":"X","𝙓":"X","𝚇":"X","Ꭓ":"X","Χ":"X","𝚾":"X","𝛸":"X","𝜲":"X","𝝬":"X","𝞦":"X","Ⲭ":"X","Х":"X","ⵝ":"X","ᚷ":"X","ꓫ":"X","𐊐":"X","𐊴":"X","𐌗":"X","𐔧":"X","⨰":"ẋ","Ҳ":"X̩","𐆖":"X̵","ⅺ":"xi","ⅻ":"xii","Ⅺ":"Xl","Ⅻ":"Xll","ɣ":"y","ᶌ":"y","ｙ":"y","𝐲":"y","𝑦":"y","𝒚":"y","𝓎":"y","𝔂":"y","𝔶":"y","𝕪":"y","𝖞":"y","𝗒":"y","𝘆":"y","𝘺":"y","𝙮":"y","𝚢":"y","ʏ":"y","ỿ":"y","ꭚ":"y","γ":"y","ℽ":"y","𝛄":"y","𝛾":"y","𝜸":"y","𝝲":"y","𝞬":"y","у":"y","ү":"y","ყ":"y","𑣜":"y","Ｙ":"Y","𝐘":"Y","𝑌":"Y","𝒀":"Y","𝒴":"Y","𝓨":"Y","𝔜":"Y","𝕐":"Y","𝖄":"Y","𝖸":"Y","𝗬":"Y","𝘠":"Y","𝙔":"Y","𝚈":"Y","Υ":"Y","ϒ":"Y","𝚼":"Y","𝛶":"Y","𝜰":"Y","𝝪":"Y","𝞤":"Y","Ⲩ":"Y","У":"Y","Ү":"Y","Ꭹ":"Y","Ꮍ":"Y","ꓬ":"Y","𖽃":"Y","𑢤":"Y","𐊲":"Y","ƴ":"y̔","ɏ":"y̵","ұ":"y̵","¥":"Y̵","Ɏ":"Y̵","Ұ":"Y̵","ʒ":"ȝ","ꝫ":"ȝ","ⳍ":"ȝ","ӡ":"ȝ","ჳ":"ȝ","𝐳":"z","𝑧":"z","𝒛":"z","𝓏":"z","𝔃":"z","𝔷":"z","𝕫":"z","𝖟":"z","𝗓":"z","𝘇":"z","𝘻":"z","𝙯":"z","𝚣":"z","ᴢ":"z","ꮓ":"z","𑣄":"z","𐋵":"Z","𑣥":"Z","Ｚ":"Z","ℤ":"Z","ℨ":"Z","𝐙":"Z","𝑍":"Z","𝒁":"Z","𝒵":"Z","𝓩":"Z","𝖅":"Z","𝖹":"Z","𝗭":"Z","𝘡":"Z","𝙕":"Z","𝚉":"Z","Ζ":"Z","𝚭":"Z","𝛧":"Z","𝜡":"Z","𝝛":"Z","𝞕":"Z","Ꮓ":"Z","ꓜ":"Z","𑢩":"Z","ʐ":"z̨","ƶ":"z̵","Ƶ":"Z̵","ȥ":"z̦","Ȥ":"Z̦","ᵶ":"z̴","ƿ":"þ","ϸ":"þ","Ϸ":"Þ","𐓄":"Þ","⁹":"ꝰ","ᴤ":"ƨ","ϩ":"ƨ","ꙅ":"ƨ","ь":"ƅ","ꮟ":"ƅ","ы":"ƅi","ꭾ":"ɂ","ˤ":"ˁ","ꛍ":"ʡ","⊙":"ʘ","☉":"ʘ","⨀":"ʘ","Ꙩ":"ʘ","ⵙ":"ʘ","𐓃":"ʘ","ℾ":"Γ","𝚪":"Γ","𝛤":"Γ","𝜞":"Γ","𝝘":"Γ","𝞒":"Γ","Ⲅ":"Γ","Г":"Γ","Ꮁ":"Γ","ᒥ":"Γ","𖼇":"Γ","Ғ":"Γ̵","ᒯ":"Γ·","Ґ":"Γ\'","∆":"Δ","△":"Δ","🜂":"Δ","𝚫":"Δ","𝛥":"Δ","𝜟":"Δ","𝝙":"Δ","𝞓":"Δ","Ⲇ":"Δ","ⵠ":"Δ","ᐃ":"Δ","𖼚":"Δ","𐊅":"Δ","𐊣":"Δ","⍙":"Δ̲","ᐏ":"Δ·","ᐬ":"Δᐠ","𝟋":"ϝ","𝛇":"ζ","𝜁":"ζ","𝜻":"ζ","𝝵":"ζ","𝞯":"ζ","ⳤ":"ϗ","𝛌":"λ","𝜆":"λ","𝝀":"λ","𝝺":"λ","𝞴":"λ","Ⲗ":"λ","𐓛":"λ","µ":"μ","𝛍":"μ","𝜇":"μ","𝝁":"μ","𝝻":"μ","𝞵":"μ","𝛏":"ξ","𝜉":"ξ","𝝃":"ξ","𝝽":"ξ","𝞷":"ξ","𝚵":"Ξ","𝛯":"Ξ","𝜩":"Ξ","𝝣":"Ξ","𝞝":"Ξ","ϖ":"π","ℼ":"π","𝛑":"π","𝛡":"π","𝜋":"π","𝜛":"π","𝝅":"π","𝝕":"π","𝝿":"π","𝞏":"π","𝞹":"π","𝟉":"π","ᴨ":"π","п":"π","∏":"Π","ℿ":"Π","𝚷":"Π","𝛱":"Π","𝜫":"Π","𝝥":"Π","𝞟":"Π","Ⲡ":"Π","П":"Π","ꛛ":"Π","𐊭":"Ϙ","𐌒":"Ϙ","ϛ":"ς","𝛓":"ς","𝜍":"ς","𝝇":"ς","𝞁":"ς","𝞻":"ς","𝚽":"Φ","𝛷":"Φ","𝜱":"Φ","𝝫":"Φ","𝞥":"Φ","Ⲫ":"Φ","Ф":"Φ","Փ":"Φ","ቀ":"Φ","ᛰ":"Φ","𐊳":"Φ","ꭓ":"χ","ꭕ":"χ","𝛘":"χ","𝜒":"χ","𝝌":"χ","𝞆":"χ","𝟀":"χ","ⲭ":"χ","𝛙":"ψ","𝜓":"ψ","𝝍":"ψ","𝞇":"ψ","𝟁":"ψ","ѱ":"ψ","𐓹":"ψ","𝚿":"Ψ","𝛹":"Ψ","𝜳":"Ψ","𝝭":"Ψ","𝞧":"Ψ","Ⲯ":"Ψ","Ѱ":"Ψ","𐓑":"Ψ","ᛘ":"Ψ","𐊵":"Ψ","⍵":"ω","ꞷ":"ω","𝛚":"ω","𝜔":"ω","𝝎":"ω","𝞈":"ω","𝟂":"ω","ⲱ":"ω","ꙍ":"ω","Ω":"Ω","𝛀":"Ω","𝛺":"Ω","𝜴":"Ω","𝝮":"Ω","𝞨":"Ω","ᘯ":"Ω","ᘵ":"Ω","𐊶":"Ω","⍹":"ω̲","ώ":"ῴ","☰":"Ⲷ","Ⳝ":"Ϭ","җ":"ж̩","Җ":"Ж̩","𝈋":"И","Ͷ":"И","ꚡ":"И","𐐥":"И","Й":"Ѝ","Ҋ":"Ѝ̦","ѝ":"й","ҋ":"й̦","𐒼":"Ӄ","ᴫ":"л","ӆ":"л̦","ꭠ":"љ","𐓫":"ꙩ","ᷮ":"ⷬ","𐓍":"Ћ","𝈂":"Ӿ","𝈢":"Ѡ","Ꮗ":"Ѡ","ᗯ":"Ѡ","Ѽ":"Ѡ҆҇","ᣭ":"Ѡ·","Ꞷ":"Ꙍ","ӌ":"ҷ","Ӌ":"Ҷ","Ҿ":"Ҽ̨","ⲽ":"ш","Ⲽ":"Ш","Ꙑ":"Ъl","℈":"Э","🜁":"Ꙙ","𖼜":"Ꙙ","ꦒ":"ⰿ","և":"եւ","ኔ":"ձ","ﬔ":"մե","ﬕ":"մի","ﬗ":"մխ","ﬓ":"մն","∩":"Ո","⋂":"Ո","𝉅":"Ո","በ":"Ո","ᑎ":"Ո","ꓵ":"Ո","ᑚ":"Ո·","ᑨ":"Ո\'","ﬖ":"վն","₽":"Ք","˓":"ՙ","ʿ":"ՙ","ℵ":"א","ﬡ":"א","אָ":"אַ","אּ":"אַ","ﭏ":"אל","ℶ":"ב","ℷ":"ג","ℸ":"ד","ﬢ":"ד","ﬣ":"ה","יּ":"יִ","ﬤ":"כ","ﬥ":"ל","ﬦ":"ם","ﬠ":"ע","ﬧ":"ר","שׂ":"שׁ","שּ":"שׁ","שּׂ":"שּׁ","ﬨ":"ת","ﺀ":"ء","۽":"ء͈","ﺂ":"آ","ﺁ":"آ","ﭑ":"ٱ","ﭐ":"ٱ","𞸁":"ب","𞸡":"ب","𞹡":"ب","𞺁":"ب","𞺡":"ب","ﺑ":"ب","ﺒ":"ب","ﺐ":"ب","ﺏ":"ب","ݑ":"بۛ","ࢶ":"بۢ","ࢡ":"بٔ","ﲠ":"بo","ﳢ":"بo","ﲜ":"بج","ﰅ":"بج","ﲝ":"بح","ﰆ":"بح","ﷂ":"بحى","ﲞ":"بخ","ﰇ":"بخ","ﳒ":"بخ","ﱋ":"بخ","ﶞ":"بخى","ﱪ":"بر","ﱫ":"بز","ﲟ":"بم","ﳡ":"بم","ﱬ":"بم","ﰈ":"بم","ﱭ":"بن","ﱮ":"بى","ﰉ":"بى","ﱯ":"بى","ﰊ":"بى","ﭔ":"ٻ","ﭕ":"ٻ","ﭓ":"ٻ","ﭒ":"ٻ","ې":"ٻ","ﯦ":"ٻ","ﯧ":"ٻ","ﯥ":"ٻ","ﯤ":"ٻ","ﭜ":"ڀ","ﭝ":"ڀ","ﭛ":"ڀ","ﭚ":"ڀ","ࢩ":"ݔ","ݧ":"ݔ","⍥":"ة","ö":"ة","ﺔ":"ة","ﺓ":"ة","ۃ":"ة","𞸕":"ت","𞸵":"ت","𞹵":"ت","𞺕":"ت","𞺵":"ت","ﺗ":"ت","ﺘ":"ت","ﺖ":"ت","ﺕ":"ت","ﲥ":"تo","ﳤ":"تo","ﲡ":"تج","ﰋ":"تج","ﵐ":"تجم","ﶠ":"تجى","ﶟ":"تجى","ﲢ":"تح","ﰌ":"تح","ﵒ":"تحج","ﵑ":"تحج","ﵓ":"تحم","ﲣ":"تخ","ﰍ":"تخ","ﵔ":"تخم","ﶢ":"تخى","ﶡ":"تخى","ﱰ":"تر","ﱱ":"تز","ﲤ":"تم","ﳣ":"تم","ﱲ":"تم","ﰎ":"تم","ﵕ":"تمج","ﵖ":"تمح","ﵗ":"تمخ","ﶤ":"تمى","ﶣ":"تمى","ﱳ":"تن","ﱴ":"تى","ﰏ":"تى","ﱵ":"تى","ﰐ":"تى","ﭠ":"ٺ","ﭡ":"ٺ","ﭟ":"ٺ","ﭞ":"ٺ","ﭤ":"ٿ","ﭥ":"ٿ","ﭣ":"ٿ","ﭢ":"ٿ","𞸂":"ج","𞸢":"ج","𞹂":"ج","𞹢":"ج","𞺂":"ج","𞺢":"ج","ﺟ":"ج","ﺠ":"ج","ﺞ":"ج","ﺝ":"ج","ﲧ":"جح","ﰕ":"جح","ﶦ":"جحى","ﶾ":"جحى","ﷻ":"جل جلlلo","ﲨ":"جم","ﰖ":"جم","ﵙ":"جمح","ﵘ":"جمح","ﶧ":"جمى","ﶥ":"جمى","ﴝ":"جى","ﴁ":"جى","ﴞ":"جى","ﴂ":"جى","ﭸ":"ڃ","ﭹ":"ڃ","ﭷ":"ڃ","ﭶ":"ڃ","ﭴ":"ڄ","ﭵ":"ڄ","ﭳ":"ڄ","ﭲ":"ڄ","ﭼ":"چ","ﭽ":"چ","ﭻ":"چ","ﭺ":"چ","ﮀ":"ڇ","ﮁ":"ڇ","ﭿ":"ڇ","ﭾ":"ڇ","𞸇":"ح","𞸧":"ح","𞹇":"ح","𞹧":"ح","𞺇":"ح","𞺧":"ح","ﺣ":"ح","ﺤ":"ح","ﺢ":"ح","ﺡ":"ح","څ":"حۛ","ځ":"حٔ","ݲ":"حٔ","ﲩ":"حج","ﰗ":"حج","ﶿ":"حجى","ﲪ":"حم","ﰘ":"حم","ﵛ":"حمى","ﵚ":"حمى","ﴛ":"حى","ﳿ":"حى","ﴜ":"حى","ﴀ":"حى","𞸗":"خ","𞸷":"خ","𞹗":"خ","𞹷":"خ","𞺗":"خ","𞺷":"خ","ﺧ":"خ","ﺨ":"خ","ﺦ":"خ","ﺥ":"خ","ﲫ":"خج","ﰙ":"خج","ﰚ":"خح","ﲬ":"خم","ﰛ":"خم","ﴟ":"خى","ﴃ":"خى","ﴠ":"خى","ﴄ":"خى","𐋡":"د","𞸃":"د","𞺃":"د","𞺣":"د","ﺪ":"د","ﺩ":"د","ڈ":"دؕ","ﮉ":"دؕ","ﮈ":"دؕ","ڎ":"دۛ","ﮇ":"دۛ","ﮆ":"دۛ","ۮ":"د̂","ࢮ":"د̤̣","𞸘":"ذ","𞺘":"ذ","𞺸":"ذ","ﺬ":"ذ","ﺫ":"ذ","ﱛ":"ذٰ","ڋ":"ڊؕ","ﮅ":"ڌ","ﮄ":"ڌ","ﮃ":"ڍ","ﮂ":"ڍ","𞸓":"ر","𞺓":"ر","𞺳":"ر","ﺮ":"ر","ﺭ":"ر","ڑ":"رؕ","ﮍ":"رؕ","ﮌ":"رؕ","ژ":"رۛ","ﮋ":"رۛ","ﮊ":"رۛ","ڒ":"ر̆","ࢹ":"ر̆̇","ۯ":"ر̂","ݬ":"رٔ","ﱜ":"رٰ","ﷶ":"رسول","﷼":"رىlل","𞸆":"ز","𞺆":"ز","𞺦":"ز","ﺰ":"ز","ﺯ":"ز","ࢲ":"ز̂","ݱ":"ڗؕ","𞸎":"س","𞸮":"س","𞹎":"س","𞹮":"س","𞺎":"س","𞺮":"س","ﺳ":"س","ﺴ":"س","ﺲ":"س","ﺱ":"س","ش":"سۛ","𞸔":"سۛ","𞸴":"سۛ","𞹔":"سۛ","𞹴":"سۛ","𞺔":"سۛ","𞺴":"سۛ","ﺷ":"سۛ","ﺸ":"سۛ","ﺶ":"سۛ","ﺵ":"سۛ","ݾ":"س̂","ﴱ":"سo","ﳨ":"سo","ﴲ":"سۛo","ﳪ":"سۛo","ﲭ":"سج","ﴴ":"سج","ﰜ":"سج","ﴭ":"سۛج","ﴷ":"سۛج","ﴥ":"سۛج","ﴉ":"سۛج","ﵝ":"سجح","ﵞ":"سجى","ﵩ":"سۛجى","ﲮ":"سح","ﴵ":"سح","ﰝ":"سح","ﴮ":"سۛح","ﴸ":"سۛح","ﴦ":"سۛح","ﴊ":"سۛح","ﵜ":"سحج","ﵨ":"سۛحم","ﵧ":"سۛحم","ﶪ":"سۛحى","ﲯ":"سخ","ﴶ":"سخ","ﰞ":"سخ","ﴯ":"سۛخ","ﴹ":"سۛخ","ﴧ":"سۛخ","ﴋ":"سۛخ","ﶨ":"سخى","ﷆ":"سخى","ﴪ":"سر","ﴎ":"سر","ﴩ":"سۛر","ﴍ":"سۛر","ﲰ":"سم","ﳧ":"سم","ﰟ":"سم","ﴰ":"سۛم","ﳩ":"سۛم","ﴨ":"سۛم","ﴌ":"سۛم","ﵡ":"سمج","ﵠ":"سمح","ﵟ":"سمح","ﵫ":"سۛمخ","ﵪ":"سۛمخ","ﵣ":"سمم","ﵢ":"سمم","ﵭ":"سۛمم","ﵬ":"سۛمم","ﴗ":"سى","ﳻ":"سى","ﴘ":"سى","ﳼ":"سى","ﴙ":"سۛى","ﳽ":"سۛى","ﴚ":"سۛى","ﳾ":"سۛى","𐋲":"ص","𞸑":"ص","𞸱":"ص","𞹑":"ص","𞹱":"ص","𞺑":"ص","𞺱":"ص","ﺻ":"ص","ﺼ":"ص","ﺺ":"ص","ﺹ":"ص","ڞ":"صۛ","ࢯ":"ص̤̣","ﲱ":"صح","ﰠ":"صح","ﵥ":"صحح","ﵤ":"صحح","ﶩ":"صحى","ﲲ":"صخ","ﴫ":"صر","ﴏ":"صر","ﷵ":"صلعم","ﷹ":"صلى","ﷰ":"صلى","ﷺ":"صلى lللo علىo وسلم","ﲳ":"صم","ﰡ":"صم","ﷅ":"صمم","ﵦ":"صمم","ﴡ":"صى","ﴅ":"صى","ﴢ":"صى","ﴆ":"صى","𞸙":"ض","𞸹":"ض","𞹙":"ض","𞹹":"ض","𞺙":"ض","𞺹":"ض","ﺿ":"ض","ﻀ":"ض","ﺾ":"ض","ﺽ":"ض","ﲴ":"ضج","ﰢ":"ضج","ﲵ":"ضح","ﰣ":"ضح","ﵮ":"ضحى","ﶫ":"ضحى","ﲶ":"ضخ","ﰤ":"ضخ","ﵰ":"ضخم","ﵯ":"ضخم","ﴬ":"ضر","ﴐ":"ضر","ﲷ":"ضم","ﰥ":"ضم","ﴣ":"ضى","ﴇ":"ضى","ﴤ":"ضى","ﴈ":"ضى","𐋨":"ط","𞸈":"ط","𞹨":"ط","𞺈":"ط","𞺨":"ط","ﻃ":"ط","ﻄ":"ط","ﻂ":"ط","ﻁ":"ط","ڟ":"طۛ","ﲸ":"طح","ﰦ":"طح","ﴳ":"طم","ﴺ":"طم","ﰧ":"طم","ﵲ":"طمح","ﵱ":"طمح","ﵳ":"طمم","ﵴ":"طمى","ﴑ":"طى","ﳵ":"طى","ﴒ":"طى","ﳶ":"طى","𞸚":"ظ","𞹺":"ظ","𞺚":"ظ","𞺺":"ظ","ﻇ":"ظ","ﻈ":"ظ","ﻆ":"ظ","ﻅ":"ظ","ﲹ":"ظم","ﴻ":"ظم","ﰨ":"ظم","؏":"ع","𞸏":"ع","𞸯":"ع","𞹏":"ع","𞹯":"ع","𞺏":"ع","𞺯":"ع","ﻋ":"ع","ﻌ":"ع","ﻊ":"ع","ﻉ":"ع","ﲺ":"عج","ﰩ":"عج","ﷄ":"عجم","ﵵ":"عجم","ﷷ":"علىo","ﲻ":"عم","ﰪ":"عم","ﵷ":"عمم","ﵶ":"عمم","ﵸ":"عمى","ﶶ":"عمى","ﴓ":"عى","ﳷ":"عى","ﴔ":"عى","ﳸ":"عى","𞸛":"غ","𞸻":"غ","𞹛":"غ","𞹻":"غ","𞺛":"غ","𞺻":"غ","ﻏ":"غ","ﻐ":"غ","ﻎ":"غ","ﻍ":"غ","ﲼ":"غج","ﰫ":"غج","ﲽ":"غم","ﰬ":"غم","ﵹ":"غمم","ﵻ":"غمى","ﵺ":"غمى","ﴕ":"غى","ﳹ":"غى","ﴖ":"غى","ﳺ":"غى","𞸐":"ف","𞸰":"ف","𞹰":"ف","𞺐":"ف","𞺰":"ف","ﻓ":"ف","ﻔ":"ف","ﻒ":"ف","ﻑ":"ف","ڧ":"ف","ﲾ":"فج","ﰭ":"فج","ﲿ":"فح","ﰮ":"فح","ﳀ":"فخ","ﰯ":"فخ","ﵽ":"فخم","ﵼ":"فخم","ﳁ":"فم","ﰰ":"فم","ﷁ":"فمى","ﱼ":"فى","ﰱ":"فى","ﱽ":"فى","ﰲ":"فى","𞸞":"ڡ","𞹾":"ڡ","ࢻ":"ڡ","ٯ":"ڡ","𞸟":"ڡ","𞹟":"ڡ","ࢼ":"ڡ","ڤ":"ڡۛ","ﭬ":"ڡۛ","ﭭ":"ڡۛ","ﭫ":"ڡۛ","ﭪ":"ڡۛ","ڨ":"ڡۛ","ࢤ":"ڢۛ","ﭰ":"ڦ","ﭱ":"ڦ","ﭯ":"ڦ","ﭮ":"ڦ","𞸒":"ق","𞸲":"ق","𞹒":"ق","𞹲":"ق","𞺒":"ق","𞺲":"ق","ﻗ":"ق","ﻘ":"ق","ﻖ":"ق","ﻕ":"ق","ﳂ":"قح","ﰳ":"قح","ﷱ":"قلى","ﳃ":"قم","ﰴ":"قم","ﶴ":"قمح","ﵾ":"قمح","ﵿ":"قمم","ﶲ":"قمى","ﱾ":"قى","ﰵ":"قى","ﱿ":"قى","ﰶ":"قى","𞸊":"ك","𞸪":"ك","𞹪":"ك","ﻛ":"ك","ﻜ":"ك","ﻚ":"ك","ﻙ":"ك","ک":"ك","ﮐ":"ك","ﮑ":"ك","ﮏ":"ك","ﮎ":"ك","ڪ":"ك","ڭ":"كۛ","ﯕ":"كۛ","ﯖ":"كۛ","ﯔ":"كۛ","ﯓ":"كۛ","ݣ":"كۛ","ﲀ":"كl","ﰷ":"كl","ﳄ":"كج","ﰸ":"كج","ﳅ":"كح","ﰹ":"كح","ﳆ":"كخ","ﰺ":"كخ","ﳇ":"كل","ﳫ":"كل","ﲁ":"كل","ﰻ":"كل","ﳈ":"كم","ﳬ":"كم","ﲂ":"كم","ﰼ":"كم","ﷃ":"كمم","ﶻ":"كمم","ﶷ":"كمى","ﲃ":"كى","ﰽ":"كى","ﲄ":"كى","ﰾ":"كى","ݢ":"ڬ","ﮔ":"گ","ﮕ":"گ","ﮓ":"گ","ﮒ":"گ","ࢰ":"گ","ڴ":"گۛ","ﮜ":"ڱ","ﮝ":"ڱ","ﮛ":"ڱ","ﮚ":"ڱ","ﮘ":"ڳ","ﮙ":"ڳ","ﮗ":"ڳ","ﮖ":"ڳ","𞸋":"ل","𞸫":"ل","𞹋":"ل","𞺋":"ل","𞺫":"ل","ﻟ":"ل","ﻠ":"ل","ﻞ":"ل","ﻝ":"ل","ڷ":"لۛ","ڵ":"ل̆","ﻼ":"لl","ﻻ":"لl","ﻺ":"لlٕ","ﻹ":"لlٕ","ﻸ":"لlٴ","ﻷ":"لlٴ","ﳍ":"لo","ﻶ":"لآ","ﻵ":"لآ","ﳉ":"لج","ﰿ":"لج","ﶃ":"لجج","ﶄ":"لجج","ﶺ":"لجم","ﶼ":"لجم","ﶬ":"لجى","ﳊ":"لح","ﱀ":"لح","ﶵ":"لحم","ﶀ":"لحم","ﶂ":"لحى","ﶁ":"لحى","ﳋ":"لخ","ﱁ":"لخ","ﶆ":"لخم","ﶅ":"لخم","ﳌ":"لم","ﳭ":"لم","ﲅ":"لم","ﱂ":"لم","ﶈ":"لمح","ﶇ":"لمح","ﶭ":"لمى","ﲆ":"لى","ﱃ":"لى","ﲇ":"لى","ﱄ":"لى","𞸌":"م","𞸬":"م","𞹬":"م","𞺌":"م","𞺬":"م","ﻣ":"م","ﻤ":"م","ﻢ":"م","ﻡ":"م","ࢧ":"مۛ","۾":"م͈","ﲈ":"مl","ﳎ":"مج","ﱅ":"مج","ﶌ":"مجح","ﶒ":"مجخ","ﶍ":"مجم","ﷀ":"مجى","ﳏ":"مح","ﱆ":"مح","ﶉ":"محج","ﶊ":"محم","ﷴ":"محمد","ﶋ":"محى","ﳐ":"مخ","ﱇ":"مخ","ﶎ":"مخج","ﶏ":"مخم","ﶹ":"مخى","ﳑ":"مم","ﲉ":"مم","ﱈ":"مم","ﶱ":"ممى","ﱉ":"مى","ﱊ":"مى","𞸍":"ن","𞸭":"ن","𞹍":"ن","𞹭":"ن","𞺍":"ن","𞺭":"ن","ﻧ":"ن","ﻨ":"ن","ﻦ":"ن","ﻥ":"ن","ݨ":"نؕ","ݩ":"ن̆","ﳖ":"نo","ﳯ":"نo","ﶸ":"نجح","ﶽ":"نجح","ﶘ":"نجم","ﶗ":"نجم","ﶙ":"نجى","ﷇ":"نجى","ﳓ":"نح","ﱌ":"نح","ﶕ":"نحم","ﶖ":"نحى","ﶳ":"نحى","ﳔ":"نخ","ﱍ":"نخ","ﲊ":"نر","ﲋ":"نز","ﳕ":"نم","ﳮ":"نم","ﲌ":"نم","ﱎ":"نم","ﶛ":"نمى","ﶚ":"نمى","ﲍ":"نن","ﲎ":"نى","ﱏ":"نى","ﲏ":"نى","ﱐ":"نى","ۂ":"ۀ","ﮥ":"ۀ","ﮤ":"ۀ","𐋤":"و","𞸅":"و","𞺅":"و","𞺥":"و","ﻮ":"و","ﻭ":"و","ࢱ":"و","ۋ":"وۛ","ﯟ":"وۛ","ﯞ":"وۛ","ۇ":"و̓","ﯘ":"و̓","ﯗ":"و̓","ۆ":"و̆","ﯚ":"و̆","ﯙ":"و̆","ۉ":"و̂","ﯣ":"و̂","ﯢ":"و̂","ۈ":"وٰ","ﯜ":"وٰ","ﯛ":"وٰ","ؤ":"وٴ","ﺆ":"وٴ","ﺅ":"وٴ","ٶ":"وٴ","ٷ":"و̓ٴ","ﯝ":"و̓ٴ","ﷸ":"وسلم","ﯡ":"ۅ","ﯠ":"ۅ","ٮ":"ى","𞸜":"ى","𞹼":"ى","ں":"ى","𞸝":"ى","𞹝":"ى","ﮟ":"ى","ﮞ":"ى","ࢽ":"ى","ﯨ":"ى","ﯩ":"ى","ﻰ":"ى","ﻯ":"ى","ي":"ى","𞸉":"ى","𞸩":"ى","𞹉":"ى","𞹩":"ى","𞺉":"ى","𞺩":"ى","ﻳ":"ى","ﻴ":"ى","ﻲ":"ى","ﻱ":"ى","ی":"ى","ﯾ":"ى","ﯿ":"ى","ﯽ":"ى","ﯼ":"ى","ے":"ى","ﮯ":"ى","ﮮ":"ى","ٹ":"ىؕ","ﭨ":"ىؕ","ﭩ":"ىؕ","ﭧ":"ىؕ","ﭦ":"ىؕ","ڻ":"ىؕ","ﮢ":"ىؕ","ﮣ":"ىؕ","ﮡ":"ىؕ","ﮠ":"ىؕ","پ":"ىۛ","ﭘ":"ىۛ","ﭙ":"ىۛ","ﭗ":"ىۛ","ﭖ":"ىۛ","ث":"ىۛ","𞸖":"ىۛ","𞸶":"ىۛ","𞹶":"ىۛ","𞺖":"ىۛ","𞺶":"ىۛ","ﺛ":"ىۛ","ﺜ":"ىۛ","ﺚ":"ىۛ","ﺙ":"ىۛ","ڽ":"ىۛ","ۑ":"ىۛ","ؿ":"ىۛ","ࢷ":"ىۛۢ","ݖ":"ى̆","ێ":"ى̆","ࢺ":"ى̆̇","ؽ":"ى̂","ࢨ":"ىٔ","ﲐ":"ىٰ","ﱝ":"ىٰ","ﳞ":"ىo","ﳱ":"ىo","ﳦ":"ىۛo","ئ":"ىٴ","ﺋ":"ىٴ","ﺌ":"ىٴ","ﺊ":"ىٴ","ﺉ":"ىٴ","ٸ":"ىٴ","ﯫ":"ىٴl","ﯪ":"ىٴl","ﲛ":"ىٴo","ﳠ":"ىٴo","ﯭ":"ىٴo","ﯬ":"ىٴo","ﯸ":"ىٴٻ","ﯷ":"ىٴٻ","ﯶ":"ىٴٻ","ﲗ":"ىٴج","ﰀ":"ىٴج","ﲘ":"ىٴح","ﰁ":"ىٴح","ﲙ":"ىٴخ","ﱤ":"ىٴر","ﱥ":"ىٴز","ﲚ":"ىٴم","ﳟ":"ىٴم","ﱦ":"ىٴم","ﰂ":"ىٴم","ﱧ":"ىٴن","ﯯ":"ىٴو","ﯮ":"ىٴو","ﯱ":"ىٴو̓","ﯰ":"ىٴو̓","ﯳ":"ىٴو̆","ﯲ":"ىٴو̆","ﯵ":"ىٴوٰ","ﯴ":"ىٴوٰ","ﯻ":"ىٴى","ﯺ":"ىٴى","ﱨ":"ىٴى","ﯹ":"ىٴى","ﰃ":"ىٴى","ﱩ":"ىٴى","ﰄ":"ىٴى","ﳚ":"ىج","ﱕ":"ىج","ﰑ":"ىۛج","ﶯ":"ىجى","ﳛ":"ىح","ﱖ":"ىح","ﶮ":"ىحى","ﳜ":"ىخ","ﱗ":"ىخ","ﲑ":"ىر","ﱶ":"ىۛر","ﲒ":"ىز","ﱷ":"ىۛز","ﳝ":"ىم","ﳰ":"ىم","ﲓ":"ىم","ﱘ":"ىم","ﲦ":"ىۛم","ﳥ":"ىۛم","ﱸ":"ىۛم","ﰒ":"ىۛم","ﶝ":"ىمم","ﶜ":"ىمم","ﶰ":"ىمى","ﲔ":"ىن","ﱹ":"ىۛن","ﲕ":"ىى","ﱙ":"ىى","ﲖ":"ىى","ﱚ":"ىى","ﱺ":"ىۛى","ﰓ":"ىۛى","ﱻ":"ىۛى","ﰔ":"ىۛى","ﮱ":"ۓ","ﮰ":"ۓ","𐊸":"ⵀ","⁞":"ⵂ","⸽":"ⵂ","⦙":"ⵂ","︙":"ⵗ","⁝":"ⵗ","⋮":"ⵗ","Մ":"ሆ","Ռ":"ቡ","Ի":"ኮ","Պ":"ጣ","आ":"अा","ऒ":"अाॆ","ओ":"अाे","औ":"अाै","ऄ":"अॆ","ऑ":"अॉ","ऍ":"एॅ","ऎ":"एॆ","ऐ":"एे","ई":"र्इ","ઽ":"ऽ","𑇜":"ꣻ","𑇋":"ऺ","ુ":"ु","ૂ":"ू","ੋ":"ॆ","੍":"्","્":"्","আ":"অা","ৠ":"ঋৃ","ৡ":"ঋৃ","𑒒":"ঘ","𑒔":"চ","𑒖":"জ","𑒘":"ঞ","𑒙":"ট","𑒛":"ড","𑒪":"ণ","𑒞":"ত","𑒟":"থ","𑒠":"দ","𑒡":"ধ","𑒢":"ন","𑒣":"প","𑒩":"ব","𑒧":"ম","𑒨":"য","𑒫":"র","𑒝":"ল","𑒭":"ষ","𑒮":"স","𑓄":"ঽ","𑒰":"া","𑒱":"ি","𑒹":"ে","𑒼":"ো","𑒾":"ৌ","𑓂":"্","𑒽":"ৗ","ਉ":"ੳੁ","ਊ":"ੳੂ","ਆ":"ਅਾ","ਐ":"ਅੈ","ਔ":"ਅੌ","ਇ":"ੲਿ","ਈ":"ੲੀ","ਏ":"ੲੇ","આ":"અા","ઑ":"અાૅ","ઓ":"અાે","ઔ":"અાૈ","ઍ":"અૅ","એ":"અે","ઐ":"અૈ","ଆ":"ଅା","௮":"அ","ர":"ஈ","ா":"ஈ","௫":"ஈு","௨":"உ","ഉ":"உ","ஊ":"உள","ഊ":"உൗ","௭":"எ","௷":"எவ","ஜ":"ஐ","ജ":"ஐ","௧":"க","௪":"ச","௬":"சு","௲":"சூ","ഺ":"டி","ണ":"ண","௺":"நீ","௴":"மீ","௰":"ய","ഴ":"ழ","ௗ":"ள","ை":"ன","ശ":"ஶ","௸":"ஷ","ി":"ி","ീ":"ி","ொ":"ெஈ","ௌ":"ெள","ோ":"ேஈ","ಅ":"అ","ಆ":"ఆ","ಇ":"ఇ","ౠ":"ఋా","ౡ":"ఌా","ಒ":"ఒ","ఔ":"ఒౌ","ಔ":"ఒౌ","ఓ":"ఒౕ","ಓ":"ఒౕ","ಜ":"జ","ಞ":"ఞ","ఢ":"డ̣","ಣ":"ణ","థ":"ధּ","భ":"బ̣","ಯ":"య","ఠ":"రּ","ಱ":"ఱ","ಲ":"ల","ష":"వ̣","హ":"వా","మ":"వు","ూ":"ుా","ౄ":"ృా","ೡ":"ಌಾ","ഈ":"ഇൗ","ഐ":"എെ","ഓ":"ഒാ","ഔ":"ഒൗ","ൡ":"ഞ","൫":"ദ്ര","൹":"നു","ഌ":"നു","ങ":"നു","൯":"ന്","ൻ":"ന്","൬":"ന്ന","൚":"ന്മ","റ":"ര","൪":"ര്","ർ":"ര്","൮":"വ്ര","൶":"ഹ്മ","ൂ":"ു","ൃ":"ു","ൈ":"െെ","෪":"ජ","෫":"ද","𑐓":"𑐴𑑂𑐒","𑐙":"𑐴𑑂𑐘","𑐤":"𑐴𑑂𑐣","𑐪":"𑐴𑑂𑐩","𑐭":"𑐴𑑂𑐬","𑐯":"𑐴𑑂𑐮","𑗘":"𑖂","𑗙":"𑖂","𑗚":"𑖃","𑗛":"𑖄","𑗜":"𑖲","𑗝":"𑖳","ฃ":"ข","ด":"ค","ต":"ค","ม":"ฆ","ຈ":"จ","ซ":"ช","ฏ":"ฎ","ท":"ฑ","ບ":"บ","ປ":"ป","ຝ":"ฝ","ພ":"พ","ຟ":"ฟ","ฦ":"ภ","ຍ":"ย","។":"ฯ","ๅ":"า","ำ":"̊า","ិ":"ิ","ី":"ี","ឹ":"ึ","ឺ":"ื","ຸ":"ุ","ູ":"ู","แ":"เเ","ໜ":"ຫນ","ໝ":"ຫມ","ຳ":"̊າ","༂":"འུྂཿ","༃":"འུྂ༔","ཪ":"ར","ༀ":"ཨོཾ","ཷ":"ྲཱྀ","ཹ":"ླཱྀ","𑲲":"𑲪","ႁ":"ဂှ","က":"ဂာ","ၰ":"ဃှ","ၦ":"ပှ","ဟ":"ပာ","ၯ":"ပာှ","ၾ":"ၽှ","ဩ":"သြ","ဪ":"သြော်","႞":"ႃ̊","ឣ":"អ","᧐":"ᦞ","᧑":"ᦱ","᪀":"ᩅ","᪐":"ᩅ","꩓":"ꨁ","꩖":"ꨣ","᭒":"ᬍ","᭓":"ᬑ","᭘":"ᬨ","ꦣ":"ꦝ","ᢖ":"ᡜ","ᡕ":"ᠵ","ῶ":"Ꮿ","ᐍ":"ᐁ·","ᐫ":"ᐁᐠ","ᐑ":"ᐄ·","ᐓ":"ᐅ·","ᐭ":"ᐅᐠ","ᐕ":"ᐆ·","ᐘ":"ᐊ·","ᐮ":"ᐊᐠ","ᐚ":"ᐋ·","ᣝ":"ᐞᣟ","ᓑ":"ᐡ","ᕀ":"ᐩ","ᐿ":"ᐲ·","ᑃ":"ᐴ·","⍩":"ᐵ","ᑇ":"ᐹ·","ᑜ":"ᑏ·","⸧":"ᑐ","⊃":"ᑐ","ᑞ":"ᑐ·","ᑩ":"ᑐ\'","⟉":"ᑐ/","⫗":"ᑐᑕ","ᑠ":"ᑑ·","⸦":"ᑕ","⊂":"ᑕ","ᑢ":"ᑕ·","ᑪ":"ᑕ\'","ᑤ":"ᑖ·","ᑵ":"ᑫ·","ᒅ":"ᑫ\'","ᑹ":"ᑮ·","ᑽ":"ᑰ·","ᘃ":"ᒉ","ᒓ":"ᒉ·","ᒕ":"ᒋ·","ᒗ":"ᒌ·","ᒛ":"ᒎ·","ᘂ":"ᒐ","ᒝ":"ᒐ·","ᒟ":"ᒑ·","ᒭ":"ᒣ·","ᒱ":"ᒦ·","ᒳ":"ᒧ·","ᒵ":"ᒨ·","ᒹ":"ᒫ·","ᓊ":"ᓀ·","ᣇ":"ᓂ·","ᣉ":"ᓃ·","ᣋ":"ᓄ·","ᣍ":"ᓅ·","ᓌ":"ᓇ·","ᓎ":"ᓈ·","ᘄ":"ᓓ","ᓝ":"ᓓ·","ᓟ":"ᓕ·","ᓡ":"ᓖ·","ᓣ":"ᓗ·","ᓥ":"ᓘ·","ᘇ":"ᓚ","ᓧ":"ᓚ·","ᓩ":"ᓛ·","ᓷ":"ᓭ·","ᓹ":"ᓯ·","ᓻ":"ᓰ·","ᓽ":"ᓱ·","ᓿ":"ᓲ·","ᔁ":"ᓴ·","ᔃ":"ᓵ·","ᔌ":"ᔋ<","ᔎ":"ᔋb","ᔍ":"ᔋᑕ","ᔏ":"ᔋᒐ","ᔘ":"ᔐ·","ᔚ":"ᔑ·","ᔜ":"ᔒ·","ᔞ":"ᔓ·","ᔠ":"ᔔ·","ᔢ":"ᔕ·","ᔤ":"ᔖ·","ᔲ":"ᔨ·","ᔴ":"ᔩ·","ᔶ":"ᔪ·","ᔸ":"ᔫ·","ᔺ":"ᔭ·","ᔼ":"ᔮ·","ᘢ":"ᕃ","ᣠ":"ᕃ·","ᘣ":"ᕆ","ᘤ":"ᕊ","ᕏ":"ᕌ·","ᖃ":"ᕐb","ᖄ":"ᕐḃ","ᖁ":"ᕐd","ᕿ":"ᕐP","ᙯ":"ᕐᑫ","ᕾ":"ᕐᑬ","ᖀ":"ᕐᑮ","ᖂ":"ᕐᑰ","ᖅ":"ᕐᒃ","ᕜ":"ᕚ·","ᣣ":"ᕞ·","ᣤ":"ᕦ·","ᕩ":"ᕧ·","ᣥ":"ᕫ·","ᣨ":"ᖆ·","ᖑ":"ᖕJ","ᙰ":"ᖕᒉ","ᖎ":"ᖕᒊ","ᖏ":"ᖕᒋ","ᖐ":"ᖕᒌ","ᖒ":"ᖕᒎ","ᖓ":"ᖕᒐ","ᖔ":"ᖕᒑ","ᙳ":"ᖖJ","ᙱ":"ᖖᒋ","ᙲ":"ᖖᒌ","ᙴ":"ᖖᒎ","ᙵ":"ᖖᒐ","ᙶ":"ᖖᒑ","ᣪ":"ᖗ·","ᙷ":"ᖧ·","ᙸ":"ᖨ·","ᙹ":"ᖩ·","ᙺ":"ᖪ·","ᙻ":"ᖫ·","ᙼ":"ᖬ·","ᙽ":"ᖭ·","⪫":"ᗒ","⪪":"ᗕ","ꓷ":"ᗡ","ᣰ":"ᗴ·","ᣲ":"ᘛ·","ᶻ":"ᙆ","ꓭ":"ᙠ","ᶺ":"ᣔ","ᴾ":"ᣖ","ᣜ":"ᣟᐞ","ˡ":"ᣳ","ʳ":"ᣴ","ˢ":"ᣵ","ᣛ":"ᣵ","ꚰ":"ᚹ","ᛡ":"ᚼ","⍿":"ᚽ","ᛂ":"ᚽ","𝈿":"ᛋ","↑":"ᛏ","↿":"ᛐ","⥮":"ᛐ⇂","⥣":"ᛐᛚ","ⵣ":"ᛯ","↾":"ᛚ","⨡":"ᛚ","⋄":"ᛜ","◇":"ᛜ","◊":"ᛜ","♢":"ᛜ","🝔":"ᛜ","𑢷":"ᛜ","𐊔":"ᛜ","⍚":"ᛜ̲","⋈":"ᛞ","⨝":"ᛞ","𐓐":"ᛦ","↕":"ᛨ","𐳼":"𐲂","𐳺":"𐲥","ㄱ":"ᄀ","ᆨ":"ᄀ","ᄁ":"ᄀᄀ","ㄲ":"ᄀᄀ","ᆩ":"ᄀᄀ","ᇺ":"ᄀᄂ","ᅚ":"ᄀᄃ","ᇃ":"ᄀᄅ","ᇻ":"ᄀᄇ","ᆪ":"ᄀᄉ","ㄳ":"ᄀᄉ","ᇄ":"ᄀᄉᄀ","ᇼ":"ᄀᄎ","ᇽ":"ᄀᄏ","ᇾ":"ᄀᄒ","ㄴ":"ᄂ","ᆫ":"ᄂ","ᄓ":"ᄂᄀ","ᇅ":"ᄂᄀ","ᄔ":"ᄂᄂ","ㅥ":"ᄂᄂ","ᇿ":"ᄂᄂ","ᄕ":"ᄂᄃ","ㅦ":"ᄂᄃ","ᇆ":"ᄂᄃ","ퟋ":"ᄂᄅ","ᄖ":"ᄂᄇ","ᅛ":"ᄂᄉ","ᇇ":"ᄂᄉ","ㅧ":"ᄂᄉ","ᅜ":"ᄂᄌ","ᆬ":"ᄂᄌ","ㄵ":"ᄂᄌ","ퟌ":"ᄂᄎ","ᇉ":"ᄂᄐ","ᅝ":"ᄂᄒ","ᆭ":"ᄂᄒ","ㄶ":"ᄂᄒ","ᇈ":"ᄂᅀ","ㅨ":"ᄂᅀ","ㄷ":"ᄃ","ᆮ":"ᄃ","ᄗ":"ᄃᄀ","ᇊ":"ᄃᄀ","ᄄ":"ᄃᄃ","ㄸ":"ᄃᄃ","ퟍ":"ᄃᄃ","ퟎ":"ᄃᄃᄇ","ᅞ":"ᄃᄅ","ᇋ":"ᄃᄅ","ꥠ":"ᄃᄆ","ꥡ":"ᄃᄇ","ퟏ":"ᄃᄇ","ꥢ":"ᄃᄉ","ퟐ":"ᄃᄉ","ퟑ":"ᄃᄉᄀ","ꥣ":"ᄃᄌ","ퟒ":"ᄃᄌ","ퟓ":"ᄃᄎ","ퟔ":"ᄃᄐ","ㄹ":"ᄅ","ᆯ":"ᄅ","ꥤ":"ᄅᄀ","ᆰ":"ᄅᄀ","ㄺ":"ᄅᄀ","ꥥ":"ᄅᄀᄀ","ퟕ":"ᄅᄀᄀ","ᇌ":"ᄅᄀᄉ","ㅩ":"ᄅᄀᄉ","ퟖ":"ᄅᄀᄒ","ᄘ":"ᄅᄂ","ᇍ":"ᄅᄂ","ꥦ":"ᄅᄃ","ᇎ":"ᄅᄃ","ㅪ":"ᄅᄃ","ꥧ":"ᄅᄃᄃ","ᇏ":"ᄅᄃᄒ","ᄙ":"ᄅᄅ","ᇐ":"ᄅᄅ","ퟗ":"ᄅᄅᄏ","ꥨ":"ᄅᄆ","ᆱ":"ᄅᄆ","ㄻ":"ᄅᄆ","ᇑ":"ᄅᄆᄀ","ᇒ":"ᄅᄆᄉ","ퟘ":"ᄅᄆᄒ","ꥩ":"ᄅᄇ","ᆲ":"ᄅᄇ","ㄼ":"ᄅᄇ","ퟙ":"ᄅᄇᄃ","ꥪ":"ᄅᄇᄇ","ᇓ":"ᄅᄇᄉ","ㅫ":"ᄅᄇᄉ","ꥫ":"ᄅᄇᄋ","ᇕ":"ᄅᄇᄋ","ퟚ":"ᄅᄇᄑ","ᇔ":"ᄅᄇᄒ","ꥬ":"ᄅᄉ","ᆳ":"ᄅᄉ","ㄽ":"ᄅᄉ","ᇖ":"ᄅᄉᄉ","ᄛ":"ᄅᄋ","ퟝ":"ᄅᄋ","ꥭ":"ᄅᄌ","ꥮ":"ᄅᄏ","ᇘ":"ᄅᄏ","ᆴ":"ᄅᄐ","ㄾ":"ᄅᄐ","ᆵ":"ᄅᄑ","ㄿ":"ᄅᄑ","ᄚ":"ᄅᄒ","ㅀ":"ᄅᄒ","ᄻ":"ᄅᄒ","ᆶ":"ᄅᄒ","ퟲ":"ᄅᄒ","ᇗ":"ᄅᅀ","ㅬ":"ᄅᅀ","ퟛ":"ᄅᅌ","ᇙ":"ᄅᅙ","ㅭ":"ᄅᅙ","ퟜ":"ᄅᅙᄒ","ㅁ":"ᄆ","ᆷ":"ᄆ","ꥯ":"ᄆᄀ","ᇚ":"ᄆᄀ","ퟞ":"ᄆᄂ","ퟟ":"ᄆᄂᄂ","ꥰ":"ᄆᄃ","ᇛ":"ᄆᄅ","ퟠ":"ᄆᄆ","ᄜ":"ᄆᄇ","ㅮ":"ᄆᄇ","ᇜ":"ᄆᄇ","ퟡ":"ᄆᄇᄉ","ꥱ":"ᄆᄉ","ᇝ":"ᄆᄉ","ㅯ":"ᄆᄉ","ᇞ":"ᄆᄉᄉ","ᄝ":"ᄆᄋ","ㅱ":"ᄆᄋ","ᇢ":"ᄆᄋ","ퟢ":"ᄆᄌ","ᇠ":"ᄆᄎ","ᇡ":"ᄆᄒ","ᇟ":"ᄆᅀ","ㅰ":"ᄆᅀ","ㅂ":"ᄇ","ᆸ":"ᄇ","ᄞ":"ᄇᄀ","ㅲ":"ᄇᄀ","ᄟ":"ᄇᄂ","ᄠ":"ᄇᄃ","ㅳ":"ᄇᄃ","ퟣ":"ᄇᄃ","ᇣ":"ᄇᄅ","ퟤ":"ᄇᄅᄑ","ퟥ":"ᄇᄆ","ᄈ":"ᄇᄇ","ㅃ":"ᄇᄇ","ퟦ":"ᄇᄇ","ᄬ":"ᄇᄇᄋ","ㅹ":"ᄇᄇᄋ","ᄡ":"ᄇᄉ","ㅄ":"ᄇᄉ","ᆹ":"ᄇᄉ","ᄢ":"ᄇᄉᄀ","ㅴ":"ᄇᄉᄀ","ᄣ":"ᄇᄉᄃ","ㅵ":"ᄇᄉᄃ","ퟧ":"ᄇᄉᄃ","ᄤ":"ᄇᄉᄇ","ᄥ":"ᄇᄉᄉ","ᄦ":"ᄇᄉᄌ","ꥲ":"ᄇᄉᄐ","ᄫ":"ᄇᄋ","ㅸ":"ᄇᄋ","ᇦ":"ᄇᄋ","ᄧ":"ᄇᄌ","ㅶ":"ᄇᄌ","ퟨ":"ᄇᄌ","ᄨ":"ᄇᄎ","ퟩ":"ᄇᄎ","ꥳ":"ᄇᄏ","ᄩ":"ᄇᄐ","ㅷ":"ᄇᄐ","ᄪ":"ᄇᄑ","ᇤ":"ᄇᄑ","ꥴ":"ᄇᄒ","ᇥ":"ᄇᄒ","ㅅ":"ᄉ","ᆺ":"ᄉ","ᄭ":"ᄉᄀ","ㅺ":"ᄉᄀ","ᇧ":"ᄉᄀ","ᄮ":"ᄉᄂ","ㅻ":"ᄉᄂ","ᄯ":"ᄉᄃ","ㅼ":"ᄉᄃ","ᇨ":"ᄉᄃ","ᄰ":"ᄉᄅ","ᇩ":"ᄉᄅ","ᄱ":"ᄉᄆ","ퟪ":"ᄉᄆ","ᄲ":"ᄉᄇ","ㅽ":"ᄉᄇ","ᇪ":"ᄉᄇ","ᄳ":"ᄉᄇᄀ","ퟫ":"ᄉᄇᄋ","ᄊ":"ᄉᄉ","ㅆ":"ᄉᄉ","ᆻ":"ᄉᄉ","ퟬ":"ᄉᄉᄀ","ퟭ":"ᄉᄉᄃ","ꥵ":"ᄉᄉᄇ","ᄴ":"ᄉᄉᄉ","ᄵ":"ᄉᄋ","ᄶ":"ᄉᄌ","ㅾ":"ᄉᄌ","ퟯ":"ᄉᄌ","ᄷ":"ᄉᄎ","ퟰ":"ᄉᄎ","ᄸ":"ᄉᄏ","ᄹ":"ᄉᄐ","ퟱ":"ᄉᄐ","ᄺ":"ᄉᄑ","ퟮ":"ᄉᅀ","ㅇ":"ᄋ","ᆼ":"ᄋ","ᅁ":"ᄋᄀ","ᇬ":"ᄋᄀ","ᇭ":"ᄋᄀᄀ","ᅂ":"ᄋᄃ","ꥶ":"ᄋᄅ","ᅃ":"ᄋᄆ","ᅄ":"ᄋᄇ","ᅅ":"ᄋᄉ","ᇱ":"ᄋᄉ","ㆂ":"ᄋᄉ","ᅇ":"ᄋᄋ","ㆀ":"ᄋᄋ","ᇮ":"ᄋᄋ","ᅈ":"ᄋᄌ","ᅉ":"ᄋᄎ","ᇯ":"ᄋᄏ","ᅊ":"ᄋᄐ","ᅋ":"ᄋᄑ","ꥷ":"ᄋᄒ","ᅆ":"ᄋᅀ","ᇲ":"ᄋᅀ","ㆃ":"ᄋᅀ","ㅈ":"ᄌ","ᆽ":"ᄌ","ퟷ":"ᄌᄇ","ퟸ":"ᄌᄇᄇ","ᅍ":"ᄌᄋ","ᄍ":"ᄌᄌ","ㅉ":"ᄌᄌ","ퟹ":"ᄌᄌ","ꥸ":"ᄌᄌᄒ","ㅊ":"ᄎ","ᆾ":"ᄎ","ᅒ":"ᄎᄏ","ᅓ":"ᄎᄒ","ㅋ":"ᄏ","ᆿ":"ᄏ","ㅌ":"ᄐ","ᇀ":"ᄐ","ꥹ":"ᄐᄐ","ㅍ":"ᄑ","ᇁ":"ᄑ","ᅖ":"ᄑᄇ","ᇳ":"ᄑᄇ","ퟺ":"ᄑᄉ","ᅗ":"ᄑᄋ","ㆄ":"ᄑᄋ","ᇴ":"ᄑᄋ","ퟻ":"ᄑᄐ","ꥺ":"ᄑᄒ","ㅎ":"ᄒ","ᇂ":"ᄒ","ᇵ":"ᄒᄂ","ᇶ":"ᄒᄅ","ᇷ":"ᄒᄆ","ᇸ":"ᄒᄇ","ꥻ":"ᄒᄉ","ᅘ":"ᄒᄒ","ㆅ":"ᄒᄒ","ᄽ":"ᄼᄼ","ᄿ":"ᄾᄾ","ㅿ":"ᅀ","ᇫ":"ᅀ","ퟳ":"ᅀᄇ","ퟴ":"ᅀᄇᄋ","ㆁ":"ᅌ","ᇰ":"ᅌ","ퟵ":"ᅌᄆ","ퟶ":"ᅌᄒ","ᅏ":"ᅎᅎ","ᅑ":"ᅐᅐ","ㆆ":"ᅙ","ᇹ":"ᅙ","ꥼ":"ᅙᅙ","ㅤ":"ᅠ","ㅏ":"ᅡ","ᆣ":"ᅡー","ᅶ":"ᅡᅩ","ᅷ":"ᅡᅮ","ᅢ":"ᅡ丨","ㅐ":"ᅡ丨","ㅑ":"ᅣ","ᅸ":"ᅣᅩ","ᅹ":"ᅣᅭ","ᆤ":"ᅣᅮ","ᅤ":"ᅣ丨","ㅒ":"ᅣ丨","ㅓ":"ᅥ","ᅼ":"ᅥー","ᅺ":"ᅥᅩ","ᅻ":"ᅥᅮ","ᅦ":"ᅥ丨","ㅔ":"ᅥ丨","ㅕ":"ᅧ","ᆥ":"ᅧᅣ","ᅽ":"ᅧᅩ","ᅾ":"ᅧᅮ","ᅨ":"ᅧ丨","ㅖ":"ᅧ丨","ㅗ":"ᅩ","ᅪ":"ᅩᅡ","ㅘ":"ᅩᅡ","ᅫ":"ᅩᅡ丨","ㅙ":"ᅩᅡ丨","ᆦ":"ᅩᅣ","ᆧ":"ᅩᅣ丨","ᅿ":"ᅩᅥ","ᆀ":"ᅩᅥ丨","ힰ":"ᅩᅧ","ᆁ":"ᅩᅧ丨","ᆂ":"ᅩᅩ","ힱ":"ᅩᅩ丨","ᆃ":"ᅩᅮ","ᅬ":"ᅩ丨","ㅚ":"ᅩ丨","ㅛ":"ᅭ","ힲ":"ᅭᅡ","ힳ":"ᅭᅡ丨","ᆄ":"ᅭᅣ","ㆇ":"ᅭᅣ","ᆆ":"ᅭᅣ","ᆅ":"ᅭᅣ丨","ㆈ":"ᅭᅣ丨","ힴ":"ᅭᅥ","ᆇ":"ᅭᅩ","ᆈ":"ᅭ丨","ㆉ":"ᅭ丨","ㅜ":"ᅮ","ᆉ":"ᅮᅡ","ᆊ":"ᅮᅡ丨","ᅯ":"ᅮᅥ","ㅝ":"ᅮᅥ","ᆋ":"ᅮᅥー","ᅰ":"ᅮᅥ丨","ㅞ":"ᅮᅥ丨","ힵ":"ᅮᅧ","ᆌ":"ᅮᅧ丨","ᆍ":"ᅮᅮ","ᅱ":"ᅮ丨","ㅟ":"ᅮ丨","ힶ":"ᅮ丨丨","ㅠ":"ᅲ","ᆎ":"ᅲᅡ","ힷ":"ᅲᅡ丨","ᆏ":"ᅲᅥ","ᆐ":"ᅲᅥ丨","ᆑ":"ᅲᅧ","ㆊ":"ᅲᅧ","ᆒ":"ᅲᅧ丨","ㆋ":"ᅲᅧ丨","ힸ":"ᅲᅩ","ᆓ":"ᅲᅮ","ᆔ":"ᅲ丨","ㆌ":"ᅲ丨","ㆍ":"ᆞ","ퟅ":"ᆞᅡ","ᆟ":"ᆞᅥ","ퟆ":"ᆞᅥ丨","ᆠ":"ᆞᅮ","ᆢ":"ᆞᆞ","ᆡ":"ᆞ丨","ㆎ":"ᆞ丨","ヘ":"へ","⍁":"〼","⧄":"〼","꒞":"ꁊ","꒬":"ꁐ","꒜":"ꃀ","꒨":"ꄲ","꒿":"ꉙ","꒾":"ꊱ","꒔":"ꋍ","꓀":"ꎫ","꓂":"ꎵ","꒺":"ꎿ","꒰":"ꏂ","꒧":"ꑘ","⊥":"ꓕ","⟂":"ꓕ","𝈜":"ꓕ","Ʇ":"ꓕ","Ꞟ":"ꓤ","⅁":"ꓨ","⅂":"ꓶ","𝈕":"ꓶ","𝈫":"ꓶ","𖼦":"ꓶ","𐐑":"ꓶ","⅃":"𖼀","𑫦":"𑫥𑫯","𑫨":"𑫥𑫥","𑫩":"𑫥𑫥𑫯","𑫪":"𑫥𑫥𑫰","𑫧":"𑫥𑫰","𑫴":"𑫳𑫯","𑫶":"𑫳𑫳","𑫷":"𑫳𑫳𑫯","𑫸":"𑫳𑫳𑫰","𑫵":"𑫳𑫰","𑫬":"𑫫𑫯","𑫭":"𑫫𑫫","𑫮":"𑫫𑫫𑫯","⊕":"𐊨","⨁":"𐊨","🜨":"𐊨","Ꚛ":"𐊨","▽":"𐊼","𝈔":"𐊼","🜄":"𐊼","⧖":"𐋀","ꞛ":"𐐺","Ꞛ":"𐐒","𐒠":"𐒆","𐏑":"𐎂","𐏓":"𐎓","𒀸":"𐎚","☥":"𐦞","𓋹":"𐦞","〹":"卄","不":"不","丽":"丽","並":"並","⎜":"丨","⎟":"丨","⎢":"丨","⎥":"丨","⎪":"丨","⎮":"丨","㇑":"丨","ᅵ":"丨","ㅣ":"丨","⼁":"丨","ᆜ":"丨ー","ᆘ":"丨ᅡ","ᆙ":"丨ᅣ","ힽ":"丨ᅣᅩ","ힾ":"丨ᅣ丨","ힿ":"丨ᅧ","ퟀ":"丨ᅧ丨","ᆚ":"丨ᅩ","ퟁ":"丨ᅩ丨","ퟂ":"丨ᅭ","ᆛ":"丨ᅮ","ퟃ":"丨ᅲ","ᆝ":"丨ᆞ","ퟄ":"丨丨","串":"串","丸":"丸","丹":"丹","乁":"乁","㇠":"乙","⼄":"乙","㇟":"乚","⺃":"乚","㇖":"乛","⺂":"乛","⻲":"亀","亂":"亂","㇚":"亅","⼅":"亅","了":"了","ニ":"二","⼆":"二","𠄢":"𠄢","⼇":"亠","亮":"亮","⼈":"人","イ":"亻","⺅":"亻","什":"什","仌":"仌","令":"令","你":"你","倂":"併","倂":"併","侀":"侀","來":"來","例":"例","侮":"侮","侮":"侮","侻":"侻","便":"便","值":"値","倫":"倫","偺":"偺","備":"備","像":"像","僚":"僚","僧":"僧","僧":"僧","㒞":"㒞","⼉":"儿","兀":"兀","⺎":"兀","充":"充","免":"免","免":"免","兔":"兔","兤":"兤","⼊":"入","內":"內","全":"全","兩":"兩","ハ":"八","⼋":"八","六":"六","具":"具","𠔜":"𠔜","𠔥":"𠔥","冀":"冀","㒹":"㒹","⼌":"冂","再":"再","𠕋":"𠕋","冒":"冒","冕":"冕","㒻":"㒻","最":"最","⼍":"冖","冗":"冗","冤":"冤","⼎":"冫","冬":"冬","况":"况","况":"况","冷":"冷","凉":"凉","凌":"凌","凜":"凜","凞":"凞","⼏":"几","𠘺":"𠘺","凵":"凵","⼐":"凵","⼑":"刀","⺉":"刂","刃":"刃","切":"切","切":"切","列":"列","利":"利","㓟":"㓟","刺":"刺","刻":"刻","剆":"剆","割":"割","剷":"剷","劉":"劉","𠠄":"𠠄","カ":"力","力":"力","⼒":"力","劣":"劣","㔕":"㔕","劳":"劳","勇":"勇","勇":"勇","勉":"勉","勉":"勉","勒":"勒","勞":"勞","勤":"勤","勤":"勤","勵":"勵","⼓":"勹","勺":"勺","勺":"勺","包":"包","匆":"匆","𠣞":"𠣞","⼔":"匕","北":"北","北":"北","⼕":"匚","⼖":"匸","匿":"匿","⼗":"十","〸":"十","〺":"卅","卉":"卉","࿖":"卍","࿕":"卐","卑":"卑","卑":"卑","博":"博","ト":"卜","⼘":"卜","⼙":"卩","⺋":"㔾","即":"即","卵":"卵","卽":"卽","卿":"卿","卿":"卿","卿":"卿","⼚":"厂","𠨬":"𠨬","⼛":"厶","參":"參","⼜":"又","及":"及","叟":"叟","𠭣":"𠭣","ロ":"口","⼝":"口","囗":"口","⼞":"口","句":"句","叫":"叫","叱":"叱","吆":"吆","吏":"吏","吝":"吝","吸":"吸","呂":"呂","呈":"呈","周":"周","咞":"咞","咢":"咢","咽":"咽","䎛":"㖈","哶":"哶","唐":"唐","啓":"啓","啟":"啓","啕":"啕","啣":"啣","善":"善","善":"善","喇":"喇","喙":"喙","喙":"喙","喝":"喝","喝":"喝","喫":"喫","喳":"喳","嗀":"嗀","嗂":"嗂","嗢":"嗢","嘆":"嘆","嘆":"嘆","噑":"噑","噴":"噴","器":"器","囹":"囹","圖":"圖","圗":"圗","⼟":"土","士":"土","⼠":"土","型":"型","城":"城","㦳":"㘽","埴":"埴","堍":"堍","報":"報","堲":"堲","塀":"塀","塚":"塚","塚":"塚","塞":"塞","填":"塡","壿":"墫","墬":"墬","墳":"墳","壘":"壘","壟":"壟","𡓤":"𡓤","壮":"壮","売":"売","壷":"壷","⼡":"夂","夆":"夆","⼢":"夊","タ":"夕","⼣":"夕","多":"多","夢":"夢","⼤":"大","奄":"奄","奈":"奈","契":"契","奔":"奔","奢":"奢","女":"女","⼥":"女","𡚨":"𡚨","𡛪":"𡛪","姘":"姘","姬":"姬","娛":"娛","娧":"娧","婢":"婢","婦":"婦","嬀":"媯","㛮":"㛮","㛼":"㛼","媵":"媵","嬈":"嬈","嬨":"嬨","嬾":"嬾","嬾":"嬾","⼦":"子","⼧":"宀","宅":"宅","𡧈":"𡧈","寃":"寃","寘":"寘","寧":"寧","寧":"寧","寧":"寧","寮":"寮","寳":"寳","𡬘":"𡬘","⼨":"寸","寿":"寿","将":"将","⼩":"小","尢":"尢","⺐":"尢","⼪":"尢","⺏":"尣","㞁":"㞁","⼫":"尸","尿":"尿","屠":"屠","屢":"屢","層":"層","履":"履","屮":"屮","屮":"屮","⼬":"屮","𡴋":"𡴋","⼭":"山","峀":"峀","岍":"岍","𡷤":"𡷤","𡷦":"𡷦","崙":"崙","嵃":"嵃","嵐":"嵐","嵫":"嵫","嵮":"嵮","嵼":"嵼","嶲":"嶲","嶺":"嶺","⼮":"巛","巢":"巢","エ":"工","⼯":"工","⼰":"己","⺒":"巳","㠯":"㠯","巽":"巽","⼱":"巾","帲":"帡","帨":"帨","帽":"帽","幩":"幩","㡢":"㡢","𢆃":"𢆃","⼲":"干","年":"年","𢆟":"𢆟","⺓":"幺","⼳":"幺","⼴":"广","度":"度","㡼":"㡼","庰":"庰","庳":"庳","庶":"庶","廊":"廊","廊":"廊","廉":"廉","廒":"廒","廓":"廓","廙":"廙","廬":"廬","⼵":"廴","廾":"廾","⼶":"廾","𢌱":"𢌱","𢌱":"𢌱","弄":"弄","⼷":"弋","⼸":"弓","弢":"弢","弢":"弢","⼹":"彐","⺔":"彑","当":"当","㣇":"㣇","⼺":"彡","形":"形","彩":"彩","彫":"彫","⼻":"彳","律":"律","㣣":"㣣","徚":"徚","復":"復","徭":"徭","⼼":"心","⺖":"忄","⺗":"㣺","忍":"忍","志":"志","念":"念","忹":"忹","怒":"怒","怜":"怜","恵":"恵","㤜":"㤜","㤺":"㤺","悁":"悁","悔":"悔","悔":"悔","惇":"惇","惘":"惘","惡":"惡","𢛔":"𢛔","愈":"愈","慨":"慨","慄":"慄","慈":"慈","慌":"慌","慌":"慌","慎":"慎","慎":"慎","慠":"慠","慺":"慺","憎":"憎","憎":"憎","憎":"憎","憐":"憐","憤":"憤","憯":"憯","憲":"憲","𢡄":"𢡄","𢡊":"𢡊","懞":"懞","懲":"懲","懲":"懲","懲":"懲","懶":"懶","懶":"懶","戀":"戀","⼽":"戈","成":"成","戛":"戛","戮":"戮","戴":"戴","⼾":"戶","戸":"戶","⼿":"手","⺘":"扌","扝":"扝","抱":"抱","拉":"拉","拏":"拏","拓":"拓","拔":"拔","拼":"拼","拾":"拾","𢬌":"𢬌","挽":"挽","捐":"捐","捨":"捨","捻":"捻","掃":"掃","掠":"掠","掩":"掩","揄":"揄","揤":"揤","摒":"摒","𢯱":"𢯱","搜":"搜","搢":"搢","揅":"揅","摩":"摩","摷":"摷","摾":"摾","㨮":"㨮","搉":"㩁","撚":"撚","撝":"撝","擄":"擄","㩬":"㩬","⽀":"支","⽁":"攴","⺙":"攵","敏":"敏","敏":"敏","敖":"敖","敬":"敬","數":"數","𣀊":"𣀊","⽂":"文","⻫":"斉","⽃":"斗","料":"料","⽄":"斤","⽅":"方","旅":"旅","⽆":"无","⺛":"旡","既":"既","旣":"旣","⽇":"日","易":"易","曶":"㫚","㫤":"㫤","晉":"晉","晩":"晚","晴":"晴","晴":"晴","暑":"暑","暑":"暑","暈":"暈","㬈":"㬈","暜":"暜","暴":"暴","曆":"曆","㬙":"㬙","𣊸":"𣊸","⽈":"曰","更":"更","書":"書","⽉":"月","𣍟":"𣍟","肦":"朌","胐":"朏","胊":"朐","脁":"朓","胶":"㬵","朗":"朗","朗":"朗","朗":"朗","脧":"朘","望":"望","望":"望","幐":"㬺","䐠":"㬻","𣎓":"𣎓","膧":"朣","𣎜":"𣎜","⽊":"木","李":"李","杓":"杓","杖":"杖","杞":"杞","𣏃":"𣏃","柿":"杮","杻":"杻","枅":"枅","林":"林","㭉":"㭉","𣏕":"𣏕","柳":"柳","柺":"柺","栗":"栗","栟":"栟","桒":"桒","𣑭":"𣑭","梁":"梁","梅":"梅","梅":"梅","梎":"梎","梨":"梨","椔":"椔","楂":"楂","㮝":"㮝","㮝":"㮝","槩":"㮣","樧":"榝","榣":"榣","槪":"槪","樂":"樂","樂":"樂","樂":"樂","樓":"樓","𣚣":"𣚣","檨":"檨","櫓":"櫓","櫛":"櫛","欄":"欄","㰘":"㰘","⽋":"欠","次":"次","𣢧":"𣢧","歔":"歔","㱎":"㱎","⽌":"止","⻭":"歯","歲":"歲","歷":"歷","歹":"歹","⽍":"歹","⺞":"歺","殟":"殟","殮":"殮","⽎":"殳","殺":"殺","殺":"殺","殺":"殺","殻":"殻","𣪍":"𣪍","⽏":"毋","⺟":"母","𣫺":"𣫺","⽐":"比","⽑":"毛","⽒":"氏","⺠":"民","⽓":"气","⽔":"水","⺡":"氵","⺢":"氺","汎":"汎","汧":"汧","沈":"沈","沿":"沿","泌":"泌","泍":"泍","泥":"泥","𣲼":"𣲼","洛":"洛","洞":"洞","洴":"洴","派":"派","流":"流","流":"流","流":"流","洖":"洖","浩":"浩","浪":"浪","海":"海","海":"海","浸":"浸","涅":"涅","𣴞":"𣴞","淋":"淋","淚":"淚","淪":"淪","淹":"淹","渚":"渚","港":"港","湮":"湮","潙":"溈","滋":"滋","滋":"滋","溜":"溜","溺":"溺","滇":"滇","滑":"滑","滛":"滛","㴳":"㴳","漏":"漏","漢":"漢","漢":"漢","漣":"漣","𣻑":"𣻑","潮":"潮","𣽞":"𣽞","𣾎":"𣾎","濆":"濆","濫":"濫","濾":"濾","瀛":"瀛","瀞":"瀞","瀞":"瀞","瀹":"瀹","灊":"灊","㶖":"㶖","⽕":"火","⺣":"灬","灰":"灰","灷":"灷","災":"災","炙":"炙","炭":"炭","烈":"烈","烙":"烙","煮":"煮","煮":"煮","𤉣":"𤉣","煅":"煅","煉":"煉","𤋮":"𤋮","熜":"熜","燎":"燎","燐":"燐","𤎫":"𤎫","爐":"爐","爛":"爛","爨":"爨","⽖":"爪","爫":"爫","⺤":"爫","爵":"爵","爵":"爵","⽗":"父","⽘":"爻","⺦":"丬","⽙":"爿","⽚":"片","牐":"牐","⽛":"牙","𤘈":"𤘈","⽜":"牛","牢":"牢","犀":"犀","犕":"犕","⽝":"犬","⺨":"犭","犯":"犯","狀":"狀","𤜵":"𤜵","狼":"狼","猪":"猪","猪":"猪","𤠔":"𤠔","獵":"獵","獺":"獺","⽞":"玄","率":"率","率":"率","⽟":"玉","王":"王","㺬":"㺬","玥":"玥","玲":"玲","㺸":"㺸","㺸":"㺸","珞":"珞","琉":"琉","理":"理","琢":"琢","瑇":"瑇","瑜":"瑜","瑩":"瑩","瑱":"瑱","瑱":"瑱","璅":"璅","璉":"璉","璘":"璘","瓊":"瓊","⽠":"瓜","⽡":"瓦","㼛":"㼛","甆":"甆","⽢":"甘","⽣":"生","甤":"甤","⽤":"用","⽥":"田","画":"画","甾":"甾","𤰶":"𤰶","留":"留","略":"略","異":"異","異":"異","𤲒":"𤲒","⽦":"疋","⽧":"疒","痢":"痢","瘐":"瘐","瘟":"瘟","瘝":"瘝","療":"療","癩":"癩","⽨":"癶","⽩":"白","𤾡":"𤾡","𤾸":"𤾸","⽪":"皮","⽫":"皿","𥁄":"𥁄","㿼":"㿼","益":"益","益":"益","盛":"盛","盧":"盧","䀈":"䀈","⽬":"目","直":"直","直":"直","𥃲":"𥃲","𥃳":"𥃳","省":"省","䀘":"䀘","𥄙":"𥄙","眞":"眞","真":"真","真":"真","𥄳":"𥄳","着":"着","睊":"睊","睊":"睊","鿃":"䀹","䀹":"䀹","䀹":"䀹","晣":"䀿","䁆":"䁆","瞋":"瞋","𥉉":"𥉉","瞧":"瞧","⽭":"矛","⽮":"矢","⽯":"石","䂖":"䂖","𥐝":"𥐝","硏":"研","硎":"硎","硫":"硫","碌":"碌","碌":"碌","碑":"碑","磊":"磊","磌":"磌","磌":"磌","磻":"磻","䃣":"䃣","礪":"礪","⽰":"示","⺭":"礻","礼":"礼","社":"社","祈":"祈","祉":"祉","𥘦":"𥘦","祐":"祐","祖":"祖","祖":"祖","祝":"祝","神":"神","祥":"祥","視":"視","視":"視","祿":"祿","𥚚":"𥚚","禍":"禍","禎":"禎","福":"福","福":"福","𥛅":"𥛅","禮":"禮","⽱":"禸","⽲":"禾","秊":"秊","䄯":"䄯","秫":"秫","稜":"稜","穊":"穊","穀":"穀","穀":"穀","穏":"穏","⽳":"穴","突":"突","𥥼":"𥥼","窱":"窱","立":"立","⽴":"立","⻯":"竜","𥪧":"𥪧","𥪧":"𥪧","竮":"竮","⽵":"竹","笠":"笠","節":"節","節":"節","䈂":"䈂","𥮫":"𥮫","篆":"篆","䈧":"䈧","築":"築","𥲀":"𥲀","𥳐":"𥳐","簾":"簾","籠":"籠","⽶":"米","类":"类","粒":"粒","精":"精","糒":"糒","糖":"糖","糨":"糨","䊠":"䊠","糣":"糣","糧":"糧","⽷":"糸","⺯":"糹","𥾆":"𥾆","紀":"紀","紐":"紐","索":"索","累":"累","絶":"絕","絣":"絣","絛":"絛","綠":"綠","綾":"綾","緇":"緇","練":"練","練":"練","練":"練","縂":"縂","䌁":"䌁","縉":"縉","縷":"縷","繁":"繁","繅":"繅","𦇚":"𦇚","䌴":"䌴","⽸":"缶","𦈨":"𦈨","缾":"缾","𦉇":"𦉇","⽹":"网","⺫":"罒","⺲":"罒","⺱":"罓","䍙":"䍙","署":"署","𦋙":"𦋙","罹":"罹","罺":"罺","羅":"羅","𦌾":"𦌾","⽺":"羊","羕":"羕","羚":"羚","羽":"羽","⽻":"羽","翺":"翺","老":"老","⽼":"老","⺹":"耂","者":"者","者":"者","者":"者","⽽":"而","𦓚":"𦓚","⽾":"耒","𦔣":"𦔣","⽿":"耳","聆":"聆","聠":"聠","𦖨":"𦖨","聯":"聯","聰":"聰","聾":"聾","⾀":"聿","⺺":"肀","⾁":"肉","肋":"肋","肭":"肭","育":"育","䏕":"䏕","䏙":"䏙","腁":"胼","脃":"脃","脾":"脾","䐋":"䐋","朡":"朡","𦞧":"𦞧","𦞵":"𦞵","朦":"䑃","臘":"臘","⾂":"臣","臨":"臨","⾃":"自","臭":"臭","⾄":"至","⾅":"臼","舁":"舁","舁":"舁","舄":"舄","⾆":"舌","舘":"舘","⾇":"舛","⾈":"舟","䑫":"䑫","⾉":"艮","良":"良","⾊":"色","⾋":"艸","艹":"艹","艹":"艹","⺾":"艹","⺿":"艹","⻀":"艹","芋":"芋","芑":"芑","芝":"芝","花":"花","芳":"芳","芽":"芽","若":"若","若":"若","苦":"苦","𦬼":"𦬼","茶":"茶","荒":"荒","荣":"荣","茝":"茝","茣":"茣","莽":"莽","荓":"荓","菉":"菉","菊":"菊","菌":"菌","菜":"菜","菧":"菧","華":"華","菱":"菱","著":"著","著":"著","𦰶":"𦰶","莭":"莭","落":"落","葉":"葉","蔿":"蒍","𦳕":"𦳕","𦵫":"𦵫","蓮":"蓮","蓱":"蓱","蓳":"蓳","蓼":"蓼","蔖":"蔖","䔫":"䔫","蕤":"蕤","𦼬":"𦼬","藍":"藍","䕝":"䕝","𦾱":"𦾱","䕡":"䕡","藺":"藺","蘆":"蘆","䕫":"䕫","蘒":"蘒","蘭":"蘭","𧃒":"𧃒","虁":"蘷","蘿":"蘿","⾌":"虍","⻁":"虎","虐":"虐","虜":"虜","虜":"虜","虧":"虧","虩":"虩","⾍":"虫","蚩":"蚩","蚈":"蚈","蛢":"蛢","蜎":"蜎","蜨":"蜨","蝫":"蝫","蟡":"蟡","蝹":"蝹","蝹":"蝹","螆":"螆","䗗":"䗗","𧏊":"𧏊","螺":"螺","蠁":"蠁","䗹":"䗹","蠟":"蠟","⾎":"血","行":"行","⾏":"行","衠":"衠","衣":"衣","⾐":"衣","⻂":"衤","裂":"裂","𧙧":"𧙧","裏":"裏","裗":"裗","裞":"裞","裡":"裡","裸":"裸","裺":"裺","䘵":"䘵","褐":"褐","襁":"襁","襤":"襤","⾑":"襾","⻄":"西","⻃":"覀","覆":"覆","見":"見","⾒":"見","𧢮":"𧢮","⻅":"见","⾓":"角","⾔":"言","𧥦":"𧥦","詽":"訮","訞":"䚶","䚾":"䚾","䛇":"䛇","誠":"誠","說":"說","說":"說","調":"調","請":"請","諒":"諒","論":"論","諭":"諭","諭":"諭","諸":"諸","諸":"諸","諾":"諾","諾":"諾","謁":"謁","謁":"謁","謹":"謹","謹":"謹","識":"識","讀":"讀","讏":"讆","變":"變","變":"變","⻈":"讠","⾕":"谷","⾖":"豆","豈":"豈","豕":"豕","⾗":"豕","豣":"豜","⾘":"豸","𧲨":"𧲨","⾙":"貝","貫":"貫","賁":"賁","賂":"賂","賈":"賈","賓":"賓","贈":"贈","贈":"贈","贛":"贛","⻉":"贝","⾚":"赤","⾛":"走","起":"起","趆":"赿","𧻓":"𧻓","𧼯":"𧼯","⾜":"足","跋":"跋","趼":"趼","跺":"跥","路":"路","跰":"跰","躛":"躗","⾝":"身","車":"車","⾞":"車","軔":"軔","輧":"軿","輦":"輦","輪":"輪","輸":"輸","輸":"輸","輻":"輻","轢":"轢","⻋":"车","⾟":"辛","辞":"辞","辰":"辰","⾠":"辰","⾡":"辵","辶":"辶","⻌":"辶","⻍":"辶","巡":"巡","連":"連","逸":"逸","逸":"逸","遲":"遲","遼":"遼","𨗒":"𨗒","𨗭":"𨗭","邏":"邏","⾢":"邑","邔":"邔","郎":"郎","郞":"郎","郞":"郎","郱":"郱","都":"都","𨜮":"𨜮","鄑":"鄑","鄛":"鄛","⾣":"酉","酪":"酪","醙":"醙","醴":"醴","⾤":"釆","里":"里","⾥":"里","量":"量","金":"金","⾦":"金","鈴":"鈴","鈸":"鈸","鉶":"鉶","鋗":"鋗","鋘":"鋘","鉼":"鉼","錄":"錄","鍊":"鍊","鎮":"鎭","鏹":"鏹","鐕":"鐕","𨯺":"𨯺","⻐":"钅","⻑":"長","⾧":"長","⻒":"镸","⻓":"长","⾨":"門","開":"開","䦕":"䦕","閭":"閭","閷":"閷","𨵷":"𨵷","⻔":"门","⾩":"阜","⻏":"阝","⻖":"阝","阮":"阮","陋":"陋","降":"降","陵":"陵","陸":"陸","陼":"陼","隆":"隆","隣":"隣","䧦":"䧦","⾪":"隶","隷":"隷","隸":"隷","隸":"隷","⾫":"隹","雃":"雃","離":"離","難":"難","難":"難","⾬":"雨","零":"零","雷":"雷","霣":"霣","𩅅":"𩅅","露":"露","靈":"靈","⾭":"靑","⻘":"青","靖":"靖","靖":"靖","𩇟":"𩇟","⾮":"非","⾯":"面","𩈚":"𩈚","⾰":"革","䩮":"䩮","䩶":"䩶","⾱":"韋","韛":"韛","韠":"韠","⻙":"韦","⾲":"韭","𩐊":"𩐊","⾳":"音","響":"響","響":"響","⾴":"頁","䪲":"䪲","頋":"頋","頋":"頋","頋":"頋","領":"領","頩":"頩","𩒖":"𩒖","頻":"頻","頻":"頻","類":"類","⻚":"页","⾵":"風","𩖶":"𩖶","⻛":"风","⾶":"飛","⻜":"飞","⻝":"食","⾷":"食","⻟":"飠","飢":"飢","飯":"飯","飼":"飼","䬳":"䬳","館":"館","餩":"餩","⻠":"饣","⾸":"首","⾹":"香","馧":"馧","⾺":"馬","駂":"駂","駱":"駱","駾":"駾","驪":"驪","⻢":"马","⾻":"骨","䯎":"䯎","⾼":"高","⾽":"髟","𩬰":"𩬰","鬒":"鬒","鬒":"鬒","⾾":"鬥","⾿":"鬯","⿀":"鬲","⿁":"鬼","⻤":"鬼","⿂":"魚","魯":"魯","鱀":"鱀","鱗":"鱗","⻥":"鱼","⿃":"鳥","鳽":"鳽","䳎":"䳎","鵧":"鵧","䳭":"䳭","𪃎":"𪃎","鶴":"鶴","𪄅":"𪄅","䳸":"䳸","鷺":"鷺","𪈎":"𪈎","鸞":"鸞","鹃":"鹂","⿄":"鹵","鹿":"鹿","⿅":"鹿","𪊑":"𪊑","麗":"麗","麟":"麟","⿆":"麥","⻨":"麦","麻":"麻","⿇":"麻","𪎒":"𪎒","⿈":"黃","⻩":"黄","⿉":"黍","黎":"黎","䵖":"䵖","⿊":"黑","黒":"黑","墨":"墨","黹":"黹","⿋":"黹","⿌":"黽","鼅":"鼅","黾":"黾","⿍":"鼎","鼏":"鼏","⿎":"鼓","鼖":"鼖","⿏":"鼠","鼻":"鼻","⿐":"鼻","齃":"齃","⿑":"齊","⻬":"齐","⿒":"齒","𪘀":"𪘀","⻮":"齿","龍":"龍","⿓":"龍","龎":"龎","⻰":"龙","龜":"龜","龜":"龜","龜":"龜","⿔":"龜","⻳":"龟","⿕":"龠"}')
		},
		"./node_modules/unhomoglyph/index.js": function(e, t, i) {
			"use strict";
			var n = i("./node_modules/unhomoglyph/data.json");
			var r = RegExp(Object.keys(n).map((function(e) {
				return e.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1")
			})).join("|"), "g");

			function s(e) {
				return n[e]
			}
			e.exports = function(e) {
				return e.replace(r, s)
			}
		},
		"./node_modules/webpack/buildin/amd-define.js": function(e, t) {
			e.exports = function() {
				throw new Error("define cannot be used indirect")
			}
		}
	}
]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/vendors~Subreddit~SubredditWiki.c17b16c26feb8de5d65f.js.map