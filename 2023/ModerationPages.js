// https://www.redditstatic.com/desktop2x/ModerationPages.2d5960975e83d50fe7a6.js
// Retrieved at 7/5/2023, 1:50:03 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["ModerationPages", "CollectionCommentsPage~CommentsPage~ProfileComments~ProfileOverview~ProfilePrivate~StandalonePostPag~0596d05c", "CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81", "Governance~Reddit~Subreddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-compo~bd4baca2", "Reddit~StandalonePostPage~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-compone~9b425435", "Reddit~RichTextEditor~reddit-components-MediumPost~reddit-components-NotificationUnit-Button~removal~87f825ba", "Governance~ModListing~Reddit~ReportFlow", "Governance~ModListing~Reddit", "Governance~Reddit~SubredditForkingCTA", "ModListing~Reddit~StandalonePostPage", "Settings~SubredditWiki"], {
		"./src/chat/controls/Svg/index.m.less": function(e, t, n) {
			e.exports = {
				Component: "_2Qq40Mz_DMe0iARkTh8cZn",
				component: "_2Qq40Mz_DMe0iARkTh8cZn",
				disable: "_2xw21QiaL_ouF76MONf7hF",
				active: "_2dOhVJ6aPS9cbx0JfiKCW8",
				hover: "_1eWUKX11coBa2dErvWkP1q"
			}
		},
		"./src/chat/controls/Svg/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/chat/controls/Svg/index.m.less"),
				d = n.n(a);
			t.a = i.a.wrapped(e => {
				const t = {
						height: e.height || void 0,
						width: e.width || void 0
					},
					{
						disable: n,
						active: s,
						hover: i
					} = e;
				return r.a.createElement("svg", {
					className: Object(o.a)(e.className, {
						[d.a.disable]: n,
						[d.a.active]: s,
						[d.a.hover]: !!i
					}),
					viewBox: e.viewBox,
					style: t,
					onClick: e.onClick
				}, e.children)
			}, "Component", d.a)
		},
		"./src/devPlatform/components/ContextActions/ContextActionsLoader.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				i = n("./src/devPlatform/constants.ts"),
				a = n("./src/reddit/contexts/PageLayer/index.tsx"),
				d = n("./src/reddit/selectors/experiments/devPlatform.ts"),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./src/devPlatform/components/ContextActions/placeholder/ContextActionsPlaceholder.tsx");
			const u = Object(o.a)({
				resolved: {},
				chunkName: () => "devPlatform-components-ContextActions",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => Promise.all([n.e("vendors~devPlatform-components-AdminPanel-Utilities-DevPlatformConfig~devPlatform-components-ContextActions"), n.e("devPlatform-components-ContextActions")]).then(n.bind(null, "./src/devPlatform/components/ContextActions/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/devPlatform/components/ContextActions/index.tsx"
				}
			}, {
				ssr: !1
			});

			function m(e) {
				const t = Object(c.e)(e => Object(d.a)(e)),
					n = Object(a.ib)(),
					s = Object(c.e)(t => p(t, {
						...e,
						pageLayer: n
					}));
				return t ? r.a.createElement(u, {
					contextType: e.contextType,
					contextData: e.contextData,
					moderator: e.moderator,
					subreddit: s,
					isOnModQueueOverflowMenu: !!e.isOnModQueueOverflowMenu,
					fallback: r.a.createElement(l.a, {
						isOnModQueueOverflowMenu: !!e.isOnModQueueOverflowMenu,
						contextType: e.contextType,
						moderator: e.moderator,
						subreddit: s
					})
				}) : null
			}
			const p = (e, t) => {
				const n = Object(a.s)(e, {
					pageLayer: t.pageLayer
				});
				if (null != n) return n;
				const s = e.subreddits.models;
				switch (t.contextType) {
					case i.a.POST:
						return s[t.contextData.belongsTo.id];
					case i.a.COMMENT:
						return s[t.contextData.subredditId];
					case i.a.SUBREDDIT:
					default:
						return null
				}
			}
		},
		"./src/devPlatform/components/ContextActions/index.m.less": function(e, t, n) {
			e.exports = {
				DropdownRow: "_2A5FemPDmjHjEjpCkaUK2h",
				dropdownRow: "_2A5FemPDmjHjEjpCkaUK2h",
				DropdownRowBorderless: "nGJGslkMB0gn9S2lxUphf",
				dropdownRowBorderless: "nGJGslkMB0gn9S2lxUphf",
				Icon: "SnpDpl5eEAD07JaiyJbpr",
				icon: "SnpDpl5eEAD07JaiyJbpr"
			}
		},
		"./src/devPlatform/components/ContextActions/placeholder/ContextActionsPlaceholder.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/devPlatform/constants.ts"),
				i = n("./src/reddit/controls/Dropdown/Row.tsx"),
				a = n("./src/reddit/icons/fonts/index.tsx"),
				d = n("./src/devPlatform/components/ContextActions/index.m.less"),
				c = n.n(d);

			function l(e) {
				const t = Object(s.useMemo)(() => {
					var t, n;
					if (null == e.subreddit) return [];
					let s;
					try {
						return (null == (s = JSON.parse(atob(null !== (n = null === (t = e.subreddit) || void 0 === t ? void 0 : t.devPlatformMetadata) && void 0 !== n ? n : ""))) ? void 0 : s.contextActions) ? s.contextActions.sort((e, t) => e.actorHostname.localeCompare(t.actorHostname)).reduce((t, n) => {
							var s;
							let r = [];
							return (null === (s = n.actions) || void 0 === s ? void 0 : s.actions) && (r = n.actions.actions.filter(t => {
								var n, s, r, i, a;
								if (e.moderator && !(null === (n = t.users) || void 0 === n ? void 0 : n.moderator) || !e.moderator && (null === (s = t.users) || void 0 === s ? void 0 : s.moderator)) return !1;
								switch (e.contextType) {
									case o.a.POST:
										return !!(null === (r = t.contexts) || void 0 === r ? void 0 : r.post);
									case o.a.COMMENT:
										return !!(null === (i = t.contexts) || void 0 === i ? void 0 : i.comment);
									case o.a.SUBREDDIT:
										return !!(null === (a = t.contexts) || void 0 === a ? void 0 : a.subreddit);
									default:
										return !1
								}
							})), [...t, ...r]
						}, []).sort((e, t) => e.name.localeCompare(t.name)) : []
					} catch (r) {
						return []
					}
				}, [e.contextType, e.moderator, e.subreddit]);
				return r.a.createElement(r.a.Fragment, null, t.map(t => r.a.createElement(i.b, {
					disabled: !0,
					className: e.isOnModQueueOverflowMenu ? c.a.DropdownRowBorderless : c.a.DropdownRow,
					displayText: t.name,
					key: `${e.contextType}.${t.actionId}`
				}, r.a.createElement(a.a, {
					name: e.moderator ? "mod" : "bot",
					className: c.a.Icon
				}))))
			}
		},
		"./src/devPlatform/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			const s = "devvit-gateway-url",
				r = "devvit-mock-metadata",
				o = "devvit-debug-logging",
				i = "DEV_PLAT__OPEN_FORM_MODAL",
				a = "DEV_PLAT__OPEN_USER_INPUT_MODAL";
			var d;
			! function(e) {
				e[e.POST = 0] = "POST", e[e.COMMENT = 1] = "COMMENT", e[e.SUBREDDIT = 2] = "SUBREDDIT", e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED"
			}(d || (d = {}))
		},
		"./src/higherOrderComponents/asModal/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/elementIds.ts");
			const r = () => {
					const e = document.getElementById(s.a);
					e && (e.style.filter = "blur(10px)")
				},
				o = () => {
					const e = document.getElementById(s.a);
					e && e.style.removeProperty("filter")
				}
		},
		"./src/higherOrderComponents/asModal/index.m.less": function(e, t, n) {
			e.exports = {
				overlay: "_1DK52RbaamLOWw5UPaht_S",
				mIsVisible: "_1acwN_tUhJ8w-n7oCp-Aw3",
				mIsBlurred: "_3Tq-_9917Q-o0iyzcNAeZn",
				modal: "_2Bejocqb-InO8686E2ehf"
			}
		},
		"./src/higherOrderComponents/asModal/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/asModal/helpers.ts"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/FocusTrap/index.ts"),
				d = n("./src/lib/portal/index.tsx"),
				c = n("./src/reddit/actions/shortcuts/utils.ts"),
				l = n("./src/reddit/constants/shortcuts.ts"),
				u = n("./src/reddit/helpers/toggleBodyScroll/index.ts"),
				m = n("./src/higherOrderComponents/asModal/index.m.less"),
				p = n.n(m);

			function b() {
				return (b = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const f = e => {
				let {
					className: t,
					shouldBlurBackground: n,
					isVisible: s,
					...o
				} = e;
				return r.a.createElement("div", b({
					className: Object(i.a)(p.a.overlay, t, {
						[p.a.mIsVisible]: s,
						[p.a.mIsBlurred]: n
					})
				}, o))
			};

			function h(e) {
				class t extends s.Component {
					constructor(e) {
						super(e), this.getRef = e => this.ref = e, this.onClick = e => e.stopPropagation(), this.onOverlayClick = e => {
							this.props.onOverlayClick && this.props.onOverlayClick(), e.stopPropagation()
						}, this.state = {
							mounted: !1
						}
					}
					componentDidMount() {
						this.props.ignoreDefaultFocus || this.ref && this.ref.focus(), this.setState({
							mounted: !0
						}), Object(u.a)(), this.ref && (this.focusTrap = new a.b(this.ref), this.focusTrap.activate()), this.props.shouldBlurBackground && Object(o.a)()
					}
					componentWillUnmount() {
						this.setState({
							mounted: !1
						}), Object(u.b)(), Object(c.d)(), this.focusTrap && this.focusTrap.deactivate(), this.props.shouldBlurBackground && Object(o.b)()
					}
					render() {
						const {
							props: t
						} = this, {
							className: n,
							ignoreDefaultFocus: s,
							onOverlayClick: o,
							overlayClassName: a,
							overlayCustomStyles: c,
							shouldBlurBackground: u,
							withOverlay: m,
							...b
						} = t, h = b;
						return r.a.createElement(d.a, {
							container: document.getElementById(l.b)
						}, r.a.createElement(f, {
							className: a,
							isVisible: m,
							onClick: this.onOverlayClick,
							shouldBlurBackground: u,
							style: c
						}, r.a.createElement("div", {
							"aria-modal": !0,
							className: Object(i.a)(p.a.modal, n),
							onClick: this.onClick,
							ref: this.getRef,
							role: "dialog",
							tabIndex: -1
						}, r.a.createElement(e, h))))
					}
				}
				return t
			}
		},
		"./src/higherOrderComponents/warnOnChildrenCount/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			n("./src/lib/logs/console.ts");
			t.a = function(e, t) {
				return t => r.a.createElement(e, t)
			}
		},
		"./src/higherOrderComponents/withAdClickLocation/Locations.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "a", (function() {
					return s
				})), n.d(t, "b", (function() {
					return r
				})),
				function(e) {
					e.UNKNOWN = "unknown", e.TITLE = "title", e.TOP_BAR = "top_bar", e.MEDIA = "media", e.BODY = "body", e.BACKGROUND = "background", e.CTA_URL = "cta_url", e.CTA_BUTTON = "cta_button", e.CTA_WHITESPACE = "cta_whitespace", e.CTA_CAPTION = "cta_caption", e.SUBREDDIT = "subreddit", e.TIMESTAMP = "timestamp", e.USER = "user"
				}(s || (s = {})),
				function(e) {
					e.COMMENTS = "comments", e.FLATLIST_SHARE = "fl_share", e.FLATLIST_AWARD = "fl_award", e.FLATLIST_SAVE = "fl_save", e.FLATLIST_GENERAL = "fl_unknown", e.OVERFLOW_MENU = "overflow_menu", e.UPVOTE = "upvote", e.DOWNVOTE = "downvote"
				}(r || (r = {}))
		},
		"./src/higherOrderComponents/withAdClickLocation/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const a = e => (e, t, n) => ({
				...i.p(e),
				source: "post",
				action: "click",
				noun: "ad",
				adClick: {
					location: t
				},
				actionInfo: i.d(e),
				adblock: i.f(e),
				app: i.g(e),
				feed: i.s(e),
				geo: i.u(e),
				platform: i.J(e),
				referrer: i.ab(e),
				request: i.bb(e),
				screen: i.db(e),
				session: i.ib(e),
				user: i.tb(e),
				media: n ? i.D(e, n) : null,
				post: n ? i.L(e, n) : null
			});
			var d = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				c = n("./src/telemetry/index.ts");
			const l = new Set;

			function u(e) {
				function t(t) {
					const n = Object(o.f)().getState(),
						{
							post: s
						} = {
							...t
						};
					return s && s.isSponsored ? r.a.createElement("div", {
						onClickCapture: function(e, s) {
							var r, o;
							if (l.has(e.timeStamp)) return;
							l.add(e.timeStamp);
							const i = function(e) {
								if (e.dataset.adclicklocation) return e.dataset.adclicklocation;
								const t = e.closest(".PostContainer, [data-adclicklocation]");
								return t ? t.dataset.adclicklocation : d.a.UNKNOWN
							}(e.target);
							i && (! function(e, t) {
								return Object.values(t).some(t => t === e)
							}(i, d.b) ? Object(c.a)(a(s)(n, i, null === (o = t.post) || void 0 === o ? void 0 : o.postId)) : Object(c.a)(a(s)(n, d.a.UNKNOWN, null === (r = t.post) || void 0 === r ? void 0 : r.postId)))
						}
					}, r.a.createElement(e, t)) : r.a.createElement(e, t)
				}
				const n = e.name || e.displayName;
				return t.displayName = `WithAdClickLocation(${n})`, t
			}
		},
		"./src/higherOrderComponents/withImageUploads.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/actions/imageUploads.ts"),
				i = n("./src/reddit/models/Image/index.tsx"),
				a = n("./src/reddit/selectors/imageUploads.ts");
			const d = Object(r.c)({
				_imageUploads: a.b
			});

			function c(e, t) {
				return Object(s.b)(d, e => ({
					uploadImage: n => e(t(n)),
					cancelUpload: t => e(Object(o.h)(t))
				}), (function(e, t, n) {
					return {
						...n,
						...t,
						getImageUploadsIfModified: function(t) {
							return function(e, t) {
								const n = [];
								let s = !1;
								for (const r of t)
									if (Object(i.i)(r) || e[r.id])
										if (e[r.id]) {
											const t = e[r.id];
											n.push(t), s = s || t !== r
										} else s = !0;
								else n.push(r);
								return s ? n : null
							}(e._imageUploads, t)
						}
					}
				}))(e)
			}
		},
		"./src/lib/CSSVariableProvider/withTheme.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/CSSVariableProvider/index.tsx");

			function i() {
				return (i = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function a(e) {
				const t = t => r.a.createElement(o.b.Consumer, null, n => r.a.createElement(e, i({
					theme: n
				}, t)));
				return t.displayName = `WithTheme(${e.displayName||e.name})`, t
			}
		},
		"./src/lib/FocusTrap/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = ['input:not([type="hidden"]):not([disabled])', "select:not([disabled])", "textarea:not([disabled])", "a[href]", "button:not([disabled])", '[tabindex]:not([tabindex="-1"]):not([disabled])', "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join();
			class r {
				constructor(e) {
					this.active = !1, this.onKeyDown = e => {
						if ("Tab" === e.key || 9 === e.keyCode) {
							const [t, n] = this.getTabbableNodes();
							if (!t || !n) return;
							e.shiftKey && e.target === t ? (e.preventDefault(), this.tryToFocusNode(n)) : e.shiftKey || e.target !== n || (e.preventDefault(), this.tryToFocusNode(t))
						}
					}, this.container = e
				}
				activate() {
					this.active || (this.active = !0, document.addEventListener("keydown", this.onKeyDown, !0))
				}
				deactivate() {
					this.active && (document.removeEventListener("keydown", this.onKeyDown, !0), this.active = !1)
				}
				getTabbableNodes() {
					const e = this.container.querySelectorAll(s);
					return [e[0], e[e.length - 1]]
				}
				tryToFocusNode(e) {
					e !== document.activeElement && e.focus && e.focus()
				}
			}
		},
		"./src/lib/LinkedListMap/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			class s {
				constructor(e) {
					this.value = e, this.next = void 0, this.prev = void 0
				}
			}
			class r {
				constructor(e) {
					this.key = e, this.tail = void 0, this.head = void 0, this.length = 0, this.itemsByKey = {}
				}
				static fromArray(e, t) {
					const n = new r(t);
					return e.forEach(e => n.push(e)), n
				}
				first() {
					if (this.tail) return this.tail.value
				}
				firstNode() {
					if (this.tail) return this.tail
				}
				forEach(e) {
					let t = this.tail;
					for (; t;) e(t.value), t = t.next
				}
				get(e) {
					const t = this.getNode(e);
					if (t) return t.value
				}
				getNode(e) {
					return this.itemsByKey[e]
				}
				has(e) {
					return e in this.itemsByKey
				}
				insertAfter(e, t) {
					const n = t instanceof s ? t : new s(t),
						r = this.getNode(e);
					if (!r) throw new Error(`Cannot find item with key ${e}`);
					n.prev = r, n.next = r.next, r.next = n, n.next && (n.next.prev = n);
					const o = t instanceof s ? t.value[this.key] : t[this.key];
					this.itemsByKey[o] = n, this.length++
				}
				insertBefore(e, t) {
					const n = t instanceof s ? t : new s(t),
						r = this.getNode(e);
					if (!r) throw new Error(`Cannot find item with key ${e}`);
					n.next = r, n.prev = r.prev, r.prev = n, n.prev && (n.prev.next = n);
					const o = t instanceof s ? t.value[this.key] : t[this.key];
					this.itemsByKey[o] = n, this.length++
				}
				last() {
					if (this.head) return this.head.value
				}
				lastNode() {
					if (this.head) return this.head
				}
				pop() {
					if (!this.head) return;
					return this.removeNode(this.head).value
				}
				push(e) {
					const t = e instanceof s ? e : new s(e);
					t.prev = this.head, this.head ? this.head.next = t : this.tail = t, this.head = t;
					const n = e instanceof s ? t.value[this.key] : e[this.key];
					this.itemsByKey[n] = t, this.length++
				}
				remove(e) {
					const t = this.getNode(e);
					if (t) return this.removeNode(t).value
				}
				removeNode(e) {
					return e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), e === this.tail && (this.tail = e.next), e === this.head && (this.head = e.prev), e.next = void 0, e.prev = void 0, this.itemsByKey[e.value[this.key]] = void 0, this.length--, e
				}
				shift() {
					if (!this.tail) return;
					return this.removeNode(this.tail).value
				}
				toArray() {
					const e = [];
					return this.forEach(t => e.push(t)), e
				}
				unshift(e) {
					const t = e instanceof s ? e : new s(e);
					t.next = this.tail, this.tail ? this.tail.prev = t : this.head = t, this.tail = t;
					const n = e instanceof s ? t.value[this.key] : e[this.key];
					this.itemsByKey[n] = t, this.length++
				}
			}
		},
		"./src/lib/LiveChatActiveUsers/index.m.less": function(e, t, n) {
			e.exports = {
				liveChatActiveUsers: "_25wqhmS87KWZppCM1ZHphX"
			}
		},
		"./src/lib/LiveChatActiveUsersWithLiveLabel/index.m.less": function(e, t, n) {
			e.exports = {
				liveParticipation: "_3qjBuOjYOffFET145CIGgi"
			}
		},
		"./src/lib/LiveLabel/index.m.less": function(e, t, n) {
			e.exports = {
				LiveLabel: "_1-nQNZpTU7wWajQDxaSGx8",
				liveLabel: "_1-nQNZpTU7wWajQDxaSGx8"
			}
		},
		"./src/lib/addAllowQuarantinedParam/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/addQueryParams/index.ts");
			t.a = e => Object(s.a)(e, {
				allow_quarantined: !0
			})
		},
		"./src/lib/assertNever.ts": function(e, t, n) {
			"use strict";

			function s(e) {
				throw new Error(`Unexpected object: ${e}`)
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/lib/asyncActions/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = e => `${e}_REQUESTED`,
				o = e => `${e}_SUCCEEDED`,
				i = e => `${e}_FAILED`;

			function a(e) {
				const t = r(e),
					n = o(e),
					a = i(e);
				return {
					requestedActionType: t,
					requested: Object(s.a)(t),
					succeededActionType: n,
					succeeded: Object(s.a)(n),
					failedActionType: a,
					failed: Object(s.a)(a)
				}
			}
			var d;
			! function(e) {
				e[e.New = 0] = "New", e[e.Pending = 1] = "Pending", e[e.Succeeded = 2] = "Succeeded", e[e.Failed = 3] = "Failed"
			}(d || (d = {}));
			const c = (e, t, n) => (function() {
				let s = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : d.New,
					r = arguments.length > 1 ? arguments[1] : void 0;
				switch (r.type) {
					case e:
						return s === d.New ? d.Pending : s;
					case t:
						return s === d.Pending ? d.Succeeded : s;
					case n:
						return s === d.Pending ? d.Failed : s;
					default:
						return s
				}
			})
		},
		"./src/lib/avatarShareImages.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			const s = 16765092,
				r = "https://i.redd.it/snoovatar",
				o = "snoovatars",
				i = "avatars";

			function a(e) {
				return `${r}/${+e>=s?i:o}/shared/${e}.png`
			}
		},
		"./src/lib/bigNumberUtils/percent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/bignumber.js/bignumber.js");

			function r(e, t) {
				const n = new s.BigNumber(e),
					r = new s.BigNumber(t),
					o = new s.BigNumber(n.dividedBy(r)),
					i = new s.BigNumber("100").multipliedBy(o);
				return new s.BigNumber(i).toNumber()
			}
		},
		"./src/lib/colors/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			}));
			const s = "#000",
				r = "#FFF",
				o = "#FF4500",
				i = "#0079D3",
				a = "#46D160",
				d = {
					black: s,
					white: r,
					orangered: o,
					alienblue: i,
					tone1: "#1A1A1B",
					tone2: "#6A6D6F",
					tone3: "#878A8C",
					tone4: "#D3D6DA",
					tone5: "#EDEFF1",
					tone6: "#F6F7F8",
					tone7: "#FFFFFF",
					primary: "#24A0ED",
					secondary: "#006CBF",
					upvote: o,
					downvote: "#7193FF",
					positive: a,
					negative: "#EA0027",
					caution: "#FFB000",
					admin: o,
					moderator: "#46D160",
					self: "#0DD3BB",
					coins: "#DDBD37",
					live: o,
					nsfw: "#FF585B",
					spoiler: "#1A1A1B"
				},
				c = {
					...d,
					tone1: "#D7DADC",
					tone2: "#818384",
					tone3: "#565758",
					tone4: "#3A3A3C",
					tone5: "#272729",
					tone6: "#1A1A1B",
					tone7: "#121213",
					primary: "#006CBF",
					secondary: "#24A0ED",
					coins: "#FFE600",
					spoiler: "#D7DADC"
				}
		},
		"./src/lib/combineRefs/index.tsx": function(e, t, n) {
			"use strict";
			t.a = function() {
				for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
				return e => {
					t.forEach(t => {
						if (t) return "function" == typeof t ? t(e) : void(t.current = e)
					})
				}
			}
		},
		"./src/lib/constants/icons.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = {
				activity: "activity",
				activity_fill: "activity_fill",
				add: "add",
				add_fill: "add_fill",
				add_media: "add_media",
				add_media_fill: "add_media_fill",
				add_to_feed: "add_to_feed",
				add_to_feed_fill: "add_to_feed_fill",
				admin: "admin",
				admin_fill: "admin_fill",
				all: "all",
				all_fill: "all_fill",
				appearance: "appearance",
				appearance_fill: "appearance_fill",
				approve: "approve",
				approve_fill: "approve_fill",
				archived: "archived",
				archived_fill: "archived_fill",
				aspect_ratio: "aspect_ratio",
				aspect_ratio_fill: "aspect_ratio_fill",
				aspect_rectangle: "aspect_rectangle",
				aspect_rectangle_fill: "aspect_rectangle_fill",
				attach: "attach",
				attach_fill: "attach_fill",
				audio: "audio",
				audio_fill: "audio_fill",
				author: "author",
				author_fill: "author_fill",
				avatar_style: "avatar_style",
				avatar_style_fill: "avatar_style_fill",
				award: "award",
				award_fill: "award_fill",
				back: "back",
				back_fill: "back_fill",
				ban: "ban",
				ban_fill: "ban_fill",
				best: "best",
				best_fill: "best_fill",
				block: "block",
				block_fill: "block_fill",
				bold: "bold",
				bold_fill: "bold_fill",
				bot: "bot",
				bot_fill: "bot_fill",
				bounce: "bounce",
				bounce_fill: "bounce_fill",
				browse: "browse",
				browse_fill: "browse_fill",
				browser: "browser",
				browser_fill: "browser_fill",
				cake: "cake",
				cake_fill: "cake_fill",
				calendar: "calendar",
				camera: "camera",
				camera_fill: "camera_fill",
				campaign: "campaign",
				caret_down: "caret_down",
				caret_down_fill: "caret_down_fill",
				caret_left: "caret_left",
				caret_left_fill: "caret_left_fill",
				caret_right: "caret_right",
				caret_right_fill: "caret_right_fill",
				caret_up: "caret_up",
				caret_up_fill: "caret_up_fill",
				chat: "chat",
				chat_fill: "chat_fill",
				chat_group: "chat_group",
				chat_group_fill: "chat_group_fill",
				chat_new: "chat_new",
				chat_new_fill: "chat_new_fill",
				checkbox: "checkbox",
				checkbox_dismiss: "checkbox_dismiss",
				checkbox_dismiss_fill: "checkbox_dismiss_fill",
				checkbox_fill: "checkbox_fill",
				checkmark: "checkmark",
				checkmark_fill: "checkmark_fill",
				chrome: "chrome",
				chrome_fill: "chrome_fill",
				clear: "clear",
				clear_fill: "clear_fill",
				close: "close",
				close_fill: "close_fill",
				closed_captioning: "closed_captioning",
				closed_captioning_fill: "closed_captioning_fill",
				code_block: "code_block",
				code_block_fill: "code_block_fill",
				code_inline: "code_inline",
				code_inline_fill: "code_inline_fill",
				coins: "coins",
				coins_fill: "coins_fill",
				coins_outline_color: "coins_outline_color",
				collapse: "collapse",
				collapse_fill: "collapse_fill",
				collection: "collection",
				collection_fill: "collection_fill",
				comment: "comment",
				comment_fill: "comment_fill",
				comments: "comments",
				comments_fill: "comments_fill",
				community: "community",
				community_fill: "community_fill",
				controversial: "controversial",
				controversial_fill: "controversial_fill",
				crop: "crop",
				crop_fill: "crop_fill",
				crosspost: "crosspost",
				crosspost_fill: "crosspost_fill",
				crowd_control: "crowd_control",
				crowd_control_fill: "crowd_control_fill",
				custom_feed: "custom_feed",
				custom_feed_fill: "custom_feed_fill",
				customize: "customize",
				customize_fill: "customize_fill",
				day: "day",
				day_fill: "day_fill",
				delete: "delete",
				delete_fill: "delete_fill",
				discover: "discover",
				discover_fill: "discover_fill",
				dismiss_all: "dismiss_all",
				dismiss_all_fill: "dismiss_all_fill",
				distinguish: "distinguish",
				distinguish_fill: "distinguish_fill",
				down: "down",
				down_fill: "down_fill",
				download: "download",
				download_fill: "download_fill",
				downvote: "downvote",
				downvote_fill: "downvote_fill",
				downvotes: "downvotes",
				downvotes_fill: "downvotes_fill",
				drag: "drag",
				duplicate: "duplicate",
				duplicate_fill: "duplicate_fill",
				edit: "edit",
				edit_fill: "edit_fill",
				effect: "effect",
				effect_fill: "effect_fill",
				embed: "embed",
				embed_fill: "embed_fill",
				emoji: "emoji",
				emoji_fill: "emoji_fill",
				expand: "expand",
				expand_fill: "expand_fill",
				external_link: "external_link",
				external_link_fill: "external_link_fill",
				feed_posts: "feed_posts",
				feed_posts_fill: "feed_posts_fill",
				feed_video: "feed_video",
				feed_video_fill: "feed_video_fill",
				filter: "filter",
				filter_fill: "filter_fill",
				format: "format",
				format_fill: "format_fill",
				forward: "forward",
				forward_fill: "forward_fill",
				gif_post: "gif_post",
				gif_post_fill: "gif_post_fill",
				heart: "heart",
				heart_fill: "heart_fill",
				help: "help",
				help_fill: "help_fill",
				hide: "hide",
				hide_fill: "hide_fill",
				history: "history",
				history_fill: "history_fill",
				home: "home",
				home_fill: "home_fill",
				hot: "hot",
				hot_fill: "hot_fill",
				ignore_reports: "ignore_reports",
				ignore_reports_fill: "ignore_reports_fill",
				image_post: "image_post",
				image_post_fill: "image_post_fill",
				info: "info",
				info_fill: "info_fill",
				italic: "italic",
				italic_fill: "italic_fill",
				join: "join",
				join_fill: "join_fill",
				joined: "joined",
				joined_fill: "joined_fill",
				jump_down: "jump_down",
				jump_down_fill: "jump_down_fill",
				jump_up: "jump_up",
				jump_up_fill: "jump_up_fill",
				karma: "karma",
				karma_fill: "karma_fill",
				keyboard: "keyboard",
				keyboard_fill: "keyboard_fill",
				kick: "kick",
				kick_fill: "kick_fill",
				leave: "leave",
				leave_fill: "leave_fill",
				left: "left",
				left_fill: "left_fill",
				link_post: "link_post",
				link_post_fill: "link_post_fill",
				list_bulleted: "list_bulleted",
				list_bulleted_fill: "list_bulleted_fill",
				list_numbered: "list_numbered",
				list_numbered_fill: "list_numbered_fill",
				live: "live",
				live_fill: "live_fill",
				load: "load",
				location: "location",
				location_fill: "location_fill",
				lock: "lock",
				lock_fill: "lock_fill",
				logout: "logout",
				logout_fill: "logout_fill",
				loop: "loop",
				loop_fill: "loop_fill",
				mark_read: "mark_read",
				mark_read_fill: "mark_read_fill",
				mask: "mask",
				mask_fill: "mask_fill",
				media_gallery: "media_gallery",
				media_gallery_fill: "media_gallery_fill",
				meme: "meme",
				meme_fill: "meme_fill",
				menu: "menu",
				menu_fill: "menu_fill",
				message: "message",
				message_fill: "message_fill",
				mod: "mod",
				mod_fill: "mod_fill",
				mod_mail: "mod_mail",
				mod_mail_fill: "mod_mail_fill",
				mod_mode: "mod_mode",
				mod_mode_fill: "mod_mode_fill",
				mod_mute: "mod_mute",
				mod_mute_fill: "mod_mute_fill",
				mod_overflow: "mod_overflow",
				mod_overflow_fill: "mod_overflow_fill",
				mod_queue: "mod_queue",
				mod_queue_fill: "mod_queue_fill",
				mod_unmute: "mod_unmute",
				mod_unmute_fill: "mod_unmute_fill",
				new: "new",
				new_fill: "new_fill",
				night: "night",
				night_fill: "night_fill",
				notification: "notification",
				notification_fill: "notification_fill",
				notification_frequent: "notification_frequent",
				notification_frequent_fill: "notification_frequent_fill",
				notification_off: "notification_off",
				notification_off_fill: "notification_off_fill",
				nsfw: "nsfw",
				nsfw_fill: "nsfw_fill",
				nsfw_language: "nsfw_language",
				nsfw_language_fill: "nsfw_language_fill",
				nsfw_violence: "nsfw_violence",
				nsfw_violence_fill: "nsfw_violence_fill",
				original: "original",
				original_fill: "original_fill",
				overflow_carat: "overflow_carat",
				overflow_carat_fill: "overflow_carat_fill",
				overflow_horizontal: "overflow_horizontal",
				overflow_vertical: "overflow_vertical",
				pause: "pause",
				pause_fill: "pause_fill",
				payment: "payment",
				payment_fill: "payment_fill",
				peace: "peace",
				peace_fill: "peace_fill",
				pending_posts: "pending_posts",
				pending_posts_fill: "pending_posts_fill",
				pin: "pin",
				pin_fill: "pin_fill",
				play: "play",
				play_fill: "play_fill",
				poll_post: "poll_post",
				poll_post_fill: "poll_post_fill",
				popular: "popular",
				popular_fill: "popular_fill",
				prediction: "prediction",
				prediction_fill: "prediction_fill",
				premium: "premium",
				premium_fill: "premium_fill",
				privacy: "privacy",
				privacy_fill: "privacy_fill",
				profile: "profile",
				profile_fill: "profile_fill",
				promote_snoo: "promote_snoo",
				qr_code: "qr_code",
				quarantined: "quarantined",
				quarantined_fill: "quarantined_fill",
				quote: "quote",
				quote_fill: "quote_fill",
				r_slash: "r_slash",
				r_slash_fill: "r_slash_fill",
				radio_button: "radio_button",
				radio_button_fill: "radio_button_fill",
				random: "random",
				random_fill: "random_fill",
				rating_drugs: "rating_drugs",
				rating_everyone: "rating_everyone",
				rating_mature: "rating_mature",
				rating_nsfw: "rating_nsfw",
				rating_violence: "rating_violence",
				refresh: "refresh",
				refresh_fill: "refresh_fill",
				remove: "remove",
				remove_fill: "remove_fill",
				reply: "reply",
				reply_fill: "reply_fill",
				report: "report",
				report_fill: "report_fill",
				reverse: "reverse",
				reverse_fill: "reverse_fill",
				right: "right",
				right_fill: "right_fill",
				rising: "rising",
				rising_fill: "rising_fill",
				rotate: "rotate",
				rotate_fill: "rotate_fill",
				rules: "rules",
				rules_fill: "rules_fill",
				safari: "safari",
				safari_fill: "safari_fill",
				save: "save",
				save_fill: "save_fill",
				saved: "saved",
				saved_fill: "saved_fill",
				scheduled: "scheduled",
				scheduled_fill: "scheduled_fill",
				search: "search",
				search_fill: "search_fill",
				self: "self",
				self_fill: "self_fill",
				send: "send",
				send_fill: "send_fill",
				settings: "settings",
				settings_fill: "settings_fill",
				share: "share",
				share_android: "share_android",
				share_android_fill: "share_android_fill",
				share_fill: "share_fill",
				share_ios: "share_ios",
				share_ios_fill: "share_ios_fill",
				show: "show",
				show_fill: "show_fill",
				side_menu: "side_menu",
				side_menu_fill: "side_menu_fill",
				skipback10: "skipback10",
				skipback10_fill: "skipback10_fill",
				skipforward10: "skipforward10",
				skipforward10_fill: "skipforward10_fill",
				sort: "sort",
				sort_fill: "sort_fill",
				spam: "spam",
				spam_fill: "spam_fill",
				spoiler: "spoiler",
				spoiler_fill: "spoiler_fill",
				sponsored: "sponsored",
				sponsored_fill: "sponsored_fill",
				star: "star",
				star_fill: "star_fill",
				statistics: "statistics",
				statistics_fill: "statistics_fill",
				sticker: "sticker",
				sticker_fill: "sticker_fill",
				strikethrough: "strikethrough",
				strikethrough_fill: "strikethrough_fill",
				subtract: "subtract",
				subtract_fill: "subtract_fill",
				superscript: "superscript",
				superscript_fill: "superscript_fill",
				swipe_back: "swipe_back",
				swipe_back_fill: "swipe_back_fill",
				swipe_down: "swipe_down",
				swipe_down_fill: "swipe_down_fill",
				swipe_forward: "swipe_forward",
				swipe_forward_fill: "swipe_forward_fill",
				swipe_up: "swipe_up",
				swipe_up_fill: "swipe_up_fill",
				table: "table",
				table_fill: "table_fill",
				tag: "tag",
				tag_fill: "tag_fill",
				tap: "tap",
				tap_fill: "tap_fill",
				text_post: "text_post",
				text_post_fill: "text_post_fill",
				text_size: "text_size",
				text_size_fill: "text_size_fill",
				top: "top",
				top_fill: "top_fill",
				topic: "topic",
				topic_activism: "topic_activism",
				topic_addiction_support: "topic_addiction_support",
				topic_advice: "topic_advice",
				topic_animals: "topic_animals",
				topic_anime: "topic_anime",
				topic_art: "topic_art",
				topic_beauty: "topic_beauty",
				topic_business: "topic_business",
				topic_careers: "topic_careers",
				topic_cars: "topic_cars",
				topic_celebrity: "topic_celebrity",
				topic_crafts: "topic_crafts",
				topic_crypto: "topic_crypto",
				topic_culture: "topic_culture",
				topic_diy: "topic_diy",
				topic_entertainment: "topic_entertainment",
				topic_ethics: "topic_ethics",
				topic_family: "topic_family",
				topic_fashion: "topic_fashion",
				topic_fitness: "topic_fitness",
				topic_food: "topic_food",
				topic_funny: "topic_funny",
				topic_gender: "topic_gender",
				topic_health: "topic_health",
				topic_help: "topic_help",
				topic_history: "topic_history",
				topic_internet: "topic_internet",
				topic_law: "topic_law",
				topic_learning: "topic_learning",
				topic_lifestyle: "topic_lifestyle",
				topic_mature: "topic_mature",
				topic_mensfashion: "topic_mensfashion",
				topic_menshealth: "topic_menshealth",
				topic_meta: "topic_meta",
				topic_military: "topic_military",
				topic_movies: "topic_movies",
				topic_music: "topic_music",
				topic_news: "topic_news",
				topic_other: "topic_other",
				topic_outdoors: "topic_outdoors",
				topic_pets: "topic_pets",
				topic_photography: "topic_photography",
				topic_places: "topic_places",
				topic_politics: "topic_politics",
				topic_programming: "topic_programming",
				topic_reading: "topic_reading",
				topic_reading_fill: "topic_reading_fill",
				topic_religion: "topic_religion",
				topic_science: "topic_science",
				topic_sexorientation: "topic_sexorientation",
				topic_sports: "topic_sports",
				topic_style: "topic_style",
				topic_tabletop: "topic_tabletop",
				topic_technology: "topic_technology",
				topic_television: "topic_television",
				topic_traumasupport: "topic_traumasupport",
				topic_travel: "topic_travel",
				topic_videogaming: "topic_videogaming",
				topic_womenshealth: "topic_womenshealth",
				trim: "trim",
				trim_fill: "trim_fill",
				trophy: "trophy",
				trophy_fill: "trophy_fill",
				u_slash: "u_slash",
				u_slash_fill: "u_slash_fill",
				unban: "unban",
				unban_fill: "unban_fill",
				undo: "undo",
				undo_fill: "undo_fill",
				unheart: "unheart",
				unlock: "unlock",
				unlock_fill: "unlock_fill",
				unmod: "unmod",
				unmod_fill: "unmod_fill",
				unpin: "unpin",
				unpin_fill: "unpin_fill",
				unverified: "unverified",
				unverified_fill: "unverified_fill",
				up: "up",
				up_fill: "up_fill",
				upload: "upload",
				upload_fill: "upload_fill",
				upvote: "upvote",
				upvote_fill: "upvote_fill",
				upvotes: "upvotes",
				upvotes_fill: "upvotes_fill",
				user: "user",
				user_fill: "user_fill",
				user_note: "user_note",
				user_note_fill: "user_note_fill",
				vault: "vault",
				vault_fill: "vault_fill",
				verified: "verified",
				verified_fill: "verified_fill",
				video_camera: "video_camera",
				video_camera_fill: "video_camera_fill",
				video_post: "video_post",
				video_post_fill: "video_post_fill",
				view_card: "view_card",
				view_card_fill: "view_card_fill",
				view_classic: "view_classic",
				view_classic_fill: "view_classic_fill",
				view_compact: "view_compact",
				view_compact_fill: "view_compact_fill",
				view_grid_fill: "view_grid_fill",
				view_grid_fill_1: "view_grid_fill_1",
				views: "views",
				views_fill: "views_fill",
				volume: "volume",
				volume_fill: "volume_fill",
				volume_mute: "volume_mute",
				volume_mute_fill: "volume_mute_fill",
				wiki: "wiki",
				wiki_fill: "wiki_fill",
				wiki_ban: "wiki_ban",
				wiki_ban_fill: "wiki_ban_fill",
				wiki_unban: "wiki_unban",
				wiki_unban_fill: "wiki_unban_fill",
				world: "world",
				world_fill: "world_fill"
			}
		},
		"./src/lib/constants/specialMembership.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "custom"
		},
		"./src/lib/forceHttps/index.ts": function(e, t, n) {
			"use strict";
			t.a = function(e) {
				return e.startsWith("http") || e.startsWith("blob") ? e.replace(/^http:\/\//i, "https://") : `https://${e}`
			}
		},
		"./src/lib/formatApiError/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts");

			function o(e, t) {
				return e ? e.fields && e.fields.length ? e.fields.map(e => e.msg).join(", ") : e.type && i[e.type] ? i[e.type]() : 401 === t ? s.fbt._("There was an authentication error", null, {
					hk: "2KZTRv"
				}) : s.fbt._("Something went wrong", null, {
					hk: "3i6szH"
				}) : ""
			}
			const i = {
				[r.k]: () => s.fbt._("you're not allowed to do that", null, {
					hk: "1jGKQw"
				}),
				[r.N]: () => s.fbt._("GIF size must be less than {max file size}MB", [s.fbt._param("max file size", Math.floor(r.eb / r.mb).toString())], {
					hk: "1zzsdM"
				}),
				[r.W]: () => s.fbt._("Image size must be less than {max file size}MB", [s.fbt._param("max file size", Math.floor(r.gb / r.mb).toString())], {
					hk: "3H6bF8"
				}),
				[r.Y]: () => s.fbt._("Sorry, we accept only images (.png, .jpeg, .gif) and videos (.mp4, .mov)", null, {
					hk: "1hw868"
				}),
				[r.vc]: () => s.fbt._("Video size must be less than {max file size}GB", [s.fbt._param("max file size", (r.kb / r.mb / 1024).toFixed(1))], {
					hk: "4FkABU"
				})
			}
		},
		"./src/lib/getShortenedLink.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/models/Media/index.ts"),
				r = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				o = n.n(r);
			t.a = function(e) {
				var t;
				const {
					source: n,
					isSponsored: r,
					domainOverride: i,
					callToAction: a
				} = e;
				let d = "";
				if (r) {
					if (n && n.displayText) {
						const e = 36 - (null !== (t = null == a ? void 0 : a.length) && void 0 !== t ? t : 0);
						return n.displayText.length > e ? n.displayText.substring(0, e - 3) + "..." : n.displayText
					}
					d = i || Object(s.E)(e)
				} else d = Object(s.E)(e);
				const c = o.a.parse(d),
					l = c.path || "",
					u = l.length > 7 ? l.substring(0, 7) + "..." : l;
				return (c.hostname ? c.hostname.replace("www.", "") : "") + u
			}
		},
		"./src/lib/hooks/useOnClickOutside.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/react/index.js");

			function r(e, t) {
				const n = Object(s.useCallback)(n => {
					if (!t) return;
					const s = document.getElementById(e);
					s && (s.contains(n.target) || t(n))
				}, [e, t]);
				Object(s.useEffect)(() => {
					if (t) return window.addEventListener("click", n), () => {
						window.removeEventListener("click", n)
					}
				}, [t, n])
			}
		},
		"./src/lib/hooks/usePrevious.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/react/index.js");

			function r(e) {
				const t = Object(s.useRef)();
				return Object(s.useEffect)(() => {
					t.current = e
				}), t.current
			}
		},
		"./src/lib/hooks/useTooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./node_modules/icepick/icepick.js"),
				r = n("./node_modules/react/index.js"),
				o = n("./node_modules/react-popper/lib/esm/usePopper.js");
			const i = Object(s.freeze)({
				modifiers: []
			});

			function a(e) {
				let t = "object" == typeof e ? e : i;
				return Array.isArray(t.modifiers) || (t = Object(s.assoc)(t, "modifiers", i.modifiers)), t
			}

			function d(e) {
				const [t, n] = Object(r.useState)(null), [i, d] = Object(r.useState)(null), [c, l] = Object(r.useState)(null), [u, m] = Object(r.useState)(!1), p = Object(r.useCallback)(async () => m(!0), []), b = Object(r.useCallback)(() => m(!1), []), f = Object(r.useCallback)(() => m(!u), [u]), h = Object(r.useMemo)(() => {
					const t = a(e);
					return c ? Object(s.updateIn)(t, ["modifiers"], e => Object(s.push)(e, {
						name: "arrow",
						options: {
							element: c
						}
					})) : t
				}, [c, e]), {
					attributes: g,
					styles: v,
					update: x
				} = Object(o.a)(t, i, h);
				return Object(r.useMemo)(() => ({
					arrowProps: {
						ref: l,
						style: v.arrow,
						...g.arrow
					},
					hide: b,
					popperProps: {
						ref: d,
						style: v.popper,
						...g.popper
					},
					show: p,
					target: {
						element: t,
						ref: n
					},
					toggle: f,
					visible: u,
					update: x
				}), [l, g, d, b, p, v, t, n, f, u, x])
			}
		},
		"./src/lib/humanizeDate/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/constants/intlSupport.ts");

			function i(e) {
				let {
					showDay: t,
					useUtc: n,
					shortMonths: i,
					locale: a = s.DEFAULT_LOCALE
				} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
				const d = new Date(e * r.Xb);
				return o.a ? new Intl.DateTimeFormat(a, {
					month: i ? "short" : "long",
					day: t ? "numeric" : void 0,
					year: "numeric",
					timeZone: n ? "UTC" : void 0
				}).format(d) : d.toLocaleString()
			}
		},
		"./src/lib/humanizeUTCDate/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js");
			t.a = function(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : s.DEFAULT_LOCALE;
				const n = e.toString().length > 10,
					r = new Date(e * (n ? 1 : 1e3));
				return r.toLocaleString(t, {
					weekday: "short",
					month: "short",
					year: "numeric",
					day: "2-digit",
					hour: "2-digit",
					minute: "2-digit",
					second: "2-digit",
					timeZoneName: "short",
					timeZone: "UTC"
				})
			}
		},
		"./src/lib/linkMatchers/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "j", (function() {
				return h
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "h", (function() {
				return C
			})), n.d(t, "i", (function() {
				return A
			}));
			var s = n("./node_modules/linkify-it/index.js"),
				r = n.n(s),
				o = n("./node_modules/tlds/index.js"),
				i = n.n(o),
				a = n("./src/lib/linkMatchers/customLinks.ts"),
				d = n("./node_modules/lodash/values.js"),
				c = n.n(d);
			const l = e => c()(a.b).includes(e.substring(1)),
				u = ["//", "ftp:", "http:", "https:", "mailto:"],
				m = e => ((e, t) => (t.forEach(t => e.add(t, null)), e))(e, u),
				p = r()().tlds(i.a).set({
					fuzzyIP: !0
				}),
				b = r()().set({
					fuzzyIP: !0,
					fuzzyEmail: !1
				}).add(a.g.mention.prefix, a.g.mention.config),
				f = m(r()()).set({
					fuzzyLink: !1,
					fuzzyEmail: !1
				}).add(a.g.subreddit.prefix, a.g.subreddit.config).add(a.g.subredditFull.prefix, a.g.subreddit.config),
				h = m(r()()).set({
					fuzzyLink: !1,
					fuzzyEmail: !1
				}).add(a.g.profile.prefix, a.g.profile.config).add(a.g.profileFull.prefix, a.g.profile.config),
				g = r()().tlds(i.a).set({
					fuzzyIP: !0
				}).add(a.g.subreddit.prefix, a.g.subreddit.config).add(a.g.subredditFull.prefix, a.g.subreddit.config).add(a.g.profile.prefix, a.g.profile.config).add(a.g.profileFull.prefix, a.g.profile.config).add(a.g.mention.prefix, a.g.mention.config),
				v = r()().tlds(i.a).set({
					fuzzyIP: !0,
					fuzzyEmail: !1
				}).add(a.g.subreddit.prefix, a.g.subredditFullUrl.config).add(a.g.subredditFull.prefix, a.g.subredditFullUrl.config),
				x = p.normalize;
			p.normalize = e => {
				x.call(p, e), !e.schema && e.url.startsWith("http:") && (e.url = `https:${e.url.slice(5)}`)
			};
			const E = (e, t) => {
					return (g.match(e) || []).filter(e => {
						const n = l(e.text);
						return !n || n && t
					})
				},
				O = e => {
					return [...h.match(e) || [], ...b.match(e) || []].map(e => !l(e.text) && e.text.replace(a.a, "")).filter(e => e)
				},
				C = (e, t) => {
					const n = e.match(t);
					if (n && 1 === n.length && 0 === n[0].index && n[0].lastIndex === t.length) return n[0]
				},
				A = e => {
					const t = p.match(e);
					if (t && 1 === t.length && 0 === t[0].index) {
						const n = t[0];
						return n.lastIndex === e.length ? n : ((e, t) => {
							const n = e.substring(t.lastIndex);
							if (/.*\/\/.*\/.*/.test(t.url) && /^(\?|\!)+$/.test(n)) return t.lastIndex += n.length, t.url += n, t
						})(e, n)
					}
				}
		},
		"./src/lib/loginHref/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/history/esm/history.js");
			t.a = (e, t, n) => {
				const o = Object(r.e)(e),
					i = encodeURIComponent(`${t}${o}`);
				return `${s.a.accountManagerOrigin}${n||"/login"}?dest=${i}`
			}
		},
		"./src/lib/makePostDraftPageKey/index.ts": function(e, t, n) {
			"use strict";

			function s(e) {
				let t = "PostDraftPage";
				return e.draftId && (t += `--[draftId:${e.draftId}]`), t
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/lib/memoizeByReference/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/lodash/every.js"),
				r = n.n(s);

			function o(e) {
				let t = null,
					n = null;
				return function() {
					for (var s = arguments.length, o = new Array(s), i = 0; i < s; i++) o[i] = arguments[i];
					return null !== t && o.length === t.length && r()(o, (e, n) => e === t[n]) || (t = o, n = e(...o)), n
				}
			}
		},
		"./src/lib/name/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			}));
			var s = n("./src/reddit/helpers/name/index.ts");
			const r = /^u_[\w-]+$/;

			function o(e) {
				return r.test(Object(s.i)(e))
			}

			function i(e) {
				return `u_${Object(s.i)(e)}`
			}

			function a(e, t) {
				return Object(s.i)(e) === Object(s.i)(t)
			}
		},
		"./src/lib/omitKey/index.ts": function(e, t, n) {
			"use strict";

			function s(e, t) {
				if (t in e) {
					const {
						[t]: n, ...s
					} = e;
					return s
				}
				return e
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/lib/onFocusAndVisibilityChange/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/brcast/dist/brcast.es.js");
			const r = () => "undefined" != typeof document,
				o = () => r() && "visible" === document.visibilityState,
				i = () => ({
					documentInFocus: o()
				}),
				{
					subscribe: a,
					unsubscribe: d,
					setState: c
				} = Object(s.a)(i()),
				l = {
					hidden: "visibilitychange",
					webkitHidden: "webkitvisibilitychange",
					mozHidden: "mozvisibilitychange",
					msHidden: "msvisibilitychange"
				},
				u = () => c(i());
			(() => {
				const e = (() => {
					if (!r()) return;
					const e = Object.keys(l).find(e => e in document);
					return e ? l[e] : void 0
				})();
				e && document.addEventListener(e, u)
			})(), t.a = {
				isDocumentHidden: () => !o(),
				isDocumentVisible: o,
				subscribe: a,
				unsubscribe: d
			}
		},
		"./src/lib/pageTitle/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/index.js"),
				r = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				o = n("./node_modules/@reddit/reddit-country-url-redirects/dist/esm/index.js"),
				i = n("./src/reddit/selectors/countrySites.ts"),
				a = n("./src/reddit/selectors/meta.ts");
			const d = (e, t, n) => {
				const {
					languageCode: d
				} = Object(i.c)(e), c = n || (Object(a.k)(e) || r.DEFAULT_LOCALE), l = Object(s.isPseudoLocale)(c) ? r.DEFAULT_LOCALE : c;
				if (d) {
					const e = Object(o.d)(d, l.substring(0, 2));
					return t + (e ? ` - ${e}` : "")
				}
				return t
			}
		},
		"./src/lib/reCaptchaEnterprise/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			n("./src/lib/reCaptchaEnterprise/reCaptcha.css");
			var s = n("./src/config.ts"),
				r = n("./src/reddit/helpers/loadThirdPartyScript.ts");
			const o = e => "object" == typeof e && null !== e,
				i = () => "undefined" != typeof window && o(window) && o(window.grecaptcha) && o(window.grecaptcha.enterprise),
				a = () => i() ? window.grecaptcha.enterprise : void 0,
				d = e => `https://www.google.com/recaptcha/enterprise.js?render=${e}`,
				c = e => Object(r.a)(d(e), i),
				l = e => new Promise(t => e.ready(t));
			var u, m = n("./node_modules/ts-error/lib/cjs.js"),
				p = n.n(m);
			class MissingReCaptchaEnterpriseSiteKeyError_MissingReCaptchaEnterpriseSiteKeyError extends p.a {
				constructor() {
					super("reCaptcha Enterprise site key is not set")
				}
			}
			class ReCaptchaEnterpriseClientIsNotReadyError_ReCaptchaEnterpriseClientIsNotReadyError extends p.a {
				constructor() {
					super("reCaptcha Enterprise client is not ready")
				}
			}
			class ReCaptchaEnterpriseClientNotAvailableError_ReCaptchaEnterpriseClientNotAvailableError extends p.a {
				constructor() {
					super("reCaptcha Enterprise client is not available")
				}
			}! function(e) {
				e.PageLoad = "PAGE_LOAD", e.PostSubmit = "post_submit"
			}(u || (u = {}));
			var b = u;
			const f = new class {
				constructor() {
					var e = this;
					let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : s.a.reCaptchaEnterprise.siteKey,
						n = arguments.length > 1 ? arguments[1] : void 0;
					this.siteKey = t, this.isReady = !1, this.hasSiteKey = () => !!this.siteKey, this.hasClient = () => !!this.instance, this.setInstance = e => {
						e && (this.instance = e, this.isReady = !1)
					}, this.scriptUrl = () => d(this.siteKey), this.ensureSiteKey = () => {
						if (!this.hasSiteKey) throw new MissingReCaptchaEnterpriseSiteKeyError_MissingReCaptchaEnterpriseSiteKeyError
					}, this.ensureClient = () => {
						const e = this.instance;
						if (!e) throw new ReCaptchaEnterpriseClientNotAvailableError_ReCaptchaEnterpriseClientNotAvailableError;
						return e
					}, this.waitUntilClientIsReady = async () => {
						const e = this.ensureClient();
						return await l(e), this.isReady = !0, e
					}, this.ensureClientIsReady = () => {
						const e = this.ensureClient();
						if (!this.isReady) throw new ReCaptchaEnterpriseClientIsNotReadyError_ReCaptchaEnterpriseClientIsNotReadyError;
						return e
					}, this.loadScript = async function() {
						let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						if (!e.instance || t) {
							e.ensureSiteKey(), await c(e.siteKey);
							const t = a();
							if (!t) throw new ReCaptchaEnterpriseClientNotAvailableError_ReCaptchaEnterpriseClientNotAvailableError;
							e.setInstance(t)
						}
						e.isReady || await e.waitUntilClientIsReady()
					}, this.execute = async e => {
						this.ensureSiteKey();
						const t = this.ensureClientIsReady(),
							n = await t.execute(this.siteKey, e);
						if (e.fast) {
							return JSON.parse(n)[1]
						}
						return n
					}, this.setInstance(n || a())
				}
			};
			t.b = f
		},
		"./src/lib/reCaptchaEnterprise/reCaptcha.css": function(e, t, n) {},
		"./src/lib/scroll/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/lib/domUtils/index.ts"),
				r = n("./src/lib/fastdom/index.ts"),
				o = n("./src/reddit/components/CommentSort/index.tsx"),
				i = n("./src/reddit/constants/elementIds.ts");
			const a = () => {
					r.a.write(() => {
						const e = document.getElementById(i.e);
						e ? Object(s.c)(e, 0) : Object(s.c)(document, 0)
					})
				},
				d = e => {
					r.a.read(() => {
						const t = e ? document.getElementById(i.e) : window,
							n = document.getElementById(o.a);
						if (t && n) {
							const s = e ? n.offsetTop : n.offsetTop - 50;
							r.a.write(() => t.scrollTo({
								top: s,
								behavior: "smooth"
							}))
						}
					})
				}
		},
		"./src/lib/stringInterpolate/index.ts": function(e, t, n) {
			"use strict";

			function s(e, t) {
				return e && t ? e.replace(/%\{(\w+)\}/g, (e, n) => {
					const s = t[n];
					return null == s ? n : String(s)
				}) : e
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/lib/stripQueryParams/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				r = n.n(s);
			t.a = e => {
				const t = r.a.parse(e);
				return t.search = void 0, t.query = null, r.a.format(t)
			}
		},
		"./src/lib/timeUntil/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts");
			const o = [r.yc, r.ub, r.D, r.U, r.pb, r.Xb],
				i = {
					[r.Xb]: e => s.fbt._({
						"*": "{number} seconds",
						_1: "1 second"
					}, [s.fbt._plural(e, "number")], {
						hk: "3pTp9Z"
					}),
					[r.pb]: e => s.fbt._({
						"*": "{number} minutes",
						_1: "1 minute"
					}, [s.fbt._plural(e, "number")], {
						hk: "2gB3sf"
					}),
					[r.U]: e => s.fbt._({
						"*": "{number} hours",
						_1: "1 hour"
					}, [s.fbt._plural(e, "number")], {
						hk: "2w4n8B"
					}),
					[r.D]: e => s.fbt._({
						"*": "{number} days",
						_1: "1 day"
					}, [s.fbt._plural(e, "number")], {
						hk: "3zIGRH"
					}),
					[r.ub]: e => s.fbt._({
						"*": "{number} months",
						_1: "1 month"
					}, [s.fbt._plural(e, "number")], {
						hk: "28DQqD"
					}),
					[r.yc]: e => s.fbt._({
						"*": "{number} years",
						_1: "1 year"
					}, [s.fbt._plural(e, "number")], {
						hk: "Gqzh3"
					})
				},
				a = {
					[r.Xb]: e => s.fbt._("{amount}s", [s.fbt._param("amount", String(e))], {
						hk: "F4qog"
					}),
					[r.pb]: e => s.fbt._("{amount}m", [s.fbt._param("amount", String(e))], {
						hk: "43tM5H"
					}),
					[r.U]: e => s.fbt._("{amount}h", [s.fbt._param("amount", String(e))], {
						hk: "19NsxU"
					}),
					[r.D]: e => s.fbt._("{amount}d", [s.fbt._param("amount", String(e))], {
						hk: "39MDc9"
					}),
					[r.ub]: e => s.fbt._("{amount}m", [s.fbt._param("amount", String(e))], {
						hk: "28feBj"
					}),
					[r.yc]: e => s.fbt._("{amount}y", [s.fbt._param("amount", String(e))], {
						hk: "10bv8G"
					}),
					[r.ub]: e => s.fbt._("{amount}m", [s.fbt._param("amount", String(e))], {
						hk: "28feBj"
					}),
					[r.yc]: e => s.fbt._("{amount}y", [s.fbt._param("amount", String(e))], {
						hk: "10bv8G"
					})
				};

			function d(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
					n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
				const d = Date.now(),
					c = new Date(e).getTime(),
					l = {
						[r.yc]: "",
						[r.ub]: "",
						[r.D]: "",
						[r.U]: "",
						[r.pb]: "",
						[r.Xb]: ""
					};
				let u = c - d;
				if (u <= 0) return s.fbt._("a moment", null, {
					hk: "3QLaye"
				}).toString();
				for (const s of o) {
					const e = Math.floor(u / s);
					e && (l[s] = (t ? a : i)[s](e).toString()), u -= e * s
				}
				const m = o.map(e => l[e]).filter(Boolean).slice(0, 2).join(" ");
				return t || n ? m : s.fbt._("{amount of time left} left", [s.fbt._param("amount of time left", m)], {
					hk: "7VjAI"
				}).toString()
			}
		},
		"./src/reddit/actions/apiRequestState.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "g", (function() {
				return m
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/models/ApiRequestState/index.ts");
			const o = "API_REQUEST_STATE__STARTED",
				i = "API_REQUEST_STATE__COMPLETED",
				a = "API_REQUEST_STATE__FAILED",
				d = "API_REQUEST_STATE__RELEASED";

			function c(e) {
				return {
					type: o,
					payload: {
						apiRequestStatus: r.a.Pending,
						apiRequestId: e
					}
				}
			}

			function l(e) {
				return {
					type: i,
					payload: {
						apiRequestStatus: r.a.Complete,
						apiRequestId: e
					}
				}
			}

			function u(e, t) {
				return {
					type: a,
					payload: {
						apiRequestStatus: r.a.Failed,
						apiRequestId: e,
						apiError: t
					}
				}
			}
			const m = Object(s.a)(d)
		},
		"./src/reddit/actions/appBadgeIndicators/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			const s = "APP_BADGES__PENDING",
				r = "APP_BADGES__LOADED",
				o = "APP_BADGES__UPDATED",
				i = "APP_BADGES__FAILED"
		},
		"./src/reddit/actions/appBadgeIndicators/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "b", (function() {
				return v
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/makeRequest/index.ts"),
				o = n("./src/reddit/actions/appBadgeIndicators/constants.ts"),
				i = n("./src/reddit/actions/tabBadging.ts"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				d = n("./src/redditGQL/operations/BadgeIndicators.json"),
				c = e => Object(a.a)(e, {
					...d
				}),
				l = n("./src/reddit/models/Badge/index.ts");
			const u = Object(s.a)(o.c),
				m = Object(s.a)(o.b),
				p = Object(s.a)(o.d),
				b = Object(s.a)(o.a),
				f = e => {
					let {
						key: t,
						count: n
					} = e;
					return {
						[t]: {
							count: n,
							style: l.b.Numbered
						}
					}
				},
				h = (e, t, n) => ({
					[l.c.ChatUnreadMessages]: {
						count: e,
						style: l.b.Numbered
					},
					[l.c.ChatV2UnreadMessages]: {
						count: n,
						style: l.b.Numbered
					},
					[l.c.ChatHasNewMessages]: {
						isShowing: t,
						style: l.b.Filled
					}
				}),
				g = () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					e(u());
					const o = await async function(e) {
						var t, n, s, o;
						const i = await c(e());
						if (Object(r.c)(i) && (null === (n = null === (t = i.body) || void 0 === t ? void 0 : t.data) || void 0 === n ? void 0 : n.badgeIndicators)) {
							const e = null === (o = null === (s = i.body) || void 0 === s ? void 0 : s.data) || void 0 === o ? void 0 : o.badgeIndicators;
							return {
								...e,
								chatUnreadMessages: {
									count: (Number(e.chatUnreadMessages.count) || 0) + (Number(e.chatUnacceptedInvites.count) || 0) + (Number(e.chatUnreadMentions.count) || 0)
								}
							}
						}
					}(s);
					o ? (e(m(o)), e(Object(i.d)())) : e(b())
				};
			const v = () => async e => {
				const t = f({
					key: l.c.MessageTab,
					count: 0
				});
				e(p(t))
			}
		},
		"./src/reddit/actions/authorFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "IN_CONTEXT_AUTHOR_FLAIR_UPDATED",
				o = Object(s.a)(r)
		},
		"./src/reddit/actions/bulkActions/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/bulkActions/constants.ts");
			const o = Object(s.a)(r.c),
				i = Object(s.a)(r.b),
				a = Object(s.a)(r.a)
		},
		"./src/reddit/actions/comment/authoring.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return be
			})), n.d(t, "r", (function() {
				return ge
			})), n.d(t, "p", (function() {
				return ve
			})), n.d(t, "t", (function() {
				return Oe
			})), n.d(t, "w", (function() {
				return Ce
			})), n.d(t, "q", (function() {
				return Ae
			})), n.d(t, "v", (function() {
				return Ie
			})), n.d(t, "o", (function() {
				return ke
			})), n.d(t, "m", (function() {
				return Se
			})), n.d(t, "b", (function() {
				return Te
			})), n.d(t, "c", (function() {
				return De
			})), n.d(t, "s", (function() {
				return Me
			})), n.d(t, "g", (function() {
				return Re
			})), n.d(t, "h", (function() {
				return Le
			})), n.d(t, "k", (function() {
				return Be
			})), n.d(t, "e", (function() {
				return Ue
			})), n.d(t, "d", (function() {
				return qe
			})), n.d(t, "a", (function() {
				return We
			})), n.d(t, "j", (function() {
				return ze
			})), n.d(t, "i", (function() {
				return Je
			})), n.d(t, "l", (function() {
				return Xe
			})), n.d(t, "u", (function() {
				return Ze
			})), n.d(t, "n", (function() {
				return $e
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/makeDraftKey/index.ts"),
				i = n("./src/lib/scroll/index.ts"),
				a = n("./src/reddit/actions/changeUsername.ts"),
				d = n("./src/reddit/actions/login.ts"),
				c = n("./src/reddit/actions/modal.ts"),
				l = n("./src/reddit/actions/onboarding/index.ts"),
				u = n("./src/reddit/actions/post.ts"),
				m = n("./src/reddit/actions/postCreation/editorContent.ts"),
				p = n("./src/reddit/actions/shortcuts/utils.ts"),
				b = n("./src/reddit/actions/toaster.ts"),
				f = n("./src/reddit/constants/adEvents.ts"),
				h = n("./src/reddit/constants/localStorage.ts"),
				g = n("./src/redditGQL/operations/CommentToxicity.json"),
				v = n("./src/lib/constants/index.ts"),
				x = n("./src/lib/makeApiRequest/index.ts"),
				E = n("./src/lib/makeGqlRequest/index.ts"),
				O = n("./src/lib/omitHeaders/index.ts"),
				C = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				A = n("./src/reddit/constants/headers.ts"),
				y = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				j = n("./src/reddit/helpers/genericServerError/index.ts"),
				I = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				k = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				_ = n("./src/reddit/models/PostCreationForm/index.ts"),
				S = n("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				w = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				T = n("./src/reddit/helpers/graphql/helpers.ts"),
				P = n("./src/reddit/helpers/graphql/normalizeCommentFromGql/index.ts"),
				N = n("./src/redditGQL/operations/CreateComment.json");
			const D = (e, t, n, s) => {
					let r, o;
					if (s === _.i.MARKDOWN) r = n.text, o = null;
					else {
						r = null;
						let e = null;
						n.rteState && (e = C.a.toRichTextJSON(n.rteState).document), o = JSON.stringify({
							document: e
						})
					}
					return Object(E.a)(e, {
						...g,
						variables: {
							subredditName: t,
							markdown: r,
							richText: o
						}
					}).then(e => !e.ok || e.body.data.isValidComment)
				},
				M = async (e, t, n, s) => {
					const r = {
						api_type: "json",
						return_rtjson: !0,
						thing_id: t
					};
					return n.commentMode === _.i.MARKDOWN ? r.text = n.text : (r.text = null, r.richtext_json = s), Object(x.a)(Object(O.a)(e, [A.a]), {
						method: v.ob.POST,
						endpoint: Object(y.a)(Object(S.a)(Object(w.a)(`${e.apiUrl}/api/comment.json`))),
						data: r
					}).then(e => e.ok ? e.body.json ? e.body.json.errors.length ? {
						...e,
						ok: !1,
						error: Object(k.a)(e)
					} : {
						...e,
						body: {
							comment: Object(I.a)(e.body.json.data.things[0].data)
						}
					} : {
						...e,
						body: {
							comment: Object(I.a)(e.body)
						}
					} : {
						...e,
						error: e.error || Object(j.a)()
					})
				}, R = async (e, t, n, s, r) => {
					const o = s.commentMode === _.i.MARKDOWN,
						i = {
							postId: t || null,
							parentId: n || null,
							content: {
								markdown: o ? s.text : null,
								richText: o ? null : r
							}
						};
					return Object(E.a)(e, {
						...N,
						variables: {
							input: i
						}
					}).then(e => {
						if (e.ok) {
							const t = e.body.data.createComment;
							if ((null == t ? void 0 : t.fieldErrors) && t.fieldErrors.length > 0) return {
								...e,
								ok: !1,
								error: Object(T.e)(t.fieldErrors)
							};
							if ((null == t ? void 0 : t.errors) && t.errors.length > 0) return {
								...e,
								ok: !1,
								error: Object(T.f)(t.errors)
							};
							if (t.ok) return {
								...e,
								body: {
									comment: Object(P.a)(t.commentInfo)
								}
							}
						}
						return {
							...e,
							ok: !1,
							error: e.error || Object(j.a)()
						}
					})
				};
			var L = n("./src/redditGQL/operations/UpdateComment.json");
			var B = n("./src/redditGQL/operations/UpdateCommentFollowState.json");
			var F = n("./src/reddit/endpoints/post/index.tsx"),
				U = n("./src/reddit/endpoints/post/convert.ts"),
				H = n("./src/reddit/featureFlags/index.ts"),
				G = n("./src/reddit/helpers/comment/index.ts"),
				Q = n("./src/reddit/helpers/correlationIdTracker.ts"),
				q = n("./src/reddit/helpers/dom/index.ts"),
				W = n("./src/reddit/helpers/localStorage/index.ts"),
				z = n("./src/reddit/helpers/sessionStorage/index.ts"),
				V = n("./src/reddit/helpers/trackers/commentsPage.ts"),
				K = n("./src/reddit/models/Comment/index.ts"),
				Y = n("./src/reddit/models/PostDraft/index.ts"),
				J = n("./src/reddit/models/RichTextJson/index.ts"),
				X = n("./src/reddit/models/RichTextJson/nodeMakers.ts"),
				Z = n("./src/reddit/models/Toast/index.ts"),
				$ = n("./src/reddit/selectors/chatPost.ts"),
				ee = n("./src/reddit/selectors/comments.ts"),
				te = n("./src/reddit/selectors/commentSelector.ts"),
				ne = n("./src/reddit/selectors/experiments/chat.ts"),
				se = n("./src/reddit/constants/experiments.ts"),
				re = n("./src/reddit/helpers/chooseVariant/index.ts"),
				oe = n("./node_modules/reselect/es/index.js");
			const ie = Object(oe.a)(e => Object(re.c)(e, {
				experimentEligibilitySelector: re.a,
				experimentName: se.Lb
			}), e => e === se.Yd);
			var ae = n("./src/reddit/selectors/experiments/contributeBeforeSignUp.ts"),
				de = n("./src/reddit/selectors/platform.ts"),
				ce = n("./src/reddit/selectors/posts.ts"),
				le = n("./src/reddit/selectors/user.ts"),
				ue = n("./src/reddit/actions/comment/index.ts"),
				me = n("./src/reddit/actions/comment/constants.ts");
			const pe = Object(r.a)(me.m),
				be = e => {
					let {
						hasFocus: t,
						draftKey: n
					} = e;
					return async (e, s) => {
						const r = s();
						if (!!r.features.comments.drafts[n])
							if (Object(le.U)(r) && t) {
								const s = pe({
									hasFocus: t,
									draftKey: n
								});
								e(Object(a.startChangeUsernameFlow)(s))
							} else e(pe({
								hasFocus: t,
								draftKey: n
							}))
					}
				},
				fe = Object(r.a)(me.L),
				he = Object(r.a)(me.H),
				ge = Object(r.a)(me.N),
				ve = Object(r.a)(me.M),
				xe = Object(r.a)(me.K),
				Ee = async (e, t, n, s, r) => {
					const o = s.ok && s.body,
						i = o && o.comment && o.comment.id;
					await V.g(e, n, t, r, i)
				}, Oe = "Toxicity_Warning__Modal", Ce = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n(),
						i = Object(de.e)(o);
					let a = "";
					i && (a = i.name);
					const {
						formData: d,
						editorMode: l
					} = e;
					if (H.d.enableToxicityWarning(o)) {
						if (!(await D(r(), a, d, l))) return void t(Object(c.i)(Oe))
					}
					t(Ae(e))
				}, Ae = e => async (t, n) => {
					t(Object(c.g)(Oe));
					const s = n(),
						r = Object(ae.a)(s),
						o = Object(ae.c)(s);
					if (!s.user.account && r) {
						const n = Object(G.e)(e.formData, s.uploads),
							r = Object(G.d)(e.formData, s.uploads);
						t(Object(c.k)({
							actionSource: c.a.Reply
						})), t(Object(d.openRegisterModal)()), Object(z.d)({
							comment: {
								...e,
								richTextJSONData: n,
								commentBodyText: r
							},
							isSkipOnboarding: o
						})
					} else t(je(e, !1))
				};

			function ye(e, t) {
				return e === _.i.MARKDOWN && ie(t)
			}
			const je = (e, t, n, r) => {
					let {
						postId: o,
						commentsPageKey: a,
						draftKey: d,
						formData: c,
						editorMode: l,
						disableAutofocus: m
					} = e;
					return async (e, h, g) => {
						let {
							apiContext: v,
							gqlContext: x
						} = g;
						var E;
						const O = h(),
							C = Object($.d)(O, {
								postId: o
							}),
							A = C ? Object(G.b)() : d,
							y = Object(te.f)(O, {
								commentId: A
							}),
							j = Object(le.m)(O);
						if (!j) return;
						if (y && !C) return;
						t || e(fe({
							draftKey: A,
							draft: c,
							commentsPageKey: a,
							optimisticComment: C ? Object(G.c)({
								temporalId: A,
								draft: c,
								post: Object(ce.F)(O, {
									postId: o
								}),
								author: j,
								subredditId: (null === (E = Object(de.e)(O)) || void 0 === E ? void 0 : E.id) || ""
							}) : void 0
						}));
						const I = c.commentMode;
						let k;
						const S = t && n ? n : Object(G.e)(c, O.uploads),
							w = Object(G.f)(S, O.uploads);
						if ((k = ye(I, O) ? await R(x(), o, null, c, S) : await M(v(), o, c, S)).ok) {
							const n = k.body;
							if (e(ge({
									...n,
									headCommentId: Object(ee.w)(O, {
										commentsPageKey: a
									}),
									commentsPageKey: a,
									draftKey: A,
									upload: w
								})), t) {
								const e = Object(de.i)(O);
								Object(i.a)(!!e)
							}
							const s = Object(ce.F)(h(), {
								postId: o
							});
							e(Object(u.y)(s, f.a.CommentSubmitted))
						} else {
							if (k.error) {
								const e = t && r ? r : Object(G.d)(c, O.uploads);
								V.f({
									state: O,
									bodyText: e,
									postId: o,
									error: k.error,
									uploadMetadata: null == w ? void 0 : w.metadata
								})
							}
							const n = k.error && k.error.fields && k.error.fields[0] ? k.error.fields[0].msg : s.fbt._("Something went wrong", null, {
								hk: "LWFS0"
							});
							e(xe({
								draftKey: A,
								error: k.error
							})), C || e(Object(b.f)({
								duration: b.a,
								kind: Z.b.Error,
								text: n
							}))
						}
						Ee(h(), a, l, k, null == w ? void 0 : w.metadata).then(() => k.ok && l === _.i.RICH_TEXT ? Object(Q.b)(Q.a.CommentComposer) : void 0), m || Object(p.d)(), t && Object(z.a)()
					}
				},
				Ie = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const {
						parentCommentId: o,
						commentsPageKey: i,
						parentCommentDepth: a,
						draftKey: d,
						formData: l,
						editorMode: u
					} = e, m = n(), p = Object(de.e)(m);
					let b = "";
					if (p && (b = p.name), H.d.enableToxicityWarning(m)) {
						if (!(await D(r(), b, l, u))) return void t(Object(c.i)(Oe))
					}
					t(ke({
						commentsPageKey: i,
						draftKey: d,
						parentCommentDepth: a,
						parentCommentId: o,
						formData: l,
						editorMode: u
					}))
				}, ke = e => async (t, n) => {
					t(Object(c.g)(Oe));
					const s = n(),
						r = Object(ae.a)(s),
						o = Object(ae.c)(s);
					if (!s.user.account && r) {
						const n = Object(G.e)(e.formData, s.uploads),
							r = Object(G.d)(e.formData, s.uploads);
						t(Object(c.k)({
							actionSource: c.a.Reply
						})), t(Object(d.openRegisterModal)()), Object(z.d)({
							comment: {
								...e,
								richTextJSONData: n,
								commentBodyText: r
							},
							isSkipOnboarding: o
						})
					} else t(_e(e, !1))
				}, _e = (e, t, n, s) => async (r, o, a) => {
					let {
						apiContext: d,
						gqlContext: c
					} = a;
					var l;
					const {
						parentCommentId: u,
						commentsPageKey: m,
						parentCommentDepth: b,
						draftKey: f,
						formData: h,
						editorMode: g
					} = e, v = o(), x = Object(te.c)(v, {
						commentId: u
					}), E = x && Object($.d)(v, {
						postId: x.postId
					}) && Object(ne.e)(v), O = x && Object($.d)(v, {
						postId: x.postId
					}), C = O ? Object(G.b)() : f, A = Object(te.f)(v, {
						commentId: C
					}), y = Object(le.m)(v);
					if (!y) return;
					if (A && !O) return;
					t || r(fe({
						draftKey: C,
						draft: h,
						commentsPageKey: m,
						optimisticComment: O && x ? Object(G.c)({
							temporalId: C,
							draft: h,
							post: Object(ce.F)(v, {
								postId: x.postId
							}),
							author: y,
							subredditId: (null === (l = Object(de.e)(v)) || void 0 === l ? void 0 : l.id) || "",
							parentId: x.id
						}) : void 0
					})), E || r(Te({
						parentCommentId: u,
						commentsPageKey: m
					}));
					const j = h.commentMode,
						I = t && n ? n : Object(G.e)(h, v.uploads),
						k = Object(G.f)(I, v.uploads);
					let _;
					if ((_ = ye(j, v) ? await R(c(), null, u, h, I) : await M(d(), u, h, I)).ok) {
						if (r(ve({
								..._.body,
								parentCommentId: u,
								commentsPageKey: m,
								draftKey: C,
								depth: b + 1,
								upload: k
							})), t) {
							const e = Object(de.i)(v);
							Object(i.a)(!!e)
						}
					} else {
						if (_.error) {
							if (!x) return;
							const e = t && s ? s : Object(G.d)(h, v.uploads);
							V.f({
								state: v,
								bodyText: e,
								postId: x.postId,
								parentId: u,
								error: _.error,
								uploadMetadata: null == k ? void 0 : k.metadata
							})
						}
						r(xe({
							draftKey: C,
							error: _.error
						}))
					}
					Ee(o(), m, g, _, null == k ? void 0 : k.metadata), E || Object(p.d)(), t && Object(z.a)()
				}, Se = () => async e => {
					const t = Object(z.b)();
					if (t) {
						const {
							comment: {
								parentCommentDepth: n,
								parentCommentId: s,
								postId: r,
								richTextJSONData: o,
								commentBodyText: i
							},
							isSkipOnboarding: a
						} = t;
						a && e(Object(l.skipOnboardingModal)()), r ? await e(je({
							...t.comment,
							postId: r
						}, !0, o, i)) : s && void 0 !== n && await e(_e({
							...t.comment,
							parentCommentId: s,
							parentCommentDepth: n
						}, !0, o, i))
					}
				}, we = Object(r.a)(me.s), Te = Object(r.a)(me.r), Pe = Object(r.a)(me.n), Ne = (Object(r.a)(me.i), Object(r.a)(me.o)), De = (Object(r.a)(me.v), (e, t, n) => async (r, o, i) => {
					let {
						apiContext: a
					} = i;
					const d = e === _.i.RICH_TEXT;
					if (!t || "object" == typeof t && Object(J.H)(t)) r(Ne({
						editorMode: e,
						draftKey: n,
						content: d ? J.i : ""
					})), r(Object(m.c)(e));
					else {
						r(Object(m.b)(n));
						const o = await Object(U.a)(a(), e, d ? t : JSON.stringify(t));
						if (o.ok) {
							const t = o.body.output;
							r(Object(m.a)(n)), r(Ne({
								editorMode: e,
								draftKey: n,
								content: t
							})), r(Object(m.c)(e))
						} else r(Object(m.a)(n)), r(Object(b.f)({
							duration: b.a,
							kind: Z.b.Error,
							text: s.fbt._("Something went wrong", null, {
								hk: "LWFS0"
							})
						}))
					}
				}), Me = e => {
					let {
						commentsPageKey: t,
						parentCommentId: n,
						singleOpen: s
					} = e;
					return async (e, r) => {
						const i = r(),
							l = Object(o.a)(Y.c.replyToComment, n);
						if (!Object(le.S)(r()) && !Object(ae.a)(i)) return e(Object(d.openRegisterModal)()), void e(Object(c.k)({
							actionSource: c.a.Reply,
							redirectUrl: Object(ee.m)(r(), {
								commentId: n
							})
						}));
						const u = i.features.comments.replyFormOpen[t],
							m = u && u[n];
						if ((m || u && s) && (Object.keys(u).forEach(n => u[n] && e(Te({
								parentCommentId: n,
								commentsPageKey: t
							}))), m)) return;
						let p = "",
							b = null;
						const f = i.user.prefs.commentMode,
							h = Object(q.d)();
						if (h) {
							const e = h.filter(e => !!e && 10 !== e.charCodeAt(0));
							if (f === _.i.MARKDOWN) p = e.map(e => `> ${e}\n`).join("");
							else {
								const t = e.map(e => X.s(e, null)).map(e => X.l([e])),
									n = X.s("", null),
									s = X.l([n]);
								b = {
									document: [X.c(t), s]
								}
							}
						}
						const g = i.features.comments.drafts[l];
						let v;
						if (v = h ? {
								commentMode: f,
								draftType: Y.c.replyToComment,
								rtJson: b,
								text: `${p}\n`
							} : g || {
								commentMode: f,
								draftType: Y.c.replyToComment,
								rtJson: b,
								text: ""
							}, Object(le.U)(i)) {
							const s = we({
								parentCommentId: n,
								commentsPageKey: t,
								draftKey: l,
								formData: v
							});
							e(Object(a.startChangeUsernameFlow)(s))
						} else e(we({
							parentCommentId: n,
							commentsPageKey: t,
							draftKey: l,
							formData: v
						}))
					}
				}, Re = e => async t => {
					t(Object(ue.r)(e)), t(Ue(e))
				}, Le = e => {
					let {
						parentCommentId: t,
						commentsPageKey: n
					} = e;
					return async e => {
						e(Te({
							parentCommentId: t,
							commentsPageKey: n
						})), e(Me({
							parentCommentId: t,
							commentsPageKey: n
						})), e(Object(ue.r)({
							commentId: t,
							commentsPageKey: n
						}))
					}
				}, Be = (e, t) => n => n(Pe({
					draftKey: e,
					formData: t
				})), Fe = Object(r.a)(me.u), Ue = e => {
					let {
						commentId: t,
						commentMode: n,
						commentsPageKey: s,
						draftKey: r,
						text: o
					} = e;
					return async (e, i) => {
						const a = i();
						a.user.account && (V.c(a), e(Fe({
							commentId: t,
							commentsPageKey: s,
							draftKey: r,
							formData: {
								text: o,
								commentMode: n,
								rteState: null,
								draftType: Y.c.edit,
								hasFocus: !0
							}
						})))
					}
				}, He = Object(r.a)(me.F), Ge = Object(r.a)(me.E), Qe = Object(r.a)(me.G), qe = Object(r.a)(me.j), We = Object(r.a)(me.f), ze = e => {
					let {
						id: t,
						commentsPageKey: n,
						draftKey: s,
						formData: r
					} = e;
					return async (e, o, i) => {
						let {
							apiContext: a,
							gqlContext: d
						} = i;
						const c = o();
						if (!c.user.account) return;
						e(He({
							draftKey: s
						})), V.d(c);
						const l = Object(G.e)(r, c.uploads),
							u = r.commentMode;
						let m;
						if ((m = ye(u, c) ? await (async (e, t, n, s, r) => {
								const o = r === _.i.MARKDOWN,
									i = {
										commentId: t,
										content: {
											markdown: o ? n.text : null,
											richText: o ? null : s
										}
									};
								return Object(E.a)(e, {
									...L,
									variables: {
										input: i
									}
								}).then(e => {
									if (e.ok) {
										const t = e.body.data.updateComment;
										if ((null == t ? void 0 : t.fieldErrors) && t.fieldErrors.length > 0) return {
											...e,
											ok: !1,
											error: Object(T.e)(t.fieldErrors)
										};
										if ((null == t ? void 0 : t.errors) && t.errors.length > 0) return {
											...e,
											ok: !1,
											error: Object(T.f)(t.errors)
										};
										if (t.ok) return {
											...e,
											body: {
												comment: {
													...Object(P.c)(t.content)
												}
											}
										}
									}
									return {
										...e,
										ok: !1,
										error: e.error || Object(j.a)()
									}
								})
							})(d(), t, r, l, u) : await (async (e, t, n, s, r) => {
								const o = {
									api_type: "json",
									return_rtjson: !0,
									thing_id: t
								};
								return r === _.i.MARKDOWN ? o.text = n.text : (o.text = null, o.richtext_json = s), Object(x.a)(Object(O.a)(e, [A.a]), {
									endpoint: Object(y.a)(Object(w.a)(Object(S.a)(`${e.apiUrl}/api/editusertext`))),
									method: v.ob.POST,
									data: o
								}).then(e => e.ok ? e.body.json ? e.body.json.errors.length ? {
									...e,
									ok: !1,
									error: Object(k.a)(e)
								} : {
									...e,
									body: {
										comment: Object(I.a)(e.body.json.data.things[0].data)
									}
								} : {
									...e,
									body: {
										comment: Object(I.a)(e.body)
									}
								} : {
									...e,
									error: e.error || Object(j.a)()
								})
							})(a(), t, r, l, u)).ok) {
							const r = m.body;
							e(Qe({
								commentId: t,
								commentsPageKey: n,
								draftKey: s
							})), e(Object(ue.j)({
								[t]: {
									...r.comment
								}
							}))
						} else e(Ge({
							draftKey: s,
							error: m.error
						}))
					}
				}, Ve = Object(r.a)(me.C), Ke = Object(r.a)(me.B), Ye = Object(r.a)(me.D), Je = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s();
					n(Ve({
						id: e
					})), V.a(e, i);
					const a = await ((e, t) => Object(x.a)(Object(O.a)(e, [A.a]), {
						endpoint: Object(y.a)(`${e.apiUrl}/api/del`),
						method: v.ob.POST,
						data: {
							id: t
						}
					}).then(e => e.ok ? e.body.json && e.body.json.errors.length ? {
						...e,
						ok: !1,
						error: Object(k.a)(e)
					} : {
						...e,
						body: {}
					} : {
						...e,
						error: e.error || Object(j.a)()
					}))(o(), e);
					a.ok ? n(Ye({
						id: e,
						postId: t
					})) : n(Ke({
						id: e,
						error: a.error
					}))
				}, Xe = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = !n().features.comments.models[e].sendReplies;
					t(Object(ue.j)({
						[e]: {
							sendReplies: o
						}
					})), (await Object(F.p)(r(), e, o)).ok || t(Object(ue.j)({
						[e]: {
							sendReplies: !o
						}
					}))
				}, Ze = (e, t) => async (n, r, o) => {
					let {
						gqlContext: i
					} = o;
					var a, d, c, l, u, m;
					n(Object(ue.c)());
					const p = e => Object(b.f)(Object(b.e)(e, Z.b.Error));
					if (((null === (d = null === (a = r().pages) || void 0 === a ? void 0 : a.comments) || void 0 === d ? void 0 : d.followed) || []).length === h.a) n(p(s.fbt._("You've reached your post follow limit", null, {
						hk: "3ebRql"
					})));
					else {
						const o = t === K.a.FOLLOWED,
							a = {
								id: e,
								expiresAt: Date.now() + 6048e5
							};
						if (n(Object(ue.p)(a)), (await ((e, t) => Object(E.a)(e, {
								...B,
								variables: {
									input: t
								}
							}))(i(), {
								commentId: e,
								followState: t
							})).ok) {
							Object(W.yb)(null !== (u = null === (l = null === (c = r().pages) || void 0 === c ? void 0 : c.comments) || void 0 === l ? void 0 : l.followed) && void 0 !== u ? u : [], null === (m = r().user.account) || void 0 === m ? void 0 : m.id);
							const e = o ? s.fbt._("Followed! Youll get updates when theres new activity.", null, {
								hk: "2O1Ou3"
							}) : s.fbt._("Unfollowed. You wont get updates on this comment anymore.", null, {
								hk: "4EAz6O"
							});
							n(Object(b.f)({
								kind: Z.b.SuccessCommunityGreen,
								text: e
							}))
						} else n(Object(ue.p)(a)), n(p(s.fbt._("Sorry, we had trouble doing that. Please try again.", null, {
							hk: "2N0vVk"
						})))
					}
				};

			function $e(e) {
				let {
					commentId: t,
					commentsPageKey: n
				} = e;
				return async (e, s) => {
					const r = s(),
						o = Object(te.c)(r, {
							commentId: t
						});
					if (!o) return;
					e(he({
						commentId: t,
						commentsPageKey: n
					}));
					const i = {
						commentMode: o.media.rteMode,
						draftType: o.parentId ? Y.c.replyToComment : Y.c.replyToPost,
						rtJson: o.media.richtextContent,
						hasFocus: !0,
						text: ""
					};
					if (o.parentId) {
						const t = Object(te.c)(r, {
								commentId: o.parentId
							}),
							s = Object(ee.j)(r, {
								commentId: o.parentId,
								commentLink: void 0,
								commentsPageKey: n
							});
						if (!t || null === s) return;
						await e(ke({
							commentsPageKey: n,
							draftKey: o.id,
							parentCommentDepth: s,
							parentCommentId: t.id,
							formData: i,
							editorMode: o.media.rteMode
						}))
					} else await e(Ae({
						postId: o.postId,
						commentsPageKey: n,
						draftKey: o.id,
						formData: i,
						editorMode: o.media.rteMode,
						disableAutofocus: !0
					}))
				}
			}
		},
		"./src/reddit/actions/comment/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return N
			})), n.d(t, "o", (function() {
				return D
			})), n.d(t, "f", (function() {
				return L
			})), n.d(t, "i", (function() {
				return B
			})), n.d(t, "n", (function() {
				return G
			})), n.d(t, "s", (function() {
				return Q
			})), n.d(t, "k", (function() {
				return q
			})), n.d(t, "h", (function() {
				return W
			})), n.d(t, "g", (function() {
				return z
			})), n.d(t, "q", (function() {
				return Y
			})), n.d(t, "r", (function() {
				return J
			})), n.d(t, "d", (function() {
				return X
			})), n.d(t, "a", (function() {
				return $
			})), n.d(t, "b", (function() {
				return ee
			})), n.d(t, "p", (function() {
				return te
			})), n.d(t, "c", (function() {
				return ne
			})), n.d(t, "m", (function() {
				return se
			})), n.d(t, "e", (function() {
				return re
			})), n.d(t, "l", (function() {
				return ie
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./src/telemetry/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/economics/helpers/async.ts"),
				d = n("./src/lib/loadableAction/index.ts");
			const c = Object(d.a)(() => n.e("AchievementsActions").then(n.bind(null, "./src/reddit/actions/economics/powerups/flairs/index.ts")).then(e => e.getSubredditUserCommentsPowerupsInfoFromCommentCollection));
			Object(d.a)(() => n.e("AchievementsActions").then(n.bind(null, "./src/reddit/actions/economics/powerups/flairs/index.ts")).then(e => e.getSubredditCurrentUserPowerupsFlairs));
			var l = n("./src/reddit/actions/login.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/modQueueTriggers/index.ts"),
				p = n("./src/reddit/actions/shortcuts/utils.ts"),
				b = n("./src/reddit/actions/subredditModeration/modUserNotes.ts"),
				f = n("./src/reddit/actions/toaster.ts"),
				h = n("./src/reddit/actions/vote.ts"),
				g = n("./src/reddit/endpoints/comment/index.tsx"),
				v = n("./src/reddit/helpers/commentList/index.ts"),
				x = n("./src/reddit/helpers/graphql/normalizeCommentFromGql/index.ts"),
				E = n("./src/reddit/helpers/trackers/comment.ts"),
				O = n("./src/reddit/models/Comment/index.ts"),
				C = n("./src/reddit/models/Post/index.ts"),
				A = n("./src/reddit/models/Toast/index.ts"),
				y = n("./src/reddit/models/Vote/index.ts"),
				j = n("./src/reddit/selectors/comments.ts"),
				I = n("./src/reddit/selectors/commentSelector.ts"),
				k = n("./src/reddit/selectors/experiments/avatarsInComments.ts"),
				_ = n("./src/reddit/selectors/moderatingComments.ts"),
				S = n("./src/reddit/selectors/moderatorPermissions.ts"),
				w = n("./src/reddit/selectors/user.ts"),
				T = n("./src/reddit/actions/comment/constants.ts");
			const P = {},
				N = Object(i.a)(T.q),
				D = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					if (!Object(w.S)(n())) return t(Object(l.openRegisterModal)()), void t(Object(u.k)({
						actionSource: u.a.Save,
						redirectUrl: Object(j.m)(n(), {
							commentId: e
						})
					}));
					const i = n().features.comments.models[e];
					if (!i) return;
					const a = i.isSaved ? g.m : g.i;
					if (t(N({
							[e]: {
								isSaved: !i.isSaved
							}
						})), (await a(o(), e)).ok) {
						const n = i.isSaved ? r.fbt._("Comment unsaved successfully", null, {
								hk: "UGKHZ"
							}) : r.fbt._("Comment saved successfully", null, {
								hk: "1BZqMx"
							}),
							s = r.fbt._("Undo", null, {
								hk: "46OwLP"
							});
						t(Object(f.f)({
							text: n,
							kind: A.b.Undo,
							buttonText: s,
							buttonAction: D(e)
						}))
					} else t(N({
						[e]: {
							isSaved: i.isSaved
						}
					}))
				}, M = e => `viewing-comment-${e}`, R = s.a.telemetry.commentConsumedThreshold, L = e => async (t, n) => {
					const r = n(),
						i = Object(I.c)(r, {
							commentId: e
						});
					if (!i || Math.random() > s.a.telemetry.commentSampleRate) return;
					E.d({
						state: r,
						commentId: e,
						collapsed: i.collapsed
					}), o.c.start(M(e));
					const a = setTimeout(() => E.a({
						state: r,
						commentId: e,
						collapsed: i.collapsed
					}), R);
					P[e] = a
				}, B = (e, t) => async (n, s) => {
					const r = s(),
						i = M(e);
					if (Object(I.c)(r, {
							commentId: e
						}) && o.c.has(i)) {
						const n = o.c.end(i);
						!t && n < R && (clearTimeout(P[e]), delete P[e])
					}
				}, F = Object(i.a)(T.z), U = Object(i.a)(T.y), H = Object(i.a)(T.x), G = (e, t, n) => async (s, r, o) => {
					let {
						apiContext: i
					} = o;
					const d = r(),
						l = d.moreComments.models[t],
						u = d.platform.currentPage,
						p = u && u.routeMatch,
						f = p && p.match,
						{
							partialPostId: h
						} = f ? f.params : null;
					if (!h) return;
					const x = Object(C.y)(h);
					s(F({
						moreCommentsId: l.id
					}));
					const E = await Object(g.g)(i(), x, {
						token: l.token
					}, Object(k.a)(d), n);
					if (E.ok) {
						const t = E.body,
							n = Object(v.a)(t, x, d);
						s(U({
							key: e,
							moreCommentsItem: l,
							shouldCollapse: n,
							...t
						}));
						const o = d.posts.models[x];
						let i;
						o && "subreddit" === o.belongsTo.type && t.comments && (i = o.belongsTo.id, await s(Object(a.a)({
							commentIds: Object.keys(E.body.comments),
							postIds: [o.id],
							skip: ["communityDetails", "subscription"],
							subredditId: i
						})), Object(S.i)(d, i) && s(Object(b.c)(x, !0, l.token)));
						const u = E.body.comments;
						await s(c(i, u)), Object(S.h)(r(), {
							subredditId: o.belongsTo.id
						}) && s(Object(m.a)({
							commentIds: Object.keys(t.comments)
						}))
					} else s(H({
						moreCommentsItem: l,
						...E.error
					}))
				}, Q = Object(h.a)(v.b, y.a.upvoted), q = Object(h.a)(v.b, y.a.downvoted), W = Object(i.a)(T.l), z = Object(i.a)(T.k), V = Object(i.a)(T.g), K = Object(i.a)(T.h), Y = (Object(i.a)(T.c), Object(i.a)(T.d), e => {
					let {
						commentId: t,
						commentsPageKey: n,
						scrollToAndRemeasure: s
					} = e;
					return async (e, r) => {
						const o = r(),
							i = Object(O.i)(t),
							a = Object(j.n)(o, {
								commentLink: i,
								commentsPageKey: n
							}),
							d = Object(_.b)(o, {
								commentId: t,
								commentsPageKey: n
							}),
							c = a.depth;
						e(V({
							commentId: t,
							commentsPageKey: n,
							isCollapsed: d
						})), d || 0 !== c || s(t, !0), Object(p.d)()
					}
				}), J = e => {
					let {
						commentId: t,
						commentsPageKey: n
					} = e;
					return async e => {
						e(K({
							commentId: t,
							commentsPageKey: n
						}))
					}
				}, X = e => {
					let {
						commentLink: t,
						commentsPageKey: n,
						lineDepth: s,
						scrollToAndRemeasure: r
					} = e;
					return async (e, o) => {
						const i = o(),
							a = Object(v.e)(n, t, s, i),
							d = Object(_.b)(i, {
								commentId: t.id,
								commentsPageKey: n
							});
						e(V({
							commentId: a,
							commentsPageKey: n,
							isCollapsed: d
						})), 0 === s && r(a, !0), Object(p.d)()
					}
				}, Z = Object(i.a)(T.t), $ = e => t => t(Z({
					draftKey: e
				})), ee = Object(i.a)(T.a), te = Object(i.a)(T.I), ne = Object(i.a)(T.b), se = Object(i.a)(T.w), re = Object(i.a)(T.e), oe = Object(i.a)(T.A), ie = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					var o, i;
					if (e) {
						const n = await Object(g.b)(r(), e);
						if (n.ok) {
							const s = n.body;
							"Comment" === (null === (o = s.data.commentById) || void 0 === o ? void 0 : o.__typename) && t(oe({
								commentId: e,
								media: Object(x.b)(null === (i = s.data.commentById) || void 0 === i ? void 0 : i.content)
							}))
						}
					}
				}
		},
		"./src/reddit/actions/comment/moderation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return E
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "f", (function() {
				return C
			})), n.d(t, "a", (function() {
				return A
			})), n.d(t, "e", (function() {
				return y
			})), n.d(t, "g", (function() {
				return j
			})), n.d(t, "h", (function() {
				return I
			})), n.d(t, "b", (function() {
				return k
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makeCommentsPageKey/index.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/actions/shortcuts/utils.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/modals.ts"),
				u = n("./src/reddit/endpoints/comment/index.tsx"),
				m = n("./src/reddit/endpoints/moderator/snoozableReport.ts"),
				p = n("./src/reddit/models/Reportable/index.ts"),
				b = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/selectors/commentSelector.ts"),
				h = n("./src/reddit/selectors/user.ts"),
				g = n("./src/reddit/actions/comment/index.ts"),
				v = n("./src/reddit/actions/comment/constants.ts");
			const x = Object(o.a)(v.p),
				E = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					n().features.comments.models[e] && (await Object(u.j)(r(), e)).ok && t((e => async t => {
						t(x({
							commentId: e
						}))
					})(e))
				}, O = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					if (!Object(h.S)(n())) return void t(Object(a.i)(l.a.LOGIN_MODAL_ID));
					const i = n().features.comments.models[e];
					if (!i) return;
					const d = i.isLocked ? u.l : u.f;
					t(Object(g.j)({
						[e]: {
							isLocked: !i.isLocked
						}
					})), (await d(o(), e)).ok ? t(Object(c.f)({
						kind: b.b.SuccessMod,
						text: i.isLocked ? s.fbt._("comment has been unlocked", null, {
							hk: "BYjts"
						}) : s.fbt._("comment has been locked", null, {
							hk: "1pBDQl"
						})
					})) : t(Object(g.j)({
						[e]: {
							isLocked: i.isLocked
						}
					}))
				}, C = Object(o.a)(v.J), A = e => async (t, n, s) => {
					let {
						apiContext: r,
						gqlContext: o
					} = s;
					const i = n(),
						a = i.features.comments.models[e],
						c = i.user.account ? i.user.account.displayText : null;
					a && c && (t(Object(g.j)({
						[e]: {
							isApproved: !0,
							approvedBy: c,
							approvedAtUTC: Date.now(),
							bannedBy: null,
							isRemoved: !1,
							isSpam: !1,
							modNote: null,
							modReasonBy: null,
							modRemovalReason: null,
							numReports: 0
						}
					})), (await Object(u.a)(o(), e)).ok || t(Object(g.j)({
						[e]: {
							isApproved: a.isApproved,
							approvedBy: null,
							bannedBy: a.bannedBy,
							isRemoved: a.isRemoved,
							isSpam: a.isSpam,
							modNote: a.modNote,
							modReasonBy: a.modReasonBy,
							modRemovalReason: a.modRemovalReason,
							numReports: a.numReports || null
						}
					})), Object(d.d)())
				}, y = (e, t) => async (n, s, r) => {
					let {
						apiContext: o,
						gqlContext: i
					} = r;
					const a = s(),
						c = a.features.comments.models[e],
						l = a.user.account ? a.user.account.displayText : null;
					c && l && (n(Object(g.j)({
						[e]: {
							approvedBy: null,
							bannedBy: l,
							bannedAtUTC: Date.now(),
							isApproved: !1,
							isRemoved: !t,
							isSpam: t,
							numReports: 0
						}
					})), (await Object(u.h)(i(), e, t)).ok || n(Object(g.j)({
						[e]: {
							approvedBy: c.approvedBy,
							bannedBy: c.bannedBy,
							isApproved: c.isApproved,
							isRemoved: c.isRemoved,
							isSpam: c.isSpam,
							numReports: c.numReports
						}
					})), Object(d.d)())
				}, j = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const i = n().features.comments.models[e];
					if (!i) return;
					const a = i.ignoreReports ? u.k : u.e;
					i.ignoreReports || t(A(e)), t(Object(g.j)({
						[e]: {
							ignoreReports: !i.ignoreReports
						}
					})), (await a(o(), e)).ok ? t(Object(c.f)({
						kind: b.b.SuccessMod,
						text: i.ignoreReports ? s.fbt._("comment has had its reports un-ignored", null, {
							hk: "HcpVV"
						}) : s.fbt._("comment has had its reports ignored", null, {
							hk: "2q4sCp"
						})
					})) : t(Object(g.j)({
						[e]: {
							ignoreReports: i.ignoreReports
						}
					}))
				}, I = (e, t, n) => async (o, i, a) => {
					let {
						gqlContext: d
					} = a;
					const l = Object(f.c)(i(), {
						commentId: e
					});
					if (!l) return;
					const u = n === r.kc.Snoozed,
						h = {
							itemId: e,
							reportText: t,
							isSnoozed: u
						};
					if ((await Object(m.a)(d(), {
							input: h
						})).ok) o(Object(g.j)({
						[e]: {
							userReports: Object(p.a)(l.userReports, t, u)
						}
					}));
					else {
						const e = Object(c.e)(s.fbt._("Sorry, that snooze failed. Try that again", null, {
							hk: "7ToJC"
						}), b.b.Error);
						o(Object(c.f)(e))
					}
				}, k = (e, t, n) => async (s, o, a) => {
					let {
						apiContext: d,
						gqlContext: c
					} = a;
					const l = o(),
						m = l.features.comments.models[e];
					if (!m) return;
					const p = m.postId,
						b = l.postStickiedComments.data[p];
					s(Object(g.j)({
						[e]: {
							distinguishType: t,
							isAdmin: t === r.I.ADMIN,
							isMod: t === r.I.MODERATOR,
							isStickied: !!n
						}
					})), n && b && b !== e && s(Object(g.j)({
						[b]: {
							isStickied: !1
						}
					}));
					const f = Object(u.c)(c(), e, t),
						h = Object(u.d)(c(), e, !!n),
						v = [f];
					(n || !n && e === b) && v.push(h), (await Promise.all(v)).every(e => e.ok) ? n && s(C({
						id: e,
						postId: p,
						commentsPageKey: Object(i.a)(p, null, {
							sort: r.v.CONFIDENCE,
							...l.platform.currentPage.queryParams
						})
					})) : (s(Object(g.j)({
						[e]: {
							distinguishType: m.distinguishType,
							isAdmin: m.isAdmin,
							isMod: m.isMod,
							isStickied: m.isStickied
						}
					})), s(Object(g.j)({
						[b]: {
							isStickied: l.features.comments.models[b].isStickied
						}
					})))
				}
		},
		"./src/reddit/actions/communityChat/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/reducers/features/communityChat/index.ts");
			const i = "COMMUNITY_CHAT__SET_SELECTED_CHANNEL_ID",
				a = "COMMUNITY_CHAT__CHANNELS_LOADED",
				d = "COMMUNITY_CHAT__SET_SHOWN_TOAST_MESSAGE";
			Object(s.a)({
				features: {
					communityChat: o.a
				}
			});
			const c = Object(r.a)(i),
				l = Object(r.a)(a),
				u = Object(r.a)(d)
		},
		"./src/reddit/actions/contentControls/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			}));
			const s = "CONTENT_CONTROLS_FAILED",
				r = "CONTENT_CONTROLS_LOADED",
				o = "CONTENT_CONTROLS_PENDING",
				i = "CONTENT_CONTROLS_UPDATED"
		},
		"./src/reddit/actions/contentControls/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return _
			})), n.d(t, "b", (function() {
				return w
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/camelCase.js"),
				o = n.n(r),
				i = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/lib/sentry/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/reddit/models/HatefulContentFilters/index.ts"),
				m = n("./src/redditGQL/operations/FetchContentControls.json");
			const p = e => {
				switch (e) {
					case "LENIENT":
						return u.a.Lenient;
					case "MODERATE":
						return u.a.Moderate;
					case "STRICT":
						return u.a.Strict;
					default:
						return u.a.Off
				}
			};
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var b = n("./node_modules/lodash/isEmpty.js"),
				f = n.n(b),
				h = n("./src/redditGQL/operations/UpdateHatefulContentFilters.json"),
				g = n("./src/redditGQL/operations/UpdatePostRequirements.json"),
				v = n("./src/reddit/endpoints/subreddit/about.ts"),
				x = n("./src/reddit/featureFlags/index.ts"),
				E = n("./src/reddit/models/Toast/index.ts"),
				O = n("./src/reddit/selectors/contentControls.ts"),
				C = n("./src/reddit/selectors/isModeratorOfSubreddit.ts"),
				A = n("./src/reddit/selectors/subreddit.ts"),
				y = n("./src/reddit/actions/contentControls/constants.ts");
			const j = Object(a.a)(y.b),
				I = Object(a.a)(y.c),
				k = Object(a.a)(y.a),
				_ = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = {
							subredditName: e.toLowerCase()
						},
						a = x.d.hatefulContentFiltersEnabled(n());
					if (Object(O.a)(n(), o)) return;
					t(I(o));
					let c = Object(A.I)(n(), e);
					if (!c) {
						const n = await Object(v.a)(r(), e, !1);
						if (n.ok) {
							c = n.body.data.subreddit.id
						}
						if (!c) {
							const e = n.error || {
								type: i.K.NOT_FOUND_ERROR
							};
							return void t(k({
								...o,
								error: e
							}))
						}
					}
					const u = Object(C.c)(n(), {
						subredditId: c
					});
					let b = null;
					const f = await ((e, t) => Object(l.a)(e, {
						...m,
						variables: t
					}).then(e => {
						var t, n;
						if (e.ok) {
							const s = null === (n = null === (t = e.body) || void 0 === t ? void 0 : t.data) || void 0 === n ? void 0 : n.subreddit;
							return {
								...e,
								body: {
									data: {
										subreddit: {
											hatefulContentFilters: {
												hatefulContentThresholdAbuse: p(null == s ? void 0 : s.hatefulContentThresholdAbuse),
												hatefulContentThresholdIdentity: p(null == s ? void 0 : s.hatefulContentThresholdIdentity),
												permittedTerms: (null == s ? void 0 : s.hatefulContentPermittedTerms) || []
											},
											postRequirements: null == s ? void 0 : s.postRequirements
										}
									}
								}
							}
						}
						return e
					}))(r(), {
						subredditId: c,
						includeHatefulFilters: u && a
					});
					if (f.ok) {
						const e = f.body;
						b = e.data.subreddit && e.data.subreddit
					}
					if (b) t(j({
						...o,
						...b
					}));
					else {
						const n = f.error || {
							type: i.K.UNKNOWN_ERROR
						};
						t(k({
							...o,
							error: n
						})), d.c.withScope(t => {
							t.setExtra("info", {
								subredditName: e,
								responseBody: f.body,
								responseOk: f.ok
							}), d.c.captureMessage("Missing post requirements data!")
						})
					}
				}, S = Object(a.a)(y.d), w = (e, t) => async (n, r, o) => {
					let {
						gqlContext: i
					} = o;
					const a = e.toLowerCase(),
						d = Object(A.I)(r(), e);
					if (!d) return {
						success: !1
					};
					const u = await ((e, t, n) => {
						const s = [Promise.resolve(null), Promise.resolve(null)];
						if (n.postRequirements && !f()(n.postRequirements)) {
							const r = {
								subredditId: t,
								...n.postRequirements
							};
							s[0] = Object(l.a)(e, {
								...g,
								variables: {
									input: r
								}
							})
						}
						if (n.hatefulContentFilters && !f()(n.hatefulContentFilters)) {
							const r = {
									subredditId: t,
									hatefulContentThresholdAbuse: n.hatefulContentFilters.hatefulContentThresholdAbuse,
									hatefulContentThresholdIdentity: n.hatefulContentFilters.hatefulContentThresholdIdentity
								},
								o = !(!r.hatefulContentThresholdAbuse && !r.hatefulContentThresholdIdentity),
								i = {
									subredditId: t,
									permittedTerms: n.hatefulContentFilters.permittedTerms
								},
								a = !!i.permittedTerms;
							s[1] = Object(l.a)(e, {
								...h,
								variables: {
									includeThresholds: o,
									includePermittedTerms: a,
									thresholdInput: r,
									permittedTermsInput: i
								}
							})
						}
						return Promise.all(s).then(e => {
							let [t, n] = e, s = !0, r = [];
							if (t) {
								const e = t.body,
									n = e.data.updatePostRequirements.fieldErrors;
								s = s && e.data.updatePostRequirements.ok, n && (r = r.concat(n))
							}
							if (n) {
								const {
									data: {
										updateHatefulContentSettings: e,
										updateSubredditSettings: t
									}
								} = n.body;
								t && (s = s && t.ok), e && (s = s && e.ok);
								const o = null == t ? void 0 : t.fieldErrors,
									i = null == e ? void 0 : e.fieldErrors;
								o && (r = r.concat(o)), i && (r = r.concat(i))
							}
							return {
								ok: s,
								fieldErrors: r.length ? r : null
							}
						})
					})(i(), d, t);
					if (u.ok) return n(S({
						subredditName: a,
						partialUpdates: t
					})), n(Object(c.f)({
						kind: E.b.SuccessCommunity,
						text: s.fbt._("Subreddit content controls updated successfully", null, {
							hk: "1n6QIQ"
						})
					})), {
						success: !0
					}; {
						const r = T(u.fieldErrors);
						return n(Object(c.f)({
							kind: E.b.Error,
							text: s.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
								hk: "3wBPeO"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: w(e, t)
						})), {
							success: !1,
							errors: r || void 0
						}
					}
				}, T = e => e && e.map(e => ({
					...e,
					field: o()(e.field)
				}))
		},
		"./src/reddit/actions/countrySites/subredditCountrySiteSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return v
			})), n.d(t, "a", (function() {
				return x
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "g", (function() {
				return A
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "f", (function() {
				return I
			}));
			var s = n("./node_modules/@sentry/minimal/esm/index.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/redditGQL/operations/GetSubredditCountrySiteSettings.json"),
				a = n("./src/redditGQL/operations/UpdateSubredditCountrySiteSettings.json");
			const d = e => ({
				input: {
					subredditId: e.subredditId,
					countryCode: e.countryCode || "",
					languageCode: e.languageCode || ""
				}
			});
			var c = async (e, t) => Object(o.a)(e, {
				...a,
				variables: d(t)
			}), l = n("./node_modules/fbt/lib/FbtPublic.js"), u = n("./src/reddit/models/Toast/index.ts"), m = n("./node_modules/reselect/es/index.js"), p = n("./src/reddit/constants/experiments.ts"), b = n("./src/reddit/helpers/chooseVariant/index.ts"), f = n("./src/reddit/selectors/user.ts");
			const h = Object(m.a)(e => Object(b.c)(e, {
				experimentEligibilitySelector: f.S,
				experimentName: p.cc
			}), e => e === p.Yd);
			var g = n("./src/reddit/actions/toaster.ts");
			const v = "SUBREDDIT_COUNTRY_SITE__LOADED",
				x = "SUBREDDIT_COUNTRY_SITE__CHANGED",
				E = "SUBREDDIT_COUNTRY_SITE__UPDATE_SUCCESS",
				O = Object(r.a)(v),
				C = Object(r.a)(E),
				A = Object(r.a)(x),
				y = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					var a;
					if (!e) return;
					const d = await (async (e, t) => Object(o.a)(e, {
							...i,
							variables: {
								subredditId: t
							}
						}))(r(), e),
						c = d.body;
					d && d.ok && c && t(O({
						subredditId: e,
						subredditCountrySite: null === (a = c.data) || void 0 === a ? void 0 : a.subredditInfoById.countrySiteSettings
					}))
				}, j = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					if (!e) return;
					const i = await c(o(), {
						subredditId: e,
						countryCode: t.countryCode,
						languageCode: t.languageCode
					});
					if (!i.ok) return n(Object(g.f)({
						kind: u.b.Error,
						text: l.fbt._("Something went wrong", null, {
							hk: "2PnKbu"
						}),
						duration: 5e3
					}));
					const a = i.body;
					n(C({
						subredditId: e,
						subredditCountrySite: a.data.updateSubredditCountrySiteSettings.subreddit.countrySiteSettings
					}))
				}, I = (e, t) => async (n, r, o) => {
					let {
						gqlContext: i
					} = o;
					if (!e || !h(r())) return;
					const a = {
							subredditId: e,
							countryCode: "",
							languageCode: t
						},
						d = await c(i(), a);
					if (d.ok) {
						const t = d.body;
						n(C({
							subredditId: e,
							subredditCountrySite: t.data.updateSubredditCountrySiteSettings.subreddit.countrySiteSettings
						}))
					} else s.l(e => {
						e.setExtra("subredditCountryLanginfo", a), s.c(d.error)
					})
				}
		},
		"./src/reddit/actions/creatorStats/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = "CREATOR_STATS_PENDING",
				r = "CREATOR_STATS_LOADED"
		},
		"./src/reddit/actions/crosspostSubredditRec/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/postCreation/general.ts"),
				o = n("./src/reddit/selectors/experiments/crosspostRecommendations.ts");
			var i = n("./src/lib/initializeClient/installReducer.ts");
			var a = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "CROSSPOST_RECOMMENDATIONS__SHOULD_TRY_TO_RENDER":
						return !0;
					case "CROSSPOST_RECOMMENDATIONS__STOP_TRYING_TO_RENDER":
						return !1;
					default:
						return e
				}
			};
			Object(i.a)({
				features: {
					shouldTryToShowCrosspostModal: a
				}
			});
			const d = Object(s.a)("CROSSPOST_RECOMMENDATIONS__SHOULD_TRY_TO_RENDER"),
				c = Object(s.a)("CROSSPOST_RECOMMENDATIONS__STOP_TRYING_TO_RENDER"),
				l = e => async (t, n) => {
					const s = n();
					if (!Object(o.b)(s)) return;
					const i = e.title,
						a = Object(o.d)(e),
						d = Object(o.c)(e);
					t(Object(r.j)(i, a, d, t => {
						const n = e.belongsTo.id === t.id,
							s = "isCrosspostDestination" in t && t.isCrosspostDestination;
						return n || !s
					}))
				}
		},
		"./src/reddit/actions/discoveryUnit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			}));
			n("./src/lib/constants/index.ts");
			var s = n("./src/lib/makeActionCreator/index.ts");
			n("./src/lib/makeListingKey/index.ts"), n("./src/lib/addQueryParams/index.ts"), n("./src/lib/makeApiRequest/index.ts"), n("./src/lib/omitHeaders/index.ts"), n("./src/lib/stringInterpolate/index.ts"), n("./src/reddit/constants/headers.ts"), n("./src/reddit/helpers/r2/normalizePostFromR2/index.ts"), n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			var r = n("./src/reddit/selectors/discoveryUnit.ts");
			n("./src/reddit/selectors/listings.ts");
			const o = "DISCOVERY_UNIT__LIST_PENDING",
				i = "DISCOVERY_UNIT__LIST_LOADED",
				a = "DISCOVERY_UNIT__LIST_FAILED",
				d = Object(s.a)(o),
				c = Object(s.a)(i),
				l = Object(s.a)(a),
				u = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const o = t(),
						i = Object(r.d)(o),
						a = Object(r.c)(o);
					if (i || a) return;
					e(d());
					const u = await (e => Promise.resolve({
						ok: !0,
						error: null,
						status: 200,
						headers: {},
						details: "",
						body: {
							global: {
								discovery_config_v1: {
									discovery_units: [{
										id: "xd_66",
										enabled: !0,
										layout: "large",
										parameters: {
											sort: "hot"
										},
										surface: "explore",
										unit_name: "posts_in_category_rails_hero",
										unit_type: "listing",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_67",
										enabled: !0,
										layout: "large",
										surface: "explore",
										unit_name: "posts_in_subreddit_hero",
										unit_type: "listing",
										url: "/r/%{subredditName}/hot.json"
									}, {
										id: "xd_68",
										enabled: !0,
										layout: "large",
										parameters: {
											sort: "hot"
										},
										surface: "explore",
										unit_name: "posts_in_category_rails_small",
										unit_type: "listing",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_69",
										enabled: !0,
										layout: "large",
										surface: "explore",
										unit_name: "posts_in_subreddit_small",
										unit_type: "listing",
										url: "/r/%{subredditName}/hot.json"
									}, {
										id: "xd_70",
										enabled: !0,
										layout: "large",
										surface: "search",
										unit_name: "search_posts",
										unit_type: "community_category",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_71",
										enabled: !0,
										layout: "large",
										surface: "search",
										unit_name: "search_subreddits",
										unit_type: "community_category",
										url: "/api/subreddits_in_category.json"
									}, {
										id: "xd_72",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "community_banner_posts",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_83",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "best_of_community",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_91",
										enabled: !0,
										layout: "large",
										surface: "comments",
										title: "Posts in subreddit %{subredditName}",
										unit_name: "posts_in_subreddit_vertical",
										unit_type: "listing"
									}, {
										id: "xd_92",
										enabled: !0,
										layout: "large",
										surface: "comments",
										title: "Posts in recommended home",
										unit_name: "posts_in_rec_home",
										unit_type: "listing"
									}, {
										id: "xd_96",
										enabled: !0,
										layout: "small",
										surface: "subreddit_listing",
										unit_name: "top_week_posts",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_97",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "top_week_posts_large",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}]
								}
							}
						}
					}))(s());
					if (u.ok) {
						const {
							discoveryUnits: t
						} = (e => {
							return {
								discoveryUnits: e.global.discovery_config_v1.discovery_units.reduce((e, t) => {
									const n = {
										enabled: t.enabled,
										experiment: t.experiment,
										id: t.id,
										index: t.index,
										layout: t.layout,
										options: t.options,
										parameters: t.parameters,
										subtitle: t.subtitle,
										subtitleIcon: t.subtitle_icon,
										surface: t.surface,
										title: t.title,
										unitName: t.unit_name,
										unitType: t.unit_type,
										url: t.url
									};
									return e[n.id] = n, e
								}, {})
							}
						})(u.body);
						e(c({
							discoveryUnits: t
						}))
					} else e(l({
						error: u.error
					}))
				}, m = "DISCOVERY_UNIT__UNIT_DATA_PENDING", p = "DISCOVERY_UNIT__UNIT_DATA_LOADED", b = "DISCOVERY_UNIT__UNIT_DATA_FAILED";
			Object(s.a)(m), Object(s.a)(p), Object(s.a)(b)
		},
		"./src/reddit/actions/economics/claims/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = "ECONOMICS__CLAIMS__CLAIM_PENDING",
				r = "ECONOMICS__CLAIMS__CLAIM_COMPLETED"
		},
		"./src/reddit/actions/economics/helpers/async.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => async t => {
				const s = await (() => n.e("EconHelperActions").then(n.bind(null, "./src/reddit/actions/economics/helpers/index.ts")).then(e => e.fetchAll))();
				await t(s(e))
			}
		},
		"./src/reddit/actions/economics/me/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			const s = "ECONOMICS__ME__ME_DATA_SUCCESS",
				r = "ECONOMICS__ME__POINTS_COPY_REQUESTED",
				o = "ECONOMICS__ME__POINTS_COPY_SUCCESS"
		},
		"./src/reddit/actions/economics/paymentSystems/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			}));
			const s = "ECONOMICS__PAYMENT_SYSTEM__CARD_DELETE_SUCCESS",
				r = "ECONOMICS__PAYMENT_SYSTEM__PAYPAL_DELETE_SUCCESS",
				o = "ECONOMICS__PAYMENT_SYSTEM__INFO_FAILURE",
				i = "ECONOMICS__PAYMENT_SYSTEM__INFO_FETCHED",
				a = "ECONOMICS__PAYMENT_SYSTEM__INFO_PENDING"
		},
		"./src/reddit/actions/economics/predictions/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return W
			})), n.d(t, "k", (function() {
				return z
			})), n.d(t, "o", (function() {
				return V
			})), n.d(t, "r", (function() {
				return K
			})), n.d(t, "q", (function() {
				return Y
			})), n.d(t, "l", (function() {
				return ee
			})), n.d(t, "m", (function() {
				return te
			})), n.d(t, "n", (function() {
				return ne
			})), n.d(t, "b", (function() {
				return se
			})), n.d(t, "u", (function() {
				return re
			})), n.d(t, "v", (function() {
				return oe
			})), n.d(t, "g", (function() {
				return ie
			})), n.d(t, "a", (function() {
				return ae
			})), n.d(t, "w", (function() {
				return ce
			})), n.d(t, "p", (function() {
				return le
			})), n.d(t, "i", (function() {
				return ue
			})), n.d(t, "j", (function() {
				return me
			})), n.d(t, "s", (function() {
				return pe
			})), n.d(t, "t", (function() {
				return be
			})), n.d(t, "f", (function() {
				return fe
			})), n.d(t, "c", (function() {
				return he
			})), n.d(t, "d", (function() {
				return ge
			})), n.d(t, "h", (function() {
				return ve
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				o = n("./src/lib/initializeClient/installReducer.ts"),
				i = n("./src/reddit/reducers/features/predictions/index.ts"),
				a = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/lib/makeRequest/index.ts")),
				d = n("./src/lib/uploadToS3/index.ts"),
				c = n("./src/lib/makeGqlRequest/index.ts"),
				l = n("./src/redditGQL/operations/CreateMediaUploadLease.json"),
				u = n("./src/redditGQL/operations/SubmitMediaUpload.json");
			var m = n("./src/reddit/helpers/graphql/normalizeUploadLeaseFromGql/index.ts"),
				p = n("./src/reddit/helpers/media/index.ts"),
				b = n("./src/redditGQL/types.ts");
			const f = new Map([
					["image/png", b.x.Png],
					["image/gif", b.x.Gif],
					["image/jpeg", b.x.Jpeg]
				]),
				h = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const i = await Object(p.h)(t) || t.type,
						b = f.get(i);
					if (!b) throw new Error("Unacceptable file type");
					const {
						mediaId: h,
						uploadLease: g
					} = await (async (e, t) => {
						const n = await Object(c.a)(e, {
							...l,
							variables: {
								input: t
							}
						});
						if (!Object(a.c)(n) || n.error) throw new Error("Failed to create upload lease");
						return n.body.data.createMediaUploadLease
					})(o(), {
						mimetype: b
					}), v = Object(m.a)(g), x = await Object(d.a)(t, v);
					if (!Object(a.c)(x)) throw new Error("Failed to upload file to S3");
					return await (async (e, t) => {
						const n = await Object(c.a)(e, {
							...u,
							variables: {
								input: t
							}
						});
						if (!Object(a.c)(n) || n.error) throw new Error("Failed to submit media")
					})(o(), {
						mediaId: h,
						redditId: e
					}), {
						mediaId: h,
						mimeType: b
					}
				};
			var g = n("./src/reddit/actions/toaster.ts"),
				v = n("./src/reddit/models/Toast/index.ts"),
				x = n("./src/lib/delay/index.ts"),
				E = n("./src/lib/makeActionCreator/index.ts"),
				O = n("./src/reddit/endpoints/economics/predictions.ts");

			function C(e) {
				let {
					topPredictorsRank: t,
					currentRank: n
				} = e;
				return {
					currentRank: n ? A(n) : null,
					topPredictorsRank: t.map(A)
				}
			}

			function A(e) {
				let {
					score: t,
					rank: n,
					redditor: s,
					redditorInfo: r
				} = e;
				var o, i;
				return {
					score: t,
					rank: n,
					redditor: s ? {
						...s,
						icon: null !== (o = s.icon) && void 0 !== o ? o : null,
						profile: null !== (i = s.profile) && void 0 !== i ? i : null
					} : null,
					redditorInfo: r
				}
			}
			var y = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				j = n("./src/reddit/helpers/graphql/normalizePredictionTournamentFromGql/index.ts"),
				I = n("./src/reddit/actions/login.ts"),
				k = n("./src/reddit/actions/modal.ts"),
				_ = n("./src/reddit/constants/modals.ts"),
				S = n("./src/reddit/selectors/features/predictions/leaderboards/index.ts"),
				w = n("./src/reddit/selectors/subreddit.ts"),
				T = n("./src/reddit/selectors/user.ts"),
				P = n("./src/reddit/selectors/features/predictions/creation/index.ts"),
				N = n("./src/reddit/selectors/features/predictions/tournaments/index.ts"),
				D = n("./src/reddit/actions/economics/predictions/constants.ts");
			Object(o.a)({
				features: {
					predictions: i.a
				}
			});
			const M = Object(E.a)(D.d),
				R = Object(E.a)(D.c),
				L = Object(E.a)(D.e),
				B = Object(E.a)(D.f),
				F = Object(E.a)(D.i),
				U = Object(E.a)(D.h),
				H = Object(E.a)(D.j),
				G = Object(E.a)(D.p),
				Q = Object(E.a)(D.s),
				q = Object(E.a)(D.o),
				W = Object(E.a)(D.b),
				z = (e, t, n) => async (s, r, o) => {
					let {
						gqlContext: i
					} = o;
					const a = Object(T.S)(r());
					if (!Object(S.c)(r(), {
							subredditId: e
						})) {
						s(M({
							subredditId: e
						}));
						try {
							const {
								predictionTournaments: r,
								predictionWinners: o
							} = await Object(O.i)(i(), {
								subredditId: e,
								period: n,
								top: t,
								includeCurrentRank: a
							}), d = C(o);
							s(L({
								subredditId: e,
								leaderboard: d
							})), r && (s(ne(e, r)), null == r || r.forEach(e => {
								let {
									tournamentId: t,
									winners: n
								} = e;
								s(B({
									tournamentId: t,
									leaderboard: C(n)
								}))
							}))
						} catch {
							s(R({
								subredditId: e
							}))
						}
					}
				}, V = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const i = Object(T.S)(s());
					if (!Object(S.g)(s(), {
							tournamentId: t
						})) {
						n(F({
							tournamentId: t
						}));
						try {
							const {
								predictionWinners: s
							} = await Object(O.j)(o(), {
								subredditId: e,
								tournamentId: t,
								includeCurrentRank: i
							}), r = C(s);
							n(H({
								tournamentId: t,
								leaderboard: r
							}))
						} catch {
							n(U({
								tournamentId: t
							}))
						}
					}
				}, K = e => {
					let {
						coinPackageId: t,
						optionId: n,
						postId: s,
						price: r
					} = e;
					return async (e, o, i) => {
						let {
							gqlContext: a
						} = i;
						const d = await Object(O.p)(a(), {
							coinPackageId: t,
							optionId: n,
							postId: s,
							price: r
						});
						return e(G({
							pollId: s,
							prediction: d,
							price: r
						})), d
					}
				}, Y = e => {
					let {
						optionId: t,
						postId: n
					} = e;
					return async (e, s, r) => {
						let {
							gqlContext: o
						} = r;
						const i = await Object(O.n)(o(), {
								optionId: t,
								postId: n
							}),
							{
								resolvePrediction: a
							} = i.body.data;
						if (!(null == a ? void 0 : a.poll)) throw new Error("Failed to resolve prediction");
						return e(q({
							pollId: n,
							prediction: a.poll
						})), a.poll
					}
				}, J = Object(E.a)(D.k), X = Object(E.a)(D.m), Z = Object(E.a)(D.l), $ = Object(E.a)(D.n), ee = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n(),
						i = Object(w.I)(o, e);
					if (Object(N.k)(o, {
							subredditId: i
						})) return Object(N.g)(o, {
						subredditId: i
					});
					t(J({
						subredditId: i
					}));
					const a = await Object(O.k)(r(), {
							subredditName: e,
							isLatestOnly: !0,
							isIncludingPredictions: !0,
							isIncludingParticipants: !0,
							isIncludingCancelledPredictions: !0
						}),
						d = {};
					a.forEach(e => {
						var n;
						if ((null === (n = e.predictionPosts) || void 0 === n ? void 0 : n.length) && e.predictionPosts.forEach(e => {
								e && (d[e.id] = Object(y.f)(e))
							}), e.winners) {
							const n = C(e.winners);
							t(B({
								tournamentId: e.tournamentId,
								leaderboard: n
							}))
						}
					});
					const c = a.map(e => Object(j.a)(e));
					return t(Z({
						subredditId: i,
						tournaments: c
					})), t(X({
						subredditId: i,
						tournaments: c
					})), t($({
						posts: d,
						meta: o.meta
					})), c
				}, te = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n(),
						i = Object(w.I)(o, e),
						a = await Object(O.l)(r(), {
							subredditName: e,
							isLatestOnly: !0
						});
					t(ne(i, a))
				}, ne = (e, t) => n => {
					const s = t.map(e => Object(j.a)(e));
					n(X({
						subredditId: e,
						tournaments: s
					}))
				}, se = Object(E.a)(D.a), re = Object(E.a)(D.q), oe = Object(E.a)(D.r), ie = (e, t, n, s) => async (r, o, i) => {
					let {
						gqlContext: a
					} = i;
					const d = o(),
						c = Object(P.b)(d);
					let l = null;
					if (!c) throw new Error("Failed to create tournament, no prediction drafts attached");
					if (s instanceof File) {
						const {
							mediaId: t,
							mimeType: n
						} = await r(h(`icon_pred_${e}`, s));
						await Object(x.a)(3e3), l = {
							mediaId: t,
							width: 1,
							height: 1,
							mimeType: n.toLowerCase()
						}
					} else s && (l = {
						url: s,
						width: 1,
						height: 1,
						mimeType: ""
					});
					const u = await Object(O.e)(a(), {
							tournamentId: null,
							name: t,
							themeId: n,
							isStartImmediately: !0,
							subredditId: e,
							predictionDrafts: c,
							currency: b.ab.Tokens,
							tokenIcon: l
						}),
						m = Object(j.a)(u);
					r(de(m))
				}, ae = (e, t) => async (n, s, o) => {
					let {
						gqlContext: i
					} = o;
					const a = Object(P.b)(s());
					if (!a) throw new Error("Failed to create prediction post, no prediction drafts attached");
					const d = await Object(O.a)(i(), {
							tournamentId: e,
							isStartImmediately: !0,
							iKey: `add-dfts-${Object(r.a)()}`,
							subredditId: t,
							predictionDrafts: a
						}),
						c = Object(j.a)(d);
					n(de(c))
				}, de = Object(E.a)(D.g), ce = (e, t, n) => async (t, s, r) => {
					let {
						gqlContext: o
					} = r;
					const i = await Object(O.o)(o(), {
							tournamentId: e,
							name: n
						}),
						a = Object(j.a)(i);
					t(de(a))
				}, le = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = await Object(O.f)(r(), {
							tournamentId: e
						}),
						{
							endPredictionTournament: i
						} = o.body.data;
					if (!i.tournament) throw new Error("Failed to update prediction name");
					return t(de(i.tournament)), i.tournament
				}, ue = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = await Object(O.g)(r(), {
						postId: e
					});
					if (!o.ok || o.error) throw new Error("Failed to fetch prediction chip packages");
					const {
						postInfoById: i
					} = o.body.data;
					if (!i.predictionChipPackages) throw new Error("Failed to fetch prediction chip packages");
					return i.predictionChipPackages
				}, me = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = await Object(O.h)(r(), {
						tournamentId: e
					});
					if (!o.ok || o.error) throw new Error("Failed to fetch token balance");
					const {
						identity: i
					} = o.body.data;
					if (!i.hasOwnProperty("predictionTokens")) throw new Error("Failed to fetch token balance");
					return i.predictionTokens
				}, pe = e => {
					let {
						coinPackageId: t,
						selectedOptionId: n,
						price: s,
						pollId: r,
						tournamentId: o,
						tournamentPostId: i
					} = e;
					return async e => {
						const a = await e(K({
							coinPackageId: t,
							optionId: n,
							postId: r,
							price: s
						}));
						return e(Q({
							predictionId: r,
							selectedOptionId: n,
							tournamentId: o,
							tournamentPostId: i
						})), a
					}
				}, be = e => async (t, n) => {
					const s = n();
					Object(T.S)(s) ? await t(Object(k.h)(_.a.ECON_PREDICTIONS_PREMIUM_UPSELL, {
						feature: e
					})) : await t(Object(I.openLoginModal)())
				}, fe = () => Object(k.g)(_.a.ECON_PREDICTIONS_PREMIUM_UPSELL), he = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					try {
						const n = await Object(O.b)(o(), {
							postId: e
						});
						t(W({
							postId: e,
							prediction: n
						}));
						const r = Object(g.e)(s.fbt._("Prediction has been cancelled", null, {
							hk: "3Bh9Fw"
						}), v.b.SuccessMod);
						t(Object(g.f)(r))
					} catch {
						const e = Object(g.e)(s.fbt._("Unable to cancel prediction", null, {
							hk: "2wkeKy"
						}), v.b.Error);
						t(Object(g.f)(e))
					}
				};

			function ge(e, t) {
				return async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const i = await Object(O.c)(o(), {
						postId: e,
						...t
					});
					return n(W({
						postId: e,
						prediction: i
					})), i
				}
			}
			const ve = e => async (t, n, s) => {
				let {
					gqlContext: r
				} = s;
				return Object(O.m)(r(), {
					subredditId: e
				})
			}
		},
		"./src/reddit/actions/economics/subredditPremium/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			}));
			const s = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_APPLIED",
				r = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_BADGE_TYPE_CHANGED",
				o = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_MODAL_OPENED",
				i = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_VIEW_CHANGED",
				a = "ECONOMICS__SUBREDDIT_PREMIUM__EDITOR_PRODUCTS_FETCH_SUCCESS",
				d = "ECONOMICS__SUBREDDIT_PREMIUM__ORDER_SUCCESS",
				c = "ECONOMICS__SUBREDDIT_PREMIUM__SUBREDDIT_INFO_SUCCESS",
				l = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_CANCEL_SUCCESS",
				u = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_DATA_SUCCESS"
		},
		"./src/reddit/actions/emoji.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return A
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "g", (function() {
				return S
			})), n.d(t, "f", (function() {
				return w
			})), n.d(t, "e", (function() {
				return T
			})), n.d(t, "a", (function() {
				return M
			})), n.d(t, "o", (function() {
				return B
			})), n.d(t, "n", (function() {
				return U
			})), n.d(t, "k", (function() {
				return H
			})), n.d(t, "l", (function() {
				return G
			})), n.d(t, "i", (function() {
				return Q
			})), n.d(t, "j", (function() {
				return q
			})), n.d(t, "d", (function() {
				return W
			})), n.d(t, "m", (function() {
				return V
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/forEach.js"),
				o = n.n(r),
				i = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/lib/uploadToS3/index.ts"),
				l = n("./src/reddit/constants/headers.ts");
			const u = async (e, t) => Object(a.a)(Object(d.a)(e, [l.a]), {
				endpoint: `${e.apiUrl}/api/v1/${t}/emojis/all`,
				method: i.ob.GET,
				type: "json"
			}).then(e => (e.ok && (e.body = (e => {
				let t;
				const n = o()(e, (e, n) => ("snoomojis" !== n && (t = n), o()(e, (t, n) => {
					e[n] = {
						name: n,
						userFlairAllowed: t.user_flair_allowed,
						postFlairAllowed: t.post_flair_allowed,
						modFlairOnly: t.mod_flair_only,
						url: t.url
					}
				})));
				return {
					[t]: {
						emojis: n[t],
						snoomojis: n.snoomojis
					}
				}
			})(e.body)), e));
			var m = n("./src/lib/makeActionCreator/index.ts"),
				p = n("./src/reddit/actions/imageUploads.ts"),
				b = n("./src/reddit/actions/toaster.ts"),
				f = n("./src/reddit/helpers/getGenericUploadError.ts"),
				h = n("./src/reddit/helpers/getS3KeyFromUrl/index.ts"),
				g = n("./src/reddit/helpers/media/index.ts"),
				v = n("./src/reddit/models/Emoji/index.ts"),
				x = n("./src/reddit/models/Image/index.tsx"),
				E = n("./src/reddit/models/Toast/index.ts"),
				O = n("./src/reddit/selectors/emojis.ts"),
				C = n("./src/reddit/selectors/subreddit.ts");
			const A = "STRUCTURED_STYLES__NEW_EMOJI_ADDED",
				y = Object(m.a)(A),
				j = "STRUCTURED_STYLES__EMOJI_DELETE_LOADED",
				I = "STRUCTURED_STYLES__EMOJI_DELETE_FAILED",
				k = Object(m.a)(j),
				_ = Object(m.a)(I),
				S = "GET_ALL_EMOJIS_PENDING",
				w = "GET_ALL_EMOJIS_LOADED",
				T = "GET_ALL_EMOJIS_FAILED",
				P = Object(m.a)(S),
				N = Object(m.a)(w),
				D = Object(m.a)(T),
				M = "STRUCTURED_STYLES__EMOJIS_ENABLED_SETTING_LOADED",
				R = Object(m.a)(M),
				L = e => ({
					text: s.fbt._("Failed to save emoji", null, {
						hk: "3i6FC2"
					}),
					buttonText: s.fbt._("Retry", null, {
						hk: "1XMjgA"
					}),
					buttonAction: U(e)
				}),
				B = e => {
					let {
						imageData: t,
						subredditId: n
					} = e;
					return async (e, s, r) => {
						const o = s(),
							u = Object(C.X)(o, {
								subredditId: n
							}).name;
						e(Object(p.k)(t));
						const m = t.file,
							b = await Object(g.h)(m),
							f = await (async (e, t, n, s) => Object(a.a)(Object(d.a)(e, [l.a]), {
								endpoint: `${e.apiUrl}/api/v1/${t}/emoji_asset_upload_s3.json`,
								method: i.ob.POST,
								data: {
									filepath: n,
									mimetype: s
								}
							}))(r.apiContext(), u, m.name, b);
						let h = !1;
						if (f.ok) {
							const n = await (async (e, t, n) => Object(c.a)(n, t))(r.apiContext(), f.body.s3UploadLease, m);
							if (n.ok) {
								if (!s().imageUploads[t.id]) return Object(x.d)(t), !1;
								const r = decodeURIComponent(n.body.PostResponse.Location),
									o = f.body.websocketUrl,
									i = Object(x.n)(t, r, o);
								e(Object(p.j)(i)), h = !0
							} else {
								const s = Object(x.k)(t, n.error);
								e(Object(p.i)(s))
							}
						} else {
							const n = Object(x.k)(t, f.error);
							e(Object(p.i)(n))
						}
						return h
					}
				},
				F = (e, t) => async (n, s, r) => {
					const {
						imageData: o,
						subredditId: c,
						emojiName: u,
						settings: m
					} = e, f = Object(h.a)(o.url), g = s(), v = Object(C.X)(g, {
						subredditId: c
					}).name, E = await (async (e, t, n, s, r) => Object(a.a)(Object(d.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/api/v1/${t}/emoji.json`,
						method: i.ob.POST,
						data: {
							s3_key: n,
							name: s,
							mod_flair_only: r.modFlairOnly,
							post_flair_allowed: r.postFlairAllowed,
							user_flair_allowed: r.userFlairAllowed
						}
					}))(r.apiContext(), v, f, u, m);
					if (!E.ok) {
						const s = Object(x.k)(o, E.error);
						n(Object(p.i)(s)), n(Object(b.f)(L(e))), t && t.close()
					}
					return E.ok
				}, U = e => async (t, n, r) => {
					const {
						imageData: o,
						subredditId: i,
						emojiName: a,
						settings: d
					} = e;
					if (t(Object(p.k)(o)), !o.websocketUrl) return t(Object(b.f)({
						text: s.fbt._("Could not upload emoji", null, {
							hk: "29nzfh"
						})
					}));
					let c;
					const l = new WebSocket(o.websocketUrl);
					return l.onopen = async () => {
						c = await F(e, l)(t, n, r)
					}, l.onmessage = n => {
						const s = JSON.parse(n.data);
						if ("success" === s.type) {
							c = !0;
							const e = s.payload.emoji_url,
								n = Object(x.o)(o, e);
							t(Object(p.l)(n));
							const r = Object(v.e)(a, n.url, i, d);
							t(y(r)), t(H(i))
						} else {
							const n = Object(f.a)(a),
								s = Object(x.k)(o, n);
							t(Object(p.i)(s)), t(Object(b.f)(L(e)))
						}
						l.close()
					}, l.onerror = n => {
						c = !1;
						const s = Object(f.a)(a),
							r = Object(x.k)(o, s);
						t(Object(p.i)(r)), t(Object(b.f)(L(e))), l.close()
					}, c
				}, H = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n();
					if (Object(O.a)(o, e)) return;
					const i = Object(C.X)(o, {
						subredditId: e
					}).name;
					t(P(e));
					const a = await u(r(), i);
					if (a.ok) {
						const n = a.body;
						t(N({
							subredditId: e,
							data: n
						}))
					} else t(D({
						subredditId: e,
						error: a.error
					}))
				}, G = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					n().emojis[e] || await t(H(e))
				}, Q = (e, t) => async (n, r, o) => {
					let {
						apiContext: c
					} = o;
					const u = r(),
						m = Object(C.X)(u, {
							subredditId: t
						}).name,
						p = await (async (e, t, n) => Object(a.a)(Object(d.a)(e, [l.a]), {
							endpoint: `${e.apiUrl}/api/v1/${n}/emoji/${t}`,
							method: i.ob.DELETE,
							type: "json"
						}))(c(), e, m);
					if (p.ok) {
						n(k({
							emojiName: e,
							subredditId: t
						})), n(b.f({
							kind: E.b.SuccessCommunityGreen,
							text: s.fbt._("Emoji successfully deleted", null, {
								hk: "1zMXEe"
							})
						}))
					} else n(_(p.error)), n(b.f({
						kind: E.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						})
					}))
				}, q = (e, t) => async (n, r, o) => {
					let {
						apiContext: c
					} = o;
					const u = r(),
						m = Object(C.X)(u, {
							subredditId: e
						}).name;
					if ((await (async (e, t, n) => Object(a.a)(Object(d.a)(e, [l.a]), {
							endpoint: `${e.apiUrl}/api/enable_emojis_in_sr.json`,
							method: i.ob.POST,
							data: {
								subreddit: t,
								enable: n
							}
						}))(c(), m, t)).ok) {
						n(R({
							subredditId: e,
							emojisEnabled: t
						}))
					} else n(b.f({
						kind: E.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						})
					}))
				}, W = "EMOJI_PERMISSIONS_UPDATED", z = Object(m.a)(W), V = (e, t, n, r) => async (o, c, u) => {
					let {
						apiContext: m
					} = u;
					const p = c(),
						f = Object(C.X)(p, {
							subredditId: r
						}).name;
					(await (async (e, t, n, s) => Object(a.a)(Object(d.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/api/v1/${n}/emoji_permissions.json`,
						method: i.ob.POST,
						data: {
							name: t,
							post_flair_allowed: s.postFlairAllowed,
							user_flair_allowed: s.userFlairAllowed,
							mod_flair_only: s.modFlairOnly
						}
					}))(m(), e, f, n)).ok ? (o(z({
						emojiName: e,
						isSnoomoji: t,
						settings: n,
						subredditId: r
					})), o(b.f({
						kind: E.b.SuccessCommunityGreen,
						text: s.fbt._("Emoji permissions updated", null, {
							hk: "4b2RIU"
						})
					}))) : o(b.f({
						kind: E.b.Error,
						text: s.fbt._("Try again later", null, {
							hk: "4dziDF"
						})
					}))
				}
		},
		"./src/reddit/actions/eventPosts/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			const s = "MOD_PAGE_EVENT_POSTS_LOADED",
				r = "MOD_PAGE_EVENT_POSTS_FAILED",
				o = "MOD_PAGE_EVENT_POSTS_PENDING",
				i = "MOD_PAGE_EVENT_POSTS_MORE_LOADED",
				a = "START_EVENT_NOW_SUCCESS",
				d = "EDIT_EVENT_TIME_SUCCESS"
		},
		"./src/reddit/actions/eventPosts/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "fetchEventPostsPending", (function() {
				return E
			})), n.d(t, "fetchEventPostsSuccess", (function() {
				return O
			})), n.d(t, "fetchEventPostsFailure", (function() {
				return C
			})), n.d(t, "fetchMoreEventPostsSuccess", (function() {
				return A
			})), n.d(t, "eventPostsRequested", (function() {
				return y
			})), n.d(t, "startEventNowSuccess", (function() {
				return j
			})), n.d(t, "startEventNowRequested", (function() {
				return I
			})), n.d(t, "editEventTimeSuccess", (function() {
				return k
			})), n.d(t, "editEventTimeRequested", (function() {
				return _
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/eventPosts/constants.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/EventPostsBySubredditName.json");
			var l = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/omitHeaders/index.ts"),
				m = n("./src/reddit/constants/headers.ts");
			var p = (e, t, n, s, o) => Object(l.a)(Object(u.a)(e, [m.a]), {
				endpoint: `${e.apiUrl}/api/event_post_time.json`,
				method: r.ob.POST,
				data: {
					id: t,
					event_start: n,
					event_end: s,
					event_tz: o
				}
			});
			var b = (e, t) => Object(l.a)(Object(u.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/start_event_post.json`,
					method: r.ob.POST,
					data: {
						id: t
					}
				}),
				f = n("./src/reddit/helpers/graphql/normalizePostsFromGql/index.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				g = n("./src/reddit/selectors/eventPosts.ts"),
				v = n("./src/reddit/selectors/posts.ts");
			const x = () => s.fbt._("Something went wrong. Just don't panic.", null, {
					hk: "4onxm1"
				}),
				E = Object(o.a)(i.e),
				O = Object(o.a)(i.c),
				C = Object(o.a)(i.b),
				A = Object(o.a)(i.d),
				y = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s, o = n();
					const i = Object(g.d)(o, {
							subredditName: e
						}),
						l = Object(g.b)(o, {
							subredditName: e
						}),
						u = Object(g.c)(o, {
							subredditName: e
						}),
						m = Object(g.a)(o, {
							subredditName: e
						}),
						p = l && u;
					if (i) return;
					const b = {
						name: e,
						pageSize: 25,
						nonInclusiveCursor: null
					};
					if (p) b.nonInclusiveCursor = m;
					else if (l && !u) return;
					const v = Object(g.e)(o, {
						subredditName: e
					});
					t(E({
						key: v
					}));
					const y = await ((e, t) => Object(d.a)(e, {
						...c,
						variables: t
					}))(r(), b);
					if (y.ok) {
						const {
							subredditInfoByName: e
						} = y.body.data, {
							eventPosts: s
						} = e, r = Object(f.a)(s);
						let i = [],
							a = {};
						const d = s.pageInfo || {
							hasNextPage: !1,
							endCursor: null,
							hasPreviousPage: !1,
							startCursor: null
						};
						r.length > 0 && (i = r.map(e => e.id), a = r.reduce((e, t) => (e[t.id] = t, e), {})), o = n(), t((p ? A : O)({
							key: v,
							postIds: i,
							meta: o.meta,
							posts: a,
							pageInfo: d
						}))
					} else t(C({
						error: y.error,
						key: v
					})), t(Object(a.f)({
						kind: h.b.Error,
						text: x()
					}))
				}, j = Object(o.a)(i.f), I = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					if ((await b(o(), e)).ok) {
						const r = () => s.fbt._("Following event has started successfully: {title}", [s.fbt._param("title", d)], {
							hk: "e9iz9"
						});
						t(j({
							postId: e
						}));
						const o = n(),
							i = Object(v.F)(o, {
								postId: e
							}),
							d = i && i.title || "";
						t(Object(a.f)({
							kind: h.b.SuccessMod,
							text: r()
						}))
					} else t(Object(a.f)({
						kind: h.b.Error,
						text: x()
					}))
				}, k = Object(o.a)(i.a), _ = (e, t) => async (n, o, i) => {
					let {
						apiContext: d
					} = i;
					const c = await p(d(), e, t.startDate, t.endDate, t.timezoneName);
					if (c.ok) {
						const t = c.body,
							i = 14400,
							d = Math.round(t.event_start / r.Xb);
						let l = t.event_end;
						const u = {
							eventStart: d,
							eventEnd: l = l && Math.round(l / r.Xb) || d + i,
							eventIsLive: t.event_is_live
						};
						n(k({
							postId: e,
							eventInfo: u
						}));
						const m = o(),
							p = Object(v.F)(m, {
								postId: e
							}),
							b = p && p.title || "",
							f = () => s.fbt._("Following event time is updated successfully: {title}", [s.fbt._param("title", b)], {
								hk: "1m1w1c"
							});
						n(Object(a.f)({
							kind: h.b.SuccessMod,
							text: f()
						}))
					} else n(Object(a.f)({
						kind: h.b.Error,
						text: x()
					}))
				}
		},
		"./src/reddit/actions/externalAccount.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return E
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "j", (function() {
				return C
			})), n.d(t, "i", (function() {
				return A
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "g", (function() {
				return j
			})), n.d(t, "o", (function() {
				return P
			})), n.d(t, "p", (function() {
				return N
			})), n.d(t, "b", (function() {
				return D
			})), n.d(t, "c", (function() {
				return M
			})), n.d(t, "a", (function() {
				return R
			})), n.d(t, "n", (function() {
				return U
			})), n.d(t, "e", (function() {
				return H
			})), n.d(t, "f", (function() {
				return G
			})), n.d(t, "d", (function() {
				return Q
			})), n.d(t, "m", (function() {
				return V
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/addQueryParams/index.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/constants/parameters.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				m = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const p = e => {
				return e.reduce((e, t) => (e[t.provider] = t, e), {})
			};
			var b = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/models/User/index.ts"),
				h = n("./src/reddit/selectors/externalAccount.ts"),
				g = n("./src/reddit/selectors/platform.ts"),
				v = n("./src/reddit/selectors/subreddit.ts"),
				x = n("./src/reddit/selectors/user.ts");
			const E = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				O = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				C = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				A = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				y = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				j = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				I = Object(r.a)(E),
				k = Object(r.a)(O),
				_ = Object(r.a)(C),
				S = Object(r.a)(A),
				w = Object(r.a)(y),
				T = Object(r.a)(j),
				P = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						i = Object(x.m)(o),
						a = e || i && Object(f.e)(i);
					if (!a) return;
					if (Object(h.d)(o, {
							username: a
						})) return;
					t(I(a));
					const b = await ((e, t) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: Object(m.a)(`${e.apiUrl}/api/v1/external_account/user/${t}.json`),
						traceRequestName: "get_external_accounts",
						method: d.ob.GET
					}))(r(), a);
					if (b.ok) {
						const e = p(b.body);
						t(k({
							username: a,
							accountsData: e
						}))
					} else t(_(b.error))
				}, N = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = t(),
						o = Object(g.d)(r);
					if (!o) return;
					const i = r.externalAccount.api.subreddit.fetched[o],
						a = r.externalAccount.api.subreddit.pending[o];
					if (i || a) return;
					const b = Object(v.z)(r, {
						subredditName: o
					});
					if (!(b && b.hasExternalAccount)) return;
					e(S(o));
					const f = await ((e, t) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: Object(m.a)(`${e.apiUrl}/api/v1/external_account/subreddit/${t}.json`),
						method: d.ob.GET
					}))(s(), o);
					if (f.ok) {
						const t = p(f.body);
						e(w({
							subredditName: o,
							accountsData: t
						}))
					} else e(T(f.error))
				}, D = "EXTERNAL_ACCOUNT_DISCONNECT_PENDING", M = "EXTERNAL_ACCOUNT_DISCONNECT_SUCCESS", R = "EXTERNAL_ACCOUNT_DISCONNECT_FAILED", L = Object(r.a)(D), B = Object(r.a)(M), F = Object(r.a)(R), U = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t(L({
						provider: e
					}));
					const o = Object(x.m)(n()),
						i = Object(f.e)(o),
						a = await ((e, t) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: Object(m.a)(`${e.apiUrl}/api/v1/external_account/${t}/disconnect.json`),
							method: d.ob.POST
						}))(r(), e);
					a.ok ? t(B({
						provider: e,
						username: i
					})) : t(F({
						provider: e,
						error: a.error
					}))
				}, H = "OAUTH_FLOW_URL_PENDING", G = "OAUTH_FLOW_URL_SUCCESS", Q = "OAUTH_FLOW_URL_FAILED", q = Object(r.a)(H), W = Object(r.a)(G), z = Object(r.a)(Q), V = e => async (t, n, r) => {
					let {
						apiContext: p
					} = r;
					t(q({
						provider: e
					}));
					const f = Object(o.a)(window.location.href, {
							[a.e]: e
						}),
						h = await ((e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: Object(m.a)(`${e.apiUrl}/api/v1/external_account/${t}/connect.json`),
							method: d.ob.POST,
							data: {
								redirect_url: n
							}
						}))(p(), e, f);
					if (h.ok) {
						const {
							redirect_url: n
						} = h.body;
						t(W({
							provider: e
						})), window.location.href = n
					} else t(z({
						provider: e,
						error: h.error
					})), t(Object(i.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "196FiB"
						})
					}))
				}
		},
		"./src/reddit/actions/gold/achievementFlairs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				d = n("./src/redditGQL/operations/SubredditAchievementFlairs.json");
			const c = (e, t) => Object(a.a)(e, {
				...d,
				variables: {
					subredditId: t
				}
			}, {
				traceRequestName: "subreddit_achievement_flairs"
			});
			var l = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/gold/powerups/flairs.ts"),
				m = n("./src/reddit/actions/gold/constants.ts");
			const p = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, r, i) => {
						let {
							gqlContext: a
						} = i;
						const d = r();
						if (!(null != Object(u.c)(d, {
								subredditId: e
							})) || t.forceLoad) {
							n(h());
							try {
								const t = await c(a(), e);
								if (!t.ok) return;
								const {
									errors: s,
									data: r
								} = t.body;
								if (null == s ? void 0 : s.length) return void(await n(x(s[0].message)));
								const o = b(r.subredditInfoById);
								f(n, e, o)
							} catch (l) {
								o.c.captureException(l), await n(x(s.fbt._("Something went wrong", null, {
									hk: "1IJNeH"
								})))
							}
						}
					}
				},
				b = e => {
					const {
						achievementFlairsStatus: t = {
							isEnabled: !1
						},
						subredditAchievementFlairs: n = []
					} = e || {};
					return {
						achievementFlairsStatus: t,
						subredditAchievementFlairs: n
					}
				},
				f = (e, t, n) => e(g({
					subredditId: t,
					...n
				})),
				h = Object(r.a)(m.hb),
				g = Object(r.a)(m.gb),
				v = Object(r.a)(m.fb),
				x = e => async t => {
					await t(v(e)), t(Object(i.f)({
						kind: l.b.Error,
						duration: i.a,
						text: e
					}))
				}
		},
		"./src/reddit/actions/gold/communityAwards/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "h", (function() {
				return b
			}));
			var s = n("./src/lib/loadableAction/index.ts");
			const r = e => () => n.e("CommunityAwards").then(n.bind(null, "./src/reddit/actions/gold/communityAwards/communityAwards.ts")).then(t => t[e]),
				o = Object(s.a)(r("awardSheetInfoRequested")),
				i = Object(s.a)(r("manageableAwardsRequested")),
				a = Object(s.a)(r("createCommunityAward")),
				d = Object(s.a)(r("createGlobalAward")),
				c = Object(s.a)(r("createModAward")),
				l = Object(s.a)(r("createAwardFailed")),
				u = Object(s.a)(r("createAwardSuccessful")),
				m = Object(s.a)(r("removeCommunityAward")),
				p = Object(s.a)(r("disableAwardinCommunity")),
				b = Object(s.a)(r("enableAwardinCommunity"))
		},
		"./src/reddit/actions/gold/customEmojis.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = n("./src/reddit/actions/gold/constants.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/SubredditCustomEmojis.json");
			const l = (e, t) => Object(d.a)(e, {
				...c,
				variables: {
					subredditId: t
				}
			}, {
				traceRequestName: "subreddit_custom_emojis"
			});
			var u = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/reddit/selectors/gold/powerups/index.ts");
			const p = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, r, i) => {
						let {
							gqlContext: a
						} = i;
						const d = r();
						if (!(null != Object(m.a)(d, {
								subredditId: e
							})) || t.forceLoad) {
							n(h());
							try {
								const t = await l(a(), e);
								if (!t.ok) return;
								const {
									errors: s,
									data: r
								} = t.body;
								if (null == s ? void 0 : s.length) return void(await n(x(s[0].message)));
								const o = b(r.subredditInfoById);
								f(n, e, o)
							} catch (c) {
								o.c.captureException(c), await n(x(s.fbt._("Something went wrong", null, {
									hk: "1IJNeH"
								})))
							}
						}
					}
				},
				b = e => {
					const {
						customEmojisStatus: t = {
							isEnabled: !1
						},
						customEmojis: n = {}
					} = e || {};
					return {
						customEmojisStatus: t,
						customEmojis: n
					}
				},
				f = (e, t, n) => e(g({
					subredditId: t,
					...n
				})),
				h = Object(r.a)(i.kb),
				g = Object(r.a)(i.jb),
				v = Object(r.a)(i.ib),
				x = e => async t => {
					await t(v(e)), t(Object(a.f)({
						kind: u.b.Error,
						duration: a.a,
						text: e
					}))
				}
		},
		"./src/reddit/actions/gold/modals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return h
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "c", (function() {
				return C
			})), n.d(t, "a", (function() {
				return A
			})), n.d(t, "f", (function() {
				return y
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/postParentMessage/index.ts"),
				o = n("./src/reddit/helpers/isPost.ts"),
				i = n("./src/reddit/constants/modals.ts"),
				a = n("./src/reddit/selectors/gild.ts"),
				d = n("./src/reddit/helpers/correlationIdTracker.ts"),
				c = n("./src/reddit/actions/gold/communityAwards/index.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/selectors/communityAwards.ts"),
				m = n("./src/reddit/selectors/posts.ts"),
				p = n("./src/reddit/selectors/subreddit.ts"),
				b = n("./src/telemetry/index.ts"),
				f = n("./src/reddit/actions/gold/constants.ts");
			const h = Object(s.a)(f.J),
				g = Object(s.a)(f.f),
				v = () => async (e, t) => {
					const s = t();
					e(g()), Object(d.b)(d.a.GiftPremiumFlow);
					const {
						clickCloseModalEvent: r
					} = await n.e("givePremiumTrackers").then(n.bind(null, "./src/reddit/helpers/trackers/givePremium.ts"));
					Object(b.a)(r()(s))
				}, x = Object(s.a)(f.I), E = e => {
					let {
						awardId: t,
						correlationId: n,
						thingId: s
					} = e;
					return async (e, r) => {
						const a = r(),
							d = t ? Object(u.a)(a, t) : void 0;
						e(x({
							award: d && d.isEnabled ? d : void 0,
							thingId: s,
							correlationId: n
						})), e(Object(l.h)(i.a.GOLD_GILD_MODAL));
						const b = Object(p.O)(a, {
							thingId: s
						});
						let f = null;
						if (b) f = b.id;
						else if (Object(o.a)(s)) {
							const e = Object(m.F)(a, {
								postId: s
							});
							e && (f = e.belongsTo.id)
						}
						f && Object(c.a)(f, s)
					}
				}, O = Object(s.a)(f.e), C = Object(s.a)(f.H), A = () => async (e, t) => {
					const s = t(),
						o = Object(a.d)(s);
					if (Object(a.g)(s)) {
						const e = "close.gild";
						Object(r.a)({
							type: e
						})
					}
					e(O()), e(Object(l.g)(i.a.GOLD_GILD_MODAL));
					const {
						clickCloseGildModalEvent: c
					} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
					Object(b.a)(c(o)(s)), Object(d.b)(d.a.GildingFlow)
				}, y = () => async () => {
					Object(r.a)({
						type: "login.gild"
					})
				}
		},
		"./src/reddit/actions/governance/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "n", (function() {
				return h
			})), n.d(t, "o", (function() {
				return g
			})), n.d(t, "p", (function() {
				return v
			})), n.d(t, "q", (function() {
				return x
			})), n.d(t, "r", (function() {
				return E
			})), n.d(t, "s", (function() {
				return O
			})), n.d(t, "t", (function() {
				return C
			})), n.d(t, "u", (function() {
				return A
			})), n.d(t, "v", (function() {
				return y
			})), n.d(t, "w", (function() {
				return j
			})), n.d(t, "x", (function() {
				return I
			}));
			const s = "GOVERNANCE__COMMUNITY_DETAILS_SUCCESS",
				r = "GOVERNANCE__NEW_SUBREDDIT_SUGGESTED",
				o = "GOVERNANCE__NEW_TOP_MOD_SUGGESTED",
				i = "GOVERNANCE__OPT_OUT_MODAL_OPENED",
				a = "POLL_VOTE_SUCCESS",
				d = "GOVERNANCE__PROPOSAL_CREATION_FAILURE",
				c = "GOVERNANCE__PROPOSAL_CREATION_PENDING",
				l = "GOVERNANCE__PROPOSAL_CREATION_SUCCESS",
				u = "GOVERNANCE__PROPOSAL_OPTION_VOTE_FAILURE",
				m = "GOVERNANCE__PROPOSAL_OPTION_VOTE_PENDING",
				p = "GOVERNANCE__PROPOSAL_OPTION_VOTE_SUCCESS",
				b = "GOVERNANCE__PUBLIC_WALLET_INFO_FAILURE",
				f = "GOVERNANCE__PUBLIC_WALLET_INFO_PENDING",
				h = "GOVERNANCE__PUBLIC_WALLET_INFO_SUCCESS",
				g = "GOVERNANCE__RELEASE_NOTES_MODAL_OPENED",
				v = "GOVERNANCE__RELEASE_NOTES_SUCCESS",
				x = "GOVERNANCE__TRANSFER_FAILURE",
				E = "GOVERNANCE__TRANSFER_MODAL_OPENED",
				O = "GOVERNANCE__TRANSFER_PENDING",
				C = "GOVERNANCE__TRANSFER_SUCCESS",
				A = "GOVERNANCE__WALLETS_FETCH_FAILURE",
				y = "GOVERNANCE__WALLETS_FETCH_PENDING",
				j = "GOVERNANCE__WALLETS_FETCH_SUCCESS",
				I = "GOVERNANCE__WALLET_REGISTRATION_MODAL_OPENED"
		},
		"./src/reddit/actions/governance/errorToast.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/actions/toaster.ts"),
				r = n("./src/reddit/helpers/governanceErrorText/index.ts"),
				o = n("./src/reddit/models/Toast/index.ts");

			function i(e, t) {
				e(Object(s.f)({
					duration: 5e3,
					kind: o.b.Error,
					text: Object(r.a)(t)
				}))
			}
		},
		"./src/reddit/actions/governance/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return E
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "c", (function() {
				return A
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "g", (function() {
				return D
			})), n.d(t, "d", (function() {
				return M
			})), n.d(t, "e", (function() {
				return R
			})), n.d(t, "h", (function() {
				return L
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/prettyPrintNumber/index.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				a = n("./src/reddit/actions/post.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/config.ts"),
				l = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/reddit/models/Poll/index.ts"),
				m = n("./src/redditGQL/operations/PollVote.json"),
				p = n("./src/reddit/endpoints/governance/requester.ts");
			var b = n("./src/reddit/endpoints/governance/wallet.ts"),
				f = n("./src/reddit/models/Toast/index.ts"),
				h = n("./src/reddit/models/Vote/index.ts"),
				g = n("./src/reddit/selectors/crypto/points.ts"),
				v = n("./src/reddit/actions/governance/constants.ts"),
				x = n("./src/reddit/actions/governance/errorToast.ts");
			const E = Object(r.a)(v.b),
				O = Object(r.a)(v.c),
				C = Object(r.a)(v.e),
				A = (Object(r.a)(v.f), Object(r.a)(v.g), Object(r.a)(v.h)),
				y = Object(r.a)(v.i),
				j = Object(r.a)(v.j),
				I = Object(r.a)(v.k),
				k = Object(r.a)(v.q),
				_ = Object(r.a)(v.r),
				S = Object(r.a)(v.s),
				w = Object(r.a)(v.t),
				T = Object(r.a)(v.u),
				P = Object(r.a)(v.v),
				N = Object(r.a)(v.w),
				D = Object(r.a)(v.x),
				M = (e, t) => async (n, s, r) => {
					let o, {
							apiContext: i,
							gqlContext: d
						} = r,
						b = s().polls.models[e];
					if (n(j({
							pollId: e
						})), (o = b.type === u.a.GA ? await ((e, t, n) => Object(l.a)(e, {
								...m,
								variables: {
									input: {
										postId: t,
										optionId: n
									}
								}
							}))(d(), e, t) : await
							function(e, t, n, s) {
								return Object(p.a)(e, {
									method: "put",
									endpoint: `${c.a.metaUrl}/polls/${t}/${n}/votes/me/${s}`
								})
							}(i(), b.subredditId, e, t)).ok) {
						if (b.type === u.a.GA) {
							const {
								options: e
							} = o.body.data.updatePostPollVoteState.poll;
							n(C({
								pollId: b.id,
								optionId: t,
								options: e
							}))
						} else n(I(o.body));
						const r = s();
						if ((b = r.polls.models[e]) && Object(u.d)(b)) {
							const {
								postId: e
							} = b, t = r.posts.models[e];
							t && t.voteState === h.a.notVoted && n(Object(a.ib)(e))
						}
					} else n(y({
						pollId: e,
						error: o.error || o.errors[0].message
					})), Object(x.a)(n, o.error || o.errors[0].messsage)
				}, R = (e, t) => async (n, r, a) => {
					let {
						apiContext: l
					} = a;
					var u;
					n(S());
					const m = r().transfers.communityPoints.contentId || void 0,
						b = await
					function(e, t) {
						return Object(p.a)(e, {
							data: {
								amount: t.amount,
								contentId: t.contentId,
								description: t.message,
								receiveUserName: t.recipient
							},
							endpoint: `${c.a.metaUrl}/wallets/me/${t.subredditId}/transfers`,
							method: "post"
						})
					}(l(), {
						...e,
						contentId: m
					});
					b.ok ? (n(w({
						...b.body,
						subredditId: e.subredditId
					})), n(Object(d.f)({
						kind: f.b.SuccessCommunity,
						text: s.fbt._("Success! You just transferred {amount} {tokenName} to {recipient}", [s.fbt._param("amount", Object(o.a)(e.amount)), s.fbt._param("tokenName", (null === (u = Object(g.b)(r(), e.subredditId)) || void 0 === u ? void 0 : u.name) || ""), s.fbt._param("recipient", e.recipient)], {
							hk: "3klrhq"
						})
					})), t && n(Object(i.f)())) : (n(k({
						error: b.error
					})), Object(x.a)(n, b.error))
				}, L = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t(P());
					const o = await Object(b.a)(r(), e);
					o.ok ? t(N(o.body)) : t(T({
						error: o.error
					}))
				}
		},
		"./src/reddit/actions/grantUserFlair/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return s
			})), n.d(t, "g", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "l", (function() {
				return i
			})), n.d(t, "k", (function() {
				return a
			})), n.d(t, "j", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			}));
			const s = "SUBREDDIT__FLAIRED_USERS_PENDING",
				r = "SUBREDDIT__FLAIRED_USERS_LOADED",
				o = "SUBREDDIT__FLAIRED_USERS_FAILED",
				i = "SUBREDDIT__FLAIRED_USERS_SEARCH_PENDING",
				a = "SUBREDDIT__FLAIRED_USERS_SEARCH_LOADED",
				d = "SUBREDDIT__FLAIRED_USERS_SEARCH_FAILED",
				c = "SUBREDDIT__FLAIRED_USERS_OWNFLAIR_CHANGED",
				l = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_ADDED",
				u = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_CHANGED",
				m = "SUBREDDIT__FLAIRED_USERS_DELETE_PENDING",
				p = "SUBREDDIT__FLAIRED_USERS_DELETE_COMPLETED",
				b = "SUBREDDIT__FLAIRED_USERS_DELETE_FAILED"
		},
		"./src/reddit/actions/grantUserFlair/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return C
			})), n.d(t, "d", (function() {
				return I
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "c", (function() {
				return D
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/redditGQL/operations/SubredditFlairedRedditorByName.json"),
				a = n("./src/redditGQL/operations/SubredditFlairedRedditors.json");
			var d = n("./src/reddit/endpoints/flair/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/helpers/flair.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts");
			var m = e => {
				const {
					subreddit: t,
					redditorInfoByName: n
				} = e.data, {
					id: s,
					flairedRedditorByName: r
				} = t, o = {};
				let i = null;
				if (!n) return {
					subredditId: s,
					searchResult: i,
					flairedUsers: o
				};
				const {
					name: a
				} = n;
				if (i = a, r) {
					const {
						flair: e,
						redditor: t
					} = r, {
						name: n
					} = t;
					e && (o[n] = Object(u.a)(e)[0])
				}
				return {
					subredditId: s,
					searchResult: i,
					flairedUsers: o
				}
			};
			var p = e => {
					const {
						subreddit: t
					} = e.data, {
						id: n,
						flairedRedditors: s
					} = t, {
						pageInfo: r,
						edges: o
					} = s, i = [], a = {};
					return o.forEach(e => {
						const {
							node: t
						} = e, {
							flair: n,
							redditor: {
								name: s
							}
						} = t;
						if (i.push(s), n) {
							const e = Object(u.a)(n)[0];
							a[s] = e
						}
					}), {
						subredditId: n,
						flairedUsers: a,
						userOrder: i,
						pageInfo: r
					}
				},
				b = n("./src/reddit/models/SubredditModeration/index.ts"),
				f = n("./src/reddit/models/Toast/index.ts"),
				h = n("./src/reddit/models/User/index.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				v = n("./src/reddit/actions/grantUserFlair/constants.ts");
			const x = Object(r.a)(v.i),
				E = Object(r.a)(v.g),
				O = Object(r.a)(v.f),
				C = (e, t) => async (n, r, i) => {
					let {
						gqlContext: d
					} = i;
					const l = t && t.after || "",
						u = t && t.before || "",
						m = Object(g.I)(r(), e),
						h = Object(b.e)(m, l, u);
					if (!!r().pages.modHub.flairedUsers.userOrder[h]) return;
					n(x());
					const v = await ((e, t, n) => Object(o.a)(e, {
						...a,
						variables: {
							subredditName: t,
							...n
						}
					}))(d(), e, t);
					if (v.ok) {
						const e = {
							...p(v.body),
							key: h
						};
						n(E(e))
					} else {
						const e = v.error;
						n(O(e)), n(Object(c.f)({
							kind: f.b.Error,
							text: s.fbt._("Something went wrong", null, {
								hk: "1IJNeH"
							})
						}))
					}
				}, A = Object(r.a)(v.l), y = Object(r.a)(v.k), j = Object(r.a)(v.j), I = (e, t) => async (n, r, a) => {
					let {
						gqlContext: d
					} = a;
					const l = Object(g.X)(r(), {
						subredditId: e
					}).name;
					n(A());
					const u = await ((e, t, n) => Object(o.a)(e, {
						...i,
						variables: {
							subredditName: t,
							name: n
						}
					}))(d(), l, t);
					if (u.ok) {
						const e = m(u.body);
						n(y(e))
					} else n(j(u.error)), n(Object(c.f)({
						kind: f.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						})
					}))
				}, k = Object(r.a)(v.e), _ = Object(r.a)(v.c), S = Object(r.a)(v.d), w = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = r(),
						l = Object(g.X)(a, {
							subredditId: t
						}).name;
					n(k());
					const u = await Object(d.a)(i(), e, l);
					if (u.ok) {
						n(_({
							userName: e,
							subredditId: t
						}));
						const r = Object(c.e)(s.fbt._("User flair cleared", null, {
							hk: "4yyH00"
						}), f.b.SuccessMod);
						n(Object(c.f)(r))
					} else {
						n(S());
						const r = Object(c.e)(s.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "uG2KO"
						}), f.b.Error, s.fbt._("Retry", null, {
							hk: "3oiY99"
						}), w(e, t));
						n(Object(c.f)(r))
					}
					return u.ok || u.error
				}, T = Object(r.a)(v.h), P = Object(r.a)(v.b), N = Object(r.a)(v.a), D = (e, t, n) => async (r, o, i) => {
					let {
						apiContext: a
					} = i;
					const u = o(),
						m = u.pages.modHub.flairedUsers.search.result === e && !u.pages.modHub.flairedUsers.models[e],
						p = {
							userName: e,
							subredditId: t,
							applied: n
						},
						b = n && n.templateId,
						v = Object(g.X)(u, {
							subredditId: t
						}),
						x = n && Object(l.g)(n),
						E = n ? n.cssClass : void 0,
						O = await Object(d.h)(a(), e, v.name, b, x, E);
					if (O.ok) {
						if (m) {
							let e;
							Object.keys(u.pages.modHub.flairedUsers.userOrder).forEach(t => {
								!1 === u.pages.modHub.flairedUsers.pageInfo[t].hasNextPage && u.pages.modHub.flairedUsers.userOrder[t].length < 50 && (e = t)
							});
							const t = {
								...p,
								key: e
							};
							r(N(t))
						}
						e === (u.user.account && Object(h.e)(u.user.account)) ? r(T(p)) : m || r(P(p))
					} else {
						const e = Object(c.e)(s.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "4hXQvr"
						}), f.b.Error);
						r(Object(c.f)(e))
					}
					return O.ok || O.error
				}
		},
		"./src/reddit/actions/inContextModeration.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "INCONTEXT__BANNED",
				o = "INCONTEXT__MUTED",
				i = Object(s.a)(r),
				a = Object(s.a)(o)
		},
		"./src/reddit/actions/inboxBanner/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = "INBOX_NOTIFICATIONS__BANNER_DISMISS",
				r = "INBOX_NOTIFICATIONS__BANNER_RECEIVED"
		},
		"./src/reddit/actions/inboxBanner/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/inboxBanner/constants.ts");
			const o = Object(s.a)(r.a),
				i = Object(s.a)(r.b)
		},
		"./src/reddit/actions/jsApi.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "JSAPI__CONSUMER_SUBSCRIBED",
				o = Object(s.a)(r)
		},
		"./src/reddit/actions/meta.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "h", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "k", (function() {
				return v
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "j", (function() {
				return C
			}));
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/index.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/selectors/runTimeEnvVars.ts"),
				l = n("./src/reddit/selectors/user.ts");
			const u = "META__GEO_CHANGED",
				m = Object(o.a)(u),
				p = "META__META_RECEIVED",
				b = (Object(o.a)(p), "META__SET_LOCALE"),
				f = Object(o.a)(b),
				h = e => async (t, n, o) => {
					let {
						apiContext: u
					} = o;
					if (!e) return;
					const m = n(),
						p = u();
					let b;
					if (t(f(e)), Object(s.isPseudoLocale)(e) ? (Object(l.P)(m) || Object(c.b)(m)) && (b = e) : b = Object(s.isoLocaleToR2Language)(e), !b) return;
					const h = new URL(window.location.href);
					Object(l.S)(m) ? Object(s.isPseudoLocale)(b) ? h.searchParams.set("locale", b) : (await Object(i.a)(Object(a.a)(p, [d.a]), {
						data: {
							lang: b
						},
						endpoint: `${p.apiUrl}/api/v1/me/prefs`,
						method: r.ob.PATCH,
						type: "json"
					}), h.searchParams.delete("locale")) : h.searchParams.delete("locale"), window.location.href = h.toString()
				}, g = "META__SET_POPULAR_GEO_FILTER", v = Object(o.a)(g), x = "META__PWA_ENTERED", E = "META__PWA_LEFT", O = Object(o.a)(x), C = Object(o.a)(E)
		},
		"./src/reddit/actions/modQueue/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return he
			})), n.d(t, "d", (function() {
				return xe
			})), n.d(t, "f", (function() {
				return Ae
			})), n.d(t, "a", (function() {
				return ye
			})), n.d(t, "b", (function() {
				return je
			})), n.d(t, "c", (function() {
				return Ie
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react-redux/es/index.js"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/bulkActions/index.ts"),
				d = n("./src/reddit/actions/removalReasons/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/postLayout.ts"),
				u = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				m = n("./src/reddit/endpoints/modQueue/index.ts"),
				p = n("./src/reddit/endpoints/user/index.ts"),
				b = n("./src/reddit/helpers/correlationIdTracker.ts"),
				f = n("./src/reddit/helpers/flair.ts"),
				h = n("./node_modules/Base64/base64.js"),
				g = n("./src/reddit/components/ModQueueList/PostSortDropdown.tsx"),
				v = n("./src/reddit/helpers/isPost.ts"),
				x = n("./src/reddit/selectors/commentSelector.ts"),
				E = n("./src/reddit/selectors/posts.ts"),
				O = n("./src/reddit/models/Flair/index.ts"),
				C = n("./src/redditGQL/types.ts"),
				A = n("./src/reddit/helpers/graphql/normalizeCommentFromGql/index.ts"),
				y = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				j = n("./src/reddit/helpers/graphql/normalizeModActivityFromGql/index.ts"),
				I = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				k = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts");
			const _ = {
					[o.wb.Edited]: C.H.Edited,
					[o.wb.Modqueue]: C.H.Mod,
					[o.wb.Reports]: C.H.Reported,
					[o.wb.Spam]: C.H.Removed,
					[o.wb.Unmoderated]: C.H.Unmoderated
				},
				S = {
					comments: C.F.Comment,
					links: C.F.Post,
					chat_comments: C.F.ChatComment
				};

			function w(e) {
				let {
					getState: t,
					queueType: n,
					options: s
				} = e;
				var r, i;
				const a = t();
				let d;
				s.only && (d = S[s.only]);
				const c = {};
				s.after && (c[s.sort === g.a.OldestFirst ? "before" : "after"] = function(e, t) {
					const n = Object(v.a)(t) ? Object(E.F)(e, {
						postId: t
					}) : Object(x.c)(e, {
						commentId: t
					});
					if (n) return Object(h.btoa)(`${n.id}|${n.created}`)
				}(a, s.after));
				const l = {};
				s.sort === g.a.OldestFirst ? l.last = 25 : l.first = 25;
				const u = s.subreddit ? [s.subreddit] : [],
					m = (null == a ? void 0 : a.platform) && (null === (r = null == a ? void 0 : a.platform) || void 0 === r ? void 0 : r.currentPage),
					p = (null === (i = null == m ? void 0 : m.meta) || void 0 === i ? void 0 : i.name) === o.Tb.MODQUEUE_PAGES;
				return {
					queueType: _[n],
					moderatedAfter: s.moderatedAfter,
					...l,
					...!!d && {
						itemTypes: d
					},
					subredditNames: u,
					...!!s.profile && {
						subredditIds: [s.profile]
					},
					sort: s.sort === g.a.MostReportedFirst ? C.G.SortReports : C.G.SortDate,
					...c,
					includeAllModActivitySummaries: p,
					includeModActivitySummariesByNames: !p,
					isModqueueListing: 0 === u.length,
					includeDevPlatformMetadata: !!s.includeDevPlatformMetadata
				}
			}
			var T;
			! function(e) {
				e.Comment = "ModQueueItemComment", e.Post = "ModQueueItemPost", e.ChatComment = "ModQueueItemChatComment"
			}(T || (T = {}));
			const P = e => ({
					access: (null == e ? void 0 : e.isAccessEnabled) || !1,
					all: (null == e ? void 0 : e.isAllAllowed) || !1,
					chatConfig: (null == e ? void 0 : e.isChatConfigEditingAllowed) || !1,
					chatOperator: (null == e ? void 0 : e.isChatOperator) || !1,
					communityChat: !1,
					channels: !1,
					config: (null == e ? void 0 : e.isConfigEditingAllowed) || !1,
					flair: (null == e ? void 0 : e.isFlairEditingAllowed) || !1,
					mail: (null == e ? void 0 : e.isMailEditingAllowed) || !1,
					posts: (null == e ? void 0 : e.isPostEditingAllowed) || !1,
					wiki: (null == e ? void 0 : e.isWikiEditingAllowed) || !1
				}),
				N = e => {
					let {
						id: t,
						icon: n,
						profile: s,
						snoovatarIcon: r,
						isAcceptingFollowers: o,
						displayName: i,
						prefixedName: a,
						name: d
					} = e;
					return {
						accountIcon: null == n ? void 0 : n.url,
						displayName: i,
						displayNamePrefixed: a,
						displayText: d,
						enableFollowers: o,
						id: t,
						profileId: null == s ? void 0 : s.id,
						snoovatarFullBodyAsset: (null == r ? void 0 : r.url) || null,
						username: d
					}
				};

			function D(e) {
				let {
					modQueueItems: t,
					identity: n,
					moderatedSubredditActivityByNames: s
				} = e;
				var r, o, i, a, d;
				const c = {
					posts: {},
					comments: {},
					reports: {},
					modActivitySummaries: {},
					modqueue: [],
					authorFlair: {},
					moderatedAfter: (null === (r = null == n ? void 0 : n.redditor.moderatedSubreddits) || void 0 === r ? void 0 : r.pageInfo.hasNextPage) ? null === (o = null == n ? void 0 : n.redditor.moderatedSubreddits) || void 0 === o ? void 0 : o.pageInfo.endCursor : null,
					moderatingProfiles: {},
					profiles: {},
					listingOrder: [],
					subreddits: {},
					moderatingSubreddits: {},
					postFlair: {},
					userFlair: {},
					users: {}
				};
				if (!t) return c;
				if (!t.edges) return c;
				const l = null === (i = null == n ? void 0 : n.redditor.moderatedSubredditActivity) || void 0 === i ? void 0 : i.edges.reduce((e, t) => {
						var n;
						if (!(null === (n = null == t ? void 0 : t.node) || void 0 === n ? void 0 : n.moderation)) return e;
						const {
							subreddit: s,
							summary: r
						} = Object(j.a)(t.node);
						return e.summaries[t.node.id] = r, e.subreddits[t.node.id] = s, e
					}, {
						subreddits: {},
						summaries: {}
					}),
					u = null == s ? void 0 : s.reduce((e, t) => {
						if (!(t && "modPermissions" in t && (null == t ? void 0 : t.modPermissions))) return e;
						if (e.moderatingSubreddits[t.id] = P(t.modPermissions), !(null == t ? void 0 : t.moderation)) return e;
						const {
							subreddit: n,
							summary: s
						} = Object(j.a)(t);
						return e.summaries[t.id] = s, e.subreddits[t.id] = n, e
					}, {
						subreddits: {},
						summaries: {},
						moderatingSubreddits: {}
					});
				c.modActivitySummaries = {
					...null == l ? void 0 : l.summaries,
					...null == u ? void 0 : u.summaries
				};
				const m = null === (d = null === (a = null == n ? void 0 : n.redditor.moderatedSubreddits) || void 0 === a ? void 0 : a.edges) || void 0 === d ? void 0 : d.reduce((e, t) => {
					var n;
					if (!(null === (n = null == t ? void 0 : t.node) || void 0 === n ? void 0 : n.modPermissions)) return e;
					const s = t.node.modPermissions;
					return e.moderatingSubreddits[t.node.id] = P(s), e.subreddits[t.node.id] = Object(k.a)(t.node), e
				}, {
					subreddits: {},
					moderatingSubreddits: {}
				});
				return c.moderatingSubreddits = {
					...null == m ? void 0 : m.moderatingSubreddits,
					...null == u ? void 0 : u.moderatingSubreddits
				}, c.subreddits = {
					...null == l ? void 0 : l.subreddits,
					...null == m ? void 0 : m.subreddits
				}, t.edges.forEach(e => {
					var t, n, s, r, o, i, a;
					if (!e) return;
					const {
						node: d
					} = e;
					if (!d) return;
					const {
						__typename: l,
						subredditInfo: u
					} = d;
					if (!u) return;
					const {
						id: m
					} = u;
					if (c.subreddits[m] = Object(k.a)(u), c.moderatingSubreddits[m] || "Subreddit" !== (null == u ? void 0 : u.__typename) || (c.moderatingSubreddits[m] = P(u.modPermissions)), !c.postFlair[m] && "Subreddit" === u.__typename) {
						const {
							position: e,
							isEnabled: n
						} = (null == u ? void 0 : u.postFlairSettings) || {};
						c.postFlair[m] = {
							displaySettings: {
								position: null == e ? void 0 : e.toLowerCase(),
								isEnabled: n
							},
							...(null === (t = null == u ? void 0 : u.postFlairTemplates) || void 0 === t ? void 0 : t.reduce((e, t) => {
								let {
									id: n,
									text: s,
									isEditable: r,
									richtext: o,
									type: i,
									textColor: a,
									backgroundColor: d,
									isModOnly: c,
									cssClass: l,
									maxEmojis: u,
									allowableContent: m
								} = t;
								return n ? (e.templateIds.push(n), e.templates[n] = {
									id: n,
									text: s || "",
									textEditable: r,
									type: i || O.f.Text,
									textColor: (null == a ? void 0 : a.toLowerCase()) || void 0,
									backgroundColor: (null == d ? void 0 : d.toLowerCase()) || void 0,
									richtext: JSON.parse(o || "[]"),
									modOnly: c,
									cssClass: l,
									maxEmojis: u,
									allowableContent: null == m ? void 0 : m.toLowerCase()
								}, e) : e
							}, {
								templates: {},
								templateIds: []
							})) || {}
						}
					}
					if (l === T.Comment || l === T.ChatComment) {
						const {
							commentInfo: e
						} = d;
						if (!e) return;
						const t = Object(A.a)(e);
						if (null === (n = e.moderationInfo) || void 0 === n ? void 0 : n.verdictBy) {
							const t = N(null === (s = e.moderationInfo) || void 0 === s ? void 0 : s.verdictBy);
							t.username && (c.users[null == t ? void 0 : t.username] = t)
						}
						c.comments[t.id] = t, c.listingOrder.push({
							id: t.id,
							type: "comment"
						}), c.modqueue.push(t.id);
						const {
							authorInfo: o,
							authorFlair: i
						} = e, a = i ? null === (r = Object(y.a)(i)) || void 0 === r ? void 0 : r[0] : null;
						c.authorFlair[m] = {
							...c.authorFlair[m],
							...(null == o ? void 0 : o.name) ? {
								[null == o ? void 0 : o.name]: a
							} : {}
						};
						const l = [];
						t.modReports.forEach(e => {
							l.push({
								type: "moderator",
								reason: e[0],
								reporter: e[1]
							})
						}), t.userReports.forEach(e => {
							l.push({
								type: "user",
								reason: e[0]
							})
						}), c.reports[t.id] = l
					}
					if (l === T.Post) {
						const {
							postInfo: e
						} = d;
						if (null === (o = null == e ? void 0 : e.moderationInfo) || void 0 === o ? void 0 : o.verdictBy) {
							const t = N(null === (i = e.moderationInfo) || void 0 === i ? void 0 : i.verdictBy);
							t.username && (c.users[null == t ? void 0 : t.username] = t)
						}
						if (!e) return;
						const t = Object(I.f)(e);
						c.posts[t.id] = t, c.listingOrder.push({
							id: t.id,
							type: "post"
						}), c.modqueue.push(t.id);
						const {
							authorInfo: n,
							authorFlair: s
						} = e, r = s ? null === (a = Object(y.a)(s)) || void 0 === a ? void 0 : a[0] : null;
						c.authorFlair[m] = {
							...c.authorFlair[m],
							...(null == n ? void 0 : n.name) ? {
								[null == n ? void 0 : n.name]: r
							} : {}
						};
						const l = [];
						t.modReports.forEach(e => {
							l.push({
								type: "moderator",
								reason: e[0],
								reporter: e[1]
							})
						}), t.userReports.forEach(e => {
							l.push({
								type: "user",
								reason: e[0]
							})
						}), c.reports[t.id] = l
					}
				}), c
			}
			var M = n("./src/reddit/models/ModQueue/index.ts"),
				R = n("./src/reddit/models/Toast/index.ts"),
				L = n("./src/reddit/selectors/experiments/devPlatform.ts"),
				B = n("./src/reddit/selectors/modQueue.ts"),
				F = n("./src/reddit/selectors/subreddit.ts"),
				U = n("./src/reddit/selectors/telemetry.ts"),
				H = n("./src/telemetry/index.ts"),
				G = n("./src/lib/initializeClient/installReducer.ts"),
				Q = n("./src/reddit/reducers/features/modActivitySummaries/index.ts"),
				q = n("./node_modules/redux/es/redux.js"),
				W = n("./node_modules/icepick/icepick.js"),
				z = n("./src/reddit/actions/modQueue/constants.ts");
			const V = {};
			var K = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : V,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case z.i:
					case z.f:
					case z.r:
					case z.u:
					case z.A: {
						const {
							response: n
						} = t.payload, {
							comments: s,
							posts: r
						} = n, o = {};
						return [...Object.values(s), ...Object.values(r)].forEach(e => {
							var t;
							const n = null === (t = e.previousActions) || void 0 === t ? void 0 : t.actions;
							n && n.length && n.forEach(e => e.modAction ? o[e.modAction.id] = e.modAction : !!e.reportAction && (o[e.reportAction.id] = e.reportAction))
						}), Object(W.merge)(e, o)
					}
					case z.l: {
						const {
							summary: n
						} = t.payload, {
							mods: s
						} = n, r = {};
						return Object.values(s).forEach(e => {
							const {
								lastModAction: t,
								info: n
							} = e;
							t && t.id && (r[t.id] = {
								...t,
								__typename: "ModAction",
								moderatorInfo: n
							})
						}), Object(W.merge)(e, r)
					}
					default:
						return e
				}
			};
			const Y = {};
			var J = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Y,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case z.i:
						case z.f:
						case z.r:
						case z.u:
						case z.A: {
							const {
								response: n
							} = t.payload, {
								comments: s,
								posts: r
							} = n, o = [...Object.values(s), ...Object.values(r)].reduce((e, t) => {
								var n;
								const s = null === (n = t.previousActions) || void 0 === n ? void 0 : n.actions;
								return s && s.length && (e[t.id] = s.map(e => {
									var t, n;
									return (null === (t = e.modAction) || void 0 === t ? void 0 : t.id) || (null === (n = e.reportAction) || void 0 === n ? void 0 : n.id)
								}).filter(e => !!e).splice(0, 5)), e
							}, {});
							return Object(W.merge)(e, o)
						}
						case z.l: {
							const {
								summary: n
							} = t.payload, {
								mods: s
							} = n, r = {};
							return Object.values(s).forEach(t => {
								const {
									lastModAction: n
								} = t;
								n && n.id && n.target && (r[n.target.id] = [n.id, ...e[n.target.id] || []].splice(0, 5))
							}), Object(W.merge)(e, r)
						}
						default:
							return e
					}
				},
				X = Object(q.c)({
					models: K,
					order: J
				}),
				Z = n("./src/reddit/reducers/features/realtimeModqueue/index.ts"),
				$ = n("./src/reddit/reducers/pages/modHub/index.ts");
			Object(G.a)({
				pages: {
					modHub: $.a
				}
			}), Object(G.a)({
				features: {
					modActivitySummaries: Q.a
				}
			}), Object(G.a)({
				features: {
					modPreviousActions: X
				}
			}), Object(G.a)({
				features: {
					realtimeModqueue: Z.a
				}
			});
			const ee = Object(i.a)(z.k),
				te = Object(i.a)(z.j),
				ne = Object(i.a)(z.i),
				se = Object(i.a)(z.h),
				re = Object(i.a)(z.g),
				oe = Object(i.a)(z.f),
				ie = Object(i.a)(z.e),
				ae = Object(i.a)(z.s),
				de = Object(i.a)(z.r),
				ce = Object(i.a)(z.q),
				le = Object(i.a)(z.v),
				ue = Object(i.a)(z.u),
				me = Object(i.a)(z.t),
				pe = Object(i.a)(z.B),
				be = Object(i.a)(z.A),
				fe = Object(i.a)(z.z),
				he = (e, t, n) => async (r, i, a) => {
					let {
						apiContext: d,
						gqlContext: b
					} = a;
					var f;
					const h = Object(L.a)(i());
					let g, v, x;
					switch (t) {
						case o.wb.Edited:
							g = re, v = ie, x = oe;
							break;
						case o.wb.Modqueue:
							g = te, v = se, x = ne;
							break;
						case o.wb.Reports:
							g = ae, v = ce, x = de;
							break;
						case o.wb.Spam:
							g = le, v = me, x = ue;
							break;
						case o.wb.Unmoderated:
							g = pe, v = fe, x = be;
							break;
						default:
							throw new Error("Invalid modqueue requested")
					}
					if (r(g()), n.profile) {
						const e = null === (f = (await Object(p.b)(d(), n.profile)).body[n.profile]) || void 0 === f ? void 0 : f.profileId;
						n.profile = e
					}
					const E = w({
							getState: i,
							queueType: t,
							options: n
						}),
						O = await Object(m.b)(b(), {
							...E,
							includeDevPlatformMetadata: h
						});
					if (!O.ok) return r(v(O.error)), void r(Object(c.f)({
						kind: R.b.Error,
						text: s.fbt._("Oh no! Something went wrong!", null, {
							hk: "16O2Sk"
						})
					}));
					const {
						users: C,
						...A
					} = D(O.body.data), y = i(), j = l.e[Object(u.V)(y, {})] === l.d.Card;
					Object(B.b)(y, j) && r(ee(C)), r(x({
						listingKey: e,
						page: `${n.page||M.b}`,
						response: A
					}))
				}, ge = Object(i.a)(z.n), ve = Object(i.a)(z.b), xe = e => async (t, n, o) => {
					let {
						gqlContext: i
					} = o;
					const a = n(),
						d = Object(r.e)(e => Object(L.a)(e)),
						l = a.pages.modHub.modQueue.moderatedCommunitiesOrder.after,
						u = a.pages.modHub.modQueue.moderatedCommunitiesOrder.pending,
						p = a.pages.modHub.modQueue.moderatedCommunitiesOrder.loaded,
						{
							pageName: b
						} = a.platform.currentPage.urlParams;
					if (e && u || p || !l) return;
					const f = w({
							getState: n,
							queueType: b,
							options: {
								moderatedAfter: l,
								includeDevPlatformMetadata: d
							}
						}),
						h = await Object(m.b)(i(), f);
					if (!h.ok) return void t(Object(c.f)({
						kind: R.b.Error,
						text: s.fbt._("Oh no! Something went wrong!", null, {
							hk: "16O2Sk"
						})
					}));
					const g = D(h.body.data);
					t(ge(g)), g.moderatedAfter ? t(xe()) : t(ve())
				}, Ee = Object(i.a)(z.y), Oe = Object(i.a)(z.x), Ce = Object(i.a)(z.w), Ae = (e, t, n) => async (r, o, i) => {
					let {
						apiContext: l
					} = i;
					r(Object(a.c)());
					const u = o(),
						p = Object(B.i)(u),
						h = u.user.account && u.user.account.displayText;
					Object(b.d)(b.a.ModQueue);
					const g = Object(b.c)(b.a.ModQueue);
					Object(H.a)({
						source: "bulk_mod_action_menu",
						action: "click",
						noun: e,
						...U.p(u),
						actionInfo: U.d(u, {
							count: p.length,
							paneName: u.platform.currentPage ? u.platform.currentPage.urlParams.pageName : void 0
						}),
						screen: U.db(u),
						correlationId: g
					});
					for (let t = 0; t < p.length; t++) {
						const n = p[t];
						let s = e;
						[M.a.Approve, M.a.Remove, M.a.Spam].includes(e) && (Object(v.a)(n) ? s += "_link" : s += "_comment"), Object(H.a)({
							source: "bulk_mod_action",
							action: "click",
							noun: s,
							...U.p(u),
							actionInfo: U.d(u, {
								count: p.length,
								paneName: u.platform.currentPage ? u.platform.currentPage.urlParams.pageName : void 0
							}),
							comment: U.i({
								state: u,
								commentId: n
							}),
							post: U.L(u, n),
							profile: U.W(u, n),
							screen: U.db(u),
							subreddit: U.pb(u, n),
							correlationId: g
						})
					}
					Object(b.b)(b.a.ModQueue);
					const x = {
						ids: p
					};
					t && (x.text = Object(f.g)(t) || "", x.flairTemplateId = ""), n && (x.cssClass = n, x.flairTemplateId = n);
					const E = await Object(m.a)(l(), e, x);
					if (E.ok) {
						r(Object(a.b)({
							...E.body,
							operation: e,
							ids: p,
							username: h,
							options: {
								flair: t
							}
						}));
						const n = function(e, t) {
							switch (e) {
								case M.a.Approve:
									return s.fbt._({
										"*": "{number} posts/comments have been approved",
										_1: "1 post/comment has been approved"
									}, [s.fbt._plural(t, "number")], {
										hk: "2kKhSf"
									});
								case M.a.Flair:
									return s.fbt._({
										"*": "{number} posts/comments have had flair applied",
										_1: "1 post/comment has had flair applied"
									}, [s.fbt._plural(t, "number")], {
										hk: "3syB5O"
									});
								case M.a.IgnoreReports:
									return s.fbt._({
										"*": "{number} posts/comments have had their reports ignored",
										_1: "1 post/comment has had their reports ignored"
									}, [s.fbt._plural(t, "number")], {
										hk: "2WfE4g"
									});
								case M.a.Lock:
									return s.fbt._({
										"*": "{number} posts/comments have been locked",
										_1: "1 post/comment has been locked"
									}, [s.fbt._plural(t, "number")], {
										hk: "45oMbv"
									});
								case M.a.MarkNSFW:
									return s.fbt._({
										"*": "{number} posts/comments have been marked NSFW",
										_1: "1 post/comment has been marked NSFW"
									}, [s.fbt._plural(t, "number")], {
										hk: "oPsQr"
									});
								case M.a.RemovalReason:
									return s.fbt._({
										"*": "{number} posts/comments have had removal reasons applied",
										_1: "1 post/comment has had removal reasons applied"
									}, [s.fbt._plural(t, "number")], {
										hk: "35Tosn"
									});
								case M.a.Remove:
									return s.fbt._({
										"*": "{number} posts/comments have been removed",
										_1: "1 post/comment has been removed"
									}, [s.fbt._plural(t, "number")], {
										hk: "B1ZbE"
									});
								case M.a.Spam:
									return s.fbt._({
										"*": "{number} posts/comments have been marked as spam",
										_1: "1 post/comment has been marked as spam"
									}, [s.fbt._plural(t, "number")], {
										hk: "3OoNfp"
									});
								case M.a.Spoiler:
									return s.fbt._({
										"*": "{number} posts/comments have been marked as spoilers",
										_1: "1 post/comment has been marked as spoilers"
									}, [s.fbt._plural(t, "number")], {
										hk: "1DFW5M"
									});
								case M.a.UnignoreReports:
									return s.fbt._({
										"*": "{number} posts/comments have had their reports un-ignored",
										_1: "1 post/comment has had their reports un-ignored"
									}, [s.fbt._plural(t, "number")], {
										hk: "303Hpb"
									});
								case M.a.Unlock:
									return s.fbt._({
										"*": "{number} posts/comments have been unlocked",
										_1: "1 post/comment has been unlocked"
									}, [s.fbt._plural(t, "number")], {
										hk: "5gUht"
									});
								case M.a.UnmarkNSFW:
									return s.fbt._({
										"*": "{number} posts/comments have been un-marked as NSFW",
										_1: "1 post/comment has been un-marked as NSFW"
									}, [s.fbt._plural(t, "number")], {
										hk: "3oSSST"
									});
								case M.a.Unspoiler:
								case M.a.Unspoiler:
									return s.fbt._({
										"*": "{number} posts/comments have been un-marked as spoilers",
										_1: "1 post/comment has been un-marked as spoilers"
									}, [s.fbt._plural(t, "number")], {
										hk: "3lHoNI"
									})
							}
						}(e, p.length);
						if (e !== M.a.Approve && e !== M.a.Flair) {
							let t, o;
							const i = u.platform.currentPage && u.platform.currentPage.queryParams && u.platform.currentPage.queryParams.subreddit,
								l = i && Object(F.I)(u, i);
							e === M.a.Remove && l && p.length > 1 && (t = s.fbt._("Add a removal reason", null, {
								hk: "3gGDCl"
							}), o = Object(d.fetchReasonsAndOpenModal)(l, p));
							const b = Object(c.e)(n, R.b.Undo, s.fbt._("UNDO", null, {
								hk: "49SEAI"
							}), (() => async (e, t, n) => {
								let {
									apiContext: r
								} = n;
								e(Ee());
								const o = t(),
									i = Object.keys(o.pages.modHub.modQueue.bulkAction.undoLastAction)[0],
									d = o.pages.modHub.modQueue.bulkAction.undoLastAction[i],
									l = o.user.account && o.user.account.displayText;
								e(Object(a.c)());
								const u = await Object(m.a)(r(), i, {
									ids: d
								});
								u.ok ? e(Oe({
									...u.body,
									operation: i,
									ids: d,
									username: l
								})) : (e(Ce(u.error)), e(Object(c.f)({
									kind: R.b.Error,
									text: s.fbt._("Oh no! Something went wrong!", null, {
										hk: "16O2Sk"
									})
								})))
							})(), t, o);
							r(Object(c.f)(b))
						} else {
							const e = Object(c.e)(n, R.b.SuccessMod);
							r(Object(c.f)(e))
						}
					} else {
						r(Object(a.a)(E.error));
						const e = Object(c.e)(s.fbt._("Oh no! Something went wrong!", null, {
							hk: "16O2Sk"
						}), R.b.Error);
						r(Object(c.f)(e))
					}
				}, ye = Object(i.a)(z.a), je = Object(i.a)(z.c), Ie = Object(i.a)(z.d)
		},
		"./src/reddit/actions/modQueue/realtime.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return k
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "b", (function() {
				return D
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = (n("./src/redditGQL/operations/LastModActionInSubreddit.json"), n("./src/redditGQL/operations/ModActivitySummaryByID.json")),
				o = n("./src/redditGQL/operations/SingleCommentById.json"),
				i = n("./src/redditGQL/operations/SinglePostInfoById.json");
			var a = n("./src/lib/initializeClient/installReducer.ts"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/reddit/actions/comment/index.ts"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./src/reddit/actions/users.ts"),
				m = n("./src/reddit/endpoints/redditor/index.ts"),
				p = n("./src/reddit/helpers/graphql/normalizeCommentFromGql/index.ts"),
				b = n("./src/reddit/helpers/graphql/normalizeModActivityFromGql/index.ts"),
				f = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				h = n("./src/reddit/helpers/isPost.ts"),
				g = n("./src/reddit/reducers/features/modActivitySummaries/index.ts"),
				v = n("./src/reddit/reducers/features/realtimeModqueue/index.ts"),
				x = n("./src/reddit/actions/modQueue/constants.ts");
			var E = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case x.o:
							return t.payload;
						default:
							return e
					}
				},
				O = n("./src/reddit/reducers/pages/modHub/index.ts"),
				C = n("./src/reddit/selectors/modQueue.ts"),
				A = n("./src/reddit/selectors/user.ts"),
				y = n("./src/redditGQL/types.ts");
			Object(a.a)({
				pages: {
					modHub: O.a
				}
			}), Object(a.a)({
				features: {
					modActivitySummaries: g.a
				}
			}), Object(a.a)({
				features: {
					realtimeModqueue: v.a
				}
			}), Object(a.a)({
				features: {
					realtimeUpdateAnimationId: E
				}
			});
			const j = Object(d.a)(x.l),
				I = e => async (t, n, o) => {
					let {
						gqlContext: i
					} = o;
					const a = await ((e, t) => Object(s.a)(e, {
							...r,
							variables: t
						}))(i(), {
							id: e
						}),
						d = Object(b.a)(a.body.data.subredditInfoById);
					t(j(d))
				}, k = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					e && t(I(e))
				}, _ = Object(d.a)(x.m), S = (e, t) => {
					const n = (e => {
							var t, n;
							const {
								subredditName: s,
								pageName: r
							} = (null === (t = e.platform.currentPage) || void 0 === t ? void 0 : t.urlParams) || {}, o = (null === (n = e.platform.currentPage) || void 0 === n ? void 0 : n.queryParams) || {};
							return {
								page: (null == o ? void 0 : o.page) || "1",
								pageName: r,
								subredditName: s || (null == o ? void 0 : o.subreddit),
								queryParams: o
							}
						})(e),
						s = Object(C.d)(e, n);
					return null == s ? void 0 : s.includes(t)
				}, w = [y.z.ApproveComment, y.z.ApproveLink, y.z.RemoveComment, y.z.RemoveLink, y.z.SpamComment, y.z.SpamLink], T = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					var o, i;
					const {
						moderatorID: a,
						targetID: d,
						action: c
					} = null === (o = null == e ? void 0 : e.subscribe) || void 0 === o ? void 0 : o.data, l = n(), p = Object(A.k)(l), b = w.includes(c), f = a === p, h = S(l, d);
					if (!b || f || !h) return;
					const g = await Object(m.b)(r(), {
						id: a
					}) || (null === (i = Object(A.Cb)(l, {
						userId: a
					})) || void 0 === i ? void 0 : i.username);
					g && t(Object(u.z)(g)), t(_({
						targetID: d
					}))
				}, P = Object(d.a)(x.p), N = Object(d.a)(x.o), D = e => async (t, n, r) => {
					let {
						gqlContext: a
					} = r;
					var d, u, m, b, g, v;
					const x = Object(h.a)(e),
						E = n(),
						O = null === (u = null === (d = null == E ? void 0 : E.features) || void 0 === d ? void 0 : d.realtimeModqueue) || void 0 === u ? void 0 : u.toUpdate.includes(e),
						C = S(E, e);
					if (!O || !C) return;
					const A = x ? () => ((e, t) => Object(s.a)(e, {
							...i,
							variables: t
						}))(a(), {
							id: e
						}) : () => ((e, t) => Object(s.a)(e, {
							...o,
							variables: t
						}))(a(), {
							id: e
						}),
						y = await A();
					if (y.ok) {
						if (x) {
							const n = null === (b = null === (m = null == y ? void 0 : y.body) || void 0 === m ? void 0 : m.data) || void 0 === b ? void 0 : b.postInfoById;
							t(Object(l.Q)({
								[e]: Object(f.f)(n)
							}))
						} else {
							const n = null === (v = null === (g = null == y ? void 0 : y.body) || void 0 === g ? void 0 : g.data) || void 0 === v ? void 0 : v.commentById;
							t(Object(c.j)({
								[e]: Object(p.a)(n)
							}))
						}
						t(N(e)), t(P({
							targetID: e
						}))
					}
				}
		},
		"./src/reddit/actions/modQueueTriggers/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/actions/comment/index.ts"),
				r = n("./src/reddit/actions/post.ts"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/redditGQL/operations/ModQueueTriggers.json");
			const a = e => {
				let {
					commentIds: t = [],
					postIds: n = []
				} = e;
				return async (e, a, d) => {
					let {
						gqlContext: c
					} = d;
					var l, u;
					if (!t.length && !n.length) return;
					const m = await ((e, t) => Object(o.a)(e, {
						...i,
						variables: t
					}))(c(), {
						commentIds: t,
						postIds: n
					});
					if (m.ok) {
						const t = m.body;
						if (t.data.commentsByIds) {
							const n = Object.fromEntries(null === (l = t.data.commentsByIds) || void 0 === l ? void 0 : l.filter(e => {
								var t;
								return null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
							}).map(e => {
								var t;
								return [null == e ? void 0 : e.id, {
									modQueueTriggers: null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
								}]
							}));
							e(Object(s.j)(n))
						}
						if (t.data.postsInfoByIds) {
							const n = Object.fromEntries(null === (u = t.data.postsInfoByIds) || void 0 === u ? void 0 : u.filter(e => {
								var t;
								return null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
							}).map(e => {
								var t;
								return [null == e ? void 0 : e.id, {
									modQueueTriggers: null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
								}]
							}));
							e(Object(r.Q)(n))
						}
					}
				}
			}
		},
		"./src/reddit/actions/moderatingSubreddits.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/profile/index.ts"),
				o = (n("./src/reddit/endpoints/moderator/moderatingSubreddits.ts"), n("./src/reddit/models/User/index.ts")),
				i = n("./src/reddit/selectors/user.ts");
			const a = "MOD_PERMS__REQUEST_LOADED",
				d = (Object(s.a)("MOD_PERMS__REQUEST_PENDING"), Object(s.a)(a), Object(s.a)("MOD_PERMS__REQUEST_FAILED"), () => async (e, t) => {
					const n = Object(i.m)(t());
					if (n) {
						const t = Object(o.e)(n);
						await e(Object(r.b)(t))
					}
				})
		},
		"./src/reddit/actions/moderationLog/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			const s = "SUBREDDIT__MODERATION_LOG_LOADED",
				r = "SUBREDDIT__ALL_MODERATORS_LOADED",
				o = "SUBREDDIT__MODERATION_CATEGORY_ACTIONS_LOADED"
		},
		"./src/reddit/actions/notificationSettingsLayout/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "k", (function() {
				return p
			}));
			const s = "NOTIFICATION_EMAIL_SETTINGS_LAYOUT__FAILED",
				r = "NOTIFICATION_EMAIL_SETTINGS_LAYOUT__LOADED",
				o = "NOTIFICATION_EMAIL_SETTINGS_LAYOUT__PENDING",
				i = "NOTIFICATION_PUSH_SETTINGS_LAYOUT__FAILED",
				a = "NOTIFICATION_PUSH_SETTINGS_LAYOUT__LOADED",
				d = "NOTIFICATION_PUSH_SETTINGS_LAYOUT__PENDING",
				c = "NOTIFICATION_SETTINGS_LAYOUT_UPDATED",
				l = "NOTIFICATION_SUBSCRIBED_SUBREDDITS_FAILED",
				u = "NOTIFICATION_SUBSCRIBED_SUBREDDITS_LOADED",
				m = "NOTIFICATION_SUBSCRIBED_SUBREDDITS_PENDING",
				p = "NOTIFICATION_SUBSCRIBED_SUBREDDITS_UPDATED"
		},
		"./src/reddit/actions/notificationSettingsLayout/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return v
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "c", (function() {
				return y
			})), n.d(t, "b", (function() {
				return I
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/notificationSettingsLayout/constants.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/endpoints/notificationsSettings/layoutByChannelEndpoint.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/UserSubredditsNotificationsLevel.json");
			var l = n("./src/reddit/models/NotificationSettingsLayout/index.ts"),
				u = n("./src/reddit/models/Toast/index.ts");
			const m = Object(r.a)(o.c),
				p = Object(r.a)(o.b),
				b = Object(r.a)(o.a),
				f = Object(r.a)(o.f),
				h = Object(r.a)(o.e),
				g = Object(r.a)(o.d),
				v = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					e === l.a.Push ? t(f()) : t(m()), await async function(e, t, n) {
						const s = await Object(a.a)(e(), {
							channel: t
						});
						if (s.ok && s.body) {
							const e = function(e) {
								const t = e && e.data,
									n = t && t.notificationSettingsLayoutByChannel,
									s = n && n.sections;
								if (s) return function(e) {
									const t = {},
										n = [];
									let s = {},
										r = [];
									const o = e => {
										const {
											rowIds: o,
											rowsCollection: i
										} = function(e) {
											const t = [],
												n = {};
											if (e.rows)
												for (let s = 0; s < e.rows.length; s++) {
													const r = e.rows[s],
														o = r.messageType;
													t.push(o), n[o] = r
												}
											return {
												rowsCollection: n,
												rowIds: t
											}
										}(e);
										s = {
											...s,
											...i
										}, r = [...r, ...o];
										const a = e.id;
										n.push(a), t[a] = {
											...e,
											rows: o
										}
									};
									for (let i = 0; i < e.length; i++) o(e[i]);
									return {
										sections: {
											byId: t,
											allIds: n
										},
										rows: {
											byId: s,
											allIds: r
										}
									}
								}(s)
							}(s.body);
							t === l.a.Push ? n(h(e)) : n(p(e))
						} else t === l.a.Push ? n(g({
							error: s.error
						})) : n(b({
							error: s.error
						}))
					}(r, e, t)
				};
			const x = Object(r.a)(o.g),
				E = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					(await Object(a.b)(o(), e)).ok ? (O(t, e), function(e) {
						e(Object(i.f)({
							kind: u.b.SuccessCommunity,
							text: s.fbt._("Changes saved", null, {
								hk: "UBoVR"
							})
						}))
					}(t)) : function(e) {
						e(Object(i.f)({
							kind: u.b.Error,
							text: s.fbt._("We had some issues saving your changes. Please try again.", null, {
								hk: "1OvQi6"
							})
						}))
					}(t)
				};

			function O(e, t) {
				e(x({
					isEnabled: t.isEnabled,
					messageType: t.messageType
				}))
			}
			const C = Object(r.a)(o.j),
				A = Object(r.a)(o.i),
				y = Object(r.a)(o.k),
				j = Object(r.a)(o.h),
				I = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					var o, a;
					t(C());
					const l = await ((e, t) => Object(d.a)(e, {
						...c,
						variables: t
					}))(r(), e);
					if (null === (a = null === (o = l.error) || void 0 === o ? void 0 : o.fields) || void 0 === a ? void 0 : a.length) return t(j({
						error: l.error
					})), void t(Object(i.d)());
					if (l.ok && l.body) {
						const e = l.body,
							n = e && e.data,
							s = n && n.identity && n.identity.subscribedSubreddits,
							r = s && s.pageInfo,
							o = (s && s.edges).map(e => e.node);
						t(A({
							nodes: o,
							pageInfo: r
						}))
					}
				}
		},
		"./src/reddit/actions/notifications/utils.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			}));
			var s = n("./src/lib/notifications/index.ts"),
				r = n("./src/lib/notifications/constants.ts"),
				o = n("./src/lib/notifications/featureFlags.ts"),
				i = n("./src/reddit/featureFlags/index.ts"),
				a = n("./src/reddit/helpers/localStorage/index.ts");
			const d = e => i.d.pushNotificationsBrowserSupported(e) ? Object(o.a)() : r.d.BrowserUnsupported,
				c = e => {
					switch (e) {
						case r.a.Denied:
							a.sb(!1), Object(s.c)();
							break;
						case r.a.Default:
						case r.a.Granted:
							a.sb(!0), Object(s.c)();
							break;
						case r.a.Closed:
							a.sb(!0)
					}
				}
		},
		"./src/reddit/actions/notificationsInbox/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			const s = "INBOX_NOTIFICATIONS__PENDING",
				r = "INBOX_NOTIFICATIONS__LOADED",
				o = "INBOX_NOTIFICATIONS__FAILED",
				i = "INBOX_NOTIFS_SET_OVERFLOW_MENU_ID",
				a = "INBOX_NOTIFICATIONS__REMOVE_NOTIFICATION",
				d = "INBOX_NOTIFS__MARK_AS_READ",
				c = "INBOX_NOTIFS__SET_EARLIER_DIVIDER_INDEX",
				l = "INBOX_NOTIFS_MARK_ALL_AS_READ"
		},
		"./src/reddit/actions/notificationsInbox/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return N
			})), n.d(t, "e", (function() {
				return D
			})), n.d(t, "b", (function() {
				return U
			})), n.d(t, "i", (function() {
				return H
			})), n.d(t, "f", (function() {
				return G
			})), n.d(t, "c", (function() {
				return Q
			})), n.d(t, "a", (function() {
				return q
			})), n.d(t, "h", (function() {
				return z
			})), n.d(t, "j", (function() {
				return V
			})), n.d(t, "g", (function() {
				return Y
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/appBadgeIndicators/index.ts"),
				i = n("./src/reddit/actions/inboxBanner/index.ts"),
				a = (n("./src/reddit/actions/notificationSettingsLayout/index.ts"), n("./src/reddit/actions/notificationsInbox/constants.ts")),
				d = n("./src/reddit/actions/tabBadging.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/redditGQL/operations/BlockAwarder.json");
			var m = (e, t) => Object(l.a)(e, {
					...u,
					variables: t
				}),
				p = n("./src/lib/constants/index.ts"),
				b = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				h = n("./src/redditGQL/operations/NotificationInboxFeed.json"),
				g = n("./src/redditGQL/operations/NotificationInboxFeedSlimmed.json"),
				v = n("./src/reddit/constants/headers.ts"),
				x = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var E;
			! function(e) {
				e.Activity = "activity", e.Messages = "messages", e.CommentReply = "comment_reply", e.PostReply = "post_reply", e.UsernameMention = "username_mention"
			}(E || (E = {}));
			var O = n("./src/redditGQL/operations/DeleteInboxNotifications.json");
			n("./src/reddit/endpoints/notificationsSettings/layoutByChannelEndpoint.ts");
			var C = n("./src/redditGQL/operations/UpdateInboxActivitySeenState.json");
			var A = n("./src/reddit/endpoints/subreddit/notificationSettings.ts"),
				y = n("./src/reddit/helpers/trackers/inbox.ts"),
				j = n("./src/reddit/models/Badge/index.ts"),
				I = n("./src/reddit/models/NotificationInbox/index.ts"),
				k = n("./src/reddit/models/Toast/index.ts"),
				_ = n("./src/reddit/selectors/appBadges.ts"),
				S = (n("./src/reddit/selectors/notificationPrefs.ts"), n("./src/reddit/selectors/notificationsInbox.tsx"));
			const w = Object(r.a)(a.e),
				T = Object(r.a)(a.b),
				P = Object(r.a)(a.a),
				N = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					var o, a;
					const d = n(),
						u = Object(S.a)(d);
					t(w());
					const m = await ((e, t) => Object(l.a)(e, {
						...h,
						variables: t
					}))(r(), e);
					if (null === (a = null === (o = m.error) || void 0 === o ? void 0 : o.fields) || void 0 === a ? void 0 : a.length) return t(P({
						error: m.error
					})), void t(Object(c.d)());
					const p = m && m.body,
						b = M(p);
					if (null === u) {
						const e = Object(S.f)(d);
						t(L(b.notifications, e.length))
					}
					t(T(b)), t(Object(i.b)(b.banners))
				}, D = () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					var r, o;
					const i = await (e => Object(l.a)(e, {
						...g
					}))(s());
					if (null === (o = null === (r = i.error) || void 0 === r ? void 0 : r.fields) || void 0 === o ? void 0 : o.length) return;
					const a = i && i.body,
						d = R(a).nodes.filter(e => !e.viewedAt);
					d.length && d.forEach(e => {
						var n;
						Object(y.s)({
							id: e.id,
							isClicked: !1,
							isViewed: Boolean(e.viewedAt),
							type: null === (n = e.context) || void 0 === n ? void 0 : n.messageType
						})(t())
					})
				}, M = e => {
					const t = [],
						n = [],
						s = e && e.data,
						r = s && s.notificationInbox,
						o = r && r.elements,
						i = o && o.pageInfo,
						a = o && o.edges;
					if (a)
						for (const d of a) Object.keys(d.node).length && (d.node.hasOwnProperty("notificationName") ? n.push(d.node) : t.push(d.node));
					return {
						notifications: t,
						banners: n,
						pageInfo: i
					}
				}, R = e => {
					var t, n;
					return {
						nodes: null === (n = null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.notificationInbox) || void 0 === n ? void 0 : n.elements.edges.map(e => e.node)
					}
				}, L = (e, t) => async (n, s) => {
					const r = s(),
						o = Object(S.a)(r),
						i = ((e, t) => {
							let n, s = 0;
							const r = new Date,
								o = r.getDate(),
								i = r.getMonth(),
								a = r.getFullYear();
							for (; s < e.length && !n;) {
								const r = e[s],
									d = new Date(r.sentAt),
									c = d.getDate(),
									l = d.getMonth(),
									u = d.getFullYear();
								if ((c !== o || l !== i || u !== a) && !n) {
									n = ((t || 0) + s).toString()
								} else s++
							}
							return n
						})(e, t);
					i && i !== o && n(B({
						index: i
					}))
				}, B = Object(r.a)(a.g), F = (Object(r.a)(a.h), Object(r.a)(a.f)), U = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					const i = [e];
					if ((await ((e, t) => Object(l.a)(e, {
							...O,
							variables: {
								input: t
							}
						}))(o(), {
							notificationIds: i
						})).ok) {
						t(F({
							id: e
						}));
						const r = Object(S.f)(n());
						t(L(r)), t(Object(c.f)(Object(c.e)(s.fbt._("Notification hidden", null, {
							hk: "1jfPqO"
						}), k.b.SuccessCommunityGreen)))
					} else t(Object(c.f)(Object(c.e)(s.fbt._("Failed to hide notification, please try again.", null, {
						hk: "fL7uB"
					}), k.b.Error)))
				}, H = (e, t) => async (n, r, o) => {
					let {
						gqlContext: i
					} = o;
					if (!e) return;
					(await Object(A.b)(i(), e, {
						isSubredditUpdatesInterestingPostEnabled: !0,
						isUpdateFromSubredditEnabled: !0
					})).ok ? (t && t(), n(Object(c.f)(Object(c.e)(s.fbt._("Success! Undone hiding notifications from this community.", null, {
						hk: "1na0NP"
					}), k.b.SuccessCommunityGreen)))) : n(Object(c.f)(Object(c.e)(s.fbt._("Failed to undo hiding notifications, please try again.", null, {
						hk: "4jo7Pf"
					}), k.b.Error)))
				}, G = (e, t) => async (n, r, o) => {
					let {
						gqlContext: i
					} = o;
					if (!e) return;
					(await Object(A.b)(i(), e, {
						isSubredditUpdatesInterestingPostEnabled: !1,
						isUpdateFromSubredditEnabled: !1
					})).ok ? n((() => {
						const n = s.fbt._("Success! You won't see notifications from this community in the future.", null, {
							hk: "2tkhbk"
						});
						return Object(c.f)(Object(c.e)(n, k.b.Undo, s.fbt._("Undo", null, {
							hk: "4zFGDk"
						}), H(e, t)))
					})()) : n(Object(c.f)(Object(c.e)(s.fbt._("Failed to hide notifications, please try again.", null, {
						hk: "KEGcB"
					}), k.b.Error)))
				}, Q = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					if (!e) return;
					(await ((e, t) => Object(b.a)(Object(f.a)(e, [v.a]), {
						endpoint: Object(x.a)(`${e.apiUrl}/api/sendreplies`),
						method: p.ob.POST,
						data: {
							id: t
						}
					}))(o(), e)).ok ? t(Object(c.f)(Object(c.e)(s.fbt._("Success! You won't see updates on this in the future", null, {
						hk: "wtDa4"
					}), k.b.SuccessCommunityGreen))) : t(Object(c.f)(Object(c.e)(s.fbt._("Failed to turn off updates on this, please try again", null, {
						hk: "1zhpEy"
					}), k.b.Error)))
				}, q = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					if (!e) return;
					(await m(o(), {
						awardingId: e
					})).ok ? t(Object(c.f)(Object(c.e)(s.fbt._("Success! Awarder has been blocked", null, {
						hk: "2D5PUk"
					}), k.b.SuccessCommunityGreen))) : t(Object(c.f)(Object(c.e)(s.fbt._("Failed to block awarder, please try again", null, {
						hk: "2dxeA8"
					}), k.b.Error)))
				}, W = Object(r.a)(a.d), z = (e, t) => async (n, s, r) => {
					let i, {
						apiContext: a
					} = r;
					if (t === I.a.CommentReply || t === I.a.PostReply || t === I.a.PrivateMessage || t === I.a.UsernameMention) {
						if ((i = await ((e, t) => Object(b.a)(Object(f.a)(e, [v.a]), {
								endpoint: Object(x.a)(`${e.apiUrl}/api/read_message`),
								method: p.ob.POST,
								data: {
									id: t
								}
							}))(a(), e)).ok) {
							let e = Object(_.a)(s());
							if (e > 0) {
								e--;
								const t = Object(o.e)({
									count: e,
									key: j.c.ActivityTab
								});
								n(Object(o.a)(t)), n(Object(d.e)())
							}
						}
					} else i = await ((e, t) => Object(b.a)(Object(f.a)(e, [v.a]), {
						endpoint: Object(x.a)(`${e.apiUrl}/api/read_notification`),
						method: p.ob.POST,
						data: {
							id: t
						}
					}))(a(), e);
					if (i.ok) {
						const t = (new Date).toISOString();
						n(W({
							id: e,
							now: t
						}))
					}
				}, V = () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					const r = (new Date).toLocaleDateString(),
						i = await ((e, t) => Object(l.a)(e, {
							...C,
							variables: {
								input: t
							}
						}))(s(), {
							lastSentAt: r
						});
					if (i.ok) {
						const t = i.body,
							n = t && t.data && t.data.updateInboxActivitySeenState && t.data.updateInboxActivitySeenState.badgeIndicators;
						n && (e(Object(o.a)(n)), e(Object(d.d)()))
					}
				}, K = Object(r.a)(a.c), Y = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const {
						notificationsInbox: {
							markAllAsReadTimestamp: i
						}
					} = t(), a = new Date;
					if (!i || a.getTime() - new Date(i).getTime() > 15e3) {
						if ((await ((e, t) => Object(b.a)(Object(f.a)(e, [v.a]), {
								endpoint: Object(x.a)(`${e.apiUrl}/api/read_all_messages`),
								method: p.ob.POST,
								data: {
									filter_types: null == t ? void 0 : t.join(",")
								}
							}))(r(), [E.Activity, E.Messages, E.CommentReply, E.PostReply, E.UsernameMention])).ok) {
							const t = Object(o.e)({
									count: 0,
									key: j.c.MessageTab
								}),
								n = Object(o.e)({
									count: 0,
									key: j.c.ActivityTab
								});
							e(Object(o.a)({
								...t,
								...n
							})), e(K({
								now: a.toISOString()
							}))
						} else e(Object(c.f)(Object(c.e)(s.fbt._("Sorry, we had trouble doing that. Please try again.", null, {
							hk: "VW7c3"
						}), k.b.Error)))
					}
				}
		},
		"./src/reddit/actions/nsfwBlocking/async.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/lib/loadableAction/index.ts");
			const r = Object(s.a)(() => n.e("NsfwBlockingActions").then(n.bind(null, "./src/reddit/actions/nsfwBlocking/index.ts")).then(e => e.default))
		},
		"./src/reddit/actions/onboarding/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			const s = "RESET_GENDER_UPDATE_STATE",
				r = "SUBREDDIT_INTEREST_TOPICS",
				o = "SKIP_ONBOARDING_MODAL"
		},
		"./src/reddit/actions/onboarding/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "openReonboardingModalIfNeeded", (function() {
				return u
			})), n.d(t, "resetGenderUpdateState", (function() {
				return m
			})), n.d(t, "subredditInterestTopicsLoaded", (function() {
				return p
			})), n.d(t, "skipOnboardingModal", (function() {
				return b
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/login.ts"),
				o = n("./src/reddit/actions/onboarding/constants.ts"),
				i = n("./src/reddit/helpers/counters/onboarding.ts"),
				a = n("./src/reddit/helpers/onboarding/reonboarding.ts"),
				d = n("./src/reddit/models/Onboarding/index.ts"),
				c = n("./src/reddit/selectors/experiments/onboarding.ts"),
				l = n("./src/reddit/selectors/onboarding.ts");
			const u = () => async (e, t) => {
				const n = t(),
					s = n.platform.currentPage;
				if (Object(l.e)(n, {
						pageLayer: s
					})) {
					e(Object(r.openD2xOnboardingModal)({
						type: d.d.REONBOARDING,
						selectedInterests: {}
					})), Object(a.d)();
					const t = Object(c.j)(n);
					Object(i.b)(d.f.FirstPopover, t)
				}
			}, m = Object(s.a)(o.a), p = Object(s.a)(o.c), b = Object(s.a)(o.b);
			t.default = () => async (e, t) => {
				const n = t();
				Object(l.d)(n) && e(Object(r.openD2xOnboardingModal)())
			}
		},
		"./src/reddit/actions/pages/modListing/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return s
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "j", (function() {
				return b
			}));
			const s = "PAGE__MOD_LISTING_PAGE_PENDING",
				r = "PAGE__MOD_LISTING_PAGE_LOADED",
				o = "PAGE__MOD_LISTING_PAGE_FAILED",
				i = "MOD_LISTING_MORE_POSTS_PENDING",
				a = "MOD_LISTING_MORE_POSTS_LOADED",
				d = "MOD_LISTING_MORE_POSTS_FAILED",
				c = "MOD_LISTING_HIDE_SUBREDDIT_SUCCESS",
				l = "MOD_LISTING_HIDE_SUBREDDIT_PENDING",
				u = "MOD_LISTING_HIDE_SUBREDDIT_FAILED",
				m = "MOD_LISTING_UNHIDE_SUBREDDIT_SUCCESS",
				p = "MOD_LISTING_UNHIDE_SUBREDDIT_PENDING",
				b = "MOD_LISTING_UNHIDE_SUBREDDIT_FAILED"
		},
		"./src/reddit/actions/pages/moderationPages/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "moderationPageRequested", (function() {
				return ve
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/assertNever.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/initializeClient/installReducer.ts"),
				a = n("./src/lib/makeListingKey/index.ts"),
				d = n("./src/reddit/actions/scheduledPosts/index.ts"),
				c = n("./src/reddit/helpers/canAccessModerationPage/index.ts"),
				l = n("./src/reddit/helpers/makeModQueueListingKey/index.ts"),
				u = n("./src/reddit/helpers/moderationLog/getGqlQueryParamsFromUrlQuery.ts"),
				m = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				p = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				b = n("./src/reddit/helpers/trackers/screenview.ts"),
				f = n("./src/reddit/actions/contentControls/index.ts"),
				h = n("./src/reddit/actions/emoji.ts"),
				g = n("./src/reddit/actions/eventPosts/index.ts"),
				v = n("./src/reddit/actions/gold/communityAwards/index.ts"),
				x = n("./src/reddit/actions/grantUserFlair/index.ts"),
				E = n("./src/lib/makeActionCreator/index.ts"),
				O = n("./src/reddit/endpoints/subredditModeration/moderationLog.ts"),
				C = n("./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts"),
				A = n("./src/reddit/models/SubredditModeration/ModerationLog/index.ts"),
				y = n("./src/reddit/selectors/subreddit.ts"),
				j = n("./src/reddit/actions/moderationLog/constants.ts");
			const I = Object(E.a)(j.c),
				k = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					var i, a;
					const d = await Object(O.b)(o(), e, t);
					if (!d.body) return;
					const c = null === (a = null === (i = d.body.data) || void 0 === i ? void 0 : i.subredditInfoByName) || void 0 === a ? void 0 : a.moderation;
					if (!c || !c.actions) return;
					const l = s(),
						{
							actions: u,
							...m
						} = c,
						p = Object(C.b)(u),
						b = Object(y.I)(l, e),
						{
							hasNextPage: f,
							hasPreviousPage: h,
							endCursor: g,
							startCursor: v
						} = c.actions.pageInfo,
						x = Object(A.a)(b, g, v),
						E = p.map(e => e.id);
					n(I({
						approximateCount: c.actions.approximateCount,
						hasNextPage: f,
						hasPreviousPage: h,
						endCursor: g,
						key: x,
						startCursor: v,
						normalizedModerationLog: p,
						actionIds: E,
						subredditId: b,
						insightsData: m
					}))
				};
			var _ = n("./src/reddit/actions/modQueue/index.ts"),
				S = n("./src/reddit/actions/pages/subreddit/index.ts"),
				w = n("./src/reddit/actions/pages/subredditWiki/index.ts"),
				T = n("./src/reddit/actions/platform.ts"),
				P = n("./src/reddit/actions/profile/index.ts"),
				N = n("./src/reddit/actions/removalReasons/index.ts"),
				D = n("./src/reddit/actions/subreddit.ts"),
				M = n("./src/reddit/actions/subreddit/questions.ts"),
				R = n("./src/reddit/actions/countrySites/subredditCountrySiteSettings.ts"),
				L = n("./src/reddit/actions/subredditModeration/index.ts"),
				B = n("./src/reddit/actions/subredditModeration/approvedSubmitters.ts"),
				F = n("./src/reddit/actions/subredditModeration/approvedTalkHosts.ts"),
				U = n("./src/reddit/actions/subredditModeration/ban.ts"),
				H = n("./src/reddit/actions/subredditModeration/mute.ts"),
				G = n("./src/reddit/actions/subredditSettings.ts"),
				Q = n("./src/reddit/actions/tags/index.ts"),
				q = n("./node_modules/fbt/lib/FbtPublic.js"),
				W = n("./src/reddit/actions/toaster.ts"),
				z = n("./src/reddit/actions/trafficStats/constants.ts"),
				V = n("./src/lib/makeGqlRequest/index.ts"),
				K = n("./src/redditGQL/operations/FetchSubredditTrafficStats.json");
			var Y = n("./node_modules/lodash/forEach.js"),
				J = n.n(Y),
				X = n("./src/reddit/helpers/graphql/helpers.ts"),
				Z = n("./src/reddit/models/TrafficStats/index.ts");
			const $ = e => ({
					desktop: new Array(e).fill(0),
					oldReddit: new Array(e).fill(0),
					mWeb: new Array(e).fill(0),
					apps: new Array(e).fill(0),
					total: new Array(e).fill(0)
				}),
				ee = (e, t) => {
					return Object(X.g)(e.startsAt) > Object(X.g)(t.startsAt) ? 1 : -1
				},
				te = (e, t, n) => {
					const s = {
							pageViews: $(t),
							uniqueUsers: $(t)
						},
						r = Object(X.g)(e[0].startsAt);
					return e.map(e => {
						const o = Object(X.g)(e.startsAt),
							i = new Date(o),
							a = t === Z.c ? i.getMonth() : Math.round((o - r) / n) % t,
							d = Z.d[e.client];
						s.pageViews[d][a] += e.pageViews, s.uniqueUsers[d][a] += e.uniqueUsers
					}), s
				};
			var ne = n("./src/reddit/models/Toast/index.ts");
			const se = Object(E.a)(z.b),
				re = Object(E.a)(z.c),
				oe = Object(E.a)(z.a),
				ie = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const i = Object(y.X)(n(), {
						subredditId: e
					}).name;
					t(re({
						subredditId: e
					}));
					const a = await ((e, t) => Object(V.a)(e, {
						...K,
						variables: t
					}))(r(), {
						subredditName: i
					});
					if (a.ok) {
						const n = a.body.data.subreddit.moderation;
						if (n && n.trafficStats) {
							const s = (e => {
								const t = J()(e, (e, t) => e.sort(ee)),
									n = t.subscriptionData,
									s = n.map(e => e.subscribers),
									r = n.map(e => e.unsubscribers),
									i = te(t.hourStats, Z.b, o.U),
									a = te(t.dayStats, Z.a, o.D),
									d = te(t.monthStats, Z.c, o.ub);
								return {
									pageViews: {
										byHour: i.pageViews,
										byDay: a.pageViews,
										byMonth: d.pageViews
									},
									uniqueUsers: {
										byHour: i.uniqueUsers,
										byDay: a.uniqueUsers,
										byMonth: d.uniqueUsers
									},
									subscribers: s,
									unsubscribers: r
								}
							})(n.trafficStats);
							t(se({
								subredditId: e,
								trafficStats: s
							}))
						}
					} else t(oe({
						subredditId: e
					})), t(W.f({
						id: "error-block-trafficStats",
						kind: ne.b.Error,
						text: q.fbt._("Try again later", null, {
							hk: "41Goel"
						})
					}))
				};
			var ae = n("./src/reddit/models/ModQueue/index.ts"),
				de = n("./src/reddit/models/ScheduledPost/index.ts"),
				ce = n("./src/reddit/reducers/pages/modHub/index.ts"),
				le = n("./src/reddit/selectors/experiments/devPlatform.ts"),
				ue = n("./src/reddit/selectors/experiments/econ/index.ts"),
				me = n("./src/reddit/selectors/moderatorPermissions.ts"),
				pe = n("./src/reddit/selectors/modQueue.ts"),
				be = n("./src/reddit/selectors/platform.ts"),
				fe = n("./src/reddit/selectors/postCreations.ts"),
				he = n("./src/reddit/selectors/profile.ts"),
				ge = n("./src/reddit/selectors/user.ts");
			Object(i.a)({
				pages: {
					modHub: ce.a
				}
			});
			const ve = e => async (t, n, i) => {
				const {
					params: E
				} = e, {
					pageName: O,
					profileName: C,
					subredditName: A
				} = E, j = Object(le.a)(n());
				if (O === o.mc.Wiki) {
					if (await t(Object(w.handleWikiRedirects)(e))) return
				}
				if (O === o.mc.SubredditContent) return void t(Object(s.c)(de.s));
				const I = e.queryParams,
					q = I.page || ae.b,
					W = n();
				if (A) {
					const e = Object(a.a)(A, o.bb.HOT),
						n = W.listings.postOrder.ids[e],
						s = W.listings.postOrder.api.error[e],
						r = W.listings.postOrder.api.pending[e];
					if (s) return;
					r || n && !s || await t(Object(S.subredditDataRequested)(e, A, {}))
				} else C && await t(Object(P.e)(C));
				if (!Object(ge.S)(n()) && O !== o.mc.SubredditRules && O !== o.mc.Contributors) return void Object(m.a)(t, n());
				if (Object(b.h)(n(), !0, A, C), !O) return;
				let z, V, K, Y, J, X, Z, $, ee, te;
				switch (O) {
					case o.mc.Awards:
						z = v.i;
						break;
					case o.mc.Muted:
						z = H.b;
						break;
					case o.mc.Contributors:
						z = B.b;
						break;
					case o.mc.Banned:
						z = U.c;
						break;
					case o.mc.Moderators:
						K = !0;
						break;
					case o.mc.Removal:
						z = N.removalReasonsRequested;
						break;
					case o.mc.ContentControls:
						z = f.a, X = !0;
						break;
					case o.mc.CommunitySettings:
						z = G.h, Z = !0;
						break;
					case o.mc.Flair:
						z = x.b, J = !0;
						break;
					case o.mc.UserFlair:
					case o.mc.PostFlair:
						z = void 0;
						break;
					case o.mc.Emojis:
						z = h.k;
						break;
					case o.mc.Badges:
					case o.mc.Emotes:
					case o.mc.SubredditRules:
						z = void 0;
						break;
					case o.mc.Traffic:
						z = ie;
						break;
					case o.mc.Modlog:
						z = k, Y = !0;
						break;
					case o.mc.Modqueue:
					case o.mc.Reports:
					case o.mc.Spam:
					case o.mc.Edited:
					case o.mc.Unmoderated:
						V = O;
						break;
					case o.mc.Wiki:
					case o.mc.WikiContributors:
					case o.mc.WikiBanned:
						await t(Object(w.subredditWikDataRequested)(E, I, !0));
						break;
					case o.mc.ScheduledPostContent:
						$ = !0, z = d.i;
						break;
					case o.mc.EventPostContent:
						ee = !0;
						break;
					case o.mc.Predictions:
						break;
					case o.mc.TalkHosts:
						te = !0;
						break;
					default:
						return Object(r.a)(O)
				}
				const ne = n(),
					se = !!A && Object(fe.ob)(ne),
					re = Object(ge.P)(ne),
					oe = A ? Object(y.ab)(ne, {
						subredditName: A.toLowerCase()
					}) : Object(he.s)(ne, {
						profileName: C.toLowerCase()
					}),
					ce = A && Object(y.I)(ne, A),
					ve = C && Object(he.o)(ne, C),
					xe = ce || ve,
					Ee = Object(ue.r)(W),
					Oe = Object(me.n)(ne, {
						subredditId: xe
					}),
					Ce = A && Object(y.z)(ne, {
						subredditName: A
					}),
					Ae = !(!Ce || !Ce.userIsContributor),
					ye = Object(y.cb)(ne, {
						subredditId: xe
					});
				if (Object(c.a)({
						canCreateScheduledPosts: se,
						isContributor: Ae,
						isEmployee: re,
						isTalkHostsEnabled: Ee,
						moderatorPermissions: Oe,
						pageName: O,
						subredditType: ye
					})) {
					if (V && A) {
						const e = Object(l.a)({
								onlyOfType: I.only,
								sort: I.sort,
								subreddit: A
							}),
							s = !!Object(pe.f)(W, {
								pageName: V,
								page: `${q}`,
								subredditName: A,
								queryParams: I
							}),
							r = W.pages.modHub.modQueue[V].api.error;
						if (Object(pe.e)(W, {
								pageName: V
							}) || s && !r) return;
						if (!Object(be.p)(W)) {
							const s = Object(_.e)(e, V, {
								...I,
								subreddit: A,
								includeDevPlatformMetadata: j
							});
							await s(t, n, i)
						}
					} else if (K && ce) {
						if (await Object(L.g)(ce, I)(t, n, i), W.moderatingSubreddits[ce]) {
							await Object(L.e)(ce, I)(t, n, i), W.pages.modHub.moderators.invitedModerators.userOrder[ce] || await Object(L.f)(ce)(t, n, i)
						}
					} else if (te && ce) await Object(F.b)({
						subredditId: ce
					})(t, n, i);
					else if (X && A) await z(A)(t, n, i);
					else if (Z && ce) await Promise.all([z(A, ce)(t, n, i), Object(Q.g)(ce, p.a.communitySettings)(t, n, i), Object(M.b)(ce)(t, n, i), Object(R.d)(ce)(t, n, i)]);
					else if (J) await z(A, I)(t, n, i);
					else if (Y) {
						const e = {
							...I
						};
						e.endDate && (e.endDate = `${e.endDate} 23:59:59`), await z(A, Object(u.b)(A, e, n()))(t, n, i)
					} else $ && ce ? await Object(d.i)({
						subredditId: ce
					})(t, n, i) : ee && A ? await Object(g.eventPostsRequested)(A)(t, n, i) : z && await z(xe, I)(t, n, i);
					A && ce && !W.subreddits.rules[ce] && await D.o(A)(t, n, i), t(T.n({
						title: oe
					}))
				}
			}
		},
		"./src/reddit/actions/pages/multireddit/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "PAGE__MULTIREDDIT_FEED_PENDING",
				r = "PAGE__MULTIREDDIT_FEED_LOADED",
				o = "PAGE__MULTIREDDIT_FEED_FAILED"
		},
		"./src/reddit/actions/pages/postCreation.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "PAGE_PENDING", (function() {
				return R
			})), n.d(t, "PAGE_LOADED", (function() {
				return L
			})), n.d(t, "PAGE_FAILED", (function() {
				return B
			})), n.d(t, "pagePending", (function() {
				return F
			})), n.d(t, "pageLoaded", (function() {
				return U
			})), n.d(t, "pageFailed", (function() {
				return H
			})), n.d(t, "postCreationPageDataRequested", (function() {
				return q
			})), n.d(t, "postCreationPageRequested", (function() {
				return W
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/filterQueryParams/index.ts"),
				o = n("./src/lib/isFakeSubreddit/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/makePostCreationPageKey/index.ts"),
				d = n("./src/lib/pageTitle/index.ts"),
				c = n("./src/reddit/actions/contentControls/index.ts"),
				l = n("./src/reddit/actions/economics/helpers/async.ts"),
				u = n("./src/reddit/actions/externalAccount.ts"),
				m = n("./src/reddit/actions/platform.ts"),
				p = n("./src/reddit/actions/post.ts"),
				b = n("./src/reddit/actions/postCreation/general.ts"),
				f = n("./src/reddit/actions/postGuidance/index.ts"),
				h = n("./src/reddit/actions/profile/index.ts"),
				g = n("./src/reddit/actions/subreddit.ts"),
				v = n("./src/reddit/actions/subredditDuplicates.ts"),
				x = n("./src/config.ts"),
				E = n("./src/lib/constants/index.ts"),
				O = n("./src/lib/makeApiRequest/index.ts"),
				C = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				A = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				y = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				j = n("./src/reddit/models/User/index.ts"),
				I = n("./src/reddit/selectors/contentControls.ts"),
				k = n("./src/reddit/selectors/experiments/postGuidance.ts"),
				_ = n("./src/reddit/selectors/postCollection.ts"),
				S = n("./src/reddit/selectors/postCreations.ts"),
				w = n("./src/reddit/selectors/postGuidance.ts"),
				T = n("./src/reddit/selectors/posts.ts"),
				P = n("./src/reddit/selectors/profile.ts"),
				N = n("./src/reddit/selectors/subreddit.ts"),
				D = n("./src/reddit/selectors/user.ts");
			const M = e => {
					const t = e.platform.currentPage;
					let n = "Reddit";
					if (t && t.urlParams.subredditName) {
						const {
							subredditName: s
						} = t.urlParams, r = Object(N.C)(e, {
							subredditName: s
						});
						r && (n = r.name)
					}
					return Object(d.o)(n)
				},
				R = "POST_CREATION__PAGE_PENDING",
				L = "POST_CREATION__PAGE_LOADED",
				B = "POST_CREATION__PAGE_FAILED",
				F = Object(i.a)(R),
				U = Object(i.a)(L),
				H = Object(i.a)(B),
				G = () => async (e, t) => {
					const n = t(),
						s = Object(S.a)(n);
					s !== Object(S.rb)(n) && e(Object(b.g)({
						submissionType: s
					}))
				}, Q = e => async (t, n) => {
					const s = n(),
						{
							profileName: r,
							subredditName: o
						} = e;
					let i;
					if (o ? i = Object(N.I)(n(), o) : r && (i = Object(D.ob)(n(), {
							userName: r
						})), Object(w.b)(s, {
							subredditId: i
						}) && o) {
						Object(k.a)(s) && t(Object(f.b)(o))
					}
				}, q = e => async (t, n, s) => {
					const {
						collectionId: r,
						profileName: i,
						subredditName: d
					} = e, l = Object(a.a)(e), m = n(), p = m.creations.api.page.pending[l], b = m.creations.api.page.fetched[l], v = m.creations.api.page.error[l];
					if (p) return;
					if (b && !v) return t(G()), void t(Q(e));
					const A = [];
					t(F({
						key: l
					}));
					let k = d;
					!d && i && (k = `u_${i}`), A.push(((e, t) => Object(O.a)(e, {
						method: E.ob.GET,
						endpoint: Object(C.a)(`${x.a.gatewayUrl}/desktopapi/v1/submitpage`),
						data: {
							subreddit: t.subredditName,
							collection_id: t.collectionId
						}
					}))(s.apiContext(), {
						subredditName: k,
						collectionId: r
					}), t(Object(f.a)())), i && (A.push(t(h.d(i))), A.push(t(h.b(i))));
					const [_] = await Object(y.a)("postCreation", () => Promise.all(A));
					if (_.ok) {
						const s = _.body,
							{
								posts: r = {}
							} = s;
						if (t(U({
								key: l,
								meta: m.meta,
								...s,
								posts: r
							})), !Object(D.S)(n())) return;
						t(G()), t(Q(e));
						const i = [];
						i.push(t(u.o()));
						const a = Object(D.m)(n());
						if (a && a.hasUserProfile && i.push(t(h.d(Object(j.e)(a)))), d && !Object(o.a)(d)) {
							i.push(t(g.o(d))), !!Object(I.b)(n(), {
								subredditName: d
							}) || i.push(t(Object(c.a)(d)))
						}
						await Promise.all(i)
					} else t(H({
						error: _.error,
						key: l
					}))
				}, W = e => async (t, n) => {
					const {
						subredditName: o,
						profileName: i
					} = e.params, a = e.queryParams, d = a.collection;
					if (await t(q({
							collectionId: d,
							profileName: i,
							subredditName: o
						})), !Object(D.S)(n())) return void Object(A.a)(t, n());
					let c;
					if (o ? (c = Object(N.C)(n(), {
							subredditName: o
						}), await t(Object(l.a)({
							subredditName: o
						}))) : i && (c = Object(P.k)(n(), {
							profileName: i
						})), a.source_id) await t(((e, t) => async (n, s) => {
						const {
							subredditName: r,
							profileName: o
						} = e, i = [];
						let a;
						r ? a = Object(N.I)(s(), r) : o && (a = Object(D.ob)(s(), {
							userName: o
						})), a && i.push(n(Object(v.b)(a, t))), i.push(n(Object(p.P)(t))), await Promise.all(i);
						const d = Object(T.f)(s(), {
							postId: t
						});
						n(Object(b.m)({
							postId: t,
							postTitle: d ? d.title : ""
						}))
					})(e.params, a.source_id));
					else if (d) {
						const o = Object(_.q)(n(), {
							collectionId: d
						});
						c && o && o.subredditId === c.id || t(Object(s.c)(Object(r.a)(e.url, ["collection"])))
					}
					t(m.n({
						title: M(n())
					}))
				}
		},
		"./src/reddit/actions/pages/postDraft.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "PAGE_PENDING", (function() {
				return p
			})), n.d(t, "PAGE_LOADED", (function() {
				return b
			})), n.d(t, "PAGE_FAILED", (function() {
				return f
			})), n.d(t, "pagePending", (function() {
				return h
			})), n.d(t, "pageLoaded", (function() {
				return g
			})), n.d(t, "pageFailed", (function() {
				return v
			})), n.d(t, "postDraftPageDataRequested", (function() {
				return x
			})), n.d(t, "postDraftRequested", (function() {
				return E
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/makePostDraftPageKey/index.ts"),
				o = n("./src/reddit/actions/profile/index.ts"),
				i = n("./src/config.ts"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				l = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				u = n("./src/reddit/endpoints/post/draft/helpers.ts"),
				m = n("./src/reddit/helpers/timeApiRoute/index.ts");
			const p = "POST_DRAFT__PAGE_PENDING",
				b = "POST_DRAFT__PAGE_LOADED",
				f = "POST_DRAFT__PAGE_FAILED",
				h = Object(s.a)(p),
				g = Object(s.a)(b),
				v = Object(s.a)(f),
				x = e => async (t, n, s) => {
					const {
						draftId: p,
						profileName: b
					} = e, f = Object(r.a)(e), h = n(), x = h.creations.api.page.pending[f], E = h.creations.api.page.fetched[f], O = h.creations.api.page.error[f];
					if (x || E && !O || !p) return;
					t(o.d(b));
					const C = await Object(m.a)("postDraft", () => ((e, t, n) => Object(d.a)(e, {
						endpoint: Object(c.a)(Object(l.a)(`${i.a.gatewayUrl}/desktopapi/v1/draftpreviewpage/${n}/${t}`)),
						method: a.ob.GET
					}))(s.apiContext(), p, b));
					if (C.ok) {
						const e = C.body;
						e.drafts[p].kind = Object(u.b)(e.drafts[p].kind), t(g({
							...e,
							key: f
						}))
					} else t(v({
						error: C.error,
						key: f
					}))
				}, E = e => async (t, n, s) => {
					await t(x(e.params))
				}
		},
		"./src/reddit/actions/pages/profilePosts.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "PROFILE_POSTS_PENDING", (function() {
				return se
			})), n.d(t, "PROFILE_POSTS_LOADED", (function() {
				return re
			})), n.d(t, "PROFILE_POSTS_FAILED", (function() {
				return oe
			})), n.d(t, "profilePostsPending", (function() {
				return ie
			})), n.d(t, "profilePostsLoaded", (function() {
				return ae
			})), n.d(t, "profilePostsFailed", (function() {
				return de
			})), n.d(t, "profilePostsRequested", (function() {
				return ce
			})), n.d(t, "MORE_POSTS_PENDING", (function() {
				return le
			})), n.d(t, "MORE_POSTS_LOADED", (function() {
				return ue
			})), n.d(t, "MORE_POSTS_FAILED", (function() {
				return me
			})), n.d(t, "morePostsPending", (function() {
				return pe
			})), n.d(t, "morePostsLoaded", (function() {
				return be
			})), n.d(t, "morePostsFailed", (function() {
				return fe
			})), n.d(t, "morePostsRequested", (function() {
				return he
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/pick.js"),
				r = n.n(s),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makeListingKey/index.ts"),
				a = n("./src/lib/safeGet/index.ts"),
				d = n("./src/reddit/actions/contentGate.ts"),
				c = n("./src/reddit/actions/externalAccount.ts"),
				l = n("./src/reddit/actions/moderatingSubreddits.ts"),
				u = n("./src/reddit/actions/pages/profileShared.ts"),
				m = n("./src/reddit/actions/pinnedPost.ts"),
				p = n("./src/reddit/actions/platform.ts"),
				b = n("./src/reddit/actions/profile/index.ts"),
				f = n("./src/reddit/actions/subreddit.ts"),
				h = n("./src/reddit/constants/errors.ts"),
				g = n("./src/reddit/constants/parameters.ts"),
				v = n("./src/reddit/contexts/PageLayer/index.tsx"),
				x = n("./src/lib/makeGqlRequest/index.ts"),
				E = n("./src/redditGQL/operations/ProfileFeed.json"),
				O = n("./src/redditGQL/types.ts");
			const C = async (e, t) => await Object(x.a)(e, {
				...E,
				variables: t
			}), A = (e, t) => {
				if (!e) return;
				const n = e.toUpperCase();
				return t.includes(n) ? n : void 0
			}, y = e => {
				let {
					username: t,
					profileSort: n,
					filter: s,
					timeSort: r,
					loadMoreData: o,
					shouldUseGqlCursor: i
				} = e;
				const a = {
					username: t,
					sort: A(n, Object.values(O.N)),
					range: A(r, Object.values(O.M)),
					filter: s
				};
				if (o) {
					const {
						token: e
					} = o;
					a.after = i ? e : btoa(e)
				}
				return a
			};
			var j = n("./src/config.ts"),
				I = n("./src/lib/addAllowQuarantinedParam/index.ts"),
				k = n("./src/lib/constants/index.ts"),
				_ = n("./src/lib/makeApiRequest/index.ts"),
				S = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				w = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const T = (e, t, n) => Object(_.a)(e, {
				data: n,
				endpoint: Object(S.a)(Object(I.a)(Object(w.a)(`${j.a.gatewayUrl}/desktopapi/v1/user/${t}/posts`))),
				method: k.ob.GET
			}).then(e => "pinned" in e.body ? e : "postIds" in e.body ? {
				...e,
				body: {
					...e.body,
					pinned: e.body.postIds.filter(t => e.body.posts[t] && e.body.posts[t].isPinned).reverse()
				}
			} : e);
			var P = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				N = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				D = n("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				M = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				R = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				L = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				B = n("./src/reddit/models/Post/index.ts");
			const F = (e, t) => {
				if (!Object(B.l)(t) && !Object(B.n)(t)) return null;
				if (e.posts[t.id]) return t.id;
				const n = Object(M.f)(t),
					{
						id: s
					} = n;
				e.posts[s] = n;
				const {
					crosspostRoot: r
				} = t;
				r && r.type === B.a.Post && r.postInfo && F(e, r.postInfo);
				const {
					authorFlair: o
				} = t;
				if (o) {
					const t = n.belongsTo.id;
					e.authorFlair[t] || (e.authorFlair[t] = {}), e.authorFlair[t][n.author] = Object(N.a)(o)[0]
				}
				if (Object(B.l)(t)) {
					const {
						profile: n
					} = t;
					e.profiles[n.id] || (e.profiles[n.id] = Object(R.a)(n))
				} else if (Object(B.n)(t)) {
					const {
						subreddit: n
					} = t;
					e.subreddits[n.id] || (e.subreddits[n.id] = Object(L.a)(n)), e.postFlair[n.id] || (e.postFlair[n.id] = Object(D.a)(n))
				}
				return s
			};
			var U = n("./src/reddit/models/Comment/index.ts"),
				H = (e, t) => {
					var n, s, r;
					const o = {
							authorFlair: {},
							pinned: [],
							postIds: [],
							posts: {},
							postFlair: {},
							profiles: {},
							subreddits: {},
							token: ""
						},
						i = null === (n = null == e ? void 0 : e.redditorInfoByName) || void 0 === n ? void 0 : n.elements;
					if (!i) return o;
					const {
						edges: a
					} = i;
					for (const {
							node: c
						} of a) {
						if (!c || c.__typename === U.d.Comment) continue;
						const e = F(o, c);
						e && o.postIds.push(e)
					}
					const d = null === (r = null === (s = null == e ? void 0 : e.redditorInfoByName) || void 0 === s ? void 0 : s.profile) || void 0 === r ? void 0 : r.stickyPosts;
					if (d && (o.pinned = d.map(e => e.id)), t) o.token = i.pageInfo.endCursor || "";
					else {
						const {
							postIds: e
						} = o, t = e[e.length - 1];
						t && (o.token = t)
					}
					return o
				},
				G = n("./node_modules/@sentry/minimal/esm/index.js"),
				Q = n("./node_modules/deep-diff/index.js"),
				q = n("./src/lib/env/index.ts");
			const W = new Set(["authorFlair.cssClass", "posts.adSupplementaryText", "posts.allAwardings", "posts.approvedAtUTC", "posts.approvedBy", "posts.attributionInfo", "posts.audioRoom", "posts.bannedAtUTC", "posts.bannedBy", "posts.collapsedBecauseCrowdControl", "posts.ignoreReports", "posts.isApproved", "posts.isAuthorPremium", "posts.isEligibleForLinkedPosts", "posts.isEligibleForQASchema", "posts.isFollowed", "posts.isPinned", "posts.isReactAllowed", "posts.isRemoved", "posts.isSpam", "posts.lastAuthorModNote", "posts.modQueueTriggers", "posts.modReportsDismissed", "posts.pollData", "posts.predictionTournament", "posts.previewComments", "posts.modReports", "posts.numReports", "posts.reactedFrom", "posts.removedBy", "posts.removedByCategory", "posts.topAwardedType", "posts.userReports", "posts.userReportsDismissed", "posts.modReasonBy", "subreddits.answerableQuestions", "subreddits.freeFormReports", "subreddits.isSubscribed", "authorFlair.richtext", "authorFlair.text", "posts.collectionIds", "posts.liveCommentsWebsocket", "posts.thumbnail.url", "posts.discussionType", "posts.eventsOnRender", "posts.flair", "posts.gildings", "posts.media", "posts.goldCount", "posts.sendReplies", "posts.score", "posts.sendReplies", "posts.source.url", "posts.source.outboundUrl", "posts.source.outboundUrlCreated", "posts.source.outboundUrlExpiration", "profiles.acceptFollowers", "profiles.communityIcon", "profiles.icon.url", "posts.upvoteRatio", "subreddits.acceptFollowers", "subreddits.allowChatPostCreation", "subreddits.communityIcon", "subreddits.icon.url", "subreddits.isChatPostFeatureEnabled", "subreddits.primaryColor", "subreddits.subscribers"]),
				z = (e, t) => {
					const n = {},
						s = {};
					Object.keys(e).forEach(r => {
						const o = e[r] || {},
							i = t[r] || {};
						n[r] = {}, s[r] = 0, Object.keys(o).forEach(e => {
							const t = o[e],
								a = i[e],
								d = Object(Q.diff)(t, a, {
									prefilter: (e, t) => W.has(`${r}.${e.length?`${e.join(".")}.`:""}${t}`) || W.has(`${r}.${t}`),
									normalize: (e, t, n, s) => n || s ? [n, s] : [n, n]
								});
							s[r] = d ? s[r] + d.length : (null == s ? void 0 : s[r]) || 0, d && (n[r][e] = {
								gatewayThing: t,
								gqlThing: a,
								diffResult: d
							})
						})
					});
					const r = Object.keys(s).reduce((e, t) => e += s[t], 0);
					return {
						allDiffs: n,
						issueCounts: s,
						totalIssues: r
					}
				};

			function V(e) {
				let {
					gatewayResponse: t,
					normalizedGqlResponse: n,
					rawGqlResponse: s
				} = e;
				if (Object(q.a)()) {
					console.group("GQL Profiles Shadowtest"), console.groupCollapsed("raw gql response"), console.log(s), console.groupEnd(), console.groupCollapsed("normalized gql response"), console.log(n), console.groupEnd(), console.groupCollapsed("gateway response"), console.log(t), console.groupEnd();
					const {
						allDiffs: e,
						issueCounts: r,
						totalIssues: o
					} = z(t, n);
					console.groupCollapsed(`diff: ${o} issues`), console.log("lhs = gateway\nrhs = gql");
					for (const t in e) {
						if (console.groupCollapsed(`${t}: ${r[t]} issues`), r[t] > 0)
							for (const n in e[t]) {
								const s = e[t][n].diffResult;
								console.groupCollapsed(`${n}: ${s.length||0} issues`), console.log(s), console.log({
									gql: e[t][n].gqlThing,
									gateway: e[t][n].gatewayThing
								}), console.groupEnd()
							}
						console.groupEnd()
					}
					console.groupEnd()
				}
				if (Object(q.b)()) {
					const {
						allDiffs: e,
						issueCounts: s,
						totalIssues: r
					} = z(t, n);
					if (r <= 0) return;
					G.l(t => {
						t.setExtra("info", {
							allDiffs: e,
							issueCounts: s,
							totalIssues: r
						}), t.setExtra("bypassSampling", !0), G.d("GQL Profiles Shadowtest Diff")
					})
				}
			}
			var K = n("./src/reddit/helpers/post/index.ts"),
				Y = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				J = n("./src/reddit/models/User/index.ts"),
				X = n("./src/reddit/constants/experiments.ts"),
				Z = n("./src/reddit/helpers/chooseVariant/index.ts");
			const $ = e => {
					return Object(Z.c)(e, {
						experimentEligibilitySelector: Z.a,
						experimentName: X.Cc
					}) === X.Yd
				},
				ee = e => {
					return Object(Z.c)(e, {
						experimentEligibilitySelector: Z.a,
						experimentName: X.Dc
					}) === X.Yd
				};
			var te = n("./src/reddit/selectors/listings.ts"),
				ne = n("./src/reddit/selectors/profile.ts");
			const se = "PAGE__PROFILE_POSTS_PENDING",
				re = "PAGE__PROFILE_POSTS_LOADED",
				oe = "PAGE__PROFILE_POSTS_FAILED",
				ie = Object(o.a)(se),
				ae = Object(o.a)(re),
				de = Object(o.a)(oe),
				ce = e => async (t, n, s) => {
					var o, x, E;
					const {
						queryParams: A,
						params: j
					} = e, {
						sort: I,
						t: k
					} = Object(u.b)(A), {
						profileName: _
					} = j, S = Object(i.a)(`u_${_}`, I, A), w = n(), N = Object(a.a)(w.listings.postOrder.ids, S), D = Object(te.c)(w, {
						listingKey: S
					}), M = Object(te.d)(w, {
						listingKey: S
					});
					if (await t(b.d(_)), M || N && !D) {
						if (N) {
							const e = Object(ne.s)(n(), {
								profileName: _
							});
							t(p.n({
								title: e
							}))
						}
						return
					}
					t(ie({
						key: S
					}));
					const R = ee(w);
					let L, B, F;
					if (R) {
						const e = y({
							username: _,
							profileSort: I,
							filter: O.T.Posts,
							timeSort: Object(P.a)(I, k),
							shouldUseGqlCursor: !0
						});
						B = null === (E = null === (x = null === (o = null == (L = await Object(Y.a)("profilePosts", () => C(s.gqlContext(), e))) ? void 0 : L.body) || void 0 === o ? void 0 : o.data) || void 0 === x ? void 0 : x.redditorInfoByName) || void 0 === E ? void 0 : E.__typename
					} else {
						const t = {
							...r()(e.queryParams, [...g.p, ...g.o, g.l]),
							layout: Object(v.U)(w, {}).toLowerCase(),
							sort: I,
							t: Object(P.a)(I, k)
						};
						L = await Object(Y.a)("profilePosts", () => T(s.apiContext(), _, t))
					}
					if (!L.ok || R && B !== J.c.AvailableRedditor) return t(de({
						account: !R && L.body.data ? L.body.data.account : null,
						error: L.body.reason ? {
							type: L.body.reason
						} : L.error,
						key: S
					})), L.body.reason === h.a.DeletedProfile || B === J.c.DeletedRedditor ? t(Object(d.v)({
						profileName: _
					})) : B === J.c.UnavailableRedditor ? t(Object(d.B)({
						profileName: _
					})) : R && !B && t(Object(d.p)({
						profileName: _
					})), void t(p.o(L.status));
					if (R) {
						const {
							data: e
						} = L.body;
						F = H(e, !0)
					} else F = L.body, await Object(K.a)(s.gqlContext, F.posts).then(e => F.posts = e);
					if (!R && $(w)) {
						const e = y({
								username: _,
								profileSort: I,
								filter: O.T.Posts
							}),
							t = await C(s.gqlContext(), e);
						if (t.ok && t.body) {
							const {
								data: e
							} = t.body, n = H(e);
							V({
								gatewayResponse: {
									authorFlair: F.authorFlair,
									pinned: F.pinned,
									postIds: F.postIds,
									posts: F.posts,
									postFlair: F.postFlair,
									profiles: F.profiles,
									subreddits: F.subreddits,
									token: F.token
								},
								normalizedGqlResponse: n,
								rawGqlResponse: e
							})
						}
					}
					t(ae({
						key: S,
						meta: n().meta,
						...F
					}));
					const U = Object(ne.o)(n(), _),
						{
							pinned: G
						} = F;
					t(Object(m.h)({
						profileId: U,
						pinned: G
					})), await Promise.all([t(Object(u.c)(_)), t(Object(f.q)()), t(Object(l.b)()), t(c.o(_))])
				}, le = "PROFILE_POSTS__MORE_POSTS_PENDING", ue = "PROFILE_POSTS__MORE_POSTS_LOADED", me = "PROFILE_POSTS__MORE_POSTS_FAILED", pe = Object(o.a)(le), be = Object(o.a)(ue), fe = Object(o.a)(me), he = () => async (e, t, n) => {
					let {
						apiContext: s,
						gqlContext: o
					} = n;
					const a = t(),
						{
							currentPage: d
						} = a.platform;
					if (!d || !d.routeMatch) return;
					const {
						queryParams: c,
						params: l
					} = d.routeMatch.match, {
						sort: m,
						t: p
					} = Object(u.b)(c), {
						profileName: b
					} = l, f = Object(i.a)(`u_${b}`, m, c), h = Object(te.g)(a, {
						listingKey: f
					});
					if (!h) return;
					const x = Object(te.d)(a, {
							listingKey: f
						}),
						E = Object(te.e)(a, {
							listingKey: f,
							token: h.token
						});
					if (x || E) return;
					e(pe({
						key: f,
						fetchedToken: h.token
					}));
					const A = ee(a);
					let j, I;
					if (A) {
						const e = y({
							username: b,
							profileSort: m,
							filter: O.T.Posts,
							timeSort: Object(P.a)(m, p),
							loadMoreData: h,
							shouldUseGqlCursor: !0
						});
						j = await C(o(), e)
					} else {
						const e = {
							after: h.token,
							dist: h.dist,
							sort: m,
							t: p,
							...r()(c, g.p),
							layout: Object(v.U)(a, {}).toLowerCase()
						};
						j = await T(s(), b, e)
					}
					if (!j.ok) return void e(fe({
						account: !A && j.body.data ? j.body.data.account : null,
						error: j.error,
						fetchedToken: h.token,
						key: f
					}));
					if (A) {
						const {
							data: e
						} = j.body;
						I = H(e, !0)
					} else I = j.body, await Object(K.a)(o, I.posts).then(e => I.posts = e);
					const k = a.listings.postOrder.ids[f],
						_ = I.postIds || [],
						S = {
							...I,
							postIds: _.filter(e => !k || !k.includes(e))
						};
					if ($(a)) {
						const e = y({
								username: b,
								profileSort: m,
								filter: O.T.Posts,
								loadMoreData: h
							}),
							t = await C(o(), e);
						if (t.ok && t.body) {
							const {
								data: e
							} = t.body, n = H(e);
							V({
								gatewayResponse: {
									authorFlair: S.authorFlair,
									pinned: S.pinned,
									postIds: S.postIds,
									posts: S.posts,
									postFlair: S.postFlair,
									profiles: S.profiles,
									subreddits: S.subreddits,
									token: S.token
								},
								normalizedGqlResponse: n,
								rawGqlResponse: e
							})
						}
					}
					e(be({
						fetchedToken: h.token,
						key: f,
						meta: a.meta,
						...S
					})), await e(Object(u.c)(b))
				}
		},
		"./src/reddit/actions/pages/shared.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				r = n("./src/reddit/helpers/routeKey/index.ts"),
				o = n("./src/reddit/helpers/trackers/screenview.ts"),
				i = n("./src/telemetry/index.ts"),
				a = n("./src/telemetry/models/Timer.ts");
			const d = () => async (e, t) => {
				const n = t(),
					{
						currentPage: d
					} = n.platform;
				if (!d) return;
				const c = d.routeMatch,
					l = Object(s.a)(n),
					u = Object(r.b)(c, n, l);
				u && i.c.has(u) && Object(o.j)(c, n, a.TimerType.InApp, i.c.end(u))
			}
		},
		"./src/reddit/actions/pages/subreddit/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "isGQLSubredditPageExtra", (function() {
				return yt
			})), n.d(t, "handleSubredditPageApiError", (function() {
				return jt
			})), n.d(t, "SUBREDDIT_PENDING", (function() {
				return It
			})), n.d(t, "SUBREDDIT_LOADED", (function() {
				return kt
			})), n.d(t, "SUBREDDIT_FAILED", (function() {
				return _t
			})), n.d(t, "subredditPending", (function() {
				return St
			})), n.d(t, "subredditLoaded", (function() {
				return wt
			})), n.d(t, "subredditFailed", (function() {
				return Tt
			})), n.d(t, "addAdditionalInformationForAGatewayResponse", (function() {
				return Pt
			})), n.d(t, "subredditDataRequested", (function() {
				return Dt
			})), n.d(t, "subredditDataFirstChunkRequested", (function() {
				return Mt
			})), n.d(t, "makeSubredditPageKey", (function() {
				return Lt
			})), n.d(t, "subredditRequested", (function() {
				return Bt
			})), n.d(t, "SUBREDDIT_INVALIDATE_LISTING", (function() {
				return Ft
			})), n.d(t, "subredditInvalidateListing", (function() {
				return Ut
			})), n.d(t, "maybeShowPrivateSubredditModal", (function() {
				return Ht
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeRequest/index.ts"),
				o = n("./node_modules/lodash/find.js"),
				i = n.n(o),
				a = n("./node_modules/lodash/pick.js"),
				d = n.n(a),
				c = n("./node_modules/react-router-redux/es/index.js"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/lib/countrySites/index.ts"),
				m = n("./src/lib/isAdHocMultireddit/index.ts"),
				p = n("./src/lib/isFakeSubreddit/index.ts"),
				b = n("./src/lib/makeActionCreator/index.ts"),
				f = n("./src/lib/makeListingKey/index.ts"),
				h = n("./src/lib/makeSearchKey/index.ts"),
				g = n("./src/lib/pageTitle/index.ts"),
				v = n("./src/lib/pageTitle/helpers.ts"),
				x = n("./src/lib/performanceTimings/index.tsx"),
				E = n("./src/lib/safeGet/index.ts"),
				O = n("./src/reddit/actions/ads/index.ts"),
				C = n("./src/reddit/actions/communityFlairs/index.ts"),
				A = n("./src/reddit/actions/contentGate.ts"),
				y = n("./src/reddit/actions/discoveryUnit.ts"),
				j = n("./src/reddit/actions/economics/helpers/async.ts"),
				I = n("./src/reddit/actions/economics/predictions/index.ts"),
				k = n("./src/reddit/actions/externalAccount.ts"),
				_ = n("./src/reddit/actions/gold/achievementFlairs.ts"),
				S = n("./src/reddit/actions/gold/customEmojis.ts"),
				w = n("./src/reddit/actions/meta.ts"),
				T = n("./src/reddit/actions/modQueueTriggers/index.ts"),
				P = n("./src/reddit/actions/nsfwBlocking/async.tsx"),
				N = n("./src/reddit/actions/onboarding/index.ts"),
				D = n("./src/reddit/actions/pages/search/index.ts"),
				M = n("./src/reddit/actions/platform.ts"),
				R = n("./src/reddit/actions/seo/linksModule.ts"),
				L = n("./src/reddit/actions/seo/topicLinks.ts"),
				B = n("./src/lib/makeGqlRequest/index.ts"),
				F = (n("./src/redditGQL/operations/SubredditInfo.json"), n("./src/reddit/helpers/graphql/normalizeSubredditLinksFromGql/index.ts")),
				U = n("./src/reddit/helpers/graphql/normalizeSubredditTopicLinksFromGql/index.ts"),
				H = (n("./src/reddit/selectors/seo/linksModule.ts"), n("./src/reddit/selectors/seo/topicLinks.ts"), n("./src/reddit/selectors/subreddit.ts")),
				G = n("./src/reddit/selectors/widgets.ts");
			const Q = (e, t) => async (n, s) => {
				const r = s(),
					o = Object(H.X)(r, {
						subredditId: e
					}),
					i = Object(G.j)(r, {
						subredditId: e
					});
				o.isNSFW || (null == i ? void 0 : i.length) > 0 && i.some(e => "community-list" === e) || n(Object(R.e)({
					id: e,
					data: t
				}))
			}, q = (e, t) => async n => {
				t && n(Object(L.b)({
					id: e,
					data: t
				}))
			};
			var W = n("./src/reddit/actions/structuredStyles/index.ts"),
				z = n("./src/reddit/actions/subreddit.ts"),
				V = n("./src/reddit/actions/toaster.ts"),
				K = n("./src/reddit/helpers/localStorage/index.ts"),
				Y = n("./src/reddit/models/Subreddit/index.ts"),
				J = n("./src/reddit/models/Toast/index.ts"),
				X = n("./src/reddit/routes/postCreation/constants.ts"),
				Z = n("./src/reddit/selectors/isModeratorOfSubreddit.ts"),
				$ = n("./src/reddit/selectors/platform.ts"),
				ee = n("./src/reddit/selectors/user.ts");
			const te = () => async (e, t, n) => {
				const s = t(),
					r = Object($.e)(s);
				if (!r || r.type !== Y.g.Public) return;
				const o = r.name,
					i = Object($.m)(s),
					a = Object(H.z)(s, {
						subredditName: o
					});
				if (!a) return;
				const {
					activity7Day: d
				} = a, l = !!d && d >= 51 && d <= 100, u = !o || Object(p.a)(o), m = i && i.urlParams.subredditName === o, b = Object(ee.S)(s), f = Object(Z.c)(s, {
					subredditId: Object(H.I)(s, o)
				});
				if (u || m || Object(K.J)() || !l || !b || f) return;
				const h = Object(G.d)(t(), {
					subredditName: o
				});
				if (!h || !h.currentlyViewingCount) return;
				const g = (24 * h.currentlyViewingCount * 7).toString(),
					v = g[0].padEnd(g.length, "0");
				e(Object(V.f)({
					buttonAction: async () => e(Object(c.b)(`/r/${o}${X.b}`)),
					buttonText: "Create Post",
					duration: -1,
					id: "createPostCta",
					kind: J.b.Modal,
					name: "createPostCta",
					secondButtonAction: async () => Object(K.Mb)(),
					secondButtonText: "Dismiss",
					text: `There have been over ${v} visits to r/${o} in the past week. Create a new post and start the next conversation.`
				}))
			};
			var ne = n("./src/reddit/actions/subreddit/questions.ts"),
				se = n("./src/reddit/actions/subredditModeration/modUserNotes.ts"),
				re = n("./src/reddit/actions/subredditSettings.ts"),
				oe = n("./src/reddit/actions/tags/index.ts"),
				ie = n("./src/reddit/actions/userFlair/userFlair.ts"),
				ae = n("./src/reddit/constants/history.ts"),
				de = n("./src/reddit/constants/page.ts"),
				ce = n("./src/reddit/constants/parameters.ts"),
				le = n("./src/reddit/constants/postLayout.ts"),
				ue = n("./src/reddit/contexts/PageLayer/index.tsx"),
				me = n("./src/reddit/endpoints/gold/topAwarded.ts"),
				pe = n("./src/reddit/endpoints/governance/posts.ts"),
				be = n("./src/reddit/endpoints/page/subredditPage.ts"),
				fe = n("./src/lib/base64/index.ts"),
				he = n("./src/reddit/constants/experiments.ts"),
				ge = n("./src/reddit/constants/graphql.ts"),
				ve = n("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				xe = n("./src/reddit/selectors/adsSignals.ts"),
				Ee = n("./src/reddit/selectors/experiments/communityChat.ts"),
				Oe = n("./src/reddit/selectors/experiments/communityDirectoryBacklinks/index.ts"),
				Ce = n("./src/reddit/selectors/experiments/onboarding.ts"),
				Ae = n("./src/redditGQL/operations/SubredditPageExtra.json");
			var ye = n("./src/reddit/endpoints/profile/info.ts"),
				je = n("./src/reddit/helpers/canonicalUrls.ts"),
				Ie = n("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				ke = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				_e = n("./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts");

			function Se(e) {
				let {
					econLeaderboards: t,
					identity: n,
					trendingSubreddits: s
				} = e;
				const r = t.topAwardedPosts.map(e => e.post).filter(e => !e.removedBy && !e.isNsfw);
				return Object(_e.b)(r, s, n)
			}
			var we = n("./src/reddit/helpers/graphql/normalizeChannelsFromGql/index.ts"),
				Te = n("./src/reddit/helpers/graphql/normalizeInterestTopicsFromGql/index.ts"),
				Pe = n("./src/reddit/helpers/graphql/normalizeSubredditRulesFromGql/index.ts"),
				Ne = n("./src/reddit/helpers/post/index.ts"),
				De = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				Me = n("./src/reddit/helpers/trackers/feed.ts"),
				Re = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				Le = n("./src/reddit/models/RichTextJson/index.ts"),
				Be = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				Fe = n("./src/reddit/constants/modals.ts"),
				Ue = n("./src/reddit/selectors/communityFlairs.ts"),
				He = n("./src/reddit/selectors/experiments/countrySites.ts"),
				Ge = n("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				Qe = n("./src/reddit/selectors/experiments/nsfwBlockingExperiment.ts"),
				qe = n("./src/reddit/selectors/experiments/topPosts.ts"),
				We = n("./src/reddit/selectors/inlineSubredditEditing.ts"),
				ze = n("./src/reddit/selectors/moderatorPermissions.ts"),
				Ve = n("./src/reddit/selectors/multireddit.ts"),
				Ke = n("./src/reddit/selectors/posts.ts"),
				Ye = n("./src/reddit/endpoints/page/popularFeed.ts"),
				Je = n("./src/lib/initializeClient/installReducer.ts"),
				Xe = n("./src/reddit/reducers/features/modUserNotes/index.ts"),
				Ze = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				$e = n("./src/reddit/actions/communityChat/index.ts"),
				et = n("./src/reddit/actions/modal.ts"),
				tt = n("./src/reddit/components/CommunityChat/utils.ts"),
				nt = n("./src/reddit/endpoints/devPlatform/index.ts"),
				st = n("./src/reddit/helpers/addSupplementaryTextInfoToAdPosts.ts"),
				rt = n("./node_modules/@sentry/minimal/esm/index.js"),
				ot = n("./src/lib/env/index.ts"),
				it = n("./node_modules/lodash/cloneDeep.js"),
				at = n.n(it);
			const dt = new Set(["authorFlair.cssClass", "posts.adSupplementaryText", "posts.allAwardings", "posts.approvedAtUTC", "posts.approvedBy", "posts.attributionInfo", "posts.audioRoom", "posts.bannedAtUTC", "posts.bannedBy", "posts.collapsedBecauseCrowdControl", "posts.ignoreReports", "posts.isApproved", "posts.isAuthorPremium", "posts.isEligibleForLinkedPosts", "posts.isEligibleForQASchema", "posts.isFollowed", "posts.isPinned", "posts.isReactAllowed", "posts.isRemoved", "posts.isSpam", "posts.lastAuthorModNote", "posts.modQueueTriggers", "posts.modReportsDismissed", "posts.pollData", "posts.predictionTournament", "posts.previewComments", "posts.modReports", "posts.numReports", "posts.reactedFrom", "posts.removedBy", "posts.removedByCategory", "posts.topAwardedType", "posts.userReports", "posts.userReportsDismissed", "posts.modReasonBy", "subreddits.answerableQuestions", "subreddits.freeFormReports", "subreddits.isSubscribed", "authorFlair.richtext", "authorFlair.text", "posts.collectionIds", "posts.liveCommentsWebsocket", "posts.thumbnail.url", "posts.discussionType", "posts.eventsOnRender", "posts.flair", "posts.gildings", "posts.media", "posts.goldCount", "posts.sendReplies", "posts.score", "posts.sendReplies", "posts.source.url", "posts.source.outboundUrl", "posts.source.outboundUrlCreated", "posts.source.outboundUrlExpiration", "profiles.acceptFollowers", "profiles.communityIcon", "profiles.icon.url", "posts.upvoteRatio", "subreddits.acceptFollowers", "subreddits.allowChatPostCreation", "subreddits.communityIcon", "subreddits.icon.url", "subreddits.isChatPostFeatureEnabled", "subreddits.primaryColor", "subreddits.subscribers"]),
				ct = new Set(["posts.upvoteRatio", "posts.score", "posts.sendReplies", "posts.media", "posts.eventsOnRender", "posts.liveCommentsWebsocket", "posts.flair", "posts.source.outboundUrl", "posts.source.outboundUrlCreated", "posts.source.outboundUrlExpiration", "posts.numComments", "posts.thumbnail.url", "posts.contentCategories", "subreddits.acceptFollowers", "subreddits.communityIcon", "subreddits.primaryColor", "subreddits.isChatPostFeatureEnabled", "subreddits.allowChatPostCreation", "subreddits.icon.url", "subreddits.subscribers", "token", "recentPostIds", "trendingSubredditIds", "posts.gildings", "posts.goldCount", "listingSort", "posts.discussionType", "posts.topAwardedType", "posts.allAwardings", "posts.audioRoom", "posts.approvedAtUTC", "posts.approvedBy", "posts.bannedAtUTC", "posts.bannedBy", "posts.ignoreReports", "posts.isApproved", "posts.isAuthorPremium", "posts.isEligibleForQASchema", "posts.isFollowed", "posts.isPinned", "posts.isRemoved", "posts.isSpam", "posts.isReactAllowed", "posts.reactedFrom", "posts.attributionInfo", "posts.modReports", "posts.numReports", "posts.pollData", "posts.predictionTournament", "posts.previewComments", "posts.removedBy", "posts.removedByCategory", "posts.userReports", "subreddits.answerableQuestions", "subreddits.freeFormReports", "subreddits.isSubscribed", "subreddits.devPlatformMetadata"]);
			var lt = n("./node_modules/deep-diff/index.js");
			const ut = (e, t) => {
					e.postIds = t, e.posts = t.reduce((t, n) => (e.posts[n] && (t[n] = e.posts[n]), t), {}), e.postInstances = t.reduce((t, n) => (e.postInstances[n] && (t[n] = e.postInstances[n]), t), {});
					const n = Object.keys(e.posts).map(t => e.posts[t].belongsTo.id);
					e.subreddits = n.reduce((t, n) => (e.subreddits[n] && (t[n] = e.subreddits[n]), t), {}), e.postFlair = n.reduce((t, n) => (e.postFlair[n] && (t[n] = e.postFlair[n]), t), {})
				},
				mt = (e, t, n) => {
					const s = {},
						r = {};
					Object.keys(e).forEach(o => {
						if (!n.has(o)) {
							const i = e[o] || {},
								a = t[o] || {};
							s[o] = {}, r[o] = 0, Object.keys(i).forEach(e => {
								const t = i[e],
									d = a[e],
									c = Object(lt.diff)(t, d, {
										prefilter: (e, t) => (e => {
											let {
												ignorePaths: t,
												path: n,
												k: s,
												key: r
											} = e;
											return t.has(`${s}.${n.length?`${n.join(".")}.`:""}${r}`) || t.has(`${s}.${r}`)
										})({
											ignorePaths: n,
											path: e,
											k: o,
											key: t
										}),
										normalize: (e, t, n, s) => n || s ? [n, s] : [n, n]
									});
								r[o] = c ? r[o] + c.length : (null == r ? void 0 : r[o]) || 0, c && (s[o][e] = {
									gatewayThing: t,
									gqlThing: d,
									diffResult: c
								})
							})
						}
					});
					const o = Object.keys(r).reduce((e, t) => e += r[t], 0);
					return {
						allDiffs: s,
						issueCounts: r,
						totalIssues: o
					}
				},
				pt = (e, t) => {
					const n = ((e, t) => {
							const n = e.postIds;
							return t.postIds.reduce((e, t, s) => {
								const r = n.findIndex(e => t === e);
								return r > 0 ? e.found[t] = {
									gateway: r,
									gql: s
								} : e.notFound.push(t), e
							}, {
								found: {},
								notFound: []
							})
						})(e, t),
						s = Object.keys(n.found).sort();
					return ut(e, s), ut(t, s), {
						gatewayResponse: e,
						normalizedGqlResponse: t,
						positionDiffs: n
					}
				},
				bt = e => {
					let {
						gatewayResponse: t,
						normalizedGqlResponse: n,
						ignorePaths: s,
						normalizeFunction: r
					} = e;
					if (r) {
						const e = r(t, n);
						return {
							...mt(e.gatewayResponse, e.normalizedGqlResponse, s),
							positionDiffs: e.positionDiffs
						}
					}
					return mt(t, n, s)
				};
			var ft = n("./src/reddit/helpers/locales.ts"),
				ht = n("./src/reddit/selectors/experiments/cnc/index.ts"),
				gt = n("./src/reddit/selectors/experiments/devPlatform.ts"),
				vt = n("./src/reddit/selectors/experiments/popularGqlMigration.ts"),
				xt = n("./node_modules/reselect/es/index.js"),
				Et = n("./src/reddit/helpers/chooseVariant/index.ts");
			const Ot = Object(xt.a)(e => Object(Et.c)(e, {
				experimentEligibilitySelector: Et.a,
				experimentName: he.xc
			}), e => e === he.Yd);
			var Ct = n("./src/reddit/selectors/features/communityChat/index.ts"),
				At = n("./src/reddit/selectors/meta.ts");

			function yt(e) {
				return Boolean(e && e.subredditInfoByName)
			}
			Object(Je.a)({
				features: {
					modUserNotes: Xe.a
				}
			});
			const jt = (e, t, n) => async (s, r, o) => {
				if (!e.ok && e.body && (e => !!e.reason)(e.body)) {
					const {
						body: {
							data: r,
							reason: o
						}
					} = e, i = r ? r.account : void 0, a = r && r.features || void 0, d = t ? t.toLowerCase() : "";
					if (404 === e.status)
						if (o === Y.f.NotFoundSubreddit) s(A.u({
							account: i,
							features: a,
							subredditName: d
						}));
						else if (o === Y.f.BannedSubreddit) {
						const e = r.banTitle || (null == n ? void 0 : n.banTitle),
							t = r.banMessage || (null == n ? void 0 : n.banMessage);
						s(A.s({
							banMessage: t,
							banTitle: e,
							account: i,
							features: a,
							subredditName: d
						}))
					}
					if (451 === e.status && s(A.t({
							account: i,
							features: a,
							subredditName: d
						})), 403 === e.status)
						if (o === Y.f.GoldSubreddit) s(A.x({
							account: i,
							features: a,
							subredditName: d
						}));
						else if (o === Y.f.PrivateSubreddit) s(A.y({
						account: i,
						features: a,
						subredditDescription: r.description || "",
						subredditName: d,
						isContributorRequestsDisabled: !!r.isContributorRequestsDisabled,
						isContributorRequestTimestamp: r.isContributorRequestTimestamp ? parseInt(r.isContributorRequestTimestamp, 10) : void 0,
						subredditId: r.id
					}));
					else if (o === Y.f.QuarantinedSubreddit) {
						const e = !r || void 0 === r.quarantineRequiresEmailOptin || r.quarantineRequiresEmailOptin;
						s(A.A({
							account: i,
							features: a,
							subredditName: d,
							quarantineRequiresEmail: e,
							quarantineMessage: r.quarantineMessage,
							quarantineMessageHtml: r.quarantineMessageHtml || "",
							quarantineMessageRTJson: r.quarantineMessageRTJson || Le.i
						}))
					} else if (o === Y.f.GatedSubreddit) {
						const {
							interstitialWarningMessage: e,
							interstitialWarningMessageHtml: t,
							interstitialWarningMessageRTJson: n
						} = r;
						s(A.w({
							account: i,
							features: a,
							subredditName: d,
							interstitialWarningMessage: e,
							interstitialWarningMessageHtml: t,
							interstitialWarningMessageRTJson: n
						}))
					}
				}
			}, It = "PAGE__SUBREDDIT_PENDING", kt = "PAGE__SUBREDDIT_LOADED", _t = "PAGE__SUBREDDIT_FAILED", St = Object(b.a)(It), wt = Object(b.a)(kt), Tt = Object(b.a)(_t), Pt = async e => {
				let {
					subredditName: t,
					subredditsResponse: n,
					extraArgs: s,
					state: r,
					isPopular: o,
					isInGqlSubredditExperiment: i,
					isInDevPlatformExperiment: a
				} = e;
				if (!n || i) return n;
				const d = {
						...n
					},
					c = o ? null : Object(Ne.a)(s.gqlContext, d.posts),
					l = Object(st.a)(s.apiContext(), d.posts, r),
					u = a ? Object(nt.a)(s.gqlContext(), {
						subredditName: t
					}) : null;
				let m, p, b;
				if ([m, p, b] = await Promise.all([c, l, u]), m && (d.posts = m), p && (d.posts = p), b) {
					const e = Nt(d.subreddits, t);
					e && d.subreddits[e] && (d.subreddits[e].devPlatformMetadata = b)
				}
				return d
			}, Nt = (e, t) => {
				var n;
				return null === (n = i()(e, e => (null == e ? void 0 : e.name.toLowerCase()) === t.toLowerCase())) || void 0 === n ? void 0 : n.id
			}, Dt = (e, t, n, o) => async (i, a, d) => {
				var c, u, m, b, f, h, g, v, A, y, P, D, R, L, G, W, K, X, Z, te, de, ce, je, Ie, ke, _e, Ne, Re, Le, Fe;
				const Ue = a(),
					Qe = Object(ee.R)(Ue) || Object(ee.S)(Ue);
				if (Object(E.a)(Ue.listings.postOrder.api.pending, e)) return;
				const qe = null === (u = null === (c = Object($.b)(Ue)) || void 0 === c ? void 0 : c.routeMatch) || void 0 === u ? void 0 : u.route.chunk,
					{
						currentPage: Ve
					} = Ue.platform,
					{
						countryCode: Ke,
						languageCode: Je
					} = (null == Ve ? void 0 : Ve.urlParams) || {},
					Xe = Object(p.a)(t, {
						countryCode: Ke,
						languageCode: Je
					}),
					et = Object(p.c)(t, {
						countryCode: Ke,
						languageCode: Je
					}),
					tt = (Object(p.b)(t, {
						countryCode: Ke,
						languageCode: Je
					}) || et) && Ue.posts.recent.length ? {
						...n,
						recentPostIds: Ue.posts.recent
					} : n;
				tt.layout = le.e[Object(ue.U)(Ue, {})], et && (tt.forceGeopopular = !0), i(St({
					key: e
				}));
				const nt = !Xe && Object($.l)(Ue) && Object(Ge.b)(Ue),
					st = et && (Object(vt.a)(Ue) || Object(vt.b)(Ue)),
					it = et && Ot(Ue);
				let lt, ut;
				if ((st || it) && (lt = Object(x.i)(() => Object(Ye.a)(d.gqlContext(), Object(be.c)(Ue, t, tt, !0)), {
						name: nt ? "fetchSubredditPageFromGql" : "fetchSubredditPage",
						page: qe,
						isLoggedIn: Qe
					})), st) ut = lt;
				else if (n.sort === l.bb.AWARDED && et) ut = Object(me.a)(d.gqlContext(), {
					top: 0,
					includeListingMetadata: !0
				}).then(e => {
					const t = e.body;
					return {
						...e,
						body: Se(t.data)
					}
				});
				else {
					const e = nt ? () => Object(be.b)(d.gqlContext(), Object(be.c)(Ue, t, tt, !0), Qe) : () => Object(be.a)(d.apiContext(), t, tt);
					ut = Object(x.i)(e, {
						name: nt ? "fetchSubredditPageFromGql" : "fetchSubredditPage",
						page: qe,
						isLoggedIn: Qe
					})
				}
				const mt = Object(H.W)(a(), {
						subredditId: Object(H.I)(a(), t)
					}).length > 0,
					ht = Object(x.i)(() => (async function(e, t) {
						return Object(B.a)(e, {
							...Ae,
							variables: t
						})
					})(d.gqlContext(), ((e, t) => {
						let {
							after: n,
							isMobile: s,
							subredditName: r,
							isFake: o,
							isLoggedIn: i,
							layout: a,
							limit: d,
							hasRules: c,
							sort: l,
							t: u
						} = t;
						var m, p;
						const b = Object(Ce.j)(e),
							f = !!b && !Object(he.Kg)(b) && (o || b === he.pb.Community),
							{
								adsSeenCount: h,
								totalPostsSeenCount: g,
								sessionStartTime: v
							} = Object(xe.a)(e),
							x = Object(Oe.c)(e),
							E = Object(Ee.b)(e) || Object(Ee.a)(e),
							O = {
								subredditName: r,
								isFake: o,
								sort: l,
								adContext: {
									layout: a ? a.toUpperCase() : ge.a.Card,
									clientSignalSessionData: {
										adsSeenCount: h,
										totalPostsSeenCount: g,
										sessionStartTime: v
									}
								},
								includeAchievementFlairs: !o,
								includeCustomEmojis: !o,
								includeIdentity: i,
								includeInterestTopics: f,
								includeQuestions: i && !o,
								includeRules: !o && !c,
								includeRedditorKarma: i && !(null === (p = null === (m = e.user.account) || void 0 === m ? void 0 : m.karma) || void 0 === p ? void 0 : p.total),
								includeSubredditLinks: !i,
								includeSubredditRankings: x,
								includeSubredditChannels: E,
								includeTopicLinks: !i
							};
						return l && (O.sort = l.toUpperCase()), u && (O.range = u.toUpperCase()), s ? O.pageSize = Object(ve.a)(a) : d && (O.pageSize = d), n && (O.after = Object(fe.a)(n)), O
					})(Ue, {
						after: n.after,
						isLoggedIn: Qe,
						subredditName: t,
						hasRules: mt,
						isFake: Xe,
						isMobile: n.isMobile,
						layout: n.layout,
						limit: n.limit,
						sort: n.sort,
						t: n.t
					})), {
						name: "fetchSubredditPageExtra",
						page: qe,
						isLoggedIn: Qe
					}),
					xt = Object(Ze.a)();
				let Et, Ct;
				nt ? Et = await ut : [Et, Ct] = await Promise.all([ut, ht]);
				const It = Ct && Object(r.c)(Ct) ? Ct.body.data : null;
				if (it) {
					const e = await lt;
					! function(e) {
						let {
							gatewayResponse: t,
							normalizedGqlResponse: n,
							rawGqlResponse: s,
							ignorePaths: r = dt,
							normalizeFunction: o
						} = e;
						const i = at()(t),
							a = at()(n);
						if (Object(ot.a)()) {
							console.group("GQL Popular Shadowtest"), console.groupCollapsed("raw gql response"), console.log(s), console.groupEnd(), console.groupCollapsed("normalized gql response"), console.log(n), console.groupEnd(), console.groupCollapsed("gateway response"), console.log(t), console.groupEnd();
							const e = bt({
									gatewayResponse: i,
									normalizedGqlResponse: a,
									ignorePaths: r,
									normalizeFunction: o
								}),
								{
									allDiffs: d,
									issueCounts: c,
									totalIssues: l
								} = e;
							e.positionDiffs && (console.groupCollapsed("position errors"), console.log(e.positionDiffs), console.groupEnd()), console.groupCollapsed(`diff: ${l} issues`), console.log("lhs = gateway\nrhs = gql");
							for (const t in d) {
								if (console.groupCollapsed(`${t}: ${c[t]} issues`), c[t] > 0)
									for (const e in d[t]) {
										const n = d[t][e].diffResult;
										console.groupCollapsed(`${e}: ${n.length||0} issues`), console.log(n), console.log({
											gql: d[t][e].gqlThing,
											gateway: d[t][e].gatewayThing
										}), console.groupEnd()
									}
								console.groupEnd()
							}
							console.groupEnd(), console.groupEnd()
						}
						if (Object(ot.b)() || Object(ot.c)()) {
							const e = bt({
								gatewayResponse: i,
								normalizedGqlResponse: a,
								ignorePaths: r,
								normalizeFunction: o
							});
							rt.l(t => {
								t.setExtra("info", e), t.setExtra("bypassSampling", !0), rt.d("GQL Popular Shadowtest Diff")
							})
						}
					}({
						gatewayResponse: Et.body,
						normalizedGqlResponse: e.body,
						rawGqlResponse: e,
						ignorePaths: ct,
						normalizeFunction: pt
					})
				}
				let kt = Et.body;
				const _t = (null == kt ? void 0 : kt.subreddits) ? Nt(kt.subreddits, t) : null,
					Mt = Object(gt.a)(Ue);
				kt = await Pt({
					subredditName: t,
					subredditsResponse: kt,
					isInGqlSubredditExperiment: nt,
					extraArgs: d,
					isPopular: et,
					state: Ue,
					isInDevPlatformExperiment: Mt
				}), i(M.o(Et.status));
				const Rt = `error-${e}`,
					Lt = Xe || _t;
				if (Et.ok && Lt || et && kt) {
					if ((et || !Xe && _t) && kt.geoFilter && i(Object(w.k)(kt.geoFilter)), !Xe && _t && !Object(Y.m)(null == It ? void 0 : It.subredditInfoByName)) {
						let e, t;
						e = nt ? kt : Object(_.b)(null == It ? void 0 : It.subredditInfoByName), Object(_.a)(i, _t, e), t = nt ? kt : Object(S.b)(null == It ? void 0 : It.subredditInfoByName), Object(S.a)(i, _t, t);
						const n = (null === (b = null === (m = null == kt ? void 0 : kt.subredditAboutInfo) || void 0 === m ? void 0 : m[_t]) || void 0 === b ? void 0 : b.detectedLanguage) || (null === (f = null == It ? void 0 : It.subredditInfoByName) || void 0 === f ? void 0 : f.detectedLanguage);
						Object(At.d)(Ue) && n && Object(He.f)(Ue) && await Object(ft.a)(n, i), kt.subredditAboutInfo[_t].detectedLanguage = n, nt ? i(Object(I.n)(_t, kt.predictionTournaments || [])) : (null == It ? void 0 : It.subredditInfoByName) && i(Object(I.n)(_t, It.subredditInfoByName.predictionTournaments || []))
					}
					let s;
					const r = null === (h = kt.postIds) || void 0 === h ? void 0 : h.filter(e => !!kt.posts[e].isMeta);
					if (r && r.length && _t) {
						const e = Object(x.i)(() => Object(pe.a)(d.apiContext(), _t, r), {
								name: "getGovernanceData",
								page: qe,
								isLoggedIn: Qe
							}),
							t = await e;
						t.ok && (s = t.body)
					}
					if (_t && !Object(Y.m)(null == It ? void 0 : It.subredditInfoByName)) {
						const e = (null === (v = null === (g = null == kt ? void 0 : kt.subredditAboutInfo) || void 0 === g ? void 0 : g[_t]) || void 0 === v ? void 0 : v.isEligibleForContentBlocking) || (null === (A = null == It ? void 0 : It.subredditInfoByName) || void 0 === A ? void 0 : A.isEligibleForContentBlocking);
						kt.subredditAboutInfo[_t].isEligibleForContentBlocking = e;
						const t = (null === (P = null === (y = null == kt ? void 0 : kt.subredditAboutInfo) || void 0 === y ? void 0 : y[_t]) || void 0 === P ? void 0 : P.isMediaInCommentsSettingShown) || (null === (D = null == It ? void 0 : It.subredditInfoByName) || void 0 === D ? void 0 : D.isMediaInCommentsSettingShown);
						kt.subredditAboutInfo[_t].isMediaInCommentsSettingShown = t;
						const n = nt ? null : null === (R = null == It ? void 0 : It.subredditInfoByName) || void 0 === R ? void 0 : R.directoryRankings;
						n && (kt.subredditAboutInfo[_t].directoryRankings = n)
					}
					if (_t) {
						const e = () => {
								var e;
								if (!Object(Y.m)(null == It ? void 0 : It.subredditInfoByName)) {
									const t = null === (e = null == It ? void 0 : It.subredditInfoByName) || void 0 === e ? void 0 : e.channels;
									if (t) return Object(we.a)(t)
								}
								return {
									channels: {},
									channelIds: []
								}
							},
							{
								channels: t,
								channelIds: n
							} = nt ? kt : e();
						t && n && i(Object($e.d)({
							subredditId: _t,
							channels: t,
							channelIds: n
						}))
					}
					if (It) {
						const e = null === (G = null === (L = It.identity) || void 0 === L ? void 0 : L.redditor) || void 0 === G ? void 0 : G.karma,
							t = {
								karma: {
									...(null === (W = Ue.user.account) || void 0 === W ? void 0 : W.karma) || ye.a,
									...e
								}
							};
						kt.account && Object.assign(kt.account, t)
					}
					if (yt(It) && function(e, t) {
							var n, s, r, o, i;
							if (!Object(Y.m)(null == t ? void 0 : t.subredditInfoByName))
								for (const a of (null === (s = null === (n = t.subredditInfoByName) || void 0 === n ? void 0 : n.elements) || void 0 === s ? void 0 : s.edges) || []) {
									const t = null == a ? void 0 : a.node,
										n = t.id,
										s = null !== (o = null === (r = null == t ? void 0 : t.media) || void 0 === r ? void 0 : r.packagedMedia) && void 0 !== o ? o : void 0,
										d = null === (i = e.posts[n]) || void 0 === i ? void 0 : i.media;
									d && "video" === d.type && (d.packagedMedia = s)
								}
						}(kt, It), _t && !Object(Y.m)(null == It ? void 0 : It.subredditInfoByName)) {
						let e;
						nt ? e = null === (K = kt.subredditAboutInfo[_t]) || void 0 === K ? void 0 : K.notificationLevel : yt(It) && (e = null === (X = It.subredditInfoByName) || void 0 === X ? void 0 : X.notificationLevel), kt.subredditAboutInfo[_t].notificationLevel = e
					}
					if (_t && !Object(Y.m)(null == It ? void 0 : It.subredditInfoByName)) {
						let e;
						yt(It) && (e = null === (Z = It.subredditInfoByName) || void 0 === Z ? void 0 : Z.isMuted), nt && (e = null === (te = kt.subredditAboutInfo[_t]) || void 0 === te ? void 0 : te.isMuted), kt.subredditAboutInfo[_t].isMuted = e
					}
					const c = null === (de = kt.subredditPermissions) || void 0 === de ? void 0 : de.posts;
					!nt && c && i(Object(T.a)({
						postIds: kt.postIds
					}));
					let l = null == kt ? void 0 : kt.interestTopicRecommendations;
					if (!l && (null == It ? void 0 : It.interestTopics)) {
						const e = Object(Te.a)(It.interestTopics);
						e.topics.length && (l = {
							interests: e,
							index: 5
						})
					}
					l && i(Object(N.subredditInterestTopicsLoaded)({
						interestTopicRecommendations: l
					})), i(wt({
						key: e,
						meta: Ue.meta,
						governance: s,
						correlationId: xt,
						...kt,
						postIds: kt.postIds
					}));
					const u = null === (je = null === (ce = Object($.b)(Ue)) || void 0 === ce ? void 0 : ce.locationState) || void 0 === je ? void 0 : je[ae.b.FeedLoadReason];
					if (Object(Me.b)(n.isRefresh ? ae.a.UserRefresh : null != u ? u : ae.a.InitialLoad)(a()), !Xe) {
						const e = Object(H.I)(a(), t);
						nt && kt.subredditRules ? i(z.t({
							rules: {
								rules: kt.subredditRules
							},
							subredditId: e
						})) : (null === (Ie = null == It ? void 0 : It.subreddit) || void 0 === Ie ? void 0 : Ie.rules) && i(z.t({
							rules: Object(Pe.a)(It.subreddit.rules),
							subredditId: e
						}));
						const n = Object(ze.g)(a(), {
								subredditId: e
							}),
							s = null === (ke = null == kt ? void 0 : kt.userFlair) || void 0 === ke ? void 0 : ke[e];
						nt && e && (n || (null == s ? void 0 : s.applied) || (null === (_e = null == s ? void 0 : s.permissions) || void 0 === _e ? void 0 : _e.canUserChange)) && i(Object(ie.fetchUserFlairFromGql)(e, t));
						const r = Object(C.c)(kt.posts, e),
							o = Object(C.b)(kt.structuredStyles),
							d = (o ? Object(C.d)(o) : []).concat(r);
						i(Object(C.a)(d, e))
					}
					if (o && i(V.g(Rt)), i(Object(O.b)(Be.a.SUBREDDIT)), i(Object(k.p)()), _t && !Object(Y.m)(null == It ? void 0 : It.subredditInfoByName)) {
						let e, n, s;
						if (nt ? (e = kt.questions, n = kt.subredditLinks, s = kt.subredditTopicLinks) : (e = null == It ? void 0 : It.subredditInfoByName, n = Object(F.a)({
								data: {
									subredditInfoById: null == It ? void 0 : It.subredditInfoByName
								}
							}), s = Object(U.a)({
								data: {
									subredditInfoById: null == It ? void 0 : It.subredditInfoByName
								}
							})), Object(ne.a)(i, _t, e), i(Q(_t, n)), i(q(_t, s)), !nt && (null === (Re = null === (Ne = null == It ? void 0 : It.subredditInfoByName) || void 0 === Ne ? void 0 : Ne.elements) || void 0 === Re ? void 0 : Re.edges)) {
							const e = (null === (Fe = null === (Le = null == It ? void 0 : It.subredditInfoByName) || void 0 === Le ? void 0 : Le.elements) || void 0 === Fe ? void 0 : Fe.edges).map(e => {
								var t, n;
								return null === (n = null === (t = e.node) || void 0 === t ? void 0 : t.moderationInfo) || void 0 === n ? void 0 : n.lastAuthorModNote
							});
							i(Object(se.e)({
								subredditId: _t,
								nodes: e
							}))
						} else if (nt && (null == kt ? void 0 : kt.postIds)) {
							const e = kt.postIds.map(e => null == kt ? void 0 : kt.posts[e].lastAuthorModNote);
							e && i(Object(se.e)({
								subredditId: _t,
								nodes: e
							}))
						}
						const r = [Object(x.i)(() => i(Object(j.a)({
							subredditId: _t,
							postIds: kt.postIds,
							skip: ["subscription"]
						})), {
							name: "fetchAllEconomicsData",
							page: qe,
							isLoggedIn: Qe
						})];
						if (Object(We.a)(a(), {
								subredditId: _t
							})) {
							const e = Object(x.i)(() => i(Object(re.h)(t, _t)), {
									name: "subredditSettingsRequested",
									isLoggedIn: Qe,
									page: qe
								}),
								n = Object(x.i)(() => i(Object(oe.g)(_t, De.a.idCard)), {
									name: "subredditTagsRequested",
									isLoggedIn: Qe,
									page: qe
								});
							r.push(e, n)
						}
						await Promise.all(r)
					}
				} else {
					const r = Et.ok ? void 0 : Et.error;
					if (Object(Me.a)(r ? `${Et.status||"000"}: ${r.type}` : "000: UNKNOWN_ERROR")(a()), 403 === Et.status || 404 === Et.status || 451 === Et.status) return void(Object(Y.m)(null == It ? void 0 : It.subredditInfoByName) ? i(jt(Et, t, null == It ? void 0 : It.subredditInfoByName)) : i(jt(Et, t)));
					i(Tt({
						error: !Et.ok && Et.error || {
							type: l.K.NOT_FOUND_ERROR
						},
						key: e,
						...kt
					})), o && i(V.f({
						id: Rt,
						kind: J.b.Error,
						text: s.fbt._("Sorry, we couldn't load posts for this page.", null, {
							hk: "CvZvm"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "3gV6S0"
						}),
						buttonAction: Dt(e, t, n, o)
					}))
				}
			}, Mt = (e, t, n) => async (s, r) => {
				const o = r(),
					i = Object(f.a)(e, t.sort, t);
				Object(Ke.y)(o, {
					listingKey: i
				}).length > 0 || await s(Dt(i, e, t, n))
			}, Rt = (e, t, n, s) => {
				const r = Object(He.b)(e);
				if (Object(p.a)(t, {
						countryCode: n,
						languageCode: s
					})) {
					if (Object(m.a)(t)) {
						return Object(Ve.a)(e, {
							listingName: t
						}).displayText
					}
					if (r) return Object(v.a)(e, Object(g.f)(t.toLowerCase()));
					switch (t.toLowerCase()) {
						case de.d.Popular:
							return "r/popular";
						case de.d.All:
							return "r/all"
					}
				}
				const o = Object(H.ab)(e, {
					subredditName: t
				});
				if (r) {
					const n = Object(H.z)(e, {
							subredditName: t
						}),
						s = n && n.detectedLanguage;
					return Object(v.a)(e, o, s)
				}
				return o
			}, Lt = (e, t, n, s) => s ? Object(h.b)(e.subredditName, void 0, s) : Object(f.a)(e.subredditName, t, n), Bt = (e, t) => async (n, r) => {
				var o, i, a;
				const {
					countryCode: m,
					languageCode: b,
					channelId: g
				} = e.params, v = Object(u.e)(e.params), {
					styling: A
				} = e.queryParams, j = r(), I = Object(Ie.a)(e.params, j), _ = () => {
					if (g) n(Object($e.f)(g));
					else {
						const e = Object(Ct.c)(r(), F);
						if (e) {
							const t = Object(tt.a)(e.id, e.name);
							n(Object(c.c)(t)), n(Object($e.f)(e.id))
						}
					}
				};
				if ("Popular" === v) return void n(Object(c.c)(e.url.replace("r/Popular", "r/popular")));
				if ("All" === v) return void n(Object(c.c)(e.url.replace("r/All", "r/all")));
				const S = Object(h.d)(e.queryParams, Object(ee.mb)(j)),
					w = Lt({
						subredditName: v,
						countryCode: m,
						languageCode: b
					}, I, e.queryParams, S),
					T = I,
					N = Object(E.a)(j.listings.postOrder.api.error, w),
					R = Object(E.a)(j.listings.postOrder.api.pending, w);
				let L = !!Object(E.a)(j.listings.postOrder.ids, w);
				const B = Object(E.a)(j.listings.postOrder.listingSort, w);
				B && B.hasChanged && (L = !1);
				let F = Object(H.I)(j, v);
				const U = (e, t) => "true" === A && ((e, t) => Object(ze.b)(Re.c.config)(e, {
						subredditId: t
					}) || Object(ze.b)(Re.c.flair)(e, {
						subredditId: t
					}))(e, t),
					G = ce.H in e.queryParams && e.queryParams[ce.H].toUpperCase() || "",
					Q = G in l.oc && l.oc[G];
				if (R || L && !N && !t) {
					if (U(j, F) && n(W.i(F)), L) {
						const t = Rt(r(), v, m, b);
						n(M.n({
							title: t
						})), (null === (o = j.listings.postOrder.correlationIds) || void 0 === o ? void 0 : o[w]) && n(M.p({
							correlationId: j.listings.postOrder.correlationIds[w]
						})), Object(je.g)(r(), n, e), window.addEventListener("load", () => {
							n(Object(k.p)())
						}), n(Ht(v)), j.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
							n(Object(O.b)(Be.a.SUBREDDIT))
						}), n(te())
					}
					return Object(Qe.e)(r()) && n(Object(P.a)()), void(Object(Ee.d)(j) ? _() : Object(Ee.d)(j) || !g || Object(Ct.g)(j) || (n(Object($e.e)(!0)), n(V.f({
						kind: J.b.Error,
						text: s.fbt._("This experience is currently only available on the iOS and Android apps.", null, {
							hk: "3V9YHz"
						})
					}))))
				}
				n(y.g());
				const q = null === (a = null === (i = Object($.b)(j)) || void 0 === i ? void 0 : i.routeMatch) || void 0 === a ? void 0 : a.route.chunk,
					z = Object(ee.S)(r());
				if (S) {
					const e = Object(x.i)(() => n(Object(D.d)({
						key: w,
						options: S,
						subredditName: v
					})), {
						name: "searchDataRequested",
						isLoggedIn: z,
						page: q
					});
					await e
				} else {
					const t = {
						...d()(e.queryParams, [...ce.p, ...ce.o, ce.l]),
						sort: T,
						t: Object(ke.a)(T, Q)
					};
					await n(Dt(w, v, t, !0))
				}
				const K = j.platform.currentPage,
					Y = Object(qe.d)(j, {
						pageLayer: K
					});
				if (Object(qe.a)(Y) || Object(qe.b)(Y) || Object(qe.c)(Y)) {
					const e = Object(f.a)(v, l.bb.TOP, {
							t: l.oc.WEEK
						}),
						t = {
							sort: l.bb.TOP,
							t: l.oc.WEEK
						};
					await n(Dt(e, v, t, !1))
				}
				if (Object(Qe.e)(r()) && n(Object(P.a)()), F = F || Object(H.I)(r(), v), !Object(Ue.a)(j, F) && !Object(p.a)(v, {
						countryCode: m,
						languageCode: b
					})) {
					const e = Object(x.i)(() => n(Object(C.e)(v)), {
						name: "getTopCommunityFlair",
						page: q,
						isLoggedIn: z
					});
					await e
				}
				U(r(), F) && n(W.i(F)), Object(je.g)(r(), n, e);
				const X = Rt(r(), v);
				n(M.n({
					title: X
				})), n(te()), Object(Ee.d)(j) && _()
			}, Ft = "PAGE__SUBREDDIT_INVALIDATE_LISTING", Ut = Object(b.a)(Ft), Ht = e => async (t, n, s) => {
				const r = n(),
					o = Object(ee.h)(r, e);
				if (null == o ? void 0 : o.privateSubreddit) {
					Object(ht.c)(r) && t(Object(et.h)(Fe.a.PRIVATE_COMMUNITY_ACCESS_MODAL, {
						subredditName: e,
						subredditDescription: o.subredditDescription || "",
						isContributorRequestsDisabled: !!o.isContributorRequestsDisabled
					}))
				}
			}
		},
		"./src/reddit/actions/pages/subredditWiki/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "PAGE__SUBREDDIT_WIKI_PAGE_PENDING",
				r = "PAGE__SUBREDDIT_WIKI_PAGE_LOADED",
				o = "PAGE__SUBREDDIT_WIKI_PAGE_FAILED"
		},
		"./src/reddit/actions/pages/subredditWiki/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "subredditWikiDataPending", (function() {
				return qe
			})), n.d(t, "subredditWikiDataLoaded", (function() {
				return We
			})), n.d(t, "subredditWikiDataFailed", (function() {
				return ze
			})), n.d(t, "fetchSubredditWikiData", (function() {
				return Ye
			})), n.d(t, "handleWikiRedirects", (function() {
				return Xe
			})), n.d(t, "subredditWikDataRequested", (function() {
				return Ze
			})), n.d(t, "subredditWikiPageRequested", (function() {
				return $e
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/isEmpty.js"),
				o = n.n(r),
				i = n("./node_modules/react-router-redux/es/index.js"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/lib/makeListingKey/index.ts"),
				l = n("./src/config.ts"),
				u = n("./src/reddit/actions/platform.ts"),
				m = n("./src/reddit/helpers/path/index.ts");
			var p = n("./src/reddit/actions/ads/index.ts"),
				b = n("./src/reddit/actions/pages/subreddit/index.ts"),
				f = n("./src/reddit/actions/pages/subredditWiki/constants.ts"),
				h = n("./src/reddit/actions/toaster.ts"),
				g = n("./src/reddit/actions/wiki/wikiBannedContributors/index.ts"),
				v = n("./src/reddit/actions/wiki/wikiContributors/index.ts"),
				x = n("./src/lib/makeGqlRequest/index.ts"),
				E = n("./src/reddit/helpers/wiki/wikiRevision.ts"),
				O = n("./src/redditGQL/operations/WikiComparisonDiff.json");
			var C = n("./src/reddit/helpers/wiki/makeComparisonDiffKey.ts"),
				A = n("./src/reddit/selectors/subredditWiki.ts");
			const y = Object(d.a)("WIKI_DIFF_PENDING"),
				j = Object(d.a)("WIKI_DIFF_LOADED"),
				I = Object(d.a)("WIKI_DIFF_FAILED"),
				k = e => async (t, n, s) => {
					const r = n(),
						o = Object(C.a)(e),
						i = Object(A.i)(r, {
							key: o
						});
					if (i && (i.pending || !i.error)) return !0;
					const d = {
						key: o
					};
					t(y(d));
					const c = await ((e, t) => Object(x.a)(e, {
						...O,
						variables: {
							...t,
							comparisonRevisionId: Object(E.b)(t.comparisonRevisionId),
							revisionId: Object(E.b)(t.revisionId)
						}
					}))(s.gqlContext(), e);
					let l = null,
						u = "";
					if (c.ok) {
						const e = c.body,
							t = e.data.subreddit && e.data.subreddit.wiki,
							n = t && t.page && t.page.revisionComparisonDiffHtml;
						n ? u = n : l = {
							type: a.K.NOT_FOUND_ERROR
						}
					} else l = c.error || {
						type: a.K.UNKNOWN_ERROR
					};
					return t(l ? I({
						...d,
						error: l
					}) : j({
						...d,
						htmlDiff: u
					})), !l
				};
			var _ = n("./src/reddit/actions/wiki/wikiPageSettings/index.tsx"),
				S = n("./src/reddit/actions/wiki/wikiRevisions/index.ts"),
				w = n("./src/reddit/constants/parameters.ts"),
				T = n("./src/reddit/constants/wiki.ts"),
				P = n("./src/reddit/endpoints/page/subredditWiki.ts"),
				N = n("./src/reddit/helpers/brandSafety/index.ts"),
				D = n("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				M = n("./src/reddit/models/Toast/index.ts"),
				R = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				L = n("./src/reddit/routes/subredditWiki/normalizeWikiUrl.ts"),
				B = n("./src/reddit/selectors/subreddit.ts"),
				F = n("./src/lib/initializeClient/installReducer.ts"),
				U = n("./node_modules/redux/es/redux.js");
			const H = {};
			var G = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : H,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "WIKI_DIFF_LOADED": {
						const {
							key: n,
							htmlDiff: s
						} = t.payload;
						return {
							...e,
							[n]: {
								htmlDiff: s
							}
						}
					}
					case "WIKI_DIFF_PENDING": {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								pending: !0
							}
						}
					}
					case "WIKI_DIFF_FAILED": {
						const {
							key: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								pending: !1,
								error: s
							}
						}
					}
					default:
						return e
				}
			};
			const Q = {};
			var q = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Q,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.b:
							const n = t.payload,
								{
									subredditWiki: s,
									options: r
								} = n,
								o = s && s.directory;
							if (!o) return e;
							const {
								subredditName: i
							} = r;
							return {
								...e, [i.toLowerCase()]: o
							};
						default:
							return e
					}
				},
				W = n("./src/reddit/actions/wiki/wikiRevisions/constants.ts");
			const z = {};
			var V = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : z,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.b: {
							const {
								subredditWiki: n,
								pageKey: s
							} = t.payload, {
								page: r
							} = n;
							return s && r ? {
								...e,
								[s]: r
							} : e
						}
						case W.a: {
							const {
								pageKey: n,
								page: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				K = n("./src/reddit/actions/wiki/wikiPageSettings/constants.ts");
			const Y = {};
			var J = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Y,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case K.c: {
							const {
								settings: n,
								pageKey: s
							} = t.payload;
							return n ? {
								...e,
								[s]: n
							} : e
						}
						case K.d: {
							const {
								isVisible: n,
								editPermissions: s,
								pageKey: r
							} = t.payload, o = e[r];
							return o ? {
								...e,
								[r]: {
									...o,
									isVisible: n,
									editPermissions: s
								}
							} : e
						}
						case K.b: {
							const {
								editorsInfo: n,
								afterToken: s,
								pageKey: r
							} = t.payload, o = e[r];
							if (!o) return e;
							const i = [...o.editorsInfo, ...n];
							return {
								...e,
								[r]: {
									...o,
									editorsInfo: i,
									afterToken: s
								}
							}
						}
						case K.a: {
							const {
								username: n,
								pageKey: s
							} = t.payload, r = e[s];
							if (!r) return e;
							const o = r.editorsInfo.filter(e => e.username !== n);
							return {
								...e,
								[s]: {
									...r,
									editorsInfo: o
								}
							}
						}
						default:
							return e
					}
				},
				X = n("./src/lib/omitKey/index.ts");
			const Z = {};
			var $ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Z,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case W.b: {
						const {
							key: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					case W.d:
					case W.c: {
						const {
							key: n
						} = t.payload;
						return Object(X.a)(e, n)
					}
					default:
						return e
				}
			};
			const ee = {};
			var te = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ee,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case W.d:
						case W.b:
						case W.c: {
							const {
								key: n
							} = t.payload, s = t.type === W.d;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				ne = Object(U.c)({
					error: $,
					pending: te
				}),
				se = n("./src/reddit/actions/wiki/wikiEditing/constants.ts");
			const re = {};
			var oe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : re,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case W.c: {
						const {
							key: n,
							options: s,
							pageInfo: r,
							revisionsIds: o
						} = t.payload, i = e[n], a = s.after && i ? [...i.ids, ...o] : o;
						return {
							...e,
							[n]: {
								ids: a,
								pageInfo: r
							}
						}
					}
					case W.a: {
						const {
							page: {
								revision: n
							},
							pageRevisionsListingKey: s,
							recentRevisionsListingKey: r
						} = t.payload, o = e[s];
						return o && n ? {
							...Object(X.a)(e, r),
							[s]: {
								...o,
								ids: [n.id, ...o.ids]
							}
						} : e
					}
					case se.a: {
						const {
							pageRevisionsListingKey: n,
							recentRevisionsListingKey: s
						} = t.payload, r = {
							...e
						};
						return delete r[n], delete r[s], r
					}
					default:
						return e
				}
			};
			const ie = {};
			var ae = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ie,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.b: {
							const {
								subredditWiki: {
									page: n
								}
							} = t.payload, s = n && n.revision;
							return s && !e[s.id] ? {
								...e,
								[s.id]: s
							} : e
						}
						case W.c: {
							const {
								revisions: n
							} = t.payload;
							return {
								...e,
								...n
							}
						}
						case W.a: {
							const {
								page: n
							} = t.payload, s = n.revision;
							return s ? {
								...e,
								[s.id]: s
							} : e
						}
						case W.e: {
							const {
								revisionId: n,
								isHidden: s
							} = t.payload, r = e[n];
							return r ? {
								...e,
								[n]: {
									...r,
									isHidden: s
								}
							} : e
						}
						default:
							return e
					}
				},
				de = Object(U.c)({
					api: ne,
					listings: oe,
					models: ae
				}),
				ce = n("./src/reddit/actions/wiki/wikiBannedContributors/constants.ts");
			const le = {};
			var ue = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : le,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.c:
					case ce.a: {
						const {
							subredditName: n,
							afterToken: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					default:
						return e
				}
			};
			const me = {};
			var pe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : me,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.b: {
						const {
							subredditName: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					case ce.d:
					case ce.c: {
						const {
							subredditName: n
						} = t.payload;
						return Object(X.a)(e, n)
					}
					default:
						return e
				}
			};
			const be = {};
			var fe = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : be,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.d:
						case ce.c:
						case ce.b: {
							const {
								subredditName: n
							} = t.payload, s = t.type === ce.d;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				he = Object(U.c)({
					error: pe,
					pending: fe
				});
			const ge = {};
			var ve = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ge,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.c:
						case ce.a: {
							const {
								subredditName: n,
								bannedContributors: s
							} = t.payload;
							return {
								...e,
								[n]: {
									...e[n],
									...s
								}
							}
						}
						case ce.e: {
							const {
								subredditName: n,
								bannedContributor: s
							} = t.payload;
							return {
								...e,
								[n]: {
									...e[n],
									...s
								}
							}
						}
						case ce.f: {
							const {
								subredditName: n,
								userId: s
							} = t.payload, r = Object(X.a)(e[n], s);
							return {
								...e,
								[n]: r
							}
						}
						default:
							return e
					}
				},
				xe = n("./node_modules/lodash/uniq.js"),
				Ee = n.n(xe);
			const Oe = {};
			var Ce = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Oe,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.c:
						case ce.a: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: Ee()([...e[n] || [], ...s])
							}
						}
						case ce.e: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: Ee()([...s, ...e[n] || []])
							}
						}
						case ce.f: {
							const {
								subredditName: n,
								userId: s
							} = t.payload;
							return {
								...e,
								[n]: (e[n] || []).filter(e => e !== s)
							}
						}
						default:
							return e
					}
				},
				Ae = Object(U.c)({
					afterToken: ue,
					api: he,
					models: ve,
					userOrder: Ce
				});
			const ye = {};
			var je = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ye,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.g: {
							const {
								subredditName: n,
								bannedContributor: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				Ie = Object(U.c)({
					listing: Ae,
					search: je
				}),
				ke = n("./src/reddit/actions/wiki/wikiContributors/constants.ts");
			const _e = {};
			var Se = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _e,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ke.c:
					case ke.a: {
						const {
							subredditName: n,
							afterToken: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					default:
						return e
				}
			};
			const we = {};
			var Te = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : we,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ke.b: {
						const {
							subredditName: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					case ke.d:
					case ke.c: {
						const {
							subredditName: n
						} = t.payload;
						return Object(X.a)(e, n)
					}
					default:
						return e
				}
			};
			const Pe = {};
			var Ne = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pe,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ke.d:
						case ke.c:
						case ke.b: {
							const {
								subredditName: n
							} = t.payload, s = t.type === ke.d;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				De = Object(U.c)({
					error: Te,
					pending: Ne
				});
			const Me = {};
			var Re = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Me,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ke.c:
					case ke.a: {
						const {
							subredditName: n,
							contributors: s
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								...s
							}
						}
					}
					case ke.e: {
						const {
							subredditName: n,
							contributor: s
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								...s
							}
						}
					}
					case ke.f: {
						const {
							subredditName: n,
							userId: s
						} = t.payload, r = Object(X.a)(e[n], s);
						return {
							...e,
							newState: r
						}
					}
					default:
						return e
				}
			};
			const Le = {};
			var Be = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Le,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ke.c:
						case ke.a: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: Ee()([...e[n] || [], ...s])
							}
						}
						case ke.e: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: [...s, ...e[n] || []]
							}
						}
						case ke.f: {
							const {
								subredditName: n,
								userId: s
							} = t.payload;
							return {
								...e,
								[n]: (e[n] || []).filter(e => e !== s)
							}
						}
						default:
							return e
					}
				},
				Fe = Object(U.c)({
					afterToken: Se,
					api: De,
					models: Re,
					userOrder: Be
				});
			const Ue = {};
			var He = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ue,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ke.g: {
							const {
								subredditName: n,
								contributor: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				Ge = Object(U.c)({
					listing: Fe,
					search: He
				}),
				Qe = Object(U.c)({
					diff: G,
					directory: q,
					pages: V,
					pageSettings: J,
					revisions: de,
					wikiBannedContributors: Ie,
					wikiContributors: Ge
				});
			Object(F.a)({
				pages: {
					subredditWiki: Qe
				}
			});
			const qe = Object(d.a)(f.c),
				We = Object(d.a)(f.b),
				ze = Object(d.a)(f.a),
				Ve = (e, t, n, s) => {
					return n === T.j ? Ke(e, t) : !!Object(A.c)(e, {
						subredditName: t,
						wikiPageName: n,
						revisionId: s
					})
				},
				Ke = (e, t) => !!Object(A.b)(e, {
					subredditName: t
				}),
				Ye = e => async (t, n, r) => {
					const {
						canShowFailToast: i,
						wikiPageName: d
					} = e, c = d === T.j, l = {
						...e,
						includePageData: e.includePageData && !c
					}, u = d ? Object(D.a)({
						...e,
						wikiPageName: d
					}) : void 0;
					t(qe({
						options: l,
						pageKey: u
					}));
					const m = await Object(P.a)(r.gqlContext(), l),
						p = m.body,
						b = m.ok ? p.data && p.data.subreddit && p.data.subreddit.wiki : null;
					return m.ok && b ? t(We({
						options: l,
						pageKey: u,
						subredditWiki: b
					})) : (t(ze({
						options: l,
						pageKey: u,
						error: m.error || {
							type: a.K.NOT_FOUND_ERROR
						}
					})), i && t(Object(h.f)({
						id: "SUBREDDIT_WIKI_DATA_ERROR_TOAST",
						kind: M.b.Error,
						text: s.fbt._("Something went wrong loading this page. Try again?", null, {
							hk: "wZxm"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "mgOpG"
						}),
						buttonAction: Ye(e)
					}))), !(!m.ok || !o()(p.data.subreddit)) || !(!m.ok || !b)
				}, Je = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (n, s) => {
						const r = s(),
							o = {
								sort: a.bb.HOT
							},
							i = Object(c.a)(e, o.sort),
							d = r.listings.postOrder.api.error[i],
							l = r.listings.postOrder.api.pending[i],
							u = !!r.listings.postOrder.ids[i];
						return !!(l || u && !d) || (await n(Object(b.subredditDataRequested)(i, e, o, t)), !s().listings.postOrder.api.error[i])
					}
				}, Xe = e => async (t, n) => {
					const {
						params: s,
						url: r
					} = e, {
						wikiPageName: o
					} = s, a = Object(L.a)(r, s);
					let d = !1;
					return T.l.includes(o || "") ? (await (async (e, t) => {
						const n = `${l.a.oldRedditUrl}${Object(m.b)(e)}`;
						window.location.href = n
					})(e.url), d = !0) : r !== a && (await t(Object(i.c)(a)), d = !0), d
				}, Ze = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (r, o, i) => {
						const {
							subredditName: d = T.e,
							wikiPageName: c,
							wikiSubRoute: l
						} = e, u = t[w.M], m = t[w.N], p = u ? Object(E.a)(u) : void 0, b = m ? Object(E.a)(m) : void 0, f = c === T.j, x = l === T.m.Revisions;
						let O = !1,
							C = !1;
						if (n) {
							const {
								pageName: t
							} = e;
							O = t === a.mc.WikiContributors, C = t === a.mc.WikiBanned
						}
						const A = o(),
							y = (f || n) && !Ke(A, d),
							j = !!c && !Ve(A, d, c, p),
							I = [];
						I.push(r(Je(d))), (y || j) && I.push(r(Ye({
							includeDirectory: y,
							includePageData: j,
							revisionId: p,
							subredditName: d,
							wikiPageName: c
						}))), l === T.m.Settings && c && I.push(r(Object(_.c)(d, c))), c && p && b && I.push(r(k({
							comparisonRevisionId: b,
							revisionId: p,
							subredditName: d,
							wikiPageName: c
						}))), x && I.push(r(Object(S.c)({
							isRecent: !c,
							wikiPageName: c,
							subredditName: d
						}))), O && I.push(r(Object(v.e)(d))), C && I.push(r(Object(g.e)(d))), (await Promise.all(I)).every(Boolean) || r(Object(h.f)({
							kind: M.b.Error,
							text: s.fbt._("Something went wrong", null, {
								hk: "3UWos1"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "mgOpG"
							}),
							buttonAction: Ze(e, t, n)
						}))
					}
				}, $e = e => async (t, n) => {
					if (await t(Xe(e))) return;
					const {
						params: s,
						queryParams: r
					} = e, o = s.subredditName || T.e;
					t(u.n({
						title: s.wikiPageName ? `${s.wikiPageName} - ${o}` : `wiki - ${o}`
					})), await t(Ze(s, r));
					const i = Object(B.C)(n(), {
							subredditName: o
						}),
						a = n();
					i && (a.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
						t(Object(p.b)(R.a.SUBREDDIT))
					}), t(Object(p.d)({
						isViewSafe: Object(N.a)([], [i])
					})))
				}
		},
		"./src/reddit/actions/pinnedPost.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			})), n.d(t, "h", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "f", (function() {
				return E
			})), n.d(t, "b", (function() {
				return A
			})), n.d(t, "e", (function() {
				return y
			})), n.d(t, "i", (function() {
				return P
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/constants/modals.ts"),
				c = n("./src/reddit/endpoints/post/index.tsx"),
				l = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/posts.ts"),
				m = n("./src/reddit/selectors/profile.ts");
			const p = "PINNEDPOST__PINNED_POSTS_LOADED",
				b = Object(o.a)(p),
				f = "PINNEDPOST__PIN_POST_SUCCESS",
				h = "PINNEDPOST__UNPIN_POST_SUCCESS",
				g = Object(o.a)(f),
				v = Object(o.a)(h),
				x = "PINNEDPOST__PIN_POST_PENDING",
				E = "PINNEDPOST__UNPIN_POST_PENDING",
				O = Object(o.a)(x),
				C = Object(o.a)(E),
				A = "PINNEDPOST__PIN_POST_FAILURE",
				y = "PINNEDPOST__UNPIN_POST_FAILURE",
				j = Object(o.a)(A),
				I = Object(o.a)(y),
				k = e => Object(a.f)({
					buttonAction: P(e, !0),
					buttonText: s.fbt._("UNDO", null, {
						hk: "1O9LWh"
					}),
					kind: l.b.SuccessMod,
					text: s.fbt._("Post pinned to profile!", null, {
						hk: "1hbHLt"
					})
				}),
				_ = (e, t) => Object(a.f)({
					buttonAction: P(e, !0),
					buttonText: s.fbt._("UNDO", null, {
						hk: "3YtcK2"
					}),
					kind: l.b.SuccessMod,
					text: t ? s.fbt._("Post unpinned, reload to see changes", null, {
						hk: "5FF1g"
					}) : s.fbt._("Post unpinned.", null, {
						hk: "2BgT0h"
					})
				}),
				S = () => Object(a.f)({
					kind: l.b.Error,
					text: s.fbt._("Could not pin post", null, {
						hk: "3uNHEh"
					})
				}),
				w = () => Object(a.f)({
					kind: l.b.Error,
					text: s.fbt._("You can't pin a removed post", null, {
						hk: "3bdn2y"
					})
				}),
				T = () => Object(a.f)({
					kind: l.b.Error,
					text: s.fbt._("Could not unpin post", null, {
						hk: "o8HG0"
					})
				}),
				P = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (n, s, o) => {
						let {
							apiContext: a,
							gqlContext: l
						} = o;
						const p = s(),
							b = p.posts.models[e];
						if (!b) return;
						const f = !Object(u.s)(p, {
							postId: e
						});
						if (f && b.isRemoved) return n(w());
						const h = b.author,
							x = Object(m.o)(p, h),
							[E, A, y, P, N] = f ? [O, g, j, k, S] : [C, v, I, _, T];
						if (f) {
							if (Object(u.O)(p, {
									profileName: h
								}).length >= r.hb) return void n(Object(i.i)(d.a.PINNED_POSTS_LIMIT_REACHED))
						}
						const D = Object(u.p)(p, e, h),
							M = !f && D;
						n(E({
							postId: e,
							profileId: x
						})), (await Object(c.i)(l(), e, f, !0)).ok ? (n(A({
							postId: e,
							profileId: x
						})), t || n(P(e, M))) : (n(y({
							postId: e,
							profileId: x
						})), n(N()))
					}
				}
		},
		"./src/reddit/actions/postCollection/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "t", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "r", (function() {
				return u
			})), n.d(t, "s", (function() {
				return m
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "k", (function() {
				return h
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "j", (function() {
				return v
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "p", (function() {
				return E
			})), n.d(t, "q", (function() {
				return O
			})), n.d(t, "o", (function() {
				return C
			}));
			const s = "CREATE_COLLECTION_PENDING",
				r = "CREATE_COLLECTION_SUCCESS",
				o = "CREATE_COLLECTION_FAILED",
				i = "GET_SUBREDDIT_COLLECTION_SUCCESS",
				a = "REMOVE_POST_FROM_COLLECTION_SUCCESS",
				d = "ADD_POST_TO_COLLECTION_SUCCESS",
				c = "UPDATE_POST_WITH_COLLECTION_ID",
				l = "DELETE_COLLECTION_SUCCESS",
				u = "UPDATE_COLLECTION_PENDING",
				m = "UPDATE_COLLECTION_SUCCESS",
				p = "UPDATE_COLLECTION_FAILED",
				b = "UPDATE_COLLECTION_DESCRIPTION_PENDING",
				f = "UPDATE_COLLECTION_DESCRIPTION_SUCCESS",
				h = "UPDATE_COLLECTION_DESCRIPTION_FAILED",
				g = "REORDER_COLLECTION_PENDING",
				v = "REORDER_COLLECTION_SUCCESS",
				x = "REORDER_COLLECTION_FAILED",
				E = "UPDATE_COLLECTION_LAYOUT_PENDING",
				O = "UPDATE_COLLECTION_LAYOUT_SUCCESS",
				C = "UPDATE_COLLECTION_LAYOUT_FAILED"
		},
		"./src/reddit/actions/postCollection/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return M
			})), n.d(t, "e", (function() {
				return L
			})), n.d(t, "g", (function() {
				return F
			})), n.d(t, "a", (function() {
				return G
			})), n.d(t, "c", (function() {
				return q
			})), n.d(t, "h", (function() {
				return K
			})), n.d(t, "f", (function() {
				return Z
			})), n.d(t, "d", (function() {
				return oe
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react-router-redux/es/index.js"),
				o = n("./src/lib/filterQueryParams/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/post.ts"),
				d = n("./src/reddit/actions/postCollection/constants.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/history.ts"),
				u = n("./src/lib/constants/index.ts"),
				m = n("./src/lib/makeApiRequest/index.ts"),
				p = n("./src/lib/omitHeaders/index.ts"),
				b = n("./src/reddit/constants/headers.ts");
			var f = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/add_post_to_collection.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					link_fullname: n
				}
			});
			var h = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/create_collection.json`,
				method: u.ob.POST,
				data: {
					title: t,
					sr_fullname: n
				}
			});
			var g = (e, t) => Object(m.a)(Object(p.a)(e, [b.a]), {
					endpoint: `${e.apiUrl}/api/v1/collections/delete_collection.json`,
					method: u.ob.POST,
					data: {
						collection_id: t
					}
				}),
				v = n("./src/config.ts");
			var x = (e, t) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${v.a.gatewayUrl}/desktopapi/v1/subreddit_collections/${t}`,
				method: u.ob.GET
			});
			var E = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/remove_post_in_collection.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					link_fullname: n
				}
			});
			var O = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/update_collection_title.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					title: n
				}
			});
			var C = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/reorder_collection.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					link_ids: n.join(",")
				}
			});
			var A = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/update_collection_description.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					description: n
				}
			});
			var y = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
					endpoint: `${e.apiUrl}/api/v1/collections/update_collection_display_layout.json`,
					method: u.ob.POST,
					data: {
						collection_id: t,
						display_layout: n
					}
				}),
				j = n("./src/reddit/helpers/overlay/index.ts"),
				I = n("./src/reddit/helpers/path/index.ts"),
				k = n("./src/reddit/models/Toast/index.ts"),
				_ = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				S = n("./src/reddit/selectors/postCollection.ts"),
				w = n("./src/reddit/selectors/posts.ts"),
				T = n("./src/reddit/selectors/subreddit.ts");
			const P = Object(i.a)(d.c),
				N = Object(i.a)(d.b),
				D = Object(i.a)(d.d),
				M = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					n(P());
					const i = await h(o(), e, t);
					let a;
					if (i.ok) {
						const e = s().meta,
							t = (e => ({
								author: e.author_name || void 0,
								createdAtUTC: e.created_at_utc,
								description: e.description,
								displayLayout: e.display_layout,
								id: e.collection_id,
								lastUpdateUTC: e.last_update_utc,
								permalink: e.permalink,
								postIds: e.link_ids,
								primaryPostId: e.primary_link_id || void 0,
								subredditId: e.subreddit_id,
								title: e.title
							}))(i.body);
						n(D({
							collection: t,
							meta: e
						})), a = t
					} else {
						const e = i.error;
						n(N(e))
					}
					return a
				}, R = Object(i.a)(d.f), L = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const i = n().postCollection.subredditToIds || {};
					if (Object.keys(i).length > 0) return;
					const a = await x(o(), e);
					a.ok ? t(R(a.body)) : t(Object(c.f)({
						kind: k.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, B = Object(i.a)(d.g), F = (e, t, n) => async (r, o, i) => {
					let {
						apiContext: a
					} = i;
					if ((await E(a(), e, t)).ok) {
						const i = o(),
							a = Object(w.F)(i, {
								postId: t
							}),
							d = a && a.title || "",
							l = Object(S.q)(i, {
								collectionId: e
							}),
							u = (l && l.postIds && l.postIds.indexOf(t) || -1) - 1;
						if (r(B({
								collectionId: e,
								postId: t
							})), n && u >= 0) {
							const t = o(),
								n = Object(S.q)(t, {
									collectionId: e
								}),
								s = n && n.postIds && n.postIds[u] || "",
								i = Object(w.F)(t, {
									postId: s
								});
							i && i.permalink && r(Object(j.a)(i.permalink))
						}
						r(Object(c.f)({
							kind: k.b.SuccessMod,
							text: s.fbt._("Following post removed from collection successfully: {postTitle}", [s.fbt._param("postTitle", d)], {
								hk: "8e1lV"
							}),
							buttonText: s.fbt._("UNDO", null, {
								hk: "3KPLib"
							}),
							buttonAction: G(e, t)
						}))
					} else r(Object(c.f)({
						kind: k.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, U = Object(i.a)(d.a), H = Object(i.a)(d.t), G = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = r();
					if ((await f(i(), e, t)).ok) {
						n(U({
							collectionId: e,
							postId: t
						})), n(H({
							collectionId: e,
							postId: t
						}));
						const r = Object(w.F)(a, {
								postId: t
							}),
							o = Object(S.q)(a, {
								collectionId: e
							}),
							i = o && o.title || "";
						n(Object(c.f)({
							kind: k.b.SuccessMod,
							text: s.fbt._("Success! You added a post to the collection: {title}", [s.fbt._param("title", i)], {
								hk: "3KNJWi"
							}),
							buttonText: s.fbt._("VIEW", null, {
								hk: "1SSkgL"
							}),
							buttonAction: Object(j.a)(r.permalink)
						}))
					} else n(Object(c.f)({
						kind: k.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, Q = Object(i.a)(d.e), q = (e, t) => async (n, i, a) => {
					let {
						apiContext: d
					} = a;
					const l = i();
					if ((await g(d(), e)).ok) {
						const {
							url: i
						} = l.platform.currentPage, a = Object(S.q)(l, {
							collectionId: e
						}), d = a && a.title || "", u = a && a.subredditId, m = u ? Object(T.c)(l, u) : "/";
						n(Q({
							collectionId: e,
							collection: a
						})), n(t ? Object(r.c)(Object(o.a)(i, ["collection"])) : Object(r.b)(m)), n(Object(c.f)({
							kind: k.b.SuccessMod,
							text: s.fbt._("Collection deleted successfully: {title}", [s.fbt._param("title", d)], {
								hk: "4tcOKB"
							})
						}))
					} else n(Object(c.f)({
						kind: k.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, W = Object(i.a)(d.r), z = Object(i.a)(d.n), V = Object(i.a)(d.s), K = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					n(W());
					const a = await O(i(), e, t);
					let d = !1;
					if (a.ok) n(V({
						collectionId: e,
						newTitle: t
					})), n(Object(c.f)({
						kind: k.b.SuccessMod,
						text: s.fbt._("Collection title updated successfully", null, {
							hk: "2hKzKl"
						})
					})), d = !0;
					else {
						const e = a.error;
						n(z(e)), n(Object(c.f)({
							kind: k.b.Error,
							text: s.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							})
						}))
					}
					return d
				}, Y = Object(i.a)(d.l), J = Object(i.a)(d.m), X = Object(i.a)(d.k), Z = e => async (t, n) => {
					const s = n();
					if (Object(_.b)(s) || Object(_.c)(s)) return void t(Object(a.Z)(Object(I.b)(e.permalink), e.id));
					const o = s.platform.currentPage.locationState;
					t(!(!o || !o[l.b.IsOverlay]) ? Object(j.a)(e.permalink) : Object(r.b)(Object(I.b)(e.permalink)))
				}, $ = Object(i.a)(d.i), ee = Object(i.a)(d.j), te = Object(i.a)(d.h), ne = Object(i.a)(d.p), se = Object(i.a)(d.o), re = Object(i.a)(d.q), oe = e => async t => {
					const n = [],
						{
							collectionId: r,
							description: o,
							displayLayout: i,
							postIds: a,
							title: d
						} = e;
					a && n.push(t(((e, t) => async (n, r, o) => {
						let {
							apiContext: i
						} = o;
						n($());
						const a = await C(i(), e, t);
						let d = !1;
						return a.ok ? (n(ee({
							collectionId: e,
							postIds: t
						})), n(Object(c.f)({
							kind: k.b.SuccessMod,
							text: s.fbt._("Collection order updated successfully", null, {
								hk: "4ccHEL"
							})
						})), d = !0) : (n(te({
							error: a.error
						})), n(Object(c.f)({
							kind: k.b.Error,
							text: s.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							})
						}))), d
					})(r, a))), d && n.push(t(K(r, d))), void 0 !== o && n.push(t(((e, t) => async (n, r, o) => {
						let {
							apiContext: i
						} = o;
						n(Y());
						const a = await A(i(), e, t);
						let d = !1;
						if (a.ok) n(J({
							collectionId: e,
							newDescription: t
						})), n(Object(c.f)({
							kind: k.b.SuccessMod,
							text: s.fbt._("Collection description updated successfully", null, {
								hk: "1rIDCC"
							})
						})), d = !0;
						else {
							const e = a.error;
							n(X(e)), n(Object(c.f)({
								kind: k.b.Error,
								text: s.fbt._("Something went wrong. Just don't panic.", null, {
									hk: "4Ck6Cm"
								})
							}))
						}
						return d
					})(r, o))), i && n.push(t(((e, t) => async (n, r, o) => {
						let {
							apiContext: i
						} = o;
						n(ne());
						const a = await y(i(), e, t);
						let d = !1;
						if (a.ok) n(re({
							collectionId: e,
							newLayout: t
						})), n(Object(c.f)({
							kind: k.b.SuccessMod,
							text: s.fbt._("Collection layout updated successfully", null, {
								hk: "1Rs19j"
							})
						})), d = !0;
						else {
							const e = a.error;
							n(se(e)), n(Object(c.f)({
								kind: k.b.Error,
								text: s.fbt._("Something went wrong. Just don't panic.", null, {
									hk: "4Ck6Cm"
								})
							}))
						}
						return d
					})(r, i)));
					let l = !0;
					return await Promise.all(n).then(e => {
						e.forEach(e => {
							e || (l = !1)
						})
					}), l
				}
		},
		"./src/reddit/actions/postCreation/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "D", (function() {
				return s
			})), n.d(t, "L", (function() {
				return r
			})), n.d(t, "M", (function() {
				return o
			})), n.d(t, "l", (function() {
				return i
			})), n.d(t, "m", (function() {
				return a
			})), n.d(t, "x", (function() {
				return d
			})), n.d(t, "I", (function() {
				return c
			})), n.d(t, "J", (function() {
				return l
			})), n.d(t, "k", (function() {
				return u
			})), n.d(t, "H", (function() {
				return m
			})), n.d(t, "p", (function() {
				return p
			})), n.d(t, "R", (function() {
				return b
			})), n.d(t, "n", (function() {
				return f
			})), n.d(t, "E", (function() {
				return h
			})), n.d(t, "s", (function() {
				return g
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "f", (function() {
				return C
			})), n.d(t, "g", (function() {
				return A
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "i", (function() {
				return j
			})), n.d(t, "j", (function() {
				return I
			})), n.d(t, "q", (function() {
				return k
			})), n.d(t, "T", (function() {
				return _
			})), n.d(t, "S", (function() {
				return S
			})), n.d(t, "U", (function() {
				return w
			})), n.d(t, "V", (function() {
				return T
			})), n.d(t, "W", (function() {
				return P
			})), n.d(t, "X", (function() {
				return N
			})), n.d(t, "Y", (function() {
				return D
			})), n.d(t, "Z", (function() {
				return M
			})), n.d(t, "ab", (function() {
				return R
			})), n.d(t, "r", (function() {
				return L
			})), n.d(t, "F", (function() {
				return B
			})), n.d(t, "u", (function() {
				return F
			})), n.d(t, "v", (function() {
				return U
			})), n.d(t, "t", (function() {
				return H
			})), n.d(t, "w", (function() {
				return G
			})), n.d(t, "Q", (function() {
				return Q
			})), n.d(t, "o", (function() {
				return q
			})), n.d(t, "y", (function() {
				return W
			})), n.d(t, "eb", (function() {
				return z
			})), n.d(t, "K", (function() {
				return V
			})), n.d(t, "a", (function() {
				return K
			})), n.d(t, "G", (function() {
				return Y
			})), n.d(t, "O", (function() {
				return J
			})), n.d(t, "P", (function() {
				return X
			})), n.d(t, "N", (function() {
				return Z
			})), n.d(t, "bb", (function() {
				return $
			})), n.d(t, "C", (function() {
				return ee
			})), n.d(t, "B", (function() {
				return te
			})), n.d(t, "z", (function() {
				return ne
			})), n.d(t, "A", (function() {
				return se
			})), n.d(t, "db", (function() {
				return re
			})), n.d(t, "cb", (function() {
				return oe
			}));
			const s = "POST_GUIDANCE_VALIDATION",
				r = "SUBMIT_VALIDATION_FIELD_HAS_ERROR",
				o = "SUBMIT_VALIDATION_FIELD_IS_VALID",
				i = "POST_CREATION_EDIT_COMPLETE",
				a = "POST_CREATION_EDIT_FAILED",
				d = "POST_CREATION_PENDING_EDIT",
				c = "POST_CREATION_START_EDITING_POST",
				l = "POST_CREATION_STOP_EDITING_POST",
				u = "EDITOR_CONTENT_KEY__NEW_DRAFT",
				m = "STARTED_CONVERTING_EDITOR_CONTENT",
				p = "FINISHED_CONVERTING_EDITOR_CONTENT",
				b = "POST_CREATION__TOGGLE_EDITOR_MODE",
				f = "POST_CREATION__ERRORS_NO_LONGER_VALID",
				h = "POST_TITLE_FETCHED",
				g = "INITIALIZE_EDITOR_MODE",
				v = "POST_CREATION__CHANGE_FLAIR",
				x = "POST_CREATION__CHANGE_EVENT_SCHEDULE",
				E = "POST_CREATION__CHANGE_LINK_BODY",
				O = "POST_CREATION__CHANGE_MARKDOWN_BODY",
				C = "POST_CREATION__CHANGE_MEDIA_BODY",
				A = "POST_CREATION__CHANGE_RECAPTCHA",
				y = "POST_CREATION__CHANGE_RTE_STATE",
				j = "POST_CREATION__CHANGE_SUBMISSION_TYPE",
				I = "POST_CREATION__CHANGE_TITLE",
				k = "POST_CREATION__GOV_TYPE_CHANGED",
				_ = "POST_CREATION__TOGGLE_IS_CHAT_POST",
				S = "POST_CREATION__TOGGLE_IS_CHANGED",
				w = "POST_CREATION__TOGGLE_IS_GOV",
				T = "POST_CREATION__TOGGLE_IS_NSFW",
				P = "POST_CREATION__TOGGLE_IS_OC",
				N = "POST_CREATION__TOGGLE_IS_POLL",
				D = "POST_CREATION__TOGGLE_IS_SPOILER",
				M = "POST_CREATION__TOGGLE_POST_TO_TWITTER",
				R = "POST_CREATION__TOGGLE_SEND_REPLIES",
				L = "POST_CREATION__INITIALIZE_CROSSPOST_MODE",
				B = "POST_CREATION__RESET_FORM",
				F = "POST_CREATION__MEDIA_UPLOAD_PENDING",
				U = "POST_CREATION__MEDIA_UPLOAD_SUCCEEDED",
				H = "POST_CREATION__MEDIA_UPLOAD_FAILED",
				G = "POST_CREATION__PENDING",
				Q = "POST_CREATION__SUCCEEDED",
				q = "POST_CREATION__FAILED",
				W = "POST_CREATION__POLL_FAILED",
				z = "POST_CREATION__VALIDATION_FAILED",
				V = "POST_CREATION__SUBMIT_VALIDATION_FAILED",
				K = "POST_CREATION__CAPTCHA_REQUIRED",
				Y = "POST_CREATION__SET_SUBMIT_MODE",
				J = "POST_CREATION__SUBREDDIT_CHANGE_PENDING",
				X = "POST_CREATION__SUBREDDIT_WILL_CHANGE",
				Z = "POST_CREATION__SUBREDDIT_CHANGE_CANCELED",
				$ = "POST_CREATION__UPDATE_SCHEDULED_POST_ADVANCED_SETTINGS",
				ee = "POST_CREATION__SUBREDDIT_RECOMMENDATION_PENDING",
				te = "POST_CREATION__SUBREDDIT_RECOMMENDATION_LOADED",
				ne = "POST_CREATION__SUBREDDIT_RECOMMENDATION_FAILED",
				se = "POST_CREATION__SUB_REC_IS_INPUT_CHANGED",
				re = "POST_CREATION__UPDATE_TOURNAMENT",
				oe = "POST_CREATION__UPDATE_TALK"
		},
		"./src/reddit/actions/postCreation/editing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return D
			})), n.d(t, "a", (function() {
				return M
			})), n.d(t, "c", (function() {
				return R
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/post.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts"),
				u = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				m = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				p = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const b = e => !(!e.document || !e.document.length),
				f = e => ({
					text: null,
					richtext_json: JSON.stringify({
						document: e.document
					})
				}),
				h = e => ({
					text: e.markdown,
					return_rtjson: !0
				}),
				g = e => ({
					api_type: "json",
					show_error_list: !0,
					thing_id: e.post.id,
					validate_on_submit: !0,
					...b(e) ? f(e) : h(e)
				});
			var v = (e, t) => Object(d.a)(Object(c.a)(e, [l.a]), {
					endpoint: Object(p.a)(Object(u.a)(`${e.apiUrl}/api/editusertext`)),
					method: a.ob.POST,
					data: g(t)
				}).then(m.b),
				x = n("./src/reddit/helpers/overlay/index.ts"),
				E = n("./src/reddit/helpers/r2/normalizePostFromR2/index.ts"),
				O = n("./src/reddit/helpers/trackers/lightbox.ts"),
				C = n("./src/reddit/helpers/trackers/post.ts"),
				A = n("./src/reddit/helpers/trackers/postComposer.ts"),
				y = n("./src/reddit/models/Media/index.ts"),
				j = n("./src/reddit/models/PostCreationForm/index.ts"),
				I = n("./src/reddit/models/Toast/index.ts"),
				k = n("./src/reddit/selectors/posts.ts"),
				_ = n("./src/reddit/actions/postCreation/constants.ts"),
				S = n("./src/reddit/actions/postCreation/general.ts");
			const w = Object(r.a)(_.l),
				T = Object(r.a)(_.m),
				P = Object(r.a)(_.x),
				N = Object(r.a)(_.I),
				D = Object(r.a)(_.J),
				M = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s(),
						a = Object(k.F)(i, {
							postId: e
						});
					t ? (n(Object(x.a)(a.permalink)), Object(O.e)(e, "edit")(i)) : Object(C.h)(e, "edit")(i);
					const {
						media: d
					} = a;
					if (!d) return;
					let c, l = j.i.RICH_TEXT,
						u = "";
					d.type === y.o.TEXT ? (l = j.i.MARKDOWN, u = d.content) : d.type === y.o.RTJSON && (u = (l = d.rteMode || j.i.RICH_TEXT) === j.i.MARKDOWN ? d.markdownContent : d.richtextContent, c = d.mediaMetadata || void 0), n(N({
						editorMode: l,
						mediaMetadata: c,
						postContent: u,
						postId: e
					}))
				}, R = e => async (t, n, r) => {
					let {
						apiContext: a
					} = r;
					const {
						post: d
					} = e, c = !d.media || "rtjson" !== d.media.type && "text" !== d.media.type ? "" : d.media.rteMode;
					A.F(n(), Object(S.o)(c)), t(P(d.id));
					const l = await v(a(), e),
						u = !1 === l.body.success;
					if (t(w(d.id)), l.ok && !u) {
						t(Object(i.f)({
							kind: I.b.SuccessCommunity,
							text: s.fbt._("Post successfully edited", null, {
								hk: "xej5K"
							})
						})), t(D(d.id));
						const e = Object(E.a)(l.body);
						t(Object(o.Q)({
							[d.id]: e
						}))
					} else t(T(l.error))
				}
		},
		"./src/reddit/actions/postCreation/editorContent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "c", (function() {
				return g
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/endpoints/post/convert.ts"),
				a = n("./src/reddit/helpers/localStorage/index.ts"),
				d = n("./src/reddit/helpers/trackers/postComposer.ts"),
				c = n("./src/reddit/models/PostCreationForm/index.ts"),
				l = n("./src/reddit/models/RichTextJson/index.ts"),
				u = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/reddit/actions/postCreation/constants.ts");
			const p = Object(r.a)(m.H),
				b = Object(r.a)(m.p),
				f = Object(r.a)(m.R),
				h = (e, t, n) => async (r, a, h) => {
					let {
						apiContext: v
					} = h;
					d.m(a(), t);
					const x = t === c.i.MARKDOWN,
						E = t === c.i.RICH_TEXT,
						O = m.k;
					if (x && Object(l.H)(n)) return r(f({
						editorKey: e,
						editorMode: c.i.MARKDOWN,
						content: ""
					})), void r(g(t));
					if (E && !n) return r(f({
						editorKey: e,
						editorMode: c.i.RICH_TEXT,
						content: l.i
					})), void r(g(t));
					r(p(O));
					const C = await Object(i.a)(v(), t, x ? JSON.stringify(n) : n);
					C.ok ? (r(b(O)), r(f({
						editorKey: e,
						editorMode: t,
						content: C.body.output
					})), r(g(t))) : (r(b(O)), r(Object(o.f)({
						duration: o.a,
						kind: u.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "3UtpxU"
						})
					})))
				}, g = e => async (t, n) => {
					const r = Object(a.l)();
					if (r >= 3) return;
					const i = n().user.prefs.useMarkdown ? c.i.MARKDOWN : c.i.RICH_TEXT;
					if (e === i) return;
					const d = e === c.i.MARKDOWN ? s.fbt._("You can set Markdown as the default editor mode in the settings", null, {
						hk: "yvN18"
					}) : s.fbt._("You can set Fancy Pants as the default editor mode in the settings", null, {
						hk: "4kQi5k"
					});
					t(Object(o.f)({
						buttonAction: async () => {
							window.open("/settings/feed")
						},
						buttonText: s.fbt._("Open Settings", null, {
							hk: "1CKz9o"
						}),
						kind: u.b.SuccessCommunity,
						text: d
					})), Object(a.wb)(r + 1)
				}
		},
		"./src/reddit/actions/postCreation/general.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return k
			})), n.d(t, "o", (function() {
				return S
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "b", (function() {
				return T
			})), n.d(t, "c", (function() {
				return N
			})), n.d(t, "d", (function() {
				return D
			})), n.d(t, "f", (function() {
				return M
			})), n.d(t, "e", (function() {
				return R
			})), n.d(t, "g", (function() {
				return L
			})), n.d(t, "h", (function() {
				return B
			})), n.d(t, "l", (function() {
				return F
			})), n.d(t, "u", (function() {
				return U
			})), n.d(t, "t", (function() {
				return H
			})), n.d(t, "v", (function() {
				return G
			})), n.d(t, "w", (function() {
				return Q
			})), n.d(t, "x", (function() {
				return q
			})), n.d(t, "y", (function() {
				return W
			})), n.d(t, "A", (function() {
				return z
			})), n.d(t, "B", (function() {
				return V
			})), n.d(t, "D", (function() {
				return K
			})), n.d(t, "C", (function() {
				return Y
			})), n.d(t, "m", (function() {
				return J
			})), n.d(t, "r", (function() {
				return Z
			})), n.d(t, "s", (function() {
				return $
			})), n.d(t, "q", (function() {
				return ee
			})), n.d(t, "z", (function() {
				return te
			})), n.d(t, "p", (function() {
				return ne
			})), n.d(t, "n", (function() {
				return se
			})), n.d(t, "k", (function() {
				return ce
			})), n.d(t, "j", (function() {
				return me
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/debounce.js"),
				r = n.n(s),
				o = n("./node_modules/react-router-redux/es/index.js"),
				i = n("./src/lib/isUrl/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/contexts/PageLayer/index.tsx"),
				l = n("./src/reddit/endpoints/post/index.tsx"),
				u = n("./src/redditGQL/operations/WhereToPostSubRec.json"),
				m = n("./src/lib/makeGqlRequest/index.ts"),
				p = n("./src/redditGQL/operations/OpenAISubRecWithDetail.json");
			var b = n("./src/reddit/helpers/correlationIdTracker.ts"),
				f = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				h = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				g = n("./src/reddit/helpers/trackers/postComposer.ts"),
				v = n("./src/reddit/models/PostCreationForm/index.ts"),
				x = n("./src/reddit/models/Subreddit/index.ts"),
				E = n("./src/reddit/routes/postCreation/constants.ts"),
				O = n("./src/reddit/selectors/activeModalId.ts"),
				C = n("./src/reddit/selectors/experiments/crosspostRecommendations.ts"),
				A = n("./src/reddit/selectors/postCollection.ts"),
				y = n("./src/reddit/selectors/postCreations.ts"),
				j = n("./src/reddit/selectors/experiments/postCreationSubRec.ts"),
				I = n("./src/reddit/actions/postCreation/constants.ts");
			const k = Object(a.a)(I.n),
				_ = Object(a.a)(I.E),
				S = (Object(a.a)(I.s), e => {
					switch (e) {
						case "markdown":
							return "self";
						case "richtext":
						case "richText":
							return "self";
						case "media":
							return "media";
						default:
							return "link"
					}
				}),
				w = Object(a.a)(I.b),
				T = Object(a.a)(I.c),
				P = Object(a.a)(I.d),
				N = Object(a.a)(I.e),
				D = Object(a.a)(I.f),
				M = Object(a.a)(I.g),
				R = Object(a.a)(I.h),
				L = Object(a.a)(I.i),
				B = Object(a.a)(I.j),
				F = Object(a.a)(I.q),
				U = Object(a.a)(I.T),
				H = Object(a.a)(I.S),
				G = (Object(a.a)(I.U), Object(a.a)(I.V)),
				Q = Object(a.a)(I.W),
				q = Object(a.a)(I.X),
				W = Object(a.a)(I.Y),
				z = Object(a.a)(I.Z),
				V = Object(a.a)(I.ab),
				K = Object(a.a)(I.db),
				Y = (Object(a.a)(I.cb), Object(a.a)(I.bb)),
				J = Object(a.a)(I.r),
				X = r()((e, t) => {
					Object(i.a)(t) && e((e => async (t, n, s) => {
						let {
							apiContext: r
						} = s;
						const o = await Object(l.e)(r(), e);
						o.ok && o.body && o.body.json && o.body.json.data && t(_(o.body.json.data))
					})(t))
				}, 500),
				Z = e => async t => {
					t(P(e)), X(t, e)
				}, $ = Object(a.a)(I.F), ee = (e, t) => async (n, s) => {
					n($()), n(e ? Object(o.b)(E.b) : Object(o.b)(Object(y.fb)(s(), {
						pageLayer: t
					})))
				}, te = e => async t => {
					t(d.i(e))
				}, ne = e => async (t, n) => {
					const s = n(),
						r = Object(c.I)(e),
						o = Object(y.H)(s);
					if (r && o) {
						Object(O.a)(s) !== v.d && t(te(v.d))
					} else t(ee(!1, e))
				}, se = e => async (t, n) => {
					const s = n();
					Object(A.m)(s, {
						subredditId: e
					}) ? t(d.i(v.a)) : t(d.i(v.c))
				}, re = Object(a.a)(I.B), oe = Object(a.a)(I.C), ie = Object(a.a)(I.z), ae = Object(a.a)(I.A), de = e => async (t, n) => {
					Object(j.e)(n()) !== e && t(ae({
						isChanged: e
					}))
				}, ce = () => async (e, t) => {
					const n = t();
					if (Object(j.g)(n))
						if (Object(j.h)(n)) {
							const t = n.creations.formData.title,
								s = Object(j.l)(n),
								r = Object(j.k)(n),
								o = Object(j.b)(n);
							e(me(t, s, r, void 0, o))
						} else Object(j.j)(n) && !Object(j.d)(n) && e(pe())
				}, le = ["torrents", "IsolatedVocals"], ue = ["askreddit", "teenagers"], me = (e, t, n, s, r) => async (o, i, a) => {
					let {
						apiContext: d,
						gqlContext: c
					} = a;
					const l = i();
					if (Object(j.i)(l)) return;
					o(oe());
					const u = Object(b.c)(b.a.PostComposer),
						v = await ((e, t, n, s, r, o) => Object(m.a)(e, {
							...p,
							variables: {
								title: t,
								body: n,
								link: s,
								correlationId: r,
								confidenceWeight: o
							}
						}))(c(), e, t, n, u, r),
						E = {};
					let O = {};
					const A = {},
						y = {},
						I = [];
					if (!v.body || !v.ok) return o(de(!1)), void o(ie()); {
						const {
							data: e
						} = v.body, {
							subredditSuggestions: t
						} = e.openaiSubredditSuggestionsDetailed;
						let n = t.map(e => {
							const {
								subredditInfo: t,
								cVal: n,
								sVal: s
							} = e, r = t.name;
							return r && (y[r] = {
								confidence: n,
								succRate: s
							}), t
						}).filter(e => !le.includes(e.name));
						const r = (n = s ? n.filter(e => !s(e)) : n).slice(0, j.a),
							a = r.map(e => {
								const t = e.name;
								return I.push(t), t
							});
						if (Object(C.b)(l) && (e => {
								const t = e.map(e => e.toLowerCase());
								let n = !1;
								return ue.forEach(e => {
									t.includes(e) && (n = !0)
								}), n
							})(a)) return o(de(!1)), o(re({
							subreddits: {},
							subredditsAboutInfo: {},
							unavailableSubreddits: {},
							recSubsDict: {},
							recSubsOrder: []
						})), Object(g.H)(i()), void o(ie());
						r.forEach(e => {
							if (Object(x.k)(e)) {
								const t = Object(h.f)(e);
								A[t.id] = t
							} else if (e && Object.keys(e).length > 0) {
								const t = Object(h.a)(e),
									n = Object(f.a)(e);
								E[t.id] = t, O = {
									...O,
									...n
								}
							}
						})
					}
					o(de(!1)), o(re({
						subreddits: E,
						subredditsAboutInfo: O,
						unavailableSubreddits: A,
						recSubsDict: y,
						recSubsOrder: I
					})), 0 === Object(j.c)(i()).length && o(ie())
				}, pe = () => async (e, t, n) => {
					let {
						apiContext: s,
						gqlContext: r
					} = n;
					const o = t();
					if (Object(j.i)(o)) return;
					e(oe());
					const i = {};
					let a = {};
					const d = {},
						c = {},
						l = [],
						p = await (e => Object(m.a)(e, {
							...u,
							variables: {
								recentSubreddits: []
							}
						}))(r());
					if (!p.ok || !p.body) return e(ie()), void e(de(!1)); {
						const {
							data: e
						} = p.body;
						(e.whereToPostSuggestions.edges || []).forEach((e, t) => {
							if (t >= j.a) return;
							const n = e.node.subredditInfo;
							if (Object(x.k)(n)) {
								const e = Object(h.f)(n);
								d[e.id] = e
							} else if (n && Object.keys(n).length > 0) {
								const e = Object(h.a)(n),
									t = Object(f.a)(n);
								c[n.name] = {}, l.push(n.name), i[e.id] = e, a = {
									...a,
									...t
								}
							}
						})
					}
					e(de(!1)), e(re({
						subreddits: i,
						subredditsAboutInfo: a,
						unavailableSubreddits: d,
						recSubsDict: c,
						recSubsOrder: l
					})), 0 === Object(j.c)(t()).length && e(ie())
				}
		},
		"./src/reddit/actions/postCreation/mediaUpload.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return N
			})), n.d(t, "b", (function() {
				return M
			})), n.d(t, "a", (function() {
				return R
			})), n.d(t, "c", (function() {
				return B
			})), n.d(t, "e", (function() {
				return F
			})), n.d(t, "d", (function() {
				return U
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/formatApiError/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/actions/upload.ts"),
				l = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/constants.ts"),
				u = n("./src/lib/makeApiRequest/index.ts"),
				m = n("./src/lib/makeGqlRequest/index.ts"),
				p = n("./src/lib/omitHeaders/index.ts"),
				b = n("./src/reddit/constants/headers.ts"),
				f = n("./src/redditGQL/operations/CreateMediaUploadLease.json");
			var h = n("./src/reddit/helpers/correlationIdTracker.ts"),
				g = n("./src/reddit/helpers/imagePreview/index.ts"),
				v = n("./src/reddit/helpers/media/index.ts"),
				x = n("./src/reddit/models/Upload/index.ts"),
				E = n("./src/reddit/selectors/telemetry.ts"),
				O = n("./src/telemetry/index.ts");
			const C = e => ({
				...E.p(e),
				screen: E.db(e),
				profile: E.U(e),
				subreddit: E.mb(e)
			});
			var A = n("./src/reddit/helpers/trackers/postComposer.ts"),
				y = n("./src/reddit/models/PostCreationForm/index.ts"),
				j = n("./src/reddit/models/Toast/index.ts"),
				I = n("./src/reddit/selectors/postCreations.ts"),
				k = n("./src/reddit/helpers/graphql/normalizeUploadLeaseFromGql/index.ts"),
				_ = n("./src/reddit/actions/postCreation/constants.ts"),
				S = n("./src/reddit/actions/postCreation/general.ts");
			const w = Object(a.a)(_.u),
				T = Object(a.a)(_.v),
				P = Object(a.a)(_.t),
				N = e => async (t, n) => {
					t(w());
					const s = e.map(e => {
						let {
							url: n,
							uploadKey: s
						} = e;
						const r = Object(v.b)(Object(v.d)(n), "poster.png");
						return t(L(r, s, !0, !1))
					});
					await Promise.all(s);
					const r = n().uploads,
						o = e.map(e => {
							let {
								uploadKey: t
							} = e;
							return r[t]
						}).find(e => e.status !== x.a.SUCCESS);
					t(o ? P(o.error) : T())
				}, D = (e, t) => ({
					error: t ? {
						type: e,
						fields: [{
							field: "",
							msg: t
						}]
					} : {
						type: e
					}
				});
			const M = "RTE",
				R = "GALLERY",
				L = (e, t, n, r, i, a, l, y) => async (_, S, w) => {
					let {
						apiContext: T,
						gqlContext: P
					} = w;
					const N = Object(I.h)(S()),
						M = Date.now();
					let R = null,
						L = !1,
						B = !1,
						F = !1;
					const U = e => {
						if (!F && i && L) {
							F = !0;
							const n = S(),
								s = Date.now() - M,
								r = Object(h.c)(h.a.PostComposer);
							B ? (async e => {
								let {
									state: t,
									uploadKey: n,
									assetId: s,
									isCanceled: r,
									fileSource: o,
									uploadDuration: i,
									correlationId: a
								} = e;
								const d = t.uploads[n],
									c = r || d.status === x.a.CANCELED,
									{
										file: l,
										url: u,
										metadata: m,
										error: p
									} = d,
									b = m.mimetype || l.type,
									f = b.startsWith("video/"),
									h = d.status === x.a.SUCCESS;
								let g = "";
								p ? g = JSON.stringify(p) : c && (g = "canceled");
								const v = {
									width: m.width,
									height: m.height,
									duration: m.videoDuration && Math.round(1e3 * m.videoDuration)
								};
								Object(O.a)({
									source: "post_composer",
									action: "upload",
									correlationId: a,
									noun: f ? "video" : "image",
									...C(t),
									actionInfo: {
										...E.d(t),
										success: h,
										...g ? {
											reason: g
										} : {}
									},
									media: {
										mimetype: b,
										uploadDuration: i,
										source: o,
										fileName: l.name,
										size: l.size,
										type: f ? "video" : "image",
										...s ? {
											id: s
										} : {},
										...u ? {
											url: u
										} : {},
										...v
									}
								})
							})({
								state: n,
								uploadKey: t,
								assetId: R,
								isCanceled: e,
								fileSource: i,
								uploadDuration: s,
								correlationId: r
							}) : A.E(n, t)
						}
					};
					return await _(Object(c.l)(e, t, async h => {
						var x, E, O, C;
						L = !0, Object(c.k)(h.id, () => {
							U(!0)
						});
						const {
							error: A,
							metadata: I
						} = await async function(e, t, n, r, i) {
							const a = r && r.allowedPostTypes,
								d = r && r.name,
								c = await Object(v.h)(e) || e.type,
								l = Object(v.c)(e) || void 0;
							if (!l) return D("UNSUPPORTED_BROWSER");
							const u = {
								localUrl: l,
								mimetype: c,
								size: e.size
							};
							if (!c || !Object(v.k)(c)) return {
								error: {
									type: o.Y
								}
							};
							if (c.startsWith("image/")) {
								if (t && n && a && !a.images) {
									const e = s.fbt._("Images are not allowed in r/{subredditName}", [s.fbt._param("subredditName", d)], {
										hk: "3C2E7Q"
									});
									return D(o.Y, e)
								}
								if ("image/gif" === c) {
									if (e.size > o.eb) return D(o.N)
								} else if (e.size > o.gb) return D(o.W);
								const r = await Object(g.a)(l);
								if (i && (r.width < i || r.height < i)) {
									const e = s.fbt._("Image must be {min_image_width}x{min_image_height} pixels or larger.", [s.fbt._param("min_image_width", i.toString()), s.fbt._param("min_image_height", i.toString())], {
										hk: "2WFKgs"
									});
									return D(o.V, e)
								}
								u.width = r.width, u.height = r.height
							} else if (c.startsWith("video/")) {
								if (e.size > o.kb) return D(o.vc);
								let t;
								try {
									t = await Object(v.j)(l, !0)
								} catch (m) {
									return D(o.Y)
								}
								if (a) {
									const {
										videos: e,
										images: n
									} = a;
									if (n && !e && t.duration > o.lb) {
										const e = s.fbt._("Sorry, r/{subredditName} doesn't allow videos. Please upload a video less than 60 seconds to convert to animated GIF.", [s.fbt._param("subredditName", d)], {
											hk: "46ULiz"
										});
										return D(o.Y, e)
									}
									if (!n && !e) {
										const e = s.fbt._("Videos are not allowed in r/{subredditName}", [s.fbt._param("subredditName", d)], {
											hk: "4uTUZb"
										});
										return D(o.Y, e)
									}
								}
								if (t.duration > o.jb) {
									const e = s.fbt._("Video is too long. Maximum video length is {duration} minutes.", [s.fbt._param("duration", (o.jb / 60).toString())], {
										hk: "20nB6Q"
									});
									return D(o.Y, e)
								}
								if (t.duration < o.rb) {
									const e = s.fbt._("Video is too short. Minimum video length is {duration} seconds.", [s.fbt._param("duration", o.rb.toString())], {
										hk: "49PSW8"
									});
									return D(o.Y, e)
								}
								if (0 === t.height || 0 === t.width) {
									const e = s.fbt._("Your browser does not support the video codec used for this video. Please try using a different video codec.", null, {
										hk: "1AC0mg"
									});
									return D(o.Y, e)
								}
								if (t.height < o.sb || t.width < o.tb) {
									const e = s.fbt._("Videos must be {min_video_width}x{min_video_height} pixels or larger.", [s.fbt._param("min_video_width", o.tb.toString()), s.fbt._param("min_video_height", o.sb.toString())], {
										hk: "2HSUGl"
									});
									return D(o.Y, e)
								}
								if (e.size / t.duration < o.qb) {
									const e = s.fbt._("Videos must have a bitrate of {min_bitrate}KB/s or larger.", [s.fbt._param("min_bitrate", (o.qb / o.Z).toString())], {
										hk: "1ehgDE"
									});
									return D(o.Y, e)
								}
								u.height = t.height, u.width = t.width, u.videoDuration = t.duration, u.videoFirstFrameUrl = t.firstFrame.dataUrl
							}
							return {
								metadata: u
							}
						}(e, n, r, N, y);
						if (A || !I) return {
							error: A
						};
						if (_(Object(c.m)({
								key: t,
								metadata: {
									fileSource: i,
									...I
								}
							})), B = !0, a && a(), l) {
							const e = I.mimetype,
								t = e && o.T[e];
							if (e && t) {
								const e = await (async (e, t) => {
									return await Object(m.a)(e, {
										...f,
										variables: {
											input: {
												mimetype: t
											}
										}
									})
								})(P(), t);
								if (e.ok) {
									const t = e.body,
										n = (null === (x = t.data.createMediaUploadLease) || void 0 === x ? void 0 : x.uploadLease.uploadLeaseUrl) || "",
										s = Object(k.a)({
											uploadLeaseUrl: n,
											uploadLeaseHeaders: null === (E = t.data.createMediaUploadLease) || void 0 === E ? void 0 : E.uploadLease.uploadLeaseHeaders
										});
									return R = (null === (O = t.data.createMediaUploadLease) || void 0 === O ? void 0 : O.mediaId) || null, {
										uploadLease: s
									}
								} {
									const t = null === (C = e.body.data.createMediaUploadLease) || void 0 === C ? void 0 : C.errors;
									let n = null;
									return t && (n = {
										fields: [{
											field: t[0].__typename || "",
											msg: t[0].message
										}],
										type: t[0].__typename || ""
									}), {
										error: n || void 0
									}
								}
							}
							return _(Object(d.f)({
								kind: j.b.Error,
								text: s.fbt._("Only .jpeg and .png image types are are allowed", null, {
									hk: "30Ms4V"
								}),
								duration: 6e3
							})), {
								error: void 0
							}
						}
						const S = e.name,
							w = await (async (e, t, n) => Object(u.a)(Object(p.a)(e, [b.a]), {
								endpoint: `${e.apiUrl}/api/media/asset.json`,
								method: o.ob.POST,
								data: {
									filepath: t,
									mimetype: n
								}
							}))(T(), S, I.mimetype);
						return w.ok ? (R = w.body.asset.asset_id, {
							uploadLease: w.body.args
						}) : {
							error: w.error || void 0
						}
					}, !0)), U(!1), S().uploads[t] || null
				}, B = (e, t) => async (n, s) => {
					const r = s().uploads[e];
					r && !Object(x.c)(r) && await n(L(r.file, r.key, t, !1, r.metadata.fileSource, void 0))
				}, F = (e, t, n, o, a, c) => async (l, u) => {
					const m = e.map((e, s) => new Promise(async s => {
							const i = Object(x.d)(n, Object(r.a)().slice(-6));
							await l(L(e, i, o, !0, t, () => s({
								uploadKey: i,
								isValid: !0
							}), a, c)), s({
								uploadKey: i,
								isValid: !1
							})
						})),
						p = await Promise.all(m),
						b = p.map(e => e.uploadKey);
					return l(function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3;
						return async (n, r) => {
							const {
								uploads: o
							} = r(), a = e.map(e => o[e]).filter(e => e.status === x.a.FAILED && !e.metadata.mimetype).map(e => e.error), c = a.length > t ? t - 1 : a.length, l = a.length - c;
							a.slice(0, c).forEach(e => n(Object(d.f)({
								duration: d.a,
								kind: j.b.Error,
								text: Object(i.a)(e)
							}))), l > 0 && n(Object(d.f)({
								duration: d.a,
								kind: j.b.Error,
								text: s.fbt._({
									"*": "Couldn't add {number} more files",
									_1: "Couldn't add 1 more file"
								}, [s.fbt._plural(l, "number")], {
									hk: "2fQwvl"
								})
							}))
						}
					}(b)), p.filter(e => e.isValid).map(e => e.uploadKey)
				}, U = (e, t) => async (n, r) => {
					const o = r(),
						i = Object(I.Z)(o),
						{
							items: a
						} = i,
						u = !a.length && 1 === e.length,
						m = Object(I.P)(o) && !u;
					let p = !1,
						b = e;
					if (m) {
						if (Object(y.x)(i)) return void n(Object(d.f)({
							kind: j.b.Error,
							text: s.fbt._("Please remove the existing video first. Videos aren't supported within galleries yet.", null, {
								hk: "3lGxp4"
							})
						}));
						b.some(e => Object(v.n)(e.type)) && n(Object(d.f)({
							duration: d.a,
							kind: j.b.Error,
							text: s.fbt._("Videos arent supported within galleries...yet", null, {
								hk: "9Cl20"
							})
						})), b = b.filter(e => Object(v.m)(e.type));
						const e = Math.max(0, l.b - a.length);
						b.length > e && (n(Object(d.f)({
							kind: j.b.Error,
							text: s.fbt._("You have hit the limit of {images_limit} images", [s.fbt._param("images_limit", `${l.b}`)], {
								hk: "6M4kX"
							})
						})), b = b.slice(0, e))
					} else b = b.slice(0, 1), p = !0, n(Object(c.j)(R, !0));
					const f = await n(F(b, t, R, !0));
					if (!f.length) return;
					const h = f.map(e => ({
							uploadKey: e,
							caption: "",
							url: ""
						})),
						g = 0 === a.length;
					n(Object(S.d)({
						...i,
						items: p ? h : [...a, ...h],
						selectedKey: g ? f[0] : f[f.length - 1]
					}))
				}
		},
		"./src/reddit/actions/postCreation/submit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return U
			})), n.d(t, "f", (function() {
				return H
			})), n.d(t, "e", (function() {
				return W
			})), n.d(t, "c", (function() {
				return X
			})), n.d(t, "d", (function() {
				return ee
			})), n.d(t, "a", (function() {
				return te
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/reCaptchaEnterprise/index.ts"),
				i = n("./src/telemetry/index.ts"),
				a = n("./src/reddit/actions/crosspostSubredditRec/index.ts"),
				d = n("./src/reddit/actions/governance/index.ts"),
				c = n("./src/reddit/actions/pages/subreddit/index.ts"),
				l = n("./src/reddit/actions/postDraft.ts"),
				u = n("./src/reddit/actions/reCaptchaEnterprise.ts"),
				m = n("./src/reddit/actions/scheduledPosts/index.ts"),
				p = n("./src/reddit/actions/urlRequested.ts"),
				b = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				f = n("./src/config.ts"),
				h = n("./src/lib/convertToCamelCase/index.ts"),
				g = n("./src/lib/makeApiRequest/index.ts"),
				v = n("./src/reddit/endpoints/post/create.ts");
			var x = n("./src/reddit/endpoints/scheduledPosts/index.ts"),
				E = n("./src/reddit/endpoints/scheduledPosts/update.ts"),
				O = n("./src/reddit/featureFlags/index.ts"),
				C = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				A = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				y = n("./src/reddit/helpers/trackers/postComposer.ts"),
				j = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				I = n("./src/reddit/models/Poll/index.ts"),
				k = n("./src/reddit/models/Post/index.ts"),
				_ = n("./src/reddit/models/PostCreationForm/index.ts"),
				S = n("./src/reddit/models/ScheduledPost/index.ts"),
				w = n("./src/reddit/models/User/index.ts"),
				T = n("./src/reddit/selectors/experiments/crosspostRecommendations.ts"),
				P = n("./src/reddit/selectors/postCreations.ts"),
				N = n("./src/reddit/selectors/postDraft.ts"),
				D = n("./src/reddit/selectors/postGuidance.ts"),
				M = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				R = n("./src/reddit/selectors/user.ts"),
				L = n("./src/reddit/actions/postCreation/constants.ts"),
				B = n("./src/reddit/actions/postCreation/general.ts"),
				F = n("./src/reddit/actions/postCreation/mediaUpload.ts");
			const U = Object(r.a)(L.w),
				H = Object(r.a)(L.Q),
				G = Object(r.a)(L.o),
				Q = Object(r.a)(L.y),
				q = Object(r.a)(L.eb),
				W = Object(r.a)(L.K),
				z = Object(r.a)(L.a),
				V = Object(r.a)(L.G),
				K = e => `/r/${e}/about/${S.s}`,
				Y = (e, t) => {
					const n = e || {
							duration: s.D,
							options: []
						},
						{
							govType: r,
							newSubreddit: o,
							newTopMod: i
						} = Object(P.u)(t),
						a = {
							...n
						};
					return r && (a.type = r), a.type === I.a.ReplaceTopMod ? (a.params = {
						userName: i
					}, a.options = I.f[I.a.ReplaceTopMod]()) : a.type === I.a.Spinoff ? (a.params = {
						subreddit: o
					}, a.options = I.f[I.a.Spinoff](o)) : a.options = a.options.map(e => ({
						text: e.text.trim()
					})).filter(e => !!e.text), a
				},
				J = e => {
					const t = e.uploads,
						n = Object(P.Z)(e),
						r = Object(P.a)(e),
						o = Object(P.lb)(e);
					if (r === s.bc.POST) return b.a.getPendingThumbnailUploads(o, t);
					if (r === s.bc.MEDIA && n && n.items.length) {
						const {
							video: e
						} = n.items[0];
						if (e && e.thumbnail && !t[_.n]) return [{
							...e.thumbnail,
							uploadKey: _.n
						}]
					}
				},
				X = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o, a = r();
					const {
						pending: d
					} = a.creations.api.post.submit, c = Object(N.g)(a);
					if (d || c) return;
					n(V(e)), a = r();
					const u = Object(P.a)(a),
						m = O.d.rteVideoPoster(a),
						p = J(a),
						b = u === s.bc.MEDIA;
					p && (m || b) && (await n(F.f(p)), J(r())) || (e === _.r.Draft ? await n(Object(l.r)(t.draftId)) : e === _.r.ScheduledPost && Object(M.r)(a) ? await n(Z(t)) : e === _.r.ScheduledPost ? await n($(t)) : await n(ee(t)))
				}, Z = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n(),
						a = Object(P.gb)(o),
						d = Object(P.hb)(o, e),
						c = Object(P.h)(o),
						l = Object(M.r)(o);
					if (!(d && c.id && a && Object(A.f)(l))) return;
					const u = c.id,
						b = Object(M.a)(o, {
							subredditId: u,
							scheduledPostId: l
						});
					if (b && Object(i.a)(Object(j.r)(b)(o)), t(U(d)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(P.x)(n()))) return;
					if (e.postGuidanceValidationPending && (await e.postGuidanceValidationPending, Object(D.c)(n()))) return;
					const {
						isPoll: f,
						polls: h
					} = Object(P.u)(o), g = Y(h, o), v = {
						...Object(x.e)({
							poll: f ? g : void 0,
							submission: d,
							schedule: a,
							subredditId: c.id,
							scheduledPostId: l
						})
					}, O = await Object(E.a)(r(), v);
					if (O.ok) return t(Object(m.e)({
						subredditId: c.id
					})), void t(Object(p.a)(K(c.name), !1));
					const C = O.error;
					t(G(C))
				}, $ = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n(),
						a = Object(P.gb)(o),
						d = Object(P.hb)(o, e),
						c = Object(P.h)(o),
						l = Object(M.b)(o);
					if (!d || !c.id || !a) return;
					if (t(U(d)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(P.x)(n()))) return;
					if (e.postGuidanceValidationPending && (await e.postGuidanceValidationPending, Object(D.c)(n()))) return;
					const {
						isPoll: u,
						polls: b
					} = Object(P.u)(o), f = Y(b, o), h = {
						duration: f.duration,
						options: f.options
					}, g = {
						...Object(x.d)({
							poll: u ? h : void 0,
							submission: d,
							schedule: a,
							subredditId: c.id
						}),
						creationToken: l
					}, v = await Object(x.a)(r(), g);
					if (v.ok) {
						t(Object(m.e)({
							subredditId: c.id
						}));
						const e = v.body.data.createScheduledPost.scheduledPost;
						return e && Object(i.a)(Object(j.o)(Object(C.d)(e))(o)), void t(Object(p.a)(K(c.name), !1))
					}
					const E = v.error;
					t(G(E))
				}, ee = e => async (t, n, r) => {
					let {
						apiContext: i
					} = r;
					const l = n(),
						m = Object(P.hb)(l, e),
						{
							isPoll: b,
							polls: x
						} = Object(P.u)(l),
						E = Y(x, l);
					if (!m) return;
					if (t(U(m)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(P.x)(n()))) return;
					if (e.postGuidanceValidationPending && (await e.postGuidanceValidationPending, Object(D.c)(n()))) return;
					let C;
					t(Object(u.b)({
						action: o.a.PostSubmit,
						catchAndLogError: !0
					}));
					const A = b && O.d.spPolls(l);
					if ((C = A ? await
							function(e, t, n) {
								const r = t.destSubreddit.id;
								return Object(g.a)(e, {
									method: s.ob.POST,
									endpoint: `${f.a.metaUrl}/polls/${r}`,
									type: "json",
									data: {
										poll: n,
										subredditId: r,
										...Object(h.a)(Object(v.d)(t))
									}
								}).then(async e => {
									const n = e.ok ? {
											...e,
											body: {
												json: {
													data: e.body
												}
											}
										} : e,
										s = await Object(v.e)(n, t);
									if (s.ok) {
										return {
											body: {
												...s.body,
												poll: e.body.poll
											},
											ok: !0,
											status: e.status
										}
									}
									return {
										error: s.body,
										ok: !1,
										status: e.status
									}
								})
							}(i(), m, E) : b ? await Object(v.b)(i(), {
								...m,
								kind: _.p.POLL,
								poll: E
							}) : m.kind === _.p.GALLERY ? await Object(v.a)(i(), m) : await Object(v.c)(i(), m)).ok) {
						const e = Object(R.m)(l),
							n = C.body;
						t(H({
							draftId: m.draftId,
							response: n
						})), A && t(Object(d.c)({
							poll: n.poll
						}));
						const s = Object(T.b)(l);
						m.kind !== _.p.LINK && m.kind !== _.p.RICH_TEXT && m.kind !== _.p.MARKDOWN || b || !s || t(Object(a.c)());
						const r = (n.path || `/user/${Object(w.e)(e)}/submitted`).replace(/^\/r\/u_/, "/user/");
						t(Object(c.subredditInvalidateListing)(m.destSubreddit.name)), t(Object(p.a)(r, !1))
					} else {
						if (b) {
							const e = C.error;
							t(Q(e))
						}
						const e = C.error;
						te(t, e)
					}
					const j = Object(B.o)(m.kind),
						I = C.ok && C.body && C.body.id && Object(k.y)(C.body.id),
						S = n();
					y.C(S, j, I, e.correlationId)
				}, te = (e, t) => {
					t.type === s.K.BAD_CAPTCHA_ERROR ? e(z()) : t.type === s.K.VALIDATION_ERROR ? e(q(t)) : t.type === s.K.SUBMIT_VALIDATION_ERROR ? e(W(t)) : e(G(t))
				}
		},
		"./src/reddit/actions/postCreation/subredditChange.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return C
			})), n.d(t, "b", (function() {
				return A
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "d", (function() {
				return j
			})), n.d(t, "c", (function() {
				return I
			}));
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/addQueryParams/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/filterQueryParams/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/pages/postCreation.ts"),
				l = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				u = n("./src/reddit/helpers/name/index.ts"),
				m = n("./src/reddit/models/PostCreationForm/index.ts"),
				p = n("./src/reddit/routes/postCreation/index.ts"),
				b = n("./src/reddit/routes/postCreation/constants.ts"),
				f = n("./src/reddit/selectors/postCreations.ts"),
				h = n("./src/reddit/selectors/platform.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				v = n("./src/reddit/actions/postCreation/constants.ts"),
				x = n("./src/reddit/actions/postCreation/general.ts");
			const E = Object(a.a)(v.O),
				O = Object(a.a)(v.P),
				C = Object(a.a)(v.N),
				A = (e, t) => async (n, s, r) => {
					let {
						apiContext: i
					} = r, a = s();
					const {
						name: p,
						isProfile: b
					} = e, v = Object(h.e)(a), x = v && !b && Object(u.a)(v.name, p), O = a.creations.api.subreddit.change.pending;
					if (x || O) return;
					const C = Object(l.x)(t);
					if (!p) return void n(y(e, C));
					n(E(e));
					const A = b ? {
						profileName: p
					} : {
						subredditName: p
					};
					if (await n(Object(c.postCreationPageDataRequested)(A)), b || !Object(f.C)(a)) return n(y(e, C));
					const j = e.allowedPostTypes || Object(g.B)(s(), {
						subredditName: p
					});
					if (!j) return void n(y(e, C));
					let I;
					a = s();
					const k = Object(f.rb)(a),
						_ = Object(f.C)(a);
					if (k === o.bc.MEDIA && _) {
						const e = Object(f.Z)(a),
							t = Object(m.x)(e),
							n = Object(f.P)(a) && e.items.length > 1,
							s = !t && !n;
						if (n && !j.galleries) I = m.q.GalleryWillBeRemovedGalleryNotAllowed;
						else if (s && !j.images) I = m.q.ImageWillBeRemoved;
						else if (t && !j.videos) {
							const t = a.uploads[e.items[0].uploadKey],
								n = t && t.metadata.videoDuration || 0;
							j.images ? n > o.lb && (I = m.q.VideoWillBeRemovedTooLongForGif) : I = m.q.VideoWillBeRemovedMediaNotAllowed
						}
					}
					n(I ? Object(d.i)(I) : y({
						...e,
						allowedPostTypes: j
					}, C))
				}, y = function(e, t) {
					let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (o, i) => {
						const {
							name: a,
							isProfile: d
						} = e, c = i().platform.currentPage, l = c.queryParams, u = d ? p.b : p.c;
						let m = "";
						m = a ? u(a) : b.b, m = Object(r.a)(m, {
							...l,
							draft: t || l.draft
						}), (t || c.url.toLowerCase() !== m.toLowerCase()) && (o(O(e)), n && o(Object(x.t)(!0)), o(Object(x.i)()), o(Object(s.c)(m)))
					}
				}, j = e => async (t, n) => {
					const o = n().platform.currentPage,
						i = o.queryParams,
						a = Object(r.a)(o.url, {
							...i,
							collection: e
						});
					t(Object(s.c)(a))
				}, I = () => async (e, t) => {
					const n = t().platform.currentPage,
						r = Object(i.a)(n.url, ["collection"]);
					e(Object(s.c)(r))
				}
		},
		"./src/reddit/actions/postDraft.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return w
			})), n.d(t, "e", (function() {
				return T
			})), n.d(t, "d", (function() {
				return P
			})), n.d(t, "p", (function() {
				return R
			})), n.d(t, "j", (function() {
				return L
			})), n.d(t, "l", (function() {
				return B
			})), n.d(t, "i", (function() {
				return F
			})), n.d(t, "m", (function() {
				return U
			})), n.d(t, "k", (function() {
				return H
			})), n.d(t, "h", (function() {
				return G
			})), n.d(t, "n", (function() {
				return Q
			})), n.d(t, "s", (function() {
				return J
			})), n.d(t, "r", (function() {
				return X
			})), n.d(t, "g", (function() {
				return Z
			})), n.d(t, "q", (function() {
				return ee
			})), n.d(t, "c", (function() {
				return te
			})), n.d(t, "a", (function() {
				return ne
			})), n.d(t, "b", (function() {
				return se
			})), n.d(t, "o", (function() {
				return ae
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/formatApiError/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/postCreation/general.ts"),
				a = n("./src/reddit/actions/postCreation/subredditChange.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				l = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/omitHeaders/index.ts"),
				m = n("./src/reddit/models/StructuredStyles/index.ts");
			var p = n("./src/reddit/constants/headers.ts"),
				b = n("./src/reddit/helpers/name/index.ts"),
				f = n("./src/reddit/models/PostDraft/index.ts"),
				h = n("./src/reddit/helpers/r2/normalizeProfileSubredditFromR2/index.ts"),
				g = n("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts"),
				v = n("./src/reddit/models/Subreddit/index.ts");
			const x = e => {
				let t = e.drafts.reduce((e, t) => {
					const n = (e => {
						let t;
						return t = "link" === e.kind ? {
							kind: f.b.Link,
							body: e.body || void 0
						} : "markdown" === e.kind ? {
							kind: f.b.Markdown,
							body: e.body || void 0
						} : {
							kind: f.b.RichText,
							body: e.body || void 0
						}, {
							subredditId: e.subreddit || void 0,
							contentCategory: e.content_category || void 0,
							created: e.created,
							flair: e.flair,
							id: e.id,
							isChatPost: !!e.discussion_type,
							isNSFW: !!e.nsfw,
							isOriginalContent: !!e.original_content,
							isSpoiler: !!e.spoiler,
							modified: e.modified || void 0,
							sendReplies: !!e.send_replies,
							isPublicLink: !!e.is_public_link,
							title: e.title || "",
							...t
						}
					})(t);
					return e.postDraftIds.push(n.id), e.postDrafts[n.id] = n, e
				}, {
					postDraftIds: [],
					postDrafts: {},
					profiles: {},
					subreddits: {}
				});
				return t = e.subreddits.reduce((e, t) => {
					if (t.subreddit_type === v.g.User) {
						const n = Object(h.a)(t, Object(b.i)(t.display_name_prefixed));
						e.profiles[n.id] = n
					} else {
						const n = Object(g.a)(t);
						e.subreddits[n.id] = n
					}
					return e
				}, t)
			};
			var E = n("./src/reddit/endpoints/post/draft/helpers.ts"),
				O = n("./src/reddit/models/PostCreationForm/index.ts"),
				C = n("./src/reddit/helpers/trackers/postComposer.ts"),
				A = n("./src/reddit/models/Toast/index.ts"),
				y = n("./src/reddit/models/User/index.ts"),
				j = n("./src/reddit/selectors/postCreations.ts"),
				I = n("./src/reddit/selectors/postDraft.ts"),
				k = n("./src/reddit/selectors/profile.ts"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				S = n("./src/reddit/selectors/user.ts");
			const w = "POST_DRAFT__LIST_PENDING",
				T = "POST_DRAFT__LIST_LOADED",
				P = "POST_DRAFT__LIST_FAILED",
				N = Object(o.a)(w),
				D = Object(o.a)(T),
				M = Object(o.a)(P),
				R = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const o = t();
					if (!Object(S.m)(o) || Object(I.b)(o)) return;
					e(N());
					const i = await (e => Object(l.a)(Object(u.a)(e, [p.a]), {
						endpoint: `${e.apiUrl}/api/v1/drafts.json`,
						method: s.ob.GET
					}))(r());
					i.ok ? e(D(x(i.body))) : e(M(i.error))
				}, L = "POST_DRAFT__SAVE_DRAFT_PENDING", B = "POST_DRAFT__SAVE_DRAFT_SUCCEEDED", F = "POST_DRAFT__SAVE_DRAFT_FAILED", U = "POST_DRAFT__SAVE_DRAFT_VALIDATION_FAILED", H = "POST_DRAFT__SAVE_DRAFT_SUBMIT_VALIDATION_FAILED", G = "POST_DRAFT__SAVE_DRAFT_CAPTCHA_REQUIRED", Q = "POST_CREATION__TOGGLE_DRAFT_IS_PUBLIC", q = Object(o.a)(L), W = Object(o.a)(B), z = Object(o.a)(F), V = Object(o.a)(U), K = Object(o.a)(H), Y = Object(o.a)(G), J = Object(o.a)(Q), X = e => async (t, n, o) => {
					let {
						apiContext: i
					} = o;
					const c = n(),
						m = Object(I.g)(c),
						b = Object(j.eb)(c);
					if (m || b) return;
					const f = Object(I.h)(c, e);
					if (!f) return;
					t(q(f)), C.g(c, f, f.destSubreddit.name);
					const h = await ((e, t, n) => Object(l.a)(Object(u.a)(e, [p.a]), {
						endpoint: `${e.apiUrl}/api/v1/draft`,
						method: n ? s.ob.PUT : s.ob.POST,
						data: Object(E.a)(t)
					}).then(e => e.body.fields && Object(O.w)(e.body.fields[0]) ? {
						...e,
						body: {},
						error: {
							type: s.K.SUBMIT_VALIDATION_ERROR,
							fields: [{
								field: e.body.fields[0],
								msg: e.body.explanation
							}]
						}
					} : e))(i(), f, e);
					if (h.ok) {
						const {
							id: n,
							draftsCount: s
						} = Object(E.c)(h.body);
						t(W({
							draftId: n,
							draftsCount: s
						})), e || t(Object(a.a)(f.destSubreddit, n, !1))
					} else {
						const e = h.error;
						e.type === s.K.BAD_CAPTCHA_ERROR ? t(Y()) : e.type === s.K.VALIDATION_ERROR ? t(V(e)) : e.type === s.K.SUBMIT_VALIDATION_ERROR ? t(K(e)) : t(z(e)), t(Object(d.f)({
							duration: d.a,
							kind: A.b.Error,
							text: Object(r.a)(e)
						}))
					}
				}, Z = "POST_DRAFT__LOAD_DRAFT", $ = Object(o.a)(Z), ee = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t($(e));
					let o = O.f;
					const i = n();
					if (e.subredditId) {
						const t = Object(_.X)(i, {
								subredditId: e.subredditId
							}),
							n = Object(k.r)(i, {
								profileId: e.subredditId
							}),
							s = Object(S.m)(i);
						t ? o = {
							isProfile: !1,
							name: t.name
						} : n && s && (o = {
							isProfile: !0,
							name: Object(y.e)(s)
						})
					}
					await t(Object(a.a)(o, e.id, !1));
					const d = Object(I.h)(n(), e.id);
					d && C.j(n(), d)
				}, te = "POST_DELETE_DRAFT_SUCCEEDED", ne = "POST_DELETE_DRAFT_FAILED", se = "POST_DELETE_DRAFT_PENDING", re = Object(o.a)(te), oe = Object(o.a)(ne), ie = Object(o.a)(se), ae = (e, t) => async (n, o, a) => {
					let {
						apiContext: p
					} = a;
					const b = o();
					if (Object(I.a)(b, e)) return;
					const f = Object(I.d)(b, {
						draftId: e
					});
					f && C.h(b, f), n(ie({
						draftId: e
					}));
					const h = await (async (e, t) => Object(l.a)(Object(u.a)(e, [m.g]), {
						endpoint: `${e.apiUrl}/api/v1/draft?draft_id=${t}`,
						method: s.ob.DELETE
					}))(p(), e);
					if (h.ok) {
						const {
							draftsCount: s
						} = Object(E.c)(h.body);
						n(re({
							draftId: e,
							draftsCount: s
						}));
						const r = Object(c.x)(t);
						e === r && n(Object(i.q)(!0, t))
					} else {
						const t = h.error;
						n(oe({
							draftId: e,
							apiError: t
						})), n(Object(d.f)({
							duration: d.a,
							kind: A.b.Error,
							text: Object(r.a)(t)
						}))
					}
				}
		},
		"./src/reddit/actions/postFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "f", (function() {
				return C
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "e", (function() {
				return w
			})), n.d(t, "d", (function() {
				return T
			})), n.d(t, "l", (function() {
				return M
			})), n.d(t, "k", (function() {
				return R
			})), n.d(t, "j", (function() {
				return L
			})), n.d(t, "g", (function() {
				return B
			})), n.d(t, "i", (function() {
				return F
			})), n.d(t, "h", (function() {
				return U
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/post.ts"),
				i = n("./src/reddit/actions/postFlairStyleTemplate.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/endpoints/flair/index.ts"),
				c = n("./src/reddit/helpers/flair.ts"),
				l = n("./src/reddit/models/Flair/index.ts"),
				u = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/reddit/selectors/postFlair.ts"),
				p = n("./src/reddit/selectors/subreddit.ts");
			const b = "STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_SUCCESS",
				f = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_PENDING"),
				h = Object(r.a)(b),
				g = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_FAILED"),
				v = "STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_SUCCESS",
				x = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_PENDING"),
				E = Object(r.a)(v),
				O = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_FAILED"),
				C = "STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_SUCCESS",
				A = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_PENDING"),
				y = Object(r.a)(C),
				j = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_FAILED"),
				I = "STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_SUCCESS",
				k = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_PENDING"),
				_ = Object(r.a)(I),
				S = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_FAILED"),
				w = "STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_PENDING",
				T = "STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_FAILED",
				P = Object(r.a)(w),
				N = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_SUCCESS"),
				D = Object(r.a)(T),
				M = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s(),
						a = Object(p.X)(i, {
							subredditId: e
						}).name;
					n(f());
					const c = await Object(d.l)(o(), a, t);
					if (c.ok) {
						n(h({
							subredditId: e,
							isEnabled: t
						}))
					} else n(g());
					return c.ok
				}, R = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s(),
						a = Object(p.X)(i, {
							subredditId: e
						}).name;
					n(x());
					const c = await Object(d.k)(o(), t, l.d.LinkFlair, a);
					if (c.ok) {
						n(E({
							subredditId: e,
							canAssignOwn: t
						}))
					} else n(O());
					return c.ok
				}, L = (e, t) => async (n, r, o) => {
					let {
						apiContext: c
					} = o;
					const m = r(),
						b = Object(p.X)(m, {
							subredditId: t
						}).name;
					n(A());
					const f = await Object(d.g)(c(), e, b, l.d.LinkFlair);
					let h = f.ok && !(f.body && !1 === f.body.success);
					if (h) {
						const s = f.body;
						if (n(y({
								subredditId: t,
								template: s
							})), s.id) {
							const r = e.styleTemplate,
								o = m.structuredStyles.flairTemplate.models[s.id];
							r ? h = await n(Object(i.d)(t, s.id, r)) : o && (h = await n(Object(i.c)(t, s.id)))
						}
					}
					if (h) {
						const e = Object(a.e)(s.fbt._("Flair saved!", null, {
							hk: "3MQuUt"
						}), u.b.SuccessMod);
						n(Object(a.f)(e))
					} else {
						n(j());
						const r = Object(a.e)(s.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "1yf1Ne"
						}), u.b.Error, s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), L(e, t));
						n(Object(a.f)(r))
					}
					return h
				}, B = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const c = r(),
						l = Object(p.X)(c, {
							subredditId: t
						}).name;
					if (n(k()), (await Object(d.b)(i(), e, l)).ok) {
						n(_({
							subredditId: t,
							templateId: e
						}));
						const r = Object(a.e)(s.fbt._("Flair deleted!", null, {
							hk: "44T1il"
						}), u.b.SuccessMod);
						n(Object(a.f)(r))
					} else {
						n(S());
						const r = Object(a.e)(s.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "1nwT0G"
						}), u.b.Error, s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), B(e, t));
						n(Object(a.f)(r))
					}
				}, F = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const c = r(),
						b = Object(m.d)(c, {
							subredditId: t
						}).templateIds,
						f = Object(p.X)(c, {
							subredditId: t
						}).name;
					if (n(P({
							subredditId: t,
							templateIds: e
						})), (await Object(d.f)(i(), f, l.d.LinkFlair, e)).ok) {
						n(N());
						const e = Object(a.e)(s.fbt._("Flair reorder saved.", null, {
							hk: "1Xbuan"
						}), u.b.SuccessMod);
						n(Object(a.f)(e))
					} else {
						n(D({
							subredditId: t,
							templateIds: b
						}));
						const r = Object(a.e)(s.fbt._("Sorry. Flair reorder wasn't saved.", null, {
							hk: "4ohwNd"
						}), u.b.Error, s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), F(e, t));
						n(Object(a.f)(r))
					}
				}, U = e => {
					let {
						post: t,
						previewFlair: n,
						selectedTemplateId: s
					} = e;
					return async (e, r, i) => {
						let {
							apiContext: a
						} = i;
						const l = t.flair.filter(e => !Object(c.q)(e.type));
						if (n && l.unshift(n), e(Object(o.Q)({
								[t.id]: {
									flair: l
								}
							})), n) {
							const e = Object(c.g)(n);
							Object(d.i)(a(), t.id, s, e)
						} else Object(d.i)(a(), t.id, "", "")
					}
				}
		},
		"./src/reddit/actions/postFlairStyleTemplate.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return O
			})), n.d(t, "d", (function() {
				return A
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "c", (function() {
				return I
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/forEach.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/isEqual.js"),
				i = n.n(o),
				a = n("./node_modules/lodash/values.js"),
				d = n.n(a),
				c = n("./src/lib/makeActionCreator/index.ts"),
				l = n("./src/reddit/actions/imageUploads.ts"),
				u = n("./src/reddit/helpers/media/index.ts"),
				m = n("./src/lib/constants/index.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				b = n("./src/lib/omitHeaders/index.ts"),
				f = n("./src/reddit/constants/headers.ts");
			var h = n("./src/reddit/helpers/trackers/blade.ts"),
				g = n("./src/reddit/models/Image/index.tsx"),
				v = n("./src/reddit/selectors/subreddit.ts"),
				x = n("./src/telemetry/index.ts");
			const E = e => {
					let {
						subredditId: t,
						flairId: n,
						imageKey: s,
						imageData: r
					} = e;
					return async (e, o, i) => {
						const a = o(),
							d = Object(v.X)(a, {
								subredditId: t
							});
						if (!d) return !1;
						e(Object(l.k)(r));
						const c = await (async (e, t, n, s, r, o) => Object(p.a)(Object(b.a)(e, [f.a]), {
							endpoint: `${e.apiUrl}/api/v1/${t}/flair_style_asset_upload_s3/${n}`,
							method: m.ob.POST,
							data: {
								filepath: s,
								imagetype: r,
								mimetype: o
							}
						}))(i.apiContext(), d.name, n, r.file.name, s, await Object(u.h)(r.file));
						let h = !1;
						try {
							const t = await Object(l.g)(o(), c, r, g.a.FlairTemplates);
							t && e(Object(l.j)(t)), h = !0
						} catch (x) {
							if (x instanceof Error) throw x;
							e(Object(l.i)(x))
						}
						return h
					}
				},
				O = "POSTFLAIR_STYLETEMPLATE_SAVED_SUCCESS",
				C = Object(c.a)(O),
				A = (e, t, n) => async (s, o, a) => {
					const {
						apiContext: c
					} = a;
					let u = o();
					const {
						pendingImages: O,
						...A
					} = n;
					let y = A;
					const j = Object(v.X)(u, {
						subredditId: e
					});
					if (!j) return !1;
					const I = u.structuredStyles.flairTemplate.models[t];
					if (I && i()(I, y)) return !0;
					if (O) {
						const n = [];
						if (r()(O, (r, o) => {
								r && n.push(s(E({
									flairId: t,
									imageData: Object(g.m)(r),
									imageKey: o,
									subredditId: e
								})))
							}), !(await Promise.all(n)).every(e => e)) return !1;
						y = ((e, t, n) => {
							const s = {
								...e
							};
							return r()(t, (e, t) => {
								const r = e && n.imageUploads[e.id];
								r && r.kind === g.b.TempUploaded && (s[t] = r.url)
							}), s
						})(y, O, o())
					}
					u = o();
					let k = null,
						_ = null;
					const S = [];
					try {
						(k = await Object(l.f)(u, g.a.FlairTemplates)) && (_ = Object(l.m)(k)(s, o, a), S.push(...d()(k.imagesByKey)))
					} catch (N) {
						return !1
					}
					const w = await (async (e, t, n, s) => Object(p.a)(Object(b.a)(e, [f.a]), {
							endpoint: `${e.apiUrl}/api/v1/${t}/flair_styles/${n}`,
							method: m.ob.PUT,
							data: s
						}))(c(), j.name, t, y),
						T = I ? "edit_post_flair_template" : "save_post_flair_template",
						P = Object(h.e)(u, T);
					if (w.ok) {
						let e;
						if (_) try {
							await _, e = ((e, t, n) => {
								const s = {
									...e
								};
								return t.forEach(e => {
									const t = n.imageUploads[e.id];
									t && t.kind === g.b.Uploaded && (e.url === s.postBackgroundImage ? s.postBackgroundImage = t.url : e.url === s.postPlaceholderImage && (s.postPlaceholderImage = t.url))
								}), s
							})(y, S, o())
						} catch (N) {
							e = null
						} else e = y;
						s(C({
							flairId: t,
							template: e || y
						}))
					} else k && k.websocket.close();
					return Object(x.a)({
						...P,
						actionInfo: {
							...P.actionInfo,
							success: w.ok
						}
					}), w.ok
				}, y = "POSTFLAIR_STYLETEMPLATE_DELETED_SUCCESS", j = Object(c.a)(y), I = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s(),
						a = Object(v.X)(i, {
							subredditId: e
						});
					if (!a) return !1;
					const d = await (async (e, t, n) => Object(p.a)(Object(b.a)(e, [f.a]), {
							endpoint: `${e.apiUrl}/api/v1/${t}/flair_styles/${n}`,
							method: m.ob.DELETE
						}))(o(), a.name, t),
						c = Object(h.e)(i, "delete_flair_template");
					return d.ok && n(j({
						flairId: t
					})), Object(x.a)({
						...c,
						actionInfo: {
							...c.actionInfo,
							success: d.ok
						}
					}), d.ok
				}
		},
		"./src/reddit/actions/postFlairStyleTemplates/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_PENDING",
				r = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_LOADED",
				o = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_FAILED"
		},
		"./src/reddit/actions/postGuidance/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			const s = "POST_GUIDANCE_CONFIG_FAILED",
				r = "POST_GUIDANCE_CONFIG_LOADED",
				o = "POST_GUIDANCE_CONFIG_PENDING",
				i = "POST_GUIDANCE_ALLOWLIST_LOADED"
		},
		"./src/reddit/actions/postGuidance/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return x
			})), n.d(t, "b", (function() {
				return E
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/lib/makeGqlRequest/index.ts")),
				a = n("./src/redditGQL/operations/GetSingleDynamicConfig.json"),
				d = (e, t) => Object(i.a)(e, {
					...a,
					variables: t
				}).then(e => {
					var t, n, s, r;
					if (e.ok) {
						const o = null === (s = null === (n = null === (t = e.body) || void 0 === t ? void 0 : t.data) || void 0 === n ? void 0 : n.dynamicConfigsByNames) || void 0 === s ? void 0 : s.values,
							i = null === (r = null == o ? void 0 : o[0]) || void 0 === r ? void 0 : r.value;
						return {
							...e,
							body: i ? JSON.parse(i) : {}
						}
					}
					return e
				}),
				c = n("./src/redditGQL/operations/FetchPostGuidanceConfig.json"),
				l = n("./src/reddit/endpoints/subreddit/about.ts"),
				u = n("./src/reddit/selectors/postGuidance.ts"),
				m = n("./src/reddit/selectors/subreddit.ts"),
				p = n("./src/redditGQL/types.ts"),
				b = n("./src/reddit/actions/postGuidance/constants.ts");
			const f = Object(r.a)(b.c),
				h = Object(r.a)(b.d),
				g = Object(r.a)(b.b),
				v = Object(r.a)(b.a),
				x = () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					var r;
					const o = d(s(), {
							name: "post_guidance_beta_subreddits_v1",
							type: p.q.Map
						}),
						i = d(s(), {
							name: "post_guidance_tier3_subreddits_v1",
							type: p.q.Map
						}),
						a = await Promise.allSettled([o, i]),
						[c, l] = a;
					let u = {};
					"fulfilled" === c.status && c.value.ok && c.value.body && (u = {
						...u,
						...c.value.body
					}), "fulfilled" === l.status && l.value.ok && (null === (r = l.value.body) || void 0 === r ? void 0 : r.ids) && (u = {
						...u,
						...l.value.body.ids.split(",").filter(e => "" !== e).reduce((e, t) => ({
							...e,
							[t]: !0
						}), {})
					}), u && e(v(u))
				}, E = e => async (t, n, r) => {
					let {
						gqlContext: a
					} = r;
					var d, p, b;
					const v = {
						subredditName: e.toLowerCase()
					};
					if (Object(u.a)(n(), v)) return;
					t(h(v));
					let x, E = Object(m.I)(n(), e);
					if (!E) {
						const n = await Object(l.a)(a(), e, !1);
						if (n.ok) {
							const e = n.body;
							E = null === (p = null === (d = null == e ? void 0 : e.data) || void 0 === d ? void 0 : d.subreddit) || void 0 === p ? void 0 : p.id
						}
						if (!E) {
							const e = n.error || {
								type: s.K.NOT_FOUND_ERROR
							};
							return void t(g({
								...v,
								error: e
							}))
						}
					}
					const O = await ((e, t) => Object(i.a)(e, {
						...c,
						variables: t
					}).then(e => {
						var t, n, s;
						if (e.ok) {
							const r = null === (s = null === (n = null === (t = e.body) || void 0 === t ? void 0 : t.data) || void 0 === n ? void 0 : n.subredditInfoByName) || void 0 === s ? void 0 : s.postGuidanceConfig;
							return {
								...e,
								body: {
									data: {
										subreddit: {
											postGuidanceConfig: r
										}
									}
								}
							}
						}
						return e
					}))(a(), {
						subredditName: e
					});
					if (O.ok) {
						x = null === (b = O.body.data.subreddit) || void 0 === b ? void 0 : b.postGuidanceConfig, t(f({
							...v,
							postGuidanceConfig: x
						}))
					} else {
						const n = O.error || {
							type: s.K.UNKNOWN_ERROR
						};
						t(g({
							...v,
							error: n
						})), o.c.withScope(t => {
							t.setExtra("info", {
								subredditName: e,
								responseBody: O.body,
								responseOk: O.ok
							}), o.c.captureMessage("issue with post guidance service")
						})
					}
				}
		},
		"./src/reddit/actions/reCaptchaEnterprise.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return h
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "e", (function() {
				return E
			}));
			var s = n("./src/lib/asyncActions/index.ts"),
				r = n("./src/lib/constants/euCookiePolicy.ts"),
				o = n("./src/lib/reCaptchaEnterprise/index.ts"),
				i = n("./src/lib/sentry/index.ts");

			function a(e) {
				return t => async (n, s, r) => {
					const o = s();
					if (e(o)) return t(n, s, r)
				}
			}
			var d = n("./node_modules/lodash/every.js"),
				c = n.n(d),
				l = n("./src/reddit/constants/experiments.ts"),
				u = n("./src/reddit/featureFlags/index.ts"),
				m = n("./src/reddit/featureFlags/utils.ts"),
				p = n("./src/reddit/helpers/chooseVariant/index.ts");
			const b = e => u.d.reCaptchaEnterprise(e),
				f = e => !!Object(p.c)(e, {
					experimentEligibilitySelector: Object(m.d)(Object(m.b)(...r.c)),
					experimentName: l.pf
				}),
				h = Object(s.b)("LOAD_RECAPTCHA_ENTERPRISE"),
				g = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
					return a(e => c()([b, f, e => e.tracking.reCaptchaEnterprise.load === s.a.New], t => t(e)))(async t => {
						t(h.requested());
						try {
							await o.b.loadScript(), t(h.succeeded())
						} catch (n) {
							if (t(h.failed()), !e) throw n;
							i.c.withScope(e => {
								Object(i.a)(e, {
									serverLogging: !1
								}), i.c.captureException(n)
							})
						}
					})
				},
				v = Object(s.b)("EXECUTE_RECAPTCHA_ENTERPRISE"),
				x = e => a(e => c()([b, f, e => e.tracking.reCaptchaEnterprise.load === s.a.Succeeded], t => t(e)))(async t => {
					t(v.requested());
					try {
						const n = await o.b.execute({
							action: e.action,
							fast: e.fast
						});
						return t(v.succeeded({
							token: n
						})), n
					} catch (n) {
						if (t(v.failed()), e.catchAndLogError) return i.c.withScope(e => {
							Object(i.a)(e, {
								serverLogging: !1
							}), i.c.captureException(n)
						}), "";
						throw n
					}
				}),
				E = Object(s.b)("SEND_RECAPTCHA_TOKEN")
		},
		"./src/reddit/actions/recentSubreddits/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "f", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			}));
			const s = "SET_RECENT_SUBREDDITS",
				r = "SUBREDDIT_VISITED",
				o = "SUBREDDIT_SAVED",
				i = "COPY_SAVED_SUBREDDITS",
				a = "COPY_SAVED_ID_SUBREDDITS",
				d = 10
		},
		"./src/reddit/actions/redditEmbed.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/tabBadging.ts"),
				i = n("./src/reddit/endpoints/me/index.ts"),
				a = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				d = n("./src/reddit/helpers/trackers/screenview.ts");
			const c = "REDDIT_EMBED_LOADED",
				l = "REDDIT_EMBED_FAILED",
				u = Object(r.a)("REDDIT_EMBED_PENDING"),
				m = Object(r.a)(c),
				p = Object(r.a)(l),
				b = (e, t) => async (e, n, s) => {
					let {
						apiContext: r
					} = s;
					const d = n();
					e(u());
					const c = await Object(i.a)(r());
					c.ok && c.body ? !t || c.body.account ? (e(m(c.body)), e(Object(o.d)()), f(d)) : Object(a.a)(e, d) : e(p(c.error))
				}, f = e => {
					e.platform.currentPage && e.platform.currentPage.routeMatch && e.platform.currentPage.routeMatch.route && e.platform.currentPage.routeMatch.route.meta && e.platform.currentPage.routeMatch.route.meta.name && e.platform.currentPage.routeMatch.route.meta.name === s.Tb.INBOX_PAGES && Object(d.f)(e)
				}
		},
		"./src/reddit/actions/removalReasons/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "removalReasonsPending", (function() {
				return $
			})), n.d(t, "removalReasonsLoaded", (function() {
				return ee
			})), n.d(t, "removalReasonsFailed", (function() {
				return te
			})), n.d(t, "removalReasonsRequested", (function() {
				return ne
			})), n.d(t, "removalReasonAddedPending", (function() {
				return se
			})), n.d(t, "removalReasonAddedSuccess", (function() {
				return re
			})), n.d(t, "removalReasonAddedFailed", (function() {
				return oe
			})), n.d(t, "addRemovalReason", (function() {
				return ie
			})), n.d(t, "editRemovalReasonPending", (function() {
				return ae
			})), n.d(t, "editRemovalReasonSuccess", (function() {
				return de
			})), n.d(t, "editRemovalReasonFailed", (function() {
				return ce
			})), n.d(t, "editRemovalReason", (function() {
				return le
			})), n.d(t, "deleteRemovalReasonPending", (function() {
				return ue
			})), n.d(t, "deleteRemovalReasonSuccess", (function() {
				return me
			})), n.d(t, "deleteRemovalReasonFailed", (function() {
				return pe
			})), n.d(t, "deleteRemovalReason", (function() {
				return be
			})), n.d(t, "removedItemsSelected", (function() {
				return fe
			})), n.d(t, "fetchReasonsAndOpenModal", (function() {
				return he
			})), n.d(t, "removalReasonSubmittedPending", (function() {
				return ge
			})), n.d(t, "removalReasonSubmittedSuccess", (function() {
				return ve
			})), n.d(t, "removalReasonSubmittedFailed", (function() {
				return xe
			})), n.d(t, "removalReasonMessagePending", (function() {
				return Ee
			})), n.d(t, "removalReasonPrivateMessageSuccess", (function() {
				return Oe
			})), n.d(t, "removalReasonPublicMessageSuccess", (function() {
				return Ce
			})), n.d(t, "removalReasonMessageFailed", (function() {
				return Ae
			})), n.d(t, "submitRemovalReason", (function() {
				return ye
			})), n.d(t, "submitBulkRemovalReason", (function() {
				return je
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/initializeClient/installReducer.ts"),
				o = n("./node_modules/redux/es/redux.js");
			const i = "REMOVALREASONS__LOAD_SUCCESS",
				a = "REMOVALREASONS__ADD_PENDING",
				d = "REMOVALREASONS__ADD_SUCCESS",
				c = "REMOVALREASONS__ADD_FAILED",
				l = "REMOVALREASONS__EDIT_PENDING",
				u = "REMOVALREASONS__EDIT_SUCCESS",
				m = "REMOVALREASONS__EDIT_FAILED",
				p = "REMOVALREASONS__DELETE_PENDING",
				b = "REMOVALREASONS__DELETE_SUCCESS",
				f = "REMOVALREASONS__DELETE_FAILED";
			var h = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "REMOVALREASONS__LOAD_PENDING":
					case i:
					case a:
					case d:
					case l:
					case u:
					case p:
					case b:
						return null;
					case "REMOVALREASONS__LOAD_FAILED":
					case c:
					case m:
					case f:
						return t.payload;
					default:
						return e
				}
			};
			var g = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "REMOVALREASONS__LOAD_PENDING":
						case a:
						case l:
						case p:
							return !0;
						case i:
						case "REMOVALREASONS__LOAD_FAILED":
						case d:
						case c:
						case u:
						case m:
						case b:
						case f:
							return !1;
						default:
							return e
					}
				},
				v = Object(o.c)({
					error: h,
					pending: g
				});
			const x = {};
			var E = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : x,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i: {
						const {
							response: n
						} = t.payload, {
							data: s
						} = n;
						return {
							...e,
							...s
						}
					}
					case d:
					case u: {
						const {
							reason: n
						} = t.payload;
						return {
							...e,
							[n.id]: n
						}
					}
					case b: {
						const {
							reasonId: n
						} = t.payload, {
							[n]: s,
							...r
						} = e;
						return r
					}
					default:
						return e
				}
			};
			const O = {};
			var C = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : O,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i: {
						const {
							subredditId: n,
							response: s
						} = t.payload, {
							order: r
						} = s;
						return {
							...e,
							[n]: r
						}
					}
					case d: {
						const {
							subredditId: n,
							reason: s
						} = t.payload;
						return {
							...e,
							[n]: [...e[n], s.id]
						}
					}
					case b: {
						const {
							subredditId: n,
							reasonId: s
						} = t.payload, r = [...e[n]].filter(e => e !== s);
						return {
							...e,
							[n]: r
						}
					}
					default:
						return e
				}
			};
			var A = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "REMOVALREASONS__REMOVEDITEMS_SELECTED": {
							const {
								subredditId: e,
								itemIds: n
							} = t.payload;
							return {
								itemIds: n,
								subredditId: e
							}
						}
						default:
							return e
					}
				},
				y = Object(o.c)({
					api: v,
					models: E,
					reasonOrder: C,
					removedItemIds: A
				}),
				j = n("./src/lib/constants/index.ts"),
				I = n("./src/lib/makeActionCreator/index.ts"),
				k = n("./src/lib/makeCommentsPageKey/index.ts"),
				_ = n("./src/lib/makeDraftKey/index.ts"),
				S = n("./src/reddit/actions/bulkActions/index.ts"),
				w = n("./src/reddit/actions/comment/index.ts"),
				T = n("./src/reddit/actions/comment/authoring.ts"),
				P = n("./src/reddit/actions/comment/moderation.ts"),
				N = n("./src/reddit/actions/modal.ts"),
				D = n("./src/reddit/actions/post.ts"),
				M = n("./src/reddit/actions/toaster.ts"),
				R = n("./src/reddit/constants/modals.ts"),
				L = n("./src/lib/makeApiRequest/index.ts"),
				B = n("./src/lib/omitHeaders/index.ts"),
				F = n("./src/reddit/constants/headers.ts"),
				U = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				H = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const G = (e, t) => Object(L.a)(Object(B.a)(e, [F.a]), {
					endpoint: Object(U.a)(`${e.apiUrl}/api/v1/modactions/removal_reasons/`),
					method: j.ob.POST,
					type: "json",
					data: {
						item_ids: t.itemIds,
						reason_id: t.reasonId,
						mod_note: t.modNote
					}
				}),
				Q = (e, t, n) => Object(L.a)(Object(B.a)(e, [F.a]), {
					endpoint: Object(U.a)(Object(H.a)(`${e.apiUrl}/api/v1/modactions/removal_${n}_message/`)),
					method: j.ob.POST,
					type: "json",
					data: t
				});
			var q = n("./src/reddit/helpers/isPost.ts"),
				W = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				z = n("./src/reddit/helpers/routeKey/index.ts"),
				V = n("./src/reddit/models/ModQueue/index.ts"),
				K = n("./src/reddit/models/PostDraft/index.ts"),
				Y = n("./src/reddit/models/RemovalReason/index.ts"),
				J = n("./src/reddit/models/Toast/index.ts"),
				X = n("./src/reddit/selectors/comments.ts"),
				Z = n("./src/reddit/selectors/platform.ts");
			Object(r.a)({
				features: {
					removalReasons: y
				}
			});
			const $ = Object(I.a)("REMOVALREASONS__LOAD_PENDING"),
				ee = Object(I.a)(i),
				te = Object(I.a)("REMOVALREASONS__LOAD_FAILED"),
				ne = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n().subreddits.models[e].name;
					t($());
					const i = await ((e, t) => Object(L.a)(Object(B.a)(e, [F.a]), {
						endpoint: `${e.apiUrl}/api/v1/${t}/removal_reasons.json`,
						method: j.ob.GET
					}))(r(), o);
					i.ok ? t(ee({
						subredditId: e,
						response: i.body
					})) : t(te(i.error))
				}, se = Object(I.a)(a), re = Object(I.a)(d), oe = Object(I.a)(c), ie = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = r().subreddits.models[e].name;
					n(se());
					const d = await ((e, t, n) => Object(L.a)(Object(B.a)(e, [F.a]), {
						endpoint: Object(U.a)(`${e.apiUrl}/api/v1/${t}/removal_reasons`),
						method: j.ob.POST,
						data: n
					}))(i(), a, t);
					if (d.ok) {
						const {
							id: r
						} = d.body, o = {
							...t,
							id: r
						};
						n(re({
							subredditId: e,
							reason: o
						})), n(Object(M.f)({
							kind: J.b.SuccessMod,
							text: s.fbt._("Removal reason added!", null, {
								hk: "2WSh8N"
							})
						}))
					} else n(oe(d.error))
				}, ae = Object(I.a)(l), de = Object(I.a)(u), ce = Object(I.a)(m), le = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = r().subreddits.models[e].name;
					n(ae());
					const d = await ((e, t, n) => Object(L.a)(Object(B.a)(e, [F.a]), {
						endpoint: Object(U.a)(`${e.apiUrl}/api/v1/${t}/removal_reasons/${n.id}`),
						method: j.ob.PUT,
						data: {
							message: n.message,
							title: n.title
						}
					}))(i(), a, t);
					d.ok ? (n(de({
						subredditId: e,
						reason: t
					})), n(Object(M.f)({
						kind: J.b.SuccessMod,
						text: s.fbt._("Removal reason saved", null, {
							hk: "28ScuL"
						})
					}))) : n(ce(d.error))
				}, ue = Object(I.a)(p), me = Object(I.a)(b), pe = Object(I.a)(f), be = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = r().subreddits.models[e].name;
					n(ue());
					const d = await ((e, t, n) => Object(L.a)(Object(B.a)(e, [F.a]), {
						endpoint: Object(U.a)(`${e.apiUrl}/api/v1/${t}/removal_reasons/${n}`),
						method: j.ob.DELETE
					}))(i(), a, t);
					d.ok ? (n(me({
						subredditId: e,
						reasonId: t
					})), n(Object(M.f)({
						kind: J.b.SuccessMod,
						text: s.fbt._("Removal reason deleted", null, {
							hk: "4xzgsa"
						})
					}))) : n(pe(d.error))
				}, fe = Object(I.a)("REMOVALREASONS__REMOVEDITEMS_SELECTED"), he = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s();
					i.features.removalReasons.reasonOrder[e] && i.features.removalReasons.reasonOrder[e].length > 0 || n(ne(e)), n(fe({
						subredditId: e,
						itemIds: t
					})), n(Object(N.i)(R.a.ADD_REMOVAL_REASON))
				}, ge = Object(I.a)("REMOVALREASONS__SUBMIT_PENDING"), ve = Object(I.a)("REMOVALREASONS__SUBMIT_SUCCESS"), xe = Object(I.a)("REMOVALREASONS__SUBMIT_FAILED"), Ee = Object(I.a)("REMOVALREASONS__MESSAGE_PENDING"), Oe = Object(I.a)("REMOVALREASONS__MESSAGE_PRIVATE_SUCCESS"), Ce = Object(I.a)("REMOVALREASONS__MESSAGE_PUBLIC_SUCCESS"), Ae = Object(I.a)("REMOVALREASONS__MESSAGE_FAILED"), ye = (e, t, n, s, r, o) => async (i, a, d) => {
					let {
						apiContext: c
					} = d;
					const l = a(),
						u = l.user.account && l.user.account.displayText,
						m = e[0],
						p = Object(q.a)(m) ? Y.e.Post : Y.e.Comment,
						b = p === Y.e.Post ? l.posts.models[m] : l.features.comments.models[m],
						f = p === Y.e.Post ? D.Q : w.j;
					if (!b || !u) return !1;
					i(ge()), i(f({
						[m]: {
							modNote: r,
							modRemovalReason: t && t.title,
							modReasonBy: u
						}
					}));
					const h = {
							itemIds: e,
							modNote: r,
							reasonId: t ? t.id : null
						},
						g = await G(c(), h);
					if (g.ok) {
						if (i(ve()), t) {
							i(Ee());
							const r = {
									itemId: e,
									message: n,
									title: t.title,
									isLocked: o,
									type: s
								},
								a = await Q(c(), Object(Y.h)(r, p), p);
							if (a.ok) {
								if ([Y.f.Public, Y.f.PublicAsSubreddit].includes(s)) {
									if (i(Ce()), a.body) {
										const e = Object(W.a)(a.body),
											t = {
												comment: e,
												parentId: m
											},
											n = Object(Z.f)(l),
											s = l.platform.currentPage && l.platform.currentPage.routeMatch;
										let r = n && s && Object(z.a)(s, l, l.posts.models[e.postId]);
										if (r || (r = Object(k.a)(e.postId, null, {
												sort: j.w,
												hasSortParam: !0
											})), p === Y.e.Post) {
											const n = Object(_.a)(K.c.replyToPost, m);
											i(Object(T.r)({
												...t,
												headCommentId: Object(X.w)(l, {
													commentsPageKey: r
												}),
												commentsPageKey: r,
												draftKey: n
											}));
											const s = l.postStickiedComments.data[m];
											i(Object(P.f)({
												id: e.id,
												postId: e.postId,
												commentsPageKey: r
											})), s && s !== e.id && i(Object(w.j)({
												[s]: {
													isStickied: !1
												}
											}))
										} else if (p === Y.e.Comment) {
											const e = Object(_.a)(K.c.replyToComment, b.id),
												n = Object(X.j)(l, {
													commentId: m,
													commentsPageKey: r
												});
											i(Object(T.p)({
												...t,
												parentCommentId: m,
												commentsPageKey: r,
												draftKey: e,
												depth: n + 1
											}))
										}
									}
								} else i(Oe());
								return !0
							}
							return i(Ae(a.error)), !1
						}
					} else i(xe(g.error)), i(f({
						[m]: {
							modNote: b.modNote,
							modRemovalReason: b.modRemovalReason,
							modReasonBy: b.modReasonBy
						}
					}));
					return !1
				}, je = (e, t, n, r, o) => async (i, a, d) => {
					let {
						apiContext: c
					} = d;
					const l = a(),
						u = l.user.account && l.user.account.displayText;
					if (!u) return;
					i(ge());
					const m = Object(M.f)({
							kind: J.b.SuccessMod,
							text: s.fbt._({
								"*": "Added removal reason for {number} posts/comments",
								_1: "Added removal reason for 1 post/comment"
							}, [s.fbt._plural(e.length, "number")], {
								hk: "3Gipsf"
							})
						}),
						p = {
							itemIds: e,
							modNote: o,
							reasonId: t ? t.id : null
						},
						b = await G(c(), p);
					if (b.ok) {
						const s = {
							ids: e,
							operation: V.a.RemovalReason,
							username: u,
							options: {
								modNote: o,
								removalReason: t && t.title
							}
						};
						if (i(Object(S.b)(s)), t) {
							const s = {
									itemId: e,
									message: n,
									title: t.title,
									type: r
								},
								o = await Q(c(), Object(Y.h)(s, Y.e.Bulk), Y.e.Bulk);
							o.ok ? (i(Oe()), i(m)) : i(Ae(o.error))
						} else i(m)
					} else i(xe(b.error))
				}
		},
		"./src/reddit/actions/reportFlow/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/lib/loadableAction/index.ts");
			const r = Object(s.a)(() => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/actions/reportFlow/reportFlow.ts")).then(e => e.postOrCommentReported)),
				o = Object(s.a)(() => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/actions/reportFlow/reportFlow.ts")).then(e => e.reportFlowOpened)),
				i = Object(s.a)(() => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/actions/reportFlow/reportFlow.ts")).then(e => e.reportFlowClosed))
		},
		"./src/reddit/actions/scheduledPosts/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "m", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "l", (function() {
				return l
			})), n.d(t, "k", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "o", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "n", (function() {
				return g
			})), n.d(t, "i", (function() {
				return v
			})), n.d(t, "r", (function() {
				return x
			})), n.d(t, "u", (function() {
				return E
			})), n.d(t, "p", (function() {
				return O
			})), n.d(t, "q", (function() {
				return C
			})), n.d(t, "v", (function() {
				return A
			})), n.d(t, "s", (function() {
				return y
			})), n.d(t, "x", (function() {
				return j
			})), n.d(t, "w", (function() {
				return I
			})), n.d(t, "t", (function() {
				return k
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			const r = "SCHEDULED_POSTS_REQUESTED",
				o = "SCHEDULED_POSTS_LOADED",
				i = "STANDALONE_SCHEDULED_POSTS_LOADED",
				a = "RECURRING_SCHEDULED_POSTS_LOADED",
				d = "SCHEDULED_POSTS_FAILED",
				c = "SCHEDULED_POST_CREATION_SUCCEEDED",
				l = "SCHEDULED_POST_SUBMIT_NOW_SUCCESS",
				u = "SCHEDULED_POST_MUTATE_REQUESTED",
				m = "SCHEDULED_POST_MUTATE_FAILED",
				p = "STANDALONE_POST_MUTATE_SUCCESS",
				b = "RECURRING_POST_MUTATE_SUCCESS",
				f = "RECURRING_POST__EDIT_MODAL_LOAD",
				h = "RECURRING_POST__EDIT_LOAD",
				g = "STANDALONE_POST__EDIT_LOAD",
				v = "SCHEDULED_POST__DELETE_SUCCESS",
				x = () => s.fbt._("Failed to load scheduled posts", null, {
					hk: "1fhkq4"
				}),
				E = () => s.fbt._("Whoops! Invalid scheduled post", null, {
					hk: "35jBb6"
				}),
				O = () => s.fbt._("Unable to delete scheduled post", null, {
					hk: "23nWms"
				}),
				C = () => s.fbt._("Successfully deleted scheduled post", null, {
					hk: "1Lk7r2"
				}),
				A = () => s.fbt._("Unable to submit scheduled post", null, {
					hk: "vCW43"
				}),
				y = () => s.fbt._("Retry", null, {
					hk: "4bCZ7M"
				}),
				j = () => s.fbt._("Successfully submitted scheduled post!", null, {
					hk: "ONo6q"
				}),
				I = () => s.fbt._("Successfully edited scheduled post!", null, {
					hk: "HfGcT"
				}),
				k = () => s.fbt._("Failed to update scheduled post", null, {
					hk: "2zBuRu"
				})
		},
		"./src/reddit/actions/scheduledPosts/delete.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/redditGQL/operations/DeleteScheduledPost.json");
			var d = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				c = n("./src/reddit/models/ScheduledPost/index.ts"),
				l = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				m = n("./src/telemetry/index.ts");
			const p = Object(s.a)(r.i),
				b = (e, t) => async (n, s, b) => {
					let {
						gqlContext: f
					} = b;
					const h = Object(u.a)(s(), {
						subredditId: e,
						scheduledPostId: t
					});
					h && Object(c.q)(h) && Object(m.a)(Object(d.s)()(s(), h)), h ? (await ((e, t) => Object(i.a)(e, {
						...a,
						variables: t
					}))(f(), {
						input: {
							id: h.id
						}
					})).ok ? (n(Object(o.f)(Object(o.e)(r.q(), l.b.SuccessCommunity))), n(p({
						subredditId: e,
						scheduledPostId: t
					}))) : n(Object(o.f)(Object(o.e)(r.p(), l.b.Error))) : n(Object(o.f)(Object(o.e)(r.u(), l.b.Error)))
				}
		},
		"./src/reddit/actions/scheduledPosts/edit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return x
			})), n.d(t, "a", (function() {
				return O
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react-router-redux/es/index.js"),
				o = n("./src/telemetry/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/scheduledPosts/index.ts"),
				d = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/endpoints/scheduledPosts/update.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				m = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				p = n("./src/reddit/models/ScheduledPost/index.ts"),
				b = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/routes/postCreation/index.ts"),
				h = n("./src/reddit/selectors/scheduledPosts/index.ts");
			const g = Object(i.a)(d.n),
				v = Object(i.a)(d.b),
				x = (e, t) => async (n, s, o) => {
					const i = Object(h.a)(s(), {
						scheduledPostId: t,
						subredditId: e
					});
					i && (await n(Object(r.b)(Object(f.c)(i.subreddit.name, i.collectionId))), n((Object(p.q)(i) ? v : g)(i)))
				}, E = (e, t) => {
					Object(p.q)(t) ? e(Object(a.d)({
						scheduledPost: t
					})) : e(Object(a.h)({
						scheduledPost: t
					}))
				}, O = (e, t, n) => async (r, i, f) => {
					let {
						gqlContext: g
					} = f;
					r(Object(a.g)());
					const v = Object(h.a)(i(), {
						subredditId: e,
						scheduledPostId: t
					});
					if (v && Object(p.q)(v) && Object(o.a)(Object(m.u)()(i(), v)), !v) return void r(Object(a.f)({
						message: s.fbt._("Scheduled post not found", null, {
							hk: "2zjM55"
						})
					}));
					if (!Object.keys(n).length) return void E(r, v);
					const x = await Object(l.a)(g(), {
							...n,
							id: t
						}),
						C = x.body;
					if (!(x.ok && C && C.data && C.data.updateScheduledPost && C.data.updateScheduledPost.ok && C.data.updateScheduledPost.scheduledPost)) return r(Object(a.f)({
						message: x.error && x.error.fields && x.error.fields.length && x.error.fields[0].msg || s.fbt._("Unknown error", null, {
							hk: "fXs5s"
						})
					})), void r(Object(c.f)(Object(c.e)(d.t(), b.b.Error, d.s(), O(e, t, n))));
					r(Object(c.f)(Object(c.e)(d.w(), b.b.SuccessCommunity))), E(r, Object(u.d)(C.data.updateScheduledPost.scheduledPost))
				}
		},
		"./src/reddit/actions/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return v
			})), n.d(t, "f", (function() {
				return x
			})), n.d(t, "h", (function() {
				return E
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "e", (function() {
				return k
			})), n.d(t, "i", (function() {
				return S
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "b", (function() {
				return P
			}));
			var s = n("./src/lib/assertNever.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				i = n("./src/reddit/actions/scheduledPosts/edit.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/endpoints/scheduledPosts/index.ts"),
				c = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				l = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				u = n("./src/reddit/models/ScheduledPost/index.ts"),
				m = n("./src/reddit/models/Toast/index.ts"),
				p = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				b = n("./src/telemetry/index.ts");
			const f = 25,
				h = 1e4,
				g = Object(r.a)(o.g),
				v = Object(r.a)(o.k),
				x = Object(r.a)(o.j),
				E = Object(r.a)(o.o),
				O = Object(r.a)(o.d),
				C = Object(r.a)(o.f),
				A = Object(r.a)(o.m),
				y = Object(r.a)(o.a),
				j = Object(r.a)(o.c),
				I = Object(r.a)(o.e),
				k = Object(r.a)(o.h),
				_ = (e, t) => {
					e(I()), e(Object(a.f)(Object(a.e)(o.r(), m.b.Error, o.s(), S(t))))
				},
				S = e => {
					let {
						subredditId: t,
						includeStandalone: n = {
							standaloneFirst: f
						},
						includeRecurring: s = {
							recurringFirst: h
						},
						...r
					} = e;
					return async (e, o, i) => {
						let {
							gqlContext: a
						} = i;
						if (Object(p.h)(o(), {
								subredditId: t
							})) return;
						e(g());
						const l = {
								subredditId: t,
								includeRecurring: s,
								includeStandalone: n,
								...r
							},
							u = await Object(d.b)(a(), l);
						Object(d.f)(u, l) ? T(e, Object(c.e)(u.body.data), l) : _(e, l)
					}
				},
				w = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n();
					if (!Object(p.h)(o, {
							subredditId: e
						})) return t(S({
						subredditId: e
					}));
					if (!Object(p.g)(o, {
							subredditId: e,
							type: u.g.standalonePosts
						})) return;
					const i = Object(p.c)(o, {
						subredditId: e,
						type: u.g.standalonePosts
					});
					if (!i) return;
					t(g());
					const a = {
							subredditId: e,
							includeStandalone: {
								standaloneFirst: f,
								standaloneAfter: i
							}
						},
						l = await Object(d.b)(r(), a);
					l.ok ? T(t, Object(c.e)(l.body.data), a) : t(I())
				}, T = (e, t, n) => {
					Object(c.b)(t) ? e(C(t)) : Object(c.a)(t) ? e(y(t)) : Object(c.c)(t) ? e(A(t)) : _(e, n)
				}, P = (e, t) => async (n, r, o) => {
					const a = {},
						d = r();
					switch (e) {
						case "isModDistinguished":
						case "isNsfw":
						case "isOriginalContent":
						case "isContestMode":
						case "isPostAsMetaMod":
						case "isSpoiler":
							a[e] = !t[e];
							break;
						case "isSticky":
							const n = !!t.sticky && "NONE" !== t.sticky;
							a.sticky = n ? "NONE" : "SECOND";
							break;
						default:
							return Object(s.a)(e)
					}
					Object(b.a)(Object(l.t)(e, a[e], Object(u.q)(t))(d)), n(Object(i.a)(t.subreddit.id, t.id, a))
				}
		},
		"./src/reddit/actions/seo/linksModule.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "d", (function() {
				return m
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/endpoints/goodContent/index.ts");
			const o = "FRONTPAGE_LINKS__REQUEST_LOADED",
				i = "SUBREDDIT_LINKS_LOADED",
				a = 10,
				d = Object(s.a)("FRONTPAGE_LINKS__REQUEST_PENDING"),
				c = Object(s.a)("FRONTPAGE_LINKS__REQUEST_FAILED"),
				l = Object(s.a)(o),
				u = Object(s.a)(i),
				m = () => async e => {
					e(d());
					const t = await Object(r.a)();
					e(t ? l(t) : c())
				}
		},
		"./src/reddit/actions/seo/topicLinks.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "SUBREDDIT_TOPIC_LINKS_LOADED",
				o = Object(s.a)(r)
		},
		"./src/reddit/actions/shortcuts/utils.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			}));
			var s = n("./src/reddit/constants/shortcuts.ts"),
				r = n("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				o = n("./src/reddit/helpers/routeKey/index.ts");
			const i = e => {
					const t = e.platform.currentPage;
					if (!t || !t.routeMatch) return;
					const n = t.routeMatch,
						s = Object(r.a)(e);
					return Object(o.b)(n, e, s)
				},
				a = e => {
					const t = document.getElementById(e);
					t && t.focus()
				},
				d = e => {
					const t = document.getElementById(e),
						n = window.scrollX,
						s = window.scrollY;
					t && (t.focus(), window.scrollTo(n, s))
				},
				c = () => {
					d(s.b)
				}
		},
		"./src/reddit/actions/snoovatar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "e", (function() {
				return v
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "d", (function() {
				return E
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = n("./src/config.ts"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts");
			var u = n("./src/reddit/reducers/features/avatar/index.ts"),
				m = n("./src/reddit/selectors/avatar.ts"),
				p = n("./src/reddit/actions/users.ts");
			Object(s.a)({
				features: {
					avatar: u.a
				}
			});
			const b = "SET_AVATAR_USER",
				f = Object(r.a)(b),
				h = "RANDOM_AVATAR_LOADED",
				g = Object(r.a)(h),
				v = (e, t, n) => async (s, r, o) => {
					let {
						apiContext: u
					} = o;
					var b, f, h, g;
					const v = Object(m.b)(r()),
						x = await (async (e, t, n, s, r) => Object(d.a)(Object(c.a)(e, [l.a]), {
							endpoint: `${i.a.snoovatarUrl}/api/snoovatar?skip_telemetry=true`,
							method: a.ob.POST,
							headers: {
								"Content-Type": "application/json ",
								"X-CSRF-Token": r || ""
							},
							data: {
								accessory_ids: t,
								styles: n,
								...s
							}
						}))(u(), e, t, n, v);
					if (!x.ok) throw new Error("User avatar failed to save");
					return s(Object(p.y)(x.body)), {
						accountIcon: null === (f = null === (b = x.body) || void 0 === b ? void 0 : b.avatar) || void 0 === f ? void 0 : f.headshot_image_url,
						fullBodySnoovatar: null === (g = null === (h = x.body) || void 0 === h ? void 0 : h.avatar) || void 0 === g ? void 0 : g.image_url
					}
				}, x = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					try {
						const t = await (async e => Object(d.a)(Object(c.a)(e, [l.a]), {
							endpoint: `${i.a.snoovatarUrl}/api/account`,
							method: a.ob.GET
						}))(s());
						t.ok && e(f(t.body))
					} catch (r) {
						o.c.captureException(r)
					}
				}, E = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					try {
						const t = await (async e => Object(d.a)(Object(c.a)(e, [l.a]), {
							endpoint: `${i.a.snoovatarUrl}/api/snoovatars/random:byId`,
							method: a.ob.GET
						}))(s());
						t.ok && e(g(t.body))
					} catch (r) {
						o.c.captureException(r)
					}
				}
		},
		"./src/reddit/actions/snoovatarModal.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			}));
			var s = n("./src/lib/pageTitle/index.ts"),
				r = n("./src/reddit/actions/login.ts"),
				o = n("./src/reddit/actions/modal.ts"),
				i = n("./src/reddit/actions/platform.ts"),
				a = n("./src/reddit/actions/users.ts"),
				d = n("./src/reddit/constants/modals.ts"),
				c = n("./src/reddit/helpers/trackers/snoovatar.ts"),
				l = n("./src/reddit/selectors/user.ts"),
				u = n("./src/telemetry/index.ts");
			const m = () => async (e, t) => {
				const n = t();
				Object(u.a)(Object(c.l)(n)), e(Object(a.s)({
					forceFetch: !0
				})), await e(Object(o.g)(d.a.SNOOVATAR_MODAL))
			};

			function p() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
				return async (t, n) => {
					const {
						clickSource: a,
						share: m,
						source: p,
						activeTab: b,
						activeMeSubpage: f,
						activeDetails: h,
						shopTabState: g
					} = e, v = n();
					a && Object(u.a)(Object(c.g)(a)(v)), Object(l.S)(v) ? (await t(Object(o.h)(d.a.SNOOVATAR_MODAL, {
						share: m,
						source: p,
						activeTab: b,
						activeMeSubpage: f,
						activeDetails: h,
						shopTabState: g
					})), t(Object(i.n)({
						title: Object(s.n)()
					}))) : await t(Object(r.openLoginModal)())
				}
			}
		},
		"./src/reddit/actions/structuredStyles/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return s
			})), n.d(t, "k", (function() {
				return r
			})), n.d(t, "j", (function() {
				return o
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "n", (function() {
				return f
			})), n.d(t, "m", (function() {
				return h
			}));
			const s = "STRUCTURED_STYLES__STYLES_RESET_PENDING",
				r = "STRUCTURED_STYLES__STYLES_RESET_LOADED",
				o = "STRUCTURED_STYLES__STYLES_RESET_FAILED",
				i = "SUBREDDIT__STYLES_PENDING",
				a = "SUBREDDIT__STYLES_LOADED",
				d = "SUBREDDIT__STYLES_FAILED",
				c = "STRUCTURED_STYLES__DRAFT_REPLACED",
				l = "STRUCTURED_STYLES__DRAFT_UPDATED",
				u = "STRUCTURED_STYLES__EDITING_STOPPED",
				m = "STRUCTURED_STYLES__EDITING_STARTED",
				p = "STRUCTURED_STYLES__IMAGE_UPLOAD_ADDED",
				b = "STRUCTURED_STYLES__DIRTIED_BLADE_EDITOR",
				f = "STRUCTURED_STYLES__UNDIRTIED_BLADE_EDITOR",
				h = "STRUCTURED_STYLES__STYLES_UPDATED_LOADED"
		},
		"./src/reddit/actions/structuredStyles/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return B
			})), n.d(t, "k", (function() {
				return H
			})), n.d(t, "j", (function() {
				return W
			})), n.d(t, "e", (function() {
				return V
			})), n.d(t, "d", (function() {
				return Y
			})), n.d(t, "g", (function() {
				return X
			})), n.d(t, "c", (function() {
				return $
			})), n.d(t, "f", (function() {
				return te
			})), n.d(t, "b", (function() {
				return ne
			})), n.d(t, "m", (function() {
				return se
			})), n.d(t, "a", (function() {
				return re
			})), n.d(t, "h", (function() {
				return oe
			})), n.d(t, "i", (function() {
				return ie
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/omit.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/pick.js"),
				i = n.n(o),
				a = n("./node_modules/react-router-redux/es/index.js"),
				d = n("./src/lib/filterQueryParams/index.ts"),
				c = n("./src/lib/formatApiError/index.ts"),
				l = n("./src/lib/makeActionCreator/index.ts"),
				u = n("./src/reddit/actions/apiRequestState.ts"),
				m = n("./src/reddit/actions/imageUploads.ts"),
				p = n("./src/reddit/actions/modal.ts"),
				b = n("./src/reddit/endpoints/moderator/structuredStyles.ts"),
				f = n("./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts"),
				h = n("./src/reddit/selectors/postFlair.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				v = n("./src/reddit/actions/postFlairStyleTemplates/constants.ts");
			const x = Object(l.a)(v.c),
				E = Object(l.a)(v.b),
				O = Object(l.a)(v.a);
			var C = n("./src/reddit/actions/toaster.ts"),
				A = n("./src/reddit/actions/widgets/index.ts"),
				y = n("./src/reddit/constants/modals.ts"),
				j = n("./src/reddit/helpers/getGenericUploadError.ts"),
				I = n("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				k = n("./src/reddit/helpers/media/index.ts"),
				_ = n("./src/reddit/models/Image/index.tsx"),
				S = n("./src/reddit/models/StructuredStyles/index.ts"),
				w = n("./src/reddit/models/Toast/index.ts"),
				T = n("./src/reddit/selectors/activeModalId.ts"),
				P = n("./src/reddit/selectors/platform.ts"),
				N = n("./src/reddit/selectors/structuredStyles.ts"),
				D = n("./src/reddit/selectors/user.ts"),
				M = n("./src/reddit/helpers/trackers/blade.ts"),
				R = n("./src/telemetry/index.ts"),
				L = n("./src/reddit/actions/structuredStyles/constants.ts");
			const B = Object(l.a)(L.m),
				F = {
					bannerBackgroundImage: ["bannerBackgroundImagePosition"],
					bannerPositionedImage: ["bannerPositionedImagePosition", "secondaryBannerPositionedImage"]
				},
				U = e => {
					const t = {
						...e
					};
					return Object.keys(e).forEach(n => {
						F[n] && !e[n] && F[n].forEach(e => t[e] = null)
					}), t
				},
				H = (e, t, n, s) => async (r, o, i) => {
					const {
						apiContext: a
					} = i, d = o(), l = U(t), p = d.structuredStyles.models[e];
					let f;
					for (const e in l)
						if (l[e] !== p[e]) {
							f = !0;
							break
						} if (!f) return;
					r(Object(u.h)(s));
					const h = Object(M.i)(n)(d);
					let v = null,
						x = null;
					try {
						(v = await Object(m.f)(o(), _.a.StructuredStyles)) && (x = Object(m.m)(v)(r, o, i))
					} catch (y) {
						const e = Object(j.a)("webSocket");
						return void r(Object(u.f)(s, e))
					}
					const E = Object(g.X)(d, {
							subredditId: e
						}).name,
						O = await b.e(a(), E, l),
						A = {};
					if (O.ok) {
						if (x) try {
							await x
						} catch (y) {}
						const n = Object(N.f)(o(), {
							apiRequestId: s
						});
						for (const e in n)
							if (e in t) {
								const t = Object(N.g)(o(), {
									name: e
								});
								t && Object(_.j)(t) && (A[e] = n[e])
							} Object.keys(A).length && r(K(A)), r(Object(u.e)(s)), r(B({
							subredditId: e,
							styles: {
								...l,
								...A
							}
						}))
					} else v && v.websocket.close(), r(Object(u.f)(s, O.error)), O.body && r(C.f({
						kind: w.b.Error,
						text: Object(c.a)(O.error, O.status)
					}));
					Object(R.a)({
						...h,
						actionInfo: {
							...h.actionInfo,
							success: O.ok
						}
					})
				}, G = Object(l.a)(L.l), Q = Object(l.a)(L.k), q = Object(l.a)(L.j), W = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t(G({
						subredditId: e
					}));
					const o = Object(g.X)(n(), {
							subredditId: e
						}).name,
						i = await b.f(r(), o);
					if (i.ok) {
						const s = n().structuredStyles.models[e],
							r = s ? s.mobileKeyColor : null;
						t(Q({
							subredditId: e,
							styles: {
								mobileKeyColor: r
							}
						}))
					} else t(q({
						subredditId: e,
						...i.error
					}))
				}, z = Object(l.a)(L.d), V = e => async (t, n, s) => {
					const r = n(),
						o = r.structuredStyles.models[e] || {},
						i = Object(D.fb)(r);
					t(z({
						isNightmodeOn: i,
						styles: o,
						subredditId: e
					})), le(e, !1)(t, n, s), (e => async (t, n, s) => {
						let {
							gqlContext: r
						} = s;
						const o = n(),
							i = Object(g.X)(o, {
								subredditId: e
							});
						if (!i) return;
						const a = Object(h.d)(o, {
								subredditId: e
							}),
							d = a && a.templateIds;
						if (!d || !d.length) return;
						t(x({
							subredditId: e
						}));
						const c = await Object(b.a)(r(), i.name, d);
						if (c.ok) {
							const n = {};
							if (c.body) {
								const {
									data: e
								} = c.body;
								if (e && e.subreddit)
									for (const t of e.subreddit.postFlairStyleTemplates) n[t.id] = Object(f.a)(t)
							}
							t(E({
								subredditId: e,
								templates: n
							}))
						} else t(O({
							subredditId: e,
							error: c.error
						}))
					})(e)(t, n, s), Object(A.g)(e, !1)(t, n, s)
				}, K = Object(l.a)(L.c), Y = e => async (t, n, s) => {
					const r = U(e),
						o = n();
					for (const e in r)
						if (Object(S.l)(e))
							if (r[e]) {
								if ("string" != typeof r[e]) {
									const o = r[e],
										i = await Object(_.e)(o);
									X(e, i)(t, n, s), r[e] = ""
								}
							} else {
								const n = Object(N.g)(o, {
									name: e
								});
								n && t(Object(m.h)(n))
							} t(K(r))
				}, J = Object(l.a)(L.f), X = (e, t, n) => async (s, r, o) => {
					const i = r(),
						a = n || i.structuredStyles.isEditing,
						d = Object(g.X)(i, {
							subredditId: a
						}).name;
					s(J({
						imageKey: e,
						uploadId: t.id
					})), s(Object(m.k)(t));
					const c = await b.d(o.apiContext(), d, t.file.name, e, await Object(k.h)(t.file));
					try {
						const n = await Object(m.g)(r(), c, t, _.a.StructuredStyles);
						if (n) {
							const t = n.url;
							s(Object(m.j)(n)), s(K({
								[e]: t
							}))
						}
					} catch (l) {
						if (l instanceof Error) throw l;
						s(Object(m.i)(l))
					}
				}, Z = Object(l.a)(L.b), $ = (e, t, n) => async (s, o, a) => {
					const d = o(),
						c = d.structuredStyles.models[e] || {},
						l = d.structuredStyles.draft,
						u = Object(M.h)(t)(d);
					if (n) {
						const t = i()(c, n),
							o = {
								...r()(l, n),
								...t
							};
						s(Z({
							subredditId: e,
							styles: o
						}))
					} else {
						s(Z({
							subredditId: e,
							styles: c
						}))
					}
					Object(R.a)(u)
				}, ee = Object(l.a)(L.e), te = () => async (e, t, n) => {
					const s = t(),
						r = Object(D.gb)(s),
						o = !!Object(P.a)(s);
					if (e(ee({
							nightmodeTempUpdated: r
						})), o) return;
					const {
						url: i
					} = s.platform.currentPage;
					i && e(Object(a.c)(Object(d.a)(i, ["styling", "route"])))
				}, ne = Object(l.a)(L.a), se = Object(l.a)(L.n), re = () => async e => e(te()), oe = e => async (t, n) => {
					const s = n(),
						r = Object(N.i)(s);
					!Object(T.b)(y.a.BLADE_UNSAVED_CHANGES)(s) && r && (Object(N.a)(s, {
						subredditId: e
					}) ? t(Object(p.i)(y.a.BLADE_UNSAVED_CHANGES)) : t(re()))
				}, ie = e => async (t, n) => {
					const s = n();
					Object(N.i)(s) || t(Object(D.fb)(s) ? Object(p.i)(y.a.BLADE_NIGHTMODE) : V(e))
				}, ae = Object(l.a)(L.i), de = Object(l.a)(L.h), ce = Object(l.a)(L.g), le = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o,
						apiContext: i
					} = r;
					n(ae({
						subredditId: e
					}));
					const a = Object(g.X)(s(), {
						subredditId: e
					});
					if (!a) return;
					if (!t) {
						const s = await b.c(i(), a.name, t);
						if (s.ok) {
							const t = s.body,
								r = t.data ? t.data.style : {};
							n(de({
								subredditId: e,
								styles: r
							}))
						} else n(ce({
							subredditId: e,
							...s.error
						}));
						return
					}
					const d = await b.b(o(), a.name);
					if (d.ok) {
						let t = {};
						if (d.body) {
							const {
								data: e
							} = d.body;
							e && e.subreddit && e.subreddit.styles && (t = Object(I.a)(e.subreddit.styles))
						}
						n(de({
							subredditId: e,
							styles: t
						}))
					} else n(ce({
						subredditId: e,
						...d.error
					}))
				}
		},
		"./src/reddit/actions/subreddit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "m", (function() {
				return J
			})), n.d(t, "l", (function() {
				return X
			})), n.d(t, "k", (function() {
				return Z
			})), n.d(t, "j", (function() {
				return $
			})), n.d(t, "i", (function() {
				return ee
			})), n.d(t, "h", (function() {
				return te
			})), n.d(t, "d", (function() {
				return ne
			})), n.d(t, "p", (function() {
				return ie
			})), n.d(t, "t", (function() {
				return ae
			})), n.d(t, "o", (function() {
				return le
			})), n.d(t, "r", (function() {
				return pe
			})), n.d(t, "g", (function() {
				return be
			})), n.d(t, "f", (function() {
				return fe
			})), n.d(t, "e", (function() {
				return he
			})), n.d(t, "q", (function() {
				return Ee
			})), n.d(t, "b", (function() {
				return Oe
			})), n.d(t, "c", (function() {
				return Ce
			})), n.d(t, "a", (function() {
				return Ae
			})), n.d(t, "u", (function() {
				return ke
			})), n.d(t, "n", (function() {
				return _e
			})), n.d(t, "s", (function() {
				return Se
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				i = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/listingSort/index.ts"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/lib/makeListingKey/index.ts"),
				l = n("./src/reddit/actions/economics/helpers/async.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/modQueueTriggers/index.ts"),
				p = n("./src/reddit/actions/pages/subreddit/index.ts"),
				b = n("./src/reddit/actions/preferences.ts"),
				f = n("./src/reddit/actions/subredditModeration/modUserNotes.ts"),
				h = n("./src/reddit/actions/subredditRules/constants.ts"),
				g = n("./src/reddit/actions/toaster.ts"),
				v = n("./src/reddit/constants/history.ts"),
				x = n("./src/reddit/constants/modals.ts"),
				E = n("./src/reddit/constants/page.ts"),
				O = n("./src/reddit/constants/parameters.ts"),
				C = n("./src/reddit/constants/postLayout.ts"),
				A = n("./src/reddit/contexts/PageLayer/index.tsx"),
				y = n("./src/reddit/endpoints/governance/posts.ts"),
				j = n("./src/reddit/endpoints/messages/index.ts"),
				I = n("./src/reddit/endpoints/modQueue/index.ts"),
				k = n("./src/reddit/endpoints/page/subredditPage.ts"),
				_ = n("./src/reddit/endpoints/subreddit/about.ts"),
				S = n("./src/reddit/endpoints/subreddit/rules.ts"),
				w = n("./src/reddit/endpoints/user/preferences.ts"),
				T = n("./src/reddit/helpers/addSupplementaryTextInfoToAdPosts.ts"),
				P = n("./src/reddit/helpers/filterListingResponse/index.ts"),
				N = n("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				D = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				M = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				R = n("./src/reddit/helpers/trackers/feed.ts"),
				L = n("./src/reddit/models/Subreddit/index.ts"),
				B = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				F = n("./src/reddit/models/Toast/index.ts"),
				U = n("./src/reddit/models/User/index.ts"),
				H = n("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				G = n("./src/reddit/selectors/moderatorPermissions.ts"),
				Q = n("./src/reddit/selectors/profile.ts"),
				q = n("./src/reddit/selectors/subreddit.ts"),
				W = n("./src/reddit/selectors/user.ts"),
				z = n("./src/lib/isFakeSubreddit/index.ts"),
				V = n("./src/reddit/endpoints/page/popularFeed.ts"),
				K = n("./src/reddit/selectors/experiments/popularGqlMigration.ts");
			const Y = {},
				J = "SUBREDDIT__MODEL_SUCCEEDED",
				X = "SUBREDDIT__MODEL_PENDING",
				Z = "SUBREDDIT__MODEL_FAILED",
				$ = "SUBREDDIT__MORE_POSTS_PENDING",
				ee = "SUBREDDIT__MORE_POSTS_LOADED",
				te = "SUBREDDIT__MORE_POSTS_FAILED",
				ne = "SUBREDDIT__META_FILTER_TOGGLED",
				se = Object(d.a)($),
				re = Object(d.a)(ee),
				oe = Object(d.a)(te),
				ie = Object(d.a)(ne),
				ae = Object(d.a)(h.b),
				de = Object(d.a)(h.c),
				ce = Object(d.a)(h.a),
				le = (e, t) => async (n, s) => {
					await (t === L.g.User ? n(ue(e)) : n(me(e)))
				}, ue = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = Object(Q.o)(n(), e),
						i = await Object(S.c)(r(), e);
					if (i.ok) {
						const e = i.body;
						t(ae({
							rules: e,
							subredditId: o
						}))
					}
				}, me = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					const i = Object(q.I)(n(), e);
					t(de());
					const a = await Object(S.b)(o(), e);
					if (a.ok) {
						const e = a.body;
						t(ae({
							rules: e,
							subredditId: i
						}))
					} else {
						t(ce());
						const n = `error-block-${e}`;
						t(g.f({
							id: n,
							kind: F.b.Error,
							text: s.fbt._("An error has occurred. Please try again later", null, {
								hk: "Elbdz"
							})
						}))
					}
				}, pe = e => async (t, n, s) => {
					let {
						apiContext: r,
						gqlContext: d
					} = s;
					const {
						subredditName: u
					} = e;
					let p = e.t;
					const b = n(),
						h = Object(N.a)(e, b),
						g = b.platform.currentPage ? b.platform.currentPage.queryParams : {},
						{
							currentPage: x
						} = b.platform,
						{
							countryCode: j,
							languageCode: I
						} = (null == x ? void 0 : x.urlParams) || {},
						_ = Object(c.a)(u, h, {
							t: p,
							...g
						}),
						S = b.listings.postOrder.loadMore[_],
						w = b.listings.postOrder.listingSort[_];
					let D = h;
					if (w && !D) {
						const e = Object(a.d)(w.sort);
						D = e.sort, p = e.timeSort
					}
					const M = b.listings.postOrder.api.pending[_],
						{
							fetchedTokens: L
						} = b.listings.postOrder,
						B = !(!L[_] || !L[_][S.token]);
					if (M || B) return;
					if (D === i.bb.AWARDED && u === E.g) return;
					t(se({
						key: _,
						fetchedToken: S.token
					}));
					const F = {
							after: S.token,
							dist: S.dist,
							forceGeopopular: u === E.d.Popular,
							layout: C.e[Object(A.U)(b, {})],
							sort: D,
							t: p,
							...o()(g, [...O.p, O.l])
						},
						U = !Object(z.a)(u, {
							countryCode: j,
							languageCode: I
						}) && Object(H.a)(b);
					let Q;
					Q = Object(z.c)(u, {
						countryCode: j,
						languageCode: I
					}) && (Object(K.a)(b) || Object(K.b)(b)) ? () => Object(V.a)(d(), Object(k.c)(b, u, F, !0)) : U ? () => Object(k.b)(d(), Object(k.c)(b, u, {
						...F,
						limit: C.a
					}), Object(W.bb)(b)) : () => Object(k.a)(r(), u, F);
					const Y = await Q(),
						J = {
							...Y.body,
							...Object(P.a)(b, _, Y.body)
						};
					if (Y.ok) {
						if (!U) {
							const e = await Object(T.a)(r(), J.posts, b);
							J.posts = e
						}
						let e;
						const s = J.postIds.filter(e => !!J.posts[e].isMeta),
							o = Object(q.I)(n(), u);
						if (s.length) {
							const t = await Object(y.a)(r(), o, s);
							t.ok && (e = t.body)
						}
						const i = Object(G.h)(b, {
							subredditId: Object(q.I)(b, u)
						});
						if (!U && i && t(Object(m.a)({
								postIds: J.postIds
							})), t(re({
								fetchedToken: S.token,
								key: _,
								meta: b.meta,
								governance: e,
								...J
							})), Object(G.i)(b, o)) {
							let e;
							U || (e = await Object(k.b)(d(), Object(k.c)(b, u, {
								...F,
								limit: C.a
							}), Object(W.bb)(b)));
							const n = U ? J : e.body;
							if (U ? n : e.ok) {
								const e = n.postIds.map(e => n.posts[e].lastAuthorModNote);
								t(Object(f.e)({
									subredditId: o,
									nodes: e
								}))
							}
						}
						await t(Object(l.a)({
							subredditId: o,
							postIds: J.postIds,
							skip: ["communityDetails", "subscription"]
						})), Object(R.b)(v.a.NextPageLoad)(n())
					} else {
						t(oe({
							error: Y.error,
							fetchedToken: S.token,
							key: _,
							...J
						}));
						const e = Y.error;
						Object(R.a)(e ? `${Y.status||"000"}: ${e.type}` : "000: UNKNOWN_ERROR")(n())
					}
				}, be = "SUBSCRIPTION__MODERATED_SUBREDDITS_PENDING", fe = "SUBSCRIPTION__MODERATED_SUBREDDITS_LOADED", he = "SUBSCRIPTION__MODERATED_SUBREDDITS_FAILED", ge = Object(d.a)(be), ve = Object(d.a)(fe), xe = Object(d.a)(he), Ee = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = t();
					if (!r.user.account || r.subreddits.moderated.api.fetched) return;
					e(ge());
					const o = await Object(I.c)(s(), i.wb.Modqueue, {
						moderated: !0,
						moderated_limit: 50
					});
					o.ok ? e(ve(o.body)) : e(xe({
						error: o.error
					}))
				}, Oe = "SUBREDDIT__ABOUT_PENDING", Ce = "SUBREDDIT__ABOUT_SUCCEEDED", Ae = "SUBREDDIT__ABOUT_FAILED", ye = Object(d.a)(Oe), je = Object(d.a)(Ce), Ie = Object(d.a)(Ae), ke = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n();
					if (Object(q.z)(o, {
							subredditName: e
						}) || o.subreddits.api.about.error[e.toLowerCase()] || o.subreddits.api.about.pending[e.toLowerCase()]) return;
					t(ye({
						subredditName: e
					}));
					const i = !Object(q.I)(o, e),
						a = await Object(_.a)(r(), e, i);
					if (a.ok) {
						const n = a.body.data.subreddit,
							s = Object(D.a)(n),
							r = i ? Object(M.a)(n) : void 0;
						t(je({
							subredditName: e,
							subreddits: r ? {
								[r.id]: r
							} : void 0,
							data: s
						}))
					} else t(Ie({
						subredditName: e,
						error: a.error
					}))
				}, _e = (e, t, n) => async (s, r, o) => {
					let {
						apiContext: i
					} = o;
					var a;
					const d = e.substring(2),
						c = n === B.e.View ? null === (a = Object(W.h)(r(), d)) || void 0 === a ? void 0 : a.subredditId : Object(q.I)(r(), d),
						l = Object(W.m)(r());
					if (l && c) {
						const e = ((e, t, n, s) => {
							return {
								to: `/r/${e}`,
								subject: `[join] I would like to join ${e}`,
								text: n + "\n\n   *To approve this user*, visit [the approved users page for r/" + e + "](https://www.reddit.com/r/" + e + "/about/contributors?user=" + t + ') and click "ADD USER".\n    Approving this user gives them permission to ' + s + ". You can change these community restrictions from the [community settings](/r/" + e + "/about/edit) page.\n\n   To get more information about this user, visit the profile page of [u/" + t + "](/u/" + t + ") or reply to this message to start a conversation."
							}
						})(d, Object(U.e)(l), t, n);
						if ((await Object(j.b)(i(), e)).ok) {
							const e = new Date,
								t = {
									isContributorRequestTimestamp: e.setDate(e.getDate())
								};
							s(Object(b.D)({
								subredditId: c,
								prefs: t
							})), Object(w.j)(c, t, i()), n !== B.e.View && s(Object(u.i)(x.a.CONTRIBUTOR_REQUEST_PENDING))
						}
					}
				}, Se = e => async (t, n) => {
					const s = n(),
						{
							subredditName: r
						} = e,
						o = e.t,
						i = Object(N.a)(e, s),
						a = s.platform.currentPage ? s.platform.currentPage.queryParams : Y,
						d = Object(c.a)(r, i, {
							t: o,
							...a
						}),
						l = {
							t: o,
							sort: i,
							isRefresh: !0,
							...a
						};
					await t(Object(p.subredditDataRequested)(d, r, l, !0))
				}
		},
		"./src/reddit/actions/subreddit/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "o", (function() {
				return i
			})), n.d(t, "n", (function() {
				return a
			})), n.d(t, "w", (function() {
				return d
			})), n.d(t, "v", (function() {
				return c
			})), n.d(t, "r", (function() {
				return l
			})), n.d(t, "q", (function() {
				return u
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "u", (function() {
				return p
			})), n.d(t, "t", (function() {
				return b
			})), n.d(t, "s", (function() {
				return f
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "l", (function() {
				return g
			})), n.d(t, "k", (function() {
				return v
			})), n.d(t, "B", (function() {
				return x
			})), n.d(t, "A", (function() {
				return E
			})), n.d(t, "C", (function() {
				return O
			})), n.d(t, "D", (function() {
				return C
			})), n.d(t, "E", (function() {
				return A
			})), n.d(t, "e", (function() {
				return y
			})), n.d(t, "d", (function() {
				return j
			})), n.d(t, "y", (function() {
				return I
			})), n.d(t, "z", (function() {
				return k
			})), n.d(t, "x", (function() {
				return _
			})), n.d(t, "j", (function() {
				return S
			})), n.d(t, "F", (function() {
				return w
			})), n.d(t, "G", (function() {
				return T
			})), n.d(t, "i", (function() {
				return P
			})), n.d(t, "h", (function() {
				return N
			})), n.d(t, "g", (function() {
				return D
			})), n.d(t, "f", (function() {
				return M
			}));
			const s = "SUBREDDIT__ADD_TOP_SUBREDDIT_MODELS",
				r = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS",
				o = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS_PAGE_INFO",
				i = "SUBREDDIT__POSTS_LOADED",
				a = "SUBREDDIT__POSTS_SET_FAILED",
				d = "SUBREDDIT__SUBREDDITS_POSTS_LOADED",
				c = "SUBREDDIT__SUBREDDITS_POSTS_SET_FAILED",
				l = "SUBREDDIT__RANKINGS_PENDING",
				u = "SUBREDDIT__RANKINGS_LOADED",
				m = "SUBREDDIT__RANKINGS_FAILED",
				p = "SUBREDDIT__SIMILAR_SUBREDDITS_PENDING",
				b = "SUBREDDIT__SIMILAR_SUBREDDITS_LOADED",
				f = "SUBREDDIT__SIMILAR_SUBREDDITS_FAILED",
				h = "SUBREDDIT__ONBOARDING_SUBREDDITS_PENDING",
				g = "SUBREDDIT__ONBOARDING_SUBREDDITS_LOADED",
				v = "SUBREDDIT__ONBOARDING_SUBREDDITS_FAILED",
				x = "SUBREDDIT__EDIT_REQUESTED",
				E = "SUBREDDIT__EDIT_FAILED",
				O = "SUBREDDIT__EDIT_SUCCESS",
				C = "SUBREDDIT_QUESTIONS_LOADED",
				A = "SUBREDDIT_SURVEY_ANSWERED",
				y = "SUBREDDIT_SURVEY_DISMISSED",
				j = "SUBREDDIT_SURVEY_DISMISS",
				I = "SUBREDDIT_ABOUT_INFO_UPDATE__PENDING",
				k = "SUBREDDIT_ABOUT_INFO_UPDATE__SUCCESS",
				_ = "SUBREDDIT_ABOUT_INFO_UPDATE__FAILED",
				S = "MUTE_SUBREDDIT__SUCCESS",
				w = "UNMUTE_SUBREDDIT_SUCCESS",
				T = "UPDATE_MUTE_AND_NOTIFICATION_LEVEL_SUCCESS",
				P = "MUTED_SUBREDDIT_LOADED__SUCCESS",
				N = "MUTED_SUBREDDIT_LOADED__FAILED",
				D = "MUTED_SUBREDDIT_LIST__UNMUTE",
				M = "MUTED_SUBREDDIT_LIST__MUTE"
		},
		"./src/reddit/actions/subreddit/muting.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return I
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "e", (function() {
				return S
			})), n.d(t, "g", (function() {
				return w
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "f", (function() {
				return P
			})), n.d(t, "b", (function() {
				return N
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/redditGQL/operations/DeleteSubredditMuteSettings.json"),
				d = n("./src/redditGQL/operations/MutedSubreddits.json"),
				c = n("./src/redditGQL/operations/UpdateSubredditMuteAndNotificationLevelSettings.json"),
				l = n("./src/redditGQL/operations/UpdateSubredditMuteSettings.json");
			const u = (e, t) => Object(i.a)(e, {
					...l,
					variables: {
						input: {
							subredditId: t
						}
					}
				}),
				m = (e, t) => Object(i.a)(e, {
					...a,
					variables: {
						input: {
							subredditId: t
						}
					}
				});
			var p = n("./src/reddit/models/Toast/index.ts"),
				b = n("./src/reddit/actions/subreddit/constants.ts"),
				f = n("./src/reddit/actions/subreddit/notifications.ts"),
				h = n("./src/reddit/selectors/subreddit.ts");
			const g = e => Object(o.f)({
					id: e,
					kind: p.b.Error,
					duration: o.a,
					text: s.fbt._("An error has occured. Please try again later", null, {
						hk: "2FpsLy"
					})
				}),
				v = (e, t) => Object(o.f)({
					kind: p.b.SuccessCommunityGreen,
					text: s.fbt._("Muted r/{subreddit name}", [s.fbt._param("subreddit name", e)], {
						hk: "Mg9mO"
					}),
					...t ? {
						buttonText: s.fbt._("Undo", null, {
							hk: "2siioQ"
						}),
						buttonAction: t
					} : {}
				}),
				x = (e, t) => Object(o.f)({
					kind: p.b.SuccessCommunityGreen,
					text: s.fbt._("Unmuted r/{subreddit name}", [s.fbt._param("subreddit name", e)], {
						hk: "Fhnht"
					}),
					...t ? {
						buttonText: s.fbt._("Undo", null, {
							hk: "2siioQ"
						}),
						buttonAction: t
					} : {}
				});
			var E = n("./src/reddit/endpoints/subreddit/about.ts");
			const O = Object(r.a)(b.i),
				C = Object(r.a)(b.h),
				A = Object(r.a)(b.G),
				y = (Object(r.a)(b.j), Object(r.a)(b.F), Object(r.a)(b.g)),
				j = Object(r.a)(b.f),
				I = e => {
					let {
						subredditId: t,
						subredditName: n,
						successCallback: s
					} = e;
					return async (e, r, o) => {
						let {
							gqlContext: i
						} = o;
						var a, d;
						const c = await u(i(), t);
						if (c.ok && c.body && (null === (d = null === (a = c.body) || void 0 === a ? void 0 : a.data.updateSubredditMuteSettings) || void 0 === d ? void 0 : d.ok)) s && s(), e(v(n, k({
							subredditId: t,
							subredditName: n
						})));
						else {
							e(g(`error-muting-${t}`))
						}
					}
				},
				k = e => {
					let {
						subredditId: t,
						subredditName: n,
						successCallback: s
					} = e;
					return async (e, r, o) => {
						let {
							gqlContext: i
						} = o;
						var a, d;
						const c = await m(i(), t);
						if (c.ok && c.body && (null === (d = null === (a = c.body) || void 0 === a ? void 0 : a.data.deleteSubredditMuteSettings) || void 0 === d ? void 0 : d.ok)) s && s(), e(x(n, I({
							subredditId: t,
							subredditName: n
						})));
						else {
							e(g(`error-muting-${t}`))
						}
					}
				},
				_ = e => {
					let {
						subredditId: t,
						subredditName: n,
						successCallback: s
					} = e;
					return async (e, r, o) => {
						let {
							gqlContext: i
						} = o;
						var a, d;
						const c = await u(i(), t);
						if (c.ok && c.body && (null === (d = null === (a = c.body) || void 0 === a ? void 0 : a.data.updateSubredditMuteSettings) || void 0 === d ? void 0 : d.ok)) s && s(), e(Object(f.c)({
							subredditAboutInfo: {
								[t]: {
									isMuted: !0
								}
							}
						})), e(v(n, S({
							subredditId: t,
							subredditName: n
						})));
						else {
							e(g(`error-muting-${t}`))
						}
					}
				},
				S = e => {
					let {
						subredditId: t,
						subredditName: n,
						successCallback: s
					} = e;
					return async (e, r, o) => {
						let {
							gqlContext: i
						} = o;
						var a, d;
						const c = await m(i(), t);
						if (c.ok && c.body && (null === (d = null === (a = c.body) || void 0 === a ? void 0 : a.data.deleteSubredditMuteSettings) || void 0 === d ? void 0 : d.ok)) s && s(), e(Object(f.c)({
							subredditAboutInfo: {
								[t]: {
									isMuted: !1
								}
							}
						})), e(x(n, _({
							subredditId: t,
							subredditName: n
						})));
						else {
							e(g(`error-muting-${t}`))
						}
					}
				},
				w = e => {
					let {
						subredditId: t,
						notificationLevel: n
					} = e;
					return async (e, r, a) => {
						let {
							gqlContext: d
						} = a;
						var l, u;
						const m = Object(f.a)(n),
							b = await ((e, t, n) => Object(i.a)(e, {
								...c,
								variables: {
									input: {
										...n,
										subredditId: t
									}
								}
							}))(d(), t, m);
						b.ok && b.body && (null === (u = null === (l = b.body) || void 0 === l ? void 0 : l.data.updateSubredditMuteAndNotificationLevelSettings) || void 0 === u ? void 0 : u.ok) ? (e(A({
							subredditId: t,
							notificationLevel: n
						})), e(Object(o.f)({
							kind: p.b.SuccessCommunityGreen,
							text: Object(f.b)(n)
						}))) : e(Object(o.f)({
							kind: p.b.Error,
							text: s.fbt._("Failed to change the frequency of notifications from this community, please try again.", null, {
								hk: "4avFFV"
							})
						}))
					}
				},
				T = () => async (e, t, n) => {
					let {
						gqlContext: r
					} = n;
					const a = await (e => Object(i.a)(e, d))(r());
					if (a.ok && a.body && a.body.data) {
						const {
							data: t
						} = a.body, n = (t && t.identity.mutedSubreddits).edges.map(e => e.node);
						e(O({
							nodes: n
						}))
					} else e(C()), e(Object(o.f)({
						duration: o.a,
						kind: p.b.Error,
						text: s.fbt._("Failed to get muted subreddits, please try again.", null, {
							hk: "2dCj3Q"
						})
					}))
				}, P = e => {
					let {
						subredditId: t,
						subredditName: n
					} = e;
					return async (e, s, r) => {
						let {
							gqlContext: o
						} = r;
						var i, a;
						const d = await m(o(), t);
						if (d.ok && d.body && (null === (a = null === (i = d.body) || void 0 === i ? void 0 : i.data.deleteSubredditMuteSettings) || void 0 === a ? void 0 : a.ok)) e(y(t)), e(x(n));
						else {
							e(g(`error-unmuting-${t}`))
						}
					}
				}, N = e => {
					let {
						subredditName: t
					} = e;
					return async (e, n, r) => {
						let {
							gqlContext: i
						} = r;
						var a, d;
						const c = n(),
							l = Object(h.t)(c).find(e => e.name.toLowerCase() === t.toLowerCase());
						if (l) {
							const t = l.name,
								n = `error-muting-duplicate-${t}`;
							return e(Object(o.f)({
								id: n,
								kind: p.b.Error,
								duration: o.a,
								text: s.fbt._("Sorry, r/{subreddit name} is already muted.", [s.fbt._param("subreddit name", t)], {
									hk: "4n64wl"
								})
							}))
						}
						const m = await Object(E.a)(i(), t, !0),
							{
								data: b
							} = m.body,
							f = b && b.subreddit;
						if (!m.ok || null === f) {
							return e(((e, t) => Object(o.f)({
								id: e,
								kind: p.b.Error,
								duration: o.a,
								text: s.fbt._("Sorry, r/{subreddit name} isn't a community.", [s.fbt._param("subreddit name", t)], {
									hk: "3UtglL"
								})
							}))(`error-muting-${t}`, t))
						}
						const x = f.id,
							O = await u(i(), x);
						if (O.ok && O.body && (null === (d = null === (a = O.body) || void 0 === a ? void 0 : a.data.updateSubredditMuteSettings) || void 0 === d ? void 0 : d.ok)) e(j([f])), e(v(f.name));
						else {
							e(g(`error-muting-${x}`))
						}
					}
				}
		},
		"./src/reddit/actions/subreddit/notifications.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "d", (function() {
				return g
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/notificationSettingsLayout/index.ts"),
				i = n("./src/reddit/actions/notificationsInbox/index.ts"),
				a = n("./src/reddit/actions/subreddit/constants.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/endpoints/subreddit/notificationSettings.ts"),
				l = n("./src/reddit/models/Subreddit/index.ts"),
				u = n("./src/reddit/models/Toast/index.ts");
			const m = Object(r.a)(a.z),
				p = Object(r.a)(a.y),
				b = Object(r.a)(a.x),
				f = e => {
					switch (e) {
						case l.c.FREQUENT:
							return {
								isSubredditUpdatesInterestingPostEnabled: !0, isUpdateFromSubredditEnabled: !0
							};
						case l.c.LOW:
							return {
								isSubredditUpdatesInterestingPostEnabled: !1, isUpdateFromSubredditEnabled: !0
							};
						case l.c.OFF:
						default:
							return {
								isSubredditUpdatesInterestingPostEnabled: !1, isUpdateFromSubredditEnabled: !1
							}
					}
				},
				h = e => {
					switch (e) {
						case l.c.OFF:
							return s.fbt._("Unfollowed. You wont get updates on new activity anymore.", null, {
								hk: "3e1CJR"
							});
						case l.c.FREQUENT:
							return s.fbt._("Followed! Now youll get updates on new activity.", null, {
								hk: "3JzOOa"
							});
						case l.c.LOW:
							return s.fbt._("Success! You will see fewer notifications from this community in the future.", null, {
								hk: "4x3TS8"
							});
						default:
							return null
					}
				};
			const g = e => {
				let {
					subredditId: t,
					notificationLevel: n,
					successCallback: r,
					undoCallback: a
				} = e;
				return async (e, l, g) => {
					let {
						gqlContext: v
					} = g;
					var x, E, O;
					e(p());
					const C = f(n),
						A = await Object(c.b)(v(), t, C);
					if ((null === (E = null === (x = A.error) || void 0 === x ? void 0 : x.fields) || void 0 === E ? void 0 : E.length) || function(e) {
							return Boolean(e && e.data && e.data.updateSubredditNotificationSettings)
						}(A.body) && (null === (O = A.body.data.updateSubredditNotificationSettings.errors) || void 0 === O ? void 0 : O.length)) return e(b()), e(Object(d.f)({
						kind: u.b.Error,
						text: s.fbt._("Failed to change the frequency of notifications from this community, please try again.", null, {
							hk: "4avFFV"
						})
					}));
					A.ok && (e(Object(o.c)({
						subredditId: t,
						notificationLevel: n
					})), e(m({
						subredditAboutInfo: {
							[t]: {
								notificationLevel: n
							}
						}
					})), r && r(), e(a ? Object(d.f)(Object(d.e)(h(n), u.b.Undo, s.fbt._("Undo", null, {
						hk: "46OwLP"
					}), Object(i.i)(t, a))) : Object(d.f)(Object(d.e)(h(n), u.b.SuccessCommunityGreen))))
				}
			}
		},
		"./src/reddit/actions/subreddit/questions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/GetSubredditQuestions.json"),
				o = n("./src/reddit/models/Subreddit/index.ts"),
				i = n("./src/reddit/actions/subreddit/constants.ts");
			const a = e => async (t, n, o) => {
				let {
					gqlContext: i
				} = o;
				var a;
				const c = (await ((e, t) => Object(s.a)(e, {
					...r,
					variables: t
				}))(i(), {
					id: e
				})).body;
				d(t, e, null === (a = c.data) || void 0 === a ? void 0 : a.subredditInfoById)
			};

			function d(e, t, n) {
				if (Object(o.m)(n)) return;
				const s = null == n ? void 0 : n.answerableQuestions,
					r = null == n ? void 0 : n.contentRatingSurvey,
					a = null == n ? void 0 : n.communityProgressModule;
				(s || r || a) && e({
					type: i.D,
					payload: {
						id: t,
						questions: s,
						survey: r,
						progressModule: a
					}
				})
			}
		},
		"./src/reddit/actions/subredditCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return w
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "e", (function() {
				return P
			})), n.d(t, "b", (function() {
				return N
			})), n.d(t, "a", (function() {
				return D
			})), n.d(t, "f", (function() {
				return B
			})), n.d(t, "g", (function() {
				return F
			})), n.d(t, "h", (function() {
				return U
			})), n.d(t, "i", (function() {
				return H
			}));
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/postCreation/general.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/actions/postCreation/submit.ts"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/reddit/components/ModWelcomeTooltip/index.tsx"),
				u = n("./src/reddit/components/SubredditForkingCTA/index.tsx"),
				m = n("./src/reddit/constants/experiments.ts"),
				p = n("./src/reddit/constants/modals.ts"),
				b = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				h = n("./src/reddit/constants/headers.ts"),
				g = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const v = e => ({
				public_description: e.publicDescription,
				name: e.name,
				type: e.type,
				over_18: e.over18,
				restrict_commenting: e.restrictCommenting,
				restrict_posting: e.restrictPosting,
				existing_tags: e.existingTags.join(","),
				new_tags: e.newTags.join(","),
				primary_tag: e.primaryTagId
			});
			var x = n("./src/lib/makeGqlRequest/index.ts"),
				E = n("./src/redditGQL/operations/ValidateCreateSubreddit.json");
			var O = n("./src/reddit/helpers/correlationIdTracker.ts"),
				C = n("./src/reddit/helpers/trackers/subredditCreation.ts"),
				A = n("./src/reddit/selectors/experiments/newCommunityProgressV3.ts"),
				y = n("./src/reddit/selectors/meta.ts"),
				j = n("./src/reddit/selectors/posts.ts"),
				I = n("./src/reddit/selectors/subreddit.ts"),
				k = n("./src/reddit/selectors/user.ts"),
				_ = n("./src/telemetry/index.ts"),
				S = n("./src/reddit/actions/countrySites/subredditCountrySiteSettings.ts");
			const w = "SUBREDDIT__CREATE_SET_INITIAL_CROSSPOST",
				T = "SUBREDDIT__CREATE_PENDING",
				P = "SUBREDDIT__CREATE_SUCCEEDED",
				N = "SUBREDDIT__CREATE_FAILED",
				D = "SUBREDDIT__CREATE_CLEARED",
				M = Object(o.a)(T),
				R = Object(o.a)(P),
				L = Object(o.a)(N),
				B = Object(o.a)(D),
				F = Object(o.a)(w),
				U = e => async (t, n, o) => {
					let {
						apiContext: x
					} = o;
					var E;
					const w = n(),
						{
							name: T,
							type: P,
							crosspostId: N
						} = e;
					if (Object(I.l)(w)) return;
					t(M({
						subredditName: T
					}));
					const D = await ((e, t) => Object(b.a)(Object(f.a)(e, [h.a]), {
						endpoint: Object(g.a)(`${e.apiUrl}/api/v1/subreddit/create_subreddit`),
						method: r.ob.POST,
						data: v(t)
					}))(x(), e);
					if (D.ok) {
						const n = D.body,
							o = n.fullname;
						Object(_.a)(Object(C.d)(P, e, o)(w)), t(R({
							subredditName: T
						}));
						const b = await Object(A.b)(w);
						if (N) {
							const e = Object(j.F)(w, {
								postId: N
							});
							t(Object(i.h)(e.title)), t(Object(i.g)({
								submissionType: r.bc.CROSSPOST
							})), await t(Object(d.d)({
								destSubreddit: {
									...n,
									isProfile: !1
								},
								sourcePostId: N,
								postFieldValidationPending: Promise.resolve()
							})), Object(u.b)(N)
						}
						await t(Object(s.b)(`${n.path}`)), b ? b === m.df.NewModule && t(Object(c.h)({
							tooltipId: l.MOD_WELCOME_TOOLTIP_ID
						})) : (t(Object(a.h)(p.a.POST_FLOW_UPSELL_MODAL_ID)), Object(_.a)(Object(C.g)()(w))), Object(O.b)(O.a.SubredditCreation), t(Object(S.f)(o, null !== (E = Object(k.db)(w)) && void 0 !== E ? E : Object(y.k)(w)))
					} else D.error && Object(_.a)(Object(C.h)(D.error.type, T)(w)), t(L({
						subredditName: T,
						error: D.error
					}))
				}, H = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n(),
						i = {
							name: e
						},
						a = await ((e, t) => Object(x.a)(e, {
							...E,
							variables: t
						}))(r(), {
							input: i
						});
					let d = null;
					if (a.ok) {
						d = a.body.data.validateCreateSubredditInput.fieldErrors
					}
					if (d) {
						const n = {
							fields: [{
								field: d[0].field,
								msg: d[0].message
							}],
							type: d[0].code
						};
						t(L({
							subredditName: e,
							error: n
						})), n && Object(_.a)(Object(C.h)(n.type, e)(o))
					} else await t(B())
				}
		},
		"./src/reddit/actions/subredditDuplicates.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "b", (function() {
				return b
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/config.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/reddit/models/Post/index.ts");
			var d = n("./src/reddit/models/Duplicates/index.ts"),
				c = n("./src/reddit/models/Subreddit/index.ts"),
				l = n("./src/reddit/selectors/profile.ts"),
				u = n("./src/reddit/selectors/subreddit.ts");
			const m = "SUBREDDIT_DUPLICATES_IN_SUBREDDIT_LOADED",
				p = (Object(s.a)("SUBREDDIT_DUPLICATES_IN_SUBREDDIT_PENDING"), Object(s.a)(m)),
				b = (e, t) => async (n, s, m) => {
					let {
						apiContext: b
					} = m;
					const f = Object(u.X)(s(), {
						subredditId: e
					}) || Object(l.r)(s(), {
						profileId: e
					});
					if (!f) return;
					const h = {
							crossposts_only: !0,
							sort: "new",
							sr: Object(c.i)(f) ? r.qc + f.name : f.name
						},
						g = await ((e, t, n) => Object(i.a)(e, {
							data: n,
							endpoint: `${o.a.gatewayUrl}/desktopapi/v1/duplicates/${Object(a.C)(t)}`,
							method: r.ob.GET
						}))(b(), t, h);
					if (g.ok) {
						const s = g.body;
						n(p({
							distinguishKey: Object(d.a)(t, h),
							postIds: s.postIds,
							posts: s.posts,
							profiles: s.profiles,
							subreddits: s.subreddits,
							subredditId: e
						}))
					}
				}
		},
		"./src/reddit/actions/subredditModeration/approvedSubmitters.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return O
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "d", (function() {
				return S
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/get.js"),
				o = n.n(r),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				m = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const p = (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
				endpoint: Object(m.a)(`${e.apiUrl}/api/v1/${t}/contributors`),
				method: d.ob.GET,
				data: n
			});
			var b = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				f = n("./src/reddit/models/SubredditModeration/index.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				g = n("./src/reddit/actions/subredditModeration/constants.ts");
			const v = Object(i.a)(g.g),
				x = Object(i.a)(g.f),
				E = Object(i.a)(g.e),
				O = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, s, r) => {
						let {
							apiContext: o
						} = r;
						const i = s(),
							a = t.after || "",
							d = Object(f.e)(e, a),
							c = i.pages.modHub.approvedSubmitters.fetchedTokens[d];
						if (i.pages.modHub.approvedSubmitters.api.pending[d] || c) return;
						n(v({
							subredditId: e,
							fetchedToken: a
						}));
						const l = i.subreddits.models[e].name,
							u = await p(o(), l, t);
						u.ok ? n(x({
							...u.body,
							fetchedToken: a
						})) : n(E({
							subredditId: e,
							fetchedToken: a
						}))
					}
				},
				C = Object(i.a)(g.j),
				A = Object(i.a)(g.i),
				y = Object(i.a)(g.h),
				j = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s().subreddits.models[e].name,
						a = {
							username: Object(b.a)(t)
						};
					n(C());
					const d = await p(o(), i, a);
					d.ok ? n(A(d.body)) : n(y(d.error))
				}, I = Object(i.a)(g.d), k = Object(i.a)(g.k), _ = (e, t) => async (n, r, i) => {
					let {
						apiContext: m
					} = i;
					const f = r(),
						g = f.subreddits.models[e].url,
						v = f.subreddits.models[e].name;
					t = Object(b.a)(t);
					const x = await ((e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: `${e.apiUrl}${t}api/friend`,
						method: d.ob.POST,
						data: {
							api_type: "json",
							name: n,
							type: "contributor"
						}
					}))(m(), g, t);
					if (x.ok) {
						const e = {
							username: t
						};
						n(Object(a.f)({
							kind: h.b.SuccessMod,
							text: s.fbt._("Successfully added an approved submitter", null, {
								hk: "4gruK7"
							})
						}));
						const r = await p(m(), v, e);
						r.ok && n(I(r.body))
					} else {
						const e = o()(x, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(a.f)({
							kind: h.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, S = (e, t) => async (n, r, i) => {
					let {
						apiContext: m
					} = i;
					const p = r().subreddits.models[e].url,
						b = await ((e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: `${e.apiUrl}${t}api/unfriend`,
							method: d.ob.POST,
							data: {
								api_type: "json",
								id: n,
								type: "contributor"
							}
						}))(m(), p, t);
					if (b.ok) n(k({
						subredditId: e,
						userId: t
					}));
					else {
						const e = o()(b, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(a.f)({
							kind: h.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}
		},
		"./src/reddit/actions/subredditModeration/approvedTalkHosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return x
			})), n.d(t, "a", (function() {
				return E
			})), n.d(t, "c", (function() {
				return O
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/sentry/index.ts"),
				o = n("./src/reddit/actions/subredditModeration/constants.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/endpoints/redditor/index.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/AddApprovedTalkHost.json"),
				l = n("./src/redditGQL/operations/RemoveApprovedTalkHost.json"),
				u = n("./src/redditGQL/operations/SubredditApprovedTalkHosts.json");
			var m = n("./src/reddit/models/SubredditModeration/index.ts"),
				p = n("./src/reddit/models/Toast/index.ts");
			const {
				fbt: b
			} = n("./node_modules/fbt/lib/FbtPublic.js"), f = Object(s.a)(o.n), h = Object(s.a)(o.m), g = Object(s.a)(o.l), v = Object(s.a)(o.o), x = e => async (t, n, s) => {
				let {
					gqlContext: o
				} = s;
				var a;
				const c = n(),
					{
						subredditId: l,
						before: v,
						forceRefresh: x
					} = e,
					E = Object(m.f)(l, v),
					O = c.pages.modHub.approvedTalkHosts.fetchedTokens[E];
				if (!(c.pages.modHub.approvedTalkHosts.api.pending[E] || O && !x)) {
					t(f({
						subredditId: l,
						fetchedToken: v
					}));
					try {
						const e = await ((e, t) => Object(d.a)(e, {
							...u,
							variables: {
								...t,
								last: 20
							}
						}))(o(), {
							subredditId: l,
							before: v
						});
						if (e.ok) {
							const {
								data: {
									subredditInfoById: n
								}
							} = e.body;
							if ("Subreddit" === (null == n ? void 0 : n.__typename) && (null === (a = null == n ? void 0 : n.talkApprovedHostMembers) || void 0 === a ? void 0 : a.edges)) {
								const {
									edges: e,
									pageInfo: s
								} = n.talkApprovedHostMembers, r = [];
								e.forEach(e => {
									e && e.node && r.push(e.node)
								}), t(h({
									subredditId: l,
									approvedTalkHosts: r,
									fetchedToken: v,
									loadMoreToken: s.hasNextPage ? s.endCursor : null,
									forceRefresh: x
								}))
							}
							const {
								errors: s
							} = e.body;
							s && s.length && r.c.captureException(s)
						} else t(g({
							subredditId: l,
							fetchedToken: v
						})), t(Object(i.f)({
							kind: p.b.Error,
							text: b._("Oops, something went wrong. Try again.", null, {
								hk: "2VQ3RW"
							}),
							duration: 3e3
						}))
					} catch (C) {
						r.c.captureException(C), t(Object(i.f)({
							kind: p.b.Error,
							text: b._("Oops, something went wrong. Try again.", null, {
								hk: "2VQ3RW"
							}),
							duration: 3e3
						}))
					}
				}
			}, E = (e, t) => async (n, s, r) => {
				let {
					gqlContext: o
				} = r;
				const l = await Object(a.a)(o(), {
					name: t
				});
				if (!l) return void n(Object(i.f)({
					kind: p.b.Error,
					text: b._("{username} doesnt exist. Double-check your spelling.", [b._param("username", t)], {
						hk: "1sikIN"
					}),
					duration: 3e3
				}));
				const u = {
						subredditId: e,
						userId: l
					},
					m = await ((e, t) => Object(d.a)(e, {
						...c,
						variables: t
					}))(o(), u);
				if (m.ok) {
					if (!m.body) return void n(Object(i.f)({
						kind: p.b.Error,
						text: b._("Something went wrong", null, {
							hk: "28RRuF"
						}),
						duration: 3e3
					}));
					n(x({
						subredditId: e,
						forceRefresh: !0
					})), n(Object(i.f)({
						kind: p.b.SuccessMod,
						text: b._("User approved!", null, {
							hk: "PeRM2"
						}),
						duration: 3e3
					}))
				} else {
					const {
						errors: e
					} = m.body, t = e[0] ? e[0].message : b._("Something went wrong", null, {
						hk: "HsnIE"
					});
					n(Object(i.f)({
						kind: p.b.Error,
						text: t,
						duration: 3e3
					}))
				}
			}, O = (e, t) => async (n, s, r) => {
				let {
					gqlContext: o
				} = r;
				const a = {
						subredditId: e,
						userId: t
					},
					c = await ((e, t) => Object(d.a)(e, {
						...l,
						variables: t
					}))(o(), a);
				if (c.ok) {
					if (!c.body) return void n(Object(i.f)({
						kind: p.b.Error,
						text: b._("Something went wrong", null, {
							hk: "1o9j5I"
						}),
						duration: 3e3
					}));
					n(v({
						subredditId: e,
						userId: t
					})), n(Object(i.f)({
						kind: p.b.SuccessMod,
						text: b._("User removed from approved hosts list", null, {
							hk: "1RWvrp"
						}),
						duration: 3e3
					}))
				} else {
					const {
						errors: e
					} = c.body, t = e[0] ? e[0].message : b._("Something went wrong", null, {
						hk: "HsnIE"
					});
					n(Object(i.f)({
						kind: p.b.Error,
						text: t,
						duration: 3e3
					}))
				}
			}
		},
		"./src/reddit/actions/subredditModeration/ban.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return $
			})), n.d(t, "d", (function() {
				return se
			})), n.d(t, "b", (function() {
				return ie
			})), n.d(t, "e", (function() {
				return ae
			})), n.d(t, "a", (function() {
				return de
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/get.js"),
				o = n.n(r),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/apiRequestState.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/subreddit.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/constants/modals.ts"),
				m = n("./src/lib/constants/index.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				b = n("./src/lib/omitHeaders/index.ts"),
				f = n("./src/reddit/constants/headers.ts"),
				h = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				g = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const v = (e, t, n) => Object(p.a)(Object(b.a)(e, [f.a]), {
				endpoint: Object(h.a)(Object(g.a)(`${e.apiUrl}/api/v1/${t}/banned`)),
				method: m.ob.GET,
				data: n
			});
			var x = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				E = n("./src/reddit/models/SubredditModeration/index.ts"),
				O = n("./src/reddit/models/Toast/index.ts"),
				C = n("./src/reddit/selectors/activeModalId.ts"),
				A = n("./src/reddit/selectors/bannedUser.ts"),
				y = n("./src/reddit/selectors/subreddit.ts"),
				j = n("./src/reddit/selectors/user.ts"),
				I = n("./src/reddit/actions/subredditModeration/constants.ts"),
				k = n("./src/lib/initializeClient/installReducer.ts"),
				_ = n("./node_modules/redux/es/redux.js");
			var S = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case I.s:
					case I.r:
						return null;
					case I.q:
						return t.payload;
					default:
						return e
				}
			};
			const w = {};
			var T = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : w,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case I.s: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(E.e)(n, s);
							return {
								...e,
								[r]: !0
							}
						}
						case I.r:
						case I.q: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(E.e)(n, s);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				P = Object(_.c)({
					error: S,
					pending: T
				});
			const N = {};
			var D = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : N,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case I.r: {
							const {
								fetchedToken: n,
								subredditId: s
							} = t.payload, r = Object(E.e)(s, n);
							return {
								...e,
								[r]: !0
							}
						}
						default:
							return e
					}
				},
				M = n("./src/reddit/actions/inContextModeration.ts");
			var R = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case M.a:
						return t.payload;
					default:
						return e
				}
			};
			const L = {};
			var B = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : L,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case I.r: {
							const {
								subredditId: e,
								after: n
							} = t.payload;
							return {
								[e]: n
							}
						}
						default:
							return e
					}
				},
				F = n("./node_modules/icepick/icepick.js");
			const U = {};
			var H = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : U,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case I.p:
					case I.r: {
						const {
							subredditId: n,
							bannedUsers: s
						} = t.payload;
						return Object(F.merge)(e, {
							[n]: s
						})
					}
					case I.w: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(F.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			var G = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case I.v:
					case I.u:
						return null;
					case I.t:
						return t.payload;
					default:
						return e
				}
			};
			var Q = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case I.v:
							return !0;
						case I.u:
						case I.t:
							return !1;
						default:
							return e
					}
				},
				q = Object(_.c)({
					error: G,
					pending: Q
				});
			var W = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case I.v:
						case I.t:
							return null;
						case I.u: {
							const e = t.payload.bannedUserIds[0];
							return e ? t.payload.bannedUsers[e] : null
						}
						default:
							return e
					}
				},
				z = Object(_.c)({
					api: q,
					result: W
				});
			const V = {};
			var K = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : V,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case I.r: {
							const {
								subredditId: n,
								bannedUserIds: s
							} = t.payload;
							return e[n] ? {
								...e,
								[n]: [...e[n], ...s]
							} : {
								...e,
								[n]: s
							}
						}
						case I.w: {
							const {
								subredditId: n,
								userId: s
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== s)
							}
						}
						case I.p: {
							const {
								subredditId: n,
								bannedUserIds: s
							} = t.payload, r = s[0];
							return r && e[n] && -1 === e[n].indexOf(r) ? {
								[n]: [r, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				Y = Object(_.c)({
					api: P,
					fetchedTokens: D,
					inContext: R,
					loadMore: B,
					models: H,
					search: z,
					userOrder: K
				});
			Object(k.a)({
				features: {
					banned: Y
				}
			});
			const J = Object(i.a)(I.s),
				X = Object(i.a)(I.r),
				Z = Object(i.a)(I.q),
				$ = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, s, r) => {
						let {
							apiContext: o
						} = r;
						const i = s(),
							a = t.after || "",
							d = Object(E.e)(e, a),
							c = i.features.banned.fetchedTokens[d];
						if (i.features.banned.api.pending[d] || c) return;
						n(J({
							subredditId: e,
							fetchedToken: a
						}));
						const l = i.subreddits.models[e].name,
							u = await v(o(), l, t);
						u.ok ? n(X({
							...u.body,
							fetchedToken: a
						})) : n(Z({
							subredditId: e,
							fetchedToken: a
						}))
					}
				},
				ee = Object(i.a)(I.v),
				te = Object(i.a)(I.u),
				ne = Object(i.a)(I.t),
				se = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s().subreddits.models[e].name,
						a = {
							username: Object(x.a)(t)
						};
					n(ee());
					const d = await v(o(), i, a);
					d.ok ? n(te(d.body)) : n(ne(d.error))
				}, re = Object(i.a)(I.p), oe = Object(i.a)(I.w), ie = (e, t, n) => async (r, i, d) => {
					let {
						apiContext: c
					} = d;
					const u = i(),
						g = u.subreddits.models[e].url,
						E = u.subreddits.models[e].name;
					t.username = Object(x.a)(t.username), r(Object(a.h)(n));
					const C = await ((e, t, n) => Object(p.a)(Object(b.a)(e, [f.a]), {
						endpoint: Object(h.a)(`${e.apiUrl}${t}api/friend`),
						method: m.ob.POST,
						data: {
							api_type: "json",
							ban_reason: n.reason,
							ban_message: n.banMessage,
							duration: n.duration,
							name: n.username,
							note: n.modNote,
							ban_context: n.contextId,
							type: "banned"
						}
					}))(c(), g, t);
					if (C.ok) {
						r(Object(a.e)(n));
						const e = {
							username: t.username
						};
						r(Object(l.f)({
							kind: O.b.SuccessMod,
							text: s.fbt._("Successfully banned a user", null, {
								hk: "1kORpS"
							})
						}));
						const o = await v(c(), E, e);
						o.ok && r(re(o.body))
					} else {
						r(Object(a.f)(n, C.error));
						const e = o()(C, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						r(Object(l.f)({
							kind: O.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, ae = (e, t) => async (n, r, i) => {
					let {
						apiContext: a
					} = i;
					const d = r().subreddits.models[e].url,
						c = await ((e, t, n) => Object(p.a)(Object(b.a)(e, [f.a]), {
							endpoint: Object(h.a)(`${e.apiUrl}${t}api/unfriend`),
							method: m.ob.POST,
							data: {
								api_type: "json",
								id: n,
								type: "banned"
							}
						}))(a(), d, t);
					if (c.ok) n(oe({
						subredditId: e,
						userId: t
					})), n(Object(l.f)({
						kind: O.b.SuccessMod,
						text: s.fbt._("Successfully unbanned a user", null, {
							hk: "OgqK6"
						})
					}));
					else {
						const e = o()(c, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(l.f)({
							kind: O.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, de = (e, t) => async (n, s) => {
					const r = s();
					await Promise.all([(async () => {
						if (!Object(C.b)(u.a.BAN_USER)(r) && !Object(y.U)(r, {
								subredditId: e
							})) {
							const t = Object(y.X)(r, {
								subredditId: e
							});
							await n(Object(c.o)(t.name))
						}
					})(), (async () => {
						const s = Object(j.Db)(r, {
							userName: t
						});
						if (!s) return;
						const o = Object(A.h)(r, {
							subredditId: e
						});
						o && o[s.id] || await n($(e, {
							username: t
						}))
					})()]), n(Object(d.i)(u.a.BAN_USER))
				}
		},
		"./src/reddit/actions/subredditModeration/modUserNotes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return S
			})), n.d(t, "e", (function() {
				return P
			})), n.d(t, "c", (function() {
				return N
			})), n.d(t, "a", (function() {
				return M
			})), n.d(t, "d", (function() {
				return L
			})), n.d(t, "b", (function() {
				return B
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = n("./src/reddit/actions/subredditModeration/constants.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/CommentsPageLastAuthorModNotes.json"),
				l = n("./src/redditGQL/operations/CreateModUserNote.json"),
				u = n("./src/redditGQL/operations/DeleteModUserNote.json"),
				m = n("./src/redditGQL/operations/GetModUserNotes.json"),
				p = n("./src/redditGQL/operations/GetTotalModNoteCount.json");
			var b = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				f = n("./src/reddit/models/SubredditModeration/index.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				g = n("./src/reddit/selectors/moderatorPermissions.ts"),
				v = n("./src/reddit/selectors/modUserNotes.ts"),
				x = n("./src/reddit/helpers/trackers/modNote.ts"),
				E = n("./src/telemetry/index.ts"),
				O = n("./src/redditGQL/types.ts"),
				C = n("./src/lib/initializeClient/installReducer.ts"),
				A = n("./src/reddit/reducers/features/modUserNotes/index.ts");
			const {
				fbt: y
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			Object(C.a)({
				features: {
					modUserNotes: A.a
				}
			});
			const j = Object(r.a)(i.U),
				I = Object(r.a)(i.T),
				k = Object(r.a)(i.S),
				_ = Object(r.a)(i.R),
				S = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					var i;
					const c = n(),
						{
							forceLoad: l,
							subredditId: u,
							userId: p,
							before: b,
							filter: g
						} = e,
						v = Object(f.d)(u, p, g, b),
						x = c.features.modUserNotes.fetchedTokens[v] && !l;
					if (!c.features.modUserNotes.api.pending[v] && !x) {
						t(j({
							subredditId: u,
							userId: p,
							filter: g,
							fetchedToken: b
						}));
						try {
							const e = await ((e, t) => Object(d.a)(e, {
								...m,
								variables: {
									...t,
									last: 25
								}
							}))(r(), {
								subredditId: u,
								userId: p,
								filter: g,
								before: b
							});
							if (e.ok) {
								const {
									data: {
										subredditInfoById: n
									}
								} = e.body;
								if ("Subreddit" === (null == n ? void 0 : n.__typename) && (null === (i = null == n ? void 0 : n.modNotes) || void 0 === i ? void 0 : i.edges)) {
									const {
										edges: e,
										pageInfo: s
									} = n.modNotes, r = [];
									e.forEach(e => {
										e && e.node && r.push(e.node)
									}), t(I({
										notes: r,
										subredditId: u,
										userId: p,
										filter: g,
										fetchedToken: b,
										loadMoreToken: s.hasNextPage ? s.endCursor : null
									}))
								}
								const {
									errors: s
								} = e.body;
								s && s.length && o.c.captureException(s)
							} else t(k({
								subredditId: u,
								userId: p,
								filter: g,
								fetchedToken: b
							})), t(Object(a.f)({
								kind: h.b.Error,
								text: y._("Oops, something went wrong. Try again.", null, {
									hk: "2VQ3RW"
								}),
								duration: 3e3
							}))
						} catch (E) {
							o.c.captureException(E), t(Object(a.f)({
								kind: h.b.Error,
								text: y._("Oops, something went wrong. Try again.", null, {
									hk: "2VQ3RW"
								}),
								duration: 3e3
							}))
						}
					}
				}, w = Object(r.a)(i.H), T = Object(r.a)(i.G), P = e => {
					let {
						subredditId: t,
						nodes: n
					} = e;
					return async (e, s, r) => {
						let {
							gqlContext: o
						} = r;
						const i = [],
							a = [];
						n.map(e => {
							const t = null == e ? void 0 : e.user.id;
							t && !a.includes(t) && e && (i.push(e), a.push(t))
						}), e(T({
							subredditId: t,
							lastAuthorModNotes: i
						}))
					}
				}, N = (e, t, n) => async (r, o, i) => {
					let {
						gqlContext: a
					} = i;
					var l, u, m, p, f, h, g;
					const {
						hasSortParam: v,
						sortToUse: x
					} = Object(b.a)(o(), e), E = s.Pb[x], C = {
						postId: e,
						requestPostModerationInfo: !t,
						...v && E && {
							sortType: O.g[E]
						},
						...n && {
							after: n
						}
					}, A = await ((e, t) => Object(d.a)(e, {
						...c,
						variables: {
							...t
						}
					}))(a(), C);
					if (A.ok) {
						const e = null === (l = A.body) || void 0 === l ? void 0 : l.data,
							t = null === (m = null === (u = null == e ? void 0 : e.postInfoById) || void 0 === u ? void 0 : u.subreddit) || void 0 === m ? void 0 : m.id,
							n = null === (f = null === (p = null == e ? void 0 : e.postInfoById) || void 0 === p ? void 0 : p.moderationInfo) || void 0 === f ? void 0 : f.lastAuthorModNote,
							s = null === (g = null === (h = null == e ? void 0 : e.postInfoById) || void 0 === h ? void 0 : h.commentForest) || void 0 === g ? void 0 : g.trees;
						n && r(w({
							subredditId: t,
							lastAuthorModNote: n
						})), s && r((e => {
							let {
								subredditId: t,
								commentTrees: n
							} = e;
							return async (e, s, r) => {
								let {
									gqlContext: o
								} = r;
								const i = [],
									a = [];
								n.map(e => {
									var t, n;
									if (!(null == e ? void 0 : e.node)) return;
									const s = null === (n = null === (t = e.node) || void 0 === t ? void 0 : t.moderationInfo) || void 0 === n ? void 0 : n.lastAuthorModNote,
										r = null == s ? void 0 : s.user.id;
									r && !a.includes(r) && s && (i.push(s), a.push(r))
								}), e(T({
									subredditId: t,
									lastAuthorModNotes: i
								}))
							}
						})({
							subredditId: t,
							commentTrees: s
						}))
					}
				}, D = Object(r.a)(i.Q), M = (e, t, n, s, r, o) => async (i, c, u) => {
					let {
						gqlContext: m
					} = u;
					var p, b;
					const f = {
							subredditId: e,
							userId: t,
							label: r,
							note: n,
							redditId: o
						},
						g = await ((e, t) => Object(d.a)(e, {
							...l,
							variables: {
								input: t
							}
						}))(m(), f);
					if (g.ok) {
						const n = null === (b = null === (p = g.body) || void 0 === p ? void 0 : p.data) || void 0 === b ? void 0 : b.createModUserNote.createdNote;
						if (!n) return void i(Object(a.f)({
							kind: h.b.Error,
							text: y._("Something went wrong", null, {
								hk: "zYMeg"
							}),
							duration: 3e3
						}));
						i(D({
							subredditId: e,
							newModNote: n,
							filter: s
						})), Object(E.a)(Object(x.v)({
							userId: t,
							subredditId: e,
							filteredType: s,
							modNote: n
						})(c())), i(Object(a.f)({
							kind: h.b.SuccessMod,
							text: y._("Successfully created mod note", null, {
								hk: "10Vu91"
							}),
							duration: 3e3
						}))
					} else {
						const {
							errors: e
						} = g.body, t = e[0] ? e[0].message : y._("Something went wrong", null, {
							hk: "2uu095"
						});
						i(Object(a.f)({
							kind: h.b.Error,
							text: t,
							duration: 3e3
						}))
					}
				}, R = Object(r.a)(i.lb), L = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					var i, a;
					const c = s();
					if (!Object(g.i)(c, e)) return;
					const l = {
						subredditId: e,
						userId: t
					};
					if (Object(v.g)(c, t, e)) return;
					const u = await ((e, t) => Object(d.a)(e, {
						...p,
						variables: {
							...t
						}
					}))(o(), l);
					if (u.ok) {
						const s = null === (i = u.body) || void 0 === i ? void 0 : i.data;
						if ("Subreddit" === (null === (a = null == s ? void 0 : s.subredditInfoById) || void 0 === a ? void 0 : a.__typename)) {
							const r = null == s ? void 0 : s.subredditInfoById;
							r && n(R({
								subredditId: e,
								userId: t,
								totalCounts: r
							}))
						}
					}
				}, B = (e, t, n, s) => async (r, o, i) => {
					let {
						gqlContext: c
					} = i;
					const l = {
						subredditId: e,
						userId: t,
						noteId: n,
						noteType: s
					};
					(await ((e, t) => Object(d.a)(e, {
						...u,
						variables: {
							input: t
						}
					}))(c(), l)).ok ? (r(_({
						subredditId: e,
						userId: t,
						noteId: n
					})), r(Object(a.f)({
						kind: h.b.SuccessMod,
						text: y._("Mod Note sucessfully deleted!", null, {
							hk: "17NyFK"
						})
					}))) : r(Object(a.f)({
						kind: h.b.Error,
						text: y._("Could not delete note. Try again later.", null, {
							hk: "1XczhA"
						})
					}))
				}
		},
		"./src/reddit/actions/subredditModeration/mute.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return O
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "a", (function() {
				return S
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./node_modules/lodash/get.js"),
				i = n.n(o),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts"),
				u = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const m = (e, t, n) => Object(d.a)(Object(c.a)(e, [l.a]), {
				endpoint: Object(u.a)(`${e.apiUrl}/api/v1/${t}/muted`),
				method: a.ob.GET,
				data: n
			});
			var p = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				b = n("./src/reddit/models/SubredditModeration/index.ts"),
				f = n("./src/reddit/models/Toast/index.ts"),
				h = n("./src/reddit/actions/toaster.ts"),
				g = n("./src/reddit/actions/subredditModeration/constants.ts");
			const v = Object(r.a)(g.Y),
				x = Object(r.a)(g.W),
				E = Object(r.a)(g.V),
				O = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, s, r) => {
						let {
							apiContext: o
						} = r;
						const i = s(),
							a = t.after || "",
							d = Object(b.e)(e, a),
							c = i.pages.modHub.muted.fetchedTokens[d];
						if (i.pages.modHub.muted.api.pending[d] || c) return;
						n(v({
							subredditId: e,
							fetchedToken: a
						}));
						const l = i.subreddits.models[e].name,
							u = await m(o(), l, t);
						u.ok ? n(x({
							...u.body,
							fetchedToken: a
						})) : n(E({
							subredditId: e,
							fetchedToken: a
						}))
					}
				},
				C = Object(r.a)(g.bb),
				A = Object(r.a)(g.ab),
				y = Object(r.a)(g.Z),
				j = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s().subreddits.models[e].name,
						a = {
							username: Object(p.a)(t)
						};
					n(C());
					const d = await m(o(), i, a);
					d.ok ? n(A(d.body)) : n(y(d.error))
				}, I = Object(r.a)(g.X), k = Object(r.a)(g.cb), _ = (e, t) => async (n, r, o) => {
					let {
						apiContext: u
					} = o;
					const m = r().subreddits.models[e].url,
						p = await ((e, t, n) => Object(d.a)(Object(c.a)(e, [l.a]), {
							endpoint: `${e.apiUrl}${t}api/unfriend`,
							method: a.ob.POST,
							data: {
								api_type: "json",
								id: n,
								type: "muted"
							}
						}))(u(), m, t);
					if (p.ok) n(k({
						subredditId: e,
						userId: t
					}));
					else {
						const e = i()(p, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(h.f)({
							kind: f.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, S = (e, t, n) => async (r, o, u) => {
					let {
						apiContext: b
					} = u;
					const g = o(),
						v = g.subreddits.models[e].url,
						x = g.subreddits.models[e].name;
					t = Object(p.a)(t);
					const E = await ((e, t, n, s) => Object(d.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}${t}api/friend`,
						method: a.ob.POST,
						data: {
							api_type: "json",
							name: n,
							note: s,
							type: "muted"
						}
					}))(b(), v, t, n);
					if (E.ok) {
						const e = {
							username: t
						};
						r(Object(h.f)({
							kind: f.b.SuccessMod,
							text: s.fbt._("Successfully muted a user", null, {
								hk: "2ypyuL"
							})
						}));
						const n = await m(b(), x, e);
						n.ok && r(I(n.body))
					} else {
						const e = i()(E, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						r(Object(h.f)({
							kind: f.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}
		},
		"./src/reddit/actions/subredditRules/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			}));
			const s = "SUBREDDIT__RULES_LOADED",
				r = "SUBREDDIT__RULES_PENDING",
				o = "SUBREDDIT__RULES_FAILED",
				i = "SUBREDDIT__RULE_ADDED",
				a = "SUBREDDIT__RULE_EDITED",
				d = "SUBREDDIT__RULE_REMOVED",
				c = "SUBREDDIT__RULES_REORDERED"
		},
		"./src/reddit/actions/subredditSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return D
			})), n.d(t, "a", (function() {
				return R
			})), n.d(t, "b", (function() {
				return B
			})), n.d(t, "h", (function() {
				return U
			})), n.d(t, "g", (function() {
				return H
			})), n.d(t, "e", (function() {
				return G
			})), n.d(t, "f", (function() {
				return Q
			})), n.d(t, "d", (function() {
				return q
			})), n.d(t, "j", (function() {
				return K
			})), n.d(t, "i", (function() {
				return Y
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				i = n("./node_modules/lodash/xor.js"),
				a = n.n(i),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				l = n("./src/lib/name/index.ts"),
				u = n("./src/reddit/endpoints/subreddit/settings.ts"),
				m = n("./src/telemetry/index.ts"),
				p = n("./src/reddit/actions/toaster.ts"),
				b = n("./src/reddit/endpoints/subreddit/notificationSettings.ts"),
				f = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				h = n("./src/redditGQL/types.ts");
			const g = e => {
					var t, n;
					if (!e) return {};
					const {
						id: s,
						isArchivePostsEnabled: r,
						isDiscoveryAllowed: o,
						isChatPostCreationAllowed: i,
						isCrosspostingAllowed: a,
						isPredictionAllowed: d,
						isPredictionContributorsAllowed: c,
						isPredictionsTournamentAllowed: l,
						commentContributionSettings: u,
						discoverySettings: m,
						isNsfw: p,
						language: b,
						publicDescriptionText: f,
						isChatPostFeatureEnabled: g,
						welcomeMessage: v,
						allAllowedPostTypes: x,
						isTopListingAllowed: O,
						isCommentingRestricted: C,
						isPostingRestricted: A,
						isSpoilerAvailable: y,
						isContributorRequestsDisabled: I,
						isModmailHarassmentFilterEnabled: k,
						type: _,
						suggestedCommentSort: S,
						title: w,
						toxicityThresholdChatLevel: T,
						crowdControl: P,
						commentDisplaySettings: N,
						allowedPostType: D,
						wikiSettings: M,
						spamFilter: R,
						modQueueSettings: L,
						banEvasionFilterSettings: B
					} = e;
					return {
						allowGalleries: x.includes(h.Q.Gallery),
						allowImages: x.includes(h.Q.Image),
						allowVideos: x.includes(h.Q.Video),
						allowPolls: x.includes(h.Q.Poll),
						archivePostsEnabled: r,
						allowDiscovery: o,
						allowChatPostCreation: i,
						allowPostCrossposts: a,
						allowPredictionContributors: c,
						allowPredictions: d,
						allowPredictionsTournament: l,
						banEvasionFilterSettings: B,
						commentContributionSettings: u,
						discoverySettings: m,
						contentVisible: O,
						crowdControlLevel: E(null == P ? void 0 : P.crowdControlLevel),
						crowdControlChatLevel: E(null == P ? void 0 : P.crowdControlChatLevel),
						crowdControlPostLevel: E(null == P ? void 0 : P.crowdControlPostLevel),
						disableContributorRequests: I,
						isChatPostFeatureEnabled: g,
						language: b,
						modmailHarassmentFilterEnabled: k,
						over18: p,
						publicDescription: f || void 0,
						restrictCommenting: C,
						restrictPosting: A,
						spoilersEnabled: y,
						subredditId: s,
						subredditType: null == _ ? void 0 : _.toLowerCase(),
						suggestedCommentSort: (null == S ? void 0 : S.toLowerCase()) || void 0,
						title: w,
						toxicityThresholdChatLevel: j(T),
						welcomeMessageEnabled: null == v ? void 0 : v.isEnabled,
						welcomeMessageText: (null == v ? void 0 : v.body) ? null === (t = v.body) || void 0 === t ? void 0 : t.markdown : void 0,
						wikimode: null === (n = null == M ? void 0 : M.wikiEditMode) || void 0 === n ? void 0 : n.toLowerCase(),
						crowdControlFilter: null == P ? void 0 : P.isCrowdControlFilterEnabled,
						collapseDeletedComments: null == N ? void 0 : N.isCollapseDeletedCommentsEnabled,
						commentScoreHideMins: (null == N ? void 0 : N.commentScoreHideMinutes) || 0,
						contentOptions: D || void 0,
						excludeBannedModqueue: null == L ? void 0 : L.isExcludeBannedModqueueEnabled,
						spamLinks: (null == R ? void 0 : R.spamPosts) || void 0,
						spamSelfposts: (null == R ? void 0 : R.spamSelfposts) || void 0,
						spamComments: (null == R ? void 0 : R.spamComments) || void 0,
						wikiEditAge: "number" == typeof(null == M ? void 0 : M.wikiEditMinimumAge) ? null == M ? void 0 : M.wikiEditMinimumAge : void 0,
						wikiEditKarma: "number" == typeof(null == M ? void 0 : M.wikiEditKarma) ? null == M ? void 0 : M.wikiEditKarma : void 0
					}
				},
				v = [h.l.Off, h.l.Lenient, h.l.Medium, h.l.Strict],
				x = e => {
					if (e) return null == v ? void 0 : v[e]
				},
				E = e => e ? v.indexOf(e) : 0,
				O = e => {
					if (e) return Object.values(h.Y).find(t => t === (null == e ? void 0 : e.toUpperCase()))
				},
				C = e => {
					if (e) return Object.values(h.g).find(t => t === (null == e ? void 0 : e.toUpperCase()))
				},
				A = e => {
					if (e) return Object.values(h.gb).find(t => t === (null == e ? void 0 : e.toUpperCase()))
				},
				y = e => {
					if (e) return e > 0 ? h.bb.Enabled : h.bb.Disabled
				},
				j = e => {
					if (e) return e === h.bb.Enabled ? 1 : 0
				},
				I = e => {
					let {
						over18: t,
						publicDescription: n,
						subredditType: s,
						contentOptions: r,
						archivePostsEnabled: o,
						allowDiscovery: i,
						allowGalleries: a,
						allowImages: d,
						allowVideos: c,
						allowChatPostCreation: l,
						allowPolls: u,
						allowPostCrossposts: m,
						allowPredictionContributors: p,
						allowPredictionsTournament: b,
						welcomeMessageEnabled: f,
						welcomeMessageText: h,
						language: g,
						contentVisible: v,
						commentContributionSettings: E,
						crowdControlFilter: j,
						crowdControlPostLevel: I,
						crowdControlChatLevel: k,
						crowdControlLevel: _,
						allowPredictions: S,
						collapseDeletedComments: w,
						commentScoreHideMins: T,
						disableContributorRequests: P,
						discoverySettings: N,
						excludeBannedModqueue: D,
						hideAds: M,
						keyColor: R,
						modmailHarassmentFilterEnabled: L,
						restrictCommenting: B,
						restrictPosting: F,
						spamLinks: U,
						spamSelfposts: H,
						spamComments: G,
						spoilersEnabled: Q,
						showMedia: q,
						showMediaPreview: W,
						submitLinkLabel: z,
						submitTextLabel: V,
						submitText: K,
						suggestedCommentSort: Y,
						title: J,
						toxicityThresholdChatLevel: X,
						wikiEditAge: Z,
						wikiEditKarma: $,
						wikimode: ee,
						...te
					} = e;
					return {
						isNsfw: t,
						publicDescription: n,
						type: null == s ? void 0 : s.toUpperCase(),
						allowedPostType: null == r ? void 0 : r.toUpperCase(),
						isImagesAllowed: d,
						isVideosAllowed: c,
						isCrosspostingAllowed: m,
						isPollsAllowed: u,
						isGalleriesAllowed: a,
						isChatPostAllowed: l,
						isTopListingAllowed: v,
						isDiscoveryAllowed: i,
						isArchivePostsEnabled: o,
						isPredictionContributorsAllowed: p,
						isPredictionsTournamentAllowed: b,
						isModmailHarassmentFilterEnabled: L,
						language: g,
						crowdControlChatLevel: x(k),
						crowdControlFilter: j,
						crowdControlLevel: x(_),
						crowdControlPostLevel: x(I),
						welcomeMessage: h ? {
							markdown: h
						} : void 0,
						isWelcomeMessageEnabled: f,
						commentContributionSettings: E,
						allowPredictions: S,
						collapseDeletedComments: w,
						commentScoreHideMinutes: T,
						disableContributorRequests: P,
						discoverySettings: N,
						excludeBannedModqueue: D,
						restrictCommenting: B,
						restrictPosting: F,
						spamLinks: O(U),
						spamSelfposts: O(H),
						spamComments: O(G),
						spoilersEnabled: Q,
						suggestedCommentSort: C(Y),
						title: J,
						toxicityThresholdChatLevel: y(X),
						wikiEditKarma: $,
						wikiEditMinimumAge: Z,
						wikiEditMode: A(ee),
						...te
					}
				};
			var k = n("./src/reddit/helpers/trackers/inlineSubredditEditing.ts"),
				_ = n("./src/reddit/models/Toast/index.ts"),
				S = n("./src/reddit/models/User/index.ts"),
				w = n("./src/reddit/selectors/subreddit.ts"),
				T = n("./src/reddit/selectors/subredditSettings.ts"),
				P = n("./src/reddit/selectors/user.ts"),
				N = n("./src/reddit/selectors/widgets.ts");
			const D = "SUBREDDIT_SETTINGS_LOADED",
				M = Object(c.a)(D),
				R = "SUBREDDIT_NOTIFICATION_SETTINGS_LOADED",
				L = Object(c.a)(R),
				B = "SUBREDDIT_NOTIFICATION_SETTINGS_UPDATED",
				F = Object(c.a)(B),
				U = (e, t) => async (n, s, r) => {
					let {
						apiContext: o,
						gqlContext: i
					} = r;
					var a, d;
					const c = s(),
						m = !Object(l.b)(e);
					if (!t || !Object(w.Z)(c, t)) {
						const t = await (m ? Object(u.b)(i(), e) : Object(u.c)(o(), e)),
							s = m ? g(null === (d = null === (a = null == t ? void 0 : t.body) || void 0 === a ? void 0 : a.data) || void 0 === d ? void 0 : d.subredditInfoByName) : t.body;
						t && t.ok && n(M(s))
					}
					if (t && !Object(T.b)(c, {
							subredditId: t
						})) {
						const e = await Object(b.a)(i(), t);
						if (e && e.ok) {
							const t = e.body,
								s = Object(f.e)(t.data);
							n(L(s))
						}
					}
				}, H = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = Object(P.m)(t());
					r && await e(U(d.qc + Object(S.e)(r)))
				}, G = "SUBREDDIT_SETTINGS_UPDATE_REQUESTED", Q = "SUBREDDIT_SETTINGS_UPDATE_SUCCESS", q = "SUBREDDIT_SETTINGS_UPDATE_FAILURE", W = Object(c.a)(G), z = Object(c.a)(Q), V = Object(c.a)(q), K = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
						r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					return async (i, d, c) => {
						let {
							apiContext: l,
							gqlContext: f
						} = c;
						var h, v, x, E, O;
						i(W());
						const C = d(),
							A = o()(Object(w.Z)(C, e), ...Object.keys(t)),
							y = o()(Object(T.b)(C, {
								subredditId: e
							}), ...Object.keys(n)),
							j = I(t),
							S = await Object(u.f)(f(), e, j),
							P = Object.keys(n).length > 0;
						let D = !0;
						if (P) {
							D = (await Object(b.b)(f(), e, n)).ok
						}
						if (S.ok && (!P || D)) {
							const o = g(null === (x = null === (v = null === (h = null == S ? void 0 : S.body) || void 0 === h ? void 0 : h.data) || void 0 === v ? void 0 : v.updateSubredditSettings) || void 0 === x ? void 0 : x.subreddit);
							i(z({
								settings: {
									...o,
									subredditId: e
								},
								idCardWidgetId: Object(N.c)(C, {
									subredditId: e
								})
							})), P && i(F({
								notificationSettings: n,
								subredditId: e
							}));
							const d = {};
							return r && 0 === a()(Object.keys(t), Object.keys(A)).length && (d.buttonText = s.fbt._("Undo", null, {
								hk: "1Gskii"
							}), d.buttonAction = K(e, A, y, r)), void i(Object(p.f)({
								kind: _.b.SuccessCommunity,
								text: s.fbt._("Subreddit settings updated successfully", null, {
									hk: "2fmdlZ"
								}),
								...d
							}))
						}
						i(V()), (null === (O = null === (E = S.error) || void 0 === E ? void 0 : E.fields) || void 0 === O ? void 0 : O.some(e => e.msg.includes("INACTIVE_MODERATOR"))) ? i(Object(p.f)({
							kind: _.b.Error,
							text: s.fbt._("You must be an active moderator to update this setting", null, {
								hk: "3qhpxZ"
							}),
							duration: 4e3
						})) : i(Object(p.f)({
							kind: _.b.Error,
							text: s.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
								hk: "3wBPeO"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: K(e, t, y, void 0)
						})), r && Object(m.a)(Object(k.c)(C, "BE returned an error:"))
					}
				}, Y = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					(await Object(u.d)(i(), e, t)).ok ? n(Object(p.f)({
						kind: _.b.SuccessCommunity,
						text: s.fbt._("Test message was sent to your inbox", null, {
							hk: "1ZtKzO"
						})
					})) : n(Object(p.f)({
						kind: _.b.Error,
						text: s.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
							hk: "3wBPeO"
						})
					}))
				}
		},
		"./src/reddit/actions/subscription/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			}));
			const s = "SUBSCRIPTION__FETCH_DATA_PENDING",
				r = "SUBSCRIPTION__FETCH_DATA_SUCCESS",
				o = "SUBSCRIPTION__FETCH_DATA_FAILURE",
				i = "SUBSCRIPTION__SUBSCRIPTION_TOGGLED",
				a = "SUBSCRIPTION__SUBSCIPTION_TOGGLE_FAILED",
				d = "SUBSCRIPTION__ORDER_LOADED",
				c = "SUBSCRIPTION__SUBREDDIT_FAVORITE_TOGGLED",
				l = "SUBSCRIPTION__MULTI_FAVORITE_TOGGLED",
				u = "SUBSCRIPTION__MULTI_FOLLOW_TOGGLED"
		},
		"./src/reddit/actions/subscription/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return T
			})), n.d(t, "d", (function() {
				return N
			})), n.d(t, "c", (function() {
				return M
			})), n.d(t, "a", (function() {
				return L
			})), n.d(t, "b", (function() {
				return F
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/linkMatchers/customLinks.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/login.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/subscription/constants.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/constants/posts.ts"),
				m = n("./src/lib/makeApiRequest/index.ts"),
				p = n("./src/lib/omitHeaders/index.ts"),
				b = n("./src/reddit/constants/headers.ts");
			var f = n("./src/reddit/endpoints/subreddit/subscriptions.ts"),
				h = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				g = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				v = n("./src/reddit/models/GqlTopLevelField.ts"),
				x = n("./src/reddit/models/User/index.ts");

			function E(e) {
				const t = [],
					n = [],
					s = {},
					r = {},
					{
						followedRedditorsInfo: o
					} = e.identity;
				for (const a of o.edges) {
					if (a.node.__typename !== x.c.AvailableRedditor || !a.node.profile) continue;
					const e = Object(h.a)(a.node.profile);
					s[e.id] = e;
					const {
						isFavorite: n
					} = a.node.profile;
					n && t.push(e.id)
				}
				const {
					subscribedSubreddits: i
				} = e.identity;
				for (const a of i.edges) {
					if (a.node.__typename !== v.a.Subreddit) continue;
					const e = Object(g.a)(a.node);
					r[e.id] = e;
					const {
						isFavorite: t
					} = a.node;
					t && n.push(e.id)
				}
				return {
					favoriteProfileIds: t,
					favoriteSubredditIds: n,
					profiles: s,
					subreddits: r
				}
			}
			var O = n("./src/reddit/models/Toast/index.ts"),
				C = n("./src/reddit/selectors/profile.ts"),
				A = n("./src/reddit/selectors/subreddit.ts"),
				y = n("./src/reddit/selectors/subscriptions.ts"),
				j = n("./src/reddit/selectors/user.ts");
			const I = () => s.fbt._("Sorry, failed to update favorites.", null, {
					hk: "40XHkp"
				}),
				k = Object(i.a)(c.c),
				_ = Object(i.a)(c.b),
				S = Object(i.a)(c.a),
				w = Object(i.a)(c.h),
				T = (Object(i.a)(c.i), Object(i.a)(c.g), () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					const r = t();
					if (!r.user.account || r.subscriptions.api.fetched) return;
					e(_());
					const o = await Object(f.a)(s());
					if (o.ok) {
						const t = E(o.body.data);
						e(k(t))
					} else e(S({
						error: o.error
					}))
				}),
				P = (e, t) => t.type === u.a.PROFILE && e.displayText === t.name.replace("u_", ""),
				N = (e, t, n) => async (i, c, m) => {
					let {
						apiContext: p
					} = m, b = e.map(e => e.type === u.a.SUBREDDIT ? {
						id: Object(A.I)(c(), e.name),
						name: e.name,
						type: e.type
					} : {
						id: Object(C.o)(c(), e.name),
						name: `${r.qc}${e.name}`,
						type: e.type
					});
					if (!Object(j.S)(c())) return i(Object(d.k)({
						actionSource: d.a.Subscribe
					})), void i(Object(a.openRegisterModal)());
					const h = Object(j.m)(c());
					if (h) {
						const t = b.length,
							n = e.length;
						if (b = b.filter(e => !P(h, e)), (e = e.filter(e => !P(h, e))).length !== n || b.length !== t) {
							const e = s.fbt._("You cannot follow yourself!", null, {
								hk: "3tfSaq"
							});
							i(Object(l.f)(Object(l.e)(e, O.b.Error)))
						}
						if (!e.length && !b.length) return
					}
					i(w({
						identifiers: b,
						nameIdentifiers: e,
						profileModels: c().profiles.models,
						subredditModels: c().subreddits.models,
						subscriptionsCount: Object(y.b)(c()),
						userIsSubscriber: t,
						widgetId: n
					}));
					const g = await Object(f.c)(p(), {
						subredditNames: b.map(e => {
							let {
								name: t
							} = e;
							return t
						}),
						subscribe: t
					});
					if (g.ok) {
						const n = 1 === e.length ? `${"subreddit"===e[0].type?o.d.subreddit:o.d.profile}${e[0].name}` : s.fbt._({
								"*": "{communities} communities",
								_1: "1 community"
							}, [s.fbt._plural(e.length, "communities")], {
								hk: "IgDzJ"
							}),
							r = s.fbt._("Successfully followed {communityname}", [s.fbt._param("communityname", n)], {
								hk: "23Snyg"
							}),
							a = s.fbt._("Successfully unfollowed {communityname}", [s.fbt._param("communityname", n)], {
								hk: "jfC0S"
							}),
							d = s.fbt._("Successfully joined {communityname}", [s.fbt._param("communityname", n)], {
								hk: "1W9UY3"
							}),
							c = s.fbt._("Successfully left {communityname}", [s.fbt._param("communityname", n)], {
								hk: "1saMW"
							});
						i(Object(l.f)({
							text: 1 === e.length && "profile" === e[0].type ? t ? r : a : t ? d : c
						}))
					} else {
						i(w({
							identifiers: b,
							nameIdentifiers: e,
							profileModels: c().profiles.models,
							subredditModels: c().subreddits.models,
							subscriptionsCount: Object(y.b)(c()),
							userIsSubscriber: !t,
							widgetId: n
						}));
						const r = s.fbt._("Something went wrong. Please try again!", null, {
							hk: "1zlDeq"
						});
						i(Object(l.f)(Object(l.e)(r, O.b.Error)))
					}
					return g.ok
				}, D = Object(i.a)(c.f), M = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						i = Object(A.Q)(o, {
							identifier: e
						});
					if (!i) throw new Error(`actions.subscription -- No subreddit or profile found with id ${e.id}`);
					const a = e.type === u.a.SUBREDDIT ? i.name : `u_${i.name}`,
						d = o.subscriptions.favoriteSubredditOrder || [],
						c = o.subscriptions.favoriteProfileOrder || [],
						m = d.indexOf(e.id),
						p = c.indexOf(e.id),
						b = -1 === m && -1 === p,
						h = o.subreddits.models,
						g = o.profiles.models,
						v = {
							type: e.type,
							name: i.name
						},
						x = () => Object(A.jb)(n(), {
							identifier: v
						});
					(x() || (await t(N([v], !0)), x())) && (t(D({
						makeFavorite: b,
						identifier: e,
						subredditModels: h,
						profileModels: g
					})), (await Object(f.b)(r(), a, b)).ok || (t(D({
						makeFavorite: !b,
						identifier: e,
						subredditModels: h,
						profileModels: g
					})), t(Object(l.f)({
						text: I(),
						kind: O.b.Error
					}))))
				}, R = Object(i.a)(c.d), L = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const i = n().multireddits.models,
						a = () => {
							t(Object(l.f)({
								text: I(),
								kind: O.b.Error
							}))
						},
						d = i[e];
					if (!d) return void a();
					const c = !d.isFavorited;
					t(R({
						makeFavorite: c,
						multiredditPath: e,
						multiredditsModelsState: i
					})), (await ((e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
						method: r.ob.POST,
						endpoint: `${e.apiUrl}/api/multi/favorite`,
						data: {
							make_favorite: n ? "true" : "false",
							multipath: t,
							api_type: "json"
						}
					}))(o(), e, c)).ok || (t(R({
						makeFavorite: !c,
						multiredditPath: e,
						multiredditsModelsState: i
					})), a())
				}, B = Object(i.a)(c.e), F = e => async (t, n, o) => {
					let {
						apiContext: i
					} = o;
					const a = n(),
						d = a.multireddits.models;
					if (!Object(j.S)(a)) return;
					const c = function() {
							let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
							t(Object(l.f)({
								text: s.fbt._("Sorry, failed to {followAction}", [s.fbt._param("followAction", e ? s.fbt._("follow", null, {
									hk: "3YMYJK"
								}) : s.fbt._("unfollow", null, {
									hk: "24IYxj"
								}))], {
									hk: "1ufRSl"
								}),
								kind: O.b.Error
							}))
						},
						u = d[e];
					if (!u) return void c();
					const f = !u.isFollowed;
					t(B({
						follow: f,
						multiredditPath: e,
						multiredditsModelsState: d
					})), (await ((e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
						method: r.ob.POST,
						endpoint: `${e.apiUrl}/api/multi/subscribe`,
						data: {
							action: n ? "sub" : "unsub",
							path: t,
							api_type: "json"
						},
						type: "json"
					}))(i(), e, f)).ok || (t(B({
						follow: !f,
						multiredditPath: e,
						multiredditsModelsState: d
					})), c(f))
				}
		},
		"./src/reddit/actions/tabBadging.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "f", (function() {
				return v
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/lib/fastdom/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				a = n("./src/reddit/helpers/tabBadging/index.ts"),
				d = n("./src/reddit/models/Badge/index.ts"),
				c = n("./src/reddit/selectors/appBadges.ts"),
				l = n("./src/reddit/selectors/user.ts"),
				u = n("./src/reddit/actions/appBadgeIndicators/index.ts");
			const m = "TAB__UPDATE_HAS_UNREAD_MESSAGES_BADGE",
				p = Object(o.a)(m),
				b = (e, t) => {
					e <= 0 ? r.a.write(() => {
						Object(a.b)(!1), window.document.title = t
					}) : r.a.write(() => {
						Object(a.b)(), window.document.title = `(${e}) ${t}`
					})
				},
				f = Object(s.c)({
					basicChannelCount: c.f,
					subredditChannelCount: c.d,
					subredditMentionCount: c.c
				}),
				h = () => async (e, t) => {
					const n = t(),
						s = Object(i.g)(n, {});
					if (!(Object(l.R)(n) || Object(l.S)(n)) || !s) return;
					const r = Object(c.j)(n);
					b(r, s), e(p({
						hasUnreadMessages: !!r
					}))
				}, g = () => async (e, t) => {
					{
						e(h());
						const n = (e => ({
							inboxCount: Object(c.i)(e),
							basicChannelCount: Object(c.f)(e)
						}))(t());
						Object(a.c)(n)
					}
				}, v = e => async (t, n) => {
					const s = n(),
						r = Object(c.f)(s),
						o = Object(c.i)(s),
						{
							basicChannelCount: i,
							inboxCount: a
						} = e;
					if (r !== i) {
						const e = Object(u.e)({
							count: i,
							key: d.c.ChatTab
						});
						t(Object(u.a)(e))
					}
					if (a && a !== o) {
						const e = Object(u.e)({
							count: a,
							key: d.c.MessageTab
						});
						t(Object(u.a)(e))
					}(r !== i || a && a !== o) && t(h())
				}
		},
		"./src/reddit/actions/tags/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "t", (function() {
				return s
			})), n.d(t, "j", (function() {
				return r
			})), n.d(t, "r", (function() {
				return o
			})), n.d(t, "q", (function() {
				return i
			})), n.d(t, "s", (function() {
				return a
			})), n.d(t, "l", (function() {
				return d
			})), n.d(t, "m", (function() {
				return c
			})), n.d(t, "k", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "v", (function() {
				return b
			})), n.d(t, "w", (function() {
				return f
			})), n.d(t, "u", (function() {
				return h
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "f", (function() {
				return x
			})), n.d(t, "A", (function() {
				return E
			})), n.d(t, "z", (function() {
				return O
			})), n.d(t, "D", (function() {
				return C
			})), n.d(t, "y", (function() {
				return A
			})), n.d(t, "C", (function() {
				return y
			})), n.d(t, "x", (function() {
				return j
			})), n.d(t, "B", (function() {
				return I
			})), n.d(t, "e", (function() {
				return k
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "c", (function() {
				return w
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "i", (function() {
				return P
			}));
			const s = "TAGS__REQUESTED",
				r = "TAGS__AVAILABLE_LOADED",
				o = "TAGS__LOADED",
				i = "TAGS__FAILURE",
				a = "TAGS__RELEVANCE_LOADED",
				d = "TAGS__CREATE_REQUESTED",
				c = "TAGS__CREATE_SUCCESS",
				l = "TAGS__CREATE_FAILURE",
				u = "TAGS__DELETE_REQUESTED",
				m = "TAGS__DELETE_SUCCESS",
				p = "TAGS__DELETE_FAILURE",
				b = "TAGS__UPDATE_STATE_REQUESTED",
				f = "TAGS__UPDATE_STATE_SUCCESS",
				h = "TAGS__UPDATE_STATE_FAILURE",
				g = "PRIMARY_TAG__UPDATE_STATE_REQUESTED",
				v = "PRIMARY_TAG__UPDATE_STATE_SUCCESS",
				x = "PRIMARY_TAG__UPDATE_STATE_FAILURE",
				E = "TAGS__OPTIONS_CANCELLED",
				O = "TAGS__OPTION_SELECTED",
				C = "TAGS__SUGGESTED_OPTION_SELECTED",
				A = "TAGS__OPTION_DESELECTED",
				y = "TAGS__SUGGESTED_OPTION_DESELECTED",
				j = "TAGS__INPUT_CHANGED",
				I = "TAGS__SUGGESTED_INPUT_CHANGED",
				k = "GLOBAL__TAGS__LOADED",
				_ = "CREATION__TAGS_INPUT_CHANGED",
				S = "CREATION__TAGS_OPTION_SELECTED",
				w = "CREATION__TAGS_OPTION_DESELECTED",
				T = "CREATION__PRIMARY_TAG_SELECTED",
				P = "SETTINGS_PAGE_PRIMARY_TAG_UPDATE"
		},
		"./src/reddit/actions/tags/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return R
			})), n.d(t, "m", (function() {
				return L
			})), n.d(t, "i", (function() {
				return B
			})), n.d(t, "l", (function() {
				return F
			})), n.d(t, "h", (function() {
				return U
			})), n.d(t, "k", (function() {
				return H
			})), n.d(t, "a", (function() {
				return W
			})), n.d(t, "f", (function() {
				return z
			})), n.d(t, "g", (function() {
				return K
			})), n.d(t, "e", (function() {
				return Z
			})), n.d(t, "d", (function() {
				return $
			})), n.d(t, "b", (function() {
				return ee
			})), n.d(t, "n", (function() {
				return te
			})), n.d(t, "c", (function() {
				return ne
			})), n.d(t, "o", (function() {
				return se
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/tags/constants.ts"),
				i = n("./src/reddit/actions/toaster.ts");
			const a = e => {
				const {
					subredditInfoById: t
				} = e, n = {
					global: {},
					[t.id]: {}
				};
				t.availableTags && t.availableTags.edges.reduce((e, t) => {
					let {
						node: n
					} = t;
					return e[n.subreddit && n.subreddit.id || "global"][n.id] = n, e
				}, n);
				const s = {
					[t.id]: {}
				};
				t.secondaryTags && t.secondaryTags.edges.reduce((e, n) => {
					let {
						node: s
					} = n;
					return e[t.id][s.tag.id] = s, e
				}, s);
				const r = {
					[t.id]: {}
				};
				return t.suggestedTags && t.suggestedTags.edges.reduce((e, n) => {
					let {
						node: s
					} = n;
					return e[t.id][s.tag.id] = s, e
				}, r), {
					primaryTag: t.primaryTag,
					globalSubredditTags: n.global,
					subredditScopedTags: {
						[t.id]: n[t.id]
					},
					subredditId: t.id,
					itemTags: s,
					suggestedItemTags: r,
					geoPlace: t.geoPlace
				}
			};
			var d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/CreateSubredditTags.json");
			const l = 1050;
			n("./src/redditGQL/operations/FetchGlobalTags.json");
			var u = n("./src/redditGQL/operations/FetchSubredditTags.json");
			const m = (e, t) => {
				let {
					subredditId: n,
					pageSize: s = l,
					after: r,
					includeAvailableTags: o
				} = t;
				return Object(d.a)(e, {
					...u,
					variables: {
						subredditId: n,
						pageSize: s,
						after: r,
						includeAvailableTags: o
					}
				})
			};
			var p = n("./src/redditGQL/operations/MaybeDeleteTagsAndUpdateItemTags.json");
			const b = (e, t) => Object(d.a)(e, {
				...p,
				variables: {
					...t,
					deleteTags: 0 !== t.deleteTagsInput.length,
					pageSize: l
				}
			});
			var f = n("./src/redditGQL/operations/UpdateSubredditTagStatesRelevance.json");
			const h = (e, t) => Object(d.a)(e, {
				...f,
				variables: t
			});
			var g = n("./src/redditGQL/operations/UpdateSubredditPrimaryTag.json");
			const v = e => {
					const {
						secondaryTags: t,
						id: n,
						primaryTag: s
					} = e.updateSubredditTagStates.subreddit, r = t && t.edges || [];
					return {
						subredditId: n,
						primaryTagId: s && s.tag.id || null,
						secondaryTags: r.reduce((e, t) => {
							let {
								node: n
							} = t;
							return e[n.tag.id] = n, e
						}, {})
					}
				},
				x = (e, t) => Object(d.a)(e, {
					...g,
					variables: t
				});
			var E = n("./src/reddit/helpers/tags/index.ts"),
				O = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				C = n("./src/reddit/models/Tags/index.ts"),
				A = n("./src/reddit/models/Toast/index.ts"),
				y = n("./src/reddit/reducers/tags/selected/index.ts"),
				j = n("./src/reddit/selectors/tags.ts");
			Object(r.a)(o.e);
			const I = Object(r.a)(o.t),
				k = Object(r.a)(o.r),
				_ = Object(r.a)(o.s),
				S = Object(r.a)(o.q),
				w = Object(r.a)(o.l),
				T = Object(r.a)(o.m),
				P = Object(r.a)(o.k),
				N = Object(r.a)(o.v),
				D = Object(r.a)(o.w),
				M = Object(r.a)(o.u),
				R = Object(r.a)(o.z),
				L = Object(r.a)(o.D),
				B = Object(r.a)(o.y),
				F = Object(r.a)(o.C),
				U = Object(r.a)(o.x),
				H = Object(r.a)(o.B),
				G = (Object(r.a)(o.d), Object(r.a)(o.c), Object(r.a)(o.b), Object(r.a)(o.g)),
				Q = Object(r.a)(o.h),
				q = Object(r.a)(o.f),
				W = Object(r.a)(o.a),
				z = Object(r.a)(o.i),
				V = Object(r.a)(o.A),
				K = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (r, o, d) => {
						let {
							gqlContext: c
						} = d;
						const l = o();
						r(I());
						const u = await m(c(), {
								subredditId: e
							}),
							p = u.body;
						if (u.ok && p.data.subredditInfoById.secondaryTags && p.data.subredditInfoById.availableTags && p.data.subredditInfoById.suggestedTags) r(k(a(p.data))), n && O.h(o(), e, {
							context: t
						});
						else {
							r(S());
							const o = n ? "topics_save" : "topics_load";
							O.g(l, e, o, {
								context: t
							}), r(Object(i.f)(Object(i.e)(s.fbt._("Oh no! We didn't load your topics. Please try again.", null, {
								hk: "2DUkWX"
							}), A.b.Error, s.fbt._("Retry", null, {
								hk: "1c2xrJ"
							}), K(e, t, n))))
						}
					}
				},
				Y = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					t(I());
					const d = await m(o(), {
						subredditId: e
					});
					if (d.ok) {
						const e = d.body;
						t(_(a(e.data)))
					} else t(S()), t(Object(i.f)(Object(i.e)(s.fbt._("Oh no! We didn't load your topics. Please try again.", null, {
						hk: "2DUkWX"
					}), A.b.Error, s.fbt._("Retry", null, {
						hk: "1c2xrJ"
					}), _(e))))
				}, J = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					if (!t.length) return null;
					n(w());
					const i = t.map(t => ({
							subredditId: e,
							...t
						})),
						a = await ((e, t) => Object(d.a)(e, {
							...c,
							variables: t
						}))(o(), {
							input: i
						}),
						l = a.body && a.body.data || null;
					return a.ok && l && l.createSubredditTags && l.createSubredditTags.ok ? (n(T()), l.createSubredditTags.createdTags || []) : (n(P()), null)
				}, X = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
					return async (s, r, o) => {
						let {
							gqlContext: i
						} = o;
						if (!t.length && !n.length) return;
						s(N());
						const d = r(),
							c = Object(j.d)(d, {
								subredditId: e
							}),
							l = Object(j.o)(d, {
								itemId: e
							}),
							u = Object(j.z)(d, {
								itemId: e
							}),
							m = new Set;
						for (const e of t)
							if (e.state === C.d.NONE && c[e.tagId] && !u[e.tagId]) {
								!!n.find(t => t.state === C.d.TAGGED && t.tagId === e.tagId) || m.add(e.tagId)
							} for (const e of n)
							if (e.state === C.d.NONE && c[e.tagId] && !l[e.tagId]) {
								!!t.find(t => t.state === C.d.TAGGED && t.tagId === e.tagId) || m.add(e.tagId)
							} const p = await b(i(), {
								deleteTagsInput: [...m].map(t => ({
									tagId: t,
									subredditId: e
								})),
								updateTagStatesInput: {
									subredditId: e,
									suggestedTagStates: n,
									tagStates: t
								}
							}),
							f = p.body && p.body.data || null;
						p.ok && f && f.updateSubredditTagStates && f.updateSubredditTagStates.ok && f.updateSubredditTagStates.subreddit ? s(D(a({
							subredditInfoById: f.updateSubredditTagStates.subreddit
						}))) : s(M())
					}
				}, Z = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (r, o, a) => {
						const d = o(),
							c = Object(j.q)(d, {
								subredditId: e
							}),
							l = Object(j.C)(d, {
								subredditId: e
							});
						let u = c.filter(e => !!e.id && !!e.action).map(e => ({
							tagId: e.id,
							state: e.action === y.a.ADD ? C.d.TAGGED : C.d.NONE
						}));
						if (l.length > 0) {
							const t = await J(e, l)(r, o, a);
							u = u.concat((t || []).map(e => ({
								tagId: e.id,
								state: C.d.TAGGED
							})))
						}
						await X(e, u)(r, o, a), Object(j.A)(o()) ? r(Object(i.f)(Object(i.e)(s.fbt._("Yikes! It looks like we didn't save all of your topics. Please try again", null, {
							hk: "2Jbh5V"
						}), A.b.Error, s.fbt._("Retry", null, {
							hk: "1c2xrJ"
						}), Z(e, t, n)))) : n && r(Object(i.f)(Object(i.e)(s.fbt._("Community topics saved!", null, {
							hk: "3wtajT"
						}), A.b.SuccessCommunity)))
					}
				}, $ = (e, t, n) => async (n, r, o) => {
					const a = {
						state: C.d.TAGGED
					};
					if (Object(E.b)(t)) {
						const s = await J(e, [{
							text: t.displayText,
							type: C.c.CLASSIFICATION
						}])(n, r, o);
						s && 1 === s.length && (a.tagId = s[0].id)
					} else {
						if (!t.id) return void n(Object(i.f)(Object(i.e)(s.fbt._("Whoops, we couldn't save that topic. Please try again later.", null, {
							hk: "CxjiK"
						}), A.b.Error)));
						a.tagId = t.id
					}(e => !!e.tagId && !!e.state)(a) ? await X(e, [], [a])(n, r, o): n(Object(i.f)(Object(i.e)(s.fbt._("Whoops, we couldn't save that topic. Please try again later.", null, {
						hk: "CxjiK"
					}), A.b.Error)))
				}, ee = (e, t, n) => async (s, r, o) => {
					t.id ? await X(e, [], [{
						state: C.d.NONE,
						tagId: t.id
					}])(s, r, o) : s(K(e, n, !1))
				}, te = function(e, t, n, r) {
					let o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
					return async (a, d, c) => {
						let {
							gqlContext: l
						} = c;
						if (!(await h(l(), {
								input: {
									tagStatesRelevance: t,
									suggestedTagStatesRelevance: n
								}
							})).ok) return a(Object(i.f)(Object(i.e)(s.fbt._("Whoops! Unable to update topics relevance status", null, {
							hk: "17akdT"
						}), A.b.Error, s.fbt._("Retry", null, {
							hk: "1wqK2v"
						}), te(e, t, n, r, o)))), void a(Y(e));
						if (o)
							for (const e of n) O.f(d(), e, {
								context: r
							});
						a(Object(i.f)(Object(i.e)(s.fbt._("Successfully updated topics relevance!", null, {
							hk: "3KIYlz"
						}), A.b.SuccessCommunity, s.fbt._("Undo", null, {
							hk: "34apPL"
						}), te(e, t.map(e => ({
							...e,
							isRelevant: !e.isRelevant
						})), n.map(e => ({
							...e,
							isRelevant: !e.isRelevant
						})), r, o)))), a(Y(e))
					}
				}, ne = e => async (t, n) => {
					t(V({
						itemTagsState: {
							[e]: Object(j.o)(n(), {
								itemId: e
							})
						}
					}))
				}, se = function(e, t) {
					let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (r, o, a) => {
						let {
							gqlContext: d
						} = a;
						const c = Object(j.x)(o(), {
							subredditId: e
						});
						if ((null == c ? void 0 : c.id) === t.tagId && t.state === C.d.TAGGED) return;
						r(G());
						const l = await x(d(), {
								input: {
									subredditId: e,
									primaryTagState: t
								}
							}),
							u = l.body && l.body.data || null;
						l.ok && u && u.updateSubredditTagStates && u.updateSubredditTagStates.ok ? (r(Q(v(u))), n && r(Object(i.f)(Object(i.e)(s.fbt._("Successfully updated primary topic!", null, {
							hk: "1NL90v"
						}), A.b.SuccessCommunity)))) : (r(q()), r(Object(i.f)(Object(i.e)(s.fbt._("Whoops! Unable to update primary topic", null, {
							hk: "3ilZqp"
						}), A.b.Error, s.fbt._("Retry", null, {
							hk: "1dRYXW"
						}), se(e, t)))))
					}
				}
		},
		"./src/reddit/actions/trafficStats/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "SUBREDDIT__TRAFFIC_STATS_LOADED",
				r = "SUBREDDIT__TRAFFIC_STATS_PENDING",
				o = "SUBREDDIT__TRAFFIC_STATS_FAILED"
		},
		"./src/reddit/actions/upload.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "m", (function() {
				return x
			})), n.d(t, "k", (function() {
				return I
			})), n.d(t, "l", (function() {
				return _
			})), n.d(t, "i", (function() {
				return S
			})), n.d(t, "j", (function() {
				return w
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/get.js"),
				r = n.n(s),
				o = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/uploadToS3/index.ts"),
				d = n("./src/reddit/models/Upload/index.ts");
			const c = "UPLOAD_PENDING",
				l = "UPLOAD_UPLOADING",
				u = "UPLOAD_METADATA_CHANGED",
				m = "UPLOAD_PROGRESS",
				p = "UPLOAD_SUCCESS",
				b = "UPLOAD_FAILED",
				f = "UPLOAD_CANCELED",
				h = "UPLOAD_REMOVED",
				g = Object(i.a)(c),
				v = Object(i.a)(l),
				x = Object(i.a)(u),
				E = Object(i.a)(m),
				O = Object(i.a)(p),
				C = Object(i.a)(b),
				A = Object(i.a)(f),
				y = Object(i.a)(h),
				j = new Map,
				I = (e, t) => {
					const n = j.get(e) || [];
					n.push(t), j.set(e, n)
				},
				k = (e, t) => {
					const n = j.get(e);
					n && n.forEach(n => n(e, t)), j.delete(e)
				},
				_ = function(e, t, n) {
					let s = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					return async (i, c) => {
						const l = t;
						if (c().uploads[l] && Object(d.c)(c().uploads[l])) return;
						const u = Object(o.a)(),
							m = () => {
								const e = c().uploads[l];
								return !e || e.id !== u || e.status === d.a.CANCELED
							};
						i(g({
							key: l,
							id: u,
							file: e
						}));
						const {
							uploadLease: p,
							error: b
						} = await n(c().uploads[l]);
						if (m()) return;
						if (b || !p) return void i(C({
							key: l,
							error: b
						}));
						let f;
						I(u, () => {
							f && f.abort()
						}), i(v({
							key: l
						}));
						const h = await Object(a.a)(e, p, e => (f = e, s && e.on("progress", e => {
							if (!m() && "upload" === e.direction) {
								const t = {
									percent: e.percent,
									total: e.total,
									uploaded: e.loaded
								};
								i(E({
									key: l,
									progress: t
								}))
							}
						}), e));
						if (f = null, !m())
							if (h.ok) {
								const e = decodeURIComponent(h.body.PostResponse.Location);
								i(O({
									key: l,
									url: e
								}))
							} else {
								const e = r()(h, "body.Error.Message.0"),
									t = {
										type: "ERROR",
										...e ? {
											fields: [{
												field: "0",
												msg: e
											}]
										} : {}
									};
								i(C({
									key: l,
									error: t
								}))
							}
					}
				},
				S = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return (n, s) => {
						const r = s().uploads[e];
						r && (k(r.id, t), n(t ? y({
							key: e
						}) : A({
							key: e
						})))
					}
				},
				w = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return (n, s) => {
						Object.keys(s().uploads).forEach(s => {
							s.startsWith(e) && n(S(s, t))
						})
					}
				}
		},
		"./src/reddit/actions/urlRequested.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/lib/matchRoute/index.ts"),
				r = n("./src/lib/opener/index.ts"),
				o = n("./node_modules/react-router-redux/es/index.js");
			const i = function(e) {
				let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
				return async (n, i, a) => {
					let {
						routes: d
					} = a;
					const c = i();
					Object(s.a)(e, d, c) ? n(Object(o.b)(e)) : t ? Object(r.e)(e, "_blank") : window.location.assign(e)
				}
			}
		},
		"./src/reddit/actions/userFlair/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "s", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "i", (function() {
				return o
			})), n.d(t, "j", (function() {
				return i
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "p", (function() {
				return u
			})), n.d(t, "q", (function() {
				return m
			})), n.d(t, "o", (function() {
				return p
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "m", (function() {
				return g
			})), n.d(t, "n", (function() {
				return v
			})), n.d(t, "l", (function() {
				return x
			})), n.d(t, "k", (function() {
				return E
			})), n.d(t, "r", (function() {
				return O
			}));
			const s = "USER_FLAIR_DATA__MUTATED",
				r = "AUTHOR_FLAIR_DATA__MUTATED",
				o = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_PENDING",
				i = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_SUCCESS",
				a = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_FAILED",
				d = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_PENDING",
				c = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_SUCCESS",
				l = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_FAILED",
				u = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_PENDING",
				m = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_SUCCESS",
				p = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_FAILED",
				b = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_PENDING",
				f = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_SUCCESS",
				h = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_FAILED",
				g = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_PENDING",
				v = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_SUCCESS",
				x = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_FAILED",
				E = "USERFLAIR_FETCH_SUCCESS",
				O = "USERFLAIR_TEMPLATES_LOADED"
		},
		"./src/reddit/actions/userFlair/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			}));
			var s = n("./src/lib/loadableAction/index.ts");
			const r = Object(s.a)(() => Promise.resolve().then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.userFlairChanged)),
				o = Object(s.a)(() => Promise.resolve().then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.toggleUserFlairInSubreddit)),
				i = Object(s.a)(() => Promise.resolve().then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.toggleAssignOwnFlairPermission)),
				a = Object(s.a)(() => Promise.resolve().then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.saveUserFlairTemplate)),
				d = Object(s.a)(() => Promise.resolve().then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.deleteUserFlairTemplate)),
				c = Object(s.a)(() => Promise.resolve().then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.reorderUserFlairTemplates)),
				l = Object(s.a)(() => Promise.resolve().then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.userFlairLoadedAndModalOpened))
		},
		"./src/reddit/actions/userFlair/userFlair.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "userFlairEnabledSettingPending", (function() {
				return E
			})), n.d(t, "userFlairEnabledSettingSuccess", (function() {
				return O
			})), n.d(t, "userFlairEnabledSettingFailed", (function() {
				return C
			})), n.d(t, "userFlairAllowAssingOwnSettingPending", (function() {
				return A
			})), n.d(t, "userFlairAllowAssignOwnSettingSuccess", (function() {
				return y
			})), n.d(t, "userFlairAllowAssingOwnSettingFailed", (function() {
				return j
			})), n.d(t, "userFlairSaveTemplatePending", (function() {
				return I
			})), n.d(t, "userFlairSaveTemplateSuccess", (function() {
				return k
			})), n.d(t, "userFlairSaveTemplateFailed", (function() {
				return _
			})), n.d(t, "userFlairDeleteTemplatePending", (function() {
				return S
			})), n.d(t, "userFlairDeleteTemplateSuccess", (function() {
				return w
			})), n.d(t, "userFlairDeleteTemplateFailed", (function() {
				return T
			})), n.d(t, "userFlairReorderTemplatesPending", (function() {
				return P
			})), n.d(t, "userFlairReorderTemplatesSuccess", (function() {
				return N
			})), n.d(t, "userFlairReorderTemplatesFailed", (function() {
				return D
			})), n.d(t, "userFlairFetchSuccess", (function() {
				return M
			})), n.d(t, "userFlairMutated", (function() {
				return R
			})), n.d(t, "authorFlairMutated", (function() {
				return L
			})), n.d(t, "userFlairChanged", (function() {
				return B
			})), n.d(t, "toggleUserFlairInSubreddit", (function() {
				return F
			})), n.d(t, "toggleAssignOwnFlairPermission", (function() {
				return U
			})), n.d(t, "saveUserFlairTemplate", (function() {
				return H
			})), n.d(t, "deleteUserFlairTemplate", (function() {
				return G
			})), n.d(t, "reorderUserFlairTemplates", (function() {
				return Q
			})), n.d(t, "userFlairLoadedAndModalOpened", (function() {
				return q
			})), n.d(t, "userFlairTemplatesLoaded", (function() {
				return W
			})), n.d(t, "fetchUserFlairFromGql", (function() {
				return z
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./node_modules/lodash/isEmpty.js"),
				i = n.n(o),
				a = n("./src/reddit/actions/authorFlair.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/endpoints/flair/index.ts"),
				l = n("./src/reddit/helpers/flair.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				m = n("./src/reddit/models/Flair/index.ts"),
				p = n("./src/reddit/models/Toast/index.ts"),
				b = n("./src/reddit/models/User/index.ts"),
				f = n("./src/reddit/selectors/subreddit.ts"),
				h = n("./src/reddit/selectors/userFlair.ts"),
				g = n("./src/lib/initializeClient/installReducer.ts"),
				v = n("./src/reddit/reducers/features/userFlair/index.ts"),
				x = n("./src/reddit/actions/userFlair/constants.ts");
			Object(g.a)({
				features: {
					userFlair: v.a
				}
			});
			const E = Object(r.a)(x.i),
				O = Object(r.a)(x.j),
				C = Object(r.a)(x.h),
				A = Object(r.a)(x.c),
				y = Object(r.a)(x.d),
				j = Object(r.a)(x.b),
				I = Object(r.a)(x.p),
				k = Object(r.a)(x.q),
				_ = Object(r.a)(x.o),
				S = Object(r.a)(x.f),
				w = Object(r.a)(x.g),
				T = Object(r.a)(x.e),
				P = Object(r.a)(x.m),
				N = Object(r.a)(x.n),
				D = Object(r.a)(x.l),
				M = Object(r.a)(x.k),
				R = Object(r.a)(x.s),
				L = Object(r.a)(x.a),
				B = (e, t, n, s, r) => async (o, i, a) => {
					let {
						apiContext: d
					} = a;
					const u = i(),
						m = u.user.account,
						p = m ? Object(b.e)(m) : void 0,
						g = {
							...Object(h.d)(u, {
								subredditId: r
							}).displaySettings,
							isUserEnabled: n
						},
						v = {
							userName: s,
							subredditId: r,
							applied: e,
							displaySettings: g
						};
					o(s === p ? R(v) : L(v));
					const x = Object(f.X)(u, {
							subredditId: r
						}),
						E = t && e ? Object(l.g)(e) : void 0;
					E && Object(c.h)(d(), s, x.name, t, E), s === p && Object(c.j)(d(), n, x.name)
				}, F = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s(),
						a = Object(f.X)(i, {
							subredditId: e
						}).name;
					n(E());
					const d = await Object(c.m)(o(), a, t);
					if (d.ok) {
						n(O({
							subredditId: e,
							isEnabled: t
						}))
					} else n(C());
					return d.ok
				}, U = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s(),
						a = Object(f.X)(i, {
							subredditId: e
						}).name;
					n(A());
					const d = await Object(c.k)(o(), t, m.d.UserFlair, a);
					if (d.ok) {
						n(y({
							subredditId: e,
							canAssignOwn: t
						}))
					} else n(j());
					return d.ok
				}, H = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = r(),
						l = Object(f.X)(a, {
							subredditId: t
						}).name;
					n(I());
					const u = await Object(c.g)(i(), e, l, m.d.UserFlair),
						b = u.ok && !(u.body && !1 === u.body.success);
					if (b) {
						const e = {
							subredditId: t,
							template: u.body
						};
						n(k(e));
						const r = Object(d.e)(s.fbt._("Flair saved!", null, {
							hk: "354KI0"
						}), p.b.SuccessMod);
						n(Object(d.f)(r))
					} else {
						n(_());
						const r = Object(d.e)(s.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "4tkRNl"
						}), p.b.Error, s.fbt._("Retry", null, {
							hk: "4zNHTm"
						}), H(e, t));
						n(Object(d.f)(r))
					}
					return b
				}, G = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = r(),
						l = Object(f.X)(a, {
							subredditId: t
						}).name;
					if (n(S()), (await Object(c.b)(i(), e, l)).ok) {
						n(w({
							subredditId: t,
							templateId: e
						}));
						const r = Object(d.e)(s.fbt._("Flair deleted!", null, {
							hk: "1mNdn0"
						}), p.b.SuccessMod);
						n(Object(d.f)(r))
					} else {
						n(T());
						const r = Object(d.e)(s.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "2QrdJr"
						}), p.b.Error, s.fbt._("Retry", null, {
							hk: "1buF3Y"
						}), G(e, t));
						n(Object(d.f)(r))
					}
				}, Q = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = r(),
						l = Object(f.X)(a, {
							subredditId: t
						}).name,
						u = Object(h.d)(a, {
							subredditId: t
						}).templateIds;
					if (n(P({
							subredditId: t,
							templateIds: e
						})), (await Object(c.f)(i(), l, m.d.UserFlair, e)).ok) {
						n(N());
						const e = Object(d.e)(s.fbt._("Flair reorder saved.", null, {
							hk: "1zrDON"
						}), p.b.SuccessMod);
						n(Object(d.f)(e))
					} else {
						n(D({
							subredditId: t,
							templateIds: u
						}));
						const r = Object(d.e)(s.fbt._("Sorry. Flair reorder wasn't saved.", null, {
							hk: "3gAbwk"
						}), p.b.Error, s.fbt._("Retry", null, {
							hk: "2nPnNw"
						}), Q(e, t));
						n(Object(d.f)(r))
					}
				}, q = (e, t) => async (n, r, o) => {
					let {
						apiContext: l
					} = o;
					var u;
					const m = r(),
						b = null === (u = m.features) || void 0 === u ? void 0 : u.userFlair;
					if (b && b[e] && b[e].displaySettings.isEnabled && i()(b[e].templateIds)) {
						const r = Object(f.X)(m, {
								subredditId: e
							}).name,
							o = await Object(c.d)(l(), r);
						if (o.ok) n(M(o.body)), n(Object(a.b)({
							username: t,
							subredditId: e
						}));
						else {
							const e = Object(d.e)(s.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							}), p.b.Error);
							n(Object(d.f)(e))
						}
					} else n(Object(a.b)({
						username: t,
						subredditId: e
					}))
				}, W = Object(r.a)(x.r), z = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					var a, d, l, m, p, b;
					const f = null === (a = s().features) || void 0 === a ? void 0 : a.userFlair;
					if (f && f[e] && f[e].displaySettings.isEnabled && i()(f[e].templateIds)) {
						const s = await Object(c.e)(o(), {
							name: t
						});
						if (s.ok) {
							const t = [],
								r = {};
							null === (b = null === (p = null === (m = null === (l = null === (d = null == s ? void 0 : s.body) || void 0 === d ? void 0 : d.data) || void 0 === l ? void 0 : l.subredditInfoByName) || void 0 === m ? void 0 : m.userFlairTemplates) || void 0 === p ? void 0 : p.edges) || void 0 === b || b.map(e => {
								const n = null == e ? void 0 : e.node;
								n && n.id && (t.push(n.id), r[n.id] = Object(u.b)(n))
							}), n(W({
								subredditId: e,
								templateIds: t,
								templates: r
							}))
						}
					}
				}
		},
		"./src/reddit/actions/widgets/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return s
			})), n.d(t, "i", (function() {
				return r
			})), n.d(t, "h", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			const s = "WIDGETS__WIDGET_CREATED",
				r = "WIDGETS__WIDGET_UPDATED",
				o = "WIDGET_DELETED",
				i = "WIDGETS_SORTED",
				a = "WIDGETS__STARTED_EDITING_WIDGET",
				d = "WIDGETS__LOADED",
				c = "SUBREDDIT__WIDGETS_PENDING",
				l = "SUBREDDIT__WIDGETS_LOADED",
				u = "SUBREDDIT__WIDGETS_FAILED"
		},
		"./src/reddit/actions/widgets/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return A
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "d", (function() {
				return k
			})), n.d(t, "h", (function() {
				return S
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "b", (function() {
				return T
			})), n.d(t, "f", (function() {
				return N
			})), n.d(t, "g", (function() {
				return L
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/apiRequestState.ts"),
				i = n("./src/reddit/actions/imageUploads.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts");
			const m = async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
				endpoint: `${e.apiUrl}/r/${t}/api/widgets`,
				method: d.ob.GET,
				type: "json",
				data: {
					progressive_images: n
				}
			});
			var p = n("./src/reddit/helpers/getGenericUploadError.ts"),
				b = n("./src/reddit/helpers/media/index.ts"),
				f = n("./src/lib/assertNever.ts"),
				h = n("./src/reddit/models/Widgets/index.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				v = n("./src/reddit/helpers/widgets/index.tsx"),
				x = n("./src/reddit/models/Image/index.tsx"),
				E = n("./src/reddit/models/Toast/index.ts"),
				O = n("./src/reddit/actions/widgets/constants.ts");
			const C = Object(r.a)(O.g),
				A = (e, t, n) => async (r, m, b) => {
					const {
						apiContext: f
					} = b;
					r(Object(o.h)(n));
					const h = m(),
						O = Object(g.X)(h, {
							subredditId: e
						}).name,
						A = Object(v.e)(t);
					let y = null,
						j = null;
					try {
						(y = await Object(i.f)(h, x.a.Widgets)) && (j = Object(i.m)(y)(r, m, b))
					} catch (k) {
						const e = Object(p.a)("webSocket");
						return void r(Object(o.f)(n, e))
					}
					const I = await (async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/widget`,
						method: d.ob.POST,
						type: "json",
						data: n
					}))(f(), O, A);
					if (I.ok) {
						let i = I.body;
						const d = i.id;
						if ("calendar" === t.kind && r(Object(a.f)({
								kind: E.b.SuccessMod,
								text: s.fbt._("New calendar added! It may take a few minutes to see your events appear", null, {
									hk: "4iETrT"
								})
							})), y) {
							try {
								await j
							} catch (k) {}
							i = await r(B(e, d)) || i
						}
						r(C({
							subredditId: e,
							widget: i,
							widgetId: d
						})), r(Object(o.e)(n))
					} else y && y.websocket.close(), r(Object(o.f)(n, I.error))
				}, y = Object(r.a)(O.i), j = (e, t, n) => async (r, m, b) => {
					const {
						apiContext: O
					} = b;
					r(Object(o.h)(n));
					const C = t.id,
						A = m(),
						j = Object(g.X)(A, {
							subredditId: e
						}).name,
						I = Object(v.e)(t);
					let k = null,
						_ = null;
					try {
						(k = await Object(i.f)(A, x.a.Widgets)) && (_ = Object(i.m)(k)(r, m, b))
					} catch (w) {
						const e = Object(p.a)("webSocket");
						return void r(Object(o.f)(n, e))
					}
					const S = await (async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/widget/${n.id}`,
						method: d.ob.PUT,
						type: "json",
						data: n
					}))(O(), j, I);
					if (S.ok) {
						let i = function(e, t, n) {
							switch (e.kind) {
								case h.i.Calendar:
								case h.i.IdCard:
								case h.i.SubredditRules:
									return {
										...e, ...t
									};
								case h.i.CommunityList: {
									const s = {};
									for (const t of e.data) s[t.name] = t;
									return {
										...t,
										data: t.data.map(e => {
											if (!("subscribers" in s[e])) {
												const t = {
														subredditName: e
													},
													s = Object(g.C)(n, t),
													r = Object(g.z)(n, t);
												return {
													name: s.name,
													subscribers: s ? s.subscribers : void 0,
													iconUrl: s ? s.communityIcon : void 0,
													isNSFW: s ? s.isNSFW : void 0,
													isSubscribed: r ? r.userIsSubscriber : void 0
												}
											}
											return s[e]
										})
									}
								}
								case h.i.Button:
								case h.i.Custom:
								case h.i.Image:
								case h.j.Menu:
								case h.i.Moderators:
								case h.i.Textarea:
								case h.i.PostFlair:
									return t;
								default:
									return Object(f.a)(e)
							}
						}(t, S.body, A);
						_ && (i = await r(B(e, C)) || i), r(y({
							subredditId: e,
							widgetId: C,
							widget: i
						})), "calendar" === t.kind && r(Object(a.f)({
							kind: E.b.SuccessMod,
							text: s.fbt._("Calendar is updated! It may take a few minutes to see your events change", null, {
								hk: "10XWV"
							})
						})), r(Object(o.e)(n))
					} else k && k.websocket.close(), r(Object(o.f)(n, S.error))
				}, I = Object(r.a)(O.h), k = (e, t, n) => async (s, r, i) => {
					let {
						apiContext: a
					} = i;
					s(Object(o.h)(n));
					const m = t.id,
						p = Object(g.X)(r(), {
							subredditId: e
						}).name,
						b = await (async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: `${e.apiUrl}/r/${t}/api/widget/${n.id}`,
							method: d.ob.DELETE,
							type: "json"
						}))(a(), p, t);
					b.ok ? (s(Object(o.e)(n)), s(I({
						subredditId: e,
						widgetId: m
					}))) : s(Object(o.f)(n, b.error))
				}, _ = Object(r.a)(O.f), S = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = Object(g.X)(s(), {
						subredditId: e
					}).name;
					(await (async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/widget_order/sidebar`,
						method: d.ob.PATCH,
						type: "json",
						data: n
					}))(o(), i, t)).ok && n(_({
						subredditId: e,
						widgetIds: t
					}))
				}, w = e => {
					let {
						imageData: t
					} = e;
					return async (e, n, s) => {
						const r = n(),
							o = r.structuredStyles.isEditing,
							a = Object(g.X)(r, {
								subredditId: o
							}).name;
						e(Object(i.k)(t));
						const m = await (async (e, t, n, s) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: `${e.apiUrl}/r/${t}/api/widget_image_upload_s3`,
							method: d.ob.POST,
							data: {
								filepath: n,
								mimetype: s
							}
						}))(s.apiContext(), a, t.file.name, await Object(b.h)(t.file));
						let p = !1;
						try {
							const s = await Object(i.g)(n(), m, t, x.a.Widgets);
							s && (e(Object(i.j)(s)), p = !0)
						} catch (f) {
							if (f instanceof Error) throw f;
							e(Object(i.i)(f))
						}
						return p
					}
				}, T = Object(r.a)(O.d), P = Object(r.a)(O.e), N = (e, t) => async (n, s, r) => {
					let {
						apiContext: i
					} = r;
					n(Object(o.h)(t));
					const a = Object(g.X)(s(), {
							subredditId: e
						}).name,
						d = await m(i(), a);
					if (d.ok) {
						const s = d.body;
						n(P({
							subredditId: e,
							widgets: s
						})), n(Object(o.e)(t))
					} else n(Object(o.f)(t, d.error))
				}, D = Object(r.a)(O.c), M = Object(r.a)(O.b), R = Object(r.a)(O.a), L = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					n(D({
						subredditId: e
					}));
					const i = Object(g.X)(s(), {
							subredditId: e
						}).name,
						a = await m(o(), i, t);
					if (a.ok) {
						const t = a.body;
						n(M({
							subredditId: e,
							widgets: t
						}))
					} else n(R({
						subredditId: e,
						error: a.error
					}))
				}, B = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = Object(g.X)(s(), {
							subredditId: e
						}).name,
						a = await m(o(), i, !0);
					if (a.ok) return a.body.items[t]
				}
		},
		"./src/reddit/actions/wiki/wikiBannedContributors/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			}));
			const s = "WIKI_BANNED_CONTRIBUTORS_PENDING",
				r = "WIKI_BANNED_CONTRIBUTORS_LOADED",
				o = "WIKI_BANNED_CONTRIBUTORS_FAILED",
				i = "MORE_WIKI_BANNED_CONTRIBUTORS_LOADED",
				a = "WIKI_BANNED_CONTRIBUTOR_ADDED",
				d = "WIKI_BANNED_CONTRIBUTOR_REMOVED",
				c = "WIKI_BANNED_CONTRIBUTOR_SEARCH_LOADED"
		},
		"./src/reddit/actions/wiki/wikiBannedContributors/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return x
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "a", (function() {
				return A
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "d", (function() {
				return k
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts"),
				u = n("./src/redditGQL/operations/SubredditWikiBannedContributors.json");
			const m = (e, t) => Object(d.a)(e, {
				...u,
				variables: t
			});
			var p = e => {
					const {
						bannedMembersInfo: t
					} = e, {
						edges: n,
						pageInfo: s
					} = t, r = [], o = {};
					return n.forEach(e => {
						const {
							date: t,
							redditor: n,
							editWikiBanInfo: s
						} = e.node;
						n.id && n.name && n.icon && (o[n.id] = {
							id: n.id,
							username: n.name,
							iconUrl: n.icon.url,
							date: t,
							daysRemaining: s.daysRemaining,
							note: s.note
						}, r.push(n.id))
					}), {
						afterToken: s.hasNextPage ? s.endCursor : null,
						bannedContributors: o,
						userOrder: r
					}
				},
				b = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/actions/wiki/wikiBannedContributors/constants.ts");
			const h = Object(o.a)(f.d),
				g = Object(o.a)(f.c),
				v = Object(o.a)(f.b),
				x = e => async (t, n, s) => {
					t(h({
						subredditName: e
					}));
					const o = {
							subredditName: e
						},
						i = await m(s.gqlContext(), o);
					if (i.ok) {
						const n = i.body,
							s = n.data.subreddit && n.data.subreddit.wiki;
						if (s) {
							const n = p(s);
							t(g({
								...n,
								subredditName: e.toLowerCase()
							}))
						}
					} else {
						const n = i.error || {
							type: r.K.UNKNOWN_ERROR
						};
						t(v({
							error: n,
							subredditName: e.toLowerCase()
						}))
					}
					return i.ok
				}, E = Object(o.a)(f.a), O = (e, t) => async (n, r, o) => {
					const a = {
							subredditName: e,
							after: t
						},
						d = await m(o.gqlContext(), a);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const s = p(t.data.subreddit.wiki);
							n(E({
								...s,
								subredditName: e.toLowerCase()
							}))
						}
					} else n(Object(i.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2EIEjY"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: O(e, t)
					}));
					return d.ok
				}, C = Object(o.a)(f.e), A = (e, t) => async (n, o, d) => {
					const u = await ((e, t, n) => Object(a.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/friend`,
						method: r.ob.POST,
						data: {
							api_type: "json",
							name: n.username,
							type: "wikibanned",
							duration: n.duration,
							ban_reason: n.banReason,
							note: n.note
						}
					}))(d.apiContext(), e, t);
					if (u.ok) {
						n(Object(i.f)({
							kind: b.b.SuccessMod,
							text: s.fbt._("Successfully banned user", null, {
								hk: "1VcdP9"
							})
						}));
						const r = {
								subredditName: e,
								username: t.username
							},
							o = (await m(d.gqlContext(), r)).body;
						if (o.data.subreddit.wiki) {
							const t = p(o.data.subreddit.wiki);
							n(C({
								bannedContributor: t.bannedContributors,
								subredditName: e.toLowerCase(),
								userOrder: t.userOrder
							}))
						}
					} else if (u.error) {
						let e;
						u.error.type === r.K.USER_DOESNT_EXIST && (e = s.fbt._("That user doesn't exist", null, {
							hk: "1AFgzG"
						})), n(Object(i.f)({
							kind: b.b.Error,
							text: e || s.fbt._("Something went wrong", null, {
								hk: "14O55Y"
							})
						}))
					}
					return u.ok
				}, y = Object(o.a)(f.f), j = (e, t) => async (n, o, d) => {
					const u = await ((e, t, n) => Object(a.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/unfriend`,
						method: r.ob.POST,
						data: {
							api_type: "json",
							id: n,
							type: "wikibanned"
						}
					}))(d.apiContext(), e, t);
					return u.ok ? (n(Object(i.f)({
						kind: b.b.SuccessMod,
						text: s.fbt._("User has been successfully removed", null, {
							hk: "381leB"
						})
					})), n(y({
						subredditName: e.toLowerCase(),
						userId: t
					}))) : n(Object(i.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "4lHXgg"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: j(e, t)
					})), u.ok
				}, I = Object(o.a)(f.g), k = (e, t) => async (n, r, o) => {
					const a = {
							subredditName: e,
							username: t
						},
						d = await m(o.gqlContext(), a);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const s = p(t.data.subreddit.wiki),
								r = Object.keys(s.bannedContributors)[0];
							n(I({
								subredditName: e.toLowerCase(),
								bannedContributor: s.bannedContributors[r]
							}))
						}
					} else n(Object(i.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2iRQ4u"
						})
					}));
					return d.ok
				}
		},
		"./src/reddit/actions/wiki/wikiContributors/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			}));
			const s = "WIKI_CONTRIBUTORS_PENDING",
				r = "WIKI_CONTRIBUTORS_LOADED",
				o = "WIKI_CONTRIBUTORS_FAILED",
				i = "MORE_WIKI_CONTRIBUTORS_LOADED",
				a = "WIKI_CONTRIBUTOR_ADDED",
				d = "WIKI_CONTRIBUTOR_REMOVED",
				c = "WIKI_CONTRIBUTOR_SEARCH_LOADED"
		},
		"./src/reddit/actions/wiki/wikiContributors/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return x
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "a", (function() {
				return A
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "d", (function() {
				return k
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts"),
				u = n("./src/redditGQL/operations/SubredditWikiContributors.json");
			const m = (e, t) => Object(d.a)(e, {
				...u,
				variables: t
			});
			var p = e => {
					const {
						contributorsInfo: t
					} = e, {
						edges: n,
						pageInfo: s
					} = t, r = [], o = {};
					return n.forEach(e => {
						const {
							date: t,
							redditor: n
						} = e.node;
						n.id && n.name && n.icon && (o[n.id] = {
							id: n.id,
							username: n.name,
							iconUrl: n.icon.url,
							date: t
						}, r.push(n.id))
					}), {
						afterToken: s.hasNextPage ? s.endCursor : null,
						contributors: o,
						userOrder: r
					}
				},
				b = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/actions/wiki/wikiContributors/constants.ts");
			const h = Object(o.a)(f.d),
				g = Object(o.a)(f.c),
				v = Object(o.a)(f.b),
				x = e => async (t, n, s) => {
					t(h({
						subredditName: e
					}));
					const o = {
							subredditName: e
						},
						i = await m(s.gqlContext(), o);
					if (i.ok) {
						const n = i.body,
							s = n.data.subreddit && n.data.subreddit.wiki;
						if (s) {
							const n = p(s);
							t(g({
								...n,
								subredditName: e.toLowerCase()
							}))
						}
					} else {
						const n = i.error || {
							type: r.K.UNKNOWN_ERROR
						};
						t(v({
							error: n,
							subredditName: e.toLowerCase()
						}))
					}
					return i.ok
				}, E = Object(o.a)(f.a), O = (e, t) => async (n, r, o) => {
					const a = {
							subredditName: e,
							after: t
						},
						d = await m(o.gqlContext(), a);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const s = p(t.data.subreddit.wiki);
							n(E({
								...s,
								subredditName: e.toLowerCase()
							}))
						}
					} else n(Object(i.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "P9mov"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: O(e, t)
					}));
					return d.ok
				}, C = Object(o.a)(f.e), A = (e, t) => async (n, o, d) => {
					const u = await ((e, t, n) => Object(a.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/friend`,
						method: r.ob.POST,
						data: {
							api_type: "json",
							name: n,
							type: "wikicontributor"
						}
					}))(d.apiContext(), e, t);
					if (u.ok) {
						n(Object(i.f)({
							kind: b.b.SuccessMod,
							text: s.fbt._("User has been successfully added", null, {
								hk: "3mt5Vr"
							})
						}));
						const r = {
								subredditName: e,
								username: t
							},
							a = (await m(d.gqlContext(), r)).body;
						if (a.data.subreddit.wiki) {
							const t = p(a.data.subreddit.wiki),
								s = Object.keys(t.contributors)[0];
							!!o().pages.subredditWiki.wikiContributors.listing.models[e.toLowerCase()][s] || n(C({
								contributor: t.contributors,
								subredditName: e.toLowerCase(),
								userOrder: t.userOrder
							}))
						}
					} else if (u.error) {
						let e;
						const t = u.error.type;
						t === r.K.USER_DOESNT_EXIST ? e = s.fbt._("That user doesn't exist", null, {
							hk: "1OHcCX"
						}) : t === r.K.BANNED_FROM_SUBREDDIT && (e = s.fbt._("That user is banned from the subreddit", null, {
							hk: "4eZcXp"
						})), n(Object(i.f)({
							kind: b.b.Error,
							text: e || s.fbt._("Something went wrong", null, {
								hk: "3VCQr6"
							})
						}))
					}
					return u.ok
				}, y = Object(o.a)(f.f), j = (e, t) => async (n, o, d) => {
					const u = await ((e, t, n) => Object(a.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/unfriend`,
						method: r.ob.POST,
						data: {
							api_type: "json",
							id: n,
							type: "wikicontributor"
						}
					}))(d.apiContext(), e, t);
					return u.ok ? (n(Object(i.f)({
						kind: b.b.SuccessMod,
						text: s.fbt._("User has been successfully removed", null, {
							hk: "2OevWA"
						})
					})), n(y({
						subredditName: e.toLowerCase(),
						userId: t
					}))) : n(Object(i.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "1zUdz2"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: j(e, t)
					})), u.ok
				}, I = Object(o.a)(f.g), k = (e, t) => async (n, r, o) => {
					const a = {
							subredditName: e,
							username: t
						},
						d = await m(o.gqlContext(), a);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const s = p(t.data.subreddit.wiki),
								r = Object.keys(s.contributors)[0];
							n(I({
								subredditName: e.toLowerCase(),
								contributor: s.contributors[r]
							}))
						}
					} else n(Object(i.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2s4L9n"
						})
					}));
					return d.ok
				}
		},
		"./src/reddit/actions/wiki/wikiEditing/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "WIKI_PAGE_SAVE_SUCCESS"
		},
		"./src/reddit/actions/wiki/wikiPageSettings/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			const s = "PAGE__SUBREDDIT_WIKI_PAGE_SETTINGS_LOADED",
				r = "SUBREDDIT_WIKI_PAGE_SETTINGS_UPDATED",
				o = "SUBREDDIT_WIKI_PAGE_CONTRIBUTOR_REOVED",
				i = "SUBREDDIT_WIKI_PAGE_MORE_CONTRIBUTORS_LOADED"
		},
		"./src/reddit/actions/wiki/wikiPageSettings/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return C
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "e", (function() {
				return I
			})), n.d(t, "a", (function() {
				return k
			})), n.d(t, "d", (function() {
				return S
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/subredditSettings.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/makeGqlRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				m = n("./src/reddit/models/SubredditWikiPage/index.ts"),
				p = n("./src/redditGQL/operations/SubredditWikiPageSettings.json");
			const b = (e, t) => Object(c.a)(e, {
					...p,
					variables: t
				}),
				f = {
					[m.a.Inherit]: "0",
					[m.a.Contributors]: "1",
					[m.a.Mods]: "2"
				};
			var h = e => {
					const {
						editPermissions: t,
						editorsInfo: n,
						isVisible: s
					} = e, {
						edges: r,
						pageInfo: o
					} = n, i = [];
					return r.forEach(e => {
						e.node.name && e.node.icon && i.push({
							username: e.node.name,
							iconUrl: e.node.icon.url
						})
					}), {
						editPermissions: t,
						editorsInfo: i,
						isVisible: s,
						afterToken: o.hasNextPage ? o.endCursor : null
					}
				},
				g = n("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				v = n("./src/reddit/models/Toast/index.ts"),
				x = n("./src/reddit/selectors/subreddit.ts"),
				E = n("./src/reddit/actions/wiki/wikiPageSettings/constants.ts");
			const O = Object(o.a)(E.c),
				C = (e, t) => async (n, s, r) => {
					const o = {
							subredditName: e,
							wikiPageName: t
						},
						a = await b(r.gqlContext(), o),
						d = Object(x.I)(s(), e);
					if (Object(x.Z)(s(), d) || await n(Object(i.h)(e, d)), a.ok) {
						const e = a.body,
							t = e.data.subreddit && e.data.subreddit.wiki;
						if (t && t.page) {
							const e = h(t.page.settings);
							n(O({
								pageKey: Object(g.a)(o),
								settings: e
							}))
						}
					}
					return a.ok
				}, A = Object(o.a)(E.b), y = (e, t, n) => async (r, o, i) => {
					const d = {
							subredditName: e,
							wikiPageName: t,
							after: n
						},
						c = await b(i.gqlContext(), d);
					if (c.ok) {
						const n = c.body,
							s = n.data.subreddit && n.data.subreddit.wiki;
						if (s && s.page) {
							const n = h(s.page.settings),
								{
									editorsInfo: o,
									afterToken: i
								} = n;
							r(A({
								editorsInfo: o,
								afterToken: i,
								pageKey: Object(g.a)({
									wikiPageName: t,
									subredditName: e
								})
							}))
						}
					} else r(Object(a.f)({
						kind: v.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "P9mov"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: y(e, t, n)
					}));
					return c.ok
				}, j = Object(o.a)(E.d), I = e => {
					let {
						editPermissions: t,
						isVisible: n,
						wikiPageName: s,
						subredditName: o
					} = e;
					return async (e, i, a) => {
						const c = await (e => Object(d.a)(Object(l.a)(e.context, [u.a]), {
							endpoint: `${e.context.apiUrl}/r/${e.subredditName}/wiki/settings/${e.wikiPageName}`,
							method: r.ob.POST,
							data: {
								permlevel: f[e.editPermissions],
								listed: e.isVisible ? "on" : void 0
							}
						}))({
							context: a.apiContext(),
							editPermissions: t,
							isVisible: n,
							wikiPageName: s,
							subredditName: o
						});
						return c.ok && e(j({
							editPermissions: t,
							isVisible: n,
							pageKey: Object(g.a)({
								wikiPageName: s,
								subredditName: o
							})
						})), c.ok
					}
				}, k = e => {
					let {
						subredditName: t,
						username: n,
						wikiPageName: o
					} = e;
					return async (e, i, c) => {
						const m = await (e => Object(d.a)(Object(l.a)(e.context, [u.a]), {
							endpoint: `${e.context.apiUrl}/r/${e.subredditName}/api/wiki/alloweditor/add`,
							method: r.ob.POST,
							data: {
								page: e.wikiPageName,
								username: e.username
							}
						}))({
							context: c.apiContext(),
							wikiPageName: o,
							subredditName: t,
							username: n
						});
						if (m.ok) e(Object(a.f)({
							kind: v.b.SuccessCommunity,
							text: "User successfully added"
						})), await e(C(t, o));
						else if (m.error) {
							const t = m.error.type;
							let n = s.fbt._("Something went wrong", null, {
								hk: "8AkV3"
							});
							t === r.K.NOT_FOUND_ERROR && (n = s.fbt._("That user does not exist", null, {
								hk: "XDM7X"
							})), e(Object(a.f)({
								kind: v.b.Error,
								text: n
							}))
						}
						return m.ok
					}
				}, _ = Object(o.a)(E.a), S = e => {
					let {
						subredditName: t,
						username: n,
						wikiPageName: s
					} = e;
					return async (e, o, i) => {
						const c = await (e => Object(d.a)(Object(l.a)(e.context, [u.a]), {
							endpoint: `${e.context.apiUrl}/r/${e.subredditName}/api/wiki/alloweditor/del`,
							method: r.ob.POST,
							data: {
								page: e.wikiPageName,
								username: e.username
							}
						}))({
							context: i.apiContext(),
							wikiPageName: s,
							subredditName: t,
							username: n
						});
						return c.ok && (e(Object(a.f)({
							kind: v.b.SuccessCommunity,
							text: "User has been successfully removed"
						})), e(_({
							username: n,
							pageKey: Object(g.a)({
								wikiPageName: s,
								subredditName: t
							})
						}))), c.ok
					}
				}
		},
		"./src/reddit/actions/wiki/wikiRevisions/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			}));
			const s = "WIKI_REVISIONS_PENDING",
				r = "WIKI_REVISIONS_LOADED",
				o = "WIKI_REVISIONS_FAILED",
				i = "WIKI_PAGE_REVERT_SUCCESS",
				a = "WIKI_REVISION_TOGGLE_VISIBILITY"
		},
		"./src/reddit/actions/wiki/wikiRevisions/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return j
			})), n.d(t, "a", (function() {
				return k
			})), n.d(t, "b", (function() {
				return S
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/endpoints/page/subredditWiki.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/WikiRevisions.json");
			var l = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/omitHeaders/index.ts"),
				m = n("./src/reddit/constants/headers.ts"),
				p = n("./src/reddit/helpers/wiki/wikiRevision.ts");
			var b = (e, t) => Object(l.a)(Object(u.a)(e, [m.a]), {
				endpoint: `${e.apiUrl}/r/${t.subredditName}/api/wiki/hide`,
				method: r.ob.POST,
				data: {
					page: t.wikiPageName,
					revision: Object(p.b)(t.revisionId)
				}
			});
			var f = (e, t) => Object(l.a)(Object(u.a)(e, [m.a]), {
				endpoint: `${e.apiUrl}/r/${t.subredditName}/api/wiki/revert`,
				method: r.ob.POST,
				data: {
					page: t.wikiPageName,
					revision: Object(p.b)(t.revisionId)
				}
			});
			var h = e => {
					const t = e.subreddit && e.subreddit.wiki || {},
						n = t.pageRevisions && t.pageRevisions.revisions || t.recentRevisions;
					if (!n) throw new Error("Invalid response");
					return (e => {
						const t = {},
							n = [];
						return e.edges.forEach(e => {
							const s = e.node;
							t[s.id] = s, n.push(s.id)
						}), {
							pageInfo: e.pageInfo,
							revisions: t,
							revisionsIds: n
						}
					})(n)
				},
				g = n("./src/reddit/helpers/wiki/makeRevisionsListingKey.ts"),
				v = n("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				x = n("./src/reddit/models/Toast/index.ts"),
				E = n("./src/reddit/selectors/subredditWiki.ts"),
				O = n("./src/reddit/actions/wiki/wikiRevisions/constants.ts");
			const C = Object(o.a)(O.d),
				A = Object(o.a)(O.c),
				y = Object(o.a)(O.b),
				j = e => async (t, n, o) => {
					const {
						canLoadMore: a = !1,
						canShowFailToast: l = !1,
						isRecent: u,
						subredditName: m,
						wikiPageName: p
					} = e, b = n(), f = Object(g.a)(e), v = Object(E.p)(b, {
						listingKey: f
					});
					if (!a && !!v) return !0;
					const O = v && v.pageInfo.endCursor || void 0;
					if (!(!v || v.pageInfo.hasNextPage)) return !0;
					const I = {
							after: O,
							isRecent: u,
							subredditName: m,
							wikiPageName: p
						},
						k = {
							key: f,
							options: I
						};
					t(C(k));
					const _ = await ((e, t) => Object(d.a)(e, {
						...c,
						variables: t
					}))(o.gqlContext(), I);
					if (_.ok) {
						const e = _.body;
						if (e.data.subreddit) {
							const n = h(e.data);
							t(A({
								...k,
								...n
							}))
						}
					} else {
						const n = _.error || {
							type: r.K.UNKNOWN_ERROR
						};
						t(y({
							...k,
							error: n
						})), l && t(Object(i.f)({
							kind: x.b.Error,
							text: s.fbt._("Something went wrong", null, {
								hk: "1e4Swa"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: j(e)
						}))
					}
					return _.ok
				}, I = Object(o.a)(O.a), k = e => async (t, n, r) => {
					const {
						subredditName: o,
						wikiPageName: d
					} = e, c = Object(v.a)({
						...e,
						revisionId: void 0
					}), l = Object(g.a)({
						...e,
						isRecent: !1
					}), u = Object(g.a)({
						...e,
						isRecent: !0
					}), m = Object(E.p)(n(), {
						listingKey: l
					}), p = m && m.ids[0];
					if ((await f(r.apiContext(), e)).ok) {
						const e = (await Object(a.a)(r.gqlContext(), {
								includePageData: !0,
								subredditName: o,
								wikiPageName: d
							})).body,
							n = e.data.subreddit && e.data.subreddit.wiki,
							m = n && n.page;
						if (!m || !m.revision) return;
						if (m.revision.id === p) return void t(Object(i.f)({
							kind: x.b.SuccessCommunityGreen,
							text: s.fbt._("Wiki page is already at selected revision!", null, {
								hk: "46i9jx"
							})
						}));
						t(I({
							page: m,
							pageKey: c,
							pageRevisionsListingKey: l,
							recentRevisionsListingKey: u,
							subredditName: o,
							wikiPageName: d
						}))
					} else t(Object(i.f)({
						kind: x.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2L5ytY"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: k(e)
					}))
				}, _ = Object(o.a)(O.e), S = e => async (t, n, r) => {
					const o = await b(r.apiContext(), e);
					if (o.ok) {
						const n = o.body.status;
						t(_({
							revisionId: e.revisionId,
							isHidden: n
						}))
					} else t(Object(i.f)({
						kind: x.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2gGq8w"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: k(e)
					}))
				}
		},
		"./src/reddit/components/AdLinkWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				AdLinkWrapper: "LniF5nGHFXZ6i7_mQiEaT",
				adLinkWrapper: "LniF5nGHFXZ6i7_mQiEaT",
				ctaExperiment: "_3JgLF82C_0NM3uN8pOyJTu",
				borders: "_3LUqJuEsn44ivYFDMegLQG",
				borderTop: "_2n1stnecLcYB2e1RjBwSq_",
				borderBottom: "_2EVJbBkxJortsXpkuVWaPA"
			}
		},
		"./src/reddit/components/AdLinkWrapper/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				a = n("./src/reddit/components/AdLinkWrapper/index.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = function(e) {
				const {
					className: t,
					ctaExperimentDesign: n,
					children: s,
					...a
				} = e, l = Object(o.a)(d.a.adLinkWrapper, t, {
					[d.a.ctaExperiment]: !!n,
					[d.a.borders]: "classic" === n,
					[d.a.borderTop]: "compact" === n || "conversation" === n,
					[d.a.borderBottom]: "card" === n
				});
				return r.a.createElement("div", c({
					className: l,
					"data-adclicklocation": i.a.CTA_WHITESPACE
				}, a), s)
			}
		},
		"./src/reddit/components/AdLinkWrapperContent/index.m.less": function(e, t, n) {
			e.exports = {
				displayUrl: "Nd1oMnpI7mh5Ewfm9VQxq",
				ctaExperimentLink: "a3FqJA6bjuoLKqPBEp52R",
				leftSideContent: "_1oCxYg3Tu1IIcDUUOu9gIA",
				ctaExperimentNoPadding: "_2pWpf_lwFeF9qkMKAgnF1j",
				ctaExperimentPadded: "_3xECPPLU5gHGEwtMV_um7R",
				productTitle: "_3IN2NbpghDp3ddkK_5fJX8",
				subcaption: "_20wkPJgadrJIAZtTeFXQXU",
				caption: "_2LmxORnqxzKG1lDeTP_w6R"
			}
		},
		"./src/reddit/components/AdLinkWrapperContent/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/CallToActionButton/index.tsx"),
				d = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				c = n("./src/reddit/models/Post/index.ts"),
				l = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				u = n("./src/reddit/components/AdLinkWrapperContent/index.m.less"),
				m = n.n(u);
			t.a = e => {
				const {
					adLinkContent: t,
					post: n,
					isCompact: r
				} = e, {
					source: u,
					callToAction: p,
					caption: b
				} = t;
				if (!u || !u.url) return null;
				let f = u.displayText;
				u.displayText.length >= 40 && (f = u.displayText.slice(0, 40 - "...".length) + "...");
				const h = Object(c.t)(n, u.displayText),
					g = Object(c.u)(n) ? f : b,
					v = Object(c.u)(n) ? n.subcaption : u.displayText,
					x = Object(i.a)(m.a.leftSideContent, {
						[m.a.ctaExperimentNoPadding]: e.ctaExperimentDesign && "card" !== e.ctaExperimentDesign,
						[m.a.ctaExperimentPadded]: "card" === e.ctaExperimentDesign
					}),
					E = Object(i.a)(m.a.displayUrl, {
						[m.a.ctaExperimentLink]: !!e.ctaExperimentDesign
					});
				return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
					className: x
				}, b && !r && !h && o.a.createElement("span", {
					className: m.a.caption,
					title: b,
					"data-adclicklocation": l.a.CTA_CAPTION
				}, b), !h && o.a.createElement(d.a, {
					href: u.url.replace(s.a.redditUrl, ""),
					isSponsored: n.isSponsored,
					postId: n.id,
					source: u,
					className: E,
					"data-adclicklocation": l.a.CTA_URL
				}, f), h && o.a.createElement(o.a.Fragment, null, o.a.createElement("span", {
					className: m.a.productTitle
				}, g), o.a.createElement("span", {
					className: m.a.subcaption
				}, v))), p && o.a.createElement(a.a, {
					className: m.a.callToAction,
					href: u.url,
					isSponsored: n.isSponsored,
					postId: n.id,
					source: u,
					showCTAExperiment: !!e.ctaExperimentDesign,
					"data-adclicklocation": l.a.CTA_BUTTON
				}, p))
			}
		},
		"./src/reddit/components/AdViewability/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/isEqual.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./node_modules/@researchgate/react-intersection-observer/lib/es/index.js"),
				c = n("./src/lib/ads/index.ts"),
				l = n("./src/lib/ads/store.ts"),
				u = n("./src/lib/onFocusAndVisibilityChange/index.ts"),
				m = n("./src/reddit/connectors/PostViewable/index.ts"),
				p = n("./src/reddit/constants/adEvents.ts"),
				b = n("./src/reddit/models/Media/index.ts"),
				f = n("./src/reddit/selectors/media.ts"),
				h = n("./src/reddit/selectors/video.ts");
			const g = [{
					event: p.a.ViewableImpression,
					threshold: c.l,
					viewabilityMinimum: c.m
				}, {
					event: p.a.Impression,
					threshold: c.c,
					viewabilityMinimum: c.d
				}, {
					event: p.a.GalleryItemImpression,
					threshold: c.c,
					viewabilityMinimum: c.d
				}, {
					event: p.a.VendorFullyInView,
					threshold: c.b,
					viewabilityMinimum: c.f
				}, {
					event: p.a.GroupMViewable,
					threshold: c.b,
					viewabilityMinimum: c.m
				}, {
					event: p.a.VendorFullyInViewSeconds5,
					threshold: c.l,
					viewabilityMinimum: c.h,
					remainingTime: c.h,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0
				}, {
					event: p.a.VendorFullyInViewSeconds15,
					threshold: c.l,
					viewabilityMinimum: c.g,
					remainingTime: c.g,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0
				}],
				v = [{
					event: p.a.VideoViewableImpression,
					threshold: c.l,
					viewabilityMinimum: c.k,
					remainingTime: c.k,
					timeViewingInterrupted: 0
				}, {
					event: p.a.VideoFullyViewableImpression,
					threshold: c.a,
					viewabilityMinimum: c.i,
					remainingTime: c.i,
					timeViewingInterrupted: 0
				}, {
					event: p.a.VideoGroupMViewable,
					threshold: void 0,
					viewabilityMinimum: c.k,
					remainingTime: void 0,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0,
					checkAudible: !0
				}, {
					event: p.a.VideoVendorFullyViewable50,
					threshold: c.a,
					viewabilityMinimum: void 0,
					remainingTime: void 0,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0
				}],
				x = e => e.map(e => {
					let {
						event: t,
						cumulative: n = !1,
						cumulativeElapsedTime: s,
						remainingTime: r,
						threshold: o = null,
						viewabilityMinimum: i,
						checkAudible: a = !1,
						timeViewingInterrupted: d
					} = e;
					return {
						event: t,
						cumulative: n,
						checkAudible: a,
						timer: null,
						fired: !1,
						threshold: o,
						remainingTime: r,
						cumulativeElapsedTime: 0,
						viewabilityMinimum: i,
						timeViewingInitialized: 0,
						timeViewingInterrupted: d
					}
				}),
				E = () => x(g),
				O = () => x(v),
				C = [c.c, c.e, c.l, c.j, c.a, c.b],
				A = [c.c, c.l, c.j, c.a],
				y = [c.c, c.e, c.l, c.b],
				j = e => "boolean" == typeof e.cumulative && e.cumulative,
				I = Object(a.c)({
					continuousViewingStartedAt: (e, t) => {
						let {
							post: n
						} = t;
						return Object(h.b)(e, {
							postId: n.id
						})
					},
					videoDuration: (e, t) => {
						let {
							post: n
						} = t;
						const s = Object(h.h)(e, {
							postId: n.id
						});
						if (s) return s.length
					},
					isAudible: e => Object(f.a)(e),
					isPlaying: (e, t) => {
						let {
							post: n
						} = t;
						return Object(h.d)(e, {
							postId: n.id
						})
					},
					isFullScreen: (e, t) => {
						let {
							post: n
						} = t;
						return Object(h.e)(e, {
							postId: n.id
						})
					}
				}),
				k = Object(m.a)(I);
			class _ extends o.Component {
				constructor(e) {
					super(e), this.viewabilityStats = E(), this.videoStats = O(), this.pageInFocus = !0, this.inViewStats = [], this.outOfViewStats = [], this.handleViewabilityChange = e => {
						this.props.trackDisplay && this.handleThresholds(e, c.r), this.props.trackVideo && this.handleThresholds(e, c.p, !0), this.checkViewabilityByType(e)
					}, this.checkViewabilityByType = e => {
						if (r()(this.state.event, e) || this.setState({
								event: e
							}), this.props.trackDisplay) {
							const t = this.props.post.media && Object(b.G)(this.props.post.media);
							this.viewabilityStats.forEach(n => {
								(n.event !== p.a.GalleryItemImpression || t) && this.checkViewability(e, n)
							})
						}
						this.props.isPlaying && this.props.trackVideo && this.videoStats.forEach(t => {
							t.checkAudible && !this.props.isAudible || this.checkViewability(e, t)
						})
					}, this.state = {
						event: null,
						currentContinuousViewingStartedAt: e.continuousViewingStartedAt
					}
				}
				componentDidMount() {
					this.visibilityChangeSubscriptionId = u.a.subscribe(e => {
						this.pageInFocus = e.documentInFocus, this.state.event && this.handleViewabilityChange(this.state.event)
					})
				}
				componentWillUnmount() {
					const {
						post: e,
						trackDisplay: t,
						trackVideo: n
					} = this.props;
					this.visibilityChangeSubscriptionId && u.a.unsubscribe(this.visibilityChangeSubscriptionId), t && (l.d(e.id, c.r, !1), this.viewabilityStats.forEach(e => {
						j(e) && e.cumulative && this.pauseCumulativeStats(e), this.clearTimer(e)
					})), n && (l.d(e.id, c.p, !0), this.videoStats.forEach(e => {
						j(e) && e.cumulative && this.pauseCumulativeStats(e), this.clearTimer(e)
					})), this.outOfViewStats = [], this.inViewStats = []
				}
				componentDidUpdate() {
					this.props.trackVideo && (this.state.currentContinuousViewingStartedAt === this.props.continuousViewingStartedAt ? (this.handleThresholds(this.state.event, c.p, !0), this.videoStats.forEach(e => {
						!this.props.isPlaying || e.checkAudible && !this.props.isAudible ? e.cumulative ? this.pauseCumulativeStats(e) : this.pauseViewableStats(e) : this.checkViewability(this.state.event, e)
					})) : this.resetTimers())
				}
				resetTimers() {
					this.videoStats.forEach(e => {
						e.cumulative || this.resetTimer(e)
					}), this.setState({
						currentContinuousViewingStartedAt: this.props.continuousViewingStartedAt
					})
				}
				resetTimer(e) {
					this.clearTimer(e), e.timeViewingInitialized = 0, void 0 !== e.viewabilityMinimum && (e.remainingTime = e.viewabilityMinimum)
				}
				pauseViewableStats(e) {
					let t;
					if (!e.timer || e.fired) return;
					e.timeViewingInterrupted = Date.now();
					const n = e.timeViewingInterrupted - e.timeViewingInitialized;
					t = (e.viewabilityMinimum || 0) - n, e.remainingTime = t > 0 ? t : 0, this.clearTimer(e)
				}
				pauseCumulativeStats(e) {
					let t;
					e.timer && !e.fired && (e.timeViewingInterrupted = Date.now(), e.cumulativeElapsedTime += e.timeViewingInterrupted - e.timeViewingInitialized, t = (e.viewabilityMinimum || 0) - e.cumulativeElapsedTime, e.remainingTime = t > 0 ? t : 0, this.clearTimer(e))
				}
				meetsViewabilityRequirements(e, t) {
					let n, s = !1,
						r = !1;
					return "object" == typeof t ? (n = t.threshold, s = !!t.playing, r = !!t.withSound) : n = t, this.isAdequatelyInView(e, n) && (!s || this.props.isPlaying) && (!r || this.props.isAudible)
				}
				handleThresholds(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					const {
						post: s
					} = this.props, o = t.filter(t => this.meetsViewabilityRequirements(e, t));
					!r()(o, this.inViewStats) && o.length > 0 && l.b(s.id, o, n);
					const i = t.filter(t => !this.meetsViewabilityRequirements(e, t));
					!r()(i, this.outOfViewStats) && i.length > 0 && l.d(s.id, i, n), this.outOfViewStats = i, this.inViewStats = o
				}
				isAdequatelyInView(e, t) {
					return !!this.props.isFullScreen || !!e && e.intersectionRatio >= t && this.pageInFocus
				}
				addDurationBasedViewabilityMinimum(e) {
					this.props.videoDuration ? e.viewabilityMinimum = Math.min(.5 * this.props.videoDuration, c.g) : e.viewabilityMinimum = c.g, e.remainingTime = e.viewabilityMinimum
				}
				adjustThreshold(e, t) {
					const {
						height: n,
						width: s
					} = e.boundingClientRect;
					return !t.threshold && t.event === p.a.VideoGroupMViewable && this.props.videoDuration && (t.threshold = s * n < 3e5 ? c.a : c.j, t.viewabilityMinimum = .5 * this.props.videoDuration), t.event === p.a.GroupMViewable && s * n > 242500 && (t.threshold = c.l), t
				}
				checkViewability(e, t) {
					if (j(t) && t.event === p.a.VideoVendorFullyViewable50 && this.addDurationBasedViewabilityMinimum(t), e && e.target && this.adjustThreshold(e, t), t.threshold && void 0 !== t.viewabilityMinimum) {
						if (this.isAdequatelyInView(e, t.threshold) && !t.fired) {
							if (t.timer) return;
							const e = this.getLengthForTimer(t);
							return e > 0 ? this.initTimer(t, e) : this.fireStat(t), void(t.timeViewingInitialized = Date.now())
						}
						j(t) && t.cumulative && this.pauseCumulativeStats(t), this.clearTimer(t)
					}
				}
				clearTimer(e) {
					e.timer && (clearTimeout(e.timer), e.timer = null)
				}
				getLengthForTimer(e) {
					return void 0 !== e.remainingTime ? e.remainingTime : e.viewabilityMinimum || 0
				}
				fireStat(e) {
					setTimeout(() => this.props.onPostViewable(this.props.post, e.event), 0), e.fired = !0
				}
				initTimer(e, t) {
					this.clearTimer(e), e.timer = window.setTimeout(() => {
						this.fireStat(e)
					}, t)
				}
				render() {
					const {
						trackDisplay: e,
						trackVideo: t
					} = this.props;
					let n = C;
					return e && !t ? n = y : !e && t && (n = A), i.a.createElement(d.a, {
						threshold: n,
						onChange: this.handleViewabilityChange
					}, this.props.children)
				}
			}
			t.a = k(_)
		},
		"./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "_2MgVqpGJKTGicaQowt_R9h",
				primaryButton: "_2MgVqpGJKTGicaQowt_R9h"
			}
		},
		"./src/reddit/components/ApprovedSubmitterList/index.m.less": function(e, t, n) {
			e.exports = {
				PencilIcon: "_1XoRj9AWrCZUnxJt2JB2QS",
				pencilIcon: "_1XoRj9AWrCZUnxJt2JB2QS",
				noPermissions: "_2LSmyOf3zXlFqKumLW0h7B",
				border: "_3EzgpCtyHn3Q2a2kldjKHP",
				newModNavContainer: "_1VMTQTSdHAeVqezcv6m9CK",
				topBar: "_3uFGVPOU08VfSKbd48Ov71",
				fixed: "_2BHWpylNdmYnlV-8ztS_0t",
				default: "_1m85OR47Hy-NodAYvISu8b"
			}
		},
		"./src/reddit/components/ApprovedSubmitterList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/subredditModeration/approvedSubmitters.ts"),
				p = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				b = n("./src/reddit/components/HumanDate/index.tsx"),
				f = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				h = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				g = n("./src/reddit/components/ModHub/NewModNav/PageLinks.tsx"),
				v = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				x = n("./src/reddit/components/Scroller/Simple.tsx"),
				E = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				O = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				C = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				A = n("./src/reddit/controls/Button/index.tsx"),
				y = n("./src/reddit/icons/fonts/index.tsx"),
				j = n("./src/reddit/models/SubredditModeration/index.ts"),
				I = n("./src/reddit/selectors/activeModalId.ts"),
				k = n("./src/lib/objectSelector/index.ts"),
				_ = n("./src/reddit/components/InboxTooltip/Component.tsx");
			const S = Object(k.a)((e, t) => {
				let {
					subredditId: n
				} = t;
				const s = e.pages.modHub.approvedSubmitters.userOrder[n];
				return s ? s.map(t => e.pages.modHub.approvedSubmitters.models[n][t]) : _.a
			});
			var w = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				T = n("./src/reddit/selectors/user.ts"),
				P = n("./src/reddit/contexts/PageLayer/index.tsx"),
				N = n("./src/higherOrderComponents/asModal/index.tsx"),
				D = n("./src/lib/lessComponent.tsx"),
				M = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				R = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				L = n("./src/reddit/controls/TextButton/index.tsx"),
				B = n("./src/reddit/helpers/isValidUsername/index.tsx"),
				F = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				U = n("./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.m.less"),
				H = n.n(U);
			const G = D.a.wrapped(A.l, "PrimaryButton", H.a);
			class Q extends i.a.Component {
				constructor(e) {
					super(e), this.onInputChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.onSubmit = () => {
						const {
							props: e,
							state: t
						} = this;
						e.onAddSubmitter(e.subredditId, t.username), e.sendEventWithName("add")(), e.toggleModal()
					}, this.state = {
						username: ""
					}
				}
				componentDidMount() {
					this.setState({
						username: this.props.username || ""
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return i.a.createElement(M.e, null, i.a.createElement(M.i, null, i.a.createElement(F.a, null, i.a.createElement(M.q, null, r.fbt._("Add approved user", null, {
						hk: "rVlIL"
					})), i.a.createElement(L.a, {
						onClick: e.toggleModal
					}, i.a.createElement(M.b, null)))), i.a.createElement(M.l, null, i.a.createElement(R.d, {
						placeholder: r.fbt._("Enter username", null, {
							hk: "4DdFFr"
						}),
						onChange: this.onInputChange,
						value: this.state.username,
						autoFocus: !0
					})), i.a.createElement(M.g, null, i.a.createElement(M.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), i.a.createElement(G, {
						onClick: this.onSubmit,
						"data-redditstyle": !0,
						disabled: !Object(B.a)(t.username)
					}, r.fbt._("Add user", null, {
						hk: "23A7cj"
					}))))
				}
			}
			var q = Object(N.a)(Q),
				W = n("./src/reddit/components/ApprovedSubmitterList/index.m.less"),
				z = n.n(W);
			const V = 24,
				K = Object(P.v)({
					username: e => Object(P.Z)(e).user
				}),
				Y = Object(d.c)({
					approvedSubmitters: S,
					approvedSubmittersListPending: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = Object(j.e)(n);
						return !!e.pages.modHub.approvedSubmitters.api.pending[s]
					},
					isAddUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(I.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--RemoveUserConfirmation" === Object(I.a)(e),
					loadMoreToken: (e, t) => {
						let {
							subredditId: n
						} = t;
						return e.pages.modHub.approvedSubmitters.loadMore[n]
					},
					searchPending: e => !!e.pages.modHub.approvedSubmitters.search.api.pending,
					searchResult: e => e.pages.modHub.approvedSubmitters.search.result,
					currentUser: T.m,
					isInShredditModNavExperiment: (e, t) => {
						let {
							moderatorPermissions: n
						} = t;
						return Object(w.a)(e, !!n)
					}
				}),
				J = Object(a.b)(Y, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						addSubmitter: (t, n) => e(Object(m.a)(t, n)),
						loadMore: t => e(Object(m.b)(n, {
							after: t
						})),
						removeSubmitter: (t, n) => e(Object(m.d)(t, n)),
						searchForSubmitter: (t, n) => e(Object(m.c)(t, n)),
						toggleRemoveUserModal: () => e(Object(u.i)("ModerationPage--Modal--RemoveUserConfirmation")),
						toggleAddUserModal: () => e(Object(u.i)("ModerationPage--Modal--AddUser"))
					}
				});
			class X extends i.a.Component {
				constructor(e) {
					super(e), this.isSticky = () => {
						const e = window.scrollY >= 100;
						this.setState({
							isFixed: e
						})
					}, this.handleRemoveToggled = (e, t) => {
						this.setState({
							userId: e,
							username: t
						}), this.props.toggleRemoveUserModal()
					}, this.handleRemoveConfirmed = () => {
						this.state.userId && this.props.removeSubmitter(this.props.subredditId, this.state.userId)
					}, this.onSearch = e => {
						this.props.searchForSubmitter(this.props.subredditId, e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.approveSubmitter = () => {
						this.props.sendEventWithName("open_add_dialog")(), this.props.toggleAddUserModal()
					}, this.renderUser = e => {
						var t, n;
						return i.a.createElement(C.b, {
							timeAgo: i.a.createElement(b.d, {
								seconds: e.approvedAtUTC
							}),
							pageName: l.mc.Contributors,
							primaryButton: (null === (t = this.props.currentUser) || void 0 === t ? void 0 : t.id) !== e.id ? i.a.createElement("a", {
								href: `${s.a.redditUrl}/message/compose/?to=${e.username}`,
								rel: "noopener noreferrer",
								target: "_blank"
							}, i.a.createElement(A.r, null, r.fbt._("Send message", null, {
								hk: "2bul7M"
							}))) : null,
							secondaryButton: (null === (n = this.props.moderatorPermissions) || void 0 === n ? void 0 : n.access) ? i.a.createElement(A.r, {
								onClick: () => this.handleRemoveToggled(e.id, e.username)
							}, r.fbt._("Remove", null, {
								hk: "3tYl0U"
							})) : null,
							subredditId: this.props.subredditId,
							userIcon: e.accountIcon,
							username: e.username
						})
					}, this.renderAddUserModal = () => i.a.createElement(q, {
						ignoreDefaultFocus: !0,
						onAddSubmitter: this.props.addSubmitter,
						sendEventWithName: this.props.sendEventWithName,
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddUserModal,
						username: this.props.username,
						withOverlay: !0
					}), this.renderTopBar = e => i.a.createElement(v.c, {
						className: Object(c.a)(e && "bg-neutral-background mb-xs pr-0", z.a.topBar, {
							[z.a.default]: !e,
							[z.a.fixed]: this.state.isFixed
						})
					}, i.a.createElement(A.l, {
						onClick: this.approveSubmitter
					}, r.fbt._("Approve user", null, {
						hk: "1qX1LT"
					}))), this.state = {
						...j.a,
						isFixed: !this.props.isInShredditModNavExperiment
					}
				}
				componentDidMount() {
					this.props.username && this.approveSubmitter(), this.props.isInShredditModNavExperiment && window.addEventListener("scroll", this.isSticky)
				}
				componentWillUnmount() {
					this.props.isInShredditModNavExperiment && window.removeEventListener("scroll", this.isSticky)
				}
				render() {
					var e;
					const {
						props: t,
						state: n
					} = this, o = t.approvedSubmitters.length ? t.approvedSubmitters[t.approvedSubmitters.length - 1].id : void 0, a = null === (e = t.moderatorPermissions) || void 0 === e ? void 0 : e.access;
					return t.approvedSubmitters.length ? i.a.createElement(i.a.Fragment, null, a && !t.isInShredditModNavExperiment && this.renderTopBar(), i.a.createElement(v.a, {
						className: Object(c.a)(t.isInShredditModNavExperiment && z.a.newModNavContainer, !a && z.a.noPermissions)
					}, t.isInShredditModNavExperiment ? i.a.createElement(i.a.Fragment, null, Object(g.e)(t.subreddit.name, l.mc.Contributors), this.renderTopBar(!0)) : i.a.createElement(v.b, null, r.fbt._("Approved users", null, {
						hk: "pxkv2"
					}), i.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009164452`
					})), i.a.createElement(O.b, {
						activeSearchQuery: this.state.searchTerm,
						onSearch: this.onSearch
					}), n.searchTerm ? i.a.createElement(E.a, {
						cancelSearch: this.cancelSearch,
						noResultsFound: !t.searchResult,
						searchPending: t.searchPending,
						searchTerm: n.searchTerm
					}, t.searchResult && this.renderUser(t.searchResult)) : i.a.createElement(x.b, {
						className: z.a.border,
						loadMoreToken: o,
						onLoadMore: this.onLoadMore
					}, t.approvedSubmitters.map((e, t) => ({
						estHeight: V,
						id: e.id,
						render: () => this.renderUser(e)
					})))), t.isAddUserModalOpen && this.renderAddUserModal(), t.isConfirmModalOpen && n.userId && n.username && i.a.createElement(p.a, {
						actionText: r.fbt._("Remove", null, {
							hk: "3tYl0U"
						}),
						modalText: r.fbt._("Are you sure you want to remove {username} as an approved user?", [r.fbt._param("username", n.username)], {
							hk: "4ELjHt"
						}),
						onConfirm: this.handleRemoveConfirmed,
						toggleModal: t.toggleRemoveUserModal,
						trackClick: t.sendEventWithName("remove"),
						withOverlay: !0
					})) : i.a.createElement(i.a.Fragment, null, a && !t.isInShredditModNavExperiment && this.renderTopBar(), i.a.createElement(v.a, {
						className: Object(c.a)(t.isInShredditModNavExperiment && z.a.newModNavContainer, !a && z.a.noPermissions)
					}, t.isInShredditModNavExperiment ? i.a.createElement(i.a.Fragment, null, Object(g.e)(t.subreddit.name, l.mc.Contributors), this.renderTopBar(!0)) : i.a.createElement(v.b, null, r.fbt._("Approved users", null, {
						hk: "pxkv2"
					}), i.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009164452`
					})), t.approvedSubmittersListPending ? i.a.createElement(C.a, null) : i.a.createElement(f.c, {
						className: z.a.border,
						text: r.fbt._("No approved users in {subredditName}", [r.fbt._param("subredditName", t.subreddit.displayText)], {
							hk: "1VEG1v"
						})
					}, i.a.createElement(y.a, {
						name: "edit",
						className: z.a.PencilIcon
					}))), t.isAddUserModalOpen && this.renderAddUserModal())
				}
			}
			t.a = K(J(X))
		},
		"./src/reddit/components/AvatarPost/index.m.less": function(e, t, n) {
			e.exports = {
				avatarPostContainer: "_2nck8non0VYnkIkyUpuvpw",
				avatarPostImage: "_2yQLdTnHA0y3hZ3I588oUM"
			}
		},
		"./src/reddit/components/BadgeCounter/index.m.less": function(e, t, n) {
			e.exports = {
				badgeCounter: "_1-nIsCaWhGBFN-L4ZHnbGp",
				mEmpty: "_3FX9lCQKNdKXkfBiSWCjSb"
			}
		},
		"./src/reddit/components/BadgeCounter/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/prettyPrintNumber/index.ts"),
				a = n("./src/reddit/components/BadgeCounter/index.m.less"),
				d = n.n(a);
			t.a = e => {
				let {
					className: t,
					isActive: n,
					showEmpty: s,
					unreadCount: a,
					testId: c
				} = e;
				return n ? r.a.createElement("span", {
					className: Object(o.a)(t, d.a.badgeCounter, {
						[d.a.mEmpty]: s || a < 1
					}),
					"data-testid": c
				}, s || a < 1 ? "" : Object(i.b)(a)) : null
			}
		},
		"./src/reddit/components/BannedUserList/AddBannedUserModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx"),
				r = n("./src/lib/loadWithRetries/index.ts");
			const o = () => null;
			t.a = Object(s.a)({
				ErrorComponent: o,
				getComponent: () => Object(r.a)(() => n.e("BannedUserModal").then(n.bind(null, "./src/reddit/components/BannedUserList/AddBannedUserModal/_AddBannedUserModal.tsx"))).then(e => e.default),
				LoadingComponent: o
			})
		},
		"./src/reddit/components/BannedUserList/ExpandedComponent.m.less": function(e, t, n) {
			e.exports = {
				UnthreadedComment: "lOLiM3i26F_WjvQ8LeLft",
				unthreadedComment: "lOLiM3i26F_WjvQ8LeLft",
				BanReason: "SrZ1u3sJDzvdTgFW_XYZl",
				banReason: "SrZ1u3sJDzvdTgFW_XYZl",
				ExpandedComponentContainer: "_3q58C3lscUB_CbjoSfgVW2",
				expandedComponentContainer: "_3q58C3lscUB_CbjoSfgVW2",
				ModNote: "_3hA381rnksvJreaBfQTIC3",
				modNote: "_3hA381rnksvJreaBfQTIC3",
				ModNoteContainer: "_35E0y1j_QASeOMGpNM97k7",
				modNoteContainer: "_35E0y1j_QASeOMGpNM97k7",
				SectionTitle: "_3QIBdlHwReGVNodLBY3cSt",
				sectionTitle: "_3QIBdlHwReGVNodLBY3cSt",
				ContextContainer: "_1pqL5T1jpl-iWaJcvRftmU",
				contextContainer: "_1pqL5T1jpl-iWaJcvRftmU"
			}
		},
		"./src/reddit/components/BannedUserList/index.m.less": function(e, t, n) {
			e.exports = {
				BanIcon: "_1c2rKv1iuQylye8ejI6-1v",
				banIcon: "_1c2rKv1iuQylye8ejI6-1v",
				border: "_3LrCp3zOkD42145A470rrQ",
				newModNavContainer: "_1803w6ybOWzc3APKm9EKaK",
				topBar: "_2hoMCOSinD0RVSUgH9qc-E",
				fixed: "_7a-x190yyErd7dvu5_SEC",
				default: "_3r5rDUxDbVlM511cKU8N7n"
			}
		},
		"./src/reddit/components/BannedUserList/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return $
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/subredditModeration/ban.ts"),
				p = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				b = n("./src/reddit/components/HumanDate/index.tsx"),
				f = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				h = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				g = n("./src/reddit/components/ModHub/NewModNav/PageLinks.tsx"),
				v = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				x = n("./src/reddit/components/Scroller/Simple.tsx"),
				E = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				O = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				C = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				A = n("./src/reddit/controls/Button/index.tsx"),
				y = n("./src/reddit/icons/fonts/index.tsx"),
				j = n("./src/reddit/models/SubredditModeration/index.ts"),
				I = n("./src/reddit/selectors/activeModalId.ts"),
				k = n("./src/reddit/selectors/bannedUser.ts"),
				_ = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				S = n("./src/reddit/components/BannedUserList/AddBannedUserModal/index.tsx"),
				w = n("./src/lib/lessComponent.tsx"),
				T = n("./src/reddit/components/Comments/UnthreadedComment/index.tsx"),
				P = n("./src/reddit/components/CompactPost/index.tsx"),
				N = n("./src/reddit/contexts/PageLayer/index.tsx"),
				D = n("./src/reddit/contexts/Post/index.tsx"),
				M = n("./src/reddit/selectors/commentSelector.ts"),
				R = n("./src/reddit/components/BannedUserList/ExpandedComponent.m.less"),
				L = n.n(R);
			const {
				fbt: B
			} = n("./node_modules/fbt/lib/FbtPublic.js"), F = Object(N.v)({
				currentProfileName: N.j,
				isCommentsPage: N.y,
				isCommentPermalink: N.x,
				isProfilePostListing: N.N,
				pageLayer: e => e
			}), U = w.a.wrapped(T.c, "UnthreadedComment", L.a), H = w.a.div("BanReason", L.a), G = w.a.div("ExpandedComponentContainer", L.a), Q = w.a.div("ModNote", L.a), q = w.a.div("ModNoteContainer", L.a), W = w.a.div("SectionTitle", L.a), z = w.a.div("ContextContainer", L.a), V = e => () => {}, K = e => {
				let {
					commentId: t
				} = e;
				const n = Object(a.e)(e => Object(M.c)(e, {
					commentId: t
				}));
				return n && n.postId ? i.a.createElement(D.a, {
					postId: n.postId
				}, i.a.createElement(U, {
					commentId: t,
					highlight: !1,
					trackClick: V
				})) : null
			};
			var Y = F(e => {
					const {
						currentProfileName: t,
						isCommentPermalink: n,
						isCommentsPage: s,
						isProfilePostListing: r,
						pageLayer: o,
						user: a
					} = e;
					return i.a.createElement(G, null, a.modNote && i.a.createElement(q, null, i.a.createElement(W, null, B._("Mod note:", null, {
						hk: "2LBtSw"
					})), i.a.createElement(Q, null, a.modNote)), i.a.createElement("div", null, i.a.createElement(W, null, B._("Banned For:", null, {
						hk: "3UbXsX"
					})), i.a.createElement(H, null, a.reason), (a.postId || a.commentId) && i.a.createElement(z, null, a.postId && i.a.createElement(P.default, {
						currentProfileName: t,
						isCommentsPage: s,
						isCommentPermalink: n,
						isProfilePostListing: r,
						pageLayer: o,
						last: !0,
						postId: a.postId,
						hideModTools: !0,
						inSubredditOrProfile: !0
					}), a.commentId && i.a.createElement(K, {
						commentId: a.commentId
					}))))
				}),
				J = n("./src/reddit/components/BannedUserList/index.m.less"),
				X = n.n(J);
			const Z = 48,
				$ = e => null == e ? r.fbt._("Permanent", null, {
					hk: "3pNDzS"
				}) : r.fbt._({
					"*": "{number} days left",
					_1: "1 day left"
				}, [r.fbt._plural(e, "number")], {
					hk: "3VM32a"
				}),
				ee = Object(d.c)({
					bannedUsers: k.h,
					bannedUsersList: k.d,
					bannedUsersListPending: k.c,
					loadMoreToken: k.e,
					isBanUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(I.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--BanUserConfirmation" === Object(I.a)(e),
					searchPending: k.f,
					searchResult: k.g,
					isInShredditModNavExperiment: (e, t) => {
						let {
							moderatorPermissions: n
						} = t;
						return Object(_.a)(e, !!n)
					}
				}),
				te = Object(a.b)(ee, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						loadMore: t => e(Object(m.c)(n, {
							after: t
						})),
						onUnbanUser: t => () => e(Object(m.e)(n, t)),
						searchForBannedUser: t => e(Object(m.d)(n, t)),
						toggleBanUserModal: () => e(Object(u.i)("ModerationPage--Modal--AddUser"))
					}
				});
			class ne extends i.a.Component {
				constructor(e) {
					super(e), this.isSticky = () => {
						const e = window.scrollY >= 100;
						this.setState({
							isFixed: e
						})
					}, this.handleBanUserToggled = e => {
						if (e) {
							const {
								id: t,
								username: n
							} = e;
							this.setState({
								userId: t,
								username: n
							})
						} else this.setState({
							...j.a,
							searchTerm: this.state.searchTerm
						});
						this.props.isBanUserModalOpen || this.props.sendEventWithName(e ? "edit_user" : "ban_dialog_banpage")(), this.props.toggleBanUserModal()
					}, this.addBannedUser = () => this.handleBanUserToggled(null), this.onSearch = e => {
						this.props.searchForBannedUser(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.renderBannedUser = e => {
						const t = this.props.bannedUsers[e] || this.props.searchResult,
							n = $(t.duration);
						return t ? i.a.createElement(C.b, {
							description: t.reason,
							expandedComponent: i.a.createElement(Y, {
								user: t
							}),
							pageName: l.mc.Banned,
							primaryButton: i.a.createElement(A.r, {
								onClick: () => this.handleBanUserToggled(t),
								"data-redditstyle": !0
							}, r.fbt._("Edit", null, {
								hk: "1nftDt"
							})),
							subredditId: this.props.subredditId,
							timeAgo: i.a.createElement(i.a.Fragment, null, i.a.createElement(b.d, {
								seconds: t.bannedAtUTC
							}), " (", n, ")"),
							userIcon: t.accountIcon,
							username: t.username
						}) : i.a.createElement("div", null)
					}, this.renderAddBannedUserModal = () => i.a.createElement(S.a, {
						ignoreDefaultFocus: !0,
						onUnbanUser: this.state.userId ? this.props.onUnbanUser(this.state.userId) : void 0,
						subredditId: this.props.subredditId,
						toggleModal: () => this.handleBanUserToggled(null),
						trackAddEvent: this.props.sendEventWithName("add_banpage"),
						trackEventWithName: this.props.sendEventWithName,
						user: this.state.userId ? this.state.searchTerm ? this.props.searchResult || null : this.props.bannedUsers[this.state.userId] : null,
						withOverlay: !0
					}), this.renderTopBar = e => i.a.createElement(v.c, {
						className: Object(c.a)(e && "bg-neutral-background mb-xs pr-0", X.a.topBar, {
							[X.a.default]: !e,
							[X.a.fixed]: this.state.isFixed
						})
					}, i.a.createElement(A.l, {
						onClick: this.addBannedUser,
						"data-redditstyle": !0
					}, " ", r.fbt._("Ban user", null, {
						hk: "2q7TuL"
					}))), this.state = j.a
				}
				componentDidMount() {
					this.props.isInShredditModNavExperiment && window.addEventListener("scroll", this.isSticky)
				}
				componentWillUnmount() {
					this.props.isInShredditModNavExperiment && window.removeEventListener("scroll", this.isSticky)
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = e.bannedUsersList.length ? e.bannedUsersList[e.bannedUsersList.length - 1].id : void 0;
					return e.bannedUsersList.length ? i.a.createElement(i.a.Fragment, null, !e.isInShredditModNavExperiment && this.renderTopBar(), i.a.createElement(v.a, {
						className: e.isInShredditModNavExperiment ? X.a.newModNavContainer : void 0
					}, e.isInShredditModNavExperiment ? i.a.createElement(i.a.Fragment, null, Object(g.e)(e.subreddit.name, l.mc.Banned), this.renderTopBar(!0)) : i.a.createElement(v.b, null, r.fbt._("Banned users", null, {
						hk: "3hvISm"
					}), i.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009161872`
					})), i.a.createElement(O.b, {
						onSearch: this.onSearch,
						activeSearchQuery: this.state.searchTerm
					}), t.searchTerm ? i.a.createElement(E.a, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && this.renderBannedUser(e.searchResult.id)) : i.a.createElement(x.b, {
						className: X.a.border,
						loadMoreToken: n,
						onLoadMore: this.onLoadMore
					}, e.bannedUsersList.map(e => ({
						estHeight: Z,
						id: e.id,
						render: () => this.renderBannedUser(e.id)
					})))), e.isBanUserModalOpen && this.renderAddBannedUserModal(), e.isConfirmModalOpen && t.userId && t.username && i.a.createElement(p.a, {
						actionText: r.fbt._("Remove", null, {
							hk: "3tYl0U"
						}),
						modalText: r.fbt._("Are you sure you want to ban {username}?", [r.fbt._param("username", t.username)], {
							hk: "4f7Mkp"
						}),
						onConfirm: () => {},
						toggleModal: e.toggleBanUserModal,
						trackClick: e.sendEventWithName("remove")
					})) : i.a.createElement(i.a.Fragment, null, !e.isInShredditModNavExperiment && this.renderTopBar(), i.a.createElement(v.a, {
						className: e.isInShredditModNavExperiment ? X.a.newModNavContainer : void 0
					}, e.isInShredditModNavExperiment ? i.a.createElement(i.a.Fragment, null, Object(g.e)(e.subreddit.name, l.mc.Banned), this.renderTopBar(!0)) : i.a.createElement(v.b, null, r.fbt._("Banned users", null, {
						hk: "3hvISm"
					}), i.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009161872`
					})), e.bannedUsersListPending ? i.a.createElement(C.a, null) : i.a.createElement(f.c, {
						className: X.a.border,
						text: r.fbt._("No banned users in {subredditName}", [r.fbt._param("subredditName", e.subreddit.displayText)], {
							hk: "1nOcbC"
						})
					}, i.a.createElement(y.a, {
						name: "ban",
						className: X.a.BanIcon
					}))), e.isBanUserModalOpen && this.renderAddBannedUserModal())
				}
			}
			t.a = te(ne)
		},
		"./src/reddit/components/BoostPost/BoostPostBanner.m.less": function(e, t, n) {
			e.exports = {
				root: "_1bFyAea2u1QxOQ1F5B4GkN",
				boostPost: "_2HRj2_i58dkRRJQoLcPYos",
				nightRoot: "_1gHnZ35aZq6j7V6-yJI8Ex",
				boostPostIcon: "_3-103Q5oLObJuUD_Kw30cF",
				boostPostTitle: "_1DC_jVf8m3dNMZizsj84j1",
				boostPostSubtitle: "_142PYc7s46KPZKVON3XAN8",
				boostPostText: "_1bYeQt_TV5_-qyJ0ou4R4g",
				boostPostButton: "pSzvw13UmARlu2u6QGtsR",
				boostPostButtonText: "_38B5eqRnC0dTpzLkC_7APC",
				boostPostCloseButton: "_3k7l59W74Y3dHDNBrT9oce",
				boostPostClose: "_9PWeID-JtyhyViXeQFfuq"
			}
		},
		"./src/reddit/components/BoostPost/BoostPostIconButton.m.less": function(e, t, n) {
			e.exports = {
				container: "Oqp_3zg4nUr27VgCF82qt",
				boostPostIconButton: "_3DV09faePsSW4n6z5V2kj1",
				boostPostIconButtonIconOnly: "ITg0gjNXOhVKsSbURGUvp",
				boostPostTooltipText: "_2q9Jd9uoQVrgF0qTQz8xC1"
			}
		},
		"./src/reddit/components/BoostPost/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return M
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "d", (function() {
				return V
			})), n.d(t, "e", (function() {
				return T
			})), n.d(t, "c", (function() {
				return Y
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/icons.ts"),
				l = n("./src/reddit/controls/Button/index.tsx"),
				u = n("./src/reddit/helpers/localStorage/index.ts"),
				m = n("./src/reddit/helpers/trackers/post.ts"),
				p = n("./src/reddit/hooks/useTracking.ts"),
				b = n("./src/reddit/icons/fonts/index.tsx"),
				f = n("./src/reddit/selectors/user.ts"),
				h = n("./src/reddit/components/BoostPost/BoostPostBanner.m.less"),
				g = n.n(h);
			const v = Object(o.createContext)({
					attemptVisiblePostIdUpdate: e => {},
					resetVisiblePostIdToDefault: () => {},
					visiblePostId: void 0
				}),
				x = () => {
					return Object(u.h)() ? null : void 0
				},
				E = () => {
					return Object(u.h)()
				},
				O = e => {
					let {
						children: t
					} = e;
					const n = Object(o.useRef)(E()),
						[s, r] = Object(o.useState)(x()),
						a = Object(o.useCallback)(() => {
							n.current = E();
							const e = x();
							r(e)
						}, []);
					return Object(o.useEffect)(() => (window.addEventListener("storage", a), () => {
						window.removeEventListener("storage", a)
					}), [a]), i.a.createElement(v.Provider, {
						value: {
							attemptVisiblePostIdUpdate: e => {
								n.current || (n.current = !0, r(e))
							},
							resetVisiblePostIdToDefault: a,
							visiblePostId: s
						}
					}, t)
				};
			var C = n("./src/reddit/constants/experiments.ts"),
				A = n("./src/reddit/contexts/PageLayer/index.tsx"),
				y = n("./src/reddit/helpers/isCrosspost.ts"),
				j = n("./src/reddit/hooks/useExperimentVariant.ts"),
				I = n("./src/reddit/models/Post/index.ts"),
				k = n("./src/reddit/models/WhitelistStatus/index.ts"),
				_ = n("./src/reddit/selectors/posts.ts"),
				S = n("./src/reddit/selectors/profile.ts"),
				w = n("./src/reddit/selectors/subreddit.ts");
			const T = (e, t) => !(!e || !t || e.authorId !== t.id || e.isSponsored || e.isNSFW || e.pollData || e.predictionTournament || e.discussionType && e.discussionType !== I.b.Comment || Object(y.a)(e)),
				P = e => !!e && e.hasVerifiedEmail,
				N = e => !!e && !e.isNSFW && !e.isQuarantined,
				D = e => {
					let {
						postId: t,
						user: n
					} = e;
					const s = Object(A.ib)(),
						r = Object(a.e)(e => Object(_.F)(e, {
							postId: t
						})),
						i = Object(I.s)(r) ? r.belongsTo.id : "",
						d = Object(I.w)(r) ? r.belongsTo.id : "",
						c = Object(a.e)(e => Object(S.j)(e, i)),
						l = Object(a.e)(e => Object(w.X)(e, {
							subredditId: d
						})),
						u = Object(a.e)(e => Object(A.G)(e, {
							pageLayer: s
						})),
						m = Object(o.useCallback)(() => !!(u && Object(I.s)(r) && T(r, n) && P(n) && N(c)), [u, r, c, n]),
						p = Object(o.useCallback)(() => T(r, n) && P(n) && N(l) && (e => !!e && (e.wls === k.b.ALL_ADS || "all_ads" === e.whitelistStatus))(l), [r, n, l]),
						b = Object(j.a)(C.r, m),
						f = Object(j.a)(C.q, m),
						h = Object(j.a)(C.s, p),
						g = Object(j.a)(C.t, p);
					return {
						canBoostPost: b === C.Yd || f === C.Yd || h === C.Yd || g === C.Yd
					}
				},
				M = e => {
					let {
						postId: t,
						user: n
					} = e;
					const {
						visiblePostId: s,
						attemptVisiblePostIdUpdate: r
					} = Object(o.useContext)(v), {
						canBoostPost: a
					} = D({
						postId: t,
						user: n
					});
					return a && r(t), s === t ? i.a.createElement(R, {
						postId: t
					}) : null
				};
			M.displayName = "BoostPostBanner";
			const R = Object(o.memo)(e => {
				let {
					postId: t
				} = e;
				const n = Object(p.a)(),
					h = Object(a.e)(f.fb);
				Object(o.useEffect)(() => {
					n(Object(m.w)(t))
				}, [n, t]);
				const v = Object(o.useCallback)(() => {
						Object(u.pb)(), n(Object(m.a)(t))
					}, [n, t]),
					x = Object(o.useCallback)(e => {
						e.stopPropagation(), Object(u.pb)(), n(Object(m.c)(t))
					}, [n, t]);
				return i.a.createElement("div", {
					className: Object(d.a)(g.a.root, {
						[g.a.nightRoot]: h
					})
				}, i.a.createElement("div", {
					className: g.a.boostPost
				}, i.a.createElement(b.a, {
					name: c.a.promote_snoo,
					className: g.a.boostPostIcon,
					style: {
						fontSize: 24,
						height: 24,
						width: 24
					}
				}), i.a.createElement("div", {
					className: g.a.boostPostText
				}, i.a.createElement("h6", {
					className: g.a.boostPostTitle
				}, r.fbt._("Reach more redditors!", null, {
					hk: "1kAZ0D"
				})), i.a.createElement("p", {
					className: g.a.boostPostSubtitle
				}, r.fbt._("Promote your post with Reddit Ads to reach more people and drive engagement.", null, {
					hk: "22s2iC"
				}))), i.a.createElement(l.t, {
					className: g.a.boostPostButton,
					kind: l.b.ExternalLink,
					priority: l.c.Secondary,
					onClick: v,
					href: `${s.a.adsUiOrigin}/boostPost?postId=${t}&utm_source=d2x_consumer&utm_name=boost_post_banner`,
					target: "_blank",
					Icon: Object(b.b)("external_link_fill", {
						style: {
							fontSize: 16,
							paddingRight: 4
						}
					}),
					text: i.a.createElement("p", {
						className: g.a.boostPostButtonText
					}, r.fbt._("Promote", null, {
						hk: "4fj8yW"
					}))
				}), i.a.createElement("button", {
					className: g.a.boostPostCloseButton,
					onClick: x,
					"aria-label": r.fbt._("Hide", null, {
						hk: "2qpeBI"
					})
				}, i.a.createElement(b.a, {
					className: g.a.boostPostClose,
					name: c.a.close_fill,
					onClick: x,
					style: {
						fontSize: 12,
						lineHeight: "12px",
						height: 12,
						width: 12
					}
				}))))
			});
			R.displayName = "BoostPostBannerMemo";
			var L = n("./node_modules/classnames/index.js"),
				B = n.n(L),
				F = n("./src/reddit/components/Flatlist/constants.ts"),
				U = n("./src/reddit/components/Flatlist/ResponsiveRow.tsx"),
				H = n("./src/reddit/components/InfoTextTooltip/Hooked.tsx"),
				G = n("./src/reddit/components/TrackingHelper/index.tsx"),
				Q = n("./src/reddit/hooks/useInfoTextTooltip.ts"),
				q = n("./src/reddit/components/BoostPost/BoostPostIconButton.m.less"),
				W = n.n(q),
				z = n("./src/reddit/components/BoostPost/useBoostPostAction.ts");
			const V = Object(o.memo)(e => {
				let {
					postId: t,
					user: n,
					userIsOp: s,
					showIconOnly: a
				} = e;
				const d = Object(Q.a)(),
					{
						canBoostPost: l
					} = D({
						postId: t,
						user: n
					}),
					{
						onBoostPostClick: u
					} = Object(z.a)(t),
					p = Object(G.b)();
				return Object(o.useEffect)(() => {
					l && p(Object(m.x)(t))
				}, [l, p, t]), l ? i.a.createElement("span", {
					onMouseEnter: d.show,
					onMouseLeave: d.hide,
					ref: d.target.ref,
					className: W.a.container
				}, i.a.createElement(U.a, {
					iconWrapperClassName: B()(W.a.boostPostIconButton, {
						[W.a.boostPostIconButtonIconOnly]: a
					}),
					displayText: a ? void 0 : r.fbt._("Promote", null, {
						hk: "K797d"
					}),
					flatlistItem: F.a.PromotePost,
					isLoggedIn: !!n,
					isUserOp: s,
					onClick: u
				}, i.a.createElement(b.a, {
					name: c.a.promote_snoo
				})), i.a.createElement(H.a, {
					arrowProps: d.arrowProps,
					popperProps: {
						...d.popperProps,
						style: {
							...d.popperProps.style,
							width: "250px"
						}
					},
					visible: d.visible
				}, r.fbt._("Promote your post with Reddit Ads to reach more people and drive engagement", null, {
					hk: "38gIbE"
				}))) : null
			});
			V.displayName = "BoostPostIconButton";
			var K = n("./src/reddit/hooks/usePageLayer.ts");
			const Y = e => {
				let {
					children: t
				} = e;
				const {
					resetVisiblePostIdToDefault: n
				} = Object(o.useContext)(v), s = Object(K.a)(), [r, i] = Object(o.useState)(null == s ? void 0 : s.queryParams);
				return Object(o.useEffect)(() => {
					(null == s ? void 0 : s.queryParams) && (null == s ? void 0 : s.queryParams) !== r && (i(null == s ? void 0 : s.queryParams), n())
				}, [s, r, n]), t
			}
		},
		"./src/reddit/components/BoostPost/useBoostPostAction.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/react/index.js"),
				o = n("./src/reddit/components/TrackingHelper/index.tsx"),
				i = n("./src/reddit/helpers/trackers/post.ts");
			const a = e => {
				const t = Object(o.b)();
				return {
					onBoostPostClick: Object(r.useCallback)(() => {
						t(Object(i.b)(e)), window.open(`${s.a.adsUiOrigin}/boostPost?postId=${e}&utm_source=d2x_consumer&utm_name=boost_post_icon_button`, "_blank")
					}, [t, e])
				}
			}
		},
		"./src/reddit/components/CCM/AddModNoteCTA/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/hooks/useTracking.ts"),
				d = n("./src/reddit/helpers/trackers/modTools.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/contexts/PageLayer/index.tsx"),
				u = n("./src/reddit/actions/tooltip.ts"),
				m = n("./src/reddit/components/Hovercards/AuthorHovercard/ModIdCard/async.tsx"),
				p = n("./src/reddit/components/Hovercards/helpers.ts"),
				b = n("./src/reddit/components/PostTopMeta/index.tsx"),
				f = n("./src/reddit/hooks/useIsOverlay.ts"),
				h = n("./src/reddit/models/Post/index.ts"),
				g = n("./src/redditGQL/types.ts");
			const v = Object(l.v)();
			t.a = v(e => {
				let {
					pageLayer: t,
					postOrComment: n,
					className: l
				} = e;
				var v;
				const x = Object(f.a)(),
					E = Object(i.d)(),
					O = Object(a.a)(),
					C = (null === (v = null == t ? void 0 : t.urlParams) || void 0 === v ? void 0 : v.pageName) === c.wb.Modqueue,
					A = Object(r.useCallback)(() => {
						const e = Object(p.b)({
							itemId: n.id,
							tooltipIdPrefix: m.a,
							tooltipType: x ? b.f.Lightbox : void 0
						});
						E(Object(u.h)({
							tooltipId: e,
							args: {
								isModNotesView: !0,
								modNotesFilter: g.A.Note
							}
						})), O(Object(d.a)(n.id, n.authorId))
					}, [n, E, x, O]);
				return !C || Object(h.p)(n.author) ? null : o.a.createElement("button", {
					className: l,
					onClick: A
				}, s.fbt._("Add a note", null, {
					hk: "1dmmma"
				}))
			})
		},
		"./src/reddit/components/CCM/ModPreviousActions/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_2-D4Vessy5Hd1e5HAU1PK3",
				wrapperTitle: "aC6WYpmVvQIF_BZRtMI_W",
				row: "ax8JnexGOa4WYNYKwXlQs",
				icon: "_1fiz4BfaOlncADi00qAx_l",
				userIconWrapper: "_1ChqLpIvObEfBbb4d-hyah",
				userIcon: "_3nEX0mG3UGhbY0hR0Kqaag",
				details: "_3jKisheiLDnZzH5J_qln3x",
				title: "_1-LXaYXcvGUA9hhrrw587d",
				meta: "_3w_F6oDd1-ZDKgp3jo94ew",
				time: "_2820zMw8REXxmaotvSTjqt",
				userlink: "_2622vu9WjymZhKkDq78CfF"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/Filters/ActionsDropdown/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "ModerationLogFilters",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModerationLogFilters").then(n.bind(null, "./src/reddit/components/CCM/ModerationLog/Filters/ActionsDropdown/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/CCM/ModerationLog/Filters/ActionsDropdown/index.tsx"
				}
			}, {
				ssr: !1
			});
			t.a = r
		},
		"./src/reddit/components/CCM/ModerationLog/Filters/DateRangeDropdown/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "ModerationLogFilters",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModerationLogFilters").then(n.bind(null, "./src/reddit/components/CCM/ModerationLog/Filters/DateRangeDropdown/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/CCM/ModerationLog/Filters/DateRangeDropdown/index.tsx"
				}
			}, {
				ssr: !1
			});
			t.a = r
		},
		"./src/reddit/components/CCM/ModerationLog/Filters/ModeratorsDropdown/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "ModerationLogFilters",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModerationLogFilters").then(n.bind(null, "./src/reddit/components/CCM/ModerationLog/Filters/ModeratorsDropdown/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/CCM/ModerationLog/Filters/ModeratorsDropdown/index.tsx"
				}
			}, {
				ssr: !1
			});
			t.a = r
		},
		"./src/reddit/components/CCM/ModerationLog/Filters/PostUrlsDropdown/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "ModerationLogFilters",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModerationLogFilters").then(n.bind(null, "./src/reddit/components/CCM/ModerationLog/Filters/PostUrlsDropdown/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/CCM/ModerationLog/Filters/PostUrlsDropdown/index.tsx"
				}
			}, {
				ssr: !1
			});
			t.a = r
		},
		"./src/reddit/components/CCM/ModerationLog/Filters/UsernameDropdown/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "ModerationLogFilters",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModerationLogFilters").then(n.bind(null, "./src/reddit/components/CCM/ModerationLog/Filters/UsernameDropdown/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/CCM/ModerationLog/Filters/UsernameDropdown/index.tsx"
				}
			}, {
				ssr: !1
			});
			t.a = r
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/Action/index.m.less": function(e, t, n) {
			e.exports = {
				actionLink: "_28SdCXCgfR0vAmVJxu6-36"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/ActionCategory/index.m.less": function(e, t, n) {
			e.exports = {
				bullet: "_2NlviZ4OCkAQ6ccvVO5UKP",
				icon: "_3pfYW7u0eipWXzeAU7bAH"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/ActionCategory/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/constants/moderationLog.ts"),
				a = n("./src/reddit/selectors/user.ts"),
				d = n("./src/reddit/icons/fonts/index.tsx"),
				c = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/ActionCategory/index.m.less"),
				l = n.n(c);
			t.a = e => {
				let {
					category: t,
					onClick: n
				} = e;
				const s = Object(o.e)(a.fb),
					c = i.d[t],
					u = s ? i.e[t] : i.c[t],
					m = i.b[t];
				return m ? r.a.createElement("button", {
					className: l.a.bullet,
					style: {
						background: u
					},
					onClick: n ? () => n(t) : void 0
				}, r.a.createElement(d.a, {
					name: c,
					className: l.a.icon
				}), m()) : null
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/DetailsColumn/index.m.less": function(e, t, n) {
			e.exports = {
				title: "_1Qgx8pnOedeEcUq1Aq7nnI",
				titleLink: "_3kK7NXJ6HXs_ri8LQwEjsP",
				content: "VQD060Jlvk5c0sh6AFZp8",
				contentLink: "d952AWo5Tt44L0YhpuoUH",
				detailsType: "_1IMWJItpkXdv4aQ8ONBhPq",
				usernameLink: "_34auX_aCptXoIb7c7744y-",
				expandButton: "_3J69NuGduUVAs7ZP_p_Lna"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/BlurrableThumbnail.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_3ylwGIumN6Usp9S0wyrUaD",
				thumbnail: "_3Z1cNySjt_ptG1UcbJvKix",
				blur: "EfkQdGKgBzVW902KMircF"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/ExpandableBody.m.less": function(e, t, n) {
			e.exports = {
				body: "_2rttRV2XGKDsn9MzINY3OH",
				bodyExpanded: "_2b_AtwH66JK156EkcBDM0d",
				seeMore: "WoZ7u09hFLxJLrpjCwQzd"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/PreviewExpandButton.m.less": function(e, t, n) {
			e.exports = {
				noPreview: "_1bzcj-0tMxHvCMU7MENeq_"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/PreviewInfo.m.less": function(e, t, n) {
			e.exports = {
				previewInfo: "_3GbSYbYdsqwQtlFTG_8n_I",
				previewInfoItem: "fQ-tARWmzWFHWbBpup9Z6"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_39tOdYiwnq1F1StfeCfMw2",
				contentWrapperComment: "_1AhVlTZKxaFeJ3o1wiyhaz",
				title: "zNUbRkrX31LKGQyn6kybd",
				authorLink: "_37cQc-cNah-iE4GOzG7qES"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/index.m.less": function(e, t, n) {
			e.exports = {
				row: "_21wBv1F97jRGr7cFOkkCJE",
				dateCell: "_6EVzgYd9a6dYgbfgRERA4",
				modCell: "_3Z-rQJg_uFjkxGkMrsmUn0",
				modNameAndIconContainer: "_1iY1HavVYTo4oCrYd78WrE",
				modNameAndIcon: "_2mOXiCh_6Z4sEH3RuMtEo-",
				actionCategoryCell: "_1abC0NqB4IvxHMrdWEYZpm",
				actionCell: "_3K7ZZHqE-muy3Z4WyyRObc",
				takedownContentPreview: "V0oJFR3vDQ2gfIPbbusXq"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/PageLimit/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2dp3heyx3W_muidSvrAtbe",
				dropdown: "_1zelwPtWhXpA0U4vKtSppP"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/index.m.less": function(e, t, n) {
			e.exports = {
				contentContainer: "_30Tatb_Hd9Ia0IxUf_1fcq",
				table: "_9ZBCc4lvvSOp7lMsuGyFZ",
				inModNavExperiment: "_3ZivNh8M3DaDbaWrEGS-Pn",
				controlRow: "_19avorQMLJgpADLYzbu7Lg",
				filters: "_30ALxCcNK-RqU6mCGsR7RX",
				paging: "_3FHBykioCchdAa3cFob_ip",
				pageLimit: "_2rc3n-RQJfDFYBJZ2d4fnm",
				title: "_1z1Hw7iREBdwhCqbaJ5diX",
				emptyPanel: "_2_imy3guN_jJPm-R93J_Ka",
				emptyIcon: "_3KJYvAtYbiobspSNUSIkNr"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/react-router-redux/es/index.js"),
				c = n("./src/reddit/hooks/useTracking.ts"),
				l = n("./src/lib/addQueryParams/index.ts"),
				u = n("./src/lib/classNames/index.ts"),
				m = n("./src/lib/constants/index.ts"),
				p = n("./src/lib/stripQueryParams/index.ts"),
				b = n("./src/reddit/helpers/moderationLog/getGqlQueryParamsFromUrlQuery.ts"),
				f = n("./src/reddit/helpers/trackers/modLog.ts"),
				h = n("./src/lib/makeActionCreator/index.ts"),
				g = n("./src/reddit/endpoints/subredditModeration/moderationLog.ts"),
				v = n("./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts"),
				x = n("./src/reddit/selectors/subreddit.ts"),
				E = n("./src/reddit/actions/moderationLog/constants.ts");
			const O = Object(h.a)(E.a);
			var C = n("./node_modules/lodash/isEmpty.js"),
				A = n.n(C);
			const y = Object(h.a)(E.b);
			var j = n("./src/reddit/components/CCM/ModerationLog/Filters/ActionsDropdown/Loader.tsx"),
				I = n("./src/reddit/components/CCM/ModerationLog/Filters/DateRangeDropdown/Loader.tsx"),
				k = n("./src/reddit/components/CCM/ModerationLog/Filters/ModeratorsDropdown/Loader.tsx"),
				_ = n("./src/reddit/components/CCM/ModerationLog/Filters/PostUrlsDropdown/Loader.tsx"),
				S = n("./src/reddit/components/CCM/ModerationLog/Filters/UsernameDropdown/Loader.tsx"),
				w = n("./src/reddit/constants/intlSupport.ts"),
				T = n("./src/reddit/components/HumanDate/HumanDate.tsx"),
				P = n("./src/reddit/components/IdentityAndIcon/index.tsx"),
				N = n("./src/reddit/constants/moderationLog.ts"),
				D = n("./src/reddit/controls/InvisibleScreenReaderText/index.tsx"),
				M = n("./src/reddit/models/User/index.ts"),
				R = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/Action/index.m.less"),
				L = n.n(R);
			const B = e => {
				let {
					action: t,
					onClick: n
				} = e;
				const s = N.a[t];
				return i.a.createElement("button", {
					className: L.a.actionLink,
					onClick: n ? () => n(t) : void 0
				}, s && s())
			};
			var F = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/ActionCategory/index.tsx"),
				U = n("./src/reddit/components/AuthorLink/index.tsx"),
				H = n("./node_modules/lodash/noop.js"),
				G = n.n(H),
				Q = n("./src/reddit/components/Hovercards/AuthorHovercard/HoverCard.tsx"),
				q = n("./src/reddit/components/Hovercards/helpers.ts"),
				W = n("./src/reddit/components/Hovercards/HoverDiv/index.tsx");
			var z = e => {
					const t = Object(q.b)({
							author: e.author,
							itemId: e.contextId,
							tooltipIdPrefix: "ModerationLogUserInfoTooltip"
						}),
						n = `${t}-hover-id`,
						s = e.author;
					return i.a.createElement(W.a, {
						authorOrSubredditName: s,
						className: e.hoverDivClassName,
						hoverId: n,
						sendHoverEvent: G.a,
						tooltipId: t
					}, i.a.createElement("div", {
						id: t
					}, e.children), i.a.createElement(Q.a, {
						className: e.className,
						contextId: e.contextId,
						hoverId: n,
						sendEvent: G.a,
						subredditId: e.subredditId,
						tooltipId: t,
						userName: s
					}))
				},
				V = n("./src/reddit/helpers/graphql/helpers.ts"),
				K = n("./src/reddit/models/Comment/index.ts"),
				Y = n("./src/reddit/models/FeedElement/index.ts");
			const J = e => {
					let {
						authorInfo: t
					} = e;
					return t && t.__typename === M.c.AvailableRedditor ? t.name : null
				},
				X = e => `${e.id}-takedown-content-preview`,
				Z = e => {
					var t, n;
					return !!((null === (t = e.takedownContentPreview) || void 0 === t ? void 0 : t.title) || (null === (n = e.takedownContentPreview) || void 0 === n ? void 0 : n.body))
				},
				$ = e => {
					var t;
					return null === (t = e.takedownContentPreview) || void 0 === t ? void 0 : t.violatedContentPolicyRule
				},
				ee = e => {
					const {
						target: t,
						takedownContentPreview: n
					} = e;
					if (!n) return null;
					const {
						title: s,
						body: r,
						thumbnail: o,
						violatedContentPolicyRule: i
					} = n;
					if (!t) return {
						title: s,
						body: r,
						thumbnail: o,
						violatedContentPolicyRule: i
					};
					if ((e => e.__typename === Y.a.SubredditPost)(t)) {
						const e = t,
							{
								score: n,
								commentCount: a,
								createdAt: d
							} = e;
						return {
							title: s,
							body: r,
							thumbnail: o,
							violatedContentPolicyRule: i,
							score: n,
							commentCount: a,
							author: J(e),
							createdAt: Object(V.g)(d)
						}
					}
					if ((e => e.__typename === K.d.Comment)(t)) {
						const e = t,
							{
								score: n,
								createdAt: s,
								postInfo: o
							} = e;
						return {
							title: null == o ? void 0 : o.title,
							body: r,
							parent: {
								score: null == o ? void 0 : o.score,
								commentCount: null == o ? void 0 : o.commentCount,
								createdAt: (null == o ? void 0 : o.createdAt) ? Object(V.g)(null == o ? void 0 : o.createdAt) : null
							},
							score: n,
							author: J(e),
							createdAt: Object(V.g)(s)
						}
					}
					return null
				};
			var te = n("./src/reddit/controls/Button/index.tsx"),
				ne = n("./src/reddit/icons/fonts/index.tsx"),
				se = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/PreviewExpandButton.m.less"),
				re = n.n(se);
			const {
				fbt: oe
			} = n("./node_modules/fbt/lib/FbtPublic.js"), ie = e => {
				let {
					action: t,
					className: n,
					showTakedownPreview: s,
					toggleShowTakedownPreview: r
				} = e;
				return Z(t) ? i.a.createElement(te.t, {
					className: n,
					Icon: Object(ne.b)(s ? "caret_up" : "caret_down"),
					iconPosition: te.h.R,
					priority: te.c.PlainLink,
					onClick: r,
					"aria-expanded": s,
					"aria-controls": X(t)
				}, s ? oe._("Hide details", null, {
					hk: "4295ML"
				}) : oe._("Show details", null, {
					hk: "4d94Js"
				})) : i.a.createElement("span", {
					className: Object(u.a)(n, re.a.noPreview)
				}, oe._("Details removed", null, {
					hk: "25LG4u"
				}))
			};
			var ae = n("./src/reddit/components/TrackingHelper/index.tsx"),
				de = n("./src/redditGQL/types.ts");
			const ce = e => {
				let {
					authorInfo: t
				} = e;
				return t && t.__typename === M.c.AvailableRedditor && t.name || null
			};
			var le = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/DetailsColumn/index.m.less"),
				ue = n.n(le);
			const me = e => {
				let {
					action: t,
					showTakedownPreview: n,
					subredditId: s,
					toggleShowTakedownPreview: r
				} = e;
				const a = Object(ae.b)(),
					{
						authorUsername: d,
						title: c,
						content: l,
						urlPath: u
					} = (e => {
						var t, n, s, r;
						const o = null === (t = e.target) || void 0 === t ? void 0 : t.__typename;
						let i = e.target;
						switch (o) {
							case Y.a.SubredditPost:
								return {
									authorUsername: ce(i = i), title: (null === (n = e.takedownContentPreview) || void 0 === n ? void 0 : n.title) || i.title, content: (null === (s = e.takedownContentPreview) || void 0 === s ? void 0 : s.body) || i.content && i.content.markdown, urlPath: i.permalink
								};
							case Y.a.DeletedSubredditPost:
								return {
									authorUsername: null, title: (i = i).title, content: null, urlPath: i.permalink
								};
							case M.c.AvailableRedditor:
								return {
									authorUsername: (i = i) && i.name || null, title: null, content: null, urlPath: void 0
								};
							case K.d.Comment:
								return {
									authorUsername: ce(i = i), title: null, content: (null === (r = e.takedownContentPreview) || void 0 === r ? void 0 : r.body) || i.content && i.content.markdown, urlPath: i.permalink
								};
							case K.d.DeletedComment:
								return {
									authorUsername: null, title: (i = i).postInfo && i.postInfo.title, content: null, urlPath: i.postInfo && i.postInfo.permalink
								};
							default:
								return {
									authorUsername: null, title: null, content: null, urlPath: void 0
								}
						}
					})(t),
					{
						text: m,
						url: p
					} = (e => {
						var t;
						const {
							actionNotes: n,
							details: s,
							takedownContentPreview: r
						} = e;
						if (null == r ? void 0 : r.violatedContentPolicyRule) return {
							text: N.j[r.violatedContentPolicyRule](),
							url: r.violatedContentPolicyRule === de.h.Dmca ? N.h : N.g
						};
						const o = (null === (t = N.f[s]) || void 0 === t ? void 0 : t.call(N.f)) || s;
						return n ? o ? {
							text: `${o}: ${e.actionNotes}`
						} : {
							text: n
						} : {
							text: o
						}
					})(t),
					b = (e => {
						var t;
						const n = $(e) || void 0,
							s = null === (t = e.target) || void 0 === t ? void 0 : t.__typename;
						let r = e.target;
						switch (s) {
							case Y.a.SubredditPost:
							case Y.a.DeletedSubredditPost:
								return {
									post: {
										id: (r = r).id
									}, comment: void 0, violatedContentPolicyRule: n
								};
							case K.d.Comment:
							case K.d.DeletedComment:
								return {
									post: void 0, comment: {
										id: (r = r).id
									}, violatedContentPolicyRule: n
								};
							default:
								return {
									post: void 0, comment: void 0, violatedContentPolicyRule: n
								}
						}
					})(t),
					h = (e => !!$(e))(t),
					g = Object(o.useCallback)(() => {
						r(), n || a(Object(f.h)(b))
					}, [b, a, n, r]),
					v = Object(o.useCallback)(() => a(Object(f.i)(b)), [b, a]),
					x = Object(o.useCallback)(() => a(Object(f.j)(b)), [b, a]),
					E = Object(o.useCallback)(() => a(Object(f.g)(b)), [b, a]);
				return i.a.createElement("div", {
					className: ue.a.container
				}, i.a.createElement("div", {
					className: ue.a.detailsContainer
				}, d && !N.i.includes(d) ? i.a.createElement(z, {
					contextId: t.id,
					alwaysShowChildren: !0,
					author: d,
					subredditId: s
				}, i.a.createElement(U.a, {
					className: ue.a.usernameLink,
					author: d,
					onClick: v
				}, `u/${d}`)) : d, c && u && i.a.createElement(i.a.Fragment, null, i.a.createElement("h5", {
					className: ue.a.title
				}, i.a.createElement("a", {
					className: ue.a.titleLink,
					target: "_blank",
					rel: "noopener noreferrer",
					href: u,
					onClick: x
				}, c)), l && i.a.createElement("p", {
					className: ue.a.content
				}, l)), !c && l && u && i.a.createElement("p", {
					className: ue.a.content
				}, i.a.createElement("a", {
					className: ue.a.contentLink,
					target: "_blank",
					rel: "noopener noreferrer",
					href: u,
					onClick: x
				}, l)), m && i.a.createElement("span", {
					className: ue.a.detailsType
				}, "(", p ? i.a.createElement("a", {
					href: p,
					target: "_blank",
					rel: "noopener noreferrer",
					onClick: E
				}, m) : m, ")")), h && i.a.createElement(ie, {
					className: ue.a.expandButton,
					action: t,
					showTakedownPreview: n,
					toggleShowTakedownPreview: g
				}))
			};
			var pe = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/BlurrableThumbnail.m.less"),
				be = n.n(pe);
			const fe = e => {
				let {
					src: t
				} = e;
				const [n, s] = Object(o.useState)(!0);
				return i.a.createElement("button", {
					className: be.a.wrapper,
					onClick: () => s(e => !e),
					role: "img",
					"aria-label": r.fbt._("Thumbnail preview of content media", null, {
						hk: "43MhFw"
					})
				}, i.a.createElement("img", {
					className: Object(u.a)(be.a.thumbnail, {
						[be.a.blur]: n
					}),
					src: t
				}))
			};
			var he = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/ExpandableBody.m.less"),
				ge = n.n(he);
			const ve = e => {
				let {
					children: t
				} = e;
				const n = Object(o.useRef)(null),
					[s, a] = Object(o.useState)(!1);
				Object(o.useLayoutEffect)(() => {
					if (n.current) {
						const e = n.current,
							t = e.clientHeight >= e.scrollHeight;
						a(t)
					}
				}, [n, a]);
				return i.a.createElement(i.a.Fragment, null, i.a.createElement("p", {
					ref: n,
					className: Object(u.a)(ge.a.body, {
						[ge.a.bodyExpanded]: s
					})
				}, t), !s && i.a.createElement(te.t, {
					className: ge.a.seeMore,
					size: te.d.XS,
					priority: te.c.PlainLink,
					onClick: () => {
						a(!0)
					}
				}, r.fbt._("See more", null, {
					hk: "PNFjo"
				})))
			};
			var xe = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/index.m.less"),
				Ee = n.n(xe),
				Oe = n("./src/reddit/components/HumanDate/index.tsx"),
				Ce = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/PreviewInfo.m.less"),
				Ae = n.n(Ce);
			const ye = e => {
					let {
						author: t,
						score: n,
						commentCount: s,
						createdAt: o
					} = e;
					return i.a.createElement("ul", {
						className: Ae.a.previewInfo
					}, t && i.a.createElement("li", {
						className: Ae.a.previewInfoItem
					}, i.a.createElement(U.a, {
						author: t,
						className: Ae.a.authorLink
					}, "u/", t)), Number.isInteger(n) && i.a.createElement("li", {
						className: Ae.a.previewInfoItem
					}, r.fbt._({
						"*": "{number} points",
						_1: "1 point"
					}, [r.fbt._plural(n, "number")], {
						hk: "1nHdfa"
					})), Number.isInteger(s) && i.a.createElement("li", {
						className: Ae.a.previewInfoItem
					}, r.fbt._({
						"*": "{number} comments",
						_1: "1 comment"
					}, [r.fbt._plural(s, "number")], {
						hk: "1izKX9"
					})), o && i.a.createElement("li", {
						className: Ae.a.previewInfoItem
					}, i.a.createElement(Oe.d, {
						seconds: o / m.Xb
					})))
				},
				je = e => {
					let {
						action: t
					} = e;
					var n, s, r;
					const o = ee(t);
					return null === o ? null : i.a.createElement("article", {
						className: Ee.a.container,
						id: X(t)
					}, (null == o ? void 0 : o.title) && i.a.createElement("p", {
						className: Ee.a.title
					}, o.title), i.a.createElement("div", {
						className: Object(u.a)({
							[Ee.a.contentWrapperComment]: !!o.parent
						})
					}, (null == o ? void 0 : o.body) && i.a.createElement(ve, null, o.body), (null == o ? void 0 : o.thumbnail) && i.a.createElement(fe, {
						src: o.thumbnail
					}), i.a.createElement(ye, {
						author: null == o ? void 0 : o.author,
						score: null == o ? void 0 : o.score,
						commentCount: null == o ? void 0 : o.commentCount,
						createdAt: null == o ? void 0 : o.createdAt
					})), (null == o ? void 0 : o.parent) && i.a.createElement(ye, {
						score: null === (n = null == o ? void 0 : o.parent) || void 0 === n ? void 0 : n.score,
						commentCount: null === (s = null == o ? void 0 : o.parent) || void 0 === s ? void 0 : s.commentCount,
						createdAt: null === (r = null == o ? void 0 : o.parent) || void 0 === r ? void 0 : r.createdAt
					}))
				};
			var Ie = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/index.m.less"),
				ke = n.n(Ie);
			const _e = e => {
					const t = new Date(e * m.Xb);
					return w.a ? new Intl.DateTimeFormat("en-US", {
						hour: "numeric",
						minute: "numeric"
					}).format(t) : `${t.getHours()}:${t.getMinutes}`
				},
				Se = e => {
					var t;
					return (null == e ? void 0 : e.__typename) === M.c.AvailableRedditor ? null === (t = e.icon) || void 0 === t ? void 0 : t.url : void 0
				};
			var we = e => {
					let {
						action: t,
						actionsUnderCategory: n,
						subredditId: s,
						updateParams: a
					} = e;
					const [d, c] = Object(o.useState)(!1), l = (e => (null == e ? void 0 : e.__typename) === M.c.AvailableRedditor ? e.displayName : null)(t.moderatorInfo), u = !!l && !N.i.includes(l), p = Z(t), b = Object(o.useCallback)(e => a({
						actions: [e]
					}), [a]), f = Object(o.useCallback)(() => a({
						actions: n
					}), [a, n]);
					return i.a.createElement(i.a.Fragment, null, i.a.createElement("tr", {
						className: ke.a.row
					}, i.a.createElement("td", {
						className: ke.a.dateCell
					}, r.fbt._("{time} on {date}", [r.fbt._param("time", _e(t.createdAt / m.Xb)), r.fbt._param("date", i.a.createElement(T.a, {
						seconds: t.createdAt / m.Xb,
						showDay: !0,
						shortMonths: !0
					}))], {
						hk: "1YNruk"
					})), i.a.createElement("td", {
						className: ke.a.modCell
					}, l && u ? i.a.createElement(P.a, {
						className: ke.a.modNameAndIconContainer,
						username: l,
						iconClassName: ke.a.modNameAndIcon,
						iconSize: 24,
						userIcon: Se(t.moderatorInfo)
					}) : l), i.a.createElement("td", {
						className: ke.a.actionCategoryCell
					}, t.actionCategory && i.a.createElement(F.a, {
						category: t.actionCategory,
						onClick: f
					})), i.a.createElement("td", {
						className: ke.a.actionCell
					}, i.a.createElement(B, {
						action: t.action,
						onClick: b
					})), i.a.createElement("td", null, i.a.createElement(me, {
						action: t,
						subredditId: s,
						showTakedownPreview: d,
						toggleShowTakedownPreview: () => c(!d)
					}), p && !d && i.a.createElement(D.a, null, r.fbt._("No content preview shown. Press show details in previous cell to reveal.", null, {
						hk: "3OP9nc"
					})), !p && i.a.createElement(D.a, null, r.fbt._("No content preview available.", null, {
						hk: "4mp2x9"
					})))), p && d && i.a.createElement("tr", null, i.a.createElement("td", {
						colSpan: 5,
						className: ke.a.takedownContentPreview
					}, i.a.createElement(je, {
						action: t
					}))))
				},
				Te = n("./src/reddit/components/CCM/ModerationLog/PageLimit/index.m.less"),
				Pe = n.n(Te);
			var Ne = e => {
					const [t, n] = Object(o.useState)(e.limit || 50);
					e.limit && e.limit !== t && n(e.limit);
					const s = Object(o.useCallback)(t => {
							const s = parseInt(t.target.value, 10) || 50;
							n(s), e.onChange && e.onChange(s)
						}, [e]),
						a = e.max !== e.approximateMax,
						d = Math.max(t * e.pageNumber + 1, 1),
						c = a ? Math.min(d, e.max) : d,
						l = t * (e.pageNumber + 1),
						m = a ? Math.min(l, e.max) : l,
						p = `${e.max.toLocaleString()}${a?"":"+"}`;
					return i.a.createElement("label", {
						className: Object(u.a)(Pe.a.container, e.className)
					}, i.a.createElement("span", {
						className: Pe.a.limit
					}, r.fbt._("{Left page limit}{Right page limit} of {Max}", [r.fbt._param("Left page limit", c.toLocaleString()), r.fbt._param("Right page limit", m.toLocaleString()), r.fbt._param("Max", p)], {
						hk: "2bGsu9"
					})), e.availableLimits && i.a.createElement("select", {
						className: Pe.a.dropdown,
						onChange: s,
						value: t
					}, e.availableLimits.map((e, t) => i.a.createElement("option", {
						value: e,
						key: `${e}_${t}`
					}, e))))
				},
				De = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				Me = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				Re = n("./src/reddit/components/ModHub/PaginationButtons/index.tsx"),
				Le = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				Be = n("./src/reddit/constants/parameters.ts"),
				Fe = n("./src/reddit/contexts/PageLayer/index.tsx"),
				Ue = n("./src/reddit/helpers/trackers/modHub.ts"),
				He = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				Ge = n("./src/reddit/selectors/moderationLog.ts"),
				Qe = n("./src/reddit/components/CCM/ModerationLog/index.m.less"),
				qe = n.n(Qe),
				We = n("./src/reddit/components/ModInsightsEntrypointCard/assets/lightbulb.tsx");
			var ze = e => {
				let {
					className: t
				} = e;
				return i.a.createElement("svg", {
					width: "33",
					height: "32",
					viewBox: "0 0 33 32",
					fill: "none",
					xmlns: "http://www.w3.org/2000/svg",
					xmlnsXlink: "http://www.w3.org/1999/xlink"
				}, i.a.createElement("rect", {
					x: "0.333496",
					width: "32",
					height: "32",
					fill: "url(#patternHeart)"
				}), i.a.createElement("defs", null, i.a.createElement("pattern", {
					id: "patternHeart",
					patternContentUnits: "objectBoundingBox",
					width: "1",
					height: "1"
				}, i.a.createElement("use", {
					xlinkHref: "#image0_1105_104575",
					transform: "scale(0.00195312)"
				})), i.a.createElement("image", {
					id: "image0_1105_104575",
					width: "512",
					height: "512",
					xlinkHref: "data:image/png;base64,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"
				})))
			};
			var Ve = e => {
				let {
					className: t
				} = e;
				return i.a.createElement("svg", {
					width: "32",
					height: "32",
					viewBox: "0 0 32 32",
					fill: "none",
					xmlns: "http://www.w3.org/2000/svg",
					xmlnsXlink: "http://www.w3.org/1999/xlink"
				}, i.a.createElement("rect", {
					width: "32",
					height: "32",
					fill: "url(#patternstar)"
				}), i.a.createElement("defs", null, i.a.createElement("pattern", {
					id: "patternstar",
					patternContentUnits: "objectBoundingBox",
					width: "1",
					height: "1"
				}, i.a.createElement("use", {
					xlinkHref: "#image0_1105_104574",
					transform: "scale(0.00195312)"
				})), i.a.createElement("image", {
					id: "image0_1105_104574",
					width: "512",
					height: "512",
					xlinkHref: "data:image/png;base64,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"
				})))
			};
			const Ke = "bg-neutral-background-strong flex p-md items-center border-sm border-neutral-border border-solid rounded-[0.5rem] w-100",
				Ye = "text-neutral-content-strong font-semibold leading-4";
			var Je = e => {
				let {
					subredditName: t,
					data: n,
					onClick: s
				} = e;
				var o, a, d, c, l, m, p, b, f, h, g, v, x, E, O, C, A;
				return i.a.createElement("div", {
					className: "flex w-100 pb-lg"
				}, i.a.createElement("div", {
					className: Ke
				}, i.a.createElement("span", {
					className: "flex justify-center mr-md"
				}, i.a.createElement(Ve, {
					className: ""
				})), i.a.createElement("span", {
					className: "w-full"
				}, i.a.createElement("div", {
					className: Ye
				}, r.fbt._("You completed {mod actions performed by user} mod actions this month", [r.fbt._param("mod actions performed by user", (null === (a = null === (o = null == n ? void 0 : n.myModActionCount) || void 0 === o ? void 0 : o.approximateCount) || void 0 === a ? void 0 : a.toString()) || "-")], {
					hk: "1mLErK"
				})), i.a.createElement("div", {
					className: "mt-2xs leading-[14px] text-12"
				}, r.fbt._("{number of items approved and removed} items approved, {removed post count} items removed.", [r.fbt._param("number of items approved and removed", (null === (c = null === (d = null == n ? void 0 : n.myApproveCount) || void 0 === d ? void 0 : d.approximateCount) || void 0 === c ? void 0 : c.toString()) || "-"), r.fbt._param("removed post count", (null === (m = null === (l = null == n ? void 0 : n.myRemoveCount) || void 0 === l ? void 0 : l.approximateCount) || void 0 === m ? void 0 : m.toString()) || "-")], {
					hk: "13qPNC"
				}), " ", i.a.createElement("a", {
					className: "text-primary",
					href: `/mod/${t}/insights/team_health`,
					target: "_blank",
					rel: "noopener noreferrer",
					onClick: s
				}, r.fbt._("See your teams health.", null, {
					hk: "2IlCTq"
				}))))), i.a.createElement("div", {
					className: Object(u.a)(Ke, "mx-md")
				}, i.a.createElement("span", {
					className: "flex justify-center mr-md"
				}, i.a.createElement(ze, {
					className: ""
				}), " "), i.a.createElement("span", {
					className: "w-full"
				}, i.a.createElement("div", {
					className: Ye
				}, r.fbt._("{number of active mods} moderators were active this week", [r.fbt._param("number of active mods", (null === (f = null === (b = null === (p = null == n ? void 0 : n.modInsights) || void 0 === p ? void 0 : p.teamActivity) || void 0 === b ? void 0 : b.activeModCount) || void 0 === f ? void 0 : f.toString()) || "-")], {
					hk: "1dUjap"
				})), i.a.createElement("div", {
					className: "mt-2xs leading-[14px] text-12"
				}, r.fbt._("An active moderator is a mod who took 1 mod action or more for the corresponding time frame.", null, {
					hk: "3LjExD"
				})))), i.a.createElement("div", {
					className: Ke
				}, i.a.createElement("span", {
					className: "flex justify-center mr-md"
				}, i.a.createElement(We.a, {
					className: ""
				}), " "), i.a.createElement("span", {
					className: "w-full"
				}, i.a.createElement("div", {
					className: Ye
				}, r.fbt._("Received {modmail messages count} modmail messages", [r.fbt._param("modmail messages count", (null === (x = null === (v = null === (g = null === (h = null == n ? void 0 : n.modInsights) || void 0 === h ? void 0 : h.modmailWeek) || void 0 === g ? void 0 : g.modmailReceived) || void 0 === v ? void 0 : v.metric) || void 0 === x ? void 0 : x.toString()) || "-")], {
					hk: "3KWHlm"
				})), i.a.createElement("div", {
					className: "mt-2xs leading-[14px] text-12"
				}, r.fbt._("Your team averages about {modmail messages received} messages received in 30 days.", [r.fbt._param("modmail messages received", (null === (A = null === (C = null === (O = null === (E = null == n ? void 0 : n.modInsights) || void 0 === E ? void 0 : E.modmailMonth) || void 0 === O ? void 0 : O.modmailReceived) || void 0 === C ? void 0 : C.metric) || void 0 === A ? void 0 : A.toString()) || "-")], {
					hk: "3QHORJ"
				})))))
			};
			const Xe = Object(Fe.v)({
					currentPageUrl: Fe.f,
					queryParams: Fe.Z
				}),
				Ze = e => new Date(e).toISOString().slice(0, 10);
			t.a = Xe(e => {
				const t = Object(c.a)(),
					{
						currentPageUrl: n,
						queryParams: h,
						subreddit: E,
						subredditId: C
					} = e,
					w = Object(a.d)(),
					T = Object(a.e)(t => Object(Ge.c)(t, e)),
					P = Object(a.e)(e => Object(Ge.e)(e)),
					N = Object(a.e)(e => Object(Ge.d)(e)),
					D = Object(a.e)(t => Object(Ge.f)(t, e)),
					M = Object(a.e)(t => Object(Ge.g)(t, e)),
					R = Object(a.e)(e => Object(Ge.h)(e)),
					L = Object(a.e)(e => Object(Ge.b)(e)),
					B = Object(a.e)(e => e);
				Object(o.useEffect)(() => {
					w((e => async (t, n, s) => {
						let {
							gqlContext: r
						} = s;
						const o = n(),
							i = Object(x.I)(o, e);
						if (o.pages.modHub.moderationLog.moderators[i]) return;
						const a = await Object(g.c)(r(), e);
						if (a.body) {
							const e = a.body.data.subreddit.moderators;
							if (e) {
								const n = Object(v.a)(e);
								t(O({
									normalizedModerators: n,
									subredditId: i
								}))
							}
						}
					})(E.name))
				}, [w, E.name]), Object(o.useEffect)(() => {
					w((() => async (e, t, n) => {
						let {
							gqlContext: s
						} = n;
						const r = t();
						if (!A()(r.pages.modHub.moderationLog.actionCategories)) return;
						const o = await Object(g.a)(s());
						if (o.body) {
							const t = o.body.data.moderationActionCategories;
							if (t) {
								const n = (e => e.reduce((e, t) => ({
									...e,
									[t.category]: t.actions
								}), {}))(t);
								e(y({
									normalizedCategories: n
								}))
							}
						}
					})())
				}, [w]);
				const F = Object(o.useCallback)(e => w(Object(d.b)(e)), [w]),
					U = Object(o.useCallback)(() => t(Object(f.k)()), [t]),
					H = Object(a.e)(e => Object(He.a)(e, !0)),
					G = Object(a.e)(e => {
						var t, n, s, r, o, i;
						return H && (null === (s = null === (n = null === (t = e.pages) || void 0 === t ? void 0 : t.modHub) || void 0 === n ? void 0 : n.moderationLog) || void 0 === s ? void 0 : s.insightsEntrypoint) ? null === (i = null === (o = null === (r = e.pages) || void 0 === r ? void 0 : r.modHub) || void 0 === o ? void 0 : o.moderationLog) || void 0 === i ? void 0 : i.insightsEntrypoint[E.id] : null
					}),
					Q = Object(o.useCallback)(() => {
						t(Object(Ue.d)({
							source: "moderator",
							action: "click",
							noun: "embedded_insights_team_health",
							paneName: void 0
						}))
					}, [t]),
					q = ((e, t, n) => {
						const s = Object(b.b)(e, t, n);
						return s[Be.u] = parseInt(t[Be.u], 10) || 0, s[Be.J] = t[Be.J], s
					})(E.name, h, B),
					W = q.pageNumber || 0,
					z = Object(o.useCallback)(e => {
						const t = {
								...q,
								last: void 0,
								before: void 0,
								after: void 0,
								pageNumber: 0,
								first: q.last || q.first || b.a,
								...e
							},
							s = Object.keys(t).reduce((e, n) => ({
								...e,
								[n]: Array.isArray(t[n]) ? t[n].join(",") : t[n]
							}), {});
						return Object(l.a)(Object(p.a)(n), s)
					}, [n, q]),
					V = Object(o.useCallback)(e => {
						const t = z(e);
						F(t)
					}, [F, z]),
					K = {
						pageNumber: W > 0 ? W - 1 : 0,
						before: R || void 0,
						first: void 0,
						last: q.last || q.first || b.a,
						after: void 0
					},
					Y = {
						pageNumber: W + 1,
						after: P || void 0,
						before: void 0,
						last: void 0,
						first: q.last || q.first || b.a
					},
					J = e => V(e),
					X = Object(o.useCallback)(e => {
						V({
							last: void 0,
							before: void 0,
							after: void 0,
							first: e,
							pageNumber: 0
						}), t(Object(f.l)())
					}, [V, t]),
					Z = !T.length,
					$ = Ze(Date.now() - 90 * m.D),
					ee = Ze(Date.now()),
					te = q.startDate ? q.startDate : $,
					ne = q.endDate ? q.endDate : ee;
				return i.a.createElement(Le.a, {
					className: qe.a.contentContainer
				}, i.a.createElement(Le.b, null, r.fbt._("Mod Log", null, {
					hk: "2wnuzj"
				}), i.a.createElement(Me.a, {
					onClick: U,
					linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360022402312`
				})), H && i.a.createElement(Je, {
					subredditName: E.name,
					data: G,
					onClick: Q
				}), i.a.createElement("span", {
					className: qe.a.title
				}, r.fbt._("Filter by", null, {
					hk: "3RkGvd"
				})), i.a.createElement("div", {
					className: qe.a.controlRow
				}, i.a.createElement("div", {
					className: qe.a.filters
				}, i.a.createElement(I.a, {
					shouldShowDefaultTitle: !q.startDate && !q.endDate,
					startDate: te,
					endDate: ne,
					maxDate: ee,
					minDate: $,
					onApply: J
				}), i.a.createElement(k.a, {
					moderatorNames: "string" == typeof q.moderatorNames ? [q.moderatorNames] : q.moderatorNames,
					onApply: J,
					subredditId: C
				}), i.a.createElement(j.a, {
					actions: "string" == typeof q.actions ? [q.actions] : q.actions,
					onApply: J
				}), i.a.createElement(S.a, {
					userName: q.userName,
					onApply: e => V({
						targetAuthorIds: e.userId ? [e.userId] : void 0,
						userName: e.userName
					})
				}), i.a.createElement(_.a, {
					postUrls: "string" == typeof q.postUrls ? [q.postUrls] : q.postUrls,
					onApply: J
				})), i.a.createElement("div", {
					className: qe.a.paging
				}, !!N && i.a.createElement(Ne, {
					approximateMax: 5e3,
					availableLimits: [25, 50, 100, 500],
					className: qe.a.pageLimit,
					limit: q.first || q.last,
					max: N,
					pageNumber: W,
					onChange: X
				}), i.a.createElement(Re.a, {
					prevButtonEnabled: M,
					prevTo: z(K),
					nextButtonEnabled: D,
					nextTo: z(Y),
					keepDisabled: !0
				}))), Z && i.a.createElement(De.c, {
					className: qe.a.emptyPanel,
					text: r.fbt._("No mod actions found", null, {
						hk: "y2pGb"
					})
				}, i.a.createElement("img", {
					src: `${s.a.assetPath}/img/snoomoji/snoo_thoughtful.png`,
					className: qe.a.emptyIcon
				})), !Z && i.a.createElement("table", {
					className: Object(u.a)(qe.a.table, {
						[qe.a.inModNavExperiment]: H
					})
				}, i.a.createElement("thead", null, i.a.createElement("tr", null, i.a.createElement("th", null, r.fbt._("Time", null, {
					hk: "4bvCKA"
				})), i.a.createElement("th", null, r.fbt._("Moderator", null, {
					hk: "2krNIi"
				})), i.a.createElement("th", null, r.fbt._("Type", null, {
					hk: "334ba7"
				})), i.a.createElement("th", null, r.fbt._("Action", null, {
					hk: "1rF6TH"
				})), i.a.createElement("th", null, r.fbt._("Details", null, {
					hk: "41wdQs"
				})))), i.a.createElement("tbody", null, T.map(e => i.a.createElement(we, {
					key: e.id,
					action: e,
					actionsUnderCategory: e.actionCategory ? L[e.actionCategory] : [],
					subredditId: C,
					updateParams: V
				})))))
			})
		},
		"./src/reddit/components/CallToActionButton/index.m.less": function(e, t, n) {
			e.exports = {
				CallToActionButton: "_2pjSQOdNtYd1I2W0Z1Im8I",
				callToActionButton: "_2pjSQOdNtYd1I2W0Z1Im8I",
				ctaExperiment: "O3tUaKrd54EXILNilEqF_",
				Icon: "_2W1YFyYH_CTGX4_5OEBs2Q",
				icon: "_2W1YFyYH_CTGX4_5OEBs2Q",
				isLeft: "p8bIdnQ5pQUQRETAyCoa5",
				isRight: "_36ucS75syCWwJ_ee7IieXZ",
				active: "NPw0Z_HL-yJPXnZ3mpWEA",
				redditStyle: "OGOshepc50ul-kJHrocIO",
				rplStyle: "_2sQjgE-zw2MQovQiJwdvVD",
				mNotCardView: "_33VrFkg3gJpkL8AlPfcHUE"
			}
		},
		"./src/reddit/components/CallToActionButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/OutboundLink/index.tsx"),
				a = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				d = n("./src/reddit/components/CallToActionButton/index.m.less"),
				c = n.n(d);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				let {
					className: t,
					showCTAExperiment: n,
					...s
				} = e;
				return r.a.createElement(i.b, l({
					className: Object(o.a)(c.a.CallToActionButton, t, {
						[c.a.mNotCardView]: s.isNotCardView,
						[c.a.ctaExperiment]: !!n
					}),
					"data-adclicklocation": a.a.CTA_BUTTON
				}, s))
			}
		},
		"./src/reddit/components/CharacterCountdown/index.m.less": function(e, t, n) {
			e.exports = {
				container: "s5ap8yh1b4ZfwxvHizW3f",
				mOverflow: "_19JhaP1slDQqu2XgT3vVS0"
			}
		},
		"./src/reddit/components/CharacterCountdown/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/StructuredStyles/StyledComponents/forms.ts"),
				a = n("./src/reddit/components/CharacterCountdown/index.m.less"),
				d = n.n(a);
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = e => r.a.createElement(i.b, {
				className: Object(o.a)(e.className, d.a.container, e.text.length >= e.maxChars ? d.a.mOverflow : null)
			}, c._({
				"*": "{characters} Characters remaining",
				_1: "1 Character remaining"
			}, [c._plural(e.maxChars - e.text.length, "characters")], {
				hk: "V22sW"
			}))
		},
		"./src/reddit/components/ChatButton/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var s, r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/actions/chat/toggle.ts"),
				d = n("./src/reddit/components/TrackingHelper/index.tsx"),
				c = n("./src/reddit/controls/Button/index.tsx"),
				l = n("./src/reddit/helpers/trackers/authorHovercard.ts");
			! function(e) {
				e.awardNotification = "AWARD_NOTIFICATION"
			}(s || (s = {}));
			const u = e => {
				let {
					onStartChat: t,
					text: n,
					className: r,
					sendEvent: i,
					contextId: a,
					priority: d,
					Icon: u,
					redditStyle: m,
					isFullWidth: p,
					eventSource: b,
					onClick: f,
					onAddUserToQuickReplyList: h,
					children: g,
					style: v,
					pageType: x,
					userId: E
				} = e;
				return o.a.createElement(c.t, {
					onClick: e => {
						if (f && f(e), t(x), b === s.awardNotification) return h();
						i(Object(l.b)(a))
					},
					className: r,
					text: n,
					priority: d,
					Icon: u,
					redditStyle: m,
					isFullWidth: p,
					style: v
				}, g)
			};
			u.displayName = "ChatButton";
			const m = Object(i.b)(null, (e, t) => {
				let {
					contextId: n,
					userId: s
				} = t;
				return {
					onStartChat: t => {
						e(Object(a.b)(s, n, t))
					},
					onAddUserToQuickReplyList: () => {
						e(Object(a.a)(s))
					}
				}
			});
			t.b = m(Object(d.c)(u))
		},
		"./src/reddit/components/ClassicPost/Thumbnail.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/Thumbnail/index.tsx"),
				a = n("./src/reddit/components/ClassicPost/index.m.less"),
				d = n.n(a);
			t.a = e => {
				let {
					className: t,
					classNameInnerThumbnail: n,
					crosspost: s,
					forceShowNSFW: a,
					isMeta: c,
					post: l,
					redditStyle: u,
					removeLink: m,
					templatePlaceholderImage: p,
					thumbnailContainerClassName: b,
					url: f,
					usePreview: h
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(d.a.thumbnailContainer, t)
				}, r.a.createElement(i.b, {
					className: Object(o.a)(d.a.thumbnail, n),
					containerClassName: b,
					crosspost: s,
					forceShowNSFW: a,
					isMeta: c,
					post: l,
					redditStyle: u,
					removeLink: m,
					templatePlaceholderImage: p,
					url: m ? void 0 : f,
					usePreview: h
				}))
			}
		},
		"./src/reddit/components/ClassicPost/index.m.less": function(e, t, n) {
			e.exports = {
				adLinkWrapper: "_2c-0jMA2BuDIlKjWFiOUOt",
				ctaExperiment: "_17HI1sHAGvXEekFXNNcehn",
				classicThumbnail: "nL7Q54U2LLg9rkVdSxxLe",
				content: "_1Y6dfr4zLlrygH-FLmr8x-",
				showBulkActionCheckbox: "W-Z7cDkcZIo1dPic9COiN",
				flatlistContainer: "_36kpXQ-z7Hr61j8878uRkP",
				creatorStatsContainer: "_2I70Qhfz-GbGzP54PWXR3P",
				crosspostMediaWrapper: "_1qc1-Anfrhr6APGcBKFk8M",
				expandoContainer: "_3r40yytzBnldjGGOrs2mCw",
				flatlist: "ssgs3QQidkqeycI33hlBa",
				flatlistSeparator: "_1wDt70OnYnqsrm0XIsNn8v",
				horizontalVotes: "_3ytybPoFoY12sGn375PMy1",
				leftExpando: "_35zWJjb5RJMIMkexZ2Prus",
				mainBody: "_2XDITKxlj4y3M99thqyCsO",
				rightExpando: "_2Ddj1d6vOe9NlJqkdothNe",
				spacer: "iRkLLvxarfGu_2c7HxhW0",
				titleWithPoll: "_2FcpdQwjwRwk7X_NiZub8x",
				thumbnail: "_2e9Lv1I3dOmICVO9fg3uTG",
				thumbnailContainer: "_38EcSQ9jzVrdtzkXO1cydX",
				eventMeta: "rmPDRyja27ULjwD3rW14H",
				postContainer: "D3IyhBGwXo9jPwz-Ka0Ve",
				shouldShowOverflow: "_3FOlcZoWAvyAWZYSVd8-WD",
				shouldUseRoundedBorder: "_2g8Jz2obQVOELSfntlgVsJ",
				promotedMainBody: "_1LAkIKOirJP5Hor0NamqyY"
			}
		},
		"./src/reddit/components/CommentSort/CommentSort.m.less": function(e, t, n) {
			e.exports = {
				container: "_2ulKn_zs7Y3LWsOqoFLHPo",
				mHasOtherDiscussions: "_3iO3U_i4YUx-2qahK_BTu1",
				HighlightPicker: "_1n6gZPmNQU56UBglU718cx",
				highlightPicker: "_1n6gZPmNQU56UBglU718cx",
				Row: "zW82EsY6Pakxpq4WWvsUG",
				row: "zW82EsY6Pakxpq4WWvsUG",
				SortPicker: "_1nMYOibX9neGRqvcaCrPDz",
				sortPicker: "_1nMYOibX9neGRqvcaCrPDz",
				containerRow: "_1avwNy0RnwlEwVEW-fwKCI",
				DropdownContainer: "_3N0NZT0gc58Hq7p0XRUjsH",
				dropdownContainer: "_3N0NZT0gc58Hq7p0XRUjsH",
				ContestMode: "_3dAMO_XZMVp2K1JSO53ohA",
				contestMode: "_3dAMO_XZMVp2K1JSO53ohA",
				SortOptionDropdownText: "_3LRBCA71BwLLXBNsSlY7HW",
				sortOptionDropdownText: "_3LRBCA71BwLLXBNsSlY7HW",
				commentSearchMargin: "_2_QzTCgd5SYB-X8CTqZf9T",
				ToggleSwitch: "JVPG0c9TNru5TLSq9sdUG",
				toggleSwitch: "JVPG0c9TNru5TLSq9sdUG",
				DropdownTriangle: "_2MGxQvIhmM2I5CzPdSJTtM",
				dropdownTriangle: "_2MGxQvIhmM2I5CzPdSJTtM",
				hideCommentSort: "uAIheeoxWlq57lu5ghv43",
				HighlightWrapper: "_201SpO3todaXvcWUHaLymN",
				highlightWrapper: "_201SpO3todaXvcWUHaLymN",
				Info: "_1urK6AxAk9Sl76RgLUHOqh",
				info: "_1urK6AxAk9Sl76RgLUHOqh",
				paddingBottom: "_233thT4kQqtwrHDoMY0Dbv",
				SetSort: "_1Pn7_008tGFVitpaAxNI9b",
				setSort: "_1Pn7_008tGFVitpaAxNI9b",
				SingleCommentText: "_2iOrDLLjWlyPdmGh4fQMuE",
				singleCommentText: "_2iOrDLLjWlyPdmGh4fQMuE",
				SortLink: "_2C0TYCrsi0B3m8sQW0hmFv",
				sortLink: "_2C0TYCrsi0B3m8sQW0hmFv",
				Title: "_1MfL8RlT7Bsr76qYvR-nqM",
				title: "_1MfL8RlT7Bsr76qYvR-nqM",
				Tooltip: "_2PA6P-upB6MB4B4I4WgZGA",
				tooltip: "_2PA6P-upB6MB4B4I4WgZGA",
				ViewFullLinkContainer: "_2Cjk95J3a3LyPUHsLEhO37",
				viewFullLinkContainer: "_2Cjk95J3a3LyPUHsLEhO37",
				ViewFullLinkOrOverlayLink: "_3P3T6fdpdL6GGPyCM7zs9q",
				viewFullLinkOrOverlayLink: "_3P3T6fdpdL6GGPyCM7zs9q",
				verticalDivider: "_3v-KNQB_UvJqSbWcQZmc0U"
			}
		},
		"./src/reddit/components/CommentSort/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return $
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/actions/comment/index.ts"),
				m = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/actions/post.ts"),
				b = n("./src/reddit/actions/toaster.ts"),
				f = n("./src/lib/makeApiRequest/index.ts"),
				h = n("./src/lib/omitHeaders/index.ts"),
				g = n("./src/reddit/constants/headers.ts"),
				v = n("./src/reddit/models/Toast/index.ts");
			const x = (e, t) => async (n, r, o) => {
				let {
					apiContext: i
				} = o;
				const a = await (async (e, t, n) => Object(f.a)(Object(h.a)(e, [g.a]), {
						endpoint: `${e.apiUrl}/api/set_suggested_sort/`,
						method: c.ob.POST,
						data: {
							api_type: "json",
							id: t,
							sort: n
						}
					}))(i(), e, t),
					d = `error-block-${t}`,
					l = `success-block-${t}`;
				if (a.ok) {
					n(Object(p.Q)({
						[e]: {
							suggestedSort: t
						}
					}));
					const r = t ? s.fbt._("Suggested sort is on.", null, {
						hk: "tW1Rb"
					}) : s.fbt._("Suggested sort is off.", null, {
						hk: "4fwvgj"
					});
					n(b.f({
						id: l,
						kind: v.b.SuccessCommunityGreen,
						text: r
					}))
				} else n(b.f({
					id: d,
					kind: v.b.Error,
					text: s.fbt._("Try again later", null, {
						hk: "1Lqlj2"
					}),
					buttonText: s.fbt._("Retry", null, {
						hk: "44HF9e"
					}),
					buttonAction: x(e, t)
				}))
			};
			var E = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				O = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				C = n("./src/reddit/components/LinkOrOverlayLink/index.tsx"),
				A = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				y = n("./src/reddit/components/SearchResultsContent/helpers/isCommentSearchRoute.ts"),
				j = n("./src/reddit/components/TrackingHelper/index.tsx"),
				I = n("./src/reddit/contexts/PageLayer/index.tsx"),
				k = n("./src/reddit/controls/Dropdown/index.tsx"),
				_ = n("./src/reddit/controls/Dropdown/Row.tsx"),
				S = n("./src/reddit/controls/Search/CommentSearch/index.tsx"),
				w = n("./src/reddit/controls/ToggleSwitch/index.tsx"),
				T = n("./src/reddit/helpers/path/index.ts"),
				P = n("./src/reddit/selectors/telemetry.ts");
			n("./src/telemetry/models/Event.ts");
			const N = (e, t, n, s, r) => o => ({
					source: "comment_sort",
					action: "click",
					noun: e,
					actionInfo: {
						pageType: t ? "post_detail" : "home"
					},
					listing: Object(P.A)(o, void 0, {
						oldSort: n,
						sort: s,
						source: r
					}),
					userSubreddit: Object(P.vb)(o)
				}),
				D = (e, t) => n => ({
					source: "comment_highlighting",
					action: t,
					noun: e
				}),
				M = e => ({
					subreddit: Object(P.mb)(e),
					userSubreddit: Object(P.vb)(e)
				}),
				R = e => t => ({
					source: "contest_mode",
					action: "click",
					noun: e ? "enable" : "disable",
					...M
				});
			var L = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				B = n("./src/reddit/icons/svgs/Info/index.tsx"),
				F = n("./src/reddit/selectors/activeModalId.ts"),
				U = n("./src/reddit/selectors/comments.ts"),
				H = n("./src/reddit/selectors/experiments/commentSearchPdp.ts"),
				G = n("./src/reddit/selectors/moderatorPermissions.ts"),
				Q = n("./src/reddit/selectors/posts.ts"),
				q = n("./src/reddit/selectors/tooltip.ts"),
				W = n("./src/reddit/selectors/user.ts"),
				z = n("./src/reddit/components/CommentSort/CommentSort.m.less"),
				V = n.n(z),
				K = n("./src/reddit/reducers/features/comments/visitHighlightingFilter/index.ts");
			const Y = Object(A.a)(k.a),
				J = e => e === K.a.First ? s.fbt._("First Visit", null, {
					hk: "HdDSr"
				}) : e === K.a.Last ? s.fbt._("Last Visit", null, {
					hk: "3ubIq3"
				}) : s.fbt._("None", null, {
					hk: "4jwXNg"
				});
			class X extends o.a.Component {
				constructor() {
					super(...arguments), this.track = () => {
						const {
							trackHighlight: e,
							selectedSort: t
						} = this.props;
						if (t !== K.a.None) {
							e(t === K.a.Last ? "since_last_visit" : "since_first_visit", "view")
						}
					}, this.onDropdownClick = (e, t) => {
						this.props.trackHighlight(e, "click"), this.props.changeHighlightSort(t)
					}, this.onDropdownClickFirst = () => {
						this.onDropdownClick("since_first_visit", K.a.First)
					}, this.onDropdownClickLast = () => {
						this.onDropdownClick("since_last_visit", K.a.Last)
					}, this.onDropdownClickNone = () => {
						this.onDropdownClick("do_not_highlight", K.a.None)
					}
				}
				componentDidMount() {
					this.track()
				}
				componentDidUpdate(e) {
					e.selectedSort !== this.props.selectedSort && this.track()
				}
				render() {
					const {
						highlightIsOpen: e,
						id: t,
						onOpen: n,
						selectedSort: r
					} = this.props;
					return o.a.createElement("div", {
						className: V.a.HighlightWrapper
					}, o.a.createElement(_.b, {
						className: Object(d.a)(V.a.HighlightPicker, V.a.Row),
						textClassName: V.a.SortOptionDropdownText,
						displayText: `${s.fbt._("Highlight",null,{hk:"2ZiUE8"})}: ${J(r)}`,
						id: t,
						noHover: !0,
						onClick: n
					}), o.a.createElement(L.b, {
						className: V.a.DropdownTriangle,
						onClick: n
					}), o.a.createElement(Y, {
						isOpen: e,
						renderContentsHidden: !0,
						tooltipId: t
					}, o.a.createElement(_.b, {
						displayText: J(K.a.First),
						isSelected: r === K.a.First,
						onClick: this.onDropdownClickFirst
					}), o.a.createElement(_.b, {
						displayText: J(K.a.Last),
						isSelected: r === K.a.Last,
						onClick: this.onDropdownClickLast
					}), o.a.createElement(_.b, {
						displayText: J(K.a.None),
						isSelected: r === K.a.None,
						onClick: this.onDropdownClickNone
					})))
				}
			}
			var Z = X;
			const $ = "CommentSort--SortPicker",
				ee = "CommentSort--HighlightPicker",
				te = "CommentSort--Tooltip",
				ne = Object(A.a)(k.a),
				se = Object(I.v)(),
				re = Object(a.c)({
					commentPermalink: (e, t) => {
						let {
							commentId: n
						} = t;
						return n && Object(U.m)(e, {
							commentId: n
						})
					},
					commentSearchPdp: e => Object(H.a)(e),
					contestModeModalIsOpen: Object(F.b)("CommentSort--ContestMode--Modal"),
					dropdownIsOpen: Object(q.b)($),
					highlightIsOpen: Object(q.b)(ee),
					hasModeratorPostPermissions: (e, t) => {
						let {
							postId: n
						} = t;
						const s = Object(G.m)(e, {
							postId: n
						});
						return !!s && s.posts
					},
					post: Q.F,
					postPermalink: Q.E,
					showCommentHighlighter: (e, t) => {
						let {
							postId: n
						} = t;
						const s = Object(W.x)(e),
							r = !!Object(G.m)(e, {
								postId: n
							}),
							o = Object(Q.F)(e, {
								postId: n
							});
						return (r || s) && !!o && !!o.previousVisits && o.previousVisits.length > 0
					},
					selectedHighlightSort: U.p
				}),
				oe = Object(i.b)(re, (e, t) => {
					let {
						postId: n
					} = t;
					return {
						changeHighlightSort: t => e(Object(u.b)({
							sort: t
						})),
						onOpenDropdown: () => e(Object(l.h)({
							tooltipId: $
						})),
						onOpenHighlightDropdown: t => {
							e(Object(l.h)({
								tooltipId: ee
							})), t()
						},
						onSetSuggestedSort: t => e(x(n, t)),
						hideTooltip: () => e(Object(l.i)()),
						setContestMode: t => e(Object(p.V)(t, n)),
						showTooltip: () => e(Object(l.h)({
							tooltipId: te
						})),
						toggleContestModeModal: () => e(Object(m.i)("CommentSort--ContestMode--Modal"))
					}
				});
			class ie extends o.a.Component {
				constructor() {
					super(...arguments), this.tooltipTargetElement = null, this.sendCommentSortEvent = (e, t, n, s) => this.props.sendEvent(N(e, this.props.isOverlay, t, n, s)), this.onOpenDropdownClick = () => {
						this.props.onOpenDropdown(), this.sendCommentSortEvent("sorting", void 0, this.props.sort, "post_detail")
					}, this.onSortOptionClick = e => this.sendCommentSortEvent("sort_by", this.props.sort, e, "post_detail"), this.clearSortOnClick = () => {
						this.props.onSetSuggestedSort(null), this.sendCommentSortEvent("clear_suggested_sort", this.props.sort)
					}, this.setSortOnClick = () => {
						const e = this.props.suggestedSort || void 0;
						this.props.onSetSuggestedSort(this.props.sort), this.sendCommentSortEvent("set_suggested_sort", e, this.props.sort)
					}, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onOpenHighlightSelector = () => {
						this.props.onOpenHighlightDropdown(D("dropdown", "click"))
					}, this.setContestMode = () => {
						this.props.sendEvent(R(!this.props.post.contestMode)), this.props.setContestMode(!this.props.post.contestMode)
					}
				}
				addSuggestedLabel(e) {
					return s.fbt._("{sort name} (suggested)", [s.fbt._param("sort name", e)], {
						hk: "3pDfQ9"
					})
				}
				render() {
					var e;
					const {
						changeHighlightSort: t,
						className: n,
						commentId: r,
						commentPermalink: i,
						commentSearchPdp: a,
						contestModeModalIsOpen: l,
						dropdownIsOpen: u,
						elementRef: m,
						hideTooltip: p,
						highlightIsOpen: b,
						hasModeratorPostPermissions: f,
						isOverlay: h,
						location: g,
						pageLayer: v,
						post: x,
						postPermalink: A,
						selectedHighlightSort: j,
						showCommentHighlighter: I,
						sort: k,
						suggestedSort: P,
						showTooltip: N,
						toggleContestModeModal: M
					} = this.props, R = x.contestMode, F = null == r, U = a.bucketed && Object(y.a)(v) && Object(y.b)(x), H = a.bucketed && Object(y.b)(x) && F, G = !(null === (e = g.search) || void 0 === e ? void 0 : e.includes(c.v.CONFIDENCE)), Q = k === c.v.CONFIDENCE && G, q = f && !Q, W = c.x[k], z = W ? W() : "", K = P && k === P && !Q ? this.addSuggestedLabel(z) : z, Y = R ? s.fbt._("End contest mode?", null, {
						hk: "2AkJRZ"
					}) : s.fbt._("Start contest?", null, {
						hk: "2PQPOu"
					}), J = R ? s.fbt._("End", null, {
						hk: "1Q8KqM"
					}) : s.fbt._("Start", null, {
						hk: "Mjvpj"
					}), X = R ? s.fbt._("Ending contest mode will make comment vote scores visible and disable random comment ordering.", null, {
						hk: "3PXrGq"
					}) : s.fbt._("Starting a contest will hide comment vote scores and randomize the order of the comments for non-mods.", null, {
						hk: "EDqlf"
					}), se = R && !f, re = o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						className: V.a.DropdownContainer
					}, o.a.createElement(_.b, {
						className: Object(d.a)(V.a.SortPicker, V.a.Row),
						textClassName: V.a.SortOptionDropdownText,
						displayText: `${s.fbt._("Sort by",null,{hk:"E6T9r"})}: ${K}`,
						id: $,
						noHover: !0,
						skipRoleAttr: !0,
						onClick: this.onOpenDropdownClick
					}), o.a.createElement(L.b, {
						className: V.a.DropdownTriangle,
						onClick: this.onOpenDropdownClick
					})), o.a.createElement(ne, {
						isOpen: u,
						tooltipId: $
					}, [c.v.CONFIDENCE, c.v.TOP, c.v.NEW, c.v.CONTROVERSIAL, c.v.OLD, c.v.QA].map(e => {
						const t = i || A,
							n = Object(T.b)(t),
							s = c.x[e],
							r = s ? s() : "";
						return o.a.createElement(C.a, {
							className: V.a.ViewFullLinkOrOverlayLink,
							isOverlay: h,
							key: e,
							onClick: () => this.onSortOptionClick(e),
							role: "menuitem",
							tabIndex: -1,
							to: `${n}?sort=${e}`
						}, o.a.createElement(_.b, {
							displayText: r,
							isSelected: k === e,
							skipRoleAttr: !0
						}))
					})));
					return o.a.createElement("div", {
						className: Object(d.a)(n, V.a.container, {
							[V.a.hideCommentSort]: !I && se,
							[V.a.paddingBottom]: U
						}),
						ref: m
					}, o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						className: V.a.containerRow
					}, !se && !U && re, q && !se && !U && (P ? o.a.createElement("button", {
						className: V.a.SortLink,
						onClick: k !== P ? this.setSortOnClick : this.clearSortOnClick
					}, k !== P ? s.fbt._("Set new suggested sort", null, {
						hk: "13BpoB"
					}) : s.fbt._("Clear suggested sort", null, {
						hk: "3WWQBy"
					})) : o.a.createElement("button", {
						className: V.a.SetSort
					}, o.a.createElement("button", {
						className: V.a.SortLink,
						onClick: this.setSortOnClick
					}, s.fbt._("Set as suggested sort", null, {
						hk: "3qLzxp"
					})), o.a.createElement("span", {
						id: te,
						onMouseEnter: N,
						onMouseLeave: p
					}, o.a.createElement(O.c, {
						className: V.a.Tooltip,
						text: s.fbt._("Suggested sort defaults Redditors to a specific way of sorting comments within this post", null, {
							hk: "3KM0ma"
						}),
						tooltipId: te
					}), o.a.createElement(B.a, {
						className: V.a.Info
					})))), f && o.a.createElement("button", {
						className: Object(d.a)(V.a.ContestMode, U && V.a.commentSearchMargin),
						onClick: this.props.toggleContestModeModal
					}, s.fbt._("Contest", null, {
						hk: "1KrhdJ"
					}), o.a.createElement(w.a, {
						className: V.a.ToggleSwitch,
						on: R
					})), U || H ? o.a.createElement("div", {
						className: V.a.containerRow
					}, !U && o.a.createElement(o.a.Fragment, null, o.a.createElement("span", {
						className: V.a.verticalDivider
					}, "|")), o.a.createElement("div", null, o.a.createElement(S.c, {
						experiment: a,
						commentId: r,
						prevLocation: g,
						postId: this.props.postId
					}))) : null), I && o.a.createElement("div", {
						className: V.a.containerRow
					}, o.a.createElement(Z, {
						changeHighlightSort: t,
						highlightIsOpen: b,
						id: ee,
						onOpen: this.onOpenHighlightSelector,
						selectedSort: j,
						trackHighlight: D
					})), l && o.a.createElement(E.a, {
						actionText: J,
						headerText: Y,
						modalText: X,
						onConfirm: this.setContestMode,
						toggleModal: M,
						withOverlay: !0
					})))
				}
			}
			t.b = se(oe(Object(j.c)(ie)))
		},
		"./src/reddit/components/Comments/Comment/ModToolsFlatlist/RestrictedButton.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				o = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.m.less"),
				i = n.n(o);
			const a = s.a.wrapped(r.c, "RestrictedButton", i.a);
			t.a = a
		},
		"./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.m.less": function(e, t, n) {
			e.exports = {
				RestrictedButton: "_1HjNIJegwQhOyUoxHZNWnm",
				restrictedButton: "_1HjNIJegwQhOyUoxHZNWnm",
				Show: "YoaDbMbI8PpFFWQbD_Uwq",
				show: "YoaDbMbI8PpFFWQbD_Uwq",
				CommentModToolsFlatlist: "_3cJNzWW-kTTUFiqoBkRMRk",
				commentModToolsFlatlist: "_3cJNzWW-kTTUFiqoBkRMRk"
			}
		},
		"./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/lib/lessComponent.tsx"),
				u = n("./src/reddit/actions/comment/moderation.ts"),
				m = n("./src/reddit/actions/tooltip.ts"),
				p = n("./src/reddit/components/ModModeReports/helpers.ts"),
				b = n("./src/reddit/components/TrackingHelper/index.tsx"),
				f = n("./src/reddit/contexts/PageLayer/index.tsx"),
				h = n("./src/reddit/helpers/trackers/modTools.ts"),
				g = n("./src/reddit/selectors/moderatingComments.ts"),
				v = n("./src/reddit/selectors/moderatorPermissions.ts"),
				x = n("./src/reddit/selectors/tooltip.ts"),
				E = n("./src/reddit/selectors/user.ts"),
				O = n("./src/reddit/icons/fonts/Approve/index.tsx"),
				C = n("./src/reddit/icons/fonts/Lock/index.tsx"),
				A = n("./src/reddit/icons/fonts/Remove/index.tsx"),
				y = n("./src/reddit/icons/fonts/Spam/index.tsx"),
				j = n("./src/reddit/icons/svgs/Show/index.tsx"),
				I = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/RestrictedButton.tsx"),
				k = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.m.less"),
				_ = n.n(k);
			const S = Object(f.v)(),
				w = e => `Distinguish--Dropdown--${e}`,
				T = Object(a.c)({
					currentUser: E.m,
					collapsedBecauseCrowdControl: (e, t) => {
						let {
							comment: n
						} = t;
						return Object(g.a)(e, {
							commentId: n.id
						})
					},
					isDistinguishDropdownOpen: (e, t) => {
						let {
							comment: n
						} = t;
						return Object(x.b)(w(n.id))(e)
					},
					moderatorPermissions: (e, t) => {
						const {
							comment: n
						} = t;
						return Object(f.i)(e, t) || Object(v.n)(e, {
							subredditId: n.subredditId
						})
					},
					modModeEnabled: f.W
				}),
				P = Object(i.b)(T, (e, t) => {
					let {
						comment: n
					} = t;
					return {
						onApproveComment: () => e(Object(u.a)(n.id)),
						onDistinguishComment: (t, s) => e(Object(u.b)(n.id, t, s)),
						onLockComment: () => e(Object(u.c)(n.id)),
						onRemoveComment: () => e(Object(u.e)(n.id, !1)),
						onSpamComment: () => e(Object(u.e)(n.id, !0)),
						onShowComment: () => e(Object(u.d)(n.id)),
						onToggleDistinguishDropdown: () => e(Object(m.h)({
							tooltipId: w(n.id)
						}))
					}
				});
			t.a = S(P(l.a.wrapped(Object(b.c)(e => {
				let {
					className: t,
					comment: n,
					currentUser: r,
					isCommentAuthor: i,
					collapsedBecauseCrowdControl: a,
					moderatorPermissions: l,
					modModeEnabled: u,
					onApproveComment: m,
					onDistinguishComment: b,
					onLockComment: f,
					onRemoveComment: g,
					onShowComment: v,
					onSpamComment: x,
					onToggleDistinguishDropdown: E,
					sendEvent: k,
					pageLayer: S,
					...w
				} = e;
				const T = Object(p.b)(n),
					P = n.isApproved && T,
					N = !n.isRemoved || n.bannedBy === c.l,
					D = a,
					M = e => k(Object(h.c)(e, n.id)),
					R = "chat_comments" === (null == S ? void 0 : S.queryParams.only);
				return o.a.createElement("div", {
					className: t
				}, (n.bannedBy || T) && o.a.createElement(I.a, {
					text: P ? s.fbt._("Reapprove", null, {
						hk: "1XngBU"
					}) : s.fbt._("Approve", null, {
						hk: "2219Nh"
					}),
					onClick: () => {
						m(), R && k(Object(h.b)("approve", n.id)), M("approve")
					}
				}, o.a.createElement(O.a, {
					className: _.a.icon
				})), N && o.a.createElement(o.a.Fragment, null, o.a.createElement(I.a, {
					text: n.bannedBy === c.l ? s.fbt._("Confirm Removal", null, {
						hk: "3JozXJ"
					}) : s.fbt._("Remove", null, {
						hk: "3tYl0U"
					}),
					onClick: () => {
						g(), R && k(Object(h.b)("remove", n.id)), n.bannedBy === c.l ? M("confirm_remove") : M("remove")
					}
				}, o.a.createElement(A.a, {
					className: _.a.icon
				})), o.a.createElement(I.a, {
					text: s.fbt._("Spam", null, {
						hk: "1jEVwZ"
					}),
					onClick: () => {
						x(), M("spam")
					}
				}, o.a.createElement(y.a, {
					className: _.a.icon
				}))), o.a.createElement(I.a, {
					text: n.isLocked ? s.fbt._("Unlock", null, {
						hk: "KGYeO"
					}) : s.fbt._("Lock", null, {
						hk: "3rDzwU"
					}),
					onClick: () => {
						f(), M(n.isLocked ? "unlock" : "lock")
					}
				}, o.a.createElement(C.a, {
					className: _.a.icon
				})), D && o.a.createElement(I.a, {
					text: s.fbt._("Show Comment", null, {
						hk: "2ki02n"
					}),
					onClick: () => {
						v()
					}
				}, o.a.createElement(j.a, {
					className: Object(d.a)(_.a.icon, _.a.Show)
				})))
			}), "CommentModToolsFlatlist", _.a)))
		},
		"./src/reddit/components/Comments/Comment/TopMeta/Author.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/constants/index.ts"),
				a = n("./src/reddit/models/Comment/index.ts"),
				d = n("./src/reddit/components/Economics/SubredditPremium/Badges/UsernameDisplay/index.tsx"),
				c = n("./src/reddit/components/Hovercards/AuthorHovercard/index.tsx"),
				l = n("./src/reddit/components/PostTopMeta/index.tsx"),
				u = n("./src/reddit/components/Comments/Comment/TopMeta/CommentAuthorLink.tsx"),
				m = n("./src/reddit/components/Comments/Comment/TopMeta/author.m.less"),
				p = n.n(m);
			const b = e => {
				let {
					authorClassName: t,
					className: n,
					comment: s,
					collapsed: m,
					isEmbeddedLiveChat: b,
					isStrong: f,
					onClick: h,
					renderedInOverlay: g
				} = e;
				const v = Object(a.f)(s),
					x = r.a.createElement(d.b, {
						ignore: v || !!s.distinguishType && s.distinguishType !== i.I.NONE,
						subredditId: s.subredditId,
						userId: s.authorId
					}, r.a.createElement(u.a, {
						className: t,
						collapsed: m,
						comment: s,
						isAuthorDeleted: Object(a.f)(s),
						isCommentAuthorBlocked: Object(a.g)(s),
						isEmbeddedLiveChat: b,
						isStrong: f,
						onClick: h
					}));
				return v || b ? x : r.a.createElement(c.b, {
					className: Object(o.a)(p.a.authorHoverCard, n),
					collapsed: m,
					isCommentAuthorBlocked: Object(a.g)(s),
					postOrComment: s,
					tooltipType: g ? l.f.Lightbox : void 0
				}, x)
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/CommentAuthorLink.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/classNames/index.ts"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/components/AuthorLink/index.tsx"),
				d = n("./src/reddit/components/Comments/Comment/TopMeta/commentAuthorLink.m.less"),
				c = n.n(d);
			const l = e => {
				const {
					className: t,
					collapsed: n,
					comment: o,
					isAuthorDeleted: d,
					isCommentAuthorBlocked: l,
					isEmbeddedLiveChat: u,
					isStrong: m,
					onClick: p,
					style: b
				} = e;
				return n && l ? i.a.createElement("p", {
					className: Object(r.a)(c.a.commentAuthorLink, t)
				}, s.fbt._("Blocked account", null, {
					hk: "2KVMxM"
				})) : i.a.createElement(a.a, {
					author: o.author,
					className: Object(r.a)(c.a.commentAuthorLink, t),
					isAuthorDeleted: d,
					isCommentAuthorBlocked: l,
					forceOpenInNewTab: u,
					isStrong: m,
					linkProps: {
						"data-testid": "comment_author_link"
					},
					onClick: p,
					style: b
				}, o.author)
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/Created.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/addQueryParams/index.ts"),
				a = n("./src/reddit/actions/comment/index.ts"),
				d = n("./src/reddit/actions/post.ts"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/reddit/components/HumanDate/index.tsx"),
				u = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				m = n("./src/reddit/helpers/path/index.ts"),
				p = n("./src/reddit/components/Comments/Comment/TopMeta/tooltip.ts");
			const b = e => {
					const {
						className: t,
						comment: n,
						compact: s,
						onClick: a,
						permalink: b,
						renderedInOverlay: h,
						isBlockingInterstitialEnabled: g
					} = e, v = Object(o.d)(), x = Object(p.d)("CommentTopMeta--Created--", n.id, h), E = () => v(Object(c.h)({
						tooltipId: x
					}));
					return r.a.createElement("a", {
						className: t,
						"data-testid": "comment_timestamp",
						href: Object(i.a)(b, {
							utm_source: "reddit",
							utm_medium: "web2x",
							context: 3
						}),
						id: x,
						onClick: e => {
							null == a || a(e), f(v, n.id), g && (e.preventDefault(), v(Object(d.X)(Object(m.b)(b), n.postId)))
						},
						onMouseEnter: E,
						onMouseLeave: E,
						target: "_blank",
						rel: "nofollow noopener noreferrer"
					}, r.a.createElement(l.d, {
						seconds: n.created,
						shortenedUnit: s
					}), r.a.createElement(u.c, {
						tooltipId: x
					}, r.a.createElement(l.b, {
						seconds: n.created
					})))
				},
				f = (e, t) => {
					window.addEventListener("focus", (function n() {
						h(e, t, n)
					}))
				},
				h = (e, t, n) => {
					window.removeEventListener("focus", n), e(Object(a.h)({
						commentListNodeId: t
					})), window.setTimeout(() => e(Object(a.h)({
						commentListNodeId: t
					})), 5e3)
				}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/Edited.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/HumanDate/index.tsx"),
				a = n("./src/reddit/controls/MetaData/index.tsx"),
				d = n("./src/reddit/components/Comments/Comment/TopMeta/edited.m.less"),
				c = n.n(d);
			const {
				fbt: l
			} = n("./node_modules/fbt/lib/FbtPublic.js"), u = e => {
				let {
					className: t,
					compact: n,
					editedAt: s
				} = e;
				return r.a.createElement(a.a, {
					className: Object(o.a)(c.a.editedText, t)
				}, l._("edited {time}", [l._param("time", r.a.createElement(i.d, {
					seconds: s,
					shortenedUnit: n
				}))], {
					hk: "1tiB0u"
				}))
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/PostCommentHeader/index.m.less": function(e, t, n) {
			e.exports = {
				author: "DjcdNGtVXPcxG0yiFXIoZ",
				authorLine: "_1a_HxF03jCyxnx706hQmJR",
				headerLine: "_2nobNdIwmDrXK7NZps5zUO",
				flair: "cFNx42ceihnMpvAsovOTi",
				baselineItem: "_3QEK34iVL1BjyHAVleVVNQ",
				container: "-Xcv3XBXmgiY2X5RqaPbO",
				cryptoPoints: "_2bfuNFXt4pN8991xPpimzy",
				role: "_3AgEmWP1qkCB8nds7LhzEB",
				achievementFlair: "_2a_XgY10KOzM0PRvywwDuY",
				cakeDay: "TNzy9Y4Ql8v80YssZ59GR",
				metaText: "_3yx4Dn0W3Yunucf5sVJeFU",
				separator: "_8b8fUdBRxCYj9MkNpFvvv",
				userBadges: "_3AXw8D3tzlqTRxjQdd5ve7",
				userFlairLine: "_3w527zTLhXkd08MyacMV9H",
				LastAuthorModNoteIcon: "_3TVHJ99XXRlGtv0wqGCBFy",
				lastAuthorModNoteIcon: "_3TVHJ99XXRlGtv0wqGCBFy"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/Role.m.less": function(e, t, n) {
			e.exports = {
				role: "LWgI-A6rN9Wajn1VLxu2A",
				modAchievement: "_2am63Mu1vtyM2MwmCJoxJp"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/Role.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return x
			}));
			var s, r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./src/config.ts"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/colors/constants.ts"),
				u = n("./src/reddit/actions/tooltip.ts"),
				m = n("./src/reddit/components/Comments/Comment/TopMeta/tooltip.ts"),
				p = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				b = n("./src/lib/constants/index.ts"),
				f = n("./src/reddit/helpers/author.ts");
			! function(e) {
				e.Op = "op", e.Mod = "mod", e.ModTeam = "modTeam", e.Admin = "admin", e.AlumniAdmin = "alumniAdmin", e.Contractor = "contractor"
			}(s || (s = {}));
			var h = n("./src/reddit/components/Comments/Comment/TopMeta/Role.m.less"),
				g = n.n(h);
			const v = {
					[s.Admin]: {
						color: l.c,
						getLabel: () => r.fbt._("Admin", null, {
							hk: "Iku1o"
						}),
						tooltipPrefix: "CommentTopMeta--Admin--",
						tooltipTemplate: m.b
					},
					[s.Mod]: {
						color: l.d,
						getLabel: () => r.fbt._("Mod", null, {
							hk: "1b6Q1p"
						}),
						tooltipPrefix: "CommentTopMeta--Mod--",
						tooltipTemplate: e => Object(m.e)(e.subredditDisplayText)
					},
					[s.ModTeam]: {
						color: l.d,
						getLabel: () => r.fbt._("Mods", null, {
							hk: "2rP88U"
						}),
						tooltipPrefix: "CommentTopMeta--ModTeam--",
						tooltipTemplate: e => Object(m.e)(e.subredditDisplayText)
					},
					[s.Op]: {
						color: l.a,
						getLabel: () => r.fbt._("Op", null, {
							hk: "ERTp9"
						}),
						tooltipPrefix: "CommentTopMeta--OP--",
						tooltipTemplate: m.f
					},
					[s.AlumniAdmin]: {
						color: l.c,
						getLabel: () => r.fbt._("Admin", null, {
							hk: "Iku1o"
						}),
						tooltipPrefix: "CommentTopMeta--AdEm--",
						tooltipTemplate: m.a
					},
					[s.Contractor]: {
						color: l.a,
						getLabel: () => r.fbt._("Contractor", null, {
							hk: "2nhaY6"
						}),
						tooltipPrefix: "CommentTopMeta--Contractor--",
						tooltipTemplate: m.c
					}
				},
				x = e => {
					const t = Object(a.d)(),
						n = function(e) {
							if (e.isAdmin) return s.Admin;
							const t = e.isMod || e.distinguishType === b.I.MODERATOR;
							return t && e.author && Object(f.a)(e.author) ? s.ModTeam : t ? s.Mod : e.isOp ? s.Op : e.distinguishType === b.I.ALUMNI_ADMIN ? s.AlumniAdmin : e.authorIsContractor ? s.Contractor : null
						}(e.comment);
					if (!n) return null;
					if (n === s.Contractor && !e.renderContractorBadge) return null;
					const {
						tooltipPrefix: r,
						color: o,
						getLabel: d,
						tooltipTemplate: l
					} = v[n], h = d(), x = Object(m.d)(r, e.comment.id, e.renderedInOverlay), O = l(e), C = () => t(Object(u.h)({
						tooltipId: x
					}));
					return i.a.createElement(i.a.Fragment, null, i.a.createElement("span", {
						className: Object(c.a)(g.a.role, e.className),
						style: {
							color: o
						},
						id: x,
						onMouseEnter: C,
						onMouseLeave: C
					}, i.a.createElement("span", null, h), (n === s.Mod || n === s.ModTeam) && i.a.createElement(E, null)), i.a.createElement(p.c, {
						tooltipId: x,
						text: O
					}))
				},
				E = () => i.a.createElement("img", {
					alt: r.fbt._("Moderator Achievement", null, {
						hk: "20RhJI"
					}),
					className: g.a.modAchievement,
					src: `${d.a.assetPath}/img/powerups/moderator-achievement.svg`
				})
		},
		"./src/reddit/components/Comments/Comment/TopMeta/author.m.less": function(e, t, n) {
			e.exports = {
				authorHoverCard: "sMaSljeAO1a-nAhrURxdj",
				container: "NL6v1uLnaxK0IHIJdUdel"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/cakeDay.m.less": function(e, t, n) {
			e.exports = {
				cakedayIcon: "_12wHSVQW6wUCbn56VnIfI-"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/commentAuthorLink.m.less": function(e, t, n) {
			e.exports = {
				commentAuthorLink: "wM6scouPXXsFDSZmZPHRo"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/crowdControl.m.less": function(e, t, n) {
			e.exports = {
				crowdControlText: "_3UBJEBi_CJ8y1i9Up_67Hb"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/edited.m.less": function(e, t, n) {
			e.exports = {
				editedText: "_18WUrfxbke5CjwIjhXu6C-"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/index.m.less": function(e, t, n) {
			e.exports = {
				iconStyles: "S8WH2aCfP030wVxp0iR_o",
				AdminEmeritus: "xIZgDbR-AMck1mC6sZI1m",
				adminEmeritus: "xIZgDbR-AMck1mC6sZI1m",
				AdminIcon: "_2IdAWdzNdIq-LUdJv0lpD6",
				adminIcon: "_2IdAWdzNdIq-LUdJv0lpD6",
				ContractorIcon: "_39FDxNax8J3IkHXRxQmeJE",
				contractorIcon: "_39FDxNax8J3IkHXRxQmeJE",
				ModeratorIcon: "rZkjnStRKzlmtr__ixhKy",
				moderatorIcon: "rZkjnStRKzlmtr__ixhKy",
				OpIcon: "_3X_-kuWbD5_nVi9_eTAYVC",
				opIcon: "_3X_-kuWbD5_nVi9_eTAYVC",
				RightPositionedAuthorFlair: "_zMIUk6t-WDI7fxfkvD02",
				rightPositionedAuthorFlair: "_zMIUk6t-WDI7fxfkvD02",
				MetaSeparator: "yJGcpQjpmA13QcuUz2h0B",
				metaSeparator: "yJGcpQjpmA13QcuUz2h0B",
				publicPoints: "_2LXcsgibmlCEsBPk8MLy7e",
				NftAuthor: "kDnKKJWz2PJGoalLInCW1",
				nftAuthor: "kDnKKJWz2PJGoalLInCW1",
				MetaLink: "_1sA-1jNHouHDpgCp1fCQ_F",
				metaLink: "_1sA-1jNHouHDpgCp1fCQ_F",
				DeletedText: "_2Wu4MNMVl4bsJ9iVnQz0dF",
				deletedText: "_2Wu4MNMVl4bsJ9iVnQz0dF",
				container: "_3ezOJqKdLbgkHsXcfvS5SA",
				collapsed: "_2k27lgIDltx9kOzVGXt48i",
				hasBadges: "_1KMFaeLEhRikeFEOlWE9Ti",
				authorRole: "_3uDFtRr_CTErFPJQBtzECl",
				metaText: "_3_GZIIN1xcMEC5AVuv4kfa",
				separator: "_1PuBpmbH2FA5sozYR7EuCs",
				userBadges: "_3Ofd-Ek86mwX500i92F84q",
				cakeDay: "UG2sa-VYMzrn7D1iNXtfR",
				addModNote: "_3xk2cMvsSpPHBinHNwkDHi"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/components/AwardBadges/index.tsx"),
				u = n("./src/reddit/components/CCM/AddModNoteCTA/index.tsx"),
				m = n("./src/reddit/components/Comments/Comment/TopMeta/CommentAuthorLink.tsx"),
				p = n("./src/reddit/components/Econ/PowerupsFlair/UserAchievementFlair.async.ts"),
				b = n("./src/reddit/components/Economics/SubredditPremium/Badges/UserDisplay/index.tsx"),
				f = n("./src/reddit/components/Flair/index.tsx"),
				h = n("./src/reddit/components/Governance/UserPublicPointsDisplay/async.tsx"),
				g = n("./src/reddit/components/LastAuthorModNoteIcon/index.tsx"),
				v = n("./src/reddit/components/PostTopMeta/index.tsx"),
				x = n("./src/reddit/controls/MetaData/index.tsx"),
				E = n("./src/reddit/helpers/flair.ts"),
				O = n("./src/reddit/helpers/trackers/features/powerupsFlair.ts"),
				C = n("./src/reddit/hooks/useTracking.ts"),
				A = n("./src/reddit/models/Comment/index.ts"),
				y = n("./src/reddit/selectors/gold/powerups/index.ts"),
				j = n("./src/reddit/components/Comments/Comment/TopMeta/Author.tsx"),
				I = n("./src/config.ts"),
				k = n("./src/reddit/actions/tooltip.ts"),
				_ = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				S = n("./src/reddit/components/Comments/Comment/TopMeta/tooltip.ts"),
				w = n("./src/reddit/components/Comments/Comment/TopMeta/cakeDay.m.less"),
				T = n.n(w);
			const P = e => {
				let {
					className: t,
					commentId: n,
					renderedInOverlay: r
				} = e;
				const a = Object(i.d)(),
					c = () => a(Object(k.h)({
						tooltipId: l
					})),
					l = Object(S.d)("CommentTopMeta--cakeday--", n, r),
					u = s.fbt._("Cake day", null, {
						hk: "1xptSi"
					});
				return o.a.createElement(o.a.Fragment, null, o.a.createElement("img", {
					className: Object(d.a)(T.a.cakedayIcon, t),
					src: `${I.a.assetPath}/img/powerups/flair_cakeday.png`,
					alt: u,
					id: l,
					onMouseEnter: c,
					onMouseLeave: c,
					"data-testid": "cakeday-icon"
				}), o.a.createElement(_.c, {
					tooltipId: l,
					text: u
				}))
			};
			var N = n("./src/reddit/components/Comments/Comment/TopMeta/Created.tsx"),
				D = n("./src/reddit/components/Comments/Comment/TopMeta/crowdControl.m.less"),
				M = n.n(D);
			const {
				fbt: R
			} = n("./node_modules/fbt/lib/FbtPublic.js"), L = () => o.a.createElement(x.a, {
				className: M.a.crowdControlText
			}, R._("Crowd Control", null, {
				hk: "4WgEW"
			}));
			var B = n("./src/reddit/components/Comments/Comment/TopMeta/Edited.tsx"),
				F = n("./src/reddit/constants/postLayout.ts"),
				U = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				H = n("./src/reddit/helpers/isRemoved.ts"),
				G = n("./src/reddit/helpers/modTooltipTemplates/index.ts"),
				Q = n("./src/reddit/helpers/showReportIndicator/index.ts"),
				q = n("./src/reddit/hooks/usePageLayer.ts"),
				W = n("./src/reddit/icons/fonts/Approve/index.tsx"),
				z = n("./src/reddit/icons/fonts/Lock/index.tsx"),
				V = n("./src/reddit/icons/fonts/Remove/index.tsx"),
				K = n("./src/reddit/icons/fonts/Report/index.tsx"),
				Y = n("./src/reddit/icons/fonts/Spam/index.tsx"),
				J = n("./src/reddit/selectors/modQueue.ts"),
				X = n("./src/reddit/components/Comments/Comment/TopMeta/modBadgeTooltip.m.less"),
				Z = n.n(X);
			const $ = e => {
				let {
					comment: t,
					ignoreLock: r,
					renderedInOverlay: a,
					isAdmin: d
				} = e;
				const c = Object(i.d)(),
					l = Object(q.a)(),
					u = Object(i.e)(e => F.e[Object(U.V)(e, {
						pageLayer: l
					})] === F.d.Card),
					m = Object(i.e)(e => Object(J.b)(e, u)),
					p = e => () => c(Object(k.f)({
						tooltipId: e
					})),
					b = () => c(Object(k.i)()),
					f = e => Object(S.d)(e, t.id, a),
					h = f("CommentTopMeta--Approve--"),
					g = f("CommentTopMeta--Remove--"),
					v = f("CommentTopMeta--Report--"),
					x = f("CommentTopMeta--Spam--"),
					E = p(g);
				return o.a.createElement(o.a.Fragment, null, (t.approvedBy || t.isApproved) && !m && o.a.createElement(o.a.Fragment, null, o.a.createElement(W.a, {
					className: Z.a.approveIcon,
					desc: Object(G.a)(t),
					id: h,
					onMouseEnter: p(h),
					onMouseLeave: b,
					isFilled: !0
				}), o.a.createElement(_.c, {
					tooltipId: h,
					text: Object(G.a)(t)
				})), Object(H.a)(t) && !m && o.a.createElement(o.a.Fragment, null, o.a.createElement(V.a, {
					className: Z.a.removeIcon,
					desc: Object(G.b)(t),
					id: g,
					onMouseEnter: E,
					onMouseLeave: b,
					isFilled: !0
				}), o.a.createElement(_.c, {
					tooltipId: g,
					text: Object(G.b)(t)
				})), Object(H.a)(t) && t.isRemoved && !t.modNote && !t.modRemovalReason && !m && o.a.createElement("a", {
					className: Z.a.removalReason,
					onClick: () => {
						Promise.all([n.e("Reddit~RichTextEditor~reddit-components-MediumPost~reddit-components-NotificationUnit-Button~removal~87f825ba"), n.e("removalReasonActions")]).then(n.bind(null, "./src/reddit/actions/removalReasons/index.ts")).then(e => c(e.fetchReasonsAndOpenModal(t.subredditId, [t.id])))
					}
				}, s.fbt._("Add a removal reason", null, {
					hk: "L6yrL"
				})), Object(H.a)(t) && !(t.isRemoved && !t.modNote && !t.modRemovalReason) && !m && o.a.createElement("a", {
					className: Z.a.removalReason,
					onMouseEnter: E,
					onMouseLeave: b
				}, s.fbt._("Removal reason", null, {
					hk: "20NRw8"
				})), t.isLocked && !r && o.a.createElement(z.a, {
					className: Z.a.lockIcon,
					desc: s.fbt._("Locked", null, {
						hk: "40Ju3g"
					}),
					isFilled: !0
				}), t.bannedBy && t.isSpam && !m && o.a.createElement(o.a.Fragment, null, o.a.createElement(Y.a, {
					className: Z.a.spamIcon,
					desc: Object(G.d)(t),
					id: x,
					onMouseEnter: p(x),
					onMouseLeave: b,
					isFilled: !0
				}), o.a.createElement(_.c, {
					tooltipId: x,
					text: Object(G.d)(t)
				})), Object(Q.a)(t) && !m && o.a.createElement(o.a.Fragment, null, o.a.createElement(K.a, {
					className: Z.a.reportIcon,
					desc: Object(G.c)(t.numReports),
					id: v,
					onMouseEnter: p(v),
					onMouseLeave: b,
					isFilled: !0
				}), o.a.createElement(_.c, {
					tooltipId: v,
					text: Object(G.c)(t.numReports)
				})), t.isDeleted && d && !m && o.a.createElement(o.a.Fragment, null, o.a.createElement(V.a, {
					className: Z.a.removeIcon,
					isFilled: !0
				}), o.a.createElement("span", {
					className: Z.a.userDeletion
				}, s.fbt._("Comment deleted by user", null, {
					hk: "1Rtt4V"
				}))))
			};
			var ee = n("./src/reddit/components/Comments/Comment/TopMeta/Role.tsx"),
				te = n("./src/reddit/components/Comments/Comment/TopMeta/stickied.m.less"),
				ne = n.n(te);
			const {
				fbt: se
			} = n("./node_modules/fbt/lib/FbtPublic.js"), re = () => o.a.createElement(x.a, {
				className: ne.a.stickiedText
			}, se._("Stickied comment", null, {
				hk: "XUSav"
			}));
			var oe = n("./src/reddit/components/Comments/Comment/TopMeta/PostCommentHeader/index.m.less"),
				ie = n.n(oe);
			const ae = e => {
				const {
					className: t,
					collapsed: n,
					collapsedBecauseCrowdControl: r,
					comment: a,
					flair: c,
					ignoreLock: u,
					isModWithUserNotesPermissions: m,
					onCommentAuthorClick: I,
					onCommentTimestampClick: k,
					permalink: _,
					renderContractorBadge: S,
					renderedInOverlay: w,
					subredditDisplayText: T,
					isAdmin: D
				} = e, M = Object(C.a)(), R = a.subredditId, F = Object(i.e)(e => Object(y.e)(e, {
					subredditId: R
				}));
				if (a.isDeleted && !D) return o.a.createElement("div", {
					className: Object(d.a)(ie.a.container, t),
					"data-testid": "post-comment-header-deleted"
				}, o.a.createElement("span", {
					className: ie.a.authorLine
				}, o.a.createElement("span", {
					className: ie.a.metaText
				}, a.deletedBy === A.c.User ? s.fbt._("Comment deleted by user", null, {
					hk: "1Rtt4V"
				}) : s.fbt._("Comment removed by moderator", null, {
					hk: "E1t49"
				})), o.a.createElement(x.c, {
					className: ie.a.separator
				}), o.a.createElement(N.a, {
					key: "Created",
					className: ie.a.metaText,
					comment: a,
					compact: !0,
					permalink: _,
					renderedInOverlay: w
				})));
				return o.a.createElement("div", {
					className: Object(d.a)(ie.a.container, t),
					"data-testid": "post-comment-header"
				}, o.a.createElement("span", {
					className: ie.a.authorLine
				}, !Object(A.f)(a) && o.a.createElement(b.b, {
					className: ie.a.userBadges,
					badgeSize: 20,
					showAddCustom: !0,
					subredditId: a.subredditId,
					userId: a.authorId,
					uniqueIdentifier: a.id
				}), o.a.createElement("div", {
					className: ie.a.baselineItem
				}, o.a.createElement(j.a, {
					authorClassName: ie.a.author,
					collapsed: n,
					comment: a,
					onClick: I,
					renderedInOverlay: w
				})), !Object(A.f)(a) && m && o.a.createElement(g.a, {
					postOrComment: a,
					className: ie.a.LastAuthorModNoteIcon
				}), r && o.a.createElement(L, null), o.a.createElement(ee.a, {
					className: ie.a.role,
					comment: a,
					subredditDisplayText: T,
					renderContractorBadge: S,
					renderedInOverlay: w
				}), a.isAuthorCakeday ? o.a.createElement(P, {
					className: ie.a.cakeDay,
					commentId: a.id,
					renderedInOverlay: w
				}) : !Object(A.f)(a) && F && o.a.createElement(p.a, {
					className: ie.a.achievementFlair,
					subredditId: a.subredditId,
					userId: a.authorId,
					onHover: () => {
						M(Object(O.b)(a.id, a.subredditId, a.authorId))
					},
					showPopupOnHover: !0
				}), o.a.createElement(h.a, {
					className: ie.a.cryptoPoints,
					contentId: a.id,
					subredditId: a.subredditId,
					userId: a.authorId,
					username: a.author
				}), o.a.createElement(x.c, {
					className: ie.a.separator
				}), o.a.createElement(N.a, {
					key: "Created",
					className: ie.a.metaText,
					comment: a,
					compact: !0,
					onClick: k,
					permalink: _,
					renderedInOverlay: w
				}), a.isStickied && o.a.createElement(o.a.Fragment, null, o.a.createElement(x.c, {
					className: ie.a.separator
				}), o.a.createElement(re, null)), a.editedAt && o.a.createElement(o.a.Fragment, null, o.a.createElement(x.c, {
					className: ie.a.separator
				}), o.a.createElement(B.a, {
					compact: !0,
					editedAt: a.editedAt
				})), o.a.createElement($, {
					comment: a,
					ignoreLock: u,
					renderedInOverlay: w,
					isAdmin: D
				}), o.a.createElement(l.a, {
					thing: a,
					tooltipType: w ? v.f.Lightbox : void 0
				})), c && !Object(E.o)(c) && o.a.createElement("span", {
					className: ie.a.userFlairLine
				}, o.a.createElement(f.c, {
					className: ie.a.flair,
					flair: c,
					forceSmallEmojis: !0
				})))
			};
			var de = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				ce = n("./src/reddit/selectors/economics.ts"),
				le = n("./src/reddit/models/Flair/index.ts"),
				ue = n("./src/reddit/selectors/comments.ts"),
				me = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				pe = n("./src/reddit/selectors/moderatorPermissions.ts"),
				be = n("./src/reddit/selectors/subreddit.ts"),
				fe = n("./src/reddit/selectors/userFlair.ts"),
				he = n("./src/reddit/components/Comments/Comment/TopMeta/index.m.less"),
				ge = n.n(he);

			function ve() {
				return (ve = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const xe = c.a.wrapped(f.c, "RightPositionedAuthorFlair", ge.a),
				Ee = c.a.span("DeletedText", ge.a),
				Oe = c.a.wrapped(x.a, "MetaSeparator", ge.a),
				Ce = Object(i.b)(() => Object(a.c)({
					hasBadges: (e, t) => {
						let {
							comment: n
						} = t;
						return !!Object(ce.q)(e, n.subredditId, n.authorId).length
					},
					subredditDisplayText: (e, t) => {
						const n = Object(be.N)(e, {
							commentId: t.comment.id
						});
						return n ? n.displayText : ""
					},
					flairPosition: (e, t) => {
						let {
							comment: n
						} = t;
						return Object(fe.e)(e, {
							subredditId: n.subredditId
						})
					},
					commentPermalink: (e, t) => Object(ue.m)(e, {
						commentId: t.comment.id
					}),
					isBlockingInterstitialEnabled: me.b,
					isBlockingInterstitialV2Enabled: me.c,
					isModWithUserNotesPermissions: (e, t) => {
						let {
							comment: n
						} = t;
						return Object(pe.i)(e, n.subredditId)
					}
				}));
			t.a = Ce(e => {
				const {
					children: t,
					className: n,
					collapsed: s,
					collapsedBecauseCrowdControl: r,
					comment: i,
					commentPermalink: a,
					commentsPageKey: c,
					compact: m,
					flair: p,
					flairPosition: g,
					hasBadges: E,
					hideAwards: O = !1,
					ignoreFlairPosition: C,
					ignoreLock: y,
					isAdmin: I,
					isBlockingInterstitialEnabled: k,
					isBlockingInterstitialV2Enabled: _,
					isModWithUserNotesPermissions: S,
					isEmbeddedLiveChat: w,
					isPostComment: T,
					onCommentAuthorClick: P,
					onCommentTimestampClick: D,
					renderContractorBadge: M,
					renderedInOverlay: R,
					subredditDisplayText: F,
					userHasNft: U
				} = e, H = o.a.createElement(o.a.Fragment, null, o.a.createElement(de.b, {
					commentId: i.id
				}), o.a.createElement(de.a, {
					commentId: i.id,
					commentsPageKey: c
				}));
				if (T) return o.a.createElement(o.a.Fragment, null, o.a.createElement(ae, {
					className: Object(d.a)(n, {
						[ge.a.collapsed]: s
					}),
					collapsed: s,
					collapsedBecauseCrowdControl: r,
					comment: i,
					flair: p || null,
					ignoreLock: y,
					isAdmin: I,
					isModWithUserNotesPermissions: S,
					onCommentAuthorClick: P,
					onCommentTimestampClick: D,
					permalink: a,
					renderContractorBadge: !!M,
					renderedInOverlay: R,
					subredditDisplayText: F
				}), H);
				if (i.isDeleted) return o.a.createElement(Ae, ve({}, e, {
					className: Object(d.a)(n, ge.a.container, {
						[ge.a.collapsed]: s
					})
				}));
				if (s) return o.a.createElement(ye, ve({}, e, {
					className: Object(d.a)(n, ge.a.container, {
						[ge.a.collapsed]: s
					})
				}));
				const G = !C && g === le.b.Left;
				return o.a.createElement("div", {
					className: Object(d.a)(n, ge.a.container, {
						[ge.a.collapsed]: s,
						[ge.a.hasBadges]: E
					}),
					"data-testid": "comment-top-meta"
				}, p && G && o.a.createElement(f.c, {
					flair: p,
					forceSmallEmojis: m
				}), !Object(A.f)(i) && o.a.createElement(b.b, {
					className: ge.a.userBadges,
					showAddCustom: !0,
					subredditId: i.subredditId,
					userId: i.authorId,
					uniqueIdentifier: i.id
				}), t && t, o.a.createElement(j.a, {
					authorClassName: U ? ge.a.NftAuthor : void 0,
					collapsed: s,
					comment: i,
					isEmbeddedLiveChat: w,
					isStrong: !!m,
					onClick: P,
					renderedInOverlay: R
				}), r && o.a.createElement(L, null), r && o.a.createElement(x.c, {
					className: ge.a.metaText,
					key: "crowdControlSeparator"
				}), p && !G && o.a.createElement(xe, {
					flair: p,
					forceSmallEmojis: m
				}), !m && o.a.createElement(h.a, {
					className: ge.a.publicPoints,
					contentId: i.id,
					metaSeparator: o.a.createElement(x.c, {
						className: ge.a.metaText
					}),
					subredditId: i.subredditId,
					userId: i.authorId,
					username: i.author
				}), H, o.a.createElement(ee.a, {
					className: ge.a.authorRole,
					comment: i,
					subredditDisplayText: F,
					renderContractorBadge: !!M,
					renderedInOverlay: R
				}), !m && o.a.createElement(o.a.Fragment, null, !i.isDeleted && !T && o.a.createElement(o.a.Fragment, null, o.a.createElement(x.b, {
					className: ge.a.metaText,
					isScoreHidden: i.isScoreHidden,
					score: i.score
				}), o.a.createElement(x.c, {
					className: ge.a.metaText,
					key: "scoreCreatedSeparator"
				})), o.a.createElement(N.a, {
					key: "Created",
					className: ge.a.MetaLink,
					comment: i,
					permalink: a,
					renderedInOverlay: R,
					isBlockingInterstitialEnabled: k || _
				}), i.isStickied && o.a.createElement(o.a.Fragment, null, o.a.createElement(x.c, {
					className: ge.a.separator
				}), o.a.createElement(re, null)), i.editedAt && o.a.createElement(o.a.Fragment, null, o.a.createElement(x.c, {
					className: ge.a.separator
				}), o.a.createElement(B.a, {
					editedAt: i.editedAt
				}))), o.a.createElement($, {
					comment: i,
					ignoreLock: y,
					renderedInOverlay: R
				}), !O && o.a.createElement(l.a, {
					thing: i,
					tooltipType: R ? v.f.Lightbox : void 0
				}), S && o.a.createElement(u.a, {
					postOrComment: i,
					className: ge.a.addModNote
				}))
			});
			const Ae = e => {
					const {
						childrenInfo: t,
						collapsed: n,
						className: r,
						comment: i,
						commentPermalink: a,
						isBlockingInterstitialEnabled: d,
						isBlockingInterstitialV2Enabled: c,
						renderedInOverlay: l
					} = e;
					return o.a.createElement("div", {
						className: r
					}, o.a.createElement(Ee, null, i.deletedBy === A.c.User ? s.fbt._("Comment deleted by user", null, {
						hk: "1Rtt4V"
					}) : s.fbt._("Comment removed by moderator", null, {
						hk: "E1t49"
					})), o.a.createElement(N.a, {
						key: "Created",
						className: ge.a.MetaLink,
						comment: i,
						permalink: a,
						renderedInOverlay: l,
						isBlockingInterstitialEnabled: d || c
					}), n && je({
						childrenInfo: t
					}))
				},
				ye = e => {
					const {
						comment: t,
						className: n,
						childrenInfo: s,
						renderedInOverlay: r,
						collapsed: i,
						commentPermalink: a,
						isBlockingInterstitialEnabled: d,
						isBlockingInterstitialV2Enabled: c
					} = e;
					return o.a.createElement("div", {
						className: n
					}, o.a.createElement("div", null, o.a.createElement(m.a, {
						comment: t,
						isAuthorDeleted: Object(A.f)(t),
						collapsed: i
					})), o.a.createElement(x.b, {
						className: ge.a.metaText,
						isScoreHidden: t.isScoreHidden,
						score: t.score
					}), o.a.createElement(x.c, {
						className: ge.a.metaText,
						key: "scoreCreatedSeparator"
					}), o.a.createElement(N.a, {
						key: "Created",
						className: ge.a.MetaLink,
						comment: t,
						permalink: a,
						renderedInOverlay: r,
						isBlockingInterstitialEnabled: d || c
					}), je({
						childrenInfo: s
					}))
				},
				je = e => {
					const {
						hasContinueThread: t,
						numChildren: n
					} = e.childrenInfo || {
						hasContinueThread: !1,
						numChildren: 0
					};
					return o.a.createElement(Oe, {
						className: ge.a.metaText
					}, t ? s.fbt._({
						"*": "More than {number} children",
						_1: "More than 1 child"
					}, [s.fbt._plural(n, "number")], {
						hk: "13XC7a"
					}) : s.fbt._({
						"*": "{number} children",
						_1: "1 child"
					}, [s.fbt._plural(n, "number")], {
						hk: "dhX9w"
					}))
				}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/modBadgeTooltip.m.less": function(e, t, n) {
			e.exports = {
				approveIcon: "_3Jlybj1GmQS_PfZVxE6yR1",
				automoderatorIcon: "_2EBjdWEqs2dwPePq0_1vJn",
				lockIcon: "YjyVr4SnBmO7WorLVMXq5",
				removeIcon: "_3M_jIwyB1POxBFR2jnGIp_",
				reportIcon: "_3hI84iVaolaHi85h6liPyp",
				spamIcon: "MufLXlXcv1oes9OlakuXr",
				removed: "_2LQnjoTNHDUWKBOoq2gTlm",
				removalReason: "EM8fL_jC3oe9bruIOZt2U",
				userDeletion: "_1KVzcRpEm0U5vCgrZbgiyN"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/stickied.m.less": function(e, t, n) {
			e.exports = {
				stickiedText: "_2wd-K5Djdc9TGPRGDgmkpX"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/tooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			const r = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return `${e}${t}${n?"inOverlay":""}`
				},
				o = () => s.fbt._("Reddit admin, speaking officially", null, {
					hk: "3vg8wE"
				}),
				i = () => s.fbt._("Reddit admin emeritus", null, {
					hk: "1Md5AV"
				}),
				a = e => s.fbt._("Moderator of {subredditDisplayText}, speaking officially", [s.fbt._param("subredditDisplayText", e)], {
					hk: "3pHm3n"
				}),
				d = () => s.fbt._("Original Poster", null, {
					hk: "3DqK8z"
				}),
				c = () => s.fbt._("Reddit contractor", null, {
					hk: "3APwEh"
				})
		},
		"./src/reddit/components/Comments/CompactUnthreadedComment/index.m.less": function(e, t, n) {
			e.exports = {
				BulkActionCheckbox: "_3iI16gsT5wEWtruoBxoOtR",
				bulkActionCheckbox: "_3iI16gsT5wEWtruoBxoOtR",
				UnthreadedCommentContainer: "sXloQX7r47Wzsk9BzGm2",
				unthreadedCommentContainer: "sXloQX7r47Wzsk9BzGm2",
				CommentColumn: "_1Xweq4o-zB3i3DcXmGzzCo",
				commentColumn: "_1Xweq4o-zB3i3DcXmGzzCo",
				ModToolsFlatlist: "vP5hkZOVsSDk7GDKAq7OO",
				modToolsFlatlist: "vP5hkZOVsSDk7GDKAq7OO",
				CommentContentWrapper: "-ejG1vHwBmlz_5bhISopO",
				commentContentWrapper: "-ejG1vHwBmlz_5bhISopO",
				CommentParentWrapper: "_3mX7brFt-u4nDJSVh-jpOe",
				commentParentWrapper: "_3mX7brFt-u4nDJSVh-jpOe",
				LeftRail: "Z9hmG99TfBJCAbBf-qUN5",
				leftRail: "Z9hmG99TfBJCAbBf-qUN5",
				hasBorder: "_1XsRq0m2kXDelxfbhz55U6",
				VoteColumn: "raHWe-JvKoiuubD1zI79q",
				voteColumn: "raHWe-JvKoiuubD1zI79q",
				Votes: "EJ8j2TI5xV293AHVFV98I",
				votes: "EJ8j2TI5xV293AHVFV98I",
				score: "_1dQ0ZDSConSfUQpPh7-fct",
				ParentPostTitle: "_3lXem8Q27IuhplBpcrbkOv",
				parentPostTitle: "_3lXem8Q27IuhplBpcrbkOv",
				Component: "_3WdgziOPlXBwthdefEr85r",
				component: "_3WdgziOPlXBwthdefEr85r",
				isBanned: "_34REldWOs0k5_KaRonS2V5",
				isReported: "sYxWb5PNRmW4dH0vC6Qiy"
			}
		},
		"./src/reddit/components/Comments/LargeUnthreadedComment/index.m.less": function(e, t, n) {
			e.exports = {
				VoteSpacer: "_3SDIICEtoL7xtFw7iXPmd4",
				voteSpacer: "_3SDIICEtoL7xtFw7iXPmd4",
				ContentWrapper: "_3kLHiyeJw88pJ2rFPeO-h_",
				contentWrapper: "_3kLHiyeJw88pJ2rFPeO-h_",
				Meta: "TmC-aUr9G4BhD7f1fazLW",
				meta: "TmC-aUr9G4BhD7f1fazLW",
				CommentParentWrapper: "XNRBSCtZVEKlAOHUTl8fv",
				commentParentWrapper: "XNRBSCtZVEKlAOHUTl8fv",
				CommentContentWrapper: "_3CTfjjt3pW3hsmgbSddrW6",
				commentContentWrapper: "_3CTfjjt3pW3hsmgbSddrW6",
				Component: "_3Pul81GjcQcqXueoAqkS0P",
				component: "_3Pul81GjcQcqXueoAqkS0P",
				realtimeAnimation: "k1q-8FmYc8uNpQ3l8LyzP",
				realtimeFade: "FHiLBdKtJWOSipvihyEvn",
				isNightMode: "_30zL0aoM9O-6UtalCfZ_Kx",
				realtimeFadeNight: "_1svg6QVu96_c0B_a6jF7pt",
				realtimeUpdated: "aYn8shFTxZXAFEmeMl5fv"
			}
		},
		"./src/reddit/components/Comments/UnthreadedComment/index.m.less": function(e, t, n) {
			e.exports = {
				VoteSpacer: "oq5mUzSj_vNl2qp3WN_JJ",
				voteSpacer: "oq5mUzSj_vNl2qp3WN_JJ",
				ContentWrapper: "Z-SSPhDFBXkUleK1Uoo5n",
				contentWrapper: "Z-SSPhDFBXkUleK1Uoo5n",
				CommentContentWrapper: "_2OgGzVSF6RB04Jb2cXSiPj",
				commentContentWrapper: "_2OgGzVSF6RB04Jb2cXSiPj",
				CommentParentWrapper: "OPElT6Do1pTNOWhGkL1eT",
				commentParentWrapper: "OPElT6Do1pTNOWhGkL1eT",
				CommentBody: "_3PTQsA2VkqzBrZxhvpwI8Z",
				commentBody: "_3PTQsA2VkqzBrZxhvpwI8Z",
				ParentPostTitle: "_144TYY84bzwNfGN3DGzUvi",
				parentPostTitle: "_144TYY84bzwNfGN3DGzUvi",
				Component: "_29-oldqrqqPwwjRRH0aLqU",
				component: "_29-oldqrqqPwwjRRH0aLqU"
			}
		},
		"./src/reddit/components/Comments/UnthreadedComment/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return L
			})), n.d(t, "b", (function() {
				return U
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/objectSelector/index.ts"),
				c = n("./src/reddit/actions/comment/index.ts"),
				l = n("./src/reddit/actions/comment/moderation.ts"),
				u = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.tsx"),
				m = n("./src/reddit/components/Comments/UnthreadedCommentContainer/index.tsx"),
				p = n("./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.tsx"),
				b = n("./src/reddit/components/Comments/UnthreadedCommentMeta/index.tsx"),
				f = n("./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.tsx"),
				h = n("./src/reddit/components/ModModeFilteredReason/index.tsx"),
				g = n("./src/reddit/components/ModModeFilteredReason/helpers.ts"),
				v = n("./src/reddit/components/ModModeReports/index.tsx"),
				x = n("./src/reddit/components/PostRailAndVotes/index.tsx"),
				E = n("./src/reddit/components/RichTextJson/index.tsx"),
				O = n("./src/reddit/constants/postLayout.ts"),
				C = n("./src/reddit/contexts/PageLayer/index.tsx"),
				A = n("./src/reddit/helpers/getRichTextContent/index.ts"),
				y = n("./src/reddit/models/Vote/index.ts"),
				j = n("./src/reddit/selectors/comments.ts"),
				I = n("./src/reddit/selectors/commentSelector.ts"),
				k = n("./src/reddit/selectors/modQueue.ts"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				S = n("./src/reddit/selectors/user.ts"),
				w = n("./src/reddit/components/Comments/UnthreadedComment/index.m.less"),
				T = n.n(w),
				P = n("./src/lib/lessComponent.tsx");
			const N = P.a.div("VoteSpacer", T.a),
				D = P.a.div("ContentWrapper", T.a),
				M = P.a.div("CommentContentWrapper", T.a),
				R = P.a.div("CommentBody", T.a),
				L = P.a.div("ParentPostTitle", T.a),
				B = P.a.div("CommentParentWrapper", T.a),
				F = Object(i.c)({
					comment: (e, t) => Object(I.c)(e, t),
					commentPermalink: j.m,
					flair: j.e,
					subreddit: _.N,
					isModQueueDisplayEnabled: e => {
						const t = O.e[Object(C.U)(e, {})] === O.d.Card;
						return Object(k.b)(e, t)
					},
					isUpdatedContent: (e, t) => {
						let {
							commentId: n
						} = t;
						var s, r;
						return !!(null === (r = null === (s = e.features) || void 0 === s ? void 0 : s.realtimeModqueue) || void 0 === r ? void 0 : r.updated.includes(n))
					},
					showRealtimeUpdateAnimation: (e, t) => {
						let {
							commentId: n
						} = t;
						var s;
						return (null === (s = e.features) || void 0 === s ? void 0 : s.realtimeUpdateAnimationId) === n
					},
					isNightMode: S.fb
				}),
				U = Object(o.b)(F, (e, t) => {
					let {
						commentId: n,
						trackClick: s
					} = t;
					return {
						onIgnoreReports: () => e(Object(l.g)(n)),
						onVoteClick: t => {
							const [r, o] = t === y.a.upvoted ? [Object(c.s)(n), "upvote_comment"] : [Object(c.k)(n), "downvote_comment"];
							s(o)(), e(r)
						}
					}
				}),
				H = Object(d.b)(e => ({
					renderingObjectInfo: e.comment
				}));
			t.c = U(P.a.wrapped(e => {
				const {
					className: t,
					comment: n,
					commentPermalink: s,
					flair: o,
					hasReports: i,
					isCheckboxSelected: d = !1,
					onIgnoreReports: c,
					onVoteClick: l,
					showModTools: O,
					subreddit: C,
					showBulkActionCheckbox: y,
					toggleCheckbox: j
				} = e, I = Object(g.a)(n);
				return r.a.createElement(m.a, {
					className: Object(a.a)(t, "UnthreadedComment"),
					clickTrackingId: n.id,
					permalink: s
				}, r.a.createElement(x.a, {
					model: n,
					handleVote: l,
					showBulkActionCheckbox: y,
					isCheckboxSelected: d,
					toggleCheckbox: j
				}), r.a.createElement(N, null, r.a.createElement(D, null, r.a.createElement(B, null, n.postTitle && r.a.createElement(L, null, n.postTitle), n.postAuthor && r.a.createElement(f.a, {
					comment: n
				})), r.a.createElement(M, null, r.a.createElement(p.a, {
					comment: n
				}, r.a.createElement(R, null, r.a.createElement(E.b, {
					content: Object(A.a)(n),
					mediaMetadata: n.media && n.media.mediaMetadata,
					rtJsonElementProps: H(e),
					mediaProps: {
						alignLeft: !0,
						renderSmallMedia: !0
					}
				})), r.a.createElement(b.a, {
					comment: n,
					flair: o,
					subredditName: C ? C.displayText : null
				}), I && r.a.createElement(h.a, {
					thing: n
				}), i && r.a.createElement(v.a, {
					onIgnoreReports: c,
					reportable: n
				}), O && !n.isDeleted && r.a.createElement(u.a, {
					comment: n
				}))))))
			}, "Component", T.a))
		},
		"./src/reddit/components/Comments/UnthreadedCommentContainer/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/addQueryParams/index.ts"),
				a = n("./src/higherOrderComponents/withClickTracking/index.tsx"),
				d = n("./src/reddit/helpers/overlay/index.ts");
			const c = Object(o.b)(null, e => ({
				openLightbox: t => e(Object(d.a)(t))
			}));
			class l extends r.a.Component {
				constructor() {
					super(...arguments), this.cancelClick = !1
				}
				render() {
					const {
						afterClickTracking: e,
						permalink: t,
						openLightbox: n,
						...s
					} = this.props, o = s => e(() => s.metaKey || s.ctrlKey || 1 === s.button ? window.open(Object(i.a)(t, {
						context: 3
					})) : n(Object(i.a)(t, {
						context: 3
					})))(s);
					return r.a.createElement("div", {
						className: s.className,
						onMouseUp: e => {
							0 !== window.getSelection().toString().length && (this.cancelClick = !0, window.setTimeout(() => {
								this.cancelClick = !1
							}, 1e3)), 1 === e.button && o(e)
						},
						onClick: e => {
							!this.cancelClick && 0 === e.button && o(e)
						}
					}, s.children)
				}
			}
			t.a = c(Object(a.a)(l))
		},
		"./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				DashWrapper: "_3Ed3UKndPjQ4kkX0QvOz3u",
				dashWrapper: "_3Ed3UKndPjQ4kkX0QvOz3u"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.m.less"),
				a = n.n(i);
			const d = o.a.div("DashWrapper", a.a);
			t.a = e => null === e.comment.parentId ? r.a.createElement(d, null, e.children) : r.a.createElement(d, null, r.a.createElement(d, null, e.children))
		},
		"./src/reddit/components/Comments/UnthreadedCommentMeta/index.m.less": function(e, t, n) {
			e.exports = {
				SubredditWrapper: "_1ZSTlGe7wnX1GJX3F-AEwD",
				subredditWrapper: "_1ZSTlGe7wnX1GJX3F-AEwD",
				TopMeta: "_2Rm4FD32bOsXwX7lx3GeYW",
				topMeta: "_2Rm4FD32bOsXwX7lx3GeYW",
				Inline: "meK3ndVOmnvQt6wVaAg5W",
				inline: "meK3ndVOmnvQt6wVaAg5W",
				PostedInfo: "_6b3ccJ38E6dy9dby4PlDN",
				postedInfo: "_6b3ccJ38E6dy9dby4PlDN",
				TextContainer: "iV3Hb5JWIQSpA3WhioY-N",
				textContainer: "iV3Hb5JWIQSpA3WhioY-N",
				SubredditIcon: "_3VveukTKira5rWfNi-vDI4",
				subredditIcon: "_3VveukTKira5rWfNi-vDI4"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/reddit/components/Comments/Comment/TopMeta/index.tsx"),
				a = n("./src/reddit/layout/row/Inline/index.tsx"),
				d = n("./src/reddit/components/Comments/UnthreadedCommentMeta/index.m.less"),
				c = n.n(d),
				l = n("./src/lib/lessComponent.tsx"),
				u = n("./src/reddit/components/SubredditIcon/index.tsx");
			const m = l.a.wrapped(a.a, "Inline", c.a),
				p = l.a.wrapped(a.a, "PostedInfo", c.a),
				b = l.a.wrapped(a.a, "SubredditWrapper", c.a),
				f = l.a.div("TextContainer", c.a),
				h = l.a.wrapped(i.a, "TopMeta", c.a);
			t.a = e => {
				let {
					subredditName: t,
					className: n,
					comment: r,
					flair: i,
					subredditOrProfile: a
				} = e;
				return o.a.createElement(m, {
					className: n
				}, a && o.a.createElement(b, null, a && o.a.createElement(u.b, {
					className: c.a.SubredditIcon,
					subredditOrProfile: a
				}), a && o.a.createElement(f, null, a.displayText)), t && !a && o.a.createElement(b, null, t && o.a.createElement(f, null, t)), o.a.createElement(p, null, o.a.createElement(f, null, `${s.fbt._("Commented by",null,{hk:"4Dveap"})}`), o.a.createElement(h, {
					collapsedBecauseCrowdControl: r.collapsedBecauseCrowdControl,
					collapsed: !1,
					comment: r,
					flair: i,
					renderedInOverlay: !1
				})))
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.m.less": function(e, t, n) {
			e.exports = {
				AuthorLink: "_2jljMb6FK7HnIb15zmm1of",
				authorLink: "_2jljMb6FK7HnIb15zmm1of",
				SubredditWrapper: "SZcM6DS3LArR6FZxlQXOv",
				subredditWrapper: "SZcM6DS3LArR6FZxlQXOv",
				TextContainer: "_2in6k_0-sFgKVz16hifq03",
				textContainer: "_2in6k_0-sFgKVz16hifq03",
				SubredditIcon: "uCjYZbKNai0INWGwHjoUh",
				subredditIcon: "uCjYZbKNai0INWGwHjoUh",
				Inline: "_2VWXAfRlnHG_4nydI7J4l3",
				inline: "_2VWXAfRlnHG_4nydI7J4l3"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/AuthorLink/index.tsx"),
				i = n("./src/reddit/components/Hovercards/AuthorHovercard/index.tsx"),
				a = n("./src/reddit/components/SubredditIcon/index.tsx"),
				d = n("./src/reddit/layout/row/Inline/index.tsx"),
				c = n("./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.m.less"),
				l = n.n(c),
				u = n("./src/lib/constants/index.ts"),
				m = n("./src/lib/lessComponent.tsx");
			const {
				fbt: p
			} = n("./node_modules/fbt/lib/FbtPublic.js"), b = m.a.wrapped(o.a, "AuthorLink", l.a), f = m.a.wrapped(d.a, "Inline", l.a), h = m.a.wrapped(d.a, "SubredditWrapper", l.a), g = m.a.div("TextContainer", l.a), v = m.a.wrapped(a.b, "SubredditIcon", l.a);
			t.a = e => r.a.createElement(f, null, e.subredditOrProfile && r.a.createElement(h, null, e.subredditOrProfile && r.a.createElement(v, {
				subredditOrProfile: e.subredditOrProfile
			}), e.subredditOrProfile && r.a.createElement(g, null, e.subredditOrProfile.displayText)), p._("posted by", null, {
				hk: "1EuRc2"
			}), e.comment.postAuthor && r.a.createElement(i.b, {
				postOrComment: e.comment,
				author: e.comment.postAuthor
			}, r.a.createElement(b, {
				author: e.comment.postAuthor,
				isUnstyled: !0,
				isAuthorDeleted: e.comment.postAuthor === u.G
			}, `u/${e.comment.postAuthor}`)))
		},
		"./src/reddit/components/CommentsChat/LiveIcon/index.m.less": function(e, t, n) {
			e.exports = {
				Icon: "_1BLJJHA9oAzG1Rqmf4pcYW",
				icon: "_1BLJJHA9oAzG1Rqmf4pcYW",
				IconText: "_6cNM5NdF82ASM5hiBVNN5",
				iconText: "_6cNM5NdF82ASM5hiBVNN5",
				Animate: "_3j98tX1WZapEArV-4rmJe5",
				animate: "_3j98tX1WZapEArV-4rmJe5",
				top: "_3Dr1MoYY5Yv4YhbQFFcks0",
				bottom: "_1GRYNQhMsR-00cWDJcE3UJ",
				bigCircle: "_85rqvRijdIsn3s0j-gUaw",
				midCircle: "RS1g6Gd_W67wwWKSteEB1",
				smallCircle: "lRlGcfTzZ7njZnIUyvhGH",
				play: "_3Kxa8oHGuT_QpP4zIN5jrV",
				blinker: "_20WvB_9deo7bJVi4af1dSS"
			}
		},
		"./src/reddit/components/CommentsChat/LiveIcon/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/@researchgate/react-intersection-observer/lib/es/index.js"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/selectors/chatPost.ts"),
				l = n("./src/reddit/components/CommentsChat/LiveIcon/index.m.less"),
				u = n.n(l);
			const m = e => {
				let {
					className: t,
					postId: n
				} = e;
				const [o, l] = i.a.useState(!1), m = Object(a.e)(e => Object(c.d)(e, {
					postId: n
				})), p = m && o;
				return m ? i.a.createElement(s.a, {
					rootMargin: "20px 0px 20px 0px",
					threshold: .1,
					onChange: e => {
						e.isIntersecting && e.intersectionRatio >= .1 ? o || l(!0) : o && l(!1)
					}
				}, i.a.createElement("div", {
					className: Object(d.a)(u.a.Icon, t)
				}, i.a.createElement("span", {
					className: Object(d.a)(u.a.Animate, u.a.top, {
						[u.a.play]: p
					})
				}, i.a.createElement("span", {
					className: u.a.bigCircle
				}), i.a.createElement("span", {
					className: u.a.midCircle
				}), i.a.createElement("span", {
					className: u.a.smallCircle
				})), i.a.createElement("p", {
					className: u.a.IconText
				}, r.fbt._("Live Chat", null, {
					hk: "gyqAe"
				})), i.a.createElement("span", {
					className: Object(d.a)(u.a.Animate, u.a.bottom, {
						[u.a.play]: p
					})
				}, i.a.createElement("span", {
					className: u.a.bigCircle
				}), i.a.createElement("span", {
					className: u.a.midCircle
				}), i.a.createElement("span", {
					className: u.a.smallCircle
				})))) : null
			}
		},
		"./src/reddit/components/CommentsLink/index.m.less": function(e, t, n) {
			e.exports = {
				commentsLink: "_1UoeAeSRhOKSNdY_h3iS1O",
				commentIcon: "_3DVrpDrMM9NLT6TlsTUMxC",
				defaultCursorWrapper: "_3m17ICJgx45k_z-t82iVuO",
				link: "_1Hw7tY9pMr-T1F4P1C-xNU",
				text: "FHCV02u6Cp2zYL0fhQPsO",
				commentsText: "_25BV1fTi10_HqCnD195T85"
			}
		},
		"./src/reddit/components/CommentsLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./node_modules/fbt/lib/FbtPublic.js"),
				m = n("./src/lib/prettyPrintNumber/index.ts"),
				p = n("./src/reddit/components/CountAnimation/index.tsx"),
				b = n("./src/reddit/constants/postLayout.ts"),
				f = n("./src/reddit/icons/fonts/Comment/index.tsx"),
				h = n("./src/reddit/selectors/experiments/postActionBarAnimation.ts"),
				g = n("./src/reddit/components/CommentsLink/index.m.less"),
				v = n.n(g);
			const x = () => 0,
				E = e => {
					let t, {
						hasModPostPerms: n,
						isCountAnimShadowTestEnabled: i,
						isChatPost: a,
						isCommentCountAnimation: c,
						modModeEnabled: g,
						numComments: E,
						postId: O,
						shouldShowIcon: C,
						shouldShowText: A,
						text: y,
						type: j
					} = e;
					const I = c && E < h.a,
						k = a ? u.fbt._({
							"*": "{number} messages",
							_1: "1 message"
						}, [u.fbt._plural(E, "number", Object(m.b)(E))], {
							hk: "2wEqSc"
						}) : u.fbt._({
							"*": "{number} comments",
							_1: "1 comment"
						}, [u.fbt._plural(E, "number", Object(m.b)(E))], {
							hk: "1QeOde"
						}),
						_ = a ? u.fbt._({
							"*": "messages",
							_1: "message"
						}, [u.fbt._plural(E)], {
							hk: "1mMKLS"
						}) : u.fbt._({
							"*": "comments",
							_1: "comment"
						}, [u.fbt._plural(E)], {
							hk: "2fJpkn"
						});
					t = y || (j === b.g.Compact || g && n ? Object(m.b)(E) : k);
					const S = Object(o.d)(),
						w = Object(s.useCallback)(e => {
							const {
								commentCountChange: t
							} = e.subscribe.data;
							0 !== t && S(Object(l.G)({
								postId: O,
								delta: t
							}))
						}, [S, O]),
						T = Object(s.useRef)({
							input: {
								channel: {
									teamOwner: "CONTENT_AND_COMMUNITIES",
									category: "COMMENT_COUNT_UPDATE",
									postID: O
								}
							}
						});
					return r.a.createElement(r.a.Fragment, null, C && r.a.createElement(f.a, {
						className: v.a.commentIcon,
						role: "presentation"
					}), A && r.a.createElement(r.a.Fragment, null, r.a.createElement("span", {
						className: v.a.text
					}, (I || i) && r.a.createElement(p.b, {
						countToUpperBound: E,
						incrementDelta: x,
						initialDelay: x,
						initialDisplayCount: E,
						postId: O,
						shouldDisjointAnimation: !0,
						subsequentRecurringDelay: x,
						featureName: p.a.Comment,
						queryKey: "postCommentCount",
						queryVariables: T.current,
						onDataCB: w,
						isLoadTestOnly: Boolean(i) && !I
					}), !I && t), (!g || !n) && I && r.a.createElement("span", {
						className: Object(d.a)(v.a.text, v.a.commentsText)
					}, _)))
				};
			var O = n("./src/reddit/constants/componentTestIds.ts"),
				C = n("./src/reddit/helpers/localStorage/index.ts"),
				A = n("./src/reddit/helpers/path/index.ts"),
				y = n("./src/reddit/hooks/useClickSourceData.ts"),
				j = n("./src/reddit/selectors/chatPost.ts"),
				I = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				k = n("./src/reddit/selectors/experiments/postSeo.ts"),
				_ = n("./src/reddit/selectors/posts.ts"),
				S = n("./src/reddit/selectors/user.ts"),
				w = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts");
			const T = Object(o.b)(() => Object(a.c)({
				isChatPost: j.d,
				isPostSEOEligible: k.e,
				postPermalink: _.E,
				shouldOpenPostInNewTab: S.lb,
				isBlockingInterstitialEnabled: I.b,
				isBlockingInterstitialV2Enabled: I.c
			}));
			t.a = T(e => {
				let {
					className: t,
					hasModPostPerms: n,
					forceOpenInNewTab: s,
					isChatPost: a,
					isCommentPermalink: u,
					isCommentsPage: m,
					isOverlay: p,
					isPostSEOEligible: b,
					modModeEnabled: f,
					numComments: h,
					onClick: g,
					postPermalink: x,
					shouldOpenPostInNewTab: j,
					shouldShowIcon: I = !0,
					shouldShowText: k = !0,
					text: _,
					type: S,
					postId: T,
					isCommentCountAnimation: P,
					isCountAnimShadowTestEnabled: N,
					isBlockingInterstitialEnabled: D,
					isBlockingInterstitialV2Enabled: M,
					isSponsored: R,
					impressionId: L
				} = e;
				const B = Object(o.d)(),
					F = m && !u && !b,
					U = u && !p,
					H = Object(y.a)(),
					G = r.a.createElement(E, {
						hasModPostPerms: n,
						isCountAnimShadowTestEnabled: !!N,
						isChatPost: a,
						isCommentCountAnimation: !!P,
						modModeEnabled: f,
						numComments: h,
						postId: T,
						shouldShowIcon: I,
						shouldShowText: k,
						text: _,
						type: S
					});
				return F ? r.a.createElement("div", {
					className: Object(d.a)(v.a.commentsLink, v.a.defaultCursorWrapper, t),
					onClick: g
				}, G) : r.a.createElement(i.a, {
					rel: "nofollow",
					"data-click-id": "comments",
					"data-adclicklocation": w.b.COMMENTS,
					"data-test-id": O.a,
					className: Object(d.a)(v.a.commentsLink, v.a.link, t),
					target: s || j ? "_blank" : void 0,
					to: U ? Object(A.b)(x) : Object(c.a)(x, !0, H),
					onClick: e => {
						R && L && x.includes("impressionid") && Object(C.Fb)(L, T), (D || M) && (e.preventDefault(), B(Object(l.X)(Object(A.b)(x), T))), g && g()
					}
				}, G)
			})
		},
		"./src/reddit/components/CommonAutocompleteDropdown/index.m.less": function(e, t, n) {
			e.exports = {
				autocompleteLabel: "_39qccdns_RvOZZlRIIVGoK",
				locked: "_2WupD4z680kgaOvurMIh3K",
				labelIcon: "_3dK0j9mvmwPub-EQjQEF-f",
				lockIcon: "m15TxfKz9KwlKtTpuUOGU",
				autocompleteInput: "_2DhRYyE3X6UOdxywO4xoas",
				autocompleteInput__no_icon: "_2gDZgLjG5_0otT8r_3nrX9",
				autocompleteInputNoIcon: "_2gDZgLjG5_0otT8r_3nrX9",
				autocompleteInput__disabled: "_2y-MwvP_24hapwkGLPhGNv",
				autocompleteInputDisabled: "_2y-MwvP_24hapwkGLPhGNv",
				autocompleteInputContainer: "_3G7m5yzFmzVctZTxy3ZUkf",
				autocompleteDropdown: "nUeCIjmjHU-llTCBuUdnn",
				autocompleteDropdownItem: "_3eWYFOsdnA9K-Jw8qXFbfH",
				autocompleteDropdownItem__rtl: "_3e5-Tc_WqzN-NNzAg8R7T6",
				autocompleteDropdownItemRtl: "_3e5-Tc_WqzN-NNzAg8R7T6",
				autocompleteDropdownItem__icon: "_1x6PJuPScW1xzB8k-WzEN",
				autocompleteDropdownItemIcon: "_1x6PJuPScW1xzB8k-WzEN",
				highlight: "_2cIM3xprCSzGFYnQGsdVSL",
				selected: "_1EEVp702_ABu8mple5Dpfk"
			}
		},
		"./src/reddit/components/CommunityAwardList/AwardRow/index.m.less": function(e, t, n) {
			e.exports = {
				row: "_1SJYzo3UAyKEOF7dfuB9mj",
				awardName: "KMxVBNnYo_dcBwZGB9Y7a",
				unfilledAward: "_3s20dmDQOAFnj9VBvMb_K9",
				awardDetail: "_2NA5kHSdCz8PTAq-oiC2lE",
				awardExpiresDetail: "_23IvuOow0OJsmKnkmU_FEX",
				headerRow: "_1NbiD8qa7KncC2IlK9RoSb",
				awardIconImage: "_3sB_KQUJdYFc6cPgCjizd4",
				deleteIcon: "_1Aox5T2z7StzW_M0WfnDTe",
				rightAlign: "_3MpqTEDv3tS3-u-1uNAt6Y",
				createButton: "_3pXwHsShRJ0s12b9e-_gCX",
				emptyIcon: "yy-p6aZDVdPVBPBYMhbEy",
				emptyDetails: "LUZArpcpRdOTEPUDrjKVR",
				awardLoadingContainer: "_2WNYZIJMYIXJIS_IJIIiTe"
			}
		},
		"./src/reddit/components/CommunityAwardList/AwardSettings/index.m.less": function(e, t, n) {
			e.exports = {
				awardToggleContainer: "_2E_k43b0N9nhGQKfSvT_c_",
				emptyToggleContainer: "_1lQVQi-D8yElpWeJLbrix0",
				emptyToggleContainerLabel: "_2Porr9EjtYqQt8OhMaCU3h",
				optionalAwardInfo: "ZViyY3IDk7c6MplUKuCKa",
				awardToggleItem: "XwXRf6eWep27jKV1kkNDN",
				awardToggleLabelItem: "_2d9jt8apy5IwNRPdrC_RtG",
				awardIconWrapper: "_3DGDvlViP1uosxrUobijCu",
				awardIcon: "_10ar4v6qlEgLvqEhxk_wyP",
				awardInfoWrapper: "_2LxUe9vOie60H44Rkl5YYd",
				awardToggleItemDisabled: "_1touzuLFgoSGqEcDiLDD00",
				awardTitle: "_1fG-NkjOvo6khgB4qJmizu",
				awardDescription: "_2VABiA5W4pgqWyCK_oV4Hg"
			}
		},
		"./src/reddit/components/CommunityAwardList/index.m.less": function(e, t, n) {
			e.exports = {
				contentContainer: "_27C02100EX-RnLoDyL_PYT",
				newModNav: "_2Xfj4aJW8R1Hj8ZpArHZoc",
				gildIcon: "_3f4YbBVVbX4YXols-8AmgC",
				infoIcon: "_1HPeb_FxEOzicQ4BuIVonK",
				pageInfo: "_2bEhfADeSjJE-8zKoxjbGy",
				awardToDelete: "dzAx082Iu3F9M7xS-PL80",
				awardToDeleteIcon: "_11ikfBu3qqa0paYAJLQINO"
			}
		},
		"./src/reddit/components/CommunityAwardList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/gold/communityAwards/index.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/tooltip.ts"),
				p = n("./src/reddit/constants/gold.ts"),
				b = n("./src/reddit/helpers/awards/isEligibleForCommunityAwards.ts"),
				f = n("./src/reddit/helpers/awards/isEligibleForGlobalAwards.ts"),
				h = n("./src/reddit/helpers/correlationIdTracker.ts"),
				g = n("./src/reddit/helpers/trackers/communityAwards.ts"),
				v = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/higherOrderComponents/makeAsync.tsx")),
				x = n("./src/lib/loadWithRetries/index.ts");
			var E = Object(v.a)({
					getComponent: () => Object(x.a)(() => Promise.all([n.e("AwardCreationModal").then(n.bind(null, "./src/reddit/components/AwardCreationModal/index.tsx"))])).then(e => e[0].default),
					ErrorComponent: () => null,
					LoadingComponent: () => null
				}),
				O = n("./src/reddit/components/ModHub/NewModNav/PageLinks.tsx"),
				C = n("./src/reddit/models/Gold/Award.ts"),
				A = n("./src/reddit/components/ConfirmModal/index.tsx"),
				y = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				j = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				I = n("./src/reddit/components/TrackingHelper/index.tsx"),
				k = n("./src/reddit/featureFlags/index.ts"),
				_ = n("./src/reddit/icons/fonts/index.tsx"),
				S = n("./src/reddit/selectors/activeModalId.ts"),
				w = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				T = n("./node_modules/lodash/times.js"),
				P = n.n(T),
				N = n("./src/reddit/controls/Button/index.tsx"),
				D = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				M = n("./src/reddit/helpers/awards/isEligibleForTemporaryAwards.ts"),
				R = n("./src/reddit/layout/row/RightAlign/index.tsx"),
				L = n("./src/reddit/components/CommunityAwardList/AwardRow/index.m.less"),
				B = n.n(L);
			const {
				fbt: F
			} = n("./node_modules/fbt/lib/FbtPublic.js"), U = () => o.a.createElement("div", {
				className: B.a.row
			}, o.a.createElement("div", {
				className: B.a.awardName
			}, o.a.createElement("div", {
				className: B.a.emptyDetails
			})), o.a.createElement("div", {
				className: B.a.awardDetail
			}, o.a.createElement("div", {
				className: B.a.emptyIcon
			})), o.a.createElement("div", {
				className: B.a.awardDetail
			}, o.a.createElement("div", {
				className: B.a.emptyDetails
			})), o.a.createElement("div", {
				className: B.a.awardDetail
			}, o.a.createElement("div", {
				className: B.a.emptyDetails
			}))), H = e => o.a.createElement("div", {
				className: Object(d.a)(e.className, B.a.awardLoadingContainer)
			}, P()(10, e => o.a.createElement(U, {
				key: e
			}))), G = e => {
				let {
					subredditId: t
				} = e;
				return o.a.createElement("div", {
					className: B.a.headerRow
				}, o.a.createElement("div", {
					className: B.a.awardName
				}, F._("Name", null, {
					hk: "2rgEdc"
				})), o.a.createElement("div", {
					className: B.a.awardDetail
				}, F._("Icon", null, {
					hk: "zWzOj"
				})), o.a.createElement("div", {
					className: B.a.awardDetail
				}, F._("Coins", null, {
					hk: "2uhz31"
				})), o.a.createElement("div", {
					className: B.a.awardDetail
				}, F._("Type", null, {
					hk: "1rYgKO"
				})), Object(M.a)(t) && o.a.createElement("div", {
					className: B.a.awardDetail
				}, F._("Starts", null, {
					hk: "HW61W"
				})), Object(M.a)(t) && o.a.createElement("div", {
					className: B.a.awardDetail
				}, F._("Expires", null, {
					hk: "3hS2VX"
				})))
			}, Q = e => {
				let {
					date: t
				} = e;
				return o.a.createElement("div", {
					className: B.a.awardExpiresDetail
				}, t && t.toLocaleString())
			}, q = e => o.a.createElement("div", {
				className: B.a.row
			}, o.a.createElement("div", {
				className: Object(d.a)(B.a.awardName, B.a.unfilledAward)
			}, F._({
				"*": "Create up to {quantity} more {coin-price} Coin Awards",
				_1: "Create up to {quantity} more {coin-price} Coin Award"
			}, [F._param("quantity", e.quantity), F._param("coin-price", e.coinPrice), F._plural(e.quantity)], {
				hk: "4nSQI7"
			})), o.a.createElement(R.a, {
				className: B.a.rightAlign
			}, o.a.createElement(N.l, {
				className: B.a.createButton,
				onClick: e.onCreate
			}, F._("Create", null, {
				hk: "3aEi77"
			})))), W = e => o.a.createElement("div", {
				className: B.a.row
			}, o.a.createElement("div", {
				className: Object(d.a)(B.a.awardName, B.a.unfilledAward)
			}, F._("Create a Moderator-Only Award", null, {
				hk: "3aMmTo"
			})), o.a.createElement(R.a, {
				className: B.a.rightAlign
			}, o.a.createElement(N.l, {
				className: B.a.createButton,
				onClick: e.onCreate
			}, F._("Create", null, {
				hk: "3aEi77"
			})))), z = e => o.a.createElement("div", {
				className: B.a.row
			}, o.a.createElement("div", {
				className: Object(d.a)(B.a.awardName, B.a.unfilledAward)
			}, F._("Create an Award", null, {
				hk: "1zGxjw"
			})), o.a.createElement(R.a, {
				className: B.a.rightAlign
			}, o.a.createElement(N.l, {
				className: B.a.createButton,
				onClick: e.onCreate
			}, F._("Create", null, {
				hk: "3aEi77"
			}))));
			class V extends o.a.Component {
				constructor() {
					super(...arguments), this.onDelete = e => {
						e.preventDefault(), this.props.onDelete(this.props.award.id)
					}
				}
				render() {
					const {
						award: e,
						canDelete: t,
						iconUrl: n,
						subredditId: s
					} = this.props, r = Object(M.a)(s), i = e.startsAt ? new Date(e.startsAt) : void 0, a = e.endsAt ? new Date(e.endsAt) : void 0;
					return o.a.createElement("div", {
						className: B.a.row
					}, o.a.createElement("div", {
						className: B.a.awardName
					}, e.name), o.a.createElement("div", {
						className: B.a.awardDetail
					}, o.a.createElement("img", {
						className: B.a.awardIconImage,
						src: n,
						title: e.name
					})), o.a.createElement("div", {
						className: B.a.awardDetail
					}, e.coinPrice || 0), o.a.createElement("div", {
						className: B.a.awardDetail
					}, e.awardType === C.e.Moderator ? F._("Mod only", null, {
						hk: "UxkP0"
					}) : F._("All", null, {
						hk: "2J55F0"
					})), r && [o.a.createElement(Q, {
						key: "startDate",
						date: i
					}), o.a.createElement(Q, {
						key: "endDate",
						date: a
					})], o.a.createElement(R.a, {
						className: B.a.rightAlign
					}, t && o.a.createElement("a", {
						href: ".",
						onClick: this.onDelete
					}, o.a.createElement(D.b, {
						className: B.a.deleteIcon
					}))))
				}
			}
			var K = V,
				Y = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				J = n("./src/reddit/hooks/useTracking.ts"),
				X = n("./src/reddit/selectors/communityAwards.ts"),
				Z = n("./src/reddit/selectors/gold/awardIcon.ts"),
				$ = n("./src/reddit/components/CommunityAwardList/AwardSettings/index.m.less"),
				ee = n.n($);
			const {
				fbt: te
			} = n("./node_modules/fbt/lib/FbtPublic.js"), ne = e => {
				let {
					award: t,
					iconUrl: n
				} = e;
				return o.a.createElement("div", {
					className: ee.a.awardToggleLabelItem
				}, o.a.createElement("div", {
					className: ee.a.awardIconWrapper
				}, o.a.createElement("img", {
					className: ee.a.awardIcon,
					src: n
				})), o.a.createElement("div", {
					className: ee.a.awardInfoWrapper
				}, o.a.createElement("div", {
					className: ee.a.awardTitle
				}, t.name), o.a.createElement("div", {
					className: ee.a.awardDescription
				}, t.description)))
			};
			var se = e => {
					let {
						subredditOrProfile: t,
						subredditOrProfileId: n,
						moderatorPermissions: s
					} = e;
					const r = Object(i.d)(),
						a = Object(J.a)(),
						c = Object(i.e)(e => Object(X.f)(e, {
							subredditOrProfileId: n
						})),
						u = Object(i.e)(e => Object(X.d)(e, {
							subredditOrProfileId: n
						})),
						m = Object(i.e)(e => Object(Z.b)(e, {
							awards: c,
							minSize: 64
						}));
					if (!c.length) return o.a.createElement("div", {
						className: ee.a.emptyToggleContainer
					}, o.a.createElement("div", {
						className: ee.a.emptyToggleContainerLabel
					}, u ? te._("Pending", null, {
						hk: "1heuFt"
					}) : te._("No Awards currently available for configuration. Please try again later.", null, {
						hk: "3BsFsT"
					})));
					const p = s && s.all;
					return o.a.createElement("div", {
						className: ee.a.awardToggleContainer
					}, o.a.createElement("div", {
						className: ee.a.optionalAwardInfo
					}, te._("Toggle whether these awards are available in your community. If disabled, they cannot be given on any posts or comments.", null, {
						hk: "4e1OPL"
					})), o.a.createElement("div", null, c.map(e => o.a.createElement(Y.q, {
						key: e.id,
						on: e.isEnabled,
						forceOn: e.isEnabled,
						className: Object(d.a)(ee.a.awardToggleItem, {
							[ee.a.awardToggleItemDisabled]: !e.isEnabled
						}),
						label: o.a.createElement(ne, {
							award: e,
							iconUrl: m[e.id]
						}),
						onClick: () => (e => {
							const s = e.isEnabled ? l.g : l.h,
								o = e.isEnabled ? g.h : g.i;
							a(o(e, n)), p && r(s(t, e))
						})(e),
						disabled: !p
					}))))
				},
				re = n("./src/reddit/components/CommunityAwardList/index.m.less"),
				oe = n.n(re);
			const ie = Object(a.c)({
					awardIcons: (e, t) => {
						let {
							subredditOrProfileId: n
						} = t;
						const s = Object(X.e)(e, {
							subredditOrProfileId: n
						});
						return Object(Z.b)(e, {
							awards: s,
							minSize: 32
						})
					},
					awards: X.e,
					awardsPending: X.d,
					communityAwardsDisabled: X.b,
					isAddAwardModalOpen: e => Object(S.a)(e) === p.a,
					isConfirmModalOpen: e => Object(S.a)(e) === p.b,
					isInShredditModNavExperiment: (e, t) => {
						let {
							moderatorPermissions: n
						} = t;
						return Object(w.a)(e, !!n)
					},
					isBadgesAndEmotesEnabled: k.d.spCustomBadgesAndEmotes
				}),
				ae = Object(i.b)(ie, (e, t) => {
					let {
						subredditOrProfileId: n
					} = t;
					return {
						deleteAward: t => e(Object(l.j)(n, t)),
						toggleAddAwardModal: () => e(Object(u.i)(p.a)),
						toggleConfirmModal: () => e(Object(u.i)(p.b)),
						toggleTooltip: t => e(Object(m.h)({
							tooltipId: t
						}))
					}
				}),
				de = {
					awardId: null,
					selectedCoinPrice: void 0,
					selectedModOnly: void 0
				};
			class ce extends o.a.Component {
				constructor(e) {
					super(e), this.openAddAwardModal = (e, t) => {
						Object(h.d)(h.a.AwardCreationFlow), this.props.sendEvent(Object(g.e)()), this.setState({
							selectedCoinPrice: e,
							selectedModOnly: t
						}, this.props.toggleAddAwardModal)
					}, this.openDeleteAwardModal = e => {
						Object(h.d)(h.a.AwardDeletionFlow), this.props.toggleConfirmModal(), this.setState({
							awardId: e
						})
					}, this.confirmDeleteAward = () => {
						const {
							awardId: e
						} = this.state, {
							awards: t
						} = this.props;
						if (this.props.toggleConfirmModal(), e) {
							const n = t.filter(t => t.id === e)[0];
							n && this.props.sendEvent(Object(g.g)(n)), this.props.deleteAward(e), Object(h.b)(h.a.AwardDeletionFlow)
						}
					}, this.renderAwardSlotRow = e => {
						const {
							awardIcons: t,
							awards: n,
							moderatorPermissions: s,
							subredditOrProfileId: r
						} = this.props, i = !(!s || !s.all);
						if (!e.filled && n.length < p.d) return o.a.createElement(q, {
							coinPrice: e.price,
							key: e.price,
							onCreate: () => this.openAddAwardModal(e.price),
							quantity: e.quantity
						});
						if (!e.filled) return null;
						const {
							award: a
						} = e, d = t[a.id];
						return o.a.createElement(K, {
							key: a.id,
							award: a,
							canDelete: i,
							onDelete: this.openDeleteAwardModal,
							iconUrl: d,
							subredditId: r
						})
					}, this.renderAwardToDelete = () => {
						const {
							awards: e
						} = this.props, {
							awardId: t
						} = this.state;
						if (!t) return null;
						const n = e.filter(e => e.id === t)[0];
						return n ? o.a.createElement("div", {
							className: oe.a.awardToDelete
						}, o.a.createElement("span", null, s.fbt._("Remove:", null, {
							hk: "1Y4r4o"
						})), o.a.createElement("img", {
							src: n.icon.url,
							className: oe.a.awardToDeleteIcon
						}), o.a.createElement("span", null, n.name)) : null
					}, this.renderInfo = () => o.a.createElement("div", {
						className: oe.a.pageInfo
					}, o.a.createElement(_.a, {
						name: "info",
						className: oe.a.infoIcon
					}), o.a.createElement("p", null, s.fbt._("Community Awards are unique to each community, and members can give them to each other. Moderators can design and name the Awards however they want.", null, {
						hk: "1mzX5Y"
					})), o.a.createElement("p", null, s.fbt._("A portion of Coins from Community Award purchases will be deposited to the communitys Coin balance. Moderators can use Coins from that balance to reward members with Mod Awards. The Coin balance is shown only to moderators in the communitys sidebar", null, {
						hk: "2TVMDb"
					}))), this.state = de
				}
				renderAwardsList() {
					const {
						awards: e,
						awardsPending: t,
						moderatorPermissions: n,
						subredditOrProfileId: s
					} = this.props;
					if (t) return o.a.createElement(H, null);
					const r = Object(f.a)(s),
						i = n && n.all,
						a = this.getAwardSlots().filter(e => i && !r || e.filled),
						d = e.filter(e => e.awardType === C.e.Moderator),
						c = e.length < p.d && d.length < p.e && i && !r;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(G, {
						subredditId: s
					}), r && o.a.createElement(z, {
						onCreate: () => this.openAddAwardModal()
					}), a.map(this.renderAwardSlotRow), c && o.a.createElement(W, {
						onCreate: () => this.openAddAwardModal(void 0, !0)
					}), this.renderInfo())
				}
				getAwardSlots() {
					const {
						awards: e
					} = this.props, t = Object(C.k)(e), n = e => e.filled && e.award.awardType === C.e.Moderator;
					return t.sort((e, t) => n(e) && !n(t) ? 1 : n(t) && !n(e) ? -1 : e.price !== t.price ? e.price - t.price : e.filled && !t.filled ? -1 : (t.filled && e.filled, 1))
				}
				render() {
					const {
						communityAwardsDisabled: e,
						isAddAwardModalOpen: t,
						isConfirmModalOpen: n,
						moderatorPermissions: r,
						subredditOrProfile: i,
						subredditOrProfileId: a,
						toggleAddAwardModal: l,
						toggleConfirmModal: u,
						isInShredditModNavExperiment: m,
						isBadgesAndEmotesEnabled: p
					} = this.props, {
						awardId: f,
						selectedCoinPrice: g,
						selectedModOnly: v
					} = this.state, x = i.isNSFW || e;
					return o.a.createElement(o.a.Fragment, null, m && Object(O.a)(i.name, c.mc.Awards, p, "pt-md px-lg"), Object(b.a)(i) && o.a.createElement(j.a, {
						className: oe.a.contentContainer
					}, o.a.createElement(j.b, null, s.fbt._("Community Awards", null, {
						hk: "lraSi"
					})), x ? this.renderBlacklistedView() : this.renderAwardsList()), o.a.createElement(j.a, {
						className: Object(d.a)(oe.a.contentContainer, {
							[oe.a.newModNav]: m
						})
					}, !m && o.a.createElement(j.b, null, s.fbt._("Enable/Disable Awards", null, {
						hk: "1IRmfG"
					})), o.a.createElement(se, {
						subredditOrProfile: i,
						subredditOrProfileId: a,
						moderatorPermissions: r
					})), t && o.a.createElement(E, {
						defaultCoinPrice: g,
						defaultModOnly: v,
						subredditId: a,
						toggleModal: () => {
							l(), Object(h.b)(h.a.AwardCreationFlow)
						}
					}), n && f && o.a.createElement(A.a, {
						acceptText: s.fbt._("Delete", null, {
							hk: "4lt26q"
						}),
						cancelText: s.fbt._("Cancel", null, {
							hk: "2TSLl5"
						}),
						headerText: s.fbt._("Delete Award", null, {
							hk: "7q2D7"
						}),
						message: s.fbt._("Deleting an Award will remove the option for members of your community to give the Award. Existing Awards will remain on the posts and comments that have received them.", null, {
							hk: "3tX5sQ"
						}),
						onAccept: this.confirmDeleteAward,
						onCancel: u,
						onClose: u,
						onOverlayClick: u,
						withOverlay: !0
					}, this.renderAwardToDelete()))
				}
				renderBlacklistedView() {
					return o.a.createElement(y.c, {
						text: s.fbt._("Community Awards have been disabled for this community.", null, {
							hk: "2g21s6"
						})
					}, o.a.createElement(_.a, {
						name: "award",
						className: oe.a.gildIcon
					}))
				}
			}
			t.a = ae(Object(I.c)(ce))
		},
		"./src/reddit/components/CommunityChat/utils.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = (e, t) => `/r/ChatCommunityM0/channel/${e}/${(e=>e.toLowerCase().split(" ").join("_"))(t)}/`
		},
		"./src/reddit/components/CommunitySafetyFeatureAdoptionCampaign/BanEvasion/useBanEvasionAdoptionCampaign.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			})), n.d(t, "b", (function() {
				return f
			}));
			n("./node_modules/react/index.js");
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/constants/experiments.ts"),
				i = n("./src/reddit/constants/localStorage.ts"),
				a = n("./src/reddit/hooks/useExperimentVariant.ts"),
				d = n("./src/reddit/hooks/useLocalStorage.ts"),
				c = n("./src/reddit/hooks/useMounted.ts"),
				l = n("./src/reddit/selectors/platform.ts"),
				u = n("./src/reddit/selectors/subreddit.ts");
			const m = "hideBanEvasionCampaignUntil";

			function p() {
				return Object(a.a)(o.wb) === o.Yd
			}

			function b() {
				return function(e) {
					let {
						storageKey: t,
						setValueOnDismiss: n,
						checkIfDismissed: r
					} = e;
					var o;
					const a = p(),
						m = Object(s.e)(l.c),
						[b, f] = Object(d.a)(i.b.BAN_EVASION_CAMPAIGN_STORE, {}),
						h = Object(s.e)(e => Object(u.Z)(e, m)),
						g = Object(c.a)(),
						v = !(null === (o = null == h ? void 0 : h.banEvasionFilterSettings) || void 0 === o ? void 0 : o.isEnabled),
						x = !r(b[t]);
					return {
						showCampaign: g && a && v && x,
						dismissCampaign: () => f({
							...b,
							[t]: n()
						})
					}
				}({
					storageKey: m,
					setValueOnDismiss: () => Date.now() + 30 * r.D,
					checkIfDismissed: e => !!e && Date.now() < e
				})
			}

			function f() {
				return {
					showCampaign: p()
				}
			}
		},
		"./src/reddit/components/CommunitySettings/CountrySiteSettings/index.m.less": function(e, t, n) {
			e.exports = {
				countrySiteForm: "_3EwDpZ19gPFB461uuy7iGL",
				dropdownContainer: "_3XPnIpveWFDgMhBmnMyd9e",
				innerFlexboxContainer: "_1tHvQJ3zvN2gjV9HDwzxRj"
			}
		},
		"./src/reddit/components/CommunitySettings/ModPnSettings/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-CommunitySettings-ModPnSettings",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-CommunitySettings-ModPnSettings").then(n.bind(null, "./src/reddit/components/CommunitySettings/ModPnSettings/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/CommunitySettings/ModPnSettings/index.tsx"
				}
			});
			t.a = r
		},
		"./src/reddit/components/CommunitySettings/components.m.less": function(e, t, n) {
			e.exports = {
				InputField: "_3V4RO9mtZyZCWAu4P0ST4A",
				inputField: "_3V4RO9mtZyZCWAu4P0ST4A",
				FormContainer: "_37sNfY6fNJVPqyQXOHlg3K",
				formContainer: "_37sNfY6fNJVPqyQXOHlg3K"
			}
		},
		"./src/reddit/components/CommunitySettings/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "l", (function() {
				return l
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "o", (function() {
				return m
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "i", (function() {
				return b
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "k", (function() {
				return g
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "j", (function() {
				return x
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/redditGQL/types.ts");
			const o = 500,
				i = 100,
				a = 5e3,
				d = 0,
				c = 1440,
				l = 36600,
				u = 1e9,
				m = {
					disabled: s.fbt._("Disabled", null, {
						hk: "1KaunG"
					}).toString(),
					modonly: s.fbt._("Mods only", null, {
						hk: "2yA6R8"
					}).toString(),
					anyone: s.fbt._("Anyone", null, {
						hk: "4gPsEy"
					}).toString()
				},
				p = [s.fbt._("Wiki is disabled for all users except mods", null, {
					hk: "2loUiE"
				}).toString(), s.fbt._("Only mods, approved wiki contributors, or those on a page's edit list may edit", null, {
					hk: "1WUeVN"
				}).toString(), s.fbt._("Anyone who can submit to the community may edit", null, {
					hk: "3hxotT"
				}).toString()],
				b = {
					any: s.fbt._("Any", null, {
						hk: "hVUT8"
					}),
					link: s.fbt._("Links only", null, {
						hk: "3upkyk"
					}),
					self: s.fbt._("Text posts only", null, {
						hk: "1VZn8Y"
					})
				},
				f = [s.fbt._("Any post type is allowed", null, {
					hk: "1rOxtJ"
				}), s.fbt._("Only links to external sites are allowed", null, {
					hk: "OJQdj"
				}), s.fbt._("Only text posts are allowed", null, {
					hk: "3q3v14"
				})],
				h = {
					mods: s.fbt._("Moderators", null, {
						hk: "2rrkiT"
					}),
					anyone: s.fbt._("Anyone", null, {
						hk: "Xp8Fs"
					})
				},
				g = {
					[r.Y.Low]: s.fbt._("Low", null, {
						hk: "4k3iTe"
					}),
					[r.Y.High]: s.fbt._("High (default)", null, {
						hk: "2GOHsH"
					}),
					[r.Y.All]: s.fbt._("All", null, {
						hk: "gl6gc"
					})
				},
				v = {
					[r.Y.Low]: s.fbt._("Low (default)", null, {
						hk: "2tqJd7"
					}),
					[r.Y.High]: s.fbt._("High", null, {
						hk: "ABfkc"
					}),
					[r.Y.All]: s.fbt._("All", null, {
						hk: "3bPDOM"
					})
				},
				x = {
					blank: s.fbt._("none (recommended)", null, {
						hk: "2FMwQH"
					}),
					confidence: s.fbt._("best", null, {
						hk: "13cLYH"
					}),
					old: s.fbt._("old", null, {
						hk: "3V0QN8"
					}),
					top: s.fbt._("top", null, {
						hk: "40R5FY"
					}),
					qa: s.fbt._("q&a", null, {
						hk: "3cm6YL"
					}),
					live: s.fbt._("live (beta)", null, {
						hk: "2EVYAd"
					}),
					controversial: s.fbt._("controversial", null, {
						hk: "1uFV5F"
					}),
					new: s.fbt._("new", null, {
						hk: "39TZi6"
					})
				}
		},
		"./src/reddit/components/CommunitySettings/index.m.less": function(e, t, n) {
			e.exports = {
				pageTitle: "_1YwfovPToau7hk7kk7VjvV",
				communityTopicsHelpLink: "_2Tzl9XrmQzUn94gYHRUYMI",
				welcomeMessageHelpLink: "_3-XV8EhlxRlIzoFKUI6gmQ",
				fullWidthTextContainer: "_2SnK_8NMPSqmFfF-es2GGa",
				subtextContainer: "_2sWG233wmE9wNycTEyRHRN",
				sectionHeadingFollowedBySubtext: "_2znhaJWCK6NY6bIPtrS2sx",
				sectionSubtext: "_2gZA-d4bPf-v-QStyl39CP",
				subtextLink: "_3m7YXm3a55mNltI6wwKkal",
				numCommunityTopicsSelected: "Ty_datAAaSbn2GX5-1O58",
				welcomeMessageEnabled: "_21a0DjKnRl3i1ItjJ8cSyf",
				geoForm: "_1QCMnCbDgm4T-QmBwOFkQ7",
				geoText: "lhgqy5yEx-4vqJhuaRIW_",
				geoInput: "_20j3hiEorqFwMLxftPVQG1",
				contentTag: "_26M_DkGPAeiqHaMshbczhg",
				navExperiment: "TFMisOd4aV7HkFY2Ajy9G",
				contentTagColumn: "_2lbeaHzGFIYy6MK6YfLqrd",
				ratingAudience: "_3HR2r8RW7cFhNSKPiAT6VO",
				ratingDescription: "_3Wy4OBl1ksNXzpoeV4dvli",
				ratingReason: "_254fRg3JX4apEtqVAAXfbm",
				promptText: "RqDOw50ARYjx_TliwJR0l",
				surveyButton: "_7aZGYzh7hj5VihV4LcNzP",
				previewButton: "_2OmdANJm2jP7a_6G2-JCqg",
				disabled: "_3DyIlr3eqm1Pq3T9Jx0Kgx",
				rangeSetting: "_3BfcidCIw4ZNn2i2jR7fKT",
				noMarginHeading: "kt9ucKpVrHFhY-_xvYiLF",
				flexSpacer: "_2urERRC5ZgXlBwG8augYFu",
				labelWithNewTag: "_2tw6jmSgf4-SvF7sT8DIwT",
				labelNewTag: "_1W9XvmIuDMXygCmP-t8uxn",
				topBar: "_2GTR21vQAwXpBb8dasZaFl",
				default: "_2ngoBnEVrKEN4yBK3Rce_E"
			}
		},
		"./src/reddit/components/CommunitySettings/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/isEqual.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/actions/pages/shared.ts"),
				m = n("./src/reddit/actions/subredditSettings.ts"),
				p = n("./src/lib/makeActionCreator/index.ts"),
				b = n("./src/lib/makeGqlRequest/index.ts"),
				f = (n("./src/redditGQL/operations/GetSubredditWelcomeMessage.json"), n("./src/redditGQL/operations/UpdateSubredditWelcomeMessage.json"));
			const h = e => {
				if (e) return {
					...e
				}
			};
			const g = (e, t, n) => async (s, r, o) => {
				let {
					gqlContext: i
				} = o;
				const a = {
						subredditId: e,
						isWelcomeMessageEnabled: t,
						welcomeMessage: {
							markdown: n
						}
					},
					d = await ((e, t) => Object(b.a)(e, {
						...f,
						variables: t
					}))(i(), {
						input: a
					});
				if (d.ok) {
					const t = (e => {
						var t, n;
						const s = null === (n = null === (t = null == e ? void 0 : e.data.updateSubredditSettings) || void 0 === t ? void 0 : t.subreddit) || void 0 === n ? void 0 : n.welcomeMessage;
						return h(s)
					})(d.body);
					t && s(v({
						subredditId: e,
						welcomeMessage: t
					}))
				}
			}, v = Object(p.a)("SUBREDDIT_WELCOME_MESSAGE__LOADED");
			var x = n("./src/reddit/actions/tags/index.ts"),
				E = n("./src/lib/lessComponent.tsx"),
				O = n("./src/reddit/controls/FormFields/index.tsx"),
				C = n("./src/reddit/components/CommunitySettings/components.m.less"),
				A = n.n(C);
			const y = E.a.wrapped(O.b, "InputField", A.a),
				j = E.a.div("FormContainer", A.a);
			var I = n("./src/reddit/components/CommunitySettings/ModPnSettings/Loader.tsx"),
				k = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				_ = n("./src/reddit/components/TrackingHelper/index.tsx"),
				S = n("./src/reddit/controls/Button/index.tsx"),
				w = n("./src/reddit/helpers/trackers/communitySettings.ts"),
				T = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				P = n("./src/reddit/models/Tags/index.ts"),
				N = n("./src/reddit/selectors/chatPost.ts"),
				D = n("./src/reddit/selectors/subreddit.ts");
			var M = n("./src/reddit/selectors/subredditSettings.ts"),
				R = n("./src/reddit/selectors/tags.ts"),
				L = n("./src/reddit/selectors/user.ts"),
				B = n("./src/reddit/actions/countrySites/subredditCountrySiteSettings.ts"),
				F = n("./src/reddit/selectors/experiments/countrySites.ts"),
				U = n("./src/reddit/selectors/experiments/nsfwCommunityMediaUpload.ts"),
				H = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				G = n("./src/reddit/selectors/moderatorPermissions.ts"),
				Q = n("./src/redditGQL/types.ts"),
				q = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/config.ts")),
				W = n("./node_modules/fbt/lib/FbtPublic.js"),
				z = n("./src/reddit/components/CommunityTopics/index.tsx"),
				V = n("./src/reddit/components/CommunityTopics/NumTopicsSelected.tsx"),
				K = n("./src/reddit/components/CommunityTopics/PrimaryTopic/index.tsx"),
				Y = n("./src/reddit/components/CommunityTopics/SuggestedTopics/index.tsx"),
				J = n("./src/reddit/components/Settings/shared/SectionHeading.tsx"),
				X = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				Z = n("./src/reddit/components/SubredditCreationModal/index.tsx"),
				$ = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				ee = n("./src/reddit/controls/RadioInput/index.tsx"),
				te = n("./src/reddit/models/Flair/index.ts"),
				ne = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				se = n("./src/reddit/components/CommunitySettings/helpers.ts"),
				re = n("./src/reddit/actions/toaster.ts"),
				oe = n("./src/reddit/components/GeoForm/GeoForm.tsx"),
				ie = n("./src/reddit/components/ModHub/ModHubNav/NavItem.tsx"),
				ae = n("./src/reddit/endpoints/geotagging/setSubredditGeoPlace.ts"),
				de = n("./src/reddit/helpers/localStorage/index.ts"),
				ce = n("./src/reddit/hooks/useGqlContext.ts"),
				le = n("./src/reddit/models/Toast/index.ts"),
				ue = [{
					value: "Global",
					countryCode: "*",
					icon: ""
				}, {
					value: "United States",
					countryCode: "US",
					icon: ""
				}, {
					value: "Argentina",
					countryCode: "AR",
					icon: ""
				}, {
					value: "Australia",
					countryCode: "AU",
					icon: ""
				}, {
					value: "Austria",
					countryCode: "AT",
					icon: ""
				}, {
					value: "Belgium",
					countryCode: "BE",
					icon: ""
				}, {
					value: "Brazil",
					countryCode: "BR",
					icon: ""
				}, {
					value: "Canada",
					countryCode: "CA",
					icon: ""
				}, {
					value: "Chile",
					countryCode: "CL",
					icon: ""
				}, {
					value: "Colombia",
					countryCode: "CO",
					icon: ""
				}, {
					value: "Czech Republic",
					countryCode: "CZ",
					icon: ""
				}, {
					value: "Denmark",
					countryCode: "DK",
					icon: ""
				}, {
					value: "Egypt",
					countryCode: "EG",
					icon: ""
				}, {
					value: "Finland",
					countryCode: "FI",
					icon: ""
				}, {
					value: "France",
					countryCode: "FR",
					icon: ""
				}, {
					value: "Germany",
					countryCode: "DE",
					icon: ""
				}, {
					value: "Greece",
					countryCode: "GR",
					icon: ""
				}, {
					value: "Hungary",
					countryCode: "HU",
					icon: ""
				}, {
					value: "India",
					countryCode: "IN",
					icon: ""
				}, {
					value: "Indonesia",
					countryCode: "ID",
					icon: ""
				}, {
					value: "Ireland",
					countryCode: "IE",
					icon: ""
				}, {
					value: "Italy",
					countryCode: "IT",
					icon: ""
				}, {
					value: "Japan",
					countryCode: "JP",
					icon: ""
				}, {
					value: "Korea, Republic of",
					countryCode: "KR",
					icon: ""
				}, {
					value: "Malaysia",
					countryCode: "MY",
					icon: ""
				}, {
					value: "Mexico",
					countryCode: "MX",
					icon: ""
				}, {
					value: "Netherlands",
					countryCode: "NL",
					icon: ""
				}, {
					value: "New Zealand",
					countryCode: "NZ",
					icon: ""
				}, {
					value: "Nigeria",
					countryCode: "NG",
					icon: ""
				}, {
					value: "Norway",
					countryCode: "NO",
					icon: ""
				}, {
					value: "Peru",
					countryCode: "PE",
					icon: ""
				}, {
					value: "Philippines",
					countryCode: "PH",
					icon: ""
				}, {
					value: "Poland",
					countryCode: "PL",
					icon: ""
				}, {
					value: "Portugal",
					countryCode: "PT",
					icon: ""
				}, {
					value: "Romania",
					countryCode: "RO",
					icon: ""
				}, {
					value: "Russia",
					countryCode: "RU",
					icon: ""
				}, {
					value: "Saudi Arabia",
					countryCode: "SA",
					icon: ""
				}, {
					value: "Singapore",
					countryCode: "SG",
					icon: ""
				}, {
					value: "South Africa",
					countryCode: "ZA",
					icon: ""
				}, {
					value: "Spain",
					countryCode: "ES",
					icon: ""
				}, {
					value: "Sweden",
					countryCode: "SE",
					icon: ""
				}, {
					value: "Switzerland",
					countryCode: "CH",
					icon: ""
				}, {
					value: "Thailand",
					countryCode: "TH",
					icon: ""
				}, {
					value: "Turkey",
					countryCode: "TR",
					icon: ""
				}, {
					value: "United Arab Emirates",
					countryCode: "AE",
					icon: ""
				}, {
					value: "United Kingdom",
					countryCode: "UK",
					icon: ""
				}, {
					value: "Vietnam",
					countryCode: "VN",
					icon: ""
				}];
			var me = [Object.freeze({
					isoCode: "",
					displayName: "Other",
					englishName: "Other",
					rtl: !1
				}), Object.freeze({
					isoCode: "af",
					displayName: "Afrikaans",
					englishName: "Afrikaans",
					rtl: !1
				}), Object.freeze({
					isoCode: "az",
					displayName: "Azrbaycan",
					englishName: "Azerbaijani",
					rtl: !1
				}), Object.freeze({
					isoCode: "id",
					displayName: "Bahasa Indonesia",
					englishName: "Indonesian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ms",
					displayName: "Bahasa Melayu",
					englishName: "Malay",
					rtl: !1
				}), Object.freeze({
					isoCode: "bs",
					displayName: "Bosanski",
					englishName: "Bosnian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ca",
					displayName: "Catal",
					englishName: "Catalan",
					rtl: !1
				}), Object.freeze({
					isoCode: "cs",
					displayName: "etina",
					englishName: "Czech",
					rtl: !1
				}), Object.freeze({
					isoCode: "da",
					displayName: "Dansk",
					englishName: "Danish",
					rtl: !1
				}), Object.freeze({
					isoCode: "de",
					displayName: "Deutsch",
					englishName: "German",
					rtl: !1
				}), Object.freeze({
					isoCode: "et",
					displayName: "Eesti",
					englishName: "Estonian",
					rtl: !1
				}), Object.freeze({
					isoCode: "en",
					displayName: "English",
					englishName: "English",
					rtl: !1
				}), Object.freeze({
					isoCode: "en-IN",
					displayName: "English (India)",
					englishName: "English (India)",
					rtl: !1
				}), Object.freeze({
					isoCode: "en-GB",
					displayName: "English (UK)",
					englishName: "English (UK)",
					rtl: !1
				}), Object.freeze({
					isoCode: "en-US",
					displayName: "English (US)",
					englishName: "English (US)",
					rtl: !1
				}), Object.freeze({
					isoCode: "es-ES",
					displayName: "Espaol (Espaa)",
					englishName: "Spanish (Spain)",
					rtl: !1
				}), Object.freeze({
					isoCode: "es",
					displayName: "Espaol (Latinoamrica)",
					englishName: "Spanish (Latam)",
					rtl: !1
				}), Object.freeze({
					isoCode: "es-US",
					displayName: "Espaol (US)",
					englishName: "Spanish (US)",
					rtl: !1
				}), Object.freeze({
					isoCode: "eu",
					displayName: "Euskara",
					englishName: "Basque",
					rtl: !1
				}), Object.freeze({
					isoCode: "tl",
					displayName: "Filipino",
					englishName: "Filipino",
					rtl: !1
				}), Object.freeze({
					isoCode: "fr",
					displayName: "Franais",
					englishName: "French",
					rtl: !1
				}), Object.freeze({
					isoCode: "fr-CA",
					displayName: "Franais (Canada)",
					englishName: "French Canada",
					rtl: !1
				}), Object.freeze({
					isoCode: "gl",
					displayName: "Galego",
					englishName: "Galician",
					rtl: !1
				}), Object.freeze({
					isoCode: "hr",
					displayName: "Hrvatski",
					englishName: "Croatian",
					rtl: !1
				}), Object.freeze({
					isoCode: "zu",
					displayName: "IsiZulu",
					englishName: "Zulu",
					rtl: !1
				}), Object.freeze({
					isoCode: "is",
					displayName: "slenska",
					englishName: "Icelandic",
					rtl: !1
				}), Object.freeze({
					isoCode: "it",
					displayName: "Italiano",
					englishName: "Italian",
					rtl: !1
				}), Object.freeze({
					isoCode: "sw",
					displayName: "Kiswahili",
					englishName: "Swahili",
					rtl: !1
				}), Object.freeze({
					isoCode: "lv",
					displayName: "Latvieu",
					englishName: "Latvian",
					rtl: !1
				}), Object.freeze({
					isoCode: "lt",
					displayName: "Lietuvi",
					englishName: "Lithuanian",
					rtl: !1
				}), Object.freeze({
					isoCode: "hu",
					displayName: "Magyar",
					englishName: "Hungarian",
					rtl: !1
				}), Object.freeze({
					isoCode: "nl",
					displayName: "Nederlands",
					englishName: "Dutch",
					rtl: !1
				}), Object.freeze({
					isoCode: "no",
					displayName: "Norsk",
					englishName: "Norwegian",
					rtl: !1
				}), Object.freeze({
					isoCode: "uz",
					displayName: "Ozbek",
					englishName: "Uzbek",
					rtl: !1
				}), Object.freeze({
					isoCode: "pl",
					displayName: "Polski",
					englishName: "Polish",
					rtl: !1
				}), Object.freeze({
					isoCode: "pt",
					displayName: "Portugus",
					englishName: "Portugues",
					rtl: !1
				}), Object.freeze({
					isoCode: "pt-BR",
					displayName: "Portugus (Brasil)",
					englishName: "Portugues (Brazil)",
					rtl: !1
				}), Object.freeze({
					isoCode: "ro",
					displayName: "Romn",
					englishName: "Romanian",
					rtl: !1
				}), Object.freeze({
					isoCode: "sq",
					displayName: "Shqip",
					englishName: "Sango",
					rtl: !1
				}), Object.freeze({
					isoCode: "sk",
					displayName: "Slovenina",
					englishName: "Slovak",
					rtl: !1
				}), Object.freeze({
					isoCode: "sl",
					displayName: "Slovenina",
					englishName: "Slovenian",
					rtl: !1
				}), Object.freeze({
					isoCode: "sr",
					displayName: "Srpski",
					englishName: "Serbian",
					rtl: !1
				}), Object.freeze({
					isoCode: "fi",
					displayName: "Suomi",
					englishName: "Finnish",
					rtl: !1
				}), Object.freeze({
					isoCode: "sv",
					displayName: "Svenska",
					englishName: "Swedish",
					rtl: !1
				}), Object.freeze({
					isoCode: "vi",
					displayName: "Ting Vit",
					englishName: "Vietnamese",
					rtl: !1
				}), Object.freeze({
					isoCode: "tr",
					displayName: "Trke",
					englishName: "Turkish",
					rtl: !1
				}), Object.freeze({
					isoCode: "el",
					displayName: "",
					englishName: "Greek, Modern",
					rtl: !1
				}), Object.freeze({
					isoCode: "be",
					displayName: "",
					englishName: "Belarusian",
					rtl: !1
				}), Object.freeze({
					isoCode: "bg",
					displayName: "",
					englishName: "Bulgarian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ky",
					displayName: "",
					englishName: "Kirghiz",
					rtl: !1
				}), Object.freeze({
					isoCode: "kk",
					displayName: " ",
					englishName: "Kazakh",
					rtl: !1
				}), Object.freeze({
					isoCode: "mk",
					displayName: "",
					englishName: "Macedonian",
					rtl: !1
				}), Object.freeze({
					isoCode: "mn",
					displayName: "",
					englishName: "Mongolian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ru",
					displayName: "",
					englishName: "Russian",
					rtl: !1
				}), Object.freeze({
					isoCode: "sr",
					displayName: "",
					englishName: "Serbian",
					rtl: !1
				}), Object.freeze({
					isoCode: "uk",
					displayName: "",
					englishName: "Ukrainian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ka",
					displayName: "",
					englishName: "Georgian",
					rtl: !1
				}), Object.freeze({
					isoCode: "hy",
					displayName: "",
					englishName: "Armenian",
					rtl: !1
				}), Object.freeze({
					isoCode: "he",
					displayName: "",
					englishName: "Hebrew",
					rtl: !0
				}), Object.freeze({
					isoCode: "ur",
					displayName: "",
					englishName: "Urdu",
					rtl: !0
				}), Object.freeze({
					isoCode: "ar",
					displayName: "",
					englishName: "Arabic",
					rtl: !0
				}), Object.freeze({
					isoCode: "fa",
					displayName: "",
					englishName: "Persian",
					rtl: !0
				}), Object.freeze({
					isoCode: "am",
					displayName: "",
					englishName: "Amharic",
					rtl: !1
				}), Object.freeze({
					isoCode: "ne",
					displayName: "",
					englishName: "Nepali",
					rtl: !1
				}), Object.freeze({
					isoCode: "mr",
					displayName: "",
					englishName: "Marathi",
					rtl: !1
				}), Object.freeze({
					isoCode: "hi",
					displayName: "",
					englishName: "Hindi",
					rtl: !1
				}), Object.freeze({
					isoCode: "as",
					displayName: "",
					englishName: "Assamese",
					rtl: !1
				}), Object.freeze({
					isoCode: "bn",
					displayName: "",
					englishName: "Bengali",
					rtl: !1
				}), Object.freeze({
					isoCode: "pa",
					displayName: "",
					englishName: "Punjabi",
					rtl: !1
				}), Object.freeze({
					isoCode: "gu",
					displayName: "",
					englishName: "Gujarati",
					rtl: !1
				}), Object.freeze({
					isoCode: "or",
					displayName: "",
					englishName: "Oriya",
					rtl: !1
				}), Object.freeze({
					isoCode: "ta",
					displayName: "",
					englishName: "Tamil",
					rtl: !1
				}), Object.freeze({
					isoCode: "te",
					displayName: "",
					englishName: "Telugu",
					rtl: !1
				}), Object.freeze({
					isoCode: "kn",
					displayName: "",
					englishName: "Kannada",
					rtl: !1
				}), Object.freeze({
					isoCode: "ml",
					displayName: "",
					englishName: "Malayalam",
					rtl: !1
				}), Object.freeze({
					isoCode: "si",
					displayName: "",
					englishName: "Sinhala",
					rtl: !1
				}), Object.freeze({
					isoCode: "th",
					displayName: "",
					englishName: "Thai",
					rtl: !1
				}), Object.freeze({
					isoCode: "lo",
					displayName: "",
					englishName: "Lao",
					rtl: !1
				}), Object.freeze({
					isoCode: "my",
					displayName: "",
					englishName: "Burmese",
					rtl: !1
				}), Object.freeze({
					isoCode: "km",
					displayName: "",
					englishName: "Central Khmer",
					rtl: !1
				}), Object.freeze({
					isoCode: "ko",
					displayName: "",
					englishName: "Korean",
					rtl: !1
				}), Object.freeze({
					isoCode: "zh-CN",
					displayName: " ()",
					englishName: "Chinese (Simplified)",
					rtl: !1
				}), Object.freeze({
					isoCode: "zh",
					displayName: " ()",
					englishName: "Chinese (Traditional)",
					rtl: !1
				}), Object.freeze({
					isoCode: "zh-HK",
					displayName: " ()",
					englishName: "Chinese (Hong Kong)",
					rtl: !1
				}), Object.freeze({
					isoCode: "ja",
					displayName: "",
					englishName: "Japanese",
					rtl: !1
				})],
				pe = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				be = n("./src/lib/humanizeDate/index.ts"),
				fe = n("./src/reddit/constants/keycodes.ts"),
				he = n("./src/reddit/icons/svgs/Lock/index.tsx"),
				ge = n("./src/reddit/components/CommonAutocompleteDropdown/index.m.less"),
				ve = n.n(ge);

			function xe(e) {
				const {
					icons: t = !0,
					id: n,
					items: s,
					currentIndex: r,
					selectValue: a
				} = e, d = Object(o.useRef)(null);
				return Object(o.useEffect)(() => {
					var e;
					let t = 30 * r;
					r > 10 && (t += 120), d && (null === (e = d.current) || void 0 === e || e.scrollTo({
						top: t
					}))
				}, [r]), i.a.createElement("ul", {
					className: ve.a.autocompleteDropdown,
					id: `autocomplete-dropdown-${n}`,
					"data-testid": `autocomplete-dropdown-${n}`,
					ref: d
				}, s.map((e, n) => i.a.createElement("li", {
					onClick: () => a(n),
					key: `${n}`,
					className: Object(c.a)({
						[ve.a.highlight]: n === r
					}, ve.a.autocompleteDropdownItem, {
						[ve.a.autocompleteDropdownItem__rtl]: e.rtl
					})
				}, t && e.icon && i.a.createElement("span", {
					role: "img",
					"aria-label": e.value,
					className: ve.a.autocompleteDropdownItem__icon
				}, e.icon), e.value)))
			}
			const Ee = (e, t) => t.filter(t => 0 === t.value.toLowerCase().indexOf(e.toLocaleLowerCase()));

			function Oe(e) {
				var t, n;
				const {
					className: s,
					customClickEvent: r,
					disabled: a,
					defaultIcon: d,
					icons: l = !1,
					initialItemIndex: u,
					listItems: m,
					locked: p = !1,
					placeholderText: b,
					sessionId: f,
					setSelectedParent: h
				} = e, [g, v] = Object(o.useState)(u), [x, E] = Object(o.useState)(m), [O, C] = Object(o.useState)(!0), [A, y] = Object(o.useState)((null === (t = m[u]) || void 0 === t ? void 0 : t.value) || ""), j = `autocomplete-input-${f}`, I = Object(o.useRef)(), k = (e, t) => {
					p || (C(!0), !t && e > -1 && (e = m.findIndex(t => x[e].key === t.key)), v(e), y(e > -1 && m[e].value || ""), h(e), E(m))
				};
				return Object(o.useEffect)(() => {
					var e;
					const t = function(e) {
						if (I && I.current) {
							I.current.contains(e.target) || C(!0)
						}
					};
					return v(u), y((null === (e = m[u]) || void 0 === e ? void 0 : e.value) || ""), document.addEventListener("click", t), () => document.removeEventListener("click", t)
				}, [u, m]), i.a.createElement("div", {
					className: ve.a.autocompleteInputContainer,
					ref: I
				}, l && i.a.createElement("label", {
					className: ve.a.autocompleteLabel,
					htmlFor: j
				}, (null === (n = x[g]) || void 0 === n ? void 0 : n.icon) || d), a ? i.a.createElement("span", {
					className: Object(c.a)(ve.a.autocompleteInput, ve.a.autocompleteInput__disabled, s)
				}, -1 !== u && m[u].value) : i.a.createElement("input", {
					id: `autocomplete-input-${f}`,
					"data-testid": `autocomplete-input-${f}`,
					className: Object(c.a)(ve.a.autocompleteInput, s, !l && ve.a.autocompleteInput__no_icon),
					name: j,
					value: A,
					placeholder: b,
					onChange: e => {
						p || (-1 !== g && (v(-1), h(-1)), y(e.currentTarget.value), E(Ee(e.currentTarget.value, m)))
					},
					onKeyDown: e => {
						if (p) return;
						let t = -1;
						const n = x.length > 0;
						C(!1), n && e.key === fe.b.ArrowDown ? (t = Math.min(g + 1, x.length - 1), v(t), h(-1), t > -1 && t < x.length && y(x[t].value)) : n && e.key === fe.b.ArrowUp ? (t = Math.max(g - 1, -1), v(t), h(-1), t > -1 && t < x.length ? y(x[t].value) : y("")) : n && e.key === fe.b.Enter ? (e.preventDefault(), g > -1 && g < x.length ? k(g, !1) : 1 === x.length && k(0, !1)) : e.key === fe.b.Backspace ? h(-1) : e.key === fe.b.Escape ? (C(!0), u > -1 && ("" !== A && k(u, !0), "" === A && k(-1, !0))) : e.key === fe.b.Tab && (C(!0), -1 !== g ? k(g, !1) : ("" !== A && k(u, !0), "" === A && k(-1, !0)))
					},
					onClick: () => {
						C(!1), r()
					},
					onFocus: () => {
						C(!1)
					}
				}), p && i.a.createElement("span", {
					className: ve.a.locked
				}, i.a.createElement(he.a, {
					className: ve.a.lockIcon
				})), p || a || O || !x.length ? null : i.a.createElement(xe, {
					id: f,
					items: x,
					currentIndex: g,
					selectValue: e => (e => {
						k(e, !1)
					})(e)
				}))
			}
			var Ce, Ae = n("./src/reddit/components/CommunitySettings/CountrySiteSettings/index.m.less"),
				ye = n.n(Ae);
			! function(e) {
				e[e.CountryForm = 0] = "CountryForm", e[e.LanguageForm = 1] = "LanguageForm"
			}(Ce || (Ce = {}));
			var je = Object(_.c)((function(e) {
					const {
						defaultIcon: t = "",
						formType: n,
						icons: s = !0,
						initialSubredditCountrySite: r,
						inputClassName: d,
						placeholderText: c,
						subredditId: l,
						listItems: u
					} = e, m = n === Ce.CountryForm, p = m ? "countryCode" : "languageCode", b = Object(a.d)();
					let f = r && r[p] || "";
					m && (f = f.toUpperCase());
					const [h] = Object(o.useState)(() => Object(pe.a)()), g = r && !(null == r ? void 0 : r.isCountrySiteEditable) || !1, v = m ? "country" : "language", x = r && m ? r.countryCode : (null == r ? void 0 : r.languageCode) || "";
					return i.a.createElement(i.a.Fragment, null, i.a.createElement("div", {
						className: ye.a.countrySiteForm
					}, i.a.createElement("div", {
						className: ye.a.dropdownContainer
					}, i.a.createElement(Oe, {
						className: d,
						defaultIcon: t,
						disabled: g,
						icons: s,
						initialItemIndex: (() => f ? u.findIndex(e => f.toUpperCase() === e.key.toUpperCase()) : -1)(),
						listItems: u,
						locked: g,
						placeholderText: c,
						sessionId: h,
						setSelectedParent: e => (e => {
							if (-1 !== e) {
								let t = u[e].code,
									n = r && r.languageCode || "";
								m || (t = r && r.countryCode || "", n = u[e].code), b(Object(B.g)({
									subredditId: l,
									subredditCountrySite: {
										countryCode: t,
										languageCode: n,
										isCountrySiteEditable: (null == r ? void 0 : r.isCountrySiteEditable) || !0,
										modMigrationAt: (null == r ? void 0 : r.modMigrationAt) || void 0
									}
								}))
							}
						})(e),
						customClickEvent: () => e.sendEvent(Object(w.a)(v, x))
					})), g && r && i.a.createElement(X.o, null, W.fbt._("This setting was saved by a mod on {modMigrationDate} and cant be changed", [W.fbt._param("modMigrationDate", (e => {
						if (!e || !e.modMigrationAt) return "";
						const t = Date.parse(e.modMigrationAt);
						return Object(be.a)(t / 1e3, {
							showDay: !0
						})
					})(r))], {
						hk: "3OWLnm"
					}))))
				})),
				Ie = n("./src/reddit/components/CommunitySettings/index.m.less"),
				ke = n.n(Ie);

			function _e(e) {
				var t;
				const {
					initialPlace: n,
					initialSubredditCountrySite: s,
					subredditId: r,
					subredditCountryEditEnabled: d = !1,
					subredditLanguageEditEnabled: l = !1,
					update: u
				} = e, m = Object(ce.a)(), p = Object(a.d)(), [b, f] = Object(o.useState)(n), [h, g] = Object(o.useState)(!1), [v, x] = Object(o.useState)(!0);
				return Object(o.useEffect)(() => {
					x(Object(de.M)("location")), Object(de.Pb)("location")
				}, []), i.a.createElement(i.a.Fragment, null, i.a.createElement(J.a, {
					className: ke.a.noMarginHeading
				}, W.fbt._("Community Location and main language", null, {
					hk: "3qWqzm"
				})), i.a.createElement(X.o, null, W.fbt._("Adding a location helps your community show up in search results and recommendations and helps local redditors find it easier.", null, {
					hk: "3m21GN"
				})), i.a.createElement("div", {
					className: ke.a.flexSpacer
				}), l && i.a.createElement(X.m, {
					label: i.a.createElement(i.a.Fragment, null, W.fbt._("Language", null, {
						hk: "4iQFeH"
					}), !v && i.a.createElement(ie.a, null)),
					textContainerClassName: Object(c.a)(ke.a.fullWidthTextContainer, ke.a.geoText)
				}, i.a.createElement(je, {
					defaultIcon: "",
					icons: !1,
					formType: Ce.LanguageForm,
					initialSubredditCountrySite: s,
					inputClassName: ke.a.autocompleteInput,
					listItems: Array.from(me, e => ({
						code: e.isoCode,
						key: e.isoCode,
						icon: "",
						value: e.displayName,
						rtl: e.rtl
					})),
					placeholderText: W.fbt._("Type to search for a language", null, {
						hk: "4dZ6Zv"
					}),
					subredditId: r
				})), d && i.a.createElement(X.m, {
					label: i.a.createElement(i.a.Fragment, null, W.fbt._("Country", null, {
						hk: "1tNtsz"
					}), !v && i.a.createElement(ie.a, null)),
					textContainerClassName: Object(c.a)(ke.a.fullWidthTextContainer, ke.a.geoText)
				}, i.a.createElement(je, {
					formType: Ce.CountryForm,
					initialSubredditCountrySite: s,
					inputClassName: ke.a.autocompleteInput,
					listItems: Array.from(ue, e => ({
						code: e.countryCode || "",
						key: e.countryCode || "",
						icon: e.icon,
						value: e.value
					})),
					placeholderText: W.fbt._("Type to search for a country", null, {
						hk: "51VKS"
					}),
					subredditId: r
				})), i.a.createElement(X.m, {
					label: i.a.createElement(i.a.Fragment, null, W.fbt._("Region", null, {
						hk: "scpaL"
					}), !v && i.a.createElement(ie.a, null)),
					textContainerClassName: Object(c.a)(ke.a.fullWidthTextContainer, ke.a.geoText)
				}, i.a.createElement(oe.a, {
					initialValue: null !== (t = null == n ? void 0 : n.name) && void 0 !== t ? t : "",
					initialPlace: b,
					onPlace: e => u(e, "place"),
					onSubmit: async function(e) {
						let {
							place: t,
							sessionId: n
						} = e;
						if ((null == t ? void 0 : t.id) === (null == b ? void 0 : b.id)) return;
						g(!0);
						const s = await Object(ae.a)(m(), {
							subredditId: r,
							placeId: t.id,
							source: t.source,
							sessionId: n
						});
						if (g(!1), !s.ok) return p(Object(re.f)({
							kind: le.b.Error,
							text: W.fbt._("Something went wrong", null, {
								hk: "2PnKbu"
							}),
							duration: 5e3
						}));
						f(t), p(Object(re.f)({
							kind: le.b.SuccessCommunity,
							text: W.fbt._("Successfully updated community location", null, {
								hk: "3aGk2e"
							}),
							duration: 5e3
						}))
					},
					disabled: h,
					className: ke.a.geoForm,
					inputClassName: ke.a.geoInput
				})))
			}
			const Se = {
				[ne.e.Post]: {
					short: () => W.fbt._("Post only (default)", null, {
						hk: "2XJHW4"
					}),
					long: () => W.fbt._("Only approved users can post. Anyone can comment.", null, {
						hk: "3frgit"
					})
				},
				[ne.e.Comment]: {
					short: () => W.fbt._("Comment only", null, {
						hk: "2OhQB5"
					}),
					long: () => W.fbt._("Only approved users can comment. Anyone can post.", null, {
						hk: "2F24kr"
					})
				},
				[ne.e.PostAndComment]: {
					short: () => W.fbt._("Post & Comment", null, {
						hk: "1lWCl2"
					}),
					long: () => W.fbt._("Only approved users can post and comment.", null, {
						hk: "4GkEs6"
					})
				}
			};

			function we(e) {
				const {
					isEmployee: t,
					restrictions: n,
					settings: s,
					subredditId: r,
					subredditName: o,
					testWelcomeMessage: a,
					update: d,
					geoPlace: u,
					onFocusWelcomeMessageInput: m,
					subredditCountrySite: p,
					subredditCountryEditEnabled: b,
					subredditLanguageEditEnabled: f
				} = e, {
					disableContributorRequests: h,
					over18: g,
					publicDescription: v,
					restrictCommenting: x,
					restrictPosting: E,
					subredditType: O,
					title: C,
					welcomeMessageEnabled: A,
					welcomeMessageText: y
				} = s, I = [], _ = [];
				for (const i of Object.keys(Se)) _.push(Se[i].short()), I.push(Se[i].long());
				const P = !y || 0 === (null == y ? void 0 : y.length);
				return i.a.createElement(k.a, null, i.a.createElement(j, null, i.a.createElement(k.b, null, W.fbt._("Community settings", null, {
					hk: "3mvH70"
				})), i.a.createElement(J.a, null, W.fbt._("Community Profile", null, {
					hk: "91aEK"
				})), i.a.createElement(X.e, {
					label: W.fbt._("Community name", null, {
						hk: "260EEx"
					}),
					maxChars: se.e,
					onChange: e => d(e.currentTarget.value, "title"),
					textContainerClassName: ke.a.fullWidthTextContainer,
					value: C || ""
				}), i.a.createElement(X.m, {
					label: W.fbt._("Community topics", null, {
						hk: "49aoGo"
					}),
					textContainerClassName: ke.a.fullWidthTextContainer,
					subtext: i.a.createElement("span", {
						className: ke.a.subtextContainer
					}, W.fbt._("This will help Reddit recommend your community to relevant users and other discovery experiences.", null, {
						hk: "3WYTu5"
					}), "", i.a.createElement($.a, {
						className: ke.a.communityTopicsHelpLink,
						href: "https://mods.reddithelp.com/hc/en-us/articles/360024518712",
						rel: "noopener noreferrer",
						target: "_blank"
					}, W.fbt._("Learn more.", null, {
						hk: "1y3kXY"
					})), " ", "", i.a.createElement("span", {
						className: ke.a.numCommunityTopicsSelected
					}, i.a.createElement(V.a, {
						subredditId: r
					}))),
					direction: "column"
				}, i.a.createElement(K.b, {
					subredditId: r,
					onPrimarySelect: e.onPrimarySelect
				}), (!!e.selectedPrimaryTag || e.hasSecondaryTags) && i.a.createElement(z.b, {
					context: T.a.communitySettings,
					subredditId: r
				}), i.a.createElement(Y.a, {
					context: T.a.communitySettings,
					subredditId: r
				})), i.a.createElement(X.h, {
					label: W.fbt._("Community description", null, {
						hk: "1XBKXj"
					}),
					onChange: e => d(e.currentTarget.value, "publicDescription", !1),
					maxChars: se.d,
					rows: 2,
					subtext: W.fbt._("This is how new members come to understand your community.", null, {
						hk: "llaA4"
					}),
					value: v || ""
				}), i.a.createElement(X.q, {
					className: A ? ke.a.welcomeMessageEnabled : void 0,
					on: A,
					onClick: () => d(!A, "welcomeMessageEnabled"),
					label: W.fbt._("Send welcome message to new members", null, {
						hk: "4euZSE"
					}),
					subtext: i.a.createElement("span", null, W.fbt._("Create a custom welcome message to greet people the instant they join your community. New community members will see this in a direct message 1 hour after joining.", null, {
						hk: "1D5tM8"
					}), "", i.a.createElement($.a, {
						className: ke.a.welcomeMessageHelpLink,
						href: "https://mods.reddithelp.com/hc/en-us/articles/360002551551-Welcoming-new-members",
						rel: "noopener noreferrer",
						target: "_blank"
					}, W.fbt._("Learn more.", null, {
						hk: "NkFhF"
					})))
				}), A && i.a.createElement(i.a.Fragment, null, i.a.createElement(X.h, {
					actionLink: i.a.createElement(S.t, {
						priority: S.c.PlainLink,
						className: Object(c.a)(ke.a.previewButton, {
							[ke.a.disabled]: P
						}),
						disabled: !y || 0 === (null == y ? void 0 : y.length),
						onClick: () => a(o, y)
					}, W.fbt._("Send me a test message", null, {
						hk: "4iE1go"
					})),
					label: null,
					onChange: e => {
						d(e.currentTarget.value, "welcomeMessageText")
					},
					onFocus: m,
					placeholder: W.fbt._("Welcome to our community! Were here to discuss our passion for all things related to grated cheese. (Heads upwere a text-only community, so sorry no image posts.) Get started by introducing yourself in our post for newbies, then check out our rules to learn more and dive in.", null, {
						hk: "AnOYs"
					}),
					maxChars: se.f,
					rows: 5,
					value: y || ""
				})), i.a.createElement(_e, {
					subredditId: r,
					update: d,
					initialPlace: u,
					initialSubredditCountrySite: p,
					subredditCountryEditEnabled: !!b,
					subredditLanguageEditEnabled: !!f
				}), i.a.createElement(J.a, null, W.fbt._("community type", null, {
					hk: "3T2OkK"
				})), i.a.createElement(X.m, {
					label: W.fbt._("Type of Community", null, {
						hk: "2PReGw"
					}),
					direction: "column"
				}, i.a.createElement(ee.a, {
					value: O,
					name: "type",
					onChange: e => d(e, "subredditType")
				}, Object(Z.radioOptions)(t, n))), i.a.createElement(X.q, {
					on: g,
					onClick: () => d(!g, "over18"),
					label: i.a.createElement("span", null, W.fbt._("18+ year old community", null, {
						hk: "3VzYZp"
					}), i.a.createElement(X.n, {
						flair: te.f.Nsfw
					})),
					subtext: W.fbt._("When your community is marked as an 18+ community, users must be flagged as 18+ in their user settings", null, {
						hk: "2h28m0"
					})
				}), "restricted" === O && i.a.createElement(i.a.Fragment, null, i.a.createElement(J.a, null, W.fbt._("Restricted Community Settings", null, {
					hk: "1HiDiC"
				})), i.a.createElement(X.d, {
					label: W.fbt._("Approved users have the ability to", null, {
						hk: "2pduhW"
					}),
					items: _,
					selected: (() => {
						let e = ne.e.Post;
						return x && E ? e = ne.e.PostAndComment : x && (e = ne.e.Comment), Se[e].short()
					})(),
					onClick: e => {
						e === Se[ne.e.PostAndComment].short() ? (d(!0, ne.f.Comment), d(!0, ne.f.Post)) : e === Se[ne.e.Comment].short() ? (d(!1, ne.f.Post), d(!0, ne.f.Comment)) : e === Se[ne.e.Post].short() && (d(!0, ne.f.Post), d(!1, ne.f.Comment))
					},
					id: "restrictionOptions",
					descriptions: I
				}), i.a.createElement(X.q, {
					on: !h,
					onClick: () => d(!h, "disableContributorRequests"),
					label: W.fbt._("Accepting new requests to post", null, {
						hk: "bTpYB"
					})
				})), "private" === O && i.a.createElement(i.a.Fragment, null, i.a.createElement(J.a, null, W.fbt._("Private Community Settings", null, {
					hk: "2JjNXE"
				})), i.a.createElement(X.q, {
					on: !h,
					onClick: () => d(!h, "disableContributorRequests"),
					label: W.fbt._("Accepting requests to join", null, {
						hk: "1l1acS"
					}),
					subtext: W.fbt._("Display a button on your private subreddit that allows users to request to join. Users may still send your subreddit modmail whether this is on or off.", null, {
						hk: "1bkLxN"
					})
				})), i.a.createElement(J.a, null, W.fbt._("Advanced Settings", null, {
					hk: "1e5Esr"
				})), i.a.createElement(X.g, {
					label: W.fbt._("Settings for old site", null, {
						hk: "4wmYj3"
					}),
					subtext: W.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
						hk: "gYPuP"
					}),
					link: `${q.a.oldRedditUrl}/r/${o}/about/edit`,
					onClick: () => e.sendEvent(Object(w.d)(l.nc.Posts)),
					openInNewTab: !0,
					last: !0
				})))
			}
			var Te = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				Pe = n("./src/reddit/components/ModHub/StyledComponents/index.m.less"),
				Ne = n.n(Pe),
				De = n("./src/reddit/components/ContentSurvey/RatingCard.tsx"),
				Me = n("./src/reddit/components/ContentSurvey/SurveyModal.tsx"),
				Re = n("./src/reddit/helpers/trackers/contentTag.ts"),
				Le = n("./src/reddit/hooks/useTracking.ts");
			const {
				fbt: Be
			} = n("./node_modules/fbt/lib/FbtPublic.js");

			function Fe(e) {
				const {
					subreddit: t
				} = e, n = Object(a.e)(e => e.subreddits.survey[t.id]), s = Object(Le.a)();
				Object(o.useEffect)(() => s(Object(Re.k)()), [s]);
				const r = Object(a.e)(e => Object(H.a)(e, !0)),
					[d, l] = Object(o.useState)(!1);

				function u() {
					s(Object(Re.o)()), l(!0)
				}
				const m = !(null == n ? void 0 : n.response) && (null == n ? void 0 : n.isEligible),
					p = (null == n ? void 0 : n.response) && (null == n ? void 0 : n.isEligible);
				return i.a.createElement("div", {
					className: Object(c.a)(Ne.a.ContentContainer, ke.a.contentTag, {
						[ke.a.navExperiment]: r
					})
				}, i.a.createElement("h2", null, Be._("Content Tag", null, {
					hk: "1AhgrD"
				})), i.a.createElement("p", null, Be._("Your content tag is based on a moderator survey about community posts and discussions. {=Learn More}", [Be._param("=Learn More", i.a.createElement("a", {
					href: "https://www.reddithelp.com/hc/en-us/articles/360048185132",
					target: "_blank",
					rel: "noopener noreferrer",
					onClick: () => s(Object(Re.d)())
				}, Be._("Learn More", null, {
					hk: "2gJ4PL"
				})))], {
					hk: "2xoqeD"
				})), i.a.createElement("div", {
					className: ke.a.contentTagColumn
				}, i.a.createElement(De.a, {
					subredditId: t.id,
					ratingResponse: null == n ? void 0 : n.response
				}, (null == n ? void 0 : n.response) ? i.a.createElement(i.a.Fragment, null, i.a.createElement("p", {
					className: ke.a.ratingAudience
				}, Be._("Tagged as {ratingName} due to:", [Be._param("ratingName", n.response.rating.name)], {
					hk: "3VVnt5"
				})), i.a.createElement("ul", null, n.response.ratingReasons.map(e => i.a.createElement("li", {
					key: e.id,
					className: ke.a.ratingReason
				}, e.contentRatingReasonText)))) : i.a.createElement(i.a.Fragment, null, i.a.createElement("p", {
					className: ke.a.ratingAudience
				}, Be._("Set up your tag", null, {
					hk: "2Fb5bg"
				})), i.a.createElement("p", {
					className: ke.a.ratingDescription
				}, Be._("Take a quick survey to help people know what to expect when they visit this community", null, {
					hk: "VvmPr"
				})))), m && i.a.createElement(S.t, {
					redditStyle: !0,
					className: ke.a.surveyButton,
					onClick: u
				}, Be._("Start Survey", null, {
					hk: "myDPK"
				})), p && i.a.createElement(i.a.Fragment, null, i.a.createElement("p", {
					className: ke.a.promptText
				}, Be._("Does this content tag look wrong to you?", null, {
					hk: "72VuM"
				})), i.a.createElement(S.t, {
					priority: S.c.Secondary,
					redditStyle: !0,
					className: ke.a.surveyButton,
					onClick: u
				}, Be._("Take the Survey", null, {
					hk: "W30wE"
				})), i.a.createElement(Te.a, {
					to: "/r/modsupport/submit"
				}, i.a.createElement(S.t, {
					priority: S.c.Tertiary,
					redditStyle: !0,
					className: ke.a.surveyButton,
					onClick: () => s(Object(Re.f)())
				}, "Message r/modsupport")))), d && n && i.a.createElement(Me.a, {
					withOverlay: !0,
					subredditId: t.id,
					survey: n,
					onClose: () => l(!1)
				}))
			}
			var Ue = n("./src/reddit/constants/experiments.ts"),
				He = n("./src/reddit/hooks/useExperimentVariant.ts");
			var Ge = n("./src/reddit/selectors/experiments/imageComment.ts"),
				Qe = n("./src/reddit/selectors/experiments/mediaInComments.ts");

			function qe(e, t) {
				const n = (null == t ? void 0 : t.allowedMediaTypes) || [],
					s = n.includes(e) ? n.filter(t => t !== e) : [...n, e];
				return {
					...t,
					allowedMediaTypes: s
				}
			}
			var We = e => {
					const {
						settings: t,
						subredditName: n,
						update: s,
						isChatPostsCreationEnabled: r,
						subredditId: d,
						shouldShowAllowVideosToggle: c
					} = e, {
						archivePostsEnabled: u,
						allowChatPostCreation: m,
						allowGalleries: p,
						allowImages: b,
						allowPolls: f,
						allowPostCrossposts: h,
						allowVideos: g,
						commentContributionSettings: v,
						collapseDeletedComments: x,
						commentScoreHideMins: E,
						contentOptions: O,
						spamComments: C,
						spamLinks: A,
						spamSelfposts: I,
						spoilersEnabled: _,
						suggestedCommentSort: S
					} = t, T = Object(a.e)(Qe.c), P = Object(a.e)(Qe.a), N = Object(a.e)(Ge.c), D = Object(a.e)(Ge.a), M = Object(a.e)(e => ((e, t) => {
						const n = t && e.subreddits.about[t];
						return Boolean(n && n.isMediaInCommentsSettingShown)
					})(e, d)), R = Object(He.a)(Ue.Uf) === Ue.Yd, L = T && M, B = (null == v ? void 0 : v.allowedMediaTypes) || [], F = S, U = Object(o.useCallback)(() => s(!u, "archivePostsEnabled"), [u, s]), H = e => e.toUpperCase() === Q.Y.All, G = e => {
						const n = H(t[e]) ? Q.Y.Low : Q.Y.All;
						s(n, e)
					};
					return i.a.createElement(k.a, null, i.a.createElement(j, null, i.a.createElement(k.b, null, W.fbt._("Post and Comment settings", null, {
						hk: "14OI7p"
					})), i.a.createElement(J.a, null, W.fbt._("Posts", null, {
						hk: "2i2G4r"
					})), i.a.createElement(X.d, {
						label: W.fbt._("Post type options", null, {
							hk: "M9AdT"
						}),
						items: Object.keys(se.i),
						displayItems: Object.values(se.i),
						displayTitle: se.i[O],
						selected: O,
						onClick: e => s(e, "contentOptions"),
						id: "contentOptions",
						descriptions: se.h
					}), i.a.createElement(X.q, {
						on: h,
						onClick: () => s(!h, "allowPostCrossposts"),
						label: W.fbt._("Allow crossposting of posts.", null, {
							hk: "19EiBT"
						})
					}), i.a.createElement(X.q, {
						on: u,
						onClick: U,
						label: W.fbt._("Archive posts", null, {
							hk: "3FdbDg"
						}),
						subtext: W.fbt._("Dont allow commenting or voting on posts older than 6 months", null, {
							hk: "4tIS0"
						})
					}), r && i.a.createElement(X.d, {
						label: W.fbt._("Live Chat Creators", null, {
							hk: "2Yd8cb"
						}),
						selected: m ? se.a.anyone : se.a.mods,
						items: Object.values(se.a),
						onClick: e => s(e === se.a.anyone, "allowChatPostCreation"),
						id: "chatPostOptions",
						subtext: W.fbt._("Choose who can start live chat posts in your community", null, {
							hk: "3F7D5k"
						})
					}), i.a.createElement(X.q, {
						on: _,
						onClick: () => s(!_, "spoilersEnabled"),
						label: i.a.createElement("span", null, W.fbt._("Enable spoiler tag", null, {
							hk: "2CtBpB"
						}), i.a.createElement(X.n, {
							flair: te.f.Spoiler
						})),
						subtext: W.fbt._("Media on posts with the spoiler tag are blurred", null, {
							hk: "4rVOs6"
						})
					}), i.a.createElement(X.q, {
						on: b,
						onClick: () => {
							s(!b, "allowImages"), s(!b, "allowGalleries")
						},
						label: W.fbt._("Allow image uploads and links to image hosting sites", null, {
							hk: "20ETVO"
						})
					}), b && i.a.createElement(X.q, {
						"data-testid": "allow-images-community-setting",
						on: p,
						onClick: () => s(!p, "allowGalleries"),
						label: W.fbt._("Allow multiple images per post", null, {
							hk: "Pcjq5"
						})
					}), c && i.a.createElement(X.q, {
						on: g,
						onClick: () => {
							s(!g, "allowVideos")
						},
						label: W.fbt._("Allow video uploads", null, {
							hk: "1eiXVU"
						})
					}), i.a.createElement(X.q, {
						on: f,
						onClick: () => s(!f, "allowPolls"),
						label: W.fbt._("Allow polls", null, {
							hk: "15LXRO"
						})
					}), R ? i.a.createElement(i.a.Fragment, null, i.a.createElement(X.m, {
						label: W.fbt._("Content filters", null, {
							hk: "ZAU2O"
						}),
						subtext: W.fbt._("The content types you select will be automaticaly added to your mod queue for you to approve or remove.", null, {
							hk: "1OW6Fg"
						})
					}), i.a.createElement(X.q, {
						indent: !0,
						on: H(A),
						label: W.fbt._("Filter link, poll, and media posts", null, {
							hk: "2JjdGk"
						}),
						onClick: () => G("spamLinks")
					}), i.a.createElement(X.q, {
						indent: !0,
						on: H(I),
						label: W.fbt._("Filter text posts", null, {
							hk: "3kvyDv"
						}),
						onClick: () => G("spamSelfposts")
					}), i.a.createElement(X.q, {
						indent: !0,
						on: H(C),
						label: W.fbt._("Filter comments", null, {
							hk: "1llhZg"
						}),
						onClick: () => G("spamComments")
					})) : i.a.createElement(i.a.Fragment, null, i.a.createElement(X.m, {
						label: W.fbt._("Spam filter strength", null, {
							hk: "4C4qar"
						}),
						subtext: W.fbt._("'HIGH' is the standard filter, 'LOW' disables most filtering, 'ALL' will filter every post initially and they will need to be approved manually to be visible", null, {
							hk: "mdxeP"
						})
					}), i.a.createElement(X.d, {
						label: W.fbt._("Posts", null, {
							hk: "1SdpTj"
						}),
						items: Object.keys(se.k),
						displayItems: Object.values(se.k),
						displayTitle: se.k[I],
						id: "spamSelfposts",
						selected: I.toUpperCase(),
						onClick: e => s(e, "spamSelfposts"),
						indent: !0
					}), i.a.createElement(X.d, {
						label: W.fbt._("Links", null, {
							hk: "Ia7TU"
						}),
						items: Object.keys(se.k),
						displayItems: Object.values(se.k),
						displayTitle: se.k[A],
						id: "spamLinks",
						selected: A.toUpperCase(),
						onClick: e => s(e, "spamLinks"),
						indent: !0
					}), i.a.createElement(X.d, {
						label: W.fbt._("Comments", null, {
							hk: "1X5Fv2"
						}),
						items: Object.keys(se.c),
						displayItems: Object.values(se.c),
						displayTitle: se.c[C],
						selected: C.toUpperCase(),
						onClick: e => s(e, "spamComments"),
						indent: !0,
						id: "spamComments"
					})), i.a.createElement(J.a, null, W.fbt._("Comments", null, {
						hk: "4sAqsA"
					})), i.a.createElement(X.d, {
						label: W.fbt._("Suggested sort", null, {
							hk: "4Af3Lr"
						}),
						subtext: W.fbt._("All comment feeds in community will default to this sort setting", null, {
							hk: "4grj1W"
						}),
						items: Object.keys(se.j),
						displayItems: Object.values(se.j),
						displayTitle: se.j[F],
						selected: F,
						onClick: e => s(e, "suggestedCommentSort"),
						id: "suggestedCommentSort"
					}), i.a.createElement(X.q, {
						on: x,
						onClick: () => s(!x, "collapseDeletedComments"),
						label: W.fbt._("Collapse deleted and removed comments", null, {
							hk: "Iw8kU"
						})
					}), i.a.createElement(X.m, {
						label: W.fbt._("Minutes to hide comment scores", null, {
							hk: "1DJhj0"
						}),
						direction: "column"
					}, i.a.createElement(y, {
						onChange: e => s(e.currentTarget.value, "commentScoreHideMins"),
						isInvalid: !(E >= se.g && E <= se.b),
						min: se.g,
						max: se.b,
						type: "number",
						value: E
					})), L && i.a.createElement(i.a.Fragment, null, i.a.createElement(X.m, {
						label: W.fbt._("Media in comments", null, {
							hk: "25YOda"
						})
					}), i.a.createElement(X.q, {
						on: B.includes(Q.f.Giphy),
						onClick: () => s(qe(Q.f.Giphy, v), "commentContributionSettings"),
						label: W.fbt._("GIFs from GIPHY", null, {
							hk: "1jwTaz"
						}),
						subtext: W.fbt._("Allow comments with GIFs from GIPHY.", null, {
							hk: "2Jqq8o"
						}),
						indent: !0
					}), P && i.a.createElement(X.q, {
						on: B.includes(Q.f.Expression),
						onClick: () => s(qe(Q.f.Expression, v), "commentContributionSettings"),
						label: W.fbt._("Collectible Expressions", null, {
							hk: "19g0dC"
						}),
						subtext: W.fbt._("Allow comments with Collectible Expressions.", null, {
							hk: "fmjBM"
						}),
						indent: !0
					}), N && i.a.createElement(X.q, {
						on: B.includes(Q.f.Static),
						onClick: () => s(qe(Q.f.Static, v), "commentContributionSettings"),
						label: W.fbt._("Images", null, {
							hk: "3Vrqqu"
						}),
						subtext: W.fbt._("Allow comments with uploaded images.", null, {
							hk: "4kSi3w"
						}),
						indent: !0
					}), D && i.a.createElement(X.q, {
						on: B.includes(Q.f.Animated),
						onClick: () => s(qe(Q.f.Animated, v), "commentContributionSettings"),
						label: W.fbt._("GIFs", null, {
							hk: "2vQkCj"
						}),
						subtext: W.fbt._("Allow comments with uploaded GIFs.", null, {
							hk: "2FQ8lo"
						}),
						indent: !0
					})), i.a.createElement(J.a, null, W.fbt._("Advanced Settings", null, {
						hk: "53xlS"
					})), i.a.createElement(X.g, {
						label: W.fbt._("Settings for old site", null, {
							hk: "2jzUi8"
						}),
						subtext: W.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
							hk: "4DHBV2"
						}),
						link: `${q.a.oldRedditUrl}/r/${n}/about/edit`,
						onClick: () => e.sendEvent(Object(w.d)(l.nc.Posts)),
						openInNewTab: !0,
						last: !0
					})))
				},
				ze = n("./src/reddit/components/CommunitySafetyFeatureAdoptionCampaign/BanEvasion/useBanEvasionAdoptionCampaign.tsx"),
				Ve = n("./src/reddit/selectors/experiments/cnc/index.ts");
			const Ke = "discoverySettings",
				Ye = {
					0: {
						text: W.fbt._("Off", null, {
							hk: "30Jfc7"
						}),
						color: "#787C7E"
					},
					1: {
						text: W.fbt._("Lenient", null, {
							hk: "2TWZ21"
						}),
						color: "#46D160"
					},
					2: {
						text: W.fbt._("Moderate", null, {
							hk: "2s7qbB"
						}),
						color: "#FFB000"
					},
					3: {
						text: W.fbt._("Strict", null, {
							hk: "4s6ECM"
						}),
						color: "#EA0027"
					}
				},
				Je = {
					0: W.fbt._("Use Crowd Control to automatically collapse comments from users youre not sure about.", null, {
						hk: "n75Tc"
					}),
					1: W.fbt._("Comments from users who have negative karma in your community are automatically collapsed.", null, {
						hk: "37Keyu"
					}),
					2: W.fbt._("Comments from new users and users with negative karma in your community are automatically collapsed.", null, {
						hk: "v6NNK"
					}),
					3: W.fbt._("Comments from users who havent joined your community, new users, and users with negative karma in your community are automatically collapsed.", null, {
						hk: "4NqwJ"
					})
				},
				Xe = {
					0: W.fbt._("Use Crowd Control to automatically filter posts from users youre not sure about.", null, {
						hk: "RFsOk"
					}),
					1: W.fbt._("Posts from users who have negative karma in your community are automatically held for review in mod queue.", null, {
						hk: "2cFJqC"
					}),
					2: W.fbt._("Posts from new users and users with negative karma in your community are automatically held for review in mod queue.", null, {
						hk: "1TwCdK"
					}),
					3: W.fbt._("Posts from users who havent joined your community, new users, and users with negative karma in your community are automatically held for review in mod queue.", null, {
						hk: "Syn69"
					})
				},
				Ze = e => {
					const t = [...e];
					for (let n = 0; n < t.length; n++)
						if (t[n] === Q.n.Onboarding) return t.splice(n, 1), t;
					return t.push(Q.n.Onboarding), t
				};

			function $e(e) {
				var t;
				const {
					isChatPostsCreationEnabled: n,
					settings: s,
					subredditName: r,
					subreddit: o,
					update: d
				} = e, {
					allowDiscovery: c,
					contentVisible: u,
					crowdControlFilter: m,
					crowdControlLevel: p,
					crowdControlChatLevel: b,
					crowdControlPostLevel: f,
					discoverySettings: h,
					excludeBannedModqueue: g,
					modmailHarassmentFilterEnabled: v,
					toxicityThresholdChatLevel: x
				} = s, {
					showCampaign: E
				} = Object(ze.b)(), O = n, C = !(null === (t = null == h ? void 0 : h.disabledDiscoveryTypes) || void 0 === t ? void 0 : t.find(e => e === Q.n.Onboarding)), A = Object(a.e)(Ve.a);
				return i.a.createElement(k.a, null, i.a.createElement(j, null, i.a.createElement(k.b, {
					className: ke.a.pageTitle
				}, W.fbt._("Safety & privacy settings", null, {
					hk: "34ghQV"
				})), i.a.createElement(X.q, {
					on: g,
					onClick: () => d(!g, "excludeBannedModqueue"),
					label: W.fbt._("Exclude posts by site-wide banned users", null, {
						hk: "Kmfy0"
					}),
					subtext: W.fbt._("Posts are excluded from modqueue/unmoderated", null, {
						hk: "2P2pfc"
					})
				}), i.a.createElement(X.q, {
					on: v,
					onClick: () => d(!v, "modmailHarassmentFilterEnabled"),
					label: i.a.createElement(i.a.Fragment, null, W.fbt._("Modmail filtered folder", null, {
						hk: "1oqjU0"
					})),
					subtext: W.fbt._("Automatically filters inbound modmail messages that are likely to contain harassment. {=Learn More.}", [W.fbt._param("=Learn More.", i.a.createElement("a", {
						className: ke.a.subtextLink,
						target: "_blank",
						rel: "noopener noreferrer",
						href: "https://mods.reddithelp.com/hc/en-us/articles/360002085732-Modmail-folders#h_01G8YBFB9VYVREXYWH1SCDP141"
					}, W.fbt._("Learn More.", null, {
						hk: "4BFEyn"
					})))], {
						hk: "FA0bG"
					})
				}), O && i.a.createElement(X.q, {
					on: !!Number(x),
					onClick: () => {
						d(Number(x) ? "0" : "1", "toxicityThresholdChatLevel")
					},
					label: W.fbt._("Collapse Toxic Messages in Chat Post", null, {
						hk: "1Pk3G5"
					}),
					subtext: W.fbt._("Comments that our model scores as toxic will be automatically collapsed.", null, {
						hk: "Rohtu"
					})
				}), i.a.createElement(X.j, {
					link: `/mod/${r}/safety/ban-evasion`,
					label: i.a.createElement(i.a.Fragment, null, W.fbt._("Ban evasion filter", null, {
						hk: "2U5eI9"
					}), E && i.a.createElement(ie.a, {
						className: ke.a.labelNewTag
					})),
					subtext: W.fbt._("Filter content from suspected ban evaders.", null, {
						hk: "tu5RI"
					}),
					linkLabel: W.fbt._("Ban evasion filter settings", null, {
						hk: "2TBsce"
					})
				}), i.a.createElement(J.a, {
					className: ke.a.sectionHeadingFollowedBySubtext
				}, W.fbt._("Crowd Control", null, {
					hk: "1HF3IV"
				})), i.a.createElement(X.o, {
					className: ke.a.sectionSubtext
				}, W.fbt._("Automatically collapse or filter content from people who aren't trusted users within your community yet.", null, {
					hk: "3U7kZS"
				})), i.a.createElement(X.k, {
					className: ke.a.rangeSetting,
					ticks: Ye,
					min: 0,
					max: Object.keys(Ye).length - 1,
					step: 1,
					value: p,
					onChange: e => d(e.target.value, "crowdControlLevel"),
					label: W.fbt._("Comments", null, {
						hk: "1vRuWQ"
					}),
					subtext: Je[p]
				}), i.a.createElement(X.q, {
					indent: !0,
					on: m,
					onClick: () => d(!m, "crowdControlFilter"),
					label: i.a.createElement(i.a.Fragment, null, W.fbt._("Hold Crowd Controlled comments for review", null, {
						hk: "43fG1u"
					})),
					subtext: W.fbt._("Instead of collapsing crowd controlled comments will be held for review in mod queue.", null, {
						hk: "1QBJUP"
					})
				}), i.a.createElement(X.k, {
					className: ke.a.rangeSetting,
					ticks: Ye,
					min: 0,
					max: Object.keys(Ye).length - 1,
					step: 1,
					value: f,
					onChange: e => d(e.target.value, "crowdControlPostLevel"),
					label: i.a.createElement(i.a.Fragment, null, W.fbt._("Posts", null, {
						hk: "nW9yu"
					})),
					subtext: Xe[f]
				}), O && i.a.createElement(X.k, {
					ticks: Ye,
					min: 0,
					max: Object.keys(Ye).length - 1,
					step: 1,
					value: b,
					onChange: e => d(e.target.value, "crowdControlChatLevel"),
					label: W.fbt._("Chat Posts", null, {
						hk: "eTeih"
					}),
					subtext: Je[b]
				}), i.a.createElement(J.a, {
					className: ke.a.sectionHeadingFollowedBySubtext
				}, W.fbt._("Discover", null, {
					hk: "1I53SY"
				})), i.a.createElement(X.o, {
					className: ke.a.sectionSubtext
				}, W.fbt._("Show your community to the general Reddit population or just to people who have similar interests, by adjusting how people can find it. Not sure what's best for you? {=Learn More.}", [W.fbt._param("=Learn More.", i.a.createElement("a", {
					className: ke.a.subtextLink,
					target: "_blank",
					rel: "noopener noreferrer",
					href: "https://mods.reddithelp.com/hc/en-us/sections/360000685771-General-Common-Questions"
				}, W.fbt._("Learn More.", null, {
					hk: "KAZVL"
				})))], {
					hk: "38WrgR"
				})), !o.isQuarantined && i.a.createElement(i.a.Fragment, null, i.a.createElement(X.q, {
					on: u,
					onClick: () => d(!u, "contentVisible"),
					label: W.fbt._("Show up in high-traffic feeds", null, {
						hk: "3l7KBc"
					}),
					subtext: W.fbt._("Allow your community to be in r/all, r/popular, and trending lists where it can be seen by the general Reddit population.", null, {
						hk: "iH0lY"
					})
				}), A && !u && i.a.createElement(X.q, {
					on: C,
					onClick: () => d({
						disabledDiscoveryTypes: Ze((null == h ? void 0 : h.disabledDiscoveryTypes) || [])
					}, Ke),
					label: W.fbt._("Get recommended to newer redditors", null, {
						hk: "1HfMHx"
					}),
					subtext: W.fbt._("Get recommended to new and returning redditors who show interest in topics related to your community during onboarding.", null, {
						hk: "oYAxo"
					})
				}), i.a.createElement(X.q, {
					on: c,
					onClick: () => d(!c, "allowDiscovery"),
					label: W.fbt._("Get recommended to individual redditors", null, {
						hk: "4wmaiH"
					}),
					subtext: W.fbt._("Let Reddit recommend your community to people who have similar interests.", null, {
						hk: "487MMM"
					})
				})), i.a.createElement(J.a, null, W.fbt._("Advanced Settings", null, {
					hk: "3TL9Or"
				})), i.a.createElement(X.g, {
					link: `${q.a.oldRedditUrl}/r/${r}/about/edit`,
					onClick: () => e.sendEvent(Object(w.d)(l.nc.Safety)),
					openInNewTab: !0,
					last: !0,
					label: W.fbt._("Settings for old site", null, {
						hk: "1WHvCJ"
					}),
					subtext: W.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
						hk: "2wPmwa"
					})
				})))
			}

			function et(e) {
				const {
					settings: t,
					subredditName: n,
					update: s
				} = e, {
					wikiEditAge: r,
					wikiEditKarma: o,
					wikimode: a
				} = t;
				return i.a.createElement(k.a, null, i.a.createElement(j, null, i.a.createElement(k.b, null, W.fbt._("Wiki settings", null, {
					hk: "1gmluS"
				})), i.a.createElement(J.a, null, W.fbt._("Community wiki pages", null, {
					hk: "1LwxaS"
				})), i.a.createElement(X.d, {
					label: W.fbt._("Wikis can be edited by", null, {
						hk: "3brAqG"
					}),
					displayItems: Object.values(se.o),
					displayTitle: se.o[a],
					items: Object.keys(se.o),
					selected: a,
					onClick: e => s(e, "wikimode"),
					id: "wikimode",
					descriptions: se.n
				}), i.a.createElement(X.m, {
					label: W.fbt._("Karma required to edit and create wiki pages", null, {
						hk: "3OgR7v"
					}),
					direction: "column"
				}, i.a.createElement(y, {
					onChange: e => s(e.currentTarget.value, "wikiEditKarma"),
					isInvalid: !(o >= se.g && o <= se.m),
					min: se.g,
					max: se.m,
					type: "number",
					value: o
				})), i.a.createElement(X.m, {
					label: W.fbt._("Age of Reddit account required to edit and create wiki pages", null, {
						hk: "3UE6cD"
					}),
					direction: "column"
				}, i.a.createElement(y, {
					onChange: e => s(e.currentTarget.value, "wikiEditAge"),
					isInvalid: !(r >= se.g && r <= se.l),
					min: se.g,
					max: se.l,
					type: "number",
					value: r
				})), i.a.createElement(J.a, null, W.fbt._("Advanced Settings", null, {
					hk: "4drMhK"
				})), i.a.createElement(X.g, {
					label: W.fbt._("Settings for old site", null, {
						hk: "2YU3sQ"
					}),
					subtext: W.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
						hk: "1ihkVe"
					}),
					link: `${q.a.oldRedditUrl}/r/${n}/about/edit`,
					onClick: () => e.sendEvent(Object(w.d)(l.nc.Wikis)),
					openInNewTab: !0,
					last: !0
				})))
			}
			const {
				fbt: tt
			} = n("./node_modules/fbt/lib/FbtPublic.js"), nt = Object(d.c)({
				allowChatPostCreation: (e, t) => Object(N.b)(e, t.subredditId),
				isChatPostsCreationEnabled: (e, t) => Object(N.c)(e, t.subredditId),
				isEmployee: L.P,
				notificationSettings: M.b,
				restrictions: D.q,
				settings: (e, t) => Object(D.Z)(e, t.subredditId),
				subreddit: D.X,
				selectedPrimaryTag: R.s,
				hasSecondaryTags: R.m,
				geoPlace: (e, t) => e.tags.models.geoPlaces[t.subredditId],
				subredditCountrySite: (e, t) => ((e, t) => e.subreddits.countrySiteSettings[t])(e, t.subredditId),
				subredditCountryEditEnabled: (e, t) => Object(F.g)(e),
				subredditLanguageEditEnabled: (e, t) => Object(F.h)(e),
				isInShredditModNavExperiment: (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = Object(G.n)(e, {
						subredditId: n
					});
					return Object(H.a)(e, !!s)
				},
				shouldShowAllowVideosToggle: e => !Object(U.b)(e)
			}), st = Object(a.b)(nt, (e, t) => {
				let {
					subredditId: n
				} = t;
				return {
					onViewPageEvent: () => e(Object(u.a)()),
					testWelcomeMessage: (t, n) => e(Object(m.i)(t, n)),
					save: (t, n) => e(Object(m.j)(n, t, void 0)),
					saveCommunityTopics: t => e(Object(x.e)(t, T.a.communitySettings)),
					onPrimarySelect: t => e(Object(x.f)({
						primaryTagId: t,
						subredditId: n
					})),
					savePrimaryTopic: t => {
						t && e(Object(x.o)(n, {
							tagId: t.id,
							state: P.d.TAGGED
						}, !1))
					},
					updateSubredditWelcomeMessage: (t, n, s) => e(g(t, n, s)),
					saveSubredditCountrysite: (t, n) => {
						if (n) return e(Object(B.e)(t, n))
					}
				}
			});
			class rt extends i.a.Component {
				constructor(e) {
					var t;
					super(e), t = this, this.saveSettings = () => {
						var e, t, n, s;
						this.props.save(this.state.changed, this.props.subredditId);
						const o = this.props.subredditCountryEditEnabled,
							i = this.props.subredditLanguageEditEnabled;
						(o || i) && this.props.subpageName === l.nc.Community && (this.props.saveSubredditCountrysite(this.props.subredditId, this.props.subredditCountrySite), o && this.props.sendEvent(Object(w.c)("country", null === (e = this.props.subredditCountrySite) || void 0 === e ? void 0 : e.countryCode, null === (t = this.state.subredditCountrySite) || void 0 === t ? void 0 : t.countryCode)), i && this.props.sendEvent(Object(w.c)("language", null === (n = this.props.subredditCountrySite) || void 0 === n ? void 0 : n.languageCode, null === (s = this.state.subredditCountrySite) || void 0 === s ? void 0 : s.languageCode)), this.props.subredditCountrySite && !r()(this.state.subredditCountrySite, this.props.subredditCountrySite) && this.setState({
							subredditCountrySite: this.props.subredditCountrySite
						})), this.props.saveCommunityTopics(this.props.subredditId), this.props.savePrimaryTopic(this.props.selectedPrimaryTag);
						for (const r in this.state.changed) this.props.sendEvent(Object(w.e)(r, this.state.changed[r], this.props.settings[r]));
						this.setState({
							settings: this.state.settings,
							changed: {}
						})
					}, this.update = function(e, n) {
						let s = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
						var r;
						if (s)
							if (n === Ke) {
								const n = null === (r = e) || void 0 === r ? void 0 : r.disabledDiscoveryTypes;
								if (Array.isArray(n)) {
									const e = !n.find(e => e === Q.n.Onboarding);
									t.props.sendEvent(Object(w.g)(e, t.state.settings.title))
								}
							} else t.props.sendEvent(Object(w.f)(n, e, t.state.settings[n]));
						t.setState(t => ({
							changed: {
								...t.changed,
								[n]: e
							},
							settings: {
								...t.settings,
								[n]: e
							}
						}))
					}, this.onFocusWelcomeMessageInput = () => this.props.sendEvent(Object(w.h)("click", "welcome_message_edit")), this.renderSubpage = () => {
						const e = {
							...this.props,
							settings: this.state.settings,
							update: this.update,
							onFocusWelcomeMessageInput: this.onFocusWelcomeMessageInput
						};
						if (!this.state.settings) return null;
						switch (this.props.subpageName) {
							case l.nc.Safety:
								return i.a.createElement($e, e);
							case l.nc.Notifications:
								return i.a.createElement(k.a, null, i.a.createElement(j, null, i.a.createElement(I.a, {
									subredditId: e.subredditId,
									subredditName: e.subredditName
								})));
							case l.nc.Posts:
								return i.a.createElement(We, e);
							case l.nc.Wikis:
								return i.a.createElement(et, e);
							case l.nc.ContentTag:
								return i.a.createElement(Fe, {
									subreddit: e.subreddit
								});
							default:
								return i.a.createElement(we, e)
						}
					}, this.state = {
						settings: e.settings,
						changed: {},
						subredditCountrySite: e.subredditCountrySite
					}
				}
				componentDidMount() {
					this.props.onViewPageEvent()
				}
				componentDidUpdate(e) {
					!this.props.settings || r()(e.settings, this.props.settings) || r()(this.state.settings, this.props.settings) || this.setState({
						settings: this.props.settings
					}), !this.props.subredditCountrySite || this.state.subredditCountrySite || r()(this.state.subredditCountrySite, this.props.subredditCountrySite) || this.setState({
						subredditCountrySite: this.props.subredditCountrySite
					})
				}
				render() {
					return i.a.createElement(i.a.Fragment, null, this.props.subpageName !== l.nc.ContentTag && i.a.createElement(k.c, {
						className: Object(c.a)(ke.a.topBar, this.props.isInShredditModNavExperiment && "pt-sm bg-neutral-background fixed", {
							[ke.a.default]: !this.props.isInShredditModNavExperiment
						})
					}, i.a.createElement(S.l, {
						onClick: this.saveSettings,
						"data-redditstyle": !0
					}, tt._("Save changes", null, {
						hk: "8mSp0"
					}))), this.renderSubpage())
				}
			}
			t.a = st(Object(_.c)(rt))
		},
		"./src/reddit/components/CommunityTopics/NumTopicsSelected.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/models/Tags/index.ts"),
				d = n("./src/reddit/selectors/tags.ts");
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js"), l = Object(i.c)({
				selectedOptions: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(d.r)(e, {
						subredditId: n
					})
				}
			});
			t.a = Object(o.b)(l)(e => r.a.createElement(r.a.Fragment, null, e.selectedOptions.length, "/", a.a))
		},
		"./src/reddit/components/CommunityTopics/PrimaryTopic/index.m.less": function(e, t, n) {
			e.exports = {
				menuItemsWrapper: "_1OISxDncG3tn4CibwqeC4e",
				tooltip: "UNHdPZIwwyCehEV-NfEY7"
			}
		},
		"./src/reddit/components/CommunityTopics/PrimaryTopic/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return N
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/actions/tags/index.ts"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/reddit/components/ContentTooltip/index.tsx"),
				u = n("./src/reddit/components/TrackingHelper/index.tsx"),
				m = n("./src/reddit/controls/Button/index.tsx"),
				p = n("./src/reddit/helpers/localStorage/index.ts"),
				b = n("./src/reddit/helpers/trackers/inlineSubredditEditing.ts"),
				f = n("./src/reddit/components/InlineSubredditEditing/index.m.less"),
				h = n.n(f);
			const {
				fbt: g
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			class v extends o.a.Component {
				componentDidMount() {
					this.props.sendEvent(b.e), this.props.onViewTooltip()
				}
				render() {
					const {
						translatedTitle: e,
						translatedDesc: t,
						translatedButtonText: n
					} = this.props;
					return o.a.createElement("div", {
						className: h.a.tooltipContent,
						onClick: e => {
							e.preventDefault(), e.stopPropagation()
						}
					}, o.a.createElement("span", {
						className: h.a.topRow
					}, o.a.createElement("h3", {
						className: h.a.title
					}, e)), o.a.createElement("p", {
						className: h.a.tooltipBody
					}, t), o.a.createElement(m.l, {
						className: h.a.gotIt,
						onClick: this.props.onDismissTooltip
					}, n || g._("Got it", null, {
						hk: "4CoCjQ"
					})))
				}
			}
			var x = Object(i.b)(void 0, e => ({
				onDismissTooltip: () => {
					e(Object(c.i)()), Object(p.Eb)()
				},
				onViewTooltip: () => {
					Object(p.dc)()
				}
			}))(Object(u.c)(v));
			const E = "editable-primary-topic-idcard";
			var O = n("./src/reddit/controls/DropdownSelector/index.tsx"),
				C = n("./src/reddit/models/Tags/index.ts"),
				A = n("./src/reddit/selectors/tags.ts"),
				y = n("./src/reddit/components/CommunityTopics/PrimaryTopic/index.m.less"),
				j = n.n(y);
			const I = e => {
					let {
						hasPrimaryTag: t,
						hasSecondaryTags: n
					} = e;
					if (t) return null;
					let r = s.fbt._("Add Community Topics", null, {
							hk: "2wd4kg"
						}),
						i = s.fbt._("Tell us what topics are relevant to your community so we can surface it to the right users", null, {
							hk: "24NCiQ"
						});
					return n && (r = s.fbt._("Add a Primary Topic", null, {
						hk: "41x5Gv"
					}), i = s.fbt._("Oops we dont have a primary topic yet. Add one so we can surface your community to the right users", null, {
						hk: "XayPA"
					})), o.a.createElement(l.a, {
						className: j.a.tooltip,
						tooltipId: E,
						defaultTooltipPosition: "left",
						tooltipSizeEstimate: {
							height: 150,
							width: 320
						}
					}, o.a.createElement(x, {
						translatedTitle: r,
						translatedDesc: i
					}))
				},
				k = {
					availablePrimaryTags: A.p
				},
				_ = Object(a.c)({
					...k,
					selectedPrimaryTag: (e, t) => {
						let {
							subredditId: n
						} = t;
						return n && Object(A.s)(e, {
							subredditId: n
						}) || null
					},
					hasSecondaryTags: (e, t) => {
						let {
							subredditId: n
						} = t;
						return Object.keys(Object(A.o)(e, {
							itemId: n
						})).length > 0
					},
					isSaving: A.D
				}),
				S = Object(a.c)({
					...k,
					selectedPrimaryTag: (e, t) => {
						let {
							subredditId: n
						} = t;
						return n && Object(A.x)(e, {
							subredditId: n
						}) || null
					},
					hasSecondaryTags: (e, t) => {
						let {
							subredditId: n
						} = t;
						return Object.keys(Object(A.o)(e, {
							itemId: n
						})).length > 0
					},
					isSaving: A.D
				}),
				w = Object(a.c)({
					...k,
					selectedPrimaryTag: A.v,
					hasSecondaryTags: () => !1,
					isSaving: e => Object(A.D)(e)
				}),
				T = (e, t) => {
					let {
						subredditId: n,
						onPrimarySelect: s
					} = t;
					return {
						onPrimaryTopicSelected: t => {
							t.isSelected || !s ? t.isSelected || (e(Object(d.f)({
								primaryTagId: t.value,
								subredditId: n
							})), e(Object(d.o)(n, {
								tagId: t.value,
								state: C.d.TAGGED
							}))) : s(t.value)
						},
						onShowTooltip: () => {
							e(Object(c.f)({
								tooltipId: E
							}))
						}
					}
				};
			class P extends o.a.Component {
				constructor(e) {
					super(e), this.state = {
						tooltipDismissed: !0
					}
				}
				componentDidMount() {
					const e = this.props.onShowTooltip;
					this.setState({
						tooltipDismissed: Object(p.t)()
					}, () => {
						this.isTooltipEnabled() && e && e()
					})
				}
				isTooltipEnabled() {
					const {
						shouldShowTooltip: e = !1,
						selectedPrimaryTag: t
					} = this.props;
					return !this.state.tooltipDismissed && !t && e
				}
				render() {
					const {
						availablePrimaryTags: e,
						className: t,
						hasSecondaryTags: n,
						isSaving: r,
						onPrimaryTopicSelected: i,
						selectedPrimaryTag: a
					} = this.props, d = a && a.text;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(O.b, {
						id: this.isTooltipEnabled() ? E : void 0,
						className: t,
						isTopicsStyle: !0,
						displayText: d || s.fbt._("Add a Primary Topic", null, {
							hk: "1HgVte"
						}),
						options: e.map(e => ({
							displayText: e.text,
							value: e.id,
							isSelected: !!a && a.id === e.id
						})),
						onSelect: i,
						menuItemsClassName: j.a.menuItemsWrapper,
						showSelectedCheckmark: !0,
						isSaving: r
					}), this.isTooltipEnabled() && o.a.createElement(I, {
						hasPrimaryTag: !!a,
						hasSecondaryTags: n
					}))
				}
			}
			Object(i.b)(w, e => ({
				onPrimaryTopicSelected: t => {
					e(Object(d.a)({
						primaryTagId: t.value
					}))
				}
			}))(P);
			const N = Object(i.b)(S, T)(P),
				D = Object(i.b)(_, T);
			t.b = D(P)
		},
		"./src/reddit/components/CommunityTopics/SuggestedTopics/index.m.less": function(e, t, n) {
			e.exports = {
				suggestedTopicsContainer: "_3qCTJNZ-iSCZa0wyVfs6my",
				relatedText: "_389N9jvZJu60U3E7vIF00n",
				closeIcon: "M40GQ3RaivlkCl8WQ-pXo",
				plusIcon: "_2OYvdU1reofcbKMJ0wvC_x",
				suggestedTopic: "_1RmiLhJpOUx_hgduPf3F5O",
				closeIconContainer: "sHLJV3zATRod0k1f_m71I",
				suggestedTopicText: "_1-rmQV4Wee08Dt-h2GyW-o"
			}
		},
		"./src/reddit/components/CommunityTopics/SuggestedTopics/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/tags/index.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/icons/svgs/Close/index.tsx"),
				m = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				p = n("./src/reddit/components/CommunityTopics/SuggestedTopics/index.m.less"),
				b = n.n(p);
			var f = e => o.a.createElement("span", {
					className: b.a.suggestedTopic,
					onClick: () => e.onSuggestedTopicSelected(e.suggestedTopic)
				}, o.a.createElement(m.a, {
					className: b.a.plusIcon
				}), o.a.createElement("span", {
					className: b.a.suggestedTopicText
				}, e.suggestedTopic.displayText), o.a.createElement("span", {
					className: b.a.closeIconContainer,
					onClick: t => {
						t.preventDefault(), t.stopPropagation(), e.onSuggestedTopicDismissed(e.suggestedTopic)
					}
				}, o.a.createElement(u.a, {
					className: b.a.closeIcon
				}))),
				h = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				g = n("./src/reddit/models/Tags/index.ts"),
				v = n("./src/reddit/models/Toast/index.ts"),
				x = n("./src/reddit/selectors/tags.ts");
			const E = Object(a.c)({
					suggestedOptions: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = Object(x.y)(e, {
								itemId: n
							}),
							r = Object(x.r)(e, {
								subredditId: n
							}),
							o = Object(x.w)(e, {
								subredditId: n
							});
						return s.filter(e => !!e.id && o !== e.id && !r.find(t => !!t.id && t.id === e.id))
					}
				}),
				O = Object(i.b)(E, (e, t) => {
					let {
						subredditId: n,
						onOptionSelected: r,
						context: o
					} = t;
					return {
						onSuggestedOptionDismissed: t => {
							e(Object(c.n)(n, [], [{
								subredditId: n,
								tagId: t.id,
								isRelevant: !1
							}], o, !0))
						},
						onSuggestedOptionSelected: t => {
							e((e, i) => {
								const a = i();
								Object(x.r)(a, {
									subredditId: n
								}).length >= g.a ? e(Object(l.f)({
									...Object(l.e)(s.fbt._("You can only add up to {max number of topics} community topics", [s.fbt._param("max number of topics", g.a.toString())], {
										hk: "1OySAh"
									}), v.b.Error),
									duration: l.a
								})) : (e(Object(c.j)({
									subredditId: n,
									option: t
								})), Object(h.c)(i(), n, t, {
									context: o
								}), r && r(t))
							})
						}
					}
				});
			t.a = O(e => e.suggestedOptions.length ? o.a.createElement("div", {
				className: Object(d.a)(b.a.suggestedTopicsContainer, e.className)
			}, e.children || o.a.createElement("span", {
				className: b.a.relatedText
			}, s.fbt._("Related:", null, {
				hk: "1qt7CO"
			})), e.suggestedOptions.map(t => o.a.createElement(f, {
				key: t.id,
				suggestedTopic: t,
				onSuggestedTopicSelected: e.onSuggestedOptionSelected,
				onSuggestedTopicDismissed: e.onSuggestedOptionDismissed
			}))) : null)
		},
		"./src/reddit/components/CommunityTopics/index.m.less": function(e, t, n) {
			e.exports = {
				communityTopicsContainer: "wsNyCIZw7veQPURlfXwXb"
			}
		},
		"./src/reddit/components/CommunityTopics/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return v
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/actions/tags/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/components/MultiOptionSelect/index.tsx"),
				u = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				m = n("./src/reddit/models/Tags/index.ts"),
				p = n("./src/reddit/models/Toast/index.ts"),
				b = n("./src/reddit/selectors/tags.ts"),
				f = n("./src/reddit/components/CommunityTopics/index.m.less"),
				h = n.n(f);
			const g = Object(a.c)({
				availableSubredditTags: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.d)(e, {
						subredditId: n
					})
				},
				subredditTags: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.o)(e, {
						itemId: n
					})
				},
				availableGlobalOptions: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.a)(e, {
						thingId: n
					})
				},
				selectedOptions: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.r)(e, {
						subredditId: n
					})
				},
				isLoading: e => Object(b.B)(e),
				currentInput: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.i)(e, {
						subredditId: n
					})
				}
			});
			class v extends o.a.Component {
				constructor() {
					super(...arguments), this.onOptionsChanged = e => {
						const t = e.filter(e => e.selected),
							n = e.filter(e => !e.selected);
						this.onOptionsSelected(t), n.forEach(e => this.onOptionDeselected(e))
					}, this.onFocus = () => {
						this.props.onSearchBarFocused(), this.props.onFocus && this.props.onFocus()
					}
				}
				onOptionsSelected(e) {
					const t = m.a - this.props.selectedOptions.length,
						n = e.filter(e => !!e.displayText.trim()),
						s = n.slice(0, t);
					s.forEach(e => {
						if (!e.id) {
							const t = Object(b.c)(e.displayText, this.props.availableSubredditTags);
							t && (e = Object(m.f)(t, !0))
						}
						this.props.optionSelected({
							...e,
							displayText: e.displayText.trim()
						})
					}), s.length !== n.length && this.props.onMaxTopicsHit()
				}
				onOptionDeselected(e) {
					this.props.optionDeselected(e)
				}
				render() {
					return o.a.createElement("div", {
						className: h.a.communityTopicsContainer
					}, o.a.createElement(l.a, {
						readOnlyMode: this.props.readOnlyMode,
						addText: s.fbt._("Add", null, {
							hk: "2wi3d4"
						}),
						allowFreeTextEntry: !0,
						availableOptions: this.props.availableGlobalOptions,
						childClassNames: this.props.childClassNames,
						dropdownHeaderText: s.fbt._("Suggested topics", null, {
							hk: "1RASWg"
						}),
						input: this.props.currentInput,
						isError: this.props.selectedOptions.length > m.a,
						isLoading: this.props.isLoading,
						maxOptionLength: m.b,
						maxOptionsToDisplay: this.props.maxTopicsToDisplay,
						onSearchBarFocus: this.onFocus,
						onSearchBarBlur: this.props.onBlur,
						onInputChanged: e => {
							this.props.onInputChanged(e)
						},
						onOptionsChanged: this.onOptionsChanged,
						selectedOptions: this.props.selectedOptions,
						selectedOptionComponent: this.props.selectedOptionComponent,
						splitOnCommaPress: !0
					}, this.props.children))
				}
			}
			t.b = Object(i.b)(g, (e, t) => {
				let {
					subredditId: n,
					context: r
				} = t;
				return {
					optionSelected: t => {
						e(Object(d.j)({
							subredditId: n,
							option: t
						})), e((e, s) => {
							u.e(s(), n, t, {
								context: r
							})
						})
					},
					optionDeselected: t => {
						e(Object(d.i)({
							subredditId: n,
							option: t
						})), e((e, s) => {
							u.d(s(), n, t, {
								context: r
							})
						})
					},
					onInputChanged: t => e(Object(d.h)({
						subredditId: n,
						input: t
					})),
					onSearchBarFocused: () => e((e, t) => {
						u.b(t(), n, {
							context: r
						})
					}),
					onMaxTopicsHit: () => e((e, t) => {
						e(Object(c.f)({
							...Object(c.e)(s.fbt._({
								"*": "You can only add up to max {number} community topics",
								_1: "You can only add up to max 1 community topic"
							}, [s.fbt._plural(m.a, "number")], {
								hk: "s07I1"
							}), p.b.Error),
							duration: c.a
						}))
					})
				}
			})(v)
		},
		"./src/reddit/components/CompactPost/HorizontalVotes/index.m.less": function(e, t, n) {
			e.exports = {
				horizontalVotes: "_2oM1YqCxIwkvwyeZamWwhW",
				customScoreStyles: "_25IkBM0rRUqWX5ZojEMAFQ",
				customDownvoteStyles: "_783RL1AYIib59nxLCXhgv"
			}
		},
		"./src/reddit/components/CompactPost/HorizontalVotes/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				a = n("./src/reddit/components/VerticalVotes/index.tsx"),
				d = n("./src/reddit/components/CompactPost/HorizontalVotes/index.m.less"),
				c = n.n(d);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const u = Object(i.a)(e => {
				let {
					className: t,
					...n
				} = e;
				return r.a.createElement(a.a, l({}, n, {
					className: Object(o.a)(c.a.horizontalVotes, t),
					scoreClassName: Object(o.a)(c.a.customScoreStyles, n.scoreClassName),
					downvoteClassName: Object(a.b)(n) ? c.a.customDownvoteStyles : void 0
				}))
			});
			t.a = u
		},
		"./src/reddit/components/CompactPost/index.m.less": function(e, t, n) {
			e.exports = {
				hideAboveSmallTablet: "FX_aWE8xMirpzniJDh7I9",
				responsiveExpandoButton: "_3gazhzxd2iBGYb2k67_HTw",
				mHideAboveSmallTablets: "_2zV_ARVPrYN10xmbbb_4Lu",
				responsiveMeta: "_1xomvNxK4aHGoGa-YDw1Mc",
				verticalVotes: "WAapGmF_gr09J509Af-gC",
				commentsLink: "Nz0lkWnnj2V_4iBKE0WL7",
				hideBelowSmallTablet: "z_7pbLL4hZp6ikYkq0prE",
				horizontalVotes: "_37nbKm3ee5NGx6e-LXErLD",
				postTopMeta: "_1ghZRP5m5xDLh0up1rFt0e",
				mHideBelowSmallTablets: "_3x_hdVQw5uJh6xeAGoZock",
				adLinkWrapper: "_4Dt8djtbHlJ5uCZDX_SeV",
				ctaExperiment: "_3xMykgG1y_Ln8tQs4ciV4i",
				content: "_1B7SUGHK0QDoHimxX2a9D0",
				leftRail: "_2r9FABr2qYEUDyZoenhn6N",
				bulkActionCheckbox: "_44ehKZ_pl1NGGaaTYouZR",
				subredditIcon: "_1kWbgdOrvSeXIZZRIw4uBS",
				topLine: "_2ZjElFi3ORaU3VPrwmdoCp",
				postBadges: "_126a2ACB41algqMEwA34TF",
				flatList: "_3jwri54NGT-SRatPIZYiMo",
				expandedContentWrapper: "_12wy0ZFFaS3a49145uXWXt",
				crosspostMediaWrapper: "_2fCIreZsKBNS3esgsKKksM",
				compactWrapper: "YA9IzN0YR-G5_oD5EUydl",
				compactPostRow: "WnMeTcero48dKo501T-19",
				leftRailWrapper: "_3YgWdffoKyCp7UaGAEQpoo",
				proposalMetaData: "_1_B8IWlNlt5jJVg4cKy7nL",
				isEvent: "_1csviRG5jI9xOrcsmpbfwt",
				modToolsFlatlist: "_20p7Nh6bZU7MOqYuB2uJcy",
				postContainer: "_2bHVWuR_l_wVivC3FKfLFf",
				leftBorderWrapper: "_3ZmFVbkR23TIZ-3nboLYXe",
				modModeBannerWrapper: "_1_voPxd0-GKljAjvO7ZcgJ"
			}
		},
		"./src/reddit/components/CompactPost/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "renderSubredditIcon", (function() {
				return Me
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/ads/index.ts"),
				l = n("./src/lib/classNames/index.ts"),
				u = n("./src/lib/constants/index.ts"),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/constants/postLayout.ts"),
				b = n("./src/reddit/helpers/showReportIndicator/index.ts"),
				f = n("./src/reddit/helpers/styles/mixins/index.tsx"),
				h = n("./src/reddit/helpers/trackers/post.ts"),
				g = n("./src/reddit/models/Media/index.ts"),
				v = n("./src/reddit/models/Post/index.ts"),
				x = n("./src/reddit/models/User/index.ts"),
				E = n("./src/reddit/models/Vote/index.ts"),
				O = n("./src/reddit/actions/post.ts"),
				C = n("./src/reddit/actions/postFlair.ts"),
				A = n("./src/reddit/actions/tooltip.ts"),
				y = n("./src/reddit/selectors/activeModalId.ts"),
				j = n("./src/reddit/selectors/moderatorPermissions.ts"),
				I = n("./src/reddit/selectors/postFlair.ts"),
				k = n("./src/reddit/selectors/posts.ts"),
				_ = n("./src/reddit/components/AdLinkWrapper/index.tsx"),
				S = n("./src/reddit/components/AdLinkWrapperContent/index.tsx"),
				w = n("./src/reddit/components/AwardBadges/index.tsx"),
				T = n("./src/reddit/components/CommentsChat/LiveIcon/index.tsx"),
				P = n("./src/reddit/components/CommentsLink/index.tsx"),
				N = n("./src/reddit/components/CompactPost/HorizontalVotes/index.tsx"),
				D = n("./src/reddit/components/EventPost/EventMetaHeader/index.tsx"),
				M = n("./src/reddit/components/ExpandoButton/index.tsx"),
				R = n("./src/reddit/components/Flatlist/index.tsx"),
				L = n("./src/reddit/components/Flatlist/getFlatlistTooltipId.ts"),
				B = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				F = n("./src/reddit/components/ModActionsMenu/index.tsx"),
				U = n("./src/reddit/components/ModModeFilteredReason/index.tsx"),
				H = n("./src/reddit/components/ModModeFilteredReason/helpers.ts"),
				G = n("./src/reddit/components/ModModeReports/index.tsx"),
				Q = n("./src/reddit/components/ModModeReports/helpers.ts"),
				q = n("./src/reddit/components/ModToolsFlatlist/index.tsx"),
				W = n("./src/reddit/components/OneFeed/PostRecommendationContext.tsx"),
				z = n("./src/reddit/components/PostBackgroundWrapper/index.tsx"),
				V = n("./src/reddit/components/PostBadges/index.tsx"),
				K = n("./src/reddit/components/PostContainer/index.tsx"),
				Y = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				J = n("./src/reddit/components/PostLeftRail/index.tsx"),
				X = n("./src/reddit/components/PostMedia/index.tsx"),
				Z = n("./src/reddit/components/PostModModeDropdown/index.tsx"),
				$ = n("./src/reddit/components/PostOverflowMenu/index.tsx"),
				ee = n("./src/reddit/components/PostTitle/index.tsx"),
				te = n("./src/reddit/components/PostTopMeta/index.tsx"),
				ne = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				se = n("./src/reddit/components/SponsoredLabel/index.tsx"),
				re = n("./src/reddit/components/SubredditIcon/index.tsx"),
				oe = n("./src/reddit/components/VerticalVotes/index.tsx"),
				ie = n("./src/reddit/components/ViewReportsDropdown/Loader.ts"),
				ae = n("./src/reddit/contexts/PageLayer/index.tsx"),
				de = n("./src/reddit/contexts/Post/index.tsx"),
				ce = n("./src/reddit/controls/Checkbox/index.tsx"),
				le = n("./src/reddit/controls/MetaData/index.tsx"),
				ue = n("./src/reddit/helpers/hasModFlairPermissions/index.ts"),
				me = n("./src/reddit/helpers/hasModFullPermissions/index.ts"),
				pe = n("./src/reddit/helpers/hasModPostPermissions/index.ts"),
				be = n("./src/reddit/helpers/postEvent.ts"),
				fe = n("./src/reddit/hooks/useIsOverlay.ts"),
				he = n("./src/reddit/hooks/useTheme.ts"),
				ge = n("./src/reddit/hooks/useUserContext.ts"),
				ve = n("./src/reddit/icons/fonts/IgnoreReport/index.tsx"),
				xe = n("./src/reddit/icons/fonts/Report/index.tsx"),
				Ee = n("./src/reddit/selectors/experiments/web2x_cta.ts"),
				Oe = n("./src/reddit/helpers/styles/mixins/index.m.less"),
				Ce = n.n(Oe),
				Ae = n("./src/reddit/selectors/experiments/chat.ts"),
				ye = n("./src/redditGQL/types.ts"),
				je = n("./src/reddit/components/LiveChatActiveUserCountWrapper/index.tsx"),
				Ie = n("./src/reddit/components/CompactPost/index.m.less"),
				ke = n.n(Ie);

			function _e() {
				return (_e = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const Se = e => {
					let {
						isCompact: t,
						...n
					} = e;
					return o.a.createElement(M.a, _e({
						className: Object(l.a)(ke.a.responsiveExpandoButton, {
							[ke.a.mHideAboveSmallTablets]: !!t,
							[ke.a.mHideBelowSmallTablets]: !t
						})
					}, n))
				},
				we = () => Object(d.c)({
					activeModalId: y.a,
					crosspost: k.d,
					flairStyleTemplate: ae.Y,
					isActive: k.j,
					isExpanded: k.m,
					layout: ae.U,
					moderatorPermissions: j.m,
					poll: (e, t) => {
						const n = e.posts.metaMap[t.postId];
						if (n) return e.polls.models[n]
					},
					showEditFlair: I.a,
					isModWithUserNotesPermissions: (e, t) => {
						let {
							subreddit: n
						} = t;
						return !!n && Object(j.i)(e, n.id)
					},
					showCTAExperimentDesign: Ee.a,
					isLiveChatUserCountEnabled: Ae.f
				}),
				Te = (e, t) => {
					let {
						postId: n
					} = t;
					return {
						dispatchFlairChanged: t => {
							let {
								post: n,
								previewFlair: s,
								selectedTemplateId: r
							} = t;
							return e(Object(C.h)({
								post: n,
								previewFlair: s,
								selectedTemplateId: r
							}))
						},
						handleVote: t => {
							const s = t === E.a.upvoted ? Object(O.ib)(n) : Object(O.v)(n);
							e(s)
						},
						onIgnoreReports: () => e(Object(O.eb)(n)),
						onOpenReportsDropdown: t => e(Object(A.h)({
							tooltipId: t
						}))
					}
				};
			class Pe extends o.a.Component {
				componentDidUpdate(e) {
					this.props.onSizeChanged && e.isExpanded !== this.props.isExpanded && this.props.onSizeChanged(this.props.post.id)
				}
				render() {
					const {
						activeModalId: e,
						className: t,
						currentProfileName: n,
						crosspost: s,
						currentUser: r,
						eventFactory: i,
						flairStyleTemplate: a,
						handleVote: d,
						imageGalleryCurrentItem: u,
						isCheckboxSelected: m = !1,
						isCommentsPage: E,
						isCommentPermalink: O,
						isExpanded: C,
						isGalleryTileLayoutDefault: A,
						isModWithUserNotesPermissions: y,
						isOverlay: j,
						isProfilePostListing: I,
						inSubredditOrProfile: k = !1,
						layout: M,
						moderatorPermissions: X,
						modModeEnabled: se,
						onClickPost: re,
						onFlairChanged: ae,
						onIgnoreReports: de,
						poll: le,
						post: fe,
						subredditOrProfile: he,
						userIsOp: ge,
						hideModTools: Ee,
						scrollerItemRef: Oe,
						showBulkActionCheckbox: Ae,
						showEditFlair: Ie,
						toggleCheckbox: _e,
						tooltipType: we,
						sendEvent: Te,
						shouldShowGalleryTileOption: Pe,
						showCTAExperimentDesign: De,
						isLiveChatUserCountEnabled: Me
					} = this.props, Le = !!fe.media && fe.media.type === g.o.RTJSON, Be = ge && Le, Fe = Object(Y.b)(fe.id, j), Ue = Object(pe.a)(X), He = Object(ue.a)(X), Ge = Object(me.a)(X), Qe = `-mod-actions-menu-${fe.id}`, qe = `voting-arrows-${fe.id}`, We = !!r && Object(x.e)(r) === fe.author, ze = Object(H.a)(fe), Ve = Object(Q.c)(fe), Ke = Object(L.a)("View--Reports", fe.id, we), Ye = Object(Q.a)(fe), Je = !(j || E || O), Xe = e => Te(Object(h.n)(fe.id, e)), Ze = Object(c.t)(fe, u), $e = Object(v.r)(fe);
					return o.a.createElement(K.b, {
						className: Object(l.a)(Ce.a.compactPostStyles, ke.a.postContainer, Object(f.a)(this.props), t),
						isOverlay: j,
						style: {
							...Object(f.d)(this.props),
							...Object(f.b)(this.props.flairStyleTemplate)
						},
						post: fe,
						onClick: re,
						eventFactory: i
					}, o.a.createElement("div", {
						className: ke.a.compactWrapper
					}, o.a.createElement("div", {
						className: ke.a.leftRailWrapper
					}, o.a.createElement("div", {
						className: ke.a.leftRail,
						style: {
							borderColor: Object(J.c)({
								isRemoved: !!fe.bannedBy,
								isReported: Object(b.a)(fe),
								isSponsored: fe.isSponsored,
								theme: this.props.theme
							})
						}
					}, Ae && o.a.createElement(ce.a, {
						className: ke.a.bulkActionCheckbox,
						isCheckboxSelected: m,
						toggleCheckbox: _e
					}), o.a.createElement(oe.a, {
						className: ke.a.verticalVotes,
						compact: !0,
						flairStyleTemplate: a,
						model: fe,
						onVoteClick: d
					}), o.a.createElement(N.a, {
						className: ke.a.horizontalVotes,
						compact: !1,
						flairStyleTemplate: a,
						model: fe,
						onVoteClick: d,
						upvoteTooltipId: qe
					}))), o.a.createElement(z.a, {
						className: Object(l.a)(ke.a.content, {
							[ke.a.isEvent]: Object(be.a)(fe)
						}),
						"data-click-id": "background",
						flairStyleTemplate: a
					}, o.a.createElement(D.a, {
						isCompactMode: !0,
						post: fe
					}), o.a.createElement("div", {
						className: ke.a.compactPostRow
					}, !Ee && o.a.createElement(Se, {
						crosspost: s,
						isCommentsPage: E,
						isCompact: !1,
						isExpanded: C,
						post: fe,
						useMediaIcons: !0
					}), !k && !fe.isSponsored && o.a.createElement(B.h, {
						type: fe.belongsTo.type,
						id: fe.belongsTo.id
					}), o.a.createElement("div", {
						className: ke.a.topLine,
						"data-click-id": "body"
					}, $e && o.a.createElement(W.a, {
						content: fe.recommendationContext.content,
						layout: p.g.Compact,
						post: fe
					}), o.a.createElement(ee.c, {
						post: fe,
						poll: le,
						size: ee.b.Small,
						titleColor: a && a.postTitleColor,
						isOverlay: !1
					}), Re(fe, he), o.a.createElement(te.g, {
						className: ke.a.postTopMeta,
						flairStyleTemplate: a,
						isModWithUserNotesPermissions: y,
						post: fe,
						showSub: !!he && !k && !fe.isSponsored,
						subredditOrProfile: he
					}), o.a.createElement(V.a, {
						className: ke.a.postBadges,
						displayText: he ? he.displayText : null,
						inSubredditOrProfile: k,
						post: fe
					}), o.a.createElement(w.a, {
						thing: fe,
						tooltipType: j ? te.f.Lightbox : void 0
					}), fe.discussionType === ye.o.Chat && o.a.createElement(je.a, {
						postId: fe.id
					})), Je && !Me && o.a.createElement("div", null, o.a.createElement(T.a, {
						className: ke.a.liveDiscussionIcon,
						postId: fe.postId
					})), !fe.isSurveyAd && o.a.createElement("div", {
						className: ke.a.flatList
					}, o.a.createElement(P.a, {
						className: ke.a.commentsLink,
						hasModPostPerms: Ue,
						isCommentsPage: E,
						isCommentPermalink: O,
						isOverlay: j,
						postId: fe.id,
						modModeEnabled: se,
						numComments: fe.numComments,
						type: p.g.Compact,
						impressionId: fe.impressionId,
						isSponsored: fe.isSponsored
					}), o.a.createElement(q.a, {
						className: ke.a.modToolsFlatlist,
						isOverlay: !1,
						layout: M,
						modModeEnabled: se,
						post: fe,
						sendEvent: Te,
						showIconsOnly: !0
					}), Ue && o.a.createElement(F.a, {
						dropdownId: Qe,
						onClick: () => Xe("post_mod_action_menu")
					}, o.a.createElement(R.b, null), o.a.createElement(Z.a, {
						canEditFlair: He && Ie,
						hasModPostPerms: Ue,
						hasModFullPerms: Ge,
						isOverlay: !1,
						isPostAuthor: We,
						modModeEnabled: se,
						post: fe,
						tooltipId: Qe
					})), Ue && Ve && !se && o.a.createElement(ne.c, {
						text: `${Ye}`,
						onClick: () => {
							this.props.onOpenReportsDropdown(Ke), Xe("post_report_menu")
						},
						id: Ke
					}, o.a.createElement(ie.a, {
						model: fe,
						onIgnoreReports: () => {
							de(), Xe(fe.ignoreReports ? "restore_reports" : "ignore_reports")
						},
						tooltipId: Ke
					}), fe.ignoreReports ? o.a.createElement(ve.a, null) : o.a.createElement(xe.a, null)), o.a.createElement($.a, {
						currentProfileName: n,
						isCommentsPage: E,
						isOverlay: !1,
						isProfilePostListing: I,
						isRecommendationPost: !!fe.recommendationContext,
						layout: M,
						permalink: fe.permalink,
						sendEvent: Te,
						showEditPost: Be,
						showEditFlair: Ie,
						dropdownId: `${fe.id}-overflow-menu`,
						useFlatlistBreakpoints: Object($.b)({
							share: !1,
							editPost: !1,
							save: !1,
							gild: !1,
							hide: !1,
							report: !1,
							mute: !1,
							promotePost: !1
						})
					}), !Ee && o.a.createElement(Se, {
						crosspost: s,
						isCommentsPage: E,
						isCompact: !0,
						isExpanded: C,
						post: fe,
						useMediaIcons: !0
					}))), Object(c.v)(fe, u) && o.a.createElement(_.a, {
						className: Object(l.a)(ke.a.adLinkWrapper, {
							[ke.a.ctaExperiment]: De
						}),
						ctaExperimentDesign: De && "compact"
					}, o.a.createElement(S.a, {
						post: fe,
						adLinkContent: Ze,
						isCompact: !0,
						ctaExperimentDesign: De && "compact"
					})), se && Ue && ze && o.a.createElement("div", {
						className: ke.a.modModeBannerWrapper
					}, o.a.createElement(U.a, {
						thing: fe
					})), se && Ue && Ve && o.a.createElement("div", {
						className: ke.a.modModeBannerWrapper
					}, o.a.createElement(G.a, {
						onIgnoreReports: de,
						reportable: fe
					})), o.a.createElement(B.d, null))), C && o.a.createElement(Ne, {
						post: fe,
						scrollerItemRef: Oe,
						flairStyleTemplate: a,
						shouldShowGalleryTileOption: Pe,
						isGalleryTileLayoutDefault: A
					}), e === Fe && o.a.createElement(Y.a, {
						flairs: fe.flair,
						subredditId: fe.belongsTo.id,
						modalId: Fe,
						onFlairChanged: ae
					}))
				}
			}
			const Ne = e => o.a.createElement(z.a, {
					className: Object(l.a)(e.className, ke.a.expandedContentWrapper),
					flairStyleTemplate: e.flairStyleTemplate
				}, e.post.crosspostRootId ? o.a.createElement("div", {
					className: ke.a.crosspostMediaWrapper
				}, De(e.post, e.scrollerItemRef, e.shouldShowGalleryTileOption, e.isGalleryTileLayoutDefault)) : De(e.post, e.scrollerItemRef, e.shouldShowGalleryTileOption, e.isGalleryTileLayoutDefault)),
				De = (e, t, n, s) => o.a.createElement(X.a, {
					isExpando: !0,
					isGalleryTileLayoutDefault: s,
					isListing: !0,
					isNotCardView: !0,
					post: e,
					scrollerItemRef: t,
					shouldLoad: !0,
					shouldPause: !1,
					shouldShowGalleryTileOption: n,
					showCentered: !0,
					showFull: !0
				}),
				Me = e => o.a.createElement(a.a, {
					"data-click-id": "subreddit",
					to: e.url
				}, o.a.createElement(re.b, {
					className: ke.a.subredditIcon,
					subredditOrProfile: e
				})),
				Re = (e, t) => o.a.createElement("div", {
					className: ke.a.responsiveMeta
				}, o.a.createElement(le.b, {
					isScoreHidden: e.scoreHidden,
					score: e.score
				}), o.a.createElement(le.c, null), Object(le.d)(e.numComments), o.a.createElement(le.c, null), t && o.a.createElement("a", {
					href: t.url
				}, o.a.createElement(le.a, null, t.displayText)), e.isSponsored && [o.a.createElement(se.a, {
					key: "label",
					isSurveyAd: e.isSurveyAd
				}), o.a.createElement(le.c, {
					key: "separator"
				})], !e.isSponsored && o.a.createElement(le.a, null, " ", s.fbt._("Posted by", null, {
					hk: "UqFDR"
				}), " "), o.a.createElement(te.d, {
					post: e,
					isDeleted: e.author === u.G
				}));
			t.default = Object(de.b)(o.a.memo((function(e) {
				const t = Object(ge.a)(),
					n = Object(r.useMemo)(() => we(), []),
					s = Object(i.e)(s => n(s, {
						...e,
						...t
					})),
					a = Object(i.d)(),
					d = Te(a, {
						...e,
						...t
					});
				return o.a.createElement(Pe, _e({}, e, t, s, d, {
					onFlairChanged: t => {
						let {
							previewFlair: n,
							selectedTemplateId: s
						} = t;
						return d.dispatchFlairChanged({
							post: e.post,
							previewFlair: n,
							selectedTemplateId: s
						})
					},
					sendEvent: Object(m.b)(),
					isOverlay: Object(fe.a)(),
					theme: Object(he.a)()
				}))
			})))
		},
		"./src/reddit/components/ConfirmModal/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3DhQ2s_h1XCiwltypHmlbp",
				close: "_2oxgXPm-tiPAEPsJoUw-ZD",
				headerText: "_2sDCzF6zlpNJ5cbVDRCPOS",
				text: "_3eWjwYvkDvPzyq4FlubrF9",
				buttonWrapper: "_6ZHRZ8Epefe887d7LL-q6",
				primaryButton: "Ch-0dFLxLOtcc6xCyQvsk",
				secondaryButton: "bgwHoiDoSwFVZKRTLRQMF"
			}
		},
		"./src/reddit/components/ConfirmModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/asModal/index.tsx"),
				i = n("./src/reddit/controls/Button/index.tsx"),
				a = n("./src/reddit/components/ConfirmModal/index.m.less"),
				d = n.n(a),
				c = n("./src/reddit/components/ModalStyledComponents/index.tsx");
			t.a = Object(o.a)(e => r.a.createElement("div", {
				className: d.a.container
			}, r.a.createElement("button", {
				onClick: () => e.onClose ? e.onClose() : e.onCancel(),
				className: d.a.close
			}, r.a.createElement(c.b, null)), r.a.createElement(c.i, null, r.a.createElement("h2", {
				className: d.a.headerText
			}, e.headerText)), r.a.createElement(c.l, null, e.message && r.a.createElement("p", {
				className: d.a.text
			}, e.message), e.children && r.a.createElement("div", {
				className: d.a.text
			}, e.children), r.a.createElement("div", {
				className: d.a.buttonWrapper
			}, e.cancelText && r.a.createElement(i.o, {
				className: d.a.secondaryButton,
				onClick: e.onCancel
			}, e.cancelText), r.a.createElement(i.l, {
				className: d.a.primaryButton,
				onClick: e.onAccept
			}, e.acceptText)))))
		},
		"./src/reddit/components/ConfirmUserActionModal/index.m.less": function(e, t, n) {
			e.exports = {
				buttonWidth: "ogOEj4x-0BpDZWeccJwxx",
				ModalText: "_2YxEi97B6Nm7NCgLG6pCud",
				modalText: "_2YxEi97B6Nm7NCgLG6pCud"
			}
		},
		"./src/reddit/components/ConfirmUserActionModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/higherOrderComponents/asModal/index.tsx"),
				a = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				d = n("./src/reddit/controls/TextButton/index.tsx"),
				c = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				l = n("./src/reddit/components/ConfirmUserActionModal/index.m.less"),
				u = n.n(l);
			const m = e => e.preventDefault();
			t.a = Object(i.a)(e => o.a.createElement(a.e, null, o.a.createElement(a.i, null, o.a.createElement(c.a, null, o.a.createElement(a.q, null, e.headerText || s.fbt._("Confirm", null, {
				hk: "2zlvKa"
			})), o.a.createElement(d.a, {
				onClick: t => {
					e.onClose && e.onClose(t), e.toggleModal && e.toggleModal()
				}
			}, o.a.createElement(a.b, null)))), o.a.createElement(a.l, null, o.a.createElement(a.p, {
				className: u.a.ModalText
			}, e.modalText)), o.a.createElement(a.g, null, !e.hideCancelButton && o.a.createElement(a.a, {
				className: u.a.buttonWidth,
				onMouseDown: m,
				onClick: () => {
					e.onCancel && e.onCancel(), e.toggleModal && e.toggleModal()
				},
				"data-redditstyle": !e.disableRedditStyle
			}, e.cancelActionText || s.fbt._("Cancel", null, {
				hk: "2TSLl5"
			})), o.a.createElement(a.u, {
				className: u.a.buttonWidth,
				onMouseDown: m,
				onClick: t => {
					e.onConfirm(t), e.toggleModal && e.toggleModal(), e.trackClick && e.trackClick()
				},
				"data-redditstyle": !e.disableRedditStyle,
				disabled: e.isDisabled
			}, e.actionText))))
		},
		"./src/reddit/components/ContentGate/index.m.less": function(e, t, n) {
			e.exports = {
				ButtonsContainer: "_3-bzOoWOXVn2xJ3cljz9oC",
				buttonsContainer: "_3-bzOoWOXVn2xJ3cljz9oC",
				Container: "_32zGs4bO3IunZfS9bSJY0_",
				container: "_32zGs4bO3IunZfS9bSJY0_",
				ContainerExp: "_2l6FU0DxoyHFIOEFPg-vV6",
				containerExp: "_2l6FU0DxoyHFIOEFPg-vV6",
				Description: "_3VTI5BOpJO70xoBKSqz3O9",
				description: "_3VTI5BOpJO70xoBKSqz3O9",
				PrivateSubredditDetails: "vpktIvfG7wrc27Xk4Gk-C",
				privateSubredditDetails: "vpktIvfG7wrc27Xk4Gk-C",
				PrivateSubredditDescription: "_2uXliuchCWW0MYUGS_Ks6v",
				privateSubredditDescription: "_2uXliuchCWW0MYUGS_Ks6v",
				PrivateSubredditName: "_3boUKJ5E--k1_9nH886_Wr",
				privateSubredditName: "_3boUKJ5E--k1_9nH886_Wr",
				Link: "o4oSRcSrppMzf__hxJKxn",
				link: "o4oSRcSrppMzf__hxJKxn",
				LinkButton: "_1_UhYZsTnAQbBONlhaTTMS",
				linkButton: "_1_UhYZsTnAQbBONlhaTTMS",
				LinkRouterButton: "_2zJbrt0pYl6tbRsmVW0peX",
				linkRouterButton: "_2zJbrt0pYl6tbRsmVW0peX",
				SecondaryLinkButton: "i2sTp1duDdXdwoKi1l8ED",
				secondaryLinkButton: "i2sTp1duDdXdwoKi1l8ED",
				CreateCommunityButton: "_209KUA_ej4pZVjoQbSOIf9",
				createCommunityButton: "_209KUA_ej4pZVjoQbSOIf9",
				GoHomeLinkButton: "_3goHjUTM8-J0xINP6EoZkZ",
				goHomeLinkButton: "_3goHjUTM8-J0xINP6EoZkZ",
				PrivateKey: "kwHMAzQCDA69TaL3eHZLa",
				privateKey: "kwHMAzQCDA69TaL3eHZLa",
				Image: "_1jefpljVGT-eHObg40F8Dm",
				image: "_1jefpljVGT-eHObg40F8Dm",
				ImagePlaceholder: "yIkP2FaSTqFA_kLFyyH1d",
				imagePlaceholder: "yIkP2FaSTqFA_kLFyyH1d",
				LeftLinkButton: "_3cs2bzZ9PGS1kcZc2r7vdP",
				leftLinkButton: "_3cs2bzZ9PGS1kcZc2r7vdP",
				LeftLinkRouterButton: "_2V3wnL5o-KBHbU_hs7cMof",
				leftLinkRouterButton: "_2V3wnL5o-KBHbU_hs7cMof",
				SecondaryLeftLinkButton: "_3t2KyZopmra_0R16z-1xwr",
				secondaryLeftLinkButton: "_3t2KyZopmra_0R16z-1xwr",
				Title: "_2XKLlvmuqdor3RvVbYZfgz",
				title: "_2XKLlvmuqdor3RvVbYZfgz",
				PageBody: "bDDEX4BSkswHAG_45VkFB",
				pageBody: "bDDEX4BSkswHAG_45VkFB",
				InterstitialMessageWrapper: "_2xiFx6Zsb5W98_T1DOroT_",
				interstitialMessageWrapper: "_2xiFx6Zsb5W98_T1DOroT_",
				QuarantineLearnMore: "_10JuhN_YtdWSrIRmGSirSQ",
				quarantineLearnMore: "_10JuhN_YtdWSrIRmGSirSQ",
				ContributorRequestButton: "_3WUsc0xUSWlcvJ0BD4jiUz",
				contributorRequestButton: "_3WUsc0xUSWlcvJ0BD4jiUz"
			}
		},
		"./src/reddit/components/ContentGate/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./src/config.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router/esm/react-router.js"),
				d = n("./src/reddit/contexts/NavbarExp.ts"),
				c = n("./node_modules/reselect/es/index.js"),
				l = n("./src/lib/lessComponent.tsx"),
				u = n("./src/lib/loginHref/index.ts"),
				m = n("./src/reddit/actions/contentGate.ts"),
				p = n("./src/reddit/actions/preferences.ts"),
				b = n("./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/async.tsx"),
				f = n("./src/reddit/components/CreateCommunityButton/index.tsx"),
				h = n("./src/reddit/components/Footer/index.tsx"),
				g = n("./src/reddit/components/RawHTMLDisplay/index.tsx"),
				v = n("./src/reddit/components/RichTextJson/index.tsx"),
				x = n("./src/reddit/components/SubredditSearchCarousel/async.tsx"),
				E = n("./node_modules/lodash/flatMap.js"),
				O = n.n(E),
				C = n("./src/lib/linkMatchers/index.ts"),
				A = n("./src/lib/linkMatchers/customLinks.ts"),
				y = n("./src/reddit/controls/OutboundLink/index.tsx");
			const j = /\[(.+?)\]\((.+?)\)/g,
				I = e => {
					const t = e.split(j);
					if (1 === t.length) return [e];
					const n = [];
					for (let s = 0; s < t.length; s += 3) {
						const [e, r, o] = t.slice(s, s + 3);
						n.push(e), n.push([o, r])
					}
					return n
				};
			var k = o.a.memo(e => {
					let t = [e.text];
					return e.parseMdLinks && (t = O()(t, I)), e.parseRegularLinks && (t = O()(t, e => Array.isArray(e) ? [e] : (e => {
						const t = C.f.add(A.g.subreddit.prefix, A.g.subreddit.config).match(e);
						if (!t) return [e];
						const n = [];
						let s = null;
						for (const r of t) n.push(e.slice(s ? s.lastIndex : 0, r.index)), s = r, n.push([r.url, r.text]);
						return s && n.push(e.slice(s.lastIndex)), n
					})(e))), o.a.createElement(o.a.Fragment, null, " ", t.map((t, n) => {
						if (Array.isArray(t)) {
							const [s, r] = t;
							return o.a.createElement(y.b, {
								className: e.linkClassName,
								href: s,
								key: n
							}, r)
						}
						return o.a.createElement("span", {
							key: n
						}, t)
					}), " ")
				}),
				_ = n("./src/reddit/constants/parameters.ts"),
				S = n("./src/reddit/contexts/PageLayer/index.tsx"),
				w = n("./src/reddit/controls/Button/index.tsx"),
				T = n("./src/reddit/icons/svgs/PrivateKey/index.tsx"),
				P = n("./src/reddit/models/ContentGate.ts"),
				N = n("./src/reddit/selectors/contentGate.ts"),
				D = n("./src/reddit/selectors/meta.ts"),
				M = n("./src/reddit/selectors/user.ts"),
				R = n("./src/reddit/components/ContentGate/index.m.less"),
				L = n.n(R);
			const {
				fbt: B
			} = n("./node_modules/fbt/lib/FbtPublic.js"), F = l.a.wrapped(T.a, "PrivateKey", L.a), U = l.a.div("ButtonsContainer", L.a), H = l.a.div("Container", L.a), G = l.a.div("ContainerExp", L.a), Q = l.a.div("Description", L.a), q = l.a.div("PrivateSubredditDetails", L.a), W = l.a.div("PrivateSubredditDescription", L.a), z = l.a.h3("PrivateSubredditName", L.a), V = l.a.a("Link", L.a), K = l.a.wrapped(w.n, "LinkRouterButton", L.a), Y = l.a.wrapped(w.m, "LinkButton", L.a), J = l.a.wrapped(w.p, "SecondaryLinkButton", L.a), X = l.a.wrapped(K, "GoHomeLinkButton", L.a), Z = l.a.wrapped(f.a, "CreateCommunityButton", L.a), $ = l.a.img("Image", L.a), ee = l.a.img("ImagePlaceholder", L.a), te = l.a.wrapped(K, "LeftLinkRouterButton", L.a), ne = l.a.wrapped(Y, "LeftLinkButton", L.a), se = l.a.wrapped(J, "SecondaryLeftLinkButton", L.a), re = l.a.h3("Title", L.a), oe = l.a.div("PageBody", L.a), ie = l.a.div("InterstitialMessageWrapper", L.a), ae = l.a.div("QuarantineLearnMore", L.a), de = Object(c.c)({
				isLoggedIn: M.R,
				origin: D.l,
				user: M.m,
				isPrivateSubredditContributorRequestPending: e => Object(N.a)(e),
				isSeo: D.h
			}), ce = Object(S.v)(), le = Object(i.b)(de, (e, t) => {
				let {
					subredditName: n
				} = t;
				return {
					continueToQuarantinedSubreddit: async () => {
						await e(p.C(n)), window.location.reload()
					},
					continueToGatedSubreddit: async () => {
						await e(p.u(n)), window.location.reload()
					},
					setNSFWPreference: async () => {
						await e(Object(m.r)())
					}
				}
			}), ue = e => {
				const {
					banMessage: t,
					banTitle: n,
					contentGateType: r,
					continueToQuarantinedSubreddit: i,
					continueToGatedSubreddit: a,
					isLoggedIn: d,
					isContributorRequestsDisabled: c,
					isPrivateSubredditContributorRequestPending: l,
					isSeo: p,
					location: f,
					origin: h,
					pageLayer: E,
					quarantineRequiresEmail: O,
					quarantineMessage: C,
					quarantineMessageHtml: A,
					quarantineMessageRTJson: y,
					interstitialWarningMessage: j,
					interstitialWarningMessageHtml: I,
					interstitialWarningMessageRTJson: S,
					setNSFWPreference: w,
					subredditDescription: T,
					subredditName: N,
					user: D
				} = e, M = async () => {
					if (d ? await w() : await Object(m.q)(), p) {
						const e = new URL(window.location.href);
						e.searchParams.set(_.k, "1"), window.location.href = e.href
					} else window.location.reload()
				};
				switch (r) {
					case P.a.GoldSubreddit:
						return o.a.createElement("div", null, o.a.createElement($, {
							src: `${s.a.assetPath}/img/gold/premium-crest.png`
						}), o.a.createElement(re, null, B._("r/{community name} is a Reddit Premium community", [B._param("community name", N)], {
							hk: "2lyDwB"
						})), o.a.createElement(Q, null, B._("The moderators in this community have set it to Reddit Premium members only. You must upgrade to a Reddit Premium membership to continue.", null, {
							hk: "mIiOw"
						})), o.a.createElement(U, null, D ? o.a.createElement(se, {
							href: `${s.a.redditUrl}/premium`,
							redditStyle: !0
						}, B._("Get Premium", null, {
							hk: "3ChWi4"
						})) : o.a.createElement(ne, {
							href: Object(u.a)(f, h),
							redditStyle: !0
						}, B._("Sign Up", null, {
							hk: "rvpjy"
						})), D ? o.a.createElement(K, {
							to: "/",
							redditStyle: !0
						}, B._("Go Home", null, {
							hk: "49p4or"
						})) : o.a.createElement(J, {
							href: Object(u.a)(f, h),
							redditStyle: !0
						}, B._("Log In", null, {
							hk: "4Cxw0g"
						}))));
					case P.a.Nsfw:
					case P.a.NsfwCustomFeed:
						return o.a.createElement("div", null, o.a.createElement($, {
							src: `${s.a.assetPath}/img/content-gate-icons/nsfw.png`
						}), o.a.createElement(re, null, r === P.a.Nsfw ? B._("You must be 18+ to view this community", null, {
							hk: "IQmEA"
						}) : B._("You must be 18+ to view this Custom Feed", null, {
							hk: "3pmHS2"
						})), o.a.createElement(Q, null, B._("You must be at least eighteen years old to view this content. Are you over eighteen and willing to see adult content?", null, {
							hk: "gI12S"
						})), o.a.createElement(U, null, o.a.createElement(te, {
							to: "/",
							redditStyle: !0
						}, B._("No", null, {
							hk: "3fMglW"
						})), o.a.createElement(J, {
							onClick: M,
							redditStyle: !0
						}, B._("Yes", null, {
							hk: "2hpRkN"
						}))));
					case P.a.PrivateSubreddit:
						return o.a.createElement("div", null, o.a.createElement(F, null), o.a.createElement(re, null, "r/", N, " ", B._("is a private community", null, {
							hk: "7zZmq"
						})), T && T.length && o.a.createElement(q, null, o.a.createElement(z, null, "r/", N), o.a.createElement(W, null, o.a.createElement("div", null, T))), o.a.createElement(Q, null, B._("The moderators of", null, {
							hk: "3QSrbr"
						}), " ", "r/", N, " ", B._("have set this community as private.", null, {
							hk: "3zhD9F"
						}), o.a.createElement("br", null), B._("Only approved members can view and take part in its discussions.", null, {
							hk: "af0uR"
						})), o.a.createElement(U, null, D ? o.a.createElement(o.a.Fragment, null, !c && o.a.createElement(b.a, {
							eventSource: "content_gate",
							smallButton: !0,
							className: L.a.ContributorRequestButton,
							isContributorRequestPending: l
						}), o.a.createElement(se, {
							href: `${s.a.redditUrl}/message/compose?to=/r/${N}`,
							redditStyle: !0
						}, B._("Message Mods", null, {
							hk: "vVe1i"
						}))) : o.a.createElement(se, {
							href: Object(u.a)(f, h),
							redditStyle: !0
						}, B._("Sign Up", null, {
							hk: "rvpjy"
						})), o.a.createElement(K, {
							to: "/",
							redditStyle: !0
						}, B._("Browse Reddit", null, {
							hk: "1fi8kh"
						}))), N && o.a.createElement(x.a, {
							subredditName: N
						}));
					case P.a.QuarantinedSubreddit:
						const d = D && D.hasVerifiedEmail;
						return o.a.createElement("div", null, o.a.createElement($, {
							src: `${s.a.assetPath}/img/content-gate-icons/quarantined_interstitial.svg`
						}), o.a.createElement(re, null, B._("r/{subredditName} is quarantined", [B._param("subredditName", N)], {
							hk: "2pxhFx"
						})), o.a.createElement(Q, null, o.a.createElement(ie, null, y ? o.a.createElement(v.b, {
							content: y,
							rtJsonElementProps: {
								pageLayer: E
							}
						}) : A ? o.a.createElement(g.a, {
							html: A
						}) : C || B._("Quarantined communities are dedicated to shocking or highly offensive content. You must be logged in with a verified email to continue.", null, {
							hk: "3kRIzE"
						})), !O || d ? B._("Are you sure youd like to continue?", null, {
							hk: "1fQqm4"
						}) : D ? B._("If youd still like to view this community, verify your email address to continue.", null, {
							hk: "2vhFbK"
						}) : B._("If youd still like to view this community, verify your email address and log in to your Reddit account to continue.", null, {
							hk: "2SmlRy"
						})), o.a.createElement(U, null, ((e, t, n) => {
							const r = e && e.hasVerifiedEmail;
							return !n || r ? o.a.createElement(U, null, o.a.createElement(te, {
								to: "/",
								redditStyle: !0
							}, B._("Go Back", null, {
								hk: "11Lp6m"
							})), o.a.createElement(J, {
								onClick: t,
								redditStyle: !0
							}, B._("Yes, Continue", null, {
								hk: "1D03m3"
							}))) : o.a.createElement(U, null, o.a.createElement(te, {
								to: "/",
								redditStyle: !0
							}, B._("Go Back", null, {
								hk: "11Lp6m"
							})), o.a.createElement(J, {
								href: `${s.a.redditUrl}/prefs/update`,
								redditStyle: !0
							}, B._("Verify Email", null, {
								hk: "1893cq"
							})))
						})(D, i, O)), o.a.createElement(ae, null, B._("Learn more about {=quarantined communities}.", [B._param("=quarantined communities", o.a.createElement(V, {
							href: "https://reddit.zendesk.com/hc/en-us/articles/360043069012-Quarantined-Subreddits"
						}, B._("quarantined communities", null, {
							hk: "3yq6Z5"
						})))], {
							hk: "uOTFJ"
						})));
					case P.a.GatedSubreddit:
						return o.a.createElement("div", null, o.a.createElement(re, null, B._("Are you sure you want to view this community?", null, {
							hk: "1K5UIm"
						})), o.a.createElement(Q, null, o.a.createElement(ie, null, S ? o.a.createElement(v.b, {
							content: S,
							rtJsonElementProps: {
								pageLayer: E
							}
						}) : I ? o.a.createElement(g.a, {
							html: I
						}) : j), B._("Are you certain you want to continue?", null, {
							hk: "3pT969"
						})), o.a.createElement(U, null, o.a.createElement(te, {
							to: "/",
							redditStyle: !0
						}, B._("No Thank You", null, {
							hk: "4B26AR"
						})), o.a.createElement(J, {
							onClick: a,
							redditStyle: !0
						}, B._("Continue", null, {
							hk: "2rLyAk"
						}))));
					case P.a.SubredditBanned:
						return o.a.createElement("div", null, o.a.createElement($, {
							src: `${s.a.assetPath}/img/content-gate-icons/banned.png`
						}), o.a.createElement(re, null, n), (e => o.a.createElement(Q, null, e ? o.a.createElement(k, {
							linkClassName: L.a.Link,
							text: e,
							parseMdLinks: !0,
							parseRegularLinks: !0
						}) : B._("This community has been banned for violating the Reddit rules.", null, {
							hk: "3iUVxA"
						})))(t), o.a.createElement(U, null, o.a.createElement(K, {
							to: "/",
							redditStyle: !0
						}, B._("Explore Reddit", null, {
							hk: "FrUWU"
						}))));
					case P.a.SubredditBlockedForLegalReason:
						return o.a.createElement("div", null, o.a.createElement($, {
							src: `${s.a.assetPath}/img/snoomoji/snoo_thoughtful.png`
						}), o.a.createElement(re, null, B._("This content has been restricted in your country in response to a legal request.", null, {
							hk: "4bCnhl"
						})), o.a.createElement(U, null, o.a.createElement(K, {
							to: "/",
							redditStyle: !0
						}, B._("Explore Reddit", null, {
							hk: "FrUWU"
						}))));
					case P.a.SubredditDoesNotExist:
						return o.a.createElement("div", null, o.a.createElement(ee, null), o.a.createElement(re, null, B._("Sorry, there arent any communities on Reddit with that name.", null, {
							hk: "31DRpe"
						})), o.a.createElement(Q, null, B._("This community may have been banned or the community name is incorrect.", null, {
							hk: "1lYMG2"
						})), o.a.createElement(U, null, D && o.a.createElement(Z, {
							eventSource: "content_gate"
						}), o.a.createElement(X, {
							to: "/",
							redditStyle: !0
						}, B._("Go Home", null, {
							hk: "49p4or"
						}))));
					case P.a.ProfileDoesNotExist:
					case P.a.ProfileDeleted:
					case P.a.ProfileSuspended:
					case P.a.ProfileBlockedForLegalReason:
						return o.a.createElement("div", null, o.a.createElement($, {
							src: `${s.a.assetPath}/img/snoomoji/snoo_thoughtful.png`
						}), o.a.createElement(re, null, (e => {
							const {
								contentGateType: t
							} = e;
							switch (t) {
								case P.a.ProfileBlockedForLegalReason:
									return B._("This content has been restricted in your country in response to a legal request.", null, {
										hk: "4eeylO"
									});
								case P.a.ProfileDeleted:
									return B._("This user has deleted their account.", null, {
										hk: "2IAF6m"
									});
								case P.a.ProfileSuspended:
									return o.a.createElement(o.a.Fragment, null, B._("This account has been {=suspended} .", [B._param("=suspended", o.a.createElement(V, {
										href: "https://www.reddithelp.com/en/categories/reddit-101/rules-reporting/account-and-community-restrictions/suspensions"
									}, B._("suspended", null, {
										hk: "3nHGgi"
									})))], {
										hk: "4cuTBS"
									}));
								case P.a.ProfileDoesNotExist:
									return o.a.createElement(o.a.Fragment, null, o.a.createElement(re, null, B._("Sorry, nobody on Reddit goes by that name.", null, {
										hk: "3i02av"
									})), o.a.createElement(Q, null, B._("The person may have been banned or the username is incorrect.", null, {
										hk: "36ab4J"
									})))
							}
						})(e)), o.a.createElement(U, null, o.a.createElement(X, {
							to: "/",
							redditStyle: !0
						}, B._("Go Home", null, {
							hk: "49p4or"
						}))));
					case P.a.CustomFeedDoesNotExist:
						return o.a.createElement("div", null, o.a.createElement($, {
							src: `${s.a.assetPath}/img/snoomoji/snoo_thoughtful.png`
						}), o.a.createElement(re, null, B._("Sorry, this custom feed is private or does not exist.", null, {
							hk: "2Ml4j9"
						})), o.a.createElement(U, null, o.a.createElement(X, {
							to: "/",
							redditStyle: !0
						}, B._("Go Home", null, {
							hk: "49p4or"
						}))));
					case P.a.PostBlockedForLegalReason:
						return o.a.createElement("div", null, o.a.createElement($, {
							src: `${s.a.assetPath}/img/snoomoji/snoo_thoughtful.png`
						}), o.a.createElement(re, null, B._("This content has been restricted in your country in response to a legal request.", null, {
							hk: "1q1rVU"
						})), o.a.createElement(U, null, o.a.createElement(K, {
							to: "/",
							redditStyle: !0
						}, B._("Browse Reddit", null, {
							hk: "1XnYmj"
						}))))
				}
			};
			t.default = ce(le(Object(a.i)(e => {
				const t = Object(r.useContext)(d.a) ? G : H;
				return o.a.createElement(t, null, o.a.createElement("div", {
					"data-testid": "content-gate"
				}, o.a.createElement(oe, null, ue(e))), o.a.createElement(h.b, null))
			})))
		},
		"./src/reddit/components/ContentSurvey/RatingCard.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/components/ContentSurvey/index.m.less"),
				a = n.n(i),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/components/SubredditIcon/index.tsx"),
				l = n("./src/reddit/hooks/useTheme.ts"),
				u = n("./src/reddit/icons/svgs/Info/index.tsx"),
				m = n("./src/reddit/models/Theme/index.ts"),
				p = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				b = n("./src/reddit/selectors/subreddit.ts");
			const {
				fbt: f
			} = n("./node_modules/fbt/lib/FbtPublic.js");

			function h(e) {
				var t, n;
				const {
					ratingResponse: s,
					subredditId: i,
					children: h
				} = e, g = null !== (t = Object(o.e)(e => Object(b.X)(e, {
					subredditId: i
				}))) && void 0 !== t ? t : {}, v = Object(l.a)();
				return r.a.createElement("div", {
					className: a.a.ratingCard
				}, "PENDING" === (null == s ? void 0 : s.status) && r.a.createElement("div", {
					className: Object(d.a)(a.a.card, a.a.pending)
				}, r.a.createElement(u.a, {
					className: a.a.infoIcon
				}), f._("Content tag is pending until reviewed", null, {
					hk: "Umha7"
				})), r.a.createElement("div", {
					className: a.a.card
				}, r.a.createElement("div", {
					className: a.a.banner,
					style: {
						background: Object(m.g)(Object(p.a)({
							theme: v
						}).banner.backgroundColor, Object(p.a)({
							theme: v
						}).banner.backgroundImage, Object(p.a)({
							theme: v
						}).banner.backgroundImagePosition)
					}
				}, r.a.createElement(c.b, {
					className: a.a.communityIcon,
					iconUrl: null === (n = g.icon) || void 0 === n ? void 0 : n.url
				})), r.a.createElement("h3", {
					className: a.a.communityName
				}, s ? r.a.createElement("span", null, g.displayText, r.a.createElement("img", {
					className: a.a.ratingImg,
					src: s.rating.icon.png
				})) : g.displayText), h))
			}
		},
		"./src/reddit/components/ContentSurvey/SurveyModal.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/higherOrderComponents/asModal/index.tsx");
			const o = Object(s.a)({
					resolved: {},
					chunkName: () => "",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e(0), n.e(5)]).then(n.bind(null, "./src/reddit/components/ContentSurvey/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ContentSurvey/index.tsx"
					}
				}),
				i = Object(r.a)(o);
			t.a = i
		},
		"./src/reddit/components/ContentSurvey/index.m.less": function(e, t, n) {
			e.exports = {
				feedBanner: "_3oY2sjcQ7EgBYd7agqleJv",
				notepadSnoo: "B0cLCCVs794x74kjJidDO",
				bannerCopy: "_2NfcId0Mtt4-NP4AbrAck5",
				copy: "BcSr5zM39F4cQJ9MQqkRn",
				meta: "r9AkMaLWOPKfC5Swx9XQf",
				chevron: "yFbNzMMxa-u2DgUP3Gz5h",
				header: "wKkshJ3Og8gaDgJmSULiK",
				introCopy: "m3rT-KnA6An7scRNg10UW",
				checkbox: "Y5aDAUsXXQaMbdCe1-qdG",
				result: "_29ewfEVekvKEl_P2hqf4tI",
				heading: "_3yKTUBG4MrGHv9n644t4Ua",
				card: "_18VT-IpGoX6SDdyHHLI_eo",
				pending: "hg80uiMz2ssH44RLsmlhG",
				infoIcon: "_3HgNBpJCFAy2mohcd9VxmZ",
				banner: "_23eBsXSECZlQ3Eh-zXhEbC",
				communityIcon: "_2Z8cRxGvjX2hQUlQK_VEOE",
				communityName: "_1sHP__xe_7iTbSpLKp7FeC",
				ratingImg: "UZWqo3i6ydUcE18iJqx3P",
				ratingAudience: "_1Y5aAemcMRF3uwSgYpqbsT",
				ratingDescription: "_1e5wHYsIyWJlZSjZCHhBKg",
				reasonsHeader: "_1npcgCYHbRcUsU6KOI7ony",
				reason: "_3rlzPcuZsxLsVx6ib3oBjk"
			}
		},
		"./src/reddit/components/ContentTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				StyledTooltipContainer: "_2uSuNRa3OeptFDJCKQ3vU6",
				styledTooltipContainer: "_2uSuNRa3OeptFDJCKQ3vU6",
				fadeIn: "_2bkYZH_kJx5pIHW0Ts5P6e",
				caretOnBottom: "_1rF-A55THyDL-rQ9ZUDQ4_",
				caretOnTop: "_1MHCyMQAMeqRqf5DPWWeq3",
				hideCaret: "dExJJiXRwxVrKsDJRWSQl",
				caretOnLeft: "nVD-oexLbZI_4QjhrkLFz",
				caretOnRight: "KRVDnoE1RIC5qyqQLXxGG"
			}
		},
		"./src/reddit/components/ContentTooltip/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/addOverlayEvents.tsx"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				l = n("./src/lib/fastdom/index.ts"),
				u = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				m = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				p = n("./src/reddit/selectors/tooltip.ts"),
				b = n("./src/reddit/components/ContentTooltip/index.m.less"),
				f = n.n(b);

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const g = {
					height: 200,
					width: 200
				},
				v = e => {
					switch (e) {
						case "top":
							return "bottom";
						case "right":
							return "left";
						case "left":
							return "right";
						case "bottom":
						default:
							return "top"
					}
				},
				x = Object(c.a)(e => {
					const {
						children: t,
						className: n,
						style: s,
						caretPosition: r,
						caretColor: i,
						onClick: a,
						hideCaret: c
					} = e;
					return o.a.createElement("div", {
						onClick: a,
						className: Object(d.a)(n, f.a.StyledTooltipContainer, {
							[f.a.caretOnTop]: "top" === r,
							[f.a.caretOnLeft]: "left" === r,
							[f.a.caretOnRight]: "right" === r,
							[f.a.caretOnBottom]: "bottom" === r,
							[f.a.hideCaret]: c
						}),
						style: {
							...s,
							"--contentTooltip-caretColor": i && i[r] ? i[r] : Object(m.a)(e).body
						}
					}, t)
				}),
				E = Object(a.c)({
					isOpen: (e, t) => {
						let {
							tooltipId: n
						} = t;
						return Object(p.b)(n)(e)
					}
				}),
				O = Object(u.a)(x, [s.a.Click, s.a.Keydown]),
				C = Object(i.b)(E);
			class A extends o.a.Component {
				constructor(e) {
					super(e), this.checkAndSetPosition = () => {
						const {
							tooltipId: e,
							tooltipSizeEstimate: t = g
						} = this.props;
						l.a.read(() => {
							const n = document.getElementById(e);
							if (!n) return;
							const s = n.getBoundingClientRect();
							if (!("undefined" != typeof window)) return void this.setState({
								position: this.props.defaultTooltipPosition
							});
							let r = !0;
							switch (this.props.defaultTooltipPosition) {
								case "bottom":
									r = window.innerHeight - s.bottom > t.height;
									break;
								case "left":
									r = s.left > t.width;
									break;
								case "right":
									r = s.right <= window.innerWidth - t.width;
									break;
								case "top":
								default:
									r = s.top > t.height
							}
							this.setState({
								position: r ? this.props.defaultTooltipPosition : v(this.props.defaultTooltipPosition)
							})
						})
					}, this.state = {
						position: null
					}
				}
				componentDidUpdate(e) {
					!e.isOpen && this.props.isOpen && this.checkAndSetPosition(), e.isOpen && !this.props.isOpen && this.setState({
						position: null
					})
				}
				getPositions(e) {
					switch (e || this.props.defaultTooltipPosition) {
						case "bottom":
							return {
								tooltipPosition: ["center", "top"], targetPosition: ["center", "bottom"], caretPosition: "top"
							};
						case "left":
							return {
								tooltipPosition: ["right", "center"], targetPosition: ["left", "center"], caretPosition: "right"
							};
						case "right":
							return {
								tooltipPosition: ["left", "center"], targetPosition: ["right", "center"], caretPosition: "left"
							};
						case "top":
						default:
							return {
								tooltipPosition: ["center", "bottom"], targetPosition: ["center", "top"], caretPosition: "bottom"
							}
					}
				}
				render() {
					const {
						position: e
					} = this.state, {
						targetPosition: t,
						tooltipPosition: n,
						caretPosition: s
					} = this.getPositions(e);
					return o.a.createElement(O, h({}, this.props, {
						caretPosition: s,
						targetPosition: t,
						tooltipPosition: n
					}))
				}
			}
			t.a = C(A)
		},
		"./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/async.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "ContributorRequestButton",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ContributorRequestButton").then(n.bind(null, "./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/index.tsx"
				}
			});
			t.a = r
		},
		"./src/reddit/components/CountAnimation/index.m.less": function(e, t, n) {
			e.exports = {
				countAnimation: "_3z5CnRH3l7hQGI8TQYFyqX",
				digitDeltaWrapper: "WBY6J5DJsZFZXSxBqtq0F",
				digitDelta: "_3LT2yD0gRFklddn3Ra9ElD",
				"sr-only": "D6SuXeSnAAagG8dKAb4O4",
				srOnly: "D6SuXeSnAAagG8dKAb4O4"
			}
		},
		"./src/reddit/components/CountAnimation/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/hooks/usePrevious.ts"),
				i = n("./src/realtime/GQLSubscription/async.tsx"),
				a = n("./src/reddit/hooks/useIntersectionObserver.ts");
			const d = e => {
				return Math.abs(e).toString().split("").map(e => parseInt(e))
			};
			var c = n("./src/reddit/components/CountAnimation/index.m.less"),
				l = n.n(c);
			var u;
			! function(e) {
				e.Vote = "vote", e.Comment = "comment"
			}(u || (u = {}));
			const m = () => 0;
			t.b = e => {
				const {
					countToUpperBound: t,
					featureName: n,
					incrementDelta: c,
					initialDelay: u,
					initialDisplayCount: p,
					isLoadTestOnly: b,
					onDataCB: f,
					postId: h,
					queryKey: g,
					queryVariables: v,
					shouldDisjointAnimation: x,
					subsequentRecurringDelay: E
				} = e, [O, C] = Object(s.useState)(!1), [A, y] = Object(s.useState)(!0), [j, I] = Object(s.useState)([]), [k, _] = Object(s.useState)(d(p).reverse()), S = Object(s.useRef)(!1), w = Object(s.useRef)(null), T = Object(s.useRef)(e => {}), P = Object(s.useRef)();
				T.current = Object(s.useCallback)(e => {
					let n = e || c();
					const s = [...k].reverse().join("");
					let r = parseInt(s) + n;
					r > t && (n = t - parseInt(s), r = t);
					const o = d(r).reverse();
					C(!1), I(k), _(o), y(!1), P.current = setTimeout(() => {
						C(!0)
					}, 0)
				}, [t, c, k]);
				const N = Object(s.useRef)(() => {}),
					D = Object(s.useRef)(),
					M = Object(s.useRef)();
				N.current = Object(s.useCallback)(() => {
					M.current = setTimeout(() => {
						T.current();
						const e = [...j].reverse().join("");
						parseInt(e) < t && N.current()
					}, E())
				}, [t, E, j]);
				const R = Object(s.useRef)(0),
					L = Object(s.useRef)(!1),
					B = Object(s.useCallback)(e => {
						e.forEach(e => {
							const {
								isIntersecting: t,
								intersectionRatio: n
							} = e, s = 1 !== n;
							t ? (L.current = !0, S.current || (S.current = !0, D.current = setTimeout(() => {
								T.current(), N.current()
							}, u())), R.current > 0 && (T.current(R.current), R.current = 0)) : s && (L.current = !1)
						})
					}, []);
				Object(a.a)(w, B);
				const [F, U] = Object(s.useState)(!1), H = Object(s.useCallback)(e => {
					e.forEach(e => {
						const {
							isIntersecting: t,
							intersectionRatio: n
						} = e, s = 1 !== n;
						t ? U(!0) : s && U(!1)
					})
				}, []), G = Object(s.useRef)({
					rootMargin: "2000px 0px 2000px 0px"
				});
				Object(a.a)(w, H, G.current);
				const Q = Object(o.a)(t);
				Object(s.useEffect)(() => {
					if (void 0 !== Q && Q !== t) {
						const e = t - Q;
						L.current ? T.current(e) : R.current += e
					}
					return () => {
						clearTimeout(D.current), clearTimeout(M.current), clearTimeout(P.current)
					}
				}, [t]);
				const q = Object(s.useCallback)(() => y(!0), [y]),
					W = 0 === j.length,
					z = A || W,
					V = Object(s.useRef)(((e, t) => `${t}_${e}_count_anim`)(h, n));
				return r.a.createElement(r.a.Fragment, null, !b && r.a.createElement("div", {
					className: l.a.countAnimation
				}, k.map((e, t) => {
					const n = ((e, t) => {
						let n = Math.abs(e);
						const s = Math.abs(t),
							r = [n];
						if (n === s) return r;
						let o = !0;
						for (; o;) ++n > 9 && (n = 0), r.push(n), n === s && (o = !1);
						return r
					})(j[t] || 0, e);
					return r.a.createElement("span", {
						"aria-hidden": !0,
						className: l.a.digitDeltaWrapper,
						key: t,
						onTransitionEnd: q,
						style: O && j.length > 0 && !A ? {
							transform: `translateY(-${x&&n.length>1?100:100*(n.length-1)}%)`,
							transitionDuration: `${(x?500:750)/1e3}s`
						} : {
							transform: "translateY(0)"
						}
					}, z ? r.a.createElement("span", {
						className: l.a.digitDelta
					}, e) : n.map((e, t) => {
						const s = 0 === t || t === n.length - 1;
						if (!x || x && s) return r.a.createElement("span", {
							className: l.a.digitDelta,
							key: t
						}, e)
					}).filter(e => !!e))
				}), r.a.createElement("span", {
					className: l.a.srOnly,
					role: "screen-reader"
				}, [...k].reverse().join(""))), r.a.createElement("span", {
					ref: w
				}), F && r.a.createElement(i.a, {
					variables: v,
					onData: b ? m : f,
					queryKey: g,
					uniqueKey: V.current
				}))
			}
		},
		"./src/reddit/components/CreateCommunityButton/index.m.less": function(e, t, n) {
			e.exports = {
				StyledTooltip: "FIYolDqalszTnjjNfThfT",
				styledTooltip: "FIYolDqalszTnjjNfThfT"
			}
		},
		"./src/reddit/components/CreateCommunityButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				u = n("./src/reddit/components/TrackingHelper/index.tsx"),
				m = n("./src/reddit/constants/modals.ts"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				b = n("./src/reddit/helpers/trackers/subredditCreation.ts"),
				f = n("./src/reddit/selectors/user.ts"),
				h = n("./src/reddit/components/CreateCommunityButton/index.m.less"),
				g = n.n(h),
				v = n("./src/lib/lessComponent.tsx");
			const x = "create-community-button",
				E = v.a.wrapped(l.c, "StyledTooltip", g.a),
				O = Object(a.c)({
					userDoesNotHaveEnoughExpToCreateCommunity: e => !Object(f.sb)(e),
					userIsSuspended: f.Z
				});
			t.a = Object(i.b)(O, (e, t) => {
				let {
					eventSource: n
				} = t;
				return {
					openCommunityCreation: t => {
						t(Object(b.c)(n)), e(Object(d.h)(m.a.SUBREDDIT_CREATION_MODAL_ID))
					},
					onShowTooltip: () => e(Object(c.f)({
						tooltipId: x
					})),
					onHideTooltip: () => e(Object(c.i)())
				}
			})(Object(u.c)(e => {
				let {
					className: t,
					eventSource: n,
					onShowTooltip: r,
					onHideTooltip: i,
					openCommunityCreation: a,
					sendEvent: d,
					userDoesNotHaveEnoughExpToCreateCommunity: c,
					userIsSuspended: l,
					onClick: u
				} = e;
				return o.a.createElement(p.t, {
					className: t,
					disabled: l || c,
					onClick: e => {
						u && u(e), a(d)
					},
					onMouseEnter: r,
					onMouseLeave: i,
					priority: p.c.Secondary,
					id: x,
					isFullWidth: !0
				}, s.fbt._("Create Community", null, {
					hk: "28v7Qq"
				}), c ? o.a.createElement(E, {
					caretOnTop: !0,
					tooltipId: x,
					text: s.fbt._("To prevent spam, accounts must be at least 30 days old and have enough positive karma to create communities.", null, {
						hk: "2R1OXu"
					})
				}) : l ? o.a.createElement(E, {
					caretOnTop: !0,
					tooltipId: x,
					text: s.fbt._("Accounts banned from the site can not create communities until the ban is lifted.", null, {
						hk: "2xBDEw"
					})
				}) : null)
			}))
		},
		"./src/reddit/components/CreatorStats/Icon.m.less": function(e, t, n) {
			e.exports = {
				icon: "D7SJKwX8OlPkNjhgXO71s"
			}
		},
		"./src/reddit/components/CreatorStats/Icon.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/icons.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/icons/fonts/index.tsx"),
				d = n("./src/reddit/selectors/subreddit.ts"),
				c = n("./src/reddit/components/CreatorStats/helpers.ts"),
				l = n("./src/reddit/components/CreatorStats/Icon.m.less"),
				u = n.n(l);
			t.a = e => {
				let {
					postCreated: t,
					subredditId: n
				} = e;
				const l = Object(i.e)(e => n ? Object(d.X)(e, {
						subredditId: n
					}) : void 0),
					[m, p] = Object(r.useState)(!0);
				return Object(r.useEffect)(() => {
					let e = !0;
					if (void 0 !== t) {
						const n = Object(c.e)(t);
						e = e && !n
					}
					if (void 0 !== l) {
						const t = l.isQuarantined;
						e = e && !t
					}
					p(e)
				}, [t, l]), o.a.createElement(a.a, {
					name: s.a.statistics,
					className: m ? u.a.icon : void 0
				})
			}
		},
		"./src/reddit/components/CreatorStats/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./src/lib/constants/index.ts");
			const r = 16374492e5,
				o = 45 * s.D;
			var i;
			! function(e) {
				e.NotAvailableYet = "NotAvailableYet", e.NotAvailable = "NotAvailable", e.Available = "Available", e.Expired = "Expired", e.Quarantined = "Quarantined"
			}(i || (i = {}));
			const a = e => {
					return e < Date.now() - o
				},
				d = e => e > r,
				c = (e, t, n, s) => {
					if (!n && !d(e.created)) return i.NotAvailable;
					if (n && !d(e.created) || a(e.created)) return i.Expired;
					if (n && s) return i.Quarantined;
					if (!t) return i.NotAvailableYet;
					const {
						shareAllCountTotals: r,
						shareCopyCountTotals: o,
						viewCountTotals: c,
						viewCountTrends: l
					} = t;
					return (null == r ? void 0 : r.availability.isAvailable) && (null == o ? void 0 : o.availability.isAvailable) && (null == c ? void 0 : c.availability.isAvailable) && (null == l ? void 0 : l.availability.isAvailable) && l.data && 0 !== l.data.length ? !(null == c ? void 0 : c.totalCount) || c.totalCount < 10 ? i.NotAvailableYet : i.Available : i.NotAvailableYet
				}
		},
		"./src/reddit/components/CrosspostBox/index.m.less": function(e, t, n) {
			e.exports = {
				mediaContainer: "P8p9Nku0-ZbYCsaCOSE2t",
				Container: "_2ED-O3JtIcOqp8iIL1G5cg",
				container: "_2ED-O3JtIcOqp8iIL1G5cg",
				PostMetaWrapper: "_1u_4ufj_H3WJW2TXEZ6a3n",
				postMetaWrapper: "_1u_4ufj_H3WJW2TXEZ6a3n",
				PostTitle: "_2akYJO5RtMK_ptA408seyG",
				postTitle: "_2akYJO5RtMK_ptA408seyG",
				FlatList: "_3Dd3XvAr-WcOJyMTx4y35x",
				flatList: "_3Dd3XvAr-WcOJyMTx4y35x",
				FlatItem: "_2Pkdj4FrQFtK8COeODi_kK",
				flatItem: "_2Pkdj4FrQFtK8COeODi_kK",
				FlatListDotSpacer: "_3w73P89exX_1mpdhQCURo6",
				flatListDotSpacer: "_3w73P89exX_1mpdhQCURo6",
				LinkContainer: "CsZ0mP84ULF0bBJJa0PFy",
				linkContainer: "CsZ0mP84ULF0bBJJa0PFy",
				Content: "_379A_08LTBsR4c8POTldR_",
				content: "_379A_08LTBsR4c8POTldR_",
				ThumbnailContainer: "_7bo--rwqP4Z7K1s_8dGPX",
				thumbnailContainer: "_7bo--rwqP4Z7K1s_8dGPX"
			}
		},
		"./src/reddit/components/CrosspostBox/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return y
			})), n.d(t, "a", (function() {
				return j
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				l = n("./src/lib/prettyPrintNumber/index.ts"),
				u = n("./src/reddit/components/Media/index.tsx"),
				m = n("./src/reddit/components/PostMeta/index.tsx"),
				p = n("./src/reddit/components/PostTitle/index.tsx"),
				b = n("./src/reddit/components/SourceLink/index.tsx"),
				f = n("./src/reddit/components/Thumbnail/index.tsx"),
				h = n("./src/lib/constants/index.ts"),
				g = n("./src/reddit/contexts/Post/index.tsx"),
				v = n("./src/reddit/selectors/posts.ts"),
				x = n("./src/reddit/selectors/user.ts"),
				E = n("./src/reddit/components/CrosspostBox/index.m.less"),
				O = n.n(E),
				C = n("./src/lib/lessComponent.tsx");

			function A() {
				return (A = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const y = 8,
				j = 1,
				I = C.a.div("Container", O.a),
				k = C.a.div("PostMetaWrapper", O.a),
				_ = C.a.wrapped(p.c, "PostTitle", O.a),
				S = C.a.div("FlatList", O.a),
				w = C.a.div("FlatItem", O.a),
				T = C.a.span("FlatListDotSpacer", O.a),
				P = C.a.wrapped(I, "LinkContainer", O.a),
				N = C.a.div("Content", O.a),
				D = C.a.div("ThumbnailContainer", O.a),
				M = Object(d.c)({
					isCurrentUserProfilePost: v.l,
					isTopicPage: e => !(!e.platform.currentPage || !e.platform.currentPage.meta || e.platform.currentPage.meta.name !== h.Tb.TOPIC),
					shouldOpenPostInNewTab: x.lb
				}),
				R = Object(i.b)(M);
			t.c = Object(g.b)(R(e => {
				const {
					className: t,
					isCurrentUserProfilePost: n,
					isTopicPage: s,
					mediaProps: r,
					post: i,
					subredditOrProfile: a
				} = e;
				if (!i) return null;
				const d = {
						post: i,
						hideGildCta: !0,
						inSubredditOrProfile: !1,
						isCurrentUserProfilePost: n,
						isTopicPage: s,
						shouldShowSubscribeButton: !1,
						subredditOrProfile: a,
						tooltipType: `CrosspostBox--${r.isListing}`
					},
					c = t;
				return i && !i.media ? o.a.createElement(P, {
					className: c
				}, o.a.createElement(N, null, o.a.createElement(k, null, o.a.createElement(m.a, d)), L(i), i.source && o.a.createElement(b.a, {
					post: i
				}), F(e)), H(e)) : o.a.createElement(I, {
					className: c
				}, o.a.createElement(k, null, o.a.createElement(m.a, d)), L(i), B(e), F(e))
			}));
			const L = e => o.a.createElement(_, {
					isCrosspost: !0,
					post: e,
					shouldLinkWrap: !0,
					size: p.b.Small
				}),
				B = e => {
					const {
						mediaProps: t,
						post: n
					} = e, s = {
						...t,
						post: n,
						crosspost: t.post
					};
					return o.a.createElement("div", null, o.a.createElement(u.a, A({}, s, {
						className: O.a.mediaContainer,
						scrollerItemRef: t.scrollerItemRef
					})))
				},
				F = e => {
					const {
						post: t
					} = e, {
						score: n
					} = t;
					return o.a.createElement(S, null, o.a.createElement(w, null, s.fbt._({
						"*": "{point count} points",
						_1: "1 point"
					}, [s.fbt._plural(n, "point count", Object(l.b)(n))], {
						hk: "PNZhd"
					})), o.a.createElement(T, null), o.a.createElement(w, null, U(e)))
				},
				U = e => {
					const {
						post: t,
						shouldOpenPostInNewTab: n
					} = e, {
						numComments: r
					} = t;
					return o.a.createElement(a.a, {
						"data-click-id": "comments",
						to: Object(c.a)(t.permalink, !0),
						target: n ? "_blank" : void 0
					}, s.fbt._({
						"*": "{comment count} comments",
						_1: "1 comment"
					}, [s.fbt._plural(r, "comment count", Object(l.b)(r))], {
						hk: "xPYWL"
					}))
				},
				H = e => o.a.createElement(D, null, o.a.createElement(f.b, {
					post: e.post
				}))
		},
		"./src/reddit/components/CrosspostRecommendationsModal/constants.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = "crosspost_recommendations_modal_id",
				r = 3e3
		},
		"./src/reddit/components/Econ/GiftOrFreeAwardIcon/index.m.less": function(e, t, n) {
			e.exports = {
				img: "_2j4blQAaYrPKIhe5jBJ9c8"
			}
		},
		"./src/reddit/components/Econ/GiftOrFreeAwardIcon/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/Econ/GiftOrFreeAwardIcon/index.m.less"),
				d = n.n(a),
				c = n("./src/reddit/icons/fonts/Gift/index.tsx"),
				l = n("./src/reddit/selectors/gold/awardIcon.ts"),
				u = n("./src/reddit/selectors/gold/purchaseCatalog.ts");
			t.a = e => {
				const t = Object(o.e)(u.b),
					n = Object(o.e)(e => Object(l.a)(e, {
						award: t,
						minSize: 32
					}));
				return t && n ? r.a.createElement("img", {
					alt: t.name,
					className: Object(i.a)(d.a.img, e.className),
					id: e.id,
					src: n
				}) : r.a.createElement(c.a, e)
			}
		},
		"./src/reddit/components/Econ/Marketplace/CollectiblesShowcaseUnit/async.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "CollectiblesShowcaseUnit",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => Promise.all([n.e("vendors~Avatar~CollectiblesShowcaseUnit~CryptoLibEthers~GovernanceTransferPointsModal~MarketplaceCla~cd1771e1"), n.e("vendors~Avatar~ChatPost~CollectiblesShowcaseUnit~MarketplaceClaimModal~MarketplaceInFeedUnit~NftProf~7d152600"), n.e("vendors~Avatar~CollectiblesShowcaseUnit~MarketplaceClaimModal~MarketplaceInFeedUnit~NftProfileUnit~S~bb3e1fe2"), n.e("CollectiblesShowcaseUnit")]).then(n.bind(null, "./src/reddit/components/Econ/Marketplace/CollectiblesShowcaseUnit/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/Econ/Marketplace/CollectiblesShowcaseUnit/index.tsx"
				}
			}, {
				ssr: !1
			});
			t.a = r
		},
		"./src/reddit/components/Econ/Marketplace/NftProfileUnit/async.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "NftProfileUnit",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => Promise.all([n.e("vendors~Avatar~CollectiblesShowcaseUnit~CryptoLibEthers~GovernanceTransferPointsModal~MarketplaceCla~cd1771e1"), n.e("vendors~Avatar~ChatPost~CollectiblesShowcaseUnit~MarketplaceClaimModal~MarketplaceInFeedUnit~NftProf~7d152600"), n.e("vendors~Avatar~CollectiblesShowcaseUnit~MarketplaceClaimModal~MarketplaceInFeedUnit~NftProfileUnit~S~bb3e1fe2"), n.e("NftProfileUnit")]).then(n.bind(null, "./src/reddit/components/Econ/Marketplace/NftProfileUnit/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/Econ/Marketplace/NftProfileUnit/index.tsx"
				}
			}, {
				ssr: !1
			});
			t.a = r
		},
		"./src/reddit/components/Econ/PowerupsFlair/UserAchievementFlair.async.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "UserAchievementFlair",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("UserAchievementFlair").then(n.bind(null, "./src/reddit/components/Econ/PowerupsFlair/UserAchievementFlair.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/Econ/PowerupsFlair/UserAchievementFlair.tsx"
				}
			})
		},
		"./src/reddit/components/EditableImage/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_27zThB3Syksyv8gLdDJqep",
				container: "_27zThB3Syksyv8gLdDJqep",
				HitBox: "_1RlGOQJAoxE66cPOVTH0s",
				hitBox: "_1RlGOQJAoxE66cPOVTH0s",
				Image: "_1te2cn6lvn-YtGSv-hrM7g",
				image: "_1te2cn6lvn-YtGSv-hrM7g",
				ImageContainer: "_1z4A5-p2XgzMTJUEq3GaXu",
				imageContainer: "_1z4A5-p2XgzMTJUEq3GaXu",
				ImageUploader: "_3oOZrOdvGjAOYvzKCu-Kjf",
				imageUploader: "_3oOZrOdvGjAOYvzKCu-Kjf",
				LoadingIcon: "_3syvcMeczod-NOIewWIb8n",
				loadingIcon: "_3syvcMeczod-NOIewWIb8n",
				EditButton: "_3A5WTC_rfbijxxWBmIP4Yx",
				editButton: "_3A5WTC_rfbijxxWBmIP4Yx",
				profileCard: "eHsnwmpOgtfnBAgrWXQKq",
				EditIcon: "_3X4DuB4IpAlTY0XMdSI5q6",
				editIcon: "_3X4DuB4IpAlTY0XMdSI5q6"
			}
		},
		"./src/reddit/components/EditableImage/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/ImageInput/index.tsx"),
				a = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				d = n("./src/reddit/icons/fonts/index.tsx"),
				c = n("./src/reddit/models/ApiRequestState/index.ts"),
				l = n("./src/reddit/components/EditableImage/index.m.less"),
				u = n.n(l);
			const {
				fbt: m
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = e => {
				let {
					altText: t,
					children: n,
					className: s,
					isProfileCard: l,
					isLoading: m,
					imageUrl: p,
					onFileSelected: b
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(u.a.Container, s)
				}, r.a.createElement("label", {
					className: u.a.HitBox
				}, r.a.createElement("span", {
					className: u.a.ImageContainer,
					role: "presentation"
				}, p ? r.a.createElement("img", {
					alt: t,
					className: u.a.Image,
					src: p
				}) : n), r.a.createElement(i.a, {
					className: u.a.ImageUploader,
					multiple: !1,
					onChange: e => {
						const t = Object(c.b)();
						b(e, t)
					},
					isPending: m
				}), !m && r.a.createElement("div", {
					className: Object(o.a)(u.a.EditButton, {
						[u.a.profileCard]: l
					})
				}, r.a.createElement(d.a, {
					name: "add_media",
					className: u.a.EditIcon
				}))), m && r.a.createElement(a.a, {
					className: u.a.LoadingIcon,
					sizePx: 80
				}))
			}
		},
		"./src/reddit/components/Emoji/index.m.less": function(e, t, n) {
			e.exports = {
				EmojiDisplay: "_2Gt13AX94UlLxkluAMsZqP",
				emojiDisplay: "_2Gt13AX94UlLxkluAMsZqP"
			}
		},
		"./src/reddit/components/EventPost/EventMetaHeader/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2A1Ng1fBxjU-qYqbEJn_sm",
				EventMetaWrapper: "_55hUWVhbF34AzbWr7SAMi",
				eventMetaWrapper: "_55hUWVhbF34AzbWr7SAMi",
				eventFollowButton: "_2XCKBYzBTZpjOAFEWv1tSy",
				isCompact: "_2gNxoOe_xKaMk0mmYMQCGs"
			}
		},
		"./src/reddit/components/EventPost/EventMetaHeader/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/eventTools/index.ts"),
				a = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/EventPost/PostEventMeta/index.tsx"),
				c = n("./src/reddit/components/PostFollow/index.tsx"),
				l = n("./src/reddit/helpers/postCollection.ts"),
				u = n("./src/reddit/helpers/postEvent.ts"),
				m = n("./src/reddit/components/EventPost/EventMetaHeader/index.m.less"),
				p = n.n(m);
			const b = a.a.div("EventMetaWrapper", p.a);
			t.a = e => {
				let {
					className: t,
					isCompactMode: n,
					post: s
				} = e;
				if (!Object(u.a)(s)) return null;
				const a = s && s.eventInfo,
					m = Object(l.a)(s),
					f = a && Object(i.c)(a.eventStart, a.eventEnd);
				return r.a.createElement("div", {
					className: Object(o.a)(p.a.container, t, {
						[p.a.isCompact]: !!n
					})
				}, r.a.createElement(b, {
					className: p.a.eventMetaWrapper
				}, r.a.createElement(d.a, {
					post: s
				}), !m && f && r.a.createElement(c.a, {
					className: p.a.eventFollowButton,
					post: s,
					isEventFollow: !0
				})))
			}
		},
		"./src/reddit/components/EventPost/PostEventMeta/index.m.less": function(e, t, n) {
			e.exports = {
				PostEventFutureText: "_3rtq7SfSLd-e5fAEgn373L",
				postEventFutureText: "_3rtq7SfSLd-e5fAEgn373L",
				PostEventPastText: "_1j5EnaNrX7PuyCnmpT-8o0",
				postEventPastText: "_1j5EnaNrX7PuyCnmpT-8o0",
				PostEventNowText: "BGfronFwr_0rXxOJmxp10",
				postEventNowText: "BGfronFwr_0rXxOJmxp10",
				Container: "_3NIcD2Vr2xrSAq08U14kCy",
				container: "_3NIcD2Vr2xrSAq08U14kCy",
				CalendarIcon: "LEz3F0HfvMpdo96occzKU",
				calendarIcon: "LEz3F0HfvMpdo96occzKU",
				LiveIcon: "_3ArSA7Spw15WyF9ld4p6ZJ",
				liveIcon: "_3ArSA7Spw15WyF9ld4p6ZJ",
				LoadingState: "_27_KVVxYHZ7v44CE2vg8bT",
				loadingState: "_27_KVVxYHZ7v44CE2vg8bT"
			}
		},
		"./src/reddit/components/EventPost/PostEventMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/eventTools/index.ts"),
				i = n("./src/reddit/helpers/styles/mixins/loading.ts"),
				a = n("./src/reddit/icons/fonts/Calendar/index.tsx"),
				d = n("./src/reddit/icons/fonts/Live/index.tsx"),
				c = n("./src/reddit/components/HumanDate/index.tsx"),
				l = n("./src/reddit/components/EventPost/PostEventMeta/index.m.less"),
				u = n.n(l),
				m = n("./src/lib/lessComponent.tsx");
			const p = m.a.span("PostEventFutureText", u.a),
				b = m.a.span("PostEventPastText", u.a),
				f = m.a.span("PostEventNowText", u.a),
				h = m.a.span("Container", u.a),
				g = m.a.wrapped(a.a, "CalendarIcon", u.a),
				v = m.a.wrapped(d.a, "LiveIcon", u.a),
				x = m.a.div("LoadingState", u.a);
			class E extends s.Component {
				constructor(e) {
					super(e), this.state = {
						mounted: !1
					}
				}
				componentDidMount() {
					this.setState({
						mounted: !0
					})
				}
				render() {
					const {
						className: e,
						post: t
					} = this.props, {
						eventInfo: n
					} = t;
					if (!n) return null;
					const {
						eventEnd: s,
						eventIsLive: a,
						eventStart: d
					} = n, l = Object(o.e)(d, s);
					let u, m;
					if (this.state.mounted || l === o.a.Live) u = r.a.createElement(c.c, {
						startTime: d,
						endTime: s,
						isLive: a
					});
					else {
						const e = Object(i.a)({
							isLoading: !0
						});
						u = r.a.createElement(x, {
							className: e
						})
					}
					if (a) m = r.a.createElement(f, null, r.a.createElement(v, null), u);
					else if (l === o.a.Future) m = r.a.createElement(p, null, r.a.createElement(g, null), u);
					else {
						if (l !== o.a.Past) return null;
						m = r.a.createElement(b, null, r.a.createElement(g, null), u)
					}
					return r.a.createElement(h, {
						className: e
					}, m)
				}
			}
			t.a = E
		},
		"./src/reddit/components/ExpandoButton/index.m.less": function(e, t, n) {
			e.exports = {
				outer: "RvLtAcdRtbOQbhFB7MD_T",
				icon: "saNpcHve-34zjaa0cbIxW",
				hideOnHover: "_25HJpaEPiVNq6Ss3Ad7dp9",
				showOnHover: "_2S05CzViTnl3I2ekCABqFo"
			}
		},
		"./src/reddit/components/ExpandoButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./src/reddit/controls/OutboundLink/index.tsx"),
				m = n("./src/reddit/helpers/path/index.ts"),
				p = n("./src/reddit/helpers/postHasSelfText/index.ts"),
				b = n("./src/reddit/icons/fonts/index.tsx"),
				f = n("./src/reddit/models/Media/index.ts"),
				h = n("./src/reddit/models/Post/index.ts"),
				g = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				v = n("./src/telemetry/models/Outbound.ts"),
				x = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				E = n("./src/reddit/components/ExpandoButton/index.m.less"),
				O = n.n(E);
			const C = Object(i.b)(null, (e, t) => ({
					toggle: () => e(Object(l.w)({
						postId: t.post.id
					})),
					showModalOnPostLinkClick: t => e(Object(l.Z)(Object(m.b)(t.permalink), t.id))
				})),
				A = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
						n = arguments.length > 2 ? arguments[2] : void 0;
					const s = Object(d.a)(O.a.icon, O.a.hideOnHover);
					if (t) return o.a.createElement(b.a, {
						name: "crosspost",
						className: s
					});
					if (n.pollData) return o.a.createElement(b.a, {
						name: "poll_post",
						className: s
					});
					if (n.audioRoom) return o.a.createElement(b.a, {
						name: "audio",
						className: s
					});
					switch (e) {
						case f.o.GIFVIDEO:
							return o.a.createElement(b.a, {
								name: "gif_post",
								className: s
							});
						case f.o.IMAGE:
							return o.a.createElement(b.a, {
								name: "image_post",
								className: s
							});
						case f.o.TEXT:
						case f.o.RTJSON:
							return o.a.createElement(b.a, {
								name: "text_post",
								className: s
							});
						case f.o.VIDEO:
							return o.a.createElement(b.a, {
								name: "video_post",
								className: s
							});
						case f.o.GALLERY:
							return o.a.createElement(b.a, {
								name: "media_gallery",
								className: s
							});
						case f.o.EMBED:
						default:
							return o.a.createElement(b.a, {
								name: "embed",
								className: s
							})
					}
				};
			t.a = C(e => {
				const {
					className: t,
					crosspost: n,
					enableCrosspostIcon: r,
					isCommentsPage: l,
					isExpanded: m,
					post: f,
					toggle: E,
					useMediaIcons: C
				} = e, y = n || f, j = Object(i.e)(g.b), I = Object(i.e)(g.c), k = t => {
					(j || I) && (t.preventDefault(), e.showModalOnPostLinkClick(y))
				}, _ = y.media, S = Object(h.q)(f), w = r && !!n;
				return _ && !S && !(("rtjson" === _.type || "text" === _.type || "liveaudio" === _.type) && !Object(p.a)(y)) || !!f.pollData ? o.a.createElement("button", {
					"aria-expanded": !!m,
					"aria-haspopup": !0,
					"aria-label": s.fbt._("Expand content", null, {
						hk: "1e35IG"
					}),
					className: Object(d.a)(t, O.a.outer),
					"data-click-id": m ? "expando_close" : "expando_open",
					"data-adclicklocation": x.a.MEDIA,
					onClick: E
				}, m ? o.a.createElement(b.a, {
					name: "collapse",
					className: O.a.icon
				}) : C ? o.a.createElement(o.a.Fragment, null, A(y.media && y.media.type, w, f), o.a.createElement(b.a, {
					name: "expand",
					className: Object(d.a)(O.a.icon, O.a.showOnHover)
				})) : o.a.createElement(b.a, {
					name: "expand",
					className: O.a.icon
				})) : y.source && y.source.url ? o.a.createElement(u.b, {
					"aria-label": s.fbt._("Open external content", null, {
						hk: "2FfpSI"
					}),
					className: Object(d.a)(t, O.a.outer),
					"data-click-id": "expando_open",
					href: y.source.url,
					isSponsored: f.isSponsored,
					postId: f.id,
					source: f.source,
					sourceElement: l ? v.SourceElement.PostImage : v.SourceElement.ListingPostImage,
					target: "_blank"
				}, o.a.createElement(b.a, {
					name: "external_link",
					className: Object(d.a)(O.a.icon, O.a.outboundLinkIcon)
				})) : o.a.createElement(a.a, {
					"aria-label": s.fbt._("View content", null, {
						hk: "24KLWF"
					}),
					className: Object(d.a)(t, O.a.outer),
					"data-click-id": "expando_open",
					to: Object(c.a)(y.permalink),
					rel: "nofollow",
					onClick: k
				}, o.a.createElement(b.a, {
					name: "text_post",
					className: O.a.icon
				}))
			})
		},
		"./src/reddit/components/Flair/index.m.less": function(e, t, n) {
			e.exports = {
				FlairEmojiDisplay: "_1QwShihKKlyRXyQSlqYaWW",
				flairEmojiDisplay: "_1QwShihKKlyRXyQSlqYaWW",
				FlairWrapper: "_2X6EB3ZhEeXCh1eIVA64XM",
				flairWrapper: "_2X6EB3ZhEeXCh1eIVA64XM",
				TextFlair: "_1jNPl3YUk6zbpLWdjaJT1r",
				textFlair: "_1jNPl3YUk6zbpLWdjaJT1r",
				transparentBackgroundColor: "_39BEcWjOlYi1QGcJil6-yl",
				RichTextFlair: "_2hSecp_zkPm_s5ddV2htoj",
				richTextFlair: "_2hSecp_zkPm_s5ddV2htoj",
				MetaFlair: "_1wzhGvvafQFOWAyA157okr",
				metaFlair: "_1wzhGvvafQFOWAyA157okr",
				CloseButton: "_3BPVpMSn5b1vb1yTQuqCRH",
				closeButton: "_3BPVpMSn5b1vb1yTQuqCRH",
				CloseIcon: "_2cvySYWkqJfynvXFOpNc5L",
				closeIcon: "_2cvySYWkqJfynvXFOpNc5L",
				small: "aJrgrewN9C8x1Fusdx4hh",
				large: "_1wj6zoMi6hRP5YhJ8nXWXE",
				flairVariant: "_2VqfzH0dZ9dIl3XWNxs42y"
			}
		},
		"./src/reddit/components/Flair/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return U
			})), n.d(t, "b", (function() {
				return H
			})), n.d(t, "a", (function() {
				return q
			})), n.d(t, "c", (function() {
				return W
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				i = n("./node_modules/polished/dist/polished.es.js"),
				a = n("./node_modules/react/index.js"),
				d = n.n(a),
				c = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				l = n("./src/lib/addQueryParams/index.ts"),
				u = n("./src/lib/classNames/index.ts"),
				m = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				p = n("./src/lib/lessComponent.tsx"),
				b = n("./src/reddit/components/Emoji/index.m.less"),
				f = n.n(b);

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const g = p.a.wrapped(e => {
				let {
					backgroundImage: t,
					style: n,
					...s
				} = e;
				return d.a.createElement("div", h({
					style: {
						...n || {},
						backgroundImage: `url('${t}')`
					}
				}, s))
			}, "EmojiDisplay", f.a);
			var v = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				x = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				E = n("./src/reddit/constants/colors.ts"),
				O = n("./src/reddit/constants/parameters.ts"),
				C = n("./src/reddit/controls/InternalLink/index.tsx"),
				A = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				y = n("./src/reddit/icons/svgs/Close/index.tsx"),
				j = n("./src/reddit/models/Flair/index.ts"),
				I = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				k = n("./src/reddit/components/Flair/index.m.less"),
				_ = n.n(k);

			function S() {
				return (S = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const w = Object(x.a)(v.b),
				T = p.a.div("FlairWrapper", _.a),
				P = p.a.wrapped(c.a, "CloseButton", _.a),
				N = p.a.wrapped(Object(m.a)(e => {
					let {
						forceSmallEmojis: t,
						theme: n,
						...s
					} = e;
					const r = n;
					return d.a.createElement(g, S({
						style: {
							...D(!!t, r) || {}
						}
					}, s))
				}), "FlairEmojiDisplay", _.a),
				D = (e, t) => {
					if (!e && !!t.subredditContext.emojiHeight && !!t.subredditContext.emojiWidth) return {
						height: `${t.subredditContext.emojiHeight}px`,
						width: `${t.subredditContext.emojiWidth}px`
					}
				},
				M = (e, t) => {
					const n = t ? `/r/${t}/search` : "/search",
						s = `${t?"flair_name":"flair"}:"${e}"`;
					return Object(l.a)(n, {
						[O.w]: s,
						[O.x]: t ? "1" : ""
					})
				},
				R = e => e.isFlairFilter ? d.a.createElement(C.default, {
					onMouseDown: e.onMouseDown,
					to: e.to || ""
				}, e.flair) : e.onClick ? d.a.createElement(C.default, {
					onClick: () => e.onClick(e.searchableTerm),
					to: M(e.searchableTerm, e.subredditName)
				}, e.flair) : e.flair;
			class L extends d.a.Component {
				constructor() {
					super(...arguments), this.tooltipTargetElement = null, this.state = {
						isTooltipOpen: !1
					}, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							isTooltipOpen: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							isTooltipOpen: !1
						})
					}
				}
				render() {
					const e = d.a.createElement("span", {
						className: Object(u.a)(this.props.className, {
							[_.a.transparentBackgroundColor]: "transparent" === this.props.backgroundColor
						}),
						onMouseEnter: this.props.tooltip ? this.onShowTooltip : void 0,
						onMouseLeave: this.props.tooltip ? this.onHideTooltip : void 0,
						ref: this.setTooltipTargetRef,
						style: {
							backgroundColor: this.props.backgroundColor || Object(I.a)(this.props).flair,
							color: `${U(this.props)}`
						}
					}, this.props.text, this.props.isSelected && d.a.createElement(P, {
						to: "./",
						onClick: this.props.onCloseClick
					}, d.a.createElement(y.a, {
						className: _.a.CloseIcon,
						style: {
							fill: this.props.backgroundColor || Object(I.a)(this.props).flair
						}
					})), !!this.props.tooltip && d.a.createElement(w, {
						text: this.props.tooltip,
						isOpen: this.state.isTooltipOpen,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: ["center", "top"],
						tooltipPosition: ["center", "bottom"]
					}));
					return d.a.createElement(R, {
						flair: e,
						isFlairFilter: this.props.isFlairFilter,
						onClick: this.props.onClick,
						onMouseDown: this.props.onMouseDown,
						searchableTerm: this.props.text,
						subredditName: this.props.subredditName,
						to: this.props.to
					})
				}
			}
			const B = Object(m.a)(L),
				F = Object(m.a)(e => {
					let t = "",
						n = !1;
					const s = e.richtext.map((s, r) => {
						if (s.e === j.c.Emoji) {
							const o = s;
							return t += o.a, n = !0, d.a.createElement(N, {
								forceSmallEmojis: e.forceSmallEmojis,
								backgroundImage: o.u,
								key: r,
								title: o.a
							})
						} {
							const e = s;
							return t += e.t, d.a.createElement("span", {
								key: r
							}, e.t)
						}
					});
					let r;
					n && !e.forceSmallEmojis && e.theme && e.theme.subredditContext.emojiWidth && e.theme.subredditContext.emojiHeight && e.theme.subredditContext.emojiHeight > 16 && (r = {
						marginTop: `-${e.theme.subredditContext.emojiHeight-16}px`
					});
					const o = d.a.createElement(T, {
						className: Object(u.a)(e.className, {
							[_.a.transparentBackgroundColor]: "transparent" === e.backgroundColor
						}),
						style: {
							...r,
							backgroundColor: e.backgroundColor || Object(I.a)(e).flair,
							color: `${U(e)}`
						}
					}, s, e.isSelected && d.a.createElement(P, {
						to: "./",
						onClick: e.onCloseClick
					}, d.a.createElement(y.a, {
						className: _.a.CloseIcon,
						style: {
							fill: e.backgroundColor || Object(I.a)(e).flair
						}
					})));
					return d.a.createElement(R, {
						flair: o,
						isFlairFilter: e.isFlairFilter,
						onClick: e.onClick ? () => {
							e.onClick(t)
						} : void 0,
						onMouseDown: e.onMouseDown,
						searchableTerm: t,
						subredditName: e.subredditName,
						to: e.to
					})
				}),
				U = e => !e.textColor || e.textColor && !e.backgroundColor ? Object(I.a)(e).postFlairText : "transparent" === e.backgroundColor ? Object(A.a)(Object(I.a)(e).post, E.a.black, E.a.white) : e.textColor === j.e.Dark ? E.a.black : E.a.white,
				H = p.a.wrapped(B, "TextFlair", _.a),
				G = p.a.wrapped(F, "RichTextFlair", _.a),
				Q = e => {
					switch (e.type) {
						case "spoiler":
							return "#A4A7A8";
						case "nsfw":
							return "#FF585B";
						default:
							return Object(i.i)(.1, Object(I.a)(o()(e, "theme", "redditStyle", "data-redditstyle")).button)
					}
				},
				q = p.a.wrapped(e => {
					const t = Q(e),
						n = d.a.createElement("span", {
							className: e.className,
							style: {
								border: `1px solid ${t}`,
								color: t
							}
						}, e.text);
					return d.a.createElement(R, {
						flair: n,
						searchableTerm: e.text
					})
				}, "MetaFlair", _.a);

			function W(e) {
				const {
					className: t,
					disabled: n = !1,
					flair: r,
					isFlairFilter: o,
					isSelected: i,
					onClick: a,
					onCloseClick: c,
					onMouseDown: l,
					subredditName: m,
					usesCommunityStyles: p,
					forceSmallEmojis: b,
					to: f
				} = e, h = Object(u.a)({
					[_.a.flairVariant]: o,
					[_.a.small]: o && !e.large,
					[_.a.large]: o && e.large
				}, t);
				switch (r.type) {
					case j.f.Richtext:
						return n || !r.richtext ? null : d.a.createElement(G, {
							backgroundColor: r.backgroundColor,
							className: h,
							forceSmallEmojis: b,
							isFlairFilter: o,
							isSelected: i,
							onClick: a,
							onCloseClick: c,
							onMouseDown: l,
							redditStyle: !p,
							richtext: r.richtext,
							subredditName: m,
							textColor: r.textColor,
							to: f
						});
					case j.f.Text:
						return n || !r.text ? null : d.a.createElement(H, {
							backgroundColor: r.backgroundColor,
							className: h,
							isFlairFilter: o,
							isSelected: i,
							onClick: a,
							onCloseClick: c,
							onMouseDown: l,
							subredditName: m,
							text: r.text,
							textColor: r.textColor,
							redditStyle: !p,
							to: f
						});
					case j.f.Meta:
						return d.a.createElement(H, {
							backgroundColor: r.backgroundColor,
							className: t,
							isFlairFilter: o,
							subredditName: m,
							text: r.text,
							textColor: r.textColor,
							redditStyle: !p,
							to: f
						});
					case j.f.Nsfw:
					case j.f.Spoiler:
						return d.a.createElement(q, {
							className: t,
							text: r.text,
							type: r.type
						});
					case j.f.Quarantined:
						return null;
					case j.f.Oc:
						return d.a.createElement(H, {
							backgroundColor: E.a.alienblue,
							text: r.text,
							textColor: j.e.Light,
							tooltip: s.fbt._("This post is marked as Original Content [OC]", null, {
								hk: "h7je6"
							})
						});
					default:
						return r.text ? d.a.createElement(H, {
							backgroundColor: r.backgroundColor,
							className: h,
							isFlairFilter: o,
							onClick: a,
							onCloseClick: c,
							onMouseDown: l,
							subredditName: m,
							text: r.text,
							redditStyle: !p,
							to: f
						}) : null
				}
			}
		},
		"./src/reddit/components/FlairList/index.m.less": function(e, t, n) {
			e.exports = {
				flairVariantInList: "_1Dl-kvSxyJMWO9nuoTof8N"
			}
		},
		"./src/reddit/components/FlairList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/noop.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/reddit/components/Flair/index.tsx"),
				l = n("./src/reddit/helpers/flair.ts"),
				u = n("./src/reddit/models/Flair/index.ts"),
				m = n("./src/reddit/selectors/user.ts"),
				p = n("./src/reddit/components/FlairList/index.m.less"),
				b = n.n(p);
			const f = Object(d.c)({
					labelNSFW: m.cb
				}),
				h = Object(a.b)(f),
				g = e => {
					if (e.type === u.f.Richtext && e.richtext) {
						const t = e.richtext.map(e => e.e === u.c.Emoji ? e.u : e.t).join("-");
						return `${e.type}--${t}`
					}
					return `${e.type}--${e.text}`
				};
			t.a = h(e => {
				let {
					className: t,
					isFlairFilter: n,
					onClick: s,
					onMouseDown: o,
					disabled: a = !1,
					flair: d,
					labelNSFW: m,
					subredditName: p
				} = e;
				const f = !!d.find(e => e.type === u.f.Richtext),
					h = d.map(e => {
						if (e.type === u.f.Text && f) return null;
						if (!m && e.type === u.f.Nsfw) return null;
						const t = Object(l.j)(e),
							d = `/r/${p}/`,
							h = o ? () => o(e) : r.a,
							v = n && (e.type === u.f.Richtext || e.type === u.f.Text);
						return i.a.createElement(c.c, {
							className: v ? b.a.flairVariantInList : void 0,
							isFlairFilter: n,
							key: g(e),
							onClick: s,
							onMouseDown: h,
							disabled: a,
							flair: e,
							forceSmallEmojis: !0,
							subredditName: p,
							to: Object(l.e)(d, t)
						})
					});
				return i.a.createElement("div", {
					className: t
				}, h)
			})
		},
		"./src/reddit/components/FlairPickerTitle/index.m.less": function(e, t, n) {
			e.exports = {
				modalHeader: "_26bOTAKvGixX5tMC3vGfTv"
			}
		},
		"./src/reddit/components/FlairPickerTitle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/noop.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				d = n("./src/reddit/controls/TextButton/index.tsx"),
				c = n("./src/reddit/components/FlairPickerTitle/index.m.less"),
				l = n.n(c);
			t.a = e => i.a.createElement(a.i, {
				className: l.a.modalHeader
			}, i.a.createElement(a.q, null, e.title), i.a.createElement(d.a, {
				onClick: e.onClosePressed || r.a
			}, i.a.createElement(a.b, null)))
		},
		"./src/reddit/components/FlairPickerWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_3nRJIwLuth2pKYrXnr2jPN",
				wrapper: "_3nRJIwLuth2pKYrXnr2jPN"
			}
		},
		"./src/reddit/components/FlairPickerWrapper/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/components/FlairPickerWrapper/index.m.less"),
				o = n.n(r);
			const i = s.a.div("Wrapper", o.a);
			t.a = i
		},
		"./src/reddit/components/FlairPreview/index.m.less": function(e, t, n) {
			e.exports = {
				Placeholder: "_30zvTaAcvBFmwfelq6Bvwg",
				placeholder: "_30zvTaAcvBFmwfelq6Bvwg",
				SelectedFlair: "BzonfS85jX2JTiu_i0Jyd",
				selectedFlair: "BzonfS85jX2JTiu_i0Jyd",
				FlairComponent: "vynkb69RQyUY-PA6bCaW0",
				flairComponent: "vynkb69RQyUY-PA6bCaW0"
			}
		},
		"./src/reddit/components/FlairPreview/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/Flair/index.tsx"),
				d = n("./src/reddit/components/FlairPreview/index.m.less"),
				c = n.n(d);
			const l = i.a.span("Placeholder", c.a),
				u = i.a.div("SelectedFlair", c.a),
				m = i.a.wrapped(a.c, "FlairComponent", c.a);
			t.a = e => e.flair ? o.a.createElement(u, null, o.a.createElement(l, null, s.fbt._("{placeholder}", [s.fbt._param("placeholder", e.placeholderText)], {
				hk: "4G6VRy"
			})), o.a.createElement(m, {
				flair: e.flair,
				forceSmallEmojis: !0
			})) : o.a.createElement(u, null, s.fbt._("No flair selected", null, {
				hk: "1XPXbv"
			}))
		},
		"./src/reddit/components/FlairSearch/FlairEdit/helper.m.less": function(e, t, n) {
			e.exports = {
				FlairEditStub: "Z7x0t_45z9vZGN2zw6US6",
				flairEditStub: "Z7x0t_45z9vZGN2zw6US6",
				isCompact: "_3YjPWOd9tK9O_DN50RI_FN"
			}
		},
		"./src/reddit/components/FlairSearch/FlairEdit/helper.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/lodash/once.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/higherOrderComponents/makeAsync.tsx"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/lib/loadWithRetries/index.ts"),
				u = n("./src/reddit/components/FlairSearch/FlairEdit/helper.m.less"),
				m = n.n(u);
			const p = c.a.wrapped(e => i.a.createElement("div", {
					className: Object(d.a)(e.className, {
						[m.a.isCompact]: e.isCompact
					})
				}), "FlairEditStub", m.a),
				b = r()((function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : p;
					return Object(a.a)({
						getComponent: () => Object(l.a)(() => Promise.all([n.e("vendors~ChatMessageInput~CommentRichUnit~FlairEdit~MembershipPaywallPage~PostCreation~PostRichUnit~R~9deab1a0"), n.e("FlairEdit")]).then(n.bind(null, "./src/reddit/components/FlairSearch/FlairEdit/index.tsx")).then(e => e.default)),
						ErrorComponent: e,
						LoadingComponent: e
					})
				}))
		},
		"./src/reddit/components/FlairSearch/FlairTemplateList/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1bdAduczElF9-gLoCvHz-p",
				flairComponent: "_2leID3tMN8hpvVd4XhEqTl",
				radioOption: "FJIE5E2gciCA8q3Jzvcyg",
				pencil: "_3H_wwe03-Fkrm6oWGakXI8",
				searchBoxWrapper: "_18cuM8Uu7RcIFu1bCT0r4t",
				searchIcon: "_2bECVWL_WJ9RGBx7-RnzfO",
				searchInput: "_1nQbRaoAvb6Uy0oI-OfDtZ"
			}
		},
		"./src/reddit/components/FlairSearch/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2AKP6aCod0Z6TuXXfc1ZqL",
				buttonsRow: "_3w7b_fPwMuVD17J7epjTXi",
				clearButton: "_3WykjMvdVO5xibqd5xlfTC",
				flairEditSection: "SVd7IxchgiWetdYbftTHx",
				editLabel: "KTa3kg9lzGPUeLuhAHMT_",
				restrictionHintText: "_1fV9kJfKnED9qQ2AF8f3iT"
			}
		},
		"./src/reddit/components/FlairSearch/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/memoizeByReference/index.ts"),
				l = n("./src/reddit/featureFlags/index.ts"),
				u = n("./src/reddit/helpers/flair.ts"),
				m = n("./src/reddit/helpers/trackers/userFlair.ts"),
				p = n("./src/reddit/hooks/useTracking.ts"),
				b = n("./src/reddit/selectors/moderatorPermissions.ts"),
				f = n("./src/reddit/components/FlairSearch/FlairEdit/helper.tsx"),
				h = n("./src/reddit/components/Flair/index.tsx"),
				g = n("./src/reddit/components/TrackingHelper/index.tsx"),
				v = n("./src/reddit/controls/RadioInput/index.tsx"),
				x = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				E = n("./src/reddit/helpers/trackers/postComposer.ts"),
				O = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				C = n("./src/reddit/icons/svgs/Search/index.tsx"),
				A = n("./src/reddit/components/FlairSearch/FlairTemplateList/index.m.less"),
				y = n.n(A);
			class j extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						searchQuery: ""
					}, this.onSearchChange = e => {
						this.setState({
							searchQuery: e.target.value
						})
					}, this.onSearchClick = () => {
						this.props.sendEvent(Object(E.n)())
					}
				}
				render() {
					const {
						templates: e,
						templateIds: t,
						selectedTemplateId: n
					} = this.props, {
						searchQuery: r
					} = this.state, i = t.map(t => e[t]).filter(e => e.text.toLowerCase().includes(r)), a = !!n && i.some(e => e.id === n);
					return o.a.createElement("div", {
						className: y.a.container
					}, o.a.createElement("div", {
						className: y.a.searchBoxWrapper
					}, o.a.createElement("input", {
						className: y.a.searchInput,
						onChange: this.onSearchChange,
						onClick: this.onSearchClick,
						type: "text",
						placeholder: s.fbt._("Search for flair", null, {
							hk: "jQdqA"
						}),
						value: r
					}), o.a.createElement(C.a, {
						className: y.a.searchIcon
					})), o.a.createElement(v.a, {
						name: "flair_picker",
						onChange: this.props.onChange,
						value: n
					}, i.map((e, t) => {
						const s = Object(u.c)(e),
							r = n === e.id || !a && 0 === t;
						return o.a.createElement(x.a, {
							className: y.a.radioOption,
							key: e.id,
							showButton: !0,
							tabIndex: r ? 0 : -1,
							value: e.id
						}, o.a.createElement(h.c, {
							className: y.a.flairComponent,
							flair: s,
							forceSmallEmojis: !0
						}), e.textEditable && o.a.createElement(O.a, {
							className: y.a.pencil
						}))
					})))
				}
			}
			var I = Object(g.c)(j),
				k = n("./src/reddit/components/FlairSearch/index.m.less"),
				_ = n.n(k);
			const S = Object(c.a)(e => e && Object(u.c)(e)),
				w = Object(a.c)({
					areFlairRestrictionsEnabled: l.d.flairRestrictions,
					isModerator: b.g
				}),
				T = Object(i.b)(w);
			t.a = T(e => {
				const {
					flairTemplateType: t,
					flair: n,
					className: r,
					onChange: i,
					subredditId: a,
					templates: c,
					templateIds: l,
					areFlairRestrictionsEnabled: b,
					isModerator: h
				} = e, g = Object(p.a)(), v = c && n && n.templateId && c[n.templateId] || void 0, x = Object(f.a)(), E = n || S(v);
				return o.a.createElement("div", {
					className: Object(d.a)(r, _.a.container)
				}, c && l && o.a.createElement(I, {
					flairTemplateType: t,
					onChange: e => {
						if (c) {
							const t = c[e],
								n = Object(u.c)(t);
							g(Object(m.b)({
								userFlair: t
							})), i(n)
						}
					},
					selectedTemplateId: v ? v.id : "",
					templateIds: l,
					templates: c
				}), E && v && (h || v.textEditable) && o.a.createElement("div", {
					className: _.a.flairEditSection
				}, o.a.createElement("div", {
					className: _.a.editLabel
				}, s.fbt._("Edit flair", null, {
					hk: "1APWWu"
				})), b && o.a.createElement("div", {
					className: _.a.restrictionHintText
				}, Object(u.k)(v)), o.a.createElement(x, {
					autofocus: !0,
					emojiPickerId: "FlairSearch-EmojiPicker-DropdownId",
					flair: E,
					flairTemplate: v,
					flairTemplateType: t,
					isFlairModOnly: v.modOnly,
					onChange: e => {
						const t = c && e.templateId ? c[e.templateId] : void 0;
						let n = e;
						t && (n = Object(u.d)({
							flair: e,
							template: t,
							ignoreTextAllowance: !0
						})), i(n)
					},
					subredditId: a
				})))
			})
		},
		"./src/reddit/components/FlairWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				flairList: "lrzZ8b0L6AzLkQj5Ww7H1",
				flairWrapper: "_2fiIRtMpITeCAzXc4cANKp",
				flairNoWrap: "_2xu1HuBz1Yx6SP10AGVx_I"
			}
		},
		"./src/reddit/components/FlairWrapper/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return O
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/components/FlairList/index.tsx"),
				l = n("./src/reddit/components/PostTitle/getLeftAndRightFlair.ts"),
				u = n("./src/reddit/components/SearchResultsContent/searchResultsPageTreatment/searchIgnoreClickContext.ts"),
				m = n("./src/reddit/contexts/PageLayer/index.tsx"),
				p = n("./src/reddit/helpers/correlationIdTracker.ts"),
				b = n("./src/reddit/helpers/trackers/postFlair.ts"),
				f = n("./src/reddit/models/Flair/index.ts"),
				h = n("./src/reddit/selectors/postFlair.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				v = n("./src/reddit/components/FlairWrapper/index.m.less"),
				x = n.n(v);
			const E = Object(i.b)(() => Object(a.c)({
					flairPosition: (e, t) => {
						let {
							pageLayer: n
						} = t;
						return Object(m.r)(e, {
							pageLayer: n
						})
					},
					isPostFlairEnabled: (e, t) => Object(h.c)(e, {
						subredditId: t.post.belongsTo.id
					}),
					subredditName: (e, t) => {
						let {
							post: n
						} = t;
						return Object(g.X)(e, {
							subredditId: n.belongsTo.id
						}).name
					}
				})),
				O = e => {
					const t = [];
					return e.isOriginalContent && t.push({
						text: s.fbt._("OC", null, {
							hk: "1i721p"
						}),
						type: f.f.Oc
					}), e.isMeta && t.push({
						text: s.fbt._("Poll", null, {
							hk: "1scdU1"
						}),
						type: f.f.Meta
					}), t.push(...e.flair), t
				};
			t.a = E(e => {
				let {
					className: t,
					disableFlair: n,
					flairPosition: s,
					isFlairFilter: r,
					isPostFlairEnabled: i,
					nowrap: a,
					post: m,
					sendEvent: h,
					subredditName: g,
					titleFlair: v
				} = e;
				const E = Object(u.a)(),
					C = s === f.b.Left,
					A = v || O(m),
					{
						leftFlair: y,
						rightFlair: j
					} = Object(l.a)({
						flair: A,
						isFlairPositionedLeft: C
					}),
					I = a ? x.a.flairNoWrap : y.length > 0 || j.length > 0 ? x.a.flairWrapper : null,
					k = e => {
						const t = {
							id: m.belongsTo.id,
							eventType: m.belongsTo.type,
							originElement: "post_flair",
							postFlairName: e
						};
						Object(p.d)(p.a.SearchResults), h && h(Object(b.a)(m.id, t))
					},
					_ = e => {
						Object(p.d)(p.a.SearchResults), h && h(Object(b.e)(e, m.id))
					},
					S = !(n || !A || !A.length);
				return S ? o.a.createElement("div", {
					className: Object(d.a)(I, t),
					"data-ignore-click": E
				}, S && y && o.a.createElement(c.a, {
					className: x.a.flairList,
					isFlairFilter: r,
					key: "leftFlair",
					onClick: k,
					onMouseDown: _,
					flair: y,
					disabled: !i,
					subredditName: g
				}), S && o.a.createElement(c.a, {
					className: x.a.flairList,
					isFlairFilter: r,
					key: "rightFlair",
					onClick: k,
					onMouseDown: _,
					flair: j,
					disabled: !i,
					subredditName: g
				})) : null
			})
		},
		"./src/reddit/components/Flatlist/ResponsiveRow.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts"),
				a = n("./src/reddit/controls/Dropdown/Row.tsx"),
				d = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				c = n("./src/reddit/components/Flatlist/index.m.less"),
				l = n.n(c);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				let {
					flatlistItem: t,
					isLoggedIn: n,
					isUserOp: s,
					noBreakpoints: c,
					...m
				} = e;
				return r.a.createElement("div", {
					"data-ignore-click": !!m.searchIgnoreClick,
					className: l.a.rowContainer,
					"data-adclicklocation": d.b.FLATLIST_GENERAL
				}, r.a.createElement(a.a, u({}, m, {
					className: c ? l.a.responsiveRow : Object(o.a)(l.a.responsiveRow, Object(i.b)({
						flatlistItem: t,
						isLoggedIn: n,
						isUserOp: s
					}))
				})))
			}
		},
		"./src/reddit/components/Flatlist/breakpoints.m.less": function(e, t, n) {
			e.exports = {
				HideIfVWSmaller: "_3yh2bniLq7bYr4BaiXowdO",
				hideIfVwSmaller: "_3yh2bniLq7bYr4BaiXowdO",
				FirstGroup: "_2sAFaB0tx4Hd5KxVkdUcAx",
				firstGroup: "_2sAFaB0tx4Hd5KxVkdUcAx",
				LoggedOutVariant: "_3sUJGnemgtNczijwoT8PGg",
				loggedOutVariant: "_3sUJGnemgtNczijwoT8PGg",
				LoggedInVariant: "_28vEaVlLWeas1CDiLuTCap",
				loggedInVariant: "_28vEaVlLWeas1CDiLuTCap",
				OpVariant: "Z-VR19FVnE3nOS0_BU4Wy",
				opVariant: "Z-VR19FVnE3nOS0_BU4Wy",
				EditingGroup: "_1EKOhBHXAW9y8Bgn93c9f3",
				editingGroup: "_1EKOhBHXAW9y8Bgn93c9f3",
				SecondGroup: "_1pShbCnOaF7EGWTq6IvZux",
				secondGroup: "_1pShbCnOaF7EGWTq6IvZux",
				AwardingGroup: "_1EWxiIupuIjiExPQeK4Kud",
				awardingGroup: "_1EWxiIupuIjiExPQeK4Kud",
				HideIfVWLarger: "_1k3nXWGGz2NdPr8dg49Tbs",
				hideIfVwLarger: "_1k3nXWGGz2NdPr8dg49Tbs"
			}
		},
		"./src/reddit/components/Flatlist/constants.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.EditPost = "EDITPOST", e.EditFlair = "EDITFLAIR", e.Save = "SAVE", e.Gild = "GILD", e.Hide = "HIDE", e.PostOverflowMenu = "POST_OVERFLOW_MENU", e.Report = "REPORT", e.Share = "SHARE", e.ShowFewerLikeThis = "SHOW_FEWER_LIKE_THIS", e.ShowMoreLikeThis = "SHOW_MORE_LIKE_THIS", e.Insights = "INSIGHTS", e.Mute = "MUTE", e.PromotePost = "PROMOTE_POST"
				}(s || (s = {}))
		},
		"./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return u
			}));
			var s, r, o, i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/Flatlist/breakpoints.m.less"),
				d = n.n(a),
				c = n("./src/reddit/components/Flatlist/constants.ts");
			! function(e) {
				e.HideIfVWSmaller = "HideIfVWSmaller", e.HideIfVWLarger = "HideIfVWLarger"
			}(s || (s = {})),
			function(e) {
				e.First = "FirstGroup", e.Editing = "EditingGroup", e.Second = "SecondGroup", e.Awarding = "AwardingGroup"
			}(r || (r = {})),
			function(e) {
				e.LoggedIn = "LoggedInVariant", e.LoggedOut = "LoggedOutVariant", e.Op = "OpVariant"
			}(o || (o = {}));
			const l = {
					[c.a.EditFlair]: r.Editing,
					[c.a.EditPost]: r.Editing,
					[c.a.Gild]: r.Awarding,
					[c.a.Hide]: r.First,
					[c.a.PostOverflowMenu]: r.First,
					[c.a.Report]: r.First,
					[c.a.Save]: r.First,
					[c.a.Share]: r.Second,
					[c.a.ShowFewerLikeThis]: r.First,
					[c.a.ShowMoreLikeThis]: r.First,
					[c.a.Insights]: r.First,
					[c.a.Mute]: r.First,
					[c.a.PromotePost]: r.First
				},
				u = e => {
					return (e => {
						const t = d.a[e.type],
							n = d.a[e.group],
							s = d.a[e.groupVariant];
						return Object(i.a)(t, n, s)
					})({
						type: e.breakpointType || s.HideIfVWSmaller,
						group: l[e.flatlistItem],
						groupVariant: ((e, t) => e && t ? o.Op : e ? o.LoggedIn : o.LoggedOut)(e.isLoggedIn, e.isUserOp)
					})
				}
		},
		"./src/reddit/components/Flatlist/index.m.less": function(e, t, n) {
			e.exports = {
				flatlistContainer: "_3-miAEojrCvx_4FQ8x3P-s",
				responsiveRow: "YszYBnnIoNY8pZ6UwCivd",
				rowContainer: "_3U_7i38RDPV5eBv7m4M-9J",
				responsiveRowText: "_70940WUuFmpHbhKlj8EjZ",
				insightsButtonText: "WH45FmM2j_4Snucem7pcm",
				flatlistSeparator: "x7sinePdvDKj7bf-cdm4Z",
				flexSpacer: "_21pmAV9gWG6F_UKVe7YIE0",
				modActionsIcon: "_15c1hqseW25EvRu0WP2Dq5",
				shareText: "_6_44iTtZoeY6_XChKt5b0",
				commentsLink: "_2qww3J5KKzsD7e5DO0BvvU",
				supportButton: "_3NIVQWStkLT7RXnwKpKNuT",
				text: "YCL-CnLJKXzXbwuLZEyh1",
				ShareButton: "kU8ebCMnbXfjCWfqn0WPb",
				shareButton: "kU8ebCMnbXfjCWfqn0WPb",
				shareIcon: "_1GQDWqbF-wkYWbrpmOvjqJ",
				ShareMenu: "_JRBNstMcGxbZUxrrIKXe",
				shareMenu: "_JRBNstMcGxbZUxrrIKXe",
				liveDiscussionWrapper: "_3rnnBQZL1OOttG3tFn629n",
				modLargePost: "_1rz4qmtk19qk1KbsKVMbAq",
				overflowMenuContainer: "_3MmwvEEt6fv5kQPFCVJizH",
				awardIcon: "_3yNNYT3e1avhAAWVHd0-92",
				saveIcon: "_1Xe01txJfRB9udUU85DNeR"
			}
		},
		"./src/reddit/components/Flatlist/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return ve
			})), n.d(t, "a", (function() {
				return xe
			})), n.d(t, "d", (function() {
				return ye
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				u = n("./src/lib/lessComponent.tsx"),
				m = n("./src/lib/ads/index.ts"),
				p = n("./src/lib/timezone/index.ts"),
				b = n("./src/reddit/actions/gold/modals.ts"),
				f = n("./src/reddit/actions/modal.ts"),
				h = n("./src/reddit/actions/post.ts"),
				g = n("./src/reddit/actions/postCreation/editing.ts"),
				v = n("./src/reddit/actions/postFlair.ts"),
				x = n("./src/reddit/actions/reportFlow/index.ts"),
				E = n("./src/reddit/components/BoostPost/index.ts"),
				O = n("./src/reddit/components/BoostPost/useBoostPostAction.ts"),
				C = n("./src/reddit/components/CommentsChat/LiveIcon/index.tsx"),
				A = n("./src/reddit/components/CommentsLink/index.tsx"),
				y = n("./src/reddit/components/CreatorStats/Icon.tsx"),
				j = n("./src/reddit/components/GiveAwardTooltip/index.tsx"),
				I = n("./src/reddit/components/ModActionsMenu/index.tsx"),
				k = n("./src/reddit/components/ModModeReports/helpers.ts"),
				_ = n("./src/reddit/components/ModToolsFlatlist/index.tsx"),
				S = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				w = n("./src/reddit/components/PostModModeDropdown/index.tsx"),
				T = n("./src/reddit/components/PostOverflowMenu/index.tsx"),
				P = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				N = n("./src/reddit/components/ShareMenu/index.tsx"),
				D = n("./src/reddit/components/TrackingHelper/index.tsx"),
				M = n("./src/reddit/components/ViewReportsDropdown/Loader.ts"),
				R = n("./src/reddit/constants/postLayout.ts"),
				L = n("./src/reddit/contexts/PageLayer/index.tsx"),
				B = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				F = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				U = n("./src/reddit/selectors/experiments/hidePostMitigation.ts"),
				H = n("./src/reddit/selectors/experiments/reportAd.ts"),
				G = n("./src/reddit/selectors/user.ts"),
				Q = n("./src/reddit/components/Flatlist/ResponsiveRow.tsx"),
				q = n("./src/reddit/helpers/correlationIdTracker.ts"),
				W = n("./src/reddit/helpers/trackers/modTools.ts"),
				z = n("./src/reddit/helpers/trackers/post.ts"),
				V = n("./src/reddit/icons/fonts/index.tsx"),
				K = n("./src/reddit/icons/fonts/ModActions/index.tsx"),
				Y = n("./src/reddit/icons/fonts/Share/index.tsx"),
				J = n("./src/reddit/models/NewStructuredStyles/index.ts"),
				X = n("./src/reddit/models/PostCreationForm/index.ts"),
				Z = n("./src/reddit/models/User/index.ts"),
				$ = n("./src/reddit/components/Flatlist/constants.ts"),
				ee = n("./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts"),
				te = n("./src/reddit/components/Flatlist/getFlatlistTooltipId.ts"),
				ne = n("./src/reddit/actions/postCollection/index.ts"),
				se = n("./src/reddit/components/Econ/GiftOrFreeAwardIcon/index.tsx"),
				re = n("./src/reddit/components/PostCreationForm/CollectionListModal/index.tsx"),
				oe = n("./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.tsx"),
				ie = n("./src/reddit/components/SearchResultsContent/searchResultsPageTreatment/searchIgnoreClickContext.ts"),
				ae = n("./src/reddit/selectors/activeModalId.ts"),
				de = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				ce = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				le = n("./src/reddit/selectors/experiments/chat.ts"),
				ue = n("./src/reddit/components/Flatlist/index.m.less"),
				me = n.n(ue);

			function pe() {
				return (pe = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			let be, fe;
			const he = u.a.button("ShareButton", me.a),
				ge = u.a.wrapped(N.a, "ShareMenu", me.a),
				ve = Object(l.a)(e => {
					let {
						className: t,
						...n
					} = e;
					return o.a.createElement(K.a, pe({}, n, {
						className: Object(d.a)(me.a.modActionsIcon, t),
						style: {
							color: Object(F.a)(Object(B.a)(n), J.a.actionIcon, J.b.actionIcon)
						}
					}))
				}),
				xe = e => o.a.createElement("div", pe({}, e, {
					className: Object(d.a)(me.a.flatlistSeparator, e.className)
				})),
				Ee = Object(L.v)({
					currentProfileName: L.j,
					isCommentPermalink: L.x,
					isCommentsPage: L.y,
					isProfilePostListing: L.N,
					pageLayer: e => e
				}),
				Oe = Object(a.c)({
					activeModalId: ae.a,
					claimedFreeAward: de.b,
					layout: L.U,
					userIsOp: G.Gb,
					subreddit: L.s,
					isReportAnAdEnabled: H.a,
					isHidePostButtonDisabled: U.a
				}),
				Ce = Object(i.b)(Oe, (e, t) => {
					let {
						post: s,
						isOverlay: r,
						isCommentsPage: o
					} = t;
					return {
						addPostToCollection: (t, n) => e(Object(ne.a)(t, n)),
						onToggleModal: t => e(Object(f.i)(t)),
						onToggleSave: () => e(Object(h.T)(s.postId)),
						onHide: t => e(Object(h.db)(s.postId, !s.hidden, r, !0)),
						onReportClick: () => e(Object(x.c)(s.postId, r)),
						onEdit: () => {
							const t = !r && !o;
							e(Object(g.a)(s.postId, t))
						},
						onFlairPost: () => e(Object(f.i)(Object(S.b)(s.postId, r))),
						onGildClick: (t, n) => e(Object(b.d)({
							awardId: n,
							correlationId: t,
							thingId: s.postId
						})),
						onFlairChanged: t => {
							let {
								selectedTemplateId: n,
								previewFlair: r
							} = t;
							return e(Object(v.h)({
								post: s,
								selectedTemplateId: n,
								previewFlair: r
							}))
						},
						toggleEditStartTimeModal: async () => {
							be && fe || ([be, fe] = await Promise.all([n.e("schedulePickerModal").then(n.bind(null, "./src/reddit/components/PostCreationForm/SchedulePickerModal/index.tsx")).then(e => e.default), Promise.resolve().then(n.bind(null, "./src/reddit/actions/eventPosts/index.ts")).then(e => e.editEventTimeRequested)])), e(Object(f.i)(Object(X.s)(s.postId, r, X.k.POST_OVERFLOW_MENU)))
						},
						addEventStartTime: t => {
							fe && e(fe(s.id, t))
						}
					}
				}),
				Ae = o.a.memo(e => {
					const {
						activeModalId: t,
						addEventStartTime: a,
						className: l,
						currentProfileName: u,
						currentUser: b,
						forceOpenInNewTab: f,
						hasModFlairPerms: h,
						hasModFullPerms: g,
						hasModPostPerms: v,
						isCommentPermalink: x,
						isCommentsPage: N,
						isCountAnimShadowTestEnabled: D,
						isLargePost: L,
						isOverlay: B,
						isProfilePostListing: F,
						isSticky: U,
						layout: H,
						modModeEnabled: G,
						onClickInsightsButton: K,
						onFlairChanged: J,
						onIgnoreReports: ne,
						onOpenReportsDropdown: ie,
						pageLayer: ae,
						post: de,
						sendEvent: ue,
						showEditFlair: pe,
						showEditPost: fe,
						subreddit: xe,
						toggleEditStartTimeModal: Ee,
						tooltipType: Oe,
						userIsOp: Ce,
						searchIgnoreClick: Ae,
						isCommentCountAnimation: je,
						hostPostData: Ie,
						listingKey: ke,
						onGildClick: _e,
						onToggleModal: Se,
						claimedFreeAward: we,
						onToggleSave: Te,
						onHide: Pe,
						addPostToCollection: Ne,
						onReportClick: De,
						shouldHideItems: Me,
						shouldShowInsightsButton: Re,
						isReportAnAdEnabled: Le,
						isHidePostButtonDisabled: Be
					} = e, {
						onBoostPostClick: Fe
					} = Object(O.a)(de.id), Ue = Object(i.e)(le.f), He = Object(r.useCallback)(async () => {
						const e = Object(q.d)(q.a.GildingFlow, !0);
						_e(e, null == we ? void 0 : we.id);
						const {
							clickGildEvent: t
						} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
						ue(t(de.id))
					}, [_e, de, ue, we]), Ge = Object(r.useCallback)(() => {
						t && Se(t)
					}, [t, Se]), Qe = Object(r.useCallback)(() => {
						const e = Object(X.t)(de.id, B);
						Se(e)
					}, [Se, B, de]), qe = Object(r.useCallback)(e => {
						Ne(e.id, de.id).then(() => Ge())
					}, [Ne, Ge, de]), We = Object(r.useCallback)((e, t) => {
						ue(Object(z.n)(de.id, e, B ? "post_detail" : "post", ke, Ie, void 0, null == t ? void 0 : t.referralId))
					}, [Ie, B, ue, ke, de]), ze = Object(r.useCallback)(() => {
						Te(), We(de.saved ? "unsave" : "save")
					}, [Te, de, We]), Ve = Object(r.useCallback)(() => {
						Pe(!!de.hidden), We(de.hidden ? "unhide" : "hide")
					}, [Pe, de, We]), Ke = Object(r.useCallback)(() => {
						De(), We("report")
					}, [De, We]), Ye = Object(r.useMemo)(() => o.a.createElement(he, {
						"data-click-id": "share",
						"data-adclicklocation": ce.b.FLATLIST_SHARE
					}, o.a.createElement(Y.a, {
						className: me.a.shareIcon
					}), o.a.createElement("span", {
						className: me.a.shareText
					}, s.fbt._("share", null, {
						hk: "1eAfZg"
					}))), []), Je = !!b && Object(Z.e)(b) === de.author, Xe = Object(te.a)("View--Reports", de.id, Oe), Ze = Object(te.a)(c.wc, de.id, Oe), $e = Object(k.c)(de), et = ye("-mod-actions-menu", de.id, B, U), tt = Object(k.a)(de), nt = de.postId, st = H === R.g.Large, rt = !N && st || v && G || Me, ot = !(B || N || x), it = !de.authorIsBlocked && b && de.isGildable && !de.authorIsBlocked && !de.unrepliableReason, at = !!de.recommendationContext, dt = de.isSponsored || Object(m.u)(ae);
					return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						className: Object(d.a)(me.a.flatlistContainer, l)
					}, o.a.createElement(A.a, {
						className: Object(d.a)(me.a.rowContainer, me.a.commentsLink),
						forceOpenInNewTab: f,
						hasModPostPerms: v,
						isCommentsPage: N,
						isCommentPermalink: x,
						isOverlay: B,
						postId: de.id,
						modModeEnabled: G,
						numComments: de.numComments,
						isCommentCountAnimation: je,
						isCountAnimShadowTestEnabled: D,
						isSponsored: de.isSponsored,
						impressionId: de.impressionId
					}), it && o.a.createElement(o.a.Fragment, null, o.a.createElement(Q.a, {
						displayText: s.fbt._("Award", null, {
							hk: "2fZCpE"
						}),
						textClassName: me.a.responsiveRowText,
						flatlistItem: $.a.Gild,
						isLoggedIn: !!b,
						isUserOp: Ce,
						onClick: He,
						searchIgnoreClick: Ae,
						"data-adclicklocation": ce.b.FLATLIST_AWARD,
						skipRoleAttr: !0
					}, o.a.createElement(se.a, {
						className: me.a.awardIcon,
						id: Ze
					})), o.a.createElement(j.a, {
						postOrComment: de,
						tooltipId: Ze
					})), o.a.createElement(ge, {
						className: Object(d.a)(me.a.rowContainer, Object(ee.b)({
							flatlistItem: $.a.Share,
							isLoggedIn: !!b,
							isUserOp: Ce
						})),
						dropdownId: ye("-share-menu", de.id, B, U),
						permalink: de.permalink,
						post: de,
						sendEventWithName: We,
						subredditType: null == xe ? void 0 : xe.type
					}, Ye), fe && !rt && o.a.createElement(Q.a, {
						displayText: s.fbt._("Edit post", null, {
							hk: "Jq2Cr"
						}),
						textClassName: me.a.responsiveRowText,
						flatlistItem: $.a.EditPost,
						isLoggedIn: !!b,
						isUserOp: Ce,
						onClick: e.onEdit,
						skipRoleAttr: !0
					}, o.a.createElement(V.a, {
						name: "edit"
					})), (!v || !G) && o.a.createElement(Q.a, {
						displayText: de.saved ? s.fbt._("unsave", null, {
							hk: "4Dn4IT"
						}) : s.fbt._("save", null, {
							hk: "3NOMst"
						}),
						textClassName: me.a.responsiveRowText,
						flatlistItem: $.a.Save,
						isLoggedIn: !!b,
						isUserOp: Ce,
						onClick: ze,
						searchIgnoreClick: Ae,
						skipRoleAttr: !0,
						"data-adclicklocation": ce.b.FLATLIST_SAVE
					}, o.a.createElement(V.a, {
						name: de.saved ? "saved" : "save",
						className: me.a.saveIcon
					})), !dt && !rt && !Be && o.a.createElement(Q.a, {
						displayText: de.hidden ? s.fbt._("unhide", null, {
							hk: "151XLs"
						}) : s.fbt._("hide", null, {
							hk: "4AnA6R"
						}),
						textClassName: me.a.responsiveRowText,
						flatlistItem: $.a.Hide,
						isLoggedIn: !!b,
						isUserOp: Ce,
						onClick: Ve,
						searchIgnoreClick: Ae,
						skipRoleAttr: !0
					}, o.a.createElement(V.a, {
						name: "hide",
						isFilled: de.hidden
					})), !Je && (!dt || Le) && !rt && o.a.createElement(Q.a, {
						displayText: s.fbt._("report", null, {
							hk: "1phfns"
						}),
						textClassName: me.a.responsiveRowText,
						flatlistItem: $.a.Report,
						isLoggedIn: !!b,
						isUserOp: Ce,
						onClick: Ke,
						searchIgnoreClick: Ae,
						skipRoleAttr: !0
					}, o.a.createElement(V.a, {
						name: "report"
					})), o.a.createElement(_.a, {
						isOverlay: B,
						layout: H,
						modModeEnabled: G,
						post: de,
						sendEvent: ue
					}), v && o.a.createElement(I.a, {
						dropdownId: et,
						onClick: () => ue(Object(z.n)(de.id, "post_mod_action_menu"))
					}, o.a.createElement(ve, null), o.a.createElement(w.a, {
						canEditFlair: h && !!pe,
						hasModFullPerms: g,
						hasModPostPerms: v,
						isOverlay: !!B,
						isPostAuthor: Je,
						modModeEnabled: G,
						post: de,
						tooltipId: et
					})), v && $e && !G && o.a.createElement(P.c, {
						text: `${tt}`,
						onClick: () => {
							ie(Xe), ue(Object(z.n)(de.id, "post_report_menu"))
						},
						id: Xe
					}, o.a.createElement(M.a, {
						model: de,
						onIgnoreReports: () => {
							ne(), ue(Object(W.q)(de.ignoreReports ? "restore_reports" : "ignore_reports", de.id))
						},
						tooltipId: Xe
					}), o.a.createElement(V.a, {
						className: me.a.icon,
						name: de.ignoreReports ? "ignore_reports" : "report"
					})), Re && o.a.createElement(Q.a, {
						displayText: s.fbt._("Insights", null, {
							hk: "2IyDq5"
						}),
						textClassName: Object(d.a)(me.a.responsiveRowText, me.a.insightsButtonText),
						flatlistItem: $.a.Insights,
						isLoggedIn: !!b,
						isUserOp: Ce,
						onClick: K,
						skipRoleAttr: !0
					}, o.a.createElement(y.a, {
						postCreated: de.created,
						subredditId: de.belongsTo.id
					})), Object(E.e)(de, b) && o.a.createElement(E.d, {
						postId: de.id,
						user: b,
						userIsOp: Ce,
						showIconOnly: H === R.g.Classic || v && G
					}), (!dt || Le) && o.a.createElement("div", {
						className: me.a.overflowMenuContainer
					}, o.a.createElement(T.a, {
						currentProfileName: u,
						dropdownId: ye("-overflow-menu", de.id, B, U),
						ignoreOverflowMenuBreakpoints: Me,
						isCommentsPage: N,
						isFixed: U,
						isOverlay: !!B,
						isProfilePostListing: F,
						isRecommendationPost: at,
						layout: H,
						modModeWithPost: G && v,
						onClickInsightsButton: K,
						pageLayer: ae,
						permalink: de.permalink,
						postId: nt,
						sendEvent: ue,
						shouldShowInsightsButton: Re,
						showEditPost: !!fe,
						showEditFlair: !!pe,
						useFlatlistBreakpoints: e.useFlatlistBreakpoints,
						toggleAddEventStartTimeModal: Ee,
						toggleEditStartTimeModal: Ee,
						onClickPromoteButton: Fe
					})), t === Object(X.t)(de.id, B) && o.a.createElement(re.a, {
						subredditId: de.belongsTo.id,
						onClose: Ge,
						postId: de.id,
						onSelectCollection: qe,
						titleText: s.fbt._("Add post to a collection", null, {
							hk: "38vSyF"
						}),
						onItemHoverActionText: s.fbt._("Add", null, {
							hk: "2wi3d4"
						}),
						isOverlay: B
					}), t === Object(X.s)(de.id, B, X.k.POST_OVERFLOW_MENU) && be && o.a.createElement(be, {
						onChange: a,
						onClose: Ee,
						schedule: Object(p.c)(de),
						shouldShowDeleteButton: !1
					}), t === Object(X.u)(de.id, B) && o.a.createElement(oe.a, {
						onCancel: Qe,
						onCollectionCreated: qe,
						subredditId: de.belongsTo.id
					}), t === Object(S.b)(de.id, B) && o.a.createElement(S.a, {
						flairs: de.flair,
						subredditId: de.belongsTo.id,
						modalId: Object(S.b)(de.id, B),
						onFlairChanged: J
					}), o.a.createElement("div", {
						className: me.a.flexSpacer
					})), ot && !Ue && o.a.createElement(C.a, {
						className: Object(d.a)(me.a.liveDiscussionWrapper, {
							[me.a.modLargePost]: L && v
						}),
						postId: de.postId
					}))
				});
			Ae.displayName = "Flatlist";
			const ye = (e, t, n, s) => {
					let r = t;
					return n && (r += "-overlay"), s && (r += "-sticky"), r += e
				},
				je = Ee(Ce(Object(D.c)(Ae)));
			t.c = o.a.memo((function(e) {
				const t = Object(ie.a)();
				return o.a.createElement(je, pe({}, e, {
					searchIgnoreClick: t
				}))
			}))
		},
		"./src/reddit/components/Footer/index.m.less": function(e, t, n) {
			e.exports = {
				FooterContainer: "_3qDK09Tb3ktpZiYXSfeMzE",
				footerContainer: "_3qDK09Tb3ktpZiYXSfeMzE",
				mIsWhite: "_3TyrvwTfHlJHEevBoOKkDJ",
				PrivacyLink: "_2mk2nvnRu7inPdJY2i-H79",
				privacyLink: "_2mk2nvnRu7inPdJY2i-H79",
				UserAgreement: "_2qv_r3Tr8ZqOWkU9s1qRfw",
				userAgreement: "_2qv_r3Tr8ZqOWkU9s1qRfw",
				UserAgreementLink: "vzd9DQ5W5uhRFvqy1_xKh",
				userAgreementLink: "vzd9DQ5W5uhRFvqy1_xKh",
				mIsGrey: "_2g4mHpbVF30jxvk8ZPbqBe"
			}
		},
		"./src/reddit/components/Footer/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/config.ts"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/Footer/index.m.less"),
				c = n.n(d);
			const {
				fbt: l
			} = n("./node_modules/fbt/lib/FbtPublic.js"), u = a.a.div("UserAgreement", c.a), m = a.a.a("UserAgreementLink", c.a), p = a.a.a("PrivacyLink", c.a);
			var b;
			! function(e) {
				e.Grey = "grey", e.White = "white"
			}(b || (b = {}));
			t.b = e => r.a.createElement("div", {
				className: Object(i.a)(c.a.FooterContainer, {
					[c.a.mIsGrey]: e.textColor === b.Grey,
					[c.a.mIsWhite]: e.textColor === b.White
				})
			}, r.a.createElement(u, null, l._("Use of this site constitutes acceptance of our {=User Agreement} and {=Privacy Policy.} Reddit, Inc.  {year}. All rights reserved. REDDIT and the ALIEN Logo are registered trademarks of reddit inc.", [l._param("=User Agreement", r.a.createElement(m, {
				href: `${o.a.redditUrl}/help/useragreement`
			}, l._("User Agreement", null, {
				hk: "1Dc18v"
			}))), l._param("=Privacy Policy.", r.a.createElement(p, {
				href: `${o.a.redditUrl}/help/privacypolicy`
			}, l._("Privacy Policy.", null, {
				hk: "1Ubjrd"
			}))), l._param("year", (new Date).getFullYear())], {
				hk: "yxLlI"
			})))
		},
		"./src/reddit/components/GeneralCleanup/SortViewBar/LayoutSwitch/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_2ZvnlxtjA4YPENO_OgH0Pw",
				container: "_2ZvnlxtjA4YPENO_OgH0Pw",
				Title: "_6Sb8zEFmf-xF6UJ5SowYB",
				title: "_6Sb8zEFmf-xF6UJ5SowYB",
				DropdownContainer: "U2iuzTD5-OeYSFP8fg9ky",
				dropdownContainer: "U2iuzTD5-OeYSFP8fg9ky",
				LayoutItem: "_1F02c6Yw0dfhdWwl99UrYn",
				layoutItem: "_1F02c6Yw0dfhdWwl99UrYn",
				LayoutItemIconWrapper: "_1WRDpeSLbiEc03Pp3Nh9H1",
				layoutItemIconWrapper: "_1WRDpeSLbiEc03Pp3Nh9H1",
				LayoutItemTextClassName: "PEJfazq4pplDD3Ti9Yaj3",
				layoutItemTextClassName: "PEJfazq4pplDD3Ti9Yaj3",
				Dropdown: "_3R-HO3gwoomy9obdIHmDLx",
				dropdown: "_3R-HO3gwoomy9obdIHmDLx",
				selected: "_1fiOgAxLiYfEU41C1NOX9B",
				DropdownButton: "_3EHmSVytc7PNTijH2qfAan",
				dropdownButton: "_3EHmSVytc7PNTijH2qfAan",
				LayoutIcon: "_2ONLRjLuDplXKbcaS8dGe_",
				layoutIcon: "_2ONLRjLuDplXKbcaS8dGe_"
			}
		},
		"./src/reddit/components/GeneralCleanup/SortViewBar/LayoutSwitch/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/higherOrderComponents/asTooltip.tsx"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				u = n("./src/reddit/actions/preferences.ts"),
				m = n("./src/reddit/actions/tooltip.ts"),
				p = n("./src/reddit/components/TrackingHelper/index.tsx"),
				b = n("./src/reddit/constants/postLayout.ts"),
				f = n("./src/reddit/contexts/PageLayer/index.tsx"),
				h = n("./src/reddit/contexts/Tooltip.ts"),
				g = n("./src/reddit/controls/Dropdown/index.tsx"),
				v = n("./src/reddit/controls/Dropdown/Row.tsx"),
				x = n("./src/reddit/icons/fonts/index.tsx"),
				E = n("./src/reddit/selectors/telemetry.ts"),
				O = n("./src/reddit/selectors/tooltip.ts"),
				C = n("./src/reddit/components/GeneralCleanup/SortViewBar/LayoutSwitch/index.m.less"),
				A = n.n(C);

			function y() {
				return (y = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const j = "view--layout--FUE",
				I = "LayoutSwitch--picker",
				k = Object(d.a)(g.a),
				_ = {
					[b.d.Card]: function(e) {
						return o.a.createElement(x.a, y({}, e, {
							name: "view_card"
						}))
					},
					[b.d.Classic]: function(e) {
						return o.a.createElement(x.a, y({}, e, {
							name: "view_classic"
						}))
					},
					[b.d.Compact]: function(e) {
						return o.a.createElement(x.a, y({}, e, {
							name: "view_compact"
						}))
					}
				},
				S = {
					[b.d.Card]: () => s.fbt._("card", null, {
						hk: "4qOOHu"
					}),
					[b.d.Classic]: () => s.fbt._("classic", null, {
						hk: "1tiTtA"
					}),
					[b.d.Compact]: () => s.fbt._("compact", null, {
						hk: "1N7pcz"
					}),
					[b.d.Search]: () => s.fbt._("search", null, {
						hk: "49uLRt"
					})
				},
				w = Object(f.v)(),
				T = Object(a.c)({
					dropdownIsOpen: Object(O.b)(I),
					postLayout: f.U,
					redditStyle: f.E
				}),
				P = Object(i.b)(T, e => ({
					onListingLayoutChange: (t, n) => e(Object(u.x)(t, n)),
					openDropdown: () => e(Object(m.h)({
						tooltipId: I
					}))
				}));
			class N extends o.a.Component {
				constructor() {
					super(...arguments), this.changeLayout = e => {
						const {
							onChange: t,
							onListingLayoutChange: n,
							sendEvent: s,
							subredditId: r
						} = this.props;
						t ? t(e) : (n(e, r), s(t => ({
							source: "layout_switch",
							action: "click",
							noun: e,
							screen: Object(E.db)(t),
							subreddit: Object(E.mb)(t)
						})))
					}, this.renderItem = (e, t) => {
						const {
							layout: n,
							onLayoutClick: s,
							postLayout: r
						} = this.props, i = n || b.e[r], a = e === i, d = _[e], l = S[e];
						return o.a.createElement(v.b, y({}, t, {
							className: Object(c.a)(A.a.LayoutItem, {
								[A.a.selected]: a,
								[A.a.DropdownButton]: null == t ? void 0 : t.showDropdownTriangle
							}),
							"data-layout": e,
							displayText: l(),
							iconWrapperClassName: A.a.LayoutItemIconWrapper,
							isSelected: a,
							noHover: a,
							onClick: a ? void 0 : () => this.changeLayout(e),
							textClassName: A.a.LayoutItemTextClassName
						}), o.a.createElement(d, {
							className: A.a.LayoutIcon,
							onClick: a ? void 0 : s,
							isFilled: a && (!t || !1 !== t.forceIconFill)
						}))
					}, this.renderDropdown = e => {
						const {
							dropdownIsOpen: t
						} = this.props;
						return o.a.createElement(k, y({}, e, {
							className: A.a.Dropdown,
							isOpen: t,
							renderContentsHidden: !0,
							rowClassName: A.a.DropdownRow,
							rowIconClassName: A.a.DropdownRowIcon,
							rowSelectedClassName: A.a.DropdownRowSelected,
							tooltipId: I
						}), this.renderItem(b.d.Card), this.renderItem(b.d.Classic), this.renderItem(b.d.Compact))
					}
				}
				render() {
					const {
						className: e,
						layout: t,
						openDropdown: n,
						postLayout: s
					} = this.props, r = t || b.e[s];
					return o.a.createElement("div", {
						className: Object(c.a)(A.a.Container, e),
						id: j
					}, o.a.createElement("div", {
						className: A.a.DropdownContainer,
						onClick: n
					}, this.renderItem(r, {
						id: I,
						showDropdownTriangle: !0,
						forceIconFill: !1
					}), o.a.createElement(h.a.Consumer, null, this.renderDropdown)))
				}
			}
			t.a = w(P(Object(p.c)(Object(l.a)(N))))
		},
		"./src/reddit/components/GeoForm/GeoForm.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return I
			}));
			var s, r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/controls/Button/index.tsx"),
				l = n("./src/reddit/hooks/useMounted.ts"),
				u = n("./node_modules/p-debounce/index.js"),
				m = n.n(u),
				p = n("./src/lib/hooks/useOnClickOutside.ts"),
				b = n("./src/reddit/constants/keycodes.ts"),
				f = n("./src/lib/makeGqlRequest/index.ts"),
				h = n("./src/lib/sentry/index.ts"),
				g = n("./src/redditGQL/operations/GeoPlaceAutocomplete.json");
			! function(e) {
				e.GoogleMaps = "GOOGLE_MAPS", e.Geonames = "GEONAMES"
			}(s || (s = {}));
			const v = (e, t) => async n => {
				let s;
				try {
					s = await async function(e, t) {
						return Object(f.a)(e, {
							...g,
							variables: t
						})
					}(e(), {
						query: n,
						sessionId: t
					})
				} catch (r) {
					return h.c.captureException(r), []
				}
				return s.body.data.geoPlaceAutocomplete || []
			};
			var x = n("./src/reddit/hooks/useGqlContext.ts"),
				E = n("./src/reddit/icons/svgs/Location/index.tsx"),
				O = n("./src/reddit/components/GeoForm/index.m.less"),
				C = n.n(O);

			function A(e) {
				const {
					value: t,
					setValue: n,
					setPlace: s,
					disabled: a,
					onFocus: c,
					sessionId: l,
					className: u
				} = e, p = Object(x.a)(), [f, h] = Object(o.useState)(!1), g = function(e, t, n) {
					const [s, r] = Object(o.useState)([]), i = Object(o.useMemo)(() => m()(n, 300), [n]);
					return Object(o.useEffect)(() => {
						e && t && i(e).then(e => {
							r(e)
						}).catch(() => r([]))
					}, [e]), s
				}(t, f, v(p, l)), {
					highlightValue: O,
					selectedIndex: A,
					onKeyDown: j,
					isClosed: I,
					setClosed: k
				} = function(e, t, n) {
					const [s, r] = Object(o.useState)(-1), [i, a] = Object(o.useState)(!!e.length), [d, c] = Object(o.useState)(void 0);
					return {
						highlightValue: d,
						selectedIndex: s,
						onKeyDown: o => {
							if (o.key === b.b.ArrowDown) {
								const t = Math.min(s + 1, e.length - 1);
								r(t), c(e[t])
							} else if (o.key === b.b.ArrowUp) {
								const t = Math.max(s - 1, -1);
								r(t), c(e[t])
							} else o.key === b.b.Enter && s > -1 ? (r(-1), t(e[s].name), n(e[s]), a(!0), o.preventDefault()) : o.key === b.b.Escape ? (r(-1), a(!0)) : c(void 0)
						},
						isClosed: i,
						setClosed: a
					}
				}(g, n, s), _ = `location-input-${l}`;
				return i.a.createElement("div", {
					className: C.a.autocompleteInput
				}, i.a.createElement("label", {
					className: C.a.geoLabel,
					htmlFor: _
				}, i.a.createElement(E.a, {
					className: C.a.locationIcon
				})), i.a.createElement("input", {
					className: Object(d.a)(C.a.geoInput, u),
					name: _,
					disabled: a,
					onKeyDown: j,
					value: O && O.name || t,
					placeholder: r.fbt._("Add location", null, {
						hk: "1BaqFd"
					}),
					onChange: e => {
						n(e.currentTarget.value), s(void 0), k(!1)
					},
					onFocus: () => {
						h(!0), c()
					},
					onBlur: () => h(!1)
				}), g.length && !I ? i.a.createElement(y, {
					id: l,
					items: g.map(e => e.name),
					selectedIndex: A,
					selectValue: e => {
						n(g[e].name), s(g[e]), k(!0)
					},
					onClickOutside: () => k(!0)
				}) : null)
			}

			function y(e) {
				const {
					id: t,
					items: n,
					selectedIndex: s,
					selectValue: r,
					onClickOutside: o
				} = e;
				return Object(p.a)(`autocomplete-dropdown-${t}`, o), i.a.createElement("ul", {
					className: C.a.autocompleteDropdown,
					id: `autocomplete-dropdown-${t}`
				}, n.map((e, t) => i.a.createElement("li", {
					key: `${e}${t}`,
					onClick: () => r(t),
					className: Object(d.a)({
						[C.a.highlight]: t === s
					})
				}, e)))
			}
			const j = () => {};

			function I(e) {
				const {
					className: t,
					initialValue: n,
					initialPlace: s,
					disabled: u = !1,
					onFocus: m = j,
					onPlace: p = j,
					onValue: b = j,
					inputClassName: f
				} = e, h = Object(l.a)(), [g] = Object(o.useState)(() => Object(a.a)()), [v, x] = Object(o.useState)(n || ""), [E, O] = Object(o.useState)(s);
				return h ? i.a.createElement("form", {
					className: Object(d.a)(C.a.geoForm, t),
					onSubmit: t => {
						t.preventDefault(), (null == s ? void 0 : s.id) !== (null == E ? void 0 : E.id) && e.onSubmit({
							name: v,
							place: E,
							sessionId: g
						})
					}
				}, i.a.createElement(A, {
					className: f,
					value: v,
					sessionId: g,
					setValue: e => {
						x(e), b(e)
					},
					setPlace: e => {
						O(e), p(e)
					},
					disabled: u,
					onFocus: m
				}), E && E.id !== (null == s ? void 0 : s.id) && i.a.createElement(c.o, {
					className: C.a.submitButton,
					type: "submit",
					disabled: u
				}, r.fbt._("Submit", null, {
					hk: "4aU3dh"
				}))) : null
			}
		},
		"./src/reddit/components/GeoForm/index.m.less": function(e, t, n) {
			e.exports = {
				geoForm: "dnC9V9HtkUxsmza-vEXgC",
				geoLabel: "_3T9bJ1ttSXUxb9rxZI9jMC",
				locationIcon: "_2Jm0p-hd1-KYZJI9iP3n6",
				geoInput: "_2O28-fZaU1kYnMmsiMKw3y",
				autocompleteInput: "oP84ZJjEgYLr154hrXHd8",
				autocompleteDropdown: "_1pwsnPyclgUCyjdfT0xWmx",
				highlight: "_1kfPE4TrjHsTFgvmrF1s33"
			}
		},
		"./src/reddit/components/GiveAwardTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_17AlFvm1kWw8NYe0FZKlMB",
				newBadge: "_18TPfQgPhTmXJ8270Nc5nM",
				text: "_26N1OuVJykHlztxQkPEfqb",
				freeAwardTooltip: "_1C7AEhBd1Od4VDczirG0jB",
				freeAwardContainer: "P0AA_X8_E-4IwAxzn2uke"
			}
		},
		"./src/reddit/components/GiveAwardTooltip/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/hooks/useTracking.ts"),
				a = n("./src/reddit/helpers/trackers/freeAwardOffer.ts"),
				d = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				c = n("./src/reddit/components/ContentTooltip/index.tsx"),
				l = n("./src/reddit/components/GiveAwardTooltip/index.m.less"),
				u = n.n(l);
			const {
				fbt: m
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = e => {
				const {
					tooltipId: t
				} = e, n = Object(o.e)(d.b), l = Object(i.a)();
				return Object(s.useEffect)(() => {
					n && l(Object(a.c)())
				}, [n, l]), n ? r.a.createElement(c.a, {
					className: u.a.freeAwardTooltip,
					caretColor: {
						bottom: "#F6481E"
					},
					tooltipSizeEstimate: {
						height: 48,
						width: 148
					},
					tooltipId: t,
					defaultTooltipPosition: "top"
				}, r.a.createElement("div", {
					className: u.a.freeAwardContainer
				}, m._("Tap to give your {award name} Award", [m._param("award name", n.name)], {
					hk: "2EMqbP"
				}))) : null
			}
		},
		"./src/reddit/components/GrantUserFlair/index.m.less": function(e, t, n) {
			e.exports = {
				titleRow: "_1knBg4PWacEaLvDRHAvsTp",
				flairDetails: "_2bPY-7msbc_UjCac-In6Li",
				flairEditColumn: "_2ebZb7SML8ZCy-QsS6tUc0",
				column: "_3vuuCvX3U56Wb64Bz3AX9W",
				iconsColumn: "Q9C1YLEYQHPi_NuLIcsS3",
				removeIcon: "_2IP600IxdVV8-hzfus_xst",
				removeButton: "Yd-aY1XSmw6atYPPJHm9n",
				row: "_3W5UQ4TDClfiDY4zEBYSqT",
				flairEditHelperText: "_2JpPK1gCbDBJBbMRrx-fe6",
				errorIndicator: "_1gmumWT2YihpY16NJJw_ac",
				hasError: "Uu_my_fNiUJaUT-wFhyeq",
				flairContainer: "_1c46XAzSY3wg6lATaRh11v",
				userLink: "_14IDyvxQsRUGTR9unevdzm",
				textInput: "_3OzKI46CUHBipWh2v7Cfq",
				dropdownTriangle: "_3L2zEwdN8hdor-MjnuTTXx",
				dropdownTarget: "_2q91kdzeOjUsLeozfWfPZI",
				dropdownContainer: "_2SgxV6WihN0lLBZ06jChDN",
				dropdownRow: "Hsh_7uWgjhtYFcA5QqiI6",
				userIcon: "uHVmBRWHNpGMMkIFBthWs",
				modIcon: "_31YDoZrj2KLLxWJhYimRfb",
				infoTooltip: "i75byXeh_ZzdbD0HGxb4",
				tooltipText: "_3FXJw0xh37YZHaJP_j3Npe",
				tooltipIconContainer: "_1dZeti3tpsM8YrfluheTX5",
				tooltipIconRow: "_2B9YDCXdUsKx20YPQ_0guj",
				tooltipIconText: "_2_doCenMWfLXsGEvDSq1NB",
				cssInputError: "_3ySNKx0QJZRCNOFB6345zX",
				bottomBarRow: "Tf16TWgXZcNKzLmD4PDPq",
				topBar: "e-h9YD6UZh8FOUPTG6drY",
				disabledBanner: "_3rrCSsx0QD7pFwGJquTq-6",
				warningIcon: "_3MSU8YNfdz6icABES0GIkK",
				emptyList: "y4YDfdWBHO7s3GVuYjBDF",
				flairIcon: "_3RYWcdo8Ov1AjwCGeCUsfs",
				mainText: "_8uYoAAuUrGW1iwcBP-2eS",
				newModNavContainer: "_28PeUSyhLWvbBrCKb7xSwQ",
				fadeIn: "_3YR0vW4lNgbJJ7RgssVmf-"
			}
		},
		"./src/reddit/components/GrantUserFlair/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/lodash/find.js"),
				i = n.n(o),
				a = n("./node_modules/react/index.js"),
				d = n.n(a),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/addQueryParams/index.ts"),
				m = n("./src/lib/classNames/index.ts"),
				p = n("./src/lib/constants/index.ts"),
				b = n("./src/lib/omitKey/index.ts"),
				f = n("./src/lib/stripQueryParams/index.ts"),
				h = n("./src/reddit/actions/grantUserFlair/index.ts"),
				g = n("./src/reddit/components/InfoBanners/BannerBase/index.tsx"),
				v = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				x = n("./src/reddit/components/ModHub/InfoTooltip/index.tsx"),
				E = n("./src/reddit/components/ModHub/NewModNav/PageLinks.tsx"),
				O = n("./src/reddit/components/ModHub/PaginationButtons/index.tsx"),
				C = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				A = n("./src/reddit/components/SaveIndicator/index.m.less"),
				y = n.n(A),
				j = n("./src/reddit/icons/svgs/CheckmarkFitted/index.tsx"),
				I = n("./src/reddit/icons/svgs/ClearFilled/index.tsx"),
				k = n("./src/reddit/icons/svgs/Replay/index.tsx"),
				_ = n("./src/reddit/models/ApiRequestState/index.ts");
			const S = {
				[_.a.Pending]: () => r.fbt._("Saving", null, {
					hk: "3r9uZO"
				}),
				[_.a.Complete]: () => r.fbt._("Saved", null, {
					hk: "e9tAk"
				}),
				[_.a.Failed]: () => r.fbt._("Save error", null, {
					hk: "3NFi3S"
				})
			};
			var w = e => d.a.createElement(d.a.Fragment, null, e.status === _.a.Pending && d.a.createElement(k.a, {
					className: Object(m.a)(y.a.icon, y.a.pendingIcon)
				}), e.status === _.a.Complete && d.a.createElement(j.a, {
					className: Object(m.a)(y.a.icon, y.a.savedIcon)
				}), e.status === _.a.Failed && d.a.createElement(I.a, {
					className: Object(m.a)(y.a.icon, y.a.saveErrorIcon)
				}), d.a.createElement("span", {
					className: y.a.caption
				}, S[e.status]())),
				T = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				P = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				N = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				D = n("./src/reddit/components/TrackingHelper/index.tsx"),
				M = n("./src/reddit/constants/colors.ts"),
				R = n("./src/reddit/contexts/PageLayer/index.tsx"),
				L = n("./src/reddit/helpers/flair.ts"),
				B = n("./src/reddit/selectors/telemetry.ts");
			const F = e => ({
					subreddit: B.mb(e),
					profile: B.U(e),
					userSubreddit: B.vb(e)
				}),
				U = e => t => ({
					source: "grant_user_flair",
					action: "click",
					noun: e,
					...F(t)
				}),
				H = () => U("search_username"),
				G = () => U("page_forward"),
				Q = () => U("page_back"),
				q = () => U("remove_granted_user_flair"),
				W = (e, t) => n => ({
					source: "grant_user_flair",
					action: "autosave",
					noun: e,
					actionInfo: {
						...B.d(n),
						settingValue: t
					},
					...F(n)
				}),
				z = () => W("flair_text"),
				V = e => W("flair_template", e || "none"),
				K = e => W("css_class", e);
			var Y = n("./src/reddit/icons/svgs/Moderate/index.tsx"),
				J = n("./src/reddit/icons/svgs/QuarantineWarning/index.tsx"),
				X = n("./src/reddit/icons/svgs/User/index.tsx"),
				Z = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				$ = n("./src/reddit/models/SubredditModeration/index.ts");
			const ee = [];
			var te = n("./src/reddit/selectors/meta.ts"),
				ne = n("./src/reddit/selectors/moderatorPermissions.ts"),
				se = n("./src/reddit/selectors/subreddit.ts"),
				re = n("./src/reddit/selectors/userFlair.ts"),
				oe = n("./src/reddit/icons/fonts/Tag/index.tsx"),
				ie = n("./src/reddit/components/GrantUserFlair/index.m.less"),
				ae = n.n(ie);
			var de = () => d.a.createElement("div", {
					className: ae.a.emptyList
				}, d.a.createElement(oe.a, {
					className: ae.a.flairIcon
				}), d.a.createElement("div", {
					className: ae.a.mainText
				}, r.fbt._("You do not have any users with user flair", null, {
					hk: "4D1S5Z"
				})), d.a.createElement("div", null, r.fbt._("Search for a user to assign a user flair", null, {
					hk: "2YaDOy"
				}))),
				ce = n("./node_modules/lodash/filter.js"),
				le = n.n(ce),
				ue = n("./node_modules/lodash/isEqual.js"),
				me = n.n(ue),
				pe = n("./node_modules/lodash/omit.js"),
				be = n.n(pe),
				fe = n("./src/reddit/constants/flair.ts"),
				he = n("./src/reddit/helpers/validateFlairCssClass.ts");
			const ge = 200;
			var ve;
			! function(e) {
				e[e.Save = 0] = "Save", e[e.Delete = 1] = "Delete"
			}(ve || (ve = {}));
			const xe = e => null === e.flair,
				Ee = e => !(!e.apiError && !e.clientValidationError),
				Oe = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					const n = Date.now();
					return le()(e, e => {
						if (!e || e.clientValidationError) return !1;
						if (e.apiError && !t) return !1;
						if (xe(e)) return !0;
						return n - e.changedAt > 2e3 || t
					})
				},
				Ce = (e, t, n) => {
					const s = Object.keys(e).filter(s => {
						const r = e[s],
							o = t[s] || null;
						return !(!!o || s === n || !Ee(r)) || !!me()(o, r.flair)
					});
					return s.length ? be()(e, s) : e
				},
				Ae = (e, t) => {
					const n = t || fe.a;
					return (e ? Object(L.m)(e, n) || Object(he.a)(e.cssClass || "") : "") || void 0
				};
			var ye = n("./node_modules/lodash/noop.js"),
				je = n.n(ye),
				Ie = n("./src/reddit/components/Flair/index.tsx"),
				ke = n("./src/reddit/components/FlairSearch/FlairEdit/helper.tsx"),
				_e = n("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				Se = n("./src/reddit/controls/InternalLink/index.tsx"),
				we = n("./src/reddit/icons/svgs/Remove/index.tsx"),
				Te = n("./src/reddit/models/Flair/index.ts"),
				Pe = n("./src/higherOrderComponents/asTooltip.tsx"),
				Ne = n("./src/reddit/actions/tooltip.ts"),
				De = n("./src/reddit/constants/keycodes.ts"),
				Me = n("./src/reddit/controls/Dropdown/index.tsx"),
				Re = n("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				Le = n("./src/reddit/selectors/tooltip.ts");
			const Be = e => `UserFlairPicker--${e}`,
				Fe = Object(Pe.a)(Me.a),
				Ue = e => {
					let {
						flair: t
					} = e;
					return d.a.createElement(d.a.Fragment, null, d.a.createElement(Ie.c, {
						flair: Object(L.c)(t),
						forceSmallEmojis: !0
					}), t.textEditable && d.a.createElement(X.a, {
						className: ae.a.userIcon
					}), t.modOnly && d.a.createElement(Y.a, {
						className: ae.a.modIcon
					}))
				},
				He = Object(l.c)({
					isDropdownOpen: (e, t) => Object(Le.b)(Be(t.userName))(e)
				});
			class Ge extends d.a.Component {
				constructor(e) {
					super(e), this.onSetFocus = e => {
						this.setState({
							focusedIndex: e
						})
					}, this.findNextFocusableItem = () => {
						if (void 0 === this.state.focusedIndex) return -1; {
							const e = this.state.focusedIndex + 1;
							if (e <= this.props.templateIds.length - 1) return e
						}
					}, this.onMouseEnter = e => {
						const t = document.getElementById(`focus-${e}`);
						t && (t.focus(), this.onSetFocus(e))
					}, this.findPreviousFocusableItem = () => {
						if (void 0 !== this.state.focusedIndex && -1 !== this.state.focusedIndex) return this.state.focusedIndex - 1
					}, this.onKeyDown = e => {
						if (e.keyCode === De.a.ArrowDown)
							if (e.preventDefault(), this.props.isDropdownOpen) {
								const e = this.findNextFocusableItem();
								if (void 0 !== e) {
									const t = document.getElementById(`focus-${e}`);
									t && (t.focus(), t.scrollIntoView({
										block: "nearest"
									})), this.onSetFocus(e)
								}
							} else this.props.onToggleDropdown();
						if (e.keyCode === De.a.ArrowUp) {
							e.preventDefault();
							const t = this.findPreviousFocusableItem();
							if (void 0 !== t) {
								const e = document.getElementById(`focus-${t}`);
								e && (e.focus(), e.scrollIntoView({
									block: "nearest"
								})), this.onSetFocus(t)
							}
						}
						if (e.keyCode === De.a.Tab && this.props.isDropdownOpen && e.preventDefault(), e.keyCode === De.a.Enter) {
							if (e.preventDefault(), e.stopPropagation(), this.props.isDropdownOpen && void 0 !== this.state.focusedIndex) {
								const e = this.props.templateIds[this.state.focusedIndex];
								this.props.onSelectFlairTemplate(e)
							}
							this.props.onToggleDropdown()
						}
					}, this.state = {}
				}
				render() {
					const {
						props: e
					} = this;
					return d.a.createElement("button", {
						className: ae.a.dropdownTarget,
						id: Be(e.userName),
						onClick: e.onToggleDropdown,
						onKeyDown: this.onKeyDown
					}, e.selectedTemplateId && e.userFlairTemplates[e.selectedTemplateId] ? d.a.createElement(Ue, {
						flair: e.userFlairTemplates[e.selectedTemplateId]
					}) : r.fbt._("none", null, {
						hk: "ng6B"
					}), d.a.createElement(Re.a, {
						className: ae.a.dropdownTriangle
					}), d.a.createElement(Fe, {
						className: ae.a.dropdownContainer,
						isOpen: e.isDropdownOpen,
						tooltipId: Be(e.userName)
					}, d.a.createElement("button", {
						className: ae.a.dropdownRow,
						id: "focus--1",
						onClick: () => e.onSelectFlairTemplate(void 0),
						onMouseEnter: () => this.onMouseEnter(-1),
						tabIndex: -1
					}, r.fbt._("none", null, {
						hk: "ng6B"
					})), e.templateIds.map((t, n) => {
						const s = e.userFlairTemplates[t];
						return d.a.createElement("button", {
							className: ae.a.dropdownRow,
							id: `focus-${n}`,
							key: t,
							onClick: () => e.onSelectFlairTemplate(t),
							onMouseEnter: () => this.onMouseEnter(n),
							tabIndex: -1
						}, d.a.createElement(Ue, {
							flair: s
						}))
					})))
				}
			}
			var Qe = Object(c.b)(He, (e, t) => ({
				onToggleDropdown: () => e(Object(Ne.h)({
					tooltipId: Be(t.userName)
				}))
			}))(Ge);
			const qe = e => `emoji-picker-${e}`,
				We = Object(L.b)();
			class ze extends d.a.PureComponent {
				constructor() {
					super(...arguments), this.onSelectFlairTemplate = e => {
						const t = e && this.props.userFlairTemplates[e],
							n = t ? Object(L.c)(t) : We;
						this.props.onChange(this.props.username, n)
					}, this.onFlairContentChanged = e => {
						this.props.onChange(this.props.username, e)
					}, this.onChangeCssClass = e => {
						const t = e.target.value,
							n = this.props.flair || We;
						this.props.onChange(this.props.username, {
							...n,
							cssClass: t
						})
					}, this.removeFlair = () => {
						this.props.onChange(this.props.username, null)
					}
				}
				render() {
					var e;
					const {
						props: t
					} = this, {
						hasError: n
					} = t, s = t.flair || We, r = Object(ke.a)(), o = s.templateId, i = o && (null === (e = t.userFlairTemplates) || void 0 === e ? void 0 : e[o]) || fe.a, a = !!i && i.modOnly, c = !Object(he.a)(s.cssClass || "");
					return d.a.createElement("div", {
						className: Object(m.a)(ae.a.row, n ? ae.a.hasError : null)
					}, d.a.createElement("div", {
						className: ae.a.errorIndicator
					}, d.a.createElement(I.a, null)), d.a.createElement(Se.default, {
						className: ae.a.userLink,
						to: `/user/${t.username}`
					}, d.a.createElement(_e.a, {
						user: t.username,
						tooltipId: `grantuserflair--userhovercard--${t.username}`,
						subredditId: t.subredditId,
						sendHoverCardEvent: je.a
					}, t.username, d.a.createElement("div", {
						className: ae.a.flairContainer
					}, d.a.createElement(Ie.c, {
						flair: s
					})))), d.a.createElement("div", {
						className: ae.a.flairDetails
					}, d.a.createElement("div", {
						className: ae.a.column
					}, d.a.createElement(Qe, {
						onSelectFlairTemplate: this.onSelectFlairTemplate,
						selectedTemplateId: o,
						templateIds: t.templateIds,
						userFlairTemplates: t.userFlairTemplates,
						userName: this.props.username
					})), d.a.createElement("div", {
						className: ae.a.flairEditColumn
					}, d.a.createElement(r, {
						allowBlank: !t.isChanged,
						emojiPickerId: qe(t.username),
						flair: s,
						flairTemplateType: Te.d.UserFlair,
						flairTemplate: i,
						helperTextClass: ae.a.flairEditHelperText,
						isCompact: !0,
						isFlairModOnly: a,
						onChange: this.onFlairContentChanged,
						subredditId: t.subredditId
					})), d.a.createElement("div", {
						className: ae.a.column
					}, d.a.createElement("input", {
						className: Object(m.a)(ae.a.textInput, {
							[ae.a.cssInputError]: !c
						}),
						value: s.cssClass || "",
						onChange: this.onChangeCssClass,
						disabled: !!i.id
					})), d.a.createElement("button", {
						className: ae.a.removeButton,
						onClick: this.removeFlair
					}, d.a.createElement(we.a, {
						className: ae.a.removeIcon
					}))))
				}
			}
			var Ve = ze;
			const Ke = {},
				Ye = Object(R.v)({
					currentPageUrl: R.f
				}),
				Je = Object(l.c)({
					flairedUserOrder: (e, t) => {
						const n = Object($.e)(t.subredditId, t.after, t.before);
						return e.pages.modHub.flairedUsers.userOrder[n] || ee
					},
					flairedUsers: (e, t) => e.pages.modHub.flairedUsers.models[t.subredditId],
					isFlairedUsersListPending: e => e.pages.modHub.flairedUsers.api.pending,
					isSearchPending: e => e.pages.modHub.flairedUsers.search.api.pending,
					isUserFlairEnabled: re.a,
					origin: te.l,
					pageInfo: (e, t) => {
						const n = Object($.e)(t.subredditId, t.after, t.before);
						return e.pages.modHub.flairedUsers.pageInfo[n]
					},
					searchResult: (e, t) => e.pages.modHub.flairedUsers.search.result,
					userFlairData: re.d,
					isInShredditModNavExperiment: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = Object(ne.n)(e, {
							subredditId: n
						});
						return Object(Z.a)(e, !!s)
					},
					subredditName: (e, t) => {
						let {
							subredditId: n
						} = t;
						return Object(se.h)(e, {
							subredditId: n
						})
					}
				}),
				Xe = Object(c.b)(Je, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						deleteUserFlair: (t, n) => e(Object(h.a)(t, n)),
						saveFlairedUser: (t, s) => e(Object(h.c)(t, n, s)),
						searchFlairedUser: t => e(Object(h.d)(n, t))
					}
				});
			class Ze extends d.a.Component {
				constructor(e) {
					var t;
					super(e), t = this, this.isUnmounted = !1, this.pendingRequestsMap = new Map, this.autoSaveIntervalId = 0, this.processChanges = function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						t.autoSaveIntervalId || (t.autoSaveIntervalId = window.setInterval(t.processChanges, ge));
						const {
							flairedUsers: n
						} = t.props, {
							unsavedChanges: s,
							searchTerm: r
						} = t.state, o = Ce(s, n, r), i = Oe(o, e);
						i.forEach(t.sendChangeToServer), o !== s && t.setState({
							unsavedChanges: o
						})
					}, this.sendChangeToServer = async e => {
						const t = e.username;
						if (this.pendingRequestsMap.get(t)) return;
						const n = this.props.flairedUsers[t] || null;
						this.sendTelemetryEvents(n, e.flair);
						const s = e.flair ? {
							type: ve.Save,
							promise: this.props.saveFlairedUser(t, e.flair)
						} : {
							type: ve.Delete,
							promise: this.props.deleteUserFlair(t, this.props.subredditId)
						};
						this.pendingRequestsMap.set(t, s);
						const r = await s.promise;
						this.pendingRequestsMap.delete(t), this.isUnmounted || this.setState(n => {
							const s = n.unsavedChanges[t];
							return e !== s ? null : {
								unsavedChanges: !0 === r ? Object(b.a)(n.unsavedChanges, t) : {
									...this.state.unsavedChanges,
									[t]: {
										...e,
										apiError: r
									}
								}
							}
						})
					}, this.onFlairChanged = (e, t) => {
						const {
							templates: n
						} = this.props.userFlairData, s = t && t.templateId ? n[t.templateId] : void 0;
						this.setState(n => {
							return {
								unsavedChanges: {
									...n.unsavedChanges,
									[e]: {
										flair: t,
										username: e,
										changedAt: Date.now(),
										clientValidationError: Ae(t, s)
									}
								}
							}
						})
					}, this.onSearch = e => {
						this.props.searchFlairedUser(e), this.setState({
							searchTerm: e
						}), this.props.sendEvent(H())
					}, this.onCancelSearch = () => {
						this.setState({
							searchTerm: null
						})
					}, this.onClickNextPage = () => this.props.sendEvent(G()), this.onClickPrevPage = () => this.props.sendEvent(Q()), this.renderUserRow = e => {
						const {
							state: t,
							props: n
						} = this, s = n.flairedUsers[e] || null, r = t.unsavedChanges[e], o = r && !xe(r) ? r.flair : s;
						return d.a.createElement(Ve, {
							flair: o,
							hasError: !!r && Ee(r),
							isChanged: !!r,
							key: e,
							onChange: this.onFlairChanged,
							subredditId: n.subredditId,
							templateIds: n.userFlairData.templateIds,
							userFlairTemplates: n.userFlairData.templates,
							username: e
						})
					}, this.state = {
						searchTerm: null,
						unsavedChanges: Ke
					}
				}
				componentDidUpdate() {
					this.processChanges()
				}
				componentWillUnmount() {
					this.isUnmounted = !0, this.processChanges(!0), window.clearInterval(this.autoSaveIntervalId)
				}
				sendTelemetryEvents(e, t) {
					if (!t) return void this.props.sendEvent(q());
					let n = e || Object(L.b)();
					const s = n.templateId || void 0,
						r = t.templateId || void 0;
					if (r !== s) {
						this.props.sendEvent(V(r));
						const e = t.templateId && this.props.userFlairData.templates[t.templateId];
						n = e ? Object(L.c)(e) : n
					}
					Object(L.p)(t, n) || this.props.sendEvent(z()), t.cssClass !== n.cssClass && this.props.sendEvent(K(t.cssClass || ""))
				}
				getIndicatorStatus() {
					const {
						unsavedChanges: e
					} = this.state;
					if (e === Ke) return null;
					const t = !!i()(e, e => Ee(e));
					return !!i()(e, e => !Ee(e)) ? _.a.Pending : t ? _.a.Failed : _.a.Complete
				}
				render() {
					var e;
					const {
						props: t,
						state: n
					} = this, o = this.getIndicatorStatus(), i = t.pageInfo && (t.pageInfo.hasNextPage || t.pageInfo.hasPreviousPage), a = !t.flairedUserOrder.length && !i;
					return d.a.createElement(d.a.Fragment, null, (!t.isInShredditModNavExperiment || !t.subredditName) && d.a.createElement(C.c, {
						className: ae.a.topBar
					}, null !== o && d.a.createElement(w, {
						status: o
					})), d.a.createElement(C.a, {
						className: Object(m.a)(t.isInShredditModNavExperiment && ae.a.newModNavContainer)
					}, t.isInShredditModNavExperiment && t.subredditName ? Object(E.d)(t.subredditName, p.mc.Flair, "pb-xs") : d.a.createElement(C.b, null, r.fbt._("Grant user flair", null, {
						hk: "N1r42"
					}), d.a.createElement(v.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360028091332`
					})), !t.isUserFlairEnabled && d.a.createElement(g.a, {
						className: ae.a.disabledBanner,
						color: M.a.quarantine,
						icon: d.a.createElement(J.a, {
							className: ae.a.warningIcon
						}),
						title: r.fbt._("User flair has been disabled for this community", null, {
							hk: "3BBvFe"
						}),
						subtitle: r.fbt._("User flair will not be displayed in posts or comments", null, {
							hk: "3E4WaA"
						})
					}), d.a.createElement(P.b, {
						activeSearchQuery: n.searchTerm,
						onSearch: this.onSearch
					}, t.pageInfo && !n.searchTerm && d.a.createElement(O.a, {
						prevTo: Object(u.a)(Object(f.a)(`${t.origin}${t.currentPageUrl}`), {
							before: t.pageInfo.startCursor
						}),
						prevButtonEnabled: t.pageInfo.hasPreviousPage,
						prevButtonOnClick: this.onClickPrevPage,
						nextButtonEnabled: t.pageInfo.hasNextPage,
						nextButtonOnClick: this.onClickNextPage,
						nextTo: Object(u.a)(Object(f.a)(`${t.origin}${t.currentPageUrl}`), {
							after: t.pageInfo.endCursor
						})
					})), d.a.createElement("div", {
						className: ae.a.titleRow
					}, r.fbt._("Username with preview", null, {
						hk: "1RFjbI"
					}), d.a.createElement("div", {
						className: ae.a.flairDetails
					}, d.a.createElement("div", {
						className: ae.a.column
					}, r.fbt._("Flair template", null, {
						hk: "18cQfH"
					}), d.a.createElement(x.a, {
						className: ae.a.infoTooltip
					}, d.a.createElement("div", {
						className: ae.a.tooltipText
					}, r.fbt._("Flair templates determine the flair's background colors, text colors, and permissions", null, {
						hk: "4y58Eg"
					})), d.a.createElement("div", {
						className: ae.a.tooltipIconContainer
					}, d.a.createElement("div", {
						className: ae.a.tooltipIconRow
					}, d.a.createElement(Y.a, {
						className: ae.a.modIcon
					}), d.a.createElement("span", {
						className: ae.a.tooltipIconText
					}, r.fbt._("Available only to mods", null, {
						hk: "2s7Gci"
					}))), d.a.createElement("div", {
						className: ae.a.tooltipIconRow
					}, d.a.createElement(X.a, {
						className: ae.a.userIcon
					}), d.a.createElement("span", {
						className: ae.a.tooltipIconText
					}, r.fbt._("User editable", null, {
						hk: "3tIGRy"
					})))))), d.a.createElement("div", {
						className: ae.a.flairEditColumn
					}, r.fbt._("Flair text", null, {
						hk: "2ab8Up"
					}), d.a.createElement(x.a, {
						text: r.fbt._("Changes the text and emojis within the user flair", null, {
							hk: "4dBW4C"
						})
					})), d.a.createElement("div", {
						className: ae.a.column
					}, r.fbt._("Css class", null, {
						hk: "1TNNcJ"
					}), d.a.createElement(x.a, {
						text: r.fbt._("CSS classes determine styling for flair in old Reddit", null, {
							hk: "j4AU"
						})
					})))), n.searchTerm ? d.a.createElement(T.a, {
						cancelSearch: this.onCancelSearch,
						noResultsFound: !t.searchResult,
						searchTerm: n.searchTerm,
						searchPending: t.isSearchPending
					}, t.searchResult && this.renderUserRow(t.searchResult)) : t.isFlairedUsersListPending || !(null === (e = t.userFlairData) || void 0 === e ? void 0 : e.templates) ? d.a.createElement(N.a, null) : a ? d.a.createElement(de, null) : t.flairedUserOrder.map(this.renderUserRow), t.pageInfo && !n.searchTerm && d.a.createElement("div", {
						className: ae.a.bottomBarRow
					}, d.a.createElement(O.a, {
						prevTo: Object(u.a)(Object(f.a)(`${t.origin}${t.currentPageUrl}`), {
							before: t.pageInfo.startCursor
						}),
						prevButtonEnabled: t.pageInfo.hasPreviousPage,
						prevButtonOnClick: this.onClickPrevPage,
						nextButtonEnabled: t.pageInfo.hasNextPage,
						nextButtonOnClick: this.onClickNextPage,
						nextTo: Object(u.a)(Object(f.a)(`${t.origin}${t.currentPageUrl}`), {
							after: t.pageInfo.endCursor
						})
					}))))
				}
			}
			t.a = Ye(Xe(Object(D.c)(Ze)))
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/HoverCard.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/actions/snoovatarModal.ts"),
				d = n("./src/reddit/actions/tooltip.ts"),
				c = n("./src/reddit/helpers/author.ts"),
				l = n("./src/reddit/helpers/isPost.ts"),
				u = n("./src/reddit/helpers/trackers/marketplace/display-collectibles.ts"),
				m = n("./src/reddit/selectors/commentSelector.ts"),
				p = n("./src/reddit/selectors/experiments/econ/index.ts"),
				b = n("./src/reddit/selectors/gold/awardIcon.ts"),
				f = n("./src/reddit/selectors/moderatorPermissions.ts"),
				h = n("./src/reddit/selectors/modUserNotes.ts"),
				g = n("./src/reddit/selectors/posts.ts"),
				v = n("./src/reddit/selectors/profile.ts"),
				x = n("./src/reddit/selectors/structuredStyles.ts"),
				E = n("./src/reddit/selectors/subreddit.ts"),
				O = n("./src/reddit/selectors/tooltip.ts"),
				C = n("./src/reddit/selectors/user.ts"),
				A = n("./src/reddit/selectors/userFlair.ts"),
				y = n("./src/reddit/selectors/userPrefs.ts"),
				j = n("./src/reddit/selectors/platform.ts"),
				I = n("./src/reddit/components/Hovercards/AuthorHovercard/ModIdCard/async.tsx"),
				k = n("./node_modules/fbt/lib/FbtPublic.js"),
				_ = n("./src/config.ts"),
				S = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				w = n("./src/lib/lessComponent.tsx"),
				T = n("./src/lib/prettyPrintNumber/index.ts"),
				P = n("./src/reddit/components/ChatButton/index.tsx"),
				N = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				D = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				M = n("./src/reddit/components/SubscribeButton/index.tsx"),
				R = n("./src/reddit/components/UserIcon/index.tsx"),
				L = n("./src/reddit/controls/Button/index.tsx"),
				B = n("./src/reddit/endpoints/profile/info.ts"),
				F = n("./src/reddit/helpers/trackers/authorHovercard.ts"),
				U = n("./src/reddit/icons/svgs/Admin/index.tsx"),
				H = n("./src/reddit/icons/svgs/Premium/index.tsx"),
				G = n("./src/reddit/models/User/index.ts"),
				Q = n("./src/reddit/components/HumanDate/index.tsx"),
				q = n("./src/reddit/components/ProfileIdCard/AwardedLastMonth.tsx"),
				W = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.tsx"),
				z = n("./src/reddit/actions/inContextModeration.ts"),
				V = n("./src/reddit/actions/modal.ts"),
				K = n("./src/reddit/actions/subredditModeration/ban.ts"),
				Y = n("./src/reddit/constants/modals.ts"),
				J = n("./src/reddit/components/Hovercards/helpers.ts"),
				X = n("./src/reddit/icons/fonts/index.tsx"),
				Z = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				$ = n("./src/reddit/selectors/bannedUser.ts"),
				ee = n("./src/reddit/components/Hovercards/AuthorHovercard/ModActions.m.less"),
				te = n.n(ee);
			const {
				fbt: ne
			} = n("./node_modules/fbt/lib/FbtPublic.js"), se = Object(i.c)({
				hasModMailPermissions: Object(f.b)(Z.c.mail),
				isUserBanned: (e, t) => !!Object($.b)(e, {
					subredditId: t.subredditId,
					username: t.username
				}),
				user: (e, t) => Object(C.Db)(e, {
					userName: t.username
				})
			});
			class re extends r.a.Component {
				componentDidMount() {
					this.props.requestUserBanInfo()
				}
				render() {
					const {
						className: e,
						contextId: t,
						hasModMailPermissions: n,
						isUserBanned: s,
						onUnbanUser: o,
						sendEvent: i,
						toggleBanModal: a,
						toggleMuteModal: d
					} = this.props;
					return r.a.createElement("div", {
						className: e
					}, s ? r.a.createElement(J.a, {
						role: "button",
						onClick: () => {
							o(this.props.user.id), i(F.e(t))
						}
					}, r.a.createElement(X.a, {
						name: "ban",
						isFilled: !0,
						className: te.a.icon
					}), ne._("Unban User", null, {
						hk: "1aASyW"
					})) : r.a.createElement(J.a, {
						role: "button",
						onClick: () => {
							a(), i(F.a(t))
						}
					}, r.a.createElement(X.a, {
						name: "ban",
						className: te.a.icon
					}), ne._("Ban User", null, {
						hk: "3OhuLx"
					})), n && r.a.createElement(J.a, {
						role: "button",
						onClick: () => {
							d(), i(F.d(t))
						}
					}, r.a.createElement(X.a, {
						name: "mod_mute",
						className: te.a.icon
					}), ne._("Mute User", null, {
						hk: "3MCujH"
					})))
				}
			}
			var oe = Object(o.b)(se, (e, t) => {
					let {
						username: n,
						subredditId: s,
						contextId: r
					} = t;
					return {
						onUnbanUser: t => e(Object(K.e)(s, t)),
						requestUserBanInfo: () => e(Object(K.c)(s, {
							username: n
						})),
						toggleBanModal: () => {
							e(Object(z.c)({
								username: n,
								subredditId: s,
								contextId: r
							})), e(Object(K.a)(s, n))
						},
						toggleMuteModal: () => {
							e(Object(z.d)({
								username: n,
								subredditId: s,
								contextId: r
							})), e(Object(V.i)(Y.a.MUTE_USER))
						}
					}
				})(re),
				ie = n("./src/reddit/actions/userFlair/index.ts");
			const {
				fbt: ae
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			var de = Object(o.b)(null, (e, t) => ({
					onToggleUserFlairModal: () => e(Object(ie.g)(t.subredditId, t.username))
				}))(e => r.a.createElement(J.a, {
					role: "button",
					onClick: () => {
						e.onToggleUserFlairModal(), e.sendEvent(F.c(e.contextId))
					}
				}, r.a.createElement(X.a, {
					name: "tag",
					className: te.a.icon
				}), ae._("Edit user flair", null, {
					hk: "4mTxM"
				}))),
				ce = n("./src/reddit/components/Hovercards/AuthorHovercard/userOptions.m.less"),
				le = n.n(ce);

			function ue() {
				return (ue = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const me = w.a.wrapped(R.a, "UserIcon", le.a),
				pe = w.a.wrapped(M.a, "SubscribeButton", le.a),
				be = w.a.wrapped(P.b, "ChatButton", le.a),
				fe = w.a.wrapped(H.a, "PremiumIcon", le.a),
				he = w.a.wrapped(S.a, "UserNameLink", le.a),
				ge = w.a.div("UserNameMetaData", le.a),
				ve = w.a.div("MetaDataItem", le.a),
				xe = w.a.div("Bullet", le.a),
				Ee = w.a.div("UserNameContainer", le.a),
				Oe = w.a.div("KarmaGrid", le.a),
				Ce = w.a.div("GenericKarma", le.a),
				Ae = w.a.div("KarmaCount", le.a),
				ye = w.a.div("GenericKarmaLabel", le.a),
				je = w.a.div("BannerImage", le.a),
				Ie = w.a.div("UserContainer", le.a),
				ke = w.a.div("BottomSpacer", le.a),
				_e = w.a.div("Container", le.a),
				Se = e => r.a.createElement("div", null, r.a.createElement("div", null, r.a.createElement(he, {
					to: `/user/${e.userName}/`
				}, e.title || e.userName), e.user.isEmployee && r.a.createElement(U.a, {
					className: le.a.adminIcon,
					title: k.fbt._("Reddit admin", null, {
						hk: "15wBTE"
					})
				}), e.user.isGold && r.a.createElement(S.a, {
					to: "/premium"
				}, r.a.createElement(fe, null))), r.a.createElement(ge, null, r.a.createElement(ve, null, `u/${e.userName}`, r.a.createElement(xe, null, "")), r.a.createElement(ve, null, (e.user.createdUtc || e.user.created) && r.a.createElement(Q.d, {
					seconds: e.user.createdUtc || e.user.created
				})))),
				we = e => {
					const {
						user: {
							karma: t
						}
					} = e, n = {
						...B.a,
						...t
					};
					return r.a.createElement(Oe, null, r.a.createElement(Ce, null, r.a.createElement(Ae, null, Object(T.b)(n.fromPosts)), r.a.createElement(ye, null, k.fbt._({
						"*": "Post Karma",
						_1: " Post Karma"
					}, [k.fbt._plural(n.fromPosts)], {
						hk: "3K4oaH"
					}))), r.a.createElement(Ce, null, r.a.createElement(Ae, null, Object(T.b)(n.fromComments)), r.a.createElement(ye, null, k.fbt._({
						"*": "Comment Karma",
						_1: " Comment Karma"
					}, [k.fbt._plural(n.fromComments)], {
						hk: "3gKRx9"
					}))))
				},
				Te = e => {
					var t, n;
					const {
						className: s,
						contextId: o,
						currentUser: i,
						hideNSFWPref: a,
						hoverId: d,
						isLoggedIn: c,
						onClickSnoovatar: l,
						moderatorPermissions: u,
						prefersReducedAnimations: m,
						profile: p,
						sendEvent: b,
						style: f,
						subredditId: h,
						topAwardIcon: g,
						userName: v,
						user: x,
						userFlair: E,
						isCurrentUserBanned: O,
						userProfileStyles: C,
						acceptChats: A,
						isCommentAuthorBlocked: y
					} = e;
					if (!x) return r.a.createElement(_e, {
						style: f
					});
					const j = !!i && Object(G.e)(i) === v,
						I = !!(null == i ? void 0 : i.snoovatarFullBodyAsset),
						S = x.accountIcon || `${_.a.assetPath}/img/snoo_user_placeholder.png`,
						w = null == u ? void 0 : u.flair,
						T = null == u ? void 0 : u.access,
						P = (null == E ? void 0 : E.templateIds) && (null === (t = null == E ? void 0 : E.templateIds) || void 0 === t ? void 0 : t.length) > 0,
						D = null === (n = null == E ? void 0 : E.displaySettings) || void 0 === n ? void 0 : n.isEnabled,
						{
							awardedLastMonth: M
						} = x,
						R = !!x.snoovatarFullBodyAsset,
						B = x.isNSFW && a;
					let U;
					return U = R ? !B && C && C.bannerBackgroundImage || void 0 : B ? `${_.a.assetPath}/img/user-info-banner.png` : e.user.bannerImage, r.a.createElement(_e, {
						className: s,
						id: d,
						style: f
					}, !R && U && r.a.createElement(je, {
						style: {
							backgroundImage: `url('${U}')`
						}
					}), r.a.createElement(Ie, null, R ? r.a.createElement(W.a, {
						isHovercard: !0,
						bannerBackgroundImage: U,
						compact: !0,
						currentUserHasSnoovatar: I,
						isEmployee: x.isEmployee,
						isGold: x.isGold,
						isNSFW: x.isNSFW,
						isOwnProfile: j,
						onClickSnoovatar: () => l && l(),
						prefersReducedAnimations: !!m,
						snoovatarUrl: x.snoovatarFullBodyAsset,
						title: null == p ? void 0 : p.title,
						userCreated: x.created,
						username: v,
						url: `/user/${e.userName}/`
					}) : r.a.createElement(Ee, null, r.a.createElement(me, {
						iconUrl: S,
						isNSFW: x.isNSFW,
						userName: v
					}), r.a.createElement(Se, {
						title: null == p ? void 0 : p.title,
						user: x,
						userName: v
					})), r.a.createElement(we, {
						user: x
					}), M && r.a.createElement(q.a, {
						recentAwardings: M,
						topAwardIcon: g,
						username: v
					}), c && !j && !O && A && !y && r.a.createElement(be, {
						contextId: o,
						priority: L.c.Secondary,
						userId: x.id,
						text: k.fbt._("Start Chat", null, {
							hk: "2mfqRE"
						}),
						isFullWidth: !0,
						pageType: "user_hovercard"
					}), x.hasUserProfile && !O && !y && !j && x.enableFollowers && r.a.createElement(pe, {
						identifier: {
							name: e.user.username,
							type: "profile"
						},
						getEventFactory: e => Object(F.h)(e ? "unfollow" : "follow", o),
						isFullWidth: !0,
						small: !0
					})), T && o && !j && h && r.a.createElement(oe, {
						contextId: o,
						subredditId: h,
						sendEvent: b,
						username: v
					}), w && o && P && D && h && r.a.createElement(de, {
						contextId: o,
						subredditId: h,
						sendEvent: b,
						username: v
					}), r.a.createElement(N.i, {
						contextId: o,
						subredditId: h,
						user: x
					}), !(T || c) && r.a.createElement(ke, null))
				},
				Pe = Object(D.a)(Te),
				Ne = e => {
					const t = e.activeTooltipId === e.tooltipId && !e.collapsed;
					return r.a.createElement(Pe, ue({
						isOpen: t
					}, e))
				};
			Ne.WrappedComponent = Te;
			var De = Ne;
			const Me = Object(i.c)({
					activeTooltipId: O.a,
					currentUser: C.m,
					isLoggedIn: C.S,
					hideNSFWPref: C.H,
					moderatorPermissions: (e, t) => {
						let {
							subredditId: n
						} = t;
						return n ? Object(f.n)(e, {
							subredditId: n
						}) : void 0
					},
					prefersReducedAnimations: y.d,
					profile: (e, t) => {
						let {
							userName: n
						} = t;
						return Object(v.k)(e, {
							profileName: n
						})
					},
					topAwardIcon: (e, t) => {
						let {
							userName: n
						} = t;
						return Object(b.e)(e, {
							userName: n,
							minSize: 32
						})
					},
					user: C.Db,
					userFlair: (e, t) => {
						let {
							subredditId: n
						} = t;
						return n ? Object(A.d)(e, {
							subredditId: n
						}) : void 0
					},
					isCurrentUserBanned: (e, t) => !!Object(E.p)(t) && Object(E.ib)(e, t),
					userProfileStyles: (e, t) => Object(x.m)(e, Object(v.o)(e, t.userName)),
					acceptChats: (e, t) => {
						const n = Object(v.i)(e, {
							profileName: t.userName
						});
						return !n || n.acceptChats
					},
					isModWithUserNotesPermissions: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = Object(j.e)(e),
							r = n || s && Object(E.I)(e, s.name);
						return !!r && Object(f.i)(e, r)
					},
					trophyCase: (e, t) => Object(v.t)(e, Object(v.o)(e, t.userName)),
					isNightMode: C.fb,
					lastAuthorModNote: (e, t) => {
						if (!t.contextId) return;
						const n = Object(l.a)(t.contextId) ? Object(g.F)(e, {
							postId: t.contextId
						}) : Object(m.c)(e, {
							commentId: t.contextId
						});
						return Object(h.b)(e, null == n ? void 0 : n.authorId, t.subredditId)
					},
					userIsSubscriber: (e, t) => {
						let {
							userName: n
						} = t;
						return Object(E.jb)(e, {
							identifier: {
								name: n,
								type: "profile"
							}
						})
					}
				}),
				Re = Object(o.b)(Me, (e, t) => ({
					onClickSnoovatar: () => e(Object(a.b)({
						clickSource: "user_hovercard"
					})),
					onHideTooltip: () => e(Object(d.i)())
				})),
				Le = e => e.isModWithUserNotesPermissions ? r.a.createElement(I.b, {
					activeTooltipId: e.activeTooltipId,
					contextId: e.contextId,
					currentUser: e.currentUser,
					isLoggedIn: e.isLoggedIn,
					hideNSFWPref: e.hideNSFWPref,
					hoverId: e.hoverId,
					moderatorPermissions: e.moderatorPermissions,
					prefersReducedAnimations: e.prefersReducedAnimations,
					profile: e.profile,
					subredditId: e.subredditId,
					tooltipId: e.tooltipId,
					user: e.user,
					isCurrentUserBanned: e.isCurrentUserBanned,
					userName: e.userName,
					userProfileStyles: e.userProfileStyles,
					acceptChats: e.acceptChats,
					isCommentAuthorBlocked: e.isCommentAuthorBlocked,
					collapsed: e.collapsed,
					trophyCase: e.trophyCase,
					isNightMode: e.isNightMode,
					lastAuthorModNote: e.lastAuthorModNote,
					userIsSubscriber: e.userIsSubscriber
				}) : Object(c.a)(e.userName) ? null : r.a.createElement(De, {
					activeTooltipId: e.activeTooltipId,
					contextId: e.contextId,
					currentUser: e.currentUser,
					isLoggedIn: e.isLoggedIn,
					hideNSFWPref: e.hideNSFWPref,
					hoverId: e.hoverId,
					moderatorPermissions: e.moderatorPermissions,
					onClickSnoovatar: e.onClickSnoovatar,
					prefersReducedAnimations: e.prefersReducedAnimations,
					profile: e.profile,
					sendEvent: e.sendEvent,
					subredditId: e.subredditId,
					topAwardIcon: e.topAwardIcon,
					tooltipId: e.tooltipId,
					tooltipType: e.tooltipType,
					user: e.user,
					userFlair: e.userFlair,
					isCurrentUserBanned: e.isCurrentUserBanned,
					userName: e.userName,
					userProfileStyles: e.userProfileStyles,
					acceptChats: e.acceptChats,
					isCommentAuthorBlocked: e.isCommentAuthorBlocked,
					collapsed: e.collapsed
				});
			t.a = Re(e => {
				const t = Object(o.e)(p.o);
				return Object(s.useEffect)(() => {
					e.user && Object(u.a)({
						sendEvent: e.sendEvent,
						user: e.user,
						pageType: "user_hovercard",
						isDisplayCollectiblesEnabled: t
					})
				}, [e.user]), r.a.createElement(Le, e)
			})
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/ModActions.m.less": function(e, t, n) {
			e.exports = {
				icon: "xd9vrdS8_V6IVus6-mHAM"
			}
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/Hovercards/HoverDiv/index.tsx"),
				i = n("./src/reddit/components/Hovercards/AuthorHovercard/HoverCard.tsx"),
				a = n("./src/reddit/components/TrackingHelper/index.tsx");
			t.a = Object(a.c)(e => {
				const t = `${e.tooltipId}-hover-id`;
				return r.a.createElement(o.a, {
					className: e.wrapperClassName,
					hoverId: t,
					sendHoverEvent: e.sendHoverCardEvent,
					tooltipId: e.tooltipId,
					authorOrSubredditName: e.user
				}, e.children, r.a.createElement(i.a, {
					className: e.className,
					hoverId: t,
					sendEvent: e.sendEvent,
					subredditId: e.subredditId,
					tooltipId: e.tooltipId,
					tooltipType: e.tooltipType,
					userName: e.user
				}))
			})
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/userOptions.m.less": function(e, t, n) {
			e.exports = {
				ChatButton: "_3OdnAY8EYU3x_Nni3KnKwI",
				chatButton: "_3OdnAY8EYU3x_Nni3KnKwI",
				UserIcon: "_3_NawY8A3QCHkZUHnxDxUP",
				userIcon: "_3_NawY8A3QCHkZUHnxDxUP",
				SubscribeButton: "yFByQg8RzENoqoOt0ysAk",
				subscribeButton: "yFByQg8RzENoqoOt0ysAk",
				PremiumIcon: "_3YJqiyvx8zFvv30tmg36S-",
				premiumIcon: "_3YJqiyvx8zFvv30tmg36S-",
				Token: "_2U0P3n4v75sHsDvQmSKNz3",
				token: "_2U0P3n4v75sHsDvQmSKNz3",
				UserNameLink: "_1oT4pd8QlZQZ1wGOk9VAaQ",
				userNameLink: "_1oT4pd8QlZQZ1wGOk9VAaQ",
				UserNameMetaData: "_1wu7a98opA-mU9WUQpJIuF",
				userNameMetaData: "_1wu7a98opA-mU9WUQpJIuF",
				GildedLastMonthDisplay: "_19NlUDUSw7ra6wC0luJwKV",
				gildedLastMonthDisplay: "_19NlUDUSw7ra6wC0luJwKV",
				Bullet: "_2dfF2p_dwLpL5C-8pAvdbL",
				bullet: "_2dfF2p_dwLpL5C-8pAvdbL",
				MetaDataItem: "RcL4UXH2ABHT3YpYzu3ms",
				metaDataItem: "RcL4UXH2ABHT3YpYzu3ms",
				UserNameContainer: "J9OjkO5NR8gsgJUQrk2Ft",
				userNameContainer: "J9OjkO5NR8gsgJUQrk2Ft",
				KarmaGrid: "_1T5Mo-6GI-SCbGJJ9xZ2N7",
				karmaGrid: "_1T5Mo-6GI-SCbGJJ9xZ2N7",
				GenericKarma: "_1Tg84WxamVCCD1zg-nbbP8",
				genericKarma: "_1Tg84WxamVCCD1zg-nbbP8",
				KarmaCount: "_18aX_pAQub_mu1suz4-i8j",
				karmaCount: "_18aX_pAQub_mu1suz4-i8j",
				GenericKarmaLabel: "EtlFWXCmzvjyd92eABb-5",
				genericKarmaLabel: "EtlFWXCmzvjyd92eABb-5",
				InfoLink: "_2qjqkYRKCjuqB4VRr2duCK",
				infoLink: "_2qjqkYRKCjuqB4VRr2duCK",
				BannerImage: "_1l9DXI5VaWcxjbz23v5b6X",
				bannerImage: "_1l9DXI5VaWcxjbz23v5b6X",
				UserContainer: "_m7PpFuKATP9fZF4xKf9R",
				userContainer: "_m7PpFuKATP9fZF4xKf9R",
				BottomSpacer: "_2D-HmwsbsNkTnIiPO4zcqb",
				bottomSpacer: "_2D-HmwsbsNkTnIiPO4zcqb",
				UserActionLink: "_1Sy8bDpK6p4JRHy1yB1Xyk",
				userActionLink: "_1Sy8bDpK6p4JRHy1yB1Xyk",
				Container: "_1sbZnfdaxhCOFVUCJ3Z75m",
				container: "_1sbZnfdaxhCOFVUCJ3Z75m",
				adminIcon: "_2aJuBKF3mo4YJS4YFkeU9a"
			}
		},
		"./src/reddit/components/Hovercards/SubredditHovercard/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx"),
				r = n("./src/lib/loadWithRetries/index.ts");
			const o = () => null;
			t.a = Object(s.a)({
				ErrorComponent: o,
				getComponent: () => Object(r.a)(() => n.e("SubredditHovercard").then(n.bind(null, "./src/reddit/components/Hovercards/SubredditHovercard/_SubredditHovercard.tsx"))).then(e => e.default),
				LoadingComponent: o
			})
		},
		"./src/reddit/components/HumanDate/HumanDate.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/humanizeDate/index.ts"),
				i = n("./src/reddit/hooks/useLocale.ts");
			t.a = function(e) {
				let {
					seconds: t,
					...n
				} = e;
				var s;
				const a = Object(i.a)(),
					d = {
						...n,
						locale: null !== (s = n.locale) && void 0 !== s ? s : a
					};
				return r.a.createElement(r.a.Fragment, null, Object(o.a)(t, d))
			}
		},
		"./src/reddit/components/HumanDate/HumanDateTime.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				i = n("./src/lib/constants/index.ts");
			var a = n("./src/reddit/hooks/useLocale.ts");
			t.a = function(e) {
				let {
					seconds: t,
					locale: n
				} = e;
				const s = Object(a.a)(),
					d = null != n ? n : s;
				return r.a.createElement(r.a.Fragment, null, function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o.DEFAULT_LOCALE;
					const n = e * i.Xb;
					return new Date(n).toLocaleString(t, {
						weekday: "short",
						month: "short",
						year: "numeric",
						day: "2-digit",
						hour: "2-digit",
						minute: "2-digit",
						second: "2-digit",
						timeZoneName: "long"
					})
				}(t, d))
			}
		},
		"./src/reddit/components/HumanDate/TimeAgo.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/timeAgo/index.ts"),
				i = n("./src/reddit/hooks/useLocale.ts");
			t.a = function(e) {
				let {
					seconds: t,
					...n
				} = e;
				var s;
				const a = Object(i.a)(),
					d = {
						...n,
						locale: null !== (s = n.locale) && void 0 !== s ? s : a
					};
				return r.a.createElement(r.a.Fragment, null, Object(o.d)(t, d))
			}
		},
		"./src/reddit/components/HumanDate/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s.a
			})), n.d(t, "a", (function() {
				return r.a
			})), n.d(t, "b", (function() {
				return o.a
			})), n.d(t, "c", (function() {
				return f
			}));
			var s = n("./src/reddit/components/HumanDate/TimeAgo.tsx"),
				r = n("./src/reddit/components/HumanDate/HumanDate.tsx"),
				o = n("./src/reddit/components/HumanDate/HumanDateTime.tsx"),
				i = n("./node_modules/react/index.js"),
				a = n.n(i),
				d = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				c = n("./node_modules/fbt/lib/FbtPublic.js"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/lib/eventTools/index.ts");

			function m(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : d.DEFAULT_LOCALE;
				return e.toLocaleDateString(t, {
					month: "numeric",
					day: "numeric"
				})
			}

			function p(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
					s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : d.DEFAULT_LOCALE;
				const r = Object(u.e)(e, t),
					o = new Date(e * l.Xb);
				let i;
				if (r === u.a.Live || n) return c.fbt._("Now", null, {
					hk: "Prpcg"
				});
				return r === u.a.Future ? i = Object(u.d)(e) ? c.fbt._("Today", null, {
					hk: "1sZpnp"
				}).toString() : Object(u.b)(e) >= 5 ? m(o, s) : function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : d.DEFAULT_LOCALE;
					return e.toLocaleDateString(t, {
						weekday: "long"
					})
				}(o, s) : r === u.a.Past && (i = Object(u.d)(e) ? c.fbt._("Today", null, {
					hk: "1sZpnp"
				}).toString() : m(o, s)), `${i} @ ${function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:d.DEFAULT_LOCALE;return e.toLocaleTimeString(t,{hour12:!0,hour:"numeric",minute:"2-digit"}).replace(/ /g,"").toUpperCase()}(o,s)}`
			}
			var b = n("./src/reddit/hooks/useLocale.ts");
			var f = function(e) {
				let {
					startTime: t,
					endTime: n,
					isLive: s,
					locale: r
				} = e;
				const o = Object(b.a)(),
					i = null != r ? r : o;
				return a.a.createElement(a.a.Fragment, null, p(t, n, s, i))
			};
			n("./src/lib/humanizeUTCDate/index.tsx")
		},
		"./src/reddit/components/IdentityAndIcon/index.m.less": function(e, t, n) {
			e.exports = {
				UserIconContainer: "_3eMur7R8H7sp0xvDIzN-zw",
				userIconContainer: "_3eMur7R8H7sp0xvDIzN-zw",
				UserIcon: "_2bT01xadnKvuBWLfFkZwwZ",
				userIcon: "_2bT01xadnKvuBWLfFkZwwZ",
				UserLink: "_2Dm4wqGsnmkd9xKJ1QdbtM",
				userLink: "_2Dm4wqGsnmkd9xKJ1QdbtM"
			}
		},
		"./src/reddit/components/IdentityAndIcon/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				d = n("./src/reddit/components/UserIcon/index.tsx"),
				c = n("./src/reddit/controls/InternalLink/index.tsx"),
				l = n("./src/reddit/models/Subreddit/index.ts"),
				u = n("./src/reddit/components/IdentityAndIcon/index.m.less"),
				m = n.n(u);
			const p = i.a.span("UserIconContainer", m.a),
				b = i.a.wrapped(d.a, "UserIcon", m.a),
				f = i.a.wrapped(c.default, "UserLink", m.a);
			t.a = e => {
				const t = e.widgetDataType === l.b.subredditMuting ? `${s.a.redditUrl}/r/${e.username}` : `${s.a.redditUrl}/user/${e.username}`,
					n = o.a.createElement(o.a.Fragment, null, o.a.createElement(p, {
						className: e.iconClassName,
						style: {
							height: e.iconSize || "32px",
							width: e.iconSize || "32px"
						}
					}, o.a.createElement(b, {
						iconUrl: e.userIcon,
						isNSFW: !1,
						userName: e.username
					})), e.username);
				return o.a.createElement(f, {
					className: e.className,
					to: t
				}, e.tooltipId && e.sendHoverCardEvent ? o.a.createElement(a.a, {
					subredditId: e.subredditId,
					user: e.username,
					sendHoverCardEvent: e.sendHoverCardEvent,
					tooltipId: e.tooltipId
				}, n) : n)
			}
		},
		"./src/reddit/components/ImageWithFallback/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const i = e => new Promise((t, n) => {
				const s = new Image;
				s.onload = () => t(s), s.onerror = n, s.src = e
			});
			t.a = e => {
				let {
					src: t,
					lowSrc: n = t,
					errorSrc: a = n,
					...d
				} = e;
				const c = Object(s.createRef)();
				return i(t).then(() => {
					c.current && (c.current.src = t)
				}).catch(() => {
					c.current && (c.current.src = a)
				}), r.a.createElement("img", o({
					ref: c,
					src: n
				}, d))
			}
		},
		"./src/reddit/components/InboxBanner/CommonBanner.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "FjkUHssa96HMV17_qcQt6",
				wrapper: "FjkUHssa96HMV17_qcQt6",
				Content: "_27ZWqn-n6gBKDTqLbt0uk1",
				content: "_27ZWqn-n6gBKDTqLbt0uk1",
				Heading: "ZtxCbLGmd-U6DH5-RsBJV",
				heading: "ZtxCbLGmd-U6DH5-RsBJV",
				Title: "_2Iz2pxeBTmtn5cilveUdwj",
				title: "_2Iz2pxeBTmtn5cilveUdwj",
				TitleIcon: "_3wZ9NKCStyQ9_XMz6jRbkL",
				titleIcon: "_3wZ9NKCStyQ9_XMz6jRbkL",
				Body: "_2GYO5AeH0SYqV0W_IYw7C_",
				body: "_2GYO5AeH0SYqV0W_IYw7C_",
				BodyText: "_1Tw_Z3ZCizARHq8mDvXtJp",
				bodyText: "_1Tw_Z3ZCizARHq8mDvXtJp",
				Thumbnail: "_3VFSVmukKEY-C06RJldU7n",
				thumbnail: "_3VFSVmukKEY-C06RJldU7n",
				ActionButtons: "_45hSSzyMPM5pmBx74E25U",
				actionButtons: "_45hSSzyMPM5pmBx74E25U",
				noMargin: "aaIwLr1Mbi15Al1BCmB8w",
				CloseButton: "_3xbx2cMOI83xtKSIZfzaeW",
				closeButton: "_3xbx2cMOI83xtKSIZfzaeW",
				SecondaryButton: "_1cOP2U6TmJgXE_lLuvdAk",
				secondaryButton: "_1cOP2U6TmJgXE_lLuvdAk",
				CloseButtonIcon: "_3uR0NalufS44rp_5yMF15w",
				closeButtonIcon: "_3uR0NalufS44rp_5yMF15w"
			}
		},
		"./src/reddit/components/InboxBanner/CommonBanner.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/opener/index.ts"),
				d = n("./src/reddit/actions/inboxBanner/index.ts"),
				c = n("./src/reddit/controls/Button/index.tsx"),
				l = n("./src/reddit/helpers/trackers/inbox.ts"),
				u = n("./src/reddit/helpers/localStorage/index.ts"),
				m = n("./src/reddit/hooks/useTracking.ts"),
				p = n("./src/reddit/icons/fonts/index.tsx"),
				b = n("./src/reddit/models/inboxBanner/index.ts");
			const f = e => e.notificationsInbox.banner,
				h = e => {
					return f(e).banners
				};
			var g = n("./src/reddit/selectors/user.ts"),
				v = n("./src/reddit/components/InboxBanner/CommonBanner.m.less"),
				x = n.n(v);
			const E = e => {
				let {
					isFromMiniInbox: t,
					banner: n,
					userId: h
				} = e;
				var g, v, E, O, C, A, y, j, I, k, _, S, w, T, P, N, D;
				const M = Object(o.d)(),
					R = Object(m.a)(),
					[L, B, F] = function(e, t, n) {
						const [r, o] = Object(s.useState)(Object(u.s)(e, t) || 0), i = Object(s.useCallback)(() => {
							o(r + 1), Object(u.Cb)(e, t, r + 1)
						}, []), a = Object(s.useCallback)(() => {
							n > 0 && (o(n), Object(u.Cb)(e, t, n))
						}, []);
						return [r, i, a]
					}(h, n.notificationName, (null === (g = n.persistence) || void 0 === g ? void 0 : g.maxViews) || 0),
					[U, H] = Object(s.useState)(!1),
					[G, Q] = Object(s.useState)(!1),
					q = Object(o.e)(e => ((e, t) => {
						var n;
						return !!(null === (n = f(e).dismissedBanners) || void 0 === n ? void 0 : n.find(e => e === t))
					})(e, n.notificationName));
				Object(s.useEffect)(() => {
					B(), t ? (R(Object(l.y)(n.notificationName)), R(Object(l.z)(n.notificationName))) : (R(Object(l.o)(n.notificationName)), R(Object(l.p)(n.notificationName)))
				}, []);
				const W = null === (v = null == n ? void 0 : n.persistence) || void 0 === v ? void 0 : v.maxViews;
				if (!n || W && L > W) return null;
				const z = !!(null == n ? void 0 : n.primaryCta),
					V = !!(null == n ? void 0 : n.secondaryCta),
					K = !!(null == n ? void 0 : n.titleImage),
					Y = !!(null == n ? void 0 : n.thumbnailImageUrl),
					J = () => {
						var e;
						(null === (e = n.persistence) || void 0 === e ? void 0 : e.isDismissible) && (F(), M(Object(d.a)(n.notificationName)))
					},
					X = {
						backgroundColor: U ? null === (E = null == n ? void 0 : n.primaryCta) || void 0 === E ? void 0 : E.colors.hoverHex : null === (O = null == n ? void 0 : n.primaryCta) || void 0 === O ? void 0 : O.colors.backgroundHex,
						color: null === (C = null == n ? void 0 : n.primaryCta) || void 0 === C ? void 0 : C.text.colorText,
						borderColor: null === (A = null == n ? void 0 : n.primaryCta) || void 0 === A ? void 0 : A.colors.borderHex
					},
					Z = {
						backgroundColor: G ? null === (y = null == n ? void 0 : n.secondaryCta) || void 0 === y ? void 0 : y.colors.hoverHex : null === (j = null == n ? void 0 : n.secondaryCta) || void 0 === j ? void 0 : j.colors.backgroundHex,
						color: null === (I = null == n ? void 0 : n.secondaryCta) || void 0 === I ? void 0 : I.text.colorText,
						borderColor: null === (k = null == n ? void 0 : n.secondaryCta) || void 0 === k ? void 0 : k.colors.borderHex
					};
				return q ? null : r.a.createElement("div", {
					className: x.a.Wrapper,
					style: {
						backgroundImage: `url(${n.bodyBackgroundImage})`
					},
					onClick: e => {
						e.stopPropagation(), Object(a.e)(n.linkUrl, "_blank"), J(), R(t ? Object(l.x)(n.notificationName, l.b.BANNER) : Object(l.n)(n.notificationName, l.b.BANNER))
					}
				}, r.a.createElement("div", {
					className: x.a.Content
				}, r.a.createElement("div", {
					className: x.a.Heading
				}, K ? r.a.createElement("img", {
					className: x.a.TitleIcon,
					src: n.titleImage
				}) : r.a.createElement("div", {
					className: x.a.Title,
					style: {
						color: null === (_ = n.titleText) || void 0 === _ ? void 0 : _.colorText
					}
				}, null === (S = n.titleText) || void 0 === S ? void 0 : S.text)), r.a.createElement("div", {
					className: x.a.Body
				}, r.a.createElement("div", {
					className: x.a.BodyText,
					style: {
						color: null === (w = n.bodyText) || void 0 === w ? void 0 : w.colorText
					}
				}, null === (T = n.bodyText) || void 0 === T ? void 0 : T.text), Y && r.a.createElement("img", {
					src: n.thumbnailImageUrl,
					className: x.a.Thumbnail
				})), z || V && r.a.createElement("div", {
					className: Object(i.a)(x.a.ActionButtons, {
						[x.a.noMargin]: Y
					})
				}, z && r.a.createElement(c.t, {
					text: null === (P = n.primaryCta) || void 0 === P ? void 0 : P.text.text,
					priority: c.c.Tertiary,
					size: c.d.XS,
					onClick: e => {
						var s;
						e.stopPropagation(), (null === (s = n.primaryCta) || void 0 === s ? void 0 : s.actionType) === b.a.GOTO && n.primaryCta.url && Object(a.e)(n.primaryCta.url, "_blank"), J(), R(t ? Object(l.x)(n.notificationName, l.b.CTA_1) : Object(l.n)(n.notificationName, l.b.CTA_1))
					},
					style: {
						...X
					},
					onMouseEnter: () => H(!0),
					onMouseLeave: () => H(!1)
				}), V && r.a.createElement(c.t, {
					text: null === (N = n.secondaryCta) || void 0 === N ? void 0 : N.text.text,
					priority: c.c.Plain,
					size: c.d.XS,
					className: x.a.SecondaryButton,
					onClick: e => {
						e.stopPropagation(), (null == n ? void 0 : n.secondaryCta) && (n.secondaryCta.actionType === b.a.GOTO && n.secondaryCta.url && Object(a.e)(n.secondaryCta.url, "_blank"), J(), R(t ? Object(l.x)(n.notificationName, l.b.CTA_2) : Object(l.n)(n.notificationName, l.b.CTA_2)))
					},
					style: {
						...Z
					},
					onMouseEnter: () => Q(!0),
					onMouseLeave: () => Q(!1)
				}))), (null === (D = n.persistence) || void 0 === D ? void 0 : D.isDismissible) && r.a.createElement(c.t, {
					Icon: Object(p.b)("close_fill"),
					className: x.a.CloseButton,
					size: c.d.XXS,
					iconClassName: x.a.CloseButtonIcon,
					priority: c.c.Plain,
					onClick: e => {
						e.stopPropagation(), J(), R(t ? Object(l.x)(n.notificationName, l.b.DISMISS) : Object(l.n)(n.notificationName, l.b.DISMISS))
					}
				}))
			};
			t.a = e => {
				let {
					isFromMiniInbox: t
				} = e;
				const n = Object(o.e)(h),
					s = Object(o.e)(g.k);
				return (null == n ? void 0 : n.length) && s ? r.a.createElement(r.a.Fragment, null, null == n ? void 0 : n.map(e => r.a.createElement(E, {
					banner: e,
					isFromMiniInbox: t,
					key: e.notificationName,
					userId: s
				}))) : null
			}
		},
		"./src/reddit/components/InboxBanner/index.m.less": function(e, t, n) {
			e.exports = {
				underlineLink: "_3vOO3WyD7yteL4Rr9E1i2y",
				banner: "_34mO86zNIysmcISYIe8gVT",
				bannerTitleContainer: "rh7yf_ejK6H75L6jZkb6C",
				bannerTitle: "V_VLkmdSrXqz92-5vad5F",
				bannerDescription: "_1vbdR0mal1nPuuTOZIemLg",
				closeButton: "-Fi_Lr4OQ6XfCIiufmgxa",
				bannerButtonsContainer: "_1a9VL63O5el1YN7RuPoDLy",
				button: "_1mejKTw8yWGmudymV6GufX",
				primaryButton: "_1mR2YFl21PdJDX9T7ykA7c",
				welcomeBanner: "_3QWgBcfZuqQ6TlxZa6uYkS",
				dnPromptBanner: "_3IIpKn1IlCXgko4sLMEie1",
				policyBanner: "GLgkxGZkPymWBWeRISXBe",
				modalHeader: "_2Ggqgl_RyXu2U-mPYZSaCk",
				modalTitle: "_2C3YUpN8pGzseZOBK0tl0I",
				modalCloseIcon: "_2BTQI8_1TIwwfdecOP_j6o",
				modalListItem: "-sXLpWAGj2HMFvzRvH_bC",
				modalListIcon: "_3UO2hA0CsOqKl1bYybPZGs",
				garlicBreadBanner: "SVn8TtBVFQ-GZUhog511q",
				bannerContainer: "V5Q75l1gWtGpBZEehJiGH",
				bannerDataContainer: "SIz6ozr7aqewYGVSLfSf6",
				bannerImage: "_2zetWw7f4W-0OWrUYJHPQ-"
			}
		},
		"./src/reddit/components/InboxTooltip/Component.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return J
			})), n.d(t, "b", (function() {
				return ee
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/notifications/index.ts"),
				a = n("./src/lib/notifications/constants.ts"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/components/BadgeCounter/index.tsx"),
				u = n("./node_modules/@researchgate/react-intersection-observer/lib/es/index.js"),
				m = n("./node_modules/lodash/omit.js"),
				p = n.n(m),
				b = n("./src/reddit/components/InboxBanner/CommonBanner.tsx"),
				f = n("./src/reddit/controls/Button/index.tsx"),
				h = n("./src/reddit/helpers/trackers/inbox.ts"),
				g = n("./src/reddit/hooks/useTracking.ts"),
				v = n("./src/reddit/icons/fonts/index.tsx"),
				x = n("./src/reddit/components/InboxBanner/index.m.less"),
				E = n.n(x);
			var O = e => {
				let {
					className: t,
					closeButtonText: n,
					closeIcon: s,
					descriptionText: r,
					primaryButtonText: i,
					titleText: a,
					onClose: c,
					onClick: l
				} = e;
				const u = Object(g.a)();
				return o.a.createElement("div", {
					className: Object(d.a)(E.a.banner, t)
				}, o.a.createElement("div", {
					className: E.a.bannerTitleContainer
				}, a && o.a.createElement("h4", {
					className: E.a.bannerTitle
				}, a), s && o.a.createElement(f.t, {
					onClick: e => {
						c && c(e), u(Object(h.q)({
							dnPromptAction: "dismiss"
						}))
					},
					Icon: Object(v.b)("close_fill"),
					className: Object(d.a)(E.a.closeIcon, E.a.closeButton),
					size: f.d.XXS,
					priority: f.c.Plain
				})), r && o.a.createElement("p", {
					className: E.a.bannerDescription
				}, r), o.a.createElement("div", {
					className: E.a.bannerButtonsContainer
				}, i && o.a.createElement(f.t, {
					text: i,
					priority: f.c.Tertiary,
					className: Object(d.a)(E.a.button, E.a.primaryButton),
					size: f.d.XS,
					onClick: e => {
						l && l(e), u(Object(h.q)({
							dnPromptAction: "cta"
						}))
					}
				}), n && o.a.createElement(f.t, {
					text: n,
					onClick: e => {
						c && c(e), u(Object(h.q)({
							dnPromptAction: "refuse"
						}))
					},
					priority: f.c.Plain,
					size: f.d.XS,
					className: Object(d.a)(E.a.button, E.a.closeButton)
				})))
			};
			const C = e => {
				let {
					onClose: t,
					onTurnOnBrowserNotifications: n
				} = e;
				return o.a.createElement(O, {
					className: E.a.dnPromptBanner,
					titleText: s.fbt._("Dont miss out on updates  Turn on desktop notifications.", null, {
						hk: "10oNqB"
					}),
					onClose: e => {
						e.stopPropagation(), t()
					},
					closeIcon: !0,
					primaryButtonText: s.fbt._("Turn On", null, {
						hk: "3hywR9"
					}),
					closeButtonText: s.fbt._("No Thanks", null, {
						hk: "2GQOmV"
					}),
					onClick: e => {
						n(), t()
					}
				})
			};
			var A = n("./src/reddit/components/NotificationUnit/Loader.tsx"),
				y = n("./src/reddit/components/ResizeSensor/index.tsx"),
				j = n("./src/reddit/components/InboxTooltip/index.m.less"),
				I = n.n(j);
			const k = 3;
			class _ extends o.a.Component {
				constructor() {
					super(...arguments), this.ref = o.a.createRef(), this.handleResize = () => {
						const e = this.ref && this.ref.current && this.ref.current.clientHeight || 0;
						e !== this.props.notificationHeight && this.props.setNotificationHeight(e, this.props.index)
					}
				}
				componentDidMount() {
					if (this.props.index + 1 <= k) {
						const e = this.ref && this.ref.current && this.ref.current.clientHeight || 0;
						this.props.setNotificationHeight(e, this.props.index)
					}
				}
				render() {
					const {
						activeOverflowMenuId: e,
						decreaseSubredditNotifications: t,
						disableNotificationUpdates: n,
						hideNotification: s,
						hideSubredditNotifications: r,
						blockAwarder: i,
						index: a,
						isInboxPostEmbedEnabled: d,
						markNotificationAsRead: c,
						notification: l,
						setActiveOverflowMenuId: u,
						onItemClick: m
					} = this.props, p = a + 1 <= k;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						ref: this.ref,
						className: I.a.notificationResizeWrapper
					}, o.a.createElement(A.a, {
						activeOverflowMenuId: e,
						decreaseSubredditNotifications: t,
						disableNotificationUpdates: n,
						hideNotification: s,
						hideSubredditNotifications: r,
						isInboxPostEmbedEnabled: d,
						isInTooltip: !0,
						markNotificationAsRead: c,
						notification: l,
						setActiveOverflowMenuId: u,
						onItemClick: m,
						blockAwarder: i
					}), !!p && o.a.createElement(y.a, {
						onResize: this.handleResize
					})))
				}
			}
			var S = n("./src/reddit/components/NotificationUnit/Placeholder.tsx"),
				w = n("./src/reddit/pages/NotificationsInbox/Content/EmptyStateViews/EmptyStateComponent.tsx");

			function T() {
				return (T = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const P = {},
				N = "",
				D = 0,
				M = "200px",
				R = "250px",
				L = "270px",
				B = 100,
				F = .5,
				U = 5,
				H = 50,
				G = 55;
			class Q extends o.a.Component {
				constructor() {
					super(...arguments), this.container = o.a.createRef(), this.state = {
						notificationHeights: P,
						currentNotificationCursorIndex: -1
					}, this.resetOverflowMenu = () => {
						this.props.activeOverflowMenuId.length > D && this.props.setActiveOverflowMenuId(N)
					}, this.getContainerHeight = () => {
						const {
							notificationHeights: e
						} = this.state, {
							isDNInboxPromptBannerEnabled: t,
							isInboxPrivacyPolicyBannerEnabled: n,
							isLoggedIn: s
						} = this.props, r = t || n, o = window.innerHeight - H - 2 * G - (r ? B : 0);
						let i = 0;
						for (const a in e) i += e[a];
						return 0 === i ? r ? R : s ? M : L : (r && (i += B), o < i && (i = o + (r ? B : 0)), i)
					}, this.setNotificationHeight = (e, t) => {
						this.setState(n => ({
							notificationHeights: {
								...n.notificationHeights,
								[t]: e
							}
						}))
					}, this.updateCurrentCursorIndex = () => {
						const {
							notifications: e
						} = this.props, {
							currentNotificationCursorIndex: t
						} = this.state, n = t + U, s = n > e.length ? n : e.length - 1;
						this.setState({
							currentNotificationCursorIndex: s
						})
					}, this.renderNotifications = () => {
						const e = p()(this.props, ["notifications"]),
							{
								notificationHeights: t,
								currentNotificationCursorIndex: n
							} = this.state,
							{
								isInboxInfiniteScrollEnabled: s,
								notifications: r
							} = this.props,
							i = r.length > n + U;
						return (s && r.length > 0 && i ? r.slice(0, n + 1) : r).map((n, s) => o.a.createElement(_, T({}, e, {
							index: s,
							key: s,
							notification: n,
							notificationHeight: t[s],
							setNotificationHeight: this.setNotificationHeight
						})))
					}, this.loadNotifications = e => {
						const {
							cursor: t,
							fetchNotifications: n,
							isInboxInfiniteScrollEnabled: s,
							notifications: r
						} = this.props;
						if (e.isIntersecting) {
							const e = r.length > this.state.currentNotificationCursorIndex + U;
							this.props.notifications.length > 0 && s && e ? this.updateCurrentCursorIndex() : t && n({
								after: t,
								first: U
							})
						}
					}
				}
				componentDidMount() {
					const e = this.container && this.container.current;
					e && e.addEventListener("scroll", this.resetOverflowMenu)
				}
				componentWillUnmount() {
					const e = this.container && this.container.current;
					e && e.removeEventListener("scroll", this.resetOverflowMenu), this.resetOverflowMenu()
				}
				render() {
					const {
						hasNextPage: e,
						isDNInboxPromptBannerEnabled: t,
						isInboxInfiniteScrollEnabled: n,
						isPending: s,
						notifications: r,
						setDesktopNotificationsPromptSeen: i,
						showBrowserNotificationsPermissionSettings: a
					} = this.props, d = !(!r || !r.length), c = this.getContainerHeight(), l = r.length > this.state.currentNotificationCursorIndex + U;
					return o.a.createElement("div", {
						className: I.a.notificationList,
						ref: this.container,
						style: d ? {
							height: c,
							maxHeight: c
						} : {
							minHeight: M
						}
					}, !s && o.a.createElement("div", {
						className: I.a.notificationBannerContainer
					}, t && o.a.createElement(C, {
						onTurnOnBrowserNotifications: a,
						onClose: i
					}), o.a.createElement(b.a, {
						isFromMiniInbox: !0
					})), !d && s && o.a.createElement(S.a, null), !d && !s && o.a.createElement(w.a, {
						inTooltip: !0
					}), d && this.renderNotifications(), n && d && !s && (e || l) && o.a.createElement(u.a, {
						onChange: this.loadNotifications,
						rootMargin: "0px 0px 0px 0px",
						threshold: F
					}, o.a.createElement("div", null)))
				}
			}
			var q = n("./src/reddit/constants/localStorage.ts"),
				W = n("./src/reddit/controls/InternalLink/index.tsx"),
				z = n("./src/reddit/hooks/useLocalStorage.ts");
			var V = n("./src/reddit/hooks/useDesktopNotificationsPromptSeen.ts"),
				K = n("./src/reddit/helpers/localStorage/index.ts");

			function Y() {
				return (Y = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const J = [],
				X = c.a.div("StyledDropdown", I.a),
				Z = e => {
					let {
						isLoggedIn: t,
						onMessagesClick: n,
						onBarClick: i,
						markAllAsRead: a,
						messagesBadgeCount: c,
						sendInboxClickSettings: u
					} = e;
					const m = !!c,
						p = Object(r.useCallback)(() => {
							n(), i()
						}, [n, i]),
						b = Object(r.useCallback)(() => {
							u(), i()
						}, [u, i]);
					return o.a.createElement("nav", {
						className: I.a.topNav
					}, o.a.createElement("span", {
						className: I.a.topNavTitle
					}, s.fbt._("Notifications", null, {
						hk: "1sYFjx"
					})), t && o.a.createElement("span", {
						className: I.a.topNavLinks
					}, o.a.createElement("span", {
						className: I.a.messagesLinkContainer
					}, o.a.createElement(W.default, {
						className: Object(d.a)(I.a.messagesLink, {
							[I.a.mActive]: m
						}),
						onClick: p,
						to: m ? "/message/unread" : "/message/messages"
					}, s.fbt._("Messages", null, {
						hk: "hulKY"
					}), o.a.createElement(l.a, {
						className: I.a.badgeCount,
						isActive: m,
						unreadCount: c
					}))), o.a.createElement("button", {
						className: I.a.navLink,
						onClick: a
					}, o.a.createElement(v.a, {
						name: "mark_read",
						className: I.a.icon
					})), o.a.createElement(W.default, {
						className: I.a.navLink,
						onClick: b,
						to: "/settings/notifications"
					}, o.a.createElement(v.a, {
						name: "settings",
						className: I.a.icon
					}))))
				},
				$ = e => o.a.createElement("div", {
					className: I.a.bottomBar
				}, o.a.createElement(W.default, {
					className: I.a.bottomLink,
					onClick: () => {
						e.sendInboxClickSeeAll(), e.onBarClick()
					},
					to: "/notifications"
				}, s.fbt._("See All", null, {
					hk: "3L3tFc"
				}))),
				ee = e => {
					const t = Object(g.a)(),
						{
							clearMessageTabBadgeCount: n,
							inboxBadgeCount: s,
							isPending: d,
							messagesBadgeCount: c,
							notifications: l,
							hideTooltip: u,
							isGarlicBreadEnabled: m,
							isInboxPolicyBannerEnabled: p,
							isLoggedIn: b,
							isPushNotificationsSupported: f,
							userId: v
						} = e,
						[x, E] = Object(V.a)(v),
						[O, C] = function(e) {
							const [t, n] = Object(r.useState)(() => Object(K.w)(e));
							return [t, Object(r.useCallback)(() => {
								n(!0), Object(K.Db)(e)
							}, [e])]
						}(v),
						[A, y] = function(e) {
							let {
								key: t,
								userId: n
							} = e;
							const [s, r] = Object(z.a)(t, []);
							return [-1 !== s.indexOf(n), () => {
								r([...s, n])
							}]
						}({
							key: q.b.GARLIC_BREAD_BANNER_SEEN,
							userId: v
						}),
						j = !(!l || !l.length),
						k = Object(i.a)(),
						_ = k === a.a.Closed || k === a.a.Default || k === a.a.Denied,
						S = f && _ && !x;
					return o.a.createElement(X, null, o.a.createElement("div", {
						className: I.a.tooltipContainer
					}, o.a.createElement(Z, {
						markAllAsRead: () => {
							e.markAllAsRead(), t(Object(h.g)({
								isMiniInbox: !0
							}))
						},
						messagesBadgeCount: c,
						onMessagesClick: () => {
							t(Object(h.t)({
								badgeCount: s,
								tab: h.f.Messages
							})), t(Object(h.h)()), n()
						},
						sendInboxClickSettings: () => t(Object(h.m)(h.c.MiniInbox)),
						onBarClick: u,
						isLoggedIn: b
					}), o.a.createElement(Q, Y({}, e, {
						isPending: d,
						onItemClick: u,
						setDesktopNotificationsPromptSeen: E,
						isDNInboxPromptBannerEnabled: S,
						isInboxPrivacyPolicyBannerEnabled: p && !O,
						setInboxPrivacyPolicyBannerSeen: C,
						isGarlicBreadEnabled: m && !A,
						setGarlicBreadBannerSeen: y
					})), (j || d) && o.a.createElement($, {
						sendInboxClickSeeAll: () => t(Object(h.l)()),
						onBarClick: u
					})))
				}
		},
		"./src/reddit/components/InboxTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				carot: "_389RY3FytRs4F82-BLVEiq",
				StyledDropdown: "_3fRnnkCBwqAZG6nmxhTKHr",
				styledDropdown: "_3fRnnkCBwqAZG6nmxhTKHr",
				tooltipContainer: "_3oNU8Gzy2V3jDPhFfeEFbD",
				topNav: "F0hrtz76LlopbY9X0wtDo",
				topNavTitle: "wdFbe8PT7DInxaiHo2Me1",
				messagesLinkContainer: "_1581SeO-Xb1j1kfhIRrIyB",
				topNavLinks: "_1R0ZV71kh7uwDXo7fn1eDk",
				messagesLink: "_27rjoZBkLhiqLLjBu-xU_p",
				"m-active": "_29xCmtH_l8UtRn8IP08VLB",
				mActive: "_29xCmtH_l8UtRn8IP08VLB",
				badgeCount: "_1mrhJHegVozrNeTH7r5svN",
				navLink: "_2l1d6HSQ764u0JcvRSEJXD",
				notificationList: "_2MId4QR3fPm4RPlrSTZg_E",
				notificationResizeWrapper: "_3PWmWL3sMw23-xBHydcnPf",
				emptyState: "_17HPdVVhdV3LWBjzHwGlhA",
				emptyTitle: "_2CY3n2AMoj0af7gQhj9dfI",
				emptyDescription: "HxBuWRTAFa8y8bMiQKdSJ",
				bottomBar: "_8INvnNiEMHRndJ0M-LiY",
				bottomLink: "X1WC7m4hrFQNzINreBRsv",
				icon: "_3pDOQfbIbQuT4PBwPGp85E",
				BellOutline: "SBkEJxL8i3eNB9EZn7AAz",
				bellOutline: "SBkEJxL8i3eNB9EZn7AAz",
				notificationBannerContainer: "_2prSjBmU3TS_Liup8DFR-2",
				welcomeTooltipContainer: "_1OZgaZvEs6sdhMUCqaUCW_",
				closeButton: "_3fWRL_DhsIqXjpW4eXDwmR",
				CloseIcon: "_2xK-Knp1-SUm_DxX4Ak1T0",
				closeIcon: "_2xK-Knp1-SUm_DxX4Ak1T0",
				tooltipTitle: "_3EmopbfaUR0bemuuUcEcko",
				tooltipDescription: "_3MtkPXIDbG9Hf6YeNOxAxv"
			}
		},
		"./src/reddit/components/InfoBanners/BannerBase/index.m.less": function(e, t, n) {
			e.exports = {
				IconWrapper: "_2p07tPrx9WpxDTQJ5cmVNe",
				iconWrapper: "_2p07tPrx9WpxDTQJ5cmVNe",
				TextWrapper: "_2jpm-rNr0Hniw6BX3NWMVe",
				textWrapper: "_2jpm-rNr0Hniw6BX3NWMVe",
				leftSideRectangle: "_3TLlMYjrPH9Kl9522LpSxb",
				wrapper: "_1DUKbp8va6vxOv9zemBDBi",
				subtitle: "_2J85dtk0HKQBLk8HTSWduv",
				title: "Nt8TnDvJ2BsL8KWcFQKy5"
			}
		},
		"./src/reddit/components/InfoBanners/BannerBase/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/InfoBanners/BannerBase/index.m.less"),
				a = n.n(i),
				d = n("./src/lib/lessComponent.tsx");
			const c = d.a.div("IconWrapper", a.a),
				l = d.a.div("TextWrapper", a.a);

			function u(e) {
				const {
					className: t,
					color: n,
					icon: s,
					subtitle: i,
					title: d,
					textWrapperClassName: u
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(t, a.a.wrapper),
					style: n && {
						borderColor: n
					} || {}
				}, r.a.createElement("div", {
					className: a.a.leftSideRectangle,
					style: n && {
						backgroundColor: n
					} || {}
				}), s ? r.a.createElement(c, null, s) : r.a.createElement(c, null), r.a.createElement(l, {
					className: u
				}, r.a.createElement("div", {
					className: a.a.title
				}, d), i && r.a.createElement("div", {
					className: a.a.subtitle
				}, i)))
			}
		},
		"./src/reddit/components/InfoBanners/PostRemovalBanner/helpers.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "e", (function() {
				return x
			})), n.d(t, "c", (function() {
				return E
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/reddit/icons/svgs/ClearFilled/index.tsx"),
				a = n("./src/reddit/icons/svgs/ModRemove/index.tsx"),
				d = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				c = n("./src/reddit/models/Post/index.ts"),
				l = n("./src/reddit/components/InfoBanners/PostRemovalBanner/index.m.less"),
				u = n.n(l);
			const {
				fbt: m
			} = n("./node_modules/fbt/lib/FbtPublic.js"), p = e => {
				let t;
				switch (e) {
					case c.g.AntiEvilOps:
					case c.g.AutomodFiltered:
					case c.g.CommunityOps:
					case c.g.ContentTakedown:
					case c.g.CopyrightTakedown:
					case c.g.Reddit:
						t = i.a;
						break;
					case c.g.AuthorDeleted:
					case c.g.Author:
						t = d.b;
						break;
					case c.g.Moderator:
						t = a.a;
						break;
					default:
						t = i.a
				}
				return o.a.createElement(t, {
					className: u.a.icon
				})
			}, b = e => {
				let t;
				switch (e) {
					case c.g.AntiEvilOps:
					case c.g.AutomodFiltered:
					case c.g.CommunityOps:
					case c.g.ContentTakedown:
					case c.g.CopyrightTakedown:
					case c.g.Reddit:
						t = "clear_fill";
						break;
					case c.g.AuthorDeleted:
					case c.g.Author:
						t = "delete_fill";
						break;
					case c.g.Moderator:
						t = "mod_fill";
						break;
					default:
						t = "clear_fill"
				}
				return t
			}, f = () => m._("To keep Reddit and its communities safe, the Anti-Evil Operations team removes posts that violate Reddit's {=User Agreement} and {=Content Policy} .", [m._param("=User Agreement", o.a.createElement("a", {
				className: u.a.link,
				href: "https://www.redditinc.com/policies/user-agreement"
			}, m._("User Agreement", null, {
				hk: "3MHgRl"
			}))), m._param("=Content Policy", o.a.createElement("a", {
				className: u.a.link,
				href: "https://www.redditinc.com/policies/content-policy"
			}, m._("Content Policy", null, {
				hk: "3UZthQ"
			})))], {
				hk: "4g3zuW"
			}), h = () => m._("Reddit administrators occasionally remove posts that violate Reddit's {=User Agreement} and {=Content Policy} .", [m._param("=User Agreement", o.a.createElement("a", {
				className: u.a.link,
				href: "https://www.redditinc.com/policies/user-agreement"
			}, m._("User Agreement", null, {
				hk: "yMHtU"
			}))), m._param("=Content Policy", o.a.createElement("a", {
				className: u.a.link,
				href: "https://www.redditinc.com/policies/content-policy"
			}, m._("Content Policy", null, {
				hk: "2dCXGu"
			})))], {
				hk: "2DLuNP"
			}), g = (e, t) => {
				switch (e) {
					case c.g.AntiEvilOps:
						return m._("Sorry, this post was removed by Reddit's Anti-Evil Operations team.", null, {
							hk: "2ZqyRT"
						});
					case c.g.Author:
						return m._("Sorry, this post was removed by the person who originally posted it.", null, {
							hk: "4IRCN"
						});
					case c.g.AuthorDeleted:
						return m._("Sorry, this post was deleted by the person who originally posted it.", null, {
							hk: "4emmIp"
						});
					case c.g.AutomodFiltered:
						return m._("Post is awaiting moderator approval.", null, {
							hk: "wdGOr"
						});
					case c.g.CommunityOps:
						return m._("Sorry, this post was removed by Reddit's Community team.", null, {
							hk: "3fs5lF"
						});
					case c.g.ContentTakedown:
						return m._("Sorry, this post was removed by Reddit.", null, {
							hk: "3XSuKc"
						});
					case c.g.CopyrightTakedown:
						return m._("Sorry, this post was removed by Reddit's Legal Operations team.", null, {
							hk: "1TbEDT"
						});
					case c.g.Moderator:
						return m._("Sorry, this post has been removed by the moderators of r/{subredditName}.", [m._param("subredditName", t)], {
							hk: "12NWKq"
						});
					case c.g.Reddit:
						return m._("Sorry, this post was removed by Reddit's spam filters.", null, {
							hk: "10ItEu"
						});
					default:
						return m._("Sorry, this post has been removed", null, {
							hk: "11sG9V"
						})
				}
			}, v = (e, t) => {
				switch (e) {
					case c.g.AntiEvilOps:
						return o.a.createElement(f, null);
					case c.g.AuthorDeleted:
					case c.g.Author:
						return m._("It doesn't appear in any feeds, and anyone with a direct link to it will see a message like this one.", null, {
							hk: "2OBDBc"
						});
					case c.g.AutomodFiltered:
						return m._("This post is currently awaiting approval by the moderators of {=[subreddit name]} before it can appear in the subreddit.", [m._param("=[subreddit name]", o.a.createElement("a", {
							className: u.a.link,
							href: `${s.a.redditUrl}/r/${t}`,
							target: "_blank",
							rel: "noopener noreferrer"
						}, m._("{subreddit name}", [m._param("subreddit name", `r/${t}`)], {
							hk: "2o22vl"
						})))], {
							hk: "3dxuEW"
						});
					case c.g.CommunityOps:
						return m._("It's rare, but Reddit's Community Team will occasionally remove posts from feeds to keep communities safe and civil.", null, {
							hk: "uPiHS"
						});
					case c.g.ContentTakedown:
						return o.a.createElement(h, null);
					case c.g.CopyrightTakedown:
						return m._("This content was removed in response to a copyright claim by a third party.", null, {
							hk: "2e8fhi"
						});
					case c.g.Moderator:
						return m._("Moderators remove posts from feeds for a variety of reasons, including keeping communities safe, civil, and true to their purpose.", null, {
							hk: "QXZPk"
						});
					case c.g.Reddit:
					default:
						return m._("Reddit's automated bots frequently filter posts it thinks might be spam.", null, {
							hk: "3vUmEz"
						})
				}
			}, x = (e, t, n) => {
				switch (e) {
					case c.g.AntiEvilOps:
						return m._("This post was removed by Reddit's Anti-Evil Operations team.", null, {
							hk: "3a8CyR"
						});
					case c.g.Author:
						return m._("This post was removed by the person who originally posted it.", null, {
							hk: "2lyUgL"
						});
					case c.g.AuthorDeleted:
						return m._("This post was deleted by the person who originally posted it.", null, {
							hk: "16LeiH"
						});
					case c.g.AutomodFiltered:
						return m._("This post was reported by automod, and is waiting for your review.", null, {
							hk: "2E46dR"
						});
					case c.g.CommunityOps:
						return m._("This post was removed by Reddit admin, u/{username}.", [m._param("username", t)], {
							hk: "34nHWu"
						});
					case c.g.ContentTakedown:
						return m._("This post was removed by Reddit.", null, {
							hk: "3uR3iw"
						});
					case c.g.CopyrightTakedown:
						return m._("This post was removed by Reddit's Legal Operations team.", null, {
							hk: "Ukfj"
						});
					case c.g.Moderator:
						return m._("This post was removed by r/{subredditName} moderator, u/{username}.", [m._param("subredditName", n), m._param("username", t)], {
							hk: "270bcn"
						});
					case c.g.Reddit:
						return m._("This post was removed by Reddit's spam filters.", null, {
							hk: "1k3lsh"
						});
					default:
						return m._("This post was removed by Reddit's spam filters.", null, {
							hk: "3oxS8r"
						})
				}
			}, E = e => {
				switch (e) {
					case c.g.AntiEvilOps:
						return o.a.createElement(f, null);
					case c.g.AuthorDeleted:
					case c.g.Author:
						return m._("It won't show up in your community feed, and anyone with a direct link to it will see a message similar to this one.", null, {
							hk: "2KZLgT"
						});
					case c.g.AutomodFiltered:
						return m._("It wont show up in your community feed until you or another moderator approve it.", null, {
							hk: "2X5ECb"
						});
					case c.g.CommunityOps:
						return m._("To keep Reddit and its communities safe, the Community team occasionally removes posts from feeds. To learn more, {=just ask} .", [m._param("=just ask", o.a.createElement("a", {
							className: u.a.link,
							href: `${s.a.redditUrl}/message/compose/?to=r/reddit.com`,
							target: "_blank",
							rel: "noopener noreferrer"
						}, m._("just ask", null, {
							hk: "jn9ip"
						})))], {
							hk: "3hMocZ"
						});
					case c.g.ContentTakedown:
						return o.a.createElement(h, null);
					case c.g.CopyrightTakedown:
						return m._("This content was removed in response to a copyright claim by a third party.", null, {
							hk: "7jiV"
						});
					case c.g.Moderator:
						return m._("It won't show up in your community feed, and moderators will see a message similar to this one.", null, {
							hk: "22qJOB"
						});
					case c.g.Reddit:
						return m._("Reddit's automated bots frequently filter posts it thinks might be spam.", null, {
							hk: "3S3oDL"
						});
					default:
						return m._("Reddit's automated bots frequently filter posts it thinks might be spam.", null, {
							hk: "uKfHK"
						})
				}
			}
		},
		"./src/reddit/components/InfoBanners/PostRemovalBanner/index.m.less": function(e, t, n) {
			e.exports = {
				BannerBase: "_2bSWRKmIOj8SKw_5EOrpVb",
				bannerBase: "_2bSWRKmIOj8SKw_5EOrpVb",
				icon: "S7CavmS-v3qdubhT9asIc",
				link: "FmwbWt4ZwkxbQbR-0vj1G"
			}
		},
		"./src/reddit/components/InfoTextTooltip/Hooked.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/InfoTextTooltip/hooked.m.less"),
				a = n.n(i);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = r.a.memo((function(e) {
				let {
					visible: t,
					...n
				} = e;
				const [i, c] = Object(s.useState)(t);
				return Object(s.useEffect)(() => {
					let e = window.setTimeout(() => {
						e = void 0, c(t)
					}, 0);
					return () => {
						e && window.clearTimeout(e), c(!1)
					}
				}, [t]), t ? r.a.createElement("div", d({
					className: Object(o.a)(a.a.tooltip, n.className, {
						[a.a.visible]: i
					})
				}, n.popperProps), n.children, i && r.a.createElement("div", d({
					className: a.a.arrow
				}, n.arrowProps))) : null
			}))
		},
		"./src/reddit/components/InfoTextTooltip/hooked.m.less": function(e, t, n) {
			e.exports = {
				arrow: "_1jsc29CjRXZWjd2tr0Ji0Y",
				tooltip: "_2J_zB4R1FH2EjGMkQjedwc",
				visible: "u6HtAZu8_LKL721-EnKuR"
			}
		},
		"./src/reddit/components/InfoTextTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				BottomText: "_3uK2I0hi3JFTKnMUFHD2Pd",
				bottomText: "_3uK2I0hi3JFTKnMUFHD2Pd",
				Text: "HQ2VJViRjokXpRbJzPvvc",
				text: "HQ2VJViRjokXpRbJzPvvc",
				"fade-in": "_1tIZttmhLdrIGrB-6VvZcT",
				fadeIn: "_1tIZttmhLdrIGrB-6VvZcT"
			}
		},
		"./src/reddit/components/InfoTextTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return h
			})), n.d(t, "a", (function() {
				return g
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/higherOrderComponents/addOverlayEvents.tsx"),
				d = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				c = n("./src/reddit/selectors/tooltip.ts"),
				l = n("./src/reddit/components/InfoTextTooltip/index.m.less"),
				u = n.n(l),
				m = n("./src/lib/lessComponent.tsx");

			function p() {
				return (p = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const b = m.a.div("Text", u.a),
				f = m.a.div("BottomText", u.a),
				h = e => r.a.createElement(b, {
					className: e.className,
					style: e.style
				}, e.text, e.children),
				g = e => {
					const t = e.overflow ? e.overflow.left : 0;
					return r.a.createElement(f, {
						className: e.className,
						style: {
							...e.style,
							"--infoTextTooltip-overflow-left": `${t}px`
						}
					}, e.text, e.children)
				},
				v = Object(i.c)({
					isOpen: (e, t) => {
						let {
							tooltipId: n
						} = t;
						return Object(c.b)(n)(e)
					}
				}),
				x = Object(d.a)(g, [a.a.Click, a.a.Keydown]),
				E = Object(d.a)(h, [a.a.Click, a.a.Keydown]),
				O = Object(o.b)(v);
			t.c = O(e => {
				const {
					caretOnTop: t
				} = e;
				return t ? r.a.createElement(x, p({}, e, {
					targetPosition: ["center", "bottom"],
					tooltipPosition: ["center", "top"]
				})) : r.a.createElement(E, p({}, e, {
					targetPosition: ["center", "top"],
					tooltipPosition: ["center", "bottom"]
				}))
			})
		},
		"./src/reddit/components/InlineSubredditEditing/index.m.less": function(e, t, n) {
			e.exports = {
				tooltipContent: "RrvkJ7ntzKYyaCOxMJ1RM",
				title: "BE2vGjFTJ80XkdBpRRr0p",
				tooltipBody: "_2yezzi8dgIemh3F2q_kvcp",
				topRow: "_1JfvdiRxYTSKf1IIe7DUvM",
				gotIt: "_1MHKCZd72tAgyoZWvIYM-G"
			}
		},
		"./src/reddit/components/LinkOrOverlayLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				i = n("./src/reddit/controls/UnstyledInternalLink/index.tsx"),
				a = n("./src/reddit/helpers/overlay/index.ts");

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function c(e) {
				const {
					children: t,
					className: n,
					to: s,
					...o
				} = e, c = Object(a.b)(s);
				return r.a.createElement(i.a, d({
					className: n,
					to: c
				}, o), t)
			}

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				const {
					isOverlay: t,
					...n
				} = e, s = t ? c : o.a;
				return r.a.createElement(s, l({}, n, {
					className: n.className,
					onClick: n.onClick,
					to: n.to
				}), n.children)
			}
		},
		"./src/reddit/components/LiveChatActiveUserCountWrapper/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return x
			}));
			var s = n("./src/lib/classNames/index.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/lib/LiveChatActiveUsers/index.m.less"),
				d = n.n(a);
			const c = e => {
				let {
					userCount: t
				} = e;
				return i.a.createElement("span", {
					className: d.a.liveChatActiveUsers
				}, t > 1 ? r.fbt._("{userCount} here now", [r.fbt._param("userCount", `${t}`)], {
					hk: "4pUoKA"
				}) : r.fbt._("join now", null, {
					hk: "3JGiBG"
				}))
			};
			var l = n("./src/lib/LiveLabel/index.m.less"),
				u = n.n(l);
			const m = () => i.a.createElement("span", {
				className: u.a.LiveLabel
			}, r.fbt._("LIVE", null, {
				hk: "1N5y3d"
			}));
			var p = n("./src/lib/LiveChatActiveUsersWithLiveLabel/index.m.less"),
				b = n.n(p);
			const f = e => {
				let {
					userCount: t = 0,
					className: n
				} = e;
				return i.a.createElement("div", {
					className: Object(s.a)(b.a.liveParticipation, n)
				}, i.a.createElement(m, null), i.a.createElement(c, {
					userCount: t
				}))
			};
			var h = n("./node_modules/react-redux/es/index.js"),
				g = n("./src/reddit/selectors/chat.ts"),
				v = n("./src/reddit/selectors/experiments/chat.ts");
			const x = e => {
				let {
					postId: t,
					className: n
				} = e;
				const s = Object(h.e)(e => Object(g.a)(e, t));
				return Object(h.e)(v.f) ? i.a.createElement(f, {
					userCount: s,
					className: n
				}) : null
			}
		},
		"./src/reddit/components/LottieAnimation/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lottie-web/build/player/lottie.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/components/LottieAnimation/util.ts");
			const d = i.a.memo(e => {
				const t = i.a.createRef(),
					{
						assetData: n,
						assetUrl: s,
						className: d,
						hidden: c,
						loop: l,
						useCanvasRenderer: u,
						onClick: m,
						prefersReducedAnimation: p
					} = e,
					[b, f] = Object(o.useState)(n);
				Object(o.useEffect)(() => {
					s ? Object(a.a)(s).then(f) : n && f(n)
				}, [s, n]);
				const [h, g] = Object(o.useState)(null);
				Object(o.useEffect)(() => {
					const e = t.current;
					if (!e || 0 !== e.childElementCount || h || !b) return;
					const n = r.a.loadAnimation({
						autoplay: !1,
						renderer: u ? "canvas" : "svg",
						loop: l,
						container: e,
						animationData: b
					});
					g(n)
				}, [l, t, h, b]), Object(o.useEffect)(() => {
					if (h)
						if (c) h.stop();
						else if (p) {
						const e = h.getDuration(!0);
						h.goToAndPlay(e, !0)
					} else h.goToAndPlay(0)
				}, [c, p, h]);
				const v = Object(o.useCallback)(() => {
					h && h.goToAndPlay(0)
				}, [h]);
				return i.a.createElement("div", {
					className: d,
					style: {
						display: c ? "none" : "block"
					},
					ref: t,
					onClick: m || v
				})
			});
			t.a = d
		},
		"./src/reddit/components/LottieAnimation/util.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./src/reddit/components/ImageWithFallback/index.tsx");
			const s = {};

			function r(e) {
				let t = s[e];
				return t || (t = s[e] = fetch(e, {
					mode: "cors",
					cache: "force-cache"
				}).then(t => (t.ok || function(e) {
					throw new Error(`Unable to download effect asset "${e}"`)
				}(e), t.json()))), t
			}
		},
		"./src/reddit/components/ModActionsMenu/index.m.less": function(e, t, n) {
			e.exports = {
				ModActionsMenu: "_28noJDp6DzFWESejYQdpcD",
				modActionsMenu: "_28noJDp6DzFWESejYQdpcD"
			}
		},
		"./src/reddit/components/ModActionsMenu/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/actions/tooltip.ts"),
				d = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/RestrictedButton.tsx"),
				c = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				l = n("./src/reddit/selectors/tooltip.ts"),
				u = n("./src/reddit/components/ModActionsMenu/index.m.less"),
				m = n.n(u);
			const p = Object(i.c)({
					dropdownIsOpen: (e, t) => {
						let {
							dropdownId: n
						} = t;
						return Object(l.b)(n)(e)
					}
				}),
				b = Object(o.b)(p, (e, t) => {
					let {
						dropdownId: n
					} = t;
					return {
						toggleDropdown: () => e(Object(a.h)({
							tooltipId: n
						}))
					}
				}),
				f = () => null;
			t.a = b(e => r.a.createElement("div", {
				className: m.a.ModActionsMenu,
				id: e.dropdownId,
				onClick: e.dropdownIsOpen ? f : e.onClick
			}, e.inCommentFlatlist ? r.a.createElement(d.a, {
				className: e.className,
				onClick: e.toggleDropdown
			}, e.children) : r.a.createElement(c.c, {
				className: e.className,
				onClick: e.toggleDropdown
			}, e.children)))
		},
		"./src/reddit/components/ModHub/ApprovedTalkHosts/AddApprovedTalkHostModal.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "yumI0nyT2gr7SFtITyKpa",
				primaryButton: "yumI0nyT2gr7SFtITyKpa"
			}
		},
		"./src/reddit/components/ModHub/ApprovedTalkHosts/index.m.less": function(e, t, n) {
			e.exports = {
				PencilIcon: "_2no2YPg0_yUhnhUSmNU8Xu",
				pencilIcon: "_2no2YPg0_yUhnhUSmNU8Xu",
				noPermissions: "_2L3p28vjPxj-Ab-h1gRXii",
				helperTitle: "_3qVhi7y_9yxVxxDGEHORe9",
				border: "q52vzxG_bCJnEI7jgEaUw",
				newModNavContainer: "uRqv70KnxP5nuqhsDejAJ",
				topBar: "_2xEqKjN-zqmlIOsE5vlPEn",
				fixed: "_pN6fRmdVdN5r9WoiLTV4",
				default: "_3l633MmgK2Naudly0mx0EF"
			}
		},
		"./src/reddit/components/ModHub/ApprovedTalkHosts/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/subredditModeration/approvedTalkHosts.ts"),
				p = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				b = n("./src/reddit/components/HumanDate/index.tsx"),
				f = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				h = n("./src/reddit/components/ModHub/NewModNav/PageLinks.tsx"),
				g = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				v = n("./src/reddit/components/Scroller/Simple.tsx"),
				x = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				E = n("./src/reddit/controls/Button/index.tsx"),
				O = n("./src/reddit/icons/fonts/index.tsx"),
				C = n("./src/reddit/models/SubredditModeration/index.ts"),
				A = n("./src/reddit/selectors/activeModalId.ts"),
				y = n("./src/lib/objectSelector/index.ts"),
				j = n("./src/reddit/components/InboxTooltip/Component.tsx");
			const I = Object(y.a)((e, t) => {
				let {
					subredditId: n
				} = t;
				return e.pages.modHub.approvedTalkHosts.models[n] || j.a
			});
			var k = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				_ = n("./src/reddit/selectors/user.ts"),
				S = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				w = n("./src/higherOrderComponents/asModal/index.tsx"),
				T = n("./src/lib/lessComponent.tsx"),
				P = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				N = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				D = n("./src/reddit/controls/TextButton/index.tsx"),
				M = n("./src/reddit/helpers/isValidUsername/index.tsx"),
				R = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				L = n("./src/reddit/components/ModHub/ApprovedTalkHosts/AddApprovedTalkHostModal.m.less"),
				B = n.n(L);
			const F = T.a.wrapped(E.l, "PrimaryButton", B.a);
			var U = Object(w.a)(e => {
					let {
						subredditId: t,
						onAddTalkHost: n,
						toggleModal: s,
						sendEventWithName: a
					} = e;
					const [d, c] = Object(o.useState)("");
					return i.a.createElement(P.e, null, i.a.createElement(P.i, null, i.a.createElement(R.a, null, i.a.createElement(P.q, null, r.fbt._("Add approved Talk host", null, {
						hk: "38DcZT"
					})), i.a.createElement(D.a, {
						onClick: s
					}, i.a.createElement(P.b, null)))), i.a.createElement(P.l, null, i.a.createElement(N.d, {
						placeholder: r.fbt._("Enter username", null, {
							hk: "4DdFFr"
						}),
						onChange: e => {
							c(e.currentTarget.value)
						},
						value: d,
						autoFocus: !0
					})), i.a.createElement(P.g, null, i.a.createElement(P.a, {
						onClick: s,
						"data-redditstyle": !0
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), i.a.createElement(F, {
						onClick: () => {
							n(t, d), a("add")(), s()
						},
						"data-redditstyle": !0,
						disabled: !Object(M.a)(d)
					}, r.fbt._("Approve user", null, {
						hk: "4Awx1T"
					}))))
				}),
				H = n("./src/reddit/components/ModHub/ApprovedTalkHosts/index.m.less"),
				G = n.n(H);
			const Q = 24,
				q = Object(d.c)({
					approvedTalkHosts: I,
					approvedTalkHostsListPending: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = Object(C.f)(n);
						return !!e.pages.modHub.approvedTalkHosts.api.pending[s]
					},
					loadMoreToken: (e, t) => {
						let {
							subredditId: n
						} = t;
						return e.pages.modHub.approvedTalkHosts.loadMore[n]
					},
					currentUser: _.m,
					isAddApprovedTalkHostModalOpen: e => "ModerationPage--Modal--AddApprovedTalkHost" === Object(A.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--RemoveHostConfirmation" === Object(A.a)(e),
					isInShredditModNavExperiment: (e, t) => {
						let {
							moderatorPermissions: n
						} = t;
						return Object(k.a)(e, !!n)
					}
				}),
				W = Object(a.b)(q, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						addApprovedTalkHost: (t, n) => e(Object(m.a)(t, n)),
						loadMore: t => e(Object(m.b)({
							subredditId: n,
							before: t
						})),
						toggleAddApprovedHostModal: () => e(Object(u.i)("ModerationPage--Modal--AddApprovedTalkHost")),
						toggleRemoveHostModal: () => e(Object(u.i)("ModerationPage--Modal--RemoveHostConfirmation")),
						removeApprovedTalkHost: (t, n) => e(Object(m.c)(t, n))
					}
				});
			class z extends i.a.Component {
				constructor(e) {
					super(e), this.isSticky = () => {
						const e = window.scrollY >= 100;
						this.setState({
							isFixed: e
						})
					}, this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.approveTalkHost = () => {
						this.props.sendEventWithName("open_add_dialog")(), this.props.toggleAddApprovedHostModal()
					}, this.handleRemoveToggled = (e, t) => {
						this.setState({
							userId: e,
							username: t
						}), this.props.toggleRemoveHostModal()
					}, this.handleRemoveConfirmed = () => {
						this.state.userId && this.props.removeApprovedTalkHost(this.props.subredditId, this.state.userId)
					}, this.renderAddApprovedHostModal = () => i.a.createElement(U, {
						ignoreDefaultFocus: !0,
						onAddTalkHost: this.props.addApprovedTalkHost,
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddApprovedHostModal,
						sendEventWithName: this.props.sendEventWithName,
						withOverlay: !0
					}), this.renderUser = e => {
						var t, n, o;
						return i.a.createElement(x.b, {
							timeAgo: i.a.createElement(b.d, {
								seconds: Date.parse(e.addedAt) / 1e3
							}),
							pageName: l.mc.TalkHosts,
							primaryButton: (null === (t = this.props.currentUser) || void 0 === t ? void 0 : t.id) !== e.redditor.id ? i.a.createElement("a", {
								href: `${s.a.redditUrl}/message/compose/?to=${e.redditor.displayName}`,
								rel: "noopener noreferrer",
								target: "_blank"
							}, i.a.createElement(E.r, null, r.fbt._("Send message", null, {
								hk: "2bul7M"
							}))) : null,
							secondaryButton: (null === (n = this.props.moderatorPermissions) || void 0 === n ? void 0 : n.access) ? i.a.createElement(E.r, {
								onClick: () => this.handleRemoveToggled(e.redditor.id, e.redditor.displayName)
							}, r.fbt._("Remove", null, {
								hk: "3tYl0U"
							})) : null,
							subredditId: this.props.subredditId,
							userIcon: null === (o = e.redditor.icon) || void 0 === o ? void 0 : o.url,
							username: e.redditor.displayName
						})
					}, this.renderTopBar = e => i.a.createElement(g.c, {
						className: Object(c.a)(e && "bg-neutral-background mb-xs pr-0", G.a.topBar, {
							[G.a.default]: !e,
							[G.a.fixed]: this.state.isFixed
						})
					}, i.a.createElement(E.l, {
						onClick: this.approveTalkHost
					}, r.fbt._("Add Talk Host", null, {
						hk: "w94Fa"
					}))), this.state = {
						...C.a,
						isFixed: !this.props.isInShredditModNavExperiment
					}
				}
				componentDidMount() {
					this.props.isInShredditModNavExperiment && window.addEventListener("scroll", this.isSticky)
				}
				componentWillUnmount() {
					this.props.isInShredditModNavExperiment && window.removeEventListener("scroll", this.isSticky)
				}
				render() {
					var e;
					const {
						props: t,
						state: n
					} = this, o = t.approvedTalkHosts.length > 0 ? t.approvedTalkHosts[t.approvedTalkHosts.length - 1].redditor.id : void 0, a = null === (e = t.moderatorPermissions) || void 0 === e ? void 0 : e.access;
					return i.a.createElement(i.a.Fragment, null, a && !t.isInShredditModNavExperiment && this.renderTopBar(), i.a.createElement(g.a, {
						className: Object(c.a)(t.isInShredditModNavExperiment && G.a.newModNavContainer, !a && G.a.noPermissions)
					}, t.isInShredditModNavExperiment ? i.a.createElement(i.a.Fragment, null, Object(h.e)(t.subredditName, l.mc.TalkHosts), this.renderTopBar(!0)) : i.a.createElement(g.b, null, r.fbt._("Talk hosts", null, {
						hk: "3ypfgA"
					}), i.a.createElement(S.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/4411156549389`
					})), i.a.createElement("p", {
						className: G.a.helperTitle
					}, r.fbt._("Talk hosts are members who are approved to create Reddit Talk posts.", null, {
						hk: "2mnjQi"
					})), t.approvedTalkHostsListPending && i.a.createElement(x.a, null), t.approvedTalkHosts.length > 0 ? i.a.createElement(v.b, {
						className: G.a.border,
						loadMoreToken: o,
						onLoadMore: this.onLoadMore
					}, t.approvedTalkHosts.map(e => ({
						estHeight: Q,
						id: e.redditor.id,
						render: () => this.renderUser(e)
					}))) : i.a.createElement(f.c, {
						className: G.a.border,
						text: r.fbt._("No approved Talk hosts in {subredditName}", [r.fbt._param("subredditName", t.subredditName)], {
							hk: "3lDejn"
						})
					}, i.a.createElement(O.a, {
						name: "edit",
						className: G.a.PencilIcon
					}))), t.isAddApprovedTalkHostModalOpen && this.renderAddApprovedHostModal(), t.isConfirmModalOpen && n.userId && n.username && i.a.createElement(p.a, {
						actionText: r.fbt._("Remove", null, {
							hk: "3tYl0U"
						}),
						modalText: r.fbt._("Are you sure you want to remove {username} as an approved Talk host?", [r.fbt._param("username", n.username)], {
							hk: "1p0fqz"
						}),
						onConfirm: this.handleRemoveConfirmed,
						toggleModal: t.toggleRemoveHostModal,
						trackClick: t.sendEventWithName("remove"),
						withOverlay: !0
					}))
				}
			}
			t.a = W(z)
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/EmptyState/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_12gWQ2C_gotA8s5-CJIlq9",
				icon: "_3-Fcrds7R5ihAWPAttv3AL",
				title: "_1vL1j4mpTYI5NOR335bInG",
				subtitle: "_3FOOtAw2Q-T7szrSBAbo9i"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/TabBar/index.m.less": function(e, t, n) {
			e.exports = {
				tabBar: "_1ItRVjBpP4aLG0vg-nXbwO",
				tab: "_3A18ggmDWAI5_Fz0nDOs-z",
				selected: "_3U85C8qDDoOUoOINg-E_3S"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/index.m.less": function(e, t, n) {
			e.exports = {
				contentContainer: "_2O3bUryrh35-WVnz9Zoet5",
				newModNav: "_18aLlA3phB0m2ra4LEjWy6",
				content: "_1FTRfhuddBV5YzYiIzObiO",
				grid: "_3i8uEN2ZVREoZOqW0PBJKD",
				header: "_3TFv4L83k0sAQxxxDJCzh9",
				actionHeader: "_3XGx1tfvY30VXMwrnAYMfZ",
				cell: "_30GfT3S_RWhS9B1JiSCaIJ",
				imageCell: "_1mzA539xYQn08RGzbn-Rgl",
				image: "_2UKv8w6-nnOZn6-lOqv57x",
				imagePlaceholder: "_2-8LfoYIQ37smNisBTPrPA",
				title: "_2cEKePFj4PUyuqlM_8uInw",
				caption: "_33iTirQvYAUBeq5vAp6Nr6",
				timeCell: "_1EzbYLhrmLPhhpk2FFAmcj",
				actionCell: "_1JvlfJR1EFT7pnSONpgiXk",
				dropdownSelector: "_2K7txHCmQX-J_7K7zNiCM1",
				byModerator: "_3czV_FVsdvYbnimTT57vCK",
				line: "_22JqeR_rL-tI8mxRb7N8Mq",
				loadingTextLong: "_2AZFpVa_LwltM1gTwCGIDe",
				loadingTextShort: "_1LWRk2sNojXWsOI1Y85nf7"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return K
			})), n.d(t, "b", (function() {
				return Y
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/governance/errorToast.ts"),
				u = n("./src/reddit/actions/toaster.ts"),
				m = n("./src/reddit/components/ModHub/NewModNav/PageLinks.tsx"),
				p = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				b = n("./src/reddit/contexts/ApiContext.tsx"),
				f = n("./src/reddit/endpoints/economics/uploadedAssets.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				g = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				v = n("./src/reddit/selectors/subreddit.ts"),
				x = n("./src/lib/lessComponent.tsx"),
				E = n("./src/reddit/icons/svgs/SnooHappy/index.tsx"),
				O = n("./src/reddit/components/ModHub/BadgesAndEmotes/EmptyState/index.m.less"),
				C = n.n(O);
			const A = {
				[f.a.Uploaded]: {
					title: () => s.fbt._("No more to review!", null, {
						hk: "2rF58X"
					}),
					subtitle: () => s.fbt._("There are no new submissions", null, {
						hk: "3h54Ot"
					})
				},
				[f.a.Approved]: {
					title: () => s.fbt._("Nothing approved yet", null, {
						hk: "157fUO"
					}),
					subtitle: () => s.fbt._("Submissions will be here once you approve them", null, {
						hk: "pLc2c"
					})
				},
				[f.a.Rejected]: {
					title: () => s.fbt._("Nothing rejected yet", null, {
						hk: "1XN9kw"
					}),
					subtitle: () => s.fbt._("Submissions will be here once you reject them", null, {
						hk: "2IYFHB"
					})
				}
			};

			function y(e) {
				const t = A[e.selectedStatus];
				return o.a.createElement("div", {
					className: C.a.container
				}, o.a.createElement(E.a, {
					className: C.a.icon
				}), o.a.createElement("h3", {
					className: C.a.title
				}, t.title()), o.a.createElement("p", {
					className: C.a.subtitle
				}, t.subtitle()))
			}
			var j = n("./src/reddit/components/AuthorLink/index.tsx"),
				I = n("./src/reddit/controls/DropdownSelector/index.tsx"),
				k = n("./src/reddit/components/ModHub/BadgesAndEmotes/index.m.less"),
				_ = n.n(k);
			const S = x.a.div("cell", _.a),
				w = () => [{
					displayText: s.fbt._("New", null, {
						hk: "2xTBYx"
					}),
					value: f.a.Uploaded
				}, {
					displayText: s.fbt._("Approved", null, {
						hk: "1xx5DL"
					}),
					value: f.a.Approved
				}, {
					displayText: s.fbt._("Rejected", null, {
						hk: "25TTJE"
					}),
					value: f.a.Rejected
				}],
				T = () => w().slice(1, 3),
				P = new Intl.DateTimeFormat(void 0, {
					month: "numeric",
					day: "numeric",
					year: "numeric",
					hour: "numeric",
					minute: "numeric",
					second: "numeric"
				}).format;

			function N(e) {
				const {
					item: t,
					onItemAction: n
				} = e, r = w().find(e => e.value === t.status);
				let i = t.type === f.b.Badge ? t.extra.description : void 0;
				return i && i.endsWith(" u/" + t.uploader) && (i = i.slice(0, i.length - t.uploader.length - 3)), o.a.createElement(o.a.Fragment, null, o.a.createElement(S, {
					className: _.a.imageCell
				}, o.a.createElement("div", {
					className: _.a.image,
					style: {
						backgroundImage: `url(${t.url})`
					}
				})), o.a.createElement(S, {
					className: _.a.nameCell
				}, o.a.createElement("div", {
					className: _.a.title
				}, t.type === f.b.Emote ? `:${t.name}:` : t.name), o.a.createElement("div", {
					className: _.a.caption
				}, i, "", o.a.createElement(j.a, {
					author: t.uploader,
					style: {
						color: t.type === f.b.Badge ? t.extra.color : void 0
					}
				}, "u/", t.uploader))), o.a.createElement(S, {
					className: _.a.timeCell
				}, P(t.createdAt)), o.a.createElement(S, {
					className: _.a.actionCell
				}, o.a.createElement(I.a, {
					className: _.a.dropdownSelector,
					displayText: r ? r.displayText : "",
					options: T(),
					onSelect: e => n(t, e.value),
					isCompactStyle: !0
				}), t.status !== f.a.Uploaded && !!t.moderator && !!t.modifiedAt && o.a.createElement("div", {
					className: _.a.byModerator
				}, s.fbt._("by u/ {moderator}, {time-modified}", [s.fbt._param("moderator", t.moderator), s.fbt._param("time-modified", P(t.modifiedAt))], {
					hk: "25I5ES"
				}))), o.a.createElement("div", {
					className: _.a.line
				}))
			}
			const D = x.a.div("cell", _.a),
				M = () => o.a.createElement(o.a.Fragment, null, o.a.createElement(D, {
					className: _.a.imageCell
				}, o.a.createElement("div", {
					className: Object(d.a)(_.a.image, _.a.imagePlaceholder)
				})), o.a.createElement(D, {
					className: _.a.nameCell
				}, o.a.createElement("div", {
					className: _.a.loadingTextLong
				})), o.a.createElement(D, null, o.a.createElement("div", {
					className: _.a.loadingTextShort
				})), o.a.createElement(D, {
					className: _.a.actionCell
				}, o.a.createElement("div", {
					className: _.a.loadingTextShort
				})), o.a.createElement("div", {
					className: _.a.line
				}));
			var R = () => o.a.createElement(o.a.Fragment, null, o.a.createElement(M, null), o.a.createElement(M, null), o.a.createElement(M, null), o.a.createElement(M, null));
			const {
				fbt: L
			} = n("./node_modules/fbt/lib/FbtPublic.js"), B = x.a.div("header", _.a);

			function F(e) {
				const {
					onAssetAction: t,
					assets: n,
					selectedStatus: s
				} = e;
				return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
					className: _.a.grid
				}, o.a.createElement(B, null, L._("Image", null, {
					hk: "3ImlXy"
				})), o.a.createElement(B, null, L._("Name and Description", null, {
					hk: "ZMWPH"
				})), o.a.createElement(B, null, L._("Submission Time", null, {
					hk: "3qPqQa"
				})), o.a.createElement(B, {
					className: _.a.actionHeader
				}, L._("Action", null, {
					hk: "27SYzP"
				})), !n && o.a.createElement(R, null), n && !!n.length && n.map(e => o.a.createElement(N, {
					item: e,
					key: e.name,
					onItemAction: t
				}))), n && !n.length && o.a.createElement(y, {
					selectedStatus: s
				}))
			}
			var U = n("./src/reddit/components/ModHub/BadgesAndEmotes/TabBar/index.m.less"),
				H = n.n(U);
			const G = e => o.a.createElement("button", {
					className: Object(d.a)(H.a.tab, {
						[H.a.selected]: e.selected
					}),
					onClick: e.onClick
				}, e.children),
				Q = e => o.a.createElement("div", {
					className: H.a.tabBar
				}, [f.a.Uploaded, f.a.Approved, f.a.Rejected].map(t => o.a.createElement(G, {
					onClick: () => e.onTabSelected(t),
					selected: t === e.value,
					value: t,
					key: t
				}, (e => {
					switch (e) {
						case f.a.Uploaded:
							return s.fbt._("Uploaded", null, {
								hk: "1AgqhR"
							});
						case f.a.Approved:
							return s.fbt._("Approved", null, {
								hk: "37lIL9"
							});
						case f.a.Rejected:
							return s.fbt._("Rejected", null, {
								hk: "W16pI"
							});
						default:
							return s.fbt._("Uploaded", null, {
								hk: "1AgqhR"
							})
					}
				})(t))));

			function q() {
				return (q = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const W = Object(a.c)({
				subredditName: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(v.h)(e, {
						subredditId: n
					})
				},
				isInShredditModNavExperiment: e => Object(g.a)(e, !0)
			});
			class z extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						selectedStatus: f.a.Uploaded
					}, this.onTabChange = async e => {
						this.setState({
							assets: void 0,
							selectedStatus: e
						});
						const t = await Object(f.c)(this.props.apiContext(), this.props.subredditId, this.props.assetType, e);
						t.ok ? this.setState({
							assets: t.body.assets || []
						}) : this.props.onGovernanceError(t.error)
					}, this.onAssetAction = async (e, t) => {
						if (e.status === t) return;
						const n = this.props.assetType,
							s = await Object(f.d)(this.props.apiContext(), this.props.subredditId, n, e.id, {
								status: t
							});
						if (s.ok) {
							const s = this.state.assets;
							this.setState({
								assets: s && s.filter(t => t !== e)
							}), t === f.a.Approved ? this.props.onApproved(n) : t === f.a.Rejected && this.props.onRejected(n)
						} else this.props.onGovernanceError(s.error)
					}
				}
				componentDidMount() {
					this.onTabChange(this.state.selectedStatus)
				}
				render() {
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(p.a, {
						className: Object(d.a)(_.a.contentContainer, {
							[_.a.newModNav]: this.props.isInShredditModNavExperiment
						})
					}, this.props.isInShredditModNavExperiment && this.props.subredditName ? Object(m.a)(this.props.subredditName, this.props.assetType === f.b.Badge ? c.mc.Badges : c.mc.Emotes, !0, "pb-md") : o.a.createElement(p.b, null, this.props.assetType === f.b.Badge ? s.fbt._("User uploaded badges", null, {
						hk: "3qGdzT"
					}) : s.fbt._("User uploaded emotes", null, {
						hk: "1GJiVz"
					})), o.a.createElement("div", {
						className: _.a.content
					}, o.a.createElement(Q, {
						onTabSelected: this.onTabChange,
						value: this.state.selectedStatus
					}), o.a.createElement(F, {
						selectedStatus: this.state.selectedStatus,
						assets: this.state.assets,
						onAssetAction: this.onAssetAction
					}))))
				}
			}
			const V = Object(b.b)(Object(i.b)(W, (e, t) => ({
					onGovernanceError: t => Object(l.a)(e, t),
					onApproved: t => e(Object(u.f)({
						kind: h.b.SuccessCommunity,
						text: t === f.b.Badge ? s.fbt._("Approved badge!", null, {
							hk: "3B3r07"
						}) : s.fbt._("Approved emote!", null, {
							hk: "tWzSE"
						})
					})),
					onRejected: t => e(Object(u.f)({
						kind: h.b.SuccessCommunity,
						text: t === f.b.Badge ? s.fbt._("Rejected badge", null, {
							hk: "1X6cSg"
						}) : s.fbt._("Rejected emote", null, {
							hk: "3RS2kT"
						})
					}))
				}))(z)),
				K = e => o.a.createElement(V, q({
					assetType: f.b.Badge
				}, e)),
				Y = e => o.a.createElement(V, q({
					assetType: f.b.Emote
				}, e))
		},
		"./src/reddit/components/ModHub/Content/ModQueue.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "getModHubPageName", (function() {
				return D
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/lodash/throttle.js"),
				i = n.n(o),
				a = n("./node_modules/react/index.js"),
				d = n.n(a),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./src/lib/classNames/index.ts"),
				u = n("./src/lib/constants/index.ts"),
				m = n("./src/realtime/GQLSubscription/async.tsx"),
				p = n("./src/reddit/constants/postLayout.ts"),
				b = n("./src/reddit/actions/modQueue/realtime.ts"),
				f = n("./src/reddit/components/TrackingHelper/index.tsx"),
				h = n("./src/reddit/controls/InternalLink/index.tsx"),
				g = n("./src/reddit/selectors/telemetry.ts");
			var v = n("./src/reddit/controls/Button/index.tsx"),
				x = n("./src/reddit/icons/fonts/index.tsx");
			const E = e => {
					let {
						iconName: t,
						heading: n,
						children: s,
						onView: o = (() => {}),
						onDismiss: i = (() => {})
					} = e;
					Object(a.useEffect)(o, []);
					return d.a.createElement("aside", {
						className: "rounded-sm flex items-center mb-lg p-md bg-neutral-background-weak"
					}, d.a.createElement(x.a, {
						name: t,
						className: "text-24 p-sm bg-global-orangered text-white mr-md rounded-sm"
					}), d.a.createElement("div", {
						className: "flex-auto"
					}, d.a.createElement("h3", {
						className: "text-16 font-semibold leading-5"
					}, n), d.a.createElement("p", {
						className: "text-14"
					}, s)), d.a.createElement(v.t, {
						className: "self-start",
						onClick: () => i(),
						priority: v.c.PlainLink,
						Icon: Object(x.b)("close"),
						isSquare: !0,
						size: v.d.XXS,
						"aria-label": r.fbt._("Dismiss message", null, {
							hk: "3rWaLv"
						})
					}))
				},
				{
					fbt: O
				} = n("./node_modules/fbt/lib/FbtPublic.js"),
				C = e => {
					let {
						subredditName: t,
						onDismiss: n
					} = e;
					const s = Object(f.b)();
					return d.a.createElement(E, {
						iconName: "ban",
						onView: () => {
							s((() => e => ({
								source: "modqueue",
								action: "view",
								noun: "ban_evasion_banner",
								subreddit: g.mb(e),
								...g.p(e)
							}))())
						},
						onDismiss: () => {
							s((() => e => ({
								source: "modqueue",
								action: "dismiss",
								noun: "ban_evasion_banner",
								subreddit: g.mb(e),
								...g.p(e)
							}))()), n()
						},
						heading: O._("NEW! Automatically filter content from ban evading users.", null, {
							hk: "3oANC4"
						})
					}, O._("To try it out, turn on the new ban evasion setting. {=Try it now}", [O._param("=Try it now", d.a.createElement(h.default, {
						className: "font-bold text-action-primary hover:underline",
						to: `/mod/${t}/safety/ban-evasion`,
						onClick: () => {
							s((() => e => ({
								source: "modqueue",
								action: "click",
								noun: "ban_evasion_banner",
								subreddit: g.mb(e),
								...g.p(e)
							}))())
						}
					}, O._("Try it now", null, {
						hk: "1BnYzj"
					})))], {
						hk: "2U39SO"
					}))
				};
			var A = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				y = n("./src/reddit/components/ModHub/NewModNav/PageLinks.tsx"),
				j = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				I = n("./src/reddit/components/ModInsightsEntrypointCard/index.tsx"),
				k = n("./src/reddit/components/ModQueueActivitySummaryCards/async.ts"),
				_ = n("./src/reddit/components/ModQueueList/index.tsx"),
				S = n("./src/reddit/components/ModQueueList/LayoutNavigation.tsx"),
				w = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				T = n("./src/reddit/components/CommunitySafetyFeatureAdoptionCampaign/BanEvasion/useBanEvasionAdoptionCampaign.tsx"),
				P = n("./src/reddit/components/ModHub/Content/index.m.less"),
				N = n.n(P);
			const D = e => {
				switch (e) {
					case "modqueue":
						return r.fbt._("Mod Queue", null, {
							hk: "XBRcQ"
						});
					case "reports":
						return r.fbt._("Reports", null, {
							hk: "14I8Zy"
						});
					case "spam":
						return r.fbt._("Spam", null, {
							hk: "3JIGi7"
						});
					case "edited":
						return r.fbt._("Edited", null, {
							hk: "3BN3ms"
						});
					case "unmoderated":
						return r.fbt._("Unmoderated", null, {
							hk: "36ryPx"
						});
					default:
						return r.fbt._("Mod Queue", null, {
							hk: "XBRcQ"
						})
				}
			};
			t.default = e => {
				const {
					showCampaign: t,
					dismissCampaign: n
				} = Object(T.a)(), r = Object(c.d)(), o = Object(a.useCallback)(i()(t => {
					r(Object(b.a)(e.subredditId)), r(Object(b.c)(t))
				}, 1e3), []), f = Object(c.e)(e => Object(w.a)(e, !0)), h = Object(a.useMemo)(() => ({
					input: {
						channel: {
							teamOwner: "MOD",
							subredditID: e.subredditId,
							category: "MOD_UPDATE"
						}
					}
				}), [e.subredditId]), g = () => d.a.createElement(d.a.Fragment, null, t && d.a.createElement(C, {
					subredditName: e.subredditName,
					onDismiss: n
				}), f ? d.a.createElement(d.a.Fragment, null, Object(y.b)(e.subredditName, e.pageName), d.a.createElement(d.a.Fragment, null, d.a.createElement(k.a, {
					className: Object(l.a)(N.a.modActivity, `absolute right-0 ${t?"top-[128px]":"top-[30px]"}`)
				}), d.a.createElement(m.a, {
					variables: h,
					onData: o,
					queryKey: "onModUpdate"
				}))) : d.a.createElement("div", {
					className: N.a.titleContainer
				}, d.a.createElement(j.b, null, D(e.pageName), d.a.createElement(A.a, {
					linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360010090132`
				})), d.a.createElement(d.a.Fragment, null, d.a.createElement(k.a, {
					className: N.a.modActivity
				}), d.a.createElement(m.a, {
					variables: h,
					onData: o,
					queryKey: "onModUpdate"
				}))), d.a.createElement(S.a, {
					hideSubredditFilter: !0,
					postTypeFilter: e.postTypeFilter,
					postSort: e.postSort,
					sendEventWithName: e.sendEventWithName,
					showTypeFilter: e.pageName !== u.mc.Unmoderated,
					subredditName: e.subredditName
				}), d.a.createElement(_.a, {
					after: e.after,
					layout: e.layout,
					sendEventWithName: e.sendEventWithName,
					subredditName: e.subredditName,
					page: e.page,
					pageName: e.pageName,
					postTypeFilter: e.postTypeFilter,
					postSort: e.postSort,
					isInShredditModNavExperiment: f
				}));
				return f ? d.a.createElement("div", {
					className: "flex mx-auto w-fit"
				}, d.a.createElement("div", {
					className: Object(l.a)("mx-0", N.a.container, e.layout === p.g.Large ? N.a.isLargePostLayout : void 0, "relative")
				}, d.a.createElement(g, null)), d.a.createElement("div", {
					className: N.a.sidebar
				}, ("modqueue" === e.pageName || "spam" === e.pageName) && d.a.createElement(I.a, {
					subredditName: e.subredditName,
					pageName: e.pageName
				}))) : d.a.createElement(j.a, {
					className: Object(l.a)(N.a.container, e.layout === p.g.Large ? N.a.isLargePostLayout : void 0, "relative")
				}, d.a.createElement(g, null))
			}
		},
		"./src/reddit/components/ModHub/Content/NoPermissions.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/contexts/NavbarExp.ts"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/components/ModHub/Content/index.m.less"),
				l = n.n(c);
			t.a = e => {
				const t = Object(o.useContext)(a.a);
				return i.a.createElement("div", {
					className: Object(d.a)(l.a.noPermissions, {
						[l.a.noPermissionsExp]: t
					})
				}, i.a.createElement("img", {
					className: l.a.rememberTheHuman,
					src: `${s.a.assetPath}/img/content-gate-icons/remember-the-human.png`
				}), e.isModerator ? r.fbt._("Sorry, you do not have the moderator permissions needed to view this page", null, {
					hk: "4wUDIF"
				}) : r.fbt._("Sorry, this is a moderator-only page", null, {
					hk: "2BZEIA"
				}), i.a.createElement("div", {
					className: l.a.noPermissionsSmallText
				}, e.isModerator ? r.fbt._("You need to change your mod permissions to view this page", null, {
					hk: "RS9sd"
				}) : e.subredditDisplayText ? r.fbt._("You must be a moderator of {subredditName} to view this page", [r.fbt._param("subredditName", e.subredditDisplayText)], {
					hk: "8eU68"
				}) : r.fbt._("You must be a moderator to view this page", null, {
					hk: "2N7TXH"
				})))
			}
		},
		"./src/reddit/components/ModHub/Content/WelcomeMessage.m.less": function(e, t, n) {
			e.exports = {
				ModerateIcon: "khXWcHNm7cUFKCGgNfNPy",
				moderateIcon: "khXWcHNm7cUFKCGgNfNPy",
				ModHubWelcomeMessage: "_1WUhYUiKwTt20VZZiLFRXQ",
				modHubWelcomeMessage: "_1WUhYUiKwTt20VZZiLFRXQ"
			}
		},
		"./src/reddit/components/ModHub/Content/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "CgYEK3BSwEitV3N5dS53Y",
				titleFontH2: "WtxSi4x3A6EHSYOlNO6dC",
				titleFontH3: "_1s8gRCw9ZEGeZdDLi4SjEs",
				titleFontH4: "iJgEN-DVO9xH1ING9PGia",
				titleFontH5: "_1Pk2HmstIcHsVCyXL0s7WR",
				titleFontH6: "_27G51xRMOXRk6p8hF2iFF4",
				metadataFont: "_3qFnOmsyfNVU4dOg-nT7AH",
				flairFont: "IHVtmv3d9vjFTy7sOv4nb",
				labelsFont: "_3veeqeCCuB-y_5Uz7aZwNo",
				actionFont: "_2GGs_1qJNsgRTBkJjB3JyV",
				smallButtonFont: "_1wMkSw4TKFwpURuJjoijc8",
				largeButtonFont: "_37n4mei_IKI2b0S9cUN6kj",
				strongTextFont: "_3iiIycx9Jvd-wtbZRRlyrS",
				tabFont: "_2uzD_ZiaRuda1gPntdeFV-",
				buttonFontXS: "X1zM6CuE0STTL567u2KEr",
				buttonFontXs: "X1zM6CuE0STTL567u2KEr",
				buttonFontS: "_35xxostuR-t_KnCQpTxb0F",
				buttonFontM: "_1siVd6fOXNWDs8SbSH_HQ5",
				buttonFontL: "_1mAbhFs88EE9k-jaJMzlbM",
				buttonFontXL: "FxQ8KBPxEROiwB1EG0sLr",
				buttonFontXl: "FxQ8KBPxEROiwB1EG0sLr",
				bodyFontH1: "_18F7ywSczMXfDxvUzIkKou",
				bodyFontH2: "_2gpSS7qXgM9-crN9KgQr_O",
				bodyFontH3: "-JM-6-h-SOMTCi9a5ZG0g",
				bodyFontH4: "_3ZVYgWzZxJjL_cahDG32l",
				bodyFontH5: "_15iJEJUM-il2Ud09a9yqhY",
				bodyFontH6: "_2kFIrTxjdWaprwQ9leev5x",
				bodyFontH6Small: "mhRrYXj7dAprAm-wE7DdO",
				bodyFont: "_38q9ZzND20FKMoX8BeB0u8",
				bodyFontSmall: "_1tFfFAHeLftmld2a2M4yIs",
				bodyFontMono: "_1N1SJCd40K_9LeW3MSWULf",
				landingPageTitleFontH1: "_188OUQdkNVSC4VoI3use3H",
				landingPageTitleFontH2: "_1Nsrmd1KvVz-41wIUPMJMp",
				landingPageTitleFontH3: "_2pcqzLgqwagTSQPKkGNO-q",
				rememberTheHuman: "_2S6IM2TPtTriI4r_2Op1Od",
				noPermissions: "_3jaCG74Q3u55JqGJy3u664",
				noPermissionsExp: "_30KCF1VJPMgbkHOfEhoE2p",
				noPermissionsSmallText: "_1Kxv5kLQoEOhRatEhltXrQ",
				container: "_3gsyCuYXsGWEEgPSTuX9aw",
				isLargePostLayout: "_1WGjuBpIEjcQC-x3_lE_Nu",
				titleContainer: "_2SyYApGPPZkM6bG9SnSk1k",
				modActivity: "zsQHq8K9sST2NCbphllOm",
				sidebar: "_10tZ9L8aymVncl-lbxMYqM"
			}
		},
		"./src/reddit/components/ModHub/Content/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/assertNever.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/reddit/components/ApprovedSubmitterList/index.tsx"),
				l = n("./src/reddit/components/BannedUserList/index.tsx"),
				u = n("./src/reddit/components/CCM/ModerationLog/index.tsx"),
				m = n("./src/reddit/components/CommunityAwardList/index.tsx"),
				p = n("./src/reddit/components/CommunitySettings/index.tsx"),
				b = n("./src/reddit/components/GrantUserFlair/index.tsx"),
				f = n("./src/reddit/components/ModeratorsList/index.tsx"),
				h = n("./src/reddit/components/ModHub/ApprovedTalkHosts/index.tsx"),
				g = n("./src/reddit/components/ModHub/BadgesAndEmotes/index.tsx"),
				v = n("./src/reddit/components/ModHub/Emojis/index.tsx"),
				x = n("./src/reddit/components/MutedUserList/index.tsx"),
				E = n("./src/reddit/components/RemovalReasons/index.tsx"),
				O = n("./src/reddit/components/SubredditContent/PredictionsContent/async.ts"),
				C = n("./src/reddit/components/SubredditContent/ScheduledPostContent/index.tsx"),
				A = n("./src/reddit/components/SubredditRules/index.tsx"),
				y = n("./src/reddit/pages/ErrorPages/index.tsx"),
				j = n("./src/reddit/selectors/experiments/eventPosts.ts");
			const I = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-ContentControls",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("reddit-components-ModHub-ContentControls").then(n.bind(null, "./src/reddit/components/ModHub/ContentControls/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/ContentControls/index.tsx"
					}
				}),
				k = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-TrafficStats",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("reddit-components-ModHub-TrafficStats").then(n.bind(null, "./src/reddit/components/ModHub/TrafficStats/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/TrafficStats/index.tsx"
					}
				}),
				_ = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-flairs-PostFlairManagement",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("reddit-components-ModHub-flairs-PostFlairManagement~reddit-components-ModHub-flairs-UserFlairManagement"), n.e("reddit-components-ModHub-flairs-PostFlairManagement")]).then(n.bind(null, "./src/reddit/components/ModHub/flairs/PostFlairManagement/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/flairs/PostFlairManagement/index.tsx"
					}
				}),
				S = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-flairs-UserFlairManagement",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("reddit-components-ModHub-flairs-PostFlairManagement~reddit-components-ModHub-flairs-UserFlairManagement"), n.e("reddit-components-ModHub-flairs-UserFlairManagement")]).then(n.bind(null, "./src/reddit/components/ModHub/flairs/UserFlairManagement/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/flairs/UserFlairManagement/index.tsx"
					}
				}),
				w = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-Wiki-ModHubWikiManagement",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("reddit-components-Wiki-ModHubWikiManagement").then(n.bind(null, "./src/reddit/components/Wiki/ModHubWikiManagement/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/Wiki/ModHubWikiManagement/index.tsx"
					}
				}),
				T = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-Content-ModQueue",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.resolve().then(n.bind(null, "./src/reddit/components/ModHub/Content/ModQueue.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/Content/ModQueue.tsx"
					}
				}),
				P = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-SubredditContent-EventPostContent",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("reddit-components-SubredditContent-EventPostContent").then(n.bind(null, "./src/reddit/components/SubredditContent/EventPostContent/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/SubredditContent/EventPostContent/index.tsx"
					}
				}),
				N = e => {
					const {
						layout: t,
						pageName: n,
						postTypeFilter: s,
						postSort: r,
						subpageName: N,
						...D
					} = e, M = Object(i.e)(j.a), R = {
						...D,
						subredditId: e.subreddit.id
					};
					switch (n) {
						case d.mc.Removal:
							return o.a.createElement(E.a, {
								subredditId: e.subreddit.id,
								sendEventWithName: e.sendEventWithName
							});
						case d.mc.Contributors:
							return o.a.createElement(c.a, R);
						case d.mc.Banned:
							return o.a.createElement(l.a, R);
						case d.mc.Muted:
							return o.a.createElement(x.a, R);
						case d.mc.Moderators:
							return o.a.createElement(f.a, R);
						case d.mc.Modlog:
							return o.a.createElement(u.a, R);
						case d.mc.ContentControls:
							return o.a.createElement(I, {
								subredditName: e.subreddit.name
							});
						case d.mc.Flair:
							return o.a.createElement(b.a, {
								after: e.after,
								before: e.before,
								subredditId: e.subreddit.id
							});
						case d.mc.PostFlair:
							return o.a.createElement(_, {
								subredditId: e.subreddit.id
							});
						case d.mc.UserFlair:
							return o.a.createElement(S, {
								subredditId: e.subreddit.id
							});
						case d.mc.Badges:
							return o.a.createElement(g.a, {
								subredditId: e.subreddit.id
							});
						case d.mc.Emotes:
							return o.a.createElement(g.b, {
								subredditId: e.subreddit.id
							});
						case d.mc.SubredditRules:
							return o.a.createElement(A.a, {
								subreddit: e.subreddit
							});
						case d.mc.CommunitySettings:
							return o.a.createElement(p.a, {
								subredditId: e.subreddit.id,
								subpageName: e.subpageName,
								subredditName: e.subreddit.name
							});
						case d.mc.Modqueue:
						case d.mc.Reports:
						case d.mc.Spam:
						case d.mc.Edited:
						case d.mc.Unmoderated:
							return o.a.createElement(T, {
								after: e.after,
								layout: t,
								page: e.page,
								pageName: n,
								postTypeFilter: s,
								postSort: r,
								sendEventWithName: e.sendEventWithName,
								subredditName: e.subreddit.name,
								subredditId: e.subreddit.id
							});
						case d.mc.Awards:
							return o.a.createElement(m.a, {
								subredditOrProfile: e.subreddit,
								subredditOrProfileId: e.subreddit.id,
								moderatorPermissions: e.moderatorPermissions
							});
						case d.mc.Emojis:
							return o.a.createElement(v.a, {
								subreddit: e.subreddit
							});
						case d.mc.Wiki:
						case d.mc.WikiContributors:
						case d.mc.WikiBanned:
							return o.a.createElement(w, {
								subreddit: e.subreddit
							});
						case d.mc.Traffic:
							return o.a.createElement(k, {
								subreddit: e.subreddit
							});
						case d.mc.SubredditContent:
							return null;
						case d.mc.ScheduledPostContent:
							return o.a.createElement(C.a, {
								subreddit: e.subreddit
							});
						case d.mc.EventPostContent:
							return M ? o.a.createElement(y.b, null) : o.a.createElement(P, {
								subredditName: e.subreddit.name
							});
						case d.mc.Predictions:
							return o.a.createElement(O.a, {
								subreddit: e.subreddit
							});
						case d.mc.TalkHosts:
							return o.a.createElement(h.a, {
								subredditName: e.subreddit.name,
								subredditId: e.subreddit.id,
								moderatorPermissions: e.moderatorPermissions,
								sendEventWithName: e.sendEventWithName
							});
						default:
							return Object(a.a)(n)
					}
				};
			t.a = N
		},
		"./src/reddit/components/ModHub/ContentControls/FormSections/HatefulContentFilters/useHCFAdoptionCampaign.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/constants/experiments.ts"),
				a = n("./src/reddit/featureFlags/index.ts"),
				d = n("./src/reddit/hooks/useExperimentVariant.ts");

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function l() {
				const e = Object(d.a)(i.se),
					t = Object(o.e)(a.d.hatefulContentFiltersEnabled);
				return e === i.Yd && t
			}

			function u(e) {
				function t(t) {
					const n = l();
					return r.a.createElement(e, c({}, t, {
						showHCFNewTagsCampaign: n
					}))
				}
				const n = e.name || e.displayName;
				return t.displayName = `HCFAdoptionNewTagCampaign(${n})`, t.WrappedComponent = e, t
			}
		},
		"./src/reddit/components/ModHub/Emojis/EmojiUploadModal/index.m.less": function(e, t, n) {
			e.exports = {
				checkbox: "_20ADRJAodM5zU1OpvNEeRz",
				checkboxText: "_21Bw38NODPHxkJ8zAXjoUZ",
				closeButton: "_3m2cog1fzR2zNYfyXI2GUB",
				emojiDisplay: "_1mMSj2QBZEQ97i-4y3-WOp",
				emojiNameDisplay: "_2lbIQVKPZ4LHDNpBLwSOps",
				imageDisplay: "_3BXziWyChS-zhQ5XC9lt4k",
				appearsIn: "_1DhToTbLLM2OC-Ze5nDwCq",
				imageTitle: "_2KrLezTGMfd18btz-KkYMi",
				modalBody: "_1PLlW-_ZV0vWQQ6LS1Z2lH",
				modalAddButton: "_1vUjBClk27uHOAYH__0rj9",
				modalCancelButton: "_23RRFTkR9NKrC22rmMDNfI",
				modFlairOnlyToggle: "_19ExxuLL5lOZW35TZFXIHf",
				modIcon: "_3ta-U9hY9R1H_BRwYv1zhl",
				modProTip: "_2yN7aUrL8peCADm-u303LV",
				modProTips: "_3WtRXJc1jCLpCEw7-mlEBU",
				proTip: "_8wjmRK1w6qEGzue3BNNOA",
				modProTipTitle: "_392GI--ZxhpUHn1eRTKzqA",
				tipList: "_3PPlagKiQrtoOsW4pcf3vc"
			}
		},
		"./src/reddit/components/ModHub/Emojis/EmojiUploader/index.m.less": function(e, t, n) {
			e.exports = {
				alertIcon: "_34rhMfrLYNSjUkhTK958Um",
				characterCountdown: "_15Hq3tMBKH4TWo9OJs8gny",
				clearIcon: "aCmT6tHKACP3PLk6IU6XT",
				duplicatesIcon: "Eq88P0Zb-rOoo4N5OL5uk",
				duplicateWarning: "DRp2YTik6Ln3yUKp7LBUv",
				editEmojiFooter: "_2ZoRiRDs45wlLK-ZnHzUh",
				editEmojiDisplay: "_2rDJJ0Uk_ySvUA9QNoKoKU",
				emojiDisplays: "_2FsakuX5ZR_IIPcwXQu0eD",
				errorText: "_3bRRwpzb2xfP5erPt9R6Cg",
				expandLeft: "_2byjR1IbLclRfoyvyjMDUz",
				iconSpacer: "_3tWeESqi0MQaqN5wKqkv68",
				imageDisplay: "_1MHWj3sdAGALX7r7UzFF0J",
				duplicateInput: "_280zGglckljUYhFjwaBt14",
				input: "_3xzW-TBy6RXHXBjCE9Yz7s",
				inputPlaceholder: "_1964bAdk8xBAb8-d_Mthtt",
				modalAddButton: "_2yQ10LXNPJ6antT2NgaTmI",
				modalCancelButton: "_31Qk2tb7PaP2XWWL2o4HM1",
				modProTip: "NSSpRN8n70A1TesDNcvxE",
				progressBar: "_3EbPa1JwqT9b_QgXnHzJsx",
				innerBarClassName: "_3CJpdsYAp2vfEOO_U7AaO8",
				progressText: "Wz5fdVLDZuS4d-ix-j4s9",
				replacingDescription: "_1oXr6AKswirSKypchDoX1n",
				replacingTitle: "oNyr5QxUcemiI3SFwjhvc",
				uploadingTitle: "_3ZEFRZKrLVT92hTIG7sRa9",
				textButton: "_3ZzQTZKV1t84-ND6HHwnsx",
				uploaderContainer: "OCFZ6HIQUbokDXiubxQEZ"
			}
		},
		"./src/reddit/components/ModHub/Emojis/index.m.less": function(e, t, n) {
			e.exports = {
				alertIcon: "_3x5p0Ujs6EWdeLO8-fVE7v",
				emojisDisabled: "_2H7y73ZptDGSake8tFEj0n",
				labelTitle: "_2R2K1Sz81kscliWYqOq1xU",
				labelDescription: "_1TqFvv__UfmckLHp5llo7q",
				leftForm: "_22aW9zYAhDGH2HdlJ-WWIM",
				modalBody: "_1_UK8ZmVC7e_nkeSs5CGnA",
				modalCloseButton: "_2-arZqA5i-aG-76OM9aj7k",
				modalEnableSection: "_2Wd3qBH4SU1NauwzVOQbVT",
				modalFooter: "_2R2UP3vtcyZqyNdUy9Y0nX",
				modalSubmitButton: "w7T2GA8_RqtkSpD4h6YKH",
				modalCancelButton: "_2wvHObzKgyjObCvFZ0QOp0",
				rightForm: "_1eE1s4H4f1_A3ck0iF679O",
				row: "_2NQoOHp9q7uhb8h4XdVWK",
				displayWrapper: "jiCIuKa0E1BjfGfUV407r",
				emojiDisplay: "_32BxZer8uLzSVJMZqqo95_",
				emojiName: "_2hJHG1X01WKzuznOL4l6ge",
				appears: "ZVOiCMvsomJLwhS8k4VPP",
				permissions: "UxdnKubszq3iR9sJGFwiY",
				buttonWrapper: "PflXNgwgKckPGaFe9wW8V",
				editEmoji: "_3RR0-7gyjso1AHuVhVbb6u",
				editSnoomoji: "FCFv4UPC_NQjiTCEBoOCD",
				trashIcon: "_2l2KeCLkXUEz_czKdpFqSw",
				settingsButton: "_2dh14d_OrE4Etrg44_cb4t",
				toggleSwitch: "_17kocpcRdOCXJwPiOk68B-",
				topRow: "_2oevuimQpT3hztJ5Rpf_hy",
				appearsTitle: "_1Qzxm6lOFpTR3O3hzKloA9",
				imageTitle: "_1NOoO9mz09cpZjIRT9nHTh",
				nameTitle: "_1Ra9yqtrrSj9q0akrKs83v",
				permissionsTitle: "_1gNO8_Ywz6va1MbMV7-jDG",
				titleTooltip: "_279Uba_Gpg0WVLV8efIdK_",
				newModNavContainer: "_2slVFPJEI9_l-E7avbt2dg",
				topBar: "XfGzuNb2QEgJg7Sf7YrbL",
				fixed: "_1rBXh3rk0i6IvI6ljcOVd3",
				default: "_1UchQlbHX28_47zOwcEeNR"
			}
		},
		"./src/reddit/components/ModHub/Emojis/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/lodash/map.js"),
				i = n.n(o),
				a = n("./node_modules/react/index.js"),
				d = n.n(a),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/classNames/index.ts"),
				m = n("./src/lib/constants/index.ts"),
				p = n("./src/lib/lessComponent.tsx"),
				b = n("./src/reddit/actions/emoji.ts"),
				f = n("./src/reddit/actions/modal.ts"),
				h = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				g = n("./src/reddit/components/InfoBanners/BannerBase/index.tsx"),
				v = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				x = n("./src/reddit/components/ModHub/InfoTooltip/index.tsx"),
				E = n("./src/reddit/components/ModHub/NewModNav/PageLinks.tsx"),
				O = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				C = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				A = n("./src/reddit/components/TrackingHelper/index.tsx"),
				y = n("./src/reddit/constants/colors.ts"),
				j = n("./src/reddit/controls/Button/index.tsx"),
				I = n("./src/reddit/featureFlags/index.ts"),
				k = n("./src/reddit/selectors/telemetry.ts");
			const _ = e => ({
					subreddit: k.mb(e),
					profile: k.U(e),
					userSubreddit: k.vb(e)
				}),
				S = (e, t) => n => ({
					source: "emoji",
					action: "toggle",
					noun: e,
					actionInfo: {
						settingValue: t ? "on" : "off"
					},
					..._(n)
				}),
				w = e => t => ({
					source: "emoji",
					action: "click",
					noun: e,
					..._(t)
				}),
				T = (e, t) => n => ({
					source: "emoji",
					action: "click",
					noun: e,
					actionInfo: k.d(n, {
						count: t
					}),
					..._(n)
				});
			var P = n("./src/reddit/icons/svgs/QuarantineWarning/index.tsx"),
				N = n("./src/reddit/selectors/activeModalId.ts"),
				D = n("./src/reddit/selectors/emojis.ts"),
				M = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				R = n("./src/reddit/components/ModHub/Emojis/index.m.less"),
				L = n.n(R),
				B = n("./src/reddit/controls/ImageDisplay/index.tsx"),
				F = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				U = n("./src/reddit/layout/row/Inline/index.tsx");
			const H = p.a.span("appears", L.a),
				G = p.a.span("buttonWrapper", L.a),
				Q = p.a.span("displayWrapper", L.a),
				q = p.a.wrapped(B.a, "emojiDisplay", L.a),
				W = p.a.span("emojiName", L.a),
				z = p.a.span("permissions", L.a),
				V = p.a.wrapped(U.a, "row", L.a),
				K = p.a.wrapped(F.b, "trashIcon", L.a);
			var Y = e => d.a.createElement(V, null, d.a.createElement(Q, null, d.a.createElement(q, {
					backgroundImage: e.emoji.url
				})), d.a.createElement(W, null, e.emoji.name), d.a.createElement(H, null, ((e, t) => e && t ? r.fbt._("Post flair, user flair", null, {
					hk: "gLvKb"
				}) : e ? r.fbt._("Post flair", null, {
					hk: "dcIoz"
				}) : t ? r.fbt._("User flair", null, {
					hk: "4fQagx"
				}) : "")(e.emoji.postFlairAllowed, e.emoji.userFlairAllowed)), d.a.createElement(z, null, e.emoji.modFlairOnly && r.fbt._("Mod only", null, {
					hk: "NMZoE"
				})), d.a.createElement(G, null, d.a.createElement(j.r, {
					className: e.isSnoomoji ? L.a.editSnoomoji : L.a.editEmoji,
					onClick: () => e.onEdit(e.emoji, e.isSnoomoji)
				}, r.fbt._("Edit", null, {
					hk: "1nftDt"
				})), !e.isSnoomoji && d.a.createElement("button", {
					onClick: () => e.onRemove(e.emoji.name)
				}, d.a.createElement(K, null)))),
				J = n("./src/higherOrderComponents/asModal/index.tsx"),
				X = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				Z = n("./src/reddit/controls/TextButton/index.tsx"),
				$ = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				ee = n("./src/reddit/selectors/subreddit.ts"),
				te = n("./src/reddit/controls/ToggleSwitch/index.tsx");
			const ne = p.a.span("labelDescription", L.a),
				se = p.a.span("labelTitle", L.a),
				re = p.a.div("leftForm", L.a),
				oe = p.a.div("rightForm", L.a),
				ie = p.a.wrapped(te.a, "toggleSwitch", L.a);
			var ae = e => d.a.createElement("div", {
				className: e.className
			}, d.a.createElement(re, null, d.a.createElement(se, null, r.fbt._("{title}", [r.fbt._param("title", e.title)], {
				hk: "4bYhaP"
			})), d.a.createElement(ne, null, r.fbt._("{description}", [r.fbt._param("description", e.description)], {
				hk: "1lFxbr"
			}))), d.a.createElement(oe, null, d.a.createElement(ie, {
				on: e.on,
				onToggle: e.onToggle
			})));
			const de = p.a.wrapped(ae, "modalEnableSection", L.a),
				ce = p.a.wrapped(X.e, "modalBody", L.a),
				le = p.a.wrapped(X.a, "modalCancelButton", L.a),
				ue = p.a.wrapped(Z.a, "modalCloseButton", L.a),
				me = p.a.wrapped(X.g, "modalFooter", L.a),
				pe = p.a.wrapped(j.l, "modalSubmitButton", L.a),
				be = Object(l.c)({
					isEmojisEnabled: (e, t) => Object(ee.z)(e, {
						subredditName: t.subreddit.name
					}).emojisEnabled
				}),
				fe = Object(c.b)(be, (e, t) => {
					let {
						subreddit: n
					} = t;
					return {
						toggleEnableEmojis: t => e(Object(b.j)(n.id, t))
					}
				});
			class he extends d.a.Component {
				constructor(e) {
					super(e), this.handleEnableEmojisToggle = () => this.setState({
						emojisEnabled: !this.state.emojisEnabled
					}), this.enableHasBeenToggled = () => this.props.isEmojisEnabled !== this.state.emojisEnabled, this.canSave = () => this.enableHasBeenToggled(), this.onSave = () => {
						const {
							props: e,
							state: t
						} = this;
						this.enableHasBeenToggled() && (e.toggleEnableEmojis(t.emojisEnabled), e.sendEvent(S("enable", t.emojisEnabled))), e.toggleModal(), e.sendEvent(w("save_emoji_settings"))
					}, this.state = {
						emojisEnabled: e.isEmojisEnabled
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return d.a.createElement(ce, null, d.a.createElement(X.i, null, d.a.createElement($.a, null, d.a.createElement(X.q, null, r.fbt._("Emoji settings", null, {
						hk: "1GjUM3"
					})), d.a.createElement(ue, {
						onClick: e.toggleModal
					}, d.a.createElement(X.b, null)))), d.a.createElement(X.l, null, d.a.createElement(de, {
						description: r.fbt._("Allow emojis to be used in post and user flair within your community", null, {
							hk: "3ppqgX"
						}),
						on: t.emojisEnabled,
						onToggle: this.handleEnableEmojisToggle,
						title: r.fbt._("Enable emojis in this community", null, {
							hk: "3uLrQi"
						})
					})), d.a.createElement(me, null, d.a.createElement(le, {
						onClick: e.toggleModal
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), d.a.createElement(pe, {
						disabled: !this.canSave(),
						onClick: this.onSave
					}, r.fbt._("Save", null, {
						hk: "4yMsMq"
					}))))
				}
			}
			var ge = Object(J.a)(fe(he)),
				ve = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/actions/toaster.ts")),
				xe = n("./src/reddit/components/StructuredStyles/ImageUpload/index.tsx"),
				Ee = n("./src/reddit/components/StructuredStyles/StyledComponents/forms.ts"),
				Oe = n("./src/reddit/controls/CheckboxInput/index.tsx"),
				Ce = n("./src/reddit/icons/svgs/Moderate/index.tsx"),
				Ae = n("./src/reddit/layout/twoCol/ExpandRight/index.tsx"),
				ye = n("./src/reddit/models/Image/index.tsx"),
				je = n("./src/reddit/models/Toast/index.ts"),
				Ie = n("./src/reddit/components/ModHub/Emojis/EmojiUploadModal/index.m.less"),
				ke = n.n(Ie),
				_e = n("./src/higherOrderComponents/withImageUploads.tsx"),
				Se = n("./src/reddit/icons/svgs/ClearFilled/index.tsx"),
				we = n("./src/reddit/models/Emoji/index.ts"),
				Te = n("./src/reddit/components/ModHub/Emojis/EmojiUploader/index.m.less"),
				Pe = n.n(Te),
				Ne = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				De = n("./src/reddit/components/ProgressBar/index.tsx"),
				Me = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				Re = n("./src/reddit/controls/ErrorText/index.tsx");
			const Le = 5,
				Be = 95,
				Fe = 600,
				Ue = 100;
			class He extends d.a.Component {
				constructor() {
					super(...arguments), this.intervalToken = 0, this.state = {
						timeStarted: Date.now(),
						percent: Le
					}, this.tick = () => {
						const e = function(e) {
							const t = e / Fe,
								n = (Math.log(t / 10) + 3) / 2.1;
							return Math.max(Be, Math.min(Le, 100 * n))
						}(Date.now() - this.state.timeStarted);
						this.setState({
							percent: e
						}), e === Be && this.intervalToken && window.clearInterval(this.intervalToken)
					}
				}
				componentDidMount() {
					this.intervalToken = window.setInterval(this.tick, Ue)
				}
				componentWillUnmount() {
					this.intervalToken && window.clearInterval(this.intervalToken)
				}
				render() {
					return d.a.createElement(De.a, {
						className: Pe.a.progressBar,
						innerBarClassName: Pe.a.innerBarClassName,
						percent: this.state.percent
					})
				}
			}
			var Ge = He;
			const Qe = p.a.wrapped(Ne.a, "characterCountdown", Pe.a),
				qe = p.a.wrapped(Se.a, "clearIcon", Pe.a),
				We = p.a.wrapped(Re.b, "errorText", Pe.a),
				ze = p.a.wrapped($.a, "expandLeft", Pe.a),
				Ve = p.a.div("iconSpacer", Pe.a),
				Ke = p.a.wrapped(B.a, "imageDisplay", Pe.a),
				Ye = p.a.div("inputPlaceholder", Pe.a),
				Je = p.a.wrapped($.a, "inputPlaceholder", Pe.a),
				Xe = p.a.wrapped(Z.a, "textButton", Pe.a);
			class Ze extends d.a.Component {
				constructor() {
					super(...arguments), this.handleChangeEmojiName = e => {
						this.props.onChangeEmojiName && this.props.onChangeEmojiName(this.props.index, e.target.value)
					}, this.handleRemove = e => {
						this.props.onCancel(this.props.index)
					}, this.renderContent = () => {
						const {
							emojiName: e,
							errorText: t,
							fileName: n,
							handleRetry: s,
							imageData: o,
							isDuplicate: i
						} = this.props;
						switch (o.kind) {
							case ye.b.NotUploaded:
							case ye.b.Pending:
								return d.a.createElement("div", null, d.a.createElement(Je, null, o.kind === ye.b.NotUploaded ? d.a.createElement(Ge, null) : d.a.createElement(De.a, {
									className: Pe.a.progressBar,
									innerBarClassName: Pe.a.innerBarClassName,
									percent: 0
								}), d.a.createElement(Xe, {
									onClick: this.handleRemove
								}, r.fbt._("Cancel", null, {
									hk: "2TSLl5"
								}))), d.a.createElement(Ee.b, null, r.fbt._("Uploading {fileName}", [r.fbt._param("fileName", n)], {
									hk: "NIxvK"
								})));
							case ye.b.FailedToUpload:
							case ye.b.Invalid:
								return d.a.createElement("div", null, d.a.createElement(Je, null, r.fbt._("Failed to upload", null, {
									hk: "2LBRW2"
								}), s ? d.a.createElement(Xe, {
									onClick: s
								}, r.fbt._("Retry", null, {
									hk: "3EwbaK"
								})) : d.a.createElement(Xe, {
									onClick: this.handleRemove
								}, r.fbt._("Remove", null, {
									hk: "3tYl0U"
								}))), t && d.a.createElement(We, null, t));
							case ye.b.Uploaded:
								return d.a.createElement(Ye, null, r.fbt._("Saved", null, {
									hk: "2xDFZZ"
								}));
							default:
								return d.a.createElement("div", null, d.a.createElement(Me.c, {
									className: i ? Pe.a.duplicateInput : Pe.a.input,
									onChange: this.handleChangeEmojiName,
									placeholder: r.fbt._("Emoji name", null, {
										hk: "UpQdA"
									}),
									value: e
								}), d.a.createElement(ze, null, d.a.createElement(Qe, {
									maxChars: we.d,
									text: e
								}), d.a.createElement(Xe, {
									onClick: this.handleRemove
								}, r.fbt._("Remove", null, {
									hk: "3tYl0U"
								}))), t && d.a.createElement(We, null, t))
						}
					}
				}
				render() {
					const {
						emojiName: e,
						imageData: t,
						isSaving: n
					} = this.props;
					return n ? d.a.createElement(d.a.Fragment, null, d.a.createElement(Ye, null, d.a.createElement(Ge, null)), d.a.createElement(Ee.b, null, r.fbt._("Saving {emojiName}", [r.fbt._param("emojiName", e)], {
						hk: "3lMST7"
					}))) : d.a.createElement(Ae.a, null, t.kind === ye.b.FailedToUpload || t.kind === ye.b.Invalid ? d.a.createElement(Ve, null, d.a.createElement(qe, null)) : d.a.createElement(Ke, {
						backgroundImage: t.url
					}), this.renderContent())
				}
			}
			var $e = Ze,
				et = n("./node_modules/lodash/countBy.js"),
				tt = n.n(et),
				nt = n("./node_modules/lodash/filter.js"),
				st = n.n(nt),
				rt = n("./node_modules/lodash/includes.js"),
				ot = n.n(rt),
				it = n("./node_modules/lodash/transform.js"),
				at = n.n(it);
			const dt = /^[A-Za-z0-9_-]{1,24}$/,
				ct = ["reddit", "snoo", "spez"],
				lt = (e, t, n) => !dt.test(e) || !n && (e => {
					const t = e.toLowerCase();
					return ct.reduce((e, n) => e || -1 !== t.indexOf(n), !1)
				})(e) ? r.fbt._("Invalid emoji name", null, {
					hk: "2Oromm"
				}) : ot()(t, e) ? r.fbt._("This name is already taken", null, {
					hk: "4dwdJL"
				}) : "",
				ut = e => e.name ? e.name.replace(/\.[^.]*$/, "").replace(/[^A-Za-z0-9_-]/g, " ").trim().replace(/ +/g, "_").slice(0, 24) : "",
				mt = (e, t) => (t.kind !== ye.b.TempUploaded || !e.emojiNameError && !e.isNameMissing) && (t.kind !== ye.b.NotUploaded && t.kind !== ye.b.Pending),
				pt = e => {
					let t = "";
					return e.file.size > we.a ? t = "file-size-error" : (e.height > we.b || e.width > we.c) && (t = "image-size-error"), {
						emojiNameError: "",
						imageError: t,
						name: ut(e.file),
						fileName: e.file.name,
						isNameMissing: !1
					}
				},
				bt = (e, t) => t.reduce((t, n) => n.kind === e ? t + 1 : t, 0),
				ft = (e, t) => {
					const {
						emojiNameError: n,
						imageError: s,
						isNameMissing: o
					} = t;
					let i = "";
					e.kind === ye.b.FailedToUpload && (i = e.error.fields && e.error.fields.length ? e.error.fields[0].msg : r.fbt._("Something went wrong", null, {
						hk: "2fCWXR"
					}));
					const a = i || !1,
						d = n || !!o && r.fbt._("Emoji name is required", null, {
							hk: "4sL3l7"
						});
					let c = "";
					return "file-size-error" === s ? c = r.fbt._("File size too large", null, {
						hk: "EksGU"
					}) : "image-size-error" === s && (c = r.fbt._("Image size too large", null, {
						hk: "1xjOmq"
					})), c || a || d || ""
				},
				ht = e => {
					const t = st()(e, e => !e.emojiNameError && !e.imageError),
						n = tt()(t, e => e.name);
					return at()(n, (e, t, n) => {
						t > 1 && e.push(n)
					}, [])
				},
				gt = 500,
				vt = p.a.div("UploaderContainer", Pe.a),
				xt = p.a.wrapped(P.a, "alertIcon", Pe.a),
				Et = p.a.wrapped(Se.a, "duplicatesIcon", Pe.a),
				Ot = p.a.wrapped(X.p, "duplicateWarning", Pe.a),
				Ct = p.a.wrapped(j.l, "modalAddButton", Pe.a),
				At = p.a.wrapped(X.a, "modalCancelButton", Pe.a),
				yt = p.a.div("uploaderContainer", Pe.a),
				jt = p.a.wrapped(X.p, "modProTip", Pe.a),
				It = p.a.div("progressText", Pe.a),
				kt = p.a.wrapped(X.p, "replacingDescription", Pe.a),
				_t = p.a.div("replacingTitle", Pe.a),
				St = p.a.div("uploadingTitle", Pe.a),
				wt = Object(l.c)({
					emojis: D.d,
					isSnoomojiSubreddit: ee.n,
					reservedEmojiNames: D.e
				}),
				Tt = Object(c.b)(wt, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						emojisUploadedToast: () => e(ve.f({
							kind: je.b.SuccessCommunityGreen,
							text: r.fbt._("New emojis added!", null, {
								hk: "1Q1mEq"
							})
						})),
						saveEmoji: (t, s, r) => e(Object(b.n)({
							imageData: t,
							subredditId: n,
							emojiName: s,
							settings: r
						}))
					}
				});
			class Pt extends d.a.Component {
				constructor(e) {
					super(e), this.timeoutToken = 0, this.loadIndex = 0, this.tempUploadNext = async () => {
						const e = this.getNextPendingImageToLoad();
						if (!e) return this.timeoutToken = 0, void(this.loadIndex = 0);
						const {
							subredditId: t
						} = this.props, n = this.state.emojiData[e.id], s = Object(ye.m)(e);
						await this.props.uploadImage({
							imageData: s,
							subredditId: t,
							emojiName: n.name,
							settings: this.props.emojiSettings
						}), this.loadIndex += 1, this.loadIndex < this.state.localData.length ? this.timeoutToken = window.setTimeout(this.tempUploadNext, gt) : (this.loadIndex = 0, this.timeoutToken = 0)
					}, this.emojiIsADuplicate = (e, t) => e && t && t.some(t => t.id === e.id), this.saveNext = e => {
						const t = this.getNextTempUploadedImageToSave();
						if (!t) return this.timeoutToken = 0, void(this.loadIndex = 0);
						if (!this.emojiIsADuplicate(t, e)) {
							const e = this.state.emojiData[t.id],
								n = this.props.saveEmoji(t, e.name, this.props.emojiSettings);
							this.setState({
								emojisUploaded: this.state.emojisUploaded || n
							})
						}
						this.loadIndex += 1, this.loadIndex < this.state.localData.length ? this.timeoutToken = window.setTimeout(() => this.saveNext(e), gt) : (this.loadIndex = 0, this.timeoutToken = 0)
					}, this.onChangeEmojiName = (e, t) => {
						const {
							isSnoomojiSubreddit: n,
							reservedEmojiNames: s
						} = this.props;
						if (t.length > we.d) return;
						const r = this.state.isReplacing ? this.state.replacingEmoji && this.state.replacingEmoji[e] : this.state.localData[e];
						if (!r) return;
						const o = this.state.emojiData,
							i = o[r.id],
							a = t ? lt(t, s, n) : "";
						o[r.id].emojiNameError = a, o[r.id].name = t;
						const d = ht(o);
						this.setState({
							duplicateNames: d,
							emojiData: {
								...this.state.emojiData,
								[r.id]: {
									...i,
									emojiNameError: a,
									isNameMissing: !t,
									name: t
								}
							}
						})
					}, this.canSave = () => {
						let e = !1;
						for (const t of this.state.localData) {
							if (!mt(this.state.emojiData[t.id], t)) return !1;
							t.kind === ye.b.TempUploaded && (e = !0)
						}
						return e
					}, this.getValidatedState = () => {
						const {
							isSnoomojiSubreddit: e,
							reservedEmojiNames: t
						} = this.props, n = {};
						for (const s of this.state.localData) {
							let r = this.state.emojiData[s.id];
							const o = lt(r.name, t, e);
							r.name && !o || (r = {
								...r,
								emojiNameError: o,
								isNameMissing: !r.name
							}), n[s.id] = r
						}
						return {
							emojiData: n
						}
					}, this.onApply = () => {
						const e = this.getValidatedState();
						this.setState(e, () => {
							if (this.canSave()) {
								const e = this.props.emojis[this.props.subredditId].emojis,
									t = [];
								for (const s of this.state.localData) {
									if (s.kind !== ye.b.TempUploaded) continue;
									this.state.emojiData[s.id].name in e && t.push(s)
								}
								t.length ? (this.setState({
									replacingEmoji: t,
									isReplacing: !0
								}), this.saveNext(t)) : (this.setState({
									isSavingImage: !0
								}), this.props.setIsSaving(!0), this.saveNext());
								const n = bt(ye.b.TempUploaded, this.state.localData) - t.length;
								n > 0 && (this.props.sendEvent(T("add", n)), this.sendSettingsEvent())
							}
						})
					}, this.sendSettingsEvent = () => {
						const {
							modFlairOnly: e,
							userFlairAllowed: t,
							postFlairAllowed: n
						} = this.props.emojiSettings;
						this.props.sendEvent(S("mods_only", e)), this.props.sendEvent(S("appear_user_flair", t)), this.props.sendEvent(S("appear_post_flair", n))
					}, this.handleSaveAndReplace = () => {
						this.setState({
							isReplacing: !1,
							isSavingImage: !0
						}), this.props.setIsSaving(!0);
						const {
							replacingEmoji: e
						} = this.state, t = e ? e.length : 0;
						this.saveNext(), t > 0 && (this.props.sendEvent(T("replace", t)), this.sendSettingsEvent())
					}, this.handleCancelReplace = () => {
						this.setState({
							isReplacing: !1,
							replacingEmoji: null
						}), this.props.stopEditing(), this.props.sendEvent(w("dont_replace"))
					}, this.findEmojiIndexById = e => this.state.localData.findIndex(t => t.id === e), this.removeEmoji = e => {
						const {
							isReplacing: t,
							localData: n,
							replacingEmoji: s
						} = this.state;
						let r, o = e;
						t && s && s[e] && (o = this.findEmojiIndexById(s[e].id), (r = s.slice(0)).splice(e, 1), this.setState({
							replacingEmoji: r
						}));
						const i = n[o],
							a = n.slice(0);
						a.splice(o, 1);
						const d = {
							...this.state.emojiData
						};
						delete d[i.id], this.setState({
							duplicateNames: ht(d),
							emojiData: d,
							localData: a
						}), t && s ? 0 === r.length && this.props.returnToAddState() : 0 === a.length && this.props.returnToAddState()
					}, this.retryEmojiUpload = () => {
						this.props.returnToAddState()
					};
					const t = {},
						n = [];
					for (const s of e.images) {
						const e = pt(s);
						t[s.id] = e, e.imageError ? n.push(Object(ye.l)(s, e.imageError)) : n.push(s)
					}
					this.state = {
						duplicateNames: ht(t),
						emojiData: t,
						emojisUploaded: !1,
						isReplacing: !1,
						isSavingImage: !1,
						localData: n,
						replacingEmoji: null
					}
				}
				UNSAFE_componentWillMount() {
					this.loadIndex = 0, this.tempUploadNext()
				}
				getNextPendingImageToLoad() {
					let e, t = null;
					for (e = this.loadIndex; e < this.state.localData.length; e++) {
						const n = this.state.localData[e];
						if (n.kind === ye.b.Pending) {
							t = n;
							break
						}
					}
					return this.loadIndex = e, t
				}
				getNextTempUploadedImageToSave() {
					let e, t = null;
					for (e = this.loadIndex; e < this.state.localData.length; e++) {
						const n = this.state.localData[e];
						if (n.kind === ye.b.TempUploaded) {
							t = n;
							break
						}
					}
					return this.loadIndex = e, t
				}
				UNSAFE_componentWillReceiveProps(e) {
					const t = e.getImageUploadsIfModified(this.state.localData);
					if (!t) return;
					let n = !1;
					const {
						isSavingImage: s
					} = this.state, r = {};
					for (const o of t) r[o.id] = this.state.emojiData[o.id], n = n || o.kind === ye.b.TempUploaded;
					!s || n ? (this.props.setIsSaving(s), this.setState({
						emojiData: r,
						isSavingImage: s,
						localData: t
					})) : this.props.stopEditing()
				}
				componentWillUnmount() {
					for (const e of this.state.localData) this.props.cancelUpload(e);
					this.timeoutToken && window.clearTimeout(this.timeoutToken), this.state.emojisUploaded && this.props.emojisUploadedToast(), this.setState({
						emojisUploaded: !1,
						isReplacing: !1
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = t.isReplacing ? t.replacingEmoji || [] : t.localData;
					return d.a.createElement(vt, null, d.a.createElement(yt, null, t.duplicateNames.length > 0 ? d.a.createElement(Ot, null, d.a.createElement(Et, null), r.fbt._("Duplicate names", null, {
						hk: "4kkNr1"
					})) : !t.isReplacing && d.a.createElement(jt, null, d.a.createElement(xt, null), r.fbt._("Names cannot be edited once added", null, {
						hk: "3f45r5"
					})), d.a.createElement(X.l, null, t.isReplacing ? d.a.createElement(d.a.Fragment, null, d.a.createElement(_t, null, r.fbt._("Replacing emojis", null, {
						hk: "4cKike"
					})), d.a.createElement(kt, null, r.fbt._("These emoji names already exist in your community. Replacing these emojis will not change pre-existing permissions. Do you want to replace them?", null, {
						hk: "3iPBUU"
					}))) : d.a.createElement(St, null, r.fbt._("Uploading emojis", null, {
						hk: "7keSV"
					})), d.a.createElement("div", {
						className: t.isReplacing ? void 0 : Pe.a.emojiDisplays
					}, n.map((e, n) => {
						const s = this.state.emojiData[e.id],
							r = e.kind === ye.b.FailedToUpload || e.kind === ye.b.Invalid,
							o = t.replacingEmoji && !t.replacingEmoji.find(t => t.id === e.id);
						if (t.isSavingImage && (r || o)) return;
						const i = ft(e, s);
						return d.a.createElement(Ee.a, {
							key: e.id
						}, d.a.createElement($e, {
							emojiName: s.name,
							errorText: i,
							fileName: s.fileName,
							imageData: e,
							index: n,
							isDuplicate: t.duplicateNames.includes(s.name),
							isSaving: t.isSavingImage,
							onCancel: this.removeEmoji,
							onChangeEmojiName: this.onChangeEmojiName
						}))
					})), !t.isReplacing && d.a.createElement(It, null, t.isSavingImage ? r.fbt._("{savedCount} out of {savedTotal} saved", [r.fbt._param("savedCount", bt(ye.b.Uploaded, t.localData).toString()), r.fbt._param("savedTotal", t.localData.length.toString())], {
						hk: "3v1E9N"
					}) : r.fbt._("{uploadedCount} out of {uploadedTotal} uploaded", [r.fbt._param("uploadedCount", bt(ye.b.TempUploaded, t.localData).toString()), r.fbt._param("uploadedTotal", t.localData.length.toString())], {
						hk: "41qbSa"
					})))), d.a.createElement(X.g, null, d.a.createElement(At, {
						disabled: t.isSavingImage,
						onClick: t.isReplacing ? this.handleCancelReplace : e.stopEditing
					}, t.isReplacing ? r.fbt._("Don't replace", null, {
						hk: "4d8hwM"
					}) : r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), d.a.createElement(Ct, {
						disabled: t.isSavingImage || !this.canSave() || t.duplicateNames.length > 0,
						onClick: t.isReplacing ? this.handleSaveAndReplace : this.onApply
					}, t.isReplacing ? r.fbt._("Replace", null, {
						hk: "45noqB"
					}) : r.fbt._("Add", null, {
						hk: "2wi3d4"
					}))))
				}
			}
			var Nt = Object(_e.a)(Tt(Pt), b.o),
				Dt = n("./src/reddit/actions/imageUploads.ts"),
				Mt = n("./src/reddit/selectors/imageUploads.ts");
			const Rt = p.a.div("UploaderContainer", Pe.a),
				Lt = p.a.wrapped(Rt, "editEmojiDisplay", Pe.a),
				Bt = Object(l.c)({
					reduxImage: (e, t) => {
						let {
							pendingImage: n
						} = t;
						const s = Object(Mt.b)(e),
							r = n && n.id;
						return r && s[r] || void 0
					}
				});
			class Ft extends d.a.Component {
				constructor(e) {
					super(e), this.onCancelAndRetry = () => {
						this.props.reduxImage && this.props.cancelUpload(this.props.reduxImage), this.props.onRetryUpload()
					}
				}
				componentDidMount() {
					const e = Object(ye.m)(this.props.pendingImage);
					this.props.uploadImage({
						imageData: e,
						subredditId: this.props.subredditId,
						emojiName: this.props.emoji.name,
						settings: this.props.emojiSettings
					})
				}
				componentDidUpdate(e) {
					this.props.reduxImage && this.props.reduxImage !== e.reduxImage && this.props.onImageChange(this.props.reduxImage)
				}
				componentWillUnmount() {
					this.props.reduxImage && this.props.cancelUpload(this.props.reduxImage)
				}
				render() {
					const {
						pendingImage: e,
						reduxImage: t,
						emoji: n
					} = this.props, s = pt(e), r = Object(ye.l)(e, s.imageError), o = s.imageError ? r : t || e, i = ft(o, s);
					return !i && o.kind === ye.b.TempUploaded || o.kind === ye.b.Uploaded ? null : d.a.createElement(Lt, null, d.a.createElement($e, {
						emojiName: n.name,
						errorText: i,
						fileName: s.fileName,
						handleRetry: this.onCancelAndRetry,
						imageData: o,
						index: 0,
						isSaving: !1,
						onCancel: this.onCancelAndRetry
					}))
				}
			}
			var Ut = Object(c.b)(Bt, e => ({
				uploadImage: t => e(Object(b.o)(t)),
				cancelUpload: t => e(Object(Dt.h)(t))
			}))(Ft);

			function Ht() {
				return (Ht = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const Gt = 32,
				Qt = 128,
				qt = 64,
				Wt = 100,
				zt = p.a.div("appearsIn", ke.a),
				Vt = p.a.wrapped(Oe.a, "checkbox", ke.a),
				Kt = p.a.span("checkboxText", ke.a),
				Yt = p.a.wrapped(Z.a, "closeButton", ke.a),
				Jt = p.a.div("imageTitle", ke.a),
				Xt = p.a.wrapped(j.l, "modalAddButton", ke.a),
				Zt = p.a.wrapped(X.e, "modalBody", ke.a),
				$t = p.a.wrapped(X.a, "modalCancelButton", ke.a),
				en = p.a.wrapped(X.l, "modalMain", ke.a),
				tn = p.a.wrapped(ae, "modFlairOnlyToggle", ke.a),
				nn = p.a.wrapped(Ce.a, "modIcon", ke.a),
				sn = p.a.li("modProTip", ke.a),
				rn = p.a.div("modProTips", ke.a),
				on = p.a.div("modProTipTitle", ke.a),
				an = p.a.div("proTip", ke.a),
				dn = p.a.ul("tipList", ke.a),
				cn = e => !!e && (e.kind === ye.b.Pending ? !!pt(e).imageError : e.kind === ye.b.FailedToUpload);
			var ln;
			! function(e) {
				e[e.AddState = 0] = "AddState", e[e.SingleEmojiEditState = 1] = "SingleEmojiEditState", e[e.BulkUploadState = 2] = "BulkUploadState"
			}(ln || (ln = {}));
			const un = p.a.wrapped(Ae.a, "emojiDisplay", ke.a),
				mn = p.a.div("emojiNameDisplay", ke.a),
				pn = p.a.wrapped(B.a, "imageDisplay", ke.a),
				bn = e => d.a.createElement(un, null, d.a.createElement(pn, {
					backgroundImage: e.url
				}), d.a.createElement(mn, null, e.emojiName)),
				fn = Object(l.c)({
					emojisCustomSize: (e, t) => Object(ee.z)(e, {
						subredditName: t.subreddit.name
					}).emojisCustomSize
				}),
				hn = Object(c.b)(fn, (e, t) => {
					let {
						emoji: n,
						isSnoomoji: s,
						subreddit: o
					} = t;
					return {
						saveEmoji: (t, n, s) => e(b.n({
							imageData: s,
							subredditId: o.id,
							emojiName: t,
							settings: n
						})),
						saveEmojiSettings: t => {
							n && e(b.m(n.name, s, t, o.id))
						},
						saveEmojiSuccessToast: () => e(ve.f({
							kind: je.b.SuccessCommunityGreen,
							text: r.fbt._("Emoji edits saved!", null, {
								hk: "3luBMA"
							})
						}))
					}
				});
			class gn extends d.a.Component {
				constructor(e) {
					super(e), this.closeModal = () => {
						this.props.toggleModal()
					}, this.clearImageData = () => {
						this.setState({
							imageData: [],
							emojiDraftImage: void 0
						})
					}, this.onEditingImageChange = e => {
						this.setState({
							emojiDraftImage: e
						})
					}, this.handleMultiImageInput = async e => {
						let t;
						const n = this.state.emojiState === ln.SingleEmojiEditState;
						n && this.clearImageData(), t = Array.isArray(e) ? n ? e.slice(0, 1) : e.slice(0, Wt) : [e];
						const s = await Promise.all(t.map(ye.f));
						n ? this.setState({
							imageData: s
						}) : this.setState({
							emojiState: ln.BulkUploadState,
							imageData: s
						})
					}, this.handleModExclusiveToggle = () => this.setState({
						settings: {
							...this.state.settings,
							modFlairOnly: !this.state.settings.modFlairOnly
						}
					}), this.handleTogglePostFlair = () => this.setState({
						settings: {
							...this.state.settings,
							postFlairAllowed: !this.state.settings.postFlairAllowed
						}
					}), this.handleToggleUserFlair = () => this.setState({
						settings: {
							...this.state.settings,
							userFlairAllowed: !this.state.settings.userFlairAllowed
						}
					}), this.returnToAdd = () => {
						this.setState({
							emojiState: ln.AddState
						}), this.clearImageData()
					}, this.sendToggleEvent = (e, t) => this.props.sendEvent(S(e, t)), this.modFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.modFlairOnly !== this.state.settings.modFlairOnly, this.userFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.userFlairAllowed !== this.state.settings.userFlairAllowed, this.postFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.postFlairAllowed !== this.state.settings.postFlairAllowed, this.settingsHaveBeenChanged = () => this.modFlairSettingHasChanged() || this.userFlairSettingHasChanged() || this.postFlairSettingHasChanged(), this.sendTelemetryEvents = () => {
						const {
							modFlairOnly: e,
							userFlairAllowed: t,
							postFlairAllowed: n
						} = this.state.settings;
						this.modFlairSettingHasChanged() && this.sendToggleEvent("mods_only", e), this.userFlairSettingHasChanged() && this.sendToggleEvent("appear_user_flair", t), this.postFlairSettingHasChanged() && this.sendToggleEvent("appear_post_flair", n)
					}, this.saveEmoji = async () => {
						const {
							props: e,
							state: t
						} = this, n = {
							modFlairOnly: t.settings.modFlairOnly,
							postFlairAllowed: t.settings.postFlairAllowed,
							userFlairAllowed: t.settings.userFlairAllowed
						};
						if (this.setIsSaving(!0), e.emoji) {
							if (e.isSnoomoji || e.emoji && !t.emojiDraftImage) e.saveEmojiSettings(n);
							else if (e.emoji && t.emojiDraftImage && t.emojiDraftImage.kind === ye.b.TempUploaded) {
								await e.saveEmoji(e.emoji.name, n, t.emojiDraftImage) && e.saveEmojiSuccessToast()
							}
							this.sendTelemetryEvents()
						}
						this.closeModal(), this.setIsSaving(!1)
					}, this.setIsSaving = e => this.setState({
						isSaving: e
					}), this.state = {
						emojiState: e.emoji ? ln.SingleEmojiEditState : ln.AddState,
						imageData: [],
						isSaving: !1,
						settings: {
							modFlairOnly: !!e.emoji && e.emoji.modFlairOnly,
							postFlairAllowed: !e.emoji || e.emoji.postFlairAllowed,
							userFlairAllowed: !e.emoji || e.emoji.userFlairAllowed
						}
					}
				}
				render() {
					const {
						emoji: e,
						emojisCustomSize: t,
						isSnoomoji: n,
						sendEvent: s,
						subreddit: o
					} = this.props, {
						emojiDraftImage: i,
						emojiState: a,
						imageData: c,
						isSaving: l,
						settings: u
					} = this.state, m = {
						emojiSettings: u,
						stopEditing: this.closeModal,
						subredditId: o.id
					}, p = 2 * (t ? t[0] : Gt), b = 2 * (t ? t[1] : Gt), f = c.length > 0 ? c[0] : void 0, h = f && f.url, g = i && i.url, v = h || g, x = i && i.kind === ye.b.TempUploaded, E = cn(f || i), O = a !== ln.SingleEmojiEditState || (!this.settingsHaveBeenChanged() && !x || E);
					return d.a.createElement(Zt, null, d.a.createElement(X.i, null, d.a.createElement($.a, null, d.a.createElement(X.q, null, e ? r.fbt._("Edit emoji", null, {
						hk: "4awCz5"
					}) : r.fbt._("Add new emojis", null, {
						hk: "2DrJ62"
					})), d.a.createElement(Yt, {
						disabled: l,
						onClick: this.closeModal
					}, d.a.createElement(X.b, null)))), (a === ln.AddState || a === ln.SingleEmojiEditState) && d.a.createElement(d.a.Fragment, null, a === ln.AddState && d.a.createElement(rn, null, d.a.createElement(on, null, d.a.createElement(nn, null), r.fbt._("Mod pro tips!", null, {
						hk: "30l9bq"
					})), d.a.createElement(dn, null, d.a.createElement(sn, null, r.fbt._("Emoji names will use the image file name and will be editable once uploaded", null, {
						hk: "2fvAIQ"
					})), d.a.createElement(sn, null, r.fbt._("You can upload up to {maxUpload} emojis at once", [r.fbt._param("maxUpload", Wt.toString())], {
						hk: "4aMYoX"
					})))), d.a.createElement(en, null, a === ln.SingleEmojiEditState && e && d.a.createElement(bn, {
						emojiName: e.name,
						url: v || e.url
					}), !n && d.a.createElement(d.a.Fragment, null, d.a.createElement(Ee.i, null, d.a.createElement(Jt, null, e ? r.fbt._("Image", null, {
						hk: "3fzI70"
					}) : r.fbt._("Images", null, {
						hk: "3SapUk"
					})), e && a === ln.SingleEmojiEditState && f && d.a.createElement(Ut, Ht({}, m, {
						emoji: e,
						onRetryUpload: this.clearImageData,
						pendingImage: f,
						onImageChange: this.onEditingImageChange
					})), (!c.length || x) && !(e && E) && d.a.createElement(xe.b, {
						label: r.fbt._("Drag and Drop or Upload Image", null, {
							hk: "3y5WvP"
						}),
						onChange: this.handleMultiImageInput,
						multiple: !0
					}), d.a.createElement(Ee.b, null, r.fbt._("Max upload dimensions {maxEmojiWidth} x {maxEmojiHeight}px", [r.fbt._param("maxEmojiWidth", Qt.toString()), r.fbt._param("maxEmojiHeight", Qt.toString())], {
						hk: "yal28"
					})), d.a.createElement(Ee.b, null, r.fbt._("Max file size {MAX_FILE_SIZE}KB", [r.fbt._param("MAX_FILE_SIZE", qt.toString())], {
						hk: "1t1L0f"
					}))), d.a.createElement(an, null, r.fbt._("Recommended upload dimensions: {recommendedWidth} x {recommendedHeight}px", [r.fbt._param("recommendedWidth", p.toString()), r.fbt._param("recommendedHeight", b.toString())], {
						hk: "35CqDV"
					}))), d.a.createElement(zt, null, r.fbt._("Appears in:", null, {
						hk: "3SZP5W"
					})), d.a.createElement(Vt, {
						name: "postFlair",
						onChange: this.handleTogglePostFlair,
						value: u.postFlairAllowed
					}, d.a.createElement(Kt, null, r.fbt._("Post flair", null, {
						hk: "mAzeZ"
					}))), d.a.createElement(Vt, {
						name: "userFlair",
						onChange: this.handleToggleUserFlair,
						value: u.userFlairAllowed
					}, d.a.createElement(Kt, null, r.fbt._("User flair", null, {
						hk: "qVf7x"
					}))), d.a.createElement(tn, {
						description: "Only appears in post and user flair that are restricted for mod use.",
						on: u.modFlairOnly,
						onToggle: this.handleModExclusiveToggle,
						title: "Mod only"
					})), d.a.createElement(X.g, null, d.a.createElement($t, {
						disabled: l,
						onClick: this.closeModal
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), d.a.createElement(Xt, {
						disabled: O,
						onClick: this.saveEmoji
					}, e ? r.fbt._("Save", null, {
						hk: "4yMsMq"
					}) : r.fbt._("Add", null, {
						hk: "2wi3d4"
					})))), a === ln.BulkUploadState && d.a.createElement(Nt, Ht({}, m, {
						images: c,
						returnToAddState: this.returnToAdd,
						sendEvent: s,
						setIsSaving: this.setIsSaving
					})))
				}
			}
			var vn = Object(J.a)(hn(gn));
			const xn = p.a.wrapped(P.a, "alertIcon", L.a),
				En = p.a.span("appearsTitle", L.a),
				On = p.a.span("imageTitle", L.a),
				Cn = p.a.span("nameTitle", L.a),
				An = p.a.span("permissionsTitle", L.a),
				yn = p.a.wrapped(j.o, "settingsButton", L.a),
				jn = p.a.wrapped(x.a, "titleTooltip", L.a),
				In = p.a.wrapped(C.a, "topRow", L.a),
				kn = Object(l.c)({
					emojis: D.d,
					isConfirmModalOpen: Object(N.b)("EmojiManager--DeleteEmojiConfirmation--Modal"),
					isEmojisEnabled: (e, t) => Object(D.b)(e, t.subreddit.name),
					isEmojiSettingsModalOpen: Object(N.b)("EmojiManager--Settings--Modal"),
					isUploadEmojisModalOpen: Object(N.b)("EmojiManager--UploadEmojis--Modal"),
					isInShredditModNavExperiment: e => Object(M.a)(e, !0),
					isBadgesAndEmotesEnabled: I.d.spCustomBadgesAndEmotes
				}),
				_n = Object(c.b)(kn, (e, t) => {
					let {
						subreddit: n
					} = t;
					return {
						deleteEmoji: t => e(b.i(t, n.id)),
						toggleDeleteConfirmationModal: () => e(Object(f.i)("EmojiManager--DeleteEmojiConfirmation--Modal")),
						toggleSettingsModal: () => e(Object(f.i)("EmojiManager--Settings--Modal")),
						toggleUploadEmojisModal: () => e(Object(f.i)("EmojiManager--UploadEmojis--Modal"))
					}
				});
			class Sn extends d.a.Component {
				constructor(e) {
					super(e), this.isSticky = () => {
						const e = window.scrollY >= 100;
						this.setState({
							isFixed: e
						})
					}, this.onClickEditEmoji = (e, t) => {
						this.props.toggleUploadEmojisModal(), this.setState({
							emojiToEdit: e,
							isSnoomoji: t
						})
					}, this.onConfirmDelete = () => {
						this.props.deleteEmoji(this.state.emojiNameToDelete), this.setState({
							emojiNameToDelete: ""
						}), this.props.sendEvent(w("delete"))
					}, this.handleRemoveEmoji = e => {
						this.setState({
							emojiNameToDelete: e
						}), this.props.toggleDeleteConfirmationModal()
					}, this.renderTopBar = e => d.a.createElement(O.c, {
						className: Object(u.a)(e && "bg-neutral-background mb-xs pr-0", L.a.topBar, {
							[L.a.default]: !e,
							[L.a.fixed]: this.state.isFixed
						})
					}, d.a.createElement(yn, {
						onClick: this.props.toggleSettingsModal
					}, r.fbt._("Emoji settings", null, {
						hk: "2k202A"
					})), d.a.createElement(j.l, {
						onClick: this.props.toggleUploadEmojisModal
					}, r.fbt._("Add emoji", null, {
						hk: "DTe8a"
					}))), this.state = {
						emojiNameToDelete: "",
						emojiToEdit: null,
						isSnoomoji: !1,
						isFixed: !this.props.isInShredditModNavExperiment
					}
				}
				componentDidMount() {
					this.props.isInShredditModNavExperiment && window.addEventListener("scroll", this.isSticky)
				}
				componentWillUnmount() {
					this.props.isInShredditModNavExperiment && window.removeEventListener("scroll", this.isSticky)
				}
				static getDerivedStateFromProps(e, t) {
					return t.emojiToEdit && !e.isUploadEmojisModalOpen ? {
						emojiToEdit: null,
						isSnoomoji: !1
					} : null
				}
				render() {
					const {
						emojis: e,
						isConfirmModalOpen: t,
						isEmojisEnabled: n,
						isEmojiSettingsModalOpen: o,
						isUploadEmojisModalOpen: a,
						sendEvent: c,
						subreddit: l,
						toggleDeleteConfirmationModal: u,
						toggleSettingsModal: p,
						toggleUploadEmojisModal: b,
						isInShredditModNavExperiment: f,
						isBadgesAndEmotesEnabled: x
					} = this.props;
					return d.a.createElement(d.a.Fragment, null, !f && this.renderTopBar(), d.a.createElement(O.a, {
						className: f ? L.a.newModNavContainer : void 0
					}, f ? d.a.createElement(d.a.Fragment, null, Object(E.a)(l.name, m.mc.Emojis, x), this.renderTopBar(!0)) : d.a.createElement(O.b, null, r.fbt._("Emoji management", null, {
						hk: "6xN5s"
					}), d.a.createElement(v.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360010560371`
					})), !n && d.a.createElement(g.a, {
						className: L.a.emojisDisabled,
						color: y.a.quarantine,
						icon: d.a.createElement(xn, null),
						subtitle: r.fbt._("Emojis in flairs will not be displayed, and existing emojis will appear as plain text.", null, {
							hk: "2WaMtH"
						}),
						title: r.fbt._("Emojis have been disabled for this community", null, {
							hk: "7LNIO"
						})
					}), d.a.createElement(In, null, d.a.createElement(On, null, r.fbt._("Image", null, {
						hk: "1rlqjH"
					})), d.a.createElement(Cn, null, r.fbt._("Name", null, {
						hk: "1ugGFI"
					})), d.a.createElement(En, null, r.fbt._("Appears in", null, {
						hk: "3K8vjU"
					}), d.a.createElement(jn, {
						text: r.fbt._("Set emoji to appear in post flair or user flair", null, {
							hk: "4cg4Se"
						})
					})), d.a.createElement(An, null, r.fbt._("Settings", null, {
						hk: "2CRrAq"
					}), d.a.createElement(jn, {
						text: r.fbt._("Set emoji to only appear in mod-only flair", null, {
							hk: "2yS10f"
						})
					}))), e[l.id] && i()(e[l.id].emojis, e => d.a.createElement(Y, {
						emoji: e,
						enabled: !0,
						isSnoomoji: !1,
						key: e.name,
						onEdit: this.onClickEditEmoji,
						onRemove: this.handleRemoveEmoji
					})), e[l.id] && i()(e[l.id].snoomojis, e => d.a.createElement(Y, {
						emoji: e,
						enabled: !0,
						isSnoomoji: !0,
						key: e.name,
						onEdit: this.onClickEditEmoji,
						onRemove: this.handleRemoveEmoji
					})), t && d.a.createElement(h.a, {
						toggleModal: u,
						onConfirm: this.onConfirmDelete,
						actionText: r.fbt._("Delete", null, {
							hk: "4lt26q"
						}),
						headerText: r.fbt._("Delete emoji?", null, {
							hk: "3VBsS8"
						}),
						modalText: r.fbt._("Do you wish to delete this emoji?", null, {
							hk: "2sPCxc"
						}),
						trackClick: () => {},
						withOverlay: !0
					}), o && d.a.createElement(ge, {
						sendEvent: c,
						subreddit: l,
						toggleModal: p,
						withOverlay: !0
					}), a && d.a.createElement(vn, {
						emoji: this.state.emojiToEdit,
						isSnoomoji: this.state.isSnoomoji,
						sendEvent: c,
						subreddit: l,
						toggleModal: b,
						withOverlay: !0
					})))
				}
			}
			t.a = _n(Object(A.c)(Sn))
		},
		"./src/reddit/components/ModHub/InfoLink/index.m.less": function(e, t, n) {
			e.exports = {
				linkContainer: "_3-yXs2bljbMxTPT6hDZU1I",
				infoIcon: "_2Eloqzd6Vfz9eGsjyzVfsf"
			}
		},
		"./src/reddit/components/ModHub/InfoLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/higherOrderComponents/asTooltip.tsx"),
				a = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				d = n("./src/reddit/icons/fonts/Info/index.tsx"),
				c = n("./src/reddit/components/ModHub/InfoLink/index.m.less"),
				l = n.n(c);
			const u = Object(i.a)(a.b),
				m = ["center", "top"],
				p = ["center", "bottom"];
			class b extends o.a.Component {
				constructor(e) {
					super(e), this.tooltipTargetElement = null, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							showTooltip: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							showTooltip: !1
						})
					}, this.state = {
						showTooltip: !1
					}
				}
				render() {
					return o.a.createElement("a", {
						className: l.a.linkContainer,
						href: this.props.linkUrl,
						onMouseEnter: this.onShowTooltip,
						onMouseLeave: this.onHideTooltip,
						ref: this.setTooltipTargetRef,
						target: "_blank",
						rel: "noopener noreferrer",
						onClick: this.props.onClick
					}, o.a.createElement(d.a, {
						className: l.a.infoIcon
					}), o.a.createElement(u, {
						isOpen: this.state.showTooltip,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: m,
						text: s.fbt._("Learn more", null, {
							hk: "3zoGtq"
						}),
						tooltipPosition: p
					}))
				}
			}
			t.a = b
		},
		"./src/reddit/components/ModHub/InfoTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				iconContainer: "_39qwCVfS_zadCI7gaPX3MI",
				textTooltip: "_1yEjLpHWBPakuE9kTnIp_w"
			}
		},
		"./src/reddit/components/ModHub/InfoTooltip/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/asTooltip.tsx"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				d = n("./src/reddit/icons/fonts/Info/index.tsx"),
				c = n("./src/reddit/components/ModHub/InfoTooltip/index.m.less"),
				l = n.n(c);
			const u = Object(o.a)(a.a),
				m = ["center", "bottom"],
				p = ["center", "top"];
			class b extends r.a.Component {
				constructor(e) {
					super(e), this.tooltipTargetElement = null, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							showTooltip: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							showTooltip: !1
						})
					}, this.state = {
						showTooltip: !1
					}
				}
				render() {
					const {
						props: e
					} = this;
					return r.a.createElement("span", {
						className: l.a.iconContainer,
						onMouseEnter: this.onShowTooltip,
						onMouseLeave: this.onHideTooltip,
						ref: this.setTooltipTargetRef
					}, r.a.createElement(d.a, null), r.a.createElement(u, {
						className: Object(i.a)(e.className, l.a.textTooltip),
						children: e.children,
						isOpen: this.state.showTooltip,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: m,
						text: e.text,
						tooltipPosition: p
					}))
				}
			}
			t.a = b
		},
		"./src/reddit/components/ModHub/ModHubNav/NavItem.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/controls/InternalLink/index.tsx"),
				d = n("./src/reddit/icons/fonts/index.tsx"),
				c = n("./src/reddit/components/ModHub/ModHubNav/index.m.less"),
				l = n.n(c);
			const u = e => {
				let {
					className: t
				} = e;
				return o.a.createElement("div", {
					className: Object(i.a)(l.a.newLinkIndicator, t)
				}, s.fbt._("New", null, {
					hk: "BnhHE"
				}))
			};
			t.b = e => e.path ? e.isExternal ? o.a.createElement("a", {
				className: l.a.navLinkStyles,
				href: e.path,
				onClick: e.onClick,
				target: "_blank",
				rel: "noopener noreferrer"
			}, e.label, o.a.createElement(d.a, {
				name: "external_link",
				className: l.a.outboundLinkIcon
			})) : o.a.createElement(a.default, {
				className: Object(i.a)(l.a.navLinkStyles, {
					[l.a.activeLink]: !!e.isActive
				}),
				to: e.path,
				onClick: e.onClick
			}, e.label, e.isNew && o.a.createElement(u, null), e.isBeta && o.a.createElement("div", {
				className: l.a.newLinkIndicator
			}, s.fbt._("Beta", null, {
				hk: "z4XPh"
			})), e.isUpdated && o.a.createElement("div", {
				className: l.a.updatedLinkIndicator
			}, s.fbt._("Updated", null, {
				hk: "2xkGR3"
			})), e.showInboundArrow && o.a.createElement(d.a, {
				name: "right",
				className: l.a.inboundLinkIcon
			})) : o.a.createElement("button", {
				className: l.a.navLinkStyles,
				onClick: e.onClick
			}, e.label, e.isNew && o.a.createElement(u, null), e.isBeta && o.a.createElement("div", {
				className: l.a.newLinkIndicator
			}, s.fbt._("Beta", null, {
				hk: "z4XPh"
			})), e.isUpdated && o.a.createElement("div", {
				className: l.a.updatedLinkIndicator
			}, s.fbt._("Updated", null, {
				hk: "2xkGR3"
			})))
		},
		"./src/reddit/components/ModHub/ModHubNav/WikiNavPanel/index.m.less": function(e, t, n) {
			e.exports = {
				wikiNavPanel: "KAUs91LhLIPR2bTL1aZRJ",
				contentTree: "_3_qIKXEwRmWcog7k9kGSno",
				footer: "_3FqEpSEBROhNwQ6pW6xmwJ",
				primaryButton: "_3fO0HSLh0kUxdhfv06hiTX",
				pageNavItem: "gCZ0Yr9nZYa9NaCdn8-eS",
				indentLine: "_2qFuXxmElNrzv3E9Qyb5xi",
				itemText: "_8bMrzJrL3U19A5yc6HTgj",
				mActive: "_1gyKwA8_GLuoQ1hu3Apd-w",
				mExists: "_3E5JJL5f6BXoTxqDq40IbB"
			}
		},
		"./src/reddit/components/ModHub/ModHubNav/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_1rWejsW3eX4yw72E6Wfmyh",
				titleFontH2: "_10H_HMu7R7ett8pmawqwCS",
				titleFontH3: "_22nuZii7bWeL3c1xoXOl9",
				titleFontH4: "_2UjVJakiyf4d3yQ1sBrOzz",
				titleFontH5: "_22v1odcGzDJaLHik5W5qCz",
				titleFontH6: "_3BdZeq3g8CWhfeqBhIiW7f",
				metadataFont: "BQ88O08B4nIUNd4oLud39",
				flairFont: "_24GksXJ4va-4ZEamEGSlFB",
				labelsFont: "bd2r035T3aLLBkiMZaODQ",
				actionFont: "v0ITosHo9F3Rl2_llDtrc",
				smallButtonFont: "_3Sxxei5IvhyFBFPSQeJemM",
				largeButtonFont: "_-8HW12kqXpCzSoPxOQgrN",
				strongTextFont: "jPwoQR2t4sGD2BGLwCS0o",
				tabFont: "_2TpZx4pScQqA92z2QTYbIk",
				buttonFontXS: "_3hhxR89D6EPPCn0stnyDtx",
				buttonFontXs: "_3hhxR89D6EPPCn0stnyDtx",
				buttonFontS: "_2geB6McFSdWvuGRz3nyzjb",
				buttonFontM: "_1uuuzIbDmUCEWDPkR9T_dx",
				buttonFontL: "_1AhaF3ULgALw9k8OUmf0pY",
				buttonFontXL: "_2iQE9slD0Zw-wYQx5FCL1j",
				buttonFontXl: "_2iQE9slD0Zw-wYQx5FCL1j",
				bodyFontH1: "_3hxV-zVTwf7J5X6U1gL2PA",
				bodyFontH2: "_1lSzh7ct7vogYQk35ULeJl",
				bodyFontH3: "_2C3DyZAU4ai6HhZtVTe-Bu",
				bodyFontH4: "_2tzV3r0Sow-B7LA2KMLD45",
				bodyFontH5: "_1-ivrwr3LQQJ2_7q7woFBf",
				bodyFontH6: "pJbG4WvyXqhjYGMHv_062",
				bodyFontH6Small: "_2lZmvARU6npWzDSAF2ffm7",
				bodyFont: "gPA4LKC5gx8g56loAEuW2",
				bodyFontSmall: "_2U2PATpiHbmfDjkovIbtF9",
				bodyFontMono: "_1tyVWTRiPy8hBs1o6HBJ_a",
				landingPageTitleFontH1: "zqAJRqCy7DeyLpsrwXWi9",
				landingPageTitleFontH2: "_1VGCtnevQ7bfeO7-4uYWSV",
				landingPageTitleFontH3: "_3dMJxOTjl7jaGOCSaAcvTW",
				navContainer: "_2xA0SygQ9V-9Vkdad_4tnh",
				wikiNavContainer: "_3wKmughJWQCbpbTpgwf2R_",
				navContainerExp: "_1HiZS01lfLdV-mZxJbB2r1",
				navSection: "_1hDKgrVgEqwg3ogyzK0xTx",
				sectionHeader: "_1C6NYhYvuXKUDoONxrMR0d",
				iconStyles: "_1lHK5OQSXGaQzgW07E3Fh4",
				inboundLinkIcon: "_1cE0_wpoZtV5YKzwxXgxQ6",
				outboundLinkIcon: "_2Fb1fof3pZ4qO7_ZowwnXG",
				navLinkStyles: "jFCRipwFbBNJ4rl18HMK5",
				activeLink: "_4Gq-jEYAhrOCtha4RZ1JZ",
				breadcrumb: "_2Pw-8XrjTaQdxaxIicJXly",
				breadcrumbButton: "_1ofO-HYNTNyx_FUAEbIMME",
				newLinkIndicator: "_26hxZhi3N_WA1WUC6pQRpa",
				updatedLinkIndicator: "_1oCiY0B1NLkEfFfIfSJIF_"
			}
		},
		"./src/reddit/components/ModHub/NewModNav/PageLinks.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return m
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "a", (function() {
				return E
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/reddit/components/ModHub/Content/ModQueue.tsx"),
				c = n("./src/reddit/controls/InternalLink/index.tsx"),
				l = n("./src/reddit/helpers/trackers/modHub.ts"),
				u = n("./src/reddit/hooks/useTracking.ts");
			const m = (e, t, n) => o.a.createElement(A, {
					links: p(e),
					currentPageName: t,
					title: s.fbt._("Queues", null, {
						hk: "2Olu9S"
					}),
					className: n
				}),
				p = e => [{
					pageName: a.mc.Modqueue,
					displayName: () => Object(d.getModHubPageName)(a.mc.Modqueue),
					href: `/r/${e}/about/modqueue`,
					eventNoun: "mod-queue"
				}, {
					pageName: a.mc.Reports,
					displayName: () => s.fbt._("Reported", null, {
						hk: "2XagIZ"
					}),
					href: `/r/${e}/about/reports`,
					eventNoun: "report-queue"
				}, {
					pageName: a.mc.Spam,
					displayName: () => s.fbt._("Removed", null, {
						hk: "1qrEsN"
					}),
					href: `/r/${e}/about/spam`,
					eventNoun: "spam-queue"
				}, {
					pageName: a.mc.Edited,
					displayName: () => Object(d.getModHubPageName)(a.mc.Edited),
					href: `/r/${e}/about/edited`,
					eventNoun: "edited-queue"
				}, {
					pageName: a.mc.Unmoderated,
					displayName: () => Object(d.getModHubPageName)(a.mc.Unmoderated),
					href: `/r/${e}/about/unmoderated`,
					eventNoun: "unmoderated-queue"
				}],
				b = (e, t) => o.a.createElement(A, {
					links: f(e),
					currentPageName: t,
					title: s.fbt._("User Management", null, {
						hk: "4Ek5Ha"
					})
				}),
				f = e => [{
					pageName: a.mc.Banned,
					displayName: () => s.fbt._("Banned", null, {
						hk: "4lYx7f"
					}),
					href: `/r/${e}/about/banned`,
					eventNoun: "banned"
				}, {
					pageName: a.mc.Muted,
					displayName: () => s.fbt._("Muted", null, {
						hk: "4r3Lpj"
					}),
					href: `/r/${e}/about/muted`,
					eventNoun: "muted"
				}, {
					pageName: a.mc.Contributors,
					displayName: () => s.fbt._("Approved", null, {
						hk: "2sfe68"
					}),
					href: `/r/${e}/about/contributors`,
					eventNoun: "approved"
				}, {
					pageName: a.mc.TalkHosts,
					displayName: () => s.fbt._("Talk Hosts", null, {
						hk: "3da8wd"
					}),
					href: `/r/${e}/about/talkhosts`,
					eventNoun: "talk-hosts"
				}, {
					pageName: a.mc.Moderators,
					displayName: () => s.fbt._("Moderators", null, {
						hk: "Y1Jqo"
					}),
					href: `/r/${e}/about/moderators`,
					eventNoun: "moderators"
				}],
				h = (e, t, n) => o.a.createElement(A, {
					links: g(e),
					currentPageName: t,
					title: s.fbt._("User Flair", null, {
						hk: "1eHuzk"
					}),
					className: n
				}),
				g = e => [{
					pageName: a.mc.UserFlair,
					displayName: () => s.fbt._("Setup", null, {
						hk: "33R1cD"
					}),
					href: `/r/${e}/about/userflair`,
					eventNoun: "user-flair-settings"
				}, {
					pageName: a.mc.Flair,
					displayName: () => s.fbt._("Assign", null, {
						hk: "23QqpZ"
					}),
					href: `/r/${e}/about/flair`,
					eventNoun: "grant-user-flair"
				}],
				v = (e, t) => o.a.createElement(A, {
					links: x(e),
					currentPageName: t,
					title: s.fbt._("Rules and Removal Reasons", null, {
						hk: "2NGFyL"
					})
				}),
				x = e => [{
					pageName: a.mc.SubredditRules,
					displayName: () => s.fbt._("Rules", null, {
						hk: "1wh4CY"
					}),
					href: `/r/${e}/about/rules`,
					eventNoun: "rules"
				}, {
					pageName: a.mc.Removal,
					displayName: () => s.fbt._("Removal Reasons", null, {
						hk: "3so7Dm"
					}),
					href: `/r/${e}/about/removal`,
					eventNoun: "removal-reasons"
				}],
				E = (e, t, n, r) => o.a.createElement(A, {
					links: n ? O(e) : C(e),
					currentPageName: t,
					title: s.fbt._("Awards, Badges, Emoji, and more", null, {
						hk: "1ZnFtn"
					}),
					className: r
				}),
				O = e => [{
					pageName: a.mc.Awards,
					displayName: () => s.fbt._("Awards", null, {
						hk: "21lDrE"
					}),
					href: `/r/${e}/about/awards`,
					eventNoun: "awards"
				}, {
					pageName: a.mc.Emojis,
					displayName: () => s.fbt._("Emojis", null, {
						hk: "4AReV1"
					}),
					href: `/r/${e}/about/emojis`,
					eventNoun: "emojis"
				}, {
					pageName: a.mc.Badges,
					displayName: () => s.fbt._("Badges", null, {
						hk: "2OUEVf"
					}),
					href: `/r/${e}/about/badges`,
					eventNoun: "badges"
				}, {
					pageName: a.mc.Emotes,
					displayName: () => s.fbt._("Emotes", null, {
						hk: "26Tr2v"
					}),
					href: `/r/${e}/about/emotes`,
					eventNoun: "emotes"
				}],
				C = e => [{
					pageName: a.mc.Awards,
					displayName: () => s.fbt._("Awards", null, {
						hk: "21lDrE"
					}),
					href: `/r/${e}/about/awards`,
					eventNoun: "awards"
				}, {
					pageName: a.mc.Emojis,
					displayName: () => s.fbt._("Emojis", null, {
						hk: "4AReV1"
					}),
					href: `/r/${e}/about/emojis`,
					eventNoun: "emojis"
				}],
				A = e => {
					let {
						links: t,
						currentPageName: n,
						title: s,
						className: a
					} = e;
					const d = Object(u.a)(),
						m = Object(r.useCallback)(e => {
							d(Object(l.d)({
								source: "moderator",
								action: "click",
								noun: e,
								paneName: "top_nav"
							}))
						}, [d]);
					return o.a.createElement("div", {
						className: Object(i.a)(a, "mb-xs")
					}, o.a.createElement("div", {
						className: "font-bold text-18 leading-6"
					}, s), o.a.createElement("div", {
						className: "flex mt-sm overflow-auto"
					}, t.map(e => {
						const t = n === e.pageName;
						return o.a.createElement(c.default, {
							className: `mr-md no-underline text-14 font-semibold py-sm px-md rounded-lg hover:no-underline cursor-pointer ${t?"bg-secondary-background-selected text-neutral-content-strong":"text-secondary-weak"}`,
							to: e.href,
							key: e.pageName,
							onClick: () => m(e.eventNoun)
						}, e.displayName())
					})))
				}
		},
		"./src/reddit/components/ModHub/NewModNav/index.m.less": function(e, t, n) {
			e.exports = {
				modNavContainer: "i8ibfoDSS6d-IVM6TF9Gp"
			}
		},
		"./src/reddit/components/ModHub/PaginationButtons/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2QinjfjfDTG6Df4_Tb_eRN",
				iconStyles: "_1MvzgnzkNefTZKkd4A5o1Y",
				arrowLeft: "_1Hul4w6ANujC9NsFF6_j4f",
				disabled: "_6Tlmy2FR_9Y83uOLY6oiP"
			}
		},
		"./src/reddit/components/ModHub/PaginationButtons/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/InternalLink/index.tsx"),
				a = n("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				d = n("./src/reddit/components/ModHub/PaginationButtons/index.m.less"),
				c = n.n(d);
			t.a = e => r.a.createElement("div", {
				className: c.a.container
			}, e.prevButtonEnabled && r.a.createElement(i.default, {
				to: e.prevTo,
				onClick: e.prevButtonOnClick
			}, r.a.createElement(a.a, {
				className: Object(o.a)(c.a.iconStyles, c.a.arrowLeft)
			})), !e.prevButtonEnabled && e.keepDisabled && r.a.createElement(a.a, {
				className: Object(o.a)(c.a.iconStyles, c.a.arrowLeft, c.a.disabled)
			}), e.nextButtonEnabled && r.a.createElement(i.default, {
				to: e.nextTo,
				onClick: e.nextButtonOnClick
			}, r.a.createElement(a.a, {
				className: c.a.iconStyles
			})), !e.nextButtonEnabled && e.keepDisabled && r.a.createElement(a.a, {
				className: Object(o.a)(c.a.iconStyles, c.a.disabled)
			}))
		},
		"./src/reddit/components/ModHub/StyledComponents/index.m.less": function(e, t, n) {
			e.exports = {
				ContentContainer: "_3mbqgd00Kdlh6nVVVhZYdS",
				contentContainer: "_3mbqgd00Kdlh6nVVVhZYdS",
				PageTitle: "_3rnK1gNGg1hiVaiRd9Hidl",
				pageTitle: "_3rnK1gNGg1hiVaiRd9Hidl",
				TopBar: "_2YY5qLRbI5q6_0JQVKiGt_",
				topBar: "_2YY5qLRbI5q6_0JQVKiGt_",
				default: "_8_dE1DV6_ih2BqmmjMMZr"
			}
		},
		"./src/reddit/components/ModHub/StyledComponents/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			}));
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/components/ModHub/StyledComponents/index.m.less"),
				o = n.n(r);
			const i = s.a.div("ContentContainer", o.a),
				a = s.a.div("PageTitle", o.a),
				d = s.a.div("TopBar", o.a)
		},
		"./src/reddit/components/ModInsightsEntrypointCard/assets/lightbulb.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => {
				let {
					className: t
				} = e;
				return r.a.createElement("svg", {
					className: t,
					width: "22",
					height: "22",
					viewBox: "0 0 22 22",
					fill: "none",
					xmlns: "http://www.w3.org/2000/svg",
					xmlnsXlink: "http://www.w3.org/1999/xlink"
				}, r.a.createElement("rect", {
					width: "22",
					height: "22",
					fill: "url(#patternlightbulb)"
				}), r.a.createElement("defs", null, r.a.createElement("pattern", {
					id: "patternlightbulb",
					patternContentUnits: "objectBoundingBox",
					width: "1",
					height: "1"
				}, r.a.createElement("use", {
					xlinkHref: "#image0_1003_112166",
					transform: "scale(0.00195312)"
				})), r.a.createElement("image", {
					id: "image0_1003_112166",
					width: "512",
					height: "512",
					xlinkHref: "data:image/png;base64,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"
				})))
			}
		},
		"./src/reddit/components/ModInsightsEntrypointCard/index.m.less": function(e, t, n) {
			e.exports = {
				widget: "_2wbaDSkxACtXr9MgGl7dOn",
				titleContainer: "_2YCAtcu4sHI8UHoa2C9sW6",
				widgetContent: "uPpwmzpXRCqMRrACvzU40",
				subredditIcon: "_3aIgaee2GxIgcB1iszrrdM",
				subredditRow: "_22PYZWCaverhoUiGj_Uamx",
				subredditName: "_3-AeaIOlIhUbr8B0kFD-uG",
				detailText: "MELvZni3XevD55q_UNVa1",
				snooImage: "_1aRxikfSpDqx40QkPlbv1o",
				headerButtonContainer: "_2ZiVWvZtreRk2p9D-ILfEi",
				headerButtonIcon: "hoOU6ieUKHREIc0LYqit6",
				up: "_2kAcDKpXJxS41HWHNqLR1i",
				moreLink: "_1uTQyZ5vtmhdwbsS5_Acna"
			}
		},
		"./src/reddit/components/ModInsightsEntrypointCard/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/reddit/components/SubredditIcon/index.tsx"),
				l = n("./src/reddit/components/Widgets/ThemedWidget/index.tsx"),
				u = n("./src/reddit/constants/imagePaths.ts"),
				m = n("./src/lib/makeGqlRequest/index.ts"),
				p = n("./src/redditGQL/operations/ModInsightsModQueueEntrypoint.json");
			var b = n("./src/reddit/helpers/trackers/modHub.ts"),
				f = n("./src/reddit/hooks/useGqlContext.ts"),
				h = n("./src/reddit/hooks/useLocalStorage.ts"),
				g = n("./src/reddit/icons/svgs/ChevronDown/index.tsx"),
				v = n("./src/reddit/selectors/subreddit.ts"),
				x = n("./src/reddit/components/ModInsightsEntrypointCard/index.m.less"),
				E = n.n(x);
			var O = e => {
					let {
						className: t
					} = e;
					return o.a.createElement("svg", {
						className: t,
						width: "22",
						height: "22",
						viewBox: "0 0 22 22",
						fill: "none",
						xmlns: "http://www.w3.org/2000/svg",
						xmlnsXlink: "http://www.w3.org/1999/xlink"
					}, o.a.createElement("rect", {
						width: "22",
						height: "22",
						fill: "url(#patternfinger)"
					}), o.a.createElement("defs", null, o.a.createElement("pattern", {
						id: "patternfinger",
						patternContentUnits: "objectBoundingBox",
						width: "1",
						height: "1"
					}, o.a.createElement("use", {
						xlinkHref: "#image0_1003_109539",
						transform: "scale(0.00195312)"
					})), o.a.createElement("image", {
						id: "image0_1003_109539",
						width: "512",
						height: "512",
						xlinkHref: "data:image/png;base64,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"
					})))
				},
				C = n("./src/reddit/components/ModInsightsEntrypointCard/assets/lightbulb.tsx");
			var A = e => {
					let {
						className: t
					} = e;
					return o.a.createElement("svg", {
						className: t,
						width: "22",
						height: "22",
						viewBox: "0 0 22 22",
						fill: "none",
						xmlns: "http://www.w3.org/2000/svg",
						xmlnsXlink: "http://www.w3.org/1999/xlink"
					}, o.a.createElement("rect", {
						width: "22",
						height: "22",
						fill: "url(#patternlightning)"
					}), o.a.createElement("defs", null, o.a.createElement("pattern", {
						id: "patternlightning",
						patternContentUnits: "objectBoundingBox",
						width: "1",
						height: "1"
					}, o.a.createElement("use", {
						xlinkHref: "#image0_1003_112152",
						transform: "scale(0.00195312)"
					})), o.a.createElement("image", {
						id: "image0_1003_112152",
						width: "512",
						height: "512",
						xlinkHref: "data:image/png;base64,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"
					})))
				},
				y = n("./src/reddit/components/TrackingHelper/index.tsx");
			const j = e => {
				if (null != e) return 0 === e ? s.fbt._("Its the same as the previous 7 days.", null, {
					hk: "1DoaPL"
				}) : e > 0 ? s.fbt._("Its {change in removed comments count} more than the previous 7 days.", [s.fbt._param("change in removed comments count", e.toString())], {
					hk: "3PslP6"
				}) : s.fbt._("Its {change in removed comments count} less than the previous 7 days.", [s.fbt._param("change in removed comments count", Math.abs(e).toString())], {
					hk: "49Ao1w"
				})
			};
			t.a = e => {
				let {
					subredditName: t,
					isModListing: n,
					pageName: x
				} = e;
				var I, k, _, S, w, T, P, N, D, M, R, L, B, F, U, H, G, Q;
				const [q, W] = Object(r.useState)(void 0), [z, V] = Object(r.useState)(!1), K = Object(f.a)();
				Object(r.useEffect)(() => {
					(async () => {
						var e, n, s, r, o, i;
						V(!0);
						const a = (() => {
								const e = new Date,
									t = e.getUTCHours() < 12 ? 2 : 1;
								return e.setDate(e.getDate() - t), e
							})(),
							c = new Date(a.getTime() - 6 * d.D).toISOString(),
							l = a.toISOString(),
							u = null === (e = (await ((e, t) => Object(m.a)(e, {
								...p,
								variables: t
							}))(K(), {
								name: t,
								startDate: c,
								endDate: l
							})).body.data) || void 0 === e ? void 0 : e.subredditInfoByName;
						if (u && "moderation" in u) {
							let e = 0;
							null === (i = null === (o = null === (r = null === (s = null === (n = u.moderation) || void 0 === n ? void 0 : n.modInsights) || void 0 === s ? void 0 : s.ranges) || void 0 === r ? void 0 : r.postReports) || void 0 === o ? void 0 : o.slices) || void 0 === i || i.map(t => null == t ? void 0 : t.values.map(t => e += null == t ? void 0 : t.metric)), W({
								modActions: u.moderation.actions.approximateCount,
								activeMods: u.moderation.modInsights.teamActivity.activeModCount,
								publishedPosts: u.moderation.modInsights.summaries.postsPublished,
								publishedComments: u.moderation.modInsights.summaries.commentsPublished,
								removedPosts: u.moderation.modInsights.summaries.postsRemoved,
								removedComments: u.moderation.modInsights.summaries.commentsRemoved,
								totalReports: e
							})
						}
						V(!1)
					})()
				}, [K, t, x]);
				const Y = Object(i.e)(e => Object(v.C)(e, {
						subredditName: t
					})),
					[J, X] = Object(h.a)("mod_insights_entrypoint_card_collapsed", "false"),
					Z = Object(y.b)(),
					$ = Object(r.useCallback)(() => {
						const e = "modqueue" === x ? "embedded_insights_team_health" : "embedded_insights_community_health";
						Z(Object(b.d)({
							source: "moderator",
							action: "click",
							noun: e,
							paneName: void 0
						}))
					}, [Z, x]),
					ee = "true" === J || !q || z;
				return o.a.createElement(l.a, {
					title: o.a.createElement("div", {
						className: E.a.titleContainer
					}, s.fbt._("Last 7 Days Insights", null, {
						hk: "1XeUsu"
					})),
					className: E.a.widget,
					contentOnly: !0,
					headerButton: o.a.createElement("div", {
						className: E.a.headerButtonContainer
					}, o.a.createElement(g.a, {
						className: Object(a.a)(E.a.headerButtonIcon, {
							[E.a.up]: ee
						}, "text-neutral-content-strong")
					})),
					headerStyles: {
						borderRadius: 4
					},
					onHeaderClick: () => X(ee ? "false" : "true"),
					redditStyle: !0
				}, !ee && o.a.createElement("div", null, o.a.createElement("div", {
					className: E.a.widgetContent
				}, n && o.a.createElement("div", {
					className: Object(a.a)(E.a.subredditRow, "flex items-center px-[8px] py-[6px]")
				}, o.a.createElement(c.b, {
					className: E.a.subredditIcon,
					iconUrl: "",
					subredditOrProfile: Y
				}), o.a.createElement("div", {
					className: E.a.subredditName
				}, null == Y ? void 0 : Y.displayText)), "modqueue" === x ? o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
					className: E.a.subredditRow
				}, o.a.createElement("img", {
					className: E.a.snooImage,
					src: u.b[0],
					style: {
						backgroundColor: "#DAE0E6",
						borderRadius: "50%",
						padding: 0
					}
				}), o.a.createElement("div", {
					className: E.a.subredditRowText
				}, o.a.createElement("div", {
					className: Object(a.a)(E.a.subredditName, "text-neutral-content-strong")
				}, s.fbt._({
					"*": "{active mod count} active mods",
					_1: "{active mod count} active mod"
				}, [s.fbt._param("active mod count", (null === (I = null == q ? void 0 : q.activeMods) || void 0 === I ? void 0 : I.toString()) || ""), s.fbt._plural((null == q ? void 0 : q.activeMods) || 0)], {
					hk: "3SijVh"
				})), o.a.createElement("div", {
					className: Object(a.a)(E.a.detailText, "text-neutral-content-weak")
				}, s.fbt._({
					"*": "Your team made {mod actions count} mod actions this week, keep it up!",
					_1: "Your team made {mod actions count} mod action this week, keep it up!"
				}, [s.fbt._param("mod actions count", (null === (k = null == q ? void 0 : q.modActions) || void 0 === k ? void 0 : k.toString()) || ""), s.fbt._plural((null == q ? void 0 : q.modActions) || 0)], {
					hk: "moIRm"
				})))), o.a.createElement("div", {
					className: E.a.subredditRow
				}, o.a.createElement(A, {
					className: E.a.snooImage
				}), o.a.createElement("div", {
					className: E.a.subredditRowText
				}, o.a.createElement("div", {
					className: Object(a.a)(E.a.subredditName, "text-neutral-content-strong")
				}, s.fbt._({
					"*": "{published posts count} published posts",
					_1: "{published posts count} published post"
				}, [s.fbt._param("published posts count", (null === (S = null === (_ = null == q ? void 0 : q.publishedPosts) || void 0 === _ ? void 0 : _.metric) || void 0 === S ? void 0 : S.toString()) || ""), s.fbt._plural((null === (w = null == q ? void 0 : q.publishedPosts) || void 0 === w ? void 0 : w.metric) || 0)], {
					hk: "1PQUVl"
				})), o.a.createElement("div", {
					className: Object(a.a)(E.a.detailText, "text-neutral-content-weak")
				}, j(null === (T = null == q ? void 0 : q.publishedPosts) || void 0 === T ? void 0 : T.delta)))), o.a.createElement("div", {
					className: E.a.subredditRow
				}, o.a.createElement(O, {
					className: E.a.snooImage
				}), o.a.createElement("div", {
					className: E.a.subredditRowText
				}, o.a.createElement("div", {
					className: Object(a.a)(E.a.subredditName, "text-neutral-content-strong")
				}, s.fbt._({
					"*": "{published comments count} published comments",
					_1: "{published comments count} published comment"
				}, [s.fbt._param("published comments count", (null === (N = null === (P = null == q ? void 0 : q.publishedComments) || void 0 === P ? void 0 : P.metric) || void 0 === N ? void 0 : N.toString()) || ""), s.fbt._plural((null === (D = null == q ? void 0 : q.publishedComments) || void 0 === D ? void 0 : D.metric) || 0)], {
					hk: "34gSaK"
				})), o.a.createElement("div", {
					className: Object(a.a)(E.a.detailText, "text-neutral-content-weak")
				}, j(null === (M = null == q ? void 0 : q.publishedComments) || void 0 === M ? void 0 : M.delta)))), o.a.createElement("div", {
					className: E.a.subredditRow
				}, o.a.createElement(C.a, {
					className: E.a.snooImage
				}), o.a.createElement("div", {
					className: E.a.subredditRowText
				}, o.a.createElement("div", {
					className: Object(a.a)(E.a.subredditName, "text-neutral-content-strong")
				}, s.fbt._({
					"*": "{total reports} reports on posts and comments",
					_1: "{total reports} report on posts and comments"
				}, [s.fbt._param("total reports", ((null == q ? void 0 : q.totalReports) || 0).toString()), s.fbt._plural((null == q ? void 0 : q.totalReports) || 0)], {
					hk: "2HRlQi"
				}))))) : o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
					className: E.a.subredditRow
				}, o.a.createElement(A, {
					className: E.a.snooImage
				}), o.a.createElement("div", {
					className: E.a.subredditRowText
				}, o.a.createElement("div", {
					className: Object(a.a)(E.a.subredditName, "text-neutral-content-strong")
				}, s.fbt._({
					"*": "{removed post count} removed posts",
					_1: "{removed post count} removed post"
				}, [s.fbt._param("removed post count", (null === (L = null === (R = null == q ? void 0 : q.removedPosts) || void 0 === R ? void 0 : R.metric) || void 0 === L ? void 0 : L.toString()) || ""), s.fbt._plural((null === (B = null == q ? void 0 : q.removedPosts) || void 0 === B ? void 0 : B.metric) || 0)], {
					hk: "3woUPL"
				})), o.a.createElement("div", {
					className: Object(a.a)(E.a.detailText, "text-neutral-content-weak")
				}, j(null === (F = null == q ? void 0 : q.removedPosts) || void 0 === F ? void 0 : F.delta)))), o.a.createElement("div", {
					className: E.a.subredditRow
				}, o.a.createElement(O, {
					className: E.a.snooImage
				}), o.a.createElement("div", {
					className: E.a.subredditRowText
				}, o.a.createElement("div", {
					className: Object(a.a)(E.a.subredditName, "text-neutral-content-strong")
				}, s.fbt._({
					"*": "{removed comments count} removed comments",
					_1: "{removed comments count} removed comment"
				}, [s.fbt._param("removed comments count", (null === (H = null === (U = null == q ? void 0 : q.removedComments) || void 0 === U ? void 0 : U.metric) || void 0 === H ? void 0 : H.toString()) || ""), s.fbt._plural((null === (G = null == q ? void 0 : q.removedComments) || void 0 === G ? void 0 : G.metric) || 0)], {
					hk: "15hI0m"
				})), o.a.createElement("div", {
					className: Object(a.a)(E.a.detailText, "text-neutral-content-weak")
				}, j(null === (Q = null == q ? void 0 : q.removedComments) || void 0 === Q ? void 0 : Q.delta)))))), o.a.createElement("a", {
					className: Object(a.a)(E.a.moreLink, "pl-sm flex items-center text-12 font-bold pb-2xs"),
					href: `/mod/${t}/insights/${"spam"===x?"community_health":"team_health"}`,
					onClick: $,
					target: "_blank",
					rel: "noopener noreferrer"
				}, s.fbt._("More Insights", null, {
					hk: "4B4tlU"
				}), o.a.createElement(g.a, {
					className: "pt-lg h-[10px]"
				}))))
			}
		},
		"./src/reddit/components/ModModeBanners/index.m.less": function(e, t, n) {
			e.exports = {
				banner: "_3FJq-cq7boH_EAWZsUPWY0",
				icon: "_1QOFlf2Sv2RU3pPqUKD6UD",
				staticBanner: "_14wV0QXuPq6IJL_pdl8sQs"
			}
		},
		"./src/reddit/components/ModModeFilteredReason/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/models/ModQueueTrigger/index.ts");
			const r = e => (e => !e.isApproved && !!Object(s.c)(e, s.b.AUTOMOD))(e) || (e => !e.isApproved && !!Object(s.c)(e, s.b.BAN_EVASION))(e) || (e => !e.isApproved && !!Object(s.c)(e, s.b.CROWD_CONTROL))(e) || (e => !e.isApproved && !!Object(s.c)(e, s.b.HATEFUL_CONTENT))(e)
		},
		"./src/reddit/components/ModModeFilteredReason/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/lib/classNames/index.ts"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/components/ModModeBanners/index.m.less"),
				d = n.n(a);
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js"), l = () => i.a.createElement("div", {
				className: Object(r.a)(d.a.banner, d.a.staticBanner)
			}, c._("Loading filter reason", null, {
				hk: "K3Ipd"
			})), u = Object(s.a)({
				resolved: {},
				chunkName: () => "ModModeBanners",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModModeBanners").then(n.bind(null, "./src/reddit/components/ModModeFilteredReason/_ModModeFilteredReason.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ModModeFilteredReason/_ModModeFilteredReason.tsx"
				}
			}, {
				fallback: i.a.createElement(l, null),
				ssr: !1
			});
			t.a = u
		},
		"./src/reddit/components/ModModeReports/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			const s = e => (e.numReports || 0) > 0 || !!e.modReportsDismissed && e.modReportsDismissed.length > 0 || !!e.userReportsDismissed && e.userReportsDismissed.length > 0,
				r = e => {
					if (e.numReports && e.numReports > 0) return e.numReports;
					return (e.modReportsDismissed && e.modReportsDismissed.length || 0) + (e.userReportsDismissed && e.userReportsDismissed.length || 0)
				},
				o = e => (e.numReports || 0) > 0
		},
		"./src/reddit/components/ModModeReports/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/lib/classNames/index.ts"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/components/ModModeBanners/index.m.less"),
				d = n.n(a);
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js"), l = () => i.a.createElement("div", {
				className: Object(r.a)(d.a.banner, d.a.staticBanner)
			}, c._("Loading reports", null, {
				hk: "4gwdQw"
			})), u = Object(s.a)({
				resolved: {},
				chunkName: () => "ModModeBanners",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModModeBanners").then(n.bind(null, "./src/reddit/components/ModModeReports/_ModModeReports.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ModModeReports/_ModModeReports.tsx"
				}
			}, {
				fallback: i.a.createElement(l, null),
				ssr: !1
			});
			t.a = u
		},
		"./src/reddit/components/ModQueueActionBar/StatusDisplays/FilteredStatusDisplay.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return U
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/fbt/lib/FbtPublic.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/reddit/icons/fonts/index.tsx"),
				c = n("./src/reddit/models/ModQueueTrigger/index.ts"),
				l = n("./src/reddit/components/RichTextJson/index.tsx"),
				u = n("./src/reddit/constants/things.ts"),
				m = n("./src/reddit/selectors/telemetry.ts");
			const p = e => t => ({
					source: "moderator",
					action: "click",
					noun: e.isCorrect ? "filter_is_correct" : "filter_is_incorrect",
					...b(e, t)
				}),
				b = (e, t) => {
					const n = e.contentId.startsWith(u.a) ? e.contentId : "",
						s = e.contentId.startsWith(u.b) ? e.contentId : "";
					return {
						comment: n ? Object(m.i)({
							state: t,
							commentId: n
						}) : null,
						post: s ? Object(m.L)(t, s) : null,
						filter: {
							reference: {
								name: e.filterName
							}
						},
						subreddit: Object(m.pb)(t, e.contentId),
						...m.p(t)
					}
				};
			var f = n("./src/reddit/hooks/useIntersectionObserver.ts"),
				h = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/constants/localStorage.ts")),
				g = n("./src/reddit/hooks/useLocalStorage.ts"),
				v = n("./src/reddit/hooks/useUserContext.ts");
			const x = () => {
				var e, t;
				const n = `${null!==(t=null===(e=Object(v.a)().currentUser)||void 0===e?void 0:e.id)&&void 0!==t?t:""}-${h.b.SAFETY_FILTER_FEEDBACK_CONTENT_IDS}`,
					[s, r] = Object(g.a)(n, []);
				return {
					contentIds: new Set(s),
					addContentId: e => {
						const t = [...s, e];
						t.length > 50 && t.shift(), r(t)
					}
				}
			};
			var E = n("./src/reddit/hooks/useTracking.ts");
			const O = {
				threshold: [.5]
			};
			var C = e => {
					const t = Object(s.useRef)(null),
						n = Object(E.a)(),
						{
							contentIds: o
						} = x(),
						i = Object(s.useCallback)(t => {
							t.forEach(t => {
								let {
									intersectionRatio: s
								} = t;
								s >= .5 && !o.has(e.contentId) && n((e => t => ({
									source: "modqueue",
									action: "view",
									noun: "hitl_filter_feedback",
									...b(e, t)
								}))({
									...e
								}))
							})
						}, [n, e, o]);
					return Object(f.a)(t, i, O), r.a.createElement("div", {
						ref: t
					}, e.children)
				},
				A = n("./src/reddit/constants/experiments.ts"),
				y = n("./src/reddit/hooks/useExperimentVariant.ts"),
				j = n("./src/reddit/hooks/useMounted.ts"),
				I = n("./src/reddit/components/ModQueueActionBar/helpers.ts"),
				k = n("./node_modules/lodash/debounce.js"),
				_ = n.n(k),
				S = n("./src/reddit/components/InfoTextTooltip/Hooked.tsx"),
				w = n("./src/reddit/hooks/useInfoTextTooltip.ts");
			const T = e => {
				let {
					confidence: t,
					children: n
				} = e;
				const s = Object(w.a)({
						placement: "top-end"
					}),
					a = _()(s.hide, 500);
				return r.a.createElement("div", {
					onMouseEnter: () => {
						s.show(), a.cancel()
					},
					onMouseLeave: a
				}, r.a.createElement("button", {
					onClick: e => {
						e.stopPropagation(), s.toggle()
					},
					className: "text-12 text-neutral-content mr-sm hover:underline",
					ref: s.target.ref
				}, r.a.createElement("span", {
					className: Object(i.a)("inline-block mr-2xs h-xs w-xs rounded-full", {
						"bg-alert-caution": t === c.a.LOW,
						"bg-success-background": t === c.a.HIGH
					})
				}), function(e) {
					switch (e) {
						case c.a.LOW:
							return o.fbt._("Low Confidence", null, {
								hk: "1woV5A"
							});
						case c.a.HIGH:
							return o.fbt._("High Confidence", null, {
								hk: "2UzCkt"
							})
					}
				}(t)), r.a.createElement(S.a, {
					popperProps: s.popperProps,
					arrowProps: s.arrowProps,
					visible: s.visible,
					className: "max-w-[230px] font-semibold text-12"
				}, r.a.createElement("div", {
					className: "py-xs flex gap-x-xs",
					onClick: e => e.stopPropagation()
				}, r.a.createElement(d.a, {
					name: "info_fill"
				}), r.a.createElement("div", null, n))))
			};
			var P = n("./src/reddit/components/TrackingHelper/index.tsx"),
				N = n("./src/reddit/components/ModQueueActionBar/StatusDisplays/SafetyFilterFeedbackPrompt.m.less"),
				D = n.n(N);
			const M = e => {
				let {
					filterName: t,
					contentId: n
				} = e;
				const i = Object(P.b)(),
					{
						addContentId: a
					} = x(),
					[d, c] = Object(s.useState)(!1),
					l = e => t => {
						t.stopPropagation(), a(n), c(!0), i(e)
					};
				return r.a.createElement("div", {
					className: D.a.feedbackPromptContainer
				}, r.a.createElement("p", {
					className: D.a.feedbackPrompt
				}, d ? o.fbt._("Thanks for your feedback!", null, {
					hk: "3ImVsP"
				}) : o.fbt._("Was this accurate?", null, {
					hk: "370juX"
				})), !d && r.a.createElement(r.a.Fragment, null, r.a.createElement("button", {
					"aria-label": "feedback response yes",
					className: D.a.feedbackPromptButton,
					onClick: l(p({
						isCorrect: !0,
						filterName: t,
						contentId: n
					}))
				}, o.fbt._("Yes", null, {
					hk: "QULVC"
				})), r.a.createElement("span", {
					className: D.a.feedbackButtonMiddot
				}, ""), r.a.createElement("button", {
					"aria-label": "feedback response no",
					className: D.a.feedbackPromptButton,
					onClick: l(p({
						isCorrect: !1,
						filterName: t,
						contentId: n
					}))
				}, o.fbt._("No", null, {
					hk: "4zGto5"
				}))))
			};
			var R = n("./src/reddit/components/ModQueueActionBar/StatusDisplays/StatusDisplay.m.less"),
				L = n.n(R);
			const B = e => {
					if (e) try {
						return JSON.parse(e)
					} catch {
						return
					}
				},
				F = e => {
					let {
						reasonRichText: t,
						reason: n,
						feedbackPrompt: s
					} = e;
					const i = Object(j.a)();
					if (s) {
						if (!i) return r.a.createElement("p", {
							className: L.a.reasonText
						}, o.fbt._("Loading filter reason", null, {
							hk: "K3Ipd"
						}));
						if (!s.feedbackSent) return r.a.createElement(C, s, r.a.createElement(M, s))
					}
					return t ? r.a.createElement(l.b, {
						content: t,
						rtJsonElementProps: {}
					}) : n ? r.a.createElement("p", {
						className: L.a.reasonText
					}, n) : null
				},
				U = e => {
					let {
						content: t
					} = e;
					const n = Object(y.a)(A.te) === A.Yd,
						{
							contentIds: u
						} = x(),
						m = Object(s.useMemo)(() => {
							var e, s, r, i, d, l;
							const m = [];
							(null === (e = t.modQueueTriggers) || void 0 === e ? void 0 : e.length) || t.bannedBy !== a.l || m.push({
								icon: "bot_fill",
								heading: o.fbt._("Blocked by AutoMod", null, {
									hk: "XZuzM"
								})
							});
							for (const a of t.modQueueTriggers || []) switch (a.type) {
								case c.b.AUTOMOD:
									m.push({
										icon: "bot_fill",
										heading: o.fbt._("Blocked by AutoMod", null, {
											hk: "XZuzM"
										}),
										reason: a.message
									});
									break;
								case c.b.SHADOWBANNED_SUBMITTER:
									m.push({
										icon: "ban_fill",
										heading: o.fbt._("Blocked by Automatic Filter", null, {
											hk: "2iaUCM"
										}),
										reason: a.message
									});
									break;
								case c.b.HATEFUL_CONTENT:
									m.push({
										icon: "mod_mode_fill",
										heading: n ? o.fbt._("Blocked for Harassment", null, {
											hk: "1FQFpi"
										}) : o.fbt._("Blocked by Automatic Filter", null, {
											hk: "4vu7uy"
										}),
										reason: a.message,
										feedbackPrompt: n ? {
											filterName: I.b.HarassingContent,
											feedbackSent: u.has(t.id),
											contentId: t.id
										} : void 0
									});
									break;
								case c.b.CROWD_CONTROL:
									m.push({
										icon: "crowd_control",
										heading: o.fbt._("Blocked by Crowd Control", null, {
											hk: "6LNvT"
										}),
										reason: a.message
									});
									break;
								case c.b.BAN_EVASION:
									m.push({
										icon: "ban_fill",
										heading: o.fbt._("Blocked by Ban Evasion Protection", null, {
											hk: "1unYu9"
										}),
										reason: a.message,
										reasonRichText: B(null === (r = null === (s = a.details) || void 0 === s ? void 0 : s.recencyExplanation) || void 0 === r ? void 0 : r.richtext),
										confidence: null === (i = a.details) || void 0 === i ? void 0 : i.confidence,
										confidenceExplanation: B(null === (l = null === (d = a.details) || void 0 === d ? void 0 : d.confidenceExplanation) || void 0 === l ? void 0 : l.richtext)
									})
							}
							return m
						}, [t.modQueueTriggers, t.bannedBy, t.id, n]);
					return r.a.createElement("div", {
						className: L.a.filteredWrapper
					}, m.map((e, t) => {
						const {
							heading: n,
							reason: s,
							icon: o,
							confidence: a,
							confidenceExplanation: c
						} = e;
						return r.a.createElement("div", {
							key: `${n}-${s}-${t}`,
							className: L.a.filteredRow
						}, r.a.createElement(d.a, {
							isFilled: !0,
							name: o,
							className: Object(i.a)(L.a.coloredIcon, L.a.icon)
						}), r.a.createElement("div", {
							className: L.a.statusText
						}, r.a.createElement("div", {
							className: L.a.statusMeta
						}, r.a.createElement("p", {
							className: L.a.status
						}, n), a && c && r.a.createElement(T, {
							confidence: a
						}, r.a.createElement(l.b, {
							className: L.a.tooltipContent,
							content: c,
							rtJsonElementProps: {}
						}))), r.a.createElement(F, e)))
					}))
				}
		},
		"./src/reddit/components/ModQueueActionBar/StatusDisplays/SafetyFilterFeedbackPrompt.m.less": function(e, t, n) {
			e.exports = {
				feedbackPromptContainer: "_3RtSyVCC6P8Sf0jcGpvCf-",
				feedbackPrompt: "_32ku9VINzkoa2aCNXzXAdB",
				feedbackPromptButton: "_3xtpwUZ-CWdFHk89lj-iQD",
				feedbackButtonMiddot: "_2urD2Oe4XFQoyHKHwdlc5y"
			}
		},
		"./src/reddit/components/ModQueueActionBar/StatusDisplays/StatusDisplay.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_2qFtoxD1OfFOBkQIQeIP5N",
				opened: "_3kWeXZJizg6u4Rpq5Bx2k6",
				openable: "_1jr1ZpXLdZNEfWwHwMp3UW",
				filteredWrapper: "_1aoTzKKtmlGCr-UYW5QI5O",
				filteredRow: "_eBNIEsnbYySvkxjmpt2P",
				reportedWrapper: "_1rfFSNr23RcUWm7d90DpDo",
				reportMeta: "_32zOxnfn5FxzpA0vNAYP7J",
				ignoreButton: "_3qPfB3L3JEpdPsa2KJ6I6Y",
				ignoreButtonIcon: "_2xeI0-KXBryv89ds5re0ac",
				reported: "_37f_VPQZEbIxZBhfy_wkzt",
				icon: "OYsuhocczx0FWqSu4etye",
				approved: "_3PA1NUdBncNEoWXl9e53aE",
				statusText: "_3trW-r5LnijGIrjgDF1u2M",
				status: "_3Q6W_eSDsN-BhormvQBcRr",
				statusMeta: "_3Qp7V0IlguVisBYUCEDLwX",
				tooltipContent: "_1SLswtlo8BWHAgKgT5Nsj_",
				reasonText: "_7YNYpwZk3KH6oXU4KhoGd",
				snoozabledButton: "_3Rixx0Z51qJ71wGmQ8UtQj",
				userIconWrapper: "_3vnCHVExwDbhdlwSh9BV9k",
				userIcon: "_1O-L18qAEJqcxeYP7bE4mK",
				filteredExplanationIcon: "a13uMv6sihYo-UyNBZDo8",
				snoozableDropdown: "_3L6lZrroGMf7wnI2DFJDJx",
				snoozeIcon: "BUoPqJh1q6Pv_Vf5bsKyT",
				caretButton: "_1iROd0ZxfCEcEidNiygaYB",
				caretIcon: "-vF-jMhpa_XhPJ_ntG1Hv",
				userlink: "_2iRjlf0DdO9rVaTZpfwvHA"
			}
		},
		"./src/reddit/components/ModQueueActionBar/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return c
			}));
			var s, r, o = n("./src/lib/constants/index.ts"),
				i = n("./src/reddit/helpers/isPost.ts"),
				a = n("./src/reddit/models/Post/index.ts"),
				d = n("./src/reddit/components/ModModeFilteredReason/helpers.ts");
			! function(e) {
				e.UNMODERATED = "UNMODERATED", e.APPROVED = "APPROVED", e.REMOVED = "REMOVED", e.SPAM = "SPAM", e.REPORTED = "REPORTED", e.FILTERED = "FILTERED"
			}(s || (s = {})),
			function(e) {
				e.HarassingContent = "harassing_content"
			}(r || (r = {}));
			const c = e => e.isRemoved && (!e.bannedBy || e.bannedBy === o.l) || !e.isRemoved && Object(d.a)(e) ? s.FILTERED : e.isRemoved || Object(i.b)(e) && [a.g.AntiEvilOps, a.g.CommunityOps, a.g.ContentTakedown, a.g.CopyrightTakedown, a.g.Reddit].indexOf(e.removedByCategory) > -1 ? s.REMOVED : e.isSpam ? s.SPAM : (e.numReports || 0) > 0 ? s.REPORTED : e.isApproved ? s.APPROVED : s.UNMODERATED
		},
		"./src/reddit/components/ModQueueActionBar/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "zF_-R5xzOOncUiSyzLSC9",
				actionBar: "NMY-KfFuIWlYboZZZ8EcY",
				overflowButton: "zctszRbdSXb3WEChmk-o9",
				button: "_3W9WNfkd8zxnn_VGjf4UnY",
				approve: "_3mPdPTYWWZwCYwh4wijZvJ",
				icon: "_1H-LK0KAgKuxT0BkJSN-51",
				overflowHeading: "_2DEP4U6JV7ZNOcbW94l3tb",
				dropdownRow: "_1dFDaRKdCA0DGOYecpQXWF"
			}
		},
		"./src/reddit/components/ModQueueActionBar/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return De
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/reddit/actions/modQueue/realtime.ts"),
				c = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				l = n("./src/reddit/components/ReportFlow/new.tsx"),
				u = n("./src/reddit/controls/Button/index.tsx"),
				m = n("./src/reddit/helpers/hasModFlairPermissions/index.ts"),
				p = n("./src/reddit/helpers/isPost.ts"),
				b = n("./src/reddit/helpers/trackers/modTools.ts"),
				f = n("./src/reddit/helpers/trackers/post.ts"),
				h = n("./src/reddit/hooks/useIntersectionObserver.ts"),
				g = n("./src/reddit/hooks/useTracking.ts"),
				v = n("./src/reddit/icons/fonts/index.tsx"),
				x = n("./src/reddit/models/Post/index.ts"),
				E = n("./src/reddit/actions/comment/moderation.ts"),
				O = n("./src/reddit/actions/modal.ts"),
				C = n("./src/reddit/actions/post.ts"),
				A = n("./src/reddit/actions/postFlair.ts"),
				y = n("./src/reddit/actions/removalReasons/index.ts"),
				j = n("./src/reddit/selectors/activeModal.ts"),
				I = n("./src/reddit/selectors/moderatorPermissions.ts"),
				k = n("./src/reddit/components/ModQueueActionBar/helpers.ts"),
				_ = n("./src/reddit/components/ModQueueActionBar/index.m.less"),
				S = n.n(_),
				w = n("./src/lib/classNames/index.ts"),
				T = n("./src/lib/constants/icons.ts"),
				P = n("./src/reddit/actions/gold/modals.ts"),
				N = n("./src/reddit/actions/reportFlow/index.ts"),
				D = n("./src/reddit/components/GiveAwardTooltip/index.tsx"),
				M = n("./src/reddit/components/OverflowMenu/index.tsx"),
				R = n("./src/reddit/constants/modals.ts"),
				L = n("./src/reddit/controls/Dropdown/Row.tsx"),
				B = n("./src/reddit/helpers/correlationIdTracker.ts"),
				F = n("./src/reddit/helpers/hasModPostPermissions/index.ts"),
				U = n("./src/reddit/helpers/trackers/gild.ts"),
				H = n("./src/reddit/selectors/comments.ts"),
				G = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				Q = n("./src/reddit/selectors/user.ts"),
				q = n("./src/devPlatform/components/ContextActions/ContextActionsLoader.tsx"),
				W = n("./src/devPlatform/constants.ts");
			const z = (e, t) => Object(b.c)(t, e),
				V = (e, t) => e ? t ? s.fbt._("Unlock Comments", null, {
					hk: "zGuti"
				}) : s.fbt._("Lock Comments", null, {
					hk: "1QO9cp"
				}) : t ? s.fbt._("Unlock thread", null, {
					hk: "SqzQU"
				}) : s.fbt._("Lock thread", null, {
					hk: "3drB04"
				});
			var K = e => {
					let {
						content: t,
						hostPostData: n,
						listingKey: d,
						moderatorPermissions: c
					} = e;
					var l, u;
					const m = Object(g.a)(),
						h = Object(i.d)(),
						x = Object(p.b)(t),
						A = Object(i.e)(Q.k),
						y = Object(i.e)(Q.P),
						j = Object(i.e)(G.b),
						I = Object(F.a)(c),
						k = x ? f.n : z,
						_ = t.authorId === A,
						K = y && _,
						Y = (null === (l = t.distinguishType) || void 0 === l ? void 0 : l.toLowerCase()) === a.I.ADMIN,
						J = (null === (u = t.distinguishType) || void 0 === u ? void 0 : u.toLowerCase()) === a.I.MODERATOR,
						X = Object(r.useCallback)(() => {
							const e = x ? C.D : E.c;
							h(e(t.id));
							const n = t.isLocked ? "unlock" : "lock";
							m(x ? k(t.id, n) : Object(b.j)(t.id, n, "mod_menu"))
						}, [k, m, h, t, x]),
						Z = Object(r.useCallback)(e => {
							m(Object(f.n)(t.id, e, "post", d, n, void 0))
						}, [m, d, n, t]),
						$ = Object(r.useCallback)(() => {
							var e;
							const n = t.isStickied ? "unsticky" : "sticky";
							x ? (h(Object(C.gb)(t.id)), m(Object(b.n)(n, t.id))) : (h(Object(E.b)(t.id, (null === (e = t.distinguishType) || void 0 === e ? void 0 : e.toLowerCase()) || "", !t.isStickied)), m(Object(b.j)(t.id, n, "mod_menu")))
						}, [m, h, t, x]),
						ee = Object(r.useCallback)(() => {
							x && (h(Object(C.I)(t.id)), m(Object(b.n)(t.isOriginalContent ? "unmark_original_content" : "mark_original_content", t.id)))
						}, [m, h, t, x]),
						te = Object(r.useCallback)(() => {
							x && (h(Object(C.F)(t.id)), Object(b.n)(t.isNSFW ? "unmark_nsfw" : "mark_nsfw", t.id))
						}, [h, t, x]),
						ne = Object(r.useCallback)(() => {
							x && (h(Object(O.i)(R.a.CROWD_CONTROL)), h(Object(C.t)(t.id)))
						}, [h, t, x]),
						se = Object(i.e)(e => Object(H.m)(e, {
							commentId: t.id
						})),
						re = Object(r.useCallback)(() => {
							const e = x ? t.permalink : se;
							e && (h(Object(C.C)(e)), x ? Z("copy") : m(Object(b.j)(t.id, "share", "mod_menu")))
						}, [Z, h, t, x, se, m]),
						oe = Object(r.useCallback)(async () => {
							if (!x) return;
							const e = Object(B.d)(B.a.GildingFlow, !0);
							h(Object(P.d)({
								awardId: null == j ? void 0 : j.id,
								correlationId: e,
								thingId: t.id
							})), m(Object(U.clickGildEvent)(t.id))
						}, [m, h, t, j, x]),
						ie = Object(r.useCallback)(() => {
							h(Object(N.c)(t.id)), x ? Z("report") : m(Object(b.j)(t.id, "report", "mod_menu"))
						}, [Z, h, t, x, m]),
						ae = Object(r.useCallback)(() => {
							var e;
							x && (h(Object(C.db)(t.id, !t.hidden, !1, !0)), Z((null === (e = t) || void 0 === e ? void 0 : e.hidden) ? "unhide" : "hide"))
						}, [Z, h, t, x]),
						de = Object(r.useCallback)(() => {
							const e = x ? C.S : E.e;
							h(e(t.id, !0)), m(x ? Object(b.n)("spam", t.id) : Object(b.j)(t.id, "remove_as_spam", "mod_menu"))
						}, [m, h, t, x]),
						ce = Object(r.useCallback)(e => {
							const n = x ? C.u : E.b;
							h(n(t.id, e));
							const s = e === a.I.ADMIN ? "distinguish_as_admin" : e === a.I.MODERATOR ? "distinguish_as_mod" : "undistinguish";
							m(Object(b.j)(t.id, s, "mod_menu"))
						}, [h, t, x, m]);
					return o.a.createElement(M.b, {
						dropdownId: `modqueue-item-overflow-${t.id}`,
						className: S.a.overflowButton,
						icon: o.a.createElement(v.a, {
							name: T.a.overflow_horizontal,
							isFilled: !0
						})
					}, o.a.createElement("h6", {
						className: Object(w.a)("text-neutral-content-weak", S.a.overflowHeading)
					}, s.fbt._("Moderation", null, {
						hk: "2NlyQQ"
					})), !t.isRemoved && !t.isSpam && o.a.createElement(o.a.Fragment, null, o.a.createElement(L.b, {
						className: S.a.dropdownRow,
						displayText: s.fbt._("Remove as spam", null, {
							hk: "3jqLzv"
						}),
						onClick: de
					}, o.a.createElement(v.a, {
						name: T.a.spam
					})), x && o.a.createElement(L.b, {
						className: S.a.dropdownRow,
						displayText: t.isStickied ? s.fbt._("Unsticky Post", null, {
							hk: "3Y6DOH"
						}) : s.fbt._("Sticky Post", null, {
							hk: "RNgCH"
						}),
						onClick: $
					}, o.a.createElement(v.a, {
						name: t.isStickied ? T.a.unpin : T.a.pin
					}))), o.a.createElement(L.b, {
						className: S.a.dropdownRow,
						onClick: X,
						displayText: V(x, !!(null == t ? void 0 : t.isLocked))
					}, o.a.createElement(v.a, {
						name: T.a.lock,
						isFilled: null == t ? void 0 : t.isLocked
					})), _ && o.a.createElement(L.b, {
						className: S.a.dropdownRow,
						displayText: J ? s.fbt._("Undistinguish as a mod", null, {
							hk: "2Nmjxw"
						}) : s.fbt._("Distinguish as a mod", null, {
							hk: "35wmCr"
						}),
						onClick: () => ce(J ? "" : a.I.MODERATOR)
					}, o.a.createElement(v.a, {
						name: J ? T.a.distinguish_fill : T.a.distinguish
					})), K && o.a.createElement(L.b, {
						className: S.a.dropdownRow,
						displayText: Y ? s.fbt._("Undistinguish as an admin", null, {
							hk: "BHAJd"
						}) : s.fbt._("Distinguish as an admin", null, {
							hk: "3gaPvB"
						}),
						onClick: () => ce(Y ? "" : a.I.ADMIN)
					}, o.a.createElement(v.a, {
						name: Y ? T.a.distinguish_fill : T.a.distinguish
					})), !x && (Y || J) && _ && o.a.createElement(L.b, {
						className: S.a.dropdownRow,
						displayText: t.isStickied ? s.fbt._("Unsticky the comment", null, {
							hk: "18TByd"
						}) : s.fbt._("Sticky the comment", null, {
							hk: "3roZIi"
						}),
						onClick: $
					}, o.a.createElement(v.a, {
						name: t.isStickied ? T.a.unpin : T.a.pin
					})), x && !t.crosspostParentId && o.a.createElement(L.b, {
						className: S.a.dropdownRow,
						onClick: ee,
						displayText: t.isOriginalContent ? s.fbt._("Remove OC Mark", null, {
							hk: "1R9sR"
						}) : s.fbt._("Mark as OC", null, {
							hk: "31GUJ2"
						})
					}, o.a.createElement(v.a, {
						name: T.a.original
					})), x && o.a.createElement(L.b, {
						className: S.a.dropdownRow,
						onClick: te,
						displayText: t.isNSFW ? s.fbt._("Mark as SFW", null, {
							hk: "rvDBl"
						}) : s.fbt._("Mark as NSFW", null, {
							hk: "1q4nut"
						})
					}, o.a.createElement(v.a, {
						name: T.a.nsfw
					})), x && I && "subreddit" === t.belongsTo.type && o.a.createElement(L.b, {
						className: S.a.dropdownRow,
						displayText: s.fbt._("Adjust crowd control", null, {
							hk: "4Drg85"
						}),
						onClick: ne
					}, o.a.createElement(v.a, {
						name: T.a.crowd_control
					})), o.a.createElement(q.a, {
						contextType: Object(p.a)(t.id) ? W.a.POST : W.a.COMMENT,
						contextData: t,
						moderator: !0,
						isOnModQueueOverflowMenu: !0
					}), o.a.createElement("h6", {
						className: Object(w.a)("text-neutral-content-weak", S.a.overflowHeading)
					}, s.fbt._("Other", null, {
						hk: "2543kN"
					})), o.a.createElement(L.b, {
						className: S.a.dropdownRow,
						displayText: s.fbt._("Share", null, {
							hk: "3L9n7l"
						}),
						onClick: re
					}, o.a.createElement(v.a, {
						name: T.a.share
					})), x && o.a.createElement(L.b, {
						className: S.a.dropdownRow,
						onClick: oe,
						displayText: s.fbt._("Award", null, {
							hk: "4hkt8T"
						})
					}, o.a.createElement(v.a, {
						name: T.a.award
					}), o.a.createElement(D.a, {
						postOrComment: t,
						tooltipId: `modqueue-item-award-${t.id}`
					})), o.a.createElement(L.b, {
						className: S.a.dropdownRow,
						displayText: s.fbt._("Report", null, {
							hk: "1FAnQb"
						}),
						onClick: ie
					}, o.a.createElement(v.a, {
						name: T.a.report
					})), x && o.a.createElement(L.b, {
						className: S.a.dropdownRow,
						onClick: ae,
						displayText: t.hidden ? s.fbt._("Unhide", null, {
							hk: "3L7lXA"
						}) : s.fbt._("Hide", null, {
							hk: "19RA4b"
						})
					}, o.a.createElement(v.a, {
						name: T.a.hide
					})), o.a.createElement(q.a, {
						contextType: Object(p.a)(t.id) ? W.a.POST : W.a.COMMENT,
						contextData: t,
						moderator: !1,
						isOnModQueueOverflowMenu: !0
					}))
				},
				Y = n("./src/reddit/helpers/trackers/modListing.ts"),
				J = n("./src/config.ts"),
				X = n("./src/reddit/components/UserIcon/index.tsx"),
				Z = n("./src/reddit/helpers/name/index.ts"),
				$ = n("./src/reddit/constants/intlSupport.ts"),
				ee = n("./src/reddit/helpers/graphql/helpers.ts"),
				te = n("./src/reddit/hooks/useLocale.ts");

			function ne(e) {
				return new Date(Date.now()).getFullYear() === e.getFullYear()
			}
			var se = function(e) {
					let {
						date: t,
						...n
					} = e;
					const r = Object(te.a)(),
						i = "string" == typeof t ? Object(ee.g)(t) / a.Xb : t,
						d = new Date(i * a.Xb);
					if (!$.a) return o.a.createElement(o.a.Fragment, null, d.toLocaleString());
					const c = new Intl.DateTimeFormat(r, {
							month: "short",
							day: "numeric",
							year: ne(d) ? void 0 : "numeric"
						}),
						l = new Intl.DateTimeFormat(r, {
							minute: "numeric",
							hour: "numeric"
						}),
						u = function(e) {
							const t = new Date(Date.now());
							return t.getFullYear() === e.getFullYear() && t.getMonth() === e.getMonth() && t.getDate() === e.getDate()
						}(d) ? s.fbt._("Today", null, {
							hk: "1sZpnp"
						}) : c.format(d),
						m = l.format(d);
					return s.fbt._("{date} at {time}", [s.fbt._param("date", u), s.fbt._param("time", m)], {
						hk: "Ot5zO"
					})
				},
				re = n("./src/reddit/components/ModQueueActivitySummaryCards/helpers.ts"),
				oe = n("./src/reddit/components/CCM/ModPreviousActions/index.m.less"),
				ie = n.n(oe);
			var ae = e => {
				let {
					className: t,
					modAction: n,
					postOrCommentId: s
				} = e;
				var r, i, a, d, c;
				const l = (null === (r = n.moderatorInfo) || void 0 === r ? void 0 : r.displayName) || "",
					u = (null === (a = null === (i = n.moderatorInfo) || void 0 === i ? void 0 : i.icon) || void 0 === a ? void 0 : a.url) || "",
					m = !!(null === (c = null === (d = n.moderatorInfo) || void 0 === d ? void 0 : d.profile) || void 0 === c ? void 0 : c.isNsfw),
					b = Object(p.a)(s);
				return o.a.createElement("div", {
					className: Object(w.a)(t, ie.a.row)
				}, o.a.createElement("div", {
					className: ie.a.userIconWrapper
				}, o.a.createElement(X.a, {
					className: ie.a.userIcon,
					iconUrl: u,
					userName: l,
					isNSFW: m
				})), o.a.createElement("div", {
					className: ie.a.details
				}, o.a.createElement("h3", {
					className: ie.a.title
				}, Object(re.a)(n.action, b ? "SubredditPost" : "")), o.a.createElement("p", {
					className: ie.a.meta
				}, o.a.createElement("a", {
					className: ie.a.userlink,
					href: `${J.a.redditUrl}/user/${l}`,
					target: "_blank",
					rel: "noopener noreferrer",
					onClick: e => e.stopPropagation()
				}, Object(Z.e)(l)))), o.a.createElement("span", {
					className: ie.a.time
				}, o.a.createElement(se, {
					date: n.createdAt
				})))
			};
			var de = e => {
				let {
					className: t,
					reportAction: n
				} = e;
				return o.a.createElement("div", {
					className: Object(w.a)(t, ie.a.row)
				}, o.a.createElement(v.a, {
					isFilled: !0,
					name: "report_fill",
					className: ie.a.icon
				}), o.a.createElement("div", {
					className: ie.a.details
				}, o.a.createElement("h3", {
					className: ie.a.title
				}, s.fbt._("Reported for", null, {
					hk: "pm0ot"
				})), !!n.reason && o.a.createElement("p", {
					className: ie.a.meta
				}, n.reason)), o.a.createElement("span", {
					className: ie.a.time
				}, o.a.createElement(se, {
					date: n.createdAt
				})))
			};
			var ce = e => {
					const t = Object(i.e)(t => {
						var n, s;
						const r = null === (s = null === (n = null == t ? void 0 : t.features) || void 0 === n ? void 0 : n.modPreviousActions) || void 0 === s ? void 0 : s.order[e.postOrCommentId];
						if (r && r.length) return r.map(e => {
							var n, s;
							return null === (s = null === (n = null == t ? void 0 : t.features) || void 0 === n ? void 0 : n.modPreviousActions) || void 0 === s ? void 0 : s.models[e]
						})
					});
					return t ? o.a.createElement("div", {
						className: Object(w.a)(e.className, ie.a.wrapper)
					}, o.a.createElement("h2", {
						className: ie.a.wrapperTitle
					}, s.fbt._("Recent actions", null, {
						hk: "PAtYM"
					})), t.map(t => "ModAction" === (null == t ? void 0 : t.__typename) ? o.a.createElement(ae, {
						modAction: t,
						key: t.id,
						postOrCommentId: e.postOrCommentId
					}) : "ReportAction" === (null == t ? void 0 : t.__typename) ? o.a.createElement(de, {
						reportAction: t,
						key: t.id
					}) : null)) : null
				},
				le = n("./src/reddit/components/HumanDate/index.tsx"),
				ue = n("./src/reddit/components/ModQueueActionBar/StatusDisplays/StatusDisplay.m.less"),
				me = n.n(ue);
			const pe = e => {
				let {
					content: t
				} = e;
				var n;
				const r = (null == t ? void 0 : t.approvedBy) || "",
					a = Object(i.e)(e => (null == t ? void 0 : t.approvedBy) ? Object(Q.Db)(e, {
						userName: r
					}) : null),
					d = t.approvedAtUTC ? (null === (n = t.approvedAtUTC) || void 0 === n ? void 0 : n.toString().length) > 10 ? t.approvedAtUTC / 1e3 : t.approvedAtUTC : null;
				return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
					className: me.a.userIconWrapper
				}, o.a.createElement(X.a, {
					className: Object(w.a)(me.a.userIcon),
					iconUrl: null == a ? void 0 : a.accountIcon,
					userName: r,
					isNSFW: !!(null == a ? void 0 : a.isNSFW)
				})), o.a.createElement("div", {
					className: me.a.statusText
				}, o.a.createElement("p", {
					className: me.a.status
				}, s.fbt._("Approved", null, {
					hk: "4d15LY"
				})), o.a.createElement("p", null, o.a.createElement("a", {
					className: me.a.userlink,
					href: `${J.a.redditUrl}/user/${r}`,
					target: "_blank",
					rel: "noopener noreferrer",
					onClick: e => e.stopPropagation()
				}, Object(Z.e)(r)), d && o.a.createElement(o.a.Fragment, null, " ", o.a.createElement(le.d, {
					seconds: d
				})))))
			};
			var be = n("./src/reddit/components/ModQueueActionBar/StatusDisplays/FilteredStatusDisplay.tsx"),
				fe = n("./src/reddit/components/InfoBanners/PostRemovalBanner/helpers.tsx"),
				he = n("./src/reddit/selectors/subreddit.ts");
			const ge = e => {
				let {
					content: t
				} = e;
				var n;
				const r = Object(i.e)(e => (null == t ? void 0 : t.bannedBy) && "string" == typeof(null == t ? void 0 : t.bannedBy) ? Object(Q.Db)(e, {
						userName: null == t ? void 0 : t.bannedBy
					}) : null),
					a = Object(p.b)(t),
					d = Object(i.e)(e => Object(he.X)(e, {
						subredditId: a ? t.belongsTo.id : t.subredditId
					})),
					c = Object(i.e)(e => {
						var t, n, s, r;
						return (null === (n = null === (t = e.user) || void 0 === t ? void 0 : t.account) || void 0 === n ? void 0 : n.isAdmin) || (null === (r = null === (s = e.user) || void 0 === s ? void 0 : s.account) || void 0 === r ? void 0 : r.isEmployee)
					}),
					l = a && t.removedByCategory ? t.removedByCategory : null,
					u = l ? Object(fe.b)(l) : "clear_fill",
					m = t.bannedAtUTC ? (null === (n = t.bannedAtUTC) || void 0 === n ? void 0 : n.toString().length) > 10 ? t.bannedAtUTC / 1e3 : t.bannedAtUTC : null,
					b = ![x.g.AntiEvilOps, x.g.CommunityOps, x.g.ContentTakedown, x.g.CopyrightTakedown, x.g.Reddit].includes(l) || c;
				return o.a.createElement(o.a.Fragment, null, r && b ? o.a.createElement("div", {
					className: me.a.userIconWrapper
				}, o.a.createElement(X.a, {
					className: Object(w.a)(me.a.userIcon),
					iconUrl: r.accountIcon,
					userName: r.username,
					isNSFW: r.isNSFW
				})) : o.a.createElement(v.a, {
					isFilled: !0,
					name: u,
					className: Object(w.a)(me.a.coloredIcon, me.a.icon)
				}), o.a.createElement("div", {
					className: me.a.statusText
				}, o.a.createElement("p", {
					className: me.a.status
				}, s.fbt._("Removed{spam}{reason}", [s.fbt._param("spam", t.isSpam ? " as spam" : ""), s.fbt._param("reason", t.modRemovalReason ? `: ${t.modRemovalReason}` : "")], {
					hk: "3BGtSz"
				})), o.a.createElement("p", null, b && (null == r ? void 0 : r.username) ? o.a.createElement(o.a.Fragment, null, o.a.createElement("a", {
					className: me.a.userlink,
					href: `${J.a.redditUrl}/user/${r.username}`,
					target: "_blank",
					rel: "noopener noreferrer",
					onClick: e => e.stopPropagation()
				}, Object(Z.e)(r.username)), m && o.a.createElement(o.a.Fragment, null, " ", o.a.createElement(le.d, {
					seconds: m
				}))) : l && Object(fe.e)(l, (null == r ? void 0 : r.username) || null, d.name))))
			};
			var ve = n("./src/reddit/components/Reports/SnoozableReport/index.tsx"),
				xe = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				Ee = n("./src/reddit/components/TrackingHelper/index.tsx"),
				Oe = n("./src/reddit/icons/fonts/helpers.tsx");
			n("./src/reddit/icons/fonts/Admin/index.tsx"), n("./src/reddit/icons/fonts/Approve/index.tsx"), n("./src/reddit/icons/fonts/Archived/index.tsx"), n("./src/reddit/icons/fonts/Calendar/index.tsx"), n("./src/reddit/icons/fonts/Clock/index.tsx"), n("./src/reddit/icons/fonts/Clear/index.tsx"), n("./src/reddit/icons/fonts/Coin/index.tsx"), n("./src/reddit/icons/fonts/Comment/index.tsx"), n("./src/reddit/icons/fonts/DistinguishShield/index.tsx"), n("./src/reddit/icons/fonts/Downvote/index.tsx"), n("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"), n("./src/reddit/icons/fonts/Envelope/index.tsx"), n("./src/reddit/icons/fonts/Expand/index.tsx"), n("./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.tsx"), n("./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.tsx"), n("./src/reddit/icons/fonts/Gift/index.tsx");
			var Ce = n("./src/reddit/icons/fonts/IgnoreReport/index.tsx");
			n("./src/reddit/icons/fonts/Info/index.tsx"), n("./src/reddit/icons/fonts/Live/index.tsx"), n("./src/reddit/icons/fonts/Lock/index.tsx");
			n("./src/reddit/icons/fonts/ModActions/index.tsx"), n("./src/reddit/icons/fonts/ModSettings/index.tsx");
			var Ae = n("./src/reddit/icons/fonts/Op/index.m.less"),
				ye = n.n(Ae),
				je = n("./src/lib/lessComponent.tsx");
			je.a.wrapped(e => o.a.createElement("i", {
				className: `${Object(Oe.b)("author",e.isFilled)} ${e.className}`,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, o.a.createElement(Oe.a, null, e.desc)), "OpIcon", ye.a), n("./src/reddit/icons/fonts/OutboundLink/index.tsx"), n("./src/reddit/icons/fonts/Pencil/index.tsx");
			var Ie = n("./src/reddit/icons/fonts/Photos/index.m.less"),
				ke = n.n(Ie);
			je.a.wrapped(e => o.a.createElement("i", {
				className: `${Object(Oe.b)("image_post",e.isFilled)} ${e.className}`
			}), "PhotoIcon", ke.a), n("./src/reddit/icons/fonts/Premium/index.tsx"), n("./src/reddit/icons/fonts/Remove/index.tsx");
			var _e = n("./src/reddit/icons/fonts/Report/index.tsx"),
				Se = (n("./src/reddit/icons/fonts/Share/index.tsx"), n("./src/reddit/icons/fonts/Spam/index.tsx"), n("./src/reddit/icons/fonts/Sticky/index.tsx"), n("./src/reddit/icons/fonts/Tag/index.tsx"), n("./src/reddit/icons/fonts/Text/index.m.less")),
				we = n.n(Se);
			je.a.wrapped(e => o.a.createElement("i", {
				className: `${Object(Oe.b)("text_post",e.isFilled)} ${e.className}`
			}), "TextIcon", we.a), n("./src/reddit/icons/fonts/Upvote/index.tsx");
			const Te = e => {
					let {
						content: t
					} = e;
					const n = Object(Ee.b)(),
						a = Object(i.d)(),
						d = Object(r.useCallback)(() => {
							const e = Object(p.a)(t.id),
								s = e ? C.eb : E.g,
								r = t.ignoreReports ? "restore_reports" : "ignore_reports",
								o = e ? Object(b.l)(r, t.id) : Object(b.k)(r, t.id);
							a(s(t.id)), n(o)
						}, [t.id, t.ignoreReports, n, a]),
						c = (t.modReportsDismissed && t.modReportsDismissed.length || 0) + (t.userReportsDismissed && t.userReportsDismissed.length || 0);
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(v.a, {
						isFilled: !0,
						name: "report_fill",
						className: Object(w.a)(me.a.coloredIcon, me.a.icon)
					}), o.a.createElement("div", {
						className: me.a.reportedWrapper
					}, !!t.modReports.length && o.a.createElement("div", {
						className: me.a.statusText
					}, o.a.createElement("p", {
						className: me.a.status
					}, s.fbt._({
						"*": "{number of reports} Mod Reports",
						_1: "1 Mod Report"
					}, [s.fbt._plural(t.modReports.length, "number of reports")], {
						hk: "P5w8P"
					})), t.modReports.map((e, t) => {
						let [n, s] = e;
						return o.a.createElement("p", {
							key: `${n}-${s}-${t}`
						}, Object(Z.e)(s), ": ", n)
					})), !!t.userReports.length && o.a.createElement("div", {
						className: me.a.statusText
					}, o.a.createElement("div", {
						className: me.a.reportMeta
					}, o.a.createElement("p", {
						className: me.a.status
					}, s.fbt._({
						"*": "{number of reports} Reports",
						_1: "1 Report"
					}, [s.fbt._plural(t.userReports.reduce((e, t) => {
						let [, n] = t;
						return n + e
					}, 0), "number of reports")], {
						hk: "1l1xMH"
					})), !c && o.a.createElement(xe.c, {
						className: me.a.ignoreButton,
						onClick: d,
						text: t.ignoreReports ? s.fbt._("Restore Reports", null, {
							hk: "2O219R"
						}) : s.fbt._("ignore reports", null, {
							hk: "48jlNW"
						})
					}, t.ignoreReports ? o.a.createElement(_e.a, {
						className: me.a.ignoreButtonIcon
					}) : o.a.createElement(Ce.a, {
						className: me.a.ignoreButtonIcon
					}))), t.userReports.map((e, n) => {
						let [s, r, i, a] = e;
						return s ? void 0 !== i && a ? o.a.createElement(ve.a, {
							key: `user-${s}`,
							reason: s,
							amount: r,
							reportedThingId: t.id,
							isSnoozed: i,
							useNewFormat: !0,
							className: me.a.snoozabledButton,
							dropdownClassName: me.a.snoozableDropdown,
							iconClassName: me.a.snoozeIcon
						}) : o.a.createElement("p", {
							key: `user-${s}`
						}, s, " (", r, ")") : null
					}))))
				},
				Pe = e => {
					let {
						content: t
					} = e;
					const n = Object(k.c)(t),
						s = Object(r.useMemo)(() => {
							switch (n) {
								case k.a.APPROVED:
									return o.a.createElement(pe, {
										content: t
									});
								case k.a.REMOVED:
								case k.a.SPAM:
									return o.a.createElement(ge, {
										content: t
									});
								case k.a.FILTERED:
									return o.a.createElement(be.a, {
										content: t
									});
								case k.a.REPORTED:
									return o.a.createElement(Te, {
										content: t
									});
								default:
									return o.a.createElement(r.Fragment, null)
							}
						}, [n, t]),
						[a, d] = Object(r.useState)(!1),
						c = Object(g.a)(),
						l = Object(r.useCallback)(e => {
							var s;
							e.stopPropagation(), d(!a), c(Object(Y.e)((null === (s = t.belongsTo) || void 0 === s ? void 0 : s.id) || t.subredditId, n, Object(p.a)(t.id), !a))
						}, [c, t, a, d, n]),
						u = Object(i.e)(e => {
							var n, s;
							return !!(null === (s = null === (n = null == e ? void 0 : e.features) || void 0 === n ? void 0 : n.modPreviousActions) || void 0 === s ? void 0 : s.order[t.id])
						});
					return n === k.a.UNMODERATED ? null : o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						className: Object(w.a)(me.a.wrapper, {
							[me.a.approved]: n === k.a.APPROVED,
							[me.a.reported]: n === k.a.REPORTED,
							[me.a.opened]: a,
							[me.a.openable]: u
						}),
						onClick: u ? l : void 0
					}, s, u && o.a.createElement("button", {
						className: me.a.caretButton
					}, o.a.createElement(v.a, {
						name: a ? T.a.caret_up : T.a.caret_down,
						className: me.a.caretIcon
					}))), u && a && o.a.createElement(ce, {
						className: me.a.previousActions,
						postOrCommentId: t.id
					}))
				},
				Ne = (e, t) => Object(b.c)(t, e),
				De = e => {
					let {
						content: t,
						listingKey: n,
						hostPostData: b
					} = e;
					const _ = Object(g.a)(),
						w = Object(i.d)(),
						T = Object(k.c)(t),
						P = Object(i.e)(j.b),
						N = Object(p.b)(t),
						D = Object(i.e)(e => {
							var n, s;
							return (null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.reportFlow) || void 0 === s ? void 0 : s.postOrCommentId) === t.id
						}),
						M = Object(i.e)(e => Object(I.m)(e, {
							postId: t.id
						})),
						R = Object(m.a)(M),
						[L, B] = Object(r.useState)(!1),
						F = Object(i.e)(e => {
							var n, s;
							return null === (s = null === (n = null == e ? void 0 : e.features) || void 0 === n ? void 0 : n.realtimeModqueue) || void 0 === s ? void 0 : s.toUpdate.includes(t.id)
						}),
						U = Object(r.useRef)(null),
						H = Object(r.useCallback)(e => {
							e.forEach(e => {
								const {
									isIntersecting: t,
									intersectionRatio: n
								} = e;
								n >= .5 ? B(!0) : t || B(!1)
							})
						}, []);
					L && F && w(Object(d.b)(t.id));
					const G = Object(r.useMemo)(() => ({
						threshold: [.5]
					}), []);
					Object(h.a)(U, H, G);
					const Q = [k.a.REPORTED, k.a.FILTERED, k.a.UNMODERATED].includes(T),
						q = [k.a.APPROVED, k.a.UNMODERATED, k.a.REPORTED].includes(T),
						W = N && R,
						z = T === k.a.REMOVED && Object(p.b)(t) && t.removedByCategory === x.g.Reddit && !t.isRemoved && !t.isApproved,
						V = T === k.a.FILTERED || z,
						Y = T === k.a.REMOVED && !t.modRemovalReason && !V,
						J = [k.a.REMOVED, k.a.SPAM].indexOf(T) > -1,
						X = N ? f.n : Ne,
						Z = Object(r.useCallback)(() => {
							const e = N ? C.r : E.a;
							w(e(t.id)), _(X(t.id, "approve"))
						}, [_, w, t, N, X]),
						$ = Object(r.useCallback)(() => {
							const e = N ? C.S : E.e;
							w(e(t.id, !1)), t.isRemoved && t.bannedBy === a.l ? _(X(t.id, "confirm_remove")) : _(X(t.id, "remove"))
						}, [_, w, t, N, X]),
						ee = Object(r.useCallback)(() => {
							w(Object(y.fetchReasonsAndOpenModal)(N ? t.belongsTo.id : t.subredditId, [t.id]))
						}, [t, N, w]),
						te = Object(r.useCallback)(() => {
							w(Object(O.i)(Object(c.b)(t.id, !1))), _(Object(f.n)(t.id, "post_flair_picker"))
						}, [_, w, t]),
						ne = Object(r.useCallback)(e => {
							let {
								previewFlair: n,
								selectedTemplateId: s
							} = e;
							N && w(Object(A.h)({
								post: t,
								previewFlair: n,
								selectedTemplateId: s
							}))
						}, [w, N, t]);
					return o.a.createElement("div", {
						className: S.a.wrapper,
						"data-testid": "modqueue-action-bar",
						ref: U
					}, o.a.createElement(Pe, {
						content: t
					}), o.a.createElement("div", {
						className: S.a.actionBar
					}, Q && o.a.createElement(u.t, {
						className: [S.a.button, S.a.approve].join(" "),
						Icon: Object(v.b)("checkmark"),
						iconPosition: u.h.L,
						iconClassName: S.a.icon,
						onClick: Z,
						text: s.fbt._("Approve", null, {
							hk: "23KvZI"
						})
					}), q && o.a.createElement(u.t, {
						className: S.a.button,
						Icon: Object(v.b)("close"),
						iconPosition: u.h.L,
						iconClassName: S.a.icon,
						onClick: $,
						text: s.fbt._("Remove", null, {
							hk: "2IDWyI"
						})
					}), Y && o.a.createElement(u.t, {
						className: S.a.button,
						onClick: ee,
						text: s.fbt._("Add Removal Reason", null, {
							hk: "2htsXM"
						})
					}), V && o.a.createElement(u.t, {
						className: S.a.button,
						Icon: Object(v.b)("close"),
						iconPosition: u.h.L,
						iconClassName: S.a.icon,
						onClick: $,
						text: s.fbt._("Confirm Removal", null, {
							hk: "1v0rxC"
						})
					}), J && o.a.createElement(u.t, {
						className: S.a.button,
						Icon: Object(v.b)("checkmark"),
						iconPosition: u.h.L,
						iconClassName: S.a.icon,
						onClick: Z,
						text: s.fbt._("Approve", null, {
							hk: "23KvZI"
						})
					}), W && o.a.createElement(u.t, {
						className: S.a.button,
						Icon: Object(v.b)("tag"),
						priority: u.c.Plain,
						iconPosition: u.h.L,
						iconClassName: S.a.icon,
						onClick: te,
						text: s.fbt._("Flair", null, {
							hk: "4968fn"
						})
					}), N && P === Object(c.b)(t.id, !1) && o.a.createElement(c.a, {
						flairs: t.flair,
						subredditId: t.belongsTo.id,
						modalId: Object(c.b)(t.id, !1),
						onFlairChanged: ne
					}), o.a.createElement(K, {
						content: t,
						hostPostData: b,
						listingKey: n,
						moderatorPermissions: M
					}), D && o.a.createElement(l.a, {
						withOverlay: !0,
						postId: N ? t.id : void 0,
						commentId: N ? void 0 : t.id
					})))
				}
		},
		"./src/reddit/components/ModQueueActivitySummaryCards/async.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.b = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-ModQueueActivitySummaryCards",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-ModQueueActivitySummaryCards").then(n.bind(null, "./src/reddit/components/ModQueueActivitySummaryCards/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ModQueueActivitySummaryCards/index.tsx"
				}
			});
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-ModQueueActivitySummaryCards-ModActivityPreview",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-ModQueueActivitySummaryCards-ModActivityPreview").then(n.bind(null, "./src/reddit/components/ModQueueActivitySummaryCards/ModActivityPreview.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ModQueueActivitySummaryCards/ModActivityPreview.tsx"
				}
			})
		},
		"./src/reddit/components/ModQueueActivitySummaryCards/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/redditGQL/types.ts");
			const o = (e, t) => {
				switch (e) {
					case r.z.AddNote:
						return s.fbt._("Added mod note", null, {
							hk: "4EQdI3"
						});
					case r.z.AddRemovalReason:
						return s.fbt._("Added removal reason", null, {
							hk: "3sDuRA"
						});
					case r.z.AdjustPostCrowdControlLevel:
						return s.fbt._("Adjusted post crowd control level", null, {
							hk: "3Ru27s"
						});
					case r.z.EnablePostCrowdControlFilter:
						return s.fbt._("Enabled post crowd control level", null, {
							hk: "bnrbt"
						});
					case r.z.DisablePostCrowdControlFilter:
						return s.fbt._("Disabled post crowd control level", null, {
							hk: "3Pn8Cm"
						});
					case r.z.ApproveComment:
						return s.fbt._("Approved comment", null, {
							hk: "15N4AH"
						});
					case r.z.ApproveLink:
						return s.fbt._("Approved post", null, {
							hk: "2pHeO6"
						});
					case r.z.BanUser:
						return s.fbt._("Banned user", null, {
							hk: "30ZUto"
						});
					case r.z.Collections:
						return s.fbt._("Collections", null, {
							hk: "4DLN5q"
						});
					case r.z.DeleteNote:
						return s.fbt._("Deleted mod note", null, {
							hk: "24mUGI"
						});
					case r.z.Distinguish:
						return "SubredditPost" === t ? s.fbt._("Post distinguished", null, {
							hk: "1EzjPd"
						}) : s.fbt._("Comment distinguished", null, {
							hk: "3TNqQa"
						});
					case r.z.EditFlair:
						return "SubredditPost" === t ? s.fbt._("Post flair edited", null, {
							hk: "2oj67i"
						}) : s.fbt._("User flair edited", null, {
							hk: "2WAVS8"
						});
					case r.z.IgnoreReports:
						return "SubredditPost" === t ? s.fbt._("Post reports ignored", null, {
							hk: "1HbgCS"
						}) : s.fbt._("Comment reports ignored", null, {
							hk: "3eLRwL"
						});
					case r.z.Lock:
						return "SubredditPost" === t ? s.fbt._("Post locked", null, {
							hk: "45Huvj"
						}) : s.fbt._("Comment locked", null, {
							hk: "2HzroI"
						});
					case r.z.MarkNsfw:
						return s.fbt._("Toggled post NSFW", null, {
							hk: "eAiVp"
						});
					case r.z.MarkOriginalContent:
						return s.fbt._("Toggled post Original Content", null, {
							hk: "46B0Bk"
						});
					case r.z.MuteUser:
						return s.fbt._("Muted user", null, {
							hk: "31YWRG"
						});
					case r.z.RemoveComment:
						return s.fbt._("Removed comment", null, {
							hk: "2qfmzC"
						});
					case r.z.RemoveLink:
						return s.fbt._("Removed post", null, {
							hk: "2leMij"
						});
					case r.z.SetContestMode:
						return s.fbt._("Set post contest mode", null, {
							hk: "2iE074"
						});
					case r.z.SetSuggestedsort:
						return s.fbt._("Set post suggested sort", null, {
							hk: "3zw33Q"
						});
					case r.z.ShowComment:
						return s.fbt._("Showed comment", null, {
							hk: "1xvaXS"
						});
					case r.z.SpamComment:
						return s.fbt._("Marked comment as spam", null, {
							hk: "E6CLe"
						});
					case r.z.SpamLink:
						return s.fbt._("Removed post as spam", null, {
							hk: "1Al2xz"
						});
					case r.z.Spoiler:
						return s.fbt._("Added spoiler tag", null, {
							hk: "254Axx"
						});
					case r.z.Sticky:
						return "SubredditPost" === t ? s.fbt._("Post stickied", null, {
							hk: "4m9DRx"
						}) : s.fbt._("Comment stickied", null, {
							hk: "1JIPzu"
						});
					case r.z.UnbanUser:
						return s.fbt._("Unbanned user", null, {
							hk: "3U4olT"
						});
					case r.z.Unlock:
						return "SubredditPost" === t ? s.fbt._("Post unlocked", null, {
							hk: "3IXrG"
						}) : s.fbt._("Comment unlocked", null, {
							hk: "4v2jmJ"
						});
					case r.z.UnmuteUser:
						return s.fbt._("Unmuted user", null, {
							hk: "2aB30x"
						});
					case r.z.UnsetContestMode:
						return s.fbt._("Unset post contest mode", null, {
							hk: "W4Yjf"
						});
					case r.z.UnsnoozeReports:
						return "SubredditPost" === t ? s.fbt._("Post unsnoozed", null, {
							hk: "3jp8zr"
						}) : s.fbt._("Comment unsnoozed", null, {
							hk: "2x01Eq"
						});
					case r.z.Unspoiler:
						return s.fbt._("Removed spoiler tag", null, {
							hk: "2GvhDn"
						});
					case r.z.Unsticky:
						return "SubredditPost" === t ? s.fbt._("Post unstickied", null, {
							hk: "KXoHl"
						}) : s.fbt._("Comment unstickied", null, {
							hk: "dpEKC"
						});
					case r.z.UpdateRemovalReason:
					case r.z.WikiBanned:
					case r.z.WikiContributor:
					case r.z.WikiPageListed:
					case r.z.WikiPermLevel:
					case r.z.WikiRevise:
					case r.z.WikiUnbanned:
					case r.z.AcceptModeratorInvite:
					case r.z.AddCommunityTopics:
					case r.z.AddContributor:
					case r.z.AddModerator:
					case r.z.CreateAward:
					case r.z.CreateScheduledPost:
					case r.z.CreateRemovalReason:
					case r.z.CommunityStyling:
					case r.z.CommunityWidgets:
					case r.z.CreateRule:
					case r.z.DeleteAward:
					case r.z.DeleteRule:
					case r.z.DeleteScheduledPost:
					case r.z.DeleteOverriddenClassification:
					case r.z.DeleteRemovalReason:
					case r.z.DisableAward:
					case r.z.EditPostRequirements:
					case r.z.EditRule:
					case r.z.EditScheduledPost:
					case r.z.EditSettings:
					case r.z.EnableAward:
					case r.z.Events:
					case r.z.HiddenAward:
					case r.z.InviteModerator:
					case r.z.InviteSubscriber:
					case r.z.ModAwardGiven:
					case r.z.ModmailEnrollment:
					case r.z.OverrideClassification:
					case r.z.RemoveCommunityTopics:
					case r.z.RemoveContributor:
					case r.z.RemoveModerator:
					case r.z.RemoveWikiContributor:
					case r.z.ReorderModerators:
					case r.z.ReorderRules:
					case r.z.SetPermissions:
					case r.z.SnoozeReports:
					case r.z.SubmitContentRatingSurvey:
					case r.z.SubmitScheduledPost:
					case r.z.UnignoreReports:
					case r.z.UninviteModerator:
					default:
						return s.fbt._("Last mod action", null, {
							hk: "S9AMb"
						})
				}
			}
		},
		"./src/reddit/components/ModQueueList/EmptyQueueBanner.m.less": function(e, t, n) {
			e.exports = {
				Container: "_3gono-WZrSL-d6xVXvjtMy",
				container: "_3gono-WZrSL-d6xVXvjtMy",
				Image: "cSzjL6IStvPqHPZ7Y7ly8",
				image: "cSzjL6IStvPqHPZ7Y7ly8",
				Title: "_15y0pZYrlSHF1PcfsddZ-q",
				title: "_15y0pZYrlSHF1PcfsddZ-q",
				Text: "_2jaFduo9u1gW746Eq2bUKo",
				text: "_2jaFduo9u1gW746Eq2bUKo"
			}
		},
		"./src/reddit/components/ModQueueList/LayoutNavigation.m.less": function(e, t, n) {
			e.exports = {
				Inline: "_3JHX3et1k6IdasjG0oW12P",
				inline: "_3JHX3et1k6IdasjG0oW12P",
				Filter: "_1OcIyF84egvn4Y6482t8jQ",
				filter: "_1OcIyF84egvn4Y6482t8jQ",
				LayoutSwitch: "_31lr1WpF-1P7ga7WE4KVS7",
				layoutSwitch: "_31lr1WpF-1P7ga7WE4KVS7",
				tooltip: "_33DykaAi84n_tY35kQoQEp"
			}
		},
		"./src/reddit/components/ModQueueList/LayoutNavigation.tsx": function(e, t, n) {
			"use strict";
			var s, r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/higherOrderComponents/asTooltip.tsx"),
				l = n("./src/lib/classNames/index.ts"),
				u = n("./src/lib/lessComponent.tsx"),
				m = n("./src/reddit/actions/modQueue/index.ts"),
				p = n("./src/reddit/actions/tooltip.ts"),
				b = n("./src/reddit/components/ContentTooltip/index.tsx"),
				f = n("./src/reddit/components/GeneralCleanup/SortViewBar/LayoutSwitch/index.tsx"),
				h = n("./src/reddit/components/TrackingHelper/index.tsx"),
				g = n("./src/reddit/controls/Dropdown/index.tsx"),
				v = n("./src/reddit/helpers/localStorage/index.ts"),
				x = n("./src/reddit/helpers/trackers/modTools.ts"),
				E = n("./src/reddit/icons/fonts/index.tsx"),
				O = n("./src/reddit/layout/row/Inline/index.tsx"),
				C = n("./src/reddit/selectors/profile.ts"),
				A = n("./src/reddit/selectors/subreddit.ts"),
				y = n("./src/reddit/selectors/tooltip.ts"),
				j = n("./src/reddit/components/ModQueueList/PostSortDropdown.tsx"),
				I = n("./src/lib/addQueryParams/index.ts"),
				k = n("./src/lib/filterQueryParams/index.ts"),
				_ = n("./src/reddit/controls/Dropdown/Row.tsx"),
				S = n("./src/reddit/controls/InternalLink/index.tsx"),
				w = n("./src/reddit/selectors/meta.ts"),
				T = n("./src/reddit/components/ModQueueList/PostTypeFilterDropdown.m.less"),
				P = n.n(T);
			! function(e) {
				e.Comments = "comments", e.Posts = "links", e.ChatPosts = "chat_comments"
			}(s || (s = {}));
			const N = u.a.wrapped(_.b, "Row", P.a),
				D = Object(d.c)({
					currentPage: e => e.platform.currentPage,
					origin: w.l
				});
			var M = Object(a.b)(D)(e => i.a.createElement("div", null, i.a.createElement(S.default, {
					onClick: e.sendEventWithName("content_type_both"),
					to: Object(k.a)(`${e.origin}${e.currentPage.url}`, ["after", "before", "only", "page"])
				}, i.a.createElement(N, {
					displayText: r.fbt._("Posts and Comments", null, {
						hk: "1ypCik"
					}),
					isSelected: !e.postTypeFilter
				})), i.a.createElement(S.default, {
					onClick: e.sendEventWithName("content_type_post"),
					to: Object(I.a)(Object(k.a)(`${e.origin}${e.currentPage.url}`, ["after", "before", "page"]), {
						only: s.Posts
					})
				}, i.a.createElement(N, {
					displayText: r.fbt._("Posts", null, {
						hk: "r23OU"
					}),
					isSelected: e.postTypeFilter === s.Posts
				})), i.a.createElement(S.default, {
					onClick: e.sendEventWithName("content_type_comment"),
					to: Object(I.a)(Object(k.a)(`${e.origin}${e.currentPage.url}`, ["after", "before", "page"]), {
						only: s.Comments
					})
				}, i.a.createElement(N, {
					displayText: r.fbt._("Comments", null, {
						hk: "2RdvZM"
					}),
					isSelected: e.postTypeFilter === s.Comments
				})), i.a.createElement(S.default, {
					onClick: e.sendEventWithName("content_type_live_post"),
					to: Object(I.a)(Object(k.a)(`${e.origin}${e.currentPage.url}`, ["after", "before", "page"]), {
						only: s.ChatPosts
					})
				}, i.a.createElement(N, {
					displayText: r.fbt._("Live Chat Messages", null, {
						hk: "26ZmtR"
					}),
					isSelected: e.postTypeFilter === s.ChatPosts
				})))),
				R = n("./src/reddit/hooks/useLocalStorage.ts"),
				L = n("./src/reddit/hooks/useMounted.ts"),
				B = n("./src/reddit/constants/experiments.ts"),
				F = n("./src/reddit/helpers/chooseVariant/index.ts"),
				U = n("./src/reddit/selectors/user.ts");
			const H = e => Object(F.c)(e, {
				experimentEligibilitySelector: U.S,
				experimentName: B.gc
			}) === B.Yd;
			var G = n("./src/reddit/components/ModQueueList/SortByNumReportsTooltip.m.less"),
				Q = n.n(G);
			const q = e => {
				let {
					children: t
				} = e;
				const [n, s] = Object(R.a)("sort_num_reports_seen_count", 0), d = Object(a.e)(H), c = Object(L.a)(), l = !d || !c || n > 3;
				Object(o.useEffect)(() => {
					l || s(n + 1)
				}, [l]);
				return l ? t : i.a.createElement("div", {
					className: Q.a.wrapper,
					onClick: () => {
						s(4)
					}
				}, i.a.createElement("span", {
					className: Q.a.tooltip
				}, r.fbt._("NEW! More sort options added", null, {
					hk: "5y9ye"
				})), t)
			};
			var W = n("./src/reddit/contexts/PageLayer/index.tsx"),
				z = n("./src/reddit/controls/SearchBar/index.tsx"),
				V = n("./src/reddit/helpers/trackers/modListing.ts"),
				K = n("./src/reddit/selectors/moderatorPermissions.ts"),
				Y = n("./src/reddit/components/ModQueueList/SubredditSelectorDropdown.m.less"),
				J = n.n(Y);
			const X = Object(W.v)({
					currentPageUrl: W.f
				}),
				Z = Object(d.c)({
					moderatingSubreddits: K.o,
					origin: w.l
				}),
				$ = Object(a.b)(Z),
				ee = u.a.div("DropdownContainer", J.a),
				te = u.a.div("SearchBarContainer", J.a),
				ne = u.a.wrapped(_.b, "Row", J.a),
				se = e => "user" === e.type ? {
					profile: e.name
				} : {
					subreddit: e.name
				};
			class re extends i.a.Component {
				constructor(e) {
					super(e), this.onClickRow = e => this.props.sendEvent(Object(V.b)(!1, e, !1)), this.state = {
						search: ""
					}, this.updateSortedSubreddits(e), this.updateFilteredSubreddits(e, this.state)
				}
				UNSAFE_componentWillUpdate(e, t) {
					e.moderatingSubreddits !== this.props.moderatingSubreddits ? (this.updateSortedSubreddits(e), this.updateFilteredSubreddits(e, t)) : t.search !== this.state.search && this.updateFilteredSubreddits(e, t)
				}
				updateSortedSubreddits(e) {
					this.sortedSubreddits = e.moderatingSubreddits.slice().sort((e, t) => e.displayText.toLowerCase() > t.displayText.toLowerCase() ? 1 : -1)
				}
				updateFilteredSubreddits(e, t) {
					if (!t.search) return void(this.filteredSubreddits = this.sortedSubreddits);
					const n = t.search.toLowerCase();
					let s;
					s = e.moderatingSubreddits !== this.props.moderatingSubreddits || 0 !== n.indexOf(this.state.search) ? this.sortedSubreddits : this.filteredSubreddits, this.filteredSubreddits = s.filter(e => -1 !== e.displayText.toLowerCase().indexOf(n))
				}
				stopPropagation(e) {
					e.nativeEvent.stopImmediatePropagation()
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return i.a.createElement(ee, {
						onClickCapture: this.stopPropagation
					}, i.a.createElement(te, null, i.a.createElement(z.a, {
						autoFocus: !0,
						onTextChange: e => this.setState({
							search: e.currentTarget.value
						}),
						placeholder: r.fbt._("Find subreddit", null, {
							hk: "1o7zy2"
						}),
						value: t.search
					})), i.a.createElement(S.default, {
						to: Object(k.a)(`${e.origin}${e.currentPageUrl}`, ["after", "before", "page", "profile", "subreddit"])
					}, i.a.createElement(ne, {
						displayText: r.fbt._("All subreddits", null, {
							hk: "45nVG6"
						}),
						isSelected: !e.subredditName && !e.profileName
					})), this.filteredSubreddits.map(t => {
						const n = se(t);
						return i.a.createElement(S.default, {
							key: t.id,
							to: Object(I.a)(Object(k.a)(`${e.origin}${e.currentPageUrl}`, ["after", "before", "page", "profile", "subreddit"]), n),
							onClick: () => this.onClickRow(t.name)
						}, i.a.createElement(ne, {
							displayText: t.displayText,
							isSelected: e.subredditName ? e.subredditName === t.name : e.profileName === t.name
						}))
					}))
				}
			}
			var oe = X($(Object(h.c)(re))),
				ie = n("./src/reddit/components/ModQueueList/LayoutNavigation.m.less"),
				ae = n.n(ie);
			const de = Object(c.a)(g.a),
				ce = "MODQ--SUBREDDIT_FILTER_DROPDOWN",
				le = "MODQ--POST_TYPE_FILTER_DROPDOWN",
				ue = "MODQ--POST_SORT_DROPDOWN",
				me = u.a.wrapped(O.a, "Inline", ae.a),
				pe = u.a.div("Filter", ae.a),
				be = u.a.wrapped(f.a, "LayoutSwitch", ae.a),
				fe = e => {
					switch (e) {
						case "allPostTypes":
							return r.fbt._("Posts and Comments", null, {
								hk: "2BGBVi"
							});
						case "allSubreddits":
							return r.fbt._("All subreddits", null, {
								hk: "3GnUZA"
							});
						case "comments":
							return r.fbt._("Comments", null, {
								hk: "3PSW3P"
							});
						case "links":
							return r.fbt._("Posts", null, {
								hk: "1nfhQO"
							});
						case "searchPlaceholder":
							return r.fbt._("Find subreddit", null, {
								hk: "2rRq64"
							});
						case "chat_comments":
							return r.fbt._("Live Chat Messages", null, {
								hk: "4iL79y"
							})
					}
				},
				he = e => {
					switch (e) {
						case "oldest":
							return r.fbt._("Oldest First", null, {
								hk: "1JMyTy"
							});
						case "most_reported":
							return r.fbt._("Most Reported First", null, {
								hk: "mANyW"
							});
						default:
							return r.fbt._("Newest First", null, {
								hk: "iP4pS"
							})
					}
				},
				ge = "mod-insights-tooltip-id",
				ve = Object(d.c)({
					isPostTypeFilterDropdownOpen: Object(y.b)(le),
					isSubredditFilterDropdownOpen: Object(y.b)(ce),
					isPostSortDropdownOpen: Object(y.b)(ue),
					profile: (e, t) => {
						let {
							profileName: n
						} = t;
						return n ? Object(C.k)(e, {
							profileName: n
						}) : null
					},
					subreddit: (e, t) => {
						let {
							subredditName: n
						} = t;
						return n ? Object(A.C)(e, {
							subredditName: n
						}) : null
					}
				}),
				xe = Object(a.b)(ve, e => ({
					loadAllSubreddits: () => e(Object(m.d)(!0)),
					onOpenDropdown: t => e(Object(p.h)({
						tooltipId: t
					})),
					sendLivePostFilterDisplayedEvent: () => e(x.i),
					openModInsightsTooltip: () => {
						e(Object(p.f)({
							tooltipId: ge
						}))
					}
				}));
			class Ee extends i.a.Component {
				constructor() {
					super(...arguments), this.onOpenSubredditFilterDropdown = () => {
						this.props.loadAllSubreddits(), this.props.onOpenDropdown(ce), this.props.sendEventWithName("subreddit")
					}, this.onOpenPostTypeFilterDropdown = () => {
						this.props.onOpenDropdown(le), this.props.sendEventWithName("content_type")(), this.props.isPostTypeFilterDropdownOpen || this.props.sendEvent(Object(x.i)())
					}, this.onOpenPostSortDropdown = () => {
						this.props.onOpenDropdown(ue), this.props.sendEventWithName("modqueue_sort")()
					}, this.onShowTooltip = () => {
						Object(v.K)() || (this.props.openModInsightsTooltip(), Object(v.Nb)())
					}
				}
				componentDidMount() {
					this.onShowTooltip()
				}
				render() {
					const {
						props: e
					} = this, t = e.subreddit && e.subreddit.displayText || e.profile && e.profile.displayText || r.fbt._("All subreddits", null, {
						hk: "3GnUZA"
					}), n = e.postTypeFilter && fe(e.postTypeFilter) || r.fbt._("Posts and Comments", null, {
						hk: "2BGBVi"
					}), s = he(null == e ? void 0 : e.postSort);
					return i.a.createElement(me, null, !e.hideSubredditFilter && i.a.createElement("div", {
						id: ge
					}, i.a.createElement(pe, {
						id: ce,
						onClick: this.onOpenSubredditFilterDropdown
					}, t, i.a.createElement(E.a, {
						name: "caret_down"
					})), i.a.createElement(de, {
						isOpen: e.isSubredditFilterDropdownOpen,
						tooltipId: ce
					}, i.a.createElement(oe, {
						profileName: e.profileName,
						subredditName: e.subredditName
					})), e.isInShredditModNavExperiment && i.a.createElement(b.a, {
						className: Object(l.a)(ae.a.tooltip, "tooltip bg-coolgray-350 p-xs text-coolgray-900"),
						defaultTooltipPosition: "bottom",
						tooltipId: ge,
						caretColor: {
							top: "#B8C5C9"
						}
					}, i.a.createElement("div", {
						className: "bg-coolgray-350 text-12 leading-4 rounded-sm font-semibold"
					}, r.fbt._("Select a subreddit to see other insights.", null, {
						hk: "1A3skz"
					})))), i.a.createElement(q, null, i.a.createElement(pe, {
						id: ue,
						onClick: this.onOpenPostSortDropdown
					}, s, i.a.createElement(E.a, {
						name: "caret_down"
					})), i.a.createElement(de, {
						isOpen: e.isPostSortDropdownOpen,
						tooltipId: ue
					}, i.a.createElement(j.b, {
						postSort: e.postSort,
						sendEventWithName: e.sendEventWithName
					}))), e.showTypeFilter && i.a.createElement(i.a.Fragment, null, i.a.createElement(pe, {
						id: le,
						onClick: this.onOpenPostTypeFilterDropdown
					}, n, i.a.createElement(E.a, {
						name: "caret_down"
					})), i.a.createElement(de, {
						isOpen: e.isPostTypeFilterDropdownOpen,
						tooltipId: le
					}, i.a.createElement(M, {
						postTypeFilter: e.postTypeFilter,
						sendEventWithName: e.sendEventWithName
					}))), i.a.createElement(be, null))
				}
			}
			t.a = xe(Object(h.c)(Ee))
		},
		"./src/reddit/components/ModQueueList/ModToolsBulkOperations/ExtraModToolsList.m.less": function(e, t, n) {
			e.exports = {
				StatusItem: "_2K7YZXKFsZRhsQQ4AbJmxU",
				statusItem: "_2K7YZXKFsZRhsQQ4AbJmxU",
				StatusContainer: "_2iPB1Z8ZMY-jLMenh1R4K4",
				statusContainer: "_2iPB1Z8ZMY-jLMenh1R4K4",
				StatusList: "B7xBQCW-i0XkgeJ22rgLC",
				statusList: "B7xBQCW-i0XkgeJ22rgLC"
			}
		},
		"./src/reddit/components/ModQueueList/ModToolsBulkOperations/index.m.less": function(e, t, n) {
			e.exports = {
				CheckboxContainer: "DsVp-bHpfq0Oq0qA6pTak",
				checkboxContainer: "DsVp-bHpfq0Oq0qA6pTak",
				Checkbox: "_3IYLDjbdCg9uE2oDb5e7Sn",
				checkbox: "_3IYLDjbdCg9uE2oDb5e7Sn",
				DropdownRow: "_5USHbSyhRaiAEnOouxEk9",
				dropdownRow: "_5USHbSyhRaiAEnOouxEk9",
				DropdownTriangle: "_3ePiZ_UzH5lFQIPzp35YXS",
				dropdownTriangle: "_3ePiZ_UzH5lFQIPzp35YXS",
				Button: "abvVqLDYtaKz3przU1pme",
				button: "abvVqLDYtaKz3przU1pme",
				Bullet: "K9CBgM-Xyd_FBz7TcYHah",
				bullet: "K9CBgM-Xyd_FBz7TcYHah",
				Text: "_14Wi7Tj4JyvXkmtsyZkG9e",
				text: "_14Wi7Tj4JyvXkmtsyZkG9e",
				left: "_1IovB6jH5oyEgCXjUwXpJs",
				right: "_1aKgaRqDhtICtELEl5XEw3",
				ModToolsBulkOperations: "IncH4Lk7NsVjvrE51jpu8",
				modToolsBulkOperations: "IncH4Lk7NsVjvrE51jpu8"
			}
		},
		"./src/reddit/components/ModQueueList/PostTypeFilterDropdown.m.less": function(e, t, n) {
			e.exports = {
				Row: "_1i-lQzTwq8UQrdKuiR_jer",
				row: "_1i-lQzTwq8UQrdKuiR_jer"
			}
		},
		"./src/reddit/components/ModQueueList/SortByNumReportsTooltip.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "FWSg-pojW6Y4suOH94gHp",
				tooltip: "_2CgvwZaR7MuuZGWt19TMWD"
			}
		},
		"./src/reddit/components/ModQueueList/SubredditSelectorDropdown.m.less": function(e, t, n) {
			e.exports = {
				DropdownContainer: "CxFih1Dllyb7Ee-gA27SM",
				dropdownContainer: "CxFih1Dllyb7Ee-gA27SM",
				SearchBarContainer: "_3TBm4aNfLDgkYxeb3BL6Qu",
				searchBarContainer: "_3TBm4aNfLDgkYxeb3BL6Qu",
				Row: "_2-Mqfq2jQLCLoIJJX5d6ER",
				row: "_2-Mqfq2jQLCLoIJJX5d6ER"
			}
		},
		"./src/reddit/components/ModQueueList/index.m.less": function(e, t, n) {
			e.exports = {
				ItemContainer: "_2QxKXxKsAXysE1p_Y7m66a",
				itemContainer: "_2QxKXxKsAXysE1p_Y7m66a",
				ButtonContainer: "_1UWG2tG2gGruVUIlnO6Qwr",
				buttonContainer: "_1UWG2tG2gGruVUIlnO6Qwr",
				isInShredditNavExperiment: "_1sDF-LJC_IbIYQbg2mRjP8",
				commentOutline: "_2Xm9FsakKZY7Tl9gVSiSif",
				bulkOptionsOutline: "haB3XltxjV5QEwIKgYrsr"
			}
		},
		"./src/reddit/components/ModQueueList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/difference.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/includes.js"),
				i = n.n(o),
				a = n("./node_modules/react/index.js"),
				d = n.n(a),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/addQueryParams/index.ts"),
				m = n("./src/lib/classNames/index.ts"),
				p = n("./src/lib/lessComponent.tsx"),
				b = n("./src/reddit/actions/modQueue/index.ts"),
				f = n("./src/reddit/actions/post.ts"),
				h = n("./src/reddit/components/ModModeReports/helpers.ts"),
				g = n("./node_modules/fbt/lib/FbtPublic.js"),
				v = n("./src/reddit/controls/Button/index.tsx"),
				x = n("./src/reddit/layout/row/Inline/index.tsx"),
				E = n("./src/reddit/components/PaginationButtons/index.m.less"),
				O = n.n(E);
			var C = e => d.a.createElement(x.a, {
					className: O.a.buttonContainer
				}, d.a.createElement(v.s, {
					className: Object(m.a)(O.a.routerLink, {
						[O.a.mDisabled]: !e.prevButtonEnabled
					}),
					disabled: !e.prevButtonEnabled,
					to: e.prevTo,
					"data-redditstyle": !0
				}, g.fbt._("Back", null, {
					hk: "2pUhBQ"
				})), d.a.createElement(v.s, {
					className: Object(m.a)(O.a.routerLink, {
						[O.a.mDisabled]: !e.nextButtonEnabled
					}),
					disabled: !e.nextButtonEnabled,
					to: e.nextTo,
					"data-redditstyle": !0
				}, g.fbt._("Next", null, {
					hk: "2mEXAi"
				}))),
				A = n("./src/reddit/components/PostList/index.tsx"),
				y = n("./src/reddit/constants/componentSizes.ts"),
				j = n("./src/reddit/contexts/PageLayer/index.tsx"),
				I = n("./src/reddit/helpers/isComment.ts"),
				k = n("./src/reddit/helpers/isPost.ts"),
				_ = n("./src/reddit/helpers/postComponentForLayout/index.tsx"),
				S = n("./src/lib/logs/console.ts"),
				w = n("./src/lib/objectSelector/index.ts"),
				T = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.tsx"),
				P = n("./src/reddit/components/Comments/UnthreadedComment/index.tsx"),
				N = n("./src/reddit/components/Comments/UnthreadedCommentContainer/index.tsx"),
				D = n("./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.tsx"),
				M = n("./src/reddit/components/Comments/UnthreadedCommentMeta/index.tsx"),
				R = n("./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.tsx"),
				L = n("./src/reddit/components/ModModeFilteredReason/index.tsx"),
				B = n("./src/reddit/components/ModModeFilteredReason/helpers.ts"),
				F = n("./src/reddit/components/ModModeReports/index.tsx"),
				U = n("./src/reddit/components/RichTextJson/index.tsx"),
				H = n("./src/reddit/components/VerticalVotes/index.tsx"),
				G = n("./src/reddit/controls/Checkbox/index.tsx"),
				Q = n("./src/reddit/helpers/getRichTextContent/index.ts"),
				q = n("./src/reddit/helpers/showReportIndicator/index.ts"),
				W = n("./src/reddit/components/Comments/CompactUnthreadedComment/index.m.less"),
				z = n.n(W);
			const V = p.a.div("LeftRail", z.a),
				K = p.a.wrapped(G.a, "BulkActionCheckbox", z.a),
				Y = p.a.div("CommentColumn", z.a),
				J = p.a.div("VoteColumn", z.a),
				X = p.a.wrapped(T.a, "ModToolsFlatlist", z.a),
				Z = p.a.wrapped(H.a, "Votes", z.a),
				$ = p.a.div("CommentContentWrapper", z.a),
				ee = p.a.div("ParentPostTitle", z.a),
				te = p.a.div("CommentParentWrapper", z.a),
				ne = Object(w.b)(e => ({
					renderingObjectInfo: e.comment
				}));
			var se = Object(P.b)(e => {
					const {
						className: t,
						comment: n,
						commentPermalink: s,
						flair: r,
						isCheckboxSelected: o = !1,
						onIgnoreReports: i,
						onVoteClick: a,
						showModTools: c,
						subreddit: l,
						showBulkActionCheckbox: u,
						toggleCheckbox: p
					} = e, b = Object(B.a)(n), f = Object(h.c)(n);
					return d.a.createElement(N.a, {
						className: Object(m.a)(t, z.a.Component, z.a.UnthreadedCommentContainer, "UnthreadedComment", {
							[z.a.isBanned]: !!n.bannedBy,
							[z.a.isReported]: Object(q.a)(n)
						}),
						clickTrackingId: n.id,
						permalink: s
					}, d.a.createElement(V, {
						className: Object(m.a)({
							[z.a.hasBorder]: !!n.bannedBy || Object(q.a)(n)
						})
					}, u && d.a.createElement(K, {
						isCheckboxSelected: o,
						toggleCheckbox: p
					})), d.a.createElement(J, null, d.a.createElement(Z, {
						compact: !1,
						model: n,
						onVoteClick: a,
						scoreClassName: z.a.score
					})), d.a.createElement(Y, null, d.a.createElement(te, null, n.postTitle && d.a.createElement(ee, null, n.postTitle), n.postAuthor && d.a.createElement(R.a, {
						comment: n
					})), d.a.createElement($, null, d.a.createElement(D.a, {
						comment: n
					}, d.a.createElement(U.b, {
						content: Object(Q.a)(n),
						mediaMetadata: n.media && n.media.mediaMetadata,
						rtJsonElementProps: ne(e),
						mediaProps: {
							alignLeft: !0,
							renderSmallMedia: !0
						}
					}), d.a.createElement(M.a, {
						comment: n,
						flair: r,
						subredditName: l ? l.displayText : null
					}), b && d.a.createElement(L.a, {
						thing: n
					}), f && d.a.createElement(F.a, {
						onIgnoreReports: i,
						reportable: n
					}), c && !n.isDeleted && d.a.createElement(X, {
						comment: n
					})))))
				}),
				re = n("./src/reddit/components/ModQueueActionBar/index.tsx"),
				oe = n("./src/reddit/components/PostRailAndVotes/index.tsx"),
				ie = n("./src/reddit/components/Comments/LargeUnthreadedComment/index.m.less"),
				ae = n.n(ie);
			const de = p.a.div("VoteSpacer", ae.a),
				ce = p.a.div("ContentWrapper", ae.a),
				le = p.a.wrapped(M.a, "Meta", ae.a),
				ue = p.a.div("CommentParentWrapper", ae.a),
				me = p.a.div("CommentContentWrapper", ae.a),
				pe = Object(w.b)(e => ({
					renderingObjectInfo: e.comment
				}));
			var be = Object(P.b)(p.a.wrapped(e => {
					const {
						className: t,
						comment: n,
						commentPermalink: s,
						flair: r,
						hasReports: o,
						isCheckboxSelected: i = !1,
						onIgnoreReports: a,
						onVoteClick: c,
						showModTools: l,
						subreddit: u,
						showBulkActionCheckbox: p,
						toggleCheckbox: b,
						isModQueueDisplayEnabled: f,
						showRealtimeUpdateAnimation: h,
						isUpdatedContent: g,
						isNightMode: v
					} = e, x = Object(B.a)(n);
					return d.a.createElement(N.a, {
						className: Object(m.a)(t, "UnthreadedComment", {
							[ae.a.realtimeAnimation]: h,
							[ae.a.realtimeUpdated]: g,
							[ae.a.isNightMode]: v
						}),
						clickTrackingId: n.id,
						permalink: s
					}, d.a.createElement(oe.a, {
						model: n,
						handleVote: c,
						showBulkActionCheckbox: p,
						isCheckboxSelected: i,
						toggleCheckbox: b
					}), d.a.createElement(de, null, d.a.createElement(ce, null, d.a.createElement(ue, null, n.postAuthor && !f && d.a.createElement(R.a, {
						comment: n,
						subredditOrProfile: u
					}), f && d.a.createElement(le, {
						comment: n,
						flair: r,
						subredditOrProfile: u
					}), n.postTitle && d.a.createElement(P.a, null, n.postTitle)), d.a.createElement(D.a, {
						comment: n
					}, d.a.createElement(me, null, d.a.createElement(U.b, {
						content: Object(Q.a)(n),
						mediaMetadata: n.media && n.media.mediaMetadata,
						rtJsonElementProps: pe(e),
						mediaProps: {
							alignLeft: !0,
							renderSmallMedia: !0
						}
					})), x && !f && d.a.createElement(L.a, {
						thing: n
					}), o && !f && d.a.createElement(F.a, {
						onIgnoreReports: a,
						reportable: n
					}), !f && d.a.createElement(le, {
						comment: n,
						flair: r
					}))), l && !n.isDeleted && (f ? d.a.createElement(re.a, {
						content: n
					}) : d.a.createElement(T.a, {
						comment: n
					}))))
				}, "Component", ae.a)),
				fe = n("./src/reddit/constants/postLayout.ts");
			const he = {
					[fe.g.Large]: be,
					[fe.g.Medium]: P.c,
					[fe.g.Classic]: P.c,
					[fe.g.Compact]: se
				},
				ge = e => null;
			var ve = n("./src/reddit/models/Flair/index.ts"),
				xe = n("./src/reddit/models/Media/index.ts"),
				Ee = n("./src/reddit/models/ModQueue/index.ts"),
				Oe = n("./src/reddit/selectors/meta.ts"),
				Ce = n("./src/reddit/selectors/modQueue.ts"),
				Ae = n("./src/reddit/selectors/subreddit.ts"),
				ye = n("./src/config.ts"),
				je = n("./src/reddit/components/ModQueueList/EmptyQueueBanner.m.less"),
				Ie = n.n(je);
			const {
				fbt: ke
			} = n("./node_modules/fbt/lib/FbtPublic.js"), _e = `${ye.a.assetPath}/img/snoomoji/cat_blep.png`, Se = p.a.div("Container", Ie.a), we = p.a.div("Image", Ie.a), Te = p.a.div("Title", Ie.a), Pe = p.a.div("Text", Ie.a);
			var Ne = () => d.a.createElement(Se, null, d.a.createElement(we, {
					style: {
						backgroundImage: `url(${_e})`
					}
				}), d.a.createElement(Te, null, ke._("The queue is clean!", null, {
					hk: "3d14fC"
				})), d.a.createElement(Pe, null, ke._("Kitteh is pleased", null, {
					hk: "3NSHqg"
				}))),
				De = n("./src/reddit/components/PostList/Placeholder.tsx");
			const Me = Object(j.v)(),
				Re = Object(l.c)({
					layout: j.U
				});
			var Le = Me(Object(c.b)(Re)(e => d.a.createElement(De.a, {
					isLoading: !0,
					layout: e.layout
				}))),
				Be = n("./node_modules/lodash/flatten.js"),
				Fe = n.n(Be),
				Ue = n("./src/reddit/actions/tooltip.ts"),
				He = n("./src/reddit/icons/fonts/index.tsx"),
				Ge = n("./src/reddit/icons/fonts/Approve/index.tsx"),
				Qe = n("./src/reddit/icons/fonts/Remove/index.tsx"),
				qe = n("./src/reddit/icons/fonts/Spam/index.tsx"),
				We = n("./src/reddit/icons/fonts/Tag/index.tsx"),
				ze = n("./src/higherOrderComponents/asTooltip.tsx"),
				Ve = n("./src/reddit/actions/modal.ts"),
				Ke = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				Ye = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				Je = n("./src/reddit/controls/Dropdown/index.tsx"),
				Xe = n("./src/reddit/controls/Dropdown/Row.tsx"),
				Ze = n("./src/reddit/helpers/flair.ts"),
				$e = n("./src/reddit/selectors/activeModalId.ts"),
				et = n("./src/reddit/selectors/moderatorPermissions.ts"),
				tt = n("./src/reddit/selectors/postFlair.ts"),
				nt = n("./src/reddit/selectors/posts.ts"),
				st = n("./src/reddit/selectors/tooltip.ts"),
				rt = n("./src/reddit/components/TrackingHelper/index.tsx"),
				ot = n("./src/reddit/components/ModQueueList/ModToolsBulkOperations/ExtraModToolsList.m.less"),
				it = n.n(ot);
			const at = e => d.a.createElement("button", {
					className: Object(m.a)(it.a.StatusItem, e.className),
					disabled: e.isDisabled,
					onClick: e.onClick,
					title: e.isDisabled ? g.fbt._("You can't take that action on a comment", null, {
						hk: "26RFsw"
					}) : void 0
				}, e.buttonText),
				dt = Object(l.c)({
					selectedItems: Ce.i
				}),
				ct = Object(c.b)(dt, e => ({
					onIgnoreReports: () => e(Object(b.f)(Ee.a.IgnoreReports)),
					onLock: () => e(Object(b.f)(Ee.a.Lock)),
					onMarkNSFW: () => e(Object(b.f)(Ee.a.MarkNSFW)),
					onSpoiler: () => e(Object(b.f)(Ee.a.Spoiler)),
					onUnignoreReports: () => e(Object(b.f)(Ee.a.UnignoreReports)),
					onUnlock: () => e(Object(b.f)(Ee.a.Unlock)),
					onUnmarkNSFW: () => e(Object(b.f)(Ee.a.UnmarkNSFW)),
					onUnspoiler: () => e(Object(b.f)(Ee.a.Unspoiler))
				})),
				lt = e => e.some(e => Object(I.a)(e));
			var ut = Object(ze.a)(ct(Object(rt.c)(e => d.a.createElement("div", {
				className: Object(m.a)(it.a.StatusList, e.className),
				style: e.style
			}, d.a.createElement("div", {
				className: it.a.StatusContainer
			}, d.a.createElement(at, {
				onClick: e.onIgnoreReports,
				buttonText: g.fbt._("Ignore Reports", null, {
					hk: "1hZ3hN"
				})
			}), d.a.createElement(at, {
				onClick: e.onUnignoreReports,
				buttonText: g.fbt._("Unignore Reports", null, {
					hk: "3y089p"
				})
			}), d.a.createElement(at, {
				isDisabled: lt(e.selectedItems),
				onClick: e.onLock,
				buttonText: g.fbt._("Lock", null, {
					hk: "4bc0vl"
				})
			}), d.a.createElement(at, {
				isDisabled: lt(e.selectedItems),
				onClick: e.onUnlock,
				buttonText: g.fbt._("Unlock", null, {
					hk: "Pe2ML"
				})
			}), d.a.createElement(at, {
				isDisabled: lt(e.selectedItems),
				onClick: e.onSpoiler,
				buttonText: g.fbt._("Mark as Spoiler", null, {
					hk: "4pIu4V"
				})
			}), d.a.createElement(at, {
				isDisabled: lt(e.selectedItems),
				onClick: e.onUnspoiler,
				buttonText: g.fbt._("Unmark as Spoiler", null, {
					hk: "1ImDYd"
				})
			}), d.a.createElement(at, {
				isDisabled: lt(e.selectedItems),
				onClick: e.onMarkNSFW,
				buttonText: g.fbt._("Mark as NSFW", null, {
					hk: "4yS4Hz"
				})
			}), d.a.createElement(at, {
				isDisabled: lt(e.selectedItems),
				onClick: e.onUnmarkNSFW,
				buttonText: g.fbt._("Unmark as NSFW", null, {
					hk: "ZzA74"
				})
			}))))));
			const mt = Object(l.c)({
				isDropdownOpen: (e, t) => {
					let {
						tooltipId: n
					} = t;
					return Object(st.b)(n)(e)
				}
			});
			var pt = Object(c.b)(mt)(Object(rt.c)(e => {
					const {
						className: t,
						isDropdownOpen: n,
						tooltipId: s
					} = e;
					return d.a.createElement("div", {
						id: s,
						className: t
					}, d.a.createElement(ut, {
						isOpen: n,
						tooltipId: s
					}))
				})),
				bt = n("./src/reddit/components/ModQueueList/ModToolsBulkOperations/index.m.less"),
				ft = n.n(bt);
			const ht = "BulkAction--BulkItemFilter",
				gt = "BulkActions--PostFlair--Modal",
				vt = Object(ze.a)(Je.a),
				xt = e => d.a.createElement(Xe.b, {
					className: Object(m.a)(ft.a.DropdownRow, e.className),
					displayText: e.displayText,
					onClick: e.onClick
				}),
				Et = Object(l.c)({
					activeModalId: $e.a,
					dropdownIsOpen: Object(st.b)(ht),
					flairData: tt.d,
					isApiPending: Ce.a,
					moderatorPermissions: et.n,
					posts: nt.I,
					selectedItems: Ce.i
				}),
				Ot = Object(c.b)(Et, e => ({
					onApprove: () => e(Object(b.f)(Ee.a.Approve)),
					onFlair: (t, n) => e(Object(b.f)(Ee.a.Flair, t, n)),
					onOpenDropdown: () => e(Object(Ue.h)({
						tooltipId: ht
					})),
					onOpenModToolsDropdown: () => e(Object(Ue.h)({
						tooltipId: "BulkActions--ModTools"
					})),
					onRemove: () => e(Object(b.f)(Ee.a.Remove)),
					onSpam: () => e(Object(b.f)(Ee.a.Spam)),
					onToggleFlairModal: () => e(Object(Ve.i)(gt))
				})),
				Ct = (e, t) => {
					const n = Fe()(e.map(e => t[e].flair));
					if (n.length <= 1) return n;
					const s = [];
					return n.forEach(e => {
						if (e.type === ve.f.Text || e.type === ve.f.Richtext) {
							const t = Object(Ze.g)(e);
							i()(s, t) || s.push(t)
						}
					}), s.length > 1 ? [{
						type: ve.f.Text,
						text: g.fbt._("Multiple Flairs", null, {
							hk: "2WHsvc"
						})
					}] : n
				};
			var At = Ot(e => {
					const {
						activeModalId: t,
						className: n,
						endNumItems: s,
						flairData: r,
						isAnyItemSelected: o,
						isApiPending: i,
						moderatorPermissions: c,
						numSelected: l,
						numShowing: u,
						onApprove: p,
						onFlair: b,
						onRemove: f,
						onSpam: h,
						onToggleFlairModal: v,
						posts: x,
						selectedItems: E,
						startNumItems: O,
						subredditId: C,
						toggleSelectAll: A,
						toggleSelectByFilter: y
					} = e, j = [{
						name: g.fbt._("Spam filtered", null, {
							hk: "S0DJ9"
						}),
						filterType: "spamFiltered"
					}, {
						name: g.fbt._("Has reports", null, {
							hk: "1x2hhv"
						}),
						filterType: "hasReports"
					}, {
						name: g.fbt._("Self posts", null, {
							hk: "KFHYI"
						}),
						filterType: "selfPosts"
					}, {
						name: g.fbt._("Posts with flair", null, {
							hk: "18cMZD"
						}),
						filterType: "postsWithFlair"
					}, {
						name: g.fbt._("Posts", null, {
							hk: "gGGKv"
						}),
						filterType: "posts"
					}, {
						name: g.fbt._("Comments", null, {
							hk: "1F1pwI"
						}),
						filterType: "comments"
					}, {
						name: g.fbt._("Chat posts", null, {
							hk: "1uSGtz"
						}),
						filterType: "chat_comments"
					}], I = c && c.flair, k = C && r && r.displaySettings.isEnabled && I && !lt(E);
					return d.a.createElement("div", {
						className: Object(m.a)(ft.a.ModToolsBulkOperations, n)
					}, d.a.createElement("div", {
						className: ft.a.CheckboxContainer,
						id: ht
					}, d.a.createElement(G.a, {
						className: ft.a.Checkbox,
						isHalfCheckboxSelected: e.isAnyItemSelected && !e.isSelectAll,
						isCheckboxSelected: e.isSelectAll,
						toggleCheckbox: A
					}), d.a.createElement(He.a, {
						name: "caret_down",
						onClick: t => {
							t.stopPropagation(), e.onOpenDropdown()
						}
					}), d.a.createElement(vt, {
						isOpen: e.dropdownIsOpen,
						isOverlay: !1,
						tooltipId: ht
					}, j.map(e => d.a.createElement(xt, {
						key: e.filterType,
						displayText: e.name,
						onClick: () => y(e.filterType)
					})))), o && d.a.createElement(a.Fragment, null, d.a.createElement(Ye.c, {
						className: ft.a.Button,
						disabled: i,
						text: g.fbt._("approve", null, {
							hk: "4ib5o9"
						}),
						onClick: p
					}, d.a.createElement(Ge.a, null)), d.a.createElement(Ye.c, {
						className: ft.a.Button,
						disabled: i,
						text: g.fbt._("remove", null, {
							hk: "1ImNcF"
						}),
						onClick: f
					}, d.a.createElement(Qe.a, null)), d.a.createElement(Ye.c, {
						className: ft.a.Button,
						disabled: i,
						text: g.fbt._("spam", null, {
							hk: "36ppaW"
						}),
						onClick: h
					}, d.a.createElement(qe.a, null)), d.a.createElement(Ye.c, {
						className: ft.a.Button,
						disabled: i,
						onClick: e.onOpenModToolsDropdown
					}, d.a.createElement(pt, {
						tooltipId: "BulkActions--ModTools"
					}), d.a.createElement(He.a, {
						name: "list_bulleted"
					})), d.a.createElement("div", null, k && d.a.createElement(Ye.c, {
						disabled: i,
						onClick: v,
						className: ft.a.Button
					}, d.a.createElement(We.a, null)))), o && C && t === gt && d.a.createElement(Ke.a, {
						flairs: Ct(E, x),
						modalId: gt,
						onFlairChanged: e => {
							let {
								previewFlair: t,
								selectedTemplateId: n
							} = e;
							b(t, n)
						},
						subredditId: C
					}), u > 0 && d.a.createElement("div", {
						className: ft.a.Text
					}, d.a.createElement("span", {
						className: ft.a.right
					}, g.fbt._("Items {startNumItems}-{endNumItems}", [g.fbt._param("startNumItems", `${O}`), g.fbt._param("endNumItems", `${s}`)], {
						hk: "1FkOkC"
					})), d.a.createElement("span", {
						className: ft.a.Bullet
					}, ""), d.a.createElement("span", {
						className: ft.a.left
					}, g.fbt._("{numSelected} selected", [g.fbt._param("numSelected", `${l}`)], {
						hk: "4uf9Ow"
					}))))
				}),
				yt = n("./src/reddit/contexts/Post/index.tsx"),
				jt = n("./src/reddit/components/ModQueueList/index.m.less"),
				It = n.n(jt);
			const kt = e => Object(k.a)(e.id),
				_t = p.a.div("ItemContainer", It.a),
				St = p.a.div("ButtonContainer", It.a),
				wt = Object(j.v)({
					currentProfileName: j.j,
					isCommentPermalink: j.x,
					isCommentsPage: j.y,
					isFrontpage: j.B,
					isProfilePostListing: j.N,
					isTopicPage: j.T,
					queryParams: j.Z,
					pageLayer: e => e
				}),
				Tt = Object(l.c)({
					currentPage: e => e.platform.currentPage,
					isModQueueListingPending: Ce.e,
					loadMore: Ce.g,
					modQueueListingItems: Ce.f,
					origin: Oe.l,
					selectedItems: Ce.i,
					subredditId: (e, t) => t.subredditName ? Object(Ae.I)(e, t.subredditName) : null
				}),
				Pt = Object(c.b)(Tt, e => ({
					addSelectedItems: t => e(Object(b.a)({
						ids: t
					})),
					bulkSelectItems: t => e(Object(b.b)({
						ids: t
					})),
					bulkUnselectItems: t => e(Object(b.c)({
						ids: t
					})),
					fireAdPixelsOfType: (t, n) => e(Object(f.y)(t, n)),
					openPost: t => e(Object(f.K)(t))
				})),
				Nt = e => e.page ? parseInt(e.page, 10) : Ee.b,
				Dt = e => Nt(e) + 1,
				Mt = e => Math.max(Ee.b, Nt(e) - 1),
				Rt = e => {
					const t = e.modQueueListingItems ? e.modQueueListingItems.length : 0;
					return Nt(e) === Ee.b ? t : 25 * Mt(e) + t
				},
				Lt = e => Nt(e) === Ee.b ? Ee.b : 25 * Mt(e) + 1;
			var Bt;
			! function(e) {
				e.comments = "comments", e.hasReports = "hasReports", e.posts = "posts", e.postsWithFlair = "postsWithFlair", e.selfPosts = "selfPosts", e.spamFiltered = "spamFiltered"
			}(Bt || (Bt = {}));
			class Ft extends d.a.Component {
				constructor() {
					super(...arguments), this.isCheckboxSelected = e => i()(this.props.selectedItems, e), this.isAllSelected = e => {
						const t = r()(e, this.props.selectedItems);
						return e.length > 0 && this.props.selectedItems.length > 0 && 0 === t.length
					}, this.toggleSelectedItems = (e, t) => {
						e ? this.props.bulkUnselectItems(t) : this.props.addSelectedItems(t)
					}, this.toggleSelectByFilter = e => {
						const t = [];
						if (!this.props.modQueueListingItems || !this.props.modQueueListingItems.length) return t;
						switch (e) {
							case Bt.posts:
								this.props.modQueueListingItems.forEach(e => {
									Object(k.a)(e.id) && t.push(e.id)
								});
								break;
							case Bt.comments:
								this.props.modQueueListingItems.forEach(e => {
									Object(I.a)(e.id) && t.push(e.id)
								});
								break;
							case Bt.hasReports:
								this.props.modQueueListingItems.forEach(e => {
									e.numReports && e.numReports > 0 && t.push(e.id)
								});
								break;
							case Bt.postsWithFlair:
								this.props.modQueueListingItems.forEach(e => {
									if (Object(k.a)(e.id)) {
										const n = e;
										n.flair && n.flair.filter(e => e.type !== ve.f.Spoiler && e.type !== ve.f.Nsfw).length > 0 && t.push(n.id)
									}
								});
								break;
							case Bt.selfPosts:
								this.props.modQueueListingItems.forEach(e => {
									if (Object(k.a)(e.id)) {
										const n = e;
										n.media && n.media.type === xe.o.TEXT && t.push(n.id)
									}
								});
								break;
							case Bt.spamFiltered:
								this.props.modQueueListingItems.forEach(e => {
									e.isSpam && t.push(e.id)
								})
						}
						this.props.bulkSelectItems(t)
					}, this.isAnyItemSelected = () => this.props.selectedItems.length > 0, this.renderItems = e => {
						let t;
						const n = !!e.page && "1" !== e.page,
							s = !!e.loadMore && !!e.modQueueListingItems && 25 === e.modQueueListingItems.length;
						return e.modQueueListingItems && e.modQueueListingItems.length && (t = e.modQueueListingItems.map(t => {
							const n = `modqueue-item-[layout: ${e.layout}]-[id: ${t.id}]`;
							if (kt(t)) {
								const s = t,
									r = Object(_.b)({
										layout: e.layout,
										post: s
									});
								return d.a.createElement(_t, {
									key: n
								}, d.a.createElement(r, {
									availableWidth: y.g,
									currentProfileName: e.currentProfileName,
									forceLoadMedia: !0,
									isCommentPermalink: e.isCommentPermalink,
									isCommentsPage: e.isCommentsPage,
									isFrontpage: e.isFrontpage,
									isProfilePostListing: e.isProfilePostListing,
									isCheckboxSelected: this.isCheckboxSelected(s.id),
									last: !0,
									pageLayer: e.pageLayer,
									postId: s.id,
									onClickPost: Object(A.b)(s.id, e),
									showBulkActionCheckbox: !0,
									toggleCheckbox: () => this.toggleSelectedItems(this.isCheckboxSelected(s.id), [s.id]),
									shouldShowGalleryTileOption: !0,
									isGalleryTileLayoutDefault: !0
								}))
							}
							const s = function(e, t) {
								const n = he[t];
								return void 0 === n ? (Object(S.a)(void 0, `Could not find component for layout ${t}.`), ge) : n
							}(0, e.layout);
							return d.a.createElement(_t, {
								key: n,
								className: e.isInShredditModNavExperiment ? It.a.commentOutline : void 0
							}, d.a.createElement(yt.a, {
								postId: t.postId
							}, d.a.createElement(s, {
								className: e.isInShredditModNavExperiment ? "mb-0" : "",
								commentId: t.id,
								hasReports: Object(h.c)(t),
								highlight: !1,
								isCheckboxSelected: this.isCheckboxSelected(t.id),
								showBulkActionCheckbox: !0,
								showModTools: !0,
								toggleCheckbox: () => this.toggleSelectedItems(this.isCheckboxSelected(t.id), [t.id]),
								trackClick: e.sendEventWithName
							})))
						})), d.a.createElement("div", null, d.a.createElement("div", null, t), d.a.createElement(St, {
							className: Object(m.a)({
								[It.a.isInShredditNavExperiment]: e.isInShredditModNavExperiment
							})
						}, d.a.createElement(C, {
							prevButtonEnabled: n,
							prevTo: Object(u.a)(`${e.origin}${e.currentPage.url}`, {
								page: Mt(e),
								after: null
							}),
							nextButtonEnabled: s,
							nextTo: Object(u.a)(`${e.origin}${e.currentPage.url}`, {
								page: Dt(e),
								after: e.loadMore
							})
						})))
					}
				}
				componentWillUnmount() {
					this.props.bulkUnselectItems(this.props.selectedItems)
				}
				UNSAFE_componentWillUpdate(e) {
					e.pageName === this.props.pageName && e.page === this.props.page && e.profileName === this.props.profileName && e.subredditName === this.props.subredditName && e.postTypeFilter === this.props.postTypeFilter && e.postSort === this.props.postSort || this.props.bulkUnselectItems(this.props.selectedItems)
				}
				render() {
					const {
						props: e
					} = this, t = e.modQueueListingItems && e.modQueueListingItems.length ? e.modQueueListingItems.map(e => e.id) : [], n = e.selectedItems.length;
					return d.a.createElement("div", null, d.a.createElement(At, {
						className: e.isInShredditModNavExperiment ? It.a.bulkOptionsOutline : void 0,
						endNumItems: Rt(e),
						numSelected: n,
						numShowing: t.length,
						isAnyItemSelected: this.isAnyItemSelected(),
						isSelectAll: this.isAllSelected(t),
						startNumItems: Lt(e),
						subredditId: e.subredditId,
						toggleSelectAll: () => this.toggleSelectedItems(this.isAllSelected(t), t),
						toggleSelectByFilter: this.toggleSelectByFilter
					}), e.modQueueListingItems && e.modQueueListingItems.length ? this.renderItems(e) : e.modQueueListingItems ? d.a.createElement(Ne, null) : e.isModQueueListingPending ? d.a.createElement(Le, null) : null)
				}
			}
			t.a = wt(Pt(Ft))
		},
		"./src/reddit/components/ModToolsFlatlist/breakpoints.m.less": function(e, t, n) {
			e.exports = {
				HideIfVWSmaller: "_3_rOJpfw54EqNa6daNkKzY",
				hideIfVwSmaller: "_3_rOJpfw54EqNa6daNkKzY",
				ApproveGroup: "LoIAKSBD5_isA5qtrC3Kt",
				approveGroup: "LoIAKSBD5_isA5qtrC3Kt",
				DefaultVariant: "_1LDTBaBSnv4jL7lV98ayQL",
				defaultVariant: "_1LDTBaBSnv4jL7lV98ayQL",
				CompactVariant: "_2SLG9GIeu2AqBhz2XpW8ow",
				compactVariant: "_2SLG9GIeu2AqBhz2XpW8ow",
				ClassicVariant: "_1u3Z1cqZ8_083AStFVo71a",
				classicVariant: "_1u3Z1cqZ8_083AStFVo71a",
				RemoveGroup: "_3LzZxt89CjBbx__WYlCPCh",
				removeGroup: "_3LzZxt89CjBbx__WYlCPCh",
				SpamGroup: "_2WaHNFliLea9SKyF3nlBx8",
				spamGroup: "_2WaHNFliLea9SKyF3nlBx8",
				FlairGroup: "_129dedXMiIcel_grUelwoG",
				flairGroup: "_129dedXMiIcel_grUelwoG",
				HideIfVWLarger: "_1RO0TIeDG89QPdOWgZwUvR",
				hideIfVwLarger: "_1RO0TIeDG89QPdOWgZwUvR",
				ButtonTextWrapper: "_2xZQ73fYkUDMcVkB0PnaU9",
				buttonTextWrapper: "_2xZQ73fYkUDMcVkB0PnaU9"
			}
		},
		"./src/reddit/components/ModToolsFlatlist/constants.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Flair = "FLAIR", e.Spam = "SPAM", e.Remove = "REMOVE", e.Approve = "APPROVE"
				}(s || (s = {}))
		},
		"./src/reddit/components/ModToolsFlatlist/getModItemBreakpoints.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "c", (function() {
				return h
			}));
			var s, r, o, i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/ModToolsFlatlist/constants.ts"),
				d = n("./src/reddit/constants/postLayout.ts"),
				c = n("./src/reddit/components/ModToolsFlatlist/breakpoints.m.less"),
				l = n.n(c),
				u = n("./src/reddit/components/ModToolsFlatlist/index.m.less"),
				m = n.n(u);
			! function(e) {
				e.HideIfVWSmaller = "HideIfVWSmaller", e.HideIfVWLarger = "HideIfVWLarger"
			}(s || (s = {})),
			function(e) {
				e.Approve = "ApproveGroup", e.Remove = "RemoveGroup", e.Spam = "SpamGroup", e.Flair = "FlairGroup"
			}(r || (r = {})),
			function(e) {
				e.Classic = "ClassicVariant", e.Compact = "CompactVariant", e.Default = "DefaultVariant"
			}(o || (o = {}));
			const p = {
					[a.a.Approve]: r.Approve,
					[a.a.Remove]: r.Remove,
					[a.a.Spam]: r.Spam,
					[a.a.Flair]: r.Flair
				},
				b = {
					[d.g.Classic]: o.Classic,
					[d.g.Compact]: o.Compact,
					[d.g.Large]: o.Default,
					[d.g.Medium]: o.Default,
					[d.g.Search]: o.Default
				},
				f = e => {
					const t = p[e.flatlistItem],
						n = e.postLayout && b[e.postLayout],
						s = l.a[e.breakpointType],
						r = l.a[t],
						a = n ? l.a[n] : l.a[o.Default];
					return Object(i.a)(s, r, a)
				},
				h = e => {
					const t = e && b[e],
						n = t ? l.a[t] : l.a[o.Default];
					return Object(i.a)(n, m.a.ButtonTextWrapper, l.a.ButtonTextWrapper)
				}
		},
		"./src/reddit/components/ModToolsFlatlist/index.m.less": function(e, t, n) {
			e.exports = {
				container: "OccjSdFd6HkHhShRg6DOl",
				tooltip: "_2a9swcTo72vLia4mUm08Fk",
				ButtonTextWrapper: "_3kA8j4bWXyfQV-T-H2dkNq",
				buttonTextWrapper: "_3kA8j4bWXyfQV-T-H2dkNq"
			}
		},
		"./src/reddit/components/ModToolsFlatlist/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return M
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/modal.ts"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./src/reddit/actions/tooltip.ts"),
				m = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				p = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				b = n("./src/reddit/components/ModModeReports/helpers.ts"),
				f = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				h = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				g = n("./src/reddit/helpers/hasModPostPermissions/index.ts"),
				v = n("./src/reddit/helpers/trackers/post.ts"),
				x = n("./src/reddit/icons/fonts/Approve/index.tsx"),
				E = n("./src/reddit/icons/fonts/Spam/index.tsx"),
				O = n("./src/reddit/icons/fonts/Tag/index.tsx"),
				C = n("./src/reddit/selectors/activeModalId.ts"),
				A = n("./src/reddit/selectors/moderatorPermissions.ts"),
				y = n("./src/reddit/selectors/postFlair.ts"),
				j = n("./src/reddit/components/ModToolsFlatlist/constants.ts"),
				I = n("./src/reddit/components/ModToolsFlatlist/getModItemBreakpoints.ts"),
				k = n("./src/lib/constants/index.ts"),
				_ = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				S = n("./src/reddit/components/ModalStyledComponents/MessageBox.tsx"),
				w = n("./src/reddit/hooks/useTracking.ts"),
				T = n("./src/reddit/icons/fonts/Remove/index.tsx"),
				P = n("./src/reddit/components/ModToolsFlatlist/index.m.less"),
				N = n.n(P);
			const D = e => {
					let {
						className: t,
						textClassName: n,
						isOverlay: r,
						iconOnly: a,
						post: d
					} = e;
					const [c, p] = o.a.useState(!1), [b, f] = o.a.useState(!1), g = Object(w.a)(), x = Object(i.d)(), {
						isPrediction: E,
						resolvedOptionId: O,
						totalVoteCount: C
					} = d.pollData || {}, A = () => {
						p(!1), x(Object(l.S)(d.id, !1)), d.isRemoved && d.bannedBy === k.l ? g(Object(v.n)(d.id, "confirm_remove")) : g(Object(v.n)(d.id, "remove"))
					}, y = ((e, t) => e ? t === k.l ? s.fbt._("Confirm removal", null, {
						hk: "1t5tKM"
					}) : s.fbt._("removed", null, {
						hk: "35ZTch"
					}) : s.fbt._("remove", null, {
						hk: "3LWMcS"
					}))(d.isRemoved, d.bannedBy), j = M("Remove", d.id, r), I = () => a && x(Object(u.h)({
						tooltipId: j
					})), P = o.a.useMemo(() => C ? 1 === C ? s.fbt._("Removing this post will cancel the 1 prediction that has already been made.", null, {
						hk: "hVYeT"
					}) : s.fbt._("Removing this post will cancel the {votedUsersCount} predictions that have already been made.", [s.fbt._param("votedUsersCount", C.toString())], {
						hk: "47oACN"
					}) : s.fbt._("Removing this post will cancel any predictions that have already been made.", null, {
						hk: "26cLeP"
					}), [C]);
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(h.d, {
						className: t,
						textClassName: n,
						id: j,
						text: a ? void 0 : y,
						disabled: d.isRemoved && d.bannedBy !== k.l,
						onMouseEnter: I,
						onMouseLeave: I,
						onClick: () => {
							E ? O ? f(!0) : p(!0) : A()
						}
					}, o.a.createElement(T.a, {
						desc: a ? y : void 0
					}), a && o.a.createElement(m.c, {
						className: N.a.tooltip,
						tooltipId: j,
						text: y
					})), b && o.a.createElement(S.a, {
						title: s.fbt._("This post can't be removed", null, {
							hk: "2GbryD"
						}),
						body: s.fbt._("Sorry about that. Once a prediction has been resolved, you can't remove the post.", null, {
							hk: "3wgNhQ"
						}),
						onClose: () => f(!b)
					}), c && o.a.createElement(_.a, {
						withOverlay: !0,
						modalText: P,
						actionText: s.fbt._("Remove", null, {
							hk: "2DXJl4"
						}),
						headerText: s.fbt._("Are you sure?", null, {
							hk: "3CJLRE"
						}),
						onConfirm: A,
						onOverlayClick: () => p(!c),
						toggleModal: () => p(!c)
					}))
				},
				M = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return `ModToolsFlatlist-${e}${t}${n?"inOverlay":""}`
				},
				R = (e, t) => Object(I.b)({
					breakpointType: I.a.HideIfVWSmaller,
					flatlistItem: e,
					postLayout: t
				}),
				L = Object(i.b)(() => Object(a.c)({
					activeModalId: C.a,
					canEditFlair: (e, t) => {
						let {
							post: n
						} = t;
						return Object(y.a)(e, {
							postId: n.id
						})
					},
					moderatorPermissions: (e, t) => Object(A.m)(e, {
						postId: t.post.id
					})
				}), (e, t) => {
					let {
						post: n
					} = t;
					return {
						onApprovePost: () => e(Object(l.r)(n.id)),
						onOpenPostModModeDropdown: t => e(Object(u.h)({
							tooltipId: t
						})),
						onSpamPost: () => e(Object(l.S)(n.id, !0)),
						onFlairPost: t => () => e(Object(c.i)(t))
					}
				});
			t.a = L(e => {
				const {
					canEditFlair: t,
					className: n,
					isOverlay: a,
					layout: c,
					moderatorPermissions: l,
					modModeEnabled: C,
					onApprovePost: A,
					onFlairPost: y,
					onSpamPost: k,
					post: _,
					sendEvent: S,
					showIconsOnly: w
				} = e, T = Object(i.d)(), P = Object(g.a)(l), L = Object(b.b)(_), B = !(!_.approvedBy || !L), F = Object(f.b)(_.id, a), U = P && C && !_.isSponsored, H = t && C, G = ((e, t) => e ? s.fbt._("reapprove", null, {
					hk: "OJvB1"
				}) : t ? s.fbt._("approved", null, {
					hk: "2bWAFI"
				}) : s.fbt._("approve", null, {
					hk: "2DIHcM"
				}))(B, _.approvedBy), Q = (e => e ? s.fbt._("spammed", null, {
					hk: "3GPrkZ"
				}) : s.fbt._("spam", null, {
					hk: "3ebJLg"
				}))(_.isSpam), q = M("Approve", _.id, a), W = M("Spam", _.id, a), z = () => w && T(Object(u.h)({
					tooltipId: q
				})), V = () => w && T(Object(u.h)({
					tooltipId: W
				})), K = a ? void 0 : c;
				return o.a.createElement("div", {
					className: Object(d.a)(N.a.container, n)
				}, U && o.a.createElement(r.Fragment, null, o.a.createElement(h.b, {
					className: R(j.a.Approve, K),
					key: "approveButton",
					text: w ? void 0 : G,
					textClassName: Object(I.c)(K),
					disabled: !!_.approvedBy && !L,
					id: q,
					onMouseEnter: z,
					onMouseLeave: z,
					onClick: () => {
						A(), S(Object(v.n)(_.id, "approve"))
					}
				}, o.a.createElement(x.a, {
					desc: w ? G : void 0
				}), w && o.a.createElement(m.c, {
					className: N.a.tooltip,
					tooltipId: q,
					text: G
				})), o.a.createElement(D, {
					className: R(j.a.Remove, K),
					textClassName: Object(I.c)(K),
					isOverlay: a,
					iconOnly: w,
					post: _
				}), o.a.createElement(h.d, {
					className: R(j.a.Spam, K),
					key: "removeSpamButton",
					text: w ? void 0 : Q,
					textClassName: Object(I.c)(K),
					disabled: _.isSpam,
					id: W,
					onMouseEnter: V,
					onMouseLeave: V,
					onClick: () => {
						k(), S(Object(v.n)(_.id, "spam"))
					}
				}, o.a.createElement(E.a, {
					desc: w ? Q : void 0
				}), w && o.a.createElement(m.c, {
					className: N.a.tooltip,
					tooltipId: W,
					text: Q
				}))), H && o.a.createElement(h.c, {
					className: R(j.a.Flair, K),
					key: "tagButton",
					onClick: () => {
						y(F)(), S(Object(v.n)(_.id, "post_flair_picker"))
					}
				}, o.a.createElement(O.a, null)), o.a.createElement(p.f, null))
			})
		},
		"./src/reddit/components/ModWelcomeTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				Overlay: "_2PnG5snRqhlCLmlBFW9Dud",
				overlay: "_2PnG5snRqhlCLmlBFW9Dud",
				isOverlayOpen: "_1LKHMvN5rVxTXGRnTa9hrB",
				DropdownPadding: "_3GVs_x5BtyiLy35GpmGSyo",
				dropdownPadding: "_3GVs_x5BtyiLy35GpmGSyo",
				Tooltip: "_2EusAZo7A7uyI8gxC0nJdp",
				tooltip: "_2EusAZo7A7uyI8gxC0nJdp",
				TooltipContent: "_1BsafzE6q8PmCVU5uqiTWj",
				tooltipContent: "_1BsafzE6q8PmCVU5uqiTWj",
				Title: "_1BFO2H2-rybL94nyL7n-e_",
				title: "_1BFO2H2-rybL94nyL7n-e_",
				Description: "_2DnHuFoYoKwYaBvTkLrs0v",
				description: "_2DnHuFoYoKwYaBvTkLrs0v",
				modLink: "_16moQ9CB6asKjB-qTj8Tvf",
				Button: "_2x6OQ6vZfN3PNhM6Eh6FLq",
				button: "_2x6OQ6vZfN3PNhM6Eh6FLq"
			}
		},
		"./src/reddit/components/ModWelcomeTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "MOD_WELCOME_TOOLTIP_ID", (function() {
				return x
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				u = n("./src/reddit/controls/Button/index.tsx"),
				m = n("./src/reddit/controls/Dropdown/index.tsx"),
				p = n("./src/reddit/helpers/toggleBodyScroll/index.ts"),
				b = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				f = n("./src/reddit/selectors/platform.ts"),
				h = n("./src/reddit/components/ModWelcomeTooltip/index.m.less"),
				g = n.n(h);
			const v = Object(l.a)(m.a),
				x = "ModProgressModule--ModWelcomeTooltip";
			t.default = Object(d.a)(e => {
				const t = Object(i.e)(f.d),
					n = x,
					d = Object(i.d)(),
					l = e => {
						e.stopPropagation(), d(Object(c.h)({
							tooltipId: n
						}))
					};
				return Object(r.useEffect)(() => {
					e.isOpen ? setTimeout(() => Object(p.a)(), 500) : setTimeout(() => Object(p.b)(), 500)
				}, [d, e.isOpen]), t ? o.a.createElement(v, {
					className: g.a.Tooltip,
					isOpen: e.isOpen,
					targetPosition: ["left", "top"],
					tooltipPosition: ["right", "top"],
					tooltipId: n,
					componentWrapper: t => o.a.createElement("div", {
						className: Object(a.a)(g.a.Overlay, {
							[g.a.isOverlayOpen]: e.isOpen
						}),
						onClick: l
					}, o.a.createElement("div", {
						className: Object(a.a)(g.a.DropdownPadding, {
							[g.a.isOverlayOpen]: e.isOpen
						}),
						onClick: l
					}), t)
				}, o.a.createElement("div", {
					className: g.a.TooltipContent
				}, o.a.createElement("div", {
					className: g.a.Title
				}, s.fbt._("Welcome to your community, r/{subredditName}!", [s.fbt._param("subredditName", t)], {
					hk: "e3rbC"
				})), o.a.createElement("div", {
					className: g.a.Description
				}, s.fbt._("Well walk you through how to get started here, and you can get more tips and advice through Reddits", null, {
					hk: "lffxe"
				}), " ", o.a.createElement("a", {
					className: g.a.modLink,
					style: {
						color: Object(b.a)(e).linkText
					},
					href: "https://www.reddit.com/r/ModCertification101/",
					rel: "noopener noreferrer",
					target: "_blank"
				}, s.fbt._("Mod Certification Program", null, {
					hk: "1FTpvR"
				})), "."), o.a.createElement(u.t, {
					className: g.a.Button,
					onClick: l
				}, s.fbt._("Let's go", null, {
					hk: "4hWwxv"
				})))) : null
			})
		},
		"./src/reddit/components/ModalStyledComponents/MessageBox.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/higherOrderComponents/asModal/index.tsx"),
				a = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				d = n("./src/reddit/controls/TextButton/index.tsx"),
				c = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx");

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const u = Object(i.a)(e => {
					let {
						title: t,
						body: n,
						actionText: r = s.fbt._("OK", null, {
							hk: "1eo6HO"
						}),
						onClose: i
					} = e;
					return o.a.createElement(a.e, null, o.a.createElement(a.i, null, o.a.createElement(c.a, null, o.a.createElement(a.q, null, t), o.a.createElement(d.a, {
						onClick: i
					}, o.a.createElement(a.b, null)))), o.a.createElement(a.l, null, o.a.createElement(a.p, null, n)), o.a.createElement(a.g, null, o.a.createElement(a.u, {
						"data-redditstyle": !0,
						onClick: i
					}, r)))
				}),
				m = e => o.a.createElement(u, l({
					withOverlay: !0,
					onOverlayClick: e.onClose
				}, e))
		},
		"./src/reddit/components/ModalStyledComponents/index.m.less": function(e, t, n) {
			e.exports = {
				CloseIcon: "_3XSQHPxjCTSWWZh_u-d0Xf",
				closeIcon: "_3XSQHPxjCTSWWZh_u-d0Xf",
				ModalBody: "_2R3RlhymCOkPrz9TusvcPq",
				modalBody: "_2R3RlhymCOkPrz9TusvcPq",
				ModalPostPreview: "HydQQ-TD4TUsVnxkYk_5F",
				modalPostPreview: "HydQQ-TD4TUsVnxkYk_5F",
				ModalText: "mFTHPdbEAklUs8yhT4Xm7",
				modalText: "mFTHPdbEAklUs8yhT4Xm7",
				ModalSmallText: "_3cwQrg-XvocnoG0U22wT8t",
				modalSmallText: "_3cwQrg-XvocnoG0U22wT8t",
				ModalDescriptionText: "_12g_PUGHD-w7T1w4Q3oTsq",
				modalDescriptionText: "_12g_PUGHD-w7T1w4Q3oTsq",
				ModalMetaText: "_27eskYssCs-urVW1uHI4YI",
				modalMetaText: "_27eskYssCs-urVW1uHI4YI",
				ModalFormItem: "_3xiY8nTCVp16qSb6CGW2Kv",
				modalFormItem: "_3xiY8nTCVp16qSb6CGW2Kv",
				ModalInput: "_20ZSV7ktyDYzPcd1UMQWZT",
				modalInput: "_20ZSV7ktyDYzPcd1UMQWZT",
				ModalInputLabel: "HVADn-LHFLaS8r6IBJWeq",
				modalInputLabel: "HVADn-LHFLaS8r6IBJWeq",
				ModalFooter: "_-0i7atRJ5NBsrRM5wuPpX",
				modalFooter: "_-0i7atRJ5NBsrRM5wuPpX",
				ModalHeader: "_1Fa5Xv7f16v5IC2Tq1m2Fy",
				modalHeader: "_1Fa5Xv7f16v5IC2Tq1m2Fy",
				ModalTitle: "eLnlHLGCDxjFf3jfGTcZu",
				modalTitle: "eLnlHLGCDxjFf3jfGTcZu",
				ModalMain: "_1uaasV6RaxBfRyVgQJdiKs",
				modalMain: "_1uaasV6RaxBfRyVgQJdiKs",
				ModalAnnotation: "gLlWG7Oj89Ost4_twUu8w",
				modalAnnotation: "gLlWG7Oj89Ost4_twUu8w",
				TextArea: "_2h8O7PjrCXfaJJWKrAxJPL",
				textArea: "_2h8O7PjrCXfaJJWKrAxJPL",
				WarningButton: "_17UyTSs2atqnKg9dIq5ERg",
				warningButton: "_17UyTSs2atqnKg9dIq5ERg",
				PrimaryButton: "_2X1FFYUx3jzlnbcegBC_Sr",
				primaryButton: "_2X1FFYUx3jzlnbcegBC_Sr",
				CancelButton: "_1QUX9-zZuGtifS6jJBUyh-",
				cancelButton: "_1QUX9-zZuGtifS6jJBUyh-",
				RemoveButton: "_2ulRgczjI5SWCMgSA1CNLj",
				removeButton: "_2ulRgczjI5SWCMgSA1CNLj",
				ConfirmButton: "JZC61-VzVuaiHdWuRUiSC",
				confirmButton: "JZC61-VzVuaiHdWuRUiSC"
			}
		},
		"./src/reddit/components/ModalStyledComponents/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "n", (function() {
				return f
			})), n.d(t, "p", (function() {
				return h
			})), n.d(t, "o", (function() {
				return g
			})), n.d(t, "f", (function() {
				return v
			})), n.d(t, "m", (function() {
				return x
			})), n.d(t, "h", (function() {
				return E
			})), n.d(t, "j", (function() {
				return O
			})), n.d(t, "k", (function() {
				return C
			})), n.d(t, "g", (function() {
				return A
			})), n.d(t, "i", (function() {
				return y
			})), n.d(t, "q", (function() {
				return j
			})), n.d(t, "d", (function() {
				return I
			})), n.d(t, "l", (function() {
				return k
			})), n.d(t, "t", (function() {
				return _
			})), n.d(t, "u", (function() {
				return S
			})), n.d(t, "r", (function() {
				return w
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "s", (function() {
				return P
			})), n.d(t, "c", (function() {
				return N
			}));
			var s = n("./src/lib/classNames/index.ts"),
				r = n("./src/lib/lessComponent.tsx"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/controls/Button/index.tsx"),
				d = n("./src/reddit/controls/Input/ModalInput.tsx"),
				c = n("./src/reddit/icons/svgs/Close/index.tsx"),
				l = n("./src/reddit/components/ModalStyledComponents/index.m.less"),
				u = n.n(l);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const p = r.a.wrapped(c.a, "CloseIcon", u.a),
				b = r.a.section("ModalBody", u.a),
				f = r.a.section("ModalPostPreview", u.a),
				h = r.a.p("ModalText", u.a),
				g = r.a.div("ModalSmallText", u.a),
				v = r.a.div("ModalDescriptionText", u.a),
				x = r.a.div("ModalMetaText", u.a),
				E = r.a.label("ModalFormItem", u.a),
				O = r.a.wrapped(d.a, "ModalInput", u.a),
				C = r.a.label("ModalInputLabel", u.a),
				A = r.a.footer("ModalFooter", u.a),
				y = r.a.header("ModalHeader", u.a),
				j = r.a.div("ModalTitle", u.a),
				I = r.a.div("ModalAnnotation", u.a),
				k = r.a.div("ModalMain", u.a),
				_ = r.a.textarea("TextArea", u.a),
				S = r.a.wrapped(a.l, "WarningButton", u.a),
				w = r.a.wrapped(a.l, "PrimaryButton", u.a),
				T = r.a.wrapped(a.o, "CancelButton", u.a),
				P = r.a.wrapped(a.r, "RemoveButton", u.a),
				N = e => {
					let {
						className: t,
						...n
					} = e;
					return i.a.createElement(a.t, m({
						kind: a.b.Button,
						priority: a.c.Primary,
						className: Object(s.a)(u.a.ConfirmButton, t)
					}, n))
				}
		},
		"./src/reddit/components/ModerationPagesEmptyList/index.m.less": function(e, t, n) {
			e.exports = {
				NoResultsContainer: "FIy4e_7DNe0P9cdi_1jVn",
				noResultsContainer: "FIy4e_7DNe0P9cdi_1jVn",
				NoResultsText: "_3V0T64xptTp5xLaY-1nsaz",
				noResultsText: "_3V0T64xptTp5xLaY-1nsaz"
			}
		},
		"./src/reddit/components/ModerationPagesEmptyList/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/components/ModerationPagesEmptyList/index.m.less"),
				a = n.n(i);
			const d = o.a.div("NoResultsContainer", a.a),
				c = o.a.div("NoResultsText", a.a);

			function l(e) {
				const {
					childrenPosition: t = "top"
				} = e;
				return r.a.createElement(d, {
					className: e.className
				}, "top" === t && e.children, r.a.createElement(c, null, e.text), "bottom" === t && e.children)
			}
		},
		"./src/reddit/components/ModeratorsList/AddModeratorModal/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "TOhrvfHoucDPr36mCCzXd",
				titleFontH2: "_3brDTRw250hGX1o5_C0hbB",
				titleFontH3: "_1wry80KT9v8gZ-OR85HxZU",
				titleFontH4: "_3UyiSE-qM-508iK8v3J9VE",
				titleFontH5: "_1X7-zzcj5Xf8vTf2xtYjK5",
				titleFontH6: "_2o19XEin0G5ad6iDvABrhH",
				metadataFont: "_1IpedXmIlnKyWpICNENnHX",
				flairFont: "_17kIb-dmfAlFCaIsLz34ar",
				labelsFont: "_3IrRBgoth_MxadAqzwGE2p",
				actionFont: "_1F_YPbXlF7ItI0z0j2Kdvy",
				smallButtonFont: "Irj9r66tO2hdWqbJx-vWa",
				largeButtonFont: "_26FBjOBHlTgNO9o-fMxWOX",
				strongTextFont: "_2umiFjo_kHT370YVhqkBUV",
				tabFont: "_1DLO-Qu2r3PHt-swAklwVx",
				buttonFontXS: "_2v4AgLqNSVXbMZLYk9vcId",
				buttonFontXs: "_2v4AgLqNSVXbMZLYk9vcId",
				buttonFontS: "_2MZUL_NnTj8rQV3EzNYnUE",
				buttonFontM: "_3cvFNq2HJE_JQWxO1GFYqj",
				buttonFontL: "_3PGa9K2pADItl7cyT0ykh_",
				buttonFontXL: "_1ZxChwU_-XfEgc5UHBhcTo",
				buttonFontXl: "_1ZxChwU_-XfEgc5UHBhcTo",
				bodyFontH1: "czPuE4HoIQInpzrURaqrX",
				bodyFontH2: "_1RMqo3EKzteTfSdM5Q-OSg",
				bodyFontH3: "_1SHo5_8OixTqxTjJ466mw1",
				bodyFontH4: "_3_zdAqdo55tnx5RHhyuGVr",
				bodyFontH5: "_22jno3ihRm-Ef63KN0Wuxa",
				bodyFontH6: "_28OREyYTHZDHgLjcK4pt_d",
				bodyFontH6Small: "_2TEwXCwEPVa9d9qN9FdZkk",
				bodyFont: "_38nKHi6IDujIOM7SuazWPd",
				bodyFontSmall: "_1lPuNthSPFYSROqTVgJlNG",
				bodyFontMono: "_3C9ynyJ6Z174Fb3-8O20xa",
				landingPageTitleFontH1: "_1nmNCQBH92sse_Es6cWOgt",
				landingPageTitleFontH2: "MAReLCada0ViNM1dSALIG",
				landingPageTitleFontH3: "_2hDhOwvMLP3waoNyjL5FB2",
				footer: "_1a_UtwKPW009WQq9JDInTY",
				checkbox: "hXaFasafnItuHCckiO50p",
				checkboxDescription: "_2HjmM9sJH5PNkLQde58pxS",
				checkboxContainer: "_15zz-Q8aRGCDeqROyYsa6f",
				divider: "_1QbYDWR424D6xhw9foYGiP",
				primaryButton: "h4QlBfFmd6UnAtiNaOhcR",
				SecondaryText: "jJBOgTxr1pZp_VDUmHpJ3",
				secondaryText: "jJBOgTxr1pZp_VDUmHpJ3",
				ModalBody: "_2UK71LqBvNes-Kto-uSxfU",
				modalBody: "_2UK71LqBvNes-Kto-uSxfU",
				automodMore: "_2IpMI7l5irmIV4rSq0_hXy"
			}
		},
		"./src/reddit/components/ModeratorsList/InvitePendingModal.m.less": function(e, t, n) {
			e.exports = {
				ModalText: "LuEOOX6cpsihxJHcF5aDv",
				modalText: "LuEOOX6cpsihxJHcF5aDv",
				ModalTextBold: "_3FiaV5-fR6fAX63py6Vyzz",
				modalTextBold: "_3FiaV5-fR6fAX63py6Vyzz",
				PrimaryButton: "_1s7NYS-cterYTwRKWqmaY6",
				primaryButton: "_1s7NYS-cterYTwRKWqmaY6",
				SecondaryButton: "_31o7G_2349tIzHKunBJEua",
				secondaryButton: "_31o7G_2349tIzHKunBJEua",
				Section: "K3DxSh_MxIy1lMkeHIPMc",
				section: "K3DxSh_MxIy1lMkeHIPMc",
				Image: "_2kAbqMQ0IHDV7bXgZ6Jsmf",
				image: "_2kAbqMQ0IHDV7bXgZ6Jsmf",
				ModalMain: "_3Nec6X3UqKJgLUGDaw4NCq",
				modalMain: "_3Nec6X3UqKJgLUGDaw4NCq"
			}
		},
		"./src/reddit/components/ModeratorsList/InvitedModeratorsList.m.less": function(e, t, n) {
			e.exports = {
				ListTitle: "_1LuVAChAgGbcgUPh_K7ebp",
				listTitle: "_1LuVAChAgGbcgUPh_K7ebp",
				ListContainer: "_1IFQy3zyz-Lgs7iYZtQaPI",
				listContainer: "_1IFQy3zyz-Lgs7iYZtQaPI"
			}
		},
		"./src/reddit/components/ModeratorsList/Moderator.m.less": function(e, t, n) {
			e.exports = {
				PencilIcon: "_2Pdzq06b5akGcY4hZ05n_5",
				pencilIcon: "_2Pdzq06b5akGcY4hZ05n_5",
				TrashIcon: "_2TU9GRodUTR72kz4zcFzxJ",
				trashIcon: "_2TU9GRodUTR72kz4zcFzxJ",
				InteractiveDiv: "qaNZ40bbce8HBshNk04f0",
				interactiveDiv: "qaNZ40bbce8HBshNk04f0"
			}
		},
		"./src/reddit/components/ModeratorsList/ResignAsModeratorModal/index.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "_3j2WCnh8ZjDRHIILJwKzkx",
				primaryButton: "_3j2WCnh8ZjDRHIILJwKzkx"
			}
		},
		"./src/reddit/components/ModeratorsList/index.m.less": function(e, t, n) {
			e.exports = {
				ListContainer: "_3s9PIWHO5f49Yj01FelAkk",
				listContainer: "_3s9PIWHO5f49Yj01FelAkk",
				SecondaryButton: "_3wQwmI4Vsj0qouIT5DTZo",
				secondaryButton: "_3wQwmI4Vsj0qouIT5DTZo",
				EditableTitle: "_1IBuDqoejky7tmj25quCUh",
				editableTitle: "_1IBuDqoejky7tmj25quCUh",
				UsersLoading: "_1oLmt3eyMItCQozx1nTk1E",
				usersLoading: "_1oLmt3eyMItCQozx1nTk1E",
				newModNavContainer: "_1jaxWHfzjsUfAkPg8MpRwE",
				topBar: "_2O-aqT2-aGXnEoY_g-8yoQ",
				fixed: "_1uGq2Ug8qa1Zo8bkv95eZT",
				default: "_22uupAL0soSQUd2vRWdY3B"
			}
		},
		"./src/reddit/components/ModeratorsList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/addQueryParams/index.ts"),
				l = n("./src/lib/classNames/index.ts"),
				u = n("./src/lib/constants/index.ts"),
				m = n("./src/lib/lessComponent.tsx"),
				p = n("./src/lib/stripQueryParams/index.ts"),
				b = n("./src/reddit/actions/modal.ts"),
				f = n("./src/reddit/actions/subredditModeration/index.ts"),
				h = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				g = n("./src/reddit/components/ModHub/NewModNav/PageLinks.tsx"),
				v = n("./src/reddit/components/ModHub/PaginationButtons/index.tsx"),
				x = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				E = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				O = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				C = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				A = n("./src/reddit/contexts/PageLayer/index.tsx"),
				y = n("./src/reddit/controls/Button/index.tsx"),
				j = n("./src/reddit/helpers/hasModFullPermissions/index.ts"),
				I = n("./src/reddit/models/SubredditModeration/index.ts"),
				k = n("./src/reddit/selectors/activeModalId.ts"),
				_ = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				S = n("./src/reddit/selectors/meta.ts"),
				w = n("./src/reddit/selectors/moderatorPermissions.ts"),
				T = n("./src/reddit/selectors/subredditModeration.ts"),
				P = n("./src/reddit/selectors/user.ts"),
				N = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/higherOrderComponents/asModal/index.tsx")),
				D = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				M = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				R = n("./src/reddit/components/TrackingHelper/index.tsx"),
				L = n("./src/reddit/controls/CheckboxWithLabel/index.tsx"),
				B = n("./src/reddit/controls/TextButton/index.tsx"),
				F = n("./src/reddit/helpers/isValidUsername/index.tsx"),
				U = n("./src/reddit/helpers/trackers/modHub.ts"),
				H = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				G = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				Q = n("./src/reddit/selectors/features/communityChat/index.ts"),
				q = n("./src/reddit/components/ModeratorsList/AddModeratorModal/index.m.less"),
				W = n.n(q);
			const z = e => {
					switch (e) {
						case G.c.access:
							return r.fbt._("Manage Users", null, {
								hk: "2cVPGG"
							});
						case G.c.config:
							return r.fbt._("Manage Settings", null, {
								hk: "10NyX"
							});
						case "chat_config":
						case G.c.chatConfig:
							return r.fbt._("Create Live Chats", null, {
								hk: "2OsHBQ"
							});
						case "chat_operator":
						case G.c.chatOperator:
							return r.fbt._("Monitor Chats", null, {
								hk: "3x751K"
							});
						case "community_chat":
						case G.c.communityChat:
							return r.fbt._("Channel Moderation", null, {
								hk: "3SzJoj"
							});
						case G.c.channels:
							return r.fbt._("Channel Management", null, {
								hk: "1v0Ix9"
							});
						case G.c.flair:
							return r.fbt._("Manage Flair", null, {
								hk: "IgS6W"
							});
						case G.c.mail:
							return r.fbt._("Manage Mod Mail", null, {
								hk: "1H5qJm"
							});
						case G.c.posts:
							return r.fbt._("Manage Posts & Comments", null, {
								hk: "1IVGI9"
							});
						case G.c.wiki:
							return r.fbt._("Manage Wiki Pages", null, {
								hk: "4gZJ2V"
							});
						case G.c.all:
						default:
							return r.fbt._("Everything", null, {
								hk: "24E26J"
							})
					}
				},
				V = (e, t) => {
					switch (e) {
						case G.c.access:
							return t ? r.fbt._("Access mod notes, ban and mute users, and approve submitters*.", null, {
								hk: "24IuB9"
							}) : r.fbt._("Approve submitters and ban and mute users*.", null, {
								hk: "KndNL"
							});
						case G.c.config:
							return r.fbt._("Manage community settings, appearance, emojis, rules, and AutoMod*.", null, {
								hk: "4djZSI"
							});
						case "chat_config":
						case G.c.chatConfig:
							return r.fbt._("Create live chat posts in this community.", null, {
								hk: "1Hxgd8"
							});
						case "chat_operator":
						case G.c.chatOperator:
							return r.fbt._("Remove messages, remove users, and lock chats.", null, {
								hk: "TFYA1"
							});
						case "community_chat":
						case G.c.communityChat:
							return r.fbt._("Moderate channel content and users.", null, {
								hk: "2rwWrA"
							});
						case G.c.channels:
							return r.fbt._("Create, edit, and delete channels.", null, {
								hk: "2pCECL"
							});
						case G.c.flair:
							return r.fbt._("Create and manage user and post flair.", null, {
								hk: "1oN7ft"
							});
						case G.c.mail:
							return r.fbt._("Read and respond to modmail and mute users*.", null, {
								hk: "2F8Yd"
							});
						case G.c.posts:
							return r.fbt._("Access queues, take action on content, and manage collections and events.", null, {
								hk: "vJ5lR"
							});
						case G.c.wiki:
							return r.fbt._("Create and manage wiki pages and AutoMod*.", null, {
								hk: "JarEL"
							});
						case G.c.all:
						default:
							return r.fbt._("Full access including the ability to manage moderator access and permissions.", null, {
								hk: "2r1vEj"
							})
					}
				},
				K = Object(d.c)({
					hasCommunityChatEnabled: (e, t) => Object(Q.f)(e, t.subredditId)
				}),
				Y = Object(a.b)(K, (e, t) => {
					let {
						subredditId: n,
						after: s,
						before: r
					} = t;
					return {
						addModerator: (t, s) => e(Object(f.b)(n, t, s)),
						editModerator: (t, s, r) => e(Object(f.d)(n, t, s, r)),
						removeModerator: t => e(Object(f.k)(n, t, s, r))
					}
				}),
				J = m.a.span("SecondaryText", W.a),
				X = m.a.wrapped(D.e, "ModalBody", W.a);
			class Z extends i.a.Component {
				constructor(e) {
					super(e), this.onUsernameChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.toggleSelect = (e, t) => {
						if (this.props.isEditingSelf) return;
						const n = {
							...this.state.permissions,
							[e]: !t
						};
						"all" === e ? Object.keys(n).forEach(e => n[e] = n.all) : n[e] || (n.all = !1), this.setState({
							permissions: n
						}), this.props.sendEvent(Object(U.e)(e, Object.keys(this.state.permissions)))
					}, this.onSubmit = e => {
						var t;
						e.preventDefault();
						const {
							props: n,
							state: s
						} = this;
						if (n.isEditingSelf) return void n.toggleModal();
						let r;
						n.isEditingPerms && n.user ? (n.editModerator(s.username, s.permissions, n.user.id), r = "edit") : (n.addModerator(s.username, s.permissions), r = "invite_moderator"), n.sendEvent(Object(U.f)(r, (null === (t = n.user) || void 0 === t ? void 0 : t.id) || s.username, Object.entries(s.permissions).reduce((e, t) => {
							let [n, s] = t;
							return [...e, ...s ? [n] : []]
						}, []))), n.toggleModal()
					}, this.onRemove = () => {
						this.props.user && (this.props.removeModerator(this.props.user.id), this.props.sendEventWithName("remove")()), this.props.toggleModal()
					}, this.state = {
						username: e.user ? e.user.username : "",
						permissions: e.user ? e.user.modPermissions : G.a
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = ["all", "chat_operator", G.c.chatOperator, ...e.hasCommunityChatEnabled ? [] : ["community_chat", G.c.communityChat, G.c.channels]], s = ["all", ...Object.keys(t.permissions).filter(e => !n.includes(e))];
					return i.a.createElement(X, null, i.a.createElement(D.i, null, i.a.createElement(H.a, null, i.a.createElement(D.q, null, e.isEditingPerms ? r.fbt._("Edit", null, {
						hk: "1nftDt"
					}) : r.fbt._("Invite Moderators", null, {
						hk: "hkBh1"
					}), e.username && r.fbt._(": u/{username}", [r.fbt._param("username", e.username)], {
						hk: "2FWWEd"
					})), i.a.createElement(B.a, {
						onClick: e.toggleModal
					}, i.a.createElement(D.b, null)))), i.a.createElement("form", {
						onSubmit: this.onSubmit
					}, i.a.createElement(D.l, null, !e.isEditingPerms && i.a.createElement(D.h, null, i.a.createElement(M.d, {
						autoFocus: !0,
						placeholder: r.fbt._("Enter Username", null, {
							hk: "2fYsDe"
						}),
						onChange: this.onUsernameChange
					})), i.a.createElement(D.q, null, e.isEditingSelf ? i.a.createElement(i.a.Fragment, null, r.fbt._("Access", null, {
						hk: "2We3HN"
					}), i.a.createElement(J, null, r.fbt._("(can't edit)", null, {
						hk: "3LZvZi"
					}))) : r.fbt._("Give them access to...", null, {
						hk: "1DzYmU"
					})), t.permissions && s.map((n, s) => i.a.createElement("div", {
						className: W.a.checkboxContainer,
						key: n
					}, i.a.createElement(L.a, {
						autoFocus: !(!e.isEditingPerms || 0 !== s) || void 0,
						className: W.a.checkbox,
						disabled: e.isEditingSelf,
						isSelected: t.permissions[n],
						onClick: () => this.toggleSelect(n, t.permissions[n]),
						text: z(n)
					}), i.a.createElement("p", {
						className: W.a.checkboxDescription
					}, V(n, e.isModWithUserNotesPermissions)), "all" === n && i.a.createElement("hr", {
						className: W.a.divider
					}))), i.a.createElement("p", {
						className: W.a.automodMore
					}, r.fbt._("*Note: To manage AutoMod, mods must have access to Wiki Pages and Manage Settings. To mute users, mods must have access to Mod Mail and Manage Users.", null, {
						hk: "1AYX38"
					}))), i.a.createElement(D.g, {
						className: W.a.footer
					}, i.a.createElement(y.l, {
						className: W.a.primaryButton,
						"data-redditstyle": !0,
						disabled: !e.username && !Object(F.a)(t.username),
						type: "submit"
					}, e.isEditingPerms ? r.fbt._("Save", null, {
						hk: "4yMsMq"
					}) : r.fbt._("Invite", null, {
						hk: "2F1syY"
					})), i.a.createElement(D.a, {
						autoFocus: !!e.isEditingSelf || void 0,
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), e.isEditingPerms && !e.isEditingSelf && i.a.createElement(D.s, {
						onClick: this.onRemove,
						"data-redditstyle": !0
					}, r.fbt._("Remove", null, {
						hk: "3tYl0U"
					})))))
				}
			}
			var $ = Object(N.a)(Y(Object(R.c)(Z))),
				ee = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				te = n("./src/reddit/selectors/telemetry.ts");
			const ne = e => ({
					screen: te.db(e),
					subreddit: te.mb(e)
				}),
				se = e => t => ({
					source: "remove_mod_invite",
					action: "click",
					noun: e,
					...ne(t)
				});
			var re = n("./src/reddit/components/HumanDate/index.tsx"),
				oe = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				ie = n("./src/reddit/icons/svgs/Trash/index.tsx"),
				ae = n("./src/reddit/components/ModeratorsList/Moderator.m.less"),
				de = n.n(ae);
			const ce = e => {
					const t = [],
						n = Object.keys(e);
					return e.all ? z("all") : (n.forEach((function(n) {
						e[n] && t.push(z(n))
					})), 0 === t.length ? r.fbt._("No permissions", null, {
						hk: "3eH05z"
					}) : t.join(", "))
				},
				le = m.a.wrapped(oe.a, "PencilIcon", de.a),
				ue = m.a.wrapped(ie.a, "TrashIcon", de.a),
				me = m.a.div("InteractiveDiv", de.a),
				pe = e => i.a.createElement(me, {
					onClick: e.onClick
				}, e.moderatorType === I.c.Editable ? i.a.createElement(le, null) : i.a.createElement(ue, null));
			var be = e => i.a.createElement(C.b, {
					additionalText: ce(e.moderator.modPermissions),
					pageName: u.mc.Moderators,
					primaryButton: e.moderatorType && e.onClick && i.a.createElement(pe, {
						onClick: e.onClick,
						moderatorType: e.moderatorType
					}),
					timeAgo: i.a.createElement(re.d, {
						seconds: e.moderator.moddedAtUTC
					}),
					subredditId: e.subredditId,
					userIcon: e.moderator.accountIcon,
					username: e.moderator.username,
					moderatorType: e.moderatorType
				}),
				fe = n("./src/reddit/components/ModeratorsList/InvitedModeratorsList.m.less"),
				he = n.n(fe);
			const ge = m.a.div("ListTitle", he.a),
				ve = m.a.div("ListContainer", he.a),
				xe = Object(d.c)({
					invitedModeratorsList: T.f,
					isConfirmModalOpen: Object(k.b)("ModerationPage--Modal--RemoveModeratorConfirmation")
				});
			class Ee extends i.a.Component {
				constructor(e) {
					super(e), this.onToggleRemovalModal = e => {
						this.setState({
							selectedModerator: e
						}), this.props.toggleConfirmUserActionModal(), e && this.props.sendEventWithName("remove_mod_invite")()
					}, this.state = {
						selectedModerator: void 0
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					if (0 === e.invitedModeratorsList.length) return null;
					const n = () => this.props.sendEvent(se("cancel"));
					return i.a.createElement("div", null, i.a.createElement(ge, null, r.fbt._("Invited moderators", null, {
						hk: "2UdpbF"
					})), i.a.createElement(ve, null, e.invitedModeratorsList.map(t => i.a.createElement(be, {
						key: t.id,
						moderator: t,
						moderatorType: I.c.Invited,
						onClick: () => this.onToggleRemovalModal(t),
						subredditId: e.subredditId
					}))), e.isConfirmModalOpen && t.selectedModerator && i.a.createElement(ee.a, {
						actionText: r.fbt._("Remove", null, {
							hk: "3tYl0U"
						}),
						modalText: r.fbt._("Are you sure you want to rescind the moderator invite to {username}?", [r.fbt._param("username", t.selectedModerator.username)], {
							hk: "3Z7yAI"
						}),
						onConfirm: () => e.removeInvitedModerator(t.selectedModerator.id),
						toggleModal: this.onToggleRemovalModal,
						onCancel: n,
						onClose: n,
						trackClick: () => this.props.sendEvent(se("remove"))
					}))
				}
			}
			var Oe = Object(a.b)(xe, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						removeInvitedModerator: t => e(Object(f.j)(n, t)),
						toggleConfirmUserActionModal: () => e(Object(b.i)("ModerationPage--Modal--RemoveModeratorConfirmation"))
					}
				})(Object(R.c)(Ee)),
				Ce = n("./src/reddit/components/ModeratorsList/InvitePendingModal.m.less"),
				Ae = n.n(Ce);
			const {
				fbt: ye
			} = n("./node_modules/fbt/lib/FbtPublic.js"), je = Object(a.b)(null, (e, t) => {
				let {
					subredditId: n
				} = t;
				return {
					acceptInvite: () => e(Object(f.a)(n)),
					declineInvite: () => e(Object(f.c)(n))
				}
			}), Ie = m.a.wrapped(D.p, "ModalText", Ae.a), ke = m.a.wrapped(Ie, "ModalTextBold", Ae.a), _e = m.a.wrapped(y.l, "PrimaryButton", Ae.a), Se = m.a.wrapped(y.o, "SecondaryButton", Ae.a), we = m.a.div("Section", Ae.a), Te = m.a.img("Image", Ae.a), Pe = m.a.wrapped(D.l, "ModalMain", Ae.a);
			var Ne = Object(N.a)(je(e => i.a.createElement(D.e, null, i.a.createElement(Pe, null, i.a.createElement(H.a, null, i.a.createElement("div", null), i.a.createElement(B.a, {
					onClick: e.toggleModal
				}, i.a.createElement(D.b, null))), i.a.createElement(we, null, i.a.createElement(Te, {
					src: `${s.a.assetPath}/img/snoo-success@2x.png`
				})), i.a.createElement(ke, null, ye._("Congrats!", null, {
					hk: "T4Ccw"
				})), i.a.createElement(Ie, null, ye._("You are invited to become a moderator!", null, {
					hk: "1jRLWz"
				}))), i.a.createElement(D.g, null, i.a.createElement(Se, {
					onClick: t => {
						e.toggleModal(), e.declineInvite(), e.sendEventWithName("declineinvite")()
					},
					"data-redditstyle": !0
				}, ye._("Decline", null, {
					hk: "1iOsJe"
				})), i.a.createElement(_e, {
					onClick: t => {
						e.toggleModal(), e.acceptInvite(), e.sendEventWithName("acceptinvite")()
					},
					"data-redditstyle": !0
				}, ye._("Accept", null, {
					hk: "2fkYc4"
				})))))),
				De = n("./src/reddit/components/ModeratorsList/ResignAsModeratorModal/index.m.less"),
				Me = n.n(De);
			const {
				fbt: Re
			} = n("./node_modules/fbt/lib/FbtPublic.js"), Le = Object(a.b)(null, (e, t) => {
				let {
					subredditId: n,
					userId: s,
					after: r,
					before: o
				} = t;
				return {
					removeModerator: () => e(Object(f.k)(n, s, r, o))
				}
			}), Be = m.a.wrapped(y.l, "PrimaryButton", Me.a);
			class Fe extends i.a.Component {
				constructor() {
					super(...arguments), this.onRemove = () => {
						this.props.removeModerator(), this.props.sendEventWithName("resign")(), this.props.toggleModal()
					}
				}
				render() {
					const {
						props: e
					} = this;
					return i.a.createElement(D.e, null, i.a.createElement(D.i, null, i.a.createElement(H.a, null, i.a.createElement(D.q, null, Re._("Leave as mod", null, {
						hk: "3ajWeG"
					})), i.a.createElement(B.a, {
						onClick: e.toggleModal
					}, i.a.createElement(D.b, null)))), i.a.createElement(D.l, null, i.a.createElement(D.p, null, Re._("Once you leave as a mod, you will lose mod permissions and will be unable to access any mod tools for this community. Are you sure you wish to leave as a mod of this community?", null, {
						hk: "4qm9md"
					}))), i.a.createElement(D.g, null, i.a.createElement(D.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, Re._("Cancel", null, {
						hk: "2TSLl5"
					})), i.a.createElement(Be, {
						onClick: this.onRemove,
						"data-redditstyle": !0
					}, Re._("Leave", null, {
						hk: "2ZHZVX"
					}))))
				}
			}
			var Ue = Object(N.a)(Le(Fe)),
				He = n("./src/reddit/components/ModeratorsList/index.m.less"),
				Ge = n.n(He);
			const Qe = m.a.div("ListContainer", Ge.a),
				qe = m.a.wrapped(y.o, "SecondaryButton", Ge.a),
				We = Object(A.v)({
					currentPageUrl: A.f
				}),
				ze = Object(d.c)({
					currentUser: P.m,
					nextAfterToken: T.k,
					nextAfterEditableToken: T.c,
					nextBeforeToken: T.l,
					nextBeforeEditableToken: T.d,
					editableModerators: T.e,
					editableModeratorsList: T.b,
					isInvitePending: T.h,
					moderators: T.o,
					moderatorsList: T.j,
					moderatorPermissions: w.n,
					isAddUserModalOpen: Object(k.b)("ModerationPage--Modal--AddModerator"),
					isEditableListPending: T.a,
					isInvitePendingModalOpen: Object(k.b)("ModerationPage--Modal--InvitePending"),
					isModeratorListPending: T.i,
					isResignAsModeratorModalOpen: Object(k.b)("ModerationPage--Modal--Resign"),
					origin: S.l,
					searchPending: T.m,
					searchResult: T.n,
					isModWithUserNotesPermissions: (e, t) => {
						let {
							subredditId: n
						} = t;
						return Object(w.i)(e, n)
					},
					isInShredditModNavExperiment: (e, t) => {
						let {
							moderatorPermissions: n
						} = t;
						return Object(_.a)(e, !!n)
					}
				}),
				Ve = Object(a.b)(ze, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						searchForModerator: t => e(Object(f.h)(n, t)),
						toggleAddModeratorModal: () => e(Object(b.i)("ModerationPage--Modal--AddModerator")),
						toggleInvitePendingModal: () => e(Object(b.i)("ModerationPage--Modal--InvitePending")),
						toggleResignAsModModal: () => e(Object(b.i)("ModerationPage--Modal--Resign"))
					}
				}),
				Ke = m.a.div("EditableTitle", Ge.a),
				Ye = m.a.wrapped(C.a, "UsersLoading", Ge.a);
			class Je extends i.a.Component {
				constructor() {
					super(...arguments), this.state = {
						...I.a,
						isFixed: !this.props.isInShredditModNavExperiment
					}, this.isSticky = () => {
						const e = window.scrollY >= 100;
						this.setState({
							isFixed: e
						})
					}, this.toggleModal = (e, t) => () => {
						this.setState({
							userId: e,
							username: t
						}), this.props.isAddUserModalOpen || t || this.props.sendEventWithName("open_invite_dialog")(), this.props.toggleAddModeratorModal()
					}, this.onSearch = e => {
						this.props.searchForModerator(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.isButtonEnabled = (e, t) => !!(e && e.length > 0 && t), this.isModeratorsListPaginated = () => !(!this.props.nextBeforeToken && !this.props.nextAfterToken), this.renderEditableList = e => {
						const t = !(!e.nextBeforeEditableToken && !e.nextAfterEditableToken),
							n = e.isEditableListPending || e.isModeratorListPending;
						return i.a.createElement(i.a.Fragment, null, i.a.createElement(Ke, null, r.fbt._("You can edit these moderators", null, {
							hk: "1KTZtm"
						})), t && i.a.createElement(O.a, null, i.a.createElement(v.a, {
							prevButtonEnabled: this.isButtonEnabled(e.editableModeratorsList, e.nextBeforeEditableToken),
							prevTo: Object(c.a)(Object(p.a)(`${e.origin}${e.currentPageUrl}`), {
								before: e.before,
								beforeEditable: e.nextBeforeEditableToken,
								after: e.after
							}),
							nextButtonEnabled: this.isButtonEnabled(e.editableModeratorsList, e.nextAfterEditableToken),
							nextTo: Object(c.a)(Object(p.a)(`${e.origin}${e.currentPageUrl}`), {
								after: e.after,
								afterEditable: e.nextAfterEditableToken,
								before: e.before
							})
						})), i.a.createElement(Qe, null, e.editableModeratorsList && e.editableModeratorsList.length > 0 ? e.editableModeratorsList.map(e => i.a.createElement(be, {
							key: e.id,
							moderator: e,
							moderatorType: I.c.Editable,
							onClick: this.toggleModal(e.id, e.username),
							subredditId: this.props.subredditId
						})) : n ? i.a.createElement(Ye, null) : null))
					}, this.renderTopBar = e => i.a.createElement(x.c, {
						className: Object(l.a)(e && "bg-neutral-background mb-xs pr-0", Ge.a.topBar, {
							[Ge.a.default]: !e,
							[Ge.a.fixed]: this.state.isFixed
						})
					}, i.a.createElement(qe, {
						onClick: this.props.toggleResignAsModModal
					}, r.fbt._("Leave as mod", null, {
						hk: "3TwqTg"
					})), Object(j.a)(this.props.moderatorPermissions) && i.a.createElement(y.l, {
						onClick: this.toggleModal(null, null)
					}, r.fbt._("Invite user as mod", null, {
						hk: "3lJRJW"
					})))
				}
				componentDidMount() {
					this.props.isInvitePending && !this.props.isInvitePendingModalOpen && this.props.toggleInvitePendingModal(), this.props.isInShredditModNavExperiment && window.addEventListener("scroll", this.isSticky)
				}
				componentWillUnmount() {
					this.props.isInShredditModNavExperiment && window.removeEventListener("scroll", this.isSticky)
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = !!e.moderatorPermissions, o = Object(j.a)(e.moderatorPermissions);
					return i.a.createElement(i.a.Fragment, null, n && !e.isInShredditModNavExperiment && this.renderTopBar(), i.a.createElement(x.a, {
						className: Object(l.a)(e.isInShredditModNavExperiment && Ge.a.newModNavContainer)
					}, e.isInShredditModNavExperiment ? i.a.createElement(i.a.Fragment, null, Object(g.e)(e.subreddit.name, u.mc.Moderators), this.renderTopBar(!0)) : i.a.createElement(x.b, null, r.fbt._("Moderators of {subredditName}", [r.fbt._param("subredditName", e.subreddit.displayText)], {
						hk: "3p7NwA"
					}), i.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009381491`
					})), i.a.createElement(O.b, {
						onSearch: this.onSearch,
						activeSearchQuery: t.searchTerm
					}, !t.searchTerm && this.isModeratorsListPaginated() && i.a.createElement(v.a, {
						prevButtonEnabled: this.isButtonEnabled(e.moderatorsList, e.nextBeforeToken),
						prevTo: Object(c.a)(Object(p.a)(`${e.origin}${e.currentPageUrl}`), {
							afterEditable: e.afterEditable,
							before: e.nextBeforeToken,
							beforeEditable: e.beforeEditable
						}),
						nextButtonEnabled: this.isButtonEnabled(e.moderatorsList, e.nextAfterToken),
						nextTo: Object(c.a)(Object(p.a)(`${e.origin}${e.currentPageUrl}`), {
							after: e.nextAfterToken,
							afterEditable: e.afterEditable,
							beforeEditable: e.beforeEditable
						})
					})), t.searchTerm ? i.a.createElement(E.a, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && i.a.createElement(be, {
						moderator: e.searchResult,
						moderatorType: e.searchResult.isEditable ? I.c.Editable : void 0,
						onClick: e.searchResult.isEditable ? this.toggleModal(e.searchResult.id, e.searchResult.username) : void 0,
						subredditId: e.subredditId
					})) : i.a.createElement(i.a.Fragment, null, i.a.createElement(Qe, null, e.moderatorsList && e.moderatorsList.length > 0 ? e.moderatorsList.map(e => i.a.createElement(be, {
						key: e.id,
						moderator: e,
						subredditId: this.props.subredditId
					})) : e.isModeratorListPending ? i.a.createElement(Ye, null) : null), o && i.a.createElement(i.a.Fragment, null, this.renderEditableList(e), i.a.createElement(Oe, {
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId
					})))), e.isAddUserModalOpen && i.a.createElement($, {
						ignoreDefaultFocus: !0,
						after: e.afterEditable,
						before: e.beforeEditable,
						subredditId: e.subredditId,
						sendEventWithName: e.sendEventWithName,
						toggleModal: this.toggleModal(null, null),
						isEditingPerms: !!t.username,
						isEditingSelf: !(!t.userId || !e.currentUser) && t.userId === e.currentUser.id,
						username: t.username,
						user: t.userId && e.editableModerators ? e.editableModerators[t.userId] : null,
						withOverlay: !0,
						isModWithUserNotesPermissions: e.isModWithUserNotesPermissions
					}), e.currentUser && e.isResignAsModeratorModalOpen && i.a.createElement(Ue, {
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId,
						toggleModal: e.toggleResignAsModModal,
						userId: e.currentUser.id,
						withOverlay: !0
					}), e.isInvitePendingModalOpen && i.a.createElement(Ne, {
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId,
						toggleModal: e.toggleInvitePendingModal,
						withOverlay: !0
					}))
				}
			}
			t.a = We(Ve(Je))
		},
		"./src/reddit/components/MultiOptionSelect/OptionSearchBar/index.m.less": function(e, t, n) {
			e.exports = {
				optionSearchBarContainer: "_3eVrzdp5khbz6W2NhQv7kl",
				optionSearchBarError: "_3va8RfTnDLBo2hfMm5URpu",
				optionSearchBarReadOnly: "_2siJVLOBn72IxBt8i_A1gZ",
				loadingIcon: "_3UsfWdV2CKiIs_EOeGhVxv",
				input: "_1OEtZmrYX2ct3ycV1AaUZS",
				hiddenInput: "_3WSlf55CAQYRdOxtxENgA7",
				optionsOverflowIndication: "_2qfFc8Ix-QpBqu8UNEXeH3"
			}
		},
		"./src/reddit/components/MultiOptionSelect/OptionsListDropdown/index.m.less": function(e, t, n) {
			e.exports = {
				activeOption: "_2Kg5EXAuLcqhsBbdEr4SGZ",
				freeTextOption: "_2H29-4MOHAslt1eKYtcGaV",
				lastFixedOption: "_1ClyNNAK4vP9o_uoSwKe0Q",
				option: "_1xWVaijFIih7uj-n4FXzH2",
				availableOptionContainer: "T2jLhmuhOy8DeOHjz6WRG",
				addText: "_1OqThwyrfhl2eJ9YhWoy2I",
				optionsContainer: "_1ZmC1GBXYnksnMU9IrTAHd",
				relativeContainer: "_3SrGeaD5FxXfpWjhSAFBD-",
				dropdown: "_2dqCXnStO_Dc8Srt_lJqVj",
				dropdownHeaderText: "_2EaXrPilAtjz6VRh_xvOGU"
			}
		},
		"./src/reddit/components/MultiOptionSelect/SelectedOption/index.m.less": function(e, t, n) {
			e.exports = {
				selectedOptionComponentContainer: "_3nUaRUcJJfrvOWldA3i10S",
				closeIcon: "_1RvgsgnXdbtv2cwTTTbT7o",
				selectedOptionComponentContainerError: "_2Qpr0YORGp3CmDjJW9Txrf"
			}
		},
		"./src/reddit/components/MultiOptionSelect/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/some.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/constants/keycodes.ts"),
				c = n("./src/reddit/components/MultiOptionSelect/OptionsListDropdown/index.m.less"),
				l = n.n(c);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			class m extends i.a.Component {
				constructor() {
					super(...arguments), this.handleClick = () => {
						this.props.handleOptionSelected(this.props.index)
					}, this.handleMouseEnter = () => {
						this.props.handleOnMouseEnter(this.props.index)
					}
				}
				shouldComponentUpdate(e) {
					return e.className !== this.props.className || e.divRef !== this.props.divRef || e.displayText !== this.props.displayText
				}
				render() {
					const {
						addText: e,
						displayText: t,
						divRef: n,
						handleOnMouseEnter: s,
						handleOptionSelected: r,
						index: o,
						className: d,
						...c
					} = this.props;
					return i.a.createElement("div", u({
						className: Object(a.a)(l.a.availableOptionContainer, d)
					}, c, {
						onMouseEnter: this.handleMouseEnter,
						onClick: this.handleClick,
						ref: n
					}), e && i.a.createElement("span", {
						className: l.a.addText
					}, e, ""), t)
				}
			}
			class p extends i.a.Component {
				constructor(e) {
					super(e), this.handleOptionSelectedByIndex = e => {
						this.props.selectableOptions[e] && this.handleOptionSelected(this.props.selectableOptions[e])
					}, this.handleFreeTextOptionSelected = () => {
						this.handleOptionSelected({
							id: null,
							displayText: this.props.currentInput,
							selected: !0
						})
					}, this.clearSelectedIndex = () => {
						this.setSelectedIndex(-1)
					}, this.setOptionActiveByIndex = e => {
						"number" == typeof e && e > -1 && this.setSelectedIndex(e)
					}, this.setFreeTextOptionActive = () => {
						this.setSelectedIndex(this.getOptionsLength() - 1)
					}, this.state = {
						selectedIndex: -1
					}, this.scrollContainer = i.a.createRef(), this.optionsContainer = i.a.createRef(), this.activeOptionDOMRef = i.a.createRef()
				}
				focus() {
					this.optionsContainer.current && this.optionsContainer.current.focus()
				}
				matchesDOMElement(e) {
					return this.optionsContainer.current === e
				}
				handleOptionSelected(e) {
					this.handleOptionsSelected([e])
				}
				handleOptionsSelected(e) {
					this.props.onOptionsChanged(e.map(e => ({
						...e,
						selected: !0
					})))
				}
				setSelectedIndex(e) {
					this.setState({
						selectedIndex: e
					})
				}
				freeTextEntryActive() {
					return this.props.allowFreeTextEntry && this.props.currentInput
				}
				getOptionsLength() {
					return this.freeTextEntryActive() ? this.props.selectableOptions.length + 1 : this.props.selectableOptions.length
				}
				freeTextOptionSelected() {
					return this.freeTextEntryActive() && this.state.selectedIndex === this.getOptionsLength() - 1
				}
				validOptionSelected() {
					return this.state.selectedIndex > -1 && this.state.selectedIndex < this.getOptionsLength()
				}
				handlePaste(e) {
					if (e.clipboardData.types.includes("text/plain")) return e.preventDefault(), e.stopPropagation(), void this.handleOptionsSelected(e.clipboardData.getData("text/plain").split(d.b.Comma).filter(e => !!e).map(e => ({
						id: null,
						displayText: e.trim(),
						selected: !0
					})))
				}
				handleKeyPress(e) {
					const {
						splitOnCommaPress: t
					} = this.props;
					return e.which === d.a.ArrowUp ? (e.preventDefault(), e.stopPropagation(), this.setSelectedIndex(this.state.selectedIndex - 1 > -1 ? this.state.selectedIndex - 1 : this.getOptionsLength() - 1)) : e.which === d.a.ArrowDown ? (e.preventDefault(), e.stopPropagation(), this.setSelectedIndex(this.state.selectedIndex + 1 < this.getOptionsLength() ? this.state.selectedIndex + 1 : 0)) : e.which === d.a.Comma && t ? (e.preventDefault(), e.stopPropagation(), this.handleFreeTextOptionSelected()) : e.which === d.a.Enter ? (e.preventDefault(), e.stopPropagation(), !this.validOptionSelected() || this.freeTextOptionSelected() ? this.handleFreeTextOptionSelected() : this.handleOptionSelected(this.props.selectableOptions[this.state.selectedIndex])) : void 0
				}
				componentDidUpdate() {
					if (!this.activeOptionDOMRef.current || !this.scrollContainer.current) return;
					const e = this.activeOptionDOMRef.current.getBoundingClientRect(),
						t = this.scrollContainer.current.getBoundingClientRect();
					if (e.top < t.top || e.bottom > t.bottom) {
						if (0 === this.state.selectedIndex) return void(this.scrollContainer.current.scrollTop = 0);
						if (e.top < t.top) return void(this.scrollContainer.current.scrollTop = this.activeOptionDOMRef.current.offsetTop);
						this.scrollContainer.current.scrollTop += e.bottom - t.bottom
					}
				}
				shouldRenderDropdownHeaderText() {
					return !!this.props.dropdownHeaderText && (!this.freeTextEntryActive() || this.props.selectableOptions.length > 0)
				}
				render() {
					return i.a.createElement("div", {
						className: l.a.relativeContainer
					}, i.a.createElement("div", {
						className: Object(a.a)(l.a.dropdown, this.props.className),
						ref: this.scrollContainer
					}, i.a.createElement("div", {
						ref: this.optionsContainer,
						tabIndex: -1,
						className: l.a.optionsContainer,
						onMouseOut: this.clearSelectedIndex
					}, this.shouldRenderDropdownHeaderText() && i.a.createElement("h3", {
						className: l.a.dropdownHeaderText
					}, this.props.dropdownHeaderText), this.props.selectableOptions.map((e, t) => {
						const n = [this.state.selectedIndex === t ? l.a.activeOption : l.a.option];
						return this.freeTextEntryActive() && t === this.props.selectableOptions.length - 1 && n.push(l.a.lastFixedOption), i.a.createElement(m, {
							key: e.id,
							className: Object(a.a)(...n),
							index: t,
							handleOptionSelected: this.handleOptionSelectedByIndex,
							handleOnMouseEnter: this.setOptionActiveByIndex,
							divRef: t === this.state.selectedIndex ? this.activeOptionDOMRef : void 0,
							displayText: e.displayText
						})
					}), this.freeTextEntryActive() && i.a.createElement(m, {
						key: "options-list-dropdown-free-text-option",
						className: Object(a.a)(l.a.freeTextOption, this.state.selectedIndex === this.getOptionsLength() - 1 ? l.a.activeOption : l.a.option),
						handleOptionSelected: () => this.handleFreeTextOptionSelected(),
						handleOnMouseEnter: this.setFreeTextOptionActive,
						divRef: this.getOptionsLength() - 1 === this.state.selectedIndex ? this.activeOptionDOMRef : void 0,
						addText: this.props.addText,
						displayText: this.props.currentInput
					}))))
				}
			}
			var b = n("./src/reddit/icons/svgs/Close/index.tsx"),
				f = n("./src/reddit/components/MultiOptionSelect/SelectedOption/index.m.less"),
				h = n.n(f);

			function g() {
				return (g = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var v = e => {
					const {
						className: t,
						innerRef: n,
						onClickHandler: s,
						option: r,
						maxLength: o,
						...d
					} = e, c = [h.a.selectedOptionComponentContainer, t];
					return o && o < r.displayText.length && c.push(h.a.selectedOptionComponentContainerError), i.a.createElement("div", g({
						className: Object(a.a)(...c),
						ref: n
					}, d, {
						onClick: s
					}), r.displayText, i.a.createElement(b.a, {
						className: h.a.closeIcon
					}))
				},
				x = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				E = n("./src/reddit/helpers/readOnlyMode/index.ts"),
				O = n("./src/reddit/components/MultiOptionSelect/OptionSearchBar/index.m.less"),
				C = n.n(O);

			function A() {
				return (A = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const y = 10,
				j = e => e.stopPropagation();
			class I extends i.a.Component {
				constructor(e) {
					super(e), this.handleKeyPress = e => {
						e.which !== d.a.Delete && e.which !== d.a.Backspace || !this.lastSelectedOptionComponentRef.current || "" !== this.props.value || (this.lastSelectedOptionComponentRef.current.focus(), e.preventDefault(), e.stopPropagation())
					}, this.handleMouseEnterSelectedOptionComponent = () => {
						this.setState({
							isHoveringOverSelectedOption: !0
						})
					}, this.handleMouseLeaveSelectedOptionComponent = () => {
						this.setState({
							isHoveringOverSelectedOption: !1
						})
					}, this.onSearchBarFocus = e => {
						Object(E.c)(this.props.readOnlyMode) || (this.inputRef.current && this.inputRef.current.focus(), this.setState({
							isFocused: !0
						}), this.props.onFocus && this.inputRef.current === e.target && this.props.onFocus())
					}, this.onSearchBarBlur = e => {
						if (this.containerRef.current && e.relatedTarget && this.containerRef.current.contains(e.relatedTarget)) return e.preventDefault(), void e.stopPropagation();
						this.props.onBlur && this.props.onBlur(e), this.setState({
							isFocused: !1
						})
					}, this.inputRef = i.a.createRef(), this.containerRef = i.a.createRef(), this.lastSelectedOptionComponentRef = i.a.createRef(), this.state = {
						isHoveringOverSelectedOption: !1,
						isFocused: !1
					}
				}
				focus() {
					Object(E.c)(this.props.readOnlyMode) || (this.inputRef.current && this.inputRef.current.focus(), this.setState({
						isFocused: !0
					}))
				}
				reset() {
					this.inputRef.current && (this.inputRef.current.value = "")
				}
				deselectOption(e) {
					this.props.onOptionsChanged([{
						...e,
						selected: !1
					}]), this.setState({
						isHoveringOverSelectedOption: !1
					})
				}
				onSelectedOptionComponentKeyDown(e, t) {
					this.state.isHoveringOverSelectedOption || e.which !== d.a.Delete && e.which !== d.a.Backspace || (e.preventDefault(), e.stopPropagation(), this.deselectOption(t), this.focus())
				}
				render() {
					const e = {};
					Object(E.c)(this.props.readOnlyMode) || (e.tabIndex = 0);
					const t = this.props.selectedOptionComponent || v,
						n = "number" == typeof this.props.maxOptionsToDisplay && this.props.options.length > this.props.maxOptionsToDisplay;
					return i.a.createElement("div", A({
						"aria-invalid": this.props.isError,
						className: Object(a.a)(this.props.className, C.a.optionSearchBarContainer, {
							[C.a.optionSearchBarError]: this.props.isError,
							[C.a.optionSearchBarReadOnly]: Object(E.c)(this.props.readOnlyMode)
						}),
						ref: this.containerRef,
						onFocus: this.onSearchBarFocus,
						onBlur: this.onSearchBarBlur
					}, e), this.props.options.map((e, s) => {
						if (!(n && s >= (this.props.maxOptionsToDisplay || 0))) return i.a.createElement(t, {
							tabIndex: 0,
							onFocus: j,
							key: e.id || e.displayText,
							option: e,
							onKeyDown: t => this.onSelectedOptionComponentKeyDown(t, e),
							onClickHandler: () => {
								this.deselectOption(e), this.focus()
							},
							onMouseEnter: this.handleMouseEnterSelectedOptionComponent,
							onMouseLeave: this.handleMouseLeaveSelectedOptionComponent,
							maxLength: this.props.maxLength,
							innerRef: s === this.props.options.length - 1 ? this.lastSelectedOptionComponentRef : void 0
						})
					}), n && i.a.createElement("span", {
						className: C.a.optionsOverflowIndication
					}, `+${this.props.options.length-(this.props.maxOptionsToDisplay||0)}`), this.props.children, !Object(E.c)(this.props.readOnlyMode) && i.a.createElement("input", {
						className: Object(a.a)(C.a.input, {
							[C.a.hiddenInput]: Object(E.b)(this.props.readOnlyMode)
						}),
						ref: this.inputRef,
						type: "text",
						onKeyDown: this.handleKeyPress,
						value: this.props.value,
						onChange: this.props.onInputChanged,
						maxLength: this.props.maxLength
					}), this.props.isLoading && i.a.createElement(x.a, {
						className: C.a.loadingIcon,
						sizePx: y
					}), this.state.isFocused && i.a.createElement(p, {
						className: this.props.dropdownClassName,
						dropdownHeaderText: this.props.dropdownHeaderText,
						addText: this.props.addText,
						selectableOptions: this.props.selectableOptions,
						onOptionsChanged: this.props.onOptionsChanged,
						ref: this.props.dropdownRef,
						currentInput: this.props.value,
						allowFreeTextEntry: this.props.allowFreeTextEntry,
						splitOnCommaPress: this.props.splitOnCommaPress
					}))
				}
			}
			var k = n("./node_modules/reselect/es/index.js");
			const _ = [],
				S = {};
			class w extends i.a.Component {
				constructor(e) {
					super(e), this._selectableOptionsSelector = Object(k.a)(e => e.availableOptions || _, e => e.input, (e, t) => e.filter(e => {
						const n = e.displayText.toLowerCase(),
							s = t.toLowerCase();
						return 0 === n.indexOf(s) || r()(n.split(/[\s\/]+/), e => 0 === e.indexOf(s))
					})), this.onSearchBarFocus = () => {
						Object(E.c)(this.props.readOnlyMode) || this.state.searchBarIsFocused || (this.setState({
							searchBarIsFocused: !0
						}), this.props.onSearchBarFocus && this.props.onSearchBarFocus())
					}, this.onSearchBarBlur = e => {
						if (!Object(E.c)(this.props.readOnlyMode)) return e.relatedTarget && this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.matchesDOMElement(e.relatedTarget) ? (e.stopPropagation(), e.preventDefault(), void setTimeout(() => {
							this.optionSearchBarRef.current && this.optionSearchBarRef.current.focus()
						}, 0)) : (this.setState({
							searchBarIsFocused: !1
						}), void(this.props.onSearchBarBlur && this.props.onSearchBarBlur(e)))
					}, this.setInput = e => {
						Object(E.b)(this.props.readOnlyMode) || this.props.input !== e && this.props.onInputChanged(e)
					}, this.onOptionChanged = e => {
						this.onOptionsChanged([e])
					}, this.onOptionsChanged = e => {
						this.props.onOptionsChanged(e), r()(e, e => !!e.selected) && this.setInput("")
					}, this.onInputChanged = e => {
						Object(E.b)(this.props.readOnlyMode) || this.setInput(e.currentTarget.value)
					}, this.onKeyDown = e => {
						Object(E.b)(this.props.readOnlyMode) || this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.handleKeyPress(e)
					}, this.onPaste = e => {
						Object(E.b)(this.props.readOnlyMode) || this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.handlePaste(e)
					}, this.state = {
						searchBarIsFocused: !1
					}, this.optionsListDropdownRef = i.a.createRef(), this.optionSearchBarRef = i.a.createRef()
				}
				getSelectableOptions() {
					return this._selectableOptionsSelector(this.props)
				}
				render() {
					const {
						childClassNames: e = S
					} = this.props;
					return i.a.createElement("div", {
						className: this.props.className,
						onKeyDown: this.onKeyDown,
						onPaste: this.onPaste
					}, i.a.createElement(I, {
						className: e.searchBarClassName,
						dropdownClassName: e.optionsListDropdownClassName,
						isError: this.props.isError,
						readOnlyMode: this.props.readOnlyMode || E.a.editable,
						isLoading: this.props.isLoading,
						ref: this.optionSearchBarRef,
						options: this.props.selectedOptions,
						onFocus: this.onSearchBarFocus,
						onBlur: this.onSearchBarBlur,
						onOptionsChanged: this.onOptionsChanged,
						onInputChanged: this.onInputChanged,
						maxLength: this.props.maxOptionLength,
						maxOptionsToDisplay: this.props.maxOptionsToDisplay,
						value: this.props.input,
						dropdownHeaderText: this.props.dropdownHeaderText,
						addText: this.props.addText,
						allowFreeTextEntry: this.props.allowFreeTextEntry,
						selectableOptions: this.getSelectableOptions(),
						dropdownRef: this.optionsListDropdownRef,
						selectedOptionComponent: this.props.selectedOptionComponent,
						splitOnCommaPress: this.props.splitOnCommaPress
					}, this.props.children))
				}
			}
			t.a = w
		},
		"./src/reddit/components/MutedUserList/ExpandedComponent.m.less": function(e, t, n) {
			e.exports = {
				BannedBy: "_2004IKQq9AjT3xoiDBg7m_",
				bannedBy: "_2004IKQq9AjT3xoiDBg7m_",
				EmptyState: "_1O-zxip2q_mFxBe_WVFPZC",
				emptyState: "_1O-zxip2q_mFxBe_WVFPZC",
				ExpandedContainer: "_1EEdKUOD4OiTBBQQkot-L9",
				expandedContainer: "_1EEdKUOD4OiTBBQQkot-L9"
			}
		},
		"./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "_16-AoomiQ2Zxycd1wA0ZL-",
				primaryButton: "_16-AoomiQ2Zxycd1wA0ZL-",
				ModalText: "_3P1niYqJc2au-fmA-xIl7i",
				modalText: "_3P1niYqJc2au-fmA-xIl7i"
			}
		},
		"./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/higherOrderComponents/asModal/index.tsx"),
				d = n("./src/lib/lessComponent.tsx"),
				c = n("./src/reddit/actions/subredditModeration/mute.ts"),
				l = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				u = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				m = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				b = n("./src/reddit/controls/TextButton/index.tsx"),
				f = n("./src/reddit/helpers/isValidUsername/index.tsx"),
				h = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				g = n("./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.m.less"),
				v = n.n(g);
			const x = 300,
				E = Object(i.b)(null, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						onMuteUser: (t, s) => e(Object(c.a)(n, t, s))
					}
				}),
				O = d.a.wrapped(p.l, "PrimaryButton", v.a),
				C = d.a.wrapped(u.p, "ModalText", v.a);
			class A extends o.a.Component {
				constructor(e) {
					super(e), this.onUsernameChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.onReasonChange = e => {
						this.setState({
							reason: e.currentTarget.value
						})
					}, this.onSubmit = () => {
						const e = this.state.username;
						this.props.onMuteUser(e, this.state.reason), this.props.trackAddEvent(), this.props.toggleModal()
					}, this.state = {
						username: this.props.username || "",
						reason: ""
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return o.a.createElement(u.e, null, o.a.createElement(u.i, null, o.a.createElement(h.a, null, o.a.createElement(u.q, null, s.fbt._("Mute user", null, {
						hk: "326ljo"
					}), e.username && `: u/${e.username}`), o.a.createElement(b.a, {
						onClick: e.toggleModal
					}, o.a.createElement(u.b, null)))), o.a.createElement(u.l, null, !e.username && o.a.createElement(u.h, null, o.a.createElement(m.d, {
						autoFocus: !0,
						placeholder: s.fbt._("Username to mute", null, {
							hk: "3GB7UW"
						}),
						onChange: this.onUsernameChange,
						value: this.state.username,
						"data-redditstyle": !0
					})), o.a.createElement(u.h, null, o.a.createElement(C, null, s.fbt._("Note about why they are muted", null, {
						hk: "12YIn5"
					})), o.a.createElement(u.f, null, s.fbt._("Only visible to other moderators. Not visible to user", null, {
						hk: "4Ahum2"
					}))), o.a.createElement(u.t, {
						maxLength: x,
						onChange: this.onReasonChange,
						placeholder: s.fbt._("Reason they were muted", null, {
							hk: "3E29Hf"
						}),
						value: this.state.reason,
						"data-redditstyle": !0
					}), o.a.createElement(l.a, {
						maxChars: x,
						text: this.state.reason
					})), o.a.createElement(u.g, null, o.a.createElement(u.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), o.a.createElement(O, {
						onClick: this.onSubmit,
						"data-redditstyle": !0,
						disabled: !e.username && !Object(f.a)(t.username)
					}, s.fbt._("Mute user", null, {
						hk: "1z1Ss8"
					}))))
				}
			}
			t.default = Object(a.a)(E(A))
		},
		"./src/reddit/components/MutedUserList/MuteUserModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx"),
				r = n("./src/lib/loadWithRetries/index.ts");
			const o = () => null;
			t.a = Object(s.a)({
				ErrorComponent: o,
				getComponent: () => Object(r.a)(() => Promise.all([n.e("vendors~CryptoHarbergerTaxManageModal~HarbergerTaxManageModal~ModerationPages~PostCreation~Settings~~f8934a85"), n.e("vendors~CommentsPage~ModerationPages~Reddit~reddit-components-ClassicPost~reddit-components-CompactP~d737df3e"), n.e("vendors~CommentsPage~Governance~ModListing~ModerationPages~Reddit~Subreddit"), n.e("vendors~ModerationPages"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~FramedGild~GildModal~GovernanceReleaseNotesModal~Hap~a5d6a3b8"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~FramedGild~GildModal~GovernanceReleaseNotesModal~Hap~cb450973"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~Frontpage~GovernanceReleaseNotesModal~ModListing~Mod~e3d63e32"), n.e("CollectionCommentsPage~CommentsPage~EconTopAwardersModal~ModQueuePages~ModerationPages~PostCreation~~bca2b657"), n.e("CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~ModerationPages~PostCreation~Profile~9a5d9fab"), n.e("ModerationPages")]).then(n.bind(null, "./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.tsx"))).then(e => e.default),
				LoadingComponent: o
			})
		},
		"./src/reddit/components/MutedUserList/index.m.less": function(e, t, n) {
			e.exports = {
				MuteIcon: "XHViv8EEjdjsATc3T66r9",
				muteIcon: "XHViv8EEjdjsATc3T66r9",
				border: "_1ptBYUtDChhG6xxdiztj9f",
				newModNavContainer: "_2ZxI5KSLFvpyVO9nZz6bSY",
				topBar: "_2mmaf-YXKOha4mLs2tc7pi",
				fixed: "_8Etg1FnbST9io6w_mES_G",
				default: "_37TZO7Ma-NxHOHFVGqMQRM"
			}
		},
		"./src/reddit/components/MutedUserList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/subredditModeration/mute.ts"),
				p = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				b = n("./src/reddit/components/HumanDate/index.tsx"),
				f = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				h = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				g = n("./src/reddit/components/ModHub/NewModNav/PageLinks.tsx"),
				v = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				x = n("./src/reddit/components/Scroller/Simple.tsx"),
				E = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				O = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				C = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				A = n("./src/reddit/controls/Button/index.tsx"),
				y = n("./src/reddit/icons/fonts/index.tsx"),
				j = n("./src/reddit/models/SubredditModeration/index.ts"),
				I = n("./src/reddit/selectors/activeModalId.ts"),
				k = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				_ = n("./src/reddit/selectors/muted.ts"),
				S = n("./src/reddit/components/MutedUserList/ExpandedComponent.m.less"),
				w = n.n(S),
				T = n("./src/lib/lessComponent.tsx");
			const {
				fbt: P
			} = n("./node_modules/fbt/lib/FbtPublic.js"), N = T.a.span("BannedBy", w.a), D = T.a.span("EmptyState", w.a), M = T.a.div("ExpandedContainer", w.a);
			var R = e => i.a.createElement(M, null, e.reason ? i.a.createElement(N, null, P._("Mod note {mutedByUsername}", [P._param("mutedByUsername", e.mutedBy)], {
					hk: "15D34v"
				})) : i.a.createElement(D, null, P._("No mod note.", null, {
					hk: "3rpIuv"
				})), e.reason),
				L = n("./src/reddit/components/MutedUserList/MuteUserModal/index.tsx"),
				B = n("./src/reddit/components/MutedUserList/index.m.less"),
				F = n.n(B);
			const U = 24,
				H = Object(d.c)({
					isAddUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(I.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--RemoveUserConfirmation" === Object(I.a)(e),
					loadMoreToken: _.d,
					mutedUsers: _.g,
					mutedUsersListPending: _.c,
					searchPending: _.e,
					searchResult: _.f,
					isInShredditModNavExperiment: (e, t) => {
						let {
							moderatorPermissions: n
						} = t;
						return Object(k.a)(e, !!n)
					}
				}),
				G = Object(a.b)(H, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						loadMore: t => e(Object(m.b)(n, {
							after: t
						})),
						searchForMutedUser: t => e(Object(m.c)(n, t)),
						toggleAddUserModal: () => e(Object(u.i)("ModerationPage--Modal--AddUser")),
						toggleUnmuteUserModal: () => e(Object(u.i)("ModerationPage--Modal--RemoveUserConfirmation")),
						unmuteUser: t => () => e(Object(m.d)(n, t))
					}
				});
			class Q extends i.a.Component {
				constructor(e) {
					super(e), this.isSticky = () => {
						const e = window.scrollY >= 100;
						this.setState({
							isFixed: e
						})
					}, this.onSearch = e => {
						this.props.searchForMutedUser(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.unmuteToggled = (e, t) => () => {
						this.setState({
							userId: e,
							username: t
						}), this.props.sendEventWithName("edit_user")(), this.props.toggleUnmuteUserModal()
					}, this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.muteUser = () => {
						this.props.toggleAddUserModal(), this.props.sendEventWithName("mute_dialog_mutepage")()
					}, this.renderMutedUser = e => i.a.createElement(C.b, {
						description: e.reason,
						expandedComponent: i.a.createElement(R, {
							mutedBy: e.mutedBy,
							reason: e.reason
						}),
						pageName: l.mc.Muted,
						primaryButton: i.a.createElement(A.r, {
							onClick: this.unmuteToggled(e.id, e.username)
						}, r.fbt._("Unmute", null, {
							hk: "334kKM"
						})),
						subredditId: this.props.subredditId,
						timeAgo: i.a.createElement(b.d, {
							seconds: e.mutedAtUTC
						}),
						userIcon: e.accountIcon,
						username: e.username
					}), this.renderMuteUserModal = () => i.a.createElement(L.a, {
						ignoreDefaultFocus: !0,
						trackAddEvent: this.props.sendEventWithName("add_mutepage"),
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddUserModal,
						withOverlay: !0
					}), this.renderTopBar = e => i.a.createElement(v.c, {
						className: Object(c.a)(e && "bg-neutral-background mb-xs pr-0", F.a.topBar, {
							[F.a.default]: !e,
							[F.a.fixed]: this.state.isFixed
						})
					}, i.a.createElement(A.l, {
						onClick: this.muteUser
					}, r.fbt._("Mute user", null, {
						hk: "4AJ7nf"
					}))), this.state = {
						...j.a,
						isFixed: !this.props.isInShredditModNavExperiment
					}
				}
				componentDidMount() {
					this.props.isInShredditModNavExperiment && window.addEventListener("scroll", this.isSticky)
				}
				componentWillUnmount() {
					this.props.isInShredditModNavExperiment && window.removeEventListener("scroll", this.isSticky)
				}
				render() {
					const {
						props: e,
						state: t
					} = this, {
						mutedUsers: n
					} = e;
					let o;
					return n.length && (o = n[n.length - 1].id), e.mutedUsers.length ? i.a.createElement(i.a.Fragment, null, !e.isInShredditModNavExperiment && this.renderTopBar(), i.a.createElement(v.a, {
						className: e.isInShredditModNavExperiment ? F.a.newModNavContainer : void 0
					}, e.isInShredditModNavExperiment ? i.a.createElement(i.a.Fragment, null, Object(g.e)(e.subreddit.name, l.mc.Muted), this.renderTopBar(!0)) : i.a.createElement(v.b, null, r.fbt._("Muted users", null, {
						hk: "2kc6Jt"
					}), i.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009161872`
					})), i.a.createElement(O.b, {
						onSearch: this.onSearch,
						activeSearchQuery: t.searchTerm
					}), t.searchTerm ? i.a.createElement(E.a, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && this.renderMutedUser(e.searchResult)) : i.a.createElement(x.b, {
						className: F.a.border,
						loadMoreToken: o,
						onLoadMore: this.onLoadMore
					}, e.mutedUsers.map((e, t) => ({
						estHeight: U,
						id: e.id,
						render: () => this.renderMutedUser(e)
					})))), e.isAddUserModalOpen && this.renderMuteUserModal(), e.isConfirmModalOpen && t.userId && t.username && i.a.createElement(p.a, {
						actionText: r.fbt._("Unmute", null, {
							hk: "334kKM"
						}),
						modalText: r.fbt._("Are you sure you want to unmute {username}?", [r.fbt._param("username", t.username)], {
							hk: "2Pq8hv"
						}),
						onConfirm: e.unmuteUser(t.userId),
						toggleModal: e.toggleUnmuteUserModal,
						trackClick: e.sendEventWithName("remove"),
						withOverlay: !0
					})) : i.a.createElement(i.a.Fragment, null, !e.isInShredditModNavExperiment && this.renderTopBar(), i.a.createElement(v.a, {
						className: e.isInShredditModNavExperiment ? F.a.newModNavContainer : void 0
					}, e.isInShredditModNavExperiment ? i.a.createElement(i.a.Fragment, null, Object(g.e)(e.subreddit.name, l.mc.Muted), this.renderTopBar(!0)) : i.a.createElement(v.b, null, r.fbt._("Muted users", null, {
						hk: "2kc6Jt"
					}), i.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009161872`
					})), e.mutedUsersListPending ? i.a.createElement(C.a, null) : i.a.createElement(f.c, {
						className: F.a.border,
						text: r.fbt._("No muted users in {subredditName}", [r.fbt._param("subredditName", e.subreddit.displayText)], {
							hk: "1o0lOP"
						})
					}, i.a.createElement(y.a, {
						name: "mod_mute",
						className: F.a.MuteIcon
					})), e.isAddUserModalOpen && this.renderMuteUserModal()))
				}
			}
			t.a = G(Q)
		},
		"./src/reddit/components/NotificationUnit/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "NotificationUnit",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("NotificationUnit").then(n.bind(null, "./src/reddit/components/NotificationUnit/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/NotificationUnit/index.tsx"
				}
			});
			t.a = r
		},
		"./src/reddit/components/NotificationUnit/Placeholder.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/NotificationUnit/index.m.less"),
				i = n.n(o);
			const a = () => r.a.createElement("li", {
					className: i.a.placeholderWrapper
				}, r.a.createElement("span", {
					className: i.a.placeholderAvatar
				}), r.a.createElement("span", {
					className: i.a.placeholderContent
				})),
				d = () => r.a.createElement("ol", null, r.a.createElement(a, null), r.a.createElement(a, null), r.a.createElement(a, null))
		},
		"./src/reddit/components/NotificationUnit/index.m.less": function(e, t, n) {
			e.exports = {
				notificationItem: "_3mUSJN4kdLCGjq-K-JLJw",
				unread: "_2n4UrzwZ3VBdRmFUYAHF_9",
				isNightMode: "_3ds5pVvIyBrh1GgQ2O7AFd",
				contextContainer: "_3T3J7R8JnlSfiFdB5bxe5h",
				link: "_1tpiOc0IxpDU113wUs4zi1",
				inAppNotification: "_3U799isaNx88b2pVv1S7m1",
				avatarContainer: "_2WN4-UdVoyjpLQ8mpNTQA",
				avatar: "_12V0IULSx8mSJHxdpHwOGE",
				nsfwAvatar: "_1Bzw8F6BC4Vk8OzAgnU0z3",
				notificationIconContainer: "_3smo-GSstogGTGh6ArpwI0",
				NotifIcon: "OzS9DxR-g3V71ZAeo2lbH",
				notifIcon: "OzS9DxR-g3V71ZAeo2lbH",
				RedditorIcon: "_23rEnykeBXjpsB9b72y8_1",
				redditorIcon: "_23rEnykeBXjpsB9b72y8_1",
				Separator: "_1caKsZ5CCRPSfIgoh608Ej",
				separator: "_1caKsZ5CCRPSfIgoh608Ej",
				topBar: "_3mGSd8RyCZhF_eqyrV_Bvk",
				TitleWrapper: "_3D7vaSdKwBK4pdvYmH0ib",
				titleWrapper: "_3D7vaSdKwBK4pdvYmH0ib",
				title: "_180jOSBDwwE60X5UR8zt3-",
				"m-tooltip": "_2a8MIP8QlMF7KPqTup62Vt",
				mTooltip: "_2a8MIP8QlMF7KPqTup62Vt",
				timeAgo: "_2fQXbzOYQuzqlwMzxgtBKH",
				menuButton: "_8Q653FSGz7lD9Ux0AQsXY",
				isOpen: "WHFiF_asC8mzlevTdJv26",
				MenuIcon: "_2oVe02cXZA6mJa7WXHJFi5",
				menuIcon: "_2oVe02cXZA6mJa7WXHJFi5",
				contentContainer: "_3Q_e75oXJ8meqWwAQS36l2",
				body: "_2VDnxV3G5ZvEDq10Z-_fM9",
				ButtonIcon: "_25ecrisK-bGTesa4kIqyHR",
				buttonIcon: "_25ecrisK-bGTesa4kIqyHR",
				ReplyButtonIcon: "_1wAIwQaxmGHWzaHv-8jex_",
				replyButtonIcon: "_1wAIwQaxmGHWzaHv-8jex_",
				notificationButton: "_3doOacPPJ-LU-aBSoLl9TV",
				isFullWidth: "_36xH7NkS9uRrlN87iMo6Bw",
				isUnread: "_2svu3lh5YfWQmYfACdB2J5",
				replyIcon: "_3LbCSOW9yuZK_CHzTuR9M5",
				postIcon: "_102yZEdZMcXLlu2Ri0KD9O",
				postEmbedContainer: "_1cndvAxAFPMUr8IaWuw_we",
				postEmbedContent: "_2fsQOzhZpW9XNu1RXtgzqW",
				deleted: "LypGzp3NJwjpkpsRn9Ocn",
				postEmbedTitleContainer: "_2XT3C7unUlQXgaiyeYfIYv",
				postEmbedTitle: "_1SZwyv3jy4dBipT0yC1CcI",
				postEmbedMeta: "_1LcCO3y9JhylZFlKsgvzHs",
				postEmbedBlurredThumbnailContainer: "_2EmrjrpYxkgB5_ljritGbO",
				postEmbedThumbnail: "msJLWFmahK0W8JhaqYny9",
				postEmbedThumbnailBase: "_3CGVcVQDu97m9Oj_xs0n01",
				postEmbedBlurredThumbnail: "_2a0rc3KL05PEnGmVWcQI8W",
				postEmbedNSFWThumbnailIndicator: "_2q-yvZHWG3Xp2YECYCI09S",
				postEmbedNsfwThumbnailIndicator: "_2q-yvZHWG3Xp2YECYCI09S",
				WarningIcon: "_2PzKGDccrg-BWzhhzJaJTs",
				warningIcon: "_2PzKGDccrg-BWzhhzJaJTs",
				StyledDropdown: "_1i_9WvxHOe7AlJZQ6w_-X9",
				styledDropdown: "_1i_9WvxHOe7AlJZQ6w_-X9",
				overflowMenuContainer: "_2UKt6pQu-os9uxZnfhPydP",
				overflowMenuOption: "_1g8x_Z2KsTf65RBk7dRBZm",
				placeholderWrapper: "_2iacm7sPgvO9z8gO1W7FoY",
				placeholderAvatar: "_2_cDiTNVpitX7CtTmIambB",
				placeholderContent: "_2KpinIkIJ7VxNGQgUgzJCA",
				glimmer: "_27pfB7o_o_4F4TdujFhrNO",
				PostUnavailableInfo: "_2lh6HxiG9gd6MKnaAag9Cu",
				postUnavailableInfo: "_2lh6HxiG9gd6MKnaAag9Cu",
				StateIcon: "_2RPeGp2zLx2hBQTZWSUTQK",
				stateIcon: "_2RPeGp2zLx2hBQTZWSUTQK",
				Text: "_2bba9zuFqUwxMhGdswkU86",
				text: "_2bba9zuFqUwxMhGdswkU86"
			}
		},
		"./src/reddit/components/OneFeed/PostRecommendationContext.m.less": function(e, t, n) {
			e.exports = {
				RecommendationContextStyles: "nAL34ZVf4KfyEoZIzUgmN",
				recommendationContextStyles: "nAL34ZVf4KfyEoZIzUgmN",
				classicLayout: "_3gsfwiq-rM6zSz9YoMlnJ0",
				compactLayout: "_9huHAs0mdMzeF-pUhJbwX",
				largeLayout: "_3hWVRt6y8PqOoC2VuZETZI"
			}
		},
		"./src/reddit/components/OneFeed/PostRecommendationContext.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/objectSelector/index.ts"),
				a = n("./src/reddit/components/RichTextJson/index.tsx"),
				d = n("./src/reddit/constants/postLayout.ts"),
				c = n("./src/reddit/hooks/useRecommendationPostContext.ts"),
				l = n("./src/reddit/components/OneFeed/PostRecommendationContext.m.less"),
				u = n.n(l);
			const m = Object(i.b)(e => ({
				renderingObjectInfo: e
			}));
			t.a = e => {
				let {
					content: t,
					layout: n,
					post: s
				} = e;
				return Object(c.a)().hideRecommendationContext ? null : r.a.createElement(a.b, {
					className: Object(o.a)(u.a.RecommendationContextStyles, {
						[u.a.classicLayout]: n === d.g.Classic,
						[u.a.compactLayout]: n === d.g.Compact,
						[u.a.largeLayout]: n === d.g.Large
					}),
					content: t,
					rtJsonElementProps: m(s),
					useExplicitTextColor: !0
				})
			}
		},
		"./src/reddit/components/OverflowMenu/index.m.less": function(e, t, n) {
			e.exports = {
				_Dropdown: "ehsOqYO6dxn_Pf9Dzwu37",
				dropdown: "ehsOqYO6dxn_Pf9Dzwu37",
				MenuButton: "_2pFdCpgBihIaYh9DSMWBIu",
				menuButton: "_2pFdCpgBihIaYh9DSMWBIu",
				mIsEnabled: "uMPgOFYlCc5uvpa2Lbteu",
				MenuIcon: "_38GxRFSqSC-Z2VLi5Xzkjy",
				menuIcon: "_38GxRFSqSC-Z2VLi5Xzkjy",
				DropdownRow: "_2DO72U0b_6CUw3msKGrnnT",
				dropdownRow: "_2DO72U0b_6CUw3msKGrnnT"
			}
		},
		"./src/reddit/components/OverflowMenu/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return C
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				m = n("./src/reddit/controls/Dropdown/index.tsx"),
				p = n("./src/reddit/controls/Dropdown/Row.tsx"),
				b = n("./src/reddit/icons/fonts/index.tsx"),
				f = n("./src/reddit/selectors/tooltip.ts"),
				h = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				g = n("./src/reddit/components/OverflowMenu/index.m.less"),
				v = n.n(g);
			const x = c.a.wrapped(m.a, "_Dropdown", v.a),
				E = Object(u.a)(x),
				O = c.a.button("MenuButton", v.a),
				C = c.a.wrapped(p.b, "DropdownRow", v.a),
				A = Object(a.c)({
					dropdownIsOpen: (e, t) => {
						let {
							dropdownId: n
						} = t;
						return Object(f.b)(n)(e)
					}
				}),
				y = Object(i.b)(A, (e, t) => {
					let {
						dropdownId: n
					} = t;
					return {
						toggleDropdown: () => e(Object(l.h)({
							tooltipId: n
						}))
					}
				}),
				j = e => t => {
					e.onClick && e.onClick(), e.toggleDropdown(), t.stopPropagation()
				};
			t.b = y(e => o.a.createElement(O, {
				"aria-expanded": e.dropdownIsOpen,
				"aria-haspopup": !0,
				"aria-label": s.fbt._("more options", null, {
					hk: "2EnY1x"
				}),
				className: Object(d.a)(e.className, {
					[v.a.mIsEnabled]: !e.disabled && !e.defaultButtonOutline
				}),
				disabled: e.disabled,
				onClick: j(e),
				onMouseDown: e.handleMouseDown,
				id: e.dropdownId,
				"data-adclicklocation": h.b.OVERFLOW_MENU
			}, e.icon ? e.icon : o.a.createElement(b.a, {
				name: "overflow_horizontal",
				className: v.a.MenuIcon
			}), o.a.createElement(E, {
				className: e.dropdownClassName,
				isOpen: e.dropdownIsOpen,
				tooltipId: e.dropdownId,
				isFixed: e.isFixed,
				targetPosition: e.targetPosition,
				tooltipPosition: e.tooltipPosition,
				style: e.style
			}, e.children)))
		},
		"./src/reddit/components/OverlayAwareTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/asTooltip.tsx"),
				i = n("./src/reddit/constants/elementIds.ts"),
				a = n("./src/reddit/contexts/InsideOverlay.tsx");

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function c(e, t) {
				const n = Object(o.a)(e, t);
				class s extends r.a.PureComponent {
					constructor() {
						super(...arguments), this.state = {
							container: null
						}
					}
					componentDidMount() {
						if (this.props.isOverlay) {
							const e = document.getElementById(i.e);
							this.setState({
								container: e
							})
						}
					}
					render() {
						return r.a.createElement(n, d({}, this.props, {
							container: this.state.container || this.props.container,
							excludeContainerPosition: this.props.isOverlay
						}))
					}
				}
				return Object(a.b)(s)
			}
		},
		"./src/reddit/components/PaginationButtons/index.m.less": function(e, t, n) {
			e.exports = {
				buttonContainer: "_1kLu6euoyZ3I2dqDVrxoZD",
				routerLink: "_3k7SslJt4xhPIXKtoe8DFf",
				mDisabled: "_1VgBJV1BqaXyZVPBXEv-KC"
			}
		},
		"./src/reddit/components/Paginator/index.m.less": function(e, t, n) {
			e.exports = {
				controlRow: "_2ixigr45sqDsYvVlMBgbMm",
				nextButtonContainer: "CloCv22o0KvzOk8LzB4VX",
				prevButtonContainer: "_2Tfdm_mlb1NvgbaCCkMtdV",
				nextButton: "_1VFGYMJpiKtL_S9_RYS-CD",
				prevButton: "eX92mTA_HDG9gpfIzIGhs"
			}
		},
		"./src/reddit/components/Poll/PollExpiry/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/components/HumanDate/index.tsx"),
				o = n("./src/lib/timeUntil/index.ts"),
				i = n("./node_modules/react/index.js"),
				a = n.n(i);
			const {
				fbt: d
			} = n("./node_modules/fbt/lib/FbtPublic.js");

			function c(e) {
				const t = new Date(e.poll.endsAt).getTime() - Date.now() <= 0;
				return a.a.createElement("span", {
					className: e.className
				}, t ? d._("Voting closed {timeAgo}", [d._param("timeAgo", a.a.createElement(r.d, {
					seconds: e.poll.endsAt / s.Xb
				}))], {
					hk: "3OERID"
				}) : Object(o.a)(new Date(e.poll.endsAt)))
			}
		},
		"./src/reddit/components/Poll/PostTitleMetaData/index.m.less": function(e, t, n) {
			e.exports = {
				proposalMetaData: "_3yYOHq_rWQcgaR_pinEQU7",
				proposalExpiry: "_1poH87fXNrjNu84jKXBtun"
			}
		},
		"./src/reddit/components/PostBackgroundWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				backgroundWrapper: "_1poyrkZ7g36PawDueRza-J",
				badge: "_1lLKAbRNH1mm32sVm7yCzQ"
			}
		},
		"./src/reddit/components/PostBackgroundWrapper/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				a = n("./src/reddit/helpers/styles/mixins/index.tsx"),
				d = n("./src/higherOrderComponents/withAdClickLocation/index.tsx"),
				c = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				l = n("./src/reddit/components/PostBackgroundWrapper/index.m.less"),
				u = n.n(l);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = Object(d.a)(Object(i.a)(e => {
				const {
					children: t,
					className: n,
					flairStyleTemplate: s,
					onClick: i,
					post: d,
					redditStyle: l,
					theme: p,
					overrideBackgroundColor: b,
					...f
				} = e;
				return r.a.createElement("div", m({
					className: Object(o.a)(u.a.backgroundWrapper, n),
					style: b || Object(a.c)(s, e),
					onClick: i,
					"data-adclicklocation": c.a.BACKGROUND
				}, f), t)
			}))
		},
		"./src/reddit/components/PostBadges/index.m.less": function(e, t, n) {
			e.exports = {
				adminIcon: "_1cje4rrmwL0yZgCOlGyBJ-",
				approveIcon: "_1knR9NIIXdSFC9IeFN11JL",
				automoderator: "_2etEb_0bRB9axAqF3uX28S",
				icon: "_3vju76MdF2FaGmELBeiJ_r",
				lockIcon: "_3wTfn3Meg1rXJ-qd2jUWMt",
				modIcon: "_SMl46gACTEszA_4A0Qfs",
				removeIcon: "_3yuF1RnBRJL4OS_STsoXcC",
				reportIcon: "_3guZWUAROueft8TPPGDZ-R",
				spamIcon: "_2BWw37nLL0rX6n7xcXciyD",
				stickyIcon: "NI8uZ-19oHf9gPO8jOvFu",
				addRemovalReason: "COGitU-ItwLZG_fP5rsdE",
				isRemoved: "_27iLVqax1FuPWTymkSkKAq",
				archivedIcon: "_2WSiH2JwZq4bXuvrDn-cgU",
				removalReason: "_16Ih3bzeELRlI6AWeW-nFy"
			}
		},
		"./src/reddit/components/PostBadges/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				m = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				p = n("./src/reddit/constants/postLayout.ts"),
				b = n("./src/reddit/constants/posts.ts"),
				f = n("./src/reddit/contexts/PageLayer/index.tsx"),
				h = n("./src/reddit/helpers/isRemoved.ts"),
				g = n("./src/reddit/helpers/modTooltipTemplates/index.ts"),
				v = n("./src/reddit/helpers/showReportIndicator/index.ts"),
				x = n("./src/reddit/icons/fonts/index.tsx"),
				E = n("./src/reddit/icons/fonts/Approve/index.tsx"),
				O = n("./src/reddit/icons/fonts/Archived/index.tsx"),
				C = n("./src/reddit/icons/fonts/Lock/index.tsx"),
				A = n("./src/reddit/icons/fonts/Remove/index.tsx"),
				y = n("./src/reddit/icons/fonts/Report/index.tsx"),
				j = n("./src/reddit/icons/fonts/Spam/index.tsx"),
				I = n("./src/reddit/icons/fonts/Sticky/index.tsx"),
				k = n("./src/reddit/models/Post/index.ts"),
				_ = n("./src/reddit/selectors/modQueue.ts"),
				S = n("./src/reddit/selectors/posts.ts"),
				w = n("./src/reddit/components/PostBadges/index.m.less"),
				T = n.n(w);

			function P() {
				return (P = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const N = e => o.a.createElement("span", P({
					className: T.a.removalReason
				}, e), e.children),
				D = () => s.fbt._("Archived", null, {
					hk: "zv3q3"
				}),
				M = () => s.fbt._("Comments are locked", null, {
					hk: "8HjJ9"
				}),
				R = e => s.fbt._("Moderator of {community name}", [s.fbt._param("community name", e)], {
					hk: "nJqIB"
				}),
				L = () => s.fbt._("Stickied post", null, {
					hk: "3qSaBs"
				}),
				B = () => s.fbt._("Pinned post", null, {
					hk: "2oxErI"
				}),
				F = (e, t, n) => {
					const s = `PostBadges--${e}--${t}`;
					return n ? `${s}--${n}` : s
				},
				U = Object(f.v)({
					isProfilePostListing: f.N,
					isSubreddit: f.Q
				}),
				H = Object(a.c)({
					isModQueueDisplayEnabled: e => {
						const t = p.e[Object(f.U)(e, {})] === p.d.Card;
						return Object(_.b)(e, t)
					},
					isPinned: (e, t) => {
						let {
							post: n
						} = t;
						return Object(S.q)(e, {
							postId: n.id
						})
					},
					modModeEnabled: f.W
				}),
				G = Object(i.b)(H, (e, t) => ({
					onHideTooltip: () => e(Object(l.i)()),
					onOpenRemovalReasonModal: () => {
						Promise.all([n.e("Reddit~RichTextEditor~reddit-components-MediumPost~reddit-components-NotificationUnit-Button~removal~87f825ba"), n.e("removalReasonActions")]).then(n.bind(null, "./src/reddit/actions/removalReasons/index.ts")).then(n => e(n.fetchReasonsAndOpenModal(t.post.belongsTo.id, [t.post.id])))
					},
					onShowTooltip: t => () => e(Object(l.f)({
						tooltipId: t
					}))
				}));
			t.a = U(G(e => {
				let {
					className: t,
					displayText: n,
					isSubreddit: i,
					inSubredditOrProfile: a,
					isCompactPinnedPost: l,
					isPinned: p,
					isProfilePostListing: f,
					modModeEnabled: _,
					onHideTooltip: S,
					onOpenRemovalReasonModal: w,
					onShowTooltip: U,
					post: H,
					tooltipType: G,
					isModQueueDisplayEnabled: Q
				} = e;
				const q = {
						caretOnTop: !1
					},
					W = H.isRemoved && !H.modRemovalReason && !H.modNote && H.belongsTo.type === b.a.SUBREDDIT,
					z = F("Approve", H.id, G),
					V = F("Archived", H.id, G),
					K = F("Lock", H.id, G),
					Y = F("Mod", H.id, G),
					J = F("Remove", H.id, G),
					X = F("Report", H.id, G),
					Z = F("Spam", H.id, G),
					$ = F("Sticky", H.id, G),
					ee = F("Pinned", H.id, G);
				return o.a.createElement("div", {
					className: t
				}, a && n && H.distinguishType === c.I.MODERATOR && o.a.createElement(r.Fragment, null, o.a.createElement(x.a, {
					name: "mod",
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.modIcon)
				}), o.a.createElement(u.c, P({
					tooltipId: Y,
					text: R(n)
				}, q))), H.isArchived && o.a.createElement(r.Fragment, null, o.a.createElement(O.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.archivedIcon),
					desc: D(),
					id: V,
					onMouseEnter: U(V),
					onMouseLeave: S
				}), o.a.createElement(u.c, P({
					tooltipId: V,
					text: D()
				}, q))), H.isLocked && !H.isSponsored && o.a.createElement(r.Fragment, null, o.a.createElement(C.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.lockIcon),
					desc: M(),
					id: K,
					onMouseEnter: U(K),
					onMouseLeave: S
				}), o.a.createElement(u.c, P({
					tooltipId: K,
					text: M()
				}, q))), i && Object(k.v)(H) && !l && o.a.createElement(r.Fragment, null, o.a.createElement(I.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.stickyIcon),
					desc: L(),
					id: $,
					onMouseEnter: U($),
					onMouseLeave: S
				}), o.a.createElement(u.c, P({
					tooltipId: $,
					text: L()
				}, q))), f && p && o.a.createElement(r.Fragment, null, o.a.createElement(I.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.stickyIcon),
					desc: B(),
					id: ee,
					onMouseEnter: U(ee),
					onMouseLeave: S
				}), o.a.createElement(u.c, P({
					tooltipId: ee,
					text: B()
				}, q))), !Q && o.a.createElement(o.a.Fragment, null, (H.isApproved || H.approvedBy) && o.a.createElement(r.Fragment, null, o.a.createElement(E.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.approveIcon),
					desc: Object(g.a)(H),
					id: z,
					onMouseEnter: U(z),
					onMouseLeave: S
				}), o.a.createElement(u.c, P({
					tooltipId: z,
					text: Object(g.a)(H)
				}, q))), Object(h.a)(H) && o.a.createElement(r.Fragment, null, o.a.createElement(A.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.removeIcon),
					desc: Object(g.b)(H),
					id: J,
					onMouseEnter: U(J),
					onMouseLeave: S
				}), W && o.a.createElement(m.a, {
					className: T.a.addRemovalReason,
					onClick: w,
					text: s.fbt._("Add a removal reason", null, {
						hk: "1YDo3"
					})
				}), (H.modRemovalReason || H.modNote) && o.a.createElement(N, {
					onMouseEnter: U(J),
					onMouseLeave: S
				}, s.fbt._("Removal reason", null, {
					hk: "2DhKVZ"
				})), o.a.createElement(u.c, P({
					tooltipId: J,
					text: Object(g.b)(H)
				}, q))), H.bannedBy && H.isSpam && o.a.createElement(r.Fragment, null, o.a.createElement(j.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.spamIcon),
					desc: Object(g.d)(H),
					id: Z,
					onMouseEnter: U(Z),
					onMouseLeave: S
				}), o.a.createElement(u.c, P({
					tooltipId: Z,
					text: Object(g.d)(H)
				}, q)))), Object(v.a)(H) && !_ && !Q && o.a.createElement(r.Fragment, null, o.a.createElement(y.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.reportIcon),
					desc: Object(g.c)(H.numReports),
					id: X,
					onMouseEnter: U(X),
					onMouseLeave: S
				}), o.a.createElement(u.c, P({
					tooltipId: X,
					text: Object(g.c)(H.numReports)
				}, q))))
			}))
		},
		"./src/reddit/components/PostContainer/index.m.less": function(e, t, n) {
			e.exports = {
				WrappedPost: "_1oQyIsiPHYt6nx7VOmd1sz",
				wrappedPost: "_1oQyIsiPHYt6nx7VOmd1sz"
			}
		},
		"./src/reddit/components/PostContainer/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return j
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/reselect/es/index.js"),
				i = n("./src/lib/ads/index.ts"),
				a = n("./src/reddit/components/AdViewability/index.tsx"),
				d = n("./src/reddit/helpers/trackers/gallery.ts"),
				c = n("./src/reddit/hooks/useIntersectionObserver.ts"),
				l = n("./src/reddit/hooks/useTracking.ts");
			var u = r.a.memo(e => {
					const t = Object(s.useRef)(null),
						n = Object(l.a)(),
						o = Object(s.useCallback)(t => {
							t.forEach(t => {
								const {
									intersectionRatio: s
								} = t;
								s >= .5 && n(d.d(e.postId))
							})
						}, [n, e.postId]),
						i = Object(s.useMemo)(() => ({
							threshold: [.5]
						}), []);
					return Object(c.a)(t, o, i), r.a.createElement("div", {
						role: "presentation"
					}, r.a.createElement("div", {
						ref: t
					}, e.children))
				}),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/connectors/PostViewable/index.ts"),
				b = n("./src/reddit/models/Media/index.ts"),
				f = n("./src/reddit/selectors/posts.ts"),
				h = n("./src/reddit/selectors/telemetry.ts"),
				g = n("./src/lib/classNames/index.ts"),
				v = n("./src/lib/objectSelector/index.ts"),
				x = n("./src/higherOrderComponents/withClickTracking/index.tsx"),
				E = n("./src/higherOrderComponents/withAdClickLocation/index.tsx"),
				O = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				C = n("./src/reddit/components/PostContainer/index.m.less"),
				A = n.n(C);
			const y = Object(p.a)(() => Object(o.c)({
					basePixelMetadata: Object(v.a)((e, t) => {
						let {
							post: n
						} = t;
						return Object(f.b)(e, n.id)
					}),
					clickTrackingId: (e, t) => {
						let {
							post: n
						} = t;
						return n.id
					},
					imageGalleryCurrentItem: (e, t) => {
						let {
							post: n
						} = t;
						return Object(f.i)(e, {
							postId: n.id
						})
					},
					pageType: e => Object(h.d)(e).pageType
				})),
				j = "post-container";
			class I extends r.a.Component {
				constructor() {
					super(...arguments), this.cancelClick = !1
				}
				render() {
					const {
						afterClickTracking: e,
						basePixelMetadata: t,
						children: n,
						className: s,
						imageGalleryCurrentItem: o,
						makePostContainerId: c,
						post: l,
						onClick: m,
						pageType: p,
						sendEvent: f,
						style: h,
						ref: v,
						shouldAddGalleryViewability: x = !0
					} = this.props, E = r.a.createElement("div", {
						"data-click-id": this.props["data-click-id"],
						style: h,
						ref: v,
						onMouseUp: e => {
							0 !== window.getSelection().toString().length && (this.cancelClick = !0, window.setTimeout(() => {
								this.cancelClick = !1
							}, 1e3))
						},
						onClick: n => {
							if (!this.cancelClick && n.button < 2 && e(() => m && m(n, l, t, o, p))(n), l.id && o) {
								const {
									source: e
								} = Object(i.t)(l, o);
								e && e.outboundUrl && f(Object(d.c)(l.id, e.outboundUrl))
							}
						},
						className: Object(g.a)(A.a.WrappedPost, s, `Post ${l.id}`, {
							promotedlink: l.isSponsored
						}),
						"data-testid": j,
						id: c ? c(l.id) : l.id,
						tabIndex: -1,
						"data-adclicklocation": O.a.BACKGROUND
					}, n), C = !!l.media && l.media.type === b.o.VIDEO;
					return (e => l.media && Object(b.G)(l.media) && x ? r.a.createElement(u, {
						postId: l.id
					}, e) : e)((e => l.isSponsored || C ? r.a.createElement(a.a, {
						post: l,
						trackDisplay: !0
					}, e) : e)(E))
				}
			}
			t.b = y(Object(E.a)(Object(x.a)(Object(m.c)(I))))
		},
		"./src/reddit/components/PostContent/ViewCount.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/prettyPrintNumber/index.ts"),
				c = n("./src/reddit/components/CreatorStats/helpers.ts"),
				l = n("./src/reddit/selectors/creatorStats.ts"),
				u = n("./src/reddit/components/PostContent/viewCount.m.less"),
				m = n.n(u);
			t.a = e => {
				let {
					className: t,
					post: n,
					showViewCount: r
				} = e;
				const {
					upvotePercentString: u,
					viewCountString: p
				} = (e => {
					const t = e.upvoteRatio ? Math.round(100 * e.upvoteRatio).toString() : "",
						n = Object(d.b)(e.viewCount);
					return {
						upvotePercentString: s.fbt._("{percent upvoted}% Upvoted", [s.fbt._param("percent upvoted", t)], {
							hk: "432tjJ"
						}),
						viewCountString: s.fbt._({
							"*": "{number of views} Views",
							_1: "1 View"
						}, [s.fbt._plural(e.viewCount, "number of views", n)], {
							hk: "rP01m"
						})
					}
				})(n), b = r && !!n.viewCount, f = Object(i.e)(e => Object(l.a)(e, n.id)), h = Object(i.e)(e => Object(l.c)(e, n.id)), g = Object(c.c)(n, h), v = f && g === c.b.Available;
				return o.a.createElement("div", {
					className: Object(a.a)(m.a.viewCounts, t)
				}, b && o.a.createElement("span", null, p), b && !!n.upvoteRatio && o.a.createElement("span", {
					className: m.a.dotSpacer
				}), !!n.upvoteRatio && !v && o.a.createElement("span", null, u))
			}
		},
		"./src/reddit/components/PostContent/viewCount.m.less": function(e, t, n) {
			e.exports = {
				dotSpacer: "_3g_cwSqBe5o5mAuhfMeGu5",
				viewCounts: "t4Hq30BDzTeJ85vREX7_M"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/CollectionListItem/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1IZotn_IQQ1fgtUjaFYbkd",
				onHoverActionText: "_1Zlk1VrZ8puYZy5lJOfz--",
				Container: "_1IZotn_IQQ1fgtUjaFYbkd",
				PostTitle: "_1hzDym_NpIlizkTDXc_rQj",
				postTitle: "_1hzDym_NpIlizkTDXc_rQj",
				MetaLine: "_67JuJTdFwIJPLPDkyPX-f",
				metaLine: "_67JuJTdFwIJPLPDkyPX-f",
				SubredditName: "_88OYON0K3w_tpnmCSWlUX",
				subredditName: "_88OYON0K3w_tpnmCSWlUX",
				InfoSpan: "_3DFfW-OG-MvCLiiEN18mpq",
				infoSpan: "_3DFfW-OG-MvCLiiEN18mpq"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_1QvpnsvD_e--dvDTEcz7_w",
				wrapper: "_1QvpnsvD_e--dvDTEcz7_w",
				TopRow: "vuQEtla32r0kemmh11Hov",
				topRow: "vuQEtla32r0kemmh11Hov",
				TitleRow: "_1eSyFPTFSsfyp8BVxs83PB",
				titleRow: "_1eSyFPTFSsfyp8BVxs83PB",
				DetailsContainer: "_87UrrqUro4oVpXFAElZUX",
				detailsContainer: "_87UrrqUro4oVpXFAElZUX",
				ButtonRow: "_1CUOht5hsM0AF9T3Ox1yos",
				buttonRow: "_1CUOht5hsM0AF9T3Ox1yos",
				CloseWrapper: "_3OsXrjEdHgK1wJBfPX6IhR",
				closeWrapper: "_3OsXrjEdHgK1wJBfPX6IhR",
				Close: "_1TaKYhB80ExuTPoLaQZMRE",
				close: "_1TaKYhB80ExuTPoLaQZMRE",
				Empty: "_20K7F6rAgXGH5z83v7Ifiv",
				empty: "_20K7F6rAgXGH5z83v7Ifiv",
				EmptyImage: "_2eLeResic3Gc77W_edgNGt",
				emptyImage: "_2eLeResic3Gc77W_edgNGt",
				EmptyText: "_3t6VBoBsR8CGQvaPLHPjmW",
				emptyText: "_3t6VBoBsR8CGQvaPLHPjmW",
				FilterWrapper: "pKfhphFBuya82DYP2Q90X",
				filterWrapper: "pKfhphFBuya82DYP2Q90X",
				FilterInput: "_3W5cary86KmYWrVgEpGKPb",
				filterInput: "_3W5cary86KmYWrVgEpGKPb",
				SearchIcon: "_9T_dguVcd795c_vOyl9s4",
				searchIcon: "_9T_dguVcd795c_vOyl9s4",
				PlusIcon: "hfmgzmXCLe3hvSyZad9WP",
				plusIcon: "hfmgzmXCLe3hvSyZad9WP",
				CreateCollectionButton: "_34_h0zRV3AgFr_0sh99pKz",
				createCollectionButton: "_34_h0zRV3AgFr_0sh99pKz"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/higherOrderComponents/asModal/index.tsx"),
				l = n("./src/lib/memoizeByReference/index.ts"),
				u = n("./src/reddit/actions/postCreation/general.ts"),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/constants/keycodes.ts"),
				b = n("./src/reddit/controls/Button/index.tsx"),
				f = n("./src/reddit/controls/Input/index.tsx"),
				h = n("./src/reddit/icons/svgs/Close/index.tsx"),
				g = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				v = n("./src/reddit/icons/svgs/Search/index.tsx"),
				x = n("./src/reddit/layout/row/Inline/index.tsx"),
				E = n("./src/reddit/models/PostCreationForm/index.ts"),
				O = n("./src/reddit/selectors/postCollection.ts"),
				C = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				A = n("./src/reddit/components/HumanDate/index.tsx"),
				y = n("./src/reddit/helpers/name/index.ts"),
				j = n("./src/reddit/models/Subreddit/index.ts"),
				I = n("./src/reddit/models/User/index.ts"),
				k = n("./src/reddit/selectors/subreddit.ts"),
				_ = n("./src/reddit/selectors/user.ts"),
				S = n("./src/reddit/components/PostCreationForm/CollectionListModal/CollectionListItem/index.m.less"),
				w = n.n(S),
				T = n("./src/lib/lessComponent.tsx");
			const {
				fbt: P
			} = n("./node_modules/fbt/lib/FbtPublic.js"), N = T.a.div("Container", w.a), D = T.a.h2("PostTitle", w.a), M = T.a.div("MetaLine", w.a), R = T.a.span("SubredditName", w.a), L = T.a.time("InfoSpan", w.a), B = Object(d.c)({
				subreddit: (e, t) => {
					let {
						collection: {
							subredditId: n
						}
					} = t;
					return n ? Object(k.X)(e, {
						subredditId: n
					}) : void 0
				},
				user: _.m
			});
			class F extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.onClick = () => {
						this.props.onClick(this.props.collection.id)
					}
				}
				render() {
					const {
						collection: e,
						subreddit: t,
						user: n,
						onHoverActionText: s
					} = this.props, r = t && Object(j.i)(t) && n ? Object(y.e)(Object(I.e)(n)) : t ? t.displayText : "", o = e.postIds.length;
					return i.a.createElement(N, {
						onClick: this.onClick,
						className: w.a.container
					}, i.a.createElement(D, {
						"data-redditstyle": !0
					}, e.title), i.a.createElement(M, {
						"data-redditstyle": !0
					}, r && i.a.createElement(R, {
						"data-redditstyle": !0
					}, r), r && i.a.createElement(C.b, null), i.a.createElement(L, null, P._({
						"*": "{number of posts} posts",
						_1: "1 post"
					}, [P._plural(o, "number of posts")], {
						hk: "1Uy96U"
					})), i.a.createElement(C.b, null), i.a.createElement(L, null, P._("created {time}", [P._param("time", i.a.createElement(A.d, {
						seconds: e.createdAtUTC
					}))], {
						hk: "2cUc5m"
					}))), s && i.a.createElement("div", {
						className: w.a.onHoverActionText
					}, i.a.createElement("span", null, s)))
				}
			}
			var U = Object(a.b)(B)(F),
				H = n("./src/reddit/helpers/trackers/postCollection.ts"),
				G = n("./src/reddit/components/PostCreationForm/CollectionListModal/index.m.less"),
				Q = n.n(G);
			const q = `${s.a.assetPath}/img/snoo-drafts.png`,
				W = T.a.div("TopRow", Q.a),
				z = T.a.div("TitleRow", Q.a),
				V = T.a.div("DetailsContainer", Q.a),
				K = T.a.wrapped(x.a, "ButtonRow", Q.a),
				Y = T.a.div("CloseWrapper", Q.a),
				J = T.a.wrapped(h.a, "Close", Q.a),
				X = T.a.div("Empty", Q.a),
				Z = T.a.img("EmptyImage", Q.a),
				$ = T.a.p("EmptyText", Q.a),
				ee = T.a.div("FilterWrapper", Q.a),
				te = T.a.wrapped(f.a, "FilterInput", Q.a),
				ne = T.a.wrapped(v.a, "SearchIcon", Q.a),
				se = T.a.wrapped(g.a, "PlusIcon", Q.a),
				re = T.a.wrapped(b.p, "CreateCollectionButton", Q.a),
				oe = Object(l.a)((e, t) => {
					const n = t.toLowerCase();
					return e.filter(e => e.title.toLowerCase().includes(n))
				}),
				ie = Object(d.c)({
					collections: O.v
				}),
				ae = Object(a.b)(ie, (e, t) => {
					let {
						postId: n,
						isOverlay: s
					} = t;
					return {
						onOpenCreateCollectionModal: () => {
							let t = E.b;
							n && (t = Object(E.u)(n, !!s)), e(Object(u.z)(t))
						}
					}
				});
			class de extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.state = {
						filterStr: ""
					}, this.close = () => {
						this.props.sendEvent(Object(H.c)()), this.props.onClose()
					}, this.handleEscapeKey = e => {
						e.keyCode === p.a.Escape && this.close()
					}, this.handleCreateCollectionClicked = () => {
						this.props.onOpenCreateCollectionModal(), this.props.sendEvent(Object(H.j)())
					}, this.handleCollectionSelected = e => {
						this.props.onSelectCollection(e), this.props.sendEvent(Object(H.q)())
					}, this.onFilterStringChange = e => {
						this.setState({
							filterStr: e.target.value
						})
					}, this.renderItem = e => i.a.createElement(U, {
						key: e.id,
						collection: e,
						onClick: () => this.handleCollectionSelected(e),
						onHoverActionText: this.props.onItemHoverActionText
					})
				}
				componentDidMount() {
					document.addEventListener("keydown", this.handleEscapeKey), this.props.sendEvent(Object(H.d)())
				}
				componentWillUnmount() {
					document.removeEventListener("keydown", this.handleEscapeKey)
				}
				renderNoCollections() {
					return i.a.createElement(X, null, i.a.createElement(Z, {
						src: q
					}), i.a.createElement($, null, r.fbt._("Your collections will live here", null, {
						hk: "FCxWg"
					})))
				}
				renderNoFilterMatches() {
					return i.a.createElement(X, null, i.a.createElement($, null, r.fbt._("No collection matching filter", null, {
						hk: "2vawdK"
					}), ";"))
				}
				render() {
					const {
						collections: e,
						titleText: t
					} = this.props;
					let n;
					if (0 === e.length) n = this.renderNoCollections();
					else {
						const t = oe(e, this.state.filterStr);
						n = 0 === t.length ? this.renderNoFilterMatches() : t.map(this.renderItem)
					}
					return i.a.createElement("div", {
						className: Q.a.wrapper,
						"data-redditstyle": !0
					}, i.a.createElement(W, null, i.a.createElement(z, {
						"data-redditstyle": !0
					}, t || r.fbt._("My collections", null, {
						hk: "3yKovS"
					}), i.a.createElement(Y, {
						onClick: this.close
					}, i.a.createElement(J, {
						"data-redditstyle": !0
					}))), i.a.createElement(ee, null, i.a.createElement(ne, null), i.a.createElement(te, {
						placeholder: r.fbt._("Find a collection", null, {
							hk: "3DbFBU"
						}),
						value: this.state.filterStr,
						onChange: this.onFilterStringChange
					}))), i.a.createElement(V, null, n), i.a.createElement(K, null, i.a.createElement(re, {
						onClick: this.handleCreateCollectionClicked
					}, i.a.createElement(se, null), r.fbt._("Create a collection", null, {
						hk: "37xJVm"
					}))))
				}
			}
			const ce = Object(c.a)(ae(Object(m.c)(de)));
			t.a = ce
		},
		"./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_3vV_tKesULQ5WMGh38lX4b",
				container: "_3vV_tKesULQ5WMGh38lX4b",
				Content: "_11JSvybbRhcX_cfoagpne_",
				content: "_11JSvybbRhcX_cfoagpne_",
				TitleRow: "_3Ev4JRxdS9-3GTBR5M1yCP",
				titleRow: "_3Ev4JRxdS9-3GTBR5M1yCP",
				Details: "_3Uw02TWwSQhLfCJkPsihqr",
				details: "_3Uw02TWwSQhLfCJkPsihqr",
				Footer: "_25MDqXgOCWDBjtAEBi2cmy",
				footer: "_25MDqXgOCWDBjtAEBi2cmy",
				CancelButton: "_2tLOIj2nClBaVRuMBIJE8X",
				cancelButton: "_2tLOIj2nClBaVRuMBIJE8X",
				CloseWrapper: "_GVnqGyX40oKfgIS56Q-k",
				closeWrapper: "_GVnqGyX40oKfgIS56Q-k",
				CloseIcon: "_1GgoANMMbLQJ-gSefDJZuZ",
				closeIcon: "_1GgoANMMbLQJ-gSefDJZuZ",
				Label: "_3QPFKpxsmu6j_gbiAuVgfW",
				label: "_3QPFKpxsmu6j_gbiAuVgfW",
				TitleInput: "ZEfw7a99aHsmkl4fx38l5",
				titleInput: "ZEfw7a99aHsmkl4fx38l5",
				AddCollectionIcon: "_30BNMMyQPTPvHEoL3-LXrM",
				addCollectionIcon: "_30BNMMyQPTPvHEoL3-LXrM",
				PrimaryActionButton: "_22f_S1XUre_FujBgOgEHJe",
				primaryActionButton: "_22f_S1XUre_FujBgOgEHJe",
				LoadingIcon: "_3cD2qECfUUTwega16qDhBc",
				loadingIcon: "_3cD2qECfUUTwega16qDhBc",
				ErrorText: "GIQ2YnBHQtY1QM1yPEhCR",
				errorText: "GIQ2YnBHQtY1QM1yPEhCR"
			}
		},
		"./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/higherOrderComponents/asModal/index.tsx"),
				c = n("./src/lib/formatApiError/index.ts"),
				l = n("./src/reddit/actions/postCollection/index.ts"),
				u = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				m = n("./src/reddit/constants/postCreation.ts"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				b = n("./src/reddit/controls/ErrorText/index.tsx"),
				f = n("./src/reddit/controls/Input/index.tsx"),
				h = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				g = n("./src/reddit/icons/svgs/AddCollection/index.tsx"),
				v = n("./src/reddit/icons/svgs/Close/index.tsx"),
				x = n("./src/reddit/layout/row/Inline/index.tsx"),
				E = n("./src/reddit/selectors/postCollection.ts"),
				O = n("./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.m.less"),
				C = n.n(O),
				A = n("./src/lib/lessComponent.tsx");
			const y = A.a.div("Container", C.a),
				j = A.a.div("Content", C.a),
				I = A.a.div("TitleRow", C.a),
				k = A.a.div("Details", C.a),
				_ = A.a.wrapped(u.g, "Footer", C.a),
				S = A.a.wrapped(p.o, "CancelButton", C.a),
				w = A.a.div("CloseWrapper", C.a),
				T = A.a.wrapped(v.a, "CloseIcon", C.a),
				P = A.a.label("Label", C.a),
				N = A.a.wrapped(f.a, "TitleInput", C.a),
				D = A.a.wrapped(g.a, "AddCollectionIcon", C.a),
				M = A.a.wrapped(p.l, "PrimaryActionButton", C.a),
				R = A.a.wrapped(h.a, "LoadingIcon", C.a),
				L = A.a.wrapped(b.b, "ErrorText", C.a),
				B = Object(a.c)({
					collection: E.q,
					error: E.c,
					isPending: E.g
				}),
				F = Object(i.b)(B, (e, t) => ({
					onCreate: (t, n) => e(Object(l.b)(t, n)),
					onUpdate: n => e(Object(l.h)(t.collectionId, n))
				}));
			class U extends o.a.PureComponent {
				constructor(e) {
					super(e), this.onTitleChange = e => {
						this.setState({
							collectionTitle: e.target.value
						})
					}, this.onPrimaryButtonClick = async () => {
						const {
							collectionId: e,
							subredditId: t
						} = this.props, {
							collectionTitle: n
						} = this.state;
						if (e) {
							await this.props.onUpdate(n) && this.props.onCollectionUpdated && this.props.onCollectionUpdated()
						} else {
							const e = await this.props.onCreate(n, t);
							e && this.props.onCollectionCreated && this.props.onCollectionCreated(e)
						}
					}, this.onClose = () => {
						this.props.onCancel()
					};
					const {
						collection: t
					} = e;
					this.state = {
						collectionTitle: t ? t.title : ""
					}
				}
				render() {
					const {
						collectionId: e,
						error: t,
						isPending: n
					} = this.props, r = !e, i = !!this.state.collectionTitle.trim(), a = r ? s.fbt._("Create", null, {
						hk: "Ijp7n"
					}) : s.fbt._("Save", null, {
						hk: "4yMsMq"
					});
					return o.a.createElement(y, null, o.a.createElement(w, {
						onClick: this.props.onCancel
					}, o.a.createElement(T, null)), o.a.createElement(j, null, r && o.a.createElement(o.a.Fragment, null, o.a.createElement(I, null, o.a.createElement(D, null), s.fbt._("Create a collection", null, {
						hk: "3ndxk5"
					})), o.a.createElement(k, null, s.fbt._("Group posts into one feed. Create a series of events or just a group of random things. Make something awesome!", null, {
						hk: "2eCAQw"
					}))), o.a.createElement(P, null, r ? s.fbt._("Give a title for your collection", null, {
						hk: "Uaqbe"
					}) : s.fbt._("Edit title", null, {
						hk: "1jzweg"
					}), o.a.createElement(N, {
						maxLength: m.e,
						onChange: this.onTitleChange,
						placeholder: s.fbt._("Enter title", null, {
							hk: "3B0iRI"
						}),
						value: this.state.collectionTitle
					}))), o.a.createElement(_, null, o.a.createElement(x.a, null, o.a.createElement(S, {
						onClick: this.props.onCancel
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), o.a.createElement(M, {
						onClick: this.onPrimaryButtonClick,
						disabled: n || !i
					}, n ? o.a.createElement(R, {
						sizePx: 10
					}) : a)), t && o.a.createElement(L, null, Object(c.a)(t))))
				}
			}
			t.a = Object(d.a)(F(U))
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = 20,
				r = 180
		},
		"./src/reddit/components/PostFlairPicker/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			}));
			var s = n("./node_modules/lodash/isEqual.js"),
				r = n.n(s),
				o = n("./src/reddit/constants/flair.ts"),
				i = n("./src/reddit/helpers/flair.ts"),
				a = n("./src/reddit/models/Flair/index.ts");
			const d = e => (e || []).find(e => e.type === a.f.Text || e.type === a.f.Image || e.type === a.f.Richtext);
			var c;
			! function(e) {
				e[e.InvalidTemplate = 0] = "InvalidTemplate", e[e.NoChanges = 1] = "NoChanges", e[e.NotSelected = 2] = "NotSelected", e[e.TextIsNotAllowed = 3] = "TextIsNotAllowed", e[e.TextIsEmpty = 4] = "TextIsEmpty", e[e.TextIsTooLong = 5] = "TextIsTooLong"
			}(c || (c = {}));
			const l = (e, t, n) => {
				if (n && !t) return {
					canSave: !0
				};
				if (!t) return {
					canSave: !1,
					reason: c.NotSelected
				};
				const s = e && t.templateId ? e[t.templateId] : void 0;
				if (!s) return {
					canSave: !1,
					reason: c.InvalidTemplate
				};
				const a = Object(i.g)(t).length;
				return 0 === a ? {
					canSave: !1,
					reason: c.TextIsEmpty
				} : a > o.g ? {
					canSave: !1,
					reason: c.TextIsTooLong
				} : Object(i.n)(t) && !Object(i.r)(s) ? {
					canSave: !1,
					reason: c.TextIsNotAllowed
				} : r()(n, t) ? {
					canSave: !1,
					reason: c.NoChanges
				} : {
					canSave: !0
				}
			}
		},
		"./src/reddit/components/PostFlairPicker/index.m.less": function(e, t, n) {
			e.exports = {
				buttonsRow: "cF9DU_4WDAKS4gs43ct2_",
				clearButton: "_3vB6Y9PiwJ0YV6c9MGbDwT"
			}
		},
		"./src/reddit/components/PostFlairPicker/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return y
			}));
			var s, r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/reddit/components/TrackingHelper/index.tsx"),
				l = n("./src/higherOrderComponents/asModal/index.tsx"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/components/FlairPickerTitle/index.tsx"),
				p = n("./src/reddit/components/FlairPickerWrapper/index.tsx"),
				b = n("./src/reddit/components/FlairPreview/index.tsx"),
				f = n("./src/reddit/components/FlairSearch/index.tsx"),
				h = n("./src/reddit/controls/Button/index.tsx"),
				g = n("./src/reddit/helpers/trackers/postComposer.ts"),
				v = n("./src/reddit/models/Flair/index.ts"),
				x = n("./src/reddit/selectors/postFlair.ts"),
				E = n("./src/reddit/selectors/subreddit.ts"),
				O = n("./src/reddit/components/PostFlairPicker/helpers.ts"),
				C = n("./src/reddit/components/PostFlairPicker/index.m.less"),
				A = n.n(C);
			! function(e) {
				e.UNSET = "unset", e.MOD_FLATLIST = "postModFlatlist", e.POST_OVERFLOW = "postOverlay"
			}(s || (s = {}));
			const y = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
						n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : s.UNSET;
					return `PostFlair__Modal-[postId: ${e}]-isOverlay[${t}]-position[${n}]`
				},
				j = Object(d.c)({
					flairData: x.d,
					subreddit: E.X
				});
			class I extends i.a.Component {
				constructor(e) {
					super(e), this.trackEvent = () => {
						this.props.sendEvent(Object(g.G)(this.props.subredditId))
					}, this.onApply = () => {
						const {
							previewFlair: e
						} = this.state, t = e && e.templateId;
						this.props.onFlairChanged({
							previewFlair: e,
							selectedTemplateId: t
						}), this.props.closeModal && this.props.closeModal(), this.trackEvent()
					}, this.onClear = () => {
						this.props.sendEvent(Object(g.b)()), this.setSelectedFlair(null)
					}, this.setSelectedFlair = e => {
						this.setState({
							previewFlair: e
						})
					};
					const t = Object(O.c)(e.flairs);
					this.state = {
						previewFlair: t || null
					}
				}
				canSave() {
					const {
						templates: e
					} = this.props.flairData, {
						previewFlair: t
					} = this.state, n = Object(O.c)(this.props.flairs) || null;
					return Object(O.b)(e, t, n)
				}
				render() {
					const {
						props: e
					} = this, {
						previewFlair: t
					} = this.state, {
						className: n,
						flairData: s,
						subreddit: o
					} = e, a = o.displayText, {
						templates: d,
						templateIds: c
					} = s, {
						canSave: l
					} = this.canSave();
					return i.a.createElement(p.a, {
						className: n
					}, i.a.createElement(m.a, {
						onClosePressed: e.closeModal,
						title: r.fbt._("Select {subredditName} flair", [r.fbt._param("subredditName", a)], {
							hk: "1lDMWS"
						})
					}), i.a.createElement(b.a, {
						flair: t,
						flairTemplateType: v.d.LinkFlair,
						placeholderText: r.fbt._("Post Title", null, {
							hk: "43RsbC"
						})
					}), i.a.createElement(f.a, {
						flair: t,
						flairTemplateType: v.d.LinkFlair,
						subredditId: o.id,
						templates: d,
						templateIds: c,
						onChange: this.setSelectedFlair
					}), i.a.createElement("div", {
						className: A.a.buttonsRow
					}, i.a.createElement(h.l, {
						disabled: !l,
						onClick: this.onApply
					}, r.fbt._("Apply", null, {
						hk: "3mAjVQ"
					})), i.a.createElement(h.o, {
						className: A.a.clearButton,
						onClick: this.onClear
					}, r.fbt._("Clear Flair", null, {
						hk: "3jvT0B"
					}))))
				}
			}
			const k = Object(a.b)(j, (e, t) => ({
				closeModal: () => e(Object(u.i)(t.modalId))
			}))(I);
			t.a = Object(l.a)(Object(c.c)(k))
		},
		"./src/reddit/components/PostFollow/index.m.less": function(e, t, n) {
			e.exports = {
				collectionFollow: "_1yF34mDRcD_ii0n-Ak0OdI",
				isFollowed: "gBrTiaH_Z7HT5D96vnUfJ",
				isEventFollow: "_1iTFEDTdpF-KFmOZvDuGHH"
			}
		},
		"./src/reddit/components/PostFollow/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return f
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/post.ts"),
				l = n("./src/reddit/components/TrackingHelper/index.tsx"),
				u = n("./src/reddit/helpers/trackers/postCollection.ts"),
				m = n("./src/reddit/components/PostFollow/index.m.less"),
				p = n.n(m);
			class b extends o.a.Component {
				constructor(e) {
					super(e), this.onFollowClick = () => {
						const {
							isEventFollow: e,
							onFollow: t,
							post: {
								id: n,
								isFollowed: s
							},
							sendEvent: r
						} = this.props, o = !!s;
						r(e ? Object(u.o)({
							postId: n,
							isFollowed: o
						}) : Object(u.g)({
							postId: n,
							isFollowed: o
						})), t && t()
					}, this.onMouseEnter = () => {
						const e = this.props.post;
						e && e.isFollowed && this.setState({
							isHovered: !0
						})
					}, this.onMouseLeave = () => {
						const e = this.props.post;
						e && e.isFollowed && this.setState({
							isHovered: !1
						})
					}, this.state = {
						isHovered: !1
					}
				}
				render() {
					const {
						className: e,
						isEventFollow: t,
						post: n
					} = this.props, r = this.state.isHovered, i = n.isFollowed;
					let a = i ? s.fbt._("Followed", null, {
						hk: "2oc9IH"
					}) : s.fbt._("Follow", null, {
						hk: "NkunG"
					});
					return i && r && (a = s.fbt._("Unfollow", null, {
						hk: "2sJ8xn"
					})), o.a.createElement("button", {
						className: Object(d.a)(p.a.collectionFollow, {
							[p.a.isFollowed]: !!n.isFollowed,
							[p.a.isEventFollow]: t
						}, e),
						onClick: this.onFollowClick,
						onMouseEnter: this.onMouseEnter,
						onMouseLeave: this.onMouseLeave
					}, a)
				}
			}
			const f = Object(i.b)(() => Object(a.c)({}), (e, t) => {
				let {
					post: n
				} = t;
				return {
					onFollow: () => e(Object(c.z)(n.isSponsored ? n.postId : n.id))
				}
			})(Object(l.c)(b))
		},
		"./src/reddit/components/PostMedia/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return ne
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/CrosspostBox/index.tsx"),
				i = n("./src/reddit/components/Media/index.tsx"),
				a = n("./src/reddit/models/Post/index.ts"),
				d = n("./node_modules/react-redux/es/index.js"),
				c = n("./src/reddit/actions/post.ts"),
				l = n("./src/reddit/constants/adEvents.ts"),
				u = n("./src/reddit/constants/experiments.ts"),
				m = n("./src/reddit/helpers/chooseVariant/index.ts"),
				p = n("./node_modules/reselect/es/index.js");
			const b = Object(p.a)(e => Object(m.c)(e, {
				experimentEligibilitySelector: m.a,
				experimentName: u.Ec
			}), e => e === u.Yd);
			var f = n("./node_modules/fbt/lib/FbtPublic.js"),
				h = n("./src/lib/classNames/index.ts"),
				g = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				v = n("./src/reddit/components/SubredditIcon/index.tsx"),
				x = n("./src/reddit/selectors/posts.ts"),
				E = n("./src/reddit/selectors/subreddit.ts"),
				O = n("./src/reddit/components/PromotedUserPostsAd/PromotedUserPostCommunityLink/index.m.less"),
				C = n.n(O);
			const A = e => {
				let {
					postId: t,
					className: n
				} = e;
				const s = Object(d.e)(e => Object(x.F)(e, {
						postId: t
					})),
					o = Object(d.e)(e => "subreddit" === (null == s ? void 0 : s.belongsTo.type) ? Object(E.X)(e, {
						subredditId: s.belongsTo.id
					}) : null);
				return o ? r.a.createElement(g.a, {
					className: Object(h.a)(C.a.link, n),
					to: o.url
				}, f.fbt._("Posts via", null, {
					hk: "23e8m8"
				}), r.a.createElement(v.b, {
					className: C.a.subredditIcon,
					shouldHideNsfwIcon: !0,
					subredditOrProfile: o
				}), r.a.createElement("span", {
					className: C.a.subredditName
				}, o.displayText)) : null
			};
			var y = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				j = n("./src/reddit/connectors/PostViewable/index.ts"),
				I = n("./src/reddit/contexts/PageLayer/index.tsx"),
				k = n("./src/reddit/contexts/Post/index.tsx"),
				_ = n("./src/reddit/helpers/path/index.ts"),
				S = n("./src/reddit/hooks/useClickSourceData.ts"),
				w = n("./src/reddit/hooks/useIsOverlay.ts"),
				T = n("./src/reddit/hooks/usePageLayer.ts"),
				P = n("./src/lib/prettyPrintNumber/index.ts"),
				N = n("./src/reddit/components/PromotedUserPostsAd/PromotedUserPostInformation/index.m.less"),
				D = n.n(N);
			const M = e => {
				let {
					post: t
				} = e;
				const n = `${Object(P.b)(t.score)} ${f.fbt._("upvotes",null,{hk:"wJqPp"})}`,
					s = `${Object(P.b)(t.numComments)} ${f.fbt._("comments",null,{hk:"30aUyh"})}`;
				return r.a.createElement("div", {
					className: D.a.postInformation
				}, r.a.createElement("h5", {
					className: D.a.title
				}, t.title), r.a.createElement("div", {
					className: D.a.interactions
				}, r.a.createElement("p", null, n), r.a.createElement("p", null, s)))
			};
			var R = n("./src/lib/isUrl/index.ts"),
				L = n("./src/reddit/actions/profile/index.ts"),
				B = n("./src/reddit/components/Thumbnail/index.tsx"),
				F = n("./src/reddit/components/UserIcon/index.tsx"),
				U = n("./src/reddit/components/UserIcon/UserIcon.tsx"),
				H = n("./src/reddit/helpers/userSnoovatar/index.ts"),
				G = n("./src/reddit/selectors/profile.ts"),
				Q = n("./src/reddit/components/PromotedUserPostsAd/PromotedUserPostMedia/index.m.less"),
				q = n.n(Q);
			const W = e => {
				let {
					post: t
				} = e;
				var n, o, i, a;
				const c = Object(d.d)(),
					l = Object(d.e)(Object(G.l)(t.author)),
					u = Object(s.useMemo)(() => Object(B.c)({
						post: t
					}), [t]),
					m = Object(s.useMemo)(() => Object(R.a)(u), [u]);
				Object(s.useEffect)(() => {
					m || c(Object(L.d)(t.author))
				}, [c, t.author, m]);
				const p = !m && Object(H.a)(null === (n = null == l ? void 0 : l.icon) || void 0 === n ? void 0 : n.url),
					b = Object(U.c)(null === (o = null == l ? void 0 : l.icon) || void 0 === o ? void 0 : o.url);
				return r.a.createElement("div", {
					className: q.a.media
				}, m ? r.a.createElement(B.b, {
					post: t,
					url: u,
					className: q.a.mediaThumbnail,
					removeLink: !0,
					containerClassName: q.a.mediaThumbnailContainer
				}) : null, !m && (null === (i = null == l ? void 0 : l.icon) || void 0 === i ? void 0 : i.url) && r.a.createElement("div", {
					className: q.a.userIconContainer
				}, r.a.createElement(F.a, {
					className: Object(h.a)({
						[q.a.snoovatarUserIcon]: p,
						[q.a.defaultUserIcon]: b
					}, q.a.userIcon),
					iconUrl: null === (a = null == l ? void 0 : l.icon) || void 0 === a ? void 0 : a.url,
					userName: l.name,
					wrapperClassName: q.a.userIconWrapper,
					isNSFW: !1
				})))
			};
			var z = n("./src/reddit/components/PromotedUserPostsAd/PromotedUserPost/index.m.less"),
				V = n.n(z);
			const K = Object(j.a)(null);
			var Y = Object(k.b)(K(e => {
					let {
						post: t
					} = e;
					const n = Object(T.a)(),
						s = Object(w.a)(),
						o = Object(S.a)(),
						i = Object(I.x)(n) && !s;
					return r.a.createElement(g.a, {
						"data-testid": `promoted-user-post-${t.id}`,
						to: i ? Object(_.b)(t.permalink) : Object(y.a)(t.permalink, !1, o)
					}, r.a.createElement("div", {
						className: V.a.container
					}, r.a.createElement(M, {
						post: t
					}), r.a.createElement(W, {
						post: t
					})))
				})),
				J = n("./src/reddit/components/PromotedUserPostsAd/PromotedUserPosts/index.m.less"),
				X = n.n(J);
			const Z = e => {
				let {
					postIds: t
				} = e;
				const n = t.map(e => r.a.createElement(Y, {
					postId: e,
					key: e
				}));
				return r.a.createElement("div", {
					className: X.a.container
				}, n)
			};
			var $ = n("./src/reddit/components/PromotedUserPostsAd/index.m.less"),
				ee = n.n($);
			const te = e => {
				let {
					post: t
				} = e;
				const n = Object(d.d)();
				if (!Object(d.e)(b) || !t.adPromotedUserPostIds || 0 === t.adPromotedUserPostIds.length) return null;
				const [s] = t.adPromotedUserPostIds;
				return r.a.createElement("div", {
					className: ee.a.container,
					onClick: () => n(Object(c.y)(t, l.a.Click))
				}, r.a.createElement(Z, {
					postIds: t.adPromotedUserPostIds
				}), r.a.createElement(A, {
					postId: s,
					className: ee.a.communityLink
				}))
			};

			function ne(e) {
				const {
					post: t
				} = e;
				return t.crosspostRootId ? r.a.createElement(o.c, {
					postId: t.crosspostRootId,
					mediaProps: {
						...e,
						availableWidth: e.availableWidth ? e.availableWidth - 2 * o.b - 2 * o.a : void 0,
						crosspost: t,
						primaryContent: !1
					}
				}) : Object(a.B)(t) && Object(a.A)(t) ? r.a.createElement(te, {
					post: t
				}) : r.a.createElement(i.a, {
					...e,
					primaryContent: !!e.showFull
				})
			}
		},
		"./src/reddit/components/PostMeta/index.m.less": function(e, t, n) {
			e.exports = {
				metaContainer: "Ywkt6EDfNWINeTr9lP29H",
				postTopMeta: "iaAYGvTNtknkTxuHArCzL",
				subredditName: "_1L0pdcPf58t25Jy6ljHIKR",
				SubscribeButton: "_2r87gmhJ9n0MsylKHkgDcp",
				subscribeButton: "_2r87gmhJ9n0MsylKHkgDcp",
				addModNote: "CUh9f8Zri7XfZRUI18jS5"
			}
		},
		"./src/reddit/components/PostMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/selectors/moderatorPermissions.ts"),
				a = n("./src/reddit/components/AwardBadges/index.tsx"),
				d = n("./src/reddit/components/CCM/AddModNoteCTA/index.tsx"),
				c = n("./src/reddit/components/Hovercards/SubredditHovercard/index.tsx"),
				l = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				u = n("./src/reddit/components/PostBadges/index.tsx"),
				m = n("./src/reddit/components/PostTopMeta/index.tsx"),
				p = n("./src/reddit/components/QuarantinedLabel/index.tsx"),
				b = n("./src/reddit/components/SubredditNameLink/index.tsx"),
				f = n("./src/reddit/components/SubscribeButton/Inline.tsx"),
				h = n("./src/reddit/constants/posts.ts"),
				g = n("./src/reddit/controls/Button/index.tsx"),
				v = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				x = n("./src/reddit/helpers/trackers/post.ts"),
				E = n("./src/reddit/hooks/useClickSourceData.ts"),
				O = n("./src/reddit/models/Subreddit/index.ts"),
				C = n("./src/reddit/components/PostMeta/index.m.less"),
				A = n.n(C);
			t.a = e => {
				const {
					flairStyleTemplate: t,
					hideGildCta: n,
					inSubredditOrProfile: s,
					isCurrentUserProfilePost: C,
					isOverlay: y,
					isTopicPage: j,
					post: I,
					shouldShowSubscribeButton: k,
					subredditOrProfile: _,
					tooltipType: S
				} = e, w = !!j, T = Object(E.a)(), P = Object(o.e)(e => !!_ && Object(i.i)(e, _.id));
				return r.a.createElement("div", {
					className: A.a.metaContainer
				}, !s && !I.isSponsored && _ && r.a.createElement(c.a, {
					postId: I.id,
					subredditName: _.name
				}, r.a.createElement(b.a, {
					className: A.a.subredditName,
					"data-click-id": "subreddit",
					to: {
						pathname: _.url,
						state: T
					}
				}, _.displayText)), _ && _.isQuarantined && r.a.createElement(p.a, null), !s && !I.isSponsored && _ && k && !C && r.a.createElement(f.a, {
					className: A.a.SubscribeButton,
					getEventFactory: e => Object(x.n)(I.id, e ? "unsubscribe" : "subscribe"),
					identifier: {
						name: _.name,
						type: Object(O.i)(_) ? h.a.PROFILE : h.a.SUBREDDIT
					},
					postId: I.id,
					size: g.d.XXS,
					small: !0
				}), !s && !I.isSponsored && r.a.createElement(v.b, null), !s && !I.isSponsored && r.a.createElement(l.h, {
					type: I.belongsTo.type,
					id: I.belongsTo.id
				}), r.a.createElement(m.g, {
					className: A.a.postTopMeta,
					flairStyleTemplate: t,
					post: I,
					tooltipType: S,
					isModWithUserNotesPermissions: P
				}), r.a.createElement(u.a, {
					displayText: _ ? _.displayText : null,
					inSubredditOrProfile: !!s,
					post: I,
					tooltipType: S
				}), !w && r.a.createElement(a.a, {
					hideCta: n,
					thing: I,
					tooltipType: y ? m.f.Lightbox : void 0
				}), P && r.a.createElement(d.a, {
					postOrComment: I,
					className: A.a.addModNote
				}))
			}
		},
		"./src/reddit/components/PostModModeDropdown/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx"),
				r = n("./src/lib/loadWithRetries/index.ts");
			const o = () => null;
			t.a = Object(s.a)({
				ErrorComponent: o,
				getComponent: () => Object(r.a)(() => n.e("ModerationDropdowns").then(n.bind(null, "./src/reddit/components/PostModModeDropdown/_PostModModeDropdown.tsx"))).then(e => e.default),
				LoadingComponent: o
			})
		},
		"./src/reddit/components/PostOverflowMenu/index.m.less": function(e, t, n) {
			e.exports = {
				overflowMenu: "_1EbinKu2t3KjaT2gR156Qp",
				DropdownRow: "_1muOrgIRB6t41qDocDiXul",
				dropdownRow: "_1muOrgIRB6t41qDocDiXul",
				disabledRow: "_2Odc33_zXVGMHX8Um_2eO7",
				muteSubreddit: "_2Y6YEgvUcx5Ic2juj3VU95",
				HideIcon: "_3CksthIwbeJIolp7OYeQYv",
				hideIcon: "_3CksthIwbeJIolp7OYeQYv",
				Icon: "_2V4nGS1AmzWhA62lzdCu4r",
				icon: "_2V4nGS1AmzWhA62lzdCu4r"
			}
		},
		"./src/reddit/components/PostOverflowMenu/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return je
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/constants/icons.ts"),
				i = n("./node_modules/react/index.js"),
				a = n.n(i),
				d = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/reselect/es/index.js"),
				l = n("./src/telemetry/index.ts"),
				u = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				m = n("./src/config.ts"),
				p = n("./src/lib/classNames/index.ts"),
				b = n("./src/lib/lessComponent.tsx"),
				f = n("./src/reddit/actions/eventPosts/index.ts"),
				h = n("./src/reddit/actions/gold/modals.ts"),
				g = n("./src/reddit/actions/modal.ts"),
				v = n("./src/reddit/actions/pinnedPost.ts"),
				x = n("./src/reddit/actions/post.ts"),
				E = n("./src/reddit/actions/postCreation/editing.ts"),
				O = n("./src/reddit/actions/reportFlow/index.ts"),
				C = n("./src/reddit/constants/oneFeed.ts"),
				A = n("./src/reddit/constants/posts.ts"),
				y = n("./src/reddit/hooks/useRecommendationPostContext.ts");

			function j() {
				return (j = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var I = function(e) {
					function t(t) {
						const n = Object(y.a)();
						return i.createElement(e, j({}, t, {
							recommendationPostContext: n
						}))
					}
					const n = e.displayName || e.name || "Component";
					return t.displayName = `withRecommendationPostContext(${n})`, t
				},
				k = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				_ = n("./src/reddit/icons/fonts/index.tsx"),
				S = n("./src/reddit/components/BoostPost/index.ts"),
				w = n("./src/reddit/components/CreatorStats/Icon.tsx"),
				T = n("./src/reddit/components/OverflowMenu/index.tsx"),
				P = n("./src/reddit/components/ReportFlow/index.tsx"),
				N = n("./src/reddit/contexts/PageLayer/index.tsx"),
				D = n("./src/reddit/controls/CheckboxMenuItem/index.tsx"),
				M = n("./src/reddit/controls/Dropdown/Row.tsx"),
				R = n("./src/reddit/components/ModToolsFlatlist/constants.ts"),
				L = n("./src/reddit/components/ModToolsFlatlist/getModItemBreakpoints.ts"),
				B = n("./src/reddit/components/Flatlist/constants.ts"),
				F = n("./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts"),
				U = n("./src/reddit/constants/postLayout.ts"),
				H = n("./src/reddit/helpers/correlationIdTracker.ts"),
				G = n("./src/reddit/helpers/isCrosspost.ts"),
				Q = n("./src/reddit/helpers/media/index.ts"),
				q = n("./src/reddit/helpers/postEvent.ts"),
				W = n("./src/reddit/helpers/trackers/post.ts"),
				z = n("./src/reddit/helpers/trackers/react.ts"),
				V = n("./src/reddit/models/Prediction/Tournament/index.ts"),
				K = n("./src/reddit/models/Subreddit/index.ts"),
				Y = n("./src/reddit/selectors/experiments/videoReactions.ts"),
				J = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				X = n("./src/reddit/selectors/posts.ts"),
				Z = n("./src/reddit/selectors/subreddit.ts"),
				$ = n("./src/reddit/selectors/user.ts"),
				ee = n("./src/reddit/selectors/experiments/reportingRevampDesktop.ts"),
				te = n("./src/reddit/components/ModalStyledComponents/Modal.tsx"),
				ne = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				se = n("./src/reddit/components/ReportFlow/new.tsx"),
				re = n("./src/reddit/selectors/experiments/antievil/index.tsx"),
				oe = n("./src/reddit/selectors/experiments/reportAd.ts"),
				ie = n("./src/reddit/actions/postCollection/index.ts"),
				ae = n("./src/reddit/contexts/Post/index.tsx"),
				de = n("./src/reddit/helpers/trackers/postCollection.ts"),
				ce = n("./src/reddit/models/PostCreationForm/index.ts"),
				le = n("./src/reddit/selectors/postCollection.ts"),
				ue = n("./node_modules/react-router/esm/react-router.js"),
				me = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				pe = n("./src/reddit/components/ModalStyledComponents/MessageBox.tsx");
			const be = Object(ue.i)(e => {
				let {
					post: t,
					toggleConfirmDelete: n,
					handleDeletePost: r,
					location: o
				} = e;
				const {
					isPrediction: i,
					resolvedOptionId: d,
					totalVoteCount: c
				} = t.pollData || {}, l = i ? s.fbt._("Are you sure?", null, {
					hk: "2mIMwE"
				}) : s.fbt._("Delete post?", null, {
					hk: "3g7QoX"
				}), u = a.a.useMemo(() => {
					const e = c || 0;
					return i ? 0 === e ? s.fbt._("Deleting this post will cancel any predictions that have been made.", null, {
						hk: "1OCTd3"
					}) : 1 === e ? s.fbt._("Deleting this post will cancel the 1 prediction that have already been made.", null, {
						hk: "1MnrUP"
					}) : s.fbt._("Deleting this post will cancel the {votedUsersCount} predictions that have already been made.", [s.fbt._param("votedUsersCount", e.toString())], {
						hk: "1jBXxs"
					}) : s.fbt._("Are you sure you want to delete your post? You can't undo this.", null, {
						hk: "2eDKWP"
					})
				}, [i, c]), m = i ? s.fbt._("Delete", null, {
					hk: "3NNdm0"
				}) : s.fbt._("Delete post", null, {
					hk: "28hc1p"
				});
				return i && d ? a.a.createElement(pe.a, {
					title: s.fbt._("This post can't be deleted", null, {
						hk: "1sZ013"
					}),
					body: s.fbt._("Sorry about that. Once a prediction has been resolved, you can't delete the post.", null, {
						hk: "32l6dr"
					}),
					onClose: n
				}) : a.a.createElement(me.a, {
					withOverlay: !0,
					toggleModal: n,
					onConfirm: () => r(o),
					onOverlayClick: n,
					actionText: m,
					headerText: l,
					modalText: u
				})
			});
			var fe = n("./src/reddit/actions/subreddit/muting.ts"),
				he = n("./src/reddit/helpers/trackers/subredditMuting.ts"),
				ge = n("./src/devPlatform/components/ContextActions/ContextActionsLoader.tsx"),
				ve = n("./src/devPlatform/constants.ts"),
				xe = n("./src/reddit/selectors/experiments/eventPosts.ts"),
				Ee = n("./src/reddit/selectors/experiments/hidePostMitigation.ts"),
				Oe = n("./src/reddit/components/PostOverflowMenu/index.m.less"),
				Ce = n.n(Oe);
			const Ae = b.a.wrapped(M.b, "DropdownRow", Ce.a),
				ye = Object(u.a)(),
				je = e => {
					let {
						gild: t = !0,
						save: n = !0,
						share: s = !0,
						report: r = !0,
						editPost: o = !0,
						hide: i = !0,
						insights: a = !0,
						mute: d = !0,
						promotePost: c = !0
					} = e;
					return {
						[B.a.Gild]: t,
						[B.a.Save]: n,
						[B.a.Share]: s,
						[B.a.Report]: r,
						[B.a.EditPost]: o,
						[B.a.Hide]: i,
						[B.a.Insights]: a,
						[B.a.Mute]: d,
						[B.a.PromotePost]: c
					}
				},
				Ie = Object(d.b)(() => Object(c.c)({
					claimedFreeAward: J.b,
					isFutureEvent: le.i,
					isPinned: X.q,
					isAllowReactionsKillswitchEnabled: Y.a,
					subredditAboutInfo: X.G,
					reportFlowIsOpen: (e, t) => {
						let {
							isOverlay: n,
							postId: s
						} = t;
						var r, o, i, a;
						return (null === (o = null === (r = e.features) || void 0 === r ? void 0 : r.reportFlow) || void 0 === o ? void 0 : o.openedFromModalPage) === n && (null === (a = null === (i = e.features) || void 0 === i ? void 0 : i.reportFlow) || void 0 === a ? void 0 : a.postOrCommentId) === s
					},
					showPinAction: (e, t) => {
						let {
							isProfilePostListing: n,
							userIsOp: s,
							post: r,
							pageLayer: o
						} = t;
						return Object(N.G)(e, {
							pageLayer: o
						}) && n && s && Object($.Eb)(e, {
							userName: r.author
						})
					},
					hasSubredditRules: Z.j,
					isPostPartOfACollection: le.k,
					shouldRenderCollectionEditButtons: (e, t) => {
						let {
							post: n,
							subredditOrProfile: s
						} = t;
						if (n.isSponsored) return !1;
						if (!s) return !1;
						const r = s.type === K.g.User;
						return Object(le.r)(e, s.name, r)
					},
					reportingRevampEnabled: ee.a,
					subredditName: (e, t) => {
						let {
							post: n
						} = t;
						return Object(Z.i)(e, n)
					},
					isCommunityMutingEnabled: re.a,
					isReportAnAdEnabled: oe.a,
					isEventPostUiHidden: xe.a,
					isHidePostButtonDisabled: Ee.a
				}), (e, t) => {
					let {
						postId: n,
						isOverlay: s,
						isCommentsPage: r
					} = t;
					return {
						onCopyLink: t => e(Object(x.C)(t)),
						onDelete: t => e(Object(x.L)(n, t, s)),
						onDistinguishPost: t => e(Object(x.u)(n, t)),
						onGildClick: (t, s) => e(Object(h.d)({
							awardId: s,
							correlationId: t,
							thingId: n
						})),
						onToggleSave: () => e(Object(x.T)(n)),
						onToggleNSFW: () => e(Object(x.F)(n)),
						onToggleOC: () => e(Object(x.I)(n)),
						onTogglePinned: () => e(Object(v.i)(n)),
						onToggleSpoiler: () => e(Object(x.cb)(n)),
						onHide: (t, r) => e(Object(x.db)(n, !t, s, !r)),
						onReportClick: () => e(Object(O.c)(n, s)),
						onStartEventNow: () => {
							e((e, t) => Object(l.a)(Object(k.l)()(t()))), e(Object(f.startEventNowRequested)(n))
						},
						onEdit: () => {
							const t = !s && !r;
							e(Object(E.a)(n, t))
						},
						onFlairPost: () => e(Object(g.i)(Object(ne.b)(n, s))),
						onToggleSendReplies: () => e(Object(x.U)(n)),
						onToggleReactAllowed: () => e(Object(x.R)(n)),
						showCollectionsList: (t, n) => {
							e(Object(ie.e)(t)).then(() => {
								const t = Object(ce.t)(n, s);
								e(g.i(t))
							})
						},
						onMuteClick: (t, n) => e(Object(fe.c)({
							subredditId: t,
							subredditName: n
						}))
					}
				});
			class ke extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.state = {
						isConfirmDeleteOpen: !1,
						showMuteSubredditModal: !1
					}, this.handlePostEvent = (e, t) => {
						const {
							isOverlay: n,
							post: s,
							sendEvent: r
						} = this.props;
						r(Object(W.n)(s.id, e, n ? "post_detail" : "post", void 0, void 0, void 0, null == t ? void 0 : t.referralId))
					}, this.handleClickMenuButton = () => {
						this.handlePostEvent("post_overflow_menu")
					}, this.handleDeletePost = e => {
						e && (this.props.onDelete(e), this.handlePostEvent("delete"))
					}, this.handleEdit = () => {
						this.handlePostEvent("edit"), this.props.onEdit()
					}, this.handleGild = async () => {
						var e;
						const t = Object(H.d)(H.a.GildingFlow, !0);
						this.props.onGildClick(t, null === (e = this.props.claimedFreeAward) || void 0 === e ? void 0 : e.id);
						const {
							clickGildEvent: s
						} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
						this.props.sendEvent(s(this.props.postId))
					}, this.onShowFewerOfClick = () => {
						const {
							postId: e,
							recommendationPostContext: {
								setRecommendationFooterView: t
							},
							sendEvent: n
						} = this.props;
						n(Object(W.q)(e)), t(C.a.SeeFewerPostsView)
					}, this.onShowMoreOfClick = () => {
						const {
							postId: e,
							recommendationPostContext: {
								setRecommendationFooterView: t
							},
							sendEvent: n
						} = this.props;
						n(Object(W.r)(e)), t(C.a.ThankYouView)
					}, this.handleMuteModal = () => {
						this.setState(e => ({
							showMuteSubredditModal: !e.showMuteSubredditModal
						}))
					}, this.toggleHide = () => {
						const e = this.props.post.hidden ? "unhide" : "hide";
						this.props.isCommunityMutingEnabled || this.handlePostEvent(e), this.props.onHide(!!this.props.post.hidden, this.props.isCommunityMutingEnabled)
					}, this.toggleSave = () => {
						const e = this.props.post.saved ? "unsave" : "save";
						this.handlePostEvent(e), this.props.onToggleSave()
					}, this.handleReport = () => {
						this.handlePostEvent("report"), this.props.onReportClick()
					}, this.toggleOC = () => {
						this.handlePostEvent(this.props.post.isOriginalContent ? "unmark_original_content" : "mark_original_content"), this.props.onToggleOC()
					}, this.togglePinned = () => {
						this.handlePostEvent(this.props.isPinned ? "unpin" : "pin"), this.props.isPinned ? this.props.sendEvent(Object(W.u)(this.props.post.id)) : this.props.sendEvent(Object(W.k)(this.props.post.id)), this.props.onTogglePinned()
					}, this.toggleSpoiler = () => {
						this.handlePostEvent(this.props.post.isSpoiler ? "unmark_spoiler" : "mark_spoiler"), this.props.onToggleSpoiler()
					}, this.toggleNSFW = () => {
						this.handlePostEvent(this.props.post.isNSFW ? "unmark_nsfw" : "mark_nsfw"), this.props.onToggleNSFW()
					}, this.toggleDeleteConfirmation = () => {
						this.setState({
							isConfirmDeleteOpen: !this.state.isConfirmDeleteOpen
						})
					}, this.getBreakpointClass = e => {
						const {
							props: t
						} = this;
						if (!t.ignoreBreakpoints && t.useFlatlistBreakpoints[e]) return Object(F.b)({
							breakpointType: F.a.HideIfVWLarger,
							flatlistItem: e,
							isLoggedIn: !!t.currentUser,
							isUserOp: t.userIsOp
						})
					}, this.getBreakpointCx = (e, t) => Object(L.b)({
						breakpointType: F.a.HideIfVWLarger,
						flatlistItem: e,
						postLayout: t
					}), this.handleAddToCollection = () => {
						const {
							isPostPartOfACollection: e,
							showCollectionsList: t,
							post: n,
							sendEvent: s
						} = this.props;
						e || (s(Object(de.b)(n.id)), t(n.belongsTo.id, n.id))
					}, this.onCloseShareModal = e => {
						e && (this.handlePostEvent("copy_link", {
							referralId: ye
						}), this.props.onCopyLink(e))
					}, this.renderReportFlow = () => this.props.reportingRevampEnabled ? a.a.createElement(se.a, {
						withOverlay: !0,
						overlayCustomStyles: P.b,
						postId: this.props.postId,
						timestamp: this.context.currentTime
					}) : a.a.createElement(P.a, {
						withOverlay: !0,
						overlayCustomStyles: P.b,
						postId: this.props.postId,
						timestamp: this.context.currentTime
					})
				}
				getOverflowMenuBreakpointClass() {
					const {
						currentUser: e,
						ignoreBreakpoints: t,
						ignoreOverflowMenuBreakpoints: n,
						isCommentsPage: s,
						isRecommendationPost: r,
						layout: o,
						modModeWithPost: i,
						recommendationPostContext: {
							hideRecommendationContext: a
						},
						userIsOp: d
					} = this.props, c = o === U.g.Classic;
					if (!(t || n || i || d || !s && !c || r && !a)) return Object(F.b)({
						breakpointType: F.a.HideIfVWLarger,
						flatlistItem: B.a.PostOverflowMenu,
						isLoggedIn: !!e,
						isUserOp: d
					})
				}
				renderDropdownIcons() {
					var e;
					const {
						props: t
					} = this, {
						currentUser: n,
						isFutureEvent: i,
						isOverlay: d,
						isPinned: c,
						isRecommendationPost: l,
						layout: u,
						onClickInsightsButton: b,
						onStartEventNow: f,
						post: h,
						recommendationPostContext: {
							hideRecommendationContext: g
						},
						shouldRenderCollectionEditButtons: v,
						shouldShowInsightsButton: x,
						showEditFlair: E,
						showPinAction: O,
						toggleAddEventStartTimeModal: C,
						toggleEditStartTimeModal: y,
						userIsOp: j,
						isCommunityMutingEnabled: I,
						subredditName: k,
						pageLayer: T,
						isReportAnAdEnabled: P,
						isEventPostUiHidden: N,
						onClickPromoteButton: M
					} = t, L = t.currentUser && t.currentUser.isEmployee, F = Object(G.a)(t.post), U = t.post.belongsTo.type === A.a.PROFILE || Object(K.h)(t.subredditAboutInfo), H = t.post.belongsTo.type === A.a.PROFILE || Object(K.j)(t.subredditAboutInfo), W = n && h.isGildable, Y = Object(q.a)(t.post), J = d ? void 0 : u, X = "popular" === (null == T ? void 0 : T.urlParams.subredditName), Z = "Frontpage" === (null === (e = null == T ? void 0 : T.routeMatch) || void 0 === e ? void 0 : e.route.chunk), $ = I && !l && k && (X || Z);
					return a.a.createElement("div", null, x && a.a.createElement(Ae, {
						className: this.getBreakpointClass(B.a.Insights),
						displayText: s.fbt._("Insights", null, {
							hk: "t7dpi"
						}),
						onClick: b
					}, a.a.createElement(w.a, {
						postCreated: h.created,
						subredditId: h.belongsTo.id
					})), Object(S.e)(t.post, t.currentUser) && a.a.createElement(Ae, {
						className: this.getBreakpointClass(B.a.PromotePost),
						displayText: s.fbt._("Promote", null, {
							hk: "K797d"
						}),
						onClick: M
					}, a.a.createElement(_.a, {
						name: o.a.promote_snoo,
						className: Ce.a.HideIcon
					})), W && a.a.createElement(Ae, {
						className: this.getBreakpointClass(B.a.Gild),
						displayText: s.fbt._("Give Award", null, {
							hk: "3mYeGJ"
						}),
						onClick: this.handleGild
					}, a.a.createElement(_.a, {
						name: "award",
						className: Ce.a.Icon
					})), l && !g && a.a.createElement(a.a.Fragment, null, a.a.createElement(Ae, {
						className: this.getBreakpointClass(B.a.ShowMoreLikeThis),
						displayText: s.fbt._("Show more posts like this", null, {
							hk: "2t0WMg"
						}),
						onClick: this.onShowMoreOfClick
					}, a.a.createElement(_.a, {
						name: "checkmark",
						className: Ce.a.Icon
					})), a.a.createElement(Ae, {
						className: this.getBreakpointClass(B.a.ShowFewerLikeThis),
						displayText: s.fbt._("Show fewer posts like this", null, {
							hk: "k9sBL"
						}),
						onClick: this.onShowFewerOfClick
					}, a.a.createElement(_.a, {
						name: "hide",
						className: Ce.a.Icon
					}))), a.a.createElement(Ae, {
						className: this.getBreakpointClass(B.a.Share),
						displayText: s.fbt._("Copy link", null, {
							hk: "ETZxA"
						}),
						onClick: () => {
							const {
								permalink: e
							} = t;
							this.handlePostEvent("share_copy"), t.onCopyLink(e)
						}
					}, a.a.createElement(_.a, {
						name: "link_post",
						className: Ce.a.Icon
					})), a.a.createElement(Ae, {
						className: this.getBreakpointClass(B.a.Share),
						displayText: s.fbt._("Embed", null, {
							hk: "3u0v6r"
						}),
						onClick: () => {
							this.handlePostEvent("share_embed"), window.open(`${m.a.rebedMediaUrl}/embed?url=${t.post.permalink}`, "RedditEmbed", "height=500,width=650,modal=yes,alwaysRaised=yes")
						}
					}, a.a.createElement(_.a, {
						name: "embed",
						className: Ce.a.Icon
					})), t.showEditPost && !Object(V.b)(this.props.post) && a.a.createElement(Ae, {
						className: this.getBreakpointClass(B.a.EditPost),
						displayText: s.fbt._("Edit post", null, {
							hk: "3gVzz0"
						}),
						onClick: this.handleEdit,
						isSelected: t.post.hidden
					}, a.a.createElement(_.a, {
						name: "edit",
						className: Ce.a.Icon
					})), E && a.a.createElement(Ae, {
						className: this.getBreakpointCx(R.a.Flair, J),
						displayText: s.fbt._("Edit Post Flair", null, {
							hk: "1pGISD"
						}),
						onClick: t.onFlairPost,
						isSelected: t.post.hidden
					}, a.a.createElement(_.a, {
						name: "tag",
						className: Ce.a.Icon
					})), a.a.createElement(Ae, {
						className: this.getBreakpointClass(B.a.Save),
						displayText: t.post.saved ? s.fbt._("unsave", null, {
							hk: "HDDPm"
						}) : s.fbt._("save", null, {
							hk: "3bg2gs"
						}),
						onClick: this.toggleSave,
						isSelected: t.post.saved
					}, a.a.createElement(_.a, {
						name: t.post.saved ? "saved" : "save",
						className: Ce.a.Icon
					})), O && a.a.createElement(Ae, {
						displayText: c ? s.fbt._("Unpin Post from Profile", null, {
							hk: "6DYfk"
						}) : s.fbt._("Pin Post to Profile", null, {
							hk: "2RWbNF"
						}),
						onClick: this.togglePinned
					}, a.a.createElement(_.a, {
						name: "pin",
						className: Ce.a.Icon,
						isFilled: this.props.isPinned
					})), $ && a.a.createElement(Ae, {
						className: Object(p.a)(Ce.a.muteSubreddit, this.getBreakpointClass(B.a.Mute)),
						displayText: s.fbt._("Mute {name of subreddit to mute}", [s.fbt._param("name of subreddit to mute", `r/${k}`)], {
							hk: "1Jw2VW"
						}),
						onClick: this.handleMuteModal
					}, a.a.createElement(_.a, {
						name: "volume_mute",
						className: Ce.a.Icon
					})), !t.post.isSponsored && !t.isHidePostButtonDisabled && a.a.createElement(Ae, {
						className: this.getBreakpointClass(B.a.Hide),
						displayText: t.post.hidden ? s.fbt._("unhide", null, {
							hk: "1P4IxC"
						}) : s.fbt._("hide", null, {
							hk: "48yKzW"
						}),
						onClick: this.toggleHide,
						isSelected: t.post.hidden
					}, a.a.createElement(_.a, {
						name: "hide",
						className: Ce.a.HideIcon
					})), (!t.post.isSponsored || P) && !j && a.a.createElement(Ae, {
						className: this.getBreakpointClass(B.a.Report),
						displayText: s.fbt._("report", null, {
							hk: "128RPn"
						}),
						onClick: this.handleReport
					}, a.a.createElement(_.a, {
						name: "report",
						className: Ce.a.Icon
					})), v && i && f && !N && a.a.createElement(Ae, {
						onClick: f,
						displayText: s.fbt._("Start event now", null, {
							hk: "3VomTN"
						})
					}, a.a.createElement(_.a, {
						name: "live",
						className: Ce.a.Icon
					})), v && i && y && !N && a.a.createElement(Ae, {
						onClick: y,
						displayText: s.fbt._("Edit start time", null, {
							hk: "2typ17"
						})
					}, a.a.createElement(_.a, {
						name: "scheduled",
						className: Ce.a.Icon
					})), v && !Y && C && !N && a.a.createElement(Ae, {
						displayText: s.fbt._("Add event start time", null, {
							hk: "1XXqzu"
						}),
						onClick: C
					}, a.a.createElement(_.a, {
						name: "scheduled",
						className: Ce.a.Icon
					})), v && a.a.createElement(Ae, {
						className: this.props.isPostPartOfACollection ? Ce.a.disabledRow : void 0,
						displayText: s.fbt._("Add to collection", null, {
							hk: "3UNHgN"
						}),
						onClick: this.handleAddToCollection,
						noHover: this.props.isPostPartOfACollection
					}, a.a.createElement(_.a, {
						name: "collection",
						className: Ce.a.Icon
					})), j && a.a.createElement(Ae, {
						displayText: s.fbt._("delete", null, {
							hk: "4kSfzC"
						}),
						onClick: this.toggleDeleteConfirmation
					}, a.a.createElement(_.a, {
						name: "delete",
						className: Ce.a.Icon
					})), L && t.userIsOp && a.a.createElement(Ae, {
						displayText: t.post.distinguishType === r.I.ADMIN ? s.fbt._("undistinguish", null, {
							hk: "2chGON"
						}) : s.fbt._("Distinguish as admin", null, {
							hk: "2xltiM"
						}),
						onClick: () => t.post.distinguishType === r.I.ADMIN ? t.onDistinguishPost(r.I.NONE) : t.onDistinguishPost(r.I.ADMIN)
					}, a.a.createElement(_.a, {
						name: "admin",
						className: Ce.a.Icon
					})), j && U && !F && a.a.createElement(D.a, {
						text: s.fbt._("Mark as OC", null, {
							hk: "2vGyoC"
						}),
						onClick: this.toggleOC,
						isSelected: this.props.post.isOriginalContent
					}), j && H && a.a.createElement(D.a, {
						text: s.fbt._("Mark as Spoiler", null, {
							hk: "3PJk7A"
						}),
						onClick: this.toggleSpoiler,
						isSelected: this.props.post.isSpoiler
					}), j && a.a.createElement(D.a, {
						text: s.fbt._("Mark as NSFW", null, {
							hk: "4qK6JN"
						}),
						onClick: this.toggleNSFW,
						isSelected: this.props.post.isNSFW
					}), j && h.domain === Q.a && !this.props.isAllowReactionsKillswitchEnabled && a.a.createElement(D.a, {
						text: s.fbt._("Allow video threads", null, {
							hk: "DJXlU"
						}),
						onClick: () => {
							var e;
							t.onToggleReactAllowed(), this.props.sendEvent(Object(z.a)({
								subredditId: null === (e = this.props.subredditOrProfile) || void 0 === e ? void 0 : e.id,
								postId: this.props.postId,
								reactionsEnabled: this.props.post.isReactAllowed
							}))
						},
						isSelected: this.props.post.isReactAllowed
					}), t.userIsOp && a.a.createElement(D.a, {
						text: s.fbt._("Send me reply notifications", null, {
							hk: "6AmTA"
						}),
						onClick: t.onToggleSendReplies,
						isSelected: this.props.post.sendReplies
					}), a.a.createElement(ge.a, {
						contextType: ve.a.POST,
						contextData: h
					}))
				}
				render() {
					const {
						props: e
					} = this, {
						subredditName: t,
						post: n
					} = e, r = n.belongsTo.id;
					return a.a.createElement("div", null, a.a.createElement(T.b, {
						className: Object(p.a)(Ce.a.overflowMenu, this.getOverflowMenuBreakpointClass(), e.className),
						dropdownId: e.dropdownId,
						isFixed: e.isFixed,
						layout: e.layout,
						onClick: this.handleClickMenuButton
					}, this.renderDropdownIcons()), e.reportFlowIsOpen && e.subredditOrProfile && e.hasSubredditRules && this.renderReportFlow(), this.state.isConfirmDeleteOpen && a.a.createElement(be, {
						post: this.props.post,
						toggleConfirmDelete: this.toggleDeleteConfirmation,
						handleDeletePost: this.handleDeletePost
					}), this.state.showMuteSubredditModal && a.a.createElement(te.a, {
						headerText: s.fbt._("Mute {name of subreddit to mute}", [s.fbt._param("name of subreddit to mute", `r/${t}`)], {
							hk: "4eAU3R"
						}),
						modalBody: s.fbt._("You won't see posts from {name of subreddit to mute} in your feeds or recommmendations anymore.", [s.fbt._param("name of subreddit to mute", `r/${t}`)], {
							hk: "1JNA6G"
						}),
						toggleModal: this.handleMuteModal,
						actionText: s.fbt._("YES, MUTE", null, {
							hk: "1eAO8C"
						}),
						cancelActionText: s.fbt._("CANCEL", null, {
							hk: "If1yt"
						}),
						onConfirm: () => {
							this.handleMuteModal(), e.onMuteClick(r, t), this.toggleHide(), this.props.sendEvent(Object(he.a)({
								subredditId: r,
								postId: n.id
							}))
						},
						withOverlay: !0
					}))
				}
			}
			t.a = I(Object(ae.e)(Ie(ke)))
		},
		"./src/reddit/components/PostRailAndVotes/index.m.less": function(e, t, n) {
			e.exports = {
				score: "_3a2ZHWaih05DgAOtvu6cIo",
				allowPointerEvents: "_2iiIcja5xIjg-5sI4ECvcV",
				checkbox: "_25sIJZLIxTa3eolXDWieo5"
			}
		},
		"./src/reddit/components/PostRailAndVotes/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/PostLeftRail/index.tsx"),
				a = n("./src/reddit/components/VerticalVotes/index.tsx"),
				d = n("./src/reddit/controls/Checkbox/index.tsx"),
				c = n("./src/reddit/helpers/isPost.ts"),
				l = n("./src/reddit/helpers/showReportIndicator/index.ts"),
				u = n("./src/reddit/components/PostRailAndVotes/index.m.less"),
				m = n.n(u);
			t.a = e => {
				const {
					model: t,
					handleVote: n,
					showBulkActionCheckbox: s = !1,
					isCheckboxSelected: u = !1,
					isCountAnimShadowTestEnabled: p,
					toggleCheckbox: b = (() => {}),
					flairStyleTemplate: f,
					redditStyle: h,
					isOverlay: g,
					isVoteCountAnimation: v,
					postId: x,
					shouldShowUpvoteRatioOnHover: E
				} = e, O = `upvote-button-${t.id}${g?"-overlay":""}`;
				return r.a.createElement(i.b, {
					isRemoved: !!t.bannedBy,
					isReported: Object(l.a)(t),
					isSponsored: !!Object(c.b)(t) && t.isSponsored,
					redditStyle: h
				}, s && r.a.createElement(d.a, {
					className: m.a.checkbox,
					isCheckboxSelected: u,
					toggleCheckbox: b
				}), r.a.createElement(a.a, {
					flairStyleTemplate: f,
					model: t,
					onVoteClick: n,
					redditStyle: h,
					upvoteTooltipId: O,
					isVoteCountAnimation: v,
					isCountAnimShadowTestEnabled: p,
					postId: x,
					scoreClassName: Object(o.a)(m.a.score, {
						[m.a.allowPointerEvents]: E
					}),
					shouldShowUpvoteRatioOnHover: E
				}))
			}
		},
		"./src/reddit/components/PostTitle/getLeftAndRightFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/helpers/flair.ts"),
				r = n("./src/reddit/models/Flair/index.ts");

			function o(e) {
				let {
					flair: t,
					isFlairPositionedLeft: n,
					showNSFWSpoilerFlairsOnly: o,
					hideNSFWSpoilerFlair: i
				} = e;
				const a = [],
					d = [],
					c = [];
				for (const m of t) m.type === r.f.Nsfw || m.type === r.f.Spoiler ? a.push(m) : Object(s.q)(m.type) ? d.push(m) : c.push(m);
				let l = [],
					u = [];
				return n ? o ? (l = a, u = []) : i ? (l = d, u = c) : (l = d, u = [...a, ...c]) : o ? (l = [], u = a) : i ? (l = [], u = [...d, ...c]) : (l = [], u = [...d, ...a, ...c]), {
					leftFlair: l,
					rightFlair: u
				}
			}
		},
		"./src/reddit/components/PostTitle/index.m.less": function(e, t, n) {
			e.exports = {
				outboundLinkIcon: "qgDkGQIoFEpMMeNtfI0BY",
				pollMeta: "FKej75-i0z1XubMqeVh9Q",
				styledLink: "SQnoC3ObvgnGjWt90zD9Z",
				Title: "_2SdHzo12ISmrC8H86TgSCp",
				title: "_2SdHzo12ISmrC8H86TgSCp",
				titleContainer: "y8HYJ-y_lTUHkQIc1mdCq",
				isNoWrap: "_2_QBmCTk6VD4M3dvKqXD23",
				isVisitedEnabled: "_2INHSNB8V5eaWp4P0rY_mE",
				postTitleVisibility: "_1hLrLjnE1G_RBCNcN9MVQf",
				blur: "_1Y3R-LNfq0EOkZUcePSt1j",
				ExtraLarge: "_29WrubtjAcKqzJSPdQqQ4h",
				extraLarge: "_29WrubtjAcKqzJSPdQqQ4h",
				Large: "_3wqmjmv3tb_k-PROt7qFZe",
				large: "_3wqmjmv3tb_k-PROt7qFZe",
				Medium: "_1zpZYP8cFNLfLDexPY65Y7",
				medium: "_1zpZYP8cFNLfLDexPY65Y7",
				Small: "uWdXen_41bh0iwLrgzFkc",
				small: "uWdXen_41bh0iwLrgzFkc",
				ExtraSmall: "_1aqE18-N18ZIRlkE1wa7DP",
				extraSmall: "_1aqE18-N18ZIRlkE1wa7DP",
				Metadata: "_2_YD0sbnnLrJvpCrMxBFaC",
				metadata: "_2_YD0sbnnLrJvpCrMxBFaC",
				Component: "_2FCtq-QzlfuN-SwVMUZMM3",
				component: "_2FCtq-QzlfuN-SwVMUZMM3"
			}
		},
		"./src/reddit/components/PostTitle/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return B
			})), n.d(t, "a", (function() {
				return J
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/polished/dist/polished.es.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				c = n("./node_modules/reselect/es/index.js"),
				l = n("./src/lib/ads/index.ts"),
				u = n("./src/lib/classNames/index.ts"),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/contexts/PageLayer/index.tsx"),
				b = n("./src/reddit/controls/OutboundLink/index.tsx"),
				f = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				h = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				g = n("./src/reddit/actions/post.ts"),
				v = n("./src/reddit/constants/adEvents.ts"),
				x = n("./src/reddit/helpers/path/index.ts"),
				E = n("./src/reddit/hooks/useClickSourceData.ts"),
				O = n("./src/reddit/hooks/useIsRemovedOrDeletedPost.ts"),
				C = n("./src/reddit/hooks/usePostContext.ts"),
				A = n("./src/reddit/hooks/useTheme.ts"),
				y = n("./src/reddit/icons/fonts/index.tsx"),
				j = n("./src/reddit/models/Flair/index.ts"),
				I = n("./src/reddit/models/Media/index.ts"),
				k = n("./src/reddit/models/Post/index.ts"),
				_ = n("./src/reddit/models/Prediction/Tournament/index.ts"),
				S = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				w = n("./src/lib/getShortenedLink.ts"),
				T = n("./src/reddit/components/FlairWrapper/index.tsx"),
				P = n("./node_modules/fbt/lib/FbtPublic.js"),
				N = n("./src/lib/prettyPrintNumber/index.ts"),
				D = n("./src/reddit/components/Poll/PollExpiry/index.tsx"),
				M = n("./src/reddit/components/Poll/PostTitleMetaData/index.m.less"),
				R = n.n(M);
			const L = Object(c.c)({
				poll: (e, t) => e.polls.models[t.pollId],
				resultsByVoters: (e, t) => e.polls.results.byVoters[t.pollId]
			});
			var B, F = Object(a.b)(L)((function(e) {
					const {
						poll: t,
						resultsByVoters: n
					} = e, s = n ? n.totalVotes : "0";
					return Object(O.a)() ? null : i.a.createElement("div", {
						className: Object(u.a)(e.className, R.a.proposalMetaData)
					}, i.a.createElement("span", null, P.fbt._({
						"*": "{count} votes",
						_1: "{count} vote"
					}, [P.fbt._param("count", Object(N.a)(s)), P.fbt._plural(parseInt(s))], {
						hk: "4rP1VK"
					})), t && i.a.createElement(D.a, {
						className: R.a.proposalExpiry,
						poll: t
					}))
				})),
				U = n("./src/reddit/components/SEOTitle/index.tsx"),
				H = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				G = n("./src/reddit/selectors/experiments/nsfwBlockingExperiment.ts"),
				Q = n("./src/reddit/selectors/user.ts"),
				q = n("./src/telemetry/models/Outbound.ts"),
				W = n("./src/reddit/components/PostTitle/getLeftAndRightFlair.ts"),
				z = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				V = n("./src/reddit/components/PostTitle/index.m.less"),
				K = n.n(V);

			function Y() {
				return (Y = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}! function(e) {
				e[e.ExtraLarge = 0] = "ExtraLarge", e[e.Large = 1] = "Large", e[e.Medium = 2] = "Medium", e[e.Small = 3] = "Small", e[e.ExtraSmall = 4] = "ExtraSmall", e[e.Metadata = 5] = "Metadata"
			}(B || (B = {}));
			const J = e => {
					let {
						size: t,
						titleColor: n,
						titleType: s,
						nowrap: r,
						children: o,
						className: a,
						redditStyle: d,
						shouldBlurTitle: c
					} = e;
					const l = Object(A.a)();
					let m = "";
					switch (t) {
						case B.ExtraLarge:
							m = K.a.ExtraLarge;
							break;
						case B.Large:
							m = K.a.Large;
							break;
						case B.Medium:
							m = K.a.Medium;
							break;
						case B.Small:
							m = K.a.Small;
							break;
						case B.ExtraSmall:
							m = K.a.ExtraSmall;
							break;
						case B.Metadata:
							m = K.a.Metadata
					}
					return i.a.createElement("div", {
						className: Object(u.a)(K.a.Title, a, m, {
							[K.a.isNoWrap]: r,
							[K.a.blur]: c
						}),
						style: {
							"--posttitletextcolor": n || Object(S.a)({
								redditStyle: d,
								theme: l
							}).titleText
						}
					}, s ? i.a.createElement(U.b, {
						type: s
					}, o) : o)
				},
				X = e => {
					let {
						className: t,
						disableVisited: n,
						titleColor: s,
						children: r,
						...o
					} = e;
					return i.a.createElement(d.a, Y({}, o, {
						className: Object(u.a)(t, K.a.styledLink, {
							[K.a.isVisitedEnabled]: !n
						})
					}), r)
				},
				Z = e => {
					let {
						disableVisited: t,
						nowrap: n,
						className: s,
						children: r
					} = e;
					return i.a.createElement("div", {
						className: Object(u.a)(K.a.titleContainer, s, {
							[K.a.isNoWrap]: n,
							[K.a.isVisitedEnabled]: !t
						})
					}, r)
				},
				$ = Object(c.c)({
					flairPosition: (e, t) => {
						let {
							pageLayer: n
						} = t;
						return Object(p.r)(e, {
							pageLayer: n
						})
					},
					isNsfwBlurSubreddit: G.e,
					shouldOpenPostInNewTab: Q.lb
				}),
				ee = e => {
					const {
						post: t
					} = e, {
						isSponsored: n
					} = t, s = Object(a.d)(), r = Object(E.a)(), o = Object(a.e)(H.b), d = Object(a.e)(H.c), c = e => {
						(o || d) && (e.preventDefault(), s(Object(g.Z)(Object(x.b)(t.permalink), t.id))), t.isSponsored && Object(k.A)(t) && s(Object(g.y)(t, v.a.Click))
					};
					if (e.isCommentsPage && !e.isCommentPermalink && !e.shouldLinkWrap) return i.a.createElement(Z, {
						nowrap: e.nowrap
					}, i.a.createElement(te, e));
					if (e.isCommentsPageAd && t.source && t.source.url) return i.a.createElement(b.b, {
						href: t.source.url,
						isSponsored: n,
						postId: t.id,
						source: t.source
					}, i.a.createElement(te, e)); {
						const s = t.permalink,
							o = e.isCommentPermalink ? Object(x.b)(s) : Object(h.a)(s, void 0, r);
						return i.a.createElement(Z, {
							disableVisited: e.disableVisited,
							nowrap: e.nowrap
						}, n && !Object(k.A)(t) ? ((e, t) => {
							const {
								source: n
							} = Object(l.t)(e, t.imageGalleryCurrentItem);
							return n ? i.a.createElement(b.b, {
								href: n.url,
								isSponsored: e.isSponsored,
								postId: e.id,
								source: n
							}, i.a.createElement(te, t)) : i.a.createElement(te, t)
						})(t, e) : i.a.createElement(X, {
							className: e.titleLinkClassName,
							"data-click-id": "body",
							disableVisited: e.disableVisited,
							target: e.shouldOpenPostInNewTab ? "_blank" : void 0,
							titleColor: e.titleColor,
							to: o,
							onClick: c
						}, i.a.createElement(te, e)))
					}
				},
				te = e => {
					const {
						leftFlair: t,
						isCommentsPageAd: n,
						post: s
					} = e;
					let r = e.format ? e.format(s) : s.title;
					n && "string" == typeof r && (r = (e => {
						return e.length >= 250 ? e.slice(0, 250 - "...".length) + "..." : e
					})(r));
					const o = e.isCommentsPage ? U.a.PostComments : U.a.PostItem,
						a = !(!e.isNsfwBlurSubreddit || !e.post.isNSFW);
					return i.a.createElement(J, {
						className: e.titleClassName,
						nowrap: e.nowrap,
						redditStyle: e.redditStyle || e.isCommentsPage || e.isCommentsPageAd,
						shouldBlurTitle: a,
						size: e.size,
						titleColor: e.titleColor,
						titleType: o
					}, t && i.a.createElement(T.a, {
						titleFlair: t,
						nowrap: !0,
						post: s,
						sendEvent: e.sendEvent
					}), r)
				},
				ne = e => {
					const {
						hideSourceLink: t,
						isNsfwBlurSubreddit: n,
						post: s
					} = e, {
						isSponsored: r
					} = s, o = e.isCommentsPage ? q.SourceElement.PostLink : q.SourceElement.ListingPostLink;
					if (Object(O.a)()) return null;
					if (n && s.isNSFW) return null;
					const a = !t && !e.isCrosspost && e.size !== B.Large && !s.isSponsored && (s.source || s.media && (s.media.type === I.o.GIFVIDEO || s.media.type === I.o.IMAGE || s.media.type === I.o.EMBED));
					if (t || !e.isCommentsPage || e.isCommentPermalink || e.shouldLinkWrap) {
						if (a) return i.a.createElement(f.a, {
							className: e.outboundLinkClassName,
							href: Object(I.E)(s),
							isSponsored: r,
							postId: s.id,
							source: s.source,
							sourceElement: o
						}, Object(w.a)(s), !s.isSponsored && i.a.createElement(y.a, {
							name: "external_link",
							className: K.a.outboundLinkIcon
						}))
					} else if (s.source && !e.isCrosspost && e.size !== B.Large && e.size !== B.ExtraLarge) return i.a.createElement(f.a, {
						className: e.outboundLinkClassName,
						href: s.source.url,
						isSponsored: r,
						postId: s.id,
						source: s.source,
						sourceElement: o
					}, Object(w.a)(s), !s.isSponsored && i.a.createElement(y.a, {
						name: "external_link",
						className: K.a.outboundLinkIcon
					}));
					return null
				};
			class se extends i.a.Component {
				getDynamicStyleTags() {
					return i.a.createElement("style", {
						dangerouslySetInnerHTML: {
							__html: `\n        .${this.props.post.id}.${K.a.Component} {\n          --postTitle-VisitedLinkColor: ${Object(r.c)(.45,Object(S.a)(this.props).titleText,"#FFFFFF")};\n          --postTitleLink-VisitedLinkColor: ${Object(r.c)(.45,this.props.titleColor||Object(S.a)(this.props).titleText,Object(S.a)(this.props).body)};\n          --postBodyLink-VisitedLinkColor: ${Object(r.c)(.45,Object(S.a)(this.props).bodyText,Object(S.a)(this.props).body)};\n        }\n      `
						}
					})
				}
				render() {
					const {
						className: e,
						disableFlair: t,
						flairPosition: n,
						isCommentsPage: r,
						isOverlay: o,
						poll: a,
						post: d,
						showNSFWSpoilerFlairsOnly: c,
						hideNSFWSpoilerFlair: l,
						onClick: m
					} = this.props, p = n === j.b.Left, b = Object(T.b)(d), {
						leftFlair: f,
						rightFlair: h
					} = Object(W.a)({
						flair: b,
						isFlairPositionedLeft: p,
						showNSFWSpoilerFlairsOnly: c,
						hideNSFWSpoilerFlair: l
					}), g = !o && !r && !t, v = g && f && f.length > 0, x = g && h && h.length > 0;
					return i.a.createElement("div", {
						className: Object(u.a)(K.a.Component, e, d.id),
						ref: this.props.innerRef,
						"data-adclicklocation": z.a.TITLE,
						onClick: m
					}, !c && v && i.a.createElement(T.a, {
						isFlairFilter: !0,
						titleFlair: f,
						nowrap: !0,
						post: d,
						sendEvent: this.props.sendEvent
					}), !Object(_.b)(d) && i.a.createElement(ee, Y({}, this.props, {
						leftFlair: c ? f : void 0
					})), a && i.a.createElement(F, {
						className: K.a.pollMeta,
						pollId: a.id
					}), i.a.createElement(ne, this.props), x && i.a.createElement(T.a, {
						isFlairFilter: !0,
						titleFlair: h,
						nowrap: !0,
						post: d,
						sendEvent: this.props.sendEvent
					}), i.a.createElement("div", {
						className: K.a.postTitleVisibility,
						dangerouslySetInnerHTML: {
							__html: `\n              <img alt="" src="${s.a.assetPath}/img/renderTimingPixel.png" style="width: 1px; height: 1px;" onLoad="(__markFirstPostVisible || function(){})();" />\n            `
						}
					}), this.getDynamicStyleTags())
				}
			}
			t.c = i.a.memo((function(e) {
				const t = Object(p.ib)(),
					n = Object(p.x)(t),
					s = Object(C.a)(),
					r = Object(a.e)(r => $(r, {
						...s,
						...e,
						isCommentPermalink: n,
						pageLayer: t
					})),
					o = Object(A.a)(),
					d = Object(m.b)();
				return s ? i.a.createElement(se, Y({
					pageLayer: t,
					isCommentPermalink: n
				}, s, r, e, {
					theme: o,
					sendEvent: d
				})) : null
			}))
		},
		"./src/reddit/components/ProfileIdCard/AwardedLastMonth.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/config.ts"),
				i = n("./src/lib/prettyPrintNumber/index.ts"),
				a = n("./src/reddit/components/ProfileIdCard/index.m.less"),
				d = n.n(a);
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			class l extends r.a.PureComponent {
				render() {
					const {
						topAwardIcon: e,
						recentAwardings: t,
						username: n
					} = this.props;
					if (!t.topAward) return null;
					const {
						topAward: s,
						totalCount: a
					} = t, l = s.description ? s.description : s.name;
					return r.a.createElement("a", {
						className: d.a.AwardedLastMonth,
						href: `${o.a.oldRedditUrl}/user/${n}/gilded`
					}, r.a.createElement("div", {
						className: d.a.iconColumn
					}, r.a.createElement("img", {
						alt: l,
						className: d.a.icon,
						src: e
					}), a > 1 && r.a.createElement("span", {
						className: d.a.count
					}, `+${Object(i.b)(a-1)}`)), r.a.createElement("div", {
						className: d.a.textColumn
					}, c._({
						"*": "Received the {award-name} Award and more in the past 30 days",
						_1: "Received the {award-name} Award in the past 30 days"
					}, [c._param("award-name", s.name), c._plural(a)], {
						hk: "16MJHe"
					})))
				}
			}
			t.a = l
		},
		"./src/reddit/components/ProfileIdCard/ProfileImage/ProfileBanner/index.m.less": function(e, t, n) {
			e.exports = {
				Banner: "_2ZyL7luKQghNeMnczY3gqW",
				banner: "_2ZyL7luKQghNeMnczY3gqW"
			}
		},
		"./src/reddit/components/ProfileIdCard/ProfileImage/ProfileBanner/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/reddit/models/Image/index.tsx"),
				a = n("./src/reddit/components/EditableImage/index.tsx"),
				d = n("./src/reddit/models/User/index.ts"),
				c = n("./src/reddit/components/ProfileIdCard/ProfileImage/connector.ts"),
				l = n("./src/reddit/components/ProfileIdCard/ProfileImage/ProfileBanner/index.m.less"),
				u = n.n(l);
			class m extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						isUpdating: !1
					}, this.updateProfileIcon = async (e, t) => {
						const n = await Object(i.e)(e);
						this.setState({
							isUpdating: !0
						}, async () => {
							await this.props.imageUpdateRequested(n, "profileBanner"), this.setState({
								isUpdating: !1
							})
						})
					}
				}
				render() {
					const {
						bannerUrl: e,
						className: t,
						currentUser: n,
						hideNSFWPref: r,
						isNSFW: i,
						userName: c
					} = this.props, {
						isUpdating: l
					} = this.state, m = e ? o.a.createElement("div", {
						className: u.a.Banner,
						style: {
							backgroundImage: `url(${e})`
						}
					}) : null;
					return n && Object(d.e)(n) === c ? o.a.createElement(a.a, {
						altText: s.fbt._("{userName} banner image", [s.fbt._param("userName", c)], {
							hk: "1PcEBS"
						}),
						className: t,
						isLoading: l,
						onFileSelected: this.updateProfileIcon
					}, m) : i && r ? null : m
				}
			}
			t.a = Object(c.a)(m)
		},
		"./src/reddit/components/ProfileIdCard/ProfileImage/connector.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/actions/preferences.ts"),
				i = n("./src/reddit/selectors/user.ts");
			const a = Object(r.c)({
					currentUser: i.m,
					hideNSFWPref: i.H
				}),
				d = Object(s.b)(a, e => ({
					imageUpdateRequested: (t, n) => e(Object(o.B)(t, n))
				}));
			t.a = d
		},
		"./src/reddit/components/ProfileIdCard/SnoovatarButton/TryItOn.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/classNames/index.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router/esm/react-router.js"),
				d = n("./src/reddit/actions/post.ts"),
				c = n("./src/reddit/actions/snoovatarModal.ts"),
				l = n("./src/reddit/components/TrackingHelper/index.tsx"),
				u = n("./src/reddit/controls/Button/index.tsx"),
				m = n("./src/reddit/helpers/trackers/snoovatar.ts"),
				p = n("./src/reddit/icons/svgs/Shirt/index.tsx"),
				b = n("./src/reddit/models/Vote/index.ts"),
				f = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/index.m.less"),
				h = n.n(f);
			const {
				fbt: g
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = Object(a.i)(e => {
				let {
					isHovercard: t,
					username: n,
					isAvatarPost: a,
					post: f,
					share: v
				} = e;
				const x = Object(l.b)(),
					E = Object(i.d)(),
					O = f && f.id,
					C = f && f.voteState;
				let A = null;
				O || (A = t ? "user_hovercard" : "profile_overview");
				const y = Object(r.useCallback)(() => x(Object(m.h)(t ? "user_hovercard" : "profile_overview", n)), [t, x, n]);
				return o.a.createElement(u.t, {
					onClick: () => {
						a ? (x(m.i), O && C === b.a.notVoted && E(Object(d.ib)(O))) : y();
						const e = a ? "postify" : "copy";
						E(Object(c.b)({
							clickSource: A,
							share: v,
							source: e
						}))
					},
					className: Object(s.a)(h.a.snoovatarButton, h.a.snoovatarExtraPadding, h.a.compactButtonLayout, {
						[h.a.avatarPostifyButton]: a
					}),
					isFullWidth: !0
				}, o.a.createElement(p.a, {
					className: Object(s.a)({
						[h.a.shirtIcon]: !a,
						[h.a.avatarPostButtonShirtIcon]: a
					})
				}), g._("Try this Look", null, {
					hk: "dOuPb"
				}), o.a.createElement("div", {
					className: h.a.chevronIcon
				}))
			})
		},
		"./src/reddit/components/ProfileIdCard/SnoovatarButton/index.m.less": function(e, t, n) {
			e.exports = {
				snoovatarButton: "_3F1tNW0P4Ff182mO_CefIg",
				avatarPostifyButton: "_2Viile0fcrruho_hQqpnUx",
				snoovatarExtraPadding: "_3DnDqV66Np6rVEiI8QK7kl",
				shirtIcon: "_3gYTHRBO1S_S5AOddgqD6Z",
				avatarPostButtonShirtIcon: "ARFP2bx6U967JwMoJ2Xr5",
				compactButtonLayout: "VFbNvXfZXUhRFiCTDHO6f",
				chevronIcon: "_12pWM-aURvVUuSrUyqfNZh"
			}
		},
		"./src/reddit/components/ProfileIdCard/SnoovatarButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/Button/index.tsx"),
				a = n("./src/reddit/icons/fonts/index.tsx"),
				d = n("./src/reddit/icons/svgs/Shirt/index.tsx"),
				c = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/index.m.less"),
				l = n.n(c);
			const {
				fbt: u
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = function(e) {
				let {
					compact: t,
					currentUserHasSnoovatar: n,
					className: s,
					isOwnProfile: c,
					onClick: m
				} = e;
				return r.a.createElement(i.t, {
					onClick: m,
					isFullWidth: !0,
					className: Object(o.a)(l.a.snoovatarButton, {
						[l.a.snoovatarExtraPadding]: !n && c,
						[l.a.compactButtonLayout]: t
					}, s)
				}, n ? r.a.createElement(d.a, {
					className: l.a.shirtIcon
				}) : r.a.createElement("div", {
					className: l.a.shirtIcon
				}), n ? u._("Style Avatar", null, {
					hk: "UEtBO"
				}) : c ? u._("Create Avatar", null, {
					hk: "2pJgje"
				}) : u._("Create Your Own Avatar", null, {
					hk: "22FFcO"
				}), n ? r.a.createElement("div", {
					className: l.a.chevronIcon
				}) : r.a.createElement(a.a, {
					name: "caret_right",
					className: l.a.chevronIcon
				}))
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserBanner/index.m.less": function(e, t, n) {
			e.exports = {
				BannerWrapper: "_8AZ553JgDTNn5ZUmBdXkR",
				bannerWrapper: "_8AZ553JgDTNn5ZUmBdXkR",
				BannerImage: "_1IvROQ79nAJZ87_JkTFsLO",
				bannerImage: "_1IvROQ79nAJZ87_JkTFsLO"
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserBanner/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				i = n("./src/reddit/icons/svgs/Close/index.tsx"),
				a = n("./src/reddit/components/ProfileIdCard/ProfileImage/ProfileBanner/index.tsx"),
				d = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserBanner/index.m.less"),
				c = n.n(d),
				l = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserProfile.m.less"),
				u = n.n(l);
			t.a = function(e) {
				let {
					bannerBackgroundImage: t,
					isNSFW: n,
					username: s,
					editMode: d,
					isDeletingBanner: l,
					onDeleteBanner: m
				} = e;
				return r.a.createElement("div", {
					className: c.a.bannerWrapper
				}, r.a.createElement(a.a, {
					bannerUrl: t,
					isNSFW: n,
					userName: s
				}), d && t && (l ? r.a.createElement(o.a, {
					sizePx: 20,
					className: u.a.loadingIcon
				}) : r.a.createElement(i.a, {
					className: u.a.closeIcon,
					onClick: m
				})))
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserName.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/controls/InternalLink/index.tsx"),
				i = n("./src/reddit/components/HumanDate/index.tsx");

			function a() {
				return (a = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const {
				fbt: d
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = function(e) {
				let {
					className: t,
					shouldDisplaySnoovatar: n,
					url: s,
					userCreated: d,
					username: c,
					...l
				} = e;
				const u = n ? r.a.createElement(r.a.Fragment, null, "u/", c, "  ", r.a.createElement(i.d, {
					seconds: d,
					noPostfix: !0,
					shortenedUnit: !0
				})) : `u/${c}`;
				return s ? r.a.createElement(o.default, a({}, l, {
					className: t,
					to: s
				}), u) : r.a.createElement("span", a({}, l, {
					className: t
				}), u)
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserProfile.m.less": function(e, t, n) {
			e.exports = {
				loadingIcon: "_2DTxp6tzlJMeNlZ-cjXWTs",
				closeIcon: "_2ioQgcdZvYlf34S0OEqBuQ",
				settingsIcon: "A4Iifg_NCOrfabq0ON3mW"
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/AvatarImage.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return y
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/classNames/index.ts"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./src/reddit/components/Econ/Marketplace/CollectiblesShowcaseUnit/async.ts"),
				c = n("./src/reddit/components/Econ/Marketplace/NftProfileUnit/async.ts"),
				l = n("./src/reddit/helpers/trackers/marketplace/claims.ts"),
				u = n("./src/reddit/helpers/userSnoovatar/index.ts"),
				m = n("./src/reddit/selectors/experiments/econ/index.ts"),
				p = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.m.less"),
				b = n.n(p);
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const f = 25;

			function h(e, t) {
				return Object.keys(t).filter(t => 0 === t.indexOf(e)).map(e => t[e])
			}

			function g(e) {
				return e[Math.floor(Math.random() * e.length)]
			}
			const v = h("particleDelay", b.a),
				x = h("particleX", b.a),
				E = h("particleFloat", b.a),
				O = () => {
					const e = g(x),
						t = g(E),
						n = g(v);
					return Object(r.a)(b.a.particle, e, t, n)
				};
			class C extends i.a.Component {
				shouldComponentUpdate() {
					return !1
				}
				render() {
					const e = [];
					for (let t = 0; t < f; t++) e.push(this.createParticle(t));
					return i.a.createElement("div", {
						role: "presentation",
						className: b.a.particleWrapper
					}, e)
				}
				createParticle(e) {
					return i.a.createElement("div", {
						key: e,
						className: `${O()}`
					})
				}
			}
			var A = C;
			const y = e => {
				let {
					className: t,
					isGold: n,
					snoovatarUrl: o,
					prefersReducedAnimations: p,
					origin: f,
					userName: h
				} = e;
				const g = o && Object(u.d)(o),
					v = f === l.a.Profile,
					x = f === l.a.Hovercard,
					E = Object(a.e)(m.o);
				return g ? i.a.createElement(i.a.Fragment, null, i.a.createElement("div", {
					className: Object(r.a)({
						[b.a.profileTreatment]: v,
						[b.a.hovercardTreatment]: x
					})
				}, i.a.createElement("div", {
					className: Object(r.a)(b.a.nftProfileUnitContainer, {
						[b.a.nftProfileUnitContainerWithoutCta]: E
					})
				}, i.a.createElement(c.a, {
					className: b.a.nftProfileUnit,
					imageUrl: o,
					origin: f,
					showDetailsCta: !E
				}))), E && i.a.createElement("div", {
					className: b.a.showcase
				}, i.a.createElement(d.a, {
					origin: f,
					userName: h
				}))) : i.a.createElement("div", {
					className: Object(r.a)(b.a.snoovatarContainer, t)
				}, n && i.a.createElement(i.a.Fragment, null, i.a.createElement("div", {
					className: b.a.topGlow
				}), i.a.createElement("div", {
					className: b.a.bottomGlow
				}), !p && i.a.createElement(A, null)), i.a.createElement("img", {
					className: Object(r.a)(b.a.snoovatar, {
						[b.a.premiumGlow]: n
					}),
					src: o,
					alt: s.fbt._("User Avatar", null, {
						hk: "3aQoRV"
					})
				}))
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/UserInformation.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/icons/svgs/Admin/index.tsx"),
				d = n("./src/reddit/icons/svgs/Nsfw/index.tsx"),
				c = n("./src/reddit/icons/svgs/PremiumCircle/index.tsx"),
				l = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.m.less"),
				u = n.n(l);
			t.a = e => {
				let {
					title: t,
					username: n,
					isEmployee: o,
					isGold: l,
					isNSFW: m
				} = e;
				return i.a.createElement("h1", {
					className: u.a.snoovatarUserTitle
				}, t || n, o && i.a.createElement(a.a, {
					className: u.a.snoovatarAdminIcon,
					title: r.fbt._("Reddit admin", null, {
						hk: "goUUb"
					})
				}), l && i.a.createElement("a", {
					title: r.fbt._("{username} has Reddit Premium", [r.fbt._param("username", n)], {
						hk: "3Fylv"
					}),
					href: `${s.a.redditUrl}/premium`
				}, i.a.createElement(c.a, {
					className: u.a.snoovatarPremiumIcon
				})), m && i.a.createElement(d.a, {
					className: u.a.snoovatarNsfwIcon,
					title: r.fbt._("NSFW - Adult Content", null, {
						hk: "2Iw7mN"
					})
				}))
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.m.less": function(e, t, n) {
			e.exports = {
				snoovatarContainer: "_34XIqvI8-YT1wukR_W8vj6",
				profileTreatment: "_2xpFvOlDs0HF8bwR0pDmqt",
				hovercardTreatment: "_34eH8NsQ_ay5kowUWt9-6E",
				nftProfileUnitContainer: "OfvB_Czxn5wwXiBN6RVlG",
				nftProfileUnitContainerWithoutCta: "_3BzIc6FzgAGGhbAOD7PPEr",
				nftProfileUnit: "n5OW4wkmX5R3yYizuJXw1",
				showcase: "_rvftTJBQnr_blLyFQjK1",
				bottomGlow: "_18b8M-cZftX_frkYRy3DN1",
				topGlow: "_1-PwjX8ETMrfCu2hAkAHFd",
				snoovatar: "_2bLCGrtCCJIMNCZgmAMZFM",
				premiumGlow: "_18BjSGkpIVVfS1xJXL1eoW",
				snoovatarUserName: "_28nEhn86_R1ENZ59eAru8S",
				snoovatarUserTitle: "_3LM4tRaExed4x1wBfK1pmg",
				snoovatarSettingsLink: "PNl4tAYE2TRxhOc34iqcY",
				snoovatarAdminIcon: "kOKnXvA8jebkfk2wVIb9R",
				snoovatarNsfwIcon: "Wb4wBt474lETdwG0YpWID",
				snoovatarPremiumIcon: "_3NZUKOdsA_2X9TrZGSNQyP",
				particleWrapper: "_3sckwXGpSWEBLgH7dBHDSI",
				particle: "R8JC02qFTBSKsWVEamnnh",
				particleX0: "_2FHPkirHUUZZ53WuQRt_ku",
				particleX20: "DeM4CXWl9dmFhzxbChV3v",
				particleX40: "_2jQr36LfrhyZudo0c4r5qb",
				particleX60: "_2ThlCGLfserHkMW64od-w_",
				particleX80: "_2PoCUl_D7HnNn8GhlmyNMn",
				particleX100: "_3xLPb9tG5DMGKH5Qmq0lMn",
				particleFloat1: "_2Tlu1OsBOwuxXIF1MLT2k",
				floatUp1: "_1-74-z_0KhbvP-MLUh63RF",
				particleFloat2: "BW4L6Zj7IYZtY4carTDWz",
				floatUp2: "BhXouEsciSb0lIayg329d",
				particleFloat3: "UjQ0lRcZlylUigyKGCSrO",
				floatUp3: "_2cAI3EiKyyG1hMFOLbG7ka",
				particleFloat4: "_2_ke4gf08pfYrY6lP-aPZ_",
				floatUp1Left: "_2D7to5Dk7q0ZyKN3MMQfuJ",
				particleFloat5: "_2wM6_vp4fY0ziLkOrGaobV",
				floatUp2Left: "_3BR2d3YbOQLeA3LmAmwBJL",
				particleFloat6: "_23n0biPU5CQf96pEUSFupJ",
				floatUp3Left: "_3FnzyfIl1wHuAYA54rlkJH",
				particleDelay1: "_3meTYeYw1F3UdYO0v-gAYr",
				particleDelay2: "_3d8_fd8LwWsj0tyZWIeQdt",
				particleDelay3: "_2PLSBdnBk3jcotYknlKud1",
				particleDelay4: "_2pnTv5ZAxpIbkx38PkPJPg",
				particleDelay5: "_3j1NzwW_t2Ufnx4ed9QabN",
				particleDelay6: "_1hddWHnQ8DFnwilLlN9GEO",
				particleDelay7: "_3eRR1I_MwXC19q9sr8mKaR",
				particleDelay8: "_1sCUpg4sdajNDXrcNTP0qW",
				particleDelay9: "_3J5h1MCyY_xUf2QP7PDSHY",
				particleDelay10: "_2RqcLn9onSZQmKQgvKmSF7"
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/controls/InternalLink/index.tsx"),
				a = n("./src/reddit/helpers/trackers/marketplace/claims.ts"),
				d = n("./src/reddit/icons/fonts/index.tsx"),
				c = n("./src/reddit/selectors/experiments/econ/index.ts"),
				l = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/index.tsx"),
				u = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/TryItOn.tsx"),
				m = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserBanner/index.tsx"),
				p = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserName.tsx"),
				b = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.m.less"),
				f = n.n(b),
				h = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserProfile.m.less"),
				g = n.n(h),
				v = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/AvatarImage.tsx"),
				x = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/UserInformation.tsx");
			t.a = e => {
				let {
					bannerBackgroundImage: t,
					compact: n,
					currentUserHasSnoovatar: s,
					editMode: b,
					isDeletingBanner: h,
					isEmployee: E,
					isGold: O,
					isNSFW: C,
					isOwnProfile: A,
					onClickSnoovatar: y,
					onDeleteBanner: j,
					prefersReducedAnimations: I,
					snoovatarUrl: k,
					title: _,
					userCreated: S,
					username: w,
					url: T,
					isHovercard: P
				} = e;
				const N = Object(o.e)(e => !A && !!k && Object(c.f)(e));
				return r.a.createElement(r.a.Fragment, null, r.a.createElement(m.a, {
					bannerBackgroundImage: t,
					editMode: !!b,
					isNSFW: C,
					username: w,
					isDeletingBanner: !!h,
					onDeleteBanner: j
				}), !b && A && r.a.createElement(i.default, {
					to: "/settings/profile",
					className: f.a.snoovatarSettingsLink
				}, r.a.createElement(d.a, {
					name: "settings",
					className: g.a.settingsIcon
				})), r.a.createElement(v.a, {
					isGold: O,
					snoovatarUrl: k,
					prefersReducedAnimations: I,
					origin: P ? a.a.Hovercard : a.a.Profile,
					userName: w
				}), r.a.createElement(x.a, {
					isEmployee: E,
					isGold: O,
					isNSFW: C,
					title: _,
					username: w
				}), r.a.createElement(p.a, {
					className: f.a.snoovatarUserName,
					shouldDisplaySnoovatar: !0,
					username: w,
					userCreated: S,
					url: T
				}), (A || !s && !!k) && r.a.createElement(l.a, {
					compact: n,
					currentUserHasSnoovatar: s,
					isOwnProfile: A,
					onClick: y
				}), N && r.a.createElement(u.a, {
					username: w,
					isHovercard: !!P,
					share: {
						username: w
					}
				}))
			}
		},
		"./src/reddit/components/ProfileIdCard/index.m.less": function(e, t, n) {
			e.exports = {
				actionItem: "_1l7CTV4NjDjmzX8DiiSgTL",
				AwardedLastMonth: "oZjk-MiWCU7KVYej9wPSw",
				awardedLastMonth: "oZjk-MiWCU7KVYej9wPSw",
				textColumn: "_wi1DtT7oN7k_x5oIV8zm",
				iconColumn: "_32tzMaZn7x3dfQC5MXndJn",
				icon: "_12jN4wdttUosp76WHzuieI",
				count: "_6xPPP5HdELF-SZJL8layH",
				awardIcon: "_2Eq8z6UD7I0ul3wnZ-YT80",
				adminIcon: "_1sNQxemH_0rq1jtZAMyAZd",
				snoovatarAdminIcon: "_1rf3zLc4sH59mO7_BEXyze",
				snoovatarPremiumIcon: "_3QQFENUs15G6BHI5pjsswJ",
				button: "_2q1wcTx60QKM_bQ1Maev7b"
			}
		},
		"./src/reddit/components/ProgressBar/index.m.less": function(e, t, n) {
			e.exports = {
				innerBar: "Db3WJFTcyAR-IM0cIkpDG",
				outerBar: "i8kQtxHYBB8Sb3bPI4M_e"
			}
		},
		"./src/reddit/components/ProgressBar/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/ProgressBar/index.m.less"),
				a = n.n(i);
			t.a = e => {
				let {
					className: t,
					innerBarClassName: n,
					percent: s
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(a.a.outerBar, t)
				}, r.a.createElement("div", {
					className: Object(o.a)(a.a.innerBar, n),
					style: {
						width: `${s.toFixed(2)}%`
					}
				}))
			}
		},
		"./src/reddit/components/PromotedUserPostsAd/PromotedUserPost/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1FLO1Nek2YpspMr4ozmJCU"
			}
		},
		"./src/reddit/components/PromotedUserPostsAd/PromotedUserPostCommunityLink/index.m.less": function(e, t, n) {
			e.exports = {
				link: "_2sOYhKsA_6kr-jal5uxghX",
				subredditName: "Y6X1Z6XpPZ42HHxG6iPUg",
				subredditIcon: "_3KW4JGkWWYds_QkhJav3lV"
			}
		},
		"./src/reddit/components/PromotedUserPostsAd/PromotedUserPostInformation/index.m.less": function(e, t, n) {
			e.exports = {
				postInformation: "_1ykNwWxnTMBSi_9FpI1aS9",
				interactions: "_17rAVV4Z_xjSbW2Dnzd6GG",
				title: "_1hY0DyJaLGV23_ZN7lGZLl"
			}
		},
		"./src/reddit/components/PromotedUserPostsAd/PromotedUserPostMedia/index.m.less": function(e, t, n) {
			e.exports = {
				media: "N08zT4c39PJ7xCbcR2dhy",
				mediaThumbnail: "_9U9c34f1Ov1YZrnCNbH_e",
				mediaThumbnailContainer: "OBfGp3Y3pfXQbQtgTek4B",
				userIconContainer: "_1Xl-Y2ofyQhQDptuCNW3gg",
				userIconWrapper: "F_vBi78s0CDuAiX2g82hg",
				userIcon: "_3Ba5v_JdXj-iGcinxrYkz6",
				defaultUserIcon: "_2Jv4FE0k7dgPuiylbWWXJg",
				snoovatarUserIcon: "X3oFujh1WDeA5ZdMgFl_h"
			}
		},
		"./src/reddit/components/PromotedUserPostsAd/PromotedUserPosts/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2trYWJQru0_I7CsxK5kt7W"
			}
		},
		"./src/reddit/components/PromotedUserPostsAd/index.m.less": function(e, t, n) {
			e.exports = {
				container: "sMTOozCI4j186nHWW2jp4",
				communityLink: "_1iVqrl2JSOJGHlr6UhojWd"
			}
		},
		"./src/reddit/components/RawHTMLDisplay/index.m.less": function(e, t, n) {
			e.exports = {
				StyledRawHTMLDisplay: "_3ms2Z8z8rPWLXaErcTJ9yH",
				styledRawHtmlDisplay: "_3ms2Z8z8rPWLXaErcTJ9yH"
			}
		},
		"./src/reddit/components/RawHTMLDisplay/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/polished/dist/polished.es.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				d = n("./src/lib/lessComponent.tsx"),
				c = n("./src/reddit/actions/urlRequested.ts"),
				l = n("./src/reddit/hooks/useOutboundClickTracking.ts"),
				u = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				m = n("./src/reddit/components/RawHTMLDisplay/index.m.less"),
				p = n.n(m);
			const b = Object(i.b)(null, e => ({
					onNavigate: t => e(Object(c.a)(t))
				})),
				f = d.a.wrapped(e => {
					const t = Object(l.a)();
					return o.a.createElement("div", {
						className: e.className,
						dangerouslySetInnerHTML: {
							__html: e.html
						},
						onClick: n => {
							((e, t, n, s, r) => {
								if (!e.ctrlKey && !e.metaKey && 1 !== e.button && "A" === e.target.tagName) {
									e.preventDefault();
									const n = e.target.getAttribute("href");
									r && s(n, r), t(n)
								}
								e.target.classList && e.target.classList.contains("md-spoiler-text") && (e.target.dataset.revealed = !0), n && n(e)
							})(n, e.onNavigate, e.onClick, t, e.sourceElement)
						},
						style: {
							...e.style,
							"--RawHTMLDisplay-tr-even": Object(s.f)(Object(u.a)(e).body, .8),
							"--RawHTMLDisplay-tr-odd": Object(s.f)(Object(u.a)(e).line, .8)
						}
					})
				}, "StyledRawHTMLDisplay", p.a);
			t.a = b(Object(a.a)(f))
		},
		"./src/reddit/components/RecurringPostList/ChangePageButton/index.m.less": function(e, t, n) {
			e.exports = {
				button: "_1i9YssSDgp0wmEC43VdLTX",
				prevButton: "_2IBDYNRoTxtwgs13LWRpeM",
				arrowIcon: "QD6Re7us6VNRFNYSiD6to",
				disabled: "_3Lm3n-nPFfEcJoNjVwcm3r"
			}
		},
		"./src/reddit/components/RecurringPostList/EditModal/async.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-RecurringPostList-EditModal",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-RecurringPostList-EditModal").then(n.bind(null, "./src/reddit/components/RecurringPostList/EditModal/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/RecurringPostList/EditModal/index.tsx"
				}
			})
		},
		"./src/reddit/components/RecurringPostList/RecurringPost/ContentMeta/index.m.less": function(e, t, n) {
			e.exports = {
				contentRow: "Bt3uIal7yhwFSN9JorIng",
				contentRowMeta: "t6hD4d7F06TL2yv9vfp7h",
				title: "_3Evplg8YGmH6GDFsdQ0_nE",
				ownerName: "_215cUXwEuCE5hl0eYEIt_o",
				ownerNameContainer: "_2yAEv_Vw_ItUYbNbAjpSsL",
				flair: "hjSMaHLSFnG_4sOWtKODi"
			}
		},
		"./src/reddit/components/RecurringPostList/RecurringPost/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_29n8ITXzfA7e5YAUZXR5Tv",
				failedStateIndicator: "_3wJPsvksvDytrEsrrZd1vI",
				metaRow: "NjfRmSRZrEkWYNAACYBql",
				replayIcon: "_17pwQtUdmIHAeybqNegNzP",
				metaRowText: "qlCreM7NlHbkzV-xkEGE7",
				recurrenceRules: "rX2aiRDwgPF22x70hQxqp",
				parametricMetaData: "_3mlGpRO1Z1gZJkATQcRNHO",
				pencilIcon: "z5A_DxaYn2G2TQSSQCpi2"
			}
		},
		"./src/reddit/components/RecurringPostList/RecurringPost/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return F
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/telemetry/index.ts"),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/scheduledPosts/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/components/AuthorLink/index.tsx"),
				m = n("./src/reddit/components/Thumbnail/index.tsx"),
				p = n("./src/reddit/components/RecurringPostList/Thumbnail/index.m.less"),
				b = n.n(p);
			var f = e => {
					let {
						post: t
					} = e;
					return r.a.createElement("div", {
						className: b.a.thumbnailContainer
					}, r.a.createElement(m.b, {
						post: t,
						contentTypeClassName: b.a.placeholderIcon
					}))
				},
				h = n("./src/reddit/components/ScheduledPost/index.tsx"),
				g = n("./src/reddit/models/ScheduledPost/index.ts"),
				v = n("./node_modules/reselect/es/index.js"),
				x = n("./src/reddit/components/Flair/index.tsx"),
				E = n("./src/reddit/models/Flair/index.ts"),
				O = n("./src/reddit/components/RecurringPostList/RecurringPost/ContentMeta/index.m.less"),
				C = n.n(O);
			const {
				fbt: A
			} = n("./node_modules/fbt/lib/FbtPublic.js"), y = Object(v.c)({
				media: (e, t) => {
					let {
						scheduledPost: n
					} = t;
					const s = {
							...h.b
						},
						r = n.postKind === g.e.LINK;
					return r && (s.media = null), {
						...s,
						isNSFW: n.isNsfw,
						title: n.title,
						...r && {
							source: n.url
						},
						pollData: n.poll
					}
				}
			});
			var j = Object(o.b)(y)(e => {
					const {
						scheduledPost: t
					} = e, {
						isPostAsMetaMod: n,
						owner: s
					} = t, o = n ? l.l : Object(g.o)(s) ? s.name : void 0, i = e.scheduledPost.isNsfw ? E.f.Nsfw : e.scheduledPost.isSpoiler ? E.f.Spoiler : null, d = e.scheduledPost.isNsfw ? A._("nsfw", null, {
						hk: "22s23h"
					}) : e.scheduledPost.isSpoiler ? A._("spoiler", null, {
						hk: "3hUbmo"
					}) : null;
					return r.a.createElement("div", {
						className: Object(a.a)(C.a.contentRow, e.className)
					}, r.a.createElement(f, {
						post: e.media
					}), r.a.createElement("div", {
						className: C.a.contentRowMeta
					}, r.a.createElement("div", {
						className: C.a.title
					}, e.scheduledPost.title, i && r.a.createElement(x.a, {
						type: i,
						text: d.toString(),
						className: C.a.flair
					})), r.a.createElement("div", {
						className: C.a.ownerNameContainer
					}, o && r.a.createElement("span", {
						className: C.a.ownerName
					}, A._("by {username}", [A._param("username", r.a.createElement(u.a, {
						author: o,
						isUnstyled: !0
					}, `u/${o}`))], {
						hk: "FAgpK"
					})), e.children)))
				}),
				I = n("./src/reddit/components/ScheduledPost/OverflowMenu/withOverflowMenu.tsx");
			var k = Object(I.a)(e => r.a.createElement(r.a.Fragment, null, e.renderOverflowMenu())),
				_ = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				S = n("./src/reddit/endpoints/subredditModeration/doesUserHavePostPermission.ts"),
				w = n("./src/reddit/helpers/graphql/normalizeDoesUserHavePostModPermissionQuery/index.ts"),
				T = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				P = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				N = n("./src/reddit/hooks/useGqlContext.ts"),
				D = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				M = n("./src/reddit/icons/svgs/Replay/index.tsx"),
				R = n("./src/reddit/components/RecurringPostList/RecurringPost/index.m.less"),
				L = n.n(R);
			const {
				fbt: B
			} = n("./node_modules/fbt/lib/FbtPublic.js"), F = "RECURRING_POSTS__EDIT", U = Object(o.b)(null, (e, t) => ({
				editRecurringPostRequested: () => {
					e(Object(c.c)({
						id: t.item.id,
						subredditId: t.item.subreddit.id
					})), e((e, t) => Object(i.a)(Object(P.e)()(t()))), e(Object(d.i)(F))
				},
				onOpenOverflow: () => {
					e((e, t) => Object(i.a)(Object(P.h)(!0)(t())))
				},
				onUpdateMetadata: n => e(Object(c.b)(n, t.item))
			}));
			t.b = U(e => {
				const [t, n] = Object(s.useState)(!0), o = Object(N.a)(), {
					className: i,
					item: d,
					editRecurringPostRequested: c
				} = e, l = Object(T.e)(d), u = d.state === g.f.FAILED, {
					owner: m,
					subreddit: p
				} = d, b = Object(g.o)(m) && m.prefixedName, f = Object(g.o)(m) && m.name, h = p.name;
				Object(s.useEffect)(() => {
					(async () => {
						if (f && u) {
							const e = await Object(S.a)(o(), {
								subredditName: h,
								userName: f
							});
							e.ok && e.body && "data" in e.body && n(Object(w.a)(e.body.data))
						}
					})()
				}, [o, u, h, f]);
				const v = b && t ? r.a.createElement("div", {
					className: L.a.failedStateIndicator
				}, B._("Recurring post failed to submit. {Link: update recurring scheduled post} to reset", [B._param("Link: update recurring scheduled post", r.a.createElement(_.p, {
					onClick: c
				}, "Update schedule"))], {
					hk: "3Uitas"
				})) : r.a.createElement("div", {
					className: L.a.failedStateIndicator
				}, B._("The creator of this recurring post no longer has adequate permissions to submit it", null, {
					hk: "vKw3D"
				}));
				return r.a.createElement("div", {
					className: Object(a.a)(i, L.a.container)
				}, u && v, r.a.createElement("div", {
					className: L.a.metaRow
				}, r.a.createElement(M.a, {
					className: L.a.replayIcon
				}), r.a.createElement("div", {
					className: L.a.metaRowText
				}, r.a.createElement("div", {
					className: L.a.recurrenceRules,
					title: l
				}, l), r.a.createElement("div", null, B._("Scheduled by {=[post owner]}", [B._param("=[post owner]", r.a.createElement("span", {
					className: L.a.parametricMetaData
				}, B._("{post owner}", [B._param("post owner", b)], {
					hk: "25fi1G"
				})))], {
					hk: "36vTyl"
				}))), r.a.createElement("button", {
					onClick: c
				}, r.a.createElement(D.a, {
					className: L.a.pencilIcon
				}))), r.a.createElement(j, {
					scheduledPost: d
				}, r.a.createElement(k, {
					scheduledPost: d,
					onUpdateMetadata: e.onUpdateMetadata,
					onOpenOverflow: e.onOpenOverflow
				})))
			})
		},
		"./src/reddit/components/RecurringPostList/Thumbnail/index.m.less": function(e, t, n) {
			e.exports = {
				placeholderIcon: "_2rWvDY38-Fa_14y347Il6W",
				thumbnailContainer: "_3cYCw7NYRAJwj6LvL8esBu"
			}
		},
		"./src/reddit/components/RecurringPostList/index.m.less": function(e, t, n) {
			e.exports = {
				titleContainer: "p9wLLlADU1pVQu4nx3HCF",
				postList: "_1qL48rnJIqcVj5nNuXkDSw",
				pageButtonPortal: "_3lBUQT-Vexm0jXk3WmIYJq",
				recurringPostsContainer: "_2UggIw0Xee7HvpOtrWrepd",
				lastRecurringPostItem: "dx2RjIkNec1E2-a1DyP07",
				emptyContainer: "_1Aurc-hBrd1zsfrQxHeZoq",
				icon: "_1BRYUIpfNcLUEr5L8DeJ8i",
				schedulePostLink: "_1mxUgytAdxfLqJuzRgGifT"
			}
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/RemovalReasonsDropdown.m.less": function(e, t, n) {
			e.exports = {
				DisplayContainer: "_3B7pbtNVM5jh1ozdZuJTfI",
				displayContainer: "_3B7pbtNVM5jh1ozdZuJTfI",
				DropdownLabel: "_3MKcNYjenRkpopz-m6f8hM",
				dropdownLabel: "_3MKcNYjenRkpopz-m6f8hM",
				ReasonTitle: "_1Ecdul4Q_dxU9eOJXmoQuK",
				reasonTitle: "_1Ecdul4Q_dxU9eOJXmoQuK",
				Dropdown: "_3z_HE15Esmqgf6bBaj3Epi",
				dropdown: "_3z_HE15Esmqgf6bBaj3Epi",
				DropdownTriangle: "_2BZTmZOOcbQzMo7VdN3KB-",
				dropdownTriangle: "_2BZTmZOOcbQzMo7VdN3KB-",
				DropdownRow: "_3AVzUedTbFNFyaVtzLzahr",
				dropdownRow: "_3AVzUedTbFNFyaVtzLzahr",
				DropdownContainer: "_33sg6HoBYll4rCDqRzRUdu",
				dropdownContainer: "_33sg6HoBYll4rCDqRzRUdu"
			}
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.m.less": function(e, t, n) {
			e.exports = {
				scrollable: "_21FhZG1l_y8JORor55FKXY",
				CharacterCountdown: "_3QAHANdA13oJnYRmkNk6sb",
				characterCountdown: "_3QAHANdA13oJnYRmkNk6sb",
				EmptyState: "_1Wu9eKXKrc5e52itaXM9ny",
				emptyState: "_1Wu9eKXKrc5e52itaXM9ny",
				ModNoteDescription: "_2yxydSiZfhd3wo7e1VeMg3",
				modNoteDescription: "_2yxydSiZfhd3wo7e1VeMg3",
				PrimaryButton: "_3ECRi_xQqKANiwqaFL6bmr",
				primaryButton: "_3ECRi_xQqKANiwqaFL6bmr",
				RadioOption: "_30JuaHooKBU-I9UQwxEwhL",
				radioOption: "_30JuaHooKBU-I9UQwxEwhL",
				BoldText: "_22_ggqyuhsjDD3F2auyNjc",
				boldText: "_22_ggqyuhsjDD3F2auyNjc",
				ModNoteInput: "_1hTAtA-9TFnHvYJWXuSFsv",
				modNoteInput: "_1hTAtA-9TFnHvYJWXuSFsv",
				MessageInput: "_1PK5NQ4vO_RKB4KvIDUONs",
				messageInput: "_1PK5NQ4vO_RKB4KvIDUONs",
				Info: "_3Bf1PCbZnJJBM391IWRv8D",
				info: "_3Bf1PCbZnJJBM391IWRv8D",
				SmallInfoText: "ozxLnphBA3LqIKZJwfCoD",
				smallInfoText: "ozxLnphBA3LqIKZJwfCoD",
				FormOptionsContainer: "_3fRFatQ34rHHRS3sO1Pacm",
				formOptionsContainer: "_3fRFatQ34rHHRS3sO1Pacm",
				ModalFooter: "_3dFILDoNznUDwdP1jfpTz-",
				modalFooter: "_3dFILDoNznUDwdP1jfpTz-",
				FooterRow: "_1vxr-V4SeBtsrkFSGJB0O8",
				footerRow: "_1vxr-V4SeBtsrkFSGJB0O8",
				ButtonRow: "_3zZmX0EjloIkzwt2-sRI2_",
				buttonRow: "_3zZmX0EjloIkzwt2-sRI2_",
				toggleLabel: "_3J1Bs_5dR0qoQB1_kO03HR",
				toggleLabelText: "jGFen5TvAvfaFKwfUboOg",
				toggle: "_1W9ZWSmEnnxTPwKV-PJWCP"
			}
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "dispatcher", (function() {
				return Y
			})), n.d(t, "selector", (function() {
				return J
			})), n.d(t, "connector", (function() {
				return X
			})), n.d(t, "CharacterCountdown", (function() {
				return Z
			})), n.d(t, "EmptyState", (function() {
				return $
			})), n.d(t, "MessageInput", (function() {
				return oe
			})), n.d(t, "FormOptionsContainer", (function() {
				return de
			})), n.d(t, "ModalFooter", (function() {
				return ce
			})), n.d(t, "ButtonRow", (function() {
				return ue
			})), n.d(t, "AddRemovalReasonModal", (function() {
				return me
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/higherOrderComponents/asModal/index.tsx"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/actions/removalReasons/index.ts"),
				u = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				m = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				p = n("./src/reddit/components/TrackingHelper/index.tsx"),
				b = n("./src/reddit/controls/Button/index.tsx"),
				f = n("./src/reddit/controls/Checkbox/index.tsx"),
				h = n("./src/reddit/controls/InternalLink/index.tsx"),
				g = n("./src/reddit/controls/RadioInput/index.tsx"),
				v = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				x = n("./src/reddit/controls/TextButton/index.tsx"),
				E = n("./src/reddit/icons/fonts/Info/index.tsx"),
				O = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				C = n("./src/reddit/models/RemovalReason/index.ts"),
				A = n("./src/reddit/selectors/removalReasons.ts"),
				y = n("./src/reddit/selectors/subreddit.ts"),
				j = n("./src/reddit/selectors/telemetry.ts"),
				I = n("./src/reddit/selectors/user.ts"),
				k = n("./node_modules/fbt/lib/FbtPublic.js"),
				_ = n("./src/reddit/controls/Dropdown/index.tsx"),
				S = n("./src/reddit/controls/Dropdown/Row.tsx"),
				w = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				T = n("./src/reddit/layout/row/Inline/index.tsx"),
				P = n("./src/reddit/components/RemovalReasons/AddRemovalReasonModal/RemovalReasonsDropdown.m.less"),
				N = n.n(P);
			const D = c.a.wrapped(T.a, "DisplayContainer", N.a),
				M = c.a.div("DropdownLabel", N.a),
				R = c.a.div("ReasonTitle", N.a),
				L = e => r.a.createElement(D, null, r.a.createElement(M, null, e.dropdownLabel), e.selectedReason && r.a.createElement(R, null, e.selectedReason)),
				B = c.a.wrapped(_.a, "Dropdown", N.a),
				F = c.a.wrapped(w.b, "DropdownTriangle", N.a),
				U = c.a.wrapped(S.b, "DropdownRow", N.a),
				H = c.a.div("DropdownContainer", N.a);
			var G = e => r.a.createElement(H, {
					onClick: e.onToggleDropdown,
					"data-testid": "removal-reasons-dropdown"
				}, r.a.createElement(L, {
					dropdownLabel: e.isLoading ? k.fbt._("Loading...", null, {
						hk: "1bT6op"
					}) : k.fbt._("Reason for removal", null, {
						hk: "3C9ecg"
					}),
					selectedReason: e.selectedReason ? e.selectedReason.title : null
				}), r.a.createElement(F, null), e.isDropdownOpen && r.a.createElement(B, {
					isOverlay: !0
				}, r.a.createElement(U, {
					displayText: k.fbt._("None", null, {
						hk: "2443EZ"
					}),
					onClick: () => e.onSelectReason(null)
				}), e.subredditRemovalReasons.map((t, n) => r.a.createElement(U, {
					displayText: `${n+1}. ${t.title}`,
					key: t.title,
					onClick: () => e.onSelectReason(t)
				})))),
				Q = n("./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.m.less"),
				q = n.n(Q);

			function W() {
				return (W = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const {
				fbt: z
			} = n("./node_modules/fbt/lib/FbtPublic.js"), V = e => {
				switch (e) {
					case C.f.Private:
						return "private_subreddit";
					case C.f.PrivateExposed:
						return "private_personal";
					default:
						return e
				}
			}, K = {
				isDropdownOpen: !1,
				message: "",
				modNote: "",
				removalType: C.f.Public,
				selectedReason: null
			}, Y = e => ({
				submitBulkRemovalReason: (t, n, s, r, o) => e(Object(l.submitBulkRemovalReason)(t, n, s, r, o)),
				submitRemovalReason: (t, n, s, r, o, i) => e(Object(l.submitRemovalReason)(t, n, s, r, o, i))
			}), J = Object(i.c)({
				currentUserName: e => {
					const t = Object(I.m)(e);
					if (t) return t.displayText
				},
				isLoading: A.a,
				removalReasons: A.c,
				subredditName: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(y.X)(e, {
						subredditId: n
					}).name
				}
			}), X = Object(o.b)(J, Y), Z = c.a.wrapped(u.a, "CharacterCountdown", q.a), $ = c.a.div("EmptyState", q.a), ee = c.a.wrapped(m.o, "ModNoteDescription", q.a), te = c.a.wrapped(b.l, "PrimaryButton", q.a), ne = c.a.wrapped(v.a, "RadioOption", q.a), se = c.a.span("BoldText", q.a), re = c.a.wrapped(m.t, "ModNoteInput", q.a), oe = c.a.wrapped(m.t, "MessageInput", q.a), ie = c.a.wrapped(E.a, "Info", q.a), ae = c.a.div("SmallInfoText", q.a), de = c.a.div("FormOptionsContainer", q.a), ce = c.a.wrapped(m.g, "ModalFooter", q.a), le = c.a.div("FooterRow", q.a), ue = c.a.wrapped(le, "ButtonRow", q.a);
			class me extends r.a.Component {
				constructor(e) {
					super(e), this.trackClick = e => t => {
						const n = 1 === this.props.itemIds.length ? this.props.itemIds[0] : void 0;
						this.props.sendEvent(s => ({
							source: "removal_reasons",
							action: "click",
							noun: e,
							comment: n && Object(j.i)({
								state: s,
								commentId: n
							}) || null,
							post: n && Object(j.L)(s, n) || null,
							screen: Object(j.db)(s),
							subreddit: Object(j.nb)(s, this.props.subredditId),
							...t || {}
						}))
					}, this.onSelectRemovalType = e => {
						this.setState({
							removalType: e
						}), this.trackClick(`type_${V(e)}`)()
					}, this.onMessageInputChange = e => {
						this.setState({
							message: e.currentTarget.value
						})
					}, this.onUpdateModNote = e => {
						this.setState({
							modNote: e.currentTarget.value
						})
					}, this.handleToggleDropdown = () => this.setState({
						isDropdownOpen: !this.state.isDropdownOpen
					}), this.closeDropdown = () => {
						this.state.isDropdownOpen && this.setState({
							isDropdownOpen: !1
						})
					}, this.onSelectReason = e => {
						this.setState({
							selectedReason: e
						}), this.trackClick("reason")(), e && this.setState({
							message: e.message
						}), this.closeDropdown()
					}, this.canSave = () => !(this.state.message.length > C.a || this.state.modNote.length > C.b) && (this.state.selectedReason ? this.state.message.trim().length > 0 : this.state.modNote.trim().length > 0), this.onSubmit = () => {
						const {
							props: e,
							state: t
						} = this;
						if (this.canSave()) {
							(t.removalContextType === C.e.Bulk ? e.submitBulkRemovalReason : e.submitRemovalReason)(e.itemIds, t.selectedReason, t.message.trim(), t.removalType, t.modNote.trim(), [C.f.Public, C.f.PublicAsSubreddit].includes(t.removalType) && t.removalContextType !== C.e.Bulk ? t.isLocked : void 0);
							const n = {
								modAction: {
									removalreason: {
										notify: [C.f.Public, C.f.PublicAsSubreddit].includes(t.removalType) ? "comment" : "modmail",
										send_as: [C.f.Private, C.f.PublicAsSubreddit].includes(t.removalType) ? "subreddit" : "self",
										is_locked: t.isLocked
									}
								}
							};
							this.trackClick("sent")(n), t.selectedReason && this.trackClick(`sent_${V(t.removalType)}`)(n), t.modNote && this.trackClick("sent_modnote")(), e.toggleModal()
						}
					}, this.toggleIsLocked = () => {
						this.setState({
							isLocked: !this.state.isLocked
						})
					}, this.onCancel = () => {
						this.props.toggleModal(), this.trackClick("cancel")()
					}, this.renderRemovalTypeOptions = () => {
						const {
							props: e,
							state: t
						} = this, n = [];
						return t.removalContextType !== C.e.Bulk && (n.push(r.a.createElement(ne, {
							key: C.f.PublicAsSubreddit,
							showButton: !0,
							tabIndex: 0,
							value: C.f.PublicAsSubreddit
						}, r.a.createElement("div", null, t.removalContextType === C.e.Post ? z._("Public: Write a sticky comment on the post as Mod Team", null, {
							hk: "er8wA"
						}) : z._("Public: Write a reply to the comment as Mod Team", null, {
							hk: "1WMyjM"
						})))), n.push(r.a.createElement(ne, {
							key: C.f.Public,
							showButton: !0,
							tabIndex: 0,
							value: C.f.Public
						}, r.a.createElement("div", null, t.removalContextType === C.e.Post ? z._("Public: Write a sticky comment on the post as {currentUserName}", [z._param("currentUserName", r.a.createElement(se, null, `u/${e.currentUserName}`))], {
							hk: "2jsvEB"
						}) : z._("Public: Write a reply to the comment as {currentUserName}", [z._param("currentUserName", r.a.createElement(se, null, `u/${e.currentUserName}`))], {
							hk: "LZfBm"
						}))))), n.push(r.a.createElement(ne, {
							key: C.f.Private,
							showButton: !0,
							tabIndex: 0,
							value: C.f.Private
						}, r.a.createElement("div", null, z._("Private: send a Modmail from {subredditName} to the user", [z._param("subredditName", r.a.createElement(se, null, `r/${e.subredditName}`))], {
							hk: "1wUxMe"
						})))), e.currentUserName && n.push(r.a.createElement(ne, {
							key: C.f.PrivateExposed,
							showButton: !0,
							tabIndex: 0,
							value: C.f.PrivateExposed
						}, r.a.createElement("div", null, z._("Private: send a Modmail from {currentUserName} to the user", [z._param("currentUserName", r.a.createElement(se, null, `u/${e.currentUserName}`))], {
							hk: "wFSJr"
						})))), n
					}, this.state = {
						...K,
						removalType: C.f.PublicAsSubreddit,
						removalContextType: Object(C.g)(e.itemIds),
						isLocked: !0
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement(m.e, {
						onClick: this.closeDropdown
					}, e.isLoading || e.removalReasons.length > 0 && r.a.createElement(m.i, null, r.a.createElement(O.a, null, r.a.createElement(m.q, null, z._("Add a removal reason", null, {
						hk: "4odEgX"
					}), e.itemIds.length > 1 && z._("({number of items} posts/comments)", [z._param("number of items", e.itemIds.length)], {
						hk: "4u7ZzL"
					})), r.a.createElement(x.a, {
						onClick: this.onCancel
					}, r.a.createElement(m.b, null)))), r.a.createElement(m.l, {
						"data-testid": "add-removal-reason-modal"
					}, e.isLoading || e.removalReasons.length > 0 ? r.a.createElement(G, {
						isDropdownOpen: t.isDropdownOpen,
						isLoading: e.isLoading,
						onSelectReason: this.onSelectReason,
						onToggleDropdown: this.handleToggleDropdown,
						selectedReason: t.selectedReason,
						subredditRemovalReasons: e.removalReasons
					}) : r.a.createElement($, null, z._("You don't have any removal reasons yet", null, {
						hk: "2cPgPy"
					}), r.a.createElement(h.default, {
						to: `/r/${e.subredditName}/about/removal`,
						target: "_blank"
					}, r.a.createElement(b.r, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, z._("Add a removal reason", null, {
						hk: "3MHM7e"
					})))), t.selectedReason && r.a.createElement(de, null, r.a.createElement(m.h, null, r.a.createElement(g.a, {
						name: "REMOVAL_REASON_INPUT",
						onChange: this.onSelectRemovalType,
						value: t.removalType
					}, this.renderRemovalTypeOptions())), r.a.createElement(oe, {
						value: t.message,
						onChange: this.onMessageInputChange
					}), r.a.createElement(Z, {
						maxChars: C.a,
						text: t.message.trim()
					}), r.a.createElement(ae, null, t.removalType !== C.f.Public && t.removalType !== C.f.PublicAsSubreddit && r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, null), z._("A link to the removed content will be appended to your message", null, {
						hk: "1DbEGF"
					}))), (t.removalType === C.f.Public || t.removalType === C.f.PublicAsSubreddit) && t.removalContextType !== C.e.Bulk && r.a.createElement("label", {
						className: q.a.toggleLabel
					}, r.a.createElement(f.a, {
						className: q.a.toggle,
						isCheckboxSelected: !!t.isLocked,
						toggleCheckbox: this.toggleIsLocked
					}), r.a.createElement("span", {
						className: q.a.toggleLabelText
					}, z._("Lock removal reason comment thread", null, {
						hk: "1p3zeG"
					}))))), r.a.createElement(ce, null, r.a.createElement(le, null, r.a.createElement(ee, null, z._("Mod note (Only mods will see this note)", null, {
						hk: "3InAsy"
					}))), r.a.createElement(le, null, r.a.createElement(re, {
						placeholder: z._("This is a short note to your mod team on why the content was removed.", null, {
							hk: "4goqsC"
						}),
						value: t.modNote,
						onChange: this.onUpdateModNote
					})), r.a.createElement(le, null, r.a.createElement(Z, {
						maxChars: C.b,
						text: t.modNote.trim()
					})), r.a.createElement(ue, null, r.a.createElement(b.o, {
						onClick: this.onCancel,
						"data-redditstyle": !0
					}, z._("Cancel", null, {
						hk: "2TSLl5"
					})), r.a.createElement(te, {
						onClick: this.onSubmit,
						disabled: !this.canSave(),
						"data-redditstyle": !0
					}, z._("Submit", null, {
						hk: "4aU3dh"
					})))))
				}
			}
			const pe = Object(a.a)(X(Object(p.c)(me)));
			t.default = e => r.a.createElement(pe, W({}, e, {
				className: Object(d.a)(q.a.scrollable, e.className)
			}))
		},
		"./src/reddit/components/RemovalReasons/RemovalReasonEditorModal.m.less": function(e, t, n) {
			e.exports = {
				GenericGreetingText: "_1RYmGXZkbjV_9GAwCiqmLp",
				genericGreetingText: "_1RYmGXZkbjV_9GAwCiqmLp",
				DeleteReasonButton: "_3LU38GqHnVONELmzr-6CjS",
				deleteReasonButton: "_3LU38GqHnVONELmzr-6CjS",
				PrimaryButton: "_1Qw31YEY4D8vZqqnidfBid",
				primaryButton: "_1Qw31YEY4D8vZqqnidfBid",
				TextArea: "_2g19cC2dTjD8Ivp0iaxvPI",
				textArea: "_2g19cC2dTjD8Ivp0iaxvPI",
				ModalFooter: "a8KANZ6wvta1y_8QSZmeS",
				modalFooter: "a8KANZ6wvta1y_8QSZmeS",
				Input: "tWupUgopHVvjD9_bZZVy0",
				input: "tWupUgopHVvjD9_bZZVy0"
			}
		},
		"./src/reddit/components/RemovalReasons/RemovalReasonItem.m.less": function(e, t, n) {
			e.exports = {
				EditButton: "_3Z3niHttcaJCxThBE2-eNN",
				editButton: "_3Z3niHttcaJCxThBE2-eNN",
				Row: "_1ERpdeakuaRdyW5OEGvV_a",
				row: "_1ERpdeakuaRdyW5OEGvV_a",
				ReasonNumber: "_37ciCG1flXTYWdLXzWUVSP",
				reasonNumber: "_37ciCG1flXTYWdLXzWUVSP",
				ReasonText: "_3Vv7n3XK-P5uslyAy7Li0w",
				reasonText: "_3Vv7n3XK-P5uslyAy7Li0w"
			}
		},
		"./src/reddit/components/RemovalReasons/index.m.less": function(e, t, n) {
			e.exports = {
				Rules: "-z_XjylM-4VxXIVlUJupm",
				rules: "-z_XjylM-4VxXIVlUJupm",
				subtext: "_2IxjljuOnx5CrtK0CMzstT",
				title: "_1wclVdwRTNycOnlbH1IkQU",
				removalReasonsCount: "_1B3ouNDntikHo-PDWo9Gwk",
				tooltipContent: "_2KMnTQyMVHRHQBFfwLKxrJ",
				tooltip: "_3YCzepP6_mhRVOdUDnmkEo",
				newModNavContainer: "_3VkLnZ6qzCQG8iD4bJ5MG0",
				topBar: "_3x4yznlWub0TM6-jzBkTaC",
				fixed: "_2ZBGP1ob81JFdyxHOzgvG3",
				default: "_1RG-rNA42jCKqb7dvfCjay"
			}
		},
		"./src/reddit/components/RemovalReasons/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/constants/colors.ts"),
				m = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/actions/removalReasons/index.ts"),
				b = n("./src/reddit/actions/tooltip.ts"),
				f = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				h = n("./src/reddit/components/ContentTooltip/index.tsx"),
				g = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				v = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				x = n("./src/reddit/components/ModHub/NewModNav/PageLinks.tsx"),
				E = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				O = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				C = n("./src/reddit/controls/Button/index.tsx"),
				A = n("./src/reddit/helpers/localStorage/index.ts"),
				y = n("./src/reddit/icons/fonts/index.tsx"),
				j = n("./src/reddit/models/RemovalReason/index.ts"),
				I = n("./src/reddit/selectors/activeModalId.ts"),
				k = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				_ = n("./src/reddit/selectors/moderatorPermissions.ts"),
				S = n("./src/reddit/selectors/removalReasons.ts"),
				w = n("./src/reddit/selectors/subreddit.ts"),
				T = n("./src/higherOrderComponents/asModal/index.tsx"),
				P = n("./src/lib/lessComponent.tsx"),
				N = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				D = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				M = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				R = n("./src/reddit/controls/TextButton/index.tsx"),
				L = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				B = n("./src/reddit/components/RemovalReasons/RemovalReasonEditorModal.m.less"),
				F = n.n(B);
			const U = {
					message: "",
					title: ""
				},
				H = P.a.wrapped(D.f, "GenericGreetingText", F.a),
				G = P.a.wrapped(D.s, "DeleteReasonButton", F.a),
				Q = P.a.wrapped(C.l, "PrimaryButton", F.a),
				q = P.a.wrapped(D.t, "TextArea", F.a),
				W = P.a.wrapped(D.g, "ModalFooter", F.a),
				z = P.a.wrapped(M.c, "Input", F.a);
			class V extends i.a.Component {
				constructor(e) {
					super(e), this.onTitleInputChange = e => {
						e.currentTarget.value.length <= j.d && this.setState({
							title: e.currentTarget.value
						})
					}, this.onMessageInputChange = e => {
						this.setState({
							message: e.currentTarget.value
						})
					}, this.onSave = () => {
						const e = {
							title: this.state.title.trim(),
							message: this.state.message.trim()
						};
						this.props.removalReason && (e.id = this.props.removalReason.id), this.props.onSubmit(e), this.props.sendEvent(), this.props.toggleModal()
					}, this.canSave = () => this.state.title.trim().length > 0 && this.state.title.trim().length <= j.d && this.state.message.trim().length > 0 && this.state.message.trim().length <= j.a, this.state = e.removalReason ? {
						title: e.removalReason.title,
						message: e.removalReason.message
					} : U
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return i.a.createElement(D.e, null, i.a.createElement(D.i, null, i.a.createElement(L.a, null, i.a.createElement(D.q, null, e.removalReason ? r.fbt._("Edit removal reason", null, {
						hk: "1P0jAw"
					}) : r.fbt._("Add new reason", null, {
						hk: "jDYo"
					})), i.a.createElement(R.a, {
						onClick: e.toggleModal
					}, i.a.createElement(D.b, null)))), i.a.createElement(D.l, null, i.a.createElement(D.h, null, i.a.createElement(z, {
						placeholder: r.fbt._("Removal reason title", null, {
							hk: "4hFurd"
						}),
						value: t.title,
						onChange: this.onTitleInputChange
					}), i.a.createElement(N.a, {
						text: t.title.trim(),
						maxChars: j.d
					})), i.a.createElement(D.o, null, r.fbt._("Reason message:", null, {
						hk: "yMtrM"
					})), i.a.createElement(H, null, r.fbt._("Hi u/username,", null, {
						hk: "NE4XP"
					})), i.a.createElement(q, {
						placeholder: r.fbt._("Write a message that will communicate to the user why their post was removed.", null, {
							hk: "4u5AVO"
						}),
						value: t.message,
						onChange: this.onMessageInputChange,
						"data-redditstyle": !0
					}), i.a.createElement(N.a, {
						text: t.message.trim(),
						maxChars: j.a
					})), i.a.createElement(W, null, i.a.createElement(Q, {
						onClick: this.onSave,
						"data-redditstyle": !0,
						disabled: !this.canSave()
					}, e.removalReason ? r.fbt._("Save", null, {
						hk: "4yMsMq"
					}) : r.fbt._("Add new reason", null, {
						hk: "34P0ii"
					})), i.a.createElement(D.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), e.removalReason && i.a.createElement(G, {
						onClick: e.onDeleteReason
					}, r.fbt._("Delete", null, {
						hk: "4lt26q"
					}))))
				}
			}
			var K = Object(T.a)(V),
				Y = n("./src/reddit/layout/row/Inline/index.tsx"),
				J = n("./src/reddit/components/RemovalReasons/RemovalReasonItem.m.less"),
				X = n.n(J);
			const {
				fbt: Z
			} = n("./node_modules/fbt/lib/FbtPublic.js"), $ = P.a.wrapped(C.r, "EditButton", X.a), ee = P.a.wrapped(Y.a, "Row", X.a), te = P.a.div("ReasonNumber", X.a), ne = P.a.div("ReasonText", X.a);
			var se = e => i.a.createElement(ee, null, i.a.createElement(te, null, e.index + 1), i.a.createElement(ne, null, e.removalReason.title), i.a.createElement($, {
					onClick: e.onEdit,
					"data-redditstyle": !0
				}, Z._("Edit", null, {
					hk: "1nftDt"
				}))),
				re = n("./src/reddit/components/RemovalReasons/index.m.less"),
				oe = n.n(re);
			const ie = "RemovalReasons--Tooltip",
				ae = 1e4,
				de = {
					reasonToEdit: null
				},
				ce = Object(d.c)({
					isConfirmModalOpen: e => "RemovalReasons--Modal--DeleteConfirmation" === Object(I.a)(e),
					isRemovalReasonEditorModalOpen: e => "RemovalReasons--Editor--Modal" === Object(I.a)(e),
					removalReasons: S.c,
					isInShredditModNavExperiment: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = Object(_.n)(e, {
							subredditId: n
						});
						return Object(k.a)(e, !!s)
					},
					subredditName: (e, t) => {
						let {
							subredditId: n
						} = t;
						return Object(w.h)(e, {
							subredditId: n
						})
					}
				}),
				le = Object(a.b)(ce, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						addRemovalReason: t => e(Object(p.addRemovalReason)(n, t)),
						deleteRemovalReason: t => e(Object(p.deleteRemovalReason)(n, t)),
						editRemovalReason: t => e(Object(p.editRemovalReason)(n, t)),
						toggleConfirmationModal: () => e(Object(m.i)("RemovalReasons--Modal--DeleteConfirmation")),
						toggleReasonEditorModal: () => e(Object(m.i)("RemovalReasons--Editor--Modal")),
						onShowTooltip: t => e(Object(b.f)({
							tooltipId: t
						})),
						onHideTooltip: () => e(Object(b.i)())
					}
				});
			class ue extends i.a.Component {
				constructor(e) {
					super(e), this.isSticky = () => {
						const e = window.scrollY >= 100;
						this.setState({
							isFixed: e
						})
					}, this.onShowTooltip = () => {
						Object(A.y)() || (this.props.onShowTooltip(ie), setTimeout(() => {
							this.props.onHideTooltip()
						}, ae), Object(A.Yb)())
					}, this.onAddReason = () => {
						this.setState({
							reasonToEdit: null
						}), this.props.toggleReasonEditorModal(), this.props.sendEventWithName("add_new")()
					}, this.onEditReason = e => () => {
						this.setState({
							reasonToEdit: e
						}), this.props.toggleReasonEditorModal(), e && this.props.sendEventWithName("edit")()
					}, this.onClickTooltip = () => {
						this.props.onHideTooltip()
					}, this.renderReasonEditorModal = () => i.a.createElement(K, {
						onDeleteReason: () => {
							this.props.toggleReasonEditorModal(), this.props.toggleConfirmationModal()
						},
						onSubmit: this.state.reasonToEdit ? this.props.editRemovalReason : this.props.addRemovalReason,
						removalReason: this.state.reasonToEdit,
						sendEvent: this.state.reasonToEdit ? this.props.sendEventWithName("edit_save") : this.props.sendEventWithName("new_save"),
						subredditId: this.props.subredditId,
						toggleModal: this.onEditReason(null),
						withOverlay: !0
					}), this.renderTopBar = e => i.a.createElement(E.c, {
						className: Object(c.a)(e && "bg-neutral-background mb-xs pr-0", oe.a.topBar, {
							[oe.a.default]: !e,
							[oe.a.fixed]: this.state.isFixed
						})
					}, i.a.createElement(C.l, {
						onClick: this.onAddReason,
						disabled: this.props.removalReasons.length >= j.c || this.props.isRemovalReasonEditorModalOpen,
						"data-redditstyle": !0
					}, r.fbt._("Add removal reason", null, {
						hk: "2fHPVe"
					}))), this.state = {
						...de,
						isFixed: !this.props.isInShredditModNavExperiment
					}
				}
				componentDidMount() {
					this.onShowTooltip(), this.props.isInShredditModNavExperiment && window.addEventListener("scroll", this.isSticky)
				}
				componentWillUnmount() {
					this.props.isInShredditModNavExperiment && window.removeEventListener("scroll", this.isSticky)
				}
				render() {
					const {
						deleteRemovalReason: e,
						isConfirmModalOpen: t,
						isRemovalReasonEditorModalOpen: n,
						removalReasons: o,
						sendEventWithName: a,
						toggleConfirmationModal: d,
						isInShredditModNavExperiment: m,
						subredditName: p
					} = this.props;
					return i.a.createElement(i.a.Fragment, null, !m && this.renderTopBar(), i.a.createElement(E.a, {
						className: Object(c.a)(m && oe.a.newModNavContainer)
					}, m && p ? i.a.createElement(i.a.Fragment, null, Object(x.c)(p, l.mc.Removal), this.renderTopBar(!0)) : i.a.createElement(E.b, {
						className: oe.a.title
					}, r.fbt._("Removal reasons", null, {
						hk: "3IWxkH"
					}), i.a.createElement(v.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360010094892`
					})), i.a.createElement(O.o, {
						className: oe.a.subtext
					}, r.fbt._("Help people become better posters by giving a short reason why their post was removed.", null, {
						hk: "2X1Ma2"
					}), i.a.createElement("span", {
						className: oe.a.removalReasonsCount,
						id: ie,
						onClick: this.onClickTooltip
					}, i.a.createElement(h.a, {
						className: oe.a.tooltip,
						defaultTooltipPosition: "left",
						tooltipId: ie,
						caretColor: {
							right: u.a.alienblue
						}
					}, i.a.createElement("div", {
						className: oe.a.tooltipContent
					}, r.fbt._("NEW! Add up to 50 removal reasons.", null, {
						hk: "1LM0MR"
					}))), o.length, "/", j.c)), o.length > 0 ? o.map((e, t) => i.a.createElement(se, {
						index: t,
						key: e.id,
						onEdit: this.onEditReason(e),
						removalReason: e
					})) : i.a.createElement(g.c, {
						text: r.fbt._("No removal reasons yet", null, {
							hk: "1j70G1"
						})
					}, i.a.createElement(y.a, {
						name: "rules",
						className: oe.a.Rules
					}))), n && this.renderReasonEditorModal(), t && this.state.reasonToEdit && i.a.createElement(f.a, {
						actionText: r.fbt._("Delete", null, {
							hk: "4lt26q"
						}),
						headerText: r.fbt._("Delete reason", null, {
							hk: "q2qun"
						}),
						modalText: r.fbt._("Are you sure you want to delete this reason?", null, {
							hk: "1FTfMR"
						}),
						onConfirm: () => {
							this.state.reasonToEdit && e(this.state.reasonToEdit.id)
						},
						toggleModal: () => {
							d(), this.setState({
								reasonToEdit: null
							})
						},
						trackClick: a("delete"),
						withOverlay: !0
					}))
				}
			}
			t.a = le(ue)
		},
		"./src/reddit/components/ReportFlow/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/reddit/constants/colors.ts");
			const o = {
				backgroundColor: r.a.overlayReportFlow
			};
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "ReportFlow",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/components/ReportFlow/_ReportFlow.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ReportFlow/_ReportFlow.tsx"
				}
			})
		},
		"./src/reddit/components/ReportFlow/new.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/reddit/constants/colors.ts");
			const o = {
					backgroundColor: r.a.overlayReportFlow
				},
				i = Object(s.a)({
					resolved: {},
					chunkName: () => "ReportFlow",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/components/ReportFlow/_ReportFlowNewModal.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ReportFlow/_ReportFlowNewModal.tsx"
					}
				}),
				a = Object(s.a)({
					resolved: {},
					chunkName: () => "ReportFlowNew",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("ReportFlowNew").then(n.bind(null, "./src/reddit/components/ReportFlow/_ReportFlowNew.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ReportFlow/_ReportFlowNew.tsx"
					}
				});
			t.b = a
		},
		"./src/reddit/components/Reports/SnoozableReport/index.m.less": function(e, t, n) {
			e.exports = {
				ReportContainer: "rcWKqpRVFFbdiL-fFemgZ",
				reportContainer: "rcWKqpRVFFbdiL-fFemgZ",
				DropdownLabelContainer: "_3rsZ2ZF99dXi8CxIvlUnna",
				dropdownLabelContainer: "_3rsZ2ZF99dXi8CxIvlUnna",
				DropdownLabel: "_1NxoOUgmzKH04lLU9O6O6z",
				dropdownLabel: "_1NxoOUgmzKH04lLU9O6O6z",
				mActive: "_1mwLBQ-SAEJSG4hvYZzPUO",
				SnoozeButton: "_1QMSuJL3vFpEsGhWHllIQ5",
				snoozeButton: "_1QMSuJL3vFpEsGhWHllIQ5",
				SnoozeButtonContent: "tGdUIanRrFFgVZrnBwdl5",
				snoozeButtonContent: "tGdUIanRrFFgVZrnBwdl5"
			}
		},
		"./src/reddit/components/Reports/SnoozableReport/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/reddit/actions/comment/moderation.ts"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./src/reddit/actions/tooltip.ts"),
				m = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				p = n("./src/reddit/components/TrackingHelper/index.tsx"),
				b = n("./src/reddit/controls/Dropdown/index.tsx"),
				f = n("./src/reddit/controls/Dropdown/Row.tsx"),
				h = n("./src/reddit/helpers/isComment.ts"),
				g = n("./src/reddit/helpers/trackers/modTools.ts"),
				v = n("./src/reddit/icons/svgs/ChevronDown/index.tsx"),
				x = n("./src/reddit/icons/svgs/ChevronUp/index.tsx"),
				E = n("./src/reddit/icons/svgs/Clock/index.tsx"),
				O = n("./src/reddit/icons/svgs/Undo/index.tsx"),
				C = n("./src/reddit/selectors/tooltip.ts"),
				A = n("./src/reddit/components/Reports/SnoozableReport/index.m.less"),
				y = n.n(A);
			const {
				fbt: j
			} = n("./node_modules/fbt/lib/FbtPublic.js"), I = (e, t) => `SnoozableReport--${t}--${e}`, k = Object(o.b)(() => Object(i.c)({
				isDropdownOpen: (e, t) => Object(C.b)(I(t.reason, t.reportedThingId))(e)
			}), (e, t) => ({
				openDropdown: () => e(Object(u.h)({
					tooltipId: I(t.reason, t.reportedThingId)
				})),
				toggleSnooze: n => {
					Object(h.a)(t.reportedThingId) ? e(Object(c.h)(t.reportedThingId, t.reason, n)) : e(Object(l.fb)(t.reportedThingId, t.reason, n))
				}
			})), _ = Object(m.a)(b.a);
			class S extends r.a.Component {
				constructor() {
					super(...arguments), this.tooltipTarget = null, this.setTooltipTargetRef = e => this.tooltipTarget = e, this.onSnoozeButtonClick = () => {
						const e = this.props.isSnoozed ? d.kc.None : d.kc.Snoozed;
						this.props.toggleSnooze(e);
						const t = Object(g.r)(Object(h.a)(this.props.reportedThingId), this.props.isSnoozed, this.props.reportedThingId, this.props.reason);
						this.props.sendEvent(t)
					}
				}
				render() {
					const {
						reason: e,
						amount: t,
						reportedThingId: n,
						openDropdown: s,
						isDropdownOpen: o,
						isSnoozed: i,
						useNewFormat: d,
						className: c,
						dropdownClassName: l,
						iconClassName: u
					} = this.props, m = I(e, n);
					return r.a.createElement("div", {
						ref: this.setTooltipTargetRef
					}, r.a.createElement(f.b, {
						id: m,
						className: Object(a.a)(y.a.DropdownLabelContainer, c),
						onClick: s
					}, r.a.createElement("label", {
						htmlFor: m,
						className: y.a.DropdownLabel
					}, i ? j._("Reporter snoozed", null, {
						hk: "1rCWql"
					}) : d ? `${e} (${t})` : `${t}: ${e}`, o ? r.a.createElement(x.a, null) : r.a.createElement(v.a, null))), r.a.createElement(_, {
						isOpen: o,
						tooltipTarget: this.tooltipTarget,
						renderContentsHidden: !0,
						isOverlay: !1
					}, r.a.createElement("button", {
						className: Object(a.a)(y.a.SnoozeButton, l),
						onClick: this.onSnoozeButtonClick
					}, r.a.createElement("div", {
						className: y.a.SnoozeButtonContent
					}, i ? r.a.createElement(r.a.Fragment, null, r.a.createElement(O.a, {
						className: u
					}), j._("Undo snoozing reports from this user", null, {
						hk: "1CloXT"
					})) : r.a.createElement(r.a.Fragment, null, r.a.createElement(E.a, {
						className: u
					}), j._("Snooze reports from this user for 7 days", null, {
						hk: "1i0sOW"
					}))))))
				}
			}
			t.a = k(Object(p.c)(S))
		},
		"./src/reddit/components/ResizeSensor/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/raf/index.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o);
			class a extends i.a.Component {
				constructor(e) {
					super(e), this.isIE = () => /Trident/.test(navigator.userAgent), this.setContainerRef = e => {
						this.containerRef || (this.containerRef = e, this.createSensor())
					}, this.handleResize = () => {
						void 0 !== this.frame && r.a.cancel(this.frame), this.frame = r()(this.props.onResize)
					}, this.containerRef = e.containerRef
				}
				shouldComponentUpdate() {
					return !1
				}
				componentDidMount() {
					this.createSensor()
				}
				createSensor() {
					if (!this.containerRef || this.sensor) return;
					this.sensor = document.createElement("object"), this.sensor.setAttribute("style", "\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      height: 100%;\n      width: 100%;\n      overflow: hidden;\n      pointer-events: none;\n      z-index: -1;\n      visibility: hidden;\n    "), this.sensor.setAttribute("tabindex", "-1"), this.sensor.onload = () => {
						this.props.onResize(), this.sensor && this.sensor.contentDocument && this.sensor.contentDocument.defaultView && this.sensor.contentDocument.defaultView.addEventListener("resize", this.handleResize)
					}, this.sensor.type = "text/html";
					const e = this.isIE();
					e && this.containerRef.appendChild(this.sensor), this.sensor.data = "about:blank", e || this.containerRef.appendChild(this.sensor), this.props.onResize()
				}
				componentWillUnmount() {
					this.sensor && (this.sensor && this.sensor.contentDocument && this.sensor.contentDocument.defaultView && this.sensor.contentDocument.defaultView.removeEventListener("resize", this.handleResize), this.containerRef && this.containerRef.removeChild(this.sensor))
				}
				render() {
					return i.a.createElement("div", {
						ref: this.setContainerRef
					})
				}
			}
		},
		"./src/reddit/components/RestrictedFlatlistButton/index.m.less": function(e, t, n) {
			e.exports = {
				removalReasonButton: "_3IEDcFIIs_TeXsZtKZGzUd",
				TextWrapper: "smOzqVIOoNqmSJcyBX2N6",
				textWrapper: "smOzqVIOoNqmSJcyBX2N6",
				Button: "_1rNBkuuOkN2SorEXyRkYjB",
				button: "_1rNBkuuOkN2SorEXyRkYjB",
				ApproveButton: "_2T9IigN7CfZvuc5KSKs2hx",
				approveButton: "_2T9IigN7CfZvuc5KSKs2hx",
				RemoveButton: "_2OvUr_pd3kddsNP_f35S28",
				removeButton: "_2OvUr_pd3kddsNP_f35S28"
			}
		},
		"./src/reddit/components/RestrictedFlatlistButton/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/RestrictedFlatlistButton/index.m.less"),
				d = n.n(a);
			const c = e => r.a.createElement("button", {
					className: Object(o.a)(d.a.Button, e.className),
					disabled: e.disabled,
					id: e.id,
					onClick: e.disabled ? void 0 : e.onClick,
					onMouseEnter: e.onMouseEnter,
					onMouseLeave: e.onMouseLeave
				}, e.children, e.text && r.a.createElement("span", {
					className: Object(o.a)(d.a.TextWrapper, e.textClassName)
				}, e.text, " ")),
				l = i.a.wrapped(c, "ApproveButton", d.a),
				u = i.a.wrapped(c, "RemoveButton", d.a),
				m = e => r.a.createElement("button", {
					className: Object(o.a)(d.a.removalReasonButton, e.className),
					onClick: e.onClick
				}, e.text)
		},
		"./src/reddit/components/RichTextEditor/HoverTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				tooltip: "ki2VbfBhU-qxg1S6VyET6",
				above: "_8fNGSBGvr1Ds8PbrsUGzN",
				below: "_38gWvHp3NJkR5r5ftUfbFG",
				HoverTooltip: "Nb7NCPTlQuxN_WDPUg5Q2",
				hoverTooltip: "Nb7NCPTlQuxN_WDPUg5Q2"
			}
		},
		"./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = i.a.wrapped(e => {
				const {
					children: t,
					className: n,
					renderBelow: s,
					text: i,
					tooltipContentClass: a,
					...l
				} = e;
				return r.a.createElement("div", c({}, l, {
					className: Object(o.a)(d.a.container, n)
				}), i ? r.a.createElement("div", {
					className: Object(o.a)(d.a.tooltip, a, s ? d.a.below : d.a.above)
				}, i) : null, t)
			}, "HoverTooltip", d.a)
		},
		"./src/reddit/components/SEOTitle/constants.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e[e.Collection = 0] = "Collection", e[e.HeaderSelector = 1] = "HeaderSelector", e[e.PostComments = 2] = "PostComments", e[e.PostItem = 3] = "PostItem", e[e.TopicHeader = 4] = "TopicHeader", e[e.Widget = 5] = "Widget"
				}(s || (s = {})),
				function(e) {
					e[e.H1 = 1] = "H1", e[e.H2 = 2] = "H2", e[e.H3 = 3] = "H3", e[e.H4 = 4] = "H4", e[e.H5 = 5] = "H5", e[e.H6 = 6] = "H6"
				}(r || (r = {}))
		},
		"./src/reddit/components/SEOTitle/index.m.less": function(e, t, n) {
			e.exports = {
				Title: "_eYtD2XCVieq6emjKBH3m",
				title: "_eYtD2XCVieq6emjKBH3m"
			}
		},
		"./src/reddit/components/SEOTitle/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a.a
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/components/SEOTitle/constants.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/reddit/helpers/postCollection.ts");
			const l = [d.Tb.COMMENTS, d.Tb.COLLECTION_COMMENTS],
				u = (e, t) => {
					if (!e) return [];
					const n = l.includes(e),
						s = e === d.Tb.COLLECTION_COMMENTS || t && Object(c.a)(t),
						r = d.ab.has(e),
						o = d.Ib.has(e),
						i = e === d.Tb.SUBREDDIT,
						u = e === d.Tb.TOPIC;
					let m, p, b;
					return r && !i || o ? m = a.a.HeaderSelector : s ? m = a.a.Collection : n ? m = a.a.PostComments : u && (m = a.a.TopicHeader), (r || o || s || n) && (p = a.a.Widget), (r || n) && (b = a.a.PostItem), [m, p, b]
				};
			var m = n("./src/reddit/contexts/PageLayer/index.tsx"),
				p = n("./src/reddit/selectors/platform.ts"),
				b = n("./src/reddit/components/SEOTitle/index.m.less"),
				f = n.n(b);
			const h = e => {
					let {
						level: t,
						children: n
					} = e;
					const s = `h${t}`;
					return r.a.createElement(s, {
						className: f.a.Title
					}, n)
				},
				g = Object(m.v)(),
				v = Object(o.b)(() => Object(i.a)((e, t) => {
					let {
						pageLayer: n
					} = t;
					return n && Object(p.n)(e, {
						page: n
					})
				}, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return n && n.meta && n.meta.name
				}, (e, t) => {
					let {
						type: n
					} = t;
					return n
				}, (e, t, n) => ({
					level: u(t, e).indexOf(n) + 1 || void 0
				})));
			class x extends r.a.Component {
				render() {
					const {
						children: e,
						level: t
					} = this.props;
					return t ? r.a.createElement(h, {
						level: t
					}, e) : r.a.createElement(r.a.Fragment, null, e)
				}
			}
			t.b = g(v(x))
		},
		"./src/reddit/components/SaveIndicator/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_13ubiSSjUBWaeyJM-itH7X",
				titleFontH2: "_2V4_0G0gJO4R1v-_sO5D_j",
				titleFontH3: "_32Uo9qgINsZX5CSOtFM0e2",
				titleFontH4: "_2AWEwOuuK5wBnQGyiB5sSq",
				titleFontH5: "_8460KZXLwbKYkuLfDNr_-",
				titleFontH6: "_7GhKEQrcNu3JuSHqj9pJc",
				metadataFont: "qilOmvvpr4iY8iiHxuV5Y",
				flairFont: "SovT7HaLHcqz1BM9MWXPA",
				labelsFont: "_3Ngpaj84VwPqy3s6Tr3GEJ",
				actionFont: "_3RLwRjy5tGM8nl4kID8Tfg",
				smallButtonFont: "nb_OfRzzHKNkGteZC-TyY",
				largeButtonFont: "_2fhzAdDCEdDseFevwE6mBQ",
				strongTextFont: "_2vvi6WI_4yX2H2H-b2aBCF",
				tabFont: "_3E-egg7Cy7bL6JzsZuFTcn",
				buttonFontXS: "_2ubuuRpTK-U-kDLRRU6pyd",
				buttonFontXs: "_2ubuuRpTK-U-kDLRRU6pyd",
				buttonFontS: "_2fsKOual6xDsvmfB9Z_Gab",
				buttonFontM: "_3pHwBKAuUlalHSG7AJTpEP",
				buttonFontL: "fC3WZNZt7dm3kVDpkLV2",
				buttonFontXL: "_1A7d3cQhRmAUn05diOyF_D",
				buttonFontXl: "_1A7d3cQhRmAUn05diOyF_D",
				bodyFontH1: "_2_nWm6krUlDJnEF9pk7xNK",
				bodyFontH2: "_3zzd4vTmfrG1aK91i6m2j9",
				bodyFontH3: "_3tFwmsoGmyp52EFCoZ0GCV",
				bodyFontH4: "MdKdTVjxUaPPkDvG_msXr",
				bodyFontH5: "_2dNFOZceckCrwGYG8Avi-k",
				bodyFontH6: "_3sSb6LvOgvwy7eawwX4Gtq",
				bodyFontH6Small: "_1W_jjzqvHEQ70RO1EVPhFD",
				bodyFont: "_2fiuzofxgtB6yu9nAHLuqW",
				bodyFontSmall: "_2IcqO4djjAVsOalbW_Zpa9",
				bodyFontMono: "_2i_EmKzaFJfCskmkHdmmgJ",
				landingPageTitleFontH1: "_38v-SivLqoC13YgJLnTKY2",
				landingPageTitleFontH2: "_1hrSZ3nT5LOSDpPFUW2brX",
				landingPageTitleFontH3: "_3GRarSBJEUqY4ZXoU7J7Zj",
				icon: "cO908rcinWKz894i8I5jJ",
				pendingIcon: "U2dgL2i9_EJN8R_MLFTjS",
				savedIcon: "_1iGcF7LdvT-OMRgF7xKWqm",
				saveErrorIcon: "kWS-87C-v-iTlGGxQOmxu",
				caption: "_1MAESVWNqu44JbWmHGJsuI"
			}
		},
		"./src/reddit/components/ScheduledPost/ControlRow/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1xM2tjm8c7LuqnoEJG1Ws1",
				controlRow: "P7KCCrRfT4TO2wcnk_Kjv",
				controlRowItem: "_1AkGbjxtRpq3ZhKADdUTU3"
			}
		},
		"./src/reddit/components/ScheduledPost/MetaLine/index.m.less": function(e, t, n) {
			e.exports = {
				content: "_297_pyPlxmqBF0tLkUhTME",
				icon: "_1n_ojuNDT8JeH9DxmHJZt9",
				author: "_1k9D_vEsQ8odWCNERbDOxX",
				modIcon: "_3ryKOTfQ_vqgap0EZsZHAl",
				stickyIcon: "qfjbZcX6-FZK2BGrOXezD"
			}
		},
		"./src/reddit/components/ScheduledPost/MetaLine/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/reddit/components/AuthorLink/index.tsx"),
				a = n("./src/reddit/components/SubredditNameLink/index.tsx"),
				d = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				c = n("./src/reddit/icons/fonts/Sticky/index.tsx"),
				l = n("./src/reddit/icons/svgs/Moderate/index.tsx"),
				u = n("./src/reddit/models/ScheduledPost/index.ts"),
				m = n("./src/reddit/components/ScheduledPost/MetaLine/index.m.less"),
				p = n.n(m);
			class b extends r.a.PureComponent {
				render() {
					if (!Object(u.p)(this.props.subreddit)) return null;
					const {
						isModDistinguished: e,
						isPostAsMetaMod: t,
						subreddit: n,
						owner: s,
						isSticky: m
					} = this.props, b = t ? o.l : Object(u.o)(s) ? s.name : void 0;
					return r.a.createElement("span", {
						className: p.a.content
					}, r.a.createElement(a.a, {
						to: n.path
					}, n.prefixedName), b && r.a.createElement(r.a.Fragment, null, r.a.createElement(d.a, null), r.a.createElement(i.a, {
						className: p.a.author,
						author: b,
						isUnstyled: !0
					}, `u/${b}`)), e && r.a.createElement(l.a, {
						className: p.a.modIcon
					}), m && r.a.createElement(c.a, {
						className: p.a.stickyIcon
					}))
				}
			}
			t.a = b
		},
		"./src/reddit/components/ScheduledPost/OverflowMenu/withOverflowMenu.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./node_modules/fbt/lib/FbtPublic.js"),
				d = n("./src/reddit/components/OverflowMenu/index.tsx"),
				c = n("./src/reddit/controls/CheckboxMenuItem/index.tsx");
			var l = e => r.a.createElement(d.b, {
					dropdownId: `SCHEDULED_POST_DROPDOWN${e.scheduledPostId}`,
					onClick: e.onOpenOverflow
				}, r.a.createElement(c.a, {
					isSelected: e.isSticky,
					onClick: e.onToggleIsSticky,
					text: a.fbt._("Sticky post", null, {
						hk: "UOShB"
					})
				}), r.a.createElement(c.a, {
					isSelected: e.isModDistinguished,
					onClick: e.onToggleIsModDistinguished,
					text: a.fbt._("Distinguish as Mod", null, {
						hk: "3opu7K"
					})
				}), r.a.createElement(c.a, {
					isSelected: e.isOriginalContent,
					onClick: e.onToggleIsOC,
					text: a.fbt._("Mark as OC", null, {
						hk: "32LGcQ"
					})
				}), r.a.createElement(c.a, {
					isSelected: e.isNsfw,
					onClick: e.onToggleIsNsfw,
					text: a.fbt._("Mark as NSFW", null, {
						hk: "2qBIcp"
					})
				}), r.a.createElement(c.a, {
					isSelected: e.isSpoiler,
					onClick: e.onToggleIsSpoiler,
					text: a.fbt._("Mark as Spoiler", null, {
						hk: "rOev9"
					})
				})),
				u = n("./src/reddit/selectors/scheduledPosts/index.ts");
			const m = Object(i.c)({
					isLoading: u.j
				}),
				p = Object(o.b)(m);

			function b(e) {
				class t extends r.a.Component {
					constructor(e) {
						super(e), this.isSaving = !1, this.onToggleMetadata = e => {
							this.setState({
								...this.state,
								[e]: !this.state[e]
							}), this.isSaving = !0, this.props.onUpdateMetadata(e)
						}, this.onToggleIsSticky = () => this.onToggleMetadata("isSticky"), this.onToggleIsModDistinguished = () => this.onToggleMetadata("isModDistinguished"), this.onToggleIsOriginalContent = () => this.onToggleMetadata("isOriginalContent"), this.onToggleIsNsfw = () => this.onToggleMetadata("isNsfw"), this.onToggleIsSpoiler = () => this.onToggleMetadata("isSpoiler"), this.renderOverflowMenu = () => r.a.createElement(l, {
							scheduledPostId: this.props.scheduledPost.id,
							onOpenOverflow: this.props.onOpenOverflow,
							onToggleIsSticky: this.onToggleIsSticky,
							onToggleIsModDistinguished: this.onToggleIsModDistinguished,
							onToggleIsOC: this.onToggleIsOriginalContent,
							onToggleIsNsfw: this.onToggleIsNsfw,
							onToggleIsSpoiler: this.onToggleIsSpoiler,
							isModDistinguished: this.state.isModDistinguished,
							isOriginalContent: this.state.isOriginalContent,
							isNsfw: this.state.isNsfw,
							isSticky: this.state.isSticky,
							isSpoiler: this.state.isSpoiler
						}), this.state = {
							isModDistinguished: e.scheduledPost.isModDistinguished,
							isNsfw: e.scheduledPost.isNsfw,
							isOriginalContent: e.scheduledPost.isOriginalContent,
							isSpoiler: e.scheduledPost.isSpoiler,
							isSticky: !!e.scheduledPost.sticky && "NONE" !== e.scheduledPost.sticky
						}
					}
					componentDidUpdate(e) {
						e.isLoading && !this.props.isLoading && this.isSaving && (this.isSaving = !1, this.setState({
							isModDistinguished: this.props.scheduledPost.isModDistinguished || !1,
							isNsfw: this.props.scheduledPost.isNsfw || !1,
							isOriginalContent: this.props.scheduledPost.isOriginalContent || !1,
							isSpoiler: this.props.scheduledPost.isSpoiler || !1,
							isSticky: !!this.props.scheduledPost.sticky && "NONE" !== this.props.scheduledPost.sticky
						}))
					}
					render() {
						const {
							isLoading: t,
							scheduledPost: n,
							onUpdateMetadata: s,
							onOpenOverflow: o,
							...i
						} = this.props, a = {
							...i,
							renderOverflowMenu: this.renderOverflowMenu
						};
						return r.a.createElement(e, a)
					}
				}
				return t.displayName = `WithOverflowMenu(${e.displayName||e.name})`, p(t)
			}
		},
		"./src/reddit/components/ScheduledPost/PostTitle/index.m.less": function(e, t, n) {
			e.exports = {
				title: "_3jA9JBnv4bqmmiAw3Akmug"
			}
		},
		"./src/reddit/components/ScheduledPost/PostTitle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/ScheduledPost/PostTitle/index.m.less"),
				i = n.n(o);
			class a extends r.a.PureComponent {
				render() {
					return r.a.createElement("span", {
						className: i.a.title
					}, this.props.title)
				}
			}
			t.a = a
		},
		"./src/reddit/components/ScheduledPost/TopMetaLine/FailureMetaLine/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1YrhJ0z1RfTXg7jHYgApSr",
				error: "_2_f_ecVpbx4yoMzazJYkDP",
				retryButton: "_1KbjdUJVdbZQOJN8d6LTsX",
				parametricMetaData: "_2x3oXUTdLAKAob3BYLRkmH"
			}
		},
		"./src/reddit/components/ScheduledPost/TopMetaLine/TemporalMetaLine/index.m.less": function(e, t, n) {
			e.exports = {
				container: "qDE3oDok1392-t8IDOBfk",
				clock: "_2sfIhl6E6vfZCwxx54EUNB",
				parametricMetaData: "_3bAfM2inJTjD3ZXNzO5nE5"
			}
		},
		"./src/reddit/components/ScheduledPost/index.m.less": function(e, t, n) {
			e.exports = {
				body: "_320l2eVngsr4Ord9dXc2er",
				container: "_26zeT5d9JKXWbWzOT4ncpg",
				thumbnailContainer: "_2UwJRJuqEbkRCV8O6REq8h",
				mainBody: "_3pHV3zwe-Q9-xNEB0iM3WT",
				backgroundWrapper: "_2KWv8ukh9RMgpOturAiV9z",
				content: "hAQclO6xLNG3WDMgkywGo",
				flairList: "_1-tY_25z_pkhbFvUz2-AqS",
				Icon: "_3XIOnqmz8vxSaPmPEY11Wh",
				icon: "_3XIOnqmz8vxSaPmPEY11Wh"
			}
		},
		"./src/reddit/components/ScheduledPost/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return pe
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/telemetry/index.ts"),
				l = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				u = n("./src/reddit/actions/scheduledPosts/index.ts"),
				m = n("./src/reddit/actions/scheduledPosts/delete.ts"),
				p = n("./src/reddit/actions/scheduledPosts/edit.ts"),
				b = n("./src/lib/makeActionCreator/index.ts"),
				f = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				h = n("./src/reddit/actions/toaster.ts"),
				g = n("./src/reddit/actions/urlRequested.ts"),
				v = n("./src/lib/makeGqlRequest/index.ts"),
				x = n("./src/redditGQL/operations/SubmitScheduledPost.json");
			var E = n("./src/reddit/models/Toast/index.ts");
			const O = Object(b.a)(f.l),
				C = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const i = Object(a.p)(s(), {
						subredditId: e,
						scheduledPostId: t
					});
					if (!i) return void n(Object(h.f)(Object(h.e)(f.u(), E.b.Error)));
					const d = await ((e, t) => Object(v.a)(e, {
						...x,
						variables: t
					}))(o(), {
						input: {
							id: i.id
						}
					});
					if (!d.ok) return void n(Object(h.f)(Object(h.e)(f.v(), E.b.Error, f.s(), C(e, t))));
					const c = d.body.data.submitScheduledPost.post.permalink;
					n(Object(g.a)(c, !1)), n(Object(h.f)(Object(h.e)(f.x(), E.b.SuccessCommunity))), n(O({
						subredditId: e,
						scheduledPostId: t
					}))
				};
			var A = n("./src/reddit/components/ClassicPost/Thumbnail.tsx"),
				y = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				j = n("./src/reddit/components/FlairList/index.tsx"),
				I = n("./src/reddit/components/PostLeftRail/index.tsx"),
				k = n("./src/reddit/components/VerticalVotes/DisabledVerticalVotes.tsx"),
				_ = n("./src/reddit/constants/thumbnails.ts"),
				S = n("./src/reddit/helpers/styles/mixins/index.tsx"),
				w = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				T = n("./src/reddit/models/PostCreationForm/index.ts"),
				P = n("./src/reddit/models/ScheduledPost/index.ts"),
				N = n("./src/reddit/components/ScheduledPost/OverflowMenu/withOverflowMenu.tsx"),
				D = n("./src/lib/classNames/index.ts"),
				M = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				R = n("./src/reddit/icons/svgs/Post/index.tsx"),
				L = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				B = n("./src/reddit/components/ScheduledPost/ControlRow/index.m.less"),
				F = n.n(B);
			const U = e => {
				const {
					icon: t,
					onClick: n
				} = e;
				return o.a.createElement("span", {
					onClick: n,
					className: Object(D.a)(F.a.controlRowItem, e.className)
				}, o.a.createElement(t, {
					className: F.a.icon
				}), " ", e.text)
			};
			class H extends o.a.Component {
				render() {
					return o.a.createElement("span", {
						className: F.a.controlRow
					}, this.props.onSubmitPostNow && o.a.createElement(U, {
						icon: R.a,
						text: s.fbt._("Submit post now", null, {
							hk: "QkS4y"
						}),
						onClick: this.props.onSubmitPostNow
					}), o.a.createElement(U, {
						icon: M.a,
						text: s.fbt._("Edit", null, {
							hk: "1nftDt"
						}),
						onClick: this.props.onEditScheduledPost
					}), o.a.createElement(U, {
						icon: L.b,
						text: s.fbt._("Delete", null, {
							hk: "1uVY7w"
						}),
						onClick: this.props.onDeleteScheduledPost
					}), this.props.renderOverflowMenu())
				}
			}
			var G = Object(N.a)(H),
				Q = n("./src/reddit/components/ScheduledPost/MetaLine/index.tsx"),
				q = n("./src/reddit/components/ScheduledPost/PostTitle/index.tsx"),
				W = n("./src/reddit/endpoints/subredditModeration/doesUserHavePostPermission.ts"),
				z = n("./src/reddit/helpers/graphql/normalizeDoesUserHavePostModPermissionQuery/index.ts"),
				V = n("./src/reddit/hooks/useGqlContext.ts"),
				K = n("./src/reddit/icons/svgs/ClearFilled/index.tsx"),
				Y = n("./src/reddit/components/ScheduledPost/TopMetaLine/FailureMetaLine/index.m.less"),
				J = n.n(Y);
			const {
				fbt: X
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			var Z = Object(i.b)(null, (e, t) => {
					let {
						scheduledPost: n
					} = t;
					return {
						onSubmitPostNow: () => {
							e(C(n.subreddit.id, n.id)), e((e, t) => Object(c.a)(Object(w.n)()(t())))
						},
						onViewFailedPost: () => e((e, t) => Object(c.a)(Object(w.w)()(t(), n)))
					}
				})(e => {
					const [t, n] = Object(r.useState)(!0), s = Object(V.a)(), {
						scheduledPost: i,
						onViewFailedPost: a,
						onSubmitPostNow: d
					} = e, {
						owner: c,
						subreddit: l
					} = i, u = Object(P.o)(c) && c.prefixedName, m = Object(P.o)(c) && c.name, p = l.name;
					return Object(r.useEffect)(() => {
						a(), (async () => {
							if (m) {
								const e = await Object(W.a)(s(), {
									subredditName: p,
									userName: m
								});
								e.ok && e.body && "data" in e.body && n(Object(z.a)(e.body.data))
							}
						})()
					}, [a, s, p, m]), o.a.createElement("div", {
						className: J.a.container
					}, o.a.createElement("div", null, o.a.createElement(K.a, {
						className: J.a.error
					}), u && t ? X._("Post failed to submit! Please {=retry}", [X._param("=retry", o.a.createElement("button", {
						className: J.a.retryButton,
						onClick: d
					}, X._("retry", null, {
						hk: "hER94"
					})))], {
						hk: "4yOnl8"
					}) : X._("The creator of this post no longer has adequate permissions to submit it. {=retry}", [X._param("=retry", o.a.createElement("button", {
						className: J.a.retryButton,
						onClick: d
					}, X._("retry", null, {
						hk: "1mBjoH"
					})))], {
						hk: "3W4lB"
					})), o.a.createElement("div", null, X._("Scheduled by {=[post owner]}", [X._param("=[post owner]", o.a.createElement("span", {
						className: J.a.parametricMetaData
					}, X._("{post owner}", [X._param("post owner", u)], {
						hk: "25fi1G"
					})))], {
						hk: "36vTyl"
					})))
				}),
				$ = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				ee = n("./src/reddit/icons/svgs/Clock/index.tsx"),
				te = n("./src/reddit/components/ScheduledPost/TopMetaLine/TemporalMetaLine/index.m.less"),
				ne = n.n(te);
			const {
				fbt: se
			} = n("./node_modules/fbt/lib/FbtPublic.js"), re = e => {
				return `${Object($.c)(e.publishAt)} ${Object($.d)(e.clientTimezone).displayText}`
			};
			class oe extends o.a.PureComponent {
				render() {
					const {
						scheduledPost: e
					} = this.props, {
						owner: t
					} = e, n = Object(P.o)(t) && t.prefixedName;
					return o.a.createElement("div", {
						className: ne.a.container
					}, o.a.createElement(ee.a, {
						className: ne.a.clock
					}), o.a.createElement("div", null, o.a.createElement("div", null, se._("This post is scheduled for {=[time]}", [se._param("=[time]", o.a.createElement("span", {
						className: ne.a.parametricMetaData
					}, se._("{time}", [se._param("time", re(e))], {
						hk: "JrMs3"
					})))], {
						hk: "4gFrnr"
					})), o.a.createElement("div", null, se._("Scheduled by {=[post owner]}", [se._param("=[post owner]", o.a.createElement("span", {
						className: ne.a.parametricMetaData
					}, se._("{post owner}", [se._param("post owner", n)], {
						hk: "25fi1G"
					})))], {
						hk: "36vTyl"
					}))))
				}
			}
			var ie = oe;
			class ae extends o.a.PureComponent {
				render() {
					const {
						scheduledPost: e
					} = this.props;
					switch (e.state) {
						case P.f.FAILED:
							return o.a.createElement(Z, {
								scheduledPost: e
							});
						case P.f.PROCESSING:
						case P.f.CREATED:
						default:
							return o.a.createElement(ie, {
								scheduledPost: e
							})
					}
				}
			}
			var de = ae,
				ce = n("./src/reddit/helpers/styles/mixins/index.m.less"),
				le = n.n(ce),
				ue = n("./src/reddit/components/ScheduledPost/index.m.less"),
				me = n.n(ue);
			const pe = {
					isNSFW: !1,
					media: {
						content: "",
						markdownContent: "",
						isRichtextPreview: !0,
						mediaMetadata: null,
						obfuscated: null,
						richtextContent: {
							document: []
						},
						rteMode: T.i.RICH_TEXT,
						type: "rtjson"
					},
					thumbnail: {
						url: _.a.DEFAULT,
						width: null,
						height: null
					},
					title: "",
					source: null,
					isSponsored: !1
				},
				be = Object(d.c)({
					media: (e, t) => {
						let {
							scheduledPostId: n,
							subredditId: s
						} = t;
						const r = Object(a.p)(e, {
							subredditId: s,
							scheduledPostId: n
						});
						if (!r) return null;
						const o = {
								...pe
							},
							i = r.postKind === P.e.LINK;
						return i && (o.media = null), {
							...o,
							isNSFW: r.isNsfw,
							title: r.title,
							...i && {
								source: r.url
							},
							pollData: r.poll
						}
					},
					flair: (e, t) => {
						let {
							scheduledPostId: n,
							subredditId: s
						} = t;
						const r = Object(a.p)(e, {
							subredditId: s,
							scheduledPostId: n
						});
						return r ? Object(a.m)({
							scheduledPost: r
						}) : null
					},
					scheduledPost: (e, t) => {
						let {
							scheduledPostId: n,
							subredditId: s
						} = t;
						return Object(a.p)(e, {
							subredditId: s,
							scheduledPostId: n
						})
					}
				}),
				fe = Object(i.b)(be, (e, t) => {
					let {
						scheduledPostId: n,
						subredditId: s
					} = t;
					return {
						onSubmitPostNow: () => {
							e(C(s, n)), e((e, t) => Object(c.a)(Object(w.n)()(t())))
						},
						onEditScheduledPost: () => {
							e(Object(p.b)(s, n)), e((e, t) => Object(c.a)(Object(w.d)()(t())))
						},
						onDeleteScheduledPost: () => e(Object(m.a)(s, n)),
						onOpenOverflow: () => {
							e((e, t) => Object(c.a)(Object(w.h)(!1)(t())))
						},
						onUpdateMetadata: t => e((e, r) => {
							const o = Object(a.p)(r(), {
								subredditId: s,
								scheduledPostId: n
							});
							o && e(Object(u.b)(t, o))
						})
					}
				});
			class he extends o.a.PureComponent {
				constructor(e) {
					super(e), this.onSubmitPostNow = () => this.setState({
						submitConfirmModalIsOpen: !0
					}), this.onCancelSubmitPostNow = () => this.setState({
						submitConfirmModalIsOpen: !1
					}), this.onConfirmSubmitPostNow = () => this.props.onSubmitPostNow(), this.onEditScheduledPost = () => {
						this.props.onEditScheduledPost()
					}, this.onDeleteScheduledPost = () => this.setState({
						deleteConfirmModalIsOpen: !0
					}), this.onCancelDeleteScheduledPost = () => this.setState({
						deleteConfirmModalIsOpen: !1
					}), this.onConfirmDeleteScheduledPost = () => this.props.onDeleteScheduledPost(), this.state = {
						deleteConfirmModalIsOpen: !1,
						submitConfirmModalIsOpen: !1
					}
				}
				render() {
					const {
						media: e,
						flair: t,
						scheduledPost: n
					} = this.props;
					return e && t && n ? o.a.createElement("div", {
						className: me.a.container
					}, o.a.createElement(de, {
						scheduledPost: n
					}), o.a.createElement("div", {
						className: le.a.classicPostStyles
					}, o.a.createElement(I.b, null, o.a.createElement(k.a, null)), o.a.createElement("div", {
						style: Object(S.c)(void 0, this.props),
						className: me.a.backgroundWrapper
					}, o.a.createElement("div", {
						className: me.a.mainBody
					}, o.a.createElement("div", {
						className: me.a.thumbnailContainer
					}, o.a.createElement(A.a, {
						post: e
					})), o.a.createElement("div", {
						className: me.a.content
					}, o.a.createElement("div", null, o.a.createElement(q.a, {
						title: n.title
					}), o.a.createElement(j.a, {
						className: me.a.flairList,
						flair: t
					})), o.a.createElement(Q.a, {
						isModDistinguished: n.isModDistinguished,
						isPostAsMetaMod: n.isPostAsMetaMod,
						isSticky: !!n.sticky && "NONE" !== n.sticky,
						subreddit: n.subreddit,
						owner: n.owner
					}), o.a.createElement(G, {
						onSubmitPostNow: n.state === P.f.FAILED ? void 0 : this.onSubmitPostNow,
						onEditScheduledPost: this.onEditScheduledPost,
						onDeleteScheduledPost: this.onDeleteScheduledPost,
						onUpdateMetadata: this.props.onUpdateMetadata,
						scheduledPost: n,
						onOpenOverflow: this.props.onOpenOverflow
					}))))), this.state.deleteConfirmModalIsOpen && o.a.createElement(y.a, {
						onClose: this.onCancelDeleteScheduledPost,
						onCancel: this.onCancelDeleteScheduledPost,
						onConfirm: this.onConfirmDeleteScheduledPost,
						actionText: s.fbt._("Delete", null, {
							hk: "1WN0R6"
						}),
						modalText: s.fbt._("Are you sure you want to delete this scheduled post? This action cannot be undone.", null, {
							hk: "1EdQC7"
						}),
						withOverlay: !0
					}), this.state.submitConfirmModalIsOpen && o.a.createElement(y.a, {
						onClose: this.onCancelSubmitPostNow,
						onCancel: this.onCancelSubmitPostNow,
						onConfirm: this.onConfirmSubmitPostNow,
						actionText: s.fbt._("Submit", null, {
							hk: "3kl12J"
						}),
						modalText: s.fbt._("Are you sure you want to submit this scheduled post now? This action cannot be undone.", null, {
							hk: "18O8dB"
						}),
						withOverlay: !0
					})) : null
				}
			}
			t.a = Object(l.a)(fe(he))
		},
		"./src/reddit/components/SearchResultsContent/searchResultsPageTreatment/searchIgnoreClickContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js");
			const r = Object(s.createContext)(!1);

			function o() {
				return Object(s.useContext)(r)
			}
		},
		"./src/reddit/components/Settings/shared/SectionHeading.m.less": function(e, t, n) {
			e.exports = {
				Component: "BotIImuktRA9aFAPP0O4Z",
				component: "BotIImuktRA9aFAPP0O4Z"
			}
		},
		"./src/reddit/components/Settings/shared/SectionHeading.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/components/Settings/shared/SectionHeading.m.less"),
				r = n.n(s),
				o = n("./src/lib/lessComponent.tsx");
			t.a = o.a.h3("Component", r.a)
		},
		"./src/reddit/components/Settings/shared/Widgets.m.less": function(e, t, n) {
			e.exports = {
				Label: "asxizthf5kZpmoY27VBKd",
				label: "asxizthf5kZpmoY27VBKd",
				HoverTooltip: "_1qQQ7O7znXpzgcC5RgQFtW",
				hoverTooltip: "_1qQQ7O7znXpzgcC5RgQFtW",
				ControlContainer: "_1kylDjSQ2hay_ez0zF7BEP",
				controlContainer: "_1kylDjSQ2hay_ez0zF7BEP",
				TextContainer: "_3dLmvT0hpACHFxhncqzCOr",
				textContainer: "_3dLmvT0hpACHFxhncqzCOr",
				inModal: "_2O2JPVgOlh8J6OW_9ur4BQ",
				ActionContainer: "_1oREjd5ToMFah-VfX5Zt1z",
				actionContainer: "_1oREjd5ToMFah-VfX5Zt1z",
				Wrapper: "_2f63as5b5FASHMqGd5P1o0",
				wrapper: "_2f63as5b5FASHMqGd5P1o0",
				isCreateCommunity: "_38bDTwLcytTCF-174R0UXB",
				mColumn: "_1HH_g-CLQB1BPcqOhZcakt",
				mLast: "_3Lu6XJyVbSLDVKDx-wue2g",
				mIndent: "_2D65jEbgD16ae_sJ8BG4AD",
				mDisabled: "LvI7FSBTGgYo2skaf18Zv",
				Subtext: "_1NdK7EwgYqUxJObBr3ym4o",
				subtext: "_1NdK7EwgYqUxJObBr3ym4o",
				RangeSlider: "_2J8tywkkd4Gotm3jZ2Gcv0",
				rangeSlider: "_2J8tywkkd4Gotm3jZ2Gcv0",
				isNightModeOn: "KUWYDFs7fIjkQNSOL_BR6",
				Wrapper__LineBreak: "wVinKyEoajEmwhqwINYGd",
				wrapperLineBreak: "wVinKyEoajEmwhqwINYGd",
				ActionHintText: "_2sMk-Gi9c8T3BKYlxSopql",
				actionHintText: "_2sMk-Gi9c8T3BKYlxSopql",
				Link: "oFObIzV6ZJDQuG09BXh8u",
				link: "oFObIzV6ZJDQuG09BXh8u",
				SubtextLink: "_3MGA27y-8plrsOsPbyYwgs",
				subtextLink: "_3MGA27y-8plrsOsPbyYwgs",
				LinkIcon: "_3gg7WkHbAGiySOBOzb9k6F",
				linkIcon: "_3gg7WkHbAGiySOBOzb9k6F",
				LinkButton: "_3I7YVr4pIJiOGmmJdgsEXK",
				linkButton: "_3I7YVr4pIJiOGmmJdgsEXK",
				ArrowRight: "_1oH-o0mDV86imeLnyfmCiD",
				arrowRight: "_1oH-o0mDV86imeLnyfmCiD",
				NoColor: "mI7WmWMma8pZnlYRHtE56",
				noColor: "mI7WmWMma8pZnlYRHtE56",
				StyledFlair: "_1F2irboi-xRChkhyndP6ct",
				styledFlair: "_1F2irboi-xRChkhyndP6ct",
				SpoilerFlair: "_3mkE4WZP2_bhfSQvrpeIka",
				spoilerFlair: "_3mkE4WZP2_bhfSQvrpeIka",
				NSFWFlair: "_1mPvZAvMvenP80lJ1RnQdE",
				nsfwFlair: "_1mPvZAvMvenP80lJ1RnQdE",
				DropdownWrapper: "_1D4YEzJAywC1b-Jx_on2cZ",
				dropdownWrapper: "_1D4YEzJAywC1b-Jx_on2cZ",
				DropdownRow: "_1ekKroexYAQllqx2MfTHbi",
				dropdownRow: "_1ekKroexYAQllqx2MfTHbi",
				Row: "_1QNl7IkO4tmBTG1Cp8_ZBk",
				row: "_1QNl7IkO4tmBTG1Cp8_ZBk",
				DropdownTriangle: "_2VFl8Aqe76Ulg9-x85FKpH",
				dropdownTriangle: "_2VFl8Aqe76Ulg9-x85FKpH",
				DescriptionsRow: "H3CGfLrRo4H9tQdWd5vG9",
				descriptionsRow: "H3CGfLrRo4H9tQdWd5vG9",
				Circle: "_20H2GFMG6B0Lai4Q3DhIE2",
				circle: "_20H2GFMG6B0Lai4Q3DhIE2",
				RangeSliderInput: "_2ieOPsoffMpHmDwvrKLRjg",
				rangeSliderInput: "_2ieOPsoffMpHmDwvrKLRjg",
				Ticks: "_3BLGt0e8kYgLHkUbAeXTWG",
				ticks: "_3BLGt0e8kYgLHkUbAeXTWG",
				TickText: "_1hEYjTFCxEu2ILobPvatAp",
				tickText: "_1hEYjTFCxEu2ILobPvatAp",
				PreSubText: "_2_hv6QgJ151j9WmCyETVfC",
				preSubText: "_2_hv6QgJ151j9WmCyETVfC",
				MultiLineInputSettingsBottomRow: "hgvQ7UQa9_0jmXSzQjqhF",
				multiLineInputSettingsBottomRow: "hgvQ7UQa9_0jmXSzQjqhF",
				ActionLinkContainer: "e4RehzaESS5nfk-O6pYoK",
				actionLinkContainer: "e4RehzaESS5nfk-O6pYoK",
				input: "_14_SnmD6g3FrozcKjTpqoH",
				tag: "_1GQzFyg5xYq94euL74ZaeJ"
			}
		},
		"./src/reddit/components/Settings/shared/Widgets.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "o", (function() {
				return q
			})), n.d(t, "l", (function() {
				return Y
			})), n.d(t, "p", (function() {
				return X
			})), n.d(t, "f", (function() {
				return $
			})), n.d(t, "m", (function() {
				return te
			})), n.d(t, "n", (function() {
				return oe
			})), n.d(t, "q", (function() {
				return ie
			})), n.d(t, "k", (function() {
				return pe
			})), n.d(t, "b", (function() {
				return be
			})), n.d(t, "g", (function() {
				return fe
			})), n.d(t, "a", (function() {
				return he
			})), n.d(t, "d", (function() {
				return ve
			})), n.d(t, "i", (function() {
				return xe
			})), n.d(t, "c", (function() {
				return Ee
			})), n.d(t, "e", (function() {
				return Oe
			})), n.d(t, "h", (function() {
				return Ce
			})), n.d(t, "j", (function() {
				return Ae
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/react-uid/dist/es2015/hooks.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/higherOrderComponents/asTooltip.tsx"),
				u = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				m = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				p = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				b = n("./src/reddit/controls/Dropdown/index.tsx"),
				f = n("./src/reddit/controls/Dropdown/Row.tsx"),
				h = n("./src/reddit/controls/FormFields/index.tsx"),
				g = n("./src/lib/lessComponent.tsx"),
				v = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				x = n("./src/reddit/controls/Select/index.m.less"),
				E = n.n(x);

			function O() {
				return (O = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const C = g.a.span("Wrapper", E.a),
				A = g.a.select("Inner", E.a),
				y = g.a.wrapped(v.b, "Caret", E.a);

			function j(e) {
				let {
					className: t,
					innerClassName: n,
					...s
				} = e;
				const o = s.disabled ? {
					"data-disabled": s.disabled
				} : {};
				return r.a.createElement(C, {
					className: t
				}, r.a.createElement(A, O({
					className: n
				}, s)), r.a.createElement(y, O({
					isSubreddit: !0
				}, o)))
			}
			var I = n("./src/reddit/controls/ToggleSwitch/index.tsx"),
				k = n("./src/reddit/controls/Typography/index.tsx"),
				_ = n("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				S = n("./src/reddit/icons/svgs/Circle/index.tsx"),
				w = n("./src/reddit/icons/svgs/OutboundLink/index.tsx"),
				T = n("./node_modules/lodash/range.js"),
				P = n.n(T),
				N = n("./src/reddit/controls/Button/index.tsx"),
				D = n("./src/reddit/layout/row/Inline/index.tsx"),
				M = n("./src/reddit/models/Flair/index.ts"),
				R = n("./src/reddit/selectors/tooltip.ts"),
				L = n("./src/reddit/selectors/user.ts"),
				B = n("./src/reddit/components/Settings/shared/Widgets.m.less"),
				F = n.n(B);

			function U() {
				return (U = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const H = Object(l.a)(b.a),
				G = g.a.wrapped(S.a, "Circle", F.a),
				Q = g.a.h3("Label", F.a),
				q = g.a.wrapped(k.c, "Subtext", F.a),
				W = g.a.wrapped(m.a, "HoverTooltip", F.a),
				z = g.a.div("ControlContainer", F.a),
				V = g.a.div("TextContainer", F.a),
				K = g.a.div("ActionContainer", F.a),
				Y = e => {
					let {
						className: t,
						direction: n,
						isCreateCommunity: s,
						inModal: o,
						isNightModeOn: i,
						disabled: a,
						indent: c,
						last: l,
						...u
					} = e;
					return r.a.createElement("div", U({}, u, {
						className: Object(d.a)(F.a.Wrapper, t, {
							[F.a.mColumn]: "column" === n,
							[F.a.mDisabled]: !!a,
							[F.a.mIndent]: !!c,
							[F.a.mLast]: !!l,
							[F.a.isCreateCommunity]: !!s,
							[F.a.inModal]: !!o,
							[F.a.isNightModeOn]: !!i
						})
					}))
				},
				J = g.a.a("Link", F.a),
				X = g.a.wrapped(J, "SubtextLink", F.a),
				Z = g.a.wrapped(w.a, "LinkIcon", F.a),
				$ = g.a.button("LinkButton", F.a),
				ee = g.a.wrapped(_.a, "ArrowRight", F.a),
				te = e => r.a.createElement(Y, {
					direction: e.direction,
					disabled: e.disabled,
					indent: e.indent,
					isCreateCommunity: e.isCreateCommunity,
					last: e.last
				}, r.a.createElement(V, {
					className: e.textContainerClassName
				}, r.a.createElement(Q, null, e.label, e.isRequired && r.a.createElement(G, null)), r.a.createElement(q, null, e.subtext)), r.a.createElement(K, null, e.children)),
				ne = g.a.div("StyledFlair", F.a),
				se = g.a.wrapped(ne, "SpoilerFlair", F.a),
				re = g.a.wrapped(ne, "NSFWFlair", F.a),
				oe = e => {
					switch (e.flair) {
						case M.f.Nsfw:
							return r.a.createElement(re, null, "NSFW");
						case M.f.Spoiler:
							return r.a.createElement(se, null, "SPOILER");
						default:
							return null
					}
				},
				ie = e => {
					const t = Object(i.a)();
					return r.a.createElement(Y, {
						className: e.className,
						disabled: e.disabled,
						indent: e.indent,
						last: e.last
					}, r.a.createElement(V, null, r.a.createElement(D.a, null, r.a.createElement("label", {
						htmlFor: t,
						className: e.labelClassname
					}, r.a.createElement(Q, null, e.label))), r.a.createElement(q, null, e.subtext)), r.a.createElement(K, null, r.a.createElement(z, null, e.tooltip && r.a.createElement(W, {
						tooltipContentClass: e.tooltipContentClassName,
						text: e.tooltip
					}), r.a.createElement(I.a, {
						id: t,
						on: e.on,
						forceOn: e.forceOn,
						onToggle: e.onClick,
						disabled: e.disabled
					}))))
				},
				ae = g.a.input("RangeSliderInput", F.a),
				de = g.a.div("RangeSlider", F.a),
				ce = g.a.div("Ticks", F.a),
				le = g.a.div("TickText", F.a),
				ue = g.a.span("PreSubText", F.a),
				me = Object(a.c)({
					isNightModeOn: L.fb
				}),
				pe = Object(o.b)(me)(e => {
					const t = Object(i.a)();
					return r.a.createElement(Y, {
						last: e.last,
						indent: e.indent,
						disabled: e.disabled,
						inModal: e.inModal,
						isNightModeOn: e.isNightModeOn,
						direction: e.direction,
						className: e.className
					}, r.a.createElement(V, {
						style: {
							flex: 5
						}
					}, !e.inModal && r.a.createElement(D.a, null, r.a.createElement("label", {
						htmlFor: t
					}, r.a.createElement(Q, {
						className: e.labelClassname
					}, e.label))), !e.hideSubtext && r.a.createElement(q, null, " ", r.a.createElement(ue, {
						style: {
							color: e.ticks[e.value].color
						}
					}, " ", e.ticks[e.value].text + ": ", " "), " ", e.subtext)), r.a.createElement(K, {
						style: {
							flex: 3,
							margin: "20px 20px 0 0"
						}
					}, r.a.createElement(de, null, r.a.createElement(ae, {
						id: t,
						style: {
							background: "linear-gradient(to right, " + P()(1, e.max + 1).map((t, n) => t <= e.value ? `${e.ticks[e.value].color} ${(t-1)/e.max*100}%,\n                    ${e.ticks[e.value].color} ${t/e.max*100-1}%,\n                    #fff ${t/e.max*100-1}%,\n                    #fff ${t/e.max*100}%` : t !== e.max ? `#c5c5c5 ${(t-1)/e.max*100}%, #c5c5c5 ${t/e.max*100-1}%,\n                    #fff ${t/e.max*100-1}%,\n                    #fff ${t/e.max*100}%` : `#c5c5c5 ${(t-1)/e.max*100}%`) + ", #C5C5C5 100%)"
						},
						className: "range-slider-input",
						type: "range",
						min: e.min,
						max: e.max,
						step: e.step,
						value: e.value,
						onChange: e.onChange,
						onInput: e.onChange,
						disabled: e.disabled
					}), r.a.createElement(ce, null, Object.keys(e.ticks).map((t, n) => r.a.createElement(le, {
						key: t,
						style: {
							color: t === e.value.toString() ? e.ticks[t].color : "#878A8C"
						}
					}, e.ticks[t].text))))))
				}),
				be = e => r.a.createElement(Y, {
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, r.a.createElement(V, null, r.a.createElement(D.a, null, r.a.createElement(Q, null, e.label)), r.a.createElement(q, null, e.subtext)), r.a.createElement(K, null, r.a.createElement(z, null, r.a.createElement(N.o, {
					onClick: e.onClick
				}, e.actionText)))),
				fe = e => r.a.createElement(Y, {
					className: e.className,
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, r.a.createElement(V, null, r.a.createElement(J, {
					href: e.link,
					onClick: e.onClick,
					target: e.openInNewTab ? "_blank" : void 0
				}, e.label, r.a.createElement(Z, null)), r.a.createElement(q, null, e.subtext)), r.a.createElement(K, null, r.a.createElement(J, {
					href: e.link,
					onClick: e.onClick,
					target: e.openInNewTab ? "_blank" : void 0
				}, r.a.createElement(ee, null)))),
				he = e => r.a.createElement(Y, {
					className: e.className,
					disabled: e.disabled,
					indent: e.indent,
					last: e.last
				}, r.a.createElement(V, null, r.a.createElement($, {
					onClick: e.onClick,
					className: Object(d.a)({
						[F.a.NoColor]: e.color && "none" === e.color
					})
				}, e.label), r.a.createElement(q, null, e.subtext)), r.a.createElement(K, null, !!e.hintText && r.a.createElement("div", {
					className: F.a.ActionHintText
				}, e.hintText), r.a.createElement($, {
					onClick: e.onClick,
					className: Object(d.a)({
						[F.a.NoColor]: e.color && "none" === e.color
					})
				}, r.a.createElement(ee, {
					className: Object(d.a)({
						[F.a.NoColor]: e.color && "none" === e.color
					})
				})))),
				ge = Object(a.c)({
					isOpen: (e, t) => Object(R.b)(t.id)(e)
				}),
				ve = Object(o.b)(ge, (e, t) => ({
					openDropdown: () => {
						e(Object(c.h)({
							tooltipId: t.id
						}))
					}
				}))(e => r.a.createElement(Y, {
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, r.a.createElement(V, null, r.a.createElement(Q, null, e.label), r.a.createElement(q, null, e.subtext)), r.a.createElement(K, null, (e => r.a.createElement("div", {
					className: F.a.DropdownWrapper,
					onClick: e.openDropdown
				}, r.a.createElement("span", {
					className: F.a.Row,
					id: `SettingDropdown--${e.id}`
				}, e.displayTitle || e.selected), r.a.createElement(v.b, {
					className: F.a.DropdownTriangle
				}), r.a.createElement(H, {
					container: void 0,
					isOpen: e.isOpen,
					renderContentsHidden: !0,
					isOverlay: !1,
					tooltipId: `SettingDropdown--${e.id}`
				}, e.items.map((t, n) => r.a.createElement(f.b, {
					className: F.a.DropdownRow,
					displayText: e.displayItems ? e.displayItems[n] : t,
					isSelected: e.selected === t,
					onClick: () => e.onClick(t),
					key: "row--" + n,
					item: t
				}))), e.descriptions && r.a.createElement("div", {
					className: F.a.DescriptionsRow
				}, e.descriptions[e.items.indexOf(e.selected)] || e.displayItems && e.descriptions[e.displayItems.indexOf(e.selected)])))(e)))),
				xe = e => {
					let {
						disabled: t,
						last: n,
						onClick: o,
						onChange: i,
						...a
					} = e;
					const d = Object(s.useCallback)(e => i(e.target.value), [i]),
						{
							items: c
						} = a;
					return r.a.createElement(Y, {
						disabled: t
					}, r.a.createElement(V, null, r.a.createElement("label", {
						htmlFor: a.id
					}, r.a.createElement(Q, {
						className: a.labelClassname
					}, a.label)), r.a.createElement(q, null, a.subtext)), r.a.createElement("div", {
						className: F.a.Wrapper__LineBreak
					}), r.a.createElement(Y, {
						last: n,
						indent: !0,
						disabled: t
					}, r.a.createElement(j, {
						id: a.id,
						className: "redditStyle",
						disabled: t || a.inputDisabled,
						onChange: d,
						value: a.selected
					}, c.map(e => {
						let {
							value: t,
							displayName: n
						} = e;
						return r.a.createElement("option", {
							key: t,
							value: t
						}, n)
					}))))
				},
				Ee = e => r.a.createElement(Y, {
					className: e.className,
					direction: e.direction,
					disabled: e.disabled,
					indent: e.indent,
					last: e.last
				}, r.a.createElement(V, null, r.a.createElement(Q, null, e.label), r.a.createElement(q, null, e.subtext)), r.a.createElement(K, null, e.children)),
				Oe = e => r.a.createElement(te, {
					isCreateCommunity: e.isCreateCommunity,
					isRequired: e.isRequired,
					label: e.label,
					subtext: e.subtext,
					direction: "column",
					textContainerClassName: e.textContainerClassName
				}, e.isCreateCommunity && r.a.createElement("span", {
					className: F.a.tag
				}, "r/"), r.a.createElement(h.a, {
					className: e.isCreateCommunity ? F.a.input : void 0,
					disabled: !!e.disabled,
					onChange: e.onChange,
					placeholder: e.placeholder,
					maxLength: e.maxChars,
					type: "text",
					value: e.value,
					onBlur: e.onBlur
				}), !e.hideCountdown && r.a.createElement(u.a, {
					maxChars: e.maxChars,
					text: e.value
				})),
				Ce = e => r.a.createElement(te, {
					isCreateCommunity: e.isCreateCommunity,
					isRequired: e.isRequired,
					label: e.label,
					subtext: e.subtext,
					direction: "column",
					textContainerClassName: e.textContainerClassName
				}, r.a.createElement(p.i, {
					disabled: !1,
					onChange: e.onChange,
					onFocus: e.onFocus,
					placeholder: e.placeholder,
					maxLength: e.maxChars,
					rows: e.rows || 4,
					style: {
						marginBottom: e.isCreateCommunity ? "4px" : 0,
						resize: e.isCreateCommunity ? "vertical" : "both"
					},
					value: e.value,
					onBlur: e.onBlur
				}), r.a.createElement("div", {
					className: F.a.MultiLineInputSettingsBottomRow
				}, !e.hideCountdown && r.a.createElement(u.a, {
					maxChars: e.maxChars,
					text: e.value || ""
				}), !!e.actionLink && r.a.createElement("div", {
					className: F.a.ActionLinkContainer
				}, e.actionLink))),
				Ae = e => r.a.createElement(Y, {
					className: e.className,
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, r.a.createElement(V, null, r.a.createElement(Q, null, e.label), r.a.createElement(q, null, e.subtext)), r.a.createElement(K, null, r.a.createElement(J, {
					href: e.link,
					onClick: e.onClick,
					"aria-label": e.linkLabel
				}, r.a.createElement(ee, null))))
		},
		"./src/reddit/components/ShareMenu/index.m.less": function(e, t, n) {
			e.exports = {
				dropdown: "PWY92ySDjTYrTAiutq4ty",
				dropdownRow: "_2snJGyyGyyH38duHobOUKE",
				linkIcon: "_1GObrri0j7y_9IWiGUfPjp",
				chatIcon: "_1PhtucoKocd-ADJ-JDEoiC",
				crosspostIcon: "_1m76BHzDzRsM1te7HBxUqd",
				embedIcon: "_3MSdPVJwGxrpakz-e1MQhO",
				modalBody: "T4VmKX-IOkP4UG-B4jUR-"
			}
		},
		"./src/reddit/components/ShareMenu/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/config.ts"),
				d = n("./src/lib/addQueryParams/index.ts"),
				c = n("./src/reddit/actions/chat/toggle.ts"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./src/reddit/actions/tooltip.ts"),
				m = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				p = n("./src/reddit/controls/Dropdown/index.tsx"),
				b = n("./src/reddit/controls/Dropdown/Row.tsx"),
				f = n("./src/reddit/constants/tracking.ts"),
				h = n("./src/reddit/selectors/telemetry.ts");
			var g = n("./src/reddit/hooks/useTracking.ts"),
				v = n("./src/reddit/icons/fonts/index.tsx"),
				x = n("./src/reddit/models/Subreddit/index.ts"),
				E = n("./src/reddit/routes/postCreation/constants.ts"),
				O = n("./src/reddit/selectors/experiments/chat.ts"),
				C = n("./src/reddit/selectors/tooltip.ts"),
				A = n("./src/reddit/components/ShareMenu/index.m.less"),
				y = n.n(A);
			const j = Object(m.a)(p.a),
				I = e => {
					let {
						permalink: t,
						onShare: n
					} = e;
					return o.a.createElement(b.b, {
						id: "shareToChat",
						className: y.a.dropdownRow,
						displayText: s.fbt._("share to chat", null, {
							hk: "3EuIWT"
						}),
						onClick: () => {
							const e = Object(d.a)(t, {
								utm_source: "share",
								utm_medium: "web2x",
								context: 3
							});
							n(e)
						}
					}, o.a.createElement(v.a, {
						name: "chat",
						className: y.a.chatIcon
					}))
				},
				k = e => {
					let {
						permalink: t,
						sendEventWithName: n
					} = e;
					return o.a.createElement(b.b, {
						className: y.a.dropdownRow,
						displayText: s.fbt._("Embed", null, {
							hk: "2CcsuC"
						}),
						onClick: () => {
							n("share_embed"), window.open(`${a.a.rebedMediaUrl}/embed?url=${t}`, "RedditEmbed", "height=500,width=650,modal=yes,alwaysRaised=yes")
						}
					}, o.a.createElement(v.a, {
						name: "embed",
						className: y.a.embedIcon
					}))
				},
				_ = e => {
					let {
						onCrosspost: t
					} = e;
					return o.a.createElement(b.b, {
						className: y.a.dropdownRow,
						displayText: s.fbt._("crosspost", null, {
							hk: "23zSN6"
						}),
						onClick: t
					}, o.a.createElement(v.a, {
						name: "crosspost",
						className: y.a.crosspostIcon
					}))
				},
				S = o.a.memo(e => {
					const t = Object(i.d)(),
						n = Object(g.a)(),
						a = Object(i.e)(t => Object(C.b)(e.dropdownId)(t)),
						m = Object(i.e)(O.m),
						p = Object(r.useCallback)(() => {
							t(Object(u.h)({
								tooltipId: e.dropdownId
							}))
						}, [t, e.dropdownId]),
						A = !e.subredditType || e.subredditType === x.g.Public,
						S = !!e.post && e.post.isCrosspostable && !e.post.isSponsored,
						w = !m,
						T = Object(r.useCallback)(e => {
							t(Object(c.e)(e)), n((() => e => ({
								...Object(h.p)(e),
								source: "post",
								action: f.c.CLICK,
								noun: "share_chat",
								subreddit: Object(h.mb)(e)
							}))())
						}, [t, n]);
					return o.a.createElement("div", {
						className: e.className,
						onClick: p,
						id: e.dropdownId
					}, e.children, o.a.createElement(j, {
						className: y.a.dropdown,
						isOpen: a,
						tooltipId: e.dropdownId
					}, o.a.createElement(b.b, {
						className: y.a.dropdownRow,
						displayText: s.fbt._("Copy link", null, {
							hk: "1tCqox"
						}),
						onClick: () => {
							const {
								permalink: n
							} = e, s = Object(d.a)(n, {
								utm_source: "share",
								utm_medium: "web2x",
								context: 3
							});
							e.sendEventWithName("share_copy"), (e => t(Object(l.C)(e)))(s)
						}
					}, o.a.createElement(v.a, {
						name: "link_post",
						className: y.a.linkIcon
					})), S && o.a.createElement(_, {
						onCrosspost: () => {
							e.sendEventWithName("share_crosspost"), e.post && window.open(`${E.b}?source_id=${e.post.id}`, "_blank")
						}
					}), A && o.a.createElement(k, {
						permalink: e.permalink,
						sendEventWithName: e.sendEventWithName
					}), w && o.a.createElement(I, {
						permalink: e.permalink,
						onShare: T
					})))
				});
			t.a = S
		},
		"./src/reddit/components/SourceLink/index.m.less": function(e, t, n) {
			e.exports = {
				OutboundLinkIcon: "_2WV2dTLgPlEXLVEmIexAxf",
				outboundLinkIcon: "_2WV2dTLgPlEXLVEmIexAxf",
				SourceLinkWrapper: "_10wC0aXnrUKfdJ4Ssz-o14",
				sourceLinkWrapper: "_10wC0aXnrUKfdJ4Ssz-o14",
				"m-comment": "_1-PD0_zreH-KVwpFoCLvQF",
				mComment: "_1-PD0_zreH-KVwpFoCLvQF"
			}
		},
		"./src/reddit/components/SourceLink/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return y
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/ads/index.ts"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/getShortenedLink.ts"),
				d = n("./node_modules/fbt/lib/FbtPublic.js"),
				c = n("./src/lib/avatarShareImages.ts"),
				l = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/TryItOn.tsx"),
				u = n("./src/reddit/components/AvatarPost/index.m.less"),
				m = n.n(u);
			var p = e => {
					let {
						sourceUrl: t,
						username: n,
						post: s
					} = e;
					const [o, i] = new URL(t).pathname.split("/").slice(2), a = Object(c.a)(i);
					return r.a.createElement("div", {
						className: m.a.avatarPostContainer
					}, r.a.createElement("img", {
						className: m.a.avatarPostImage,
						src: a,
						alt: d.fbt._("User Shared Avatar", null, {
							hk: "FDRaA"
						})
					}), r.a.createElement(l.a, {
						isHovercard: !1,
						username: n,
						isAvatarPost: !0,
						post: s,
						share: {
							username: o,
							avatarId: i
						}
					}))
				},
				b = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				f = n("./src/reddit/hooks/useIsAvatarPost.ts"),
				h = n("./src/reddit/icons/fonts/OutboundLink/index.tsx"),
				g = n("./src/reddit/components/SourceLink/index.m.less"),
				v = n.n(g),
				x = n("./src/lib/lessComponent.tsx"),
				E = n("./src/telemetry/models/Outbound.ts"),
				O = n("./src/reddit/hooks/useIsRemovedOrDeletedPost.ts");
			const C = x.a.wrapped(h.a, "OutboundLinkIcon", v.a),
				A = x.a.div("SourceLinkWrapper", v.a);

			function y(e) {
				const {
					className: t,
					post: n,
					isCommentsPage: s,
					pageLayer: d
				} = e, c = s ? E.SourceElement.PostLink : E.SourceElement.ListingPostLink, {
					source: l
				} = n, u = n.isSponsored || Object(o.u)(d), m = Object(f.a)(n), h = Object(O.a)();
				return !l || h ? null : m ? r.a.createElement(p, {
					sourceUrl: l.url,
					username: n.author,
					post: n
				}) : r.a.createElement(A, {
					className: Object(i.a)({
						[v.a["m-comment"]]: s
					}, t)
				}, r.a.createElement(b.a, {
					href: l.url,
					isSponsored: u,
					postId: n.id,
					source: l,
					sourceElement: c
				}, Object(a.a)({
					...n,
					isSponsored: u
				}), r.a.createElement(C, {
					isFilled: !0
				})))
			}
		},
		"./src/reddit/components/StructuredStyles/Breadcrumbs/index.m.less": function(e, t, n) {
			e.exports = {
				StyledChevron: "_2iNDx2lEuGuIyvMjz5ujOL",
				styledChevron: "_2iNDx2lEuGuIyvMjz5ujOL",
				BreadcrumbElement: "_32_k0a9y4N9cAnw6gApo5X",
				breadcrumbElement: "_32_k0a9y4N9cAnw6gApo5X",
				BreadcrumbContainer: "_1PgkMUbe7dhkAqRt4-VPGe",
				breadcrumbContainer: "_1PgkMUbe7dhkAqRt4-VPGe",
				breadcrumbTitle: "_2N7RnlFNJblZD8KUBuiBEQ"
			}
		},
		"./src/reddit/components/StructuredStyles/Breadcrumbs/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/components/TrackingHelper/index.tsx"),
				a = n("./src/reddit/helpers/trackers/blade.ts"),
				d = n("./src/reddit/icons/svgs/Chevron/index.tsx"),
				c = n("./src/reddit/components/StructuredStyles/Breadcrumbs/index.m.less"),
				l = n.n(c);
			const u = o.a.wrapped(d.a, "StyledChevron", l.a),
				m = o.a.div("BreadcrumbElement", l.a),
				p = o.a.div("BreadcrumbContainer", l.a);
			t.b = Object(i.c)(e => r.a.createElement(p, null, e.breadcrumbs.map(t => r.a.createElement(m, {
				key: t.title,
				onClick: () => {
					e.sendEvent(Object(a.a)()), e.onNavigate(t)
				}
			}, r.a.createElement(u, null), r.a.createElement("span", {
				className: l.a.breadcrumbTitle
			}, t.title)))))
		},
		"./src/reddit/components/StructuredStyles/ImageUpload/index.m.less": function(e, t, n) {
			e.exports = {
				ImageUploadIcon: "e9OxAKtFra_8aEeb27dTl",
				imageUploadIcon: "e9OxAKtFra_8aEeb27dTl",
				ImageIconRow: "_14ar_PmlmkOhLrVDBwohzK",
				imageIconRow: "_14ar_PmlmkOhLrVDBwohzK",
				ImageUploadText: "_3-gXMEj353M5u8pnC-tDG8",
				imageUploadText: "_3-gXMEj353M5u8pnC-tDG8",
				FileDrop: "_3n4Aj_eDE25JhXbxz3XpKf",
				fileDrop: "_3n4Aj_eDE25JhXbxz3XpKf",
				ContainerUploading: "rOyNUbZnjJvWxtyInd1T8",
				containerUploading: "rOyNUbZnjJvWxtyInd1T8",
				Label: "_2ZFG2IQMaso9iA14qjicA_",
				label: "_2ZFG2IQMaso9iA14qjicA_",
				isOver: "_1B5UKMPaEBX3HOKKEBfp7o",
				ImageInput: "_362HLUlCiz7UbtVPniNjjW",
				imageInput: "_362HLUlCiz7UbtVPniNjjW"
			}
		},
		"./src/reddit/components/StructuredStyles/ImageUpload/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return x
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/controls/FileDrop/index.tsx"),
				d = n("./src/reddit/controls/ImageInput/index.tsx"),
				c = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				l = n("./src/reddit/icons/svgs/ImageUpload/index.tsx"),
				u = n("./src/reddit/components/StructuredStyles/ImageUpload/index.m.less"),
				m = n.n(u);
			const {
				fbt: p
			} = n("./node_modules/fbt/lib/FbtPublic.js"), b = i.a.wrapped(l.a, "ImageUploadIcon", m.a), f = i.a.div("ImageIconRow", m.a), h = i.a.div("ImageUploadText", m.a), g = i.a.wrapped(a.a, "FileDrop", m.a), v = i.a.div("ContainerUploading", m.a), x = e => r.a.createElement(v, {
				className: e.className
			}, r.a.createElement(f, null, r.a.createElement(c.a, {
				sizePx: 40,
				center: !0
			})), r.a.createElement(h, null, p._("Uploading...", null, {
				hk: "2ICpZ2"
			}))), E = i.a.label("Label", m.a);
			t.b = e => r.a.createElement(g, {
				className: e.className,
				onDrop: e.onChange,
				render: t => r.a.createElement(E, {
					className: Object(o.a)({
						[m.a.isOver]: t
					}, e.labelClassName)
				}, r.a.createElement(f, null, e.icon || r.a.createElement(b, null)), r.a.createElement(h, null, e.label), r.a.createElement(d.a, {
					className: m.a.ImageInput,
					name: e.name,
					value: e.value,
					onChange: e.onChange,
					multiple: e.multiple,
					tabIndex: e.tabIndex
				}))
			})
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/forms.m.less": function(e, t, n) {
			e.exports = {
				FormPage: "_9ZuQyDXhFth1qKJF4KNm8",
				formPage: "_9ZuQyDXhFth1qKJF4KNm8",
				HomePageBreadcrumb: "_2iNJX36LR2tMHx_unzEkVM",
				homePageBreadcrumb: "_2iNJX36LR2tMHx_unzEkVM",
				HomePageTitle: "_1JmnMJclrTwTPpAip5U_Hm",
				homePageTitle: "_1JmnMJclrTwTPpAip5U_Hm",
				breadcrumbTitle: "_24r4TaTKqNLBGA3VgswFrN",
				HomePageGroup: "_306gA2lxjCHX44ssikUp3O",
				homePageGroup: "_306gA2lxjCHX44ssikUp3O",
				FormPageTitle: "_1Omf6afKRpv3RKNCWjIyJ4",
				formPageTitle: "_1Omf6afKRpv3RKNCWjIyJ4",
				FormPageSection: "_2Ss7VGMX-UPKt9NhFRtgTz",
				formPageSection: "_2Ss7VGMX-UPKt9NhFRtgTz",
				FormGroup: "_3vWu4F9B4X4Yc-Gm86-FMP",
				formGroup: "_3vWu4F9B4X4Yc-Gm86-FMP",
				FormGroupTitle: "_2qAEe8HGjtHsuKsHqNCa9u",
				formGroupTitle: "_2qAEe8HGjtHsuKsHqNCa9u",
				FormElement: "c5RWd-O3CYE-XSLdTyjtI",
				formElement: "c5RWd-O3CYE-XSLdTyjtI",
				FormGroupDescription: "_3whORKuQps-WQpSceAyHuF",
				formGroupDescription: "_3whORKuQps-WQpSceAyHuF",
				FormItem: "_1Qk-ka6_CJz1fU3OUfeznu",
				formItem: "_1Qk-ka6_CJz1fU3OUfeznu",
				FormElementTitle: "_3ds8Wk2l32hr3hLddQshhG",
				formElementTitle: "_3ds8Wk2l32hr3hLddQshhG",
				FormElementDescription: "_1h0r6vtgOzgWtu-GNBO6Yb",
				formElementDescription: "_1h0r6vtgOzgWtu-GNBO6Yb",
				FormElementError: "horIoLCod23xkzt7MmTpC",
				formElementError: "horIoLCod23xkzt7MmTpC",
				FormElementSubGroup: "_33Iw1wpNZ-uhC05tWsB9xi",
				formElementSubGroup: "_33Iw1wpNZ-uhC05tWsB9xi",
				FormListItem: "_2M7LQbQxH40ingJ9h9RslL",
				formListItem: "_2M7LQbQxH40ingJ9h9RslL"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/forms.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return i
			})), n.d(t, "p", (function() {
				return a
			})), n.d(t, "n", (function() {
				return d
			})), n.d(t, "o", (function() {
				return c
			})), n.d(t, "m", (function() {
				return l
			})), n.d(t, "l", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "i", (function() {
				return h
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "j", (function() {
				return O
			}));
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/components/StructuredStyles/StyledComponents/forms.m.less"),
				o = n.n(r);
			const i = s.a.section("FormPage", o.a),
				a = s.a.h1("HomePageTitle", o.a),
				d = s.a.button("HomePageBreadcrumb", o.a),
				c = s.a.div("HomePageGroup", o.a),
				l = s.a.h1("FormPageTitle", o.a),
				u = s.a.div("FormPageSection", o.a),
				m = s.a.div("FormGroup", o.a),
				p = s.a.h2("FormGroupTitle", o.a),
				b = s.a.div("FormElement", o.a),
				f = s.a.div("FormGroupDescription", o.a),
				h = s.a.div("FormItem", o.a),
				g = s.a.h3("FormElementTitle", o.a),
				v = s.a.div("FormElementDescription", o.a),
				x = s.a.div("FormElementError", o.a),
				E = s.a.div("FormElementSubGroup", o.a),
				O = s.a.li("FormListItem", o.a)
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/inputs.m.less": function(e, t, n) {
			e.exports = {
				ModalInput: "_2-UQO_nq1P8ACGIq0yZJRz",
				modalInput: "_2-UQO_nq1P8ACGIq0yZJRz",
				Input: "_1BJV17HgWhhC-BxrpqGjM",
				input: "_1BJV17HgWhhC-BxrpqGjM",
				Checkbox: "_29ZBtSa05ZCR4Sj1modCls",
				checkbox: "_29ZBtSa05ZCR4Sj1modCls",
				CheckboxSelected: "_1UmPxfh5dZu-x2VK6n61BM",
				checkboxSelected: "_1UmPxfh5dZu-x2VK6n61BM",
				iconStyles: "_349rJ1BueyeldYiZniwYOz",
				RadioOff: "_23-RdhX276B0bg5nrt0cpf",
				radioOff: "_23-RdhX276B0bg5nrt0cpf",
				RadioOn: "_2tv2vEpNmUbYbUPoOrSuAh",
				radioOn: "_2tv2vEpNmUbYbUPoOrSuAh",
				Textarea: "_2gchCc4pmLk-CHEErYmFaP",
				textarea: "_2gchCc4pmLk-CHEErYmFaP",
				StyledLabel: "_3X0DVhTjHSRuQBMvaWD4N",
				styledLabel: "_3X0DVhTjHSRuQBMvaWD4N",
				StyledFileInput: "_2kbxOlf5qlKAzRVdk0a0GN",
				styledFileInput: "_2kbxOlf5qlKAzRVdk0a0GN"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "g", (function() {
				return x
			}));
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/Input/ModalInput.tsx"),
				o = n("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				i = n("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				a = n("./src/reddit/icons/svgs/RadioOff/index.tsx"),
				d = n("./src/reddit/icons/svgs/RadioOn/index.tsx"),
				c = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.m.less"),
				l = n.n(c);
			const u = s.a.wrapped(r.a, "ModalInput", l.a),
				m = s.a.input("Input", l.a),
				p = s.a.wrapped(d.a, "RadioOn", l.a),
				b = s.a.wrapped(a.a, "RadioOff", l.a),
				f = s.a.wrapped(o.a, "Checkbox", l.a),
				h = s.a.wrapped(i.a, "CheckboxSelected", l.a),
				g = s.a.textarea("Textarea", l.a),
				v = s.a.label("StyledLabel", l.a),
				x = s.a.input("StyledFileInput", l.a)
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/navs.m.less": function(e, t, n) {
			e.exports = {
				FormNavElement: "KLpkXNw-FZfqtRK9U_8HB",
				formNavElement: "KLpkXNw-FZfqtRK9U_8HB",
				disabled: "_2omjYUqCweNidaShU2H5EC",
				DragCard: "ygS6b189jD1GHwzotinJB",
				dragCard: "ygS6b189jD1GHwzotinJB",
				isOverAndCanDrop: "_3_GRCa3UIhqQ68fvB00PLZ",
				isDragging: "_2yg01oNjKP8Gcb4HPjf58k"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/StructuredStyles/StyledComponents/navs.m.less"),
				a = n.n(i);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const c = e => {
					let {
						disabled: t,
						...n
					} = e;
					return r.a.createElement("div", d({}, n, {
						className: Object(o.a)(a.a.FormNavElement, {
							[a.a.disabled]: t
						})
					}), n.children)
				},
				l = e => {
					let {
						canDrop: t,
						className: n,
						isDragging: s,
						isOver: i,
						disabled: c,
						...l
					} = e;
					return r.a.createElement("div", d({}, l, {
						className: Object(o.a)(a.a.DragCard, {
							[a.a.disabled]: c,
							[a.a.isDraffing]: s,
							[a.a.isOverAndCanDrop]: i && t
						}, n)
					}))
				}
		},
		"./src/reddit/components/SubredditContent/PredictionsContent/async.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-SubredditContent-PredictionsContent",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-SubredditContent-PredictionsContent").then(n.bind(null, "./src/reddit/components/SubredditContent/PredictionsContent/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/SubredditContent/PredictionsContent/index.tsx"
				}
			})
		},
		"./src/reddit/components/SubredditContent/ScheduledPostContent/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/scheduledPosts/index.ts"),
				l = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				u = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				m = n("./node_modules/reselect/es/index.js"),
				p = n("./src/reddit/actions/modal.ts"),
				b = n("./src/lib/CSSVariableProvider/index.tsx"),
				f = n("./src/reddit/controls/Button/index.tsx"),
				h = n("./src/reddit/components/Paginator/index.m.less"),
				g = n.n(h);

			function v() {
				return (v = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const x = e => {
				const {
					isNextButton: t,
					isActive: n,
					...s
				} = e;
				return o.a.createElement(f.i, v({
					disabled: !n
				}, s))
			};
			class E extends o.a.Component {
				constructor(e) {
					super(e), this.onHandlePrev = () => this.onHandlePageChange(!1), this.onHandleNext = () => this.onHandlePageChange(!0), this.state = {
						currentCursor: void 0
					}
				}
				getCurrentCursorIdx() {
					const {
						items: e
					} = this.props, {
						currentCursor: t
					} = this.state;
					return t ? e.findIndex(e => e.id === t) : -1
				}
				getRenderableItems() {
					const {
						items: e,
						itemsPerPage: t
					} = this.props, n = this.getCurrentCursorIdx() + 1;
					return e.slice(n, n + t)
				}
				hasPrevPage() {
					return !(this.getCurrentCursorIdx() <= 0)
				}
				hasNextPage() {
					const {
						items: e,
						itemsPerPage: t
					} = this.props;
					return !(this.getCurrentCursorIdx() + t > e.length - 2)
				}
				onHandlePageChange(e) {
					const {
						items: t,
						itemsPerPage: n
					} = this.props, s = this.getCurrentCursorIdx();
					if (e && !this.hasNextPage()) return;
					if (!e && !this.hasPrevPage()) return;
					const r = e ? Math.max(-1, Math.min(s + n, t.length - 2)) : Math.max(-1, s - n);
					this.setState({
						currentCursor: t[r] ? t[r].id : void 0
					})
				}
				renderControlRow() {
					const {
						usePortalForControlRow: e,
						controlRowPortal: t,
						pagerButton: n = x
					} = this.props, r = this.hasPrevPage(), i = this.hasNextPage();
					if (!r && !i) return null;
					const a = o.a.createElement("div", {
						className: g.a.controlRow
					}, o.a.createElement("span", {
						className: g.a.prevButtonContainer
					}, o.a.createElement(n, {
						className: g.a.prevButton,
						onClick: this.onHandlePrev,
						isNextButton: !1,
						isActive: r
					}, s.fbt._("Previous", null, {
						hk: "4hX0ue"
					}))), o.a.createElement("span", {
						className: g.a.nextButtonContainer
					}, o.a.createElement(n, {
						className: g.a.nextButton,
						onClick: this.onHandleNext,
						isNextButton: !0,
						isActive: i
					}, s.fbt._("Next", null, {
						hk: "2mEXAi"
					}))));
					return e && !t ? null : t ? Object(b.d)(a, t) : a
				}
				render() {
					const {
						className: e,
						lastItemClassName: t,
						itemComponent: n
					} = this.props, s = this.getRenderableItems();
					return o.a.createElement("div", {
						className: e
					}, s.map((e, r) => o.a.createElement(n, {
						className: t && r === s.length - 1 ? t : void 0,
						key: e.id,
						item: e
					})), this.renderControlRow())
				}
			}
			var O = E,
				C = n("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				A = n("./src/reddit/components/RecurringPostList/ChangePageButton/index.m.less"),
				y = n.n(A);
			var j = e => o.a.createElement("button", {
					className: Object(d.a)(y.a.button, e.className, {
						[y.a.prevButton]: !e.isNextButton,
						[y.a.disabled]: !e.isActive
					}),
					onClick: e.onClick,
					disabled: !e.isActive
				}, o.a.createElement(C.a, {
					className: y.a.arrowIcon
				})),
				I = n("./src/reddit/components/RecurringPostList/EditModal/async.tsx"),
				k = n("./src/reddit/components/RecurringPostList/RecurringPost/index.tsx"),
				_ = n("./src/reddit/components/TrackingHelper/index.tsx"),
				S = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				w = n("./src/reddit/icons/fonts/index.tsx"),
				T = n("./src/reddit/routes/postCreation/index.ts"),
				P = n("./src/reddit/selectors/activeModalId.ts"),
				N = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				D = n("./src/reddit/components/RecurringPostList/index.m.less"),
				M = n.n(D);
			const {
				fbt: R
			} = n("./node_modules/fbt/lib/FbtPublic.js"), L = 5, B = Object(m.c)({
				recurringPosts: (e, t) => {
					let {
						subreddit: n
					} = t;
					return Object(N.l)(e, {
						subredditId: n.id
					})
				},
				editModalIsOpen: e => Object(P.a)(e) === k.a,
				editingRecurringPostId: N.d,
				editingRecurringPostSubredditId: N.e
			});
			class F extends o.a.PureComponent {
				constructor() {
					super(...arguments), this.pageButtonPortalRef = o.a.createRef(), this.onEditModalSuccessfulSave = () => {
						this.props.editModalIsOpen && this.props.toggleModal()
					}, this.onClickLink = () => {
						this.props.sendEvent(Object(S.j)())
					}
				}
				renderEmptyState() {
					return o.a.createElement(l.c, {
						className: M.a.emptyContainer,
						text: R._("No recurring posts", null, {
							hk: "2G7szl"
						}),
						childrenPosition: "bottom"
					}, o.a.createElement(w.a, {
						name: "refresh",
						className: M.a.icon
					}), o.a.createElement(a.a, {
						className: M.a.schedulePostLink,
						onClick: this.onClickLink,
						to: Object(T.c)(this.props.subreddit.name)
					}, R._("Schedule recurring post", null, {
						hk: "1TrUPC"
					})))
				}
				render() {
					const {
						className: e,
						recurringPosts: t,
						editModalIsOpen: n,
						subreddit: s,
						editingRecurringPostSubredditId: r,
						editingRecurringPostId: i
					} = this.props;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						className: Object(d.a)(e, M.a.postList)
					}, o.a.createElement("div", {
						className: M.a.titleContainer
					}, R._("Recurring posts", null, {
						hk: "30aHKv"
					}), o.a.createElement("div", {
						ref: this.pageButtonPortalRef,
						className: M.a.pageButtonPortal
					})), t.length ? o.a.createElement(O, {
						className: M.a.recurringPostsContainer,
						lastItemClassName: M.a.lastRecurringPostItem,
						itemsPerPage: L,
						items: t,
						itemComponent: k.b,
						pagerButton: j,
						usePortalForControlRow: !0,
						controlRowPortal: this.pageButtonPortalRef.current
					}) : this.renderEmptyState()), n && !!i && !!r && s.id === r && o.a.createElement(I.a, {
						scheduledPostId: i,
						subredditId: r,
						onSuccessfulSave: this.onEditModalSuccessfulSave,
						withOverlay: !0
					}))
				}
			}
			var U = Object(i.b)(B, (e, t) => ({
					toggleModal: () => e(Object(p.i)(k.a))
				}))(Object(_.c)(F)),
				H = n("./src/reddit/components/ScheduledPost/index.tsx"),
				G = n("./src/reddit/components/Scroller/Simple.tsx"),
				Q = n("./src/reddit/components/SubredditContent/index.tsx"),
				q = n("./src/reddit/components/SubredditContent/index.m.less"),
				W = n.n(q),
				z = n("./src/reddit/models/ScheduledPost/index.ts"),
				V = n("./src/reddit/selectors/experiments/shredditModNav.ts");
			const K = Object(m.c)({
					isLoading: N.i,
					hasData: (e, t) => {
						let {
							subreddit: n
						} = t;
						return Object(N.h)(e, {
							subredditId: n.id
						})
					},
					standalonePosts: (e, t) => {
						let {
							subreddit: n
						} = t;
						return Object(N.q)(e, {
							subredditId: n.id
						})
					},
					loadMoreToken: (e, t) => {
						let {
							subreddit: n
						} = t;
						return Object(N.c)(e, {
							subredditId: n.id,
							type: z.g.standalonePosts
						})
					},
					isInShredditModNavExperiment: e => Object(V.a)(e, !0)
				}),
				Y = Object(i.b)(K, (e, t) => {
					let {
						subreddit: n
					} = t;
					return {
						onLoadMoreStandaloneScheduledPosts: () => e(Object(c.a)(n.id))
					}
				});
			class J extends o.a.PureComponent {
				render() {
					const {
						hasData: e,
						standalonePosts: t,
						onLoadMore: n,
						loadMoreToken: s,
						renderEmptyState: r,
						subreddit: i
					} = this.props;
					return o.a.createElement("div", {
						className: W.a.contentContainer
					}, o.a.createElement("div", {
						className: W.a.standaloneContainer
					}, e && t.length ? o.a.createElement(G.b, {
						className: W.a.scroller,
						onLoadMore: n,
						loadMoreToken: s || void 0
					}, t.map(e => ({
						id: e.id,
						estHeight: 112,
						render: t => o.a.createElement(H.a, {
							key: `scheduled-post-id-${e.id}`,
							scheduledPostId: e.id,
							subredditId: e.subreddit.id
						})
					}))) : r()), o.a.createElement(U, {
						className: W.a.sidebar,
						subreddit: i
					}))
				}
			}
			class X extends o.a.PureComponent {
				constructor() {
					super(...arguments), this.renderStandaloneEmptyState = () => {
						const {
							subreddit: e
						} = this.props;
						return o.a.createElement(l.c, {
							className: W.a.emptyStateContainer,
							text: s.fbt._("No scheduled posts in r/{subredditName}", [s.fbt._param("subredditName", e.name)], {
								hk: "mUwQ4"
							}),
							childrenPosition: "bottom"
						}, o.a.createElement(w.a, {
							name: "history",
							className: W.a.icon
						}), o.a.createElement(a.a, {
							className: W.a.schedulePostLink,
							to: Object(T.c)(e.name)
						}, s.fbt._("Schedule post", null, {
							hk: "xI07X"
						})))
					}
				}
				renderBody() {
					const {
						hasData: e,
						loadMoreToken: t,
						onLoadMoreStandaloneScheduledPosts: n,
						standalonePosts: s,
						subreddit: r
					} = this.props;
					return o.a.createElement(J, {
						renderEmptyState: this.renderStandaloneEmptyState,
						hasData: e,
						standalonePosts: s,
						onLoadMore: n,
						subreddit: r,
						loadMoreToken: t
					})
				}
				render() {
					const {
						isLoading: e,
						hasData: t,
						subreddit: n,
						isInShredditModNavExperiment: r
					} = this.props;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(u.c, {
						className: Object(d.a)(W.a.topBar, r && "fixed bg-neutral-background mb-xs pr-0", {
							[W.a.default]: !r
						})
					}, o.a.createElement(a.a, {
						to: Object(T.c)(n.name)
					}, o.a.createElement(f.l, null, s.fbt._("Schedule Post", null, {
						hk: "2Ygkzg"
					})))), o.a.createElement(u.a, null, o.a.createElement(u.b, {
						className: W.a.pageTitle
					}, s.fbt._("Scheduled posts", null, {
						hk: "28Qjmj"
					})), !t && e ? Object(Q.a)() : this.renderBody(), t && e && Object(Q.a)(1)))
				}
			}
			t.a = Y(X)
		},
		"./src/reddit/components/SubredditContent/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_1N366WahaKnCqUlSezl6CQ",
				titleFontH2: "_2ySCAslCokkxUasLc4m7l0",
				titleFontH3: "_3Na_u-vwpkuPZfuuvUROk-",
				titleFontH4: "_30jImFPUovcaQMWasU-Ohq",
				titleFontH5: "_1fkIEAH9a9eCt2B8XAaUbq",
				titleFontH6: "bHSjFLbSCNEywMorkTrqn",
				metadataFont: "_2Qe8DvvY_RxPEkj-mRpX65",
				flairFont: "_1TXuHKPD3YeZiCgMqyoBBe",
				labelsFont: "_1MiMOmZyBl0g5x8oLzodW8",
				actionFont: "_3USAKL0kbrc0ZhCvZS-J4j",
				smallButtonFont: "_2JaNUow_hy9X8yw0QFNOSg",
				largeButtonFont: "_2QdyaDMXRLLL3gChJ0NOE9",
				strongTextFont: "_3qauH8UCZvDtHIr65uebN5",
				tabFont: "_1bq9fxhlMVaxA2GQdVomf4",
				buttonFontXS: "_7W4YggPAccJm6b7j_5tM_",
				buttonFontXs: "_7W4YggPAccJm6b7j_5tM_",
				buttonFontS: "_2ZBn3QtRUE4GU3UTdoCOzY",
				buttonFontM: "_1FF_0_g8KF3VAe3NMA-Lu6",
				buttonFontL: "_12R7hgqLzyY_mHo7tL6VIy",
				buttonFontXL: "_1c2eC_5e586qF7hV3NBVj_",
				buttonFontXl: "_1c2eC_5e586qF7hV3NBVj_",
				bodyFontH1: "_2qU2oh77HnIxSqTey1ZezW",
				bodyFontH2: "_2XZkZ1zrfSvpi64O-KP4IB",
				bodyFontH3: "_1icF_z4wcZT687-ao6Mzr7",
				bodyFontH4: "ZRi07Zo9aba1n7XQY_Xio",
				bodyFontH5: "_1dhvcwu2KcypL8_En9Aa7I",
				bodyFontH6: "_1FGIk1pK7xZjRbWXhruioE",
				bodyFontH6Small: "gX_Loj9AWtmLld5X2fYAM",
				bodyFont: "_3xTpswgMylBeM6Y-XFNTUD",
				bodyFontSmall: "_3U8U5anYwaLfjJvSrrhIKo",
				bodyFontMono: "_1VL2XaMyhrq5PiMxCa8tkv",
				landingPageTitleFontH1: "_3U33V1TLB1wNZLhlm76iyw",
				landingPageTitleFontH2: "_1qRVc7UgXT9O9JIwEy17WP",
				landingPageTitleFontH3: "Jt9WK82aCYMXRtfrdkHBw",
				icon: "_1wICBaO2ARQK5N8CBXP8kI",
				schedulePostLink: "_3hO2emEyTZ-txWczRsI6lb",
				betaIndicator: "q9zqS5nIMgIr22a55zflg",
				pageTitle: "_2HS4U5X7Rt3fT__Kpgmp9M",
				contentContainer: "_2i38uCMOvjLO0N4T-QGmV1",
				scroller: "_2toQcR3aw1_hj1A49e4wi7",
				sidebar: "_3Pz5gIKK5q2FYttguHTNa3",
				emptyStateContainer: "_3uHuaRL_-Tec711luXRhl8",
				standaloneContainer: "Q7W5RJknO1UJ-qscCW0k6",
				eventPostContainer: "_1WvFOm4w7Qt8CpM_XKK9y8",
				topBar: "zm-d6hGDaBlN7C9OEx3rJ",
				default: "_172px3AfRRUVVtAahz78d6",
				modNavExperiment: "_2j6EF9zkW7QR4zAEMu-aUi"
			}
		},
		"./src/reddit/components/SubredditContent/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/ClassicPost/Placeholder.tsx");

			function i() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 3;
				const t = [];
				for (let n = 0; n < e; n++) t.push(r.a.createElement(o.a, {
					isLoading: !0
				}));
				return r.a.createElement(r.a.Fragment, null, t)
			}
		},
		"./src/reddit/components/SubredditCreationModal/Layout/index.m.less": function(e, t, n) {
			e.exports = {
				Content: "gGAX8JwsFcDSDsT5KcKrL",
				content: "gGAX8JwsFcDSDsT5KcKrL",
				Container: "_1J0hJj-EXr49KppYTmtS9S",
				container: "_1J0hJj-EXr49KppYTmtS9S",
				ContainerExp: "_3Cb_x0VK1tr3QTaBDGU_-K",
				containerExp: "_3Cb_x0VK1tr3QTaBDGU_-K",
				OuterContainer: "_1wLNhgzYyv0-JBg0BfYf3Y",
				outerContainer: "_1wLNhgzYyv0-JBg0BfYf3Y"
			}
		},
		"./src/reddit/components/SubredditCreationModal/index.m.less": function(e, t, n) {
			e.exports = {
				sublabel: "_1l4AkEjhz6oh1lmsJv-6Oo",
				subtitle: "SJ8r-Lx8GZVAGXaT954wj",
				radioDescription: "_1FBE2BnOrrXe8bCr6ZLfGq",
				buttonContainer: "pllx1jz7x_s-pSUC5f15v",
				field: "_2m493sVo9iDo-3EBxQrAJc",
				isCreatePending: "_39K9U8eGRvjiN3lSUWfoXF",
				subredditCreation: "_3O95baBiXBhn2SNtTQXPun",
				container: "o5ISTIh6L_lvDC1gObc76",
				title: "_2d-OkUXQj6P8CRIrcoi1i9",
				nsfw: "_3bx-zSg4-Vgfi3x1IUw6QP",
				createButton: "_2shIfL3K7ivaojvZFjvI-Z",
				pendingText: "A8PHuGr_4pbV_7t_GaokO",
				metaFieldDescription: "HsJgPFCmZ8OKgFe3tYiOB",
				numCommunityTopicsSelected: "_3-RTBwxKbhnYzfNZydOubp",
				subtextContainer: "_1V3LfcGf8bnGW9vw7JkOOs",
				radioContainer: "_247NCf2PSxl4rhmx2dDhDC",
				radioContent: "_2QiRZZs4K5lTjMTuSaMgDC",
				textButton: "c6YtB-MsWwD2pwSxCRQWE",
				fullWidthTextContainer: "_39cm2YKltxh0YW0O1f54y3",
				Info: "_16_IgJ4BqtadthCKIpnW1g",
				info: "_16_IgJ4BqtadthCKIpnW1g",
				RadioOption: "_12umGu0WfWJw9rxGq4ykrZ",
				radioOption: "_12umGu0WfWJw9rxGq4ykrZ",
				StyledTooltip: "j2Jvuy8Yu-jexJED1Ap51",
				styledTooltip: "j2Jvuy8Yu-jexJED1Ap51",
				RadioIcon: "_1g89RGQdzecmnfVeXck6JL",
				radioIcon: "_1g89RGQdzecmnfVeXck6JL",
				Employee: "_2gDVAtwwxskByrxI2Zr9BL",
				employee: "_2gDVAtwwxskByrxI2Zr9BL",
				Private: "_1Ma7YYe0ShiEmNSS16r18H",
				private: "_1Ma7YYe0ShiEmNSS16r18H",
				Public: "_3WyydSidemq34inFmhA1SE",
				public: "_3WyydSidemq34inFmhA1SE",
				Restricted: "CodbGPlWjCpPE6jWVhkOn",
				restricted: "CodbGPlWjCpPE6jWVhkOn",
				CloseButton: "_1P7Eow5rs9Xxm1uqMMEr2h",
				closeButton: "_1P7Eow5rs9Xxm1uqMMEr2h",
				ErrorText: "_2dXAoHGf_uRg0D6ofrpJbr",
				errorText: "_2dXAoHGf_uRg0D6ofrpJbr"
			}
		},
		"./src/reddit/components/SubredditCreationModal/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "radioOptions", (function() {
				return se
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/higherOrderComponents/asModal/index.tsx"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/subredditCreation.ts"),
				m = n("./src/reddit/actions/tooltip.ts"),
				p = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				b = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				f = n("./src/reddit/contexts/NavbarExp.ts"),
				h = n("./src/reddit/components/SubredditCreationModal/Layout/index.m.less"),
				g = n.n(h);
			var v = e => {
					const t = Object(r.useContext)(f.a);
					return o.a.createElement("div", {
						className: g.a.OuterContainer
					}, o.a.createElement("div", {
						className: Object(c.a)(e.className, g.a.Container)
					}, o.a.createElement("div", {
						className: Object(c.a)(g.a.Content, {
							[g.a.ContainerExp]: t
						})
					}, e.children)))
				},
				x = n("./src/reddit/components/TrackingHelper/index.tsx"),
				E = n("./src/reddit/constants/modals.ts"),
				O = n("./src/reddit/controls/Button/index.tsx"),
				C = n("./src/reddit/controls/CheckboxInput/index.tsx"),
				A = n("./src/reddit/controls/ErrorText/index.tsx"),
				y = n("./src/reddit/controls/RadioInput/index.tsx"),
				j = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				I = n("./src/reddit/helpers/trackers/screenview.ts"),
				k = n("./src/reddit/helpers/trackers/subredditCreation.ts"),
				_ = n("./src/reddit/icons/svgs/Admin/index.tsx"),
				S = n("./src/reddit/icons/svgs/Close/index.tsx"),
				w = n("./src/reddit/icons/svgs/Eye/index.tsx"),
				T = n("./src/reddit/icons/svgs/Info/index.tsx"),
				P = n("./src/reddit/icons/svgs/Lock/index.tsx"),
				N = n("./src/reddit/icons/svgs/User/index.tsx"),
				D = n("./src/reddit/models/Subreddit/index.ts"),
				M = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				R = n("./src/reddit/selectors/subreddit.ts"),
				L = n("./src/reddit/selectors/tags.ts"),
				B = n("./src/reddit/selectors/user.ts"),
				F = n("./src/lib/formatApiError/index.ts");
			const U = (e, t) => {
				if (!e) return {};
				const n = e.fields && e.fields.length && e.fields[0] && e.fields[0].field,
					r = e.type;
				if ("name" === n) {
					if ("NO_TEXT" === r) return {
						name: s.fbt._("A community name is required", null, {
							hk: "QIlYS"
						})
					};
					if ("BAD_SR_NAME" === r) return {
						name: s.fbt._("Community names must be between 321 characters, and can only contain letters, numbers, or underscores.", null, {
							hk: "2rmVgd"
						})
					};
					if ("SUBREDDIT_EXISTS" === r) return {
						name: s.fbt._("Sorry, r/{subreddit name attempt} is taken. Try another.", [s.fbt._param("subreddit name attempt", t)], {
							hk: "CLwzs"
						})
					};
					if ("SUBREDDIT_UNAVAILABLE" === r) return {
						name: s.fbt._("This community name is unavailable", null, {
							hk: "15j6BB"
						})
					}
				}
				return {
					generic: Object(F.a)(e)
				}
			};
			var H = n("./src/reddit/components/SubredditCreationModal/index.m.less"),
				G = n.n(H),
				Q = n("./src/lib/lessComponent.tsx");
			const q = 21,
				W = "create-title-info",
				z = Q.a.wrapped(T.a, "Info", G.a),
				V = Q.a.wrapped(j.a, "RadioOption", G.a),
				K = Q.a.wrapped(p.c, "Tooltip", G.a),
				Y = Q.a.wrapped(N.a, "Public", G.a),
				J = Q.a.wrapped(w.a, "Restricted", G.a),
				X = Q.a.wrapped(P.a, "Private", G.a),
				Z = Q.a.wrapped(_.a, "Employee", G.a),
				$ = Q.a.wrapped(S.a, "CloseButton", G.a),
				ee = Q.a.wrapped(A.b, "ErrorText", G.a),
				te = Object(a.c)({
					error: R.f,
					isCreatePending: R.l,
					isEmployee: B.P,
					crosspostId: R.k,
					userDoesNotHaveEnoughExpToCreateCommunity: e => !Object(B.sb)(e),
					userIsSuspended: B.Z,
					allTags: L.e,
					existingTags: L.f,
					newTags: L.g,
					selectedPrimaryTagId: L.h
				}),
				ne = Object(i.b)(te, e => ({
					createCommunity: t => e(Object(u.h)(t)),
					clearErrors: () => e(Object(u.f)()),
					onCloseModal: () => e(Object(l.g)(E.a.SUBREDDIT_CREATION_MODAL_ID)),
					onShowTooltip: () => e(Object(m.f)({
						tooltipId: W
					})),
					onHideTooltip: () => e(Object(m.i)()),
					validateSubredditName: t => e(Object(u.i)(t))
				})),
				se = (e, t) => [o.a.createElement(V, {
					key: "public",
					showButton: !0,
					value: "public"
				}, o.a.createElement("div", {
					className: G.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement(Y, null)), o.a.createElement("div", {
					className: G.a.radioContainer
				}, o.a.createElement("div", {
					className: G.a.sublabel
				}, s.fbt._("Public", null, {
					hk: "DK992"
				})), o.a.createElement("div", {
					className: Object(c.a)(G.a.metafieldDescription, G.a.radioDescription)
				}, s.fbt._("Anyone can view, post, and comment to this community", null, {
					hk: "1PfFUA"
				}))))), o.a.createElement(V, {
					key: "restricted",
					showButton: !0,
					value: "restricted"
				}, o.a.createElement("div", {
					className: G.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement(J, null)), o.a.createElement("div", {
					className: G.a.radioContainer
				}, o.a.createElement("div", {
					className: G.a.sublabel
				}, s.fbt._("Restricted", null, {
					hk: "1iBTDq"
				})), o.a.createElement("div", {
					className: Object(c.a)(G.a.metafieldDescription, G.a.radioDescription)
				}, Object(M.g)(t))))), o.a.createElement(V, {
					key: "private",
					showButton: !0,
					value: "private"
				}, o.a.createElement("div", {
					className: G.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement(X, null)), o.a.createElement("div", {
					className: G.a.radioContainer
				}, o.a.createElement("div", {
					className: G.a.sublabel
				}, s.fbt._("Private", null, {
					hk: "3q5SYn"
				})), o.a.createElement("div", {
					className: Object(c.a)(G.a.metafieldDescription, G.a.radioDescription)
				}, s.fbt._("Only approved users can view and submit to this community", null, {
					hk: "3z8OI6"
				}))))), o.a.createElement(V, {
					key: "employees_only",
					showButton: !0,
					value: "employees_only",
					hidden: !e
				}, o.a.createElement("div", {
					className: G.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement(Z, null)), o.a.createElement("div", {
					className: G.a.radioContainer
				}, o.a.createElement("div", {
					className: G.a.sublabel
				}, s.fbt._("Employees only", null, {
					hk: "1arrQC"
				})), o.a.createElement("div", {
					className: Object(c.a)(G.a.metafieldDescription, G.a.radioDescription)
				}, s.fbt._("Only Reddit employees can view and submit to this community", null, {
					hk: "3ty23C"
				})))))];
			class re extends o.a.Component {
				constructor(e) {
					super(e), this.onNameChange = e => {
						this.setState({
							name: e.target.value
						}), this.props.clearErrors()
					}, this.update = (e, t) => this.setState({
						[t]: e
					}), this.onTypeChange = e => {
						this.setState({
							type: e
						})
					}, this.onCreateCommunityClick = () => {
						this.props.isCreatePending || (clearTimeout(this.timeout), this.props.createCommunity({
							name: this.state.name,
							publicDescription: "",
							type: this.state.type,
							over18: this.state.over18,
							restrictCommenting: this.state.restrictCommenting,
							restrictPosting: this.state.restrictPosting,
							allTags: this.props.allTags,
							newTags: this.props.newTags,
							crosspostId: this.state.crosspostId,
							existingTags: this.props.existingTags,
							primaryTagId: this.props.selectedPrimaryTagId || void 0
						}), this.timeout = window.setTimeout(() => {
							this.props.isCreatePending && this.setState({
								waitingForSuccessfulCommunity: !0
							})
						}, 2e3))
					}, this.onValidateSubredditName = () => this.props.validateSubredditName(this.state.name), this.onCloseModal = () => {
						this.props.sendEvent(Object(k.b)()), this.props.onCloseModal()
					}, this.onCancelCreation = () => {
						this.props.onCloseModal(), this.props.sendEvent(Object(k.b)())
					}, this.onUpdateOver18 = () => this.update(!this.state.over18, "over18"), this.state = {
						name: "",
						type: D.g.Public,
						crosspostId: e.crosspostId,
						over18: !1,
						waitingForSuccessfulCommunity: !1,
						restrictCommenting: !1,
						restrictPosting: !0
					}
				}
				componentDidMount() {
					const {
						sendEvent: e
					} = this.props;
					e(Object(I.v)())
				}
				componentWillUnmount() {
					clearTimeout(this.timeout), this.props.clearErrors()
				}
				render() {
					const {
						error: e,
						isCreatePending: t,
						isEmployee: n,
						onHideTooltip: r,
						onShowTooltip: i,
						userDoesNotHaveEnoughExpToCreateCommunity: a,
						userIsSuspended: d
					} = this.props, l = U(e, this.state.name), {
						over18: u,
						waitingForSuccessfulCommunity: m
					} = this.state;
					return o.a.createElement(v, {
						className: G.a.subredditCreation
					}, o.a.createElement("div", {
						className: G.a.container
					}, o.a.createElement("h1", {
						className: G.a.title
					}, s.fbt._("Create a community", null, {
						hk: "SlFa7"
					}), o.a.createElement($, {
						onClick: this.onCloseModal
					})), a ? o.a.createElement("h2", {
						className: G.a.sublabel
					}, s.fbt._("To prevent spam, accounts must be at least 30 days old and have enough positive karma to create communities.", null, {
						hk: "44qhJp"
					})) : d ? o.a.createElement("h2", {
						className: G.a.sublabel
					}, s.fbt._("Accounts banned from the site can not create communities until the ban is lifted.", null, {
						hk: "3trJMZ"
					})) : o.a.createElement(o.a.Fragment, null, o.a.createElement(b.e, {
						isCreateCommunity: !0,
						label: s.fbt._("Name", null, {
							hk: "3OIzgl"
						}),
						textContainerClassName: G.a.fullWidthTextContainer,
						onBlur: this.onValidateSubredditName,
						onChange: this.onNameChange,
						maxChars: q,
						value: this.state.name,
						subtext: o.a.createElement("span", {
							className: G.a.subtextContainer
						}, s.fbt._("Community names including capitalization cannot be changed.", null, {
							hk: "VjrZg"
						}), o.a.createElement("span", {
							id: W,
							onMouseEnter: i,
							onMouseLeave: r,
							className: G.a.info
						}, o.a.createElement(z, null), o.a.createElement(K, {
							className: G.a.StyledTooltip,
							caretOnTop: !0,
							tooltipId: W,
							text: s.fbt._('Names cannot have spaces (e.g., "r/bookclub" not "r/book club"), must be between 3-21 characters, and underscores ("_") are the only special characters allowed. Avoid using solely trademarked names (e.g., "r/FansOfAcme" not "r/Acme").', null, {
								hk: "3RsycS"
							})
						})))
					}), l.name && o.a.createElement(ee, null, l.name), o.a.createElement(b.m, {
						label: s.fbt._("Community type", null, {
							hk: "152EhZ"
						}),
						direction: "column",
						isCreateCommunity: !0,
						textContainerClassName: G.a.fullWidthTextContainer
					}, o.a.createElement(y.a, {
						value: this.state.type,
						name: "type",
						onChange: this.onTypeChange
					}, se(n, "post"))), o.a.createElement("div", {
						className: Object(c.a)(G.a.field, {
							[G.a.isCreatePending]: t
						})
					}, o.a.createElement("div", {
						className: G.a.subtitle
					}, s.fbt._("Adult content", null, {
						hk: "20arB"
					})), o.a.createElement(C.a, {
						name: "over18",
						value: u,
						onChange: this.onUpdateOver18,
						disabled: t
					}, o.a.createElement("div", {
						className: G.a.nsfw
					}, "NSFW"), o.a.createElement("div", {
						className: G.a.sublabel
					}, s.fbt._("18+ year old community", null, {
						hk: "1XxZMV"
					})))), l.generic && o.a.createElement(ee, null, l.generic), m && o.a.createElement("div", {
						className: G.a.pendingText
					}, s.fbt._("Your community is being created...", null, {
						hk: "3dSTrq"
					})), o.a.createElement("div", {
						className: G.a.buttonContainer
					}, o.a.createElement(O.t, {
						disabled: t,
						className: G.a.createButton,
						onClick: this.onCancelCreation,
						priority: O.c.Secondary
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), o.a.createElement(O.t, {
						disabled: t,
						className: G.a.createButton,
						onClick: this.onCreateCommunityClick
					}, s.fbt._("Create Community", null, {
						hk: "QE8Y3"
					}))))))
				}
			}
			t.default = Object(d.a)(Object(x.c)(ne(re)))
		},
		"./src/reddit/components/SubredditForkingCTA/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return A
			})), n.d(t, "a", (function() {
				return _
			}));
			var s = n("./node_modules/core-js/modules/web.dom.iterable.js"),
				r = n.n(s),
				o = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				i = n("./node_modules/react/index.js"),
				a = n.n(i),
				d = n("./node_modules/react-redux/es/index.js"),
				c = n("./src/reddit/constants/comments.ts"),
				l = n("./src/reddit/models/Subreddit/index.ts"),
				u = n("./src/reddit/selectors/comments.ts"),
				m = n("./src/reddit/selectors/posts.ts"),
				p = n("./src/reddit/selectors/user.ts"),
				b = n("./node_modules/reselect/es/index.js"),
				f = n("./src/lib/cache/index.ts"),
				h = n("./src/lib/makeCommentsPageKey/index.ts"),
				g = n("./src/reddit/helpers/trackers/subredditForking.ts"),
				v = n("./src/reddit/components/TrackingHelper/index.tsx");
			const x = Object(o.a)({
					resolved: {},
					chunkName: () => "SubredditForkingCTA",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("Governance~Reddit~SubredditForkingCTA"), n.e("SubredditForkingCTA")]).then(n.bind(null, "./src/reddit/components/SubredditForkingCTA/SubredditForkingCTA.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/SubredditForkingCTA/SubredditForkingCTA.tsx"
					}
				}),
				E = [{
					low: 0,
					high: 1e5,
					threshold: 100
				}, {
					low: 1e5,
					high: 3e5,
					threshold: 200
				}, {
					low: 3e5,
					high: 8e5,
					threshold: 300
				}, {
					low: 8e5,
					high: 1 / 0,
					threshold: 500
				}],
				O = "subreddit-forking.dismissals",
				C = (e, t) => {
					const n = Object(p.m)(e),
						s = Object(h.a)(t.postId),
						r = Object(m.F)(e, t),
						o = Object(u.o)(e, {
							...t,
							commentsPageKey: s
						}),
						i = Object(u.k)(e, {
							...t,
							commentsPageKey: s
						}).reduce((t, n) => {
							var s;
							const r = Object(u.l)(e, {
								commentLink: n
							});
							return n.type !== c.a.Comment && 0 !== (null === (s = o[n.id]) || void 0 === s ? void 0 : s.depth) || t.push(r), t
						}, []).sort((e, t) => t.score - e.score).slice(0, 5);
					return (null == n ? void 0 : n.id) === r.authorId || !!i.find(e => e.authorId === (null == n ? void 0 : n.id))
				},
				A = e => {
					let t = Object(f.b)(O);
					const n = Object.entries(t || {});
					n.length >= 99 && (t = n.sort((e, t) => {
						let [, n] = e, [, s] = t;
						return s - n
					}).splice(0, 99).reduce((e, t) => {
						let [n, s] = t;
						return e[n] = s, e
					}, {})), Object(f.d)(O, {
						...t,
						[e]: Date.now()
					}, Date.now() + 2592e3)
				},
				y = (e, t) => {
					var n;
					if (!Object(p.S)(e)) return !1;
					if (null === (n = Object(f.b)(O)) || void 0 === n ? void 0 : n[t.postId]) return !1;
					const s = Object(m.F)(e, t),
						r = Object(m.U)(e, {
							...t,
							disallowProfile: !0
						});
					if ((null == r ? void 0 : r.type) !== l.g.Public || r.isNSFW || r.isQuarantined || (null == s ? void 0 : s.isNSFW) || (null == s ? void 0 : s.source)) return !1;
					const o = E.find(e => {
						let {
							low: t,
							high: n
						} = e;
						return n >= r.subscribers && r.subscribers > t
					});
					return !(!o || !s.numComments || o.threshold > s.numComments) && !!C(e, t)
				},
				j = () => Object(b.c)({
					shouldLoadCTA: y
				}),
				I = Object(d.b)(j),
				k = e => {
					let {
						shouldLoadCTA: t,
						postId: n,
						sendEvent: s
					} = e;
					const [r, o] = Object(i.useState)(!1);
					return r || !t ? null : a.a.createElement(x, {
						onClose: () => {
							A(n), o(!0), s(Object(g.b)(n))
						},
						postId: n
					})
				},
				_ = Object(i.memo)(I(Object(v.c)(k)))
		},
		"./src/reddit/components/SubredditIcon/index.m.less": function(e, t, n) {
			e.exports = {
				Image: "_34CfAAowTqdbNDYXz5tBTW",
				image: "_34CfAAowTqdbNDYXz5tBTW",
				UserIcon: "_3-8BEp7zk8HU_Tq2SjmosX",
				userIcon: "_3-8BEp7zk8HU_Tq2SjmosX",
				blur: "_2P3jpibqK9Q2k2UJYzBNIy",
				PlanetIcon: "_2WM2ef3imxyCFqHx0Nx5M4",
				planetIcon: "_2WM2ef3imxyCFqHx0Nx5M4",
				BackupImage: "RK004G8fbNOkGdNLEzm67",
				backupImage: "RK004G8fbNOkGdNLEzm67",
				iconContainer: "_7nyhK_sDI_8i22XNdcMzb",
				editableIcon: "_1AxWRIyg1lV9-r_CmqYj0o",
				flexContainer: "-Mpi2pdgifDBOdpUYX2vh",
				clickableUploadText: "_3H6u2CWhsluIPVF14GpEaA",
				inTopBar: "_1UpdjN7u66BU606z97t4HS",
				emptyUploadButton: "ndkYE2hc8Y-V3NHpSYvxA",
				transition: "_1iA7YdCRjbU9Rd_2VNGvsw",
				emptyEditableIcon: "_1h9JeZaSDxkh67Ns3QVUP2",
				emptyPlusButton: "Dh1qxsy_tIctL9f4LEzv9",
				imageUploader: "JBITiVY1zX1mMDq-sHkru",
				loadingIcon: "_3Dk8QRKhQImYqds2lSF6G4",
				loadingIconInTopBar: "_1U3KLnHX2TdXL5lNrrv4EW",
				emptyEditableIconInTopBar: "_3-i_fdY8zqHIo3CjuVzTYE",
				defaultCommunityIcon: "_1xvdfUtOPDANqHjxzxKX5b",
				mNightmode: "_1TI6C7sqGL9TRdsq1jRks",
				iconLink: "_35ahToY-XcU6llULyYdy2A"
			}
		},
		"./src/reddit/components/SubredditIcon/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return A
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/components/UserIcon/index.tsx"),
				u = n("./src/reddit/constants/colors.ts"),
				m = n("./src/reddit/contexts/PageLayer/index.tsx"),
				p = n("./src/reddit/helpers/getSubredditOrProfileIconData/index.tsx"),
				b = n("./src/reddit/icons/fonts/index.tsx"),
				f = n("./src/reddit/models/Subreddit/index.ts"),
				h = n("./src/reddit/selectors/user.ts"),
				g = n("./src/reddit/components/SubredditIcon/index.m.less"),
				v = n.n(g);

			function x() {
				return (x = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const E = c.a.wrapped(l.a, "UserIcon", v.a),
				O = c.a.img("Image", v.a),
				C = e => {
					let {
						iconColor: t,
						...n
					} = e;
					return i.a.createElement(O, x({
						style: {
							backgroundColor: t || ""
						}
					}, n))
				},
				A = c.a.div("BackupImage", v.a),
				y = Object(m.v)();
			t.b = y(e => {
				var t;
				const n = Object(a.e)(h.fb);
				let o, c, l;
				if (e.subredditOrProfile) {
					const {
						url: t,
						color: n
					} = Object(p.a)({
						shouldHideNsfwIcon: !!e.shouldHideNsfwIcon,
						subredditOrProfile: e.subredditOrProfile
					});
					Object(f.i)(e.subredditOrProfile) ? l = i.a.createElement(E, {
						className: e.className,
						iconUrl: t,
						isNSFW: e.subredditOrProfile.isNSFW,
						userName: e.subredditOrProfile.name
					}) : (o = t, c = n)
				} else o = e.shouldHideNsfwIcon ? `${s.a.assetPath}/img/avatar_over18.png` : e.iconUrl, c = e.primaryColor || u.a.alienblue;
				return o ? l = i.a.createElement(C, {
					alt: r.fbt._("Subreddit Icon", null, {
						hk: "134aM1"
					}),
					className: Object(d.a)(e.className, {
						[v.a.blur]: e.shouldBlurSubredditIcon
					}),
					iconColor: c,
					role: "presentation",
					src: o
				}) : l || (l = i.a.createElement(b.a, {
					name: "community",
					isFilled: !n,
					className: Object(d.a)(v.a.defaultCommunityIcon, e.className, {
						[v.a.mNightmode]: n,
						[v.a.blur]: e.shouldBlurSubredditIcon
					}),
					style: n ? {
						backgroundColor: e.redditStyle ? u.a.alienblue : c
					} : {
						color: e.redditStyle ? u.a.alienblue : c
					}
				})), e.linkTo ? i.a.createElement("a", x({}, null !== (t = e.linkProps) && void 0 !== t ? t : {}, {
					href: e.linkTo,
					className: v.a.iconLink
				}), l) : i.a.createElement(i.a.Fragment, null, l)
			})
		},
		"./src/reddit/components/SubredditModerationSearch/index.m.less": function(e, t, n) {
			e.exports = {
				SearchIcon: "_2LL7WLn2-4Pv8zCUsmDPv9",
				searchIcon: "_2LL7WLn2-4Pv8zCUsmDPv9",
				NoResultsContainer: "_38zxhEjlOjKTVFYaSwtDTL",
				noResultsContainer: "_38zxhEjlOjKTVFYaSwtDTL",
				Container: "_3RNapyf_4ZQOEfoJhVRMEO",
				container: "_3RNapyf_4ZQOEfoJhVRMEO",
				SearchStatusBar: "_3yWFGY3HrViWVFFUCsTUjv",
				searchStatusBar: "_3yWFGY3HrViWVFFUCsTUjv",
				SearchStatus: "uTK2QKUebu8hg0gYZWTI7",
				searchStatus: "uTK2QKUebu8hg0gYZWTI7",
				Bold: "_2u65S50DJfsU-z8bR0G2DQ",
				bold: "_2u65S50DJfsU-z8bR0G2DQ"
			}
		},
		"./src/reddit/components/SubredditModerationSearch/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return O
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				d = n("./src/reddit/controls/Button/index.tsx"),
				c = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				l = n("./src/reddit/layout/row/Inline/index.tsx"),
				u = n("./src/reddit/layout/row/RightAlign/index.tsx"),
				m = n("./src/reddit/icons/svgs/Search/index.tsx"),
				p = n("./src/reddit/components/SubredditModerationSearch/index.m.less"),
				b = n.n(p);
			const f = i.a.wrapped(m.a, "SearchIcon", b.a),
				h = i.a.wrapped(a.a, "NoResultsContainer", b.a),
				g = i.a.div("Container", b.a),
				v = i.a.wrapped(l.a, "SearchStatusBar", b.a),
				x = i.a.div("SearchStatus", b.a),
				E = i.a.span("Bold", b.a);

			function O(e) {
				if (e.searchPending) return null;
				const t = Object(c.a)(e.searchTerm);
				return e.noResultsFound ? o.a.createElement(h, null, o.a.createElement(f, null), o.a.createElement(a.b, null, s.fbt._("No results for {searchTerm}", [s.fbt._param("searchTerm", `u/${t}`)], {
					hk: "1nDAlG"
				})), o.a.createElement(d.r, {
					onClick: e.cancelSearch
				}, s.fbt._("See all", null, {
					hk: "3aLS8s"
				}))) : o.a.createElement(g, null, o.a.createElement(v, null, o.a.createElement(x, null, s.fbt._("1 search result for {=[searchTerm]}", [s.fbt._param("=[searchTerm]", o.a.createElement(E, {
					"data-redditstyle": !0
				}, s.fbt._("{searchTerm}", [s.fbt._param("searchTerm", `'${t}':`)], {
					hk: "1B9ZWG"
				})))], {
					hk: "iAcV5"
				})), o.a.createElement(u.a, null, o.a.createElement(d.r, {
					onClick: e.cancelSearch
				}, s.fbt._("See all", null, {
					hk: "3aLS8s"
				})))), e.children)
			}
		},
		"./src/reddit/components/SubredditModerationTopBar/index.m.less": function(e, t, n) {
			e.exports = {
				topBarRow: "_3H6HwkSZ2zUC1pwaIMv-EY",
				searchBar: "_2LvB93iPopVPdhNBxBnfAH",
				searchIcon: "_1lo1uHsqx3-EkgYDL4xKEB",
				searchInput: "_1ox94KT4YX0mmZgLO51PG_",
				searchButton: "_3-3xbjG4pcuzlB7SzgBvzg"
			}
		},
		"./src/reddit/components/SubredditModerationTopBar/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				d = n("./src/reddit/icons/svgs/Search/index.tsx"),
				c = n("./src/reddit/components/SubredditModerationTopBar/index.m.less"),
				l = n.n(c);
			const u = i.a.div("topBarRow", l.a);
			class m extends o.a.Component {
				constructor(e) {
					super(e), this.onSearchChange = e => {
						Object(a.a)(e.currentTarget.value).length < 21 && this.setState({
							searchInputText: e.currentTarget.value
						})
					}, this.onKeyPress = e => {
						"Enter" === e.key && this.onSearch()
					}, this.onSearch = () => {
						this.props.onSearch(this.state.searchInputText)
					}, this.state = {
						searchInputText: ""
					}
				}
				UNSAFE_componentWillReceiveProps(e) {
					this.props.activeSearchQuery && null === e.activeSearchQuery && this.setState({
						searchInputText: ""
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return o.a.createElement("div", {
						className: l.a.topBarRow
					}, e.positionSearchRight && e.children, o.a.createElement("div", {
						className: l.a.searchBar
					}, o.a.createElement("input", {
						className: l.a.searchInput,
						onChange: this.onSearchChange,
						onKeyPress: this.onKeyPress,
						placeholder: s.fbt._("Search for a user", null, {
							hk: "1yTo6e"
						}),
						type: "text",
						value: t.searchInputText
					}), o.a.createElement("button", {
						className: l.a.searchButton,
						onClick: this.onSearch
					}, o.a.createElement(d.a, {
						className: l.a.searchIcon
					}))), !e.positionSearchRight && e.children)
				}
			}
		},
		"./src/reddit/components/SubredditModerationUserItem/index.m.less": function(e, t, n) {
			e.exports = {
				Row: "_2O5kmPXewMHlCcrRWrjEB_",
				row: "_2O5kmPXewMHlCcrRWrjEB_",
				Username: "_1sIhmckJjyRyuR_z7M5kbI",
				username: "_1sIhmckJjyRyuR_z7M5kbI",
				RightAlign: "_3f00u5KR-M4rdaonscLX8k",
				rightAlign: "_3f00u5KR-M4rdaonscLX8k",
				Description: "_3YjnH6nyw9xU3dQ5hTVmEg",
				description: "_3YjnH6nyw9xU3dQ5hTVmEg",
				AdditionalText: "_2FHMhpmaJ7uKirIBSL-nfq",
				additionalText: "_2FHMhpmaJ7uKirIBSL-nfq",
				ChevronDown: "_13LaWwDlCX3ERr0EUCo3Lx",
				chevronDown: "_13LaWwDlCX3ERr0EUCo3Lx",
				ChevronUp: "_2wUaFuEtiqP0eWtfI9dDoI",
				chevronUp: "_2wUaFuEtiqP0eWtfI9dDoI",
				ExpandoContainer: "_2AQcG05ynImXmYdd8D8PMU",
				expandoContainer: "_2AQcG05ynImXmYdd8D8PMU",
				Bullet: "_1VQtDRh-JtZQghS8jetaHR",
				bullet: "_1VQtDRh-JtZQghS8jetaHR",
				PlaceholderItem: "_3KdpSC_L0JbYqsU7OmeaGX",
				placeholderItem: "_3KdpSC_L0JbYqsU7OmeaGX",
				EmptyUserIcon: "iNRbW9Tpfe2qsnXftvupu",
				emptyUserIcon: "iNRbW9Tpfe2qsnXftvupu",
				EmptyDetails: "_16EL0HBUzdiC9vh2S9H5Ee",
				emptyDetails: "_16EL0HBUzdiC9vh2S9H5Ee",
				UsersLoadingContainer: "_1s6c6XYRhTyY6FWEkJHQg",
				usersLoadingContainer: "_1s6c6XYRhTyY6FWEkJHQg"
			}
		},
		"./src/reddit/components/SubredditModerationUserItem/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return D
			}));
			var s = n("./node_modules/lodash/times.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/TrackingHelper/index.tsx"),
				c = n("./src/reddit/helpers/trackers/moderationPages.ts"),
				l = n("./src/reddit/components/IdentityAndIcon/index.tsx"),
				u = n("./src/reddit/controls/Button/index.tsx"),
				m = n("./src/reddit/icons/svgs/ChevronDown/index.tsx"),
				p = n("./src/reddit/icons/svgs/ChevronUp/index.tsx"),
				b = n("./src/reddit/layout/row/Inline/index.tsx"),
				f = n("./src/reddit/layout/row/RightAlign/index.tsx"),
				h = n("./src/reddit/components/SubredditModerationUserItem/index.m.less"),
				g = n.n(h);
			const {
				fbt: v
			} = n("./node_modules/fbt/lib/FbtPublic.js"), x = (e, t) => {
				const n = `UserInfoTooltip--${e}`;
				return t ? `${n}--${t}` : n
			}, E = a.a.wrapped(b.a, "Row", g.a), O = a.a.div("Username", g.a), C = a.a.wrapped(f.a, "RightAlign", g.a), A = a.a.div("Description", g.a), y = a.a.div("AdditionalText", g.a), j = a.a.wrapped(m.a, "ChevronDown", g.a), I = a.a.wrapped(p.a, "ChevronUp", g.a), k = a.a.div("ExpandoContainer", g.a), _ = a.a.span("Bullet", g.a), S = a.a.div("PlaceholderItem", g.a), w = a.a.wrapped(S, "EmptyUserIcon", g.a), T = a.a.wrapped(S, "EmptyDetails", g.a), P = a.a.div("UsersLoadingContainer", g.a), N = () => i.a.createElement(E, null, i.a.createElement(w, null), i.a.createElement(T, null), i.a.createElement(T, null)), D = e => i.a.createElement(P, {
				className: e.className
			}, r()(e.rows || 10, e => i.a.createElement(N, {
				key: e
			})));
			class M extends i.a.Component {
				constructor(e) {
					super(e), this.onToggleExpandedComponent = () => {
						this.props.pageName && !this.state.isExpanded && this.props.sendEvent(c.a("more_detail", this.props.pageName)), this.setState({
							isExpanded: !this.state.isExpanded
						})
					}, this.sendHoverCardEvent = () => {
						this.props.pageName && this.props.sendEvent(c.c(this.props.pageName))
					}, this.state = {
						isExpanded: !1
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return i.a.createElement(i.a.Fragment, null, i.a.createElement(E, null, i.a.createElement(O, null, i.a.createElement(l.a, {
						username: e.username,
						userIcon: e.userIcon,
						tooltipId: x(e.username, e.moderatorType),
						subredditId: e.subredditId,
						sendHoverCardEvent: this.sendHoverCardEvent
					})), i.a.createElement(A, null, e.timeAgo, e.description && i.a.createElement(i.a.Fragment, null, i.a.createElement(_, null, ""), e.description)), i.a.createElement(C, null, e.additionalText && i.a.createElement(y, null, e.additionalText), e.primaryButton, e.secondaryButton, e.tertiaryButton, e.expandedComponent && i.a.createElement(u.r, {
						onClick: this.onToggleExpandedComponent
					}, v._("More Details", null, {
						hk: "KnMc6"
					}), t.isExpanded ? i.a.createElement(I, null) : i.a.createElement(j, null)))), t.isExpanded && i.a.createElement(k, null, e.expandedComponent))
				}
			}
			t.b = Object(d.c)(M)
		},
		"./src/reddit/components/SubredditNameLink/index.m.less": function(e, t, n) {
			e.exports = {
				SubredditName: "_3ryJoIoycVkA88fy40qNJc",
				subredditName: "_3ryJoIoycVkA88fy40qNJc"
			}
		},
		"./src/reddit/components/SubredditNameLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				r = n("./src/reddit/components/SubredditNameLink/index.m.less"),
				o = n.n(r);
			const i = n("./src/lib/lessComponent.tsx").a.wrapped(s.a, "SubredditName", o.a);
			t.a = i
		},
		"./src/reddit/components/SubredditRules/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_1fQ3jmS7djNiAnk2kVsPko",
				titleFontH2: "_39dtESYDu10VI6hZlt8jT_",
				titleFontH3: "_2_Ya84laiZ_AK4zBLZeXmE",
				titleFontH4: "_2k9S2SK_mdrMw9dXzIJka3",
				titleFontH5: "_3hrj37O_iGAZk7ssKstspL",
				titleFontH6: "_2KYRCY7gyTJjBx_Vr5pjqd",
				metadataFont: "_2hHNLn3quM7R0Znfoal7Wi",
				flairFont: "KkD9-eQEXAm_GdJAbixZ5",
				labelsFont: "_1xgXWixwTrYRf6JjxPm7ft",
				actionFont: "_1HQtdMEzh4gag8do4e9j7Z",
				smallButtonFont: "zWcRyj2-0oiXHbpM-5L1A",
				largeButtonFont: "_2PIOcp6QTxVygtl2u9ji_a",
				strongTextFont: "_2adE8ldKa4w_dETRAs-vdP",
				tabFont: "UtQUA6_scmmMeiLaweTg2",
				buttonFontXS: "_10ruUMhuBmxZqA1yF_MlA9",
				buttonFontXs: "_10ruUMhuBmxZqA1yF_MlA9",
				buttonFontS: "_1TFRBw_YwgrsDelv1Pi-SM",
				buttonFontM: "_2H_oQnXKALaCioWB1K9l-O",
				buttonFontL: "_2gy3VLIz6UYY1qlR5-fcVm",
				buttonFontXL: "_1drcPUSEFqtlwYnTDdJsro",
				buttonFontXl: "_1drcPUSEFqtlwYnTDdJsro",
				bodyFontH1: "_3lbK38dxFajKo78JrAEtIe",
				bodyFontH2: "_1CH0HVqZd3qMaT2gzU5mYn",
				bodyFontH3: "xk7ESbG2cmLPdln3D1fVi",
				bodyFontH4: "_29_oVfDyKoOggix5Gj6kah",
				bodyFontH5: "_1RoE8VrwOjvkyDDc-a8RZ_",
				bodyFontH6: "_3jwZ9V_jg7YZ4T-0cmGzxY",
				bodyFontH6Small: "_3WMZAYheSFIrrjKgM6FOG1",
				bodyFont: "_2iji_FM7kTNPRlaRGrPpq8",
				bodyFontSmall: "oJpqQ5hwA0NwwwlDu-EZH",
				bodyFontMono: "_2nUMbdZlQ1fQpJ_LaDNrbn",
				landingPageTitleFontH1: "_2cEdGJGz8oV3sN_gTRGtCx",
				landingPageTitleFontH2: "_3suYS5xyzArxtj-MdsUF-5",
				landingPageTitleFontH3: "_1rB8J25cUM1_ndaSDpWLAC",
				duplicateName: "_31Visb7b2S-tj09Ls_2Acy",
				emptyDetails: "_8PDfWWfcYPlmlmOr2Notr",
				emptyIcon: "_2tEWDkQudqJGiBAQsXSYXE",
				emptyRightIcon: "aF9GyLBXjDrRFO_7BTOYU",
				expandDetails: "_19etb4qzR1xpaHDy7AVdRr",
				header: "_2Xb_1g-T9iGzHDDy3_XpMD",
				DragCard: "_1KNUx1QX0DDrtynCc-GRE_",
				dragCard: "_1KNUx1QX0DDrtynCc-GRE_",
				dragIcon: "RR4AdUs4L9geua2bjCoqQ",
				icon: "PbUpiwMGWTjzrcYfCTdc0",
				iconButton: "_138C3cC0PAtIwsXoIAfGvJ",
				iconWrapper: "Ep3vJhfng2q2-wfiIgstP",
				loadingContainer: "ve35wYJQyEHavtRQYDY7V",
				metadata: "_1xQ_DrqnJXDZq1ptXHxYIB",
				middleMeta: "_2OWUxJA0Dhi0onvygJk3_i",
				middleMetaBlock: "n1lY8o9sGnqcqSfVzm5Vs",
				modalCloseButton: "zKQ8lyAF3pYyDoSlTpTjA",
				modalDescriptionBlock: "_26a81Mk5bsppGjI9AXbmWS",
				modalDescriptionField: "_1brIoxFWlohWpvu34OwZQP",
				modalFooter: "R-9ebJbU9igzPDfUi4Txg",
				modalRadioButton: "_1KFGHoJGHbU05yh6-sQIr5",
				modalRadioText: "_360Lh4DKj256s8RdElARFo",
				modalReasonField: "_1hdSGf--gQDRwsU96bzao1",
				modalRemoveButton: "_2yAePObDkhgZql3P1FHRu1",
				modalReportMeta: "_21sqmEi4OnC4uXlcUGDT_T",
				modalReportTitle: "_1y0X9006mE_5nlHfol1nc2",
				modalRule: "_1AlCnggMuPLxxDUbWWhG2q",
				modalRuleField: "QP-_TXfrh6G1-IRJif4Cy",
				modalRuleTitle: "_2I1A_fyvhaC7TYrYwA047Y",
				modalSubmitButton: "hHFW3BkgX7tSn5Nev-ooY",
				placeholderRow: "hv6YY1IfCww5loDzbkuMS",
				row: "_1LfPdWXylWmVTmLinhd4xl",
				ruleContainer: "_1ZlrZi6hLVu7wggjYho4IT",
				newModNavContainer: "_83jJ2EaLlnmh3ZDj07kW9",
				topBar: "_36qW-hp67Ytwc3P1LfmOHr",
				fixed: "_3_R3jpckQGJp9vcNPsVQRD",
				default: "_1AFZi_BgffRLVBZCUNHt4Q",
				rulesHeader: "_3MOq7UPqtI4o9EnAyCWkEQ",
				rulesIcon: "_29Fl8s_IvZwHxUPNV2ARiW",
				rulesInfo: "KTZ0Ir6xknUXuN4WMI7RN",
				ruleMetaText: "iVYauV_t6_ChREoxhNGsU",
				ruleMetaTitle: "ffGjaCMPoTUkhkVp6rHw5",
				emptyWrapper: "_2-xwKK1EqJlzI2dO7SIrbF",
				ruleNumber: "_3DEhjnxmn1BzXcJ_ml7kSQ",
				ruleText: "_1ZwBW5sLL75ZAZvQreMjn-",
				PrimaryButton: "_3GOmWOjCh6hPWZg1j-zPkr",
				primaryButton: "_3GOmWOjCh6hPWZg1j-zPkr"
			}
		},
		"./src/reddit/components/SubredditRules/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/config.ts"),
				o = n("./node_modules/lodash/isEqual.js"),
				i = n.n(o),
				a = n("./node_modules/lodash/times.js"),
				d = n.n(a),
				c = n("./node_modules/react/index.js"),
				l = n.n(c),
				u = n("./node_modules/react-redux/es/index.js"),
				m = n("./node_modules/reselect/es/index.js"),
				p = n("./src/lib/classNames/index.ts"),
				b = n("./src/lib/constants/index.ts"),
				f = n("./src/lib/lessComponent.tsx"),
				h = n("./src/reddit/actions/modal.ts"),
				g = n("./src/lib/makeActionCreator/index.ts"),
				v = n("./src/reddit/actions/subredditRules/constants.ts"),
				x = n("./src/reddit/actions/toaster.ts"),
				E = n("./src/reddit/endpoints/subreddit/rules.ts"),
				O = n("./src/reddit/models/Toast/index.ts"),
				C = n("./src/reddit/selectors/subreddit.ts");
			const A = Object(g.a)(v.e),
				y = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = Object(C.X)(r(), {
							subredditId: e
						}).name,
						d = `success-block-${t.rule}`,
						c = `error-block-${t.rule}`,
						l = await Object(E.a)(i(), a, t);
					if (l.ok) {
						const t = l.body;
						n(A({
							rules: t,
							subredditId: e
						})), n(x.f({
							id: d,
							kind: O.b.SuccessCommunityGreen,
							text: s.fbt._("Rule added", null, {
								hk: "4D4jbP"
							})
						}))
					} else n(x.f({
						id: c,
						kind: O.b.Error,
						text: l.json.errors ? l.json.errors[0][1] : s.fbt._("An error has occured. Please try again later", null, {
							hk: "2C9b4N"
						})
					}))
				}, j = Object(g.a)(v.f), I = Object(g.a)(v.g), k = Object(g.a)(v.d), _ = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = Object(C.X)(r(), {
							subredditId: e
						}).name,
						d = Object(C.T)(r(), {
							subredditId: e
						}),
						c = `success-block-${e}`,
						l = `error-block-${e}`,
						u = await Object(E.e)(i(), a, t);
					if (u.ok) {
						const t = u.body;
						n(k({
							rules: t,
							subredditId: e
						})), n(x.f({
							id: c,
							kind: O.b.SuccessCommunityGreen,
							text: s.fbt._("Rule order updated", null, {
								hk: "3bmmvl"
							}),
							buttonText: s.fbt._("Undo", null, {
								hk: "1RYWKC"
							}),
							buttonAction: _(e, d)
						}))
					} else n(x.f({
						id: l,
						kind: O.b.Error,
						text: "explanation" in u ? u.explanation : u.json && "errors" in u.json ? u.json.errors[0][1] : s.fbt._("An error has occured. Please try again later", null, {
							hk: "1XJ2UQ"
						})
					}))
				};
			var S = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				w = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				T = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				P = n("./src/reddit/components/ModHub/NewModNav/PageLinks.tsx"),
				N = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				D = n("./src/reddit/components/TrackingHelper/index.tsx"),
				M = n("./src/reddit/controls/Button/index.tsx"),
				R = n("./src/reddit/controls/Sortable/index.tsx"),
				L = n("./src/reddit/selectors/telemetry.ts");
			const B = e => ({
					subreddit: L.mb(e),
					profile: L.U(e),
					userSubreddit: L.vb(e)
				}),
				F = e => t => ({
					source: "rules",
					action: "click",
					noun: e,
					...B(t)
				}),
				U = (e, t) => n => ({
					source: "rules",
					action: "click",
					noun: e,
					actionInfo: L.d(n, {
						count: t
					}),
					...B(n)
				});
			var H = n("./src/reddit/icons/fonts/index.tsx"),
				G = n("./src/reddit/layout/row/Inline/index.tsx"),
				Q = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				q = n("./src/reddit/models/Rule/index.ts"),
				W = n("./src/reddit/selectors/activeModalId.ts"),
				z = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				V = n("./src/reddit/selectors/moderatorPermissions.ts"),
				K = n("./src/reddit/components/SubredditRules/index.m.less"),
				Y = n.n(K),
				J = n("./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx"),
				X = n("./src/reddit/icons/svgs/Grapple/index.tsx");
			const Z = f.a.wrapped(J.a, "DragCard", Y.a);
			var $ = e => l.a.createElement(Z, {
					isDragging: e.isDragging,
					isOver: e.isOver,
					canDrop: e.canDrop
				}, l.a.createElement(G.a, {
					className: Object(p.a)(Y.a.row, {
						[Y.a.isReordering]: !0
					})
				}, l.a.createElement("span", {
					className: Y.a.ruleNumber
				}, e.index + 1), l.a.createElement("span", {
					className: Y.a.ruleText
				}, e.shortName), l.a.createElement("span", {
					className: Y.a.iconWrapper
				}, l.a.createElement(X.a, {
					className: Y.a.dragIcon,
					title: s.fbt._("Drag", null, {
						hk: "dBKmA"
					})
				})))),
				ee = n("./src/higherOrderComponents/asModal/index.tsx"),
				te = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				ne = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				se = n("./src/reddit/controls/RadioInput/index.tsx"),
				re = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				oe = n("./src/reddit/controls/TextButton/index.tsx"),
				ie = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				ae = n("./src/reddit/selectors/experiments/communityChat.ts");
			const de = {
					rule: "",
					kind: "all",
					reportReason: "",
					description: ""
				},
				ce = Object(m.c)({
					shouldShowChatNewSubredditRules: e => Object(ae.c)(e)
				}),
				le = Object(u.b)(ce, (e, t) => ({
					createRule: n => e(y(t.subredditId, n)),
					updateRule: (n, r) => e(((e, t, n) => async (r, o, i) => {
						let {
							apiContext: a
						} = i;
						const d = Object(C.X)(o(), {
								subredditId: e
							}).name,
							c = `success-block-${t.rule}`,
							l = `error-block-${t.rule}`,
							u = await Object(E.f)(a(), d, t, n);
						if (u.ok) {
							const t = u.body;
							r(j({
								rules: t,
								subredditId: e,
								oldName: n
							})), r(x.f({
								id: c,
								kind: O.b.SuccessCommunityGreen,
								text: s.fbt._("Rule updated", null, {
									hk: "1ljetO"
								})
							}))
						} else r(x.f({
							id: l,
							kind: O.b.Error,
							text: u.json.errors ? u.json.errors[0][1] : s.fbt._("An error has occured. Please try again later", null, {
								hk: "2acjBM"
							})
						}))
					})(t.subredditId, n, r))
				}));
			class ue extends l.a.Component {
				constructor(e) {
					super(e), this.onRuleInputChange = e => {
						e.currentTarget.value.trim().length <= q.g && this.setState({
							rule: e.currentTarget.value
						})
					}, this.onReportReasonInputChange = e => {
						e.currentTarget.value.trim().length <= q.f && this.setState({
							reportReason: e.currentTarget.value
						})
					}, this.onDescriptionInputChange = e => {
						e.currentTarget.value.trim().length <= q.a && this.setState({
							description: e.currentTarget.value
						})
					}, this.onSave = () => {
						const {
							props: e,
							state: t
						} = this, n = {
							rule: t.rule.trim(),
							kind: t.kind,
							reason: t.reportReason.trim(),
							description: t.description.trim()
						};
						e.rule ? e.updateRule(n, e.rule.shortName) : e.createRule(n), e.toggleModal(), e.sendEvent()
					}, this.canSave = () => {
						const {
							props: e,
							state: t
						} = this, n = t.rule.trim(), s = t.reportReason.trim(), r = t.description.trim(), o = !e.ruleNames.includes(n) || e.ruleNames.includes(n) && e.rule && e.rule.shortName === n, i = !e.rule || (e.rule.shortName !== n || e.rule.violationReason !== t.reportReason || e.rule.kind !== t.kind || e.rule.description !== r);
						return o && i && n.length > 0 && n.length <= q.g && s.length <= q.f && r.length <= q.a && t.kind
					}, this.selectRuleKind = e => {
						this.setState({
							kind: e
						})
					}, this.isDuplicateRuleName = () => {
						const {
							props: e,
							state: t
						} = this, n = !e.rule || e.rule.shortName !== t.rule.trim(), s = e.ruleNames.includes(t.rule.trim());
						return 0 !== t.rule.trim().length && n && s
					}, this.state = e.rule ? {
						rule: e.rule.shortName,
						kind: e.rule.kind,
						reportReason: e.rule.violationReason || "",
						description: e.rule.description || ""
					} : de
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return l.a.createElement(ne.e, null, l.a.createElement(ne.i, null, l.a.createElement(ie.a, null, l.a.createElement(ne.q, null, e.rule ? s.fbt._("Edit rule", null, {
						hk: "2zflTO"
					}) : s.fbt._("Add rule", null, {
						hk: "1xqo5O"
					})), l.a.createElement(oe.a, {
						className: Y.a.modalCloseButton,
						onClick: e.toggleModal
					}, l.a.createElement(ne.b, null)))), l.a.createElement(ne.l, null, l.a.createElement(ne.h, null, l.a.createElement(ne.p, {
						className: Y.a.modalRule
					}, s.fbt._("Rule", null, {
						hk: "1W7esG"
					})), l.a.createElement(ne.t, {
						className: Y.a.modalRuleField,
						onChange: this.onRuleInputChange,
						placeholder: s.fbt._('Rule displayed (e.g. "No photos")', null, {
							hk: "GdEW"
						}),
						value: t.rule
					}), this.isDuplicateRuleName() && l.a.createElement("span", {
						className: Y.a.duplicateName
					}, s.fbt._("You have another rule with this title. Please change.", null, {
						hk: "2EPSGv"
					})), l.a.createElement(te.a, {
						maxChars: q.g,
						text: t.rule.trim()
					})), l.a.createElement(ne.h, null, l.a.createElement(ne.p, {
						className: Y.a.modalRuleTitle
					}, s.fbt._("Applies to", null, {
						hk: "Pzu3b"
					})), l.a.createElement(se.a, {
						name: "RULE_KIND_PICKER",
						onChange: this.selectRuleKind,
						value: t.kind
					}, l.a.createElement(re.a, {
						className: Y.a.modalRadioButton,
						key: q.b.all,
						value: q.b.all,
						selected: t.kind === q.b.all,
						showButton: !0,
						tabIndex: t.kind === q.b.all ? 0 : -1
					}, l.a.createElement(ne.p, {
						className: Y.a.modalRadioText
					}, e.shouldShowChatNewSubredditRules ? s.fbt._("Posts, comments, and chat messages", null, {
						hk: "4CFkd4"
					}) : s.fbt._("Posts & comments", null, {
						hk: "tHmQq"
					}))), l.a.createElement(re.a, {
						className: Y.a.modalRadioButton,
						key: q.b.post,
						value: q.b.post,
						selected: t.kind === q.b.post,
						showButton: !0,
						tabIndex: t.kind === q.b.post ? 0 : -1
					}, l.a.createElement(ne.p, {
						className: Y.a.modalRadioText
					}, s.fbt._("Posts only", null, {
						hk: "16dDBr"
					}))), l.a.createElement(re.a, {
						className: Y.a.modalRadioButton,
						key: q.b.comment,
						value: q.b.comment,
						selected: t.kind === q.b.comment,
						showButton: !0,
						tabIndex: t.kind === q.b.comment ? 0 : -1
					}, l.a.createElement(ne.p, {
						className: Y.a.modalRadioText
					}, e.shouldShowChatNewSubredditRules ? s.fbt._("Comments and chat messages", null, {
						hk: "2NstYC"
					}) : s.fbt._("Comments only", null, {
						hk: "2V8qUA"
					}))))), l.a.createElement(ne.h, null, l.a.createElement(ne.p, {
						className: Y.a.modalReportTitle
					}, s.fbt._("Report reason", null, {
						hk: "3ShjE9"
					})), l.a.createElement(ne.m, {
						className: Y.a.modalReportMeta
					}, s.fbt._("Defaults to rule name if left blank", null, {
						hk: "2xObiU"
					})), l.a.createElement(ne.t, {
						className: Y.a.modalReasonField,
						onChange: this.onReportReasonInputChange,
						placeholder: t.rule.trim().length > 0 && 0 === t.reportReason.trim().length ? t.rule : s.fbt._('Reason rule is broken (e.g. "This is a photo")', null, {
							hk: "2Op1SL"
						}),
						value: t.reportReason
					}), l.a.createElement(te.a, {
						maxChars: q.f,
						text: t.reportReason.trim()
					})), l.a.createElement("div", {
						className: Y.a.modalDescriptionBlock
					}, l.a.createElement(ne.p, {
						className: Y.a.modalRuleTitle
					}, s.fbt._("Full description", null, {
						hk: "4CTvQy"
					})), l.a.createElement(ne.t, {
						className: Y.a.modalDescriptionField,
						onChange: this.onDescriptionInputChange,
						placeholder: s.fbt._("Enter the full description of the rule.", null, {
							hk: "3EyaJe"
						}),
						value: t.description
					}), l.a.createElement(te.a, {
						maxChars: q.a,
						text: t.description.trim()
					}))), l.a.createElement(ne.g, {
						className: Y.a.modalFooter
					}, l.a.createElement(M.l, {
						className: Y.a.modalSubmitButton,
						onClick: this.onSave,
						disabled: !this.canSave()
					}, e.rule ? s.fbt._("Save", null, {
						hk: "4yMsMq"
					}) : s.fbt._("Add new rule", null, {
						hk: "2dy0gV"
					})), l.a.createElement(ne.a, {
						onClick: e.toggleModal
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), e.rule && l.a.createElement(ne.s, {
						className: Y.a.modalRemoveButton,
						onClick: e.onDelete
					}, s.fbt._("Delete", null, {
						hk: "4lt26q"
					}))))
				}
			}
			var me = Object(ee.a)(le(ue)),
				pe = n("./src/lib/timeAgo/index.ts"),
				be = n("./src/reddit/components/HumanDate/index.tsx"),
				fe = n("./src/reddit/components/RawHTMLDisplay/index.tsx"),
				he = n("./src/reddit/components/RichTextJson/index.tsx"),
				ge = n("./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.tsx"),
				ve = n("./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.tsx"),
				xe = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				Ee = n("./src/reddit/models/RichTextJson/index.ts");
			const Oe = {},
				Ce = Object(m.c)({
					shouldShowChatNewSubredditRules: e => Object(ae.c)(e)
				});
			class Ae extends l.a.Component {
				constructor(e) {
					super(e), this.toggleExpandDetails = () => {
						this.setState(e => ({
							isExpanded: !e.isExpanded
						}))
					}, this.state = {
						isExpanded: !1
					}
				}
				render() {
					const {
						hasConfigPerms: e,
						index: t,
						onEdit: n,
						subredditRule: r,
						shouldShowChatNewSubredditRules: o
					} = this.props, i = r.descriptionRichText ? JSON.parse(r.descriptionRichText).document : void 0, a = r.createdUtc / b.Xb, d = Object(pe.c)(a) >= 1;
					return l.a.createElement(l.a.Fragment, null, l.a.createElement(G.a, {
						className: Y.a.row
					}, l.a.createElement("span", {
						className: Y.a.ruleNumber
					}, t + 1), l.a.createElement("span", {
						className: Y.a.ruleText
					}, r.shortName), l.a.createElement("span", {
						className: Y.a.iconWrapper
					}, e && l.a.createElement("button", {
						className: Y.a.iconButton,
						onClick: n
					}, l.a.createElement(xe.a, {
						className: Y.a.icon,
						title: s.fbt._("Edit", null, {
							hk: "1nftDt"
						})
					})), l.a.createElement("button", {
						className: Y.a.iconButton,
						onClick: this.toggleExpandDetails
					}, this.state.isExpanded ? l.a.createElement(ge.a, {
						className: Y.a.icon,
						title: s.fbt._("Collapse", null, {
							hk: "eGqwd"
						})
					}) : l.a.createElement(ve.a, {
						className: Y.a.icon,
						title: s.fbt._("Expand", null, {
							hk: "4dMVPg"
						})
					})))), this.state.isExpanded && l.a.createElement(G.a, {
						className: Y.a.expandDetails
					}, l.a.createElement("span", {
						className: Y.a.metadata
					}, l.a.createElement("span", {
						className: Y.a.ruleMetaTitle
					}, s.fbt._("Report reason", null, {
						hk: "2RH1DJ"
					})), l.a.createElement("span", {
						className: Y.a.ruleMetaText
					}, r.violationReason && 0 !== r.violationReason.length ? r.violationReason : r.shortName)), l.a.createElement("span", {
						className: Y.a.middleMeta
					}, l.a.createElement("div", {
						className: Y.a.middleMetaBlock
					}, l.a.createElement("div", {
						className: Y.a.ruleMetaTitle
					}, s.fbt._("Applies to", null, {
						hk: "19eYpy"
					})), l.a.createElement("div", {
						className: Y.a.ruleMetaText
					}, r.kind === q.b.all ? o ? s.fbt._("Posts, comments, and chat messages", null, {
						hk: "3jAmZW"
					}) : s.fbt._("Posts & comments", null, {
						hk: "34PjHx"
					}) : r.kind === q.b.post ? s.fbt._("Posts only", null, {
						hk: "3MllWy"
					}) : o ? s.fbt._("Comments and chat messages", null, {
						hk: "4bWrXc"
					}) : s.fbt._("Comments only", null, {
						hk: "StCEa"
					}))), l.a.createElement("div", {
						className: Y.a.middleMetaBlock
					}, l.a.createElement("div", {
						className: Y.a.ruleMetaTitle
					}, s.fbt._("Created", null, {
						hk: "gSE9w"
					})), l.a.createElement("div", {
						className: Y.a.ruleMetaText
					}, d ? l.a.createElement(be.b, {
						seconds: a
					}) : l.a.createElement(be.d, {
						seconds: a
					})))), l.a.createElement("span", {
						className: Y.a.metadata
					}, l.a.createElement("span", {
						className: Y.a.ruleMetaTitle
					}, s.fbt._("Full description", null, {
						hk: "20Lgcg"
					})), l.a.createElement("span", {
						className: Y.a.ruleMetaText
					}, i && !Object(Ee.H)({
						document: i
					}) ? l.a.createElement(he.b, {
						className: Y.a.ruleMetaText,
						content: {
							document: i
						},
						rtJsonElementProps: Oe
					}) : r.descriptionHtml ? l.a.createElement(fe.a, {
						className: Y.a.ruleMetaText,
						html: r.descriptionHtml
					}) : r.description))))
				}
			}
			var ye = Object(u.b)(Ce)(Ae);
			const je = f.a.wrapped(M.l, "PrimaryButton", Y.a),
				Ie = () => l.a.createElement(G.a, {
					className: Y.a.placeholderRow
				}, l.a.createElement("span", {
					className: Y.a.emptyWrapper
				}, l.a.createElement("span", {
					className: Y.a.emptyIcon
				})), l.a.createElement("span", {
					className: Y.a.emptyDetails
				}), l.a.createElement("span", {
					className: Y.a.iconWrapper
				}, l.a.createElement("span", {
					className: Y.a.emptyRightIcon
				}), l.a.createElement("span", {
					className: Y.a.emptyRightIcon
				}))),
				ke = () => l.a.createElement("div", {
					className: Y.a.loadingContainer
				}, d()(15, e => l.a.createElement(Ie, {
					key: e
				}))),
				_e = Object(m.c)({
					hasModConfigPerms: (e, t) => Object(V.b)(Q.c.config)(e, {
						subredditId: t.subreddit.id
					}),
					isConfirmModalOpen: e => "SubredditRule--Modal--DeleteConfirmation" === Object(W.a)(e),
					isRuleEditorOpen: e => "SubredditRule--Editor--Modal" === Object(W.a)(e),
					isSubredditRulesPending: e => Object(C.V)(e),
					ruleOrder: (e, t) => Object(C.T)(e, {
						subredditId: t.subreddit.id
					}),
					subredditRules: (e, t) => Object(C.W)(e, {
						subredditId: t.subreddit.id
					}),
					isInShredditModNavExperiment: (e, t) => {
						let {
							subreddit: n
						} = t;
						const s = Object(V.n)(e, {
							subredditId: n.id
						});
						return Object(z.a)(e, !!s)
					}
				}),
				Se = Object(u.b)(_e, (e, t) => ({
					removeRule: (n, r) => e(((e, t, n) => async (r, o, i) => {
						let {
							apiContext: a
						} = i;
						const d = Object(C.X)(o(), {
								subredditId: e
							}).name,
							c = Object(C.W)(o(), {
								subredditId: e
							})[n],
							l = `success-block-${t}`,
							u = `error-block-${t}`,
							m = await Object(E.d)(a(), d, t);
						if (m.ok) {
							const t = m.body;
							r(I({
								rules: t,
								subredditId: e
							})), r(x.f({
								id: l,
								kind: O.b.SuccessCommunityGreen,
								text: s.fbt._("Rule deleted", null, {
									hk: "2Kwoph"
								}),
								buttonText: s.fbt._("Undo", null, {
									hk: "1RYWKC"
								}),
								buttonAction: y(e, {
									rule: c.shortName,
									kind: c.kind,
									reason: c.violationReason,
									description: c.description
								})
							}))
						} else r(x.f({
							id: u,
							kind: O.b.Error,
							text: m.json.errors ? m.json.errors[0][1] : s.fbt._("An error has occured. Please try again later", null, {
								hk: "37ELrZ"
							})
						}))
					})(t.subreddit.id, n, r)),
					reorderRules: n => {
						e(_(t.subreddit.id, n))
					},
					toggleConfirmationModal: () => e(Object(h.i)("SubredditRule--Modal--DeleteConfirmation")),
					toggleRuleEditorModal: () => e(Object(h.i)("SubredditRule--Editor--Modal"))
				}));
			class we extends l.a.Component {
				constructor(e) {
					super(e), this.isSticky = () => {
						const e = window.scrollY >= 100;
						this.setState({
							isFixed: e
						})
					}, this.deleteRule = () => {
						const e = this.state.ruleToEdit;
						e && this.props.removeRule(e.shortName, e.priority)
					}, this.onConfirmDeleteRule = () => {
						this.props.toggleConfirmationModal()
					}, this.onEditRule = e => {
						this.setState({
							ruleToEdit: e
						}), this.props.toggleRuleEditorModal()
					}, this.handleDrop = (e, t, n) => this.setState({
						ruleOrder: n,
						numRulesMoved: this.state.numRulesMoved + 1
					}), this.reorderRules = () => {
						this.props.reorderRules(this.state.ruleOrder), this.props.sendEvent(U("save_reorder", this.state.numRulesMoved)), this.stopReorder()
					}, this.startReorder = () => {
						this.setState({
							isReordering: !0,
							ruleOrder: this.props.ruleOrder
						})
					}, this.stopReorder = () => this.setState({
						isReordering: !1,
						numRulesMoved: 0
					}), this.toggleConfirmationModal = () => {
						this.props.toggleConfirmationModal(), this.setState({
							ruleToEdit: null
						})
					}, this.toggleEditorModal = () => {
						this.props.toggleRuleEditorModal(), this.setState({
							ruleToEdit: null
						})
					}, this.trackClick = e => this.props.sendEvent(F(e)), this.trackEdit = () => this.state.ruleToEdit ? this.trackClick("save_edit") : this.trackClick("save_new"), this.trackDelete = () => this.trackClick("delete"), this.renderTopBar = e => l.a.createElement(N.c, {
						className: Object(p.a)(e && "bg-neutral-background mb-xs pr-0", Y.a.topBar, {
							[Y.a.default]: !e,
							[Y.a.fixed]: this.state.isFixed
						})
					}, this.state.isReordering ? l.a.createElement(M.o, {
						onClick: this.stopReorder
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})) : l.a.createElement(M.r, {
						onClick: this.startReorder,
						disabled: this.props.subredditRules.length <= 1
					}, s.fbt._("Reorder rules", null, {
						hk: "1qh7V6"
					})), this.state.isReordering ? l.a.createElement(je, {
						onClick: this.reorderRules,
						disabled: i()(this.props.subredditRules.map(e => e.shortName), this.state.ruleOrder)
					}, s.fbt._("Save", null, {
						hk: "4yMsMq"
					})) : l.a.createElement(je, {
						onClick: this.toggleEditorModal,
						disabled: this.props.isSubredditRulesPending || this.props.subredditRules.length >= q.e
					}, s.fbt._("Add rule", null, {
						hk: "6GEk0"
					}))), this.state = {
						numRulesMoved: 0,
						ruleToEdit: null,
						ruleOrder: e.ruleOrder,
						isReordering: !1,
						isFixed: !this.props.isInShredditModNavExperiment
					}
				}
				componentDidMount() {
					this.props.isInShredditModNavExperiment && window.addEventListener("scroll", this.isSticky)
				}
				componentWillUnmount() {
					this.props.isInShredditModNavExperiment && window.removeEventListener("scroll", this.isSticky)
				}
				render() {
					const {
						hasModConfigPerms: e,
						isConfirmModalOpen: t,
						isRuleEditorOpen: n,
						isSubredditRulesPending: o,
						subreddit: i,
						subredditRules: a,
						isInShredditModNavExperiment: d
					} = this.props;
					return l.a.createElement(l.a.Fragment, null, !d && e && this.renderTopBar(), a.length ? l.a.createElement(N.a, {
						className: Object(p.a)(d && Y.a.newModNavContainer)
					}, l.a.createElement("div", {
						className: Y.a.header
					}, d ? l.a.createElement(l.a.Fragment, null, Object(P.c)(i.name, b.mc.SubredditRules), this.renderTopBar(!0)) : l.a.createElement(N.b, {
						className: Y.a.rulesHeader
					}, s.fbt._("Rules", null, {
						hk: "41SmPR"
					}), l.a.createElement(T.a, {
						linkUrl: `${r.a.redditModHelpUrl}/hc/en-us/articles/360023379211`
					})), !this.state.isReordering && l.a.createElement("div", {
						className: Y.a.rulesInfo
					}, s.fbt._("These are rules that visitors must follow to participate. They can be used as reasons to report or ban posts, comments, and users. Communities can have a maximum of 15 rules.", null, {
						hk: "1C2Vjc"
					}))), l.a.createElement("div", {
						className: Object(p.a)("w-100", Y.a.ruleContainer, {
							[Y.a.isReodering]: this.state.isReordering
						})
					}, this.state.isReordering ? l.a.createElement(R.a, {
						values: this.state.ruleOrder,
						render: (e, t, n, s, r) => l.a.createElement($, {
							isDragging: n,
							isOver: s,
							canDrop: r,
							index: t,
							shortName: e
						}),
						onDrop: this.handleDrop
					}) : a.map((t, n) => l.a.createElement(ye, {
						hasConfigPerms: e,
						index: n,
						key: `${i.name}-${t.shortName}`,
						onEdit: () => this.onEditRule(t),
						subredditRule: t
					})))) : l.a.createElement(N.a, {
						className: Object(p.a)(d && Y.a.newModNavContainer)
					}, l.a.createElement("div", {
						className: Y.a.header
					}, d ? l.a.createElement(l.a.Fragment, null, Object(P.c)(i.name, b.mc.SubredditRules), this.renderTopBar(!0)) : l.a.createElement(N.b, {
						className: Y.a.rulesHeader
					}, s.fbt._("Rules", null, {
						hk: "41SmPR"
					}), l.a.createElement(T.a, {
						linkUrl: `${r.a.redditModHelpUrl}/hc/en-us/articles/360023379211`
					}))), o ? l.a.createElement(ke, null) : l.a.createElement(w.c, {
						text: s.fbt._("No rules yet", null, {
							hk: "pYLkV"
						})
					}, l.a.createElement(H.a, {
						name: "rules",
						className: Y.a.rulesIcon
					}))), n && l.a.createElement(me, {
						onDelete: this.onConfirmDeleteRule,
						rule: this.state.ruleToEdit,
						ruleNames: a.map(e => e.shortName),
						sendEvent: this.trackEdit,
						subredditId: i.id,
						toggleModal: this.toggleEditorModal,
						withOverlay: !0
					}), t && this.state.ruleToEdit && l.a.createElement(S.a, {
						actionText: s.fbt._("Delete", null, {
							hk: "4lt26q"
						}),
						headerText: s.fbt._("Delete rule", null, {
							hk: "5q2Ri"
						}),
						modalText: s.fbt._("Are you sure you want to delete this rule?", null, {
							hk: "2diD6u"
						}),
						onConfirm: this.deleteRule,
						toggleModal: this.toggleConfirmationModal,
						trackClick: this.trackDelete,
						withOverlay: !0
					}))
				}
			}
			t.a = Se(Object(D.c)(we))
		},
		"./src/reddit/components/SubredditSearchCarousel/async.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/selectors/experiments/joinOptimizations.ts");
			const d = Object(s.a)({
					resolved: {},
					chunkName: () => "SubredditSearchCarousel",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("SubredditSearchCarousel").then(n.bind(null, "./src/reddit/components/SubredditSearchCarousel/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/SubredditSearchCarousel/index.tsx"
					}
				}),
				c = e => {
					const t = Object(i.e)(a.e),
						n = Object(i.e)(a.a);
					return t || n ? o.a.createElement(d, e) : null
				}
		},
		"./src/reddit/components/SubscribeButton/Base.m.less": function(e, t, n) {
			e.exports = {
				BaseButton: "_1LHxa-yaHJwrPK8kuyv_Y4",
				baseButton: "_1LHxa-yaHJwrPK8kuyv_Y4",
				UnsubscribeButtonDefault: "_31L3r0EWsU0weoMZvEJcUA",
				unsubscribeButtonDefault: "_31L3r0EWsU0weoMZvEJcUA",
				UnsubscribeButtonHover: "_11Zy7Yp4S1ZArNqhUQ0jZW",
				unsubscribeButtonHover: "_11Zy7Yp4S1ZArNqhUQ0jZW"
			}
		},
		"./src/reddit/components/SubscribeButton/Base.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/reddit/controls/Button/index.tsx"),
				a = n("./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts"),
				d = n("./src/reddit/components/SubscribeButton/Base.m.less"),
				c = n.n(d),
				l = n("./src/lib/classNames/index.ts");

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const m = (e, t, n) => null != n ? n : t ? e : i.c.Plain,
				p = e => {
					let {
						border: t,
						priority: n,
						small: s,
						...r
					} = e;
					return o.a.createElement(i.t, u({}, r, {
						priority: m(i.c.Primary, t, n),
						className: Object(l.a)(r.className, c.a.BaseButton),
						size: s ? i.d.S : i.d.M
					}))
				},
				b = e => o.a.createElement(o.a.Fragment, null, o.a.createElement("span", {
					className: c.a.UnsubscribeButtonDefault
				}, "subreddit" === e ? s.fbt._("Joined", null, {
					hk: "1MTmIz"
				}) : s.fbt._("Following", null, {
					hk: "1wQlVR"
				})), o.a.createElement("span", {
					className: c.a.UnsubscribeButtonHover
				}, "subreddit" === e ? s.fbt._("Leave", null, {
					hk: "2lLnnn"
				}) : s.fbt._("Unfollow", null, {
					hk: "2b5ERD"
				}))),
				f = e => {
					let {
						buttonType: t,
						border: n,
						priority: s,
						small: r,
						...a
					} = e;
					return o.a.createElement(i.t, u({}, a, {
						priority: m(i.c.Secondary, n, s),
						className: Object(l.a)(a.className, c.a.BaseButton),
						size: r ? i.d.S : i.d.M,
						text: b(t)
					}))
				};
			class h extends o.a.Component {
				constructor() {
					super(...arguments), this.onClick = e => {
						if (this.props.userIsSubscriber ? (this.props.onUnsubscribe(), this.props.afterUnsubscribeAction && this.props.afterUnsubscribeAction()) : this.props.onSubscribe(), this.props.onClick && this.props.onClick(e), this.props.getEventFactory) {
							const e = this.props.getEventFactory(this.props.userIsSubscriber);
							e && this.props.sendEvent(e)
						}
					}
				}
				componentDidMount() {
					this.props.onSubscriptionsRequested()
				}
				render() {
					const {
						border: e = !0,
						className: t,
						id: n,
						priority: s,
						small: r = !1,
						isFullWidth: i = !1,
						style: d
					} = this.props, c = {
						border: e,
						className: t,
						onClick: this.onClick,
						priority: s,
						small: r,
						isFullWidth: i,
						style: d
					};
					return this.props.userIsSubscriber ? o.a.createElement(f, u({}, c, {
						buttonType: this.props.identifier.type
					})) : o.a.createElement(p, u({}, c, {
						id: n
					}), this.props.children, Object(a.a)({
						type: this.props.identifier.type,
						key: "subscribe"
					}))
				}
			}
		},
		"./src/reddit/components/SubscribeButton/Inline.m.less": function(e, t, n) {
			e.exports = {
				ButtonSpacer: "vXXjS_s-Ic4QZpFsPjThV",
				buttonSpacer: "vXXjS_s-Ic4QZpFsPjThV",
				Checkmark: "_2qm48d8K8lTcwSJiHL9KLT",
				checkmark: "_2qm48d8K8lTcwSJiHL9KLT",
				Plus: "_2zcGm9WDxG67GYyNNvHzlA",
				plus: "_2zcGm9WDxG67GYyNNvHzlA"
			}
		},
		"./src/reddit/components/SubscribeButton/Inline.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/TrackingHelper/index.tsx"),
				i = n("./src/reddit/connectors/SubscribeButton/index.ts"),
				a = n("./src/reddit/controls/Button/index.tsx"),
				d = n("./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts"),
				c = n("./src/reddit/components/SubscribeButton/Inline.m.less"),
				l = n.n(c);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const m = n("./src/lib/lessComponent.tsx").a.div("ButtonSpacer", l.a);
			class p extends r.a.Component {
				constructor(e) {
					super(e), this.onMouseEnter = () => {
						this.setState({
							isHovered: !0
						})
					}, this.onMouseLeave = () => {
						this.setState({
							isHovered: !1
						})
					}, this.onClick = e => {
						const {
							props: t
						} = this;
						if (t.userIsSubscriber ? t.onUnsubscribe() : (this.setState({
								hasJustSubscribed: !0
							}), t.onSubscribe()), t.onClick && t.onClick(e), t.getEventFactory) {
							const e = t.getEventFactory(t.userIsSubscriber);
							e && t.sendEvent(e)
						}
					}, this.renderUnsubscribeButton = () => {
						const {
							className: e,
							identifier: t,
							onSubscribe: n,
							onUnsubscribe: s,
							postId: o,
							sendEvent: i,
							size: c,
							userIsSubscriber: l,
							doNotHideOtherSubscribeButtons: m,
							getEventFactory: p,
							onSubscriptionsRequested: b,
							priority: f,
							isShredditParityEnabled: h,
							...g
						} = this.props, v = this.state.isHovered, x = Object(d.a)({
							type: t.type,
							key: v ? "unsubscribe" : "subscribed"
						}), E = g.shouldReverseColor ? a.c.Secondary : a.c.Primary;
						return r.a.createElement(a.t, u({
							className: e,
							priority: f || E,
							rplStyle: h,
							text: x,
							onClick: this.onClick,
							onMouseEnter: this.onMouseEnter,
							onMouseLeave: this.onMouseLeave,
							size: a.d.XSP
						}, g))
					}, this.renderSubscribeButton = () => {
						const {
							className: e,
							identifier: t,
							onSubscribe: n,
							onUnsubscribe: s,
							postId: o,
							sendEvent: i,
							size: c,
							userIsSubscriber: l,
							doNotHideOtherSubscribeButtons: m,
							getEventFactory: p,
							onSubscriptionsRequested: b,
							priority: f,
							isShredditParityEnabled: h,
							...g
						} = this.props, v = Object(d.a)({
							type: t.type,
							key: "subscribe"
						}), x = g.shouldReverseColor ? a.c.Secondary : a.c.Primary;
						return r.a.createElement(a.t, u({
							className: e,
							priority: f || x,
							size: a.d.XSP,
							rplStyle: h,
							text: v,
							onClick: this.onClick
						}, g, {
							id: `subscribe-button-${o}`,
							onMouseEnter: this.onMouseEnter,
							onMouseLeave: this.onMouseLeave
						}))
					}, this.state = {
						hasJustSubscribed: !1,
						isHovered: !1
					}
				}
				componentDidMount() {
					this.props.onSubscriptionsRequested()
				}
				render() {
					const {
						small: e = !1,
						userIsSubscriber: t,
						doNotHideOtherSubscribeButtons: n
					} = this.props;
					return t ? this.state.hasJustSubscribed || n ? this.renderUnsubscribeButton() : e ? null : r.a.createElement(m, null) : this.renderSubscribeButton()
				}
			}
			t.a = Object(i.a)(Object(o.c)(p))
		},
		"./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			const r = e => {
					let {
						type: t
					} = e;
					return "subreddit" === t ? "subredditActions" : "profileActions"
				},
				o = {
					subredditActions: {
						subscribe: () => s.fbt._("Join", null, {
							hk: "3Nhj3V"
						}),
						subscribed: () => s.fbt._("Joined", null, {
							hk: "1YGago"
						}),
						unsubscribe: () => s.fbt._("Leave", null, {
							hk: "299znK"
						})
					},
					profileActions: {
						subscribe: () => s.fbt._("Follow", null, {
							hk: "18PRa5"
						}),
						subscribed: () => s.fbt._("Following", null, {
							hk: "sjS3y"
						}),
						unsubscribe: () => s.fbt._("Unfollow", null, {
							hk: "3c0uwF"
						})
					}
				},
				i = e => {
					let {
						type: t,
						key: n
					} = e;
					return o[r({
						type: t
					})][n]()
				}
		},
		"./src/reddit/components/SubscribeButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/components/TrackingHelper/index.tsx"),
				r = n("./src/reddit/connectors/SubscribeButton/index.ts"),
				o = n("./src/reddit/components/SubscribeButton/Base.tsx");
			t.a = Object(r.a)(Object(s.c)(o.a))
		},
		"./src/reddit/components/Thumbnail/index.m.less": function(e, t, n) {
			e.exports = {
				blurredThumbnail: "GnWcY6GPzeZ5rzsiQ98fo",
				container: "_2MkcR85HDnYngvlVW2gMMa",
				contentType: "_2hIvPRO2xz4rn9LXAJXYDa",
				hasType: "_10qSZsDWnOBwx4bc7GJ1QF",
				hiddenImage: "_25ZOvQhQdAqwdxPd5z-KFB",
				imageThumbnail: "_33Pa96SGhFVpZeI6a7Y_Pl",
				verticallyCenterThumbnail: "Fq7oYOARH1VVCaLAuAh37",
				linkIcon: "m0n699kowSp8Wfa40lqpF",
				outboundLinkIcon: "_2rOixIHGmpfZB93ihJsw3V",
				placeholderThumbnail: "_2YO2O4rMRYYMeH_t2y8M5w",
				thumbnail: "_2c1ElNxHftd8W_nZtcG9zf",
				usePreview: "_78ohNtfA1urjgUhnN1jLi",
				LinkText: "_3HXDOeeCKnmgu_pIdoLofi",
				linkText: "_3HXDOeeCKnmgu_pIdoLofi"
			}
		},
		"./src/reddit/components/Thumbnail/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return I
			})), n.d(t, "c", (function() {
				return T
			}));
			var s = n("./src/lib/isUrl/index.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				d = n("./src/lib/lessComponent.tsx"),
				c = n("./src/reddit/components/ImageWithFallback/index.tsx"),
				l = n("./src/reddit/controls/ContentType/index.tsx"),
				u = n("./src/reddit/controls/OutboundLink/index.tsx"),
				m = n("./src/reddit/icons/fonts/OutboundLink/index.tsx"),
				p = n("./src/reddit/models/Media/index.ts"),
				b = n("./src/reddit/models/Theme/index.ts"),
				f = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				h = n("./src/telemetry/models/Outbound.ts"),
				g = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				v = n("./src/reddit/components/Thumbnail/index.m.less"),
				x = n.n(v);

			function E() {
				return (E = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const O = e => e.placeholderImage || Object(f.a)(e).placeholderImage,
				C = e => e.placeholderImage ? "cover" : Object(f.a)(e).placeholderImagePosition,
				A = d.a.span("LinkText", x.a),
				y = e => {
					let {
						className: t,
						onClick: n,
						children: s
					} = e;
					return o.a.createElement("div", {
						onClick: n,
						className: Object(i.a)(x.a.linkIcon, t)
					}, s)
				},
				j = e => o.a.createElement("img", {
					alt: e.alt,
					className: Object(i.a)(x.a.hiddenImage, e.className)
				}),
				I = e => {
					const t = o.a.createRef(),
						{
							src: n,
							errorSrc: s
						} = e;
					return n && s && Object(c.b)(n).catch(() => {
						t.current && (t.current.style.backgroundImage = `url(${s})`)
					}), o.a.createElement("div", {
						"aria-label": e.alt,
						className: Object(i.a)(x.a.thumbnail, x.a.imageThumbnail, e.className),
						"data-click-id": "image",
						"data-adclicklocation": g.a.MEDIA,
						ref: t,
						role: "img",
						style: {
							backgroundImage: `url(${e.src})`,
							borderColor: e.isOutbound ? Object(f.a)(e).button : Object(f.a)(e).line
						}
					}, e.isOutbound && o.a.createElement(y, {
						className: e.linkIconClassName
					}, o.a.createElement(m.a, {
						className: Object(i.a)(x.a.outboundLinkIcon, e.outboundLinkIconClassName),
						isFilled: !0
					}), e.text && o.a.createElement(A, {
						className: e.linkTextClassName
					}, e.text)), o.a.createElement(j, {
						alt: e.alt,
						className: "hiddenImg"
					}))
				},
				k = e => e.isOutbound ? Object(f.a)(e).button : e.placeholderImage ? "transparent" : Object(f.a)(e).line,
				_ = e => {
					const t = O(e),
						n = t && {
							background: Object(b.g)(Object(f.a)(e).placeholder, t, C(e))
						};
					return o.a.createElement("div", {
						className: Object(i.a)(x.a.thumbnail, x.a.placeholderThumbnail, e.className),
						"data-click-id": "image",
						style: {
							...n,
							borderColor: k(e)
						}
					}, (!e.placeholderImage || e.showContentType) && o.a.createElement(l.a, {
						className: Object(i.a)(e.contentTypeClassName, x.a.contentType, {
							[x.a.hasType]: e.type && !e.isOutbound
						}),
						type: e.isMeta || e.isPoll ? "meta" : e.type
					}), e.isOutbound && o.a.createElement(y, {
						className: e.linkIconClassName
					}, o.a.createElement(m.a, {
						className: Object(i.a)(x.a.outboundLinkIcon, e.outboundLinkIconClassName),
						isFilled: !0
					}), e.text && o.a.createElement(A, {
						className: e.linkTextClassName
					}, e.text)))
				},
				S = e => o.a.createElement(I, E({}, e, {
					className: Object(i.a)(x.a.blurredThumbnail, e.className)
				})),
				w = Object(a.a)(e => {
					const {
						className: t,
						containerClassName: n,
						contentTypeClassName: r,
						crosspost: a,
						forceShowNSFW: d,
						isCommentsPage: c,
						isMeta: l,
						linkIconClassName: m,
						linkTextClassName: b,
						outboundLinkIconClassName: f,
						post: g,
						redditStyle: v,
						removeLink: E,
						showContentType: C,
						templatePlaceholderImage: A,
						text: y,
						theme: j,
						usePreview: I
					} = e, k = !j.subredditContext.shouldShowNSFWContent && (g.isNSFW || !(!a || !a.isNSFW)) && !d, _ = O({
						placeholderImage: A,
						redditStyle: v,
						theme: j
					}), S = T(e), w = c ? h.SourceElement.PostImage : h.SourceElement.ListingPostImage, N = P(g, t, _, k, y, j, S, l, C, E, v, m, b, f, r), D = Object(p.E)(g);
					return Object(s.a)(D) && !E && D.indexOf("redditmedia") < 0 ? o.a.createElement("div", {
						className: Object(i.a)(x.a.container, I ? x.a.usePreview : "", n)
					}, o.a.createElement(u.b, {
						href: Object(p.E)(g),
						isSponsored: g.isSponsored,
						postId: g.id,
						source: g.source,
						sourceElement: w
					}, N)) : o.a.createElement("div", {
						className: Object(i.a)(x.a.container, I ? x.a.usePreview : "", n)
					}, N)
				}),
				T = e => {
					let {
						crosspost: t,
						post: n,
						url: s,
						usePreview: r
					} = e;
					if (s) return s;
					const {
						preview: o,
						thumbnail: i
					} = t || n;
					return r && o ? o.url : n.isSponsored && o && "default" === i.url ? o.url : i.url
				},
				P = (e, t, n, r, a, d, c, l, u, m, p, b, f, h, g) => {
					const v = (e => e.source && !e.isSponsored || !1)(e);
					if (Object(s.a)(c)) {
						const n = Object(i.a)(t);
						return r ? o.a.createElement(S, {
							"data-click-id": "image",
							src: c,
							className: n,
							isOutbound: v && !m,
							linkIconClassName: b,
							linkTextClassName: f,
							outboundLinkIconClassName: h,
							redditStyle: p,
							text: a,
							theme: d
						}) : o.a.createElement(I, {
							alt: e.title,
							className: n,
							src: c,
							isOutbound: v && !m,
							linkIconClassName: b,
							linkTextClassName: f,
							outboundLinkIconClassName: h,
							redditStyle: p,
							text: a,
							theme: d
						})
					}
					return o.a.createElement(_, {
						className: t,
						contentTypeClassName: g,
						placeholderImage: n,
						isMeta: l,
						isOutbound: v && !m,
						linkIconClassName: b,
						linkTextClassName: f,
						outboundLinkIconClassName: h,
						redditStyle: p,
						showContentType: u,
						text: a,
						theme: d,
						type: e.media ? e.media.type : null,
						isPoll: !!e.pollData
					})
				};
			t.b = w
		},
		"./src/reddit/components/TrackingHelper/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/selectors/telemetry.ts"),
				a = n("./src/telemetry/index.ts");

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const c = r.a.createContext(() => {});

			function l(e) {
				let {
					children: t
				} = e;
				const n = Object(o.f)(),
					d = Object(s.useCallback)(e => {
						{
							const t = n.getState(),
								s = e(t);
							Object(a.a)({
								...i.p(t),
								...s
							})
						}
					}, [n]);
				return r.a.createElement(c.Provider, {
					value: d
				}, t ? r.a.Children.only(t) : null)
			}

			function u() {
				return Object(s.useContext)(c)
			}

			function m(e) {
				function t(t) {
					const n = u();
					return r.a.createElement(e, d({}, t, {
						sendEvent: n
					}))
				}
				const n = e.name || e.displayName;
				return t.displayName = `Tracked(${n})`, t.WrappedComponent = e, t
			}
		},
		"./src/reddit/components/UserIcon/PresenceDot.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/hooks/useIntersectionObserver.ts"),
				a = n("./src/reddit/icons/svgs/PresenceCircle/index.tsx"),
				d = n("./src/reddit/components/UserIcon/UserIcon.m.less"),
				c = n.n(d);
			t.default = e => {
				const {
					showPresence: t,
					onceInViewport: n
				} = e, d = Object(s.useRef)(null), l = Object(s.useCallback)(e => {
					e.forEach(e => {
						const {
							isIntersecting: t
						} = e;
						t && n && n()
					})
				}, [n]);
				return Object(i.a)(d, l), r.a.createElement(a.a, {
					ref: d,
					className: Object(o.a)(c.a.presenceDot, {
						[c.a.isLit]: t
					}),
					isHighlighted: e.isHighlighted,
					outlineClassName: e.outlineClassName
				})
			}
		},
		"./src/reddit/components/UserIcon/SnoovatarHeadshot.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/UserIcon/UserIcon.m.less"),
				d = n.n(a);
			t.a = function(e) {
				let {
					backgroundClassName: t,
					className: n,
					headshot: r,
					hasNftBorder: a,
					style: c
				} = e;
				return o.a.createElement("div", {
					className: Object(i.a)(d.a.snoovatarWrapper, n, {
						[d.a.hasNftBorder]: Boolean(a)
					}),
					style: c
				}, o.a.createElement("div", {
					className: Object(i.a)(d.a.snoovatarBackground, t)
				}), o.a.createElement("div", {
					className: d.a.snoovatarHeadshotContainer
				}, o.a.createElement("img", {
					alt: s.fbt._("User avatar", null, {
						hk: "12gjW8"
					}),
					className: d.a.snoovatarHeadshot,
					src: r
				})))
			}
		},
		"./src/reddit/components/UserIcon/UserIcon.m.less": function(e, t, n) {
			e.exports = {
				currentUserIconWrapper: "efdkOLo3oigH_95whTYCp",
				userIconWrapper: "_2p14AQvJBvTrEEa4csiW9v",
				isProfileIcon: "_1lxVpLf3223Gve3gRhbG-R",
				DefaultUserIcon: "_3utuhrSAkEkzgaswqglvpN",
				defaultUserIcon: "_3utuhrSAkEkzgaswqglvpN",
				UserIcon: "_2TN8dEgAQbSyKntWpSPYM7",
				userIcon: "_2TN8dEgAQbSyKntWpSPYM7",
				mNightmode: "_2aVSEFJsIE0M-4uRE-U24H",
				nftAnimation: "_3fhlcUDP9SJN47QMfuzW_j",
				nftBackground: "_3ppYbU2ZS369JSNSb8585I",
				nftBorder: "_1AX7t-EP7R4ZoVC41DG-Jx",
				snoovatarWrapper: "_1cyAeeYDGrx7MPL_jRwKZ",
				snoovatarBackground: "_2_QqG5dG916znjlVV8ZCbw",
				hasNftBorder: "_3Bn5QwbgKslkdt4UwkP9r9",
				snoovatarHeadshotContainer: "_1XJXnCAngvZLEeLpB3oa4L",
				snoovatarHeadshot: "ScrrUjzznpAqm92uwgnvO",
				presenceDot: "_2dn5Ncenn0BSD4tCSmxQhA",
				isLit: "GpWjjkZl5_kV4yZYWBaT2",
				hasHeadShotWrapper: "_1TENjLYSaj4L4uJMZa3DRe"
			}
		},
		"./src/reddit/components/UserIcon/UserIcon.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/icons/svgs/SnooSilhouette/index.tsx"),
				c = n("./src/reddit/components/UserIcon/UserIcon.m.less"),
				l = n.n(c);
			const u = `${s.a.assetPath}/img/avatar_over18_square.png`,
				m = e => !e || e.includes("avatar_default_");
			t.b = e => {
				const {
					className: t,
					iconUrl: n,
					isCurrentUser: s,
					isNightMode: o,
					isNSFW: c,
					nsfwIconUrl: p,
					shouldHideNSFW: b,
					style: f
				} = e;
				if (s && m(n) || !s && !n) return i.a.createElement(d.a, {
					className: Object(a.a)(l.a.DefaultUserIcon, t, {
						[l.a.mNightmode]: o
					}),
					style: f
				});
				const h = !s && c && b ? p || u : n;
				return i.a.createElement("img", {
					alt: r.fbt._("User avatar", null, {
						hk: "X43nA"
					}),
					className: Object(a.a)(l.a.UserIcon, t),
					src: h,
					style: f
				})
			}
		},
		"./src/reddit/components/UserIcon/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/classNames/index.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/realtime/GQLSubscription/async.tsx"),
				c = n("./src/reddit/helpers/userSnoovatar/index.ts"),
				l = n("./src/reddit/hooks/useIntersectionObserver.ts"),
				u = n("./src/reddit/models/User/index.ts"),
				m = n("./src/config.ts"),
				p = n("./src/reddit/components/LottieAnimation/index.tsx");
			var b = e => {
					let {
						className: t
					} = e;
					return o.a.createElement("svg", {
						className: t,
						fill: "none",
						viewBox: "0 0 32 32",
						xmlns: "http://www.w3.org/2000/svg"
					}, o.a.createElement("radialGradient", {
						id: "a",
						cx: "0",
						cy: "0",
						gradientTransform: "matrix(20.06268 6.0999 -3097.55815 10187.91225 -3.1 11.6)",
						gradientUnits: "userSpaceOnUse",
						r: "1"
					}, o.a.createElement("stop", {
						offset: "0",
						stopColor: "#1185b5"
					}), o.a.createElement("stop", {
						offset: ".29",
						stopColor: "#d7f7ff"
					}), o.a.createElement("stop", {
						offset: ".53",
						stopColor: "#5ef6d8"
					}), o.a.createElement("stop", {
						offset: ".84",
						stopColor: "#5ef6d8"
					}), o.a.createElement("stop", {
						offset: ".87",
						stopColor: "#1990b9"
					}), o.a.createElement("stop", {
						offset: "1",
						stopColor: "#3f9fc6"
					})), o.a.createElement("path", {
						d: "M13.77 1.1c.76-.41 1.7-.41 2.46 0L28 7.58c.75.42 1.2 1.17 1.2 1.96v12.94c0 .79-.45 1.54-1.2 1.95L16.23 30.9c-.76.42-1.7.42-2.46 0L2 24.42a2.25 2.25 0 0 1-1.2-1.95V9.53C.8 8.74 1.24 8 2 7.57z",
						stroke: "url(#a)",
						strokeLinejoin: "round",
						strokeWidth: "1.59"
					}))
				},
				f = n("./src/reddit/components/UserIcon/UserIcon.m.less"),
				h = n.n(f);
			var g = e => {
					let {
						iconUrl: t
					} = e;
					return Object(c.c)(t) ? o.a.createElement(p.a, {
						className: h.a.nftAnimation,
						assetUrl: `${m.a.assetPath}/img/snoovatars/comment-animations/nft_comment_animation.json`,
						loop: !0
					}) : o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						className: h.a.nftBackground
					}), o.a.createElement(b, {
						className: h.a.nftBorder
					}))
				},
				v = n("./src/reddit/components/UserIcon/PresenceDot.tsx"),
				x = n("./src/reddit/components/UserIcon/SnoovatarHeadshot.tsx"),
				E = n("./src/reddit/components/UserIcon/UserIcon.tsx"),
				O = n("./src/reddit/selectors/user.ts");

			function C() {
				return (C = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const A = () => {},
				y = Object(a.c)({
					currentUser: O.m,
					isNightMode: O.fb,
					shouldHideNSFW: O.H,
					user: O.Db
				}),
				j = Object(i.b)(y);
			t.a = j(e => {
				const {
					authorId: t,
					collapsed: n,
					currentUser: i,
					iconUrl: a,
					isCommentAuthorBlocked: m,
					isHighlighted: p,
					isNft: b,
					isNSFW: f,
					shouldUseOnlineOverride: O,
					isOnlineOverrideValue: y,
					isOnlineStatusLoadTest: j,
					isProfileIcon: I,
					omitResponsivePresenceWrapper: k,
					onPresenceIndicatorInViewport: _,
					shouldShowPresenceIndicator: S,
					user: w,
					userName: T,
					wrapperClassName: P,
					style: N,
					...D
				} = e, M = !!i && Object(u.e)(i) === T, R = M ? i : w, L = R && R.accountIcon || a, B = w ? w.isNSFW : f, F = Object(c.a)(L) && !m, U = F ? o.a.createElement(x.a, {
					headshot: L,
					className: e.className,
					hasNftBorder: b && Object(c.d)(a),
					style: N
				}) : o.a.createElement(E.b, C({}, D, {
					iconUrl: m && n ? "https://www.redditstatic.com/avatars/defaults/v2/avatar_default_3.png" : L,
					isCurrentUser: M,
					isNSFW: B,
					style: N
				})), [H, G] = Object(r.useState)(!1), Q = Object(r.useMemo)(() => ({
					input: {
						channel: {
							teamOwner: "CONTENT_AND_COMMUNITIES",
							category: "ONLINE_STATUS_INDICATOR",
							userID: t
						}
					}
				}), [t]), q = Object(r.useCallback)(e => {
					const {
						isOnline: t
					} = e.subscribe.data;
					G(t)
				}, []), W = Object(r.useRef)(null), [z, V] = Object(r.useState)(!1), K = Object(r.useCallback)(e => {
					e.forEach(e => {
						const {
							isIntersecting: t,
							intersectionRatio: n
						} = e, s = 1 !== n;
						t ? V(!0) : s && V(!1)
					})
				}, []), Y = Object(r.useRef)({
					rootMargin: "750px 0px 1000px 0px"
				});
				return Object(l.a)(W, K, Y.current), k ? U : o.a.createElement("div", {
					className: Object(s.a)(h.a.userIconWrapper, {
						[h.a.hasHeadShotWrapper]: F,
						[h.a.isProfileIcon]: I
					}, P),
					ref: W
				}, b && o.a.createElement(g, {
					iconUrl: a
				}), U, S && (H || O && y) && o.a.createElement(v.default, {
					showPresence: !0,
					isHighlighted: p,
					onceInViewport: _
				}), (S || j) && !O && z && o.a.createElement(d.a, {
					variables: Q,
					onData: S ? q : A,
					queryKey: "isUserOnline"
				}))
			})
		},
		"./src/reddit/components/VerticalVotes/DisabledVerticalVotes.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/VerticalVotes/votes.tsx"),
				d = n("./src/reddit/controls/Score/index.tsx"),
				c = n("./src/reddit/models/Vote/index.ts"),
				l = n("./src/reddit/components/VerticalVotes/index.m.less"),
				u = n.n(l);
			class m extends o.a.PureComponent {
				render() {
					const {
						className: e,
						scoreClassName: t
					} = this.props;
					return o.a.createElement("div", {
						className: Object(i.a)(e, u.a.votesContainer)
					}, o.a.createElement("button", {
						className: u.a.disabledVoteIcon,
						"aria-label": s.fbt._("Upvote", null, {
							hk: "4aEt1X"
						}),
						"aria-pressed": !1,
						disabled: !0
					}, o.a.createElement(a.d, {
						compact: !1,
						voteState: c.a.notVoted,
						interactive: !1
					})), o.a.createElement(d.a, {
						className: Object(i.a)(u.a.disabledScore, t),
						score: 0,
						voteState: c.a.notVoted,
						isScoreHidden: !0
					}), o.a.createElement("button", {
						className: u.a.disabledVoteIcon,
						"aria-label": s.fbt._("downvote", null, {
							hk: "4xXpvV"
						}),
						"aria-pressed": !1,
						disabled: !0
					}, o.a.createElement(a.c, {
						compact: !1,
						voteState: c.a.notVoted,
						interactive: !1
					})))
				}
			}
			t.a = m
		},
		"./src/reddit/components/VerticalVotes/index.m.less": function(e, t, n) {
			e.exports = {
				votesContainer: "_1E9mcoVn4MYnuBQSVDt1gC",
				bounceUp: "nmB1I04Z-G4nY3g3s_17F",
				bounceDown: "_1L6r7KisMt3CYUGWSEMGiR",
				disabledVoteIcon: "mvlZFfW9BWm1bmljE_0Rg"
			}
		},
		"./src/reddit/components/VerticalVotes/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return A
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				l = n("./src/reddit/constants/elementClassNames.ts"),
				u = n("./src/reddit/controls/Score/index.tsx"),
				m = n("./src/reddit/components/VerticalVotes/votes.tsx"),
				p = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				b = n("./src/reddit/models/Vote/index.ts"),
				f = n("./src/reddit/selectors/posts.ts"),
				h = n("./src/reddit/selectors/user.ts"),
				g = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				v = n("./src/reddit/components/VerticalVotes/index.m.less"),
				x = n.n(v);
			const E = Object(a.c)({
					isNightMode: h.fb,
					isAnimatingUpvotePostId: f.k
				}),
				O = Object(i.b)(E),
				C = e => !e.isCustomIconDisabled && !0 !== e.redditStyle && Object(p.a)(e).voteIcons.upvoteInactive && Object(p.a)(e).voteIcons.upvoteActive,
				A = e => !e.isCustomIconDisabled && !0 !== e.redditStyle && Object(p.a)(e).voteIcons.downvoteInactive && Object(p.a)(e).voteIcons.downvoteActive;
			class y extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						voted: b.a.notVoted
					}, this.onUpvote = () => {
						const {
							voteState: e
						} = this.props.model, {
							onVoteClick: t
						} = this.props;
						t(b.a.upvoted), this.setState({
							voted: e !== b.a.upvoted ? b.a.upvoted : b.a.notVoted
						})
					}, this.onDownvote = () => {
						const {
							voteState: e
						} = this.props.model, {
							onVoteClick: t
						} = this.props;
						t(b.a.downvoted), this.setState({
							voted: e !== b.a.downvoted ? b.a.downvoted : b.a.notVoted
						})
					}
				}
				render() {
					const e = this.props,
						{
							downvoteButtonClassName: t,
							isCountAnimShadowTestEnabled: n,
							isNightMode: r,
							isAnimatingUpvotePostId: i,
							shouldShowUpvoteRatioOnHover: a,
							isVoteCountAnimation: c,
							shouldShowScore: p = !0,
							upvoteButtonClassName: f,
							containerRef: h,
							model: v,
							postId: E
						} = e,
						O = C(e),
						y = A(e),
						j = v.voteState,
						I = i === E;
					return o.a.createElement("div", {
						className: Object(d.a)(x.a.votesContainer, e.className),
						id: `vote-arrows-${v.id}`,
						ref: h
					}, O ? o.a.createElement(m.b, {
						"aria-label": s.fbt._("upvote", null, {
							hk: "G6dJB"
						}),
						"aria-pressed": j === b.a.upvoted,
						"data-click-id": "upvote",
						"data-adclicklocation": g.b.UPVOTE,
						compact: e.compact,
						className: e.upvoteClassName,
						id: e.upvoteTooltipId,
						isNightMode: r,
						onClick: this.onUpvote,
						voteState: j
					}) : o.a.createElement("button", {
						"aria-label": s.fbt._("upvote", null, {
							hk: "RguWS"
						}),
						"aria-pressed": j === b.a.upvoted,
						className: Object(d.a)(l.n, f, {
							[x.a.bounceUp]: I
						}),
						onClick: this.onUpvote,
						"data-click-id": "upvote",
						"data-adclicklocation": g.b.UPVOTE,
						id: e.upvoteTooltipId
					}, o.a.createElement(m.d, {
						compact: e.compact,
						className: e.upvoteClassName,
						voteState: j
					})), !e.compact && p && o.a.createElement(u.a, {
						className: Object(d.a)(x.a.Score, e.scoreClassName),
						flairStyleTemplate: e.flairStyleTemplate,
						light: e.light,
						score: e.model.score,
						voteState: j,
						shouldShowUpvoteRatioOnHover: a,
						isScoreHidden: e.model.isScoreHidden,
						isVoteCountAnimation: !!c,
						isCountAnimShadowTestEnabled: !!n,
						postId: E
					}), y ? o.a.createElement(m.a, {
						"aria-label": s.fbt._("downvote", null, {
							hk: "tNfDV"
						}),
						"aria-pressed": j === b.a.downvoted,
						"data-click-id": "downvote",
						"data-adclicklocation": g.b.DOWNVOTE,
						className: e.downvoteClassName,
						compact: e.compact,
						isNightMode: r,
						onClick: this.onDownvote,
						voteState: j
					}) : o.a.createElement("button", {
						"aria-label": s.fbt._("downvote", null, {
							hk: "1mDjTw"
						}),
						"aria-pressed": j === b.a.downvoted,
						className: Object(d.a)(l.n, t),
						onClick: this.onDownvote,
						"data-click-id": "downvote",
						"data-adclicklocation": g.b.DOWNVOTE
					}, o.a.createElement(m.c, {
						className: e.downvoteClassName,
						compact: e.compact,
						voteState: j
					})))
				}
			}
			const j = Object(c.a)(O(y));
			t.a = j
		},
		"./src/reddit/components/VerticalVotes/votes.m.less": function(e, t, n) {
			e.exports = {
				customDownvote: "ceU_3ot04pOVIcrrXH9fY",
				compact: "_3sO1xEnOT_9CQBjRzczQjS",
				voted: "_8dpZTfzgKPKCUTjp9SAn1",
				customUpvote: "_2k73nZrjAYiwAj9hv7K-kq"
			}
		},
		"./src/reddit/components/VerticalVotes/votes.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return w
			})), n.d(t, "b", (function() {
				return T
			})), n.d(t, "c", (function() {
				return P
			})), n.d(t, "d", (function() {
				return N
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/CSSVariableProvider/withTheme.tsx");
			const a = (e, t, n) => s => {
				const r = e(s),
					i = t(s),
					a = !r && i;
				return Object(o.a)(n.baseClassName, s.className, {
					[n.mIsInteractive]: i,
					[n.mIsActive]: r,
					[n.mIsVoteable]: a
				})
			};
			var d = n("./src/reddit/icons/fonts/Downvote/index.tsx"),
				c = n("./src/reddit/models/Vote/index.ts"),
				l = n("./src/reddit/controls/Downvote/index.m.less"),
				u = n.n(l);
			const m = {
					...u.a,
					baseClassName: u.a.Downvote
				},
				p = e => {
					let {
						voteState: t
					} = e;
					return t === c.a.downvoted
				},
				b = a(p, e => {
					let {
						interactive: t
					} = e;
					return !1 !== t
				}, m);
			var f = e => r.a.createElement(d.a, {
					className: b(e),
					compact: e.compact,
					isFilled: p(e)
				}),
				h = n("./src/reddit/icons/fonts/Upvote/index.tsx"),
				g = n("./src/reddit/controls/Upvote/index.m.less"),
				v = n.n(g);
			const x = {
					...v.a,
					baseClassName: v.a.Upvote
				},
				E = e => {
					let {
						voteState: t
					} = e;
					return t === c.a.upvoted
				},
				O = a(E, e => {
					let {
						interactive: t
					} = e;
					return !1 !== t
				}, x);
			var C = e => r.a.createElement(h.b, {
					className: O(e),
					compact: e.compact,
					isFilled: E(e)
				}),
				A = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				y = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				j = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				I = n("./src/reddit/components/VerticalVotes/votes.m.less"),
				k = n.n(I);

			function _() {
				return (_ = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const S = e => Object(o.a)({
					[k.a.compact]: e.compact,
					[k.a.dark]: Object(y.b)(Object(A.a)(e)),
					[k.a.nightmode]: e.isNightMode
				}),
				w = Object(i.a)(e => {
					const {
						voteIcons: t
					} = Object(j.a)(e), n = {
						"--verticalvotes-customdownvote-active": `url(${t.downvoteActive})`,
						"--verticalvotes-customdownvote-inactive": `url(${t.downvoteInactive})`
					}, {
						theme: s,
						isNightMode: i,
						voteState: a,
						compact: d,
						...l
					} = e;
					return r.a.createElement("button", _({}, l, {
						className: Object(o.a)(k.a.customDownvote, S(e), {
							[k.a.voted]: e.voteState === c.a.downvoted
						}, e.className),
						style: n
					}))
				}),
				T = Object(i.a)(e => {
					const {
						voteIcons: t
					} = Object(j.a)(e), n = {
						"--verticalvotes-customupvote-active": `url(${t.upvoteActive})`,
						"--verticalvotes-customupvote-inactive": `url(${t.upvoteInactive})`
					}, {
						theme: s,
						isNightMode: i,
						voteState: a,
						compact: d,
						...l
					} = e;
					return r.a.createElement("button", _({}, l, {
						className: Object(o.a)(k.a.customUpvote, S(e), {
							[k.a.voted]: e.voteState === c.a.upvoted
						}, e.className),
						style: n
					}))
				}),
				P = f,
				N = C
		},
		"./src/reddit/components/ViewReportsDropdown/Loader.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-ViewReportsDropdown-index",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-ViewReportsDropdown-index").then(n.bind(null, "./src/reddit/components/ViewReportsDropdown/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ViewReportsDropdown/index.tsx"
				}
			})
		},
		"./src/reddit/components/Widgets/ThemedWidget/index.m.less": function(e, t, n) {
			e.exports = {
				widgetBackground: "_1G4yU68P50vRZ4USXfaceV",
				clickable: "_2mtWlchu4uQf339v56bSha",
				redditStyle: "_2QeqBqfT5UbHBoViZUt-wX",
				truncatedGradient: "_1lvCNVth3dt5y8lu3vT95L",
				widgetHeader: "_ZhON3a3vplThB8NFwuJn",
				widgetTitle: "_2sggAEfRQLyoAl4J__5twU",
				widgetContent: "TmgZY6tDcdErbE5d7E0HJ",
				widgetContentOnly: "_3RPJ8hHnfFohktLZca18J6",
				truncated: "r5dzQq7dgZyAmve8abbbt",
				seeMore: "_3dbp6Cm9uKkkIBr9EsU-qS"
			}
		},
		"./src/reddit/components/Widgets/ThemedWidget/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				c = n("./src/reddit/components/SEOTitle/index.tsx"),
				l = n("./src/reddit/components/TrackingHelper/index.tsx"),
				u = n("./src/reddit/contexts/PageLayer/index.tsx"),
				m = n("./src/reddit/controls/Button/index.tsx"),
				p = n("./src/reddit/helpers/trackers/widgets.ts"),
				b = n("./src/reddit/models/NewStructuredStyles/index.ts"),
				f = n("./src/reddit/selectors/experiments/topPosts.ts"),
				h = n("./src/reddit/selectors/structuredStyles.ts"),
				g = n("./src/reddit/selectors/user.ts"),
				v = n("./src/reddit/models/Theme/index.ts"),
				x = n("./src/reddit/models/Theme/NewColorSystem/index.ts");
			const E = e => e.styles && e.styles.backgroundColor ? e.styles.backgroundColor : Object(x.a)(e).widgetColors.sidebarWidgetBackgroundColor,
				O = e => e.styles && e.styles.headerColor ? e.styles.headerColor : Object(x.a)(e).widgetColors.sidebarWidgetHeaderColor,
				C = e => {
					const t = E(e);
					return Object(v.f)(t)
				},
				A = e => {
					const t = O(e);
					return Object(v.f)(t)
				};
			var y = n("./src/reddit/components/Widgets/ThemedWidget/index.m.less"),
				j = n.n(y);
			const {
				fbt: I
			} = n("./node_modules/fbt/lib/FbtPublic.js"), k = Object(u.v)(), _ = Object(o.b)(() => Object(i.c)({
				forceRedditStyle: (e, t) => {
					const n = Object(u.o)(e, t) || void 0,
						s = t.redditStyle || Object(h.l)(e, {
							subredditId: n
						}),
						r = Object(g.fb)(e);
					return s || r
				},
				nigtmode: g.fb,
				subredditId: u.o,
				topPostVariant: f.d
			}));
			class S extends r.a.Component {
				constructor() {
					super(...arguments), this.contentRef = r.a.createRef(), this.state = {
						isTruncated: !1
					}, this.handleSeeMoreClick = () => {
						const {
							subredditId: e,
							widgetKind: t
						} = this.props;
						e && t && this.props.sendEvent(Object(p.b)(e, t)), this.setState({
							isTruncated: !1
						})
					}
				}
				componentDidMount() {
					const e = this.contentRef.current,
						t = e && e.offsetHeight;
					this.props.truncateThreshold && t && t > this.props.truncateThreshold && this.setState({
						isTruncated: !0
					})
				}
				getWidgetBackgroundStyles() {
					const e = {};
					return e.backgroundColor = E(this.props), e.borderColor = Object(b.d)(e.backgroundColor, this.props.nigtmode), e.color = e.fill = C(this.props), e
				}
				getWidgetHeaderStyles() {
					const e = {};
					return e.backgroundColor = O(this.props), e.color = e.fill = A(this.props), e
				}
				render() {
					const {
						children: e,
						className: t,
						contentOnly: n,
						forceRedditStyle: s,
						headerButton: o,
						id: i,
						onClick: d,
						onHeaderClick: l,
						title: u,
						titleClassName: p,
						truncateThreshold: b
					} = this.props, f = n ? j.a.widgetContentOnly : j.a.widgetContent, h = !s && this.props.styles, g = h ? this.getWidgetBackgroundStyles() : {}, v = h ? this.getWidgetHeaderStyles() : {};
					return r.a.createElement("div", {
						className: Object(a.a)(t, j.a.widgetBackground, {
							[j.a.redditStyle]: s,
							[j.a.clickable]: !!d,
							[j.a.truncatedGradient]: this.state.isTruncated && !this.props.noGradient
						}),
						"data-redditstyle": s,
						onClick: d,
						style: g
					}, u && r.a.createElement("div", {
						className: Object(a.a)(j.a.widgetHeader, {
							[j.a.clickable]: !!l
						}),
						id: i,
						style: {
							...v,
							...this.props.headerStyles
						},
						onClick: l
					}, r.a.createElement("div", {
						className: Object(a.a)(j.a.widgetTitle, p)
					}, r.a.createElement(c.b, {
						type: c.a.Widget
					}, u)), o), r.a.createElement("div", {
						className: Object(a.a)(f, {
							[j.a.truncated]: this.state.isTruncated
						}),
						ref: this.contentRef,
						style: {
							maxHeight: this.state.isTruncated ? b : "none"
						}
					}, e), this.state.isTruncated && r.a.createElement(m.r, {
						className: j.a.seeMore,
						onClick: this.handleSeeMoreClick
					}, I._("See More", null, {
						hk: "4w47Qu"
					})))
				}
			}
			t.a = k(_(Object(d.a)(Object(l.c)(S))))
		},
		"./src/reddit/components/Wiki/CreateNewWikiPageModal/index.m.less": function(e, t, n) {
			e.exports = {
				modalBody: "_1bgWTt9jbjzFmQBe0xzfBc",
				notice: "_19wd_7K0Gqdp6cf0Pno6jX",
				sectionTitle: "_2eB-lbdBJ7yGnpy9iCXf27",
				primaryButton: "_1Wp9oAwAZieyVMe4wA5SeL",
				dropdownContainer: "_2-waVlosIHdWwUa_OBavKm",
				dropdownTarget: "_1mcRpBQSnN5ALeKix2x4Py",
				targetText: "_3QRCCOc1SfjMkk4bZCW5lD",
				dropdown: "_1Uq_MgLQhUk4iL9iHGz3qL",
				dropdownRow: "_2UfNC6z3v6GQsT_TQn-eoZ",
				errorText: "_31tw_6Xr1vH0KRVUnoJEdv"
			}
		},
		"./src/reddit/connectors/PostViewable/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/reddit/actions/post.ts");
			t.a = (e, t) => Object(s.b)(e, function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
				return {
					...e,
					onPostViewable: r.O
				}
			}(t))
		},
		"./src/reddit/connectors/SubscribeButton/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/actions/subscription/index.ts"),
				i = n("./src/reddit/selectors/subreddit.ts");
			t.a = Object(s.b)(() => Object(r.c)({
				userIsSubscriber: i.jb
			}), (e, t) => {
				let {
					identifier: n
				} = t;
				return {
					onSubscribe: () => e(o.d([n], !0)),
					onSubscriptionsRequested: () => e(o.e()),
					onUnsubscribe: () => e(o.d([n], !1))
				}
			})
		},
		"./src/reddit/constants/componentSizes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return u
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "p", (function() {
				return p
			})), n.d(t, "q", (function() {
				return b
			})), n.d(t, "r", (function() {
				return f
			})), n.d(t, "t", (function() {
				return h
			})), n.d(t, "s", (function() {
				return g
			})), n.d(t, "u", (function() {
				return v
			})), n.d(t, "v", (function() {
				return x
			})), n.d(t, "k", (function() {
				return E
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "m", (function() {
				return C
			})), n.d(t, "n", (function() {
				return A
			})), n.d(t, "o", (function() {
				return y
			}));
			const s = 284,
				r = 450,
				o = 800,
				i = 284,
				a = 48,
				d = 640,
				c = 1600,
				l = 40,
				u = 48,
				m = 24,
				p = 24,
				b = 312,
				f = 40,
				h = 270,
				g = 106,
				v = 5,
				x = 16,
				E = 1250,
				O = 82,
				C = 48,
				A = 36,
				y = 40
		},
		"./src/reddit/constants/componentTestIds.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			}));
			const s = "comment",
				r = "comment-submission-form-markdown",
				o = "comment-submission-form-richtext",
				i = "comments-page-link-num-comments",
				a = "language-prompt-close",
				d = "post-content"
		},
		"./src/reddit/constants/elementClassNames.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "k", (function() {
				return a
			})), n.d(t, "m", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "n", (function() {
				return l
			})), n.d(t, "j", (function() {
				return u
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "i", (function() {
				return h
			}));
			const s = "DraftEditor-contentwrapper",
				r = "public-DraftStyleDefault-block",
				o = "data-offset-key",
				i = "hovered",
				a = "scrollerItem",
				d = "threadline",
				c = "header-user-dropdown",
				l = "voteButton",
				u = "RichTextJSON-root",
				m = "ImageBox-image",
				p = "content-type-link",
				b = "styled-outbound-link",
				f = "ListingLayout-backgroundContainer",
				h = "ListingLayout-outerContainer"
		},
		"./src/reddit/constants/elementIds.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			}));
			const s = "AppRouter-main-content",
				r = "bladeContainer",
				o = "header",
				i = "overlayScrollContainer",
				a = "collectionPostListScrollContainer"
		},
		"./src/reddit/constants/errors.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.BannedProfile = "BANNED", e.DeletedProfile = "DELETED", e.NotFoundProfile = "NOT_FOUND", e.ForbiddenProfile = "FORBIDDEN"
				}(s || (s = {})),
				function(e) {
					e.Unknown = "Unknown"
				}(r || (r = {}))
		},
		"./src/reddit/constants/gold.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "i", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "g", (function() {
				return u
			}));
			const s = "ModerationPage--Modal--AddAward",
				r = "ModerationPage--Modal--DeleteAwardConfirmation",
				o = 20,
				i = 4,
				a = 1e4,
				d = .2,
				c = .1,
				l = .1,
				u = 500
		},
		"./src/reddit/constants/graphql.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Card = "CARD", e.Classic = "CLASSIC", e.Compact = "COMPACT"
				}(s || (s = {}))
		},
		"./src/reddit/constants/imagePaths.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/config.ts");
			const r = Array.from({
					length: 20
				}).map((e, t) => `${s.a.assetPath}/img/snoovatars/snoovatar_${t+1}.png`),
				o = Array.from({
					length: 8
				}).map((e, t) => `${s.a.processingAvatarImageUrl}/defaults/v2/avatar_default_${t}.png`)
		},
		"./src/reddit/constants/jsapiEvents.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			const s = "reddit",
				r = "reddit.ready",
				o = "reddit.urlChanged"
		},
		"./src/reddit/constants/keycodes.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "a", (function() {
					return s
				})), n.d(t, "b", (function() {
					return r
				})),
				function(e) {
					e[e.ArrowDown = 40] = "ArrowDown", e[e.ArrowLeft = 37] = "ArrowLeft", e[e.ArrowRight = 39] = "ArrowRight", e[e.ArrowUp = 38] = "ArrowUp", e[e.Backspace = 8] = "Backspace", e[e.Delete = 46] = "Delete", e[e.Enter = 13] = "Enter", e[e.Escape = 27] = "Escape", e[e.F = 70] = "F", e[e.K = 75] = "K", e[e.Space = 32] = "Space", e[e.Tab = 9] = "Tab", e[e.Comma = 188] = "Comma"
				}(s || (s = {})),
				function(e) {
					e.ArrowDown = "ArrowDown", e.ArrowLeft = "ArrowLeft", e.ArrowRight = "ArrowRight", e.ArrowUp = "ArrowUp", e.Backspace = "Backspace", e.Enter = "Enter", e.Escape = "Escape", e.F = "f", e.Tab = "Tab", e.Space = " ", e.Comma = ","
				}(r || (r = {}))
		},
		"./src/reddit/constants/livebar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "live_bar_nav"
		},
		"./src/reddit/constants/moderationLog.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "j", (function() {
				return v
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/icons.ts"),
				o = n("./src/redditGQL/types.ts");
			const i = ["Anti-Evil Operations", "Reddit Legal"];
			var a;
			! function(e) {
				e.DATE = "date", e.ACTION = "action", e.MODERATOR = "moderator"
			}(a || (a = {}));
			const d = {
					[o.y.Apps]: () => s.fbt._("Apps", null, {
						hk: "Pj7M4"
					}),
					[o.y.Awards]: () => s.fbt._("Awards", null, {
						hk: "MZQfH"
					}),
					[o.y.Comments]: () => s.fbt._("Comments", null, {
						hk: "2lDGmG"
					}),
					[o.y.CrowdControl]: () => s.fbt._("CrowdControl", null, {
						hk: "36Hdke"
					}),
					[o.y.Members]: () => s.fbt._("Members", null, {
						hk: "3XMB94"
					}),
					[o.y.ModTeam]: () => s.fbt._("Mod Team", null, {
						hk: "3PHzgJ"
					}),
					[o.y.Posts]: () => s.fbt._("Posts", null, {
						hk: "4anDQX"
					}),
					[o.y.PostsAndComments]: () => s.fbt._("Posts and Comments", null, {
						hk: "2wSR4X"
					}),
					[o.y.Rules]: () => s.fbt._("Rules", null, {
						hk: "1Se158"
					}),
					[o.y.Settings]: () => s.fbt._("Settings", null, {
						hk: "uTh33"
					}),
					[o.y.Wiki]: () => s.fbt._("Wiki", null, {
						hk: "2f4T1a"
					})
				},
				c = {
					[o.y.Apps]: r.a.bot,
					[o.y.Awards]: r.a.award,
					[o.y.Comments]: r.a.comment,
					[o.y.CrowdControl]: r.a.crowd_control,
					[o.y.Members]: r.a.profile,
					[o.y.ModTeam]: r.a.mod,
					[o.y.Posts]: r.a.text_post,
					[o.y.PostsAndComments]: r.a.list_bulleted,
					[o.y.Rules]: r.a.rules,
					[o.y.Settings]: r.a.settings,
					[o.y.Wiki]: r.a.wiki
				},
				l = {
					[o.y.Apps]: "#C5C5C5",
					[o.y.Awards]: "#FFD5C6",
					[o.y.Comments]: "#FFCCD2",
					[o.y.CrowdControl]: "#FFC5EC",
					[o.y.Members]: "#F2C8FF",
					[o.y.ModTeam]: "#D8D4FF",
					[o.y.Posts]: "#C6DCFF",
					[o.y.PostsAndComments]: "#D2DADD",
					[o.y.Rules]: "#B6E9FF",
					[o.y.Settings]: "#BFEEB8",
					[o.y.Wiki]: "#FFE88F"
				},
				u = {
					[o.y.Apps]: "#A8A8A8",
					[o.y.Awards]: "#FFBEA6",
					[o.y.Comments]: "#FFADB8",
					[o.y.CrowdControl]: "#FFA5E3",
					[o.y.Members]: "#EEA7FF",
					[o.y.ModTeam]: "#C3BDFF",
					[o.y.Posts]: "#A7CCFF",
					[o.y.PostsAndComments]: "#A0B0B5",
					[o.y.Rules]: "#95DCFB",
					[o.y.Settings]: "#A3E398",
					[o.y.Wiki]: "#FADB61"
				},
				m = {
					ALL_ACTIONS: () => s.fbt._("All actions", null, {
						hk: "3sHzD4"
					}),
					ACCEPT_MODERATOR_INVITE: () => s.fbt._("Accept moderator invite", null, {
						hk: "3WJot2"
					}),
					ADD_COMMUNITY_TOPICS: () => s.fbt._("Add community topics", null, {
						hk: "4xgglk"
					}),
					ADD_CONTRIBUTOR: () => s.fbt._("Add contributor", null, {
						hk: "444ZK"
					}),
					ADD_MODERATOR: () => s.fbt._("Add moderator", null, {
						hk: "4rRghF"
					}),
					ADD_NOTE: () => s.fbt._("Add note", null, {
						hk: "2UjBm"
					}),
					ADD_REMOVAL_REASON: () => s.fbt._("Add removal reason", null, {
						hk: "jCC35"
					}),
					ADJUST_POST_CROWD_CONTROL_LEVEL: () => s.fbt._("Adjust post crowd control level", null, {
						hk: "Eqwnv"
					}),
					ENABLE_POST_CROWD_CONTROL_FILTER: () => s.fbt._("Enable post crowd control filter", null, {
						hk: "1uzJGq"
					}),
					DISABLE_POST_CROWD_CONTROL_FILTER: () => s.fbt._("Disable post crowd control filter", null, {
						hk: "UrQCB"
					}),
					APPROVE_COMMENT: () => s.fbt._("Approve comment", null, {
						hk: "1gvHWC"
					}),
					APPROVE_LINK: () => s.fbt._("Approve link", null, {
						hk: "2LqFt4"
					}),
					BAN_USER: () => s.fbt._("Ban user", null, {
						hk: "4DmPqi"
					}),
					COLLECTIONS: () => s.fbt._("Collections", null, {
						hk: "3a39Wa"
					}),
					COMMUNITY_STYLING: () => s.fbt._("Community styling", null, {
						hk: "386ps9"
					}),
					COMMUNITY_WIDGETS: () => s.fbt._("Community widgets", null, {
						hk: "4ml45n"
					}),
					CREATE_AWARD: () => s.fbt._("Create award", null, {
						hk: "bWa9w"
					}),
					CREATE_REMOVAL_REASON: () => s.fbt._("Create removal reason", null, {
						hk: "i1LIy"
					}),
					CREATE_RULE: () => s.fbt._("Create rule", null, {
						hk: "28uE69"
					}),
					CREATE_SCHEDULED_POST: () => s.fbt._("Create scheduled post", null, {
						hk: "mVbI1"
					}),
					DELETE_AWARD: () => s.fbt._("Delete award", null, {
						hk: "3xYaZ7"
					}),
					DELETE_REMOVAL_REASON: () => s.fbt._("Delete removal reason", null, {
						hk: "3FdYhk"
					}),
					DELETE_RULE: () => s.fbt._("Delete rule", null, {
						hk: "2lWdRL"
					}),
					DELETE_SCHEDULED_POST: () => s.fbt._("Delete scheduled post", null, {
						hk: "MhwRy"
					}),
					DELETE_OVERRIDDEN_CLASSIFICATION: () => s.fbt._("Delete overridden classification", null, {
						hk: "3hPfDT"
					}),
					DELETE_NOTE: () => s.fbt._("Delete note", null, {
						hk: "1P0prb"
					}),
					DEV_PLATFORM_APP_CHANGED: () => s.fbt._("App changed", null, {
						hk: "4vxPNi"
					}),
					DEV_PLATFORM_APP_DISABLED: () => s.fbt._("App disabled", null, {
						hk: "EUIP4"
					}),
					DEV_PLATFORM_APP_ENABLED: () => s.fbt._("App enabled", null, {
						hk: "3ZN1Is"
					}),
					DEV_PLATFORM_APP_INSTALLED: () => s.fbt._("App installed", null, {
						hk: "FcJY5"
					}),
					DEV_PLATFORM_APP_UNINSTALLED: () => s.fbt._("App uninstalled", null, {
						hk: "4lcMq"
					}),
					DISABLE_AWARD: () => s.fbt._("Disable award", null, {
						hk: "2yFBt7"
					}),
					DISTINGUISH: () => s.fbt._("Distinguish", null, {
						hk: "3cWniK"
					}),
					EDIT_FLAIR: () => s.fbt._("Edit flair", null, {
						hk: "mD0CV"
					}),
					EDIT_POST_REQUIREMENTS: () => s.fbt._("Edit post requirements", null, {
						hk: "1SLqNE"
					}),
					EDIT_RULE: () => s.fbt._("Edit rule", null, {
						hk: "2T4TJx"
					}),
					EDIT_SCHEDULED_POST: () => s.fbt._("Edit scheduled post", null, {
						hk: "1XCmsI"
					}),
					EDIT_SETTINGS: () => s.fbt._("Edit settings", null, {
						hk: "3o8q46"
					}),
					ENABLE_AWARD: () => s.fbt._("Enable award", null, {
						hk: "3zYir4"
					}),
					HIDDEN_AWARD: () => s.fbt._("Hide award", null, {
						hk: "31lRN8"
					}),
					EVENTS: () => s.fbt._("Events", null, {
						hk: "4Bq9wt"
					}),
					IGNORE_REPORTS: () => s.fbt._("Ignore reports", null, {
						hk: "1defIy"
					}),
					INVITE_MODERATOR: () => s.fbt._("Invite moderator", null, {
						hk: "1DbgL5"
					}),
					INVITE_SUBSCRIBER: () => s.fbt._("Invite subscriber", null, {
						hk: "4yEMNb"
					}),
					LOCK: () => s.fbt._("Lock", null, {
						hk: "39hTi5"
					}),
					MARK_NSFW: () => s.fbt._("Mark nsfw", null, {
						hk: "3bo45o"
					}),
					MARK_ORIGINAL_CONTENT: () => s.fbt._("Mark original content", null, {
						hk: "SadHO"
					}),
					MOD_AWARD_GIVEN: () => s.fbt._("Mod award given by moderators", null, {
						hk: "35cQgR"
					}),
					MODMAIL_ENROLLMENT: () => s.fbt._("Modmail enrollment", null, {
						hk: "4ee1XK"
					}),
					MUTE_USER: () => s.fbt._("Mute user", null, {
						hk: "3kPYe4"
					}),
					OVERRIDE_CLASSIFICATION: () => s.fbt._("Override classification", null, {
						hk: "2VPY6n"
					}),
					REMOVE_COMMENT: () => s.fbt._("Remove comment", null, {
						hk: "vEI4S"
					}),
					REMOVE_COMMUNITY_TOPICS: () => s.fbt._("Remove community topics", null, {
						hk: "1tLjxQ"
					}),
					REMOVE_CONTRIBUTOR: () => s.fbt._("Remove contributor", null, {
						hk: "4FMLz6"
					}),
					REMOVE_LINK: () => s.fbt._("Remove link", null, {
						hk: "tmjch"
					}),
					REMOVE_MODERATOR: () => s.fbt._("Remove moderator", null, {
						hk: "1FHVTB"
					}),
					REMOVE_WIKI_CONTRIBUTOR: () => s.fbt._("Remove wiki contributor", null, {
						hk: "1PcCja"
					}),
					REORDER_REMOVAL_REASON: () => s.fbt._("Reorder removal reason", null, {
						hk: "2dAkjt"
					}),
					REORDER_MODERATORS: () => s.fbt._("Reorder moderators", null, {
						hk: "3Csxj8"
					}),
					REORDER_RULES: () => s.fbt._("Reorder rules", null, {
						hk: "306Bqx"
					}),
					SET_CONTEST_MODE: () => s.fbt._("Set contest mode", null, {
						hk: "1pERnU"
					}),
					SET_PERMISSIONS: () => s.fbt._("Set permissions", null, {
						hk: "3UzkKU"
					}),
					SET_SUGGESTEDSORT: () => s.fbt._("Set suggested sort", null, {
						hk: "208T6K"
					}),
					SHOW_COMMENT: () => s.fbt._("Show comment", null, {
						hk: "n5M3i"
					}),
					SNOOZE_REPORTS: () => s.fbt._("Snooze reports", null, {
						hk: "3gOkDV"
					}),
					SPAM_COMMENT: () => s.fbt._("Spam comment", null, {
						hk: "2ROyTD"
					}),
					SPAM_LINK: () => s.fbt._("Spam link", null, {
						hk: "2G5xg3"
					}),
					SPOILER: () => s.fbt._("Spoiler", null, {
						hk: "2nfv1a"
					}),
					STICKY: () => s.fbt._("Sticky", null, {
						hk: "1W6JrJ"
					}),
					SUBMIT_CONTENT_RATING_SURVEY: () => s.fbt._("Submit content rating survey", null, {
						hk: "1F1ead"
					}),
					SUBMIT_SCHEDULED_POST: () => s.fbt._("Submit scheduled post", null, {
						hk: "1i2VUH"
					}),
					UNBAN_USER: () => s.fbt._("Unban user", null, {
						hk: "4m2iNP"
					}),
					UNIGNORE_REPORTS: () => s.fbt._("Unignore reports", null, {
						hk: "1wfp99"
					}),
					UNINVITE_MODERATOR: () => s.fbt._("Uninvite moderator", null, {
						hk: "3E6UkD"
					}),
					UNLOCK: () => s.fbt._("Unlock", null, {
						hk: "2BHnOC"
					}),
					UNMUTE_USER: () => s.fbt._("Unmute user", null, {
						hk: "25tct2"
					}),
					UNSET_CONTEST_MODE: () => s.fbt._("Unset contest mode", null, {
						hk: "AxsDk"
					}),
					UNSNOOZE_REPORTS: () => s.fbt._("Unsnooze reports", null, {
						hk: "4nlwcg"
					}),
					UNSPOILER: () => s.fbt._("Unspoiler", null, {
						hk: "2gE1K1"
					}),
					UNSTICKY: () => s.fbt._("Unsticky", null, {
						hk: "U5tvd"
					}),
					UPDATE_REMOVAL_REASON: () => s.fbt._("Update removal reason", null, {
						hk: "aDPHp"
					}),
					WIKI_BANNED: () => s.fbt._("Wiki banned", null, {
						hk: "1nk4H7"
					}),
					WIKI_CONTRIBUTOR: () => s.fbt._("Wiki contributor", null, {
						hk: "1W6zn3"
					}),
					WIKI_PAGE_LISTED: () => s.fbt._("Wiki page listed", null, {
						hk: "4aghdO"
					}),
					WIKI_PERM_LEVEL: () => s.fbt._("Wiki perm level", null, {
						hk: "4waHE"
					}),
					WIKI_REVISE: () => s.fbt._("Wiki revise", null, {
						hk: "3FZuIJ"
					}),
					WIKI_UNBANNED: () => s.fbt._("Wiki unbanned", null, {
						hk: "1fAtKd"
					})
				},
				p = {
					added_event_times: () => s.fbt._("added event times to post", null, {
						hk: "1TpgVq"
					}),
					added_flair_styling: () => s.fbt._("added flair styling", null, {
						hk: "zQ6Tv"
					}),
					added_styling: () => s.fbt._("modified community styling", null, {
						hk: "xSJ7B"
					}),
					added_to_collection: () => s.fbt._("added post to collection", null, {
						hk: "3V4fk0"
					}),
					added_widget: () => s.fbt._("added widget", null, {
						hk: "1eVJg6"
					}),
					allow_discovery: () => s.fbt._("toggle allow in search/onboarding/discovery", null, {
						hk: "3on6Qf"
					}),
					allow_top: () => s.fbt._("toggle allow in default/trending lists", null, {
						hk: "DikzW"
					}),
					collapse_deleted_comments: () => s.fbt._("toggle collapse deleted/removed comments", null, {
						hk: "22QPzD"
					}),
					comment_score_hide_mins: () => s.fbt._("comment score hide period", null, {
						hk: "21jsup"
					}),
					confirm_ham: () => s.fbt._("approved", null, {
						hk: "3xh84x"
					}),
					confirm_spam: () => s.fbt._("confirm spam", null, {
						hk: "2yAos0"
					}),
					created_collection: () => s.fbt._("created collection", null, {
						hk: "3vtmUM"
					}),
					css_on_cname: () => s.fbt._("toggle custom css from cname", null, {
						hk: "LTlcB"
					}),
					del_banner: () => s.fbt._("delete banner image", null, {
						hk: "2HRlu"
					}),
					del_header: () => s.fbt._("delete header image", null, {
						hk: "2k08m2"
					}),
					del_icon: () => s.fbt._("delete icon image", null, {
						hk: "43ObSQ"
					}),
					del_image: () => s.fbt._("delete image", null, {
						hk: "4ztzG0"
					}),
					deleted_collection: () => s.fbt._("deleted collection", null, {
						hk: "1T8FDF"
					}),
					description: () => s.fbt._("sidebar description", null, {
						hk: "3gBQBx"
					}),
					domain: () => s.fbt._("domain", null, {
						hk: "37Eg7w"
					}),
					edit_post_requirements: () => s.fbt._("edited post requirements", null, {
						hk: "CoMF6"
					}),
					edited_collection_description: () => s.fbt._("edited collection description", null, {
						hk: "ViGod"
					}),
					edited_collection_display_layout: () => s.fbt._("edited collection display layout", null, {
						hk: "xGExq"
					}),
					edited_collection_title: () => s.fbt._("edited collection title", null, {
						hk: "2x6aKQ"
					}),
					edited_event_body: () => s.fbt._("edited event post body", null, {
						hk: "2uwjvL"
					}),
					edited_event_times: () => s.fbt._("edited event post times", null, {
						hk: "3HNoa4"
					}),
					edited_event_title: () => s.fbt._("edited event post title", null, {
						hk: "4itZHA"
					}),
					edited_widget: () => s.fbt._("edited widget", null, {
						hk: "4eaNe6"
					}),
					enable_award: () => s.fbt._("enabled award", null, {
						hk: "3Ehki9"
					}),
					exclude_banned_modqueue: () => s.fbt._("toggle exclude banned users posts from modqueue", null, {
						hk: "j41F1"
					}),
					flair_clear_template: () => s.fbt._("clear flair template", null, {
						hk: "1IMRYi"
					}),
					flair_csv: () => s.fbt._("edit flair by csv", null, {
						hk: "480ZDT"
					}),
					flair_delete_template: () => s.fbt._("delete flair template", null, {
						hk: "bJ8f2"
					}),
					flair_add: () => s.fbt._("add flair", null, {
						hk: "281rsb"
					}),
					flair_delete: () => s.fbt._("delete flair", null, {
						hk: "2UkqAp"
					}),
					flair_edit: () => s.fbt._("edit flair", null, {
						hk: "3oxZYq"
					}),
					flair_enabled: () => s.fbt._("toggle flair enabled", null, {
						hk: "9WUzt"
					}),
					flair_position: () => s.fbt._("toggle user flair position", null, {
						hk: "4cwkk5"
					}),
					flair_self_enabled: () => s.fbt._("toggle user assigned flair enabled", null, {
						hk: "4q13ZR"
					}),
					flair_template: () => s.fbt._("add/edit flair templates", null, {
						hk: "NSSHD"
					}),
					free_form_reports: () => s.fbt._("toggle allow free form reports by users", null, {
						hk: "3MBfJn"
					}),
					header_title: () => s.fbt._("header title", null, {
						hk: "40Y0QO"
					}),
					ignore_reports: () => s.fbt._("ignore reports", null, {
						hk: "h7fov"
					}),
					lang: () => s.fbt._("language", null, {
						hk: "2xhrR8"
					}),
					link_flair_position: () => s.fbt._("toggle link flair position", null, {
						hk: "3j33wQ"
					}),
					link_flair_self_enabled: () => s.fbt._("toggle submitter assigned link flair enabled", null, {
						hk: "43EykN"
					}),
					link_type: () => s.fbt._("link type", null, {
						hk: "2FuNM"
					}),
					over_18: () => s.fbt._("toggle viewers must be over 18", null, {
						hk: "PRgas"
					}),
					permanent: () => s.fbt._("permanent ban", null, {
						hk: "3MeL5T"
					}),
					permission_moderator_invite: () => s.fbt._("set permissions on moderator invitation", null, {
						hk: "hA7I9"
					}),
					permission_moderator: () => s.fbt._("set permissions on moderator", null, {
						hk: "1yq3O2"
					}),
					public_description: () => s.fbt._("description", null, {
						hk: "JizZj"
					}),
					public_traffic: () => s.fbt._("toggle public traffic stats page", null, {
						hk: "qIXty"
					}),
					remove_self: () => s.fbt._("removed self", null, {
						hk: "I5wgr"
					}),
					remove: () => s.fbt._("remove", null, {
						hk: "mAXhe"
					}),
					removed_from_collection: () => s.fbt._("removed post from collection", null, {
						hk: "2dwuxr"
					}),
					removed_styling: () => s.fbt._("removed community styling", null, {
						hk: "1p7Io9"
					}),
					removed_widget: () => s.fbt._("removed widget", null, {
						hk: "43WUko"
					}),
					show_cname_sidebar: () => s.fbt._("toggle show sidebar from cname", null, {
						hk: "4nlv2A"
					}),
					show_media: () => s.fbt._("toggle show thumbnail images of content", null, {
						hk: "2XmVTJ"
					}),
					spam: () => s.fbt._("spam", null, {
						hk: "3usg93"
					}),
					stylesheet: () => s.fbt._("stylesheet", null, {
						hk: "1TOdUF"
					}),
					submit_link_label: () => s.fbt._("submit link button label", null, {
						hk: "4BdL19"
					}),
					submit_text_label: () => s.fbt._("submit text post button label", null, {
						hk: "4wc8qi"
					}),
					title: () => s.fbt._("title", null, {
						hk: "3tlhiX"
					}),
					type: () => s.fbt._("type", null, {
						hk: "14BQua"
					}),
					unspam: () => s.fbt._("unspam", null, {
						hk: "3SxHQ4"
					}),
					upload_image_banner: () => s.fbt._("upload image banner", null, {
						hk: "1ocFEe"
					}),
					upload_image_header: () => s.fbt._("upload image header", null, {
						hk: "3J6pke"
					}),
					upload_image_icon: () => s.fbt._("upload image icon", null, {
						hk: "4jr6Eg"
					}),
					upload_image: () => s.fbt._("upload image", null, {
						hk: "2KN9ig"
					}),
					copyright_removal: () => s.fbt._("copyright removal", null, {
						hk: "9vN6G"
					}),
					copyright_restoration: () => s.fbt._("copyright restoration", null, {
						hk: "35qFx5"
					})
				};
			var b, f;
			! function(e) {
				e.APPS = "Apps", e.AWARD = "Award", e.COMMENT = "Comment", e.FLAIR = "Flair", e.MULTIPLE = "Multiple", e.POST = "Post", e.REDDITOR = "Redditor", e.SETTINGS = "Settings", e.WIKI = "Wiki", e.COLLECTION = "Collection", e.EVENT = "Event", e.NOTE = "Note"
			}(b || (b = {})),
			function(e) {
				e.NONE = "none", e.POSITIVE = "positive", e.NEGATIVE = "negative"
			}(f || (f = {}));
			const h = "https://www.redditinc.com/policies/content-policy",
				g = "https://reddit.zendesk.com/hc/en-us/sections/360008810152-Copyright-Help-Center",
				v = {
					[o.h.Rule_1]: () => s.fbt._("Sitewide Rule 1", null, {
						hk: "3jk6cs"
					}),
					[o.h.Rule_2]: () => s.fbt._("Sitewide Rule 2", null, {
						hk: "4xT4lX"
					}),
					[o.h.Rule_3]: () => s.fbt._("Sitewide Rule 3", null, {
						hk: "3BFdeS"
					}),
					[o.h.Rule_4]: () => s.fbt._("Sitewide Rule 4", null, {
						hk: "4COU2Q"
					}),
					[o.h.Rule_5]: () => s.fbt._("Sitewide Rule 5", null, {
						hk: "QU0F5"
					}),
					[o.h.Rule_6]: () => s.fbt._("Sitewide Rule 6", null, {
						hk: "45NxT7"
					}),
					[o.h.Rule_7]: () => s.fbt._("Sitewide Rule 7", null, {
						hk: "1uFtlD"
					}),
					[o.h.Rule_8]: () => s.fbt._("Sitewide Rule 8", null, {
						hk: "4Gj2wR"
					}),
					[o.h.Dmca]: () => s.fbt._("Copyright Violation", null, {
						hk: "4ekSIy"
					}),
					[o.h.Unknown]: () => s.fbt._("Sitewide Rule", null, {
						hk: "16haBr"
					})
				}
		},
		"./src/reddit/constants/postCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			}));
			const s = "PostCreation-AddEventButton",
				r = 500,
				o = "PostCreation-CollectionEducationTooltip",
				i = "PostCreation-EventEducationTooltip",
				a = 300,
				d = a,
				c = "PostCreation-AddToCollectionButton"
		},
		"./src/reddit/constants/screenWidths.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = 480,
				r = 960,
				o = 1200
		},
		"./src/reddit/constants/shortcuts.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "d", (function() {
					return s
				})), n.d(t, "c", (function() {
					return r
				})), n.d(t, "b", (function() {
					return o
				})), n.d(t, "a", (function() {
					return i
				})),
				function(e) {
					e.CommentPage = "CommentPage", e.Global = "Global", e.Lightbox = "Lightbox", e.Listing = "Listing", e.Modqueue = "Modqueue", e.CommunityChat = "CommunityChat"
				}(s || (s = {})),
				function(e) {
					e.Close = "CLOSE", e.CollapseOrLoad = "COLLAPSE_OR_LOAD", e.Downvote = "DOWNVOTE", e.Expando = "EXPANDO", e.Hide = "HIDE", e.Konami = "KONAMI", e.NewPost = "NEW_POST", e.NextComment = "NEXT_COMMENT", e.NextPost = "NEXT_POST", e.OpenIndex = "OPEN_INDEX", e.OpenLightbox = "OPEN_LIGHTBOX", e.OpenLink = "OPEN_LINK", e.PrevComment = "PREV_COMMENT", e.PrevPost = "PREV_POST", e.Reply = "REPLY", e.Save = "SAVE", e.Upvote = "UPVOTE"
				}(r || (r = {}));
			const o = "SHORTCUT_FOCUSABLE_DIV",
				i = [9, 13, 32]
		},
		"./src/reddit/constants/zIndex.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			}));
			const s = 4,
				r = 60,
				o = 70,
				i = 90,
				a = 99,
				d = 100,
				c = 100
		},
		"./src/reddit/contexts/InsideOverlay.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const i = r.a.createContext(!1);

			function a(e) {
				function t(t) {
					return r.a.createElement(i.Consumer, null, n => r.a.createElement(e, o({}, t, {
						isOverlay: n
					})))
				}
				return t.displayName = `WithOverlay(${e.displayName||e.name})`, t
			}
		},
		"./src/reddit/contexts/NavbarExp.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = r.a.createContext(!1)
		},
		"./src/reddit/contexts/Post/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "b", (function() {
				return g
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/constants/posts.ts"),
				a = n("./src/reddit/hooks/useMemoShallowEqual.ts"),
				d = n("./src/reddit/hooks/useUserContext.ts"),
				c = n("./src/reddit/models/User/index.ts"),
				l = n("./src/reddit/selectors/posts.ts"),
				u = n("./src/reddit/selectors/subreddit.ts");

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const p = r.a.createContext(null);

			function b(e) {
				const t = Object(o.e)(t => Object(l.F)(t, {
						postId: e
					})),
					{
						currentUser: n
					} = Object(d.a)();
				let s = Object(o.e)(e => t ? Object(u.Q)(e, {
					identifier: t.belongsTo
				}) : null);
				s || (null == t ? void 0 : t.belongsTo.type) !== i.a.PROFILE || (s = t.profile);
				const r = (null == t ? void 0 : t.belongsTo.type) === i.a.SUBREDDIT ? s : null,
					m = !(!n || (null == t ? void 0 : t.author) !== Object(c.e)(n)),
					p = Object(o.e)(o => ({
						currentUser: n,
						imageGalleryCurrentItem: Object(l.i)(o, {
							postId: e
						}),
						isModerator: !(!r || !o.moderatingSubreddits[r.name]),
						post: t,
						postId: e,
						subreddit: r,
						subredditOrProfile: s,
						userIsOp: m
					}));
				return Object(a.a)(p)
			}

			function f(e) {
				const {
					postId: t,
					children: n
				} = e, s = b(t);
				return r.a.createElement(p.Provider, {
					value: s
				}, n)
			}

			function h(e) {
				const t = e.displayName || e.name;

				function n(n) {
					return r.a.createElement(p.Consumer, null, s => {
						if (!s) throw new Error(`No Post context for <${t}/>!`);
						return r.a.createElement(e, m({}, n, s))
					})
				}
				return n.displayName = `PostContext(${t})`, n
			}

			function g(e) {
				const t = e.displayName || e.name;

				function n(t) {
					const n = b(t.postId);
					return r.a.createElement(p.Provider, {
						value: n
					}, r.a.createElement(e, m({}, t, n)))
				}
				return n.displayName = `PostProvider(${t})`, n
			}
			t.c = p
		},
		"./src/reddit/contexts/Tooltip.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = r.a.createContext({})
		},
		"./src/reddit/contexts/User/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/hooks/useMemoShallowEqual.ts"),
				a = n("./src/reddit/reducers/user/prefs/index.ts"),
				d = n("./src/reddit/selectors/user.ts");

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const l = r.a.createContext({
				currentUser: null,
				modModeEnabled: !1,
				nightmodeEnabled: !1,
				prefs: a.a,
				isLoggedIn: !1
			});

			function u() {
				const e = Object(o.e)(e => ({
					currentUser: Object(d.m)(e),
					modModeEnabled: e.modModeEnabled,
					nightmodeEnabled: Object(d.fb)(e),
					prefs: e.user.prefs,
					isLoggedIn: Object(d.S)(e)
				}));
				return Object(i.a)(e)
			}

			function m(e) {
				return r.a.createElement(l.Provider, {
					value: u()
				}, e.children)
			}

			function p(e) {
				const t = e.displayName || e.name;

				function n(t) {
					return r.a.createElement(l.Consumer, null, n => r.a.createElement(e, c({}, t, n)))
				}
				return n.displayName = `UserContext(${t})`, n
			}
		},
		"./src/reddit/controls/Button/index.m.less": function(e, t, n) {
			e.exports = {
				Button: "_2iuoyPiKHN3kfOoeIQalDT",
				button: "_2iuoyPiKHN3kfOoeIQalDT",
				isFullWidth: "_34mIRHpFtnJ0Sk97S2Z3D9",
				xxsmallButtonStyles: "_1h6qKGhVsgNfytYFlo8m3f",
				Icon: "_1mvTX6krm3Q2d1CSyUm28s",
				icon: "_1mvTX6krm3Q2d1CSyUm28s",
				isLeft: "_1HHR_ND8U6x6YrIqKFeXZy",
				isRight: "_3tKmDp5VAtgWvabEmFkJ7T",
				xsmallButtonStyles: "_3uJP0daPEH2plzVEYyTdaH",
				xsmallBigPaddingButtonStyles: "UEPNkU0rd1-nvbkOcBatc",
				smallButtonStyles: "HNozj_dKjQZ59ZsfEegz8",
				mediumButtonStyles: "_3ukcnQySDskQwK_wB2iXYl",
				largeButtonStyles: "_1J4mN6_wNfCtSyMDUNGQqN",
				xlargeButtonStyles: "XpD6n11mOiKNg8ZKtvgVR",
				primary: "_10BQ7pjWbeYP63SAPNS8Ts",
				active: "_39a0Mt5b1i2joAqIaEHOWJ",
				redditStyle: "_2nelDm85zKKmuD94NequP0",
				DangerButtonColors: "_1t63zWyh9UUgsyQc6acROM",
				dangerButtonColors: "_1t63zWyh9UUgsyQc6acROM",
				GoldButtonColors: "_10UWrWSil1Xu6pdSaa_3-K",
				goldButtonColors: "_10UWrWSil1Xu6pdSaa_3-K",
				PremiumButtonColors: "q_unSaY23rpdd3lDvGZ-",
				premiumButtonColors: "q_unSaY23rpdd3lDvGZ-",
				secondary: "_2tU8R9NTqhvBrhoNAXWWcP",
				rplStyle: "_2Z-LWN_PrkTncEM_mPuEW5",
				tertiary: "_4Glnzr5LA7bNBGMWGW4pU",
				plain: "_3zbhtNO0bdck0oYbYRhjMC",
				isIconOnly: "_1tPpYVD73ugqp4k-VMFRki",
				isSquare: "_3ojSE1JW7jxNzUzZK8kt7m",
				ExtraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				extraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				InlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				inlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				ChatButton: "_13twe55MPRo1LqypxB-LJx",
				chatButton: "_13twe55MPRo1LqypxB-LJx",
				PlainLinkButton: "_2UhHcZFBOYxMULbf2p-skl",
				plainLinkButton: "_2UhHcZFBOYxMULbf2p-skl"
			}
		},
		"./src/reddit/controls/Button/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "m", (function() {
				return x
			})), n.d(t, "n", (function() {
				return E
			})), n.d(t, "l", (function() {
				return O
			})), n.d(t, "p", (function() {
				return C
			})), n.d(t, "q", (function() {
				return A
			})), n.d(t, "o", (function() {
				return y
			})), n.d(t, "s", (function() {
				return j
			})), n.d(t, "r", (function() {
				return I
			})), n.d(t, "f", (function() {
				return k
			})), n.d(t, "g", (function() {
				return _
			})), n.d(t, "k", (function() {
				return S
			})), n.d(t, "e", (function() {
				return w
			})), n.d(t, "i", (function() {
				return T
			})), n.d(t, "j", (function() {
				return P
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/InternalLink/index.tsx"),
				a = n("./src/reddit/controls/Button/index.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const l = {
				role: "button",
				tabIndex: 0
			};
			var u, m, p, b;
			! function(e) {
				e.XXS = "xxsmallButtonStyles", e.XS = "xsmallButtonStyles", e.XSP = "xsmallBigPaddingButtonStyles", e.S = "smallButtonStyles", e.M = "mediumButtonStyles", e.L = "largeButtonStyles", e.XL = "xlargeButtonStyles"
			}(u || (u = {})),
			function(e) {
				e.Primary = "primary", e.Secondary = "secondary", e.Tertiary = "tertiary", e.Plain = "plain", e.PlainLink = "plainLink"
			}(m || (m = {})),
			function(e) {
				e.L = "left", e.R = "right", e.C = "center"
			}(p || (p = {})),
			function(e) {
				e.Button = "button", e.ExternalLink = "external-link", e.InternalLink = "internal-link"
			}(b || (b = {}));
			const f = e => {
					const {
						"data-redditstyle": t,
						Icon: n,
						iconClassName: s,
						iconPosition: i = p.C,
						isFullWidth: a = !1,
						isSquare: f = !1,
						children: x,
						className: E,
						kind: O = b.Button,
						priority: C = m.Primary,
						redditStyle: A,
						rplStyle: y,
						size: j = u.S,
						text: I,
						textClassName: k,
						..._
					} = e, S = (e => {
						let {
							baseClassName: t,
							redditStyle: n,
							rplStyle: s,
							dataRedditStyle: r,
							Icon: i,
							isFullWidth: a,
							isSquare: c,
							priority: l,
							size: u,
							text: m
						} = e;
						return Object(o.a)(t, d.a.Button, l && d.a[l], u && d.a[u], {
							[d.a.isFullWidth]: a,
							[d.a.isIconOnly]: !!i && !m,
							[d.a.isSquare]: c,
							[d.a.redditStyle]: !(!n && !r),
							[d.a.rplStyle]: s
						})
					})({
						baseClassName: E,
						children: x,
						dataRedditStyle: t,
						Icon: n,
						isFullWidth: a,
						isSquare: f,
						priority: C,
						redditStyle: A,
						rplStyle: y,
						size: j,
						text: I
					}), w = (e => {
						let {
							children: t,
							text: n,
							Icon: s,
							iconClassName: i,
							iconPosition: a,
							priority: c,
							textClassName: l
						} = e;
						return !s && n ? r.a.createElement("span", {
							className: l
						}, n) : r.a.createElement(r.a.Fragment, null, s && (a === p.C || a === p.L) && r.a.createElement(s, {
							className: Object(o.a)(d.a.Icon, i, {
								[d.a.isLeft]: a === p.L
							}),
							isFilled: c === m.Primary
						}), n && r.a.createElement("span", {
							className: Object(o.a)(d.a.Text, l)
						}, n), t && t, s && a === p.R && r.a.createElement(s, {
							className: Object(o.a)(d.a.Icon, i, d.a.isRight),
							isFilled: c === m.Primary
						}))
					})({
						children: x,
						text: I,
						Icon: n,
						iconClassName: s,
						iconPosition: i,
						priority: C,
						textClassName: k
					});
					return O === b.InternalLink && (e => "to" in e)(_) ? r.a.createElement(h, c({}, l, _, {
						className: S
					}), w) : O === b.ExternalLink && (e => "href" in e)(_) ? r.a.createElement(g, c({}, l, _, {
						className: S
					}), w) : r.a.createElement(v, c({}, l, _, {
						className: S
					}), w)
				},
				h = e => r.a.createElement(i.default, e),
				g = e => r.a.createElement("a", e),
				v = e => r.a.createElement("button", e),
				x = e => r.a.createElement(f, c({
					kind: b.ExternalLink,
					priority: m.Primary
				}, e)),
				E = e => r.a.createElement(f, c({
					kind: b.InternalLink,
					priority: m.Primary
				}, e)),
				O = e => r.a.createElement(f, c({
					kind: b.Button,
					priority: m.Primary
				}, e)),
				C = e => r.a.createElement(f, c({
					kind: b.ExternalLink,
					priority: m.Secondary
				}, e)),
				A = e => r.a.createElement(f, c({
					kind: b.InternalLink,
					priority: m.Secondary
				}, e)),
				y = e => r.a.createElement(f, c({
					kind: b.Button,
					priority: m.Secondary
				}, e)),
				j = e => r.a.createElement(f, c({
					kind: b.InternalLink,
					priority: m.Plain
				}, e)),
				I = e => r.a.createElement(f, c({
					kind: b.Button,
					priority: m.Plain
				}, e)),
				k = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(f, c({
						kind: b.Button,
						priority: m.Primary,
						className: Object(o.a)(t, d.a.DangerButtonColors)
					}, n))
				},
				_ = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(f, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.GoldButtonColors)
					}, n))
				},
				S = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(f, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.PremiumButtonColors)
					}, n))
				},
				w = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(f, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.ChatButton)
					}, n))
				},
				T = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(f, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.InlineTextButton)
					}, n))
				},
				P = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(f, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.PlainLinkButton),
						priority: m.PlainLink
					}, n))
				};
			t.t = f
		},
		"./src/reddit/controls/Checkbox/index.m.less": function(e, t, n) {
			e.exports = {
				CheckboxIcon: "WYS1s7GjzJiaX4fu-xZOJ",
				checkboxIcon: "WYS1s7GjzJiaX4fu-xZOJ",
				redditStyle: "J_lIqJrnicKj84OhD29vQ",
				disabled: "n0Me225oxRbL3aLt7kQA8"
			}
		},
		"./src/reddit/controls/Checkbox/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/index.tsx"),
				a = n("./src/reddit/controls/Checkbox/index.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("button", {
				"aria-checked": e.isHalfCheckboxSelected ? "mixed" : e.isCheckboxSelected,
				className: e.className,
				onClick: t => {
					e.toggleCheckbox && (t.stopPropagation(), e.toggleCheckbox())
				},
				disabled: e.disabled
			}, r.a.createElement(i.a, {
				name: e.isHalfCheckboxSelected ? "checkbox_dismiss_fill" : e.isCheckboxSelected ? "checkbox_fill" : "checkbox",
				className: Object(o.a)({
					[d.a.redditStyle]: e.redditStyle,
					[d.a.disabled]: e.disabled
				}),
				style: e.checkBoxStyle
			}))
		},
		"./src/reddit/controls/CheckboxInput/index.m.less": function(e, t, n) {
			e.exports = {
				checkboxInput: "_2BPowd18EKTnfZFrj5kY3G",
				disabled: "_303iMx_S0pgrbpYhsYTV6K",
				checkboxSelected: "_2VtQ8EjxlJXdicVJhc73gQ"
			}
		},
		"./src/reddit/controls/CheckboxInput/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/constants/keycodes.ts"),
				a = n("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				d = n("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				c = n("./src/reddit/layout/row/Inline/index.tsx"),
				l = n("./src/reddit/controls/CheckboxInput/index.m.less"),
				u = n.n(l);
			t.a = e => {
				const t = e.onChange && !e.disabled ? t => {
						t.key !== i.b.Enter && t.key !== i.b.Space || e.onChange(!e.value)
					} : void 0,
					n = e.onChange && !e.disabled ? () => e.onChange(!e.value) : void 0;
				return r.a.createElement(c.a, {
					"aria-checked": !!e.value,
					"aria-disabled": e.disabled,
					"aria-labelledby": e.name,
					className: Object(o.a)(e.className, u.a.checkboxInput, e.disabled ? u.a.disabled : null),
					onClick: n,
					onKeyPress: t,
					role: "checkbox",
					tabIndex: 0
				}, r.a.createElement("input", {
					value: e.value ? e.value.toString() : "",
					type: "hidden"
				}), e.value ? r.a.createElement(d.a, {
					className: u.a.checkboxSelected
				}) : r.a.createElement(a.a, null), e.children)
			}
		},
		"./src/reddit/controls/CheckboxMenuItem/index.m.less": function(e, t, n) {
			e.exports = {
				checkboxIcon: "_3Ebr0mkLD0A7HiowzExNW-",
				checkboxMenuItem: "_2eawLPCtwzvTZhWKtaUgZQ",
				expandRight: "_34Odk7t6y-rCPxPcYJa4Nw",
				postCheckboxMenuItem: "_3LyKu57c-QkPvlFvAgWop5"
			}
		},
		"./src/reddit/controls/CheckboxMenuItem/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/index.tsx"),
				a = n("./src/reddit/layout/twoCol/ExpandRight/index.tsx"),
				d = n("./src/reddit/controls/CheckboxMenuItem/index.m.less"),
				c = n.n(d);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const u = e => r.a.createElement("div", {
					className: Object(o.a)(c.a.checkboxMenuItem, e.className),
					onClick: e.onClick
				}, r.a.createElement(a.a, {
					className: c.a.expandRight
				}, r.a.createElement(i.a, {
					name: "checkbox",
					isFilled: e.isSelected,
					className: c.a.checkboxIcon
				}), e.text)),
				m = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(u, l({
						className: Object(o.a)(c.a.postCheckboxMenuItem, t)
					}, n))
				}
		},
		"./src/reddit/controls/CheckboxWithLabel/index.m.less": function(e, t, n) {
			e.exports = {
				checkbox: "_21CrWSXdmd-ue61gDl6zRs",
				checkboxSelected: "_1xT_z2uw_7yX0esEUZVFwf",
				sharedIconStyles: "_1NVucoiiTLKJiKzRTPVKaW",
				checkboxLabel: "_1H6-wE3jxCdsIeXW5AMjj8",
				labelContent: "-kceiAQn0jpWOpu7qZRjD"
			}
		},
		"./src/reddit/controls/CheckboxWithLabel/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				a = n("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				d = n("./src/reddit/controls/CheckboxWithLabel/index.m.less"),
				c = n.n(d);
			t.a = e => r.a.createElement("button", {
				"aria-checked": e.isSelected,
				"aria-disabled": e.disabled,
				autoFocus: e.autoFocus,
				className: Object(o.a)(c.a.checkboxLabel, e.className),
				disabled: e.disabled,
				onClick: e.onClick,
				type: "button",
				role: "checkbox"
			}, r.a.createElement("span", {
				tabIndex: -1,
				className: c.a.labelContent
			}, e.isSelected ? r.a.createElement(a.a, {
				className: c.a.checkboxSelected
			}) : r.a.createElement(i.a, {
				className: c.a.checkbox
			}), e.text))
		},
		"./src/reddit/controls/ContentType/index.m.less": function(e, t, n) {
			e.exports = {
				contentTypeIcon: "_3CquMWJ6RMh8E9D-_84AtZ"
			}
		},
		"./src/reddit/controls/ContentType/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/constants/icons.ts"),
				a = n("./src/reddit/icons/fonts/index.tsx"),
				d = n("./src/reddit/constants/elementClassNames.ts"),
				c = n("./src/reddit/controls/ContentType/index.m.less"),
				l = n.n(c);
			const u = e => Object(o.a)(l.a.contentTypeIcon, e.className),
				m = {
					embed: i.a.embed,
					gallery: i.a.media_gallery,
					gifvideo: i.a.gif_post,
					image: i.a.image_post,
					meta: i.a.poll_post,
					rtjson: i.a.text_post,
					text: i.a.text_post,
					video: i.a.video_post,
					liveaudio: i.a.audio
				};

			function p(e) {
				const t = u(e),
					n = e.type && m[e.type] || i.a.link_post;
				return r.a.createElement(a.a, {
					name: n,
					className: Object(o.a)({
						[d.a]: n === i.a.link_post
					}, t)
				})
			}
		},
		"./src/reddit/controls/Downvote/index.m.less": function(e, t, n) {
			e.exports = {
				Downvote: "Q0BxYHtCOJ_rNSPJMU2Y7",
				downvote: "Q0BxYHtCOJ_rNSPJMU2Y7",
				mIsInteractive: "_2fe-KdD2OM0ciaiux-G1EL",
				mIsActive: "_3emIxnIscWEPB7o5LgU_rn",
				mIsVoteable: "_3yQIOwaIuF6gn8db96Gu7y"
			}
		},
		"./src/reddit/controls/Dropdown/Row.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return g
			}));
			var s = n("./node_modules/lodash/throttle.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/controls/UnstyledInternalLink/index.tsx"),
				c = n("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				l = n("./src/reddit/icons/svgs/Checkmark/index.tsx"),
				u = n("./src/reddit/layout/row/InlineButton/index.tsx"),
				m = n("./src/reddit/controls/Dropdown/index.m.less"),
				p = n.n(m),
				b = n("./src/reddit/controls/Dropdown/row.m.less"),
				f = n.n(b);

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			class g extends i.a.Component {
				constructor() {
					super(...arguments), this.handleMouseMove = r()(() => {
						const {
							props: e
						} = this;
						e.handleActivateRow && e.handleActivateRow(e.index)
					}, 500)
				}
				render() {
					const {
						props: e
					} = this, t = e.skipRoleAttr ? null : {
						role: "menuitem"
					}, n = Object(a.a)(f.a.iconWrapper, e.iconWrapperClassName);
					return e.href ? i.a.createElement(d.a, h({}, t, {
						id: e.id,
						className: e.className,
						onBlur: e.onBlur,
						onClick: e.onClick,
						onMouseDown: e.onMouseDown,
						onMouseMove: this.handleMouseMove,
						onKeyDown: e.onKeydown,
						rel: e.rel,
						to: e.href,
						disabled: e.disabled
					}), e.children && i.a.createElement("span", {
						className: n
					}, e.children), i.a.createElement("span", {
						className: Object(a.a)(f.a.text, e.textClassName)
					}, e.displayText)) : i.a.createElement(u.a, h({}, t, {
						id: e.id,
						className: e.className,
						disabled: e.disabled,
						onBlur: e.onBlur,
						onClick: e.onClick,
						onKeyDown: e.onKeydown,
						onMouseDown: e.onMouseDown,
						onMouseMove: r()(this.handleMouseMove, 500)
					}), e.children && (e.noIcon ? i.a.createElement("div", null, e.children) : i.a.createElement("span", {
						className: n
					}, e.children)), e.displayText && i.a.createElement("span", {
						className: Object(a.a)(f.a.text, e.textClassName)
					}, e.displayText), e.showSelectedCheckmark && e.isSelected && i.a.createElement(l.a, {
						className: f.a.checkmark
					}), e.showDropdownTriangle && i.a.createElement(c.a, {
						className: p.a.dropdownTriangle
					}))
				}
			}
			t.b = e => {
				let {
					className: t,
					...n
				} = e;
				const s = Object(a.a)(f.a.row, t, {
					[f.a.mIsInteractive]: !n.noHover,
					[f.a.mIsSelected]: n.isSelected,
					[f.a.topics]: n.isTopicsStyle
				});
				return i.a.createElement(g, h({
					className: s
				}, n))
			}
		},
		"./src/reddit/controls/Dropdown/index.m.less": function(e, t, n) {
			e.exports = {
				dropdownTriangle: "_1oxgVV3q47KbjEKqP5CHuM",
				dropdown: "_2uYY-KeuYHKiwl-9aF0UiL"
			}
		},
		"./src/reddit/controls/Dropdown/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/domUtils/index.ts"),
				a = n("./src/reddit/constants/zIndex.ts"),
				d = n("./src/reddit/controls/Dropdown/index.m.less"),
				c = n.n(d);
			class l extends r.a.Component {
				componentDidMount() {
					this.props.onDropdownMounted && this.props.onDropdownMounted(), this.props.noFocus || this.ref && this.ref.focus({
						preventScroll: this.props.isOverlay
					})
				}
				componentWillUnmount() {
					Object(i.a)(this.props.tooltipId)
				}
				render() {
					const e = this.props,
						t = {};
					return (e.isFixed || e.isOverlay) && (e.isFixed && (t.position = "fixed"), e.isOverlay && (t.zIndex = e.isFixed ? a.d + 1 : a.c)), r.a.createElement("div", {
						className: Object(o.a)(c.a.dropdown, e.className),
						id: this.props.id,
						ref: e => this.ref = e,
						role: "menu",
						style: {
							...t,
							...e.style
						},
						tabIndex: -1,
						onScroll: e.onScroll
					}, e.children)
				}
			}
		},
		"./src/reddit/controls/Dropdown/row.m.less": function(e, t, n) {
			e.exports = {
				iconWrapper: "pthKOcceozMuXLYrLlbL1",
				text: "_2-cXnP74241WI7fpcpfPmg",
				row: "_3LwUIE7yX7CZQKmD2L87vf",
				topics: "kR_ljR-F8vtc-ORj1uipB",
				checkmark: "_3Iua3qlR9JiTwjjk6NKye1",
				muteSubreddit: "ui39KJ4PwbdKkxvIBbLbV",
				modNotes: "sK8_uuNiAqPNlw-HoD2HG",
				mIsSelected: "_1IKtbRloF_LV1hPqMzP3MC",
				mIsInteractive: "_1oYEKCssGFjqxQ9jJMNj5G"
			}
		},
		"./src/reddit/controls/DropdownSelector/index.m.less": function(e, t, n) {
			e.exports = {
				dropdownMenu: "_1PLoXiZH4WKzHTfmYIt34X",
				selector: "apk_M-7ks6NcaiMN8cotM",
				selectorContent: "Ot99igbaJ5id3P1tw6wow",
				disabled: "FVIZ8GUq5tMGZlJ7y28ll",
				compact: "_1qaMsHCBrTmejbIUPjsRVI",
				caretDown: "_2i4dyr-iTBOmkZ4fL_M70P",
				topics: "qWs3cMcSjquK-OXl-9jH5",
				loadingIcon: "_3WxhmmhQ3cYt1J7mtfcoKG",
				menuItems: "_3ssvFhIB2HAXL261eWf7G0",
				isClosed: "_3sZzbLftdYnJNnJ7m7ImmO",
				menuOption: "_1Qm1phX3yfiJHnjgi_O_9V",
				buttonIcon: "_1J0h3Uv7HEaVZiJLcCUlQw"
			}
		},
		"./src/reddit/controls/DropdownSelector/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/controls/DropdownSelector/index.m.less"),
				i = n.n(o),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/controls/Dropdown/Row.tsx"),
				c = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				l = n("./src/reddit/icons/fonts/index.tsx");
			const u = e => {
				e.preventDefault()
			};
			class m extends r.a.Component {
				constructor() {
					super(...arguments), this.dropdownButton = r.a.createRef(), this.menuItems = r.a.createRef(), this.containerRef = r.a.createRef(), this.state = {
						isOpen: !1
					}, this.handleDocumentClick = e => {
						this.containerRef && this.containerRef.current && (this.containerRef.current.contains(e.target) || this.setState({
							isOpen: !1
						}))
					}, this.onSelectOption = (e, t, n) => {
						const {
							onSelect: s
						} = this.props;
						e.preventDefault(), e.stopPropagation(), e.nativeEvent.stopPropagation(), s(t), n && this.dropdownButton.current && this.dropdownButton.current.focus(), this.setState({
							isOpen: !1
						})
					}, this.onOptionClick = (e, t) => {
						this.onSelectOption(e, t)
					}, this.handleDropdownClick = e => {
						e.preventDefault(), e.stopPropagation(), this.props.onOpen && this.props.onOpen(), this.setState({
							isOpen: !this.state.isOpen
						})
					}, this.handleDropdownBlur = e => {
						let t = !1;
						if (e.relatedTarget === this.dropdownButton.current) t = !0;
						else {
							if (!this.menuItems.current) return;
							const n = this.menuItems.current.getElementsByClassName(i.a.menuOption);
							for (let s = 0; s < n.length; s++) e.relatedTarget === n[s] && (t = !0)
						}
						this.setState({
							isOpen: t
						})
					}, this.handleDropdownKeyDown = e => {
						if (!this.state.isOpen && [40, 32, 13].includes(e.keyCode)) return e.preventDefault(), void this.setState({
							isOpen: !0
						}, this.focusOnFirstOption);
						40 === e.keyCode && (e.preventDefault(), this.focusOnFirstOption()), 27 === e.keyCode && this.state.isOpen && (e.stopPropagation(), e.nativeEvent.stopPropagation(), e.nativeEvent.stopImmediatePropagation(), this.setState({
							isOpen: !1
						}))
					}, this.handleOptionKeyDown = (e, t) => {
						if (32 === e.keyCode || 13 === e.keyCode) this.onSelectOption(e, t, !0);
						else if (38 === e.keyCode || 40 === e.keyCode) {
							if (e.preventDefault(), !this.menuItems.current) return;
							const t = this.menuItems.current.getElementsByClassName(i.a.menuOption);
							for (let n = 0; n < t.length; n++) t[n] === e.target && (38 === e.keyCode && n > 0 && t[n - 1].focus(), 40 === e.keyCode && n < t.length - 1 && t[n + 1].focus())
						}
					}
				}
				componentDidMount() {
					document.body.addEventListener("click", this.handleDocumentClick, !1)
				}
				componentWillUnmount() {
					document.body.removeEventListener("click", this.handleDocumentClick, !1)
				}
				focusOnFirstOption() {
					if (!this.menuItems.current) return;
					const e = this.menuItems.current.getElementsByClassName(i.a.menuOption);
					e.length && e[0].focus()
				}
				getDropdownMenuItems() {
					const {
						options: e,
						showSelectedCheckmark: t,
						isTopicsStyle: n,
						menuOptionClassName: s
					} = this.props;
					return e.map((e, o) => r.a.createElement(d.b, {
						key: o + e.displayText,
						className: Object(a.a)(i.a.menuOption, s, {
							[i.a.topics]: n
						}),
						noIcon: Boolean(e.icon),
						onKeydown: t => this.handleOptionKeyDown(t, e),
						onMouseDown: t => this.onOptionClick(t, e),
						onBlur: this.handleDropdownBlur,
						showSelectedCheckmark: t,
						isSelected: void 0 !== e.isSelected ? e.isSelected : void 0,
						isTopicsStyle: n
					}, e.icon && e.icon, e.displayText))
				}
				render() {
					const {
						buttonClassName: e,
						className: t,
						displayText: n,
						isCompactStyle: s,
						isTopicsStyle: o,
						menuItemsClassName: d,
						name: m,
						isSaving: p,
						buttonIcon: b,
						disabled: f
					} = this.props, {
						isOpen: h
					} = this.state;
					return r.a.createElement("div", {
						ref: this.containerRef,
						id: this.props.id,
						className: Object(a.a)(i.a.dropdownMenu, t, {
							[i.a.topics]: o
						})
					}, r.a.createElement("button", {
						onClick: f ? void 0 : this.handleDropdownClick,
						className: Object(a.a)(e, i.a.selector, {
							[i.a.compact]: s
						}, {
							[i.a.topics]: o
						}, {
							[i.a.disabled]: f
						}),
						name: m,
						role: "menu",
						ref: this.dropdownButton,
						onBlur: f ? void 0 : this.handleDropdownBlur,
						onKeyDown: f ? void 0 : this.handleDropdownKeyDown
					}, r.a.createElement("span", {
						className: i.a.selectorContent,
						tabIndex: -1
					}, b && r.a.createElement("span", {
						className: i.a.buttonIcon
					}, b), n), f ? null : p ? r.a.createElement(c.a, {
						sizePx: 8,
						className: i.a.loadingIcon
					}) : r.a.createElement(l.a, {
						name: "caret_down"
					})), r.a.createElement("div", {
						className: Object(a.a)(i.a.menuItems, d, {
							[i.a.topics]: o,
							[i.a.isClosed]: !h
						}),
						onMouseDown: u,
						ref: this.menuItems
					}, !f && h && this.getDropdownMenuItems()))
				}
			}
			t.b = m
		},
		"./src/reddit/controls/ErrorText/SeeAllTextModal/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_2AfJEqW9tv4b_kolKEuS9K",
				titleRow: "p4QfstubN5cRxd-gy8gFH",
				detailsContainer: "_2V3KEAhexNh-mP3TbrVClC",
				buttonRow: "_1fcbQFwN65ik28DNmWnpX4",
				confirmButton: "zcMEJWBL7q-mYGOPSpjN-"
			}
		},
		"./src/reddit/controls/ErrorText/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_2hGJP-9xfXBXd0wqhBLHhY",
				description: "_3h_9YwxjuOr77VhScPrjCI",
				moreText: "_1Y0BrhDgcSTeSYvmSPYepI"
			}
		},
		"./src/reddit/controls/ErrorText/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return E
			})), n.d(t, "c", (function() {
				return O
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/uniqueId.js"),
				o = n.n(r),
				i = n("./node_modules/raf/index.js"),
				a = n.n(i),
				d = n("./node_modules/react/index.js"),
				c = n.n(d),
				l = n("./src/lib/classNames/index.ts"),
				u = n("./src/higherOrderComponents/asModal/index.tsx"),
				m = n("./src/reddit/controls/Button/index.tsx"),
				p = n("./src/reddit/layout/row/Inline/index.tsx"),
				b = n("./src/reddit/controls/ErrorText/SeeAllTextModal/index.m.less"),
				f = n.n(b);
			var h = Object(u.a)(e => {
					const {
						children: t,
						title: n
					} = e;
					return c.a.createElement("div", {
						className: f.a.wrapper
					}, c.a.createElement(p.a, {
						className: f.a.titleRow
					}, n), c.a.createElement("div", {
						className: f.a.detailsContainer
					}, t), c.a.createElement(p.a, {
						className: f.a.buttonRow
					}, c.a.createElement(m.l, {
						className: f.a.confirmButton,
						onClick: e.onConfirmed
					}, s.fbt._("Ok", null, {
						hk: "2Giu9U"
					}))))
				}),
				g = n("./src/reddit/controls/ErrorText/index.m.less"),
				v = n.n(g);
			class x extends c.a.Component {
				constructor(e) {
					super(e), this.spanRef = c.a.createRef(), this.toggleModal = () => {
						this.setState({
							isModalOpen: !this.state.isModalOpen
						})
					}, this.state = {
						textHasOverflowed: !1,
						modalId: `ErrorTextModal--${o()()}`,
						isModalOpen: !1
					}
				}
				componentDidMount() {
					this.calcTextDidOverflow()
				}
				componentDidUpdate() {
					this.calcTextDidOverflow()
				}
				calcTextDidOverflow() {
					a()(() => {
						const e = this.spanRef.current;
						if (!e) return;
						const t = e.scrollWidth > e.clientWidth;
						this.setState(e => e.textHasOverflowed !== t ? {
							textHasOverflowed: t
						} : null)
					})
				}
				render() {
					const {
						children: e,
						className: t,
						errorModalBody: n,
						errorModalTitle: r = s.fbt._("Error", null, {
							hk: "2nPF4G"
						}),
						moreText: o = s.fbt._("More", null, {
							hk: "1bCAQ0"
						})
					} = this.props, {
						textHasOverflowed: i,
						isModalOpen: a
					} = this.state;
					return c.a.createElement("div", {
						className: Object(l.a)(v.a.wrapper, t)
					}, c.a.createElement("span", {
						className: v.a.description,
						ref: this.spanRef
					}, e), i && c.a.createElement("span", {
						className: v.a.moreText,
						onClick: this.toggleModal
					}, o), a && c.a.createElement(h, {
						onConfirmed: this.toggleModal,
						title: r
					}, n || e))
				}
			}
			const E = e => {
					const {
						className: t,
						errorClassName: n,
						errorModalTitle: s,
						fallbackMessage: r,
						messages: o = []
					} = e, i = o.length ? o : r ? [r] : [];
					return i.length ? c.a.createElement("div", {
						className: t
					}, i.map((e, t) => c.a.createElement(x, {
						className: n,
						errorModalTitle: s,
						key: t
					}, e))) : null
				},
				O = e => c.a.createElement(E, {
					fallbackMessage: s.fbt._("Something went wrong", null, {
						hk: "Cw1BT"
					}),
					messages: e
				});
			t.b = x
		},
		"./src/reddit/controls/FileDrop/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/flow.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-dnd/lib/index.js"),
				d = n("./node_modules/react-dnd-html5-backend/lib/index.js"),
				c = n("./src/reddit/helpers/dragDropContext/index.ts");
			const l = d.NativeTypes.FILE,
				u = r()(Object(a.DropTarget)(l, {
					drop: (e, t) => {
						if (t && t.didDrop() || !t) return;
						const n = t.getItem();
						n.files && e.onDrop(n.files)
					}
				}, (e, t) => ({
					connectDropTarget: e.dropTarget(),
					isOver: t.isOver(),
					canDrop: t.canDrop()
				})), c.a);
			class m extends i.a.Component {
				render() {
					return this.props.connectDropTarget ? this.props.connectDropTarget(i.a.createElement("div", {
						className: this.props.className
					}, this.props.render(this.props.isOver, this.props.canDrop))) : null
				}
			}
			t.a = u(m)
		},
		"./src/reddit/controls/FormFields/index.m.less": function(e, t, n) {
			e.exports = {
				input: "_3CWuMoFPzdbJCxYJVmEw00",
				label: "J4DegnzzIY1-C2PFzYkrA",
				mHasValue: "t09kxBqaSw0Is_F5sUdQ1",
				inputWrapper: "_3TCLGRXxb1PXK-_sziBD2q",
				mIsInvalid: "_1pMjk4nL9CObVggXCSuELu",
				inputMovingLabelWrapper: "_2-meAmTwsZSCNYrpbEy7BX",
				mIsRedditStyle: "_3ONm7CsU4BtjX9jO5WYv2X",
				trash: "_2YUtyje1Y5rUty_3zgPOGM",
				trashContainer: "_2wjFyjW1rwWs4WFcSc7xNl",
				plus: "_3o11DwChSYlSiDT6FYqOIE",
				addValueButton: "_1Dm7EZTfDne90O5xANs501",
				multiInputWrapper: "_3CjWcr8XyX0xN32ADxPngu",
				errorText: "_2JNX-DiHbrfxhFYgkcBNaK"
			}
		},
		"./src/reddit/controls/FormFields/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "d", (function() {
				return x
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/controls/ErrorText/index.tsx"),
				d = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				c = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				l = n("./src/reddit/controls/FormFields/index.m.less"),
				u = n.n(l);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const p = i.a.input("input", u.a),
				b = e => {
					"LABEL" === e.target.tagName && (e.target.parentElement.firstElementChild.focus(), e.stopPropagation())
				},
				f = e => {
					let {
						label: t,
						children: n,
						inputRef: s,
						className: i,
						isInvalid: a,
						...d
					} = e;
					const c = void 0 !== d.value && "" !== d.value;
					return r.a.createElement("div", {
						className: Object(o.a)(u.a.inputWrapper, i, {
							[u.a.mIsInvalid]: a
						}),
						onClick: b
					}, r.a.createElement(p, m({
						"aria-invalid": a,
						innerRef: s
					}, d)), t && r.a.createElement("label", {
						className: Object(o.a)(u.a.label, {
							[u.a.mHasValue]: c
						})
					}, t), n)
				},
				h = e => {
					let {
						label: t,
						children: n,
						inputRef: s,
						isInvalid: i,
						className: a,
						redditStyle: d,
						...c
					} = e;
					const l = void 0 !== c.value && "" !== c.value;
					return r.a.createElement("div", {
						className: Object(o.a)(u.a.inputMovingLabelWrapper, a, {
							[u.a.mIsInvalid]: i,
							[u.a.mIsRedditStyle]: d
						}),
						onClick: b
					}, r.a.createElement(p, m({
						innerRef: s
					}, c)), t && r.a.createElement("label", {
						className: Object(o.a)(u.a.label, {
							[u.a.mHasValue]: l
						})
					}, t), n)
				},
				g = e => r.a.createElement("div", {
					className: Object(o.a)(u.a.addValueButton, e.className),
					onClick: e.onClick
				}, e.text, " ", r.a.createElement(d.a, {
					className: u.a.plus
				}));
			var v;
			! function(e) {
				e[e.ADD = 0] = "ADD", e[e.REMOVE = 1] = "REMOVE"
			}(v || (v = {}));
			class x extends r.a.Component {
				constructor() {
					super(...arguments), this.state = {
						addingNewInputs: !1
					}, this.addValue = () => {
						const e = this.props.values.slice();
						this.props.buttonOnTop ? e.unshift("") : e.push(""), this.props.onChange(e), this.props.onEvent && this.props.onEvent({
							action: v.ADD
						})
					}, this.updateValue = (e, t) => {
						const n = this.props.values.slice();
						n[t] = e.target.value, this.props.onChange(n)
					}, this.removeValue = e => {
						const t = this.props.values.slice(),
							n = t[e];
						t.splice(e, 1), this.props.onChange(t), this.props.onEvent && this.props.onEvent({
							action: v.REMOVE,
							value: n,
							index: e
						})
					}
				}
				componentWillReceiveProps(e) {
					e.values.length > this.props.values.length && this.setState({
						addingNewInputs: !0
					})
				}
				componentDidUpdate() {
					this.focusedInput && this.state.addingNewInputs && (this.focusedInput.focus(), this.setState({
						addingNewInputs: !1
					}))
				}
				setInputRef(e, t) {
					this.state.addingNewInputs && (!this.props.buttonOnTop || this.props.buttonOnTop && !t) && (this.focusedInput = e)
				}
				renderFields() {
					const {
						values: e,
						disabled: t,
						label: n,
						placeholder: s,
						errors: o = []
					} = this.props;
					return e.map((e, i) => r.a.createElement(f, {
						inputRef: e => this.setInputRef(e, i),
						isInvalid: !!o[i],
						disabled: t,
						type: "text",
						label: n,
						onChange: e => this.updateValue(e, i),
						placeholder: s,
						value: e,
						style: {
							paddingRight: "36px"
						}
					}, r.a.createElement("div", {
						className: u.a.trashContainer,
						onClick: () => this.removeValue(i)
					}, r.a.createElement(c.b, {
						className: u.a.trash
					})), !!o[i] && r.a.createElement(a.b, {
						className: u.a.errorText
					}, o[i])))
				}
				render() {
					const {
						className: e,
						buttonOnTop: t,
						values: n,
						maxLength: s,
						addValueText: i,
						disabled: a
					} = this.props;
					this.focusedInput = null;
					const d = !(!!s && n.length >= s) && !a;
					return r.a.createElement("div", {
						className: Object(o.a)(u.a.multiInputWrapper, e)
					}, t && d && r.a.createElement(g, {
						onClick: this.addValue,
						text: i
					}), this.renderFields(), !t && d && r.a.createElement(g, {
						onClick: this.addValue,
						text: i
					}))
				}
			}
		},
		"./src/reddit/controls/ImageDisplay/index.m.less": function(e, t, n) {
			e.exports = {
				imageDisplay: "_1OSym2TYADlQNpSDWNxtjB"
			}
		},
		"./src/reddit/controls/ImageDisplay/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/ImageDisplay/index.m.less"),
				a = n.n(i);
			t.a = e => {
				let {
					backgroundImage: t,
					children: n,
					className: s
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(a.a.imageDisplay, s),
					style: {
						backgroundImage: `url('${t}')`
					},
					children: n
				})
			}
		},
		"./src/reddit/controls/ImageInput/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			class o extends r.a.Component {
				constructor(e) {
					super(e), this.onFileInput = e => {
						const t = e.currentTarget.files,
							n = this.props.multiple ? [...t] : t[0];
						this.props.onChange(n), this.setState(() => ({
							value: n
						}))
					}, this.state = {
						value: e.value || ""
					}
				}
				static getDerivedStateFromProps(e, t) {
					return {
						value: t.value || e.value || ""
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = "string" == typeof t.value ? t.value : "", s = "object" == typeof t.value ? t.value : null, o = n || s;
					return r.a.createElement("div", {
						className: e.className
					}, n && r.a.createElement("input", {
						id: e.inputId,
						ref: e.inputRef,
						name: e.name,
						readOnly: !0,
						type: "text",
						value: n,
						tabIndex: e.tabIndex
					}), (!o || e.multiple || void 0 !== e.isPending && !e.isPending) && r.a.createElement("input", {
						id: e.inputId,
						ref: e.inputRef,
						name: e.name,
						type: "file",
						onChange: this.onFileInput,
						accept: "image/x-png,image/jpeg",
						multiple: e.multiple || !1,
						tabIndex: e.tabIndex
					}))
				}
			}
		},
		"./src/reddit/controls/Input/ModalInput.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/constants/keycodes.ts"),
				c = n("./src/reddit/controls/Input/index.m.less"),
				l = n.n(c);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			class m extends r.a.Component {
				constructor() {
					super(...arguments), this.handleKeyDown = e => {
						let {
							keyCode: t
						} = e;
						t === d.a.Escape && this.props.closeModal()
					}
				}
				render() {
					const {
						className: e,
						closeModal: t,
						...n
					} = this.props;
					return r.a.createElement("input", u({
						className: Object(i.a)(l.a.input, e),
						onKeyDown: this.handleKeyDown
					}, n))
				}
			}
			t.a = Object(o.b)(null, {
				closeModal: a.f
			})(m)
		},
		"./src/reddit/controls/Input/index.m.less": function(e, t, n) {
			e.exports = {
				input: "_3eoXtlBWKbkFYoOHUIcIgK"
			}
		},
		"./src/reddit/controls/Input/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/Input/index.m.less"),
				o = n.n(r);
			t.a = s.a.input("input", o.a)
		},
		"./src/reddit/controls/InternalLink/index.m.less": function(e, t, n) {
			e.exports = {
				disabledLink: "_1tQt2CUWT3M7NNSMoh_o_4"
			}
		},
		"./src/reddit/controls/InternalLink/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "default", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/helpers/path/index.ts"),
				d = n("./src/reddit/controls/InternalLink/index.m.less"),
				c = n.n(d);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function u(e) {
				let {
					children: t,
					className: n,
					disabled: s,
					replace: d,
					to: u,
					...m
				} = e;
				return s ? r.a.createElement("span", {
					className: Object(i.a)(c.a.disabledLink, n)
				}, t) : ("string" == typeof u && (u = Object(a.b)(u)), r.a.createElement(o.a, l({
					className: n,
					to: u
				}, m), t))
			}
		},
		"./src/reddit/controls/InvisibleScreenReaderText/index.m.less": function(e, t, n) {
			e.exports = {
				invisibleText: "_1RIl585IYPW6cmNXwgRz0J"
			}
		},
		"./src/reddit/controls/InvisibleScreenReaderText/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/InvisibleScreenReaderText/index.m.less"),
				o = n.n(r);
			t.a = s.a.span("invisibleText", o.a)
		},
		"./src/reddit/controls/LoadingIcon/index.m.less": function(e, t, n) {
			e.exports = {
				loadingIcon: "_3LwT7hgGcSjmJ7ng7drAuq",
				spin: "ibDwUVR1CAykturOgqOS5",
				mCentered: "_2qr28EeyPvBWAsPKl-KuWN"
			}
		},
		"./src/reddit/controls/LoadingIcon/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/LoadingIcon/index.m.less"),
				a = n.n(i);
			t.a = e => {
				let {
					center: t,
					className: n,
					sizePx: s = 10
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(a.a.loadingIcon, n, {
						[a.a.mCentered]: t
					}),
					style: {
						"--sizePx": `${s}px`
					},
					"data-testid": "LoadingIcon"
				})
			}
		},
		"./src/reddit/controls/MetaData/index.m.less": function(e, t, n) {
			e.exports = {
				metaText: "_2ETuFsVzMBxiHia6HfJCTQ"
			}
		},
		"./src/reddit/controls/MetaData/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/lib/prettyPrintNumber/index.ts"),
				d = (n("./src/lib/timeAgo/index.ts"), n("./src/reddit/controls/MetaData/index.m.less")),
				c = n.n(d);
			const l = i.a.span("metaText", c.a),
				u = e => o.a.createElement(l, e, "  "),
				m = e => {
					let {
						isScoreHidden: t,
						score: n,
						useUpvotes: r,
						...i
					} = e;
					const d = Object(a.b)(n),
						c = s.fbt._({
							"*": "{number} upvotes",
							_1: "1 upvote"
						}, [s.fbt._plural(n, "number", d)], {
							hk: "2L3T21"
						}),
						u = t ? s.fbt._("Score hidden", null, {
							hk: "SDk6B"
						}) : r ? c : s.fbt._({
							"*": "{number} points",
							_1: "1 point"
						}, [s.fbt._plural(n, "number", d)], {
							hk: "gf67v"
						});
					return o.a.createElement(l, i, u)
				},
				p = e => o.a.createElement(l, null, s.fbt._({
					"*": "{number} comments",
					_1: "1 comment"
				}, [s.fbt._plural(e, "number", Object(a.b)(e))], {
					hk: "3bVMk9"
				}))
		},
		"./src/reddit/controls/OutboundLink/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return k
			})), n.d(t, "c", (function() {
				return _
			}));
			var s = n("./node_modules/lodash/omit.js"),
				r = n.n(s),
				o = n("./node_modules/query-string/index.js"),
				i = n.n(o),
				a = n("./node_modules/react/index.js"),
				d = n.n(a),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/addQueryParams/index.ts");
			var m = (e, t) => t ? Object(u.a)(e, {
				user_id: t
			}) : e;
			var p = n("./src/lib/opener/index.ts"),
				b = n("./src/lib/redditId/index.ts"),
				f = n("./src/reddit/actions/post.ts"),
				h = n("./src/reddit/constants/adEvents.ts"),
				g = n("./src/reddit/helpers/getVendorMetadata.ts"),
				v = n("./src/reddit/helpers/trackers/ads.ts"),
				x = n("./src/reddit/hooks/useOutboundClickTracking.ts"),
				E = n("./src/reddit/selectors/posts.ts"),
				O = n("./src/reddit/selectors/telemetry.ts"),
				C = n("./src/reddit/selectors/user.ts");

			function A() {
				return (A = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const y = Object(l.a)(C.c, C.m, (e, t) => {
					let {
						isSponsored: n,
						postId: s
					} = t;
					return n && s ? Object(E.b)(e, s) : null
				}, E.F, O.d, (e, t, n, s, r) => ({
					allowClickTracking: e,
					basePixelMetadata: n,
					userId: t ? Object(b.a)(t.id) : null,
					post: s,
					pageType: r.pageType
				})),
				j = Object(c.b)(y, e => ({
					fireAdPixelsOfType: (t, n) => e(Object(f.y)(t, n))
				})),
				I = (e, t, n, s) => {
					const r = t.outboundUrlExpiration && t.outboundUrlExpiration > Date.now();
					s && t.outboundUrl && r && (e.href = m(t.outboundUrl, n), e.href = function(e) {
						return Object(u.a)(e, {
							web_redirect: "true"
						})
					}(e.href))
				},
				k = (e, t, n) => {
					let s, r = null;
					if (e && t && /^(http|https):\/\/([a-z]+\.)?reddit.com/.test(n)) {
						r = Object(g.a)(e, t, h.a.Click);
						const {
							url: o,
							query: a
						} = i.a.parseUrl(n);
						s = i.a.stringifyUrl({
							url: o,
							query: {
								...a,
								...r
							}
						})
					} else s = n;
					return {
						url: s,
						metadata: r
					}
				},
				_ = (e, t, n) => {
					const s = k(t, n, e.href);
					return e.href = s.url, s.metadata
				},
				S = e => {
					let {
						isSponsored: t,
						source: n
					} = e;
					return !!(t && (null == n ? void 0 : n.outboundUrl))
				},
				w = j(e => {
					const t = Object(a.useRef)(null),
						n = Object(x.a)(),
						{
							allowClickTracking: s,
							basePixelMetadata: o,
							commentId: i,
							fireAdPixelsOfType: c,
							href: l,
							isSponsored: u,
							pageType: m,
							post: b,
							postId: f,
							source: g,
							sourceElement: E,
							userId: O
						} = e;
					let C = r()(e, ["allowClickTracking", "basePixelMetadata", "fireAdPixelsOfType", "isSponsored", "postId", "post", "commentId", "source", "sourceElement", "userId", "pageType"]);
					const y = g && g.outboundUrl && u ? g.outboundUrl : l;
					return C = {
						...C,
						href: y,
						rel: u ? p.b : p.a,
						target: p.d.BLANK
					}, !g || (e => {
						const {
							outboundUrlCreated: t,
							outboundUrlReceived: n
						} = e;
						return !(!t || !n) && (t > n + 3e5 || t < n - 36e5)
					})(g) ? d.a.createElement("a", A({}, C, {
						onClick: () => n(l, E, i, f)
					})) : d.a.createElement("a", A({}, C, {
						onMouseDown: n => {
							if (!S(e)) return !(1 !== n.button && 2 !== n.button && !n.ctrlKey) || void I(n.currentTarget, g, O, s);
							t.current = _(n.currentTarget, f, o)
						},
						onClick: () => {
							b && (S(e) && Object(v.a)(b, m), c(b, h.a.Click), n(l, E, i, f))
						},
						onMouseLeave: e => {
							u || ((e, t) => {
								e.href = t
							})(e.currentTarget, y)
						},
						onTouchStart: e => I(e.currentTarget, g, O, s),
						"data-testid": "outbound-link"
					}))
				});
			t.b = w
		},
		"./src/reddit/controls/OutboundLink/styled.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/constants/elementClassNames.ts"),
				o = n("./src/reddit/controls/OutboundLink/index.tsx"),
				i = n("./src/reddit/controls/OutboundLink/styles.m.less"),
				a = n.n(i);
			t.a = s.a.wrapped(o.b, "styledOutboundLink", {
				styledOutboundLink: `${a.a.styledOutboundLink} ${r.l}`
			})
		},
		"./src/reddit/controls/OutboundLink/styles.m.less": function(e, t, n) {
			e.exports = {
				styledOutboundLink: "_13svhQIUZqD9PVzFcLwOKT"
			}
		},
		"./src/reddit/controls/RadioInput/RadioOption/index.m.less": function(e, t, n) {
			e.exports = {
				radioOption: "_2e6fJknJ4noSygWYov8-F1",
				radioOff: "_1lzSnSABNXX12WerTnwqI3",
				radioOn: "_3PYsg_uRJ6AGptv-hi7kqu"
			}
		},
		"./src/reddit/controls/RadioInput/RadioOption/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/constants/keycodes.ts"),
				a = n("./src/reddit/icons/svgs/RadioOff/index.tsx"),
				d = n("./src/reddit/icons/svgs/RadioOn/index.tsx"),
				c = n("./src/reddit/layout/row/Inline/index.tsx"),
				l = n("./src/reddit/controls/RadioInput/RadioOption/index.m.less"),
				u = n.n(l);
			class m extends r.a.Component {
				constructor() {
					super(...arguments), this.ref = null, this.onKeyPress = e => {
						const {
							props: t
						} = this;
						t.disabled || e.key !== i.b.Enter && e.key !== i.b.Space || (t.onClick && t.onClick(t.value), e.preventDefault())
					}
				}
				componentDidUpdate(e) {
					this.props.selected && !e.selected && this.ref && this.ref.focus()
				}
				render() {
					const {
						props: e
					} = this;
					return e.hidden ? null : r.a.createElement(c.a, {
						"aria-checked": e.selected,
						className: Object(o.a)(e.className, u.a.radioOption),
						innerRef: e => this.ref = e,
						onClick: e.disabled ? void 0 : e.onClick,
						onKeyPress: this.onKeyPress,
						role: "radio",
						tabIndex: e.tabIndex
					}, e.showButton && (e.selected ? r.a.createElement(d.a, {
						className: u.a.radioOn,
						role: "presentation"
					}) : r.a.createElement(a.a, {
						className: u.a.radioOff,
						role: "presentation"
					})), e.children)
				}
			}
			t.a = m
		},
		"./src/reddit/controls/RadioInput/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/constants/keycodes.ts");
			class i extends r.a.Component {
				constructor(e) {
					super(e), this.handleClick = e => {
						const {
							disabled: t,
							onChange: n
						} = this.props;
						t || this.state.value !== e && (n(e), this.setState({
							value: e
						}))
					}, this.getValues = () => {
						const e = [];
						return r.a.Children.forEach(this.props.children, t => {
							t.props.hidden || t.props.disabled || e.push(t.props.value)
						}), e
					}, this.onKeyDown = e => {
						const {
							disabled: t,
							onChange: n
						} = this.props, {
							value: s
						} = this.state;
						if (t) return;
						const r = e.key === o.b.ArrowUp,
							i = e.key === o.b.ArrowDown;
						if (r || i) {
							const t = this.getValues();
							if (!t.length) return;
							const o = s ? t.indexOf(s) : 0,
								i = t[((r ? o - 1 : o + 1) + t.length) % t.length];
							n(i), this.setState({
								value: i
							}), e.preventDefault()
						}
					}, this.state = {
						value: e.value || null
					}
				}
				UNSAFE_componentWillReceiveProps(e) {
					e.value !== this.props.value && this.setState({
						value: e.value || null
					})
				}
				render() {
					const {
						props: e
					} = this, {
						value: t
					} = this.state;
					return r.a.createElement("div", {
						"aria-label": e.name,
						className: e.className,
						role: "radiogroup",
						onKeyDown: this.onKeyDown
					}, r.a.createElement("input", {
						disabled: e.disabled,
						type: "hidden",
						value: t || ""
					}), r.a.Children.map(e.children, (n, s) => {
						const o = 0 === s,
							i = n.props.value === t,
							a = null !== t ? i ? 0 : -1 : o ? 0 : -1;
						return r.a.cloneElement(n, {
							disabled: e.disabled,
							onClick: e => this.handleClick(n.props.value),
							selected: i,
							tabIndex: a
						})
					}))
				}
			}
		},
		"./src/reddit/controls/Score/index.m.less": function(e, t, n) {
			e.exports = {
				score: "_1rZYMD_4xY3gRcSS3p8ODO",
				dot: "uFieChpcVxrPI9VvCKqZu",
				viewCount: "_3bAGP2FKe97ijgBAGQOYsk"
			}
		},
		"./src/reddit/controls/Score/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/classNames/index.ts"),
				o = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				i = n("./src/lib/prettyPrintNumber/index.ts"),
				a = n("./node_modules/react/index.js"),
				d = n.n(a),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./src/reddit/components/CountAnimation/index.tsx"),
				m = n("./src/reddit/components/InfoTextTooltip/Hooked.tsx"),
				p = n("./src/reddit/components/PostContent/ViewCount.tsx"),
				b = n("./src/reddit/constants/colors.ts"),
				f = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				h = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				g = n("./src/reddit/hooks/useInfoTextTooltip.ts"),
				v = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				x = n("./src/reddit/models/Vote/index.ts"),
				E = n("./src/reddit/selectors/experiments/postActionBarAnimation.ts"),
				O = n("./src/reddit/selectors/meta.ts"),
				C = n("./src/reddit/selectors/posts.ts"),
				A = n("./node_modules/reselect/es/index.js"),
				y = n("./src/reddit/controls/Score/index.m.less"),
				j = n.n(y);
			const I = {
					placement: "right"
				},
				k = e => e.voteState === x.a.downvoted ? Object(v.a)(e).voteText.downvote : e.voteState === x.a.upvoted ? Object(v.a)(e).voteText.upvote : Object(h.a)(Object(f.a)(e)),
				_ = Object(A.c)({
					locale: e => Object(O.k)(e),
					post: (e, t) => {
						let {
							shouldShowUpvoteRatioOnHover: n,
							postId: s
						} = t;
						if (n && s) return Object(C.F)(e, {
							postId: s
						})
					}
				}),
				S = () => 0,
				w = Object(c.b)(_),
				T = Object(o.a)(e => {
					const t = {
							color: e.light ? b.a.lightboxHeaderText : k(e)
						},
						{
							score: n,
							postId: o = "",
							locale: f,
							isVoteCountAnimation: h,
							isCountAnimShadowTestEnabled: v,
							shouldShowUpvoteRatioOnHover: x,
							post: O
						} = e,
						C = Object(c.d)(),
						A = null == f ? void 0 : f.startsWith("en"),
						y = e.isScoreHidden ? A ? s.fbt._("Vote", null, {
							hk: "2TMson"
						}) : d.a.createElement("span", {
							className: j.a.dot
						}, "") : Object(i.b)(n),
						_ = Object(a.useCallback)(e => {
							const {
								voteCountChange: t
							} = e.subscribe.data;
							0 !== t && C(Object(l.H)({
								postId: o,
								delta: t
							}))
						}, [C, o]),
						w = Object(a.useRef)({
							input: {
								channel: {
									teamOwner: "CONTENT_AND_COMMUNITIES",
									category: "VOTE_COUNT_UPDATE",
									postID: o
								}
							}
						}),
						T = !e.isScoreHidden && h && n < E.a,
						P = Object(g.a)(I),
						N = n < 0 ? 0 : n;
					return d.a.createElement("div", {
						className: Object(r.a)(j.a.score, e.className),
						style: t,
						onMouseEnter: x ? P.show : void 0,
						onMouseLeave: x ? P.hide : void 0,
						ref: x ? P.target.ref : void 0
					}, (T || v) && d.a.createElement(d.a.Fragment, null, d.a.createElement(u.b, {
						initialDisplayCount: N,
						countToUpperBound: N,
						initialDelay: S,
						subsequentRecurringDelay: S,
						incrementDelta: S,
						shouldDisjointAnimation: !0,
						postId: o,
						featureName: u.a.Vote,
						queryKey: "postVoteCount",
						queryVariables: w.current,
						onDataCB: _,
						isLoadTestOnly: v && !T
					})), !T && y, x && O && d.a.createElement(m.a, P, d.a.createElement(p.a, {
						className: j.a.viewCount,
						post: O,
						showViewCount: !1
					})))
				});
			t.a = w(T)
		},
		"./src/reddit/controls/Search/CommentSearch/index.m.less": function(e, t, n) {
			e.exports = {
				absolute: "_3JOs2fo7GARfPQK9n9uvyr",
				actionFont: "_2GiazGbWQeG84CupoExWj9",
				dismissButton: "_2lSQO1uFdnaWbYRKtLg3H-",
				metadataFont: "_1Vs6ZQxgSSIBCGCe2dcMoA",
				flex: "_1qRmLv2PYGtqa3xyVEYz_R",
				input: "_2WVAyd_SvtylHMe7sKaua9",
				linkTextColor: "_1zG8KFMibgWr8ahovOZAUB",
				paddingIcon: "_2i3sQHj_1l-LDzGfzQTjHM",
				postIcon: "_1rMy-IddyxrWMGR5hH5O1E",
				relative: "_3AIIvG4My2zfaJh7r8TucE",
				verticalDivider: "_34BFzBLxzKlRZTjBIHtnlh",
				dismissIcon: "_1Z_UNdjZZu53GD24SI5BLG",
				searchIcon: "_380giGvmbbYVTkgLoNx7ZP"
			}
		},
		"./src/reddit/controls/Search/CommentSearch/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return S
			})), n.d(t, "b", (function() {
				return w
			})), n.d(t, "d", (function() {
				return N
			})), n.d(t, "c", (function() {
				return D
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router-redux/es/index.js"),
				d = n("./src/lib/addQueryParams/index.ts"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/lib/makeSearchKey/index.ts"),
				m = n("./src/reddit/actions/pages/search/index.ts"),
				p = n("./src/reddit/constants/keycodes.ts"),
				b = n("./src/reddit/constants/parameters.ts"),
				f = n("./src/reddit/contexts/PageLayer/index.tsx"),
				h = n("./src/reddit/helpers/path/index.ts"),
				g = n("./src/reddit/helpers/search/searchClickSearchBarOriginElement.ts"),
				v = n("./src/reddit/helpers/search/searchImpressionId.ts"),
				x = n("./src/reddit/helpers/search/SearchTelemetrySource.ts"),
				E = n("./src/reddit/helpers/trackers/searchResults.ts"),
				O = n("./src/reddit/hooks/usePageLayer.ts"),
				C = n("./src/reddit/hooks/useTracking.ts"),
				A = n("./src/reddit/icons/fonts/index.tsx"),
				y = n("./src/reddit/selectors/platform.ts"),
				j = n("./src/reddit/selectors/telemetry.ts"),
				I = n("./src/reddit/selectors/user.ts"),
				k = n("./src/reddit/controls/Search/CommentSearch/index.m.less"),
				_ = n.n(k);
			const S = "comment_search-bar",
				w = "comment-search-button",
				T = "search-bar-dismiss-button",
				P = "COMMENT_SEARCH_BAR_TEST_ID";

			function N(e) {
				let {
					searchValue: t,
					post: n,
					subreddit: s
				} = e;
				return {
					[b.w]: t,
					[b.I]: [l.ic.Comments]
				}
			}

			function D(e) {
				const {
					expanded: t,
					bucketed: n,
					collapsed: l
				} = e.experiment, b = Object(O.a)(), k = Object(C.a)(), D = (null == b ? void 0 : b.queryParams.q) || "", [M, R] = Object(r.useState)(D), [L, B] = Object(r.useState)(t), F = Object(i.d)(), U = Object(r.useRef)(null), H = Object(i.e)(e => Object(f.h)(e, {
					pageLayer: b
				})), G = Object(i.e)(e => Object(f.s)(e, {
					pageLayer: b
				})), Q = Object(i.e)(e => Object(I.mb)(e)), q = Object(i.e)(e => Object(I.rb)(e)), W = Object(i.e)(e => Object(y.i)(e));
				var z, V, K;

				function Y() {
					var t;
					if (!M.trim() || !H) return;
					const n = new URL(H.permalink).pathname,
						s = N({
							searchValue: M,
							post: H,
							subreddit: G
						});
					g.a.set(j.a.CommentSearchBar), k(Object(E.o)(E.a.FULL_SEARCH_BUTTON, s, x.a.PdpCommentSearchBar, b || void 0));
					const r = Object(u.b)(H.id, void 0, s, Q && q);
					F(Object(m.d)({
						key: r,
						options: s,
						subredditName: null == G ? void 0 : G.name,
						postId: H.id
					}));
					const o = Object(d.a)(n, s);
					F(Object(a.b)(Object(h.b)(o), {
						...null === (t = e.prevLocation) || void 0 === t ? void 0 : t.state,
						isOverlay: W,
						scrollOnLoad: !0
					}))
				}
				return z = U, V = B, K = l, Object(r.useEffect)(() => {
					if (K) return document.addEventListener("mousedown", e), () => {
						document.removeEventListener("mousedown", e)
					};

					function e(e) {
						z.current && !z.current.contains(e.target) && V(!1)
					}
				}, [z]), n ? o.a.createElement("div", {
					className: _.a.flex
				}, M || L ? o.a.createElement("div", {
					"data-testid": S
				}, o.a.createElement("label", {
					className: Object(c.a)(_.a.flex, _.a.relative)
				}, o.a.createElement("div", {
					className: _.a.absolute,
					role: "submit",
					onClick: Y
				}, o.a.createElement(A.a, {
					className: Object(c.a)(_.a.postIcon, _.a.paddingIcon),
					name: "search"
				})), o.a.createElement("input", {
					className: Object(c.a)(_.a.metadataFont, _.a.input),
					"data-testid": P,
					id: S,
					type: "search",
					onChange: e => {
						v.a.update(x.a.PdpCommentSearchBar), R(e.target.value)
					},
					onFocus: function() {
						v.a.update(x.a.PdpCommentSearchBar), g.a.set(j.a.CommentSearchBar), k(Object(E.o)(E.a.SEARCH_BAR, N({
							searchValue: M,
							post: H,
							subreddit: G
						}), x.a.PdpCommentSearchBar, b || void 0))
					},
					onKeyPress: function(e) {
						e.key === p.b.Enter && Y()
					},
					placeholder: s.fbt._("Search comments", null, {
						hk: "2ObH7B"
					}),
					ref: U,
					value: M
				}), M && o.a.createElement("button", {
					"aria-label": s.fbt._("Remove search bar text", null, {
						hk: "4twCsS"
					}),
					id: T,
					className: _.a.dismissButton,
					"data-testid": T,
					onClick: () => {
						R("")
					}
				}, o.a.createElement(A.a, {
					className: _.a.dismissIcon,
					name: "clear"
				})))) : o.a.createElement("button", {
					className: _.a.linkTextColor,
					"data-testid": w,
					id: w,
					onClick: () => {
						Promise.resolve(B(!0)).then(() => {
							var e;
							return null === (e = U.current) || void 0 === e ? void 0 : e.focus()
						})
					}
				}, o.a.createElement(A.a, {
					className: Object(c.a)(_.a.searchIcon, _.a.paddingIcon),
					name: "search"
				}), o.a.createElement("span", {
					className: _.a.actionFont
				}, s.fbt._("Search comments", null, {
					hk: "2ObH7B"
				})))) : null
			}
		},
		"./src/reddit/controls/SearchBar/index.m.less": function(e, t, n) {
			e.exports = {
				searchContainer: "_13yLxNALfY3_F48PYybgUr",
				search: "RxQA71ktKLBiPThTT7ita",
				mRightAlignedIcon: "_1NR83qzzPFX9KcVm-fxGFg",
				searchIconContainer: "_1IUrembT3LfQzzy388S8eF",
				mClickable: "_1K9n38-jQENV0_njgPIo_x",
				mRightAligned: "_1fLhMe5y6XbNg-lgHQrh5e"
			}
		},
		"./src/reddit/controls/SearchBar/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Search/index.tsx"),
				a = n("./src/reddit/controls/SearchBar/index.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("label", {
				className: Object(o.a)(d.a.searchContainer, e.className)
			}, r.a.createElement("input", {
				className: Object(o.a)(d.a.search, {
					[d.a.mRightAlignedIcon]: e.rightAlignedIcon
				}),
				autoFocus: e.autoFocus,
				type: "text",
				onChange: e.onTextChange,
				onKeyPress: e.onKeyPress,
				placeholder: e.placeholder,
				ref: e.innerRef,
				value: e.value
			}), r.a.createElement("div", {
				className: Object(o.a)(d.a.searchIconContainer, {
					[d.a.mClickable]: !!e.onSearch,
					[d.a.mRightAligned]: e.rightAlignedIcon
				}),
				role: e.onSearch && "submit",
				onClick: e.onSearch
			}, r.a.createElement(i.a, null)))
		},
		"./src/reddit/controls/Select/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "DuuuuIp9EubfvJyrdxytL",
				wrapper: "DuuuuIp9EubfvJyrdxytL",
				Caret: "_8fOXBcWxu_c3tlrAKMR3R",
				caret: "_8fOXBcWxu_c3tlrAKMR3R",
				Inner: "_3-_epznhOfLDNH3-plYM6l",
				inner: "_3-_epznhOfLDNH3-plYM6l",
				active: "wFEhEmBm9HI3jG6QDUnaw",
				redditStyle: "_2PDExzXmSTOdxzNjRB1Pww"
			}
		},
		"./src/reddit/controls/Sortable/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/helpers/dragDropContext/index.ts"),
				i = n("./node_modules/lodash/flow.js"),
				a = n.n(i),
				d = n("./node_modules/react-dnd/lib/index.js");
			class c extends r.a.Component {
				constructor() {
					super(...arguments), this.handleClick = () => {
						this.props.onClick && this.props.onClick(this.props.id, this.props.index)
					}
				}
				render() {
					const {
						props: e
					} = this;
					return e.connectDropTarget && e.connectDragSource ? a()(e.connectDropTarget, e.connectDragSource)(r.a.createElement("div", {
						onClick: this.handleClick
					}, e.render(e.id, e.index, e.isDragging, e.isOver, e.canDrop))) : null
				}
			}
			var l = a()(Object(d.DragSource)("card", {
				beginDrag: e => ({
					id: e.id,
					index: e.index
				}),
				endDrag: (e, t) => {
					if (t && t.didDrop()) {
						const n = t.getDropResult();
						e.onDrop(e.id, n.id)
					}
				}
			}, (e, t) => ({
				connectDragSource: e.dragSource(),
				isDragging: t.isDragging()
			})), Object(d.DropTarget)("card", {
				drop: (e, t) => {
					if (!t || !t.didDrop()) return {
						id: e.id,
						index: e.index
					}
				},
				canDrop: (e, t) => {
					if (!t) return !1;
					const n = t.getItem();
					return e.id !== n.id
				}
			}, (e, t) => ({
				connectDropTarget: e.dropTarget(),
				isOver: t.isOver(),
				canDrop: t.canDrop()
			})))(c);
			class u extends r.a.Component {
				constructor(e) {
					super(e), this.onDrop = (e, t) => {
						this.setState(n => {
							const s = n.values.slice(),
								r = s.indexOf(e),
								o = s.splice(r, 1)[0];
							let i = s.indexOf(t);
							return r <= i && (i += 1), s.splice(i, 0, o), this.props.onDrop(e, t, s), {
								values: s
							}
						})
					}, this.state = {
						values: e.values
					}
				}
				componentWillReceiveProps(e) {
					this.setState(() => ({
						values: e.values
					}))
				}
				render() {
					const {
						className: e,
						getReactKey: t,
						onClick: n,
						render: s
					} = this.props;
					return r.a.createElement("div", {
						className: e
					}, this.state.values.map((e, o) => r.a.createElement(l, {
						id: e,
						key: t && t(e, o),
						index: o,
						render: s,
						onDrop: this.onDrop,
						onClick: n
					})))
				}
			}
			t.a = Object(o.a)(u)
		},
		"./src/reddit/controls/TextButton/index.m.less": function(e, t, n) {
			e.exports = {
				textButton: "qYzY57HWQ8W424hj3s10-"
			}
		},
		"./src/reddit/controls/TextButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/TextButton/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("button", {
				children: e.children,
				className: Object(o.a)(a.a.textButton, e.className),
				disabled: e.disabled,
				onClick: e.onClick
			})
		},
		"./src/reddit/controls/ToggleSwitch/index.m.less": function(e, t, n) {
			e.exports = {
				toggleDisplay: "_2FKpII1jz0h6xCAw1kQAvS",
				toggleSwitch: "_2e2g485kpErHhJQUiyvvC2",
				redditStyle: "_3kUvbpMbR21zJBboDdBH7D",
				mActive: "_1L5kUnhRYhUJ4TkMbOTKkI",
				mDisabled: "_3clF3xRMqSWmoBQpXv8U5z",
				xs: "_1asGWL2_XadHoBuUlNArOq",
				s: "_1hku5xiXsbqzLmszstPyR3",
				m: "_10hZCcuqkss2sf5UbBMCSD",
				l: "_1fCdbQCDv6tiX242k80-LO",
				xl: "_2Jp5Pv4tgpAsTcnUzTsXgO"
			}
		},
		"./src/reddit/controls/ToggleSwitch/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/Button/index.tsx"),
				a = n("./src/reddit/controls/ToggleSwitch/index.m.less"),
				d = n.n(a);
			t.a = Object(s.memo)(Object(s.forwardRef)((e, t) => {
				const n = e.size || i.d.XS;
				return r.a.createElement("button", {
					"aria-checked": e.on,
					className: Object(o.a)(d.a.toggleSwitch, e.className, {
						[d.a.xs]: n === i.d.XS,
						[d.a.s]: n === i.d.S,
						[d.a.m]: n === i.d.M,
						[d.a.l]: n === i.d.L,
						[d.a.xl]: n === i.d.XL,
						[d.a.mActive]: e.on && !e.disabled || e.forceOn && e.on,
						[d.a.mDisabled]: e.disabled,
						[d.a.redditStyle]: e.redditStyle
					}),
					style: e.on && !e.disabled && e.activeColorOverride ? {
						backgroundColor: e.activeColorOverride
					} : void 0,
					id: e.id,
					role: "switch",
					tabIndex: e.tabIndex,
					type: "button",
					onClick: () => !e.disabled && e.onToggle && e.onToggle(),
					ref: t
				}, r.a.createElement("div", {
					className: d.a.toggleDisplay
				}))
			}))
		},
		"./src/reddit/controls/Typography/index.m.less": function(e, t, n) {
			e.exports = {
				heading1: "_37JeV292IJA7_x1qej_-2H",
				heading2: "p13k-tsMcatGBlVpJBZmw",
				heading3: "_1nHvvYpmn7q9eWDAGzKcce",
				heading4: "_1-rwUWsB5F8WmYI8F66dai",
				heading5: "_22RKdGqihAj6MFumW6DuRV",
				heading6: "_4xqrI_N1UdqsK9E1RSisG",
				body1: "_2HJOIn4SJm4z1NeCv_hNFu",
				body2: "_3ImIPX9rfoPmUrZ1R8KGqS",
				actionFont: "_3uShGanwyVFBaTiPMFzfAC",
				metadata: "_2nyJGeaFJbXTqTh9OGwxfu",
				metadata3: "_3BIqvjJkJKZfH4vtC11dGF"
			}
		},
		"./src/reddit/controls/Typography/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			}));
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/Typography/index.m.less"),
				o = n.n(r);
			s.a.h1("heading1", o.a), s.a.h2("heading2", o.a), s.a.h3("heading3", o.a), s.a.h4("heading4", o.a);
			const i = s.a.h5("heading5", o.a),
				a = (s.a.h6("heading6", o.a), s.a.p("body1", o.a), s.a.p("body2", o.a)),
				d = (s.a.p("actionFont", o.a), s.a.p("metadata", o.a));
			s.a.p("metadata3", o.a)
		},
		"./src/reddit/controls/UnstyledInternalLink/index.m.less": function(e, t, n) {
			e.exports = {
				unstyledInternalLink: "_39Glgtoolpdt4PIzcnjPSW"
			}
		},
		"./src/reddit/controls/UnstyledInternalLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/InternalLink/index.tsx"),
				o = n("./src/reddit/controls/UnstyledInternalLink/index.m.less"),
				i = n.n(o);
			t.a = s.a.wrapped(r.default, "unstyledInternalLink", i.a)
		},
		"./src/reddit/controls/Upvote/index.m.less": function(e, t, n) {
			e.exports = {
				Upvote: "_3SUsITjKNQ7Tp0Wi2jGxIM",
				upvote: "_3SUsITjKNQ7Tp0Wi2jGxIM",
				mIsInteractive: "qW0l8Af61EP35WIG6vnGk",
				mIsActive: "Z3lT0VGlALek4Q9j0ZQCr",
				mIsVoteable: "_3edNsMs0PNfyQYofMNVhsG"
			}
		},
		"./src/reddit/customMiddleware/recentSubreddits.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			}));
			var s = n("./src/chat/customMiddleware/noop.ts"),
				r = n("./src/lib/cache/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/localStorageAvailable/index.ts"),
				a = n("./src/reddit/actions/recentSubreddits/constants.ts");
			const d = Object(r.c)(o.s.RECENT_SUBREDDITS, "recent_subreddits"),
				c = () => Object(i.a)() && Object(r.b)(d) || [];
			t.a = e => "undefined" == typeof window ? s.a : e => t => {
				const n = e(t);
				switch (t.type) {
					case a.e: {
						const e = c() || [],
							n = {
								...t.payload,
								lastVisited: Date.now()
							},
							{
								id: s
							} = n;
						if (s) {
							const t = e.findIndex(e => e.id === s); - 1 !== t && e.splice(t, 1), e.unshift(n), e.splice(a.c), Object(r.d)(d, e, o.ub)
						}
						break
					}
				}
				return n
			}
		},
		"./src/reddit/endpoints/comment/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return E
			})), n.d(t, "m", (function() {
				return O
			})), n.d(t, "f", (function() {
				return C
			})), n.d(t, "l", (function() {
				return A
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "h", (function() {
				return j
			})), n.d(t, "e", (function() {
				return I
			})), n.d(t, "k", (function() {
				return k
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "g", (function() {
				return S
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "d", (function() {
				return P
			})), n.d(t, "b", (function() {
				return N
			}));
			var s = n("./src/config.ts"),
				r = n("./src/redditGQL/operations/ModApprove.json"),
				o = n("./src/redditGQL/operations/ModRemove.json"),
				i = n("./src/redditGQL/operations/UpdateCommentDistinguishState.json"),
				a = n("./src/redditGQL/operations/UpdateCommentStickyState.json"),
				d = n("./src/redditGQL/types.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/makeGqlRequest/index.ts"),
				m = n("./src/lib/omitHeaders/index.ts"),
				p = n("./src/reddit/constants/headers.ts"),
				b = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				f = n("./src/reddit/helpers/comment/index.ts"),
				h = n("./src/reddit/models/Comment/addProfileImgParam.ts"),
				g = n("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				v = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				x = n("./src/redditGQL/operations/GetCommentById.json");
			const E = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/save`),
					method: c.ob.POST,
					data: {
						id: t
					}
				}),
				O = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/unsave`),
					method: c.ob.POST,
					data: {
						id: t
					}
				}),
				C = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/lock`),
					method: c.ob.POST,
					data: {
						id: t
					}
				}),
				A = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/unlock`),
					method: c.ob.POST,
					data: {
						id: t
					}
				}),
				y = (e, t) => Object(u.a)(e, {
					...r,
					variables: {
						input: {
							id: t
						}
					}
				}),
				j = (e, t, n) => Object(u.a)(e, {
					...o,
					variables: {
						input: {
							id: t,
							isSpam: n
						}
					}
				}),
				I = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/ignore_reports`),
					method: c.ob.POST,
					data: {
						id: t
					}
				}),
				k = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/unignore_reports`),
					method: c.ob.POST,
					data: {
						id: t
					}
				}),
				_ = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: `${e.apiUrl}/api/show_comment`,
					method: c.ob.POST,
					data: {
						id: t
					}
				}),
				S = (e, t, n, r, o) => {
					let i = Object(b.a)(Object(v.a)(Object(f.a)(Object(g.a)(`${s.a.gatewayUrl}/desktopapi/v1/morecomments/${t}`), o ? 1 : void 0)));
					return r && (i = Object(h.a)(i)), Object(l.a)(e, {
						data: n,
						endpoint: i,
						method: c.ob.POST,
						type: "json",
						traceRequestName: "more_comments"
					})
				},
				w = {
					[c.I.NONE]: d.p.None,
					[c.I.MODERATOR]: d.p.ModDistinguished,
					[c.I.ADMIN]: d.p.AdminDistinguished,
					[c.I.ALUMNI_ADMIN]: d.p.AlumniDistinguished
				};

			function T(e, t, n) {
				const s = function(e, t) {
					return {
						input: {
							commentId: e,
							distinguishState: t === c.I.NONE ? d.e.None : d.e.Distinguished,
							distinguishType: w[t]
						}
					}
				}(t, n);
				return Object(u.a)(e, {
					...i,
					variables: s
				})
			}

			function P(e, t, n) {
				return Object(u.a)(e, {
					...a,
					variables: {
						input: {
							commentId: t,
							sticky: n
						}
					}
				})
			}
			const N = async (e, t) => {
				return await Object(u.a)(e, {
					...x,
					variables: {
						id: t
					}
				})
			}
		},
		"./src/reddit/endpoints/devPlatform/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/GetDevPlatformMetadata.json");
			const o = async (e, t) => {
				var n;
				const o = await Object(s.a)(e, {
					...r,
					variables: {
						...t,
						mimetype: "application/json"
					}
				});
				return o.ok && o.body ? null === (n = o.body.data.subredditInfoByName) || void 0 === n ? void 0 : n.devPlatformMetadata : null
			}
		},
		"./src/reddit/endpoints/economics/predictions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "p", (function() {
				return O
			})), n.d(t, "n", (function() {
				return C
			})), n.d(t, "i", (function() {
				return y
			})), n.d(t, "j", (function() {
				return j
			})), n.d(t, "e", (function() {
				return I
			})), n.d(t, "k", (function() {
				return k
			})), n.d(t, "l", (function() {
				return _
			})), n.d(t, "a", (function() {
				return S
			})), n.d(t, "o", (function() {
				return w
			})), n.d(t, "f", (function() {
				return T
			})), n.d(t, "g", (function() {
				return P
			})), n.d(t, "h", (function() {
				return N
			})), n.d(t, "c", (function() {
				return D
			})), n.d(t, "b", (function() {
				return M
			})), n.d(t, "d", (function() {
				return R
			})), n.d(t, "m", (function() {
				return L
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/lib/makeRequest/index.ts"),
				o = n("./src/redditGQL/operations/AddPredictionDrafts.json"),
				i = n("./src/redditGQL/operations/CancelPrediction.json"),
				a = n("./src/redditGQL/operations/ChangePrediction.json"),
				d = n("./src/redditGQL/operations/ChangePredictionVote.json"),
				c = n("./src/redditGQL/operations/CreatePredictionTournament.json"),
				l = n("./src/redditGQL/operations/EndPredictionTournament.json"),
				u = n("./src/redditGQL/operations/GetPredictionChipPackages.json"),
				m = n("./src/redditGQL/operations/GetPredictionCreationAllowance.json"),
				p = n("./src/redditGQL/operations/GetPredictionToken.json"),
				b = n("./src/redditGQL/operations/GetTournaments.json"),
				f = n("./src/redditGQL/operations/GetTournamentsBaseInfo.json"),
				h = n("./src/redditGQL/operations/ResolvePrediction.json"),
				g = n("./src/redditGQL/operations/SubredditTopPredictors.json"),
				v = n("./src/redditGQL/operations/SubredditTournamentLeaderboard.json"),
				x = n("./src/redditGQL/operations/UpdatePredictionTournament.json"),
				E = n("./src/redditGQL/operations/VotePrediction.json");
			const O = async (e, t) => {
				let {
					postId: n,
					optionId: o,
					coinPackageId: i,
					price: a
				} = t;
				var d;
				const c = await Object(s.a)(e, {
					...E,
					variables: {
						input: {
							postId: n,
							optionId: o,
							coinPackageId: i,
							price: a
						}
					}
				});
				if (!Object(r.c)(c) || c.error || !(null === (d = c.body.data.votePrediction) || void 0 === d ? void 0 : d.ok)) throw new Error("Failed to make prediction");
				return c.body.data.votePrediction.poll
			}, C = (e, t) => {
				let {
					postId: n,
					optionId: r
				} = t;
				return Object(s.a)(e, {
					...h,
					variables: {
						input: {
							postId: n,
							optionId: r
						}
					}
				})
			};
			var A;
			! function(e) {
				e.AllTime = "ALL_TIME", e.Monthly = "MONTHLY"
			}(A || (A = {}));
			const y = async (e, t) => {
				let {
					subredditId: n,
					period: o = A.AllTime,
					top: i = 100,
					includeCurrentRank: a
				} = t;
				const d = await Object(s.a)(e, {
					...g,
					variables: {
						subredditId: n,
						period: o,
						top: i,
						includeCurrentRank: a
					}
				});
				if (!Object(r.c)(d) || d.error) throw new Error("Failed to fetch subreddit top predictors");
				if (!d.body.data.subredditInfoById) throw new Error("Subreddit has no prediction winners");
				return d.body.data.subredditInfoById
			}, j = async (e, t) => {
				let {
					subredditId: n,
					tournamentId: o,
					includeCurrentRank: i
				} = t;
				const a = await Object(s.a)(e, {
					...v,
					variables: {
						subredditId: n,
						tournamentId: o,
						includeCurrentRank: i
					}
				});
				if (!Object(r.c)(a) || a.error) throw new Error("Failed to fetch subreddit tournament");
				if (!a.body.data.subredditInfoById) throw new Error("Subreddit has no prediction winners");
				return a.body.data.subredditInfoById
			}, I = async (e, t) => {
				const n = await Object(s.a)(e, {
					...c,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(n) || n.error || !n.body.data.createPredictionTournament.tournament) throw new Error("Failed to create tournament");
				return n.body.data.createPredictionTournament.tournament
			}, k = async (e, t) => {
				const n = await Object(s.a)(e, {
					...b,
					variables: t
				});
				if (!Object(r.c)(n) || n.error) throw new Error("Failed to fetch tournaments");
				return n.body.data.subredditInfoByName.predictionTournaments || []
			}, _ = async (e, t) => {
				const n = await Object(s.a)(e, {
					...f,
					variables: t
				});
				if (!Object(r.c)(n) || n.error) throw new Error("Failed to fetch tournaments");
				return n.body.data.subredditInfoByName.predictionTournaments || []
			}, S = async (e, t) => {
				const n = await Object(s.a)(e, {
					...o,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(n) || n.error) throw new Error("Failed to create prediction");
				const {
					errors: i,
					tournament: a
				} = n.body.data.addPredictionDrafts;
				if (null == i ? void 0 : i.length) throw new Error(i[0].message);
				if (!a) throw new Error("Failed to create prediction");
				return a
			}, w = async (e, t) => {
				const n = await Object(s.a)(e, {
					...x,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(n) || n.error) throw new Error("Failed to update prediction tournament");
				const {
					tournament: o
				} = n.body.data.updatePredictionTournament;
				if (!o) throw new Error("Failed to update prediction tournament");
				return o
			}, T = (e, t) => Object(s.a)(e, {
				...l,
				variables: {
					input: t
				}
			}), P = (e, t) => Object(s.a)(e, {
				...u,
				variables: t
			}), N = (e, t) => Object(s.a)(e, {
				...p,
				variables: t
			}), D = async (e, t) => {
				const n = await Object(s.a)(e, {
					...a,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(n) || !n.body.data.changePrediction.ok) throw new Error("Unable to update prediction");
				return n.body.data.changePrediction.poll
			}, M = async (e, t) => {
				let {
					postId: n
				} = t;
				var o, a;
				const d = await Object(s.a)(e, {
					...i,
					variables: {
						input: {
							postId: n
						}
					}
				});
				if (!Object(r.c)(d) || !(null === (o = d.body.data.cancelPrediction) || void 0 === o ? void 0 : o.ok) || !(null === (a = d.body.data.cancelPrediction) || void 0 === a ? void 0 : a.poll)) throw new Error("Unable to cancel prediction");
				return d.body.data.cancelPrediction.poll
			}, R = async (e, t) => {
				var n, o;
				const i = await Object(s.a)(e, {
					...d,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(i) || !(null === (n = i.body.data.changePredictionVote) || void 0 === n ? void 0 : n.ok) || !(null === (o = i.body.data.changePredictionVote) || void 0 === o ? void 0 : o.poll)) throw new Error("Unable to change prediction.");
				return i.body.data.changePredictionVote.poll
			}, L = async (e, t) => {
				const n = await Object(s.a)(e, {
					...m,
					variables: t
				});
				return !!Object(r.c)(n) && n.body.data.identity.isPredictionCreationAllowed
			}
		},
		"./src/reddit/endpoints/economics/uploadedAssets.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			}));
			var s, r, o = n("./src/config.ts"),
				i = n("./src/reddit/endpoints/governance/requester.ts");

			function a(e, t, n, s) {
				const r = `assetType=${n}&assetStatus=${s}`;
				return Object(i.a)(e, {
					method: "get",
					endpoint: `${o.a.metaUrl}/modtools/${t}/assets?${r}`
				})
			}

			function d(e, t, n) {
				const r = new FormData;
				return r.append("assetType", n.assetType), r.append("assetName", n.assetName), r.append("upfile", n.imageFile), n.assetType === s.Badge && (r.append("badgeColor", n.badgeColor || ""), r.append("badgeDescription", n.badgeDescription || "")), Object(i.a)(e, {
					endpoint: `${o.a.metaUrl}/modtools/${t}/assets`,
					method: "post",
					type: null,
					data: r
				})
			}

			function c(e, t, n, s, r) {
				return Object(i.a)(e, {
					endpoint: `${o.a.metaUrl}/modtools/${t}/assets/${n}s/${s}`,
					method: "patch",
					data: r
				})
			}! function(e) {
				e.Badge = "badge", e.Emote = "emote"
			}(s || (s = {})),
			function(e) {
				e.Uploaded = "uploaded", e.Approved = "approved", e.Rejected = "rejected"
			}(r || (r = {}))
		},
		"./src/reddit/endpoints/geotagging/setSubredditGeoPlace.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/SetSubredditGeoPlace.json");
			const o = e => ({
				input: {
					subredditId: e.subredditId,
					geoPlace: {
						id: e.placeId,
						source: e.source,
						sessionId: e.sessionId
					}
				}
			});
			t.a = async (e, t) => Object(s.a)(e, {
				...r,
				variables: o(t)
			})
		},
		"./src/reddit/endpoints/gold/topAwarded.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/TopAwardedPosts.json"),
				o = n("./src/redditGQL/operations/TopAwardersLeaderboard.json");
			const i = (e, t) => Object(s.a)(e, {
					...r,
					variables: {
						...t,
						includeListingMetadata: !!t.includeListingMetadata
					}
				}),
				a = (e, t) => Object(s.a)(e, {
					...o,
					variables: t
				})
		},
		"./src/reddit/endpoints/goodContent/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			var s, r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./src/lib/loadWithRetries/index.ts");
			! function(e) {
				e.PopularCommunities = "Popular Communities", e.Gaming = "Gaming", e.Sports = "Sports", e.TV = "TV", e.Travel = "Travel", e.HealthAndFitness = "Health & Fitness", e.Fashion = "Fashion"
			}(s || (s = {}));
			const i = {
					[s.PopularCommunities]: () => r.fbt._("Popular Communities", null, {
						hk: "2K4vGY"
					}),
					[s.Gaming]: () => r.fbt._("Gaming", null, {
						hk: "16rFc7"
					}),
					[s.Sports]: () => r.fbt._("Sports", null, {
						hk: "1cmqIR"
					}),
					[s.TV]: () => r.fbt._("TV", null, {
						hk: "2rVWoK"
					}),
					[s.Travel]: () => r.fbt._("Travel", null, {
						hk: "35HRB5"
					}),
					[s.HealthAndFitness]: () => r.fbt._("Health & Fitness", null, {
						hk: "2vstHj"
					}),
					[s.Fashion]: () => r.fbt._("Fashion", null, {
						hk: "3mkHju"
					})
				},
				a = e => {
					const t = i[e];
					return t ? t() : e
				},
				d = async () => (await Object(o.a)(() => n.e("FrontpageLinks").then(n.t.bind(null, "./src/reddit/endpoints/goodContent/frontpageLinks.json", 3)))).default
		},
		"./src/reddit/endpoints/governance/crypto.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "j", (function() {
				return i
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "l", (function() {
				return c
			})), n.d(t, "k", (function() {
				return l
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "n", (function() {
				return v
			}));
			var s, r = n("./src/config.ts"),
				o = n("./src/reddit/endpoints/governance/requester.ts");

			function i(e) {
				switch (e) {
					case s.Ethereum:
					case s.EthTraderEthereum:
						return "Ethereum Main Network";
					case s.Rinkeby:
					case s.EthTraderRinkeby:
						return "Rinkeby Test Network"
				}
				return e + " Network"
			}

			function a(e) {
				switch (e) {
					case s.Ethereum:
					case s.EthTraderEthereum:
						return "https://meta-api.reddit.com/ethereum/ethereum";
					case s.Rinkeby:
					case s.EthTraderRinkeby:
						return "https://meta-api.reddit.com/ethereum/rinkeby";
					case s.ArbitrumRinkeby:
						return "https://meta-api.reddit.com/ethereum/ethereum:5391184";
					case s.ArbitrumNitroDevnet:
						return "https://meta-api.reddit.com/ethereum/nitroDevnet";
					case s.ArbitrumMainnet:
						return "https://a4ba.arbitrum.io/rpc";
					default:
						return `https://meta-api.reddit.com/ethereum/${e}`
				}
			}

			function d(e) {
				switch (e) {
					case s.Ethereum:
					case s.EthTraderEthereum:
						return "homestead";
					case s.Rinkeby:
					case s.EthTraderRinkeby:
						return "rinkeby";
					case s.ArbitrumRinkeby:
						return 5391184;
					case s.ArbitrumNitroDevnet:
						return 421612;
					case s.ArbitrumMainnet:
						return 42170;
					default: {
						const [, t] = e.split(":");
						return t
					}
				}
			}

			function c(e) {
				return e === s.ArbitrumRinkeby ? 5e3 : 3e4
			}
			async function l(e, t, n) {
				return Object(o.a)(e, {
					method: "post",
					endpoint: `${r.a.metaUrl}/crypto/${t}/challenges`,
					data: {
						challengeType: "registration-challenge-EIP712",
						address: n
					}
				})
			}
			async function u(e, t, n) {
				return await Object(o.a)(e, {
					method: "post",
					endpoint: `${r.a.metaUrl}/crypto/${t}/registrations`,
					data: n
				})
			}
			async function m(e, t, n) {
				return await Object(o.a)(e, {
					method: "delete",
					endpoint: `${r.a.metaUrl}/crypto/${t}/registrations/${n}`
				})
			}! function(e) {
				e.Ethereum = "ethereum:1", e.Rinkeby = "ethereum:4", e.ArbitrumNova = "ethereum:42170", e.ArbitrumRinkeby = "ethereum:5391184", e.ArbitrumNitroDevnet = "ethereum:421612", e.ArbitrumMainnet = "ethereum:42170", e.EthTraderEthereum = "ethereum:1:ethtrader", e.EthTraderRinkeby = "ethereum:4:ethtrader"
			}(s || (s = {}));
			const p = (e, t, n) => ({
					type: "burn-link",
					subredditId: e,
					amount: t,
					burnMemo: n
				}),
				b = e => ({
					type: "convert-to-coins",
					subredditId: e
				}),
				f = e => ({
					type: "claim",
					subredditId: e
				}),
				h = e => ({
					type: "subscribe",
					subredditId: e
				}),
				g = (e, t, n, s) => ({
					type: "transfer",
					subredditId: e,
					recipient: t,
					recipientAddress: n,
					amount: s
				});
			async function v(e, t) {
				return await Object(o.a)(e, {
					method: "put",
					endpoint: `${r.a.metaUrl}/crypto/ethereum/transaction-intent`,
					data: t
				})
			}
		},
		"./src/reddit/endpoints/governance/posts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/config.ts"),
				r = (n("./src/reddit/models/Poll/index.ts"), n("./src/reddit/endpoints/governance/requester.ts"));

			function o(e, t, n) {
				return Object(r.a)(e, {
					method: "get",
					endpoint: `${s.a.metaUrl}/polls/${t}?postIds=${n.join(",")}`
				})
			}
		},
		"./src/reddit/endpoints/governance/requester.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/lib/makeApiRequest/index.ts");

			function r(e, t) {
				return Object(s.a)(e, {
					type: "json",
					...t
				}).then(e => {
					if (e.ok) return {
						body: e.body,
						ok: !0,
						status: e.status
					};
					return {
						error: e.error && e.error.fields && e.error.fields[0] ? e.error.fields[0].msg : {
							...e.body,
							code: e.status
						},
						ok: !1,
						status: e.status
					}
				})
			}
		},
		"./src/reddit/endpoints/governance/wallet.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/config.ts"),
				r = (n("./src/lib/bigNumberUtils/percent.ts"), n("./src/lib/constants/index.ts")),
				o = n("./src/reddit/endpoints/governance/requester.ts");

			function i(e, t) {
				return Object(o.a)(e, {
					endpoint: `${s.a.metaUrl}/wallets/${t.subredditId}/me`,
					method: r.ob.GET
				}).then(e => {
					if (e.ok) {
						const n = e.body,
							s = {
								[t.subredditId]: n
							};
						return {
							...e,
							body: s
						}
					}
					return e
				})
			}

			function a(e, t) {
				return Object(o.a)(e, {
					headers: {
						"X-HTTP-Method-Override": "GET"
					},
					endpoint: `${s.a.metaUrl}/wallets/${t.subredditId}`,
					method: r.ob.POST,
					data: t.userIds
				}).then(e => e.ok ? {
					...e,
					body: {
						wallets: e.body
					}
				} : e)
			}
		},
		"./src/reddit/endpoints/me/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const a = e => Object(o.a)(e, {
				endpoint: Object(i.a)(`${s.a.gatewayUrl}/desktopapi/v1/me`),
				method: r.ob.GET
			})
		},
		"./src/reddit/endpoints/messages/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			var s = n("./src/redditGQL/operations/ReportMessage.json"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const l = (e, t) => Object(o.a)(Object(a.a)(e, [d.a]), {
					endpoint: Object(c.a)(`${e.apiUrl}/api/compose`),
					method: r.ob.POST,
					data: t
				}),
				u = (e, t) => Object(i.a)(e, {
					...s,
					variables: t
				})
		},
		"./src/reddit/endpoints/modQueue/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				l = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				u = n("./src/redditGQL/operations/ModQueueItems.json");
			const m = (e, t, n) => Object(o.a)(e, {
					endpoint: Object(l.a)(Object(c.a)(`${s.a.gatewayUrl}/desktopapi/v1/${t}`)),
					method: r.ob.GET,
					data: {
						moderated_limit: 25,
						...n
					}
				}),
				p = (e, t, n) => Object(o.a)(Object(a.a)(e, [d.a]), {
					endpoint: `${e.apiUrl}/api/v1/modactions/${t}`,
					method: r.ob.POST,
					type: "json",
					data: n
				}),
				b = (e, t) => Object(i.a)(e, {
					...u,
					variables: t
				})
		},
		"./src/reddit/endpoints/moderator/moderatingSubreddits.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts");
			t.a = async e => Object(r.a)(Object(o.a)(e, [i.a]), {
				endpoint: `${e.apiUrl}/subreddit_permissions`,
				method: s.ob.GET,
				traceRequestName: "get_subreddit_permissions"
			})
		},
		"./src/reddit/endpoints/notificationsSettings/layoutByChannelEndpoint.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/NotificationSettingsLayoutByChannel.json"),
				o = n("./src/redditGQL/operations/UpdateNotificationPreferences.json");
			const i = (e, t) => Object(s.a)(e, {
					...r,
					variables: t
				}),
				a = (e, t) => Object(s.a)(e, {
					...o,
					variables: {
						input: {
							preferences: [t]
						}
					}
				})
		},
		"./src/reddit/endpoints/page/popularFeed.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/lib/env/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = n("./src/reddit/models/Post/index.ts"),
				a = n("./src/reddit/helpers/graphql/normalizeInterestTopicsFromGql/index.ts"),
				d = n("./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts"),
				c = n("./src/reddit/models/Onboarding/index.ts"),
				l = n("./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts"),
				u = n("./src/redditGQL/operations/PopularFeedElements.json");
			const m = async (e, t) => {
				var n, m, p, b;
				const f = await ((e, t) => Object(s.a)(e, {
					...u,
					variables: t
				}))(e, t);
				if (!f.ok && !(null === (p = null === (m = null === (n = f.body) || void 0 === n ? void 0 : n.data) || void 0 === m ? void 0 : m.popular) || void 0 === p ? void 0 : p.elements)) return f;
				const h = f.body,
					g = ((e, t) => {
						let {
							identity: n,
							popular: s,
							recentPosts: u,
							trendingSubreddits: m
						} = e;
						const p = {};
						let b;
						const [f, h] = s.elements.edges.reduce((e, t, n) => {
							var s, r, o, l;
							const [u, m] = e, f = t.node;
							if (Object(i.k)(f)) {
								const e = f;
								e.subreddit = {
									...e.subreddit
								}, u.push(f), (null === (r = null === (s = f.flair) || void 0 === s ? void 0 : s.template) || void 0 === r ? void 0 : r.id) && (null === (l = null === (o = f.flair) || void 0 === o ? void 0 : o.template) || void 0 === l ? void 0 : l.postStyle) && (p[f.flair.template.id] = Object(d.a)(f.flair.template.postStyle))
							} else if (Object(c.g)(f)) {
								const e = Object(a.a)(f.interestTopicRecommendations.recommendationTopics);
								e.topics.length && (b = {
									interests: e,
									index: n
								})
							} else m.push(f);
							return [u, m]
						}, [
							[],
							[]
						]);
						if (h.length) {
							const e = `Received unhandled ${h.length} elements when processing subreddit data: "${h[0].__typename}"`;
							Object(r.b)() || console.warn(e), o.c.captureMessage(e)
						}
						u && f.push(...u);
						const g = s.elements.dist,
							v = s.elements.geoFilter,
							x = null == u ? void 0 : u.map(e => e.id),
							E = Object(l.b)(f, m, n, x);
						return E.subredditAboutInfo = {}, b && (E.interestTopicRecommendations = b), {
							...E,
							...null !== g && {
								dist: g
							},
							...void 0 !== v && {
								geoFilter: v
							},
							...void 0 !== t.sort && {
								listingSort: t.sort
							}
						}
					})(h.data, t);
				return {
					...f,
					ok: !!(null === (b = h.data.popular) || void 0 === b ? void 0 : b.elements.edges.length),
					status: 200,
					body: g
				}
			}
		},
		"./src/reddit/endpoints/page/subredditPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return j
			})), n.d(t, "b", (function() {
				return I
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/isAdHocMultireddit/index.ts"),
				i = n("./src/lib/isFakeSubreddit/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/lib/performanceTimings/index.tsx"),
				l = n("./src/reddit/constants/graphql.ts"),
				u = n("./src/reddit/constants/page.ts"),
				m = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				p = n("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				b = n("./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts"),
				f = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				h = n("./src/reddit/models/Subreddit/index.ts"),
				g = n("./src/reddit/selectors/adsSignals.ts"),
				v = n("./src/reddit/selectors/experiments/communityChat.ts"),
				x = n("./src/reddit/selectors/experiments/communityDirectoryBacklinks/index.ts"),
				E = n("./src/reddit/selectors/experiments/devPlatform.ts"),
				O = n("./src/reddit/selectors/platform.ts"),
				C = n("./src/reddit/selectors/subreddit.ts"),
				A = n("./src/reddit/selectors/user.ts"),
				y = n("./src/redditGQL/operations/SubredditPage.json");
			const j = (e, t, n, s) => {
					var r, a;
					const {
						after: d,
						geo_filter: c,
						isMobile: m,
						layout: b,
						limit: f,
						recentPostIds: h,
						sort: y,
						t: j
					} = n, I = Object(A.bb)(e), k = Object(O.q)(e), _ = Object(o.a)(t), S = Object(i.a)(t), w = Object(C.W)(e, {
						subredditId: Object(C.I)(e, t)
					}).length > 0, T = Object(A.q)(e), P = Object(A.pb)(e), {
						adsSeenCount: N,
						totalPostsSeenCount: D,
						sessionStartTime: M
					} = Object(g.a)(e), R = Object(E.a)(e), L = Object(x.c)(e), B = Object(v.b)(e) || Object(v.a)(e), F = {
						name: t,
						includeIdentity: I && !e.user.account,
						adContext: {
							layout: b ? b.toUpperCase() : l.a.Card,
							clientSignalSessionData: {
								adsSeenCount: N,
								totalPostsSeenCount: D,
								sessionStartTime: M
							}
						},
						isFake: S,
						includeAchievementFlairs: s && !S,
						includeAppliedFlair: !S && I && s,
						includeCustomEmojis: s && !S,
						includeDevPlatformMetadata: R,
						includeQuestions: s && I && !S,
						includeRecents: S && h && h.length > 0 || !1,
						includeRedditorKarma: s && I && !(null === (a = null === (r = e.user.account) || void 0 === r ? void 0 : r.karma) || void 0 === a ? void 0 : a.total),
						includeRules: s && !S && !w,
						includeSubredditLinks: s && !S && !I,
						includeTopicLinks: s && !S && !I,
						includeTrending: S,
						includeSubredditRankings: L,
						includeSubredditChannels: B,
						isAdHocMulti: _,
						isAll: t === u.d.All,
						isLoggedOutGatedOptedin: T,
						isLoggedOutQuarantineOptedin: P,
						isPopular: t === u.d.Popular,
						recentPostIds: h || [],
						subredditNames: _ ? t.split("+") : []
					};
					return y && (F.sort = y.toUpperCase()), j && (F.range = j.toUpperCase()), m ? F.pageSize = Object(p.a)(b) : f && (F.pageSize = f), k && k.ad && (F.forceAds = {
						ad: k.ad
					}), (k && k.geo_filter || c) && (F.region = k && k.geo_filter || c), d && (F.after = btoa(d)), F
				},
				I = async (e, t, n) => {
					const s = Date.now(),
						o = await ((e, t) => Object(d.a)(e, {
							...y,
							variables: t
						}))(e, t),
						i = Date.now();
					if (!o.ok || !o.body) return o;
					const a = o.body,
						l = Date.now(),
						u = Object(b.a)(a.data),
						m = Date.now(),
						p = [{
							duration: i - s,
							logKeyType: c.a.gqlFetchTiming
						}, {
							duration: m - l,
							logKeyType: c.a.gqlNormalizationTiming
						}];
					return Object(c.h)({
						name: r.t.SUBREDDIT,
						isLoggedIn: n,
						metrics: p
					}), {
						...o,
						ok: !!a.data.subredditInfoByName && !Object(h.k)(a.data.subredditInfoByName),
						status: k(a.data),
						body: u
					}
				}, k = e => {
					if (!e.subredditInfoByName) return 404;
					if (Object(h.k)(e.subredditInfoByName)) {
						if (e.subredditInfoByName.forbiddenReason === h.d.Banned) return 404;
						if (e.subredditInfoByName.forbiddenReason === h.d.GoldOnly || e.subredditInfoByName.forbiddenReason === h.d.Private || e.subredditInfoByName.forbiddenReason === h.d.Quarantined || e.subredditInfoByName.forbiddenReason === h.d.Gated) return 403
					}
					return 200
				}, _ = e => {
					let {
						recentPostIds: t,
						...n
					} = e;
					return t && t.length ? {
						...n,
						recentPostIds: t.join(",")
					} : n
				};
			t.a = (e, t, n) => Object(a.a)(e, {
				endpoint: Object(m.a)(Object(f.a)(`${s.a.gatewayUrl}/desktopapi/v1/subreddits/${t}`)),
				method: r.ob.GET,
				data: n && _(n) || {},
				traceRequestName: "get_subreddit_page"
			})
		},
		"./src/reddit/endpoints/page/subredditWiki.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/SubredditWiki.json");
			const o = (e, t) => Object(s.a)(e, {
				...r,
				variables: t
			})
		},
		"./src/reddit/endpoints/post/convert.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts"),
				a = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				d = n("./src/reddit/models/PostCreationForm/index.ts");
			t.a = (e, t, n) => {
				const c = {
					output_mode: "markdown" === t ? t : "rtjson"
				};
				return t === d.i.MARKDOWN ? c.richtext_json = n : c.markdown_text = n, Object(r.a)(Object(o.a)(e, [i.a]), {
					endpoint: Object(a.a)(`${e.apiUrl}/api/convert_rte_body_format`),
					method: s.ob.POST,
					data: c
				})
			}
		},
		"./src/reddit/endpoints/post/create.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return x
			})), n.d(t, "f", (function() {
				return E
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "b", (function() {
				return C
			})), n.d(t, "a", (function() {
				return A
			}));
			var s = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts"),
				d = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				c = n("./src/reddit/helpers/flair.ts"),
				l = n("./src/reddit/helpers/name/index.ts"),
				u = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				m = n("./src/reddit/models/Poll/index.ts"),
				p = n("./src/reddit/models/Post/index.ts"),
				b = n("./src/reddit/models/PostCreationForm/index.ts"),
				f = n("./src/reddit/models/RichTextJson/addRTJParam.ts");

			function h(e) {
				return Math.floor(e.valueOf() / 1e3)
			}
			const g = e => {
					switch (e.kind) {
						case b.p.CROSSPOST:
							return b.p.CROSSPOST;
						case b.p.LINK:
							return b.p.LINK;
						case b.p.POLL:
							return b.p.POLL;
						case b.p.MEDIA:
							return e.makeGif ? b.p.VIDEO_GIF : e.mediaType;
						default:
							return "self"
					}
				},
				v = e => {
					switch (e.kind) {
						case b.p.RICH_TEXT:
							return {
								richtext_json: JSON.stringify({
									document: e.document
								})
							};
						case b.p.MARKDOWN:
							return {
								text: e.markdown
							};
						case b.p.LINK:
						case b.p.MEDIA:
							return {
								url: e.url
							};
						case b.p.CROSSPOST:
							return {
								crosspost_fullname: e.sourcePostId
							};
						case b.p.POLL:
							return e.poll.type === m.a.Prediction ? {
								duration: 999999,
								end_timestamp: h(e.poll.endDate),
								options: e.poll.options.map(e => e.text),
								prediction: !0,
								text: e.markdown,
								raw_rtjson: "markdown" in e ? null : JSON.stringify({
									document: e.document
								})
							} : {
								duration: Math.floor(e.poll.duration / 864e5),
								options: e.poll.options.map(e => e.text),
								text: e.markdown,
								raw_rtjson: "markdown" in e ? null : JSON.stringify({
									document: e.document
								})
							}
					}
				},
				x = e => {
					const t = Object(l.i)(e.destSubreddit.name);
					return {
						...e.destSubreddit.isProfile ? {
							sr: `u_${t}`,
							submit_type: "profile"
						} : {
							sr: t,
							submit_type: "subreddit"
						},
						api_type: "json",
						show_error_list: !0,
						draft_id: e.draftId || void 0,
						title: e.title,
						discussion_type: e.isChatPost ? p.b.Chat : void 0,
						spoiler: e.isSpoiler,
						nsfw: e.isNSFW,
						recaptcha_token: e.reCaptchaEnterpriseToken,
						...e.kind !== b.p.POLL ? {
							kind: g(e),
							original_content: e.isOC
						} : {},
						post_to_twitter: e.postToTwitter,
						sendreplies: e.sendReplies,
						...e.gRecaptchaResponse ? {
							"g-recaptcha-response": e.gRecaptchaResponse
						} : {},
						resubmit: e.resubmit,
						...v(e),
						...e.kind === b.p.MEDIA && "video" === e.mediaType ? {
							video_poster_url: e.videoThumbnailUrl
						} : {},
						...e.kind === b.p.MEDIA && e.makeGif ? {
							make_gif: "on"
						} : {},
						...e.flair ? {
							flair_id: e.flair.templateId,
							flair_text: Object(c.g)(e.flair)
						} : {},
						...e.validate_on_submit ? {
							validate_on_submit: e.validate_on_submit
						} : {},
						...e.eventSchedule && {
							event_start: e.eventSchedule.startDate,
							event_end: e.eventSchedule.endDate,
							event_tz: e.eventSchedule.timezoneName,
							unlist: e.eventSchedule.submitTime === b.j.AtEventTime
						},
						...e.collectionId && {
							collection_id: e.collectionId
						}
					}
				},
				E = e => {
					const t = /comments\/(\w+)\/.*$/.exec(e),
						n = t && t[1];
					return n ? `${r.Ob.Post}_${n}` : ""
				},
				O = async (e, t) => {
					if (!e.ok) return Object(u.b)(e);
					const n = e.body.json.data;
					let r = n.url;
					r || t.kind !== b.p.MEDIA || (r = await ((e, t) => new Promise(n => {
						const s = new WebSocket(e),
							r = e => {
								s.close(), clearTimeout(o), n(e)
							},
							o = setTimeout(() => {
								r("")
							}, t);
						s.onmessage = e => {
							const t = JSON.parse(e.data),
								n = "success" === t.type ? t.payload.redirect : "";
							r(n)
						}, s.onerror = e => {
							r("")
						}
					}))(n.websocket_url, 3e4));
					const o = n.id || E(r),
						i = Object(s.parse)(r).path,
						a = n.drafts_count;
					return {
						...e,
						body: {
							id: o,
							path: i,
							draftsCount: a
						}
					}
				}, C = (e, t) => Object(o.a)(Object(i.a)(e, [a.a]), {
					endpoint: Object(f.a)(Object(d.a)(`${e.apiUrl}/api/submit_poll_post.json?resubmit=true`)),
					method: r.ob.POST,
					data: x(t),
					type: "json"
				}).then(e => O(e, t)), A = (e, t) => Object(o.a)(Object(i.a)(e, [a.a]), {
					endpoint: Object(f.a)(Object(d.a)(`${e.apiUrl}/api/submit_gallery_post.json?resubmit=true`)),
					method: r.ob.POST,
					data: {
						...x(t),
						items: t.galleryItems.map(e => ({
							caption: e.caption,
							outbound_url: e.url,
							media_id: e.assetId
						}))
					},
					type: "json"
				}).then(e => O(e, t));
			t.c = (e, t) => Object(o.a)(Object(i.a)(e, [a.a]), {
				endpoint: Object(f.a)(Object(d.a)(`${e.apiUrl}/api/submit?resubmit=true`)),
				method: r.ob.POST,
				data: x(t)
			}).then(async e => await O(e, t))
		},
		"./src/reddit/endpoints/post/draft/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return m
			}));
			var s = n("./src/reddit/helpers/flair.ts"),
				r = n("./src/reddit/models/PostDraft/index.ts");
			const o = e => ({
					id: e.json.data.id,
					draftsCount: e.json.data.drafts_count
				}),
				i = e => e.destSubreddit.id ? {
					subreddit: e.destSubreddit.id,
					target: e.destSubreddit.isProfile ? "profile" : "subreddit"
				} : {},
				a = e => {
					switch (e.kind) {
						case r.b.Link:
							return "link";
						case r.b.Markdown:
							return "markdown";
						case r.b.RichText:
							return "richtext";
						default:
							return "self"
					}
				},
				d = e => {
					switch (e) {
						case "link":
							return r.b.Link;
						case "markdown":
							return r.b.Markdown;
						case "richtext":
							return r.b.RichText;
						default:
							return "self"
					}
				},
				c = e => e.title.substring(0, 300),
				l = e => {
					switch (e.kind) {
						case r.b.Link:
						case r.b.Markdown:
							return e.body;
						case r.b.RichText:
							return JSON.stringify({
								document: e.body
							})
					}
				},
				u = e => e ? {
					flair_id: e.templateId || null,
					flair_text: Object(s.g)(e) || null,
					flair_text_color: e.textColor || null,
					flair_background_color: e.backgroundColor || null
				} : {
					flair_id: null,
					flair_text: null,
					flair_text_color: null,
					flair_background_color: null
				},
				m = e => ({
					id: e.draftId || void 0,
					...i(e),
					kind: a(e),
					title: c(e),
					body: l(e),
					spoiler: e.isSpoiler,
					nsfw: e.isNSFW,
					original_content: e.isOC,
					...u(e.flair),
					send_replies: e.sendReplies,
					is_public_link: e.isPublicLink
				})
		},
		"./src/reddit/endpoints/redditor/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/lib/makeRequest/index.ts"),
				o = n("./src/redditGQL/operations/RedditorIdByName.json"),
				i = n("./src/redditGQL/operations/RedditorNameById.json");
			const a = async (e, t) => {
				var n;
				const i = await Object(s.a)(e, {
					...o,
					variables: t
				});
				return Object(r.c)(i) && (null === (n = i.body.data.redditorInfoByName) || void 0 === n ? void 0 : n.id) || null
			}, d = async (e, t) => {
				const n = await Object(s.a)(e, {
					...i,
					variables: t
				});
				return Object(r.c)(n) && n.body.data.redditorInfoById.name || null
			}
		},
		"./src/reddit/endpoints/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return u
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "a", (function() {
				return C
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/reddit/helpers/flair.ts"),
				o = n("./src/reddit/helpers/richTextJson/index.ts"),
				i = n("./src/reddit/models/Post/index.ts"),
				a = n("./src/reddit/models/PostCreationForm/index.ts"),
				d = n("./src/reddit/models/ScheduledPost/index.ts"),
				c = n("./src/redditGQL/operations/CreateScheduledPost.json"),
				l = n("./src/redditGQL/operations/SubredditScheduledPosts.json");
			const u = (e, t) => Object(s.a)(e, {
					...l,
					variables: {
						...t,
						includeRecurring: !(!t.includeRecurring || !t.includeRecurring.recurringFirst),
						includeStandalone: !(!t.includeStandalone || !t.includeStandalone.standaloneFirst),
						recurringAfter: t.includeRecurring ? t.includeRecurring.recurringAfter : void 0,
						recurringFirst: t.includeRecurring ? t.includeRecurring.recurringFirst : void 0,
						standaloneAfter: t.includeStandalone ? t.includeStandalone.standaloneAfter : void 0,
						standaloneFirst: t.includeStandalone ? t.includeStandalone.standaloneFirst : void 0
					}
				}),
				m = (e, t) => {
					if (!e.ok || !e.body) return !1;
					const n = e.body;
					return !!(n.data && n.data.subredditInfoById && n.data.subredditInfoById.scheduledPosts && n.data.subredditInfoById.scheduledPosts[t] && n.data.subredditInfoById.scheduledPosts[t].edges)
				},
				p = (e, t) => !(!e.ok || !e.body) && (!(t.includeStandalone && !(e => m(e, d.g.standalonePosts))(e)) && !(t.includeRecurring && !(e => m(e, d.g.recurringPosts))(e))),
				b = e => {
					let {
						poll: t,
						schedule: n,
						submission: s,
						subredditId: o
					} = e;
					return {
						collectionId: s.collectionId || "",
						discussionType: s.isChatPost ? i.b.Chat : i.b.Comment,
						isContestMode: s.isContestMode,
						isPostAsMetaMod: s.isPostAsMetaMod,
						isSpoiler: s.isSpoiler,
						isNsfw: s.isNSFW,
						poll: t && O(t),
						title: s.title,
						isOriginalContent: s.isOC,
						flair: s.flair ? {
							id: s.flair.templateId,
							text: Object(r.g)(s.flair)
						} : {},
						sticky: s.sticky,
						subredditId: o,
						suggestedCommentSort: s.suggestedSort,
						isSendReplies: s.sendReplies,
						...f(n),
						...x(s),
						assetIds: E(s)
					}
				},
				f = e => ({
					scheduling: {
						publishAt: e.submitDate,
						clientTimezone: e.timezoneName,
						frequency: e.recurrenceInfo ? e.recurrenceInfo.frequency : void 0,
						interval: e.recurrenceInfo ? e.recurrenceInfo.interval : void 0,
						byMonthDays: e.recurrenceInfo ? e.recurrenceInfo.byMonthDays : void 0,
						byWeekDays: e.recurrenceInfo ? e.recurrenceInfo.byWeekDays : void 0
					}
				}),
				h = e => ({
					scheduling: Object.keys(e).length > 0 ? {
						clientTimezone: e.timezoneName || void 0,
						publishAt: e.submitDate || void 0,
						frequency: e.recurrenceInfo ? e.recurrenceInfo.frequency : void 0,
						interval: e.recurrenceInfo ? e.recurrenceInfo.interval : void 0,
						byMonthDays: e.recurrenceInfo ? e.recurrenceInfo.byMonthDays : void 0,
						byWeekDays: e.recurrenceInfo ? e.recurrenceInfo.byWeekDays : void 0
					} : void 0
				}),
				g = e => {
					let {
						poll: t,
						schedule: n,
						scheduledPostId: s,
						submission: r,
						subredditId: o
					} = e;
					const i = b({
						poll: t,
						schedule: n,
						submission: r,
						subredditId: o
					});
					return {
						id: s,
						...i,
						flair: Object.keys(i.flair || {}).length ? {
							...i.flair
						} : {
							id: "",
							text: ""
						}
					}
				},
				v = e => /^https?:\/\//i.test(e) ? e : `http://${e}`,
				x = e => {
					switch (e.kind) {
						case a.p.RICH_TEXT:
							return {
								content: {
									richText: JSON.stringify({
										document: e.document
									})
								}
							};
						case a.p.MARKDOWN:
							return {
								content: {
									markdown: e.markdown
								}
							};
						case a.p.LINK:
							return {
								content: {}, link: {
									url: v(e.url)
								}
							};
						default:
							return {
								content: {}
							}
					}
				},
				E = e => {
					let t = [];
					if (e.document) {
						const n = e.document || [];
						t = Object(o.d)(n)
					}
					return t
				},
				O = e => {
					if (e && e.options && e.duration && (e.options = e.options.map(e => ({
							text: e.text.trim()
						})).filter(e => !!e.text), e.options.length)) return e.duration = Math.floor(e.duration / 864e5), e
				},
				C = (e, t) => Object(s.a)(e, {
					...c,
					variables: {
						input: t
					}
				})
		},
		"./src/reddit/endpoints/scheduledPosts/update.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/redditGQL/operations/UpdateScheduledPost.json"),
				r = n("./src/lib/makeGqlRequest/index.ts");
			const o = (e, t) => Object(r.a)(e, {
				...s,
				variables: {
					input: t
				}
			})
		},
		"./src/reddit/endpoints/subreddit/about.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/SubredditAbout.json");
			t.a = (e, t, n) => Object(s.a)(e, {
				...r,
				variables: {
					subredditName: t,
					includeSubreddit: n
				}
			})
		},
		"./src/reddit/endpoints/subreddit/notificationSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/redditGQL/operations/FetchSubredditsNotificationSettings.json"),
				r = n("./src/redditGQL/operations/UpdateSubredditNotificationSettings.json"),
				o = n("./src/lib/makeGqlRequest/index.ts");
			const i = (e, t) => Object(o.a)(e, {
					...s,
					variables: {
						subredditIds: [t]
					}
				}),
				a = (e, t, n) => Object(o.a)(e, {
					...r,
					variables: {
						input: {
							...n,
							subredditId: t
						}
					}
				})
		},
		"./src/reddit/endpoints/subreddit/rules.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return h
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "a", (function() {
				return x
			})), n.d(t, "f", (function() {
				return E
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "e", (function() {
				return A
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/camelCase.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/mapKeys.js"),
				i = n.n(o),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/makeGqlRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/redditGQL/operations/SubredditRules.json"),
				m = n("./src/reddit/constants/headers.ts"),
				p = n("./src/reddit/helpers/graphql/normalizeSubredditRulesFromGql/index.ts"),
				b = n("./src/reddit/models/Rule/index.ts");
			const f = e => {
					let {
						rules: t
					} = e;
					return {
						rules: t.map(e => ({
							...i()(e, (e, t) => r()(t)),
							kind: "link" === e.kind ? "post" : e.kind
						}))
					}
				},
				h = (e, t) => Object(c.a)(e, {
					...u,
					variables: {
						subredditName: t
					}
				}).then(e => {
					var t, n, s;
					return e.ok && e.body && (e => Object.keys(e).length > 0)(e.body) && (null === (s = null === (n = null === (t = e.body) || void 0 === t ? void 0 : t.data) || void 0 === n ? void 0 : n.subreddit) || void 0 === s ? void 0 : s.rules) ? e.body = Object(p.a)(e.body.data.subreddit.rules) : e.body = {
						rules: []
					}, e
				}),
				g = (e, t) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/user/${t}/about/rules.json`,
					method: a.ob.GET
				}).then(e => (e.ok && e.body.rules && (e.body = f(e.body)), e)),
				v = e => e.ok ? (e.body = Object(b.h)(JSON.parse(e.body.json.data.rules)), e) : e.body,
				x = async (e, t, n) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/add_subreddit_rule`,
					method: a.ob.POST,
					data: {
						r: t,
						short_name: n.rule,
						kind: n.kind === b.b.post ? "link" : n.kind,
						violation_reason: n.reason,
						description: n.description,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => v(e)), E = async (e, t, n, s) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/update_subreddit_rule`,
					method: a.ob.POST,
					data: {
						r: t,
						short_name: n.rule,
						kind: n.kind === b.b.post ? "link" : n.kind,
						violation_reason: n.reason,
						description: n.description,
						old_short_name: s,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => v(e)), O = async (e, t, n) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/remove_subreddit_rule`,
					method: a.ob.POST,
					data: {
						r: t,
						short_name: n,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => v(e)), C = e => e.map(e => encodeURIComponent(e)).join(), A = async (e, t, n) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/reorder_subreddit_rules`,
					method: a.ob.POST,
					data: {
						r: t,
						new_rule_order: C(n),
						api_type: "json",
						raw_json: 1
					}
				}).then(e => v(e))
		},
		"./src/reddit/endpoints/subreddit/subscriptions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			}));
			var s = n("./src/redditGQL/operations/SubscribedSubreddits.json"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			t.a = e => Object(i.a)(e, s);
			const l = (e, t) => {
					let {
						subredditIds: n,
						subredditNames: s,
						subscribe: i
					} = t;
					return Object(o.a)(Object(a.a)(e, [d.a]), {
						method: r.ob.POST,
						endpoint: Object(c.a)(`${e.apiUrl}/api/subscribe`),
						data: {
							action: i ? "sub" : "unsub",
							sr: n && n.join(",") || void 0,
							sr_name: s && s.join(",") || void 0,
							api_type: "json"
						}
					})
				},
				u = (e, t, n) => Object(o.a)(Object(a.a)(e, [d.a]), {
					method: r.ob.POST,
					endpoint: `${e.apiUrl}/api/favorite`,
					data: {
						make_favorite: n ? "true" : "false",
						sr_name: t,
						api_type: "json"
					}
				})
		},
		"./src/reddit/endpoints/subredditModeration/doesUserHavePostPermission.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/DoesUserHavePostModPermission.json");
			const o = (e, t) => Object(s.a)(e, {
				...r,
				variables: t
			})
		},
		"./src/reddit/endpoints/subredditModeration/moderationLog.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/AllModerators.json"),
				o = n("./src/redditGQL/operations/FetchModerationLogActions.json"),
				i = n("./src/redditGQL/operations/ModerationActionCategories.json");
			const a = (e, t) => Object(s.a)(e, {
					...r,
					variables: {
						subredditName: t
					}
				}),
				d = (e, t, n) => Object(s.a)(e, {
					...o,
					variables: {
						subredditName: t,
						...n
					}
				}),
				c = e => Object(s.a)(e, {
					...i,
					variables: {}
				})
		},
		"./src/reddit/featureFlags/component.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/featureFlags/index.ts");

			function d(e, t, n) {
				const s = Object(i.c)({
					featureEnabled: t => a.d[e](t)
				});
				return Object(o.b)(s)(e => {
					const {
						featureEnabled: s,
						...o
					} = e, i = o;
					return s ? r.a.createElement(t, i) : void 0 !== n ? r.a.createElement(n, i) : null
				})
			}
		},
		"./src/reddit/helpers/addSupplementaryTextInfoToAdPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/reddit/endpoints/post/convert.ts"),
				r = n("./src/reddit/models/Post/index.ts"),
				o = n("./src/reddit/selectors/experiments/supportingLinkAds.ts");
			const i = e => !(!Object(r.B)(e) || !e.adSupplementaryText || "string" != typeof e.adSupplementaryText),
				a = async (e, t) => {
					try {
						const n = await Object(s.a)(e, "rtjson", t.adSupplementaryText);
						return {
							...t,
							adSupplementaryText: n.body.output
						}
					} catch (n) {
						return t
					}
				}, d = async (e, t, n) => {
					if (!Object(o.a)(n) || !t) return t;
					const s = {};
					for (const [r, o] of Object.entries(t)) s[r] = i(o) ? await a(e, o) : o;
					return s
				}
		},
		"./src/reddit/helpers/ads/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = (e, t) => {
					if (null == e ? void 0 : e.instanceId) return e.instanceId;
					if (null == e ? void 0 : e.impressionid) {
						return t.impressionMap[e.impressionid]
					}
					return null
				},
				r = (e, t, n) => {
					const s = new URLSearchParams;
					return s.append("p", "1"), n ? s.append("impressionid", encodeURIComponent(n)) : s.append("instanceId", encodeURIComponent(t)), `${e}?${s.toString()}`
				}
		},
		"./src/reddit/helpers/author.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => !!e && e.endsWith("-ModTeam")
		},
		"./src/reddit/helpers/awards/isEligibleForCommunityAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/reddit/models/Subreddit/index.ts");
			const r = new Set(["goins", "gold_testing", "inthesoulstone", "lounge", "lssgoldnormal", "maymodsguide1", "maymodsguide2", "megalounge", "pan2", "pan3", "venkman_bookclub", "whatssnoo", "translation_piglatin", "translation_pirate", "translation_initials", "translation_german", "translation_british", "translation_french_fr", "translation_es_mx", "translation_br_pt", "german_translation", "lssgoldnormal_13", "test_automation_001"]),
				o = new Set([s.g.Private, s.g.User]),
				i = e => !(!e || !e.name) && (!!r.has(e.name.toLowerCase()) || !e.isNSFW && !e.isQuarantined && !o.has(e.type));
			t.a = i
		},
		"./src/reddit/helpers/awards/isEligibleForGlobalAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const s = new Set(["t5_22cerq"]),
				r = e => s.has(e);
			t.a = r
		},
		"./src/reddit/helpers/awards/isEligibleForTemporaryAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const s = new Set(["t5_q0gj4", "t5_z5gli", "t5_22cerq", "t5_3j0kj"]),
				r = e => s.has(e)
		},
		"./src/reddit/helpers/brandSafety/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/models/WhitelistStatus/index.ts");
			const r = (e, t) => {
				const n = e.some(e => e.isNSFW),
					r = t.some(e => e.wls === s.b.NO_ADS);
				return !n && !r
			}
		},
		"./src/reddit/helpers/canAccessModerationPage/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/models/Subreddit/index.ts");
			t.a = e => {
				let {
					pageName: t,
					moderatorPermissions: n,
					canCreateScheduledPosts: o,
					isEmployee: i,
					isTalkHostsEnabled: a,
					subredditType: d,
					isContributor: c
				} = e;
				switch (t) {
					case s.mc.Awards:
						return !!n;
					case s.mc.SubredditRules:
					case s.mc.Moderators:
						return !0;
					case s.mc.Modlog:
						return !!n;
					case s.mc.Muted:
						return !!(n && n.access && n.mail);
					case s.mc.Banned:
						return !(!n || !n.access);
					case s.mc.Contributors:
						return !!(n && n.access || d === r.g.Restricted || d === r.g.Private && c);
					case s.mc.Flair:
					case s.mc.PostFlair:
					case s.mc.UserFlair:
						return !(!n || !n.flair);
					case s.mc.CommunitySettings:
						return !(!n || !n.config);
					case s.mc.Modqueue:
					case s.mc.Reports:
					case s.mc.Edited:
					case s.mc.Spam:
					case s.mc.Unmoderated:
					case s.mc.ContentControls:
					case s.mc.Removal:
						return !(!n || !n.posts);
					case s.mc.Badges:
					case s.mc.Emojis:
						return !!n;
					case s.mc.Emotes:
						return !(!n || !n.config);
					case s.mc.Wiki:
					case s.mc.WikiBanned:
					case s.mc.WikiContributors:
						return !(!n || !n.wiki);
					case s.mc.Traffic:
						return i || !!n;
					case s.mc.EventPostContent:
					case s.mc.ScheduledPostContent:
						return !!o;
					case s.mc.Predictions:
						return !(!n || !n.posts);
					case s.mc.TalkHosts:
						return !!a && !!n;
					default:
						return !1
				}
			}
		},
		"./src/reddit/helpers/comment/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return c
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				r = n("./src/lib/addQueryParams/index.ts"),
				o = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				i = n("./src/reddit/constants/things.ts"),
				a = n("./src/reddit/models/Upload/index.ts"),
				d = n("./src/reddit/models/Vote/index.ts");
			const c = (e, t) => e.rteState ? o.a.toRichTextJSON(e.rteState, t) : e.rtJson || e.text,
				l = (e, t) => {
					let n = [];
					return e.rteState ? n = o.a.toRichTextJSON(e.rteState, t).document : e.rtJson && (n = e.rtJson.document), {
						document: n
					}
				},
				u = (e, t) => JSON.stringify(l(e, t));

			function m() {
				return `${i.a}_${Object(s.a)()}`
			}

			function p(e) {
				let {
					temporalId: t,
					draft: n,
					post: s,
					author: r,
					subredditId: o,
					parentId: i
				} = e;
				return {
					id: t,
					postId: s.postId,
					subredditId: o,
					author: r.displayText || "",
					authorId: r.id,
					collapsed: !1,
					collapsedBecauseCrowdControl: null,
					created: Math.floor(Date.now() / 1e3),
					distinguishType: null,
					ignoreReports: !1,
					isAdmin: !1,
					isApproved: !1,
					isDeleted: !1,
					isGildable: !1,
					isLocked: !1,
					isMod: !1,
					isOp: !1,
					isRemoved: !1,
					isScoreHidden: !1,
					isSpam: !1,
					isStickied: !1,
					isSaved: !1,
					isSystem: !1,
					media: {
						type: "rtjson",
						rteMode: n.commentMode,
						richtextContent: l(n)
					},
					parentId: i,
					permalink: "",
					postAuthor: s.author,
					postTitle: null,
					score: 1,
					sendReplies: !1,
					modReports: [],
					numReports: 0,
					voteState: d.a.notVoted,
					userReports: []
				}
			}

			function b(e, t) {
				for (const n of Object.keys(t)) {
					const s = t[n],
						r = s.url ? Object(a.b)(s.url) : null;
					if (r && e.includes(r)) return s
				}
				return null
			}
			const f = (e, t) => t ? Object(r.a)(e, {
				depth: t
			}) : e
		},
		"./src/reddit/helpers/commentList/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/reddit/constants/comments.ts"),
				r = n("./src/reddit/selectors/comments.ts"),
				o = n("./src/reddit/constants/experiments.ts"),
				i = n("./src/reddit/helpers/chooseVariant/index.ts");
			const a = (e, t) => t().features.comments.models[e],
				d = e => {
					switch (e.commentLink.type) {
						case s.a.Comment:
							return e.commentsDict[e.commentLink.id];
						case s.a.MoreComments:
							return e.moreCommentsDict[e.commentLink.id];
						case s.a.ContinueThread:
							return e.continueThreadDict[e.commentLink.id]
					}
				},
				c = (e, t) => e.type === s.a.MoreComments ? t[e.id].numComments : 1,
				l = (e, t, n, s) => {
					let o = Object(r.n)(s, {
							commentLink: t,
							commentsPageKey: e
						}),
						i = t;
					for (; o && o.depth > n && o.prev && (i = o.prev, (o = Object(r.n)(s, {
							commentLink: i,
							commentsPageKey: e
						})) && !(o.depth <= n)););
					return i.id
				},
				u = (e, t, n) => {
					const {
						commentLists: s,
						comments: r
					} = e, {
						head: a
					} = s[t];
					if (a) return Object.keys(r).filter(e => {
						const t = r[e];
						return !(!t.isStickied || !((e, t) => {
							const n = Object(i.c)(e, {
								experimentEligibilitySelector: i.a,
								experimentName: o.H,
								expEventOverride: t
							});
							return !!(Object(o.Kg)(n) ? void 0 : n)
						})(n)) || (e => !1 !== e.collapsed)(t)
					})
				}
		},
		"./src/reddit/helpers/counters/onboarding.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/sample/index.ts"),
				o = n("./src/telemetry/helpers/sendCounter.ts");
			const i = (e, t) => {
					Object(o.b)(s.n.Redesign, {
						type: o.a.GenderCollection,
						data: {
							gender: e,
							submitSuccess: t
						}
					})
				},
				a = (e, t) => {
					Object(r.b)(10) && Object(o.b)(s.n.Redesign, {
						type: o.a.ReonboardingFlow,
						data: {
							type: e,
							variant: t
						}
					})
				}
		},
		"./src/reddit/helpers/crypto/vaultActionLink.ts": function(e, t, n) {
			"use strict";

			function s(e) {
				return e.match(/^https:\/\/www\.reddit\.com\/vault\/burn/)
			}

			function r(e) {
				const {
					subreddit: t,
					amount: n,
					memo: s,
					cta: r
				} = e;
				return t && n && s && r ? {
					subreddit: t,
					amount: n,
					memo: s,
					cta: r
				} : (console.error("subreddit, amount, and memo query params required for vault action"), null)
			}
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}))
		},
		"./src/reddit/helpers/dom/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/lodash/map.js"),
				r = n.n(s),
				o = n("./src/lib/FocusTrap/index.ts");
			const i = () => {
					const e = document.getSelection();
					return !!e && (e.rangeCount > 0 && e.getRangeAt(0).toString().length > 0)
				},
				a = () => i() ? (() => {
					const e = document.getSelection();
					if (!e) return [];
					const t = e.getRangeAt(0).cloneContents().childNodes;
					return r()(t, e => e.textContent || "")
				})() : null,
				d = (e, t) => {
					const n = document.createRange();
					return n.selectNode(t), e.compareBoundaryPoints(Range.END_TO_START, n) < 0 && e.compareBoundaryPoints(Range.START_TO_END, n) > 0
				},
				c = e => {
					const t = window.getSelection();
					if (1 !== t.rangeCount) return;
					const n = t.getRangeAt(0);
					if (!d(n, e)) return;
					const {
						startContainer: s,
						startOffset: r,
						endContainer: o,
						endOffset: i
					} = n, a = document.createRange();
					a.selectNode(e);
					let c = !0;
					if (-1 === a.compareBoundaryPoints(Range.START_TO_START, n) && (a.setStart(s, r), c = !1), 1 === a.compareBoundaryPoints(Range.END_TO_END, n) && (a.setEnd(o, i), c = !1), c) return [e];
					const l = document.createElement("div");
					return l.appendChild(a.cloneContents()), [...l.childNodes]
				},
				l = (e, t, n) => {
					let s = e;
					for (; s && (!n || !n(s));) {
						if (s && t(s)) return s;
						s = s.parentElement
					}
				},
				u = e => e && e.parentElement && l(e.parentElement, e => "static" !== window.getComputedStyle(e).getPropertyValue("position")),
				m = e => {
					e.querySelectorAll(o.a).forEach(e => {
						e.tabIndex = -1
					})
				}
		},
		"./src/reddit/helpers/dragDropContext/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-dnd/lib/index.js"),
				r = n("./node_modules/react-dnd-html5-backend/lib/index.js"),
				o = n.n(r);
			t.a = Object(s.DragDropContext)(o.a)
		},
		"./src/reddit/helpers/economics/sortBadges.ts": function(e, t, n) {
			"use strict";

			function s(e, t) {
				if (e.placement && !t.placement) return -1;
				if (t.placement && !e.placement) return 1;
				if (e.position && !t.position) return -1;
				if (t.position && !e.position) return 1;
				let n = 0;
				return e.placement && t.placement && (n = e.placement.localeCompare(t.placement)), 0 === n && e.position && t.position && (n = e.position - t.position), 0 === n && (n = e.title.localeCompare(t.title)), n
			}

			function r(e) {
				return [...e].sort(s)
			}
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}))
		},
		"./src/reddit/helpers/filterListingResponse/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/findLastIndex.js"),
				r = n.n(s),
				o = n("./src/reddit/models/WhitelistStatus/index.ts"),
				i = n("./src/reddit/selectors/telemetry.ts"),
				a = n("./src/telemetry/index.ts");
			const d = (e, t) => {
				let {
					subreddits: n,
					profiles: s
				} = t;
				const r = n[e.belongsTo.id] || s[e.belongsTo.id];
				return !e.isNSFW && r && o.a.has(r.wls || o.b.NO_ADS)
			};
			t.a = (e, t, n) => {
				let {
					postIds: s,
					posts: o,
					subreddits: c,
					profiles: l,
					...u
				} = n;
				const m = e.listings.postOrder.ids[t],
					p = (s || []).filter(e => !m || !m.includes(e)),
					b = m.map(t => e.posts.models[t]),
					f = b.length - (r()(b, e => e.isSponsored) + 1),
					h = p.map(e => o[e]);
				let g;
				const v = [],
					x = {
						subreddits: c,
						profiles: l
					};
				for (let r = 0; r < h.length; r++) {
					const n = h[r];
					let s = !1;
					if (n.isSponsored) {
						const e = r > 0 && h[r - 1],
							t = r < h.length - 1 && h[r + 1];
						e && d(e, x) && t && d(t, x) && (s = !0)
					}
					n.isSponsored && s && (null == g && f + r >= 3 || r - g >= 3) ? (g = r, v.push(n.id)) : n.isSponsored ? n.isSponsored && Object(a.a)({
						source: "feed",
						action: "remove",
						noun: "ad",
						...i.p(e),
						listing: i.A(e, t)
					}) : v.push(n.id)
				}
				return {
					...u,
					subreddits: c,
					profiles: l,
					posts: o,
					postIds: v
				}
			}
		},
		"./src/reddit/helpers/genericServerError/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts");
			t.a = () => ({
				type: r.K.SERVER_ERROR,
				fields: [{
					field: "",
					msg: s.fbt._("Something went wrong.", null, {
						hk: "RcX5A"
					})
				}]
			})
		},
		"./src/reddit/helpers/getPostLimitForMobile/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/constants/postLayout.ts");

			function r(e) {
				return e ? s.c[e] : s.f
			}
		},
		"./src/reddit/helpers/getSubredditErrorProps/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/models/ContentGate.ts");
			t.a = (e, t, n) => {
				let r, o, i, a, d, c, l, u, m, p, b, f;
				return e ? e.quarantinedSubreddit ? (i = s.a.QuarantinedSubreddit, d = e.quarantineMessage, c = e.quarantineMessageHtml, l = e.quarantineRequiresEmail) : e.privateSubreddit ? (i = s.a.PrivateSubreddit, a = e.subredditDescription, u = e.isContributorRequestsDisabled, m = e.isContributorRequestTimestamp) : e.goldSubreddit ? i = s.a.GoldSubreddit : e.subredditBanned ? (i = s.a.SubredditBanned, r = e.subredditBanMessage, o = e.subredditBanTitle) : e.subredditDoesNotExist ? i = s.a.SubredditDoesNotExist : e.subredditBlockedForLegalReason ? i = s.a.SubredditBlockedForLegalReason : e.interstitialWarningMessage && (i = s.a.GatedSubreddit, p = e.interstitialWarningMessage, b = e.interstitialWarningMessageHtml, f = e.interstitialWarningMessageRTJson) : t && (i = s.a.Nsfw), i && n ? {
					banMessage: r,
					banTitle: o,
					contentGateType: i,
					isContributorRequestsDisabled: u,
					isContributorRequestTimestamp: m,
					subredditDescription: a,
					subredditName: n,
					quarantineMessage: d,
					quarantineMessageHtml: c,
					quarantineRequiresEmail: l,
					interstitialWarningMessage: p,
					interstitialWarningMessageHtml: b,
					interstitialWarningMessageRTJson: f
				} : void 0
			}
		},
		"./src/reddit/helpers/getTimeSortForListing/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/listingSort/index.ts");
			t.a = (e, t) => {
				if (e) return Object(r.a)(e) ? t || s.pc : void 0
			}
		},
		"./src/reddit/helpers/governanceErrorText/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js");

			function r(e) {
				return e[0].toUpperCase() + e.slice(1)
			}

			function o(e) {
				return "extra" in e ? "string" == typeof e.extra ? e.extra : Object.keys(e.extra).map(t => e.extra[t]).map(r).join(" ") : s.fbt._("Something went wrong. Please try again later.", null, {
					hk: "16ibYk"
				})
			}

			function i(e) {
				const t = `${e.type} (${e.code})`;
				return "message" in e ? `${t}: ${e.message}` : t
			}
		},
		"./src/reddit/helpers/graphql/normalizeChannelsFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => {
				const t = [],
					n = {},
					s = (e, t, n) => {
						for (const r of e) {
							if (!r) continue;
							const e = r.node;
							if (!e) continue;
							if (e.channels) {
								s(e.channels.edges, t, n);
								continue
							}
							const o = e.id;
							t.push(o), n[o] = e
						}
					};
				return s(e.edges, t, n), {
					channelIds: t,
					channels: n
				}
			}
		},
		"./src/reddit/helpers/graphql/normalizeDoesUserHavePostModPermissionQuery/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => {
				var t, n, s, r, o, i;
				return "__typename" in e && "Query" === e.__typename && "Subreddit" === (null === (t = e.subredditInfoByName) || void 0 === t ? void 0 : t.__typename) && ((null === (n = e.subredditInfoByName.moderatorMembers) || void 0 === n ? void 0 : n.edges) || []).length > 0 && !0 === (null === (i = null === (o = null === (r = null === (s = e.subredditInfoByName.moderatorMembers) || void 0 === s ? void 0 : s.edges[0]) || void 0 === r ? void 0 : r.node) || void 0 === o ? void 0 : o.modPermissions) || void 0 === i ? void 0 : i.isPostEditingAllowed)
			}
		},
		"./src/reddit/helpers/graphql/normalizeInterestTopicsFromGql/index.ts": function(e, t, n) {
			"use strict";
			const s = e => ({
				id: e.id,
				name: e.name,
				topic: e.title,
				children: e.isRoot ? [] : null
			});
			t.a = e => (e => {
				let {
					edges: t,
					schemeName: n
				} = e;
				return {
					topics: t.reduce((e, t) => {
						let {
							node: n
						} = t;
						const r = n.topic.parents.map(e => e.nodeId),
							o = r.length <= 0,
							i = n.id,
							a = {
								id: i,
								isRoot: o,
								parents: r,
								title: n.topic.title,
								name: n.topic.name
							};
						return o ? (e.topics.push(s(a)), e.dict[i] = e.topics.length - 1) : r.forEach(t => {
							var n;
							const r = e.dict[t];
							if ("number" == typeof r) {
								null === (n = e.topics[r].children) || void 0 === n || n.push(s(a))
							}
						}), e
					}, {
						topics: [],
						dict: {}
					}).topics,
					schemeName: n
				}
			})(e)
		},
		"./src/reddit/helpers/graphql/normalizeModActivityFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts");
			const r = e => {
				const {
					moderation: t,
					...n
				} = e, {
					lastModAction: r,
					activeModerators: o
				} = (null == t ? void 0 : t.modActivitySummary) || {}, i = [], a = {};
				null == o || o.edges.map(e => {
					if (!(null == e ? void 0 : e.node)) return;
					const {
						lastModAction: t,
						moderator: n
					} = e.node;
					if (!n) return;
					const s = null == n ? void 0 : n.id;
					s && (i.push(s), a[s] || (a[s] = {
						info: {},
						lastModAction: {}
					}), a[s].info = n, a[s].lastModAction = {
						...t
					})
				});
				const d = {
					lastModAction: r,
					activeMods: i
				};
				return {
					subreddit: Object(s.a)(n),
					summary: {
						sub: d,
						mods: a
					}
				}
			}
		},
		"./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/helpers/graphql/helpers.ts");
			const r = e => {
					const t = [];
					for (const {
							node: n
						} of e.edges) {
						const {
							action: e,
							actionCategory: r,
							actionNotes: o,
							createdAt: i,
							details: a,
							id: d,
							moderator: c,
							moderatorInfo: l,
							subredditName: u,
							target: m,
							takedownContentPreview: p
						} = n, b = {
							action: e,
							actionCategory: r,
							actionNotes: o,
							createdAt: Object(s.g)(i),
							details: a,
							id: d,
							moderator: c,
							moderatorInfo: l,
							subredditName: u,
							target: m,
							takedownContentPreview: p
						};
						t.push(b)
					}
					return t
				},
				o = e => {
					const t = [];
					for (const {
							node: n
						} of e.edges) {
						const {
							id: e,
							name: s,
							icon: r
						} = n, o = {
							id: e,
							name: s,
							icon: r
						};
						t.push(o)
					}
					return t
				}
		},
		"./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => ({
				...e.id && {
					id: e.id
				},
				...e.postBackgroundColor && {
					postBackgroundColor: e.postBackgroundColor
				},
				...e.postBackgroundImage && {
					postBackgroundImage: e.postBackgroundImage
				},
				...e.postPlaceholderImage && {
					postPlaceholderImage: e.postPlaceholderImage
				},
				...e.postTitleColor && {
					postTitleColor: e.postTitleColor
				}
			})
		},
		"./src/reddit/helpers/graphql/normalizePostsFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts");
			const r = e => {
				let {
					edges: t
				} = e;
				const n = [];
				for (const {
						node: r
					} of t) n.push(Object(s.f)(r));
				return n
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditLinksFromGql/index.ts": function(e, t, n) {
			"use strict";
			const s = e => ({
				communityIcon: e.styles && e.styles.icon || void 0,
				iconUrl: e.styles && e.styles.legacyIcon && e.styles.legacyIcon.url || void 0,
				id: e.id,
				isNSFW: e.isNSFW || !1,
				isSubscribed: e.isSubscribed,
				name: e.name,
				primaryColor: e.styles && e.styles.primaryColor || void 0,
				subscribers: e.subscribers,
				type: "subreddit"
			});
			t.a = e => {
				var t;
				return {
					subreddits: (null === (t = e.data.subredditInfoById) || void 0 === t ? void 0 : t.linkedSubreddits) ? e.data.subredditInfoById.linkedSubreddits.map(s) : []
				}
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return T
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/assertNever.ts"),
				r = n("./src/lib/env/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = n("./src/reddit/actions/gold/achievementFlairs.ts"),
				a = n("./src/reddit/actions/gold/customEmojis.ts"),
				d = n("./src/reddit/models/Post/index.ts"),
				c = n("./src/reddit/models/RichTextJson/index.ts"),
				l = n("./src/reddit/models/Subreddit/index.ts"),
				u = n("./src/reddit/helpers/ads/index.ts"),
				m = n("./src/reddit/helpers/graphql/normalizeChannelsFromGql/index.ts"),
				p = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				b = n("./src/reddit/helpers/graphql/normalizeInterestTopicsFromGql/index.ts"),
				f = n("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				h = n("./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts"),
				g = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				v = n("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				x = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				E = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				O = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				C = n("./src/reddit/helpers/graphql/normalizeSubredditLinksFromGql/index.ts"),
				A = n("./src/reddit/helpers/graphql/normalizeSubredditModPermissions/index.ts"),
				y = n("./src/reddit/helpers/graphql/normalizeSubredditRulesFromGql/index.ts"),
				j = n("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				I = n("./src/reddit/helpers/graphql/normalizeSubredditTopicLinksFromGql/index.ts"),
				k = n("./src/reddit/helpers/graphql/normalizeSubredditWidgetsFromGql/index.ts"),
				_ = n("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				S = n("./src/reddit/models/Onboarding/index.ts"),
				w = n("./src/reddit/helpers/graphql/helpers.ts");
			const T = (e, t, n, i) => {
				const a = {
						account: null,
						authorFlair: {},
						channelIds: [],
						channels: {},
						interestTopicRecommendations: void 0,
						postIds: [],
						postInstances: {},
						posts: {},
						postFlair: {},
						powerups: {},
						predictionTournaments: null,
						preferences: null,
						profiles: {},
						questions: {},
						recentPostIds: [],
						structuredStyles: {},
						subredditAboutInfo: {},
						subredditLinks: {},
						subredditPermissions: void 0,
						subredditRules: [],
						subreddits: {},
						subredditTopicLinks: void 0,
						token: "",
						trendingSubredditIds: [],
						userFlair: {}
					},
					c = function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						if (Object(d.j)(e) || Object(d.i)(e)) return null;
						if (a.posts[e.id]) return e.id;
						const n = Object(g.f)(e, !0);
						a.posts[n.id] = n;
						const {
							crosspostRoot: l
						} = e;
						l && l.type === d.a.Post && l.postInfo && c(l.postInfo, !0), Object(d.o)(e).forEach(e => c(e, !0));
						let m = n.id;
						if (e.authorFlair && (a.authorFlair[n.belongsTo.id] || (a.authorFlair[n.belongsTo.id] = {}), a.authorFlair[n.belongsTo.id][n.author] = Object(p.a)(e.authorFlair)[0]), Object(d.l)(e)) a.profiles[e.profile.id] || (a.profiles[e.profile.id] = Object(x.a)(e.profile));
						else if (Object(d.n)(e)) a.subreddits[e.subreddit.id] || (a.subreddits[e.subreddit.id] = Object(O.a)(e.subreddit)), a.postFlair[e.subreddit.id] || (a.postFlair[e.subreddit.id] = Object(f.a)(e.subreddit));
						else if (Object(d.h)(e)) {
							const t = Object(g.b)(e),
								s = e.impressionId;
							if (!t) return null;
							m = t;
							const r = Object(u.b)(n.permalink, t, s);
							a.posts[t] = {
								...n,
								id: t,
								permalink: r
							}, a.posts[n.id] || (a.posts[n.id] = {
								...n,
								events: []
							}), a.postInstances[e.id] || (a.postInstances[e.id] = []), a.postInstances[e.id].push(t)
						} else try {
							Object(s.a)(e)
						} catch (h) {
							const t = `Received unhandled element type when processing subreddit posts: "${e.__typename}"`;
							Object(r.b)() || console.warn(t), o.c.captureMessage(t)
						}
						const b = i && i.includes(m);
						return t || !m || b || a.postIds.push(m), m
					};
				if (e.forEach(e => c(e)), t) {
					a.trendingSubredditIds = t.map(e => e.id);
					for (const e of t) a.subreddits[e.id] = Object(O.a)(e)
				}
				const l = a.postIds.length - 1;
				return a.token = l >= 0 ? a.postIds[l] : "", n && (a.account = Object(_.a)(n), a.preferences = n.preferences && Object(v.a)(n.preferences, n.interactions) || null), a
			};
			t.a = e => {
				let {
					adhocMultiredditByNames: t,
					all: n,
					identity: s,
					popular: u,
					recentPosts: f,
					subredditInfoByName: g,
					trendingSubreddits: v
				} = e;
				var x, O, N, D, M, R, L, B, F, U;
				if (!g) return {
					reason: l.f.NotFoundSubreddit,
					data: {
						account: s && Object(_.a)(s) || null
					}
				};
				if (Object(l.k)(g)) {
					const {
						banMessage: e,
						banTitle: t,
						publicDescriptionText: n,
						quarantineMessage: r,
						isEmailRequiredForQuarantineOptin: o,
						interstitialWarningMessage: i
					} = g;
					return {
						reason: P(g.forbiddenReason),
						data: {
							account: s && Object(_.a)(s) || null,
							banMessage: e || void 0,
							banTitle: t || void 0,
							description: n,
							quarantineRequiresEmailOptin: o,
							...r ? {
								quarantineMessage: r.markdown,
								quarantineMessageRTJson: Object(w.h)(r.richtext, c.i)
							} : {},
							interstitialWarningMessage: null == i ? void 0 : i.markdown,
							interstitialWarningMessageRTJson: Object(w.h)(null == i ? void 0 : i.richtext, c.i)
						}
					}
				}
				const H = {},
					G = g.devPlatformMetadata;
				let Q;
				const q = g || u || n || t,
					[W, z] = q.elements.edges.reduce((e, t, n) => {
						var s, r, o, i;
						const [a, c] = e, l = t.node;
						if (Object(d.k)(l)) {
							const e = l;
							e.subreddit = {
								...e.subreddit,
								devPlatformMetadata: G
							}, a.push(l), (null === (r = null === (s = l.flair) || void 0 === s ? void 0 : s.template) || void 0 === r ? void 0 : r.id) && (null === (i = null === (o = l.flair) || void 0 === o ? void 0 : o.template) || void 0 === i ? void 0 : i.postStyle) && (H[l.flair.template.id] = Object(h.a)(l.flair.template.postStyle))
						} else if (Object(S.g)(l)) {
							const e = Object(b.a)(l.interestTopicRecommendations.recommendationTopics);
							e.topics.length && (Q = {
								interests: e,
								index: n
							})
						} else c.push(l);
						return [a, c]
					}, [
						[],
						[]
					]);
				if (z.length) {
					const e = `Received unhandled ${z.length} elements when processing subreddit data: "${z[0].__typename}"`;
					Object(r.b)() || console.warn(e), o.c.captureMessage(e)
				}
				f && W.push(...f);
				const V = q.elements.dist,
					K = T(W, v, s);
				if (g.styles && (K.structuredStyles = {
						data: {
							style: Object(j.a)(g.styles)
						}
					}), K.structuredStyles = {
						data: {
							...g.styles ? {
								style: Object(j.a)(g.styles)
							} : {},
							content: {
								widgets: Object(k.a)(g)
							},
							flairTemplate: H
						}
					}, K.subredditAboutInfo = Object(E.a)(g), g.modPermissions && (K.subredditPermissions = Object.keys(g.modPermissions).length > 0 ? Object(A.a)(g.modPermissions) : void 0), g.rules && (K.subredditRules = Object(y.a)(g.rules).rules), ((null == g ? void 0 : g.answerableQuestions) || g.contentRatingSurvey || g.communityProgressModule) && (K.questions = {
						answerableQuestions: null == g ? void 0 : g.answerableQuestions,
						contentRatingSurvey: null == g ? void 0 : g.contentRatingSurvey,
						communityProgressModule: null == g ? void 0 : g.communityProgressModule
					}), Object(l.k)(g) || Object.assign(K, Object(i.b)(g), Object(a.b)(g)), K.subredditLinks = Object(C.a)({
						data: {
							subredditInfoById: g
						}
					}), K.subredditTopicLinks = Object(I.a)({
						data: {
							subredditInfoById: g
						}
					}), K.userFlair = {
						[g.id]: {
							displaySettings: {
								isEnabled: !!(null === (x = g.authorFlairSettings) || void 0 === x ? void 0 : x.isEnabled),
								isSelfAssignable: !!(null === (O = g.authorFlairSettings) || void 0 === O ? void 0 : O.isSelfAssignable),
								isUserEnabled: !!(null === (N = g.authorFlairSettings) || void 0 === N ? void 0 : N.isOwnFlairEnabled),
								position: null === (M = null === (D = g.authorFlairSettings) || void 0 === D ? void 0 : D.position) || void 0 === M ? void 0 : M.toLowerCase()
							},
							permissions: {
								canAssignOwn: !!(null === (R = g.authorFlairSettings) || void 0 === R ? void 0 : R.isSelfAssignable),
								canUserChange: !!((null === (L = g.authorFlairSettings) || void 0 === L ? void 0 : L.isSelfAssignable) && (null === (B = g.authorFlairSettings) || void 0 === B ? void 0 : B.isEnabled) || (null === (F = K.subredditPermissions) || void 0 === F ? void 0 : F.flair) || (null === (U = K.account) || void 0 === U ? void 0 : U.isAdmin))
							},
							applied: g.authorFlair ? Object(p.a)(g.authorFlair)[0] : void 0,
							templates: {},
							templateIds: []
						}
					}, Q && (K.interestTopicRecommendations = Q), K.predictionTournaments = g.predictionTournaments || [], g.channels) {
					const {
						channels: e,
						channelIds: t
					} = Object(m.a)(g.channels);
					K.channels = e, K.channelIds = t
				}
				return {
					...K,
					...null !== V && {
						dist: V
					}
				}
			};
			const P = e => {
				switch (e) {
					case l.d.Banned:
						return l.f.BannedSubreddit;
					case l.d.GoldOnly:
						return l.f.GoldSubreddit;
					case l.d.Private:
						return l.f.PrivateSubreddit;
					case l.d.Quarantined:
						return l.f.QuarantinedSubreddit;
					case l.d.Gated:
						return l.f.GatedSubreddit;
					case l.d.Unknown:
						return l.f.ForbiddenSubreddit
				}
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return o
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "d", (function() {
				return f
			}));
			const s = e => e.subredditInfoById.scheduledPosts.recurringPosts ? {
					recurringPosts: {
						models: p(e.subredditInfoById.scheduledPosts.recurringPosts.edges),
						pageInfo: {
							...e.subredditInfoById.scheduledPosts.recurringPosts.pageInfo
						}
					},
					recurringPostsIds: e.subredditInfoById.scheduledPosts.recurringPosts.edges.map(e => e.node.id)
				} : {},
				r = e => e.subredditInfoById.scheduledPosts.standalonePosts ? {
					standalonePosts: {
						models: u(e.subredditInfoById.scheduledPosts.standalonePosts.edges),
						pageInfo: {
							...e.subredditInfoById.scheduledPosts.standalonePosts.pageInfo
						}
					},
					standalonePostsIds: e.subredditInfoById.scheduledPosts.standalonePosts.edges.map(e => e.node.id)
				} : {},
				o = e => ({
					...e,
					subredditInfoById: {
						id: e.subredditInfoById.id,
						scheduledPosts: {
							...s(e),
							...r(e)
						}
					}
				}),
				i = e => e.subredditInfoById.scheduledPosts && !!e.subredditInfoById.scheduledPosts.recurringPosts && !!e.subredditInfoById.scheduledPosts.recurringPostsIds,
				a = e => e.subredditInfoById.scheduledPosts && !!e.subredditInfoById.scheduledPosts.standalonePosts && !!e.subredditInfoById.scheduledPosts.standalonePostsIds,
				d = e => i(e) && a(e),
				c = e => !i(e) && a(e),
				l = e => i(e) && !a(e),
				u = e => e.map(e => m(e.node)),
				m = e => ({
					id: e.id,
					title: e.title,
					body: e.body,
					postKind: e.postKind,
					collectionId: e.collections.edges.length ? e.collections.edges[0].node.id : void 0,
					discussionType: e.discussionType,
					isContestMode: e.isContestMode,
					isPostAsMetaMod: e.isPostAsMetaMod,
					isSpoiler: e.isSpoiler,
					isNsfw: e.isNsfw,
					isOriginalContent: e.isOriginalContent,
					isSendReplies: e.isSendReplies,
					isSticky: !!e.sticky && "NONE" !== e.sticky,
					mediaAssets: e.mediaAssets,
					subreddit: {
						...e.subreddit
					},
					suggestedCommentSort: e.suggestedCommentSort,
					owner: {
						...e.owner
					},
					poll: e.poll,
					contentType: e.contentType,
					clientTimezone: e.clientTimezone,
					publishAt: e.publishAt.split(".")[0],
					state: e.state,
					flair: e.flair ? {
						...e.flair
					} : void 0,
					sticky: e.sticky,
					isModDistinguished: "MODERATOR" === e.distinguishedAs,
					url: e.url
				}),
				p = e => e.map(e => b(e.node)),
				b = e => ({
					...m(e),
					frequency: e.frequency,
					byMonthDays: e.byMonthDays || [],
					byWeekDays: e.byWeekDays || [],
					interval: e.interval || 1
				}),
				f = e => (e => !!e.frequency && !!e.interval)(e) ? b(e) : m(e)
		},
		"./src/reddit/helpers/graphql/normalizeSubredditTopicLinksFromGql/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => {
				var t, n;
				return (null === (n = null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.subredditInfoById) || void 0 === n ? void 0 : n.topicLinks) || void 0
			}
		},
		"./src/reddit/helpers/graphql/normalizeUploadLeaseFromGql/index.ts": function(e, t, n) {
			"use strict";

			function s(e) {
				let {
					uploadLeaseUrl: t,
					uploadLeaseHeaders: n
				} = e;
				return {
					action: t,
					fields: (null == n ? void 0 : n.map(e => {
						let {
							header: t,
							value: n
						} = e;
						return {
							name: t,
							value: n
						}
					})) || []
				}
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/reddit/helpers/hasModFlairPermissions/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => !!e && !!e.flair
		},
		"./src/reddit/helpers/hasModFullPermissions/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => !!e && !!e.all
		},
		"./src/reddit/helpers/hasModPostPermissions/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => !!e && !!e.posts
		},
		"./src/reddit/helpers/isArrayEqual.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/isEqual.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/xorWith.js"),
				i = n.n(o);
			t.a = (e, t) => {
				const n = i()(e, t, r.a);
				return !(!n || 0 !== n.length)
			}
		},
		"./src/reddit/helpers/isCrosspost.ts": function(e, t, n) {
			"use strict";
			t.a = function(e) {
				return !!e && !!e.crosspostRootId
			}
		},
		"./src/reddit/helpers/isRemoved.ts": function(e, t, n) {
			"use strict";
			t.a = e => !!e.bannedBy && !e.isSpam
		},
		"./src/reddit/helpers/isValidUsername/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/helpers/normalizeUsername/index.tsx");
			t.a = e => {
				const t = Object(s.a)(e.trim());
				return t.length > 2 && t.length <= 20
			}
		},
		"./src/reddit/helpers/loadThirdPartyScript.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/config.ts"),
				r = n("./src/lib/fastdom/index.ts");
			const o = "https://js.stripe.com/v3/",
				i = "https://www.paypalobjects.com/api/checkout.js",
				a = {
					checkout: "https://js.braintreegateway.com/web/3.44.2/js/paypal-checkout.min.js",
					client: "https://js.braintreegateway.com/web/3.44.2/js/client.min.js",
					paypal: `https://www.paypal.com/sdk/js?client-id=${s.a.paypal.braintreeApiKey}` + "&currency=USD&vault=true"
				};

			function d(e, t) {
				return t() ? Promise.resolve() : new Promise((n, s) => r.a.write(() => {
					t() && n();
					const r = document.head;
					let o = r.querySelector(`script[src='${e}']`);

					function i() {
						this.removeEventListener("load", i), this.removeEventListener("error", a), n()
					}

					function a() {
						this.removeEventListener("load", i), this.removeEventListener("error", a), o && r.removeChild(o), s()
					}
					o || ((o = document.createElement("script")).src = e, r.appendChild(o)), o.addEventListener("load", i), o.addEventListener("error", a)
				}))
			}

			function c() {
				return d(o, () => "undefined" != typeof Stripe)
			}

			function l() {
				return d(i, () => "undefined" != typeof paypalCheckout).then(() => {
					"undefined" == typeof paypalCheckout && "undefined" != typeof window && (window.paypalCheckout = paypal), paypal = void 0
				})
			}

			function u() {
				return Promise.all(Object.keys(a).map(e => {
					const t = "__" + e;
					return d(a[e], () => void 0 !== window[t]).then(() => {
						window[t] = !0
					})
				}))
			}
		},
		"./src/reddit/helpers/locales.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				r = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/fbt.js"),
				o = n("./src/reddit/selectors/runTimeEnvVars.ts"),
				i = n("./src/reddit/selectors/user.ts"),
				a = n("./node_modules/reselect/es/index.js");
			const d = e => Object.entries(e).map(e => {
					let [t, n] = e;
					return {
						value: t,
						displayName: n.displayName
					}
				}),
				c = Object.freeze({
					[s.GERMAN_LOCALE]: Object.freeze({
						bcp47: s.GERMAN_LOCALE,
						displayName: "Deutsch",
						englishName: "German",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.GERMAN_LOCALE),
						rtl: !1
					}),
					[s.DEFAULT_LOCALE]: Object.freeze({
						bcp47: s.DEFAULT_LOCALE,
						displayName: "English (US)",
						englishName: "English (US)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.DEFAULT_LOCALE),
						rtl: !1
					}),
					[s.SPANISH_LOCALE]: Object.freeze({
						bcp47: s.SPANISH_LOCALE,
						displayName: "Espaol (ES)",
						englishName: "Spanish (ES)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.SPANISH_LOCALE),
						rtl: !1
					}),
					[s.SPANISH_MEXICAN_LOCALE]: Object.freeze({
						bcp47: s.SPANISH_MEXICAN_LOCALE,
						displayName: "Espaol (MX)",
						englishName: "Spanish (MX)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.SPANISH_MEXICAN_LOCALE),
						rtl: !1
					}),
					"fr-FR": Object.freeze({
						bcp47: "fr-FR",
						displayName: "Franais",
						englishName: "French",
						fbtLocale: Object(r.isoLocaleToFbtLocale)("fr-FR"),
						rtl: !1
					}),
					[s.ITALIAN_LOCALE]: Object.freeze({
						bcp47: s.ITALIAN_LOCALE,
						displayName: "Italiano",
						englishName: "Italian",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.ITALIAN_LOCALE),
						rtl: !1
					}),
					[s.PORTUGUESE_BRAZILIAN_LOCALE]: Object.freeze({
						bcp47: s.PORTUGUESE_BRAZILIAN_LOCALE,
						displayName: "Portugus (BR)",
						englishName: "Portuguese (BR)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.PORTUGUESE_BRAZILIAN_LOCALE),
						rtl: !1
					}),
					[s.PORTUGUESE_LOCALE]: Object.freeze({
						bcp47: s.PORTUGUESE_LOCALE,
						displayName: "Portugus (PT)",
						englishName: "Portuguese (PT)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.PORTUGUESE_LOCALE),
						rtl: !1
					})
				}),
				l = Object.freeze({
					[s.BENGALI_BANGLADESHI_LOCALE]: Object.freeze({
						bcp47: s.BENGALI_BANGLADESHI_LOCALE,
						displayName: "",
						englishName: "Bengali",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.BENGALI_BANGLADESHI_LOCALE),
						rtl: !1
					}),
					[s.HINDI_LOCALE]: Object.freeze({
						bcp47: s.HINDI_LOCALE,
						displayName: "",
						englishName: "Hindi",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.HINDI_LOCALE),
						rtl: !1
					})
				}),
				u = Object.freeze({
					[s.PSEUDO_LOCALE]: Object.freeze({
						bcp47: s.PSEUDO_LOCALE,
						displayName: "Pseudo",
						englishName: "Pseudo",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.PSEUDO_LOCALE),
						rtl: !1
					}),
					[s.PSEUDO_AUTO]: Object.freeze({
						bcp47: s.PSEUDO_AUTO,
						displayName: "Pseudo Auto",
						englishName: "Pseudo Auto",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.PSEUDO_AUTO),
						rtl: !1
					})
				}),
				m = Object(a.a)(i.P, o.b, (e, t) => e || t ? {
					...c,
					...l,
					...u
				} : c);
			const p = async (e, t) => {
				0
			}
		},
		"./src/reddit/helpers/modTooltipTemplates/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/humanizeUTCDate/index.tsx");
			const o = e => e.approvedBy && "string" == typeof e.approvedBy && e.approvedAtUTC ? s.fbt._("Approved by {username} at {time}", [s.fbt._param("username", e.approvedBy), s.fbt._param("time", Object(r.a)(e.approvedAtUTC))], {
					hk: "3G807D"
				}) : s.fbt._("Approved", null, {
					hk: "3CbKag"
				}),
				i = e => {
					let t = e.bannedBy && "string" == typeof e.bannedBy && e.bannedAtUTC ? s.fbt._("Removed by {username} at {time}", [s.fbt._param("username", e.bannedBy), s.fbt._param("time", Object(r.a)(e.bannedAtUTC))], {
						hk: "2Ey569"
					}) : s.fbt._("Removed", null, {
						hk: "238xK9"
					});
					return e.modReasonBy && e.modRemovalReason && (t = t + "\n" + s.fbt._("Reason by {username}:", [s.fbt._param("username", `u/${e.bannedBy}`)], {
						hk: "3qLdNZ"
					}) + e.modRemovalReason), e.modNote && (t = t + "\n" + s.fbt._("Note:", null, {
						hk: "2LD4vO"
					}) + e.modNote), t
				},
				a = e => s.fbt._({
					"*": "{number} Reports",
					_1: "1 Report"
				}, [s.fbt._plural(e, "number")], {
					hk: "3S0yx6"
				}),
				d = e => e.bannedBy && "string" == typeof e.bannedBy && e.bannedAtUTC ? s.fbt._("Removed as spam by {username} at {time}", [s.fbt._param("username", e.bannedBy), s.fbt._param("time", Object(r.a)(e.bannedAtUTC))], {
					hk: "2uutjk"
				}) : s.fbt._("Removed as spam", null, {
					hk: "1hD9G0"
				})
		},
		"./src/reddit/helpers/moderationLog/getGqlQueryParamsFromUrlQuery.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/constants/parameters.ts"),
				r = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = 50;
			t.b = (e, t, n) => {
				const i = Object(o.m)(n),
					a = (null == i ? void 0 : i.username) || (null == i ? void 0 : i.displayText) || "",
					d = new Date,
					c = new Date(d.getTime());
				c.setUTCDate(d.getUTCDate() - 1), c.setUTCHours(23, 59, 59, 59);
				const l = c.toISOString(),
					u = {
						subredditName: e,
						currentModName: a,
						startDateInsights: new Date(new Date(c.getTime()).setDate(c.getDate() - 29)).toISOString(),
						endDateInsights: l,
						includeInsightsData: Object(r.a)(n, !0)
					};
				return t[s.r] && (u[s.r] = t[s.r].split(",")), t[s.a] && (u[s.a] = t[s.a]), t[s.c] && (u[s.c] = t[s.c]), t[s.q] && (u[s.q] = t[s.q].split(",")), t[s.v] && (u[s.v] = t[s.v].split(",")), t[s.F] && (u[s.F] = t[s.F]), t[s.g] && (u[s.g] = t[s.g]), t[s.G] && (u[s.G] = t[s.G].split(",")), t[s.n] && (u[s.n] = parseInt(t[s.n], 10)), t[s.i] && (u[s.i] = parseInt(t[s.i], 10)), u
			}
		},
		"./src/reddit/helpers/onboarding/reonboarding.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/customMiddleware/recentSubreddits.ts"),
				o = n("./src/reddit/helpers/featureThrottling/store/index.ts"),
				i = n("./src/reddit/helpers/onboarding/postsConsumedWeekly.ts"),
				a = n("./src/reddit/models/Onboarding/index.ts");
			const d = () => {
					const e = Date.now() - s.xc,
						t = Object(r.b)().filter(t => t.lastVisited >= e),
						n = Object(i.a)();
					return t.length < 3 || n < 50
				},
				c = () => !(() => !o.a.isReady || o.a.isFeatureThrottled(a.e.FeatureGate) || o.a.isFeatureThrottled(a.e.Dismissed))() && d(),
				l = () => !(() => !o.a.isReady || o.a.throttlingData[a.e.FeatureGate] || o.a.isFeatureThrottled(a.e.Triggered) || o.a.isFeatureThrottled(a.e.Dismissed))() && d(),
				u = () => {
					o.a.isFeatureThrottled(a.e.Triggered) || (o.a.throttleFeature(a.e.FeatureGate), o.a.throttleFeature(a.e.Triggered))
				},
				m = () => {
					o.a.throttleFeature(a.e.Dismissed)
				}
		},
		"./src/reddit/helpers/ordinal/index.ts": function(e, t, n) {
			"use strict";
			t.a = function(e) {
				const t = ["th", "st", "nd", "rd"],
					n = e % 100;
				return e + (t[(n - 20) % 10] || t[n] || t[0])
			}
		},
		"./src/reddit/helpers/pageActionLoginRedirect.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/history/esm/history.js"), n("./src/reddit/actions/platform.ts");
			var s = n("./src/config.ts");
			t.a = (e, t) => {
				const n = t.platform.currentPage && t.platform.currentPage.url;
				let r = `${s.a.accountManagerOrigin}/login/`;
				const o = window.location.origin;
				n && (r += `?dest=${encodeURIComponent(`${o}${n}`)}`), window.location.href = r
			}
		},
		"./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/helpers/isComment.ts"),
				o = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				i = n("./src/reddit/models/Vote/index.ts"),
				a = e => !0 === e ? i.a.upvoted : !1 === e ? i.a.downvoted : i.a.notVoted,
				d = n("./src/reddit/models/Comment/index.ts");
			t.a = e => {
				const t = {
					approvedAtUTC: e.approved_at_utc,
					approvedBy: e.approved_by,
					author: e.author,
					authorId: e.author_fullname,
					bannedAtUTC: e.banned_at_utc,
					bannedBy: e.banned_by,
					body: e.body_html,
					bodyMD: e.body,
					collapsed: e.collapsed,
					collapsedReason: e.collapsed_reason,
					collapsedReasonCode: e.collapsed_reason_code,
					collapsedBecauseCrowdControl: e.collapsed_because_crowd_control,
					commentType: e.comment_type,
					created: e.created_utc,
					deletedBy: l(e),
					distinguishType: e.distinguished || "",
					editedAt: null,
					id: e.name,
					ignoreReports: e.ignore_reports,
					isAdmin: "admin" === e.distinguished,
					isAuthorPremium: !!e.author_premium,
					isApproved: e.approved,
					isDeleted: e.author === s.G,
					isGildable: e.can_gild,
					isLocked: e.locked,
					isMod: "moderator" === e.distinguished,
					isOp: e.is_submitter,
					isRemoved: e.removed,
					isScoreHidden: e.score_hidden,
					isSpam: e.spam,
					isStickied: e.stickied,
					isSaved: e.isSaved,
					isSystem: !1,
					subredditId: e.subreddit_id,
					markdown: e.body,
					media: {
						mediaMetadata: e.media_metadata,
						type: "rtjson",
						richtextContent: c(e.rtjson),
						rteMode: e.rte_mode
					},
					modReports: e.mod_reports,
					modReportsDismissed: e.mod_reports_dismissed,
					numReports: e.num_reports,
					parentId: Object(r.a)(e.parent_id) ? e.parent_id : null,
					permalink: e.permalink,
					postAuthor: e.link_author || null,
					postId: e.link_id,
					postTitle: e.link_title || null,
					sendReplies: e.send_replies,
					score: e.score,
					treatmentTags: e.treatment_tags,
					userReports: e.user_reports,
					userReportsDismissed: e.user_reports_dismissed,
					voteState: a(e.likes)
				};
				return e.all_awardings && (t.allAwardings = Object(o.a)(e.all_awardings)), e.awarders && (t.awarders = e.awarders), e.associated_award && (t.associatedAwardId = e.associated_award.id, t.associatedAward = Object(o.b)(e.associated_award)), t
			};
			const c = e => "string" == typeof e ? JSON.parse(e) : e,
				l = e => e.author !== s.G ? null : e.body === s.H ? d.c.User : e.body === s.Rb ? d.c.Moderator : null
		},
		"./src/reddit/helpers/r2/normalizePostFromR2/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				r = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/models/Media/index.ts"),
				i = n("./src/reddit/models/PostCreationForm/index.ts"),
				a = n("./src/reddit/models/Vote/index.ts");
			const d = e => {
					const t = [];
					return e.link_flair_richtext && e.link_flair_richtext.length && t.push({
						richtext: e.link_flair_richtext,
						type: r.f.Richtext,
						textColor: e.link_flair_text_color || "dark",
						backgroundColor: e.link_flair_background_color || "",
						templateId: e.link_flair_template_id
					}), e.link_flair_text && t.push({
						text: e.link_flair_text,
						type: r.f.Text,
						textColor: e.link_flair_text_color || "dark",
						backgroundColor: e.link_flair_background_color || "",
						templateId: e.link_flair_template_id
					}), e.spoiler && t.push({
						text: "spoiler",
						type: r.f.Spoiler
					}), e.over_18 && t.push({
						text: "nsfw",
						type: r.f.Nsfw
					}), t
				},
				c = e => e ? e.map(e => ({
					categoryId: e.category_id,
					categoryName: e.category_name
				})) : [],
				l = e => {
					const t = e.preview && e.preview.enabled;
					let n = !1,
						s = null,
						r = {},
						a = {};
					const d = e.over_18 || e.spoiler;
					if (e.preview && (n = !!(a = e.preview.images[0].variants).mp4, r = e.preview.images[0].source, d && (s = a.obfuscated.source.url)), e.is_self) return {
						content: e.selftext_html,
						type: o.o.TEXT,
						markdownContent: e.selftext,
						obfuscated: s,
						rteMode: e.rte_mode || i.i.RICH_TEXT,
						...e.rtjson && {
							richtextContent: e.rtjson,
							type: o.o.RTJSON,
							mediaMetadata: e.media_metadata
						}
					};
					if (e.secure_media && e.secure_media.oembed || e.is_survey_ad) return {
						content: e.secure_media_embed.media_domain_url,
						type: o.o.EMBED,
						width: e.secure_media.oembed.width || 0,
						height: e.secure_media.oembed.height || 0,
						obfuscated: s,
						provider: e.secure_media.oembed.provider_name || ""
					};
					if (e.media && e.media.reddit_video) {
						const t = e.media.reddit_video;
						return {
							hlsUrl: t.hls_url,
							dashUrl: t.dash_url,
							isGif: t.is_gif,
							scrubberThumbSource: t.scrubber_media_url,
							obfuscated: s,
							posterUrl: t.url,
							width: t.width,
							height: t.height,
							type: o.o.VIDEO
						}
					}
					if (t && n) return {
						content: a.mp4.source.url,
						type: o.o.GIFVIDEO,
						width: a.mp4.source.width,
						height: a.mp4.source.height,
						gifBackgroundImage: r.url,
						gifBackgroundResolutions: e.preview.images[0].resolutions,
						obfuscated: s,
						resolutions: a.mp4.resolutions
					};
					if (t) {
						const t = a.gif ? a.gif.resolutions : e.preview.images[0].resolutions;
						return {
							content: r.url,
							type: o.o.IMAGE,
							width: r.width,
							height: r.height,
							obfuscated: s,
							resolutions: t
						}
					}
					return null
				},
				u = e => {
					const t = {};
					if (e.promoted && e.outbound_link || !e.is_self && !e.is_reddit_media_domain) {
						if (t.displayText = e.domain, t.url = e.url, e.outbound_link) {
							const n = e.outbound_link;
							t.outboundUrl = n.url, t.outboundUrlExpiration = n.expiration, t.outboundUrlCreated = n.created
						}
						return t
					}
					return null
				};
			t.a = e => {
				return {
					adPromotedUserPostIds: [],
					adSupplementaryText: null,
					allAwardings: e.all_awardings ? Object(s.a)(e.all_awardings) : [],
					awarders: e.awarders,
					author: e.author,
					authorId: e.author_fullname,
					authorIsBlocked: e.author_is_blocked,
					audioRoom: e.audioRoom,
					approvedAtUTC: e.approved_at_utc,
					approvedBy: e.approved_by,
					bannedAtUTC: e.banned_at_utc,
					bannedBy: e.banned_by,
					belongsTo: {
						type: "user" === e.subreddit_type ? "profile" : "subreddit",
						id: e.subreddit_id || ""
					},
					callToAction: e.call_to_action || null,
					contestMode: e.contest_mode,
					created: 1e3 * e.created,
					crosspostParentId: e.cross_post_parent_id || null,
					crosspostRootId: e.cross_post_root_id || null,
					discussionType: e.discussion_type || null,
					distinguishType: e.distinguish_type || null,
					domain: e.domain,
					domainOverride: e.domain_override || null,
					events: e.events || [],
					flair: d(e),
					hidden: e.hidden,
					id: e.name,
					ignoreReports: e.ignore_reports,
					impressionId: e.impression_id ? String(e.impression_id) : null,
					impressionIdStr: e.impression_id_str,
					isApproved: e.approved,
					isArchived: e.archived,
					isAuthorPremium: e.author_premium,
					isBlank: e.is_blank,
					isCreatedFromAdsUi: e.is_created_from_ads_ui,
					isCrosspostable: e.is_crosspostable,
					isEligibleForQASchema: !1,
					isFollowed: e.is_followed || !1,
					isGildable: e.can_gild,
					isLocked: e.locked,
					isReactAllowed: !1,
					reactedFrom: null,
					attributionInfo: null,
					isMediaOnly: e.media_only,
					isMeta: e.is_meta,
					isNSFW: e.over_18,
					isOriginalContent: e.is_original_content,
					isPinned: e.pinned,
					isRemoved: e.removed,
					isSpam: e.spam,
					isSpoiler: e.spoiler,
					isSponsored: e.promoted,
					isSurveyAd: !!e.is_survey_ad,
					isStickied: e.stickied,
					liveCommentsWebsocket: e.liveCommentsWebsocket || e.websocket_url,
					media: l(e),
					modNote: e.mod_note || null,
					modReports: e.mod_reports,
					numComments: e.num_comments,
					numCrossposts: e.num_crossposts || 0,
					numDuplicates: e.num_duplicates,
					numReports: e.num_reports || 0,
					permalink: `https://www.reddit.com${e.permalink}`,
					postCategories: c(e.post_categories),
					preview: e.preview && e.preview.images && e.preview.images[0] && e.preview.images[0].source ? {
						url: e.preview.images[0].source.url,
						width: e.preview.images[0].source.width,
						height: e.preview.images[0].source.height
					} : void 0,
					previewComments: [],
					previousVisits: e.previous_visits,
					postId: e.name,
					modRemovalReason: e.mod_reason_title,
					modReasonBy: e.mod_reason_by,
					removedBy: e.removed_by,
					removedByCategory: e.removed_by_category,
					saved: e.saved,
					score: e.score,
					topAwardedType: e.top_awarded_type && e.top_awarded_type.toUpperCase(),
					treatmentTags: e.treatment_tags,
					isScoreHidden: !!e.hide_score,
					sendReplies: e.send_replies,
					source: u(e),
					suggestedSort: e.suggested_sort,
					thumbnail: {
						url: e.thumbnail,
						width: e.thumbnail_width,
						height: e.thumbnail_height
					},
					title: e.title,
					userReports: e.user_reports,
					upvoteRatio: e.upvote_ratio,
					viewCount: e.view_count || 0,
					voteState: Object(a.d)(e.likes)
				}
			}
		},
		"./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/lib/constants/index.ts");
			const r = e => {
					for (const t of e) {
						const e = t[0] || "";
						switch (e) {
							case s.K.NO_STRIPE_SUBSCRIPTION:
							case s.K.USER_DOESNT_EXIST:
							case s.K.USER_REQUIRED_ERROR:
							case s.K.VALIDATION_ERROR:
								return e;
							case s.K.NO_USER:
							case s.K.NO_TEXT:
							case s.K.NO_URL:
								return s.K.VALIDATION_ERROR;
							case s.K.CREDIT_CARD_FAILURE:
							case s.K.CREDIT_CARD_FAILURE_GENERIC:
								return s.K.CREDIT_CARD_FAILURE;
							default:
								if (e.startsWith("SUBMIT_VALIDATION")) return s.K.SUBMIT_VALIDATION_ERROR
						}
					}
					return s.K.VALIDATION_ERROR
				},
				o = e => {
					const t = e.body;
					return {
						type: r(t.json.errors),
						fields: t.json.errors.map(e => ({
							field: e[2] || "",
							msg: e[1]
						}))
					}
				},
				i = e => {
					const t = e.body;
					return !e.ok && t && t.json && t.json.errors ? {
						...e,
						error: o(e)
					} : e
				};
			t.a = o
		},
		"./src/reddit/helpers/readOnlyMode/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})), n.d(t, "b", (function() {
					return r
				})), n.d(t, "c", (function() {
					return o
				})),
				function(e) {
					e.editable = "editable", e.focusableReadOnly = "focusablereadonly", e.readOnly = "readonly"
				}(s || (s = {}));
			const r = e => o(e) || e === s.focusableReadOnly,
				o = e => e === s.readOnly
		},
		"./src/reddit/helpers/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "f", (function() {
				return E
			})), n.d(t, "e", (function() {
				return C
			})), n.d(t, "h", (function() {
				return A
			})), n.d(t, "g", (function() {
				return y
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			n("./node_modules/react/index.js");
			const r = function(e) {
				if (void 0 === e) throw new Error("invariant(...): Second argument must be a string.")
			};

			function o(e, t) {
				for (var n = arguments.length, s = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++) s[o - 2] = arguments[o];
				if (r(t), !e) {
					let e;
					if (void 0 === t) e = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
					else {
						let n = 0;
						(e = new Error(t.replace(/%s/g, () => String(s[n++])))).name = "Invariant Violation"
					}
					throw e.framesToPop = 1, e
				}
			}
			const i = {
					AND: "AND",
					NONE: "NONE",
					OR: "OR"
				},
				a = {
					COMMA: "COMMA",
					SEMICOLON: "SEMICOLON"
				};
			var d = function(e, t, n) {
					const r = e.length;
					if (0 === r) return "";
					if (1 === r) return e[0];
					const d = e[r - 1];
					let c = e[0];
					for (let o = 1; o < r - 1; ++o) switch (n) {
						case a.SEMICOLON:
							c = s.fbt._("{previous items}; {following items}", [s.fbt._param("previous items", c), s.fbt._param("following items", e[o])], {
								hk: "4hs4xq"
							});
							break;
						default:
							c = s.fbt._("{previous items}, {following items}", [s.fbt._param("previous items", c), s.fbt._param("following items", e[o])], {
								hk: "2z8RMb"
							})
					}
					return function(e, t, n, r) {
						switch (n) {
							case i.AND:
								return s.fbt._("{list of items} and {last item }", [s.fbt._param("list of items", e), s.fbt._param("last item ", t)], {
									hk: "1ylan1"
								});
							case i.OR:
								return s.fbt._("{list of items} or {last item}", [s.fbt._param("list of items", e), s.fbt._param("last item", t)], {
									hk: "3q8AmB"
								});
							case i.NONE:
								switch (r) {
									case a.SEMICOLON:
										return s.fbt._("{previous item}; {last item}", [s.fbt._param("previous item", e), s.fbt._param("last item", t)], {
											hk: "1h77rJ"
										});
									default:
										return s.fbt._("{list of items}, {last item}", [s.fbt._param("list of items", e), s.fbt._param("last item", t)], {
											hk: "3Q0iaX"
										})
								}
								default:
									o(!1, "Invalid conjunction %s provided to intlList", n)
						}
					}(c, d, t || i.AND, n || a.COMMA)
				},
				c = n("./src/lib/timezone/index.ts"),
				l = n("./src/reddit/helpers/isArrayEqual.ts"),
				u = n("./src/reddit/helpers/ordinal/index.ts"),
				m = n("./src/reddit/models/ScheduledPost/index.ts");
			const p = e => {
					return `${e.toLocaleDateString(void 0,{month:"numeric",day:"numeric"})} @ ${e.toLocaleTimeString(void 0,{hour:"numeric",minute:"numeric"}).replace(" ","").toLowerCase()}`
				},
				b = (e, t) => {
					if (e && t) {
						const n = Object(c.f)(h(e, t)),
							r = p(n);
						return s.fbt._("At {time}", [s.fbt._param("time", r)], {
							hk: "25s5Tg"
						})
					}
					return s.fbt._("Submit post at scheduled event time", null, {
						hk: "lYsoU"
					})
				},
				f = e => e.slice(0, 5),
				h = (e, t) => `${e}T${f(t)}:00`,
				g = e => {
					const [t, n] = e.split("T");
					return [t, f(n)]
				},
				v = e => {
					const [t, n] = g(e);
					if (t && n) {
						const e = Object(c.f)(h(t, n));
						return p(e)
					}
					return ""
				},
				x = e => {
					const t = Object(c.d)(e);
					let n, s = e;
					if (t) {
						n = t.offset, s = `(GMT${Object(c.e)(t.offset)}) ${e.replace("/"," - ").replace(/_/g," ")}`
					}
					return {
						name: e,
						displayText: s,
						offset: n
					}
				},
				E = e => "string" == typeof e,
				O = e => {
					const t = new Date,
						n = e - t.getDay();
					return t.setDate(t.getDate() + n), t.toLocaleDateString(void 0, {
						weekday: "long"
					})
				},
				C = e => {
					const t = (e => {
						const [t, n] = g(e);
						if (t && n) {
							return Object(c.f)(h(t, n)).toLocaleTimeString(void 0, {
								hour: "numeric",
								minute: "numeric"
							})
						}
						return ""
					})(e.publishAt);
					if (e.frequency === m.d.Hourly) return 2 === e.interval ? s.fbt._("Every other hour", null, {
						hk: "64vzK"
					}) : e.interval > 1 ? s.fbt._("Every {hour interval} hours", [s.fbt._param("hour interval", e.interval.toString())], {
						hk: "3x8zaD"
					}) : s.fbt._("Every hour", null, {
						hk: "1VzCs"
					});
					if (e.frequency === m.d.Daily) return 2 === e.interval ? s.fbt._("Every other day at {start time}", [s.fbt._param("start time", t)], {
						hk: "yTynp"
					}) : e.interval > 1 ? s.fbt._("Every {day interval} days at {start time}", [s.fbt._param("day interval", e.interval.toString()), s.fbt._param("start time", t)], {
						hk: "2OoGlG"
					}) : s.fbt._("Every day at {start time}", [s.fbt._param("start time", t)], {
						hk: "1cvwm2"
					});
					if (e.frequency === m.d.Weekly) {
						const n = (e => d(e.map(m.l).sort((e, t) => e - t).map(O), i.AND, a.COMMA))(e.byWeekDays);
						return 2 === e.interval ? s.fbt._("Every other week on {days of week } at {start time}", [s.fbt._param("days of week ", n), s.fbt._param("start time", t)], {
							hk: "43xwaa"
						}) : e.interval > 1 ? s.fbt._("Every {interval} weeks on {days of week} at {start time}", [s.fbt._param("interval", e.interval.toString()), s.fbt._param("days of week", n), s.fbt._param("start time", t)], {
							hk: "2IVbH"
						}) : s.fbt._("Every week on {days of week} at {start time}", [s.fbt._param("days of week", n), s.fbt._param("start time", t)], {
							hk: "2Zl0L"
						})
					}
					const n = (e => d(e.sort((e, t) => e - t).map(u.a), i.AND, a.COMMA))(e.byMonthDays);
					return 2 === e.interval ? s.fbt._({
						"*": "Every other month on the {days of month} days at {start time}",
						_1: "Every other month on the {days of month} day at {start time}"
					}, [s.fbt._param("days of month", n), s.fbt._plural(e.byMonthDays.length), s.fbt._param("start time", t)], {
						hk: "okH9o"
					}) : e.interval > 1 ? s.fbt._({
						"*": "Every {interval} months on the {days of month} days at {start time}",
						_1: "Every {interval} months on the {days of month} day at {start time}"
					}, [s.fbt._param("interval", e.interval.toString()), s.fbt._param("days of month", n), s.fbt._plural(e.byMonthDays.length), s.fbt._param("start time", t)], {
						hk: "KqN3x"
					}) : s.fbt._({
						"*": "Every month on the {days of month} days at {start time}",
						_1: "Every month on the {days of month} day at {start time}"
					}, [s.fbt._param("days of month", n), s.fbt._plural(e.byMonthDays.length), s.fbt._param("start time", t)], {
						hk: "1jBuYc"
					})
				},
				A = e => {
					let t = null;
					e.frequency && (t = e.frequency), (e.byWeekDays.length > 1 || e.byMonthDays.length > 1 || e.interval > 1) && (t = m.b);
					const n = Object(c.f)(e.publishAt),
						s = Object(m.r)(n.getDay()),
						r = n.getDate();
					return 1 === e.byWeekDays.length && e.byWeekDays[0] !== s && (t = m.b), 1 === e.byMonthDays.length && e.byMonthDays[0] !== r && (t = m.b), {
						recurrenceInfo: e.frequency ? {
							frequency: e.frequency,
							byMonthDays: e.byMonthDays,
							byWeekDays: e.byWeekDays,
							interval: e.interval
						} : null,
						frequencyOption: t,
						submitDate: e.publishAt,
						timezoneName: e.clientTimezone
					}
				},
				y = (e, t) => {
					if (!e && t || e && !t) return !1;
					if (!e && !t) return !0;
					for (const n in e) {
						if (!t) return !1;
						if (e.hasOwnProperty(n)) {
							if (Array.isArray(e[n]) && (!Array.isArray(t[n]) || !Object(l.a)(e[n], t[n]))) return !1;
							if (e[n] !== t[n]) return !1
						}
					}
					return !0
				}
		},
		"./src/reddit/helpers/sessionStorage/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "d", (function() {
					return o
				})), n.d(t, "b", (function() {
					return i
				})), n.d(t, "a", (function() {
					return a
				})), n.d(t, "c", (function() {
					return d
				})),
				function(e) {
					e.COMMENT_BEFORE_SIGNUP_STORAGE = "comment_before_signup_storage"
				}(s || (s = {}));
			const r = e => {
					if (window.sessionStorage) {
						const t = window.sessionStorage.getItem(e);
						if (t) return JSON.parse(t)
					}
					return null
				},
				o = e => {
					((e, t) => {
						window.sessionStorage && window.sessionStorage.setItem(e, JSON.stringify(t))
					})(s.COMMENT_BEFORE_SIGNUP_STORAGE, e)
				},
				i = () => r(s.COMMENT_BEFORE_SIGNUP_STORAGE),
				a = () => (e => {
					window.sessionStorage && window.sessionStorage.removeItem(e)
				})(s.COMMENT_BEFORE_SIGNUP_STORAGE),
				d = () => {
					return !!r(s.COMMENT_BEFORE_SIGNUP_STORAGE)
				}
		},
		"./src/reddit/helpers/showReportIndicator/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => !e.ignoreReports && (e.numReports || 0) > 0
		},
		"./src/reddit/helpers/styles/mixins/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "d", (function() {
				return g
			}));
			var s = n("./node_modules/polished/dist/polished.es.js"),
				r = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				o = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				i = n("./src/reddit/models/NewStructuredStyles/index.ts"),
				a = n("./src/reddit/models/Theme/index.ts"),
				d = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				c = n("./src/reddit/helpers/styles/mixins/index.m.less"),
				l = n.n(c);
			const u = {},
				m = e => Object(a.g)(Object(d.a)(e).post, Object(d.a)(e).backgroundImage, Object(d.a)(e).backgroundImagePosition),
				p = (e, t) => {
					if (e) {
						if (e.postBackgroundImage) return {
							background: Object(a.g)(e.postBackgroundColor || Object(d.a)(t).post, e.postBackgroundImage, Object(d.a)(t).backgroundImagePosition)
						};
						if (e.postBackgroundColor) return {
							background: Object(a.g)(e.postBackgroundColor, null, null)
						}
					}
					return {
						background: m(t)
					}
				},
				b = e => Object(s.k)(.2, e),
				f = e => e && e.postBackgroundColor ? {
					backgroundColor: b(e.postBackgroundColor)
				} : u,
				h = e => e.isActive ? l.a.mIsActive : void 0,
				g = e => {
					const t = Object(o.a)(Object(r.a)(e), i.a.actionIcon, i.b.actionIcon);
					return {
						color: t,
						cursor: "pointer",
						fill: t
					}
				}
		},
		"./src/reddit/helpers/styles/mixins/loading.m.less": function(e, t, n) {
			e.exports = {
				loadingBackground: "fzTkuBRFT8iIn1XnJX_Yn",
				"m-loading": "_34yMY7-6MNnz3utfjExvIq",
				mLoading: "_34yMY7-6MNnz3utfjExvIq",
				gradientAnimation: "vnt666wwqSK5qL63sBn9P",
				loadingBar: "_3giTODNeZ-Po90u8Ghs4aI",
				loadingContainer: "VRC9QT7CgUxvhK0ceQSrn"
			}
		},
		"./src/reddit/helpers/styles/mixins/loading.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/lib/classNames/index.ts"),
				r = n("./src/reddit/helpers/styles/mixins/loading.m.less"),
				o = n.n(r);
			const i = e => {
					let {
						isLoading: t
					} = e;
					return Object(s.a)(o.a.loadingBackground, {
						[o.a["m-loading"]]: t
					})
				},
				a = e => Object(s.a)(o.a.loadingBar, i(e))
		},
		"./src/reddit/helpers/styles/postBackgroundColor.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/polished/dist/polished.es.js");
			var s = n("./src/reddit/models/Theme/NewColorSystem/index.ts");

			function r(e) {
				return e.flairStyleTemplate && e.flairStyleTemplate.postBackgroundColor ? e.flairStyleTemplate.postBackgroundColor : Object(s.a)(e).post
			}
		},
		"./src/reddit/helpers/styles/smartTextColor.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/polished/dist/polished.es.js"),
				r = n("./src/reddit/models/NewStructuredStyles/index.ts");
			const o = e => Object(s.b)(e) < .6;

			function i(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : r.a.bodyText,
					n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : r.b.bodyText;
				return o(e) ? n : t
			}
		},
		"./src/reddit/helpers/tabBadging/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			}));
			var s = n("./src/config.ts");
			const r = `${s.a.assetPath}/img/favicon/badged-favicon-32x32.png`,
				o = `${s.a.assetPath}/img/favicon/badged-favicon-16x16.png`,
				i = `${s.a.assetPath}/img/favicon/favicon-32x32.png`,
				a = `${s.a.assetPath}/img/favicon/favicon-16x16.png`,
				d = "badgeCountSync",
				c = e => window.document.querySelector(`link[href="${e}"]`),
				l = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
					const t = c(e ? i : r),
						n = c(e ? a : o);
					t && n && (t.href = e ? r : i, n.href = e ? o : a)
				},
				u = e => {
					navigator && navigator.serviceWorker && navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage({
						command: d,
						badgeCounts: e
					})
				}
		},
		"./src/reddit/helpers/tags/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./node_modules/lodash/values.js"),
				r = n.n(s);
			const o = e => r()(e).sort((t, n) => {
					const s = e[t.tag.id].tag.text.toLowerCase(),
						r = e[n.tag.id].tag.text.toLowerCase();
					return s < r ? -1 : s > r ? 1 : 0
				}),
				i = e => !e.id && !!e.action
		},
		"./src/reddit/helpers/toggleBodyScroll/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./src/reddit/constants/elementIds.ts");
			let r;
			const o = () => {
					const e = document.body.dataset.previousOverflow;
					if (!e) return;
					document.body.removeAttribute("data-previous-overflow");
					const t = document.getElementById(s.d);
					document.body.style.overflow = e, document.body.style.marginRight = "", t && (t.style.marginRight = "")
				},
				i = () => {
					if (document.body.dataset.previousOverflow) return;
					const e = document.body.style.overflow || "auto";
					document.body.dataset.previousOverflow = e, r || (r = d(document.body)), document.body.style.overflow = "hidden", document.body.style.marginRight = `${r}px`;
					const t = document.getElementById(s.d);
					t && (t.style.marginRight = `${r}px`)
				},
				a = e => {
					e ? o() : i()
				},
				d = e => {
					const t = e.getBoundingClientRect();
					return window.innerWidth - (t.left + t.right)
				},
				c = e => {
					if (!e || !document.body) return 0;
					const t = d(document.body),
						n = e.offsetWidth - e.scrollWidth;
					return t || n
				}
		},
		"./src/reddit/helpers/trackers/ads.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/helpers/localStorage/index.ts"),
				o = n("./src/reddit/selectors/telemetry.ts");
			const i = (e, t, n) => r => ({
					source: "post",
					action: "view",
					noun: "programmatic_ad",
					...o.p(r),
					subreddit: o.mb(r),
					programmatic: {
						adUnit: null !== e && null !== t ? `DESKTOP ${e}x${t} ${n}` : `DESKTOP ${n}`,
						count: 1,
						type: s.h.SWITCH_HOUSE_AD
					}
				}),
				a = (e, t) => {
					t && (Object(r.Hb)(e.postId), Object(r.Rb)(t)), e.impressionIdStr ? Object(r.Ib)(e.impressionIdStr) : e.impressionId && Object(r.Ib)(e.impressionId)
				}
		},
		"./src/reddit/helpers/trackers/blade.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return i
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "j", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "k", (function() {
				return v
			}));
			var s = n("./src/reddit/constants/blade.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => n => ({
					...r.p(n),
					source: s.c.Appearance,
					action: "click",
					noun: e,
					actionInfo: r.d(n, {
						paneName: t
					}),
					subreddit: r.mb(n)
				}),
				i = e => o("save_style", e),
				a = e => o("cancel_style", e),
				d = e => t => ({
					source: s.c.Structure,
					action: "click",
					noun: e,
					screen: r.db(t),
					subreddit: r.mb(t)
				}),
				c = e => t => ({
					source: s.c.Appearance,
					action: "click",
					noun: e,
					screen: r.db(t),
					subreddit: r.mb(t)
				}),
				l = (e, t) => n => ({
					source: "colorpicker",
					action: "click",
					noun: e,
					actionInfo: r.d(n, {
						paneName: s.f[t]
					}),
					screen: r.db(n),
					subreddit: r.mb(n)
				}),
				u = e => t => ({
					source: s.g[e],
					action: "click",
					noun: "colorpicker",
					actionInfo: r.d(t, {
						paneName: s.f[e]
					}),
					screen: r.db(t),
					subreddit: r.mb(t)
				}),
				m = e => ({
					screen: r.db(e),
					subreddit: r.mb(e)
				}),
				p = () => e => ({
					source: s.c.Appearance,
					action: "view",
					noun: "blade",
					...m(e)
				}),
				b = e => t => ({
					source: s.a[e],
					action: "click",
					noun: s.b[e],
					...m(t)
				}),
				f = () => e => ({
					source: s.c.Appearance,
					action: "click",
					noun: "back",
					...m(e)
				}),
				h = e => t => ({
					source: s.c.PostFlairManagement,
					action: "click",
					noun: e,
					...m(t)
				}),
				g = (e, t) => ({
					...r.p(e),
					...h(t)(e)
				}),
				v = e => t => ({
					source: s.c.MenuLinks,
					action: "click",
					noun: e ? "wiki_link_on" : "wiki_link_off",
					screen: r.db(t),
					subreddit: r.mb(t),
					userSubreddit: r.vb(t)
				})
		},
		"./src/reddit/helpers/trackers/comment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./src/telemetry/index.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => ({
					profile: r.U(e),
					post: r.L(e, t),
					media: r.D(e, t),
					subreddit: r.mb(e),
					comment: r.i({
						state: e,
						commentId: t
					})
				}),
				i = e => {
					let {
						state: t,
						commentId: n,
						collapsed: i
					} = e;
					return Object(s.a)({
						source: "comment",
						action: "view",
						noun: i ? "collapsed_comment" : "comment",
						...r.p(t),
						...o(t, n)
					})
				},
				a = e => {
					let {
						state: t,
						commentId: n,
						collapsed: i
					} = e;
					return Object(s.a)({
						source: "comment",
						action: "consume",
						noun: i ? "collapsed_comment" : "comment",
						...r.p(t),
						...o(t, n)
					})
				},
				d = e => t => ({
					source: "online_presence",
					action: "view",
					noun: "user",
					user: r.tb(t),
					subreddit: r.mb(t),
					post: r.L(t, e),
					actionInfo: r.d(t),
					app: r.g(t),
					referrer: r.ab(t),
					session: r.ib(t)
				}),
				c = e => t => ({
					source: "post_detail",
					action: "click",
					noun: "comment_image",
					...r.p(t),
					...o(t, e)
				})
		},
		"./src/reddit/helpers/trackers/commentsChat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return l
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "n", (function() {
				return x
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "h", (function() {
				return O
			})), n.d(t, "m", (function() {
				return C
			})), n.d(t, "i", (function() {
				return A
			})), n.d(t, "j", (function() {
				return y
			}));
			var s = n("./src/lib/makeCommentsPageKey/index.ts"),
				r = n("./src/reddit/constants/tracking.ts"),
				o = n("./src/reddit/selectors/comments.ts"),
				i = n("./src/reddit/selectors/commentSelector.ts"),
				a = n("./src/reddit/selectors/telemetry.ts"),
				d = n("./src/telemetry/models/Event.ts");
			const c = (e, t) => ({
					...Object(a.p)(e),
					subreddit: Object(a.mb)(e),
					profile: Object(a.U)(e),
					post: Object(a.L)(e, t),
					comment: Object(a.i)({
						state: e,
						commentId: t
					})
				}),
				l = (e, t) => {
					const n = Object(i.c)(e, {
							commentId: t
						}),
						r = n && Object(s.a)(n.postId);
					if (!n || !r) return null;
					const d = {
							commentId: t,
							commentsPageKey: r
						},
						c = t && r && Object(o.j)(e, d) || 0;
					return Object(a.A)(e, void 0, {
						depth: c
					})
				},
				u = e => {
					var t;
					return null !== (t = e.split("chat_reaction_")[1]) && void 0 !== t ? t : ""
				},
				m = (e, t) => n => ({
					action: "load",
					noun: e,
					post: Object(a.L)(n, t),
					source: d.b.ChatView,
					subreddit: Object(a.mb)(n)
				}),
				p = (e, t) => n => ({
					...c(n, t),
					source: "live_post",
					action: r.c.CLICK,
					noun: e,
					actionInfo: {
						reason: "live_post",
						pageType: "actions_menu"
					},
					listing: l(n, t)
				}),
				b = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.VIEW,
					noun: "last_message"
				}),
				f = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.SUBMIT,
					noun: "reply",
					post: Object(a.L)(t, e),
					comment: Object(a.i)({
						state: t,
						commentId: e
					}),
					actionInfo: Object(a.d)(t, {
						reason: "live_post",
						type: "live_post"
					})
				}),
				h = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.CLICK,
					noun: "comment",
					actionInfo: Object(a.d)(t, {
						pageType: "user_mention",
						reason: "live_post",
						type: "live_post"
					})
				}),
				g = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.VIEW,
					noun: "warning",
					post: Object(a.L)(t, e),
					actionInfo: {
						pageType: "spam_rate_countdown"
					}
				}),
				v = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.CLOSE,
					noun: "warning",
					post: Object(a.L)(t, e),
					actionInfo: {
						pageType: "spam_rate_countdown"
					}
				}),
				x = e => t => ({
					...c(t, e),
					source: "global",
					action: r.c.VIEW,
					noun: "screen",
					actionInfo: {
						reason: "live_post",
						pageType: "given_awards_list"
					},
					listing: l(t, e)
				}),
				E = (e, t, n) => s => ({
					...c(s, t),
					source: d.b.Chat,
					action: r.c.CLICK,
					noun: "reaction",
					actionInfo: {
						pageType: n,
						reason: u(e)
					},
					chat: {
						type: "live_post"
					},
					listing: l(s, t)
				}),
				O = (e, t, n) => s => ({
					...c(s, t),
					source: d.b.Chat,
					action: r.c.DELETE,
					noun: "reaction",
					actionInfo: {
						pageType: n,
						reason: u(e)
					},
					chat: {
						type: "live_post"
					},
					listing: l(s, t)
				}),
				C = () => e => {
					var t;
					return {
						...Object(a.p)(e),
						subreddit: Object(a.mb)(e),
						profile: Object(a.U)(e),
						actionInfo: {
							...Object(a.d)(e),
							paneName: (null === window || void 0 === window ? void 0 : window.parent) !== window ? "chat_tab" : (null === (t = null == e ? void 0 : e.platform.currentPage) || void 0 === t ? void 0 : t.locationState.clickSource) || ""
						},
						source: "chat_post",
						action: r.c.VIEW,
						noun: "hint"
					}
				},
				A = e => t => {
					const n = c(t, e);
					return n.comment.type = "thread_chat", {
						...n,
						source: "live_post",
						action: r.c.CLICK,
						noun: "chat_thread",
						actionInfo: Object(a.d)(t, {
							pageType: "actions_menu"
						})
					}
				},
				y = e => t => {
					const n = c(t, e);
					return n.comment.type = "thread_chat", {
						...n,
						source: "live_post",
						action: r.c.SUBMIT,
						noun: "comment",
						actionInfo: Object(a.d)(t)
					}
				}
		},
		"./src/reddit/helpers/trackers/commentsPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return p
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "h", (function() {
				return E
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "j", (function() {
				return C
			})), n.d(t, "i", (function() {
				return A
			})), n.d(t, "l", (function() {
				return y
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/constants/tracking.ts"),
				o = n("./src/reddit/helpers/correlationIdTracker.ts"),
				i = n("./src/reddit/models/PostDraft/index.ts"),
				a = n("./src/reddit/selectors/comments.ts"),
				d = n("./src/reddit/selectors/platform.ts"),
				c = n("./src/reddit/selectors/telemetry.ts"),
				l = n("./src/telemetry/index.ts"),
				u = n("./src/reddit/constants/richTextJson.ts");
			const m = e => {
					const t = Object(d.o)(e);
					return {
						source: "comment_composer",
						action: r.c.CLICK,
						...Object(c.p)(e),
						screen: Object(c.db)(e),
						subreddit: Object(c.mb)(e),
						post: t ? Object(c.L)(e, t) : null,
						profile: Object(c.U)(e),
						correlationId: Object(o.c)(o.a.CommentComposer)
					}
				},
				p = async (e, t, s, r, o) => {
					const i = {
							commentId: o,
							commentsPageKey: s
						},
						d = o && Object(a.j)(e, i) || 0,
						{
							getFlairData: u
						} = await n.e("getFlairData").then(n.bind(null, "./src/reddit/helpers/trackers/features/getFlairData.ts")),
						p = r ? "image" : void 0;
					return Object(l.a)({
						noun: "comment",
						...m(e),
						comment: o ? Object(c.i)({
							state: e,
							commentId: o,
							contentType: p
						}) : null,
						listing: Object(c.A)(e, void 0, {
							depth: d
						}),
						commentComposer: {
							editorMode: t
						},
						userFlair: u(e),
						media: {
							mimetype: null == r ? void 0 : r.mimetype,
							size: null == r ? void 0 : r.size
						}
					})
				}, b = e => {
					let {
						state: t,
						bodyText: n,
						postId: r,
						error: o,
						parentId: i,
						uploadMetadata: a
					} = e;
					const d = m(t),
						c = o.type === s.Qb ? "karma_rate_limit" : o.fields && o.fields.length > 0 ? o.fields[0].msg : void 0,
						p = a ? "image" : function(e) {
							return e.includes(`"id":"${u.d}`)
						}("string" == typeof n ? n : JSON.stringify(n)) ? "giphy" : void 0;
					return Object(l.a)({
						...d,
						source: o.type === s.Qb ? "backend" : "comment_composer",
						actionInfo: {
							...d.actionInfo,
							reason: c
						},
						action: "error",
						noun: "comment",
						comment: {
							bodyText: n,
							parentId: i,
							postId: r,
							contentType: p
						},
						media: {
							mimetype: null == a ? void 0 : a.mimetype,
							size: null == a ? void 0 : a.size
						}
					})
				}, f = e => Object(l.a)({
					noun: "cancel",
					...m(e)
				}), h = (e, t) => {
					t === i.c.replyToPost && Object(l.a)({
						noun: "input",
						...m(e)
					})
				}, g = (e, t) => Object(l.a)({
					source: "comment",
					noun: "delete",
					action: "click",
					...Object(c.p)(t),
					screen: Object(c.db)(t),
					subreddit: Object(c.mb)(t),
					post: Object(c.L)(t, e)
				}), v = e => Object(l.a)({
					noun: "edit",
					...m(e)
				}), x = e => Object(l.a)({
					noun: "save_edit",
					...m(e)
				}), E = (e, t) => n => {
					const s = "image_upload" === e || "video_upload" === e;
					return {
						...m(n),
						noun: s ? e : "text_option",
						commentComposer: {
							textType: e,
							finalStatus: t ? "on" : "off"
						}
					}
				}, O = () => e => ({
					...m(e),
					action: "open",
					noun: "gif_tooltip"
				}), C = e => t => ({
					...m(t),
					action: "change",
					noun: "gif_tooltip_search",
					search: {
						query: e
					}
				}), A = () => e => ({
					...m(e),
					action: "select",
					noun: "gif_tooltip_result"
				}), y = () => e => ({
					...m(e),
					source: "comment_composer",
					action: "open",
					noun: "images_tooltip"
				})
		},
		"./src/reddit/helpers/trackers/communityAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "i", (function() {
				return g
			}));
			var s = n("./src/reddit/models/Gold/Award.ts"),
				r = n("./src/reddit/selectors/telemetry.ts"),
				o = n("./src/reddit/helpers/correlationIdTracker.ts"),
				i = n("./src/reddit/helpers/trackers/gild.ts");
			const a = e => ({
					...r.p(e),
					screen: r.db(e),
					subreddit: r.mb(e),
					userSubreddit: r.vb(e)
				}),
				d = e => ({
					awardId: e.id,
					awardName: e.name,
					isModAward: e.awardType === s.e.Moderator,
					isTemporatyAward: !!e.endsAt,
					numberCoins: e.coinPrice,
					numberMonths: Math.floor((e.daysOfPremium || 0) / 30),
					numberCoinsToRecipient: e.coinReward || 0,
					numberCoinsToCommunity: e.subredditCoinReward || 0,
					type: Object(i.getAwardTypeFromAward)(e)
				}),
				c = () => e => ({
					...a(e),
					source: "awards",
					action: "click",
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: "create"
				}),
				l = e => t => ({
					...a(t),
					source: "awards",
					action: "click",
					correlationId: Object(o.c)(o.a.AwardDeletionFlow),
					noun: "delete",
					goldPurchase: e ? d(e) : null,
					media: e ? {
						url: e.icon.url
					} : null
				}),
				u = (e, t, n) => s => ({
					...a(s),
					source: "create_award",
					action: e,
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: t,
					goldPurchase: n
				}),
				m = (e, t, n, s) => r => ({
					...a(r),
					source: "create_award",
					action: "upload",
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: "image",
					actionInfo: s ? {
						reason: s
					} : {
						success: !0
					},
					media: t ? {
						fileName: t.file.name,
						height: t.height,
						id: t.id,
						mimetype: t.file.type,
						size: t.file.size,
						type: "image",
						uploadDuration: n,
						url: e,
						width: t.width
					} : null
				}),
				p = (e, t, n) => s => ({
					...a(s),
					source: "create_award",
					action: "click",
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: "create",
					media: t && e ? {
						fileName: t.file.name,
						height: t.height,
						id: t.id,
						mimetype: t.file.type,
						size: t.file.size,
						type: "image",
						url: e,
						width: t.width
					} : null,
					goldPurchase: n ? d(n) : null
				}),
				b = (e, t, n) => s => ({
					...a(s),
					source: "create_award",
					action: e,
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: t,
					goldPurchase: n ? d(n) : null
				}),
				f = (e, t, n) => s => ({
					...a(s),
					source: "awards",
					action: "click",
					noun: n,
					goldPurchase: d(e),
					profile: r.V(s, t),
					subreddit: r.nb(s, t)
				}),
				h = (e, t) => f(e, t, "disable_in_community"),
				g = (e, t) => f(e, t, "enable_in_community")
		},
		"./src/reddit/helpers/trackers/communitySettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return p
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "a", (function() {
				return x
			})), n.d(t, "c", (function() {
				return E
			}));
			var s = n("./node_modules/lodash/snakeCase.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const a = {
					contentOptions: "link_type",
					contentVisible: "allow_top",
					subredditType: "type",
					welcomeMessageText: "welcome_message"
				},
				d = {
					allowChatPostCreation: o.nc.Posts,
					allowDiscovery: o.nc.Safety,
					allowGalleries: o.nc.Posts,
					allowImages: o.nc.Posts,
					allowVideos: o.nc.Posts,
					allowPolls: o.nc.Posts,
					allowPostCrossposts: o.nc.Posts,
					collapseDeletedComments: o.nc.Posts,
					commentScoreHideMins: o.nc.Posts,
					contentOptions: o.nc.Posts,
					contentVisible: o.nc.Safety,
					crowdControlChatLevel: o.nc.Safety,
					crowdControlPostLevel: o.nc.Safety,
					crowdControlLevel: o.nc.Safety,
					crowdControlFilter: o.nc.Safety,
					crowdControlMode: o.nc.Safety,
					disableContributorRequests: o.nc.Community,
					excludeBannedModqueue: o.nc.Safety,
					over18: o.nc.Community,
					publicDescription: o.nc.Community,
					restrictCommenting: o.nc.Community,
					restrictPosting: o.nc.Community,
					spamComments: o.nc.Posts,
					spamLinks: o.nc.Posts,
					spamSelfposts: o.nc.Posts,
					spoilersEnabled: o.nc.Posts,
					subredditType: o.nc.Community,
					suggestedCommentSort: o.nc.Posts,
					toxicityThresholdChatLevel: o.nc.Safety,
					welcomeMessageEnabled: o.nc.Community,
					welcomeMessageText: o.nc.Community,
					wikiEditAge: o.nc.Wikis,
					wikiEditKarma: o.nc.Wikis,
					wikimode: o.nc.Wikis
				},
				c = {
					[o.nc.Community]: "community_settings_details",
					[o.nc.Notifications]: "community_settings_notifications",
					[o.nc.Safety]: "community_settings_safety",
					[o.nc.Posts]: "community_settings_content",
					[o.nc.Wikis]: "community_settings_wiki",
					[o.nc.ContentTag]: "content_tag"
				},
				l = e => a[e] || r()(e),
				u = e => {
					const t = d[e];
					return t && c[t] || "community_settings"
				};

			function m(e) {
				return "object" == typeof e ? JSON.stringify(e) : String(e)
			}
			const p = (e, t, n) => s => ({
					source: u(e),
					action: "click",
					noun: l(e),
					setting: {
						value: m(t),
						oldValue: m(n)
					},
					subreddit: i.mb(s),
					...i.p(s)
				}),
				b = (e, t) => n => ({
					...i.p(n),
					source: "mod",
					action: e ? "opt_in" : "opt_out",
					noun: "onboarding",
					actionInfo: {
						reason: t
					}
				}),
				f = (e, t, n) => s => ({
					source: u(e),
					action: "save",
					noun: l(e),
					setting: {
						value: m(t),
						oldValue: m(n)
					},
					subreddit: i.mb(s),
					...i.p(s)
				}),
				h = e => t => ({
					source: "community_settings",
					action: "click",
					noun: c[e],
					...i.p(t)
				}),
				g = e => t => ({
					source: c[e],
					action: "click",
					noun: "r2_community_settings",
					...i.p(t)
				}),
				v = (e, t, n, s) => r => ({
					...i.p(r),
					source: "mod_tools",
					action: e,
					noun: t,
					...void 0 !== n && void 0 !== s && {
						setting: {
							value: String(n),
							oldValue: String(s)
						}
					},
					subreddit: i.mb(r),
					actionInfo: i.d(r, {
						reason: "welcome_message"
					})
				}),
				x = (e, t) => n => {
					var s;
					return {
						...i.p(n),
						source: "language" === e.toLowerCase() ? "mod_tools" : "community_settings",
						action: "click",
						noun: e,
						subreddit: i.mb(n),
						subredditId: null === (s = i.mb(n)) || void 0 === s ? void 0 : s.id,
						actionInfo: {
							settingValue: String(t)
						}
					}
				},
				E = (e, t, n) => s => {
					var r;
					return {
						...i.p(s),
						source: "language" === e.toLowerCase() ? "mod_tools" : "community_settings",
						action: "save",
						noun: e,
						subreddit: i.mb(s),
						subredditId: null === (r = i.mb(s)) || void 0 === r ? void 0 : r.id,
						setting: {
							value: String(t),
							oldValue: String(n)
						},
						actionInfo: {
							settingValue: String(t)
						}
					}
				}
		},
		"./src/reddit/helpers/trackers/communityTopics.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "g", (function() {
				return v
			}));
			var s, r = n("./src/reddit/selectors/tags.ts"),
				o = n("./src/reddit/selectors/telemetry.ts"),
				i = n("./src/telemetry/index.ts");
			! function(e) {
				e.communitySettings = "community_settings", e.idCard = "id_card"
			}(s || (s = {}));
			const a = (e, t, n) => {
					const s = Object(r.x)(e, {
						subredditId: t
					});
					return !!s && s.id === n
				},
				d = (e, t) => Object(r.u)(e, {
					itemId: t
				}).reduce((e, t) => {
					let {
						topicTagIds: n,
						topicTagContents: s,
						topicTagTypes: r
					} = e;
					return n.push(t.tag.id), s.push(t.tag.text), r.push(t.tag.type), {
						topicTagIds: n,
						topicTagContents: s,
						topicTagTypes: r
					}
				}, {
					topicTagIds: [],
					topicTagContents: [],
					topicTagTypes: []
				}),
				c = (e, t, n) => {
					if (!n.id) return {
						content: n.displayText
					};
					const s = Object(r.b)(e)[n.id] || Object(r.d)(e, {
						subredditId: t
					})[n.id];
					return s ? {
						id: s.id,
						content: s.text,
						type: s.type,
						isPrimary: a(e, t, s.id)
					} : null
				},
				l = (e, t, n) => {
					if (!n) return null;
					const s = Object(r.b)(e)[n] || Object(r.d)(e, {
						subredditId: t
					})[n];
					return s ? {
						id: s.id,
						content: s.text,
						type: s.type,
						isPrimary: a(e, t, s.id)
					} : null
				},
				u = (e, t, n) => ({
					...o.p(e),
					subreddit: {
						...o.mb(e) || {},
						id: t,
						...d(e, t)
					},
					source: n.context,
					action: "click"
				}),
				m = (e, t, n) => {
					Object(i.a)(((e, t, n) => ({
						...u(e, t.subredditId, n),
						noun: t.isRelevant ? "restore_related_topic" : "remove_related_topic",
						topicTag: l(e, t.subredditId, t.tagId)
					}))(e, t, n))
				},
				p = (e, t, n, s) => {
					Object(i.a)({
						...u(e, t, s),
						topicTag: c(e, t, n),
						noun: "add_related_topic"
					})
				},
				b = (e, t, n, s) => {
					return !Object(r.i)(e, {
						subredditId: t
					}) && n.id ? Object(i.a)(((e, t, n, s) => ({
						...u(e, t, s),
						topicTag: c(e, t, n),
						noun: "topic_auto_suggest"
					}))(e, t, n, s)) : n.id ? Object(i.a)(((e, t, n, s) => ({
						...u(e, t, s),
						topicTag: c(e, t, n),
						noun: "topic_auto_complete"
					}))(e, t, n, s)) : Object(i.a)(((e, t, n, s) => ({
						...u(e, t, s),
						topicTag: c(e, t, n),
						noun: "topic_add_new"
					}))(e, t, n, s))
				},
				f = (e, t, n, s) => Object(i.a)({
					...u(e, t, s),
					topicTag: c(e, t, n),
					noun: "topic_remove"
				}),
				h = (e, t, n) => Object(i.a)({
					...u(e, t, n),
					noun: "topic_tag_field"
				}),
				g = (e, t, n) => Object(i.a)({
					...u(e, t, n),
					noun: n.context === s.communitySettings ? "save" : "save_community_topics"
				}),
				v = (e, t, n, s) => {
					const r = u(e, t, s);
					Object(i.a)({
						...r,
						action: "view",
						noun: "error",
						actionInfo: {
							...r.actionInfo,
							reason: n
						}
					})
				}
		},
		"./src/reddit/helpers/trackers/contentTag.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return s
			})), n.d(t, "g", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "l", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "j", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "m", (function() {
				return p
			})), n.d(t, "k", (function() {
				return b
			})), n.d(t, "o", (function() {
				return f
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "d", (function() {
				return g
			}));
			const s = () => () => ({
					source: "content_tag",
					action: "view",
					noun: "verify_topics_module"
				}),
				r = () => () => ({
					source: "content_tag",
					action: "click",
					noun: "verify_topics_module"
				}),
				o = () => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "survey_intro",
					actionInfo: {
						pageType: "survey_intro"
					}
				}),
				i = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "start",
					actionInfo: {
						pageType: "survey_intro"
					}
				}),
				a = () => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "mature_themes_prompt",
					actionInfo: {
						pageType: "survey_mature_themes"
					}
				}),
				d = e => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: e,
					actionInfo: {
						pageType: e
					}
				}),
				c = e => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "survey_answer",
					actionInfo: {
						pageType: e
					}
				}),
				l = (e, t) => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "next",
					actionInfo: {
						reason: t.join(),
						pageType: e
					}
				}),
				u = e => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "back",
					actionInfo: {
						pageType: e
					}
				}),
				m = () => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "survey_rating_summary",
					actionInfo: {
						pageType: "survey_rating_summary"
					}
				}),
				p = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "submit_survey",
					actionInfo: {
						pageType: "survey_rating_summary"
					}
				}),
				b = () => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "survey_rating_review",
					actionInfo: {
						pageType: "survey_rating_review"
					}
				}),
				f = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "take_survey",
					actionInfo: {
						pageType: "survey_rating_review"
					}
				}),
				h = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "message_modsupport",
					actionInfo: {
						pageType: "survey_rating_review"
					}
				}),
				g = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "learn_more",
					actionInfo: {
						pageType: "survey_rating_review"
					}
				})
		},
		"./src/reddit/helpers/trackers/features/powerupsFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/reddit/helpers/flair.ts"),
				r = n("./src/reddit/selectors/comments.ts"),
				o = n("./src/reddit/selectors/gold/powerups/flairs.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const a = (e, t, n) => a => {
					const d = Object(r.e)(a, {
							commentId: e
						}),
						c = Object(o.f)(a, {
							subredditId: t,
							userId: n
						});
					return {
						source: "meta",
						action: "hover",
						noun: "achieve_flair",
						...i.p(a),
						subreddit: {
							id: t
						},
						userFlair: {
							id: null == d ? void 0 : d.templateId,
							title: d ? Object(s.g)(d) : void 0,
							achievementFlairId: null == c ? void 0 : c.type,
							achievementFlairTitle: null == c ? void 0 : c.name
						}
					}
				},
				d = () => e => ({
					source: "powerups",
					action: "click",
					noun: "view_your_achievements",
					...i.p(e)
				})
		},
		"./src/reddit/helpers/trackers/feed.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/selectors/telemetry.ts"),
				r = n("./src/telemetry/index.ts");
			const o = e => t => Object(r.a)({
					...s.p(t),
					actionInfo: s.d(t, {
						reason: e
					}),
					source: "feed",
					action: "load",
					noun: "serving",
					feed: s.s(t)
				}),
				i = e => t => Object(r.a)({
					...s.p(t),
					actionInfo: s.d(t, {
						reason: e
					}),
					source: "feed",
					action: "fail",
					noun: "serving",
					feed: s.s(t)
				})
		},
		"./src/reddit/helpers/trackers/freeAwardOffer.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/helpers/trackers/goldPayment.ts"),
				o = n("./src/reddit/models/Gold/ProductOffer.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const a = e => ({
					...Object(r.h)(e, {
						offerContext: o.a.StorefrontFreeAward
					}),
					correlationId: Object(s.d)(s.a.GoldPayment, !1),
					profile: i.U(e),
					subreddit: i.mb(e)
				}),
				d = () => e => ({
					source: "free_award_offer",
					action: "view",
					noun: "page",
					...a(e)
				}),
				c = e => t => ({
					source: "free_award_offer",
					action: "click",
					noun: e,
					...a(t)
				}),
				l = () => e => ({
					source: "tooltip",
					action: "view",
					noun: "try_free_award",
					...a(e)
				})
		},
		"./src/reddit/helpers/trackers/gild.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "getAwardTypeFromAward", (function() {
				return u
			})), n.d(t, "clickGildEvent", (function() {
				return b
			})), n.d(t, "clickAddAward", (function() {
				return f
			})), n.d(t, "clickHideAward", (function() {
				return h
			})), n.d(t, "clickConfirmHideAward", (function() {
				return g
			})), n.d(t, "clickCancelHideAward", (function() {
				return v
			})), n.d(t, "clickAwardReportFlow", (function() {
				return E
			})), n.d(t, "clickCancelAwardReportFlow", (function() {
				return O
			})), n.d(t, "clickFlagAwardUsage", (function() {
				return C
			})), n.d(t, "clickCancelFlagAwardUsage", (function() {
				return A
			})), n.d(t, "clickConfirmFlagAwardUsage", (function() {
				return y
			})), n.d(t, "clickReportAward", (function() {
				return j
			})), n.d(t, "clickCancelReportAward", (function() {
				return I
			})), n.d(t, "clickConfirmReportAward", (function() {
				return k
			})), n.d(t, "viewGildModalEvent", (function() {
				return _
			})), n.d(t, "clickSelectAwardEvent", (function() {
				return S
			})), n.d(t, "triggerAnonymousEvent", (function() {
				return w
			})), n.d(t, "clickMessageInputEvent", (function() {
				return T
			})), n.d(t, "typeMessageInputEvent", (function() {
				return P
			})), n.d(t, "clickLearnMoreLinkEvent", (function() {
				return N
			})), n.d(t, "clickQuestionMarkEvent", (function() {
				return D
			})), n.d(t, "clickConfirmAwardEvent", (function() {
				return M
			})), n.d(t, "clickGetPremiumEvent", (function() {
				return R
			})), n.d(t, "clickAddCoinsButtonEvent", (function() {
				return L
			})), n.d(t, "clickNextButtonEvent", (function() {
				return B
			})), n.d(t, "clickCloseGildModalEvent", (function() {
				return F
			})), n.d(t, "viewKarmaSuccessEvent", (function() {
				return U
			})), n.d(t, "clickFilterEvent", (function() {
				return H
			})), n.d(t, "clickNextFiltersEvent", (function() {
				return G
			})), n.d(t, "clickPreviousFiltersEvent", (function() {
				return Q
			}));
			var s = n("./src/reddit/helpers/trackers/commentsChat.ts"),
				r = n("./src/reddit/models/Gold/Award.ts"),
				o = n("./src/reddit/selectors/commentSelector.ts"),
				i = n("./src/reddit/selectors/telemetry.ts"),
				a = n("./src/telemetry/models/GoldPurchase.ts"),
				d = n("./src/reddit/helpers/correlationIdTracker.ts"),
				c = n("./src/reddit/helpers/isComment.ts"),
				l = n("./src/reddit/selectors/gild.ts");
			const u = e => e.awardType === r.e.Global && e.awardSubType === r.d.Appreciation ? a.GoldPurchaseType.GidAppreciation : e.awardType === r.e.Global && e.awardSubType === r.d.Premium ? a.GoldPurchaseType.GidPremium : e.awardSubType === r.d.Group ? a.GoldPurchaseType.GidGroup : e.awardType === r.e.Community ? a.GoldPurchaseType.GidCommunity : e.awardType === r.e.Moderator ? a.GoldPurchaseType.GidMod : e.awardType === r.e.Global && e.awardSubType === r.d.Global ? a.GoldPurchaseType.GidGlobal : a.GoldPurchaseType.GidUnknown,
				m = (e, t) => ({
					awardId: e.id,
					awardName: e.name,
					isTemporaryAward: !!e.endsAt,
					numberCoinsToRecipient: e.coinReward,
					type: u(e),
					...t
				}),
				p = (e, t, n) => {
					const r = t && Object(o.g)(e, {
						commentId: t
					});
					return {
						...i.p(e),
						actionInfo: i.d(e, {
							reason: r ? "live_post" : void 0,
							...n
						}),
						comment: t ? i.i({
							state: e,
							commentId: t
						}) : void 0,
						correlationId: Object(l.b)(e) || Object(d.d)(d.a.GildingFlow, !1),
						post: t ? i.L(e, t) : void 0,
						screen: i.db(e),
						subreddit: i.mb(e),
						userSubreddit: i.vb(e),
						listing: t ? Object(s.k)(e, t) : void 0
					}
				},
				b = (e, t) => n => ({
					...p(n, e, t),
					source: Object(c.a)(e) ? "comment" : "post",
					action: "click",
					noun: "give_gold",
					feed: i.s(n)
				}),
				f = e => t => ({
					...p(t, e),
					source: Object(c.a)(e) ? "comment" : "post",
					action: "click",
					noun: "add_award",
					feed: i.s(t)
				}),
				h = (e, t) => n => ({
					...p(n, t),
					source: Object(c.a)(t) ? "comment" : "post",
					action: "click",
					noun: "hide_award",
					goldPurchase: m(e)
				}),
				g = (e, t) => n => ({
					...p(n, t),
					source: Object(c.a)(t) ? "comment" : "post",
					action: "click",
					noun: "confirm_hide_award",
					goldPurchase: m(e)
				}),
				v = (e, t) => n => ({
					...p(n, t),
					source: Object(c.a)(t) ? "comment" : "post",
					action: "click",
					noun: "cancel_hide_award",
					goldPurchase: m(e)
				}),
				x = e => (t, n) => s => ({
					...p(s, n),
					source: Object(c.a)(n) ? "comment" : "post",
					action: "click",
					noun: e,
					goldPurchase: m(t)
				}),
				E = x("award_hovercard_report"),
				O = x("cancel_award_hovercard_report"),
				C = x("flag_award"),
				A = x("cancel_flag_award"),
				y = x("confirm_flag_award"),
				j = x("report_community_award"),
				I = x("cancel_report_community_award"),
				k = x("confirm_report_community_award"),
				_ = (e, t, n) => s => ({
					...p(s, n),
					source: "give_gold",
					action: "view",
					noun: "page",
					goldPurchase: {
						defaultOption: e,
						defaultAnonymous: t
					}
				}),
				S = (e, t, n) => s => ({
					...p(s, t),
					source: "give_gold",
					action: "click",
					noun: "award",
					goldPurchase: m(e, n)
				}),
				w = (e, t) => n => ({
					...p(n, t),
					source: "give_gold",
					action: e,
					noun: "anonymous"
				}),
				T = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "message_input"
				}),
				P = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "type",
					noun: "message_input"
				}),
				N = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "learn_more"
				}),
				D = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "question"
				}),
				M = (e, t) => n => ({
					...p(n, e),
					source: "give_gold",
					action: "click",
					noun: "confirm",
					goldPurchase: {
						contentType: Object(c.a)(e) ? "comment" : "post",
						...m(t)
					}
				}),
				R = (e, t) => n => ({
					...p(n, e),
					source: "give_gold",
					action: "click",
					noun: "get_premium",
					goldPurchase: {
						contentType: Object(c.a)(e) ? "comment" : "post",
						...m(t)
					}
				}),
				L = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "add_coins"
				}),
				B = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "next"
				}),
				F = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "close"
				}),
				U = e => {
					let {
						award: t,
						awardeeKarmaEarned: n,
						awarderKarmaEarned: s,
						numberCoins: r,
						thingId: o
					} = e;
					return e => ({
						...p(e, o),
						source: "give_gold",
						action: "view",
						noun: "karma_success",
						goldPurchase: {
							contentType: Object(c.a)(o) ? "comment" : "post",
							awardeeKarmaEarned: n,
							awarderKarmaEarned: s,
							numberCoins: r,
							...m(t)
						}
					})
				},
				H = e => t => ({
					...p(t),
					source: "give_gold",
					action: "click",
					noun: "filter",
					goldPurchase: {
						filterId: e.tag,
						filterName: e.content.markdown
					}
				}),
				G = () => e => ({
					...p(e),
					source: "give_gold",
					action: "click",
					noun: "next_filters"
				}),
				Q = () => e => ({
					...p(e),
					source: "give_gold",
					action: "click",
					noun: "previous_filters"
				})
		},
		"./src/reddit/helpers/trackers/goldPayment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "e", (function() {
				return x
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "g", (function() {
				return C
			})), n.d(t, "i", (function() {
				return A
			})), n.d(t, "j", (function() {
				return y
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/models/Gold/ProductOffer.ts"),
				o = n("./src/reddit/selectors/gold/giveAwards.ts"),
				i = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				a = n("./src/reddit/selectors/goldPurchaseModals.ts"),
				d = n("./src/reddit/selectors/telemetry.ts"),
				c = n("./src/telemetry/models/GoldPurchase.ts"),
				l = n("./src/telemetry/models/Payment.ts"),
				u = n("./src/reddit/helpers/trackers/gild.ts"),
				m = n("./src/reddit/helpers/correlationIdTracker.ts"),
				p = n("./src/reddit/helpers/isComment.ts"),
				b = n("./src/reddit/helpers/trackers/communityAwards.ts");
			const f = (e, t) => {
					const {
						thingId: n,
						packageId: l
					} = t, f = !!n, h = o.b(e), g = h ? Object(u.getAwardTypeFromAward)(h) : null, v = f ? g : a.p(e) ? c.GoldPurchaseType.Premium : c.GoldPurchaseType.Coins, x = n ? Object(p.a)(n) ? "comment" : "post" : void 0, E = l || a.u(e), O = [...Object(i.d)(e), ...Object(i.e)(e)].filter(e => e.mobileId === E)[0], C = t.offerContext || (h && 0 === h.coinPrice ? r.a.StorefrontFreeAward : Object(r.d)(O, f)), A = O ? Math.round(1e4 * (O.baselinePennies - O.pennies) / O.baselinePennies) / 100 : 0, y = O ? Math.round(1e4 * (O.coins - O.baselineCoins) / O.coins) / 100 : 0, j = O ? O.baselinePennies !== O.pennies ? `${A}_percent_price` : O.baselineCoins !== O.coins ? `${y}_percent_bonus` : void 0 : void 0, I = v === c.GoldPurchaseType.Premium ? s.Eb : O ? O.pennies : void 0;
					return {
						...d.p(e),
						comment: n ? d.i({
							state: e,
							commentId: n
						}) : null,
						correlationId: a.s(e) || Object(m.d)(m.a.GoldPayment, !1),
						post: n ? d.L(e, n) : null,
						screen: d.db(e),
						subreddit: n ? d.mb(e) : null,
						goldPurchase: {
							...h ? Object(b.a)(h) : null,
							type: v,
							gildedContent: f,
							contentType: x,
							numberCoins: O ? O.coins : void 0,
							offerContext: C,
							offerType: j
						},
						payment: {
							currency: "USD",
							amountInSmallestDenom: I
						},
						purchase: {
							priceMicros: I
						}
					}
				},
				h = (e, t, n) => s => ({
					...f(s, {
						packageId: t,
						thingId: e,
						offerContext: n
					}),
					source: "gold_payment",
					action: "click",
					noun: "close"
				}),
				g = e => t => ({
					...f(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "paypal"
				}),
				v = e => t => ({
					...f(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "continue_paypal"
				}),
				x = e => t => ({
					...f(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "credit_card"
				}),
				E = e => t => ({
					...f(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "complete_credit_card"
				}),
				O = (e, t) => n => ({
					...f(n, {
						packageId: e,
						offerContext: t
					}),
					source: "gold_payment",
					action: "click",
					noun: "confirm"
				}),
				C = e => t => ({
					...f(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "display",
					noun: "error"
				}),
				A = (e, t, n) => s => {
					const r = f(s, {
						packageId: t,
						thingId: e,
						offerContext: n
					});
					return {
						...r,
						source: "gold_payment",
						action: "view",
						noun: "page",
						payment: {
							...r.payment,
							defaultOption: l.PaymentMethod.Paypal
						},
						goldPurchase: {
							...r.goldPurchase,
							source: e ? c.GiveGold : a.p(s) ? c.PremiumMarketing : c.CoinsMarketing
						}
					}
				},
				y = e => t => {
					var n;
					const s = f(t, {
						thingId: e
					});
					return {
						...s,
						source: "gold_payment",
						action: "view",
						noun: "success",
						payment: {
							...s.payment,
							method: (null === (n = t.platform.currentPage) || void 0 === n ? void 0 : n.queryParams.thanks) ? l.PaymentMethod.Paypal : l.PaymentMethod.CreditCard
						}
					}
				}
		},
		"./src/reddit/helpers/trackers/inbox.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return s
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "v", (function() {
				return m
			})), n.d(t, "s", (function() {
				return p
			})), n.d(t, "q", (function() {
				return b
			})), n.d(t, "i", (function() {
				return f
			})), n.d(t, "t", (function() {
				return h
			})), n.d(t, "u", (function() {
				return g
			})), n.d(t, "A", (function() {
				return v
			})), n.d(t, "j", (function() {
				return x
			})), n.d(t, "w", (function() {
				return E
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "k", (function() {
				return C
			})), n.d(t, "B", (function() {
				return A
			})), n.d(t, "r", (function() {
				return y
			})), n.d(t, "m", (function() {
				return j
			})), n.d(t, "l", (function() {
				return I
			})), n.d(t, "h", (function() {
				return k
			})), n.d(t, "g", (function() {
				return _
			})), n.d(t, "b", (function() {
				return S
			})), n.d(t, "n", (function() {
				return w
			})), n.d(t, "x", (function() {
				return T
			})), n.d(t, "o", (function() {
				return P
			})), n.d(t, "y", (function() {
				return N
			})), n.d(t, "z", (function() {
				return D
			})), n.d(t, "p", (function() {
				return M
			}));
			var s, r, o, i, a, d, c = n("./src/reddit/constants/tracking.ts"),
				l = n("./src/reddit/selectors/telemetry.ts"),
				u = n("./src/telemetry/index.ts");
			! function(e) {
				e.Activity = "activity", e.Messages = "messages"
			}(s || (s = {})),
			function(e) {
				e.HideNotifications = "hide_notification", e.HideSubreddit = "hide_subreddit", e.BlockAwarder = "block_awarder", e.DecreaseSubredditUpdates = "disable_frequent"
			}(r || (r = {})),
			function(e) {
				e.MiniInbox = "mini_inbox", e.Inbox = "inbox"
			}(o || (o = {})),
			function(e) {
				e.Inbox = "inbox", e.Nav = "nav", e.Settings = "notification_app_settings"
			}(i || (i = {})),
			function(e) {
				e[e.FIRST = 1] = "FIRST", e[e.SECOND = 2] = "SECOND"
			}(a || (a = {})),
			function(e) {
				e.Confirm = "confirm"
			}(d || (d = {}));
			const m = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r
					} = e;
					return e => ({
						...l.p(e),
						action: c.c.VIEW,
						noun: "inbox_notification",
						source: "inbox",
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						}
					})
				},
				p = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r,
						awardId: o
					} = e;
					return e => {
						Object(u.a)({
							...l.p(e),
							action: "receive",
							noun: "inbox_notification",
							source: i.Inbox,
							inbox: {
								id: t,
								isClicked: n,
								isViewed: s
							},
							notification: {
								type: r
							},
							goldPurchase: {
								awardId: o
							}
						})
					}
				},
				b = e => {
					let {
						dnPromptAction: t
					} = e;
					return e => ({
						...l.p(e),
						action: c.c.CLICK,
						noun: "inbox_banner",
						source: "inbox",
						banner: {
							id: "inbox_dn_banner"
						},
						actionInfo: {
							pageType: "dn_prompt",
							type: t
						}
					})
				},
				f = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r,
						awardId: o,
						position: i,
						postId: a,
						subredditId: d
					} = e;
					return e => ({
						...l.p(e),
						action: c.c.CLICK,
						noun: "inbox_notification",
						source: "inbox",
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						},
						goldPurchase: {
							awardId: o
						},
						actionInfo: {
							position: i
						},
						subreddit: d ? {
							id: d
						} : null,
						post: a ? {
							id: a
						} : null
					})
				},
				h = e => {
					let {
						badgeCount: t,
						tab: n
					} = e;
					return e => ({
						...l.p(e),
						action: c.c.VIEW,
						noun: "inbox",
						source: i.Inbox,
						inbox: {
							badgeCount: t,
							tab: n
						}
					})
				},
				g = e => {
					let {
						badgeCount: t,
						tab: n
					} = e;
					return e => ({
						...l.p(e),
						action: c.c.VIEW,
						noun: "mini-inbox",
						source: i.Inbox,
						inbox: {
							badgeCount: t,
							tab: s.Activity
						}
					})
				},
				v = e => {
					let {
						badgeCount: t
					} = e;
					return e => ({
						...l.p(e),
						action: c.c.CLICK,
						noun: "inbox",
						source: i.Nav,
						inbox: {
							badgeCount: t
						}
					})
				},
				x = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r,
						awardId: o
					} = e;
					return e => ({
						...l.p(e),
						action: c.c.CLICK,
						noun: "inbox_notification_overflow",
						source: i.Inbox,
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						},
						goldPurchase: {
							awardId: o
						}
					})
				},
				E = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r
					} = e;
					return e => ({
						...l.p(e),
						action: c.c.VIEW,
						noun: "inbox_notification_overflow",
						source: i.Inbox,
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						}
					})
				};
			var O;
			! function(e) {
				e.Cats = "cats", e.Memes = "memes", e.Karma = "karma_free_subs", e.PN_perms = "pn_perms", e.Email_perms = "email_perms"
			}(O || (O = {}));
			const C = e => {
					let {
						actionInfoType: t,
						id: n,
						isClicked: s,
						isViewed: r,
						type: o
					} = e;
					return e => ({
						...l.p(e),
						action: c.c.CLICK,
						noun: "overflow_option",
						source: i.Inbox,
						inbox: {
							id: n,
							isClicked: s,
							isViewed: r
						},
						notification: {
							type: o
						},
						actionInfo: {
							...l.d(e),
							type: t
						}
					})
				},
				A = e => {
					let {
						actionInfoType: t,
						id: n,
						isClicked: s,
						isViewed: r,
						type: o
					} = e;
					return e => ({
						...l.p(e),
						action: c.c.UNDO,
						noun: "overflow_option",
						source: i.Inbox,
						inbox: {
							id: n,
							isClicked: s,
							isViewed: r
						},
						notification: {
							type: o
						},
						actionInfo: {
							...l.d(e),
							type: t
						}
					})
				},
				y = e => {
					let {
						actionInfoType: t
					} = e;
					return e => ({
						...l.p(e),
						action: c.c.CLICK,
						noun: "empty_state_cta",
						source: i.Inbox,
						actionInfo: {
							...l.d(e),
							type: t
						}
					})
				},
				j = e => t => ({
					...l.p(t),
					action: c.c.CLICK,
					noun: "notification_app_settings",
					source: i.Inbox,
					actionInfo: {
						...l.d(t),
						pageType: e
					}
				}),
				I = () => e => ({
					...l.p(e),
					action: c.c.CLICK,
					noun: "see_all",
					source: i.Inbox,
					actionInfo: {
						...l.d(e),
						pageType: o.MiniInbox
					}
				}),
				k = () => e => ({
					...l.p(e),
					action: c.c.CLICK,
					noun: "messages",
					source: i.Inbox
				}),
				_ = e => {
					let {
						isMiniInbox: t
					} = e;
					return e => ({
						...l.p(e),
						action: c.c.CLICK,
						noun: "mark_all_as_read",
						source: i.Inbox,
						actionInfo: t ? {
							...l.d(e),
							pageType: o.MiniInbox
						} : {}
					})
				};
			var S;
			! function(e) {
				e.DISMISS = "dismiss", e.BANNER = "banner", e.CTA_1 = "cta1", e.CTA_2 = "cta2"
			}(S || (S = {}));
			const w = (e, t) => n => ({
					...l.p(n),
					action: c.c.CLICK,
					noun: "inbox_banner",
					source: "inbox",
					actionInfo: {
						...l.d(n),
						type: t
					},
					banner: {
						id: e
					}
				}),
				T = (e, t) => n => ({
					...l.p(n),
					action: c.c.CLICK,
					noun: "inbox_banner",
					source: "mini_inbox",
					actionInfo: {
						...l.d(n),
						type: t
					},
					banner: {
						id: e
					}
				}),
				P = e => t => ({
					...l.p(t),
					action: c.c.RECEIVE,
					noun: "inbox_banner",
					source: "inbox",
					actionInfo: {
						...l.d(t)
					},
					banner: {
						id: e
					}
				}),
				N = e => t => ({
					...l.p(t),
					action: c.c.RECEIVE,
					noun: "inbox_banner",
					source: "mini_inbox",
					actionInfo: {
						...l.d(t)
					},
					banner: {
						id: e
					}
				}),
				D = e => t => ({
					...l.p(t),
					action: c.c.VIEW,
					noun: "inbox_banner",
					source: "mini_inbox",
					actionInfo: {
						...l.d(t)
					},
					banner: {
						id: e
					}
				}),
				M = e => t => ({
					...l.p(t),
					action: c.c.VIEW,
					noun: "inbox_banner",
					source: "inbox",
					actionInfo: {
						...l.d(t)
					},
					banner: {
						id: e
					}
				})
		},
		"./src/reddit/helpers/trackers/inlineSubredditEditing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			}));
			var s, r = n("./src/reddit/constants/tracking.ts"),
				o = n("./src/reddit/selectors/telemetry.ts");
			! function(e) {
				e.SubredditInlineTooltip = "subreddit_inline_tooltip", e.EditSubredditIcon = "edit_subreddit_icon", e.EditSubredditDescription = "edit_subreddit_description", e.SaveDescription = "save_description", e.Error = "error"
			}(s || (s = {}));
			const i = e => ({
					subreddit: o.mb(e),
					userSubreddit: o.vb(e)
				}),
				a = e => ({
					source: "subreddit_tooltip",
					noun: s.SubredditInlineTooltip,
					action: r.c.VIEW,
					...i(e)
				}),
				d = e => ({
					source: "id_card",
					noun: s.EditSubredditIcon,
					action: r.c.CLICK,
					...i(e)
				}),
				c = e => ({
					source: "id_card",
					noun: s.EditSubredditDescription,
					action: r.c.CLICK,
					...i(e)
				}),
				l = (e, t) => n => ({
					source: "id_card",
					noun: s.SaveDescription,
					action: r.c.CLICK,
					setting: {
						value: String(e),
						oldValue: String(t)
					},
					...i(n)
				}),
				u = (e, t) => ({
					source: "id_card",
					noun: s.Error,
					action: r.c.VIEW,
					...i(e),
					...o.p(e),
					actionInfo: o.d(e, {
						reason: t
					})
				})
		},
		"./src/reddit/helpers/trackers/lightbox.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/telemetry/index.ts"),
				o = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				i = n("./src/reddit/selectors/platform.ts"),
				a = n("./src/reddit/selectors/telemetry.ts");
			const d = e => ({
					profile: a.U(e),
					screen: a.db(e),
					subreddit: a.mb(e)
				}),
				c = (e, t, n) => s => ({
					source: Object(i.i)(s) || n ? "post_lightbox" : "post_detail",
					action: "click",
					noun: t,
					...d(s),
					post: a.L(s, e)
				}),
				l = (e, t, n, s) => r => {
					const i = n ? a.i({
							state: r,
							commentId: n
						}) : null,
						{
							sortToUse: d
						} = Object(o.a)(r, e);
					return {
						...c(e, t, s)(r),
						comment: i,
						listing: {
							sort: d
						}
					}
				},
				u = (e, t) => n => {
					const s = a.l(n);
					return s ? c(s.id, e, t)(n) : {
						source: Object(i.i)(n) || t ? "post_lightbox" : "post_detail",
						action: "click",
						noun: e,
						...d(n)
					}
				},
				m = (e, t) => n => Object(r.a)({
					...c(e, t)(n),
					...a.p(n)
				}),
				p = e => t => ({
					source: "id_card",
					action: s.c.CLICK,
					noun: e,
					...d(t),
					post: a.l(t),
					userSubreddit: a.vb(t)
				})
		},
		"./src/reddit/helpers/trackers/marketplace/claims.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "k", (function() {
				return c
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "g", (function() {
				return h
			}));
			var s = n("./src/reddit/selectors/avatarPushcard.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = () => e => ({
					...Object(r.p)(e),
					source: "marketplace",
					action: "view",
					noun: "claim_post_unit"
				}),
				i = () => e => ({
					...Object(r.p)(e),
					source: "marketplace",
					action: "click",
					noun: "claim_post_unit"
				}),
				a = () => e => ({
					...Object(r.p)(e),
					source: "marketplace",
					action: "close",
					noun: "claim_post_unit"
				});
			var d;
			! function(e) {
				e.Profile = "profile", e.Hovercard = "hovercard"
			}(d || (d = {}));
			const c = e => t => {
					const n = Object(r.p)(t);
					return {
						...n,
						source: "marketplace",
						action: "view",
						noun: "product_detail_page",
						actionInfo: {
							...n.actionInfo,
							reason: e,
							pageType: "product_detail_page"
						}
					}
				},
				l = (e, t, n) => o => {
					const i = Object(s.a)(o).id;
					return {
						...Object(r.p)(o),
						source: e,
						action: t,
						noun: n,
						goldPurchase: {
							offerContext: i
						}
					}
				},
				u = l("marketplace_top_nav", "view", "achievement_icon"),
				m = l("marketplace_top_nav", "click", "achievement_icon"),
				p = l("user_drawer", "view", "pushcard"),
				b = l("user_drawer", "click", "pushcard"),
				f = l("user_drawer", "dismiss", "pushcard"),
				h = l("user_drawer", "dismiss_confirm", "pushcard")
		},
		"./src/reddit/helpers/trackers/marketplace/display-collectibles.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/helpers/userSnoovatar/index.ts"),
				r = n("./src/reddit/helpers/trackers/snoovatar.ts");
			const o = e => {
				let {
					sendEvent: t,
					user: n,
					pageType: o,
					isDisplayCollectiblesEnabled: i
				} = e;
				const a = Object(s.b)(n.accountIcon);
				i && a || t(Object(r.m)({
					user: n,
					pageType: o,
					userHasNft: a
				}))
			}
		},
		"./src/reddit/helpers/trackers/modHub.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return l
			}));
			var s = n("./src/reddit/selectors/telemetry.ts");
			const r = e => ({
					screen: s.db(e),
					subreddit: s.mb(e),
					profile: s.U(e),
					userSubreddit: s.vb(e)
				}),
				o = e => t => ({
					source: "mod_hub_nav",
					action: "click",
					noun: e,
					...r(t)
				}),
				i = e => {
					let {
						noun: t,
						action: n,
						source: o,
						paneName: i
					} = e;
					return e => ({
						source: o,
						action: n,
						noun: t,
						...r(e),
						actionInfo: {
							...s.d(e),
							paneName: i
						}
					})
				},
				a = () => e => ({
					source: "breadcrumb",
					action: "click",
					noun: "subreddit",
					...r(e)
				}),
				d = () => e => ({
					source: "id_card",
					action: "click",
					noun: "mod_hub_nav",
					...r(e)
				}),
				c = (e, t) => n => ({
					...r(n),
					source: "modmanagement",
					action: "click",
					noun: "permission",
					setting: {
						value: e,
						values: t
					}
				}),
				l = (e, t, n) => s => ({
					...r(s),
					source: "modmanagement",
					action: "click",
					noun: e,
					setting: {
						value: "",
						values: n
					},
					chat: {
						recipient_user_id: t
					}
				})
		},
		"./src/reddit/helpers/trackers/modListing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			}));
			var s = n("./src/reddit/selectors/telemetry.ts");
			const r = () => e => ({
					source: "r_mod",
					action: "click",
					noun: "hide_subreddit"
				}),
				o = () => e => ({
					source: "r_mod",
					action: "click",
					noun: "unhide_subreddit"
				}),
				i = e => t => ({
					source: "r_mod",
					action: "click",
					noun: e ? "unfiltered_subreddits" : "filtered_subreddits"
				}),
				a = (e, t) => n => ({
					source: "moderator",
					action: "view",
					noun: "activemod_details",
					...Object(s.p)(n),
					actionInfo: {
						pageType: "moderation_pages_modqueue",
						paneName: e ? "general_queue" : "community"
					},
					subreddit: {
						name: t.toLowerCase(),
						...Object(s.ob)(n, t)
					}
				}),
				d = (e, t, n) => r => ({
					source: "moderator",
					action: "click",
					noun: "subreddit_filter",
					...Object(s.p)(r),
					actionInfo: {
						pageType: "moderation_pages_modqueue",
						paneName: n ? "activity_card" : "queue_filters",
						reason: e ? "active" : "inactive"
					},
					subreddit: {
						name: t.toLowerCase(),
						...Object(s.ob)(r, t)
					}
				}),
				c = (e, t, n, r) => o => ({
					source: "moderator",
					action: "click",
					noun: r ? "expand_previous_actions" : "collapse_previous_actions",
					...Object(s.p)(o),
					actionInfo: {
						pageType: "moderation_pages_modqueue",
						paneName: n ? "post" : "comment",
						reason: t
					},
					subreddit: Object(s.nb)(o, e)
				})
		},
		"./src/reddit/helpers/trackers/modLog.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "m", (function() {
				return p
			})), n.d(t, "n", (function() {
				return b
			})), n.d(t, "i", (function() {
				return f
			})), n.d(t, "j", (function() {
				return h
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "l", (function() {
				return x
			})), n.d(t, "k", (function() {
				return E
			}));
			var s = n("./src/reddit/selectors/telemetry.ts");
			const r = e => ({
					subreddit: s.mb(e),
					userSubreddit: s.vb(e)
				}),
				o = () => e => ({
					source: "mod_log",
					action: "click",
					noun: "mod_filter_dropdown",
					...r(e),
					actionInfo: s.d(e)
				}),
				i = () => e => ({
					source: "mod_filter_dropdown",
					action: "click",
					noun: "moderator",
					...r(e),
					actionInfo: s.d(e)
				}),
				a = () => e => ({
					source: "mod_log",
					action: "click",
					noun: "mod_action_dropdown",
					...r(e),
					actionInfo: s.d(e)
				}),
				d = () => e => ({
					source: "mod_action_dropdown",
					action: "click",
					noun: "action",
					...r(e),
					actionInfo: s.d(e)
				}),
				c = () => e => ({
					source: "moderator",
					action: "click",
					noun: "date_filter_dropdown",
					...r(e),
					actionInfo: s.d(e)
				}),
				l = () => e => ({
					source: "moderator",
					action: "filter",
					noun: "date_filter_dropdown",
					...r(e),
					actionInfo: s.d(e)
				}),
				u = () => e => ({
					source: "moderator",
					action: "click",
					noun: "author_filter_dropdown",
					...r(e),
					actionInfo: s.d(e)
				}),
				m = () => e => ({
					source: "moderator",
					action: "filter",
					noun: "author_filter_dropdown",
					...r(e),
					actionInfo: s.d(e)
				}),
				p = () => e => ({
					source: "moderator",
					action: "click",
					noun: "post_urls_filter_dropdown",
					...r(e),
					actionInfo: s.d(e)
				}),
				b = () => e => ({
					source: "moderator",
					action: "filter",
					noun: "post_urls_filter_dropdown",
					...r(e),
					actionInfo: s.d(e)
				}),
				f = e => {
					let {
						violatedContentPolicyRule: t,
						post: n,
						comment: r
					} = e;
					return e => ({
						source: "mod_log",
						action: "click",
						noun: "user_profile",
						post: n,
						comment: r,
						...s.p(e),
						actionInfo: s.d(e, {
							reason: t
						})
					})
				},
				h = e => {
					let {
						violatedContentPolicyRule: t,
						post: n,
						comment: r
					} = e;
					return e => ({
						source: "mod_log",
						action: "click",
						noun: (null == r ? void 0 : r.id) ? "comment" : "post",
						post: n,
						comment: r,
						...s.p(e),
						actionInfo: s.d(e, {
							reason: t
						})
					})
				},
				g = e => {
					let {
						violatedContentPolicyRule: t,
						post: n,
						comment: r
					} = e;
					return e => ({
						source: "mod_log",
						action: "click",
						noun: "content_policy",
						post: n,
						comment: r,
						...s.p(e),
						actionInfo: s.d(e, {
							reason: t
						})
					})
				},
				v = e => {
					let {
						violatedContentPolicyRule: t,
						post: n,
						comment: r
					} = e;
					return e => ({
						source: "mod_log",
						action: "click",
						noun: "show_details",
						post: n,
						comment: r,
						...s.p(e),
						actionInfo: s.d(e, {
							reason: t
						})
					})
				},
				x = () => e => ({
					source: "moderator",
					action: "click",
					noun: "pagesize",
					...s.p(e),
					actionInfo: s.d(e)
				}),
				E = () => e => ({
					source: "moderator",
					action: "click",
					noun: "modlog_helpcenter",
					...s.p(e),
					actionInfo: s.d(e)
				})
		},
		"./src/reddit/helpers/trackers/modNote.ts": function(e, t, n) {
			"use strict";
			n.d(t, "w", (function() {
				return a
			})), n.d(t, "r", (function() {
				return d
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "o", (function() {
				return f
			})), n.d(t, "p", (function() {
				return h
			})), n.d(t, "q", (function() {
				return g
			})), n.d(t, "x", (function() {
				return v
			})), n.d(t, "a", (function() {
				return x
			})), n.d(t, "k", (function() {
				return E
			})), n.d(t, "l", (function() {
				return O
			})), n.d(t, "y", (function() {
				return C
			})), n.d(t, "s", (function() {
				return A
			})), n.d(t, "n", (function() {
				return y
			})), n.d(t, "m", (function() {
				return j
			})), n.d(t, "u", (function() {
				return I
			})), n.d(t, "t", (function() {
				return k
			})), n.d(t, "v", (function() {
				return _
			})), n.d(t, "j", (function() {
				return S
			})), n.d(t, "b", (function() {
				return w
			})), n.d(t, "c", (function() {
				return T
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => {
					var n, s, r, o, i, a, d, c, l, u, m;
					const {
						modNote: p,
						subredditId: b,
						userId: f,
						postId: h,
						commentId: g,
						subredditSearch: v,
						filteredType: x,
						filteredSubredditId: E
					} = t, O = g || (null === (s = null === (n = p) || void 0 === n ? void 0 : n.commentInfo) || void 0 === s ? void 0 : s.id), C = h || (null === (o = null === (r = p) || void 0 === r ? void 0 : r.postInfo) || void 0 === o ? void 0 : o.id);
					return {
						modnote: {
							type: null == p ? void 0 : p.itemType,
							content: null === (i = p) || void 0 === i ? void 0 : i.note,
							label: null === (d = null === (a = p) || void 0 === a ? void 0 : a.label) || void 0 === d ? void 0 : d.toLowerCase(),
							operatorId: null === (c = null == p ? void 0 : p.operator) || void 0 === c ? void 0 : c.id,
							subredditSearch: v,
							filteredType: null == x ? void 0 : x.toLowerCase(),
							filteredSubredditId: null == E ? void 0 : E.toLowerCase()
						},
						modAction: {
							targetUserId: f || (null === (l = null == p ? void 0 : p.user) || void 0 === l ? void 0 : l.id),
							action: null === (m = null === (u = p) || void 0 === u ? void 0 : u.actionType) || void 0 === m ? void 0 : m.toLowerCase()
						},
						...O ? {
							comment: {
								id: O,
								postId: C || "none"
							}
						} : null,
						...C ? {
							post: {
								id: C
							}
						} : null,
						subreddit: {
							id: b
						}
					}
				},
				i = "moderator",
				a = e => t => ({
					source: i,
					action: "view",
					noun: "modnote_quickaccess",
					correlationId: Object(s.d)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				d = e => t => {
					const n = {
						source: i,
						action: "close",
						noun: "modnote_quickaccess",
						correlationId: Object(s.c)(s.a.ModNotes),
						...r.p(t),
						...o(0, e)
					};
					return Object(s.b)(s.a.ModNotes), n
				},
				c = e => t => ({
					source: i,
					action: "click",
					noun: "relatedcontent_modnote_quickaccess",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				l = e => t => ({
					source: i,
					action: "click",
					noun: "relatedcontent_modnote_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				u = e => t => ({
					source: i,
					action: "click",
					noun: "relatedcontent_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				m = e => t => ({
					source: i,
					action: "click",
					noun: "expand_modlog_quickaccess",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				p = e => t => ({
					source: i,
					action: "click",
					noun: "expand_modlog_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				b = e => t => ({
					source: i,
					action: "click",
					noun: "expand_modnote_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				f = e => t => ({
					source: i,
					action: "click",
					noun: "username_modnote_quickaccess",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				h = e => t => ({
					source: i,
					action: "click",
					noun: "mod_username_modnote_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				g = e => t => ({
					source: i,
					action: "click",
					noun: "username_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				v = e => t => ({
					source: i,
					action: "view",
					noun: "user_profile_hovercard",
					correlationId: Object(s.d)(s.a.ModNotes, !1),
					...r.p(t),
					...o(0, e)
				}),
				x = e => t => ({
					source: i,
					action: "click",
					noun: "add_note_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				E = e => t => ({
					source: i,
					action: "click",
					noun: "user_mod_log_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				O = e => t => ({
					source: i,
					action: "click",
					noun: "send_modmail_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				C = e => t => ({
					source: i,
					action: "view",
					noun: "modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				A = e => t => ({
					source: i,
					action: "close",
					noun: "modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				y = e => t => ({
					source: i,
					action: "click",
					noun: "type_filter_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				j = e => t => ({
					source: i,
					action: "click",
					noun: "subreddit_filter_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				I = e => t => ({
					source: i,
					action: "select",
					noun: "type_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				k = e => t => ({
					source: i,
					action: "select",
					noun: "subreddit_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				_ = e => t => ({
					source: i,
					action: "submit",
					noun: "submit_note_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				S = e => t => ({
					source: i,
					action: "click",
					noun: "delete_modnote_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				w = e => t => ({
					source: i,
					action: "click",
					noun: "cancel_deletemodnote",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				}),
				T = e => t => ({
					source: i,
					action: "click",
					noun: "delete_deletemodnote",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.p(t),
					...o(0, e)
				})
		},
		"./src/reddit/helpers/trackers/modTools.ts": function(e, t, n) {
			"use strict";
			n.d(t, "m", (function() {
				return i
			})), n.d(t, "n", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "q", (function() {
				return f
			})), n.d(t, "l", (function() {
				return h
			})), n.d(t, "k", (function() {
				return g
			})), n.d(t, "r", (function() {
				return v
			})), n.d(t, "i", (function() {
				return x
			})), n.d(t, "j", (function() {
				return E
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "o", (function() {
				return C
			})), n.d(t, "p", (function() {
				return A
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => ({
					screen: Object(r.db)(e),
					profile: Object(r.U)(e),
					subreddit: Object(r.mb)(e),
					userSubreddit: Object(r.vb)(e)
				}),
				i = e => t => ({
					source: "nav",
					action: "click",
					noun: e ? "mod_mode_on" : "mod_mode_off",
					...o(t)
				}),
				a = (e, t) => n => ({
					source: "post_mod_action_menu",
					action: "click",
					noun: e,
					post: Object(r.L)(n, t),
					...o(n)
				}),
				d = (e, t) => n => ({
					source: "comment",
					action: "click",
					noun: e,
					post: Object(r.L)(n, t),
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					media: {
						mimetype: Object(r.k)(n, t)
					},
					...o(n)
				}),
				c = (e, t) => n => ({
					source: "comment",
					action: s.c.CLICK,
					noun: e,
					post: Object(r.L)(n, t),
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					actionInfo: {
						pageType: "chat_live_post"
					},
					...o(n)
				}),
				l = (e, t) => n => ({
					source: "comment",
					action: s.c.UNDO,
					noun: e,
					post: Object(r.L)(n, t),
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					...o(n)
				}),
				u = (e, t) => n => ({
					source: "comment_overflow_menu",
					action: "click",
					noun: e,
					post: Object(r.L)(n, t),
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					...o(n)
				}),
				m = (e, t) => n => ({
					source: "mod_distinguish_menu",
					action: "click",
					noun: e,
					post: Object(r.L)(n, t),
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					...o(n)
				}),
				p = (e, t) => n => ({
					source: "comment_mod_action_menu",
					action: "click",
					noun: e,
					post: Object(r.L)(n, t),
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					...o(n)
				}),
				b = (e, t) => n => ({
					source: "comment_report_menu",
					action: "click",
					noun: e,
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					post: Object(r.L)(n, t),
					...o(n)
				}),
				f = (e, t) => n => ({
					source: "post_report_menu",
					action: "click",
					noun: e,
					post: Object(r.L)(n, t),
					...o(n)
				}),
				h = (e, t) => n => ({
					source: "post",
					action: "click",
					noun: e,
					post: Object(r.L)(n, t),
					subreddit: Object(r.pb)(n, t)
				}),
				g = (e, t) => n => ({
					source: "comment",
					action: "click",
					noun: e,
					comment: Object(r.i)({
						state: n,
						commentId: t
					}),
					post: Object(r.L)(n, t),
					subreddit: Object(r.pb)(n, t)
				}),
				v = (e, t, n, s) => o => ({
					source: e ? "comment" : "post",
					action: "click",
					noun: t ? "unsnooze_reporter" : "snooze_reporter",
					post: Object(r.L)(o, n),
					subreddit: Object(r.pb)(o, n),
					actionInfo: {
						reason: s
					},
					...e && {
						comment: Object(r.i)({
							state: o,
							commentId: n
						})
					}
				}),
				x = () => e => ({
					...o(e),
					source: "modqueue",
					noun: "content_type_live_post",
					action: "view",
					actionInfo: {
						pageType: "chat_live_post"
					}
				}),
				E = (e, t, n) => s => ({
					...o(s),
					source: "moderator",
					noun: "action",
					action: "click",
					actionInfo: {
						pageType: "mod_queue",
						paneName: n,
						reason: t
					},
					comment: Object(r.i)({
						state: s,
						commentId: e
					}) || void 0,
					post: Object(r.L)(s, e)
				}),
				O = (e, t) => n => ({
					...o(n),
					source: "moderator",
					noun: "add_note_mod_queue",
					action: "click",
					comment: Object(r.i)({
						state: n,
						commentId: e
					}) || void 0,
					post: Object(r.L)(n, e),
					modAction: {
						targetUserId: t
					}
				}),
				C = (e, t, n, s) => i => ({
					source: "post_mod_action_menu",
					action: "click",
					post: Object(r.L)(i, t),
					noun: e,
					setting: {
						value: n,
						oldValue: s
					},
					...o(i)
				}),
				A = (e, t, n, s) => i => ({
					source: "post_mod_action_menu",
					action: "save",
					post: Object(r.L)(i, t),
					noun: e,
					setting: {
						value: n,
						oldValue: s
					},
					...o(i)
				})
		},
		"./src/reddit/helpers/trackers/moderationPages.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => ({
					screen: r.db(e),
					profile: r.U(e),
					subreddit: r.mb(e)
				}),
				i = e => {
					switch (e) {
						case s.mc.Banned:
							return "banned";
						case s.mc.Muted:
							return "muted";
						case s.mc.Contributors:
							return "contributors";
						case s.mc.Moderators:
							return "modmanagement";
						case s.mc.Removal:
							return "set_removal_reasons";
						case s.mc.CommunitySettings:
							return "edit";
						default:
							return e
					}
				},
				a = (e, t) => n => ({
					source: i(t),
					noun: e,
					action: "click",
					...o(n)
				}),
				d = e => t => ({
					source: i(e),
					noun: "hover_user_hovercard",
					action: "view",
					...o(t)
				})
		},
		"./src/reddit/helpers/trackers/postCollection.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "n", (function() {
				return f
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "p", (function() {
				return x
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "j", (function() {
				return O
			})), n.d(t, "q", (function() {
				return C
			})), n.d(t, "k", (function() {
				return A
			})), n.d(t, "l", (function() {
				return y
			})), n.d(t, "i", (function() {
				return j
			})), n.d(t, "d", (function() {
				return I
			}));
			var s, r, o = n("./src/reddit/constants/tracking.ts"),
				i = n("./src/reddit/helpers/trackers/postEvent.ts"),
				a = n("./src/reddit/selectors/platform.ts"),
				d = n("./src/reddit/selectors/telemetry.ts");
			! function(e) {
				e.collection = "collection", e.collectionComposer = "collection_composer", e.postComposer = "post_composer", e.postOverflowMenu = "post_overflow_menu"
			}(s || (s = {})),
			function(e) {
				e.post = "post", e.follow = "follow", e.unfollow = "unfollow", e.screen = "screen", e.eventEducation = "event_education", e.eventEducationGotIt = "event_education_got_it", e.collectionEducation = "collection_education", e.collectionEducationGotIt = "collection_education_got_it", e.collectionCancel = "cancel", e.collectionCreate = "collection_create", e.collectionSelect = "collection_select", e.collectionDelete = "collection_delete", e.collectionEdit = "collection_edit", e.collectionAddPost = "collection_add_post", e.collectionRemovePost = "remove_post_from_collection", e.startEvent = "start_event"
			}(r || (r = {}));
			const c = e => t => ({
					source: s.collection,
					noun: r.post,
					...m(t, e)
				}),
				l = e => {
					let {
						postId: t,
						isFollowed: n
					} = e;
					return e => ({
						source: s.collection,
						noun: n ? r.unfollow : r.follow,
						...m(e, t)
					})
				},
				u = e => {
					let {
						postId: t,
						isFollowed: n
					} = e;
					return e => ({
						source: i.a.postEvent,
						noun: n ? r.unfollow : r.follow,
						...m(e, t)
					})
				},
				m = (e, t) => {
					const n = {
						...d.p(e),
						action: o.c.CLICK,
						subreddit: d.mb(e)
					};
					return void 0 === t ? n : {
						...n,
						post: d.L(e, t),
						postCollection: d.N(e, {
							postId: t
						}),
						postEvent: d.O(e, {
							postId: t
						})
					}
				},
				p = e => ({
					...g(e),
					action: o.c.VIEW,
					noun: r.collectionEducation
				}),
				b = e => ({
					...g(e),
					action: o.c.CLICK,
					noun: r.collectionEducationGotIt
				}),
				f = e => ({
					...g(e),
					action: o.c.VIEW,
					noun: r.eventEducation
				}),
				h = e => ({
					...g(e),
					action: o.c.CLICK,
					noun: r.eventEducationGotIt
				}),
				g = e => ({
					...d.p(e),
					subreddit: d.mb(e),
					source: s.postComposer
				}),
				v = (e, t) => n => ({
					...m(n, e),
					source: t || s.postOverflowMenu,
					noun: r.collectionAddPost
				}),
				x = e => t => ({
					...m(t, e),
					source: s.collectionComposer,
					noun: r.collectionRemovePost
				}),
				E = () => e => ({
					...m(e),
					source: s.collectionComposer,
					noun: r.collectionCancel
				}),
				O = () => e => {
					const t = Object(a.o)(e) || void 0;
					return {
						...m(e, t),
						source: s.collectionComposer,
						noun: r.collectionCreate
					}
				},
				C = () => e => ({
					...m(e),
					source: s.collectionComposer,
					noun: r.collectionSelect
				}),
				A = e => t => ({
					...d.p(t),
					subreddit: d.mb(t),
					source: s.collectionComposer,
					action: o.c.CLICK,
					noun: r.collectionDelete,
					postCollection: d.M(t, {
						collectionId: e
					})
				}),
				y = e => t => ({
					...m(t),
					source: s.collectionComposer,
					noun: r.collectionEdit,
					postCollection: d.M(t, {
						collectionId: e
					})
				}),
				j = e => t => ({
					...m(t, e),
					source: s.collectionComposer,
					noun: r.startEvent
				}),
				I = () => e => {
					const t = Object(a.o)(e) || void 0;
					return {
						...m(e, t),
						source: s.collectionComposer,
						action: o.c.VIEW,
						noun: r.screen
					}
				}
		},
		"./src/reddit/helpers/trackers/postComposer.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return E
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "L", (function() {
				return C
			})), n.d(t, "J", (function() {
				return A
			})), n.d(t, "D", (function() {
				return y
			})), n.d(t, "z", (function() {
				return j
			})), n.d(t, "A", (function() {
				return I
			})), n.d(t, "N", (function() {
				return k
			})), n.d(t, "C", (function() {
				return _
			})), n.d(t, "m", (function() {
				return S
			})), n.d(t, "F", (function() {
				return w
			})), n.d(t, "E", (function() {
				return T
			})), n.d(t, "t", (function() {
				return P
			})), n.d(t, "s", (function() {
				return N
			})), n.d(t, "M", (function() {
				return D
			})), n.d(t, "p", (function() {
				return M
			})), n.d(t, "o", (function() {
				return R
			})), n.d(t, "q", (function() {
				return L
			})), n.d(t, "f", (function() {
				return F
			})), n.d(t, "r", (function() {
				return G
			})), n.d(t, "B", (function() {
				return q
			})), n.d(t, "j", (function() {
				return W
			})), n.d(t, "g", (function() {
				return z
			})), n.d(t, "h", (function() {
				return V
			})), n.d(t, "d", (function() {
				return K
			})), n.d(t, "I", (function() {
				return Y
			})), n.d(t, "i", (function() {
				return J
			})), n.d(t, "c", (function() {
				return X
			})), n.d(t, "v", (function() {
				return $
			})), n.d(t, "u", (function() {
				return ee
			})), n.d(t, "H", (function() {
				return te
			})), n.d(t, "w", (function() {
				return ne
			})), n.d(t, "k", (function() {
				return se
			})), n.d(t, "G", (function() {
				return re
			})), n.d(t, "y", (function() {
				return oe
			})), n.d(t, "b", (function() {
				return ie
			})), n.d(t, "n", (function() {
				return ae
			})), n.d(t, "x", (function() {
				return de
			})), n.d(t, "l", (function() {
				return ce
			})), n.d(t, "K", (function() {
				return le
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/helpers/correlationIdTracker.ts"),
				o = n("./src/reddit/helpers/media/index.ts"),
				i = n("./src/reddit/models/PostCreationForm/index.ts"),
				a = n("./src/reddit/models/PostDraft/index.ts"),
				d = n("./src/reddit/selectors/experiments/postCreationSubRec.ts"),
				c = n("./src/reddit/selectors/postDraft.ts"),
				l = n("./src/reddit/selectors/postGuidance.ts"),
				u = n("./src/reddit/selectors/subreddit.ts"),
				m = n("./src/reddit/selectors/telemetry.ts"),
				p = n("./src/reddit/selectors/user.ts"),
				b = n("./src/telemetry/index.ts"),
				f = n("./src/telemetry/models/PostComposer.ts"),
				h = n("./src/telemetry/models/PostDraft.ts");
			const g = {
					imageOnly: "image",
					linkOnly: "link",
					media: "media",
					poll: "poll",
					post: "self",
					prediction: "prediction",
					crosspost: "crosspost",
					talk: "talk"
				},
				v = e => ({
					source: "post_composer",
					action: s.c.CLICK,
					...m.p(e),
					screen: m.db(e),
					correlationId: Object(r.c)(r.a.PostComposer)
				}),
				x = (e, t) => "self" !== t ? {} : {
					editorMode: e.user.prefs.editorMode === i.i.MARKDOWN ? "markdown" : "rte"
				},
				E = e => {
					Object(b.a)({
						noun: "cancel",
						...v(e)
					})
				},
				O = e => {
					Object(b.a)({
						noun: "discard",
						...v(e)
					})
				},
				C = e => t => ({
					...v(t),
					noun: "subreddit_choice",
					subreddit: e ? m.nb(t, e) : void 0,
					actionInfo: m.h(t)
				}),
				A = () => e => ({
					...v(e),
					noun: "subreddit_selector"
				}),
				y = (e, t) => {
					Object(b.a)({
						noun: "post_type_selector",
						postComposer: {
							type: g[t]
						},
						...v(e)
					})
				},
				j = () => e => ({
					noun: "add_option",
					...v(e)
				}),
				I = () => e => ({
					noun: "voting_length",
					...v(e)
				}),
				k = (e, t, n) => {
					"image_upload" === t || "video_upload" === t ? Object(b.a)({
						noun: t,
						...v(e)
					}) : Object(b.a)({
						noun: "text_option",
						postComposer: {
							textType: t,
							finalStatus: n ? "on" : "off"
						},
						...v(e)
					})
				},
				_ = (e, t, n, s) => {
					Object(b.a)({
						noun: "post",
						subreddit: m.mb(e),
						postComposer: {
							type: t,
							...x(e, t)
						},
						post: n ? m.L(e, n) : null,
						...v(e),
						correlationId: s
					})
				},
				S = (e, t) => {
					const n = t === i.i.MARKDOWN ? "markdown_mode" : "rte_mode";
					Object(b.a)({
						noun: n,
						...v(e)
					})
				},
				w = (e, t) => {
					Object(b.a)({
						noun: "save",
						subreddit: m.mb(e),
						postComposer: {
							type: t,
							...x(e, t)
						},
						...v(e)
					})
				},
				T = (e, t) => {
					const n = e.uploads[t];
					n.error && Object(b.a)({
						...v(e),
						noun: "media",
						action: s.c.REJECT,
						actionInfo: {
							...m.d(e),
							reason: JSON.stringify(n.error)
						}
					})
				},
				P = (e, t) => {
					t.forEach(t => {
						const n = Object(o.g)(t.type);
						n && Object(b.a)({
							...v(e),
							action: s.c.DRAG,
							noun: n
						})
					})
				},
				N = (e, t, n) => {
					Object(b.a)({
						...v(e),
						noun: "input",
						postComposer: {
							inputType: n
						},
						action: t,
						actionInfo: m.h(e)
					})
				},
				D = (e, t, n) => {
					Object(b.a)({
						...v(e),
						noun: n,
						action: Object(f.getToggleAction)(t),
						actionInfo: m.h(e)
					})
				},
				M = e => B("input", e),
				R = () => B("add"),
				L = () => B("remove_image"),
				B = (e, t) => n => ({
					...v(n),
					noun: e,
					postComposer: {
						inputType: t,
						type: g.imageOnly
					},
					action: s.c.CLICK
				}),
				F = e => {
					Object(b.a)({
						...v(e),
						noun: "hide_oc_description",
						action: s.c.CLICK
					})
				},
				U = (e, t) => {
					if (t) {
						const n = m.nb(e, t);
						if (n) return {
							subreddit: n
						};
						const s = m.V(e, t);
						if (s) return {
							profile: s
						}
					}
				},
				H = (e, t) => {
					const n = l.e(e, {
							subredditName: t
						}),
						s = l.g(e);
					return {
						automoderator: {
							automod_post_guidance: !!n && n.postGuidanceConfig.length > 0,
							automod_post_guidance_ids: s
						}
					}
				},
				G = (e, t) => {
					const {
						draftId: n,
						destSubreddit: s
					} = t, r = Object(p.m)(e), o = Object(c.d)(e, {
						draftId: n
					}), i = {
						authorId: r ? r.id : void 0,
						createdTimestamp: o ? o.created : void 0,
						id: n || void 0,
						nsfw: t.isNSFW,
						originalContent: t.isOC,
						spoiler: t.isSpoiler,
						titleLength: t.title.length
					};
					switch (t.kind) {
						case a.b.Link:
							i.type = h.DraftType.Link, i.urlLength = t.body.length;
							break;
						case a.b.Markdown:
							i.type = h.DraftType.Self, i.bodyTextLength = t.body.length;
							break;
						case a.b.RichText:
							i.type = h.DraftType.RichText, t.documentStats && (i.bodyTextLength = t.documentStats.textLength, i.numberRteImages = t.documentStats.rteImagesCount, i.numberRteVideos = t.documentStats.rteVideosCount);
							break;
						case a.b.Image:
							i.type = h.DraftType.Image;
							break;
						case a.b.Video:
							i.type = h.DraftType.Video
					}
					return {
						postDraft: i,
						...U(e, s.id)
					}
				},
				Q = (e, t) => {
					const n = Object(p.m)(e),
						s = {
							authorId: n ? n.id : void 0,
							createdTimestamp: t.created,
							id: t.id,
							nsfw: t.isNSFW,
							originalContent: t.isOriginalContent,
							spoiler: t.isSpoiler,
							titleLength: t.title.length
						};
					switch (t.kind) {
						case a.b.Link:
							s.type = h.DraftType.Link, s.urlLength = (t.body || "").length;
							break;
						case a.b.Markdown:
							s.type = h.DraftType.Self, s.bodyTextLength = (t.body || "").length;
							break;
						case a.b.RichText:
							s.type = h.DraftType.RichText
					}
					return {
						postDraft: s,
						...U(e, t.subredditId)
					}
				},
				q = (e, t) => {
					Object(b.a)({
						noun: "post_guidance",
						...v(e),
						action: s.c.VIEW,
						actionInfo: {
							...m.d(e)
						},
						automoderator: {
							automod_post_guidance_ids: t
						}
					})
				},
				W = (e, t) => {
					Object(b.a)({
						noun: "draft_load",
						...v(e),
						...G(e, t)
					})
				},
				z = (e, t, n) => {
					Object(b.a)({
						noun: t.draftId ? "draft_update" : "draft_create",
						...v(e),
						...G(e, t),
						...H(e, n)
					})
				},
				V = (e, t) => {
					Object(b.a)({
						noun: "draft_delete",
						...v(e),
						...Q(e, t)
					})
				},
				K = e => {
					Object(b.a)({
						...v(e),
						noun: "social_connect_link",
						action: s.c.CLICK
					})
				},
				Y = (e, t) => {
					Object(b.a)({
						...v(e),
						noun: "twitter_share_checkbox",
						action: Object(f.getToggleAction)(t)
					})
				},
				J = (e, t, n) => {
					Object(b.a)({
						...v(e),
						...G(e, t),
						noun: "draft_share",
						action: n ? s.c.ENABLE : s.c.DISABLE
					})
				},
				X = e => {
					Object(b.a)({
						...v(e),
						noun: "create_community",
						actionInfo: {
							...m.d(e),
							pageType: "post_select_community"
						}
					})
				},
				Z = "community_recommendation",
				$ = () => e => ({
					...v(e),
					action: s.c.VIEW,
					noun: Z,
					listing: {
						links: Object(d.c)(e).map(t => Object(u.I)(e, t.name))
					}
				}),
				ee = (e, t) => n => ({
					...v(n),
					action: s.c.CLICK,
					noun: Z,
					actionInfo: {
						...m.d(n),
						position: t
					},
					subreddit: {
						name: e,
						id: Object(u.I)(n, e)
					}
				}),
				te = e => {
					Object(b.a)({
						...v(e),
						action: s.c.SKIP,
						noun: Z
					})
				},
				ne = (e, t) => n => ({
					...v(n),
					action: s.c.VIEW,
					noun: `${Z}_hover`,
					actionInfo: {
						...m.d(n),
						position: t
					},
					subreddit: {
						name: e,
						id: Object(u.I)(n, e)
					}
				}),
				se = e => t => ({
					...v(t),
					action: s.c.CLICK,
					noun: "draft_preview",
					actionInfo: {
						...m.d(t),
						count: e
					}
				}),
				re = e => t => ({
					...v(t),
					action: "add",
					noun: "flair",
					subreddit: m.nb(t, e)
				}),
				oe = () => e => ({
					...v(e),
					action: s.c.CLICK,
					noun: "flair_dropdown"
				}),
				ie = () => e => ({
					...v(e),
					action: "clear",
					noun: "flair"
				}),
				ae = () => e => ({
					...v(e),
					action: "search",
					noun: "flair"
				}),
				de = e => {
					let {
						actionInfoType: t,
						subredditId: n = "",
						noun: o = "create_post"
					} = e;
					return e => ({
						...v(e),
						action: s.c.CLICK,
						noun: o,
						actionInfo: {
							...m.d(e),
							type: t
						},
						correlationId: Object(r.d)(r.a.PostComposer, !1),
						subreddit: n ? m.nb(e, n) : void 0
					})
				},
				ce = () => e => ({
					...v(e),
					action: s.c.CLICK,
					noun: "edit_post"
				}),
				le = e => t => ({
					...v(t),
					action: "type",
					noun: "subreddit_search",
					actionInfo: {
						...m.d(t),
						type: e
					}
				})
		},
		"./src/reddit/helpers/trackers/postEvent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "d", (function() {
				return x
			}));
			var s, r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/eventTools/index.ts"),
				i = n("./src/lib/timezone/index.ts"),
				a = n("./src/reddit/constants/tracking.ts"),
				d = n("./src/reddit/models/PostCreationForm/index.ts"),
				c = n("./src/reddit/selectors/platform.ts"),
				l = n("./src/reddit/selectors/postCreations.ts"),
				u = n("./src/reddit/selectors/telemetry.ts"),
				m = n("./src/telemetry/index.ts");
			! function(e) {
				e.postEvent = "post_event", e.postComposer = "post_composer", e.eventComposer = "event_composer"
			}(s || (s = {}));
			const p = e => u.d(e, {
					pageType: "event_submit"
				}),
				b = e => {
					Object(m.a)({
						...u.p(e),
						source: s.postComposer,
						action: a.c.CLICK,
						noun: "event_create",
						subreddit: u.mb(e)
					})
				},
				f = e => {
					Object(m.a)({
						...u.p(e),
						source: s.postComposer,
						action: a.c.CLICK,
						noun: "event_edit",
						subreddit: u.mb(e),
						postEvent: E(e),
						postComposer: O(e)
					})
				},
				h = () => e => ({
					source: s.eventComposer,
					action: a.c.VIEW,
					noun: a.b.SCREEN,
					actionInfo: p(e),
					postEvent: E(e)
				}),
				g = e => t => ({
					...y(t, Object(c.o)(t)),
					source: s.postComposer,
					noun: "apply",
					postComposer: C(e)
				}),
				v = () => e => ({
					...y(e, Object(c.o)(e)),
					noun: "cancel",
					actionInfo: p(e)
				}),
				x = e => t => ({
					...y(t, Object(c.o)(t)),
					noun: "delete",
					actionInfo: p(t),
					postComposer: O(t),
					postEvent: A(e)
				}),
				E = e => {
					const t = Object(l.p)(e);
					return t && A(t)
				},
				O = e => C(Object(l.p)(e)),
				C = e => {
					return {
						postScheduled: !!e,
						submitScheduledTime: e && e.submitTime === d.j.AtEventTime ? Object(i.f)(e.startDate).getTime() / r.Xb : void 0
					}
				},
				A = e => {
					const t = Object(i.f)(e.startDate).getTime() / r.Xb,
						n = Object(i.f)(e.endDate).getTime() / r.Xb;
					return {
						eventStartTimestamp: t,
						eventEndTimestamp: n,
						eventState: Object(o.e)(t, n)
					}
				},
				y = (e, t) => {
					const n = {
						source: s.eventComposer,
						action: a.c.CLICK,
						subreddit: u.mb(e)
					};
					return t ? {
						...n,
						post: u.L(e, t),
						postEvent: u.O(e, {
							postId: t
						}),
						postCollection: u.N(e, {
							postId: t
						})
					} : n
				}
		},
		"./src/reddit/helpers/trackers/postFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/helpers/search/SearchTelemetrySource.ts"),
				o = n("./src/reddit/selectors/telemetry.ts"),
				i = n("./src/reddit/helpers/flair.ts"),
				a = n("./src/reddit/helpers/search/searchImpressionId.ts");
			const d = (e, t) => n => {
					const i = `flair_name:'${t.postFlairName}'`;
					return {
						source: "post",
						action: "click",
						noun: "post_flair",
						...o.p(n),
						actionInfo: o.d(n),
						correlationId: Object(s.c)(s.a.SearchResults),
						post: o.L(n, e),
						search: {
							...o.P(n, t),
							query: i,
							queryId: o.gb(n, r.a.SERP),
							impressionId: a.a.get(r.a.SERP)
						},
						subreddit: o.mb(n)
					}
				},
				c = e => t => ({
					source: "post_flair_widget",
					action: "click",
					noun: "post_flair_search",
					...o.p(t),
					actionInfo: o.d(t),
					correlationId: Object(s.c)(s.a.SearchResults),
					search: o.P(t, e),
					subreddit: o.mb(t)
				}),
				l = e => t => {
					const n = Object(i.g)(e);
					return {
						...o.p(t),
						action: "click",
						noun: "post_flair",
						source: "post_flair_widget",
						subreddit: o.mb(t),
						postFlair: {
							id: e.templateId,
							title: n
						}
					}
				},
				u = () => e => ({
					...o.p(e),
					action: "click",
					noun: "overflow",
					source: "post_flair_widget",
					subreddit: o.mb(e)
				}),
				m = e => t => {
					const n = Object(i.g)(e);
					return {
						...o.p(t),
						action: "click",
						noun: "clear",
						source: "post_flair_widget",
						subreddit: o.mb(t),
						postFlair: {
							id: e.templateId,
							title: n
						}
					}
				},
				p = (e, t) => n => {
					const s = Object(i.g)(e),
						d = o.L(n, t),
						c = `flair_name:'${s}'`;
					return {
						...o.p(n),
						action: "click",
						noun: "post_flair",
						source: "post",
						subreddit: o.mb(n),
						postFlair: {
							id: e.templateId,
							title: s
						},
						post: d,
						search: {
							query: c,
							subredditId: d ? d.subredditId : void 0,
							subredditName: d ? d.subredditName : void 0,
							postFlairName: s,
							originElement: "post_flair",
							queryId: o.gb(n, r.a.SERP),
							impressionId: a.a.get(r.a.SERP),
							originPageType: n.platform.currentPage ? o.w(n.platform.currentPage) : void 0
						},
						feed: o.s(n)
					}
				}
		},
		"./src/reddit/helpers/trackers/scheduledPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return a
			})), n.d(t, "y", (function() {
				return d
			})), n.d(t, "m", (function() {
				return c
			})), n.d(t, "p", (function() {
				return l
			})), n.d(t, "q", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "o", (function() {
				return b
			})), n.d(t, "r", (function() {
				return f
			})), n.d(t, "k", (function() {
				return h
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "n", (function() {
				return x
			})), n.d(t, "h", (function() {
				return E
			})), n.d(t, "g", (function() {
				return C
			})), n.d(t, "l", (function() {
				return A
			})), n.d(t, "t", (function() {
				return y
			})), n.d(t, "j", (function() {
				return j
			})), n.d(t, "e", (function() {
				return I
			})), n.d(t, "x", (function() {
				return k
			})), n.d(t, "u", (function() {
				return _
			})), n.d(t, "a", (function() {
				return S
			})), n.d(t, "s", (function() {
				return w
			})), n.d(t, "v", (function() {
				return T
			})), n.d(t, "w", (function() {
				return P
			}));
			var s = n("./src/reddit/models/ScheduledPost/index.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => ({
					...r.p(e),
					screen: r.db(e),
					subreddit: r.mb(e),
					userSubreddit: r.vb(e)
				}),
				i = e => ({
					id: e.id,
					publishAt: e.publishAt,
					clientTimezone: e.clientTimezone,
					isRecurring: Object(s.q)(e)
				}),
				a = () => e => ({
					source: "post_composer",
					action: "click",
					noun: "schedule_post",
					...o(e)
				}),
				d = () => e => ({
					source: "scheduled_post_composer",
					action: "view",
					noun: "schedule_post_composer",
					...o(e)
				}),
				c = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_date",
					...o(e)
				}),
				l = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_time",
					...o(e)
				}),
				u = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_timezone",
					...o(e)
				}),
				m = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "apply",
					...o(e)
				}),
				p = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "cancel",
					...o(e)
				}),
				b = e => t => ({
					source: "post_composer",
					action: "click",
					noun: "schedule_post_submit",
					...o(t),
					scheduledPost: i(e)
				}),
				f = e => t => ({
					source: "post_composer",
					action: "click",
					noun: "schedule_post_update_submit",
					...o(t),
					scheduledPost: i(e)
				}),
				h = () => e => ({
					source: "mod_hub_nav",
					action: "click",
					noun: "scheduled_posts",
					...o(e)
				}),
				g = () => e => ({
					source: "mod_hub_nav",
					action: "click",
					noun: "event_posts",
					...o(e)
				}),
				v = () => e => ({
					source: "post",
					action: "click",
					noun: "edit_post",
					...o(e)
				}),
				x = () => e => ({
					source: "post",
					action: "click",
					noun: "submit_post_now",
					...o(e)
				}),
				E = e => t => ({
					source: "post",
					action: "click",
					noun: "overflow_menu",
					...o(t),
					actionInfo: r.d(t, {
						pageType: e ? "recurring_posts" : "scheduled_posts"
					})
				}),
				O = {
					[s.d.Hourly]: "hourly_frequency",
					[s.d.Daily]: "daily_frequency",
					[s.d.Weekly]: "weekly_frequency",
					[s.d.Monthly]: "monthly_frequency",
					[s.b]: "custom_frequency"
				},
				C = e => t => ({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: null === e ? "one_time_frequency" : O[e],
					...o(t)
				}),
				A = () => e => ({
					source: "post",
					action: "click",
					noun: "start_event_now",
					...o(e)
				}),
				y = (e, t, n) => i => ({
					source: "post",
					action: "click",
					noun: Object(s.m)(e),
					...o(i),
					actionInfo: r.d(i, {
						settingValue: t ? "true" : "false",
						pageType: n ? "recurring_posts" : "scheduled_posts"
					})
				}),
				j = () => e => ({
					source: "recurring_post_module",
					action: "click",
					noun: "schedule_post_cta",
					...o(e)
				}),
				I = () => e => ({
					source: "recurring_post_module",
					action: "click",
					noun: "edit_recurring_post",
					...o(e)
				}),
				k = () => e => ({
					source: "recurring_post_composer",
					action: "view",
					noun: "recurring_post_composer",
					...o(e)
				}),
				_ = () => (e, t) => ({
					source: "recurring_post_composer",
					action: "click",
					noun: "update",
					...o(e),
					scheduledPost: i(t)
				}),
				S = () => e => ({
					source: "recurring_post_composer",
					action: "click",
					noun: "cancel",
					...o(e)
				}),
				w = () => (e, t) => ({
					source: "recurring_post_composer",
					action: "click",
					noun: "delete",
					...o(e),
					scheduledPost: i(t)
				}),
				T = () => e => ({
					source: "scheduled_post_composer",
					action: "view",
					noun: "custom_schedule_post_composer",
					...o(e)
				}),
				P = () => (e, t) => {
					const n = o(e);
					return {
						source: "post",
						action: "view",
						noun: "error",
						...n,
						actionInfo: {
							...n.actionInfo,
							reason: "failed_post"
						},
						scheduledPost: i(t)
					}
				}
		},
		"./src/reddit/helpers/trackers/screenview.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return w
			})), n.d(t, "e", (function() {
				return P
			})), n.d(t, "p", (function() {
				return N
			})), n.d(t, "q", (function() {
				return D
			})), n.d(t, "n", (function() {
				return M
			})), n.d(t, "r", (function() {
				return R
			})), n.d(t, "c", (function() {
				return L
			})), n.d(t, "k", (function() {
				return B
			})), n.d(t, "o", (function() {
				return F
			})), n.d(t, "h", (function() {
				return U
			})), n.d(t, "i", (function() {
				return H
			})), n.d(t, "f", (function() {
				return G
			})), n.d(t, "b", (function() {
				return W
			})), n.d(t, "a", (function() {
				return z
			})), n.d(t, "m", (function() {
				return V
			})), n.d(t, "l", (function() {
				return K
			})), n.d(t, "v", (function() {
				return X
			})), n.d(t, "d", (function() {
				return $
			})), n.d(t, "t", (function() {
				return ne
			})), n.d(t, "s", (function() {
				return se
			})), n.d(t, "u", (function() {
				return re
			})), n.d(t, "g", (function() {
				return oe
			}));
			var s = n("./node_modules/lodash/pick.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makePostDraftPageKey/index.ts"),
				a = n("./src/reddit/components/SearchResultsContent/helpers/isCommentSearchRoute.ts"),
				d = n("./src/reddit/constants/parameters.ts"),
				c = n("./src/reddit/constants/tracking.ts"),
				l = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				u = n("./src/reddit/helpers/routeKey/index.ts"),
				m = n("./src/reddit/helpers/trackers/postComposer.ts"),
				p = n("./src/reddit/helpers/trackers/profileSettings.ts"),
				b = n("./src/reddit/models/Comment/index.ts"),
				f = n("./src/reddit/models/Post/index.ts"),
				h = n("./src/reddit/routes/subreddit/index.ts"),
				g = n("./src/reddit/selectors/profile.ts"),
				v = n("./src/reddit/selectors/subreddit.ts"),
				x = n("./src/lib/makePostCreationPageKey/index.ts"),
				E = n("./src/lib/makeSearchKey/index.ts"),
				O = n("./src/reddit/constants/livebar.ts"),
				C = n("./src/reddit/helpers/correlationIdTracker.ts"),
				A = n("./src/reddit/helpers/search/SearchTelemetrySource.ts"),
				y = n("./src/reddit/helpers/trackers/searchResults.ts"),
				j = n("./src/reddit/selectors/experiments/communityDirectoryBacklinks/index.ts"),
				I = n("./src/reddit/selectors/postDraft.ts"),
				k = n("./src/reddit/selectors/telemetry.ts"),
				_ = n("./src/reddit/selectors/user.ts"),
				S = n("./src/telemetry/index.ts");
			const w = (e, t, n, s, c, m) => {
					const {
						route: g
					} = e, {
						name: v
					} = g.meta;
					if (!v) return;
					const O = t.platform.currentPage;
					switch (v) {
						case o.Tb.COMMENTS: {
							const {
								partialCommentId: r,
								partialPostId: o
							} = e.match.params, i = Object(f.y)(o), d = Object(u.a)(e, t, t.posts.models[i]), c = Object(a.a)(t.platform.currentPage);
							if (!d || c) return;
							const m = r && Object(b.h)(r),
								{
									sortToUse: p
								} = Object(l.a)(t, i);
							Object(S.a)(L(d, i, m, n, s, p)(t));
							break
						}
						case o.Tb.INDEX:
						case o.Tb.LISTING:
						case o.Tb.MULTIREDDIT:
						case o.Tb.SUBREDDIT: {
							const r = Object(u.c)(e, t);
							if (!r.listingKey) return;
							const {
								params: i,
								queryParams: a,
								path: d
							} = e.match, {
								sort: c = (r.sort ? r.sort : o.bb.HOT)
							} = i, l = a.t, m = d === h.a;
							Object(S.a)(P({
								key: r.listingKey,
								sort: c,
								timerType: n,
								timerMillis: s,
								timeSort: l,
								isPredictionsPage: m
							})(t));
							break
						}
						case o.Tb.TOPIC: {
							const r = Object(u.c)(e, t);
							if (!r.listingKey) return;
							const {
								params: i
							} = e.match, a = r.sort ? r.sort : o.cb, {
								sort: d = a
							} = i;
							Object(S.a)(P({
								key: r.listingKey,
								sort: d,
								timerType: n,
								timerMillis: s
							})(t));
							break
						}
						case o.Tb.PROFILE_OVERVIEW: {
							const r = Object(u.d)(e, t);
							if (!r) return;
							const {
								params: i,
								queryParams: a
							} = e.match, {
								sort: d = o.Kb
							} = i, c = a.t;
							Object(S.a)(N(r, d, n, s, c)(t));
							break
						}
						case o.Tb.PROFILE_POSTS: {
							const r = Object(u.d)(e, t);
							if (!r) return;
							const {
								queryParams: i
							} = e.match, {
								sort: a = o.Kb,
								t: d = o.Lb
							} = i;
							Object(S.a)(D(r, a, n, s, d)(t));
							break
						}
						case o.Tb.PROFILE_COMMENTS: {
							const r = Object(u.d)(e, t);
							if (!r) return;
							const {
								queryParams: i
							} = e.match, {
								sort: a = o.Kb,
								t: d = o.Lb
							} = i;
							Object(S.a)(M(r, a, n, s, d)(t));
							break
						}
						case o.Tb.PROFILE_PRIVATE: {
							const r = Object(u.d)(e, t);
							if (!r) return;
							Object(S.a)(R(r)(s, n)(t));
							break
						}
						case o.Tb.FOLLOWERS:
							Q(t);
							break;
						case o.Tb.PROFILE_MODERATION:
							m && F(t, !0);
							break;
						case o.Tb.SETTINGS: {
							const r = e;
							Object(S.a)(J(n, s)(t)), r.match.params.page === o.jc.Profile && Object(p.l)(t);
							break
						}
						case o.Tb.POST_CREATION:
							if (m && c) {
								const e = Object(x.a)(c);
								Object(S.a)(B(e, n, s)(t))
							}
							break;
						case o.Tb.POST_DRAFT: {
							const {
								draftId: r
							} = e.match.params, o = Object(i.a)(e.match.params);
							if (!o) return;
							q(t, o, r, n, s);
							break
						}
						case o.Tb.SUBREDDIT_WIKI:
							Object(S.a)(Z(n, s)(t));
							break;
						case o.Tb.COINS:
							Object(S.a)(W(n, s)(t)), Object(S.a)(z()(t));
							break;
						case o.Tb.PREMIUM:
							Object(S.a)(V(n, s)(t)), Object(S.a)(K()(t));
							break;
						case o.Tb.APPEAL:
							Object(S.a)(Y(n, s)(t));
							break;
						case o.Tb.INBOX_PAGES:
							m && G(t);
							break;
						case o.Tb.MODERATION_PAGES:
							m && U(t, !0, c ? c.subredditName : null, c ? c.profileName : null);
							break;
						case o.Tb.COLLECTION_COMMENTS:
							m && re(t, !0);
							break;
						case o.Tb.MODQUEUE_PAGES:
							m && H(t, c ? c.subredditName : null, c ? c.profileName : null);
							break;
						case o.Tb.SEARCH_RESULTS:
							if (m) {
								const o = Object(_.mb)(t),
									i = Object(_.rb)(t),
									a = Object(u.e)(e, o && i);
								if (!a) return;
								Object(S.a)(ne(a, Object(E.e)(r()(O && O.queryParams || {}, d.y)), n, s, O)(t))
							}
							break;
						case o.Tb.GEOTAGGING:
							m && Object(S.a)($()(t));
							break;
						case o.Tb.SUBREDDIT_CREATION:
							m && Object(S.a)(X()(t));
							break;
						case o.Tb.MOD_LISTING:
							m && oe(t, !0)
					}
				},
				T = e => ({
					...k.p(e, {
						isGVSEvent: !0
					}),
					userPreferences: k.ub(e)
				}),
				P = e => {
					let {
						key: t,
						sort: n,
						timerType: s,
						timerMillis: r,
						timeSort: o,
						flairTitle: i,
						isPredictionsPage: a
					} = e;
					return e => {
						const {
							api: d
						} = e.listings.postOrder, c = !d.error[t] && !d.pending[t], l = a ? {
							paneName: "predictions",
							reason: "predictions_tournament"
						} : {}, u = Object(j.b)(e);
						return {
							source: "global",
							action: "view",
							noun: "screen",
							...T(e),
							actionInfo: k.d(e, {
								success: c,
								...l
							}),
							customFeed: k.n(e),
							listing: k.A(e, t, {
								sort: n,
								sortTime: o
							}),
							subreddit: k.mb(e),
							timer: k.sb(s, r),
							userSubreddit: k.vb(e),
							adblock: k.e(e),
							postFlair: {
								title: i
							},
							predictions: a ? Object(k.S)(e) : void 0,
							...(null == u ? void 0 : u.internalLinkUrl) ? {
								seo: u
							} : void 0
						}
					}
				},
				N = (e, t, n, s, r) => o => {
					const i = k.A(o, e);
					i && (i.sort = t, r && (i.sortTime = r));
					const {
						api: a
					} = o.listings.postOrder, d = !a.error[e] && !a.pending[e];
					return {
						listing: i,
						source: "global",
						action: "view",
						noun: "screen",
						...T(o),
						actionInfo: k.d(o, {
							success: d
						}),
						profile: k.U(o),
						snoovatar: k.jb(o),
						subreddit: k.mb(o),
						timer: k.sb(n, s),
						userSubreddit: k.vb(o),
						adblock: k.e(o)
					}
				},
				D = (e, t, n, s, r) => o => {
					const i = k.A(o, e);
					i && (i.sort = t, r && (i.sortTime = r));
					const {
						api: a
					} = o.listings.postOrder, d = !a.error[e] && !a.pending[e];
					return {
						listing: i,
						source: "global",
						action: "view",
						noun: "screen",
						...T(o),
						actionInfo: k.d(o, {
							success: d
						}),
						profile: k.U(o),
						subreddit: k.mb(o),
						timer: k.sb(n, s),
						userSubreddit: k.vb(o),
						adblock: k.e(o)
					}
				},
				M = (e, t, n, s, r) => o => {
					const i = k.X(o, e);
					i && (i.sort = t, r && (i.sortTime = r));
					const {
						api: a
					} = o.profileCommentsPage, d = !a.error[e] && !a.pending[e];
					return {
						listing: i,
						source: "global",
						action: "view",
						noun: "screen",
						...T(o),
						actionInfo: k.d(o, {
							success: d
						}),
						profile: k.U(o),
						subreddit: k.mb(o),
						timer: k.sb(n, s),
						userSubreddit: k.vb(o),
						adblock: k.e(o)
					}
				},
				R = e => (t, n) => s => {
					const r = !s.profilePrivatePage.api.error[e] && !s.profilePrivatePage.api.pending[e];
					return {
						source: "global",
						action: "view",
						noun: "screen",
						...T(s),
						actionInfo: k.d(s, {
							success: r
						}),
						profile: k.U(s),
						subreddit: k.mb(s),
						timer: k.sb(n, t),
						userSubreddit: k.vb(s),
						adblock: k.e(s)
					}
				},
				L = (e, t, n, s, r, o) => i => {
					const {
						api: a
					} = i.pages.comments, d = !a.error[e] && !a.pending[e], c = new URLSearchParams(window.location.search).has(O.a), l = Object(j.b)(i), u = {
						source: "global",
						action: "view",
						noun: "screen",
						...T(i),
						actionInfo: k.d(i, {
							success: d,
							...c ? {
								reason: "live_bar"
							} : {}
						}),
						post: k.L(i, t),
						profile: k.U(i),
						subreddit: k.mb(i),
						timer: k.sb(s, r),
						userSubreddit: k.vb(i),
						adblock: k.e(i),
						postEvent: k.O(i, {
							postId: t
						}),
						postCollection: k.N(i, {
							postId: t
						}),
						listing: k.A(i, void 0, {
							sort: o
						})
					};
					return n && (u.comment = k.i({
						state: i,
						commentId: n
					})), (null == l ? void 0 : l.internalLinkUrl) && (u.seo = l), u
				},
				B = (e, t, n) => s => {
					const r = s.creations.api.page.fetched[e],
						o = s.platform.currentPage ? s.platform.currentPage.queryParams.source_id : void 0;
					return {
						source: "global",
						action: "view",
						noun: "screen",
						...T(s),
						actionInfo: k.d(s, {
							success: r
						}),
						post: o ? k.L(s, o) : void 0,
						subreddit: k.mb(s),
						timer: k.sb(t, n),
						userSubreddit: k.vb(s),
						adblock: k.e(s)
					}
				},
				F = (e, t) => {
					Object(S.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...T(e),
						actionInfo: k.d(e, {
							success: t
						})
					})
				},
				U = (e, t, n, s) => {
					Object(S.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...T(e),
						actionInfo: k.d(e, {
							success: t
						}),
						profile: k.V(e, Object(g.o)(e, s)),
						subreddit: k.nb(e, Object(v.I)(e, n)),
						userSubreddit: k.vb(e),
						adblock: k.e(e)
					})
				},
				H = (e, t, n) => {
					Object(S.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...T(e),
						profile: k.V(e, Object(g.o)(e, n)),
						subreddit: k.nb(e, Object(v.I)(e, t)),
						userSubreddit: k.vb(e),
						adblock: k.e(e)
					})
				},
				G = e => {
					Object(S.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...T(e),
						actionInfo: k.d(e)
					})
				},
				Q = e => {
					Object(S.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...T(e),
						actionInfo: k.d(e)
					})
				},
				q = (e, t, n, s, r) => {
					const o = e.creations.api.page.pending[t],
						i = !e.creations.api.page.error[t] && !o && !!n,
						a = Object(I.h)(e, n);
					Object(S.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...T(e),
						actionInfo: k.d(e, {
							success: i
						}),
						subreddit: k.mb(e),
						timer: k.sb(s, r),
						userSubreddit: k.vb(e),
						adblock: k.e(e),
						...a ? Object(m.r)(e, a) : {}
					})
				},
				W = (e, t) => n => ({
					source: "coins_marketing",
					action: "view",
					noun: "page",
					correlationId: Object(C.c)(C.a.GoldPayment),
					...T(n),
					timer: k.sb(e, t),
					adblock: k.e(n)
				}),
				z = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					...T(e)
				}),
				V = (e, t) => n => ({
					source: "premium_marketing",
					action: "view",
					noun: "page",
					correlationId: Object(C.c)(C.a.GoldPayment),
					...T(n),
					timer: k.sb(e, t),
					adblock: k.e(n)
				}),
				K = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					...T(e)
				}),
				Y = (e, t) => n => ({
					source: "appeal",
					action: "view",
					noun: "page",
					...T(n),
					timer: k.sb(e, t)
				}),
				J = (e, t) => n => ({
					source: "global",
					action: "view",
					noun: "screen",
					...T(n),
					timer: k.sb(e, t)
				}),
				X = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					...T(e)
				}),
				Z = (e, t) => n => ({
					source: "global",
					action: "view",
					noun: "screen",
					...T(n),
					customFeed: k.n(n),
					subreddit: k.mb(n),
					timer: k.sb(e, t),
					userSubreddit: k.vb(n),
					adblock: k.e(n)
				}),
				$ = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					...T(e)
				}),
				ee = {
					source: "global",
					action: c.c.VIEW,
					noun: "screen"
				},
				te = e => !!e && {
					correlationId: Object(C.c)(C.a.SearchResults)
				},
				ne = (e, t, n, s, r, i) => a => {
					var d, c;
					let l = !0;
					if (t.type.indexOf(o.ic.Posts) > -1) {
						const {
							api: t
						} = a.listings.listingOrder;
						l = l && !t.error[e] && !t.pending[e]
					}
					if (t.type.indexOf(o.ic.Subreddits) > -1 || t.type.indexOf(o.ic.Users) > -1) {
						const {
							api: t
						} = a.listings.postOrder;
						l = l && !t.error[e] && !t.pending[e]
					}
					const u = k.I(a, r);
					return {
						...y.f(a, t),
						...ee,
						...T(a),
						actionInfo: k.d(a, {
							success: l,
							paneName: u
						}),
						timer: k.sb(n, s),
						search: {
							...k.eb(a, t, A.a.SERP, r || void 0),
							sort: null !== (d = t.sort) && void 0 !== d ? d : o.Vb,
							range: null !== (c = t.t) && void 0 !== c ? c : o.Wb
						},
						...te(i),
						userPreferences: k.hb(a)
					}
				},
				se = (e, t, n) => s => ({
					...T(s),
					...ee,
					actionInfo: {
						...k.d(s),
						pageType: "search_dropdown"
					},
					search: k.eb(s, e, A.a.Typeahead, t || void 0),
					...te(n),
					userPreferences: k.hb(s)
				}),
				re = (e, t) => {
					Object(S.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...T(e),
						actionInfo: k.d(e, {
							success: t
						})
					})
				},
				oe = (e, t) => {
					Object(S.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...T(e),
						actionInfo: k.d(e, {
							success: t
						})
					})
				}
		},
		"./src/reddit/helpers/trackers/snoovatar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "s", (function() {
				return m
			})), n.d(t, "l", (function() {
				return p
			})), n.d(t, "o", (function() {
				return b
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "r", (function() {
				return v
			})), n.d(t, "e", (function() {
				return x
			})), n.d(t, "k", (function() {
				return E
			})), n.d(t, "n", (function() {
				return C
			})), n.d(t, "j", (function() {
				return A
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "q", (function() {
				return I
			})), n.d(t, "d", (function() {
				return k
			})), n.d(t, "a", (function() {
				return S
			})), n.d(t, "p", (function() {
				return w
			})), n.d(t, "m", (function() {
				return T
			}));
			var s = n("./src/reddit/models/Gold/ProductOffer.ts"),
				r = n("./src/reddit/selectors/avatarMarketing.ts"),
				o = n("./src/reddit/selectors/telemetry.ts"),
				i = n("./src/reddit/selectors/user.ts"),
				a = n("./src/reddit/helpers/userSnoovatar/index.ts");
			const d = {
					goldPurchase: {
						offerContext: s.a.AvatarNewGear
					}
				},
				c = e => t => {
					const n = {
						source: e,
						action: "click",
						noun: "edit_snoovatar",
						...o.p(t)
					};
					return Object(r.a)(t) && Object.assign(n, d), n
				},
				l = (e, t) => n => {
					const {
						id: s
					} = Object(i.Db)(n, {
						userName: t
					});
					return {
						source: e,
						action: "click",
						noun: "copy_avatar",
						...o.p(n),
						snoovatar: {
							userGenerated: s
						}
					}
				},
				u = e => ({
					...o.p(e),
					source: "avatar",
					action: "click",
					noun: "try_this_look_post",
					snoovatar: o.kb(e)
				}),
				m = e => ({
					...o.p(e, {
						isGVSEvent: !0
					}),
					source: "global",
					action: "view",
					noun: "screen",
					actionInfo: {
						pageType: "snoovatar_builder"
					},
					snoovatar: o.kb(e)
				}),
				p = e => ({
					...o.p(e),
					source: "avatar_builder",
					action: "click",
					noun: "close",
					snoovatar: o.kb(e)
				}),
				b = e => ({
					source: "nav",
					action: "view",
					noun: "avatar_marketing",
					...o.p(e),
					...d
				}),
				f = e => ({
					source: "nav",
					action: "click",
					noun: "avatar_marketing",
					...o.p(e),
					...d
				}),
				h = e => t => ({
					...o.p(t),
					source: "snoovatar",
					action: "set_to_profile",
					noun: "snoovatar",
					snoovatar: {
						userGeneratedSource: e
					}
				}),
				g = e => t => n => ({
					source: "avatar",
					action: e,
					noun: "community_spaces",
					...o.p(n),
					snoovatar: o.kb(n),
					actionInfo: {
						paneName: "avatar_community_spaces" + (t ? "_control" : "")
					}
				}),
				v = g("view"),
				x = g("click"),
				E = g("dismiss"),
				O = (e, t, n) => () => s => ({
					source: e,
					action: t,
					noun: n,
					...o.p(s),
					snoovatar: o.kb(s)
				}),
				C = O("anniversary_achievement", "view", "anniversary_achievement"),
				A = O("anniversary_achievement", "click", "close"),
				y = O("anniversary_achievement", "click", "equip"),
				j = e => () => t => ({
					...o.p(t),
					source: "gold_top_nav",
					action: e,
					noun: "quick_create_cta"
				}),
				I = j("view"),
				k = j("click"),
				_ = (e, t, n) => s => ({
					source: e,
					action: t,
					noun: n,
					...o.p(s),
					actionInfo: {
						pageType: "onboarding"
					},
					snoovatar: o.kb(s)
				}),
				S = e => _("onboarding", "click", e),
				w = () => _("avatar", "view", "onboarding"),
				T = e => {
					let {
						user: t,
						pageType: n,
						userHasNft: s
					} = e;
					return e => {
						const r = Object(a.a)(t.accountIcon),
							i = (null == t ? void 0 : t.id) && (null == t ? void 0 : t.username);
						return {
							source: "profile",
							action: "screen",
							noun: "load",
							...o.p(e),
							actionInfo: {
								pageType: n
							},
							profile: i ? {
								id: t.id,
								name: t.username
							} : null,
							snoovatar: {
								snoovatarActive: r,
								userHasNft: s
							},
							marketplace: {
								hasCollectibleCollection: !1
							}
						}
					}
				}
		},
		"./src/reddit/helpers/trackers/socialLinks.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => {
					let {
						socialLinkType: t,
						outboundUrl: n,
						name: s,
						position: r,
						isNew: o,
						currentList: i
					} = e;
					return {
						socialLink: {
							type: t,
							url: n,
							name: s,
							position: r,
							isNew: o,
							currentList: i
						}
					}
				},
				i = e => t => ({
					...Object(r.p)(t),
					action: s.c.CLICK,
					noun: "add_social_link",
					source: e
				}),
				a = e => t => ({
					...Object(r.p)(t),
					action: s.c.CLICK,
					noun: "social_link",
					source: "add_social_link",
					...o({
						socialLinkType: e
					})
				}),
				d = e => t => ({
					...Object(r.p)(t),
					action: s.c.CLICK,
					noun: "save",
					source: "add_social_link",
					...o(e)
				}),
				c = e => t => ({
					...Object(r.p)(t),
					action: s.c.CLICK,
					noun: "edit_social_link",
					source: "profile_settings",
					...o(e)
				}),
				l = e => t => ({
					...Object(r.p)(t),
					action: s.c.CLICK,
					noun: "delete_social_link",
					source: "profile_settings",
					...o(e)
				}),
				u = e => t => ({
					...Object(r.p)(t),
					action: s.c.CLICK,
					noun: "social_link",
					source: "profile",
					profile: Object(r.U)(t),
					...o(e)
				})
		},
		"./src/reddit/helpers/trackers/subredditCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => t => ({
					source: e,
					noun: "create_community_button",
					action: "click",
					...r.p(t),
					actionInfo: r.d(t, {
						settingValue: t.user.account && t.user.account.isMod ? "existing_mod" : "new_mod"
					}),
					correlationId: Object(s.d)(s.a.SubredditCreation, !0)
				}),
				i = (e, t, n) => o => ({
					source: "community_form",
					noun: "save_community_button",
					action: "click",
					...r.p(o),
					actionInfo: r.d(o, {
						settingValue: e
					}),
					subreddit: {
						id: n,
						name: t.name,
						publicDescription: t.publicDescription,
						nsfw: t.over18,
						accessType: t.type,
						topicTagContents: t.allTags,
						topicTagPrimaryId: t.primaryTagId
					},
					correlationId: Object(s.c)(s.a.SubredditCreation)
				}),
				a = () => e => ({
					source: "community_form",
					noun: "cancel",
					action: "click",
					...r.p(e),
					actionInfo: r.d(e),
					correlationId: Object(s.c)(s.a.SubredditCreation)
				}),
				d = (e, t) => n => ({
					source: "community_form",
					noun: "error_message",
					action: "view",
					...r.p(n),
					actionInfo: r.d(n, {
						reason: e,
						settingValue: t
					}),
					correlationId: Object(s.c)(s.a.SubredditCreation)
				}),
				c = () => e => ({
					source: "user_dropdown",
					noun: "create_community",
					action: "click",
					...r.p(e),
					actionInfo: r.d(e)
				}),
				l = () => e => ({
					source: "community_first_post",
					noun: "modal",
					action: "view",
					...r.p(e),
					actionInfo: r.d(e)
				}),
				u = () => e => ({
					source: "community_first_post",
					noun: "modal",
					action: "click",
					...r.p(e),
					actionInfo: r.d(e)
				}),
				m = () => e => ({
					source: "community_first_post",
					noun: "modal",
					action: "dismiss",
					...r.p(e),
					actionInfo: r.d(e)
				})
		},
		"./src/reddit/helpers/trackers/subredditForking.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			}));
			var s = n("./src/reddit/selectors/telemetry.ts");
			const r = e => e => ({
					source: "post",
					noun: "forking_module",
					action: "click",
					...s.p(e),
					actionInfo: s.d(e, {
						settingValue: e.user.account && e.user.account.isMod ? "existing_mod" : "new_mod"
					})
				}),
				o = e => e => ({
					source: "post",
					noun: "forking_module",
					action: "dismiss",
					...s.p(e),
					actionInfo: s.d(e)
				}),
				i = e => e => ({
					source: "post",
					noun: "forking_module",
					action: "view",
					...s.p(e),
					actionInfo: s.d(e)
				})
		},
		"./src/reddit/helpers/trackers/subredditMuting.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/reddit/selectors/telemetry.ts"),
				r = n("./src/telemetry/models/Event.ts");
			const o = e => {
					let {
						subredditId: t,
						postId: n
					} = e;
					return e => ({
						source: r.f.SubredditMuting,
						action: r.d.Mute,
						noun: r.e.Subreddit,
						subreddit: {
							id: t
						},
						...s.p(e),
						...n && {
							post: {
								id: n
							}
						}
					})
				},
				i = e => {
					let {
						subredditId: t,
						postId: n
					} = e;
					return e => ({
						source: r.f.SubredditMuting,
						action: r.d.Unmute,
						noun: r.e.Subreddit,
						subreddit: {
							id: t
						},
						...s.p(e),
						...n && {
							post: {
								id: n
							}
						}
					})
				}
		},
		"./src/reddit/helpers/trackers/userFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			}));
			var s = n("./src/reddit/helpers/flair.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = () => e => ({
					source: "id_card",
					action: "click",
					noun: "user_flair_picker",
					...r.p(e)
				}),
				i = e => t => {
					const n = r.mb(t),
						{
							userFlair: o,
							achievementFlair: i
						} = e;
					return {
						source: "user_flair_picker",
						action: "click",
						noun: "user_flair",
						...r.p(t),
						subreddit: n,
						userFlair: {
							id: null == o ? void 0 : o.id,
							title: o ? Object(s.g)(o) : void 0,
							isActive: !!o || void 0,
							achievementFlairId: null == i ? void 0 : i.type,
							achievementFlairTitle: null == i ? void 0 : i.name,
							isLocked: null == i ? void 0 : i.isLocked
						}
					}
				},
				a = () => e => ({
					source: "user_flair_picker",
					action: "click",
					noun: "edit_user_flair",
					...r.p(e)
				}),
				d = e => t => ({
					source: "user_flair_picker",
					action: "click",
					noun: "enable_powerups_flair",
					setting: {
						value: e ? "0" : "1",
						oldValue: e ? "1" : "0"
					},
					subreddit: r.mb(t),
					...r.p(t)
				})
		},
		"./src/reddit/helpers/trackers/widgets.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			var s, r, o = n("./src/reddit/constants/tracking.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			! function(e) {
				e.REREDDIT_PROMO = "rereddit_promo", e.SEE_MORE = "see_more", e.TOPIC = "topic", e.TOPICS_WIDGET = "topics_widget"
			}(s || (s = {})),
			function(e) {
				e.COMMUNITY_WIDGETS = "community_widgets", e.POST = "post", e.SIDEBAR = "sidebar", e.TOPICS_WIDGET = "topics_widget"
			}(r || (r = {}));
			const a = (e, t) => n => ({
					source: r.COMMUNITY_WIDGETS,
					action: o.c.CLICK,
					noun: s.SEE_MORE,
					widget: Object(i.zb)(n, {
						subredditId: e,
						widgetKind: t
					}),
					...i.p
				}),
				d = (e, t) => n => ({
					source: r.POST,
					action: o.c.CLICK,
					noun: s.REREDDIT_PROMO,
					post: i.L(n, e),
					subreddit: i.mb(n),
					...t && {
						banner: {
							buttonText: t,
							id: s.REREDDIT_PROMO
						}
					},
					...i.p(n)
				}),
				c = () => e => ({
					source: r.SIDEBAR,
					action: o.c.VIEW,
					noun: s.TOPICS_WIDGET,
					...i.p(e)
				}),
				l = e => t => ({
					source: r.TOPICS_WIDGET,
					action: o.c.CLICK,
					noun: s.TOPIC,
					...i.p(t),
					topicMetadata: {
						displayName: e
					}
				})
		},
		"./src/reddit/helpers/validateFlairCssClass.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/reddit/constants/flair.ts");
			const o = new RegExp(`^[a-zA-Z0-9-]{1,${r.f}}$`);
			t.a = e => {
				if (!e) return;
				const t = e.split(" ").filter(Boolean);
				if (t.length > r.c) return s.fbt._("Too many class names", null, {
					hk: "musK5"
				});
				const n = t.find(e => !e.match(o));
				return n ? n.length > r.f ? s.fbt._("Class name should not be longer than 100 characters", null, {
					hk: "2nBmgP"
				}) : s.fbt._("Class name contains an invalid character", null, {
					hk: "4kdVCU"
				}) : void 0
			}
		},
		"./src/reddit/helpers/wiki/buildWikiPagesTree.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/sortBy.js"),
				r = n.n(s),
				o = n("./src/reddit/constants/wiki.ts");
			const i = e => {
				return r()(e, e => `${e.path}/`.startsWith(`${o.i}/`) ? `\0${e.path}` : e.path).filter(e => !o.l.includes(e.path))
			};
			t.a = e => {
				const t = new Map,
					n = [];
				return i(e).forEach(e => {
					const s = {
							...e,
							children: []
						},
						r = s.parent ? t.get(s.parent) : null;
					r ? r.children.push(s) : n.push(s), t.set(s.path, s)
				}), n
			}
		},
		"./src/reddit/helpers/wiki/makeComparisonDiffKey.ts": function(e, t, n) {
			"use strict";
			t.a = e => {
				const {
					comparisonRevisionId: t,
					revisionId: n,
					subredditName: s,
					wikiPageName: r
				} = e;
				return `[${s}]--[${r}]--[rev1:${n}]--[rev2:${t}]`.toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/makeRevisionsListingKey.ts": function(e, t, n) {
			"use strict";
			t.a = e => {
				const t = e.isRecent ? "(recent)" : e.wikiPageName;
				return `[${e.subredditName}]--[${t}]`.toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/makeWikiPageKey.ts": function(e, t, n) {
			"use strict";
			t.a = e => {
				let t = `[${e.subredditName}]--[${e.wikiPageName}]`;
				return e.revisionId && (t += `--[rev:${e.revisionId}]`), t.toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/validatePageName.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./src/reddit/constants/wiki.ts");
			const r = new RegExp(`^[-\\w]+(?:\\/[-\\w]+){0,${s.c}}$`),
				o = /^[-\w]+$/;
			var i;
			! function(e) {
				e[e.InvalidPageName = 1] = "InvalidPageName", e[e.RestrictedPageName = 2] = "RestrictedPageName", e[e.MaxLengthExceed = 3] = "MaxLengthExceed", e[e.PageAlreadyExists = 4] = "PageAlreadyExists"
			}(i || (i = {}));
			const a = e => {
					if (!o.test(e.toLowerCase())) return i.InvalidPageName
				},
				d = (e, t) => {
					const n = e.toLowerCase(),
						o = n.split("/")[0],
						a = s.b.has(o),
						d = s.f.has(o) && n !== s.h && n !== s.k;
					if (a || d) return i.RestrictedPageName;
					if (!r.test(n)) return i.InvalidPageName;
					if (t) {
						if (t.some(e => e.path.toLowerCase() === n)) return i.PageAlreadyExists
					}
					return n.length > s.d ? i.MaxLengthExceed : void 0
				}
		},
		"./src/reddit/helpers/wiki/wikiRevision.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = e => e.startsWith("WikiRevision_") ? e : "WikiRevision_" + e,
				r = e => e.startsWith("WikiRevision_") ? e.slice("WikiRevision_".length) : e
		},
		"./src/reddit/hooks/useClickSourceData.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./node_modules/react-redux/es/index.js"),
				o = n("./src/reddit/helpers/clickSourceData/index.ts");

			function i() {
				const e = Object(r.e)(e => e.platform.currentPage),
					[t, n] = Object(s.useState)({});
				return Object(s.useEffect)(() => {
					n(Object(o.b)(e))
				}, [e]), t
			}
		},
		"./src/reddit/hooks/useDesktopNotificationsPromptSeen.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./src/reddit/helpers/localStorage/index.ts");

			function o(e) {
				const [t, n] = Object(s.useState)(Object(r.v)(e));
				return [t, Object(s.useCallback)(() => {
					n(!0), Object(r.tb)(e)
				}, [])]
			}
		},
		"./src/reddit/hooks/useExperimentVariant.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");

			function o(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : r.a;
				return Object(s.e)(n => Object(r.c)(n, {
					experimentName: e,
					experimentEligibilitySelector: t
				}))
			}
		},
		"./src/reddit/hooks/useInfoTextTooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/icepick/icepick.js"),
				r = n("./node_modules/react/index.js"),
				o = n("./src/lib/hooks/useTooltip.ts");
			const i = Object(s.freeze)({
				name: "offset",
				options: {
					offset: [0, 6]
				}
			});

			function a(e) {
				const t = Object(r.useMemo)(() => {
					const t = Object(o.a)(e);
					return Object(s.updateIn)(t, ["modifiers"], e => Object(s.push)(e, i))
				}, [e]);
				return Object(o.b)(t)
			}
		},
		"./src/reddit/hooks/useIntersectionObserver.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js");
			t.a = function(e, t, n) {
				Object(s.useEffect)(() => {
					const s = e && e.current;
					if (!s || "undefined" == typeof IntersectionObserver) return;
					const r = new IntersectionObserver(t, n);
					return r.observe(s), () => {
						r.unobserve(s)
					}
				}, [e, t, n])
			}
		},
		"./src/reddit/hooks/useIsAvatarPost.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react-redux/es/index.js");
			const r = ["t2_83axfjo9", "t2_5ybo8iyi", "t2_7yef0w0w", "t2_fvlxukt", "t2_16060o", "t2_364me452", "t2_46dwatoq", "t2_86xzqcqi", "t2_97lsdz5t", "t2_8394tzuq ", "t2_b46ms2wj", "t2_btxoz0zb"],
				o = ["t5_q0gj4", "t5_2rjli"],
				i = new RegExp(/https:\/\/(www\.)?reddit.com\/avatar\/.*\/\d+$/);
			var a = n("./src/reddit/selectors/experiments/econ/index.ts");
			const d = e => Object(s.e)(t => {
				return !!(e => {
					let {
						adminId: t,
						subredditId: n,
						avatarShareUrl: s
					} = e;
					const a = i.test(s.trim()),
						d = r.includes(t),
						c = o.includes(n);
					return a && d && c
				})({
					adminId: e.authorId,
					subredditId: e.belongsTo.id,
					avatarShareUrl: e.source ? e.source.url : ""
				}) && Object(a.a)(t)
			})
		},
		"./src/reddit/hooks/useIsRemovedOrDeletedPost.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/reddit/selectors/removedPosts.ts");
			const o = () => Object(s.e)(e => Object(r.d)(e))
		},
		"./src/reddit/hooks/useLocalStorage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./src/reddit/helpers/localStorage/index.ts");
			const o = {},
				i = (e, t, n) => (o[e] || (o[e] = {
					callbacks: [],
					value: n
				}), o[e].callbacks.push(t), {
					deregister: () => {
						const {
							callbacks: n
						} = o[e], s = n.indexOf(t);
						s > -1 && n.splice(s, 1)
					},
					emit: n => {
						o[e].value !== n && (o[e].value = n, o[e].callbacks.forEach(e => {
							e !== t && e(n)
						}))
					}
				});

			function a(e, t) {
				const n = Object(s.useRef)(null);
				let o;
				o = Object(r.G)(e);
				const [a, d] = Object(s.useState)(null != o ? o : t);
				return Object(s.useEffect)(() => (n.current = i(e, d, t), () => {
					var e;
					return null === (e = n.current) || void 0 === e ? void 0 : e.deregister()
				}), [e, t]), Object(s.useEffect)(() => {
					var e;
					null === (e = n.current) || void 0 === e || e.emit(a)
				}, [a]), [a, function(t) {
					Object(r.Lb)(e, t), d(t)
				}]
			}
		},
		"./src/reddit/hooks/useLocale.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			}));
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/index.js"),
				r = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/selectors/meta.ts");
			const a = "undefined" == typeof document ? function() {
				const e = Object(o.e)(i.k) || r.DEFAULT_LOCALE;
				return Object(s.isPseudoLocale)(e) ? r.DEFAULT_LOCALE : e
			} : function() {
				const e = document.documentElement.lang || r.DEFAULT_LOCALE;
				return Object(s.isPseudoLocale)(e) ? r.DEFAULT_LOCALE : e
			};
			t.a = a;
			const d = () => {
				const e = a(),
					t = Object(o.e)(i.b);
				return t ? e.replace(/([a-z]+-)([A-Z]+)/, `$1${t}`) : e
			}
		},
		"./src/reddit/hooks/useMemoShallowEqual.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./node_modules/react-redux/es/index.js");

			function o(e) {
				const t = Object(s.useRef)(e);
				return t.current === e || Object(r.c)(t.current, e) || (t.current = e), t.current
			}
		},
		"./src/reddit/hooks/useOutboundClickTracking.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./src/reddit/components/TrackingHelper/index.tsx");
			const r = /^https?:\/\/([\w\.\-]+\.)?(reddit(media|static)?\.com|redd\.it)(\/|$)/;
			var o = n("./src/reddit/helpers/trackers/socialLinks.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const a = (e, t, n, s, r) => a => {
				const d = {
					noun: "outbound_link",
					action: "click",
					source: "link",
					...Object(i.p)(a),
					actionInfo: Object(i.d)(a),
					geo: Object(i.u)(a),
					screen: Object(i.db)(a),
					subreddit: Object(i.mb)(a),
					outbound: Object(i.H)(a, e, t, s, n)
				};
				return n && (d.comment = Object(i.i)({
					state: a,
					commentId: n
				})), s && (d.post = Object(i.L)(a, s)), r && (d.socialLink = Object(o.g)({
					socialLinkType: r
				}).socialLink), d
			};
			var d = n("./src/lib/serviceWorker/index.ts"),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./src/telemetry/helpers/getSerializedThriftJSON.ts"),
				u = n("./src/telemetry/helpers/getSignatureHeader.ts"),
				m = n("./src/telemetry/models/Event.ts");
			const p = () => {
				const e = Object(c.f)();
				return t => {
					const n = t(e.getState()),
						s = m.g(n),
						r = Object(l.a)(s),
						o = Object(u.b)(r);
					Object(d.b)("sendV2EventsData", {
						data: r,
						headers: o
					})
				}
			};

			function b() {
				const e = Object(s.b)(),
					t = p();
				return (n, s, o, i, d) => {
					var c, l;
					if (s && function(e) {
							return !e.startsWith("/") && null == e.match(r)
						}(n)) {
						const r = a(n, s, o, i, d);
						(null === (l = null === (c = null === window || void 0 === window ? void 0 : window.navigator) || void 0 === c ? void 0 : c.serviceWorker) || void 0 === l ? void 0 : l.controller) ? t(r): e(r)
					}
				}
			}
		},
		"./src/reddit/hooks/usePageLayer.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/contexts/PageLayer/index.tsx");
			t.a = s.ib
		},
		"./src/reddit/hooks/usePostContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/lib/sentry/index.ts"),
				r = n("./node_modules/react/index.js"),
				o = n("./src/reddit/contexts/Post/index.tsx");

			function i() {
				const e = Object(r.useContext)(o.c);
				return e || s.c.captureMessage("No post context provided"), e
			}
		},
		"./src/reddit/hooks/useTheme.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./src/lib/CSSVariableProvider/index.tsx");

			function o() {
				return Object(s.useContext)(r.b)
			}
		},
		"./src/reddit/hooks/useTracking.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/components/TrackingHelper/index.tsx");
			t.a = s.b
		},
		"./src/reddit/hooks/useUserContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./src/reddit/contexts/User/index.tsx");

			function o() {
				return Object(s.useContext)(r.a)
			}
		},
		"./src/reddit/icons/fonts/Approve/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("approve", e.isFilled), d.a.approveIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Archived/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("archived", e.isFilled), d.a.archivedIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Calendar/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("scheduled", e.isFilled), d.a.calendarIcon, e.className)
			})
		},
		"./src/reddit/icons/fonts/Clear/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("clear", e.isFilled), e.className)
			})
		},
		"./src/reddit/icons/fonts/Clock/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("history", e.isFilled), e.className)
			})
		},
		"./src/reddit/icons/fonts/Coin/index.m.less": function(e, t, n) {
			e.exports = {
				CoinIcon: "_12xlue8dQ1odPw1J81FIGQ",
				coinIcon: "_12xlue8dQ1odPw1J81FIGQ"
			}
		},
		"./src/reddit/icons/fonts/Coin/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/constants/colors.ts"),
				a = n("./src/reddit/icons/fonts/helpers.tsx"),
				d = n("./src/reddit/icons/fonts/Coin/index.m.less"),
				c = n.n(d);
			const l = n("./src/lib/lessComponent.tsx").a.wrapped(e => r.a.createElement("i", {
				className: Object(o.a)(e.className, Object(a.b)("coins", e.isFilled)),
				style: {
					color: e.fillColor || i.a.gold
				}
			}), "CoinIcon", c.a);
			t.a = l
		},
		"./src/reddit/icons/fonts/Comment/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				let {
					className: t,
					...n
				} = e;
				return r.a.createElement("i", c({
					className: Object(o.a)(Object(i.b)("comment", n.isFilled), d.a.commentIcon, t)
				}, n))
			}
		},
		"./src/reddit/icons/fonts/DistinguishShield/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("distinguish", e.isFilled), e.className)
			})
		},
		"./src/reddit/icons/fonts/Downvote/index.m.less": function(e, t, n) {
			e.exports = {
				compactDownvote: "_2GCoZTwJW7199HSwNZwlHk",
				compactDownvoteWrapper: "jR747Vd1NbfaLusf5bHre",
				downvote: "ZyxIIl4FP5gHGrJDzNpUC",
				downvoteWrapper: "_1iKd82bq_nqObFvSH1iC_Q"
			}
		},
		"./src/reddit/icons/fonts/Downvote/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/Downvote/index.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const l = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("downvote", e.isFilled), d.a.downvote, e.className)
			});
			t.a = e => {
				let {
					compact: t,
					isFilled: n,
					...s
				} = e;
				return t ? r.a.createElement("span", c({}, s, {
					className: Object(o.a)(d.a.compactDownvoteWrapper, s.className)
				}), r.a.createElement(l, {
					className: d.a.compactDownvote,
					isFilled: n
				})) : r.a.createElement("span", c({}, s, {
					className: Object(o.a)(d.a.downvoteWrapper, s.className)
				}), r.a.createElement(l, {
					isFilled: n
				}))
			}
		},
		"./src/reddit/icons/fonts/DropdownTriangle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("caret_down",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Envelope/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("message",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Expand/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("expand", e.isFilled), e.className)
			})
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.m.less": function(e, t, n) {
			e.exports = {
				CollapseIcon: "_3D7Ev4BX__nKnbqb-KPpvI",
				collapseIcon: "_3D7Ev4BX__nKnbqb-KPpvI"
			}
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.m.less"),
				a = n.n(i);
			const d = n("./src/lib/lessComponent.tsx").a.wrapped(e => r.a.createElement("i", {
				className: `${Object(o.b)("collapse",e.isFilled)} ${e.className}`,
				onClick: e.onClick,
				title: e.title
			}), "CollapseIcon", a.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.m.less": function(e, t, n) {
			e.exports = {
				ExpandIcon: "QOwFub52NskNmv0MdMa2_",
				expandIcon: "QOwFub52NskNmv0MdMa2_"
			}
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.m.less"),
				a = n.n(i);
			const d = n("./src/lib/lessComponent.tsx").a.wrapped(e => r.a.createElement("i", {
				className: `${Object(o.b)("expand",e.isFilled)} ${e.className}`,
				onClick: e.onClick,
				title: e.title
			}), "ExpandIcon", a.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/IgnoreReport/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("ignore_reports",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Info/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("info",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Live/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("live", e.isFilled), d.a.liveIcon, e.className)
			})
		},
		"./src/reddit/icons/fonts/Lock/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("lock", e.isFilled), d.a.lockIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/ModActions/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("i", c({}, e, {
				className: Object(o.a)(Object(i.b)("mod", e.isFilled), d.a.modActions, e.className)
			}))
		},
		"./src/reddit/icons/fonts/ModSettings/index.m.less": function(e, t, n) {
			e.exports = {
				ModSettings: "_3-SW6hQX6gXK9G4FM74obr",
				modSettings: "_3-SW6hQX6gXK9G4FM74obr"
			}
		},
		"./src/reddit/icons/fonts/ModSettings/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/ModSettings/index.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(d.a.ModSettings, Object(i.b)("mod", e.isFilled), e.className)
			})
		},
		"./src/reddit/icons/fonts/Op/index.m.less": function(e, t, n) {
			e.exports = {
				OpIcon: "_3mrrZsVUDI2b3p1rpkjbph",
				opIcon: "_3mrrZsVUDI2b3p1rpkjbph"
			}
		},
		"./src/reddit/icons/fonts/OutboundLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("external_link",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Pencil/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("edit",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Photos/index.m.less": function(e, t, n) {
			e.exports = {
				PhotoIcon: "_1LWQVKh7NQLbKMIz2io1Di",
				photoIcon: "_1LWQVKh7NQLbKMIz2io1Di"
			}
		},
		"./src/reddit/icons/fonts/Premium/index.m.less": function(e, t, n) {
			e.exports = {
				PremiumIcon: "dLp3R7pmxclGjLS87yr5S",
				premiumIcon: "dLp3R7pmxclGjLS87yr5S"
			}
		},
		"./src/reddit/icons/fonts/Premium/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Premium/index.m.less"),
				a = n.n(i);
			const d = n("./src/lib/lessComponent.tsx").a.wrapped(e => r.a.createElement("i", {
				title: e.title,
				className: `${Object(o.b)("premium",e.isFilled)} ${e.className}`
			}), "PremiumIcon", a.a)
		},
		"./src/reddit/icons/fonts/Remove/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("remove", e.isFilled), d.a.removeIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Report/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("report", e.isFilled), d.a.reportIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Share/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("share", e.isFilled), d.a.shareIcon, e.className)
			})
		},
		"./src/reddit/icons/fonts/Spam/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("spam", e.isFilled), d.a.spamIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Sticky/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("pin", e.isFilled), d.a.stickyIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Tag/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("tag",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Text/index.m.less": function(e, t, n) {
			e.exports = {
				TextIcon: "_5UHlAh7zBZ6migrBJeld3",
				textIcon: "_5UHlAh7zBZ6migrBJeld3"
			}
		},
		"./src/reddit/icons/fonts/Upvote/index.m.less": function(e, t, n) {
			e.exports = {
				compactUpvote: "_39UOLMgvssWenwbRxz_iEn",
				compactUpvoteWrapper: "_3wVayy5JvIMI67DheMYra2",
				upvote: "_2Jxk822qXs4DaXwsN7yyHA",
				upvoteWrapper: "_2q7IQ0BUOWeEZoeAxN555e"
			}
		},
		"./src/reddit/icons/fonts/Upvote/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/Upvote/index.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const l = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("upvote", e.isFilled), d.a.upvote, e.className)
			});
			t.b = e => {
				let {
					compact: t,
					isFilled: n,
					...s
				} = e;
				return t ? r.a.createElement("span", c({}, s, {
					className: Object(o.a)(d.a.compactUpvoteWrapper, s.className)
				}), r.a.createElement(l, {
					className: d.a.compactUpvote,
					isFilled: n
				})) : r.a.createElement("span", c({}, s, {
					className: Object(o.a)(d.a.upvoteWrapper, s.className)
				}), r.a.createElement(l, {
					isFilled: n
				}))
			}
		},
		"./src/reddit/icons/fonts/helpers.m.less": function(e, t, n) {
			e.exports = {
				TooltipDesc: "_37iEJpUpWXN00_fpZKHglg",
				tooltipDesc: "_37iEJpUpWXN00_fpZKHglg"
			}
		},
		"./src/reddit/icons/fonts/helpers.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.m.less"),
				i = n.n(o),
				a = n("./src/lib/constants/icons.ts"),
				d = n("./src/lib/lessComponent.tsx");
			const c = (e, t) => `icon icon-${e}${t&&!e.includes("fill")&&a.a[`${e}_fill`]?"_fill":""}`,
				l = d.a.wrapped(e => r.a.createElement("span", {
					className: e.className
				}, e.children), "TooltipDesc", i.a)
		},
		"./src/reddit/icons/fonts/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx");

			function a() {
				return (a = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const d = e => {
				let {
					className: t,
					isFilled: n,
					name: s,
					...d
				} = e;
				return r.a.createElement("i", a({
					className: Object(o.a)(t, Object(i.b)(s, n))
				}, d))
			};
			d.displayName = "Icon";
			const c = (e, t) => n => r.a.createElement(d, a({
				name: e
			}, t, n, {
				isFilled: (null == t ? void 0 : t.isFilled) || (null == n ? void 0 : n.isFilled),
				className: Object(o.a)(null == t ? void 0 : t.className, null == n ? void 0 : n.className)
			}));
			t.a = d
		},
		"./src/reddit/icons/svgs/AddCollection/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 24 24"
			}, r.a.createElement("defs", null, r.a.createElement("path", {
				id: "svg-add-collection",
				d: "M19.2 2.4a2.4 2.4 0 0 1 2.4 2.4v.936a3.577 3.577 0 0 0-2.4-.936H4.8c-.925 0-1.763.361-2.4.936V4.8a2.4 2.4 0 0 1 2.4-2.4h14.4zm0 3.6a2.4 2.4 0 0 1 2.4 2.4v.936a3.577 3.577 0 0 0-2.4-.936H4.8c-.925 0-1.763.361-2.4.936V8.4A2.4 2.4 0 0 1 4.8 6h14.4zm0 3.6a2.4 2.4 0 0 1 2.4 2.4v7.2a2.4 2.4 0 0 1-2.4 2.4H4.8a2.4 2.4 0 0 1-2.4-2.4V12a2.4 2.4 0 0 1 2.4-2.4h14.4zm-3.806 5.1H12.9v-2.494a.9.9 0 1 0-1.8 0V14.7H8.607a.9.9 0 1 0 0 1.8H11.1v2.494a.9.9 0 1 0 1.8 0V16.5h2.494a.9.9 0 0 0 0-1.8z"
			})), r.a.createElement("use", {
				fill: "inherit",
				xlinkHref: "#svg-add-collection",
				fillRule: "evenodd"
			}))
		},
		"./src/reddit/icons/svgs/Admin/index.m.less": function(e, t, n) {
			e.exports = {
				admin: "_1PeZajQI0Wm8P3B45yshR",
				mEnabled: "_3axV0unm-cpsxoKWYwKh2x"
			}
		},
		"./src/reddit/icons/svgs/Admin/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Admin/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(e.className, a.a.admin, {
					[a.a.mEnabled]: e.enabled
				}),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 -0.75 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.title && r.a.createElement("title", null, e.title), e.desc && r.a.createElement("desc", null, e.desc), r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "M19.99,9.3125 C19.99,8.104375 19.010625,7.125 17.8025,7.125 C17.213125,7.125 16.67875,7.359375 16.285625,7.73875 C14.8075,6.6725 12.776875,5.98 10.514375,5.886875 L11.491875,1.2875 L14.695625,1.96875 C14.775,2.756875 15.433125,3.375 16.2425,3.375 C17.105625,3.375 17.805,2.675625 17.805,1.8125 C17.805,0.949375 17.105625,0.25 16.2425,0.25 C15.6575,0.25 15.154375,0.575 14.88625,1.050625 L11.228125,0.273125 C11.10625,0.24625 10.98,0.270625 10.875625,0.338125 C10.77125,0.40625 10.698125,0.5125 10.6725,0.63375 L9.556875,5.8825 C7.26,5.960625 5.1975,6.65625 3.7,7.735 C3.306875,7.358125 2.775,7.125 2.1875,7.125 C0.979375,7.125 0,8.104375 0,9.3125 C0,10.20125 0.530625,10.965 1.2925,11.306875 C1.25875,11.524375 1.24,11.745 1.24,11.96875 C1.24,15.334375 5.1575,18.0625 9.99,18.0625 C14.8225,18.0625 18.74,15.334375 18.74,11.96875 C18.74,11.746875 18.721875,11.5275 18.68875,11.31125 C19.455,10.97125 19.99,10.205 19.99,9.3125"
			})), r.a.createElement("g", {
				fill: "none",
				fillRule: "evenodd"
			}, r.a.createElement("polygon", {
				points: "0 20 20 20 20 0 0 0"
			}), r.a.createElement("g", {
				transform: "translate(0 1)"
			})))
		},
		"./src/reddit/icons/svgs/ArrowRight/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({
				viewBox: "0 0 11.4 11.4",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "m11.17929,5.99479c0.08081,-0.19519 0.08081,-0.41599 0,-0.61118c-0.0408,-0.0984 -0.0992,-0.1864 -0.17361,-0.2608l-4.79963,-4.79911c-0.31283,-0.3128 -0.81847,-0.3128 -1.1313,0c-0.31283,0.31279 -0.31283,0.81918 0,1.13118l3.43471,3.43433l-7.66949,0c-0.44244,0 -0.80007,0.3584 -0.80007,0.79999c0,0.44159 0.35763,0.79999 0.80007,0.79999l7.66949,0l-3.43471,3.43433c-0.31283,0.3128 -0.31283,0.81919 0,1.13118c0.15601,0.156 0.36083,0.2344 0.56565,0.2344c0.20482,0 0.40964,-0.0784 0.56565,-0.2344l4.79963,-4.79911c0.07441,-0.0744 0.13281,-0.1624 0.17361,-0.2608"
			})))
		},
		"./src/reddit/icons/svgs/Checkbox/index.m.less": function(e, t, n) {
			e.exports = {
				checkbox: "_1vmueUAOJJg7fhS7wxztWa"
			}
		},
		"./src/reddit/icons/svgs/Checkbox/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Checkbox/index.m.less"),
				a = n.n(i);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				let {
					className: t,
					...n
				} = e;
				return r.a.createElement("svg", d({
					xmlns: "http://www.w3.org/2000/svg",
					width: "20",
					height: "20",
					viewBox: "0 0 20 20",
					className: Object(o.a)(a.a.checkbox, t)
				}, n), r.a.createElement("path", {
					fill: "inherit",
					d: "M1.66666667,3.34755033 L1.66666667,16.6524497 C1.66666667,17.5781756 2.42112363,18.3333333 3.34755033,18.3333333 L16.6524497,18.3333333 C17.5781756,18.3333333 18.3333333,17.5788764 18.3333333,16.6524497 L18.3333333,3.34755033 C18.3333333,2.42182438 17.5788764,1.66666667 16.6524497,1.66666667 L3.34755033,1.66666667 C2.42182438,1.66666667 1.66666667,2.42112363 1.66666667,3.34755033 Z M0,3.34755033 C0,1.49874933 1.5032506,0 3.34755033,0 L16.6524497,0 C18.5012507,0 20,1.5032506 20,3.34755033 L20,16.6524497 C20,18.5012507 18.4967494,20 16.6524497,20 L3.34755033,20 C1.49874933,20 0,18.4967494 0,16.6524497 L0,3.34755033 Z"
				}))
			}
		},
		"./src/reddit/icons/svgs/CheckboxSelected/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({
				xmlns: "http://www.w3.org/2000/svg",
				width: "20",
				height: "20",
				viewBox: "0 0 20 20"
			}, e), r.a.createElement("path", {
				fill: "inherit",
				d: "M0,3.34755033 C0,1.49874933 1.5032506,0 3.34755033,0 L16.6524497,0 C18.5012507,0 20,1.5032506 20,3.34755033 L20,16.6524497 C20,18.5012507 18.4967494,20 16.6524497,20 L3.34755033,20 C1.49874933,20 0,18.4967494 0,16.6524497 L0,3.34755033 Z M8.50575,15.1995 L15.797625,7.907625 C16.25325,7.452625 16.25325,6.71325 15.797625,6.25825 C15.342,5.802625 14.602625,5.802625 14.147625,6.25825 L7.7295,12.676375 L5.635125,10.327625 C5.20575,9.846375 4.46825,9.805125 3.987625,10.23325 C3.506375,10.662625 3.4645,11.400125 3.89325,11.88075 L6.810125,15.151375 C7.023875,15.39075 7.327,15.531375 7.647625,15.54075 C7.658875,15.54075 7.6695,15.541375 7.68075,15.541375 C7.990125,15.541375 8.287,15.41825 8.50575,15.1995 Z"
			}))
		},
		"./src/reddit/icons/svgs/Checkmark/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 22",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M8.9310375,15.1995 C8.70135,15.41825 8.38963125,15.541375 8.0647875,15.541375 C8.052975,15.541375 8.04181875,15.54075 8.03000625,15.54075 C7.69335,15.531375 7.37506875,15.39075 7.15063125,15.151375 L4.0879125,11.88075 C3.637725,11.400125 3.68169375,10.662625 4.18700625,10.23325 C4.6916625,9.805125 5.4660375,9.846375 5.91688125,10.327625 L8.115975,12.676375 L14.8550063,6.25825 C15.3327563,5.802625 16.1091,5.802625 16.5875063,6.25825 C17.0659125,6.71325 17.0659125,7.452625 16.5875063,7.907625 L8.9310375,15.1995 Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/CheckmarkFitted/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "3 4 14 14",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M8.9310375,15.1995 C8.70135,15.41825 8.38963125,15.541375 8.0647875,15.541375 C8.052975,15.541375 8.04181875,15.54075 8.03000625,15.54075 C7.69335,15.531375 7.37506875,15.39075 7.15063125,15.151375 L4.0879125,11.88075 C3.637725,11.400125 3.68169375,10.662625 4.18700625,10.23325 C4.6916625,9.805125 5.4660375,9.846375 5.91688125,10.327625 L8.115975,12.676375 L14.8550063,6.25825 C15.3327563,5.802625 16.1091,5.802625 16.5875063,6.25825 C17.0659125,6.71325 17.0659125,7.452625 16.5875063,7.907625 L8.9310375,15.1995 Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/ChevronDown/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 12 12",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, r.a.createElement("g", null, r.a.createElement("polygon", {
				fill: "inherit",
				points: "11.0584 4.0602 6.0292 9.0894 1 4.0602 2.0608 3 6.0292 6.9684 9.9982 3"
			})))
		},
		"./src/reddit/icons/svgs/ChevronUp/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 12 12",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("polygon", {
				fill: "inherit",
				transform: "translate(6.029200, 6.044700) scale(1, -1) translate(-6.029200, -6.044700)",
				points: "11.0584 4.0602 6.0292 9.0894 1 4.0602 2.0608 3 6.0292 6.9684 9.9982 3"
			})))
		},
		"./src/reddit/icons/svgs/Circle/index.m.less": function(e, t, n) {
			e.exports = {
				circle: "_17IuRdA-NY8vFk-Tt991sn"
			}
		},
		"./src/reddit/icons/svgs/Circle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Circle/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(a.a.circle, e.className),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 8 8"
			}, r.a.createElement("g", {
				fill: "inherit",
				stroke: "none"
			}, r.a.createElement("circle", {
				r: "4",
				cy: "4",
				cx: "4"
			})))
		},
		"./src/reddit/icons/svgs/ClearFilled/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				onClick: e.onClick,
				onMouseUp: e.onMouseUp,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 40 40"
			}, r.a.createElement("path", {
				d: "M20 2.5C10.3 2.5 2.5 10.3 2.5 20c0 9.7 7.8 17.5 17.5 17.5S37.5 29.7 37.5 20C37.5 10.3 29.7 2.5 20 2.5zM24.2 27.7L20 23.5l-4.2 4.2c-1.1 1.1-2.5 1.1-3.5 0-1.1-1.1-1.1-2.4 0-3.5l4.2-4.2-4.2-4.2c-1.1-1.1-1.1-2.5 0-3.5 1.1-1.1 2.4-1.1 3.5 0l4.2 4.2 4.2-4.2c1.1-1.1 2.5-1.1 3.5 0 1.1 1.1 1.1 2.4 0 3.5L23.5 20l4.2 4.2c1.1 1.1 1.1 2.5 0 3.5C26.7 28.8 25.3 28.8 24.2 27.7z"
			}))
		},
		"./src/reddit/icons/svgs/Clock/index.m.less": function(e, t, n) {
			e.exports = {
				clock: "_3dezPhiKJXkVFXj94zLKcs"
			}
		},
		"./src/reddit/icons/svgs/Clock/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Clock/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(a.a.clock, e.className),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 11 11"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M5 3.75C5 3.47388 5.22363 3.25 5.5 3.25C5.77637 3.25 6 3.47388 6 3.75V5.53735L7.81689 6.58643C8.05615 6.72449 8.13818 7.03027 8 7.26941C7.86182 7.50861 7.55615 7.59052 7.31689 7.45245L5.25049 6.25934C5.07861 6.16028 4.98779 5.97504 5.00146 5.78992L5 5.75V3.75Z",
				fill: "inherit"
			}), r.a.createElement("path", {
				fillRule: "evenodd",
				clipRule: "evenodd",
				d: "M11 5.5C11 8.53754 8.5376 11 5.5 11C2.4624 11 0 8.53754 0 5.5C0 2.46246 2.4624 0 5.5 0C8.5376 0 11 2.46246 11 5.5ZM10 5.5C10 7.98529 7.98535 10 5.5 10C3.01465 10 1 7.98529 1 5.5C1 3.01471 3.01465 1 5.5 1C7.98535 1 10 3.01471 10 5.5Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Close/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), r.a.createElement("polygon", {
				fill: "inherit",
				points: "11.649 9.882 18.262 3.267 16.495 1.5 9.881 8.114 3.267 1.5 1.5 3.267 8.114 9.883 1.5 16.497 3.267 18.264 9.881 11.65 16.495 18.264 18.262 16.497"
			}))
		},
		"./src/reddit/icons/svgs/Dropdown/index.m.less": function(e, t, n) {
			e.exports = {
				dropdown: "XHbKeEqnW58ib9mTN6jnS",
				mRedditStyle: "u_kypUXmB-k1A5TcC8MI9"
			}
		},
		"./src/reddit/icons/svgs/Dropdown/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Dropdown/index.m.less"),
				a = n.n(i);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const c = e => {
				let {
					className: t,
					isSubreddit: n,
					...s
				} = e;
				return r.a.createElement("svg", d({
					className: Object(o.a)(a.a.dropdown, {
						[a.a.mRedditStyle]: !n
					}, t),
					viewBox: "0 0 20 20",
					xmlns: "http://www.w3.org/2000/svg"
				}, s), r.a.createElement("path", {
					d: "M14.17,9.35,10,13.53,5.83,9.35a.5.5,0,0,1,.35-.85h7.64a.5.5,0,0,1,.35.85"
				}))
			};
			t.b = c
		},
		"./src/reddit/icons/svgs/Eye/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o(e) {
				return r.a.createElement("svg", {
					className: e.className,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 40 40"
				}, r.a.createElement("g", null, r.a.createElement("path", {
					d: "M20,8C9.1,8,0.5,14,0.5,21.7h4c0-3.6,3.4-6.9,8.2-8.5C11,15,10,17.4,10,20c0,5.5,4.5,10,10,10s10-4.5,10-10c0-2.6-1-5-2.7-6.8c4.8,1.7,8.2,4.9,8.2,8.5h4C39.5,14,30.9,8,20,8z"
				})))
			}
		},
		"./src/reddit/icons/svgs/Grapple/index.m.less": function(e, t, n) {
			e.exports = {
				grapple: "_23XYJUJn_XitrV-LLkNyCQ",
				mIsDragging: "_1jCsYjqdUw4PYY-s3mGB47"
			}
		},
		"./src/reddit/icons/svgs/Grapple/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Grapple/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(e.className, a.a.grapple, {
					[a.a.mIsDragging]: e.isDragging
				}),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("title", {
				id: `${e.title}-title`
			}, e.title), r.a.createElement("g", null, r.a.createElement("path", {
				d: "M8,2 C8.553,2 9,2.447 9,3 L9,5 C9,5.553 8.553,6 8,6 L6,6 C5.447,6 5,5.553 5,5 L5,3 C5,2.447 5.447,2 6,2 L8,2 Z M14,2 C14.553,2 15,2.447 15,3 L15,5 C15,5.553 14.553,6 14,6 L12,6 C11.447,6 11,5.553 11,5 L11,3 C11,2.447 11.447,2 12,2 L14,2 Z M8,8 C8.553,8 9,8.447 9,9 L9,11 C9,11.553 8.553,12 8,12 L6,12 C5.447,12 5,11.553 5,11 L5,9 C5,8.447 5.447,8 6,8 L8,8 Z M14,8 C14.553,8 15,8.447 15,9 L15,11 C15,11.553 14.553,12 14,12 L12,12 C11.447,12 11,11.553 11,11 L11,9 C11,8.447 11.447,8 12,8 L14,8 Z M8,14 C8.553,14 9,14.447 9,15 L9,17 C9,17.553 8.553,18 8,18 L6,18 C5.447,18 5,17.553 5,17 L5,15 C5,14.447 5.447,14 6,14 L8,14 Z M14,14 C14.553,14 15,14.447 15,15 L15,17 C15,17.553 14.553,18 14,18 L12,18 C11.447,18 11,17.553 11,17 L11,15 C11,14.447 11.447,14 12,14 L14,14 Z"
			})))
		},
		"./src/reddit/icons/svgs/ImageUpload/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_2irXdPA4C5flwkupsFkN9-"
			}
		},
		"./src/reddit/icons/svgs/ImageUpload/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/ImageUpload/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("polygon", {
				fill: "inherit",
				opacity: "0",
				points: "0.610673352 20 20.625 20 20.625 0 0.610673352 0"
			}), r.a.createElement("path", {
				d: "M17.451,9.14823765 C17.03,5.40791696 13.8555,2.5 10,2.5 C6.1445,2.5 2.97,5.40791696 2.549,9.14823765 C1.0455,9.84024195 0,11.3551568 0,13.1173944 C0,15.531665 1.959,17.4892627 4.375,17.4892627 L7.8125,17.4892627 L7.8125,12.8051181 L5,12.8051181 C4.8735,12.8051181 4.7595,12.7291725 4.7115,12.6122563 C4.6625,12.49534 4.6895,12.3614359 4.779,12.272 L9.779,7.2755791 C9.901,7.15366643 10.099,7.15366643 10.221,7.2755791 L15.187,12.2375247 C15.2665,12.2944839 15.3185,12.3874173 15.3185,12.4928418 C15.3185,12.6652183 15.1785,12.8051181 15.006,12.8051181 L15,12.8051181 L12.1875,12.8051181 L12.1875,17.4892627 L15.625,17.4892627 C18.041,17.4892627 20,15.531665 20,13.1173944 C20,11.3551568 18.954,9.84024195 17.451,9.14823765",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Info/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M10,8.5 C10.553,8.5 11,8.948 11,9.5 L11,13.5 C11,14.052 10.553,14.5 10,14.5 C9.447,14.5 9,14.052 9,13.5 L9,9.5 C9,8.948 9.447,8.5 10,8.5 Z M10.7002,5.79 C10.8012,5.89 10.8702,6 10.9212,6.12 C10.9712,6.24 11.0002,6.37 11.0002,6.5 C11.0002,6.57 10.9902,6.63 10.9802,6.7 C10.9712,6.76 10.9502,6.82 10.9212,6.88 C10.9002,6.94 10.8702,7 10.8302,7.05 C10.7902,7.11 10.7502,7.16 10.7002,7.21 C10.6602,7.25 10.6102,7.29 10.5512,7.33 C10.5002,7.37 10.4402,7.4 10.3812,7.42 C10.3202,7.45 10.2612,7.47 10.1902,7.48 C10.1312,7.49 10.0602,7.5 10.0002,7.5 C9.7402,7.5 9.4802,7.39 9.2902,7.21 C9.1102,7.02 9.0002,6.77 9.0002,6.5 C9.0002,6.37 9.0302,6.24 9.0802,6.12 C9.1312,5.99 9.2002,5.89 9.2902,5.79 C9.5202,5.56 9.8702,5.46 10.1902,5.52 C10.2612,5.53 10.3202,5.55 10.3812,5.58 C10.4402,5.6 10.5002,5.63 10.5512,5.67 C10.6102,5.71 10.6602,5.75 10.7002,5.79 Z M10,16 C6.691,16 4,13.309 4,10 C4,6.691 6.691,4 10,4 C13.309,4 16,6.691 16,10 C16,13.309 13.309,16 10,16 M10,2 C5.589,2 2,5.589 2,10 C2,14.411 5.589,18 10,18 C14.411,18 18,14.411 18,10 C18,5.589 14.411,2 10,2"
			})))
		},
		"./src/reddit/icons/svgs/Location/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 13 16",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				d: "m10.4442 10.9445c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5m0-8.944c-3.554 0-6.444 2.891-6.444 6.444 0 3.32 5.143 8.658 5.73 9.256.189.192.446.3.714.3.269 0 .526-.108.714-.3.587-.598 5.73-5.936 5.73-9.256 0-3.553-2.89-6.444-6.444-6.444",
				fill: "inherit",
				fillRule: "evenodd",
				transform: "translate(-4 -2)"
			}))
		},
		"./src/reddit/icons/svgs/Lock/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 0 40 40",
				xmlns: "http://www.w3.org/2000/svg",
				fill: e.fill
			}, r.a.createElement("g", null, r.a.createElement("rect", {
				x: "7.5",
				y: "12.5",
				width: "0",
				height: "0"
			}), r.a.createElement("path", {
				fill: "inherit",
				d: "M32.5,17.5v-2.6c0-6.8-5.6-12.4-12.4-12.4h-0.2c-6.8,0-12.4,5.6-12.4,12.4v2.6C6.1,17.5,5,18.6,5,20v10c0,5.5,4.5,10,10,10h10c5.5,0,10-4.5,10-10V20C35,18.6,33.9,17.5,32.5,17.5z M12.5,17.5v-2.6c0-4.1,3.3-7.4,7.4-7.4h0.2c4.1,0,7.4,3.3,7.4,7.4v2.6H12.5z"
			})))
		},
		"./src/reddit/icons/svgs/ModRemove/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M13.0303,11.4697 C13.3233,11.7627 13.3233,12.2377 13.0303,12.5307 C12.8843,12.6767 12.6923,12.7497 12.5003,12.7497 C12.3083,12.7497 12.1163,12.6767 11.9693,12.5307 L10.0003,10.5607 L8.0303,12.5307 C7.8843,12.6767 7.6923,12.7497 7.5003,12.7497 C7.3083,12.7497 7.1163,12.6767 6.9693,12.5307 C6.6763,12.2377 6.6763,11.7627 6.9693,11.4697 L8.9393,9.4997 L6.9693,7.5307 C6.6763,7.2377 6.6763,6.7627 6.9693,6.4697 C7.2623,6.1767 7.7373,6.1767 8.0303,6.4697 L10.0003,8.4397 L11.9693,6.4697 C12.2623,6.1767 12.7373,6.1767 13.0303,6.4697 C13.3233,6.7627 13.3233,7.2377 13.0303,7.5307 L11.0603,9.4997 L13.0303,11.4697 Z M17.2753,3.0377 L10.2753,1.0377 C10.0953,0.9877 9.9053,0.9877 9.7253,1.0377 L2.7253,3.0377 C2.2963,3.1607 2.0003,3.5537 2.0003,3.9997 L2.0003,10.9997 C2.0003,16.6887 9.4093,18.8707 9.7253,18.9617 C9.8153,18.9877 9.9073,18.9997 10.0003,18.9997 C10.0923,18.9997 10.1853,18.9877 10.2753,18.9617 C10.5903,18.8707 18.0003,16.6887 18.0003,10.9997 L18.0003,3.9997 C18.0003,3.5537 17.7043,3.1607 17.2753,3.0377 L17.2753,3.0377 Z",
				id: "path-1"
			})))
		},
		"./src/reddit/icons/svgs/Moderate/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/constants/colors.ts");
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.desc && r.a.createElement("desc", null, e.desc), r.a.createElement("path", {
				d: "M1.88,3.32V9a11.53,11.53,0,0,0,8,11L10,20l.08,0a11.53,11.53,0,0,0,8-11V3.32A11.57,11.57,0,0,1,10,0,11.57,11.57,0,0,1,1.88,3.32"
			}), r.a.createElement("circle", {
				cx: "18",
				cy: "3",
				r: "5",
				fill: e.isUnread ? "white" : "none"
			}), r.a.createElement("circle", {
				cx: "18",
				cy: "3",
				r: "4",
				fill: e.isUnread ? o.a.orangered : "none"
			}))
		},
		"./src/reddit/icons/svgs/Nsfw/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				style: e.style,
				viewBox: "0 0 40 40",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.title && r.a.createElement("title", null, e.title), r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "M38.5,16.5l-15-15c-2-2-5.1-2-7.1,0l-15,15c-2,2-2,5.1,0,7.1l15,15c2,2,5.1,2,7.1,0l15-15 C40.5,21.6,40.5,18.4,38.5,16.5z M17.7,8.3C17.7,7,18.7,6,20,6s2.3,1,2.3,2.3v14.3c0,1.3-1,2.3-2.3,2.3s-2.3-1-2.3-2.3V8.3z M20,33.7c-1.7,0-3.1-1.4-3.1-3.1c0-1.7,1.4-3.1,3.1-3.1s3.1,1.4,3.1,3.1C23.1,32.4,21.7,33.7,20,33.7z"
			})))
		},
		"./src/reddit/icons/svgs/Pencil/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("title", {
				id: `${e.title}-title`
			}, e.title), r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "M15.75,7.834625 L12,4.084625 L12.808,3.276625 C13.8435,2.241125 15.5225,2.241125 16.558,3.276625 C17.5935,4.312125 17.5935,5.991125 16.558,7.026625 L15.75,7.834625 Z M11.366,5 L15.116,8.75 L7.25,16.616 L3.5,12.866 L11.366,5 Z M2.5035,13.5 L6.1125,17.109 L1,18.6125 L2.5035,13.5 Z"
			})))
		},
		"./src/reddit/icons/svgs/Plus/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				version: "1.1"
			}, r.a.createElement("g", {
				stroke: "none"
			}, r.a.createElement("g", {
				transform: "translate(-34.000000, -136.000000)",
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M45.2,147.2 L48.8,147.2 C49.46272,147.2 50,146.66272 50,146 C50,145.33728 49.46272,144.8 48.8,144.8 L45.2,144.8 L45.2,141.2 C45.2,140.53728 44.66272,140 44,140 C43.33728,140 42.8,140.53728 42.8,141.2 L42.8,144.8 L39.2,144.8 C38.53728,144.8 38,145.33728 38,146 C38,146.66272 38.53728,147.2 39.2,147.2 L42.8,147.2 L42.8,150.8 C42.8,151.46272 43.33728,152 44,152 C44.66272,152 45.2,151.46272 45.2,150.8 L45.2,147.2 Z"
			}))))
		},
		"./src/reddit/icons/svgs/Post/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("path", {
				d: "M5,15a1,1,0,0,1-1-1V11.17a1,1,0,0,1,.29-.7l8.09-8.09a1,1,0,0,1,1.41,0l2.83,2.83a1,1,0,0,1,0,1.41L8.54,14.71a1,1,0,0,1-.71.29Zm12,1a1,1,0,0,1,0,2H3a1,1,0,0,1,0-2Z"
			}))
		},
		"./src/reddit/icons/svgs/Premium/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				d: "M13.535 15.785c-1.678.244-2.883.742-3.535 1.071v-5.113a2 2 0 0 0-2-2H4.217c.044-.487.076-1.016.076-1.629 0-1.692-.489-2.968-.884-3.722L4.8 3.001H10v4.742a2 2 0 0 0 2 2h3.783c.06.67.144 1.248.22 1.742.097.632.182 1.177.182 1.745 0 1.045-.829 2.291-2.65 2.555m5.028-12.249l-2.242-2.242a1 1 0 0 0-.707-.293H4.386a1 1 0 0 0-.707.293L1.436 3.536a1 1 0 0 0-.069 1.337c.009.011.926 1.2.926 3.241 0 1.304-.145 2.24-.273 3.065-.106.684-.206 1.33-.206 2.051 0 1.939 1.499 4.119 4.364 4.534 2.086.304 3.254 1.062 3.261 1.065a1.016 1.016 0 0 0 1.117.004c.011-.007 1.18-.765 3.266-1.069 2.864-.415 4.363-2.595 4.363-4.534 0-.721-.099-1.367-.206-2.051-.128-.825-.272-1.761-.272-3.065 0-2.033.893-3.199.926-3.241a.999.999 0 0 0-.07-1.337"
			}))
		},
		"./src/reddit/icons/svgs/PremiumCircle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("rect", {
				width: "20",
				height: "20",
				rx: "10",
				fill: "url(#gradient)"
			}), r.a.createElement("path", {
				d: "M12.121 13.471c-1.007.146-1.73.445-2.121.643v-3.068a1.2 1.2 0 00-1.2-1.2H6.53c.027-.292.046-.61.046-.978 0-1.015-.294-1.78-.53-2.233l.834-.834H10v2.845a1.2 1.2 0 001.2 1.2h2.27c.036.402.086.749.132 1.045.058.38.109.706.109 1.047 0 .627-.497 1.375-1.59 1.533zm3.017-7.35l-1.345-1.345a.6.6 0 00-.425-.175H6.632a.6.6 0 00-.425.175L4.862 6.122a.6.6 0 00-.042.802c.006.006.556.72.556 1.944 0 .783-.087 1.344-.164 1.84-.064.41-.124.797-.124 1.23 0 1.163.9 2.471 2.619 2.72 1.251.183 1.952.638 1.956.64a.61.61 0 00.67.002c.007-.004.709-.46 1.96-.642 1.719-.249 2.618-1.557 2.618-2.72 0-.433-.06-.82-.124-1.23a11.026 11.026 0 01-.163-1.84c0-1.22.536-1.919.556-1.944a.6.6 0 00-.042-.802z",
				fill: "#fff"
			}), r.a.createElement("defs", null, r.a.createElement("linearGradient", {
				id: "gradient",
				x1: "0",
				y1: "20",
				x2: "20.021",
				y2: "19.979",
				gradientUnits: "userSpaceOnUse"
			}, r.a.createElement("stop", {
				stopColor: "#EC0623"
			}), r.a.createElement("stop", {
				offset: "1",
				stopColor: "#FF8717"
			}))))
		},
		"./src/reddit/icons/svgs/PresenceCircle/index.m.less": function(e, t, n) {
			e.exports = {
				defaultInactiveState: "_1g3Xfh9mljLHWv24M9A3Rw",
				outline: "_3SlBAJb2MbUHwgBZFH8eL7",
				highlighted: "_1-JQy00VxG8hpTxxdxV32y"
			}
		},
		"./src/reddit/icons/svgs/PresenceCircle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/PresenceCircle/index.m.less"),
				a = n.n(i);
			t.a = Object(s.forwardRef)((e, t) => {
				let {
					className: n,
					isHighlighted: s,
					outlineClassName: i
				} = e;
				return r.a.createElement("svg", {
					className: Object(o.a)(a.a.defaultInactiveState, n),
					viewBox: "0 0 12 12",
					xmlns: "http://www.w3.org/2000/svg",
					width: "12",
					height: "12",
					ref: t
				}, r.a.createElement("circle", {
					cx: "6",
					cy: "6",
					r: "4"
				}), r.a.createElement("path", {
					className: Object(o.a)(a.a.outline, i, {
						[a.a.highlighted]: s
					}),
					fillRule: "evenodd",
					clipRule: "evenodd",
					d: "M12 6C12 9.31371 9.31371 12 6 12C2.68629 12 0 9.31371 0 6C0 2.68629 2.68629 0 6 0C9.31371 0 12 2.68629 12 6ZM6 10C8.20914 10 10 8.20914 10 6C10 3.79086 8.20914 2 6 2C3.79086 2 2 3.79086 2 6C2 8.20914 3.79086 10 6 10Z"
				}))
			})
		},
		"./src/reddit/icons/svgs/PrivateKey/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/chat/controls/Svg/index.tsx");

			function i() {
				return (i = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement(o.a, i({}, e, {
				viewBox: "-1 -1 21 21"
			}), r.a.createElement("path", {
				d: "M16.64,2.32a4.5,4.5,0,0,0-7,5.57L4.85,12.69,3.59,13.95h0L2.34,15.2a1,1,0,0,0,0,1.41l1.25,1.25h0l.42.42a1,1,0,0,0,1.41-1.41L5,16.46H5a.78.78,0,0,1,0-1.09.79.79,0,0,1,1.09,0h0l.42.42a1,1,0,0,0,1.41-1.41L7.52,14h0L7,13.4l4.1-4.1a4.5,4.5,0,0,0,5.57-7Zm-1.41,5a2.5,2.5,0,1,1,0-3.54A2.5,2.5,0,0,1,15.22,7.27Z"
			}))
		},
		"./src/reddit/icons/svgs/RadioOff/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_11Rht_b1e-kmk12gkz7Lug"
			}
		},
		"./src/reddit/icons/svgs/RadioOff/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/RadioOff/index.m.less"),
				a = n.n(i);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", d({}, e, {
				className: Object(o.a)(a.a.icon, e.className),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}), r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M10,1.66666667 C5.39762708,1.66666667 1.66666667,5.39762708 1.66666667,10 C1.66666667,14.6023729 5.39762708,18.3333333 10,18.3333333 C14.6023729,18.3333333 18.3333333,14.6023729 18.3333333,10 C18.3333333,5.39762708 14.6023729,1.66666667 10,1.66666667 Z M10,0 C15.5228475,-1.01453063e-15 20,4.4771525 20,10 C20,15.5228475 15.5228475,20 10,20 C4.4771525,20 6.76353751e-16,15.5228475 0,10 C-6.76353751e-16,4.4771525 4.4771525,1.01453063e-15 10,0 Z"
			})))
		},
		"./src/reddit/icons/svgs/RadioOn/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({}, e, {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}), r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M10,6.66666667 C8.15905083,6.66666667 6.66666667,8.15905083 6.66666667,10 C6.66666667,11.8409492 8.15905083,13.3333333 10,13.3333333 C11.8409492,13.3333333 13.3333333,11.8409492 13.3333333,10 C13.3333333,8.15905083 11.8409492,6.66666667 10,6.66666667 Z M10,0 C15.5228475,-1.01453063e-15 20,4.4771525 20,10 C20,15.5228475 15.5228475,20 10,20 C4.4771525,20 6.76353751e-16,15.5228475 0,10 C-6.76353751e-16,4.4771525 4.4771525,1.01453063e-15 10,0 Z"
			})))
		},
		"./src/reddit/icons/svgs/Remove/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				id: e.id,
				tabIndex: e.tabIndex,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement("g", null, r.a.createElement("path", {
				fillRule: "evenodd",
				d: "M13.5559061,14.5 C13.5559061,14.776 13.3283409,15 13.0479481,15 C12.7675552,15 12.53999,14.776 12.53999,14.5 L12.53999,9 C12.53999,8.724 12.7675552,8.5 13.0479481,8.5 C13.3283409,8.5 13.5559061,8.724 13.5559061,9 L13.5559061,14.5 Z M10.508158,14.5 C10.508158,14.776 10.2805928,15 10.0002,15 C9.71980718,15 9.49224199,14.776 9.49224199,14.5 L9.49224199,9 C9.49224199,8.724 9.71980718,8.5 10.0002,8.5 C10.2805928,8.5 10.508158,8.724 10.508158,9 L10.508158,14.5 Z M7.46040996,14.5 C7.46040996,14.776 7.23284477,15 6.95245195,15 C6.67205913,15 6.44449394,14.776 6.44449394,14.5 L6.44449394,9 C6.44449394,8.724 6.67205913,8.5 6.95245195,8.5 C7.23284477,8.5 7.46040996,8.724 7.46040996,9 L7.46040996,14.5 Z M15.492242,6 C15.7736507,6 16.0002,6.224 16.0002,6.5 L16.0002,16.5 C16.0002,17.327 15.3164885,18 14.476326,18 L5.52407403,18 C4.68391148,18 4.0002,17.327 4.0002,16.5 L4.0002,6.5 C4.0002,6.224 4.22674927,6 4.50815801,6 L15.492242,6 Z M15.491585,3 C15.7719541,3 15.9995,3.224 15.9995,3.5 L15.9995,4.5 C15.9995,4.776 15.7719541,5 15.491585,5 L4.50741501,5 C4.22704592,5 3.9995,4.776 3.9995,4.5 L3.9995,3.5 C3.9995,3.224 4.22704592,3 4.50741501,3 L7.51325603,3 L8.26598607,2.167 C8.36248993,2.061 8.50064281,2 8.6459065,2 L11.3541093,2 C11.4983572,2 11.6365101,2.061 11.7340298,2.167 L12.485744,3 L15.491585,3 Z"
			})))
		},
		"./src/reddit/icons/svgs/Replay/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({}, e, {
				viewBox: "13 12 23 23",
				xmlns: "http://www.w3.org/2000/svg"
			}), r.a.createElement("g", null, r.a.createElement("path", {
				d: "M32.5 23.3c-.7 0-1.2.5-1.2 1.2 0 4-3.2 7.2-7.2 7.2s-7.2-3.2-7.2-7.2c0-3.6 2.7-6.6 6.2-7.1v1.7c0 .2.1.4.3.5.1 0 .2.1.3.1.1 0 .3 0 .4-.1l3.6-3c.1-.1.2-.3.2-.5s-.1-.3-.2-.5l-3.7-3c-.2-.1-.4-.2-.6-.1-.2.1-.4.3-.4.6V15c-4.8.5-8.6 4.6-8.6 9.5 0 5.3 4.3 9.6 9.6 9.6s9.6-4.3 9.6-9.6c.1-.7-.5-1.2-1.1-1.2",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Search/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				d: "M15.59,13.91l2.78,2.69a1.25,1.25,0,1,1-1.74,1.8l-2.82-2.73a8,8,0,1,1,1.78-1.76ZM14.64,9.2A5.45,5.45,0,1,0,9.2,14.64,5.45,5.45,0,0,0,14.64,9.2Z"
			}))
		},
		"./src/reddit/icons/svgs/Shirt/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = function(e) {
				let {
					className: t
				} = e;
				return r.a.createElement("svg", {
					className: t,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", {
					fill: "inherit"
				}, r.a.createElement("path", {
					d: "M7 1.75a.486.486 0 01.487.4 2.574 2.574 0 005.085 0 .488.488 0 01.488-.4h1.583A.5.5 0 0115 1.9l3.951 4.09a.5.5 0 01-.006.7l-1.931 1.938a.5.5 0 01-.649.05l-1.482-1.084.007 10.156a.5.5 0 01-.5.5H5.385a.5.5 0 01-.5-.5l.007-10.156L3.7 8.626a.5.5 0 01-.677-.026L1.115 6.694a.5.5 0 01-.006-.7L5.06 1.9a.5.5 0 01.359-.153z"
				})))
			}
		},
		"./src/reddit/icons/svgs/Show/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("path", {
				d: "M17.71,10.29,14.95,7.54a7,7,0,0,0-9.9,0L2.29,10.29a1,1,0,0,0,1.41,1.41L6.46,8.95c.07-.07.14-.11.21-.17a4,4,0,1,0,6.65,0c.07.06.15.11.21.17l2.76,2.76a1,1,0,0,0,1.41-1.41Z"
			}))
		},
		"./src/reddit/icons/svgs/SnooHappy/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 24 25",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				fill: "#000",
				d: "M19.7 9.4c-.6.2-1.1 0-1.6-.3-1.3-.8-2.6-1.4-4.2-1.5-1.2-.1-1.8-.1-2.3 0-1.1.2-2.2.4-3.2.7-.6.2-1.1.6-1.7.8-.2.1-.5.2-.7.2-2.3-.6-4.1.2-5.4 2.2-1.1 1.7-.4 4.4.9 5.3.2.2.5.5.5.8.1 2.1 1.2 3.6 2.7 4.8.1.1.2.1.3.2.6.4 1.9 1.2 3 1.5 1.5.5 3 .7 4.5.7 1.5-.1 3-.1 4.4-.6.4-.2 2.3-1.1 3.4-2.2 1.2-1.5 2.3-3 2.5-4.9.1-1 .4-1.8.9-2.7.2-.3.2-.6.3-.9.4-2.5-2-5-4.3-4.1z"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M20.9 10c-.4-.1-.8 0-1.4 0 1 1.1 1.8 2.1 2.2 3.4-2.2-3.2-5.3-5.1-9.1-5.1s-7 1.6-9.2 4.9c-.1-.3-.3-.6-.2-.7.5-1 1.2-1.9 2.3-2.5-1.7-.5-3.5.4-4.4 2.2-.7 1.4-.3 3.3.9 4.1l.3-1.2c.1-.4.4-.7.6-1 .1.2.1.3 0 .4-.5 1.5-.3 3 .2 4.5.5 1 1.1 2 2.1 2.8 3.9 2.9 9.4 3.6 13.8.5 1.9-1.3 2.9-3.3 3.1-5.7.1-.6.1-1.2.1-1.8.1 0 .1.1.2.1.2-.2.6-.3.7-.5.7-1.7-.4-3.9-2.2-4.4z"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M10.1 15.4s-.3-.1-.4-.2l-.6-.6c-.8-.5-1.6-.3-2.2.5-.2.3-.3.5-.5.8-.1.1-.3.2-.5.3-.1-.2-.2-.4-.2-.6.1-.4.3-.7.3-.9 1.1-1.7 3.3-1.8 4.1-.3.1.2.2.3.2.5s-.1.4-.2.5zm3.1 6.5c-2.3 0-4-1.6-4.4-3.4 0-.1.3-.4.6-.5 2-.8 5-1.1 7.2-.4.2.1.5.2.5.3 0 .1-.3.2-.3.3-.4 1.7-1.5 3.7-3.6 3.7zm5.9-6.5c-.1 0-.3-.1-.4-.2-.1 0-.1-.1-.1-.2-.6-.9-1.4-1-2.2-.3-.2.2-.5.2-.7.4.1-.3 0-.7.2-.9.7-.9 1.8-1.1 2.7-.5.2.2.6.9.8 1.4-.1.1-.2.3-.3.3zM16.6.5c-.5-.4-1.4-.7-2.3-.2-.4.2-.7.5-.8.7-.2.7-.2 1.1-.1 1.5-1 1-2.2 1.6-3.6 1.7-.2 0-.4.2-.4.4-.1.5.1.9.4 1.4.5.7.7 1.2.9 1.9V8c.1.2.2.2.4.2.1 0 .2-.1.3-.1.1-.1.1-.2.1-.3v-.2c0-.1-.1-.3-.1-.4-.1-.3-.2-.6-.3-.8-.1-.2-.2-.3-.3-.4-.1-.3-.3-.8-.3-1.1.5-.1 1.1-.2 1.6-.5.4-.2.7-.5 1-.8.2-.2.3-.3.5-.4.4.5.8.7 1.6.8h.2c.4 0 .9-.2 1.3-.5s.6-.8.6-1.4c.1-.6-.2-1.2-.7-1.6z"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M14 1.9c-.1-.6.4-1.1 1.1-1.2.8-.1 1.4.3 1.5 1 .1.7-.5 1.5-1.1 1.6-.7.1-1.4-.6-1.5-1.4z"
			}))
		},
		"./src/reddit/icons/svgs/SnooSilhouette/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 320 320",
				xmlns: "http://www.w3.org/2000/svg",
				style: e.style
			}, r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "m124.91 237.79c-53.47 32.9-28.3 109.77-9.81 76.9"
			}), r.a.createElement("path", {
				d: "m115.13 314.7a9.86 9.86 0 0 1 -1.44 3l-.85 1.22c-.34.4-.68.85-1.09 1.28a11.46 11.46 0 0 1 -3 2.34 7.26 7.26 0 0 1 -4.16.82 8.13 8.13 0 0 1 -3.86-1.63 14 14 0 0 1 -2.64-2.62 26.58 26.58 0 0 1 -1.7-2.45c-3.11-5.09-4.59-11.37-5.16-17.65a66.18 66.18 0 0 1 6.12-33.55 69 69 0 0 1 3.7-6.66 68.22 68.22 0 0 1 4.3-5.93 62.51 62.51 0 0 1 9.65-9.4 61.54 61.54 0 0 1 9.62-6.13c-2.15 2.3-5.35 5.36-8.11 8.41s-5.19 6-6.61 7.42a56.91 56.91 0 0 0 -7.33 9.28 58.25 58.25 0 0 0 -5 10 60.67 60.67 0 0 0 -4 20 53 53 0 0 0 2.33 17.65 28.76 28.76 0 0 0 3.32 7.14c1.39 2 3.15 3.76 5.17 4.28a5.79 5.79 0 0 0 3.36-.19 11.09 11.09 0 0 0 3.45-2.14 29.87 29.87 0 0 0 3.93-4.49z"
			}), r.a.createElement("path", {
				d: "m194.69 240.89c45.74 25.85 23.37 107.54 4.1 73.8"
			}), r.a.createElement("path", {
				d: "m198.81 314.67a17 17 0 0 1 2 2.41 16.1 16.1 0 0 0 4.54 4.16 6.1 6.1 0 0 0 3.23.79 5.88 5.88 0 0 0 3-1.15 12.67 12.67 0 0 0 3.58-4.37c2.39-4.65 3.64-10.3 4.24-16a71.58 71.58 0 0 0 -.3-17 66.16 66.16 0 0 0 -9-25.89 54.68 54.68 0 0 0 -15.7-16.28 30.16 30.16 0 0 1 10.19 5 29.29 29.29 0 0 1 7.11 7.13 68.35 68.35 0 0 1 8.62 21.25 81.56 81.56 0 0 1 2 19.91 58.88 58.88 0 0 1 -2.83 17.4 27.36 27.36 0 0 1 -3.67 7.28 13.8 13.8 0 0 1 -2.85 2.86 7.81 7.81 0 0 1 -3.8 1.51 6.82 6.82 0 0 1 -4.21-1 11.92 11.92 0 0 1 -3.25-3 24.69 24.69 0 0 1 -2.9-5.01z"
			}), r.a.createElement("path", {
				d: "m125.46 236.86c32.07-45.32 77.78-13.73 79.92 56.7-.5 46.56-23 35.27-51.14 35.27s-42.05 9.17-44.66-24.83c-1.5-19.46-.66-20.87 3.28-33"
			}), r.a.createElement("path", {
				d: "m112.89 271a23.38 23.38 0 0 1 -.68 2.76c-.41 1.47-1 3.44-1.61 5.81a38.08 38.08 0 0 0 -1.14 8.22c-.12 3.08.07 6.43.29 9.9.51 6.92 1 14.41 3.16 20.71a16.43 16.43 0 0 0 4.9 7.54 13.56 13.56 0 0 0 6.7 2.65 56.37 56.37 0 0 0 11.6-.1c4-.32 8-.71 12.18-.92a124.9 124.9 0 0 1 12.55-.09c4.2.16 8.4.49 12.56.7 2.08.1 4.15.18 6.2.15a40.17 40.17 0 0 0 6.05-.44 22.51 22.51 0 0 0 5.6-1.55 14.89 14.89 0 0 0 4.6-3.17 17.38 17.38 0 0 0 3.27-4.6l.33-.64.29-.67.56-1.34c.3-.93.65-1.84.9-2.79a62.06 62.06 0 0 0 1.9-11.66 108.3 108.3 0 0 0 -.63-20.6 130.55 130.55 0 0 0 -3.86-20 94.18 94.18 0 0 0 -7.15-18.4 59.18 59.18 0 0 0 -11-15.23c-4.38-4.24-9.48-7.58-15-9a27.57 27.57 0 0 0 -16.33.49 39.21 39.21 0 0 0 -13.41 7.9 74.8 74.8 0 0 0 -9.76 10.58 61.55 61.55 0 0 1 8.78-11.74 39.25 39.25 0 0 1 14.45-9.6 31.64 31.64 0 0 1 8.59-1.83h2.12a13 13 0 0 1 2.08.09 28.29 28.29 0 0 1 3.93.63 31.93 31.93 0 0 1 11.28 5.06 50.46 50.46 0 0 1 12 12.46 74.93 74.93 0 0 1 7.89 14.59 117.86 117.86 0 0 1 7.81 30.35c.15 1.25.31 2.5.46 3.75s.22 2.49.32 3.73c.26 2.48.3 5 .43 7.41a34.56 34.56 0 0 1 0 3.67c0 1.22-.07 2.44-.16 3.64s-.14 2.41-.28 3.6-.23 2.38-.43 3.56-.34 2.36-.6 3.52-.51 2.32-.82 3.46a16.49 16.49 0 0 1 -.52 1.69c-.19.56-.36 1.12-.57 1.68a32.08 32.08 0 0 1 -1.48 3.21 19.92 19.92 0 0 1 -4.28 5.58 18.29 18.29 0 0 1 -6 3.5 37.52 37.52 0 0 1 -13.18 1.66c-4.33-.07-8.53-.42-12.65-.67s-8.17-.43-12.14-.36-7.88.29-11.73.58-7.66.61-11.47.63a34.51 34.51 0 0 1 -5.73-.4 17.16 17.16 0 0 1 -5.52-1.82 13.8 13.8 0 0 1 -4.34-3.84 19.11 19.11 0 0 1 -2.64-4.9 44.16 44.16 0 0 1 -2.39-10.24c-.44-3.22-.63-7-.81-11a93.65 93.65 0 0 1 .09-12 37.54 37.54 0 0 1 .92-5.5c.42-1.71.94-3.25 1.4-4.62.96-2.66 1.74-4.74 2.12-5.74z"
			}), r.a.createElement("path", {
				d: "m229 74.81c-1 .47-5.78-2.28-11.24-5.44s-11.7-6.6-15.42-7.94c-3.26-1.22-6.62-2.41-10-3.36a43 43 0 0 0 -4.93-1.07 13.89 13.89 0 0 0 -4.19-.08 3.6 3.6 0 0 0 -1.2.4c-.13.08-.17.17-.27.22s-.12.11-.14.24l-1 1.75c-.42.78-.91 1.53-1.29 2.34-.8 1.58-1.62 3.14-2.3 4.75s-1.34 3.2-2 4.78c-4.19 11.17-6.17 23.06-7.52 34.18s-2.05 21.46-3.05 29.85a36 36 0 0 1 -3.83-6.41 58 58 0 0 1 -2.89-7.72c-1.5-5.24-2.06-10.33-1.53-13a266.73 266.73 0 0 1 7.37-29.3 114.2 114.2 0 0 1 10.81-24.11l.39-.67.2-.33.09-.17.16-.2a8.58 8.58 0 0 1 1.33-1.56l.78-.69.86-.53a9.4 9.4 0 0 1 1.8-.83 15.64 15.64 0 0 1 6.86-.52 44.74 44.74 0 0 1 11.26 3.14 87 87 0 0 1 17.63 9.78c4.93 3.27 11.92 10.94 13.26 12.5z"
			}), r.a.createElement("path", {
				d: "m105.63 128c-43.28-20.15-74.18 36.54-30.75 61.74"
			}), r.a.createElement("path", {
				d: "m74.86 189.75c-.5 0-4.4-2-8.31-5.22-.94-.85-2-1.65-2.88-2.59s-1.82-1.86-2.61-2.82-1.51-1.9-2.15-2.77-1.13-1.7-1.57-2.38a32.77 32.77 0 0 1 -5-17.32 36.58 36.58 0 0 1 1.3-9.37c.22-.76.5-1.49.74-2.24l.39-1.1.47-1.07c.33-.7.62-1.42 1-2.11s.76-1.33 1.13-2a34 34 0 0 1 24.86-16.35 36.14 36.14 0 0 1 13.32.9 42.71 42.71 0 0 1 10.39 4.17c-3.08-.41-7.27-1.42-11.25-1.59a81.76 81.76 0 0 0 -9.48-.06 29.42 29.42 0 0 0 -11 2.08 30.48 30.48 0 0 0 -9.21 5.75 31.36 31.36 0 0 0 -8.27 34 38.69 38.69 0 0 0 7.82 12.76 66.35 66.35 0 0 0 5.7 5.64 36 36 0 0 0 2.84 2.34z"
			}), r.a.createElement("path", {
				d: "m254.61 176.52c30.45-26.89-2.76-71.55-39.71-54.67"
			}), r.a.createElement("path", {
				d: "m214.89 121.83a9.6 9.6 0 0 1 2.48-1.41 20.3 20.3 0 0 1 2.51-1l1.47-.51c.5-.18 1.05-.27 1.59-.42a28.32 28.32 0 0 1 3.37-.69 28.71 28.71 0 0 1 3.38-.39 46.61 46.61 0 0 1 5.63 0 34.21 34.21 0 0 1 15.32 4.6l1.79 1.09c.59.37 1.13.81 1.7 1.22a35.6 35.6 0 0 1 8.53 8.92 32.62 32.62 0 0 1 5.34 12.84 30.43 30.43 0 0 1 -.56 13.24 31.13 31.13 0 0 1 -5.33 10.68 36.88 36.88 0 0 1 -7.12 7c1.37-2.44 3.58-5.54 5.05-8.73.43-.76.7-1.59 1-2.31.16-.38.35-.73.49-1.09l.38-1c.24-.68.53-1.28.72-1.84a13.79 13.79 0 0 1 .52-1.42 26.43 26.43 0 0 0 .49-19 31.61 31.61 0 0 0 -4.13-8 35.33 35.33 0 0 0 -5.79-6.19c-.52-.45-1.08-.83-1.62-1.24a15 15 0 0 0 -1.64-1.14l-1.68-1-1.72-.88-.85-.44c-.28-.13-.58-.24-.87-.36l-1.73-.71c-.58-.21-1.17-.37-1.74-.56a17.9 17.9 0 0 0 -1.73-.5 40.08 40.08 0 0 0 -13.23-.93c-.49.06-1 .1-1.6.14l-1.76.27c-.6.09-1.23.15-1.84.26l-1.81.39c-.59.13-1.17.22-1.7.37l-1.46.41z"
			}), r.a.createElement("path", {
				d: "m159.25 111.23c-48.61-.37-93.95 27.23-96.18 72.22-1.87 83.41 194.24 83.41 192.37 0 0-48.33-44.72-72.22-96.19-72.22z"
			}), r.a.createElement("path", {
				d: "m159.25 111.23c-48.61-.37-93.95 27.23-96.18 72.22-1.87 83.41 194.24 83.41 192.37 0 0-48.33-44.72-72.22-96.19-72.22z",
				fill: "none"
			}), r.a.createElement("path", {
				d: "m159.25 111.2a100.82 100.82 0 0 1 14.86.32 130.39 130.39 0 0 1 30.18 6.06 97.07 97.07 0 0 1 16.43 7.17 78.93 78.93 0 0 1 14.49 10.25 63.78 63.78 0 0 1 16.79 23.82 67.61 67.61 0 0 1 4.45 19.57c.13 1.7.15 3.4.22 5.11v3.89l-.11 1.3-.22 2.61-.42 2.6a23.2 23.2 0 0 1 -.54 2.58c-.22.85-.37 1.72-.67 2.56a49.79 49.79 0 0 1 -4.15 9.79 56.7 56.7 0 0 1 -6.2 8.74 68 68 0 0 1 -7.75 7.43 78.42 78.42 0 0 1 -8.81 6.14c-12.32 7.38-26.19 11.74-40.07 14.24a168.29 168.29 0 0 1 -41.54 2.05 148 148 0 0 1 -34.89-6.69c-11.22-3.67-22-9-31-16.58a56.52 56.52 0 0 1 -11.6-13.16 48.93 48.93 0 0 1 -6.51-16.08 50.29 50.29 0 0 1 -.46-17 66.24 66.24 0 0 1 4.18-16 70.76 70.76 0 0 1 18.09-25.69 90.75 90.75 0 0 1 24.8-15.93 101.47 101.47 0 0 1 13.06-4.78 112.2 112.2 0 0 1 12.93-3c2.12-.41 4.24-.65 6.32-1s4.15-.47 6.2-.57c4.08-.33 8.06-.33 11.91-.29a142.44 142.44 0 0 0 -24.22 3.34 117.79 117.79 0 0 0 -26.52 9.42 92.75 92.75 0 0 0 -21.58 14.9 77.13 77.13 0 0 0 -12.25 14.6 62.07 62.07 0 0 0 -9.53 25.39 45.71 45.71 0 0 0 3.46 25.86 53.67 53.67 0 0 0 16.28 19.83 87.52 87.52 0 0 0 22.14 12.14 129.68 129.68 0 0 0 23.75 6.56 160.17 160.17 0 0 0 23.78 2.47 157.94 157.94 0 0 0 45.17-5.1 113.68 113.68 0 0 0 20.3-7.54 86.22 86.22 0 0 0 9.16-5.19 73.68 73.68 0 0 0 8.22-6.24 52.36 52.36 0 0 0 12.26-15.71l.56-1.09.48-1.13c.3-.76.64-1.5.92-2.26a44.84 44.84 0 0 0 1.41-4.63 46.94 46.94 0 0 0 1.37-9.46c0-1.59.08-3.16 0-4.75s-.07-3.17-.26-4.72l-.21-2.34c-.09-.77-.23-1.54-.34-2.3s-.22-1.54-.37-2.3l-.49-2.25a58.73 58.73 0 0 0 -6.56-16.8 63.59 63.59 0 0 0 -10.77-13.72 74.79 74.79 0 0 0 -13.46-10.24 100.84 100.84 0 0 0 -16.3-7.81 122.86 122.86 0 0 0 -19-5.41 160 160 0 0 0 -27.37-2.98z"
			}), r.a.createElement("circle", {
				cx: "238.47",
				cy: "80.13",
				r: "22.93"
			}), r.a.createElement("path", {
				d: "m261.37 80.13a5.12 5.12 0 0 1 -.27-1.29c-.06-.34-.08-.75-.17-1.2s-.19-1-.3-1.5a23.88 23.88 0 0 0 -3.12-7.61 22.56 22.56 0 0 0 -6.59-6.71 20 20 0 0 0 -7.06-2.93 22.12 22.12 0 0 0 -19.67 5.49 21.36 21.36 0 0 0 -5.7 9 20.88 20.88 0 0 0 -.7 10.29 21.16 21.16 0 0 0 9.47 14.18 21.55 21.55 0 0 0 16.06 2.92 21.77 21.77 0 0 0 12.8-8.08 23.8 23.8 0 0 0 3.39-6.16 26 26 0 0 0 1.32-6.35 19.06 19.06 0 0 1 .12 6.81 21.83 21.83 0 0 1 -8.21 13.51 18.67 18.67 0 0 1 -5.13 2.82 24.34 24.34 0 0 1 -8.2 1.31 24.84 24.84 0 0 1 -7.83-1.26 25.86 25.86 0 0 1 -6.77-3.5 25 25 0 0 1 -5.2-5.16 23.4 23.4 0 0 1 -3.35-6.21 25 25 0 0 1 -1-3.32c-.13-.56-.18-1.12-.28-1.68l-.12-.84c0-.28 0-.56-.05-.84 0-.56 0-1.12-.07-1.68s.05-1.11.08-1.66a11.26 11.26 0 0 1 .17-1.64c.09-.54.15-1.09.26-1.62a25.58 25.58 0 0 1 2.15-6 24.56 24.56 0 0 1 5.71-7.24c.37-.34.79-.62 1.18-.93a11.19 11.19 0 0 1 1.21-.87 23.57 23.57 0 0 1 21.4-2.45 23 23 0 0 1 8.39 5.48 22 22 0 0 1 6.08 14.14c.11 1.26 0 2.29 0 2.78z"
			})))
		},
		"./src/reddit/icons/svgs/Trash/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 40 40"
			}, r.a.createElement("g", null, r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("polygon", {
				points: "10,38.8 30,38.8 31.2,10.9 8.7,10.9"
			}), r.a.createElement("path", {
				d: "M27.5,3.8H25c0-1.4-1.1-2.5-2.5-2.5h-5c-1.4,0-2.5,1.1-2.5,2.5h-2.5c-2.8,0-5,2.2-5,5h25C32.5,6,30.3,3.8,27.5,3.8z"
			}))))
		},
		"./src/reddit/icons/svgs/Trash2/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1Fa4RPHlhrfUZuNaXK2-eP"
			}
		},
		"./src/reddit/icons/svgs/Trash2/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Trash2/index.m.less"),
				a = n.n(i);
			const d = e => r.a.createElement("svg", {
				className: Object(o.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, r.a.createElement("path", {
				d: "M16.5,2H12.71l-.85-.85A.5.5,0,0,0,11.5,1h-3a.5.5,0,0,0-.35.15L7.29,2H3.5a.5.5,0,0,0-.5.5v1a.5.5,0,0,0,.5.5h13a.5.5,0,0,0,.5-.5v-1A.5.5,0,0,0,16.5,2Z"
			}), r.a.createElement("path", {
				d: "M16.5,5H3.5a.5.5,0,0,0-.5.5v12A1.5,1.5,0,0,0,4.5,19h11A1.5,1.5,0,0,0,17,17.5V5.5A.5.5,0,0,0,16.5,5ZM6.75,15.5a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Zm4,0a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Zm4,0a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Z"
			}));
			t.b = d
		},
		"./src/reddit/icons/svgs/Undo/index.m.less": function(e, t, n) {
			e.exports = {
				undo: "_2sBykNOXv7XBQtHHHAB1JB"
			}
		},
		"./src/reddit/icons/svgs/Undo/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Undo/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(a.a.undo, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M10,2.375H6.726L8.4.98,7.6.02l-3,2.5a.625.625,0,0,0,0,.96l3,2.5.8-.96L6.726,3.625H10A6.375,6.375,0,1,1,3.625,10H2.375A7.625,7.625,0,1,0,10,2.375ZM5.976,3,6,2.98v.04Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/User/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("path", {
				d: "M12,11 C15.309,11 18,13.691 18,17 C18,17.553 17.552,18 17,18 L3,18 C2.448,18 2,17.553 2,17 C2,13.691 4.691,11 8,11 L12,11 Z M10,9.7334 C7.868,9.7334 6.133,7.9994 6.133,5.8664 L6.133,4.8664 C6.133,2.7344 7.868,1.0004 10,1.0004 C12.132,1.0004 13.867,2.7344 13.867,4.8664 L13.867,5.8664 C13.867,7.9994 12.132,9.7334 10,9.7334 Z"
			}))
		},
		"./src/reddit/layout/row/Inline/index.m.less": function(e, t, n) {
			e.exports = {
				inlineRow: "XZK-LTFT5CgGo9MvPQQsy"
			}
		},
		"./src/reddit/layout/row/Inline/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/layout/row/Inline/index.m.less"),
				o = n.n(r);
			t.a = s.a.div("inlineRow", o.a)
		},
		"./src/reddit/layout/row/InlineButton/index.m.less": function(e, t, n) {
			e.exports = {
				inlineButton: "_10K5i7NW6qcm-UoCtpB3aK"
			}
		},
		"./src/reddit/layout/row/InlineButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/layout/row/InlineButton/index.m.less"),
				o = n.n(r);
			t.a = s.a.button("inlineButton", o.a)
		},
		"./src/reddit/layout/row/RightAlign/index.m.less": function(e, t, n) {
			e.exports = {
				rightAligned: "_1sEFSGIUpFtX1hzGDyWJpr"
			}
		},
		"./src/reddit/layout/row/RightAlign/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/layout/row/RightAlign/index.m.less"),
				o = n.n(r);
			t.a = s.a.div("rightAligned", o.a)
		},
		"./src/reddit/layout/twoCol/ExpandLeft/index.m.less": function(e, t, n) {
			e.exports = {
				left: "_5gAwSCo7K8G413IoE78Ml",
				right: "_2ghjBMFIsORwdO3oh2Kq6g",
				exapndLeftContainer: "_1zTJo0Ndih4fp__5DjbClN"
			}
		},
		"./src/reddit/layout/twoCol/ExpandLeft/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/warnOnChildrenCount/index.tsx"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/layout/twoCol/ExpandLeft/index.m.less"),
				d = n.n(a);
			t.a = Object(o.a)(e => r.a.createElement("div", {
				className: Object(i.a)(d.a.exapndLeftContainer, e.className)
			}, r.a.createElement("div", {
				className: d.a.left
			}, Array.isArray(e.children) && e.children[0]), r.a.createElement("div", {
				className: d.a.right,
				style: {
					flexBasis: e.widthRight
				}
			}, Array.isArray(e.children) && e.children[1])), 2)
		},
		"./src/reddit/layout/twoCol/ExpandRight/index.m.less": function(e, t, n) {
			e.exports = {
				left: "_3YRHtGWABKh4OVO3s5gJwt",
				right: "_1IPWlMFPB_zPPajVPKk5Dy",
				expandRightContainer: "_2CUZHyZpRYmdvLE9tOI-2L"
			}
		},
		"./src/reddit/layout/twoCol/ExpandRight/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/warnOnChildrenCount/index.tsx"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/layout/twoCol/ExpandRight/index.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = Object(o.a)(e => {
				const {
					className: t,
					children: n,
					heightLeft: s,
					widthLeft: o,
					gutter: a,
					...l
				} = e;
				return r.a.createElement("div", c({
					className: Object(i.a)(d.a.expandRightContainer, t)
				}, l), r.a.createElement("div", {
					className: d.a.left,
					style: {
						flexBasis: o,
						height: s,
						marginRight: a
					}
				}, Array.isArray(n) && n[0]), r.a.createElement("div", {
					className: d.a.right
				}, Array.isArray(n) && n[1]))
			}, 2)
		},
		"./src/reddit/models/ApiRequestState/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			var s, r = n("./node_modules/uuid/dist/esm-browser/v4.js");
			! function(e) {
				e[e.Pending = 0] = "Pending", e[e.Complete = 1] = "Complete", e[e.Failed = 2] = "Failed"
			}(s || (s = {}));
			const o = () => Object(r.a)()
		},
		"./src/reddit/models/Badge/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r, o, i = n("./src/config.ts");

			function a(e) {
				return "userId" in e
			}

			function d(e) {
				return !(!e.extra || !e.extra.membership) && !!e.extra.membership.included
			}

			function c(e, t, n) {
				const s = n.media[0],
					r = Object.keys(s);
				if (s["0x0"]) return s["0x0"];
				let o = {
					width: 1 / 0,
					height: 1 / 0,
					url: ""
				};
				if (r.forEach(n => {
						const r = s[n],
							[i, a] = n.split("x").map(e => parseInt(e));
						(i < o.width && i >= e || a < o.height && a >= t) && (o = {
							height: a,
							width: i,
							url: r
						})
					}), !o.url && r.length) {
					const e = Object.keys(s)[0],
						t = s[e],
						[n, r] = e.split("x").map(e => parseInt(e));
					o = {
						height: r,
						width: n,
						url: t
					}
				}
				return o.url
			}

			function l(e) {
				return e.startsWith("https") ? e : `${i.a.assetPath}/${e}`
			}

			function u(e, t, n) {
				const s = c(e, t, n),
					r = c(2 * e, 2 * t, n);
				return {
					url: l(s),
					url2x: l(r)
				}
			}! function(e) {
				e.First = "p1", e.Second = "p2"
			}(s || (s = {})),
			function(e) {
				e.ActivityTab = "activityTab", e.ChatTab = "chatTab", e.MessageTab = "messageTab", e.ChatHasNewMessages = "chatHasNewMessages", e.ChatUnreadMessages = "chatUnreadMessages", e.ChatV2UnreadMessages = "chatV2UnreadMessages"
			}(r || (r = {})),
			function(e) {
				e.Numbered = "NUMBERED", e.Filled = "FILLED"
			}(o || (o = {}))
		},
		"./src/reddit/models/Badge/managementPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			}));
			var s, r, o = n("./src/reddit/models/Badge/index.ts");
			! function(e) {
				e.Loyalty = "loyalty", e.Achievement = "achievement", e.Cosmetic = "cosmetic"
			}(s || (s = {})),
			function(e) {
				e.Gallery = "gallery", e.MyBadges = "my-badges"
			}(r || (r = {}));
			const i = {
					[s.Loyalty]: o.a.First,
					[s.Achievement]: o.a.Second,
					[s.Cosmetic]: void 0
				},
				a = e => e === o.a.First ? s.Loyalty : e === o.a.Second ? s.Achievement : s.Cosmetic
		},
		"./src/reddit/models/CommunityChat/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.SubredditPostChannel = "SubredditPostChannel", e.SubredditChatChannel = "SubredditChatChannel"
				}(s || (s = {}))
		},
		"./src/reddit/models/ContentGate.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.CustomFeedDoesNotExist = "CustomFeedDoesNotExist", e.GoldSubreddit = "GoldSubreddit", e.Nsfw = "Nsfw", e.NsfwCustomFeed = "NsfwCustomFeed", e.PrivateSubreddit = "PrivateSubreddit", e.ProfileDoesNotExist = "ProfileDoesNotExist", e.ProfileDeleted = "ProfileDeleted", e.ProfileSuspended = "ProfileSuspended", e.ProfileBlockedForLegalReason = "ProfileBlockedForLegalReason", e.QuarantinedSubreddit = "QuarantinedSubreddit", e.GatedSubreddit = "GatedSubreddit", e.SubredditBanned = "SubredditBanned", e.SubredditBlockedForLegalReason = "SubredditBlockedForLegalReason", e.SubredditDoesNotExist = "SubredditDoesNotExist", e.PostBlockedForLegalReason = "PostBlockedForLegalReason"
				}(s || (s = {}))
		},
		"./src/reddit/models/Duplicates/index.ts": function(e, t, n) {
			"use strict";

			function s(e, t) {
				return `${e}-sort[${t.sort}]-crossposts_only[${t.crossposts_only}]`
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/reddit/models/Emoji/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			}));
			const s = 24,
				r = 64e3,
				o = 128,
				i = 128,
				a = (e, t, n, s) => ({
					name: e,
					url: t,
					subredditId: n,
					...s
				})
		},
		"./src/reddit/models/ExternalAccount/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Twitter = "twitter"
				}(s || (s = {}))
		},
		"./src/reddit/models/HatefulContentFilters/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Off = "OFF", e.Lenient = "LENIENT", e.Moderate = "MODERATE", e.Strict = "STRICT"
				}(s || (s = {}))
		},
		"./src/reddit/models/ModQueueTrigger/index.ts": function(e, t, n) {
			"use strict";
			var s, r;

			function o(e, t) {
				var n;
				return null === (n = e.modQueueTriggers) || void 0 === n ? void 0 : n.find(e => e.type === t)
			}
			n.d(t, "b", (function() {
					return s
				})), n.d(t, "a", (function() {
					return r
				})), n.d(t, "c", (function() {
					return o
				})),
				function(e) {
					e.USER_REPORTS = "USER_REPORTS", e.AUTOMOD = "AUTOMOD", e.MOD = "MOD", e.ADMIN = "ADMIN", e.SHADOWBANNED_SUBMITTER = "SHADOWBANNED_SUBMITTER", e.HATEFUL_CONTENT = "HATEFUL_CONTENT", e.CROWD_CONTROL = "CROWD_CONTROL", e.BAN_EVASION = "BAN_EVASION"
				}(s || (s = {})),
				function(e) {
					e.LOW = "LOW", e.HIGH = "HIGH"
				}(r || (r = {}))
		},
		"./src/reddit/models/NotificationInbox/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return d
			}));
			var s, r, o, i, a = n("./src/reddit/models/FeedElement/index.ts");

			function d(e) {
				return e.__typename === a.a.InboxNotificationCollection
			}! function(e) {
				e.AwardReceived = "AWARD_RECEIVED", e.CakeDay = "CAKE_DAY", e.ChatMessage = "CHAT_MESSAGE", e.ChatRequest = "CHAT_REQUEST", e.ChatAcceptInvite = "CHAT_ACCEPT_INVITE", e.CommentFollow = "COMMENT_FOLLOW", e.CommentReply = "COMMENT_REPLY", e.HFNSubredditInterestingPost = "SUBREDDIT_UPDATES_INTERESTING_POST", e.LifecyclePostSuggestions = "LIFECYCLE_POST_SUGGESTIONS", e.ModeratedSrViralCommentPost = "MODERATED_SR_VIRAL_COMMENT_POST", e.OneOff = "ONE_OFF", e.PostFollow = "POST_FOLLOW", e.PostReply = "POST_REPLY", e.PrivateMessage = "PRIVATE_MESSAGE", e.RedditLore = "REDDIT_LORE", e.SubredditRecommendation = "SUBREDDIT_RECOMMENDATION", e.TalkLive = "TALK_LIVE", e.ThreadReplies = "THREAD_REPLIES", e.TopLevelComment = "TOP_LEVEL_COMMENT", e.UpvoteComment = "UPVOTE_COMMENT", e.UpvotePost = "UPVOTE_POST", e.UsernameMention = "USERNAME_MENTION", e.UserNewFollower = "USER_NEW_FOLLOWER"
			}(s || (s = {})),
			function(e) {
				e.Award = "AWARD", e.Bell = "BELL", e.Chat = "CHAT", e.Comment = "COMMENT", e.Heart = "HEART", e.Live = "LIVE", e.Lore = "LORE", e.NotifyAll = "NOTIFY_ALL", e.Redditor = "REDDITOR", e.Reply = "REPLY", e.SortLive = "SORT_LIVE", e.SortRising = "SORT_RISING", e.SortTop = "SORT_TOP", e.Trophy = "TROPHY", e.Upvote = "UPVOTE"
			}(r || (r = {})),
			function(e) {
				e.CopyrightTakedown = "COPYRIGHT_TAKEDOWN", e.ContentTakedown = " CONTENT_TAKEDOWN", e.Author = "AUTHOR", e.Moderator = "MODERATOR", e.CommunityOps = "COMMUNITY_OPS", e.AntiEvilOps = "ANTI_EVIL_OPS", e.Reddit = "REDDIT", e.Deleted = "DELETED", e.AutomodFiltered = "AUTOMOD_FILTERED"
			}(o || (o = {})),
			function(e) {
				e.InboxNotification = "InboxNotification", e.InboxNotificationContext = "InboxNotificationContext", e.NotificationIcon = "NotificationIcon", e.AwardReceivedInboxNotificationContext = "AwardReceivedInboxNotificationContext", e.BasicInboxNotificationContext = "BasicInboxNotificationContext", e.CommentInboxNotificationContext = "CommentInboxNotificationContext", e.PostInboxNotificationContext = "PostInboxNotificationContext", e.PostSubredditInboxNotificationContext = "PostSubredditInboxNotificationContext", e.SubredditInboxNotificationContext = "SubredditInboxNotificationContext"
			}(i || (i = {}))
		},
		"./src/reddit/models/NotificationSettingsLayout/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Email = "EMAIL", e.Push = "PUSH", e.CommunityAlerts = "COMMUNITY_ALERTS", e.ModCommunityAlerts = "MOD_COMMUNITY_ALERTS"
				}(s || (s = {}))
		},
		"./src/reddit/models/Option/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			const s = e => !e.id,
				r = e => !!e.id,
				o = (e, t) => s(e) && s(t) ? e.displayText.toLowerCase().trim() === t.displayText.toLowerCase().trim() : !(!r(e) || !r(t)) && e.id === t.id
		},
		"./src/reddit/models/RemovalReason/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "h", (function() {
				return u
			}));
			var s = n("./src/reddit/helpers/isPost.ts");
			const r = 50,
				o = 50,
				i = 1e4,
				a = 100;
			var d, c;
			! function(e) {
				e.Private = "private", e.PrivateExposed = "private_exposed", e.Public = "public", e.PublicAsSubreddit = "public_as_subreddit"
			}(d || (d = {})),
			function(e) {
				e.Bulk = "bulk", e.Comment = "comment", e.Post = "link"
			}(c || (c = {}));
			const l = e => 1 === e.length ? Object(s.a)(e[0]) ? c.Post : c.Comment : c.Bulk,
				u = (e, t) => {
					return {
						[t === c.Bulk ? "item_ids" : "item_id"]: e.itemId,
						message: e.message,
						title: e.title,
						type: e.type,
						lock_comment: e.isLocked
					}
				}
		},
		"./src/reddit/models/ScheduledPost/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "s", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "r", (function() {
				return g
			})), n.d(t, "l", (function() {
				return v
			})), n.d(t, "k", (function() {
				return x
			})), n.d(t, "i", (function() {
				return E
			})), n.d(t, "j", (function() {
				return O
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "n", (function() {
				return A
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "m", (function() {
				return j
			})), n.d(t, "q", (function() {
				return I
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/assertNever.ts"),
				r = n("./src/reddit/models/GqlTopLevelField.ts"),
				o = n("./src/reddit/models/User/index.ts");
			const i = "scheduledposts";
			var a, d, c;
			! function(e) {
				e.LINK = "LINK", e.POLL = "POLL", e.SELF = "SELF"
			}(a || (a = {})),
			function(e) {
				e.RTJSON = "RTJSON", e.TEXT = "TEXT"
			}(d || (d = {})),
			function(e) {
				e.CREATED = "CREATED", e.PROCESSING = "PROCESSING", e.FAILED = "FAILED", e.SUCCESS = "SUCCESS"
			}(c || (c = {}));
			const l = e => {
					return new Set(["links", "text", "polls"]).has(e)
				},
				u = e => e.__typename === o.c.AvailableRedditor,
				m = e => e.__typename === r.a.Subreddit;
			var p, b, f, h;
			! function(e) {
				e.standalonePosts = "standalonePosts", e.recurringPosts = "recurringPosts"
			}(p || (p = {})),
			function(e) {
				e.MONDAY = "MONDAY", e.TUESDAY = "TUESDAY", e.WEDNESDAY = "WEDNESDAY", e.THURSDAY = "THURSDAY", e.FRIDAY = "FRIDAY", e.SATURDAY = "SATURDAY", e.SUNDAY = "SUNDAY"
			}(b || (b = {})),
			function(e) {
				e[e.MONDAY = 0] = "MONDAY", e[e.TUESDAY = 1] = "TUESDAY", e[e.WEDNESDAY = 2] = "WEDNESDAY", e[e.THURSDAY = 3] = "THURSDAY", e[e.FRIDAY = 4] = "FRIDAY", e[e.SATURDAY = 5] = "SATURDAY", e[e.SUNDAY = 6] = "SUNDAY"
			}(f || (f = {})),
			function(e) {
				e[e.SUNDAY = 0] = "SUNDAY", e[e.MONDAY = 1] = "MONDAY", e[e.TUESDAY = 2] = "TUESDAY", e[e.WEDNESDAY = 3] = "WEDNESDAY", e[e.THURSDAY = 4] = "THURSDAY", e[e.FRIDAY = 5] = "FRIDAY", e[e.SATURDAY = 6] = "SATURDAY"
			}(h || (h = {}));
			const g = e => b[h[e]],
				v = e => h[b[e]],
				x = e => f[b[e]],
				E = e => b[f[e]],
				O = e => h[f[e]];
			var C;
			! function(e) {
				e.Hourly = "HOURLY", e.Daily = "DAILY", e.Weekly = "WEEKLY", e.Monthly = "MONTHLY"
			}(C || (C = {}));
			const A = e => {
					switch (e) {
						case C.Hourly:
						case C.Daily:
						case C.Weekly:
						case C.Monthly:
							return !0
					}
					return !1
				},
				y = "custom",
				j = e => {
					switch (e) {
						case "isNsfw":
							return "mark_as_nsfw";
						case "isOriginalContent":
							return "mark_as_oc";
						case "isSticky":
							return "sticky";
						case "isModDistinguished":
							return "mod_distinguish";
						case "isSpoiler":
							return "mark_as_spoiler";
						case "isContestMode":
							return "mark_as_contest_mode";
						case "isPostAsMetaMod":
							return "post_as_meta_mod";
						default:
							return Object(s.a)(e)
					}
				},
				I = e => "frequency" in e && !!e.frequency
		},
		"./src/reddit/models/SubredditModeration/ModerationLog/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = (e, t, n) => `${e}-${((e,t)=>t||e||"1")(n,t)}`
		},
		"./src/reddit/models/SubredditWikiPage/index.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "b", (function() {
					return s
				})), n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.MayNotView = "MAY_NOT_VIEW", e.PageNotCreated = "PAGE_NOT_CREATED", e.PageNotFound = "PAGE_NOT_FOUND", e.RestrictedPage = "RESTRICTED_PAGE", e.Unknown = "UNKNOWN", e.Valid = "VALID", e.WikiDisabled = "WIKI_DISABLED"
				}(s || (s = {})),
				function(e) {
					e.Inherit = "INHERIT_SUBREDDIT_PERMS", e.Contributors = "CONTRIBUTORS", e.Mods = "MODS"
				}(r || (r = {}))
		},
		"./src/reddit/models/Tags/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			}));
			const s = 25,
				r = 64;
			var o;
			! function(e) {
				e.EVENT = "EVENT", e.COLLECTION = "COLLECTION", e.CLASSIFICATION = "CLASSIFICATION", e.POST_CLASSIFICATION = "POST_CLASSIFICATION", e.SUBREDDIT_CLASSIFICATION = "SUBREDDIT_CLASSIFICATION", e.COMMENT_CLASSIFICATION = "COMMENT_CLASSIFICATION"
			}(o || (o = {}));
			const i = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return {
						id: e.id,
						displayText: e.text,
						selected: t
					}
				},
				a = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return i(e.tag, t)
				};
			var d;
			! function(e) {
				e.TAGGED = "TAGGED", e.NONE = "NONE"
			}(d || (d = {}))
		},
		"./src/reddit/models/TrafficStats/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			}));
			const s = 97,
				r = 57,
				o = 12;
			var i;
			! function(e) {
				e.TOTAL = "total", e.DESKTOP = "desktop", e.OLD_REDDIT = "oldReddit", e.IOS = "apps", e.ANDROID = "apps", e.MOBILE_WEB = "mWeb"
			}(i || (i = {}))
		},
		"./src/reddit/models/inboxBanner/index.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "b", (function() {
					return s
				})), n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.IOS = "IOS_APP", e.ANDROID = "ANDROID_APP", e.DESKTOP = "DESKTOP_APP"
				}(s || (s = {})),
				function(e) {
					e.GOTO = "goto", e.DISMISS = "dismiss"
				}(r || (r = {}))
		},
		"./src/reddit/pages/ErrorPages/index.m.less": function(e, t, n) {
			e.exports = {
				primaryRouterLink: "WPSTJCepGLEWZl2fETrUM",
				container: "_3pfk0xbr5atzL7KT8pXEZG",
				title: "_3uo9iClHghoc_hoxzdgipi"
			}
		},
		"./src/reddit/pages/ErrorPages/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/reddit/controls/Button/index.tsx"),
				a = n("./src/reddit/pages/ErrorPages/index.m.less"),
				d = n.n(a);
			const c = e => {
					let {
						shouldReloadHome: t
					} = e;
					return t ? o.a.createElement(i.a, {
						kind: i.b.ExternalLink,
						priority: i.c.Primary,
						className: d.a.primaryRouterLink,
						href: "/"
					}, s.fbt._("Go Home", null, {
						hk: "3E9E1g"
					})) : o.a.createElement(i.a, {
						kind: i.b.InternalLink,
						priority: i.c.Primary,
						className: d.a.primaryRouterLink,
						to: "/"
					}, s.fbt._("Go Home", null, {
						hk: "3E9E1g"
					}))
				},
				l = e => {
					let {
						message: t,
						shouldReloadHome: n
					} = e;
					return o.a.createElement("div", {
						className: d.a.container
					}, o.a.createElement("h3", {
						className: d.a.title
					}, t || s.fbt._("Sorry, there doesn't seem to be anything here.", null, {
						hk: "3VvHek"
					})), o.a.createElement(c, {
						shouldReloadHome: n
					}))
				},
				u = e => {
					let {
						message: t,
						shouldReloadHome: n
					} = e;
					return o.a.createElement("div", {
						className: d.a.container
					}, o.a.createElement("h3", {
						className: d.a.title
					}, t || s.fbt._("Sorry, You do not have permission to view this page.", null, {
						hk: "4lRbHD"
					})), o.a.createElement(c, {
						shouldReloadHome: n
					}))
				}
		},
		"./src/reddit/pages/ModHub/Header.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_3moWGMnbR8K4S0yEul07nr",
				titleFontH2: "_2oI68wVKNMPkDrFs5iv-mT",
				titleFontH3: "_2SjfolwDVVvPkTR19n53-N",
				titleFontH4: "_2PCswqdAkej43QrI3i2XD6",
				titleFontH5: "_2ClzPN9iMLeouYjBczMuak",
				titleFontH6: "-Ys2BgGuQrEY2uMl3yymz",
				metadataFont: "_13D6uHC3HmU2n303ICkc2Z",
				flairFont: "jd22g-ATlzm80vQJWeapy",
				labelsFont: "_1UxIO379jfzGXKK-UTji0l",
				actionFont: "_33izYXQ9DA6aVnhOiSApGv",
				smallButtonFont: "_3gTmhpwBqqacn2Fbh1nFPi",
				largeButtonFont: "_18NraFj-4C_LqHvfoVPar1",
				strongTextFont: "_3tRumE3gvvS_0BYlnDtcIA",
				tabFont: "_1DLPo8qhiBT00GYX1ng3ad",
				buttonFontXS: "_1jy5yDpKOT5-Cv2QAMnE8Z",
				buttonFontXs: "_1jy5yDpKOT5-Cv2QAMnE8Z",
				buttonFontS: "_3DmXGTGm5YD5IApa9MyBNq",
				buttonFontM: "_32Yvll-0lWSj_SZKU0TKRR",
				buttonFontL: "_1wDiG7XcGSvunA559KlfGG",
				buttonFontXL: "xpxpmGAZ5HYQvDSsMNvp8",
				buttonFontXl: "xpxpmGAZ5HYQvDSsMNvp8",
				bodyFontH1: "_1ygLn4-Vtd31oQv6zylo5z",
				bodyFontH2: "_1btDxE6K9AP_wtfakdg11l",
				bodyFontH3: "cMjXJNdI0iac3nSCHtBrq",
				bodyFontH4: "_3ZsC5lxE3Dnw9-duolQiN3",
				bodyFontH5: "_3gWD0dGAav6VxMQZ2iY4qc",
				bodyFontH6: "_2yKCC1d-C1qheMkCr5CedW",
				bodyFontH6Small: "_1AyCUR1VQn-opitbpGpNcf",
				bodyFont: "_1RI3wkzuynRc_Bqno__Uom",
				bodyFontSmall: "_2MlCobLFb0alel2wzuIFVK",
				bodyFontMono: "_3RdMKJzgzPT9lgXHEf0XZB",
				landingPageTitleFontH1: "KVO5ZZIscMWGahfHIsr-o",
				landingPageTitleFontH2: "_1Z7_zVV5u4BYuO1gRsLx90",
				landingPageTitleFontH3: "_2yCXZ7SWFT2-XNs-FGlvBs",
				header: "_3u9on6H92JkZNRumczPd67",
				navColor: "_1DRfX_EIQDZ7qPhVmfJlcY",
				subredditLink: "_3EIUrhztcaaHcqMILEsnBq",
				subredditIcon: "_3uA1he5X3WeG6mpoUWdcXy"
			}
		},
		"./src/reddit/pages/ModHub/Header.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/pages/ModHub/Header.m.less"),
				i = n.n(o),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/components/SubredditIcon/index.tsx"),
				c = n("./src/reddit/controls/InternalLink/index.tsx");
			t.a = e => {
				var t, n;
				return r.a.createElement("div", {
					className: Object(a.a)(e.isInShredditModNavExperiment && "bg-neutral-background border-b border-solid border-neutral-border-weak", i.a.header, {
						[i.a.navColor]: !e.isInShredditModNavExperiment
					})
				}, r.a.createElement(d.b, {
					className: i.a.subredditIcon,
					subredditOrProfile: e.subredditOrProfile
				}), r.a.createElement(c.default, {
					className: i.a.subredditLink,
					to: (null === (t = e.subredditOrProfile) || void 0 === t ? void 0 : t.url) || "",
					onClick: e.onClick
				}, null === (n = e.subredditOrProfile) || void 0 === n ? void 0 : n.displayText), e.pageName && `/ ${e.pageName}`)
			}
		},
		"./src/reddit/pages/ModHub/index.m.less": function(e, t, n) {
			e.exports = {
				contentWrapper: "_2Z3MiFrgj2rofHXrH1YVKn",
				isModerator: "_1haViLcso0RRPvkDGZgDLJ",
				BackgroundContainer: "_1XAvW8OS9HO-SVS7BDAIGe",
				backgroundContainer: "_1XAvW8OS9HO-SVS7BDAIGe",
				background: "_2BaTQr1trjn0K2oh9bPA6j",
				Body: "_3hAOyl8ThaUgCBqiNvN_sN",
				body: "_3hAOyl8ThaUgCBqiNvN_sN"
			}
		},
		"./src/reddit/pages/ModHub/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./node_modules/lodash/fromPairs.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/extractQueryParams/index.ts"),
				u = n("./src/lib/lessComponent.tsx"),
				m = n("./src/reddit/components/ContentGate/index.tsx"),
				p = n("./node_modules/fbt/lib/FbtPublic.js"),
				b = n("./src/lib/assertNever.ts"),
				f = n("./src/lib/constants/index.ts");
			const h = e => {
				switch (e) {
					case f.mc.Awards:
						return p.fbt._("Awards", null, {
							hk: "EiSXW"
						});
					case f.mc.Banned:
						return p.fbt._("Banned", null, {
							hk: "35R8OD"
						});
					case f.mc.Muted:
						return p.fbt._("Muted", null, {
							hk: "f2nJu"
						});
					case f.mc.ContentControls:
						return p.fbt._("Content controls", null, {
							hk: "H1yxv"
						});
					case f.mc.Contributors:
						return p.fbt._("Approved", null, {
							hk: "180AS9"
						});
					case f.mc.Moderators:
						return p.fbt._("Moderators", null, {
							hk: "4qdV8t"
						});
					case f.mc.SubredditRules:
						return p.fbt._("Rules", null, {
							hk: "2SNdd8"
						});
					case f.mc.Removal:
						return p.fbt._("Removal reasons", null, {
							hk: "1smDUM"
						});
					case f.mc.Modqueue:
						return p.fbt._("Mod queue", null, {
							hk: "yEBGb"
						});
					case f.mc.Reports:
						return p.fbt._("Reports", null, {
							hk: "4Ctcb1"
						});
					case f.mc.Spam:
						return p.fbt._("Spam", null, {
							hk: "1D73Vp"
						});
					case f.mc.Unmoderated:
						return p.fbt._("Unmoderated", null, {
							hk: "3TOaeD"
						});
					case f.mc.Edited:
						return p.fbt._("Edited", null, {
							hk: "OLtvW"
						});
					case f.mc.Modlog:
						return p.fbt._("Mod log", null, {
							hk: "3uy7LL"
						});
					case f.mc.Flair:
						return p.fbt._("Grant user flair", null, {
							hk: "2B8sTJ"
						});
					case f.mc.CommunitySettings:
						return p.fbt._("Community settings", null, {
							hk: "XbHzi"
						});
					case f.mc.Emojis:
						return p.fbt._("Emojis", null, {
							hk: "3mPnxe"
						});
					case f.mc.UserFlair:
						return p.fbt._("User flair", null, {
							hk: "3kleCv"
						});
					case f.mc.PostFlair:
						return p.fbt._("Post flair", null, {
							hk: "2Y1FKb"
						});
					case f.mc.Badges:
						return p.fbt._("Badges", null, {
							hk: "3vM0lt"
						});
					case f.mc.Emotes:
						return p.fbt._("Emotes", null, {
							hk: "2Ivxxq"
						});
					case f.mc.Wiki:
					case f.mc.WikiContributors:
					case f.mc.WikiBanned:
						return p.fbt._("Wiki pages", null, {
							hk: "WdSXv"
						});
					case f.mc.Traffic:
						return p.fbt._("Traffic stats", null, {
							hk: "3mcw71"
						});
					case f.mc.ScheduledPostContent:
					case f.mc.SubredditContent:
						return p.fbt._("Scheduled posts", null, {
							hk: "19KZjq"
						});
					case f.mc.EventPostContent:
						return p.fbt._("Event posts", null, {
							hk: "3ejc42"
						});
					case f.mc.Predictions:
						return p.fbt._("Predictions", null, {
							hk: "1yASCC"
						});
					case f.mc.TalkHosts:
						return p.fbt._("Talk hosts", null, {
							hk: "3BAjFt"
						});
					default:
						return Object(b.a)(e)
				}
			};
			var g = n("./src/lib/sentry/index.ts"),
				v = n("./node_modules/react-router-redux/es/index.js"),
				x = n("./src/reddit/helpers/trackers/modHub.ts"),
				E = n("./src/reddit/hooks/usePageLayer.ts"),
				O = n("./src/reddit/hooks/useTracking.ts"),
				C = n("./src/reddit/selectors/experiments/devPlatform.ts"),
				A = n("./src/reddit/actions/postGuidance/index.ts"),
				y = n("./src/reddit/selectors/experiments/cnc/index.ts"),
				j = n("./src/reddit/selectors/postGuidance.ts"),
				I = n("./src/reddit/components/ModHub/NewModNav/index.m.less"),
				k = n.n(I);

			function _() {
				return (_ = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const {
				fbt: S
			} = n("./node_modules/fbt/lib/FbtPublic.js"), w = e => ({
				isAccessEnabled: !!(null == e ? void 0 : e.access),
				isAllAllowed: !!(null == e ? void 0 : e.all),
				isChatConfigEditingAllowed: !!(null == e ? void 0 : e.chatConfig),
				isChatOperator: !!(null == e ? void 0 : e.chatOperator),
				isConfigEditingAllowed: !!(null == e ? void 0 : e.config),
				isFlairEditingAllowed: !!(null == e ? void 0 : e.flair),
				isMailEditingAllowed: !!(null == e ? void 0 : e.mail),
				isPostEditingAllowed: !!(null == e ? void 0 : e.posts),
				isWikiEditingAllowed: !!(null == e ? void 0 : e.wiki),
				isChannelsEditingAllowed: !1,
				isCommunityChatEditingAllowed: !1
			}), T = e => {
				e.stopPropagation(), e.preventDefault()
			};
			var P = e => {
					let {
						subredditName: t,
						moderatorPermissions: s,
						subreddit: r
					} = e;
					const d = Object(o.useRef)(),
						l = Object(a.d)(),
						u = Object(O.a)();
					l(Object(A.a)());
					const m = Object(a.e)(C.a),
						p = Object(a.e)(y.b),
						b = Object(a.e)(e => Object(j.b)(e, {
							subredditId: r.id
						})) && p,
						[f, h] = Object(o.useState)("ready"),
						I = Object(E.a)();
					return Object(o.useEffect)(() => {
						"ready" === f && async function() {
							try {
								h("importing"), await Promise.all([n.e("vendors~mod-nav~shreddit-player"), n.e("mod-nav")]).then(n.bind(null, "./node_modules/@reddit/shreddit.components.mod-nav/dist/index.js")), h("done")
							} catch (e) {
								console.error("Error importing mod-nav", e), h("error"), g.c.withScope(n => {
									n.setExtra("info", {
										subredditName: t
									}), g.c.captureException(e)
								})
							}
						}()
					}, [f, t]), Object(o.useEffect)(() => {
						if ("done" !== f) return;
						const e = async e => {
							e.stopPropagation();
							const {
								details: t
							} = (null == e ? void 0 : e.detail) || {};
							t && await u(Object(x.d)({
								noun: t.noun,
								source: t.source,
								action: t.action,
								paneName: t.action_info.pane_name
							}))
						}, {
							current: t
						} = d;
						return null == t || t.addEventListener("track-event", e), null == t || t.addEventListener("faceplate-track", e), () => {
							null == t || t.removeEventListener("track-event", e), null == t || t.removeEventListener("faceplate-track", e)
						}
					}, [f, d, u]), Object(o.useEffect)(() => {
						if ("done" !== f) return;
						const e = e => {
								if ((null == e ? void 0 : e.detail) && "/" === (null == e ? void 0 : e.detail.charAt(0)) && !(null == e ? void 0 : e.detail.includes("insights"))) e.stopPropagation(), e.preventDefault(), l(Object(v.b)(null == e ? void 0 : e.detail));
								else {
									const t = !((null == e ? void 0 : e.detail) && (null == e ? void 0 : e.detail.includes("insights")));
									window.open(null == e ? void 0 : e.detail, t ? "_blank" : "_self")
								}
							},
							{
								current: t
							} = d;
						return null == t || t.addEventListener("mod-nav-click", e), null == t || t.addEventListener("click", e), () => {
							null == t || t.removeEventListener("mod-nav-click", e), null == t || t.removeEventListener("click", e)
						}
					}, [f, d, l]), "ready" === f || "importing" === f ? i.a.createElement("div", null, i.a.createElement("div", {
						className: "fixed left-0 w-[280px] overscroll-none mt-sm h-full flex items-center justify-center ease inset-0 text-white "
					}, i.a.createElement("svg", {
						"aria-hidden": "true",
						className: "w-3xl h-3xl animate-spin",
						fill: "none",
						viewBox: "0 0 120 120"
					}, i.a.createElement("circle", {
						className: "opacity-25",
						cx: "60",
						cy: "60",
						r: "54",
						stroke: "currentColor",
						strokeWidth: "8"
					}), i.a.createElement("circle", {
						className: "opacity-75",
						cx: "60",
						cy: "60",
						r: "54",
						stroke: "currentColor",
						strokeWidth: "10",
						strokeDasharray: 100,
						strokeDashoffset: 50,
						pathLength: "100"
					})))) : "error" === f ? i.a.createElement("div", null, S._("Sorry, something went wrong loading the menu. Refresh the page to try again.", null, {
						hk: "4otejm"
					})) : i.a.createElement("mod-nav", _({
						class: Object(c.a)(k.a.modNavContainer, "theme-beta pr-sm overflow-x-visible overflow-y-auto left-sidebar-min fixed left-0 w-[268px] overscroll-none mt-sm"),
						"subreddit-name": t,
						"current-url": null == I ? void 0 : I.url,
						"mod-permissions": JSON.stringify(w(s))
					}, b ? {
						"post-guidance-enabled": b
					} : {}, m ? {
						"dev-platform-enabled": m
					} : {}, r.allowPredictionsTournament ? {
						"predictions-tournament-allowed": r.allowPredictionsTournament
					} : {}, {
						ref: d,
						onClick: T
					}))
				},
				N = n("./src/reddit/components/TrackingHelper/index.tsx"),
				D = n("./src/reddit/contexts/PageLayer/index.tsx"),
				M = n("./src/reddit/helpers/canAccessModerationPage/index.ts"),
				R = n("./src/reddit/helpers/getSubredditErrorProps/index.ts"),
				L = n("./src/reddit/helpers/trackers/moderationPages.ts"),
				B = n("./src/reddit/models/ModQueue/index.ts"),
				F = n("./src/reddit/selectors/experiments/econ/index.ts"),
				U = n("./src/reddit/selectors/experiments/shredditModNav.ts"),
				H = n("./src/reddit/selectors/moderatorPermissions.ts"),
				G = n("./src/reddit/selectors/postCreations.ts"),
				Q = n("./src/reddit/selectors/profile.ts"),
				q = n("./src/reddit/selectors/subreddit.ts"),
				W = n("./src/reddit/selectors/user.ts"),
				z = n("./src/reddit/components/ModHub/Content/index.tsx"),
				V = n("./src/reddit/components/ModHub/Content/NoPermissions.tsx"),
				K = n("./src/reddit/icons/svgs/Moderate/index.tsx"),
				Y = n("./src/reddit/components/ModHub/Content/WelcomeMessage.m.less"),
				J = n.n(Y);
			const X = u.a.wrapped(K.a, "ModerateIcon", J.a),
				Z = u.a.div("ModHubWelcomeMessage", J.a);
			var $ = e => i.a.createElement(Z, null, i.a.createElement(X, null), p.fbt._("Welcome to the mod tools for {subredditName}", [p.fbt._param("subredditName", e.subredditDisplayText)], {
					hk: "7Usff"
				})),
				ee = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/config.ts")),
				te = n("./src/reddit/components/ModHub/ContentControls/FormSections/HatefulContentFilters/useHCFAdoptionCampaign.tsx"),
				ne = n("./src/reddit/contexts/NavbarExp.ts"),
				se = n("./src/reddit/featureFlags/index.ts"),
				re = n("./src/reddit/helpers/localStorage/index.ts"),
				oe = n("./src/reddit/helpers/trackers/communitySettings.ts"),
				ie = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				ae = n("./src/reddit/icons/fonts/index.tsx"),
				de = n("./src/reddit/routes/moderationPages/index.ts"),
				ce = n("./src/reddit/selectors/experiments/eventPosts.ts"),
				le = n("./src/reddit/components/StructuredStyles/Breadcrumbs/index.tsx"),
				ue = n("./src/reddit/components/ModHub/ModHubNav/index.m.less"),
				me = n.n(ue);

			function pe() {
				return (pe = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var be = e => i.a.createElement("div", pe({
					className: Object(c.a)(me.a.breadcrumb, e.className)
				}, e), i.a.createElement("button", {
					className: me.a.breadcrumbButton
				}, i.a.createElement(le.a, null), p.fbt._("Back to mod tools", null, {
					hk: "4udiKO"
				}))),
				fe = n("./src/reddit/components/ModHub/ModHubNav/NavItem.tsx"),
				he = n("./src/reddit/actions/modal.ts"),
				ge = n("./src/higherOrderComponents/asModal/index.tsx"),
				ve = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				xe = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				Ee = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				Oe = n("./src/reddit/constants/wiki.ts"),
				Ce = n("./src/reddit/controls/Button/index.tsx"),
				Ae = n("./src/reddit/controls/TextButton/index.tsx"),
				ye = n("./src/reddit/helpers/wiki/buildWikiPagesTree.ts"),
				je = n("./src/reddit/helpers/wiki/validatePageName.ts"),
				Ie = n("./src/reddit/icons/svgs/QuarantineWarning/index.tsx"),
				ke = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				_e = n("./src/reddit/controls/Dropdown/index.tsx"),
				Se = n("./src/reddit/controls/Dropdown/Row.tsx"),
				we = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				Te = n("./src/reddit/components/Wiki/CreateNewWikiPageModal/index.m.less"),
				Pe = n.n(Te);
			class Ne extends i.a.Component {
				constructor(e) {
					super(e), this.onToggleDropdown = () => {
						this.setState({
							isDropdownOpen: !this.state.isDropdownOpen
						})
					}, this.onSelectParentPage = e => {
						this.props.onSelectParentPage(e), this.onToggleDropdown()
					}, this.state = {
						isDropdownOpen: !1
					}
				}
				render() {
					const {
						pageTree: e,
						parentPageName: t
					} = this.props, {
						isDropdownOpen: n
					} = this.state, s = p.fbt._("None", null, {
						hk: "3FT0YQ"
					});
					return i.a.createElement("div", {
						className: Pe.a.dropdownContainer
					}, i.a.createElement("button", {
						className: Pe.a.dropdownTarget,
						onClick: this.onToggleDropdown
					}, i.a.createElement("div", {
						className: Pe.a.targetText
					}, t || s), i.a.createElement(we.b, null)), n && i.a.createElement(_e.a, {
						className: Pe.a.dropdown
					}, i.a.createElement(Se.b, {
						className: Pe.a.dropdownRow,
						displayText: s,
						onClick: () => this.onSelectParentPage(void 0)
					}), e.map(e => e.depth >= Oe.c ? null : Oe.f.has(e.path.split("/")[0]) ? null : i.a.createElement(Se.b, {
						className: Pe.a.dropdownRow,
						displayText: e.path,
						key: e.path,
						onClick: () => this.onSelectParentPage(e.path)
					}))))
				}
			}
			var De = Ne;
			const Me = e => {
				switch (e) {
					case je.a.InvalidPageName:
						return p.fbt._("Invalid page name", null, {
							hk: "1gQvCb"
						});
					case je.a.MaxLengthExceed:
						return p.fbt._("Name exceeds character limit", null, {
							hk: "RDoIC"
						});
					case je.a.PageAlreadyExists:
						return p.fbt._("That page already exists", null, {
							hk: "xEyyR"
						});
					case je.a.RestrictedPageName:
						return p.fbt._("Restricted page name", null, {
							hk: "Bjv5o"
						})
				}
			};
			class Re extends i.a.Component {
				constructor(e) {
					super(e), this.onChangePageName = e => {
						this.setState({
							partialPageName: e.currentTarget.value
						})
					}, this.onSelectParentPage = e => {
						this.setState({
							parentPageName: e
						})
					}, this.getNewPagePath = () => {
						let e = "";
						return this.state.parentPageName && (e += `${this.state.parentPageName}/`), (e += `${this.state.partialPageName}`).toLowerCase()
					}, this.state = {
						partialPageName: "",
						parentPageName: void 0
					}
				}
				hasError() {
					const {
						pageTree: e
					} = this.props, {
						partialPageName: t
					} = this.state;
					return Object(je.c)(t) || Object(je.b)(this.getNewPagePath(), e)
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = this.hasError();
					return i.a.createElement(xe.e, {
						className: Pe.a.modalBody
					}, i.a.createElement(xe.i, null, i.a.createElement(ke.a, null, i.a.createElement(xe.q, null, p.fbt._("Create a new wiki page", null, {
						hk: "V7Jnm"
					})), i.a.createElement(Ae.a, {
						onClick: e.toggleModal
					}, i.a.createElement(xe.b, null)))), i.a.createElement("div", {
						className: Pe.a.notice
					}, i.a.createElement(Ie.a, null), p.fbt._("Parent page and page URL cannot be edited once created", null, {
						hk: "20D6uz"
					})), i.a.createElement(xe.l, null, i.a.createElement("div", {
						className: Pe.a.sectionTitle
					}, p.fbt._("Parent page", null, {
						hk: "1FeKiT"
					})), i.a.createElement(De, {
						onSelectParentPage: this.onSelectParentPage,
						pageTree: Object(ye.b)(e.pageTree || []),
						parentPageName: t.parentPageName
					}), i.a.createElement("div", {
						className: Pe.a.sectionTitle
					}, p.fbt._("Page URL", null, {
						hk: "WL8sn"
					})), i.a.createElement(Ee.d, {
						placeholder: p.fbt._("ex: rules", null, {
							hk: "J0qH1"
						}),
						onChange: this.onChangePageName,
						value: t.partialPageName
					}), i.a.createElement(ve.a, {
						text: this.getNewPagePath(),
						maxChars: Oe.d
					}), i.a.createElement("div", {
						className: Pe.a.errorText
					}, t.partialPageName && n ? Me(n) : null)), i.a.createElement(xe.g, null, i.a.createElement(xe.a, {
						onClick: e.toggleModal
					}, p.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), i.a.createElement(Ce.n, {
						disabled: !t.partialPageName || !!n,
						className: Pe.a.primaryButton,
						to: `${e.subredditUrl}about/wiki/create/${this.getNewPagePath()}`
					}, p.fbt._("Create", null, {
						hk: "2W0PL1"
					}))))
				}
			}
			var Le = Object(ge.a)(Re),
				Be = n("./src/reddit/selectors/activeModalId.ts"),
				Fe = n("./src/reddit/selectors/subredditWiki.ts"),
				Ue = n("./node_modules/lodash/times.js"),
				He = n.n(Ue),
				Ge = n("./src/reddit/controls/InternalLink/index.tsx"),
				Qe = n("./src/reddit/components/ModHub/ModHubNav/WikiNavPanel/index.m.less"),
				qe = n.n(Qe);
			class We extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.containerRef = i.a.createRef()
				}
				componentDidMount() {
					this.scrollToActiveItemIfNeeded()
				}
				scrollToActiveItemIfNeeded() {
					const e = this.containerRef.current,
						t = e && e.getElementsByClassName(qe.a.mActive)[0];
					if (!e || !t) return;
					const n = e.getBoundingClientRect(),
						s = t.getBoundingClientRect();
					s.top >= n.top && s.bottom <= n.bottom || t.scrollIntoView()
				}
				render() {
					const {
						activePageName: e,
						baseUrl: t,
						directory: n
					} = this.props, s = Object(ye.b)(n && n.pageTree || []);
					return i.a.createElement("div", {
						ref: this.containerRef,
						className: qe.a.contentTree
					}, s.map(n => {
						const s = n.path === e;
						return i.a.createElement(Ge.default, {
							key: n.path,
							className: qe.a.pageNavLink,
							to: `${t}/${n.path}`
						}, i.a.createElement("div", {
							className: Object(c.a)(qe.a.pageNavItem, {
								[qe.a.mActive]: s,
								[qe.a.mExists]: n.isPagePresent
							})
						}, He()(n.depth, () => i.a.createElement("div", {
							className: qe.a.indentLine
						})), i.a.createElement("span", {
							className: qe.a.itemText
						}, `/${n.name}`)))
					}))
				}
			}
			const ze = Object(d.c)({
				directory: (e, t) => Object(Fe.b)(e, {
					subredditName: t.subreddit.name
				}),
				isCreateWikiPageModalOpen: e => "CreateWikiPageModal" === Object(Be.a)(e),
				isInShredditModNavExperimet: e => Object(U.a)(e, !0)
			});
			class Ve extends i.a.Component {
				constructor() {
					super(...arguments), this.onToggleCreateWikiModal = () => {
						this.props.toggleCreateWikiModal()
					}, this.sendModNavEvent = e => {
						this.props.isInShredditModNavExperimet && this.props.sendEvent(Object(x.d)({
							noun: e,
							source: "moderator",
							action: "click",
							paneName: "left_nav"
						}))
					}
				}
				render() {
					const {
						directory: e,
						isCreateWikiPageModalOpen: t,
						subreddit: n,
						toggleCreateWikiModal: s,
						pageLayer: r
					} = this.props;
					if (!r) return null;
					const {
						urlParams: o
					} = r, {
						wikiPageName: a,
						wikiSubRoute: d,
						pageName: c
					} = o;
					return i.a.createElement("div", {
						className: qe.a.wikiNavPanel
					}, i.a.createElement(Ce.l, {
						className: qe.a.primaryButton,
						onClick: this.onToggleCreateWikiModal
					}, p.fbt._("Create new page", null, {
						hk: "35WDuL"
					})), i.a.createElement(We, {
						activePageName: a,
						baseUrl: `${n.url}about/wiki`,
						directory: e
					}), i.a.createElement("div", {
						className: qe.a.footer
					}, i.a.createElement(fe.b, {
						isActive: d === Oe.m.Revisions && !a,
						label: p.fbt._("Recent wiki revisions", null, {
							hk: "278VnD"
						}),
						path: `${n.url}about/wiki/revisions`,
						onClick: () => this.sendModNavEvent("recent-wiki-revisions")
					}), i.a.createElement(fe.b, {
						isActive: c === f.mc.WikiContributors,
						label: p.fbt._("Add wiki contributors", null, {
							hk: "1XHd90"
						}),
						path: `${n.url}about/wikicontributors`,
						onClick: () => this.sendModNavEvent("add-wiki-contributors")
					}), i.a.createElement(fe.b, {
						isActive: c === f.mc.WikiBanned,
						label: p.fbt._("Ban wiki contributors", null, {
							hk: "3IVNKp"
						}),
						path: `${n.url}about/wikibanned`,
						onClick: () => this.sendModNavEvent("ban-wiki-contributors")
					}), i.a.createElement(fe.b, {
						label: p.fbt._("Wiki settings", null, {
							hk: "1Jctxf"
						}),
						path: `${n.url}about/edit?page=wikis`,
						onClick: () => this.sendModNavEvent("wiki-settings")
					})), t && i.a.createElement(Le, {
						pageTree: e && e.pageTree,
						subredditUrl: n.url,
						toggleModal: s,
						withOverlay: !0
					}))
				}
			}
			var Ke = Object(D.v)()(Object(a.b)(ze, e => ({
				toggleCreateWikiModal: () => e(Object(he.i)("CreateWikiPageModal"))
			}))(Object(N.c)(Ve)));
			const Ye = Object(d.c)({
				isBadgesAndEmotesEnabled: se.d.spCustomBadgesAndEmotes,
				isContentTagEnabled: (e, t) => !!e.subreddits.survey[t.subreddit.id],
				isEligibleForScheduledPosts: se.d.scheduledPosts,
				isTournamentsEnabled: (e, t) => {
					let {
						subreddit: n
					} = t;
					return Object(q.S)(e, {
						subredditId: n.id
					})
				},
				isTalkHostsExperimentEnabled: F.r,
				isEventPostUiHidden: ce.a,
				isDevplatformEnabled: C.a
			});
			class Je extends i.a.Component {
				constructor(e, t) {
					super(e, t), this.trackClick = e => this.props.sendEvent(x.c(e)), this.trackCommunitySettingsNavItemClick = e => this.props.sendEvent(Object(oe.b)(e)), this.onClickAwards = () => this.trackClick("awards"), this.onClickModQueue = () => this.trackClick("mod_queue"), this.onClickReports = () => this.trackClick("reports"), this.onClickSpam = () => this.trackClick("spam"), this.onClickEdited = () => this.trackClick("edited"), this.onClickUnmoderated = () => this.trackClick("unmoderated"), this.onClickBannedUsers = () => this.trackClick("ban_users"), this.onClickMutedUsers = () => this.trackClick("mute_users"), this.onClickApprovedSubmitters = () => this.trackClick("approved_submitters"), this.onClickApprovedTalkHosts = () => this.trackClick("talk_hosts"), this.onClickEmojis = () => this.trackClick("emoji"), this.onClickModerators = () => this.trackClick("moderators"), this.onClickCommunitySettings = () => this.trackClick("community_settings"), this.onClickCommunityAppearance = () => this.trackClick("community_appearance"), this.onClickModMail = () => this.trackClick("mod_mail"), this.onClickRemovalReasons = () => this.trackClick("removal_reasons"), this.onClickRules = () => this.trackClick("rules"), this.onClickPostRequirements = () => this.trackClick("post_requirements"), this.onClickAutomodConfig = () => this.trackClick("automod_config"), this.onClickWikiPages = () => this.trackClick("wiki"), this.onClickTraffic = () => this.trackClick("traffic"), this.onClickModLog = () => this.trackClick("mod_log"), this.onClickModSupport = () => this.trackClick("r_mod_support"), this.onClickModHelp = () => this.trackClick("mod_help"), this.onClickContactReddit = () => this.trackClick("contact_reddit"), this.onClickModEducation = () => this.trackClick("mod_education_site"), this.onClickModGuidelines = () => this.trackClick("mod_guidelines"), this.onClickModHelpCenter = () => this.trackClick("mod_help_center"), this.onClickPostFlair = () => this.trackClick("post_flair"), this.onClickUserFlair = () => this.trackClick("user_flair"), this.onClickGrantUserFlair = () => this.trackClick("grant_user_flair"), this.onClickBadges = () => this.trackClick("badges"), this.onClickEmotes = () => this.trackClick("emotes"), this.onClickScheduledPosts = () => this.props.sendEvent(Object(ie.k)()), this.onClickEventPosts = () => this.props.sendEvent(Object(ie.f)()), this.onClickPredictions = () => this.trackClick("predictions"), this.onGoToModHub = () => {
						const e = this.props.moderatorPermissions && this.props.moderatorPermissions.posts,
							t = `${this.props.subreddit.url}about/`,
							n = e ? `${t}modqueue` : t;
						this.props.pushUrl(n)
					}, this.getFlairSectionName = () => this.props.isBadgesAndEmotesEnabled ? p.fbt._("Badges, flair & emojis", null, {
						hk: "1FuDnm"
					}) : p.fbt._("Flair & emojis", null, {
						hk: "42b2AJ"
					}), this.state = {
						locationSettingSeen: !0
					}
				}
				componentDidMount() {
					this.setState({
						locationSettingSeen: Object(re.M)("location")
					})
				}
				renderDevPlatformNavSection() {
					return i.a.createElement(i.a.Fragment, null, this.props.isDevplatformEnabled && i.a.createElement("div", {
						className: me.a.navSection
					}, i.a.createElement("div", {
						className: me.a.sectionHeader
					}, i.a.createElement(ae.a, {
						name: "view_grid_fill",
						className: me.a.iconStyles
					}), p.fbt._("Community apps (Beta)", null, {
						hk: "1NkOYl"
					})), i.a.createElement(i.a.Fragment, null, i.a.createElement(fe.b, {
						isExternal: !0,
						label: p.fbt._("Installed Apps", null, {
							hk: "4oLAcb"
						}),
						path: `${ee.a.devPlatformPortalUrl}/r/${this.props.subreddit.name}/apps`
					}), i.a.createElement(fe.b, {
						isExternal: !0,
						label: p.fbt._("Browse Apps", null, {
							hk: "3YlX33"
						}),
						path: `${ee.a.devPlatformPortalUrl}/apps`
					}))))
				}
				render() {
					const {
						props: e
					} = this, t = e.isEligibleForScheduledPosts && !e.isProfile || e.isTournamentsEnabled;
					switch (e.pageName) {
						case f.mc.CommunitySettings: {
							const t = !e.subpageName || !Object.values(f.nc).includes(e.subpageName);
							return e.isProfile ? null : i.a.createElement(ne.a.Consumer, null, n => i.a.createElement("div", {
								className: Object(c.a)(me.a.navContainer, {
									[me.a.navContainerExp]: n
								})
							}, i.a.createElement(be, {
								onClick: this.onGoToModHub
							}), i.a.createElement(fe.b, {
								label: p.fbt._("Community", null, {
									hk: "1EIoJe"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(f.nc.Community),
								path: `${e.subreddit.url}about/edit?page=community`,
								isActive: t || e.subpageName === f.nc.Community
							}), i.a.createElement(fe.b, {
								label: p.fbt._("Safety and Privacy", null, {
									hk: "3E0TnI"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(f.nc.Safety),
								path: `${e.subreddit.url}about/edit?page=safety`,
								isActive: e.subpageName === f.nc.Safety
							}), i.a.createElement(fe.b, {
								label: p.fbt._("Posts and Comments", null, {
									hk: "2jt4ea"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(f.nc.Posts),
								path: `${e.subreddit.url}about/edit?page=posts`,
								isActive: e.subpageName === f.nc.Posts
							}), i.a.createElement(fe.b, {
								label: p.fbt._("Wikis", null, {
									hk: "2X1iz1"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(f.nc.Wikis),
								path: `${e.subreddit.url}about/edit?page=wikis`,
								isActive: e.subpageName === f.nc.Wikis
							}), e.isContentTagEnabled && i.a.createElement(fe.b, {
								label: p.fbt._("Content Tag", null, {
									hk: "VuxaQ"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(f.nc.ContentTag),
								path: `${e.subreddit.url}about/edit?page=content_tag`,
								isActive: e.subpageName === f.nc.ContentTag
							}), i.a.createElement(fe.b, {
								label: p.fbt._("Notifications", null, {
									hk: "SRNLx"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(f.nc.Notifications),
								path: `${e.subreddit.url}about/edit?page=notifications`,
								isActive: e.subpageName === f.nc.Notifications
							})))
						}
						case f.mc.Wiki:
						case f.mc.WikiContributors:
						case f.mc.WikiBanned:
							return e.isProfile ? null : i.a.createElement(ne.a.Consumer, null, t => i.a.createElement("div", {
								className: Object(c.a)(me.a.navContainer, me.a.wikiNavContainer, {
									[me.a.navContainerExp]: t
								})
							}, i.a.createElement(be, {
								onClick: this.onGoToModHub
							}), e.moderatorPermissions.wiki && i.a.createElement(Ke, {
								subreddit: e.subreddit
							})));
						default:
							return i.a.createElement(ne.a.Consumer, null, n => i.a.createElement("div", {
								className: Object(c.a)(me.a.navContainer, {
									[me.a.navContainerExp]: n
								})
							}, e.moderatorPermissions.posts && !e.isProfile && i.a.createElement("div", {
								className: me.a.navSection
							}, i.a.createElement("div", {
								className: me.a.sectionHeader
							}, i.a.createElement(ae.a, {
								name: "mod_queue",
								className: me.a.iconStyles
							}), p.fbt._("Queues", null, {
								hk: "2BbIZV"
							})), i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Modqueue,
								label: h(f.mc.Modqueue),
								onClick: this.onClickModQueue,
								path: `${e.subreddit.url}about/modqueue`
							}), i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Reports,
								label: h(f.mc.Reports),
								onClick: this.onClickReports,
								path: `${e.subreddit.url}about/reports`
							}), i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Spam,
								label: h(f.mc.Spam),
								onClick: this.onClickSpam,
								path: `${e.subreddit.url}about/spam`
							}), i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Edited,
								label: h(f.mc.Edited),
								onClick: this.onClickEdited,
								path: `${e.subreddit.url}about/edited`
							}), i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Unmoderated,
								label: h(f.mc.Unmoderated),
								onClick: this.onClickUnmoderated,
								path: `${e.subreddit.url}about/unmoderated`
							})), !e.isProfile && i.a.createElement("div", {
								className: me.a.navSection
							}, i.a.createElement("div", {
								className: me.a.sectionHeader
							}, i.a.createElement(ae.a, {
								name: "user",
								className: me.a.iconStyles
							}), p.fbt._("User management", null, {
								hk: "3G4BgD"
							})), e.moderatorPermissions.access && i.a.createElement(i.a.Fragment, null, i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Banned,
								label: h(f.mc.Banned),
								onClick: this.onClickBannedUsers,
								path: `${e.subreddit.url}about/banned`
							}), e.moderatorPermissions.mail && i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Muted,
								label: h(f.mc.Muted),
								onClick: this.onClickMutedUsers,
								path: `${e.subreddit.url}about/muted`
							}), i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Contributors,
								label: h(f.mc.Contributors),
								onClick: this.onClickApprovedSubmitters,
								path: `${e.subreddit.url}about/contributors`
							}), e.isTalkHostsExperimentEnabled && i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.TalkHosts,
								label: h(f.mc.TalkHosts),
								onClick: this.onClickApprovedTalkHosts,
								path: `${e.subreddit.url}about/talkhosts`
							})), i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Moderators,
								label: h(f.mc.Moderators),
								onClick: this.onClickModerators,
								path: `${e.subreddit.url}about/moderators`
							})), (e.moderatorPermissions.flair || e.moderatorPermissions.config) && !e.isProfile && i.a.createElement("div", {
								className: me.a.navSection
							}, i.a.createElement("div", {
								className: me.a.sectionHeader
							}, i.a.createElement(ae.a, {
								name: "tag",
								className: me.a.iconStyles
							}), this.getFlairSectionName()), e.moderatorPermissions.flair && i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Flair,
								label: h(f.mc.Flair),
								onClick: this.onClickGrantUserFlair,
								path: `${e.subreddit.url}about/flair`
							}), e.moderatorPermissions.config && i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Emojis,
								label: h(f.mc.Emojis),
								onClick: this.onClickEmojis,
								path: `${e.subreddit.url}about/emojis`
							}), e.moderatorPermissions.flair && i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.UserFlair,
								label: h(f.mc.UserFlair),
								onClick: this.onClickUserFlair,
								path: `${e.subreddit.url}about/userflair`
							}), e.moderatorPermissions.flair && e.moderatorPermissions.config && i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.PostFlair,
								label: h(f.mc.PostFlair),
								onClick: this.onClickPostFlair,
								path: `${e.subreddit.url}about/postflair`
							}), e.isBadgesAndEmotesEnabled && i.a.createElement(i.a.Fragment, null, i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Badges,
								label: h(f.mc.Badges),
								onClick: this.onClickBadges,
								path: `${e.subreddit.url}about/badges`
							}), i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Emotes,
								label: h(f.mc.Emotes),
								onClick: this.onClickEmotes,
								path: `${e.subreddit.url}about/emotes`
							}))), (e.moderatorPermissions.config || e.moderatorPermissions.posts) && !e.isProfile && i.a.createElement("div", {
								className: me.a.navSection
							}, i.a.createElement("div", {
								className: me.a.sectionHeader
							}, i.a.createElement(ae.a, {
								name: "rules",
								className: me.a.iconStyles
							}), p.fbt._("Rules and regulations", null, {
								hk: "QAksk"
							})), i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.SubredditRules,
								label: h(f.mc.SubredditRules),
								onClick: this.onClickRules,
								path: `${e.subreddit.url}about/rules`
							}), e.moderatorPermissions.posts && i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Removal,
								label: h(f.mc.Removal),
								onClick: this.onClickRemovalReasons,
								path: `${e.subreddit.url}about/removal`
							}), e.moderatorPermissions.config && i.a.createElement(i.a.Fragment, null, i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.ContentControls,
								label: h(f.mc.ContentControls),
								onClick: this.onClickPostRequirements,
								path: `${e.subreddit.url}about/settings`,
								isNew: e.showHCFNewTagsCampaign
							}), i.a.createElement(fe.b, {
								label: p.fbt._("Automod", null, {
									hk: "1IngsO"
								}),
								onClick: this.onClickAutomodConfig,
								path: `${e.subreddit.url}about/wiki/config/automoderator/`
							}))), this.renderDevPlatformNavSection(), t && i.a.createElement("div", {
								className: me.a.navSection
							}, i.a.createElement("div", {
								className: me.a.sectionHeader
							}, i.a.createElement(ae.a, {
								name: "list_bulleted",
								className: me.a.iconStyles
							}), p.fbt._("Content", null, {
								hk: "IAh5R"
							})), e.isEligibleForScheduledPosts && !e.isProfile && i.a.createElement(i.a.Fragment, null, i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.ScheduledPostContent,
								label: p.fbt._("Scheduled posts", null, {
									hk: "11S6dN"
								}),
								onClick: this.onClickScheduledPosts,
								path: Object(de.e)(e.subreddit.url)
							}), e.isEventPostUiHidden ? null : i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.EventPostContent,
								label: p.fbt._("Event posts", null, {
									hk: "3D98hc"
								}),
								onClick: this.onClickEventPosts,
								path: Object(de.b)(e.subreddit.url)
							})), e.isTournamentsEnabled && i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Predictions,
								label: p.fbt._("Predictions", null, {
									hk: "Serjr"
								}),
								onClick: this.onClickPredictions,
								path: Object(de.d)(e.subreddit.url),
								isNew: !0
							})), (e.moderatorPermissions.config || e.moderatorPermissions.wiki) && i.a.createElement("div", {
								className: me.a.navSection
							}, i.a.createElement("div", {
								className: me.a.sectionHeader
							}, i.a.createElement(ae.a, {
								name: "settings",
								className: me.a.iconStyles
							}), p.fbt._("Other", null, {
								hk: "ST5RE"
							})), i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Awards,
								label: p.fbt._("Awards", null, {
									hk: "48U4Du"
								}),
								onClick: this.onClickAwards,
								path: `${e.subreddit.url}about/awards`
							}), e.moderatorPermissions.wiki && !e.isProfile && i.a.createElement(fe.b, {
								label: p.fbt._("Wiki pages", null, {
									hk: "wShFl"
								}),
								onClick: this.onClickWikiPages,
								path: `${ee.a.redditUrl}${e.subreddit.url}about/wiki/index/`
							}), e.moderatorPermissions.config && !e.isProfile && i.a.createElement(fe.b, {
								label: p.fbt._("Community settings", null, {
									hk: "2xOUK6"
								}),
								onClick: this.onClickCommunitySettings,
								isNew: !this.state.locationSettingSeen,
								path: `${e.subreddit.url}about/edit?page=community`,
								showInboundArrow: !0
							}), e.moderatorPermissions.config && !e.isProfile && i.a.createElement(fe.b, {
								label: p.fbt._("Community appearance", null, {
									hk: "3AHttA"
								}),
								path: `${e.subreddit.url}?styling=true`,
								onClick: this.onClickCommunityAppearance,
								showInboundArrow: !0
							})), e.moderatorPermissions.mail && !e.isProfile && i.a.createElement("div", {
								className: me.a.navSection
							}, i.a.createElement("div", {
								className: me.a.sectionHeader
							}, i.a.createElement(ae.a, {
								name: "mod_mail",
								className: me.a.iconStyles
							}), p.fbt._("Modmail", null, {
								hk: "Eh4Vu"
							})), i.a.createElement(fe.b, {
								isExternal: !0,
								label: p.fbt._("Modmail", null, {
									hk: "3Xkgqo"
								}),
								onClick: this.onClickModMail,
								path: "https://mod.reddit.com"
							})), !e.isProfile && i.a.createElement("div", {
								className: me.a.navSection
							}, i.a.createElement("div", {
								className: me.a.sectionHeader
							}, i.a.createElement(ae.a, {
								name: "statistics",
								className: me.a.iconStyles
							}), p.fbt._("Community activity", null, {
								hk: "1vGSer"
							})), i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Traffic,
								label: p.fbt._("Traffic stats", null, {
									hk: "vw5CU"
								}),
								onClick: this.onClickTraffic,
								path: `${e.subreddit.url}about/traffic`
							}), i.a.createElement(fe.b, {
								isActive: e.pageName === f.mc.Modlog,
								label: h(f.mc.Modlog),
								onClick: this.onClickModLog,
								path: `${e.subreddit.url}about/log`
							})), i.a.createElement("div", {
								className: me.a.navSection
							}, i.a.createElement("div", {
								className: me.a.sectionHeader
							}, i.a.createElement(ae.a, {
								name: "help",
								className: me.a.iconStyles
							}), p.fbt._("Mod help center", null, {
								hk: "256YE"
							})), i.a.createElement(fe.b, {
								isExternal: !0,
								label: p.fbt._("Mod help center", null, {
									hk: "4dCwWU"
								}),
								onClick: this.onClickModHelpCenter,
								path: ee.a.redditModHelpUrl
							}), i.a.createElement(fe.b, {
								isExternal: !0,
								label: p.fbt._("Mod education site", null, {
									hk: "20YCt0"
								}),
								onClick: this.onClickModEducation,
								path: "https://modeducation.reddithelp.com/"
							}), i.a.createElement(fe.b, {
								isExternal: !0,
								label: p.fbt._("Moderator code of conduct", null, {
									hk: "fl2JE"
								}),
								onClick: this.onClickModGuidelines,
								path: "https://www.reddit.com/help/healthycommunities/"
							}), i.a.createElement(fe.b, {
								isExternal: !0,
								label: "r/ModSupport",
								onClick: this.onClickModSupport,
								path: "/r/ModSupport/"
							}), i.a.createElement(fe.b, {
								isExternal: !0,
								label: "r/ModHelp",
								onClick: this.onClickModHelp,
								path: "/r/modhelp/"
							}), i.a.createElement(fe.b, {
								isExternal: !0,
								label: p.fbt._("Contact Reddit", null, {
									hk: "2NRBBx"
								}),
								onClick: this.onClickContactReddit,
								path: "https://www.reddithelp.com/hc/en-us/requests/new"
							}))))
					}
				}
			}
			var Xe = Object(a.b)(Ye, e => ({
					pushUrl: t => e(Object(v.b)(t))
				}))(Object(N.c)(Object(te.b)(Je))),
				Ze = n("./src/reddit/pages/ModHub/Header.tsx"),
				$e = n("./src/reddit/pages/ModHub/index.m.less"),
				et = n.n($e);
			const tt = u.a.div("BackgroundContainer", et.a),
				nt = u.a.div("Body", et.a),
				st = Object(d.c)({
					contentGateInfo: (e, t) => Object(W.h)(e, t.match.params.subredditName)
				}),
				rt = Object(d.c)({
					queryParams: (e, t) => {
						let {
							location: n
						} = t;
						return r()([...Object(l.a)(n.search)])
					}
				}),
				ot = Object(d.c)({
					moderatorPermissions: (e, t) => {
						var n;
						const {
							subredditName: s,
							profileName: r
						} = t.match.params, o = s ? Object(q.I)(e, s) : null === (n = Object(Q.k)(e, {
							profileName: r
						})) || void 0 === n ? void 0 : n.id;
						if (o) return Object(H.n)(e, {
							subredditId: o
						})
					}
				}),
				it = Object(d.c)({
					isContributor: (e, t) => {
						const {
							subredditName: n
						} = t.match.params;
						if (n) {
							const t = Object(q.z)(e, {
								subredditName: n
							});
							if (t) return t.userIsContributor
						}
						return !1
					}
				}),
				at = Object(d.c)({
					subreddit: (e, t) => t.match.params.subredditName ? Object(q.C)(e, {
						subredditName: t.match.params.subredditName
					}) : Object(Q.k)(e, {
						profileName: t.match.params.profileName
					})
				}),
				dt = Object(a.b)(() => Object(d.a)(st, W.P, D.U, ot, W.mb, G.ob, at, it, rt, (e, t) => t.match.params.pageName, e => e, (e, t, n, s, r, o, i, a, d, c, l) => {
					let {
						contentGateInfo: u
					} = e, {
						moderatorPermissions: m
					} = s, {
						subreddit: p
					} = i, {
						isContributor: b
					} = a, {
						queryParams: f
					} = d;
					const {
						after: h,
						afterEditable: g,
						before: v,
						beforeEditable: x,
						only: E,
						page: O,
						sort: C
					} = f, A = Object(U.a)(l, !!m);
					return {
						contentGateInfo: u,
						isTalkHostsEnabled: Object(F.r)(l),
						isContributor: b,
						isEmployee: t,
						layout: n,
						moderatorPermissions: m,
						isScheduledPostsEnabled: o,
						subreddit: p,
						renderNSFWContentGate: !!p && p.isNSFW && !r,
						page: `${O||B.b}`,
						pageName: c,
						postTypeFilter: E,
						after: h || "",
						afterEditable: g,
						before: v,
						postSort: C,
						beforeEditable: x,
						isInShredditModNavExperiment: A
					}
				})),
				ct = Object(D.v)();
			class lt extends i.a.Component {
				constructor() {
					super(...arguments), this.sendEventWithName = e => () => {
						this.props.sendEvent(t => ({
							source: e.includes("modqueue_sort") ? "moderator" : Object(L.b)(this.props.pageName),
							action: "click",
							noun: e,
							...x.b(t)
						}))
					}, this.onClickSubredditLink = () => {
						this.props.sendEvent(x.g())
					}
				}
				componentDidUpdate(e) {
					(this.props.pageName && this.props.pageName !== e.pageName || this.props.page && this.props.page !== e.page) && (document.documentElement.scrollTop = document.body.scrollTop = 0)
				}
				render() {
					const {
						props: e
					} = this;
					if (!e.subreddit) {
						const t = Object(R.a)(e.contentGateInfo, e.renderNSFWContentGate, e.match.params.subredditName);
						return t ? i.a.createElement(m.default, t) : null
					}
					const t = !!e.moderatorPermissions,
						n = e.isInShredditModNavExperiment && !(e.pageName && e.pageName.includes("wiki"));
					return i.a.createElement(tt, {
						className: Object(c.a)(n ? "bg-neutral-background" : void 0, {
							[et.a.background]: !n
						})
					}, i.a.createElement(Ze.a, {
						onClick: this.onClickSubredditLink,
						subredditOrProfile: e.subreddit,
						pageName: e.pageName ? h(e.pageName) : void 0,
						isInShredditModNavExperiment: e.isInShredditModNavExperiment
					}), i.a.createElement(nt, null, n ? i.a.createElement(P, {
						subredditName: e.subreddit.name,
						moderatorPermissions: e.moderatorPermissions,
						subreddit: e.subreddit
					}) : e.moderatorPermissions && i.a.createElement(Xe, {
						moderatorPermissions: e.moderatorPermissions,
						pageName: e.pageName,
						subpageName: e.page,
						subreddit: e.subreddit,
						isProfile: !!e.match.params.profileName
					}), i.a.createElement("div", {
						className: Object(c.a)(et.a.contentWrapper, t && et.a.isModerator)
					}, e.pageName && Object(M.a)({
						pageName: e.pageName,
						moderatorPermissions: e.moderatorPermissions,
						canCreateScheduledPosts: e.isScheduledPostsEnabled,
						isEmployee: e.isEmployee,
						isTalkHostsEnabled: e.isTalkHostsEnabled,
						subredditType: e.subreddit.type,
						isContributor: e.isContributor
					}) ? i.a.createElement(z.a, {
						after: e.after,
						afterEditable: e.afterEditable,
						before: e.before,
						beforeEditable: e.beforeEditable,
						layout: e.layout,
						moderatorPermissions: e.moderatorPermissions,
						page: e.page,
						pageName: e.pageName,
						postSort: e.postSort,
						postTypeFilter: e.postTypeFilter,
						sendEventWithName: this.sendEventWithName,
						subpageName: e.page,
						subreddit: e.subreddit
					}) : e.moderatorPermissions ? i.a.createElement($, {
						subredditDisplayText: e.subreddit.displayText
					}) : i.a.createElement(V.a, {
						isModerator: t,
						subredditDisplayText: e.subreddit.displayText
					}))))
				}
			}
			t.default = ct(dt(Object(N.c)(lt)))
		},
		"./src/reddit/pages/NotificationsInbox/Content/EmptyStateViews/EmptyStateComponent.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/helpers/trackers/inbox.ts"),
				i = n("./src/reddit/hooks/useTracking.ts"),
				a = n("./node_modules/fbt/lib/FbtPublic.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/config.ts"),
				l = n("./src/reddit/controls/Button/index.tsx"),
				u = n("./src/reddit/controls/InternalLink/index.tsx"),
				m = n("./src/reddit/pages/NotificationsInbox/Content/EmptyStateViews/index.m.less"),
				p = n.n(m);

			function b() {
				return (b = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const f = ["r/somethingimade", "r/CasualConversation", "r/DoesAnybodyElse", "r/Old_Recipes"][Math.floor(100 * Math.random()) % 4];
			var h = e => {
				let {
					inTooltip: t,
					onBtnClick: n
				} = e;
				const s = `/${f}`,
					o = {
						to: s,
						kind: l.b.InternalLink
					},
					i = r.a.createElement(u.default, {
						to: s,
						target: "_blank",
						rel: "noopener noreferrer",
						className: p.a.subredditLinkR,
						onClick: n
					}, f);
				return r.a.createElement("div", {
					className: Object(d.a)(p.a.emptyState, p.a.karmaView, {
						[p.a.inNotificationsPage]: !t
					})
				}, r.a.createElement("img", {
					src: `${c.a.assetPath}/img/wrappedreddit/default_avatar.png`,
					alt: a.fbt._("default user avatar", null, {
						hk: "1VMTKf"
					}),
					className: Object(d.a)(p.a.avatarImage, {
						[p.a.inTooltip]: t
					})
				}), r.a.createElement("h1", {
					className: Object(d.a)(p.a.emptyTitle, {
						[p.a.inTooltip]: t
					})
				}, a.fbt._("You dont have any activity yet", null, {
					hk: "43tvWW"
				})), r.a.createElement("p", {
					className: p.a.emptyDescription
				}, a.fbt._("Thats ok, maybe you just need the right inspiration. Try posting in {Link: to popular subreddit} , a popular community for discussion.", [a.fbt._param("Link: to popular subreddit", i)], {
					hk: "1WOK4T"
				})), r.a.createElement(l.t, b({
					className: p.a.emptyStateButton,
					onClick: n,
					text: `Visit ${f}`
				}, o)))
			};
			t.a = e => {
				let {
					inTooltip: t
				} = e;
				const n = Object(i.a)();
				return r.a.createElement(h, {
					inTooltip: t,
					onBtnClick: (e => () => n(Object(o.r)({
						actionInfoType: e
					})))(o.a.Karma)
				})
			}
		},
		"./src/reddit/pages/NotificationsInbox/Content/EmptyStateViews/index.m.less": function(e, t, n) {
			e.exports = {
				emptyState: "_3B_EfQMwEiEzc_9vEdVplz",
				emptyStateLoggedOutContainer: "_3AcDG0KjCxs3H1UW_4ajNf",
				emptyStateDivider: "bfJNAfRJ7wvCVMJIHbVa-",
				karmaView: "_3eBLRjkIDT-8Hobfrj_UTz",
				inNotificationsPage: "_2upiES-f8azWSz_UdoeHE7",
				avatarImage: "mGm_bo7f-d7T6Ax_UEs_l",
				inTooltip: "JBKRJW6IC_gf5qQ_mqb4A",
				catsImageWrapper: "odMqhFpc4xkpus4jHz_9f",
				cat: "_13uS-SsNmI2cGGsq2rpP8O",
				top: "_29krHC0w9xxlGw1mBpwNHU",
				bottom: "_3VkvX9EbwQAVQJ3qEl_wzw",
				cloud: "_3yAL94u5AxUY-JhhHIPNuU",
				yummy: "_2TY8uYFieKTHl7jN_vmcYR",
				memesImageWrapper: "jaQ0krPJ6FkjLU-VDMGNq",
				shrek: "_1f1-1KlOtH3uQKPHzkGdDI",
				star: "_2mEU_pG_y9L4CaC7zihby0",
				inBottom: "_1kfecAwlZWu6be_WDfvh-P",
				inCenter: "_4DkJv1On5ORUXrwzznhqE",
				inTop: "_1lJAHwdJYzqn-69JkG-HJQ",
				emptyStateButton: "_1_kVxSQ5_eQNTfI-Y89mu4",
				loggedOutState: "_3uw_OsQCi8zOpS3fha4JEF",
				emptyStateWithBanner: "_1L4nSUqK39ZB-E1-MXtBve",
				emptyTitle: "_36brOzjH6sE_rgnTt-hcL1",
				emptyDescription: "Ae79bDDbZ2U_G-wqwA71z",
				subredditLinkR: "_9DV1fqkU31oi8pfSQxzjw",
				BellOutline: "_23NDu_VaLgaSWVzKHs-Gfa",
				bellOutline: "_23NDu_VaLgaSWVzKHs-Gfa"
			}
		},
		"./src/reddit/reducers/economics/paymentSystems/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var s, r = n("./src/reddit/actions/economics/paymentSystems/constants.ts");
			! function(e) {
				e[e.Failure = 0] = "Failure", e[e.Fetched = 1] = "Fetched", e[e.NotFetched = 2] = "NotFetched", e[e.Pending = 3] = "Pending"
			}(s || (s = {}));
			const o = {
				status: s.NotFetched
			};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						if (e.status === s.Fetched && e.data.stripe && e.data.stripe.sources) {
							const n = t.payload.cardId,
								{
									[n]: s,
									...r
								} = e.data.stripe.sources;
							return {
								...e,
								data: {
									...e.data,
									stripe: {
										...e.data.stripe,
										sources: r
									}
								}
							}
						}
						return e;
					case r.e:
						if (e.status === s.Fetched && e.data.braintree && e.data.braintree.sources) {
							const n = t.payload.sourceId,
								{
									[n]: s,
									...r
								} = e.data.braintree.sources;
							return {
								...e,
								data: {
									...e.data,
									braintree: {
										...e.data.braintree,
										sources: r
									}
								}
							}
						}
						return e;
					case r.b:
						return {
							error: t.payload.error, status: s.Failure
						};
					case r.c:
						return {
							data: t.payload, status: s.Fetched
						};
					case r.d:
						return {
							status: s.Pending
						};
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/economics/subredditPremium/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r = n("./src/lib/constants/specialMembership.ts"),
				o = n("./src/reddit/actions/economics/subredditPremium/constants.ts"),
				i = n("./src/reddit/helpers/economics/sortBadges.ts"),
				a = n("./src/reddit/models/Badge/index.ts"),
				d = n("./src/reddit/models/Badge/managementPage.ts");
			! function(e) {
				e[e.NotFetched = 0] = "NotFetched", e[e.Fetched = 1] = "Fetched"
			}(s || (s = {}));
			const c = {};

			function l(e) {
				return "userId" in e
			}

			function u(e, t, n, s) {
				e.forEach(e => {
					e.collections && Object.keys(e.collections).forEach(r => {
						let o;
						(o = e.placement ? e.placement === a.a.First ? s[d.a.Loyalty][r] : s[d.a.Achievement][r] : l(e) ? s[d.a.Cosmetic][d.c.MyBadges][r] : s[d.a.Cosmetic][d.c.Gallery][r]) && (l(e) ? n.has(e.id) && o.unlocked.push(e) : t.has(e.id) || o.locked.push(e))
					})
				})
			}

			function m(e) {
				const t = (e, t) => {
					const n = parseInt(e.price || "0"),
						s = parseInt(t.price || "0");
					return n === s ? Object(i.b)(e, t) : n - s
				};
				return e.locked.sort(t), e.unlocked.sort(t), e
			}

			function p(e, t) {
				return Object.keys(e).map(t => e[t]).filter(e => !!e.locked.length || !!e.unlocked.length || e.id === r.a).map(m).sort((e, n) => {
					const s = t[e.id],
						r = t[n.id];
					return Object(i.b)(s, r)
				})
			}

			function b(e) {
				const t = {
					[d.a.Loyalty]: {},
					[d.a.Achievement]: {},
					[d.a.Cosmetic]: {
						[d.c.Gallery]: {},
						[d.c.MyBadges]: {}
					}
				};
				Object.keys(e.collections).forEach(n => {
					const s = e.collections[n],
						r = {
							description: s.description,
							highlight: s.extra && s.extra.style && s.extra.style.color,
							id: s.id,
							locked: [],
							title: s.title,
							unlocked: []
						};
					t[d.a.Loyalty][n] = {
						...r,
						locked: [],
						unlocked: []
					}, t[d.a.Achievement][n] = {
						...r,
						locked: [],
						unlocked: []
					}, t[d.a.Cosmetic][d.c.Gallery][n] = {
						...r,
						locked: [],
						unlocked: []
					}, t[d.a.Cosmetic][d.c.MyBadges][n] = {
						...r,
						locked: [],
						unlocked: []
					}
				});
				const n = new Set;
				e.userOwnedBadges.forEach(t => {
					const s = e.badges[t];
					s && n.add(s.type)
				});
				const s = new Set(e.userOwnedBadges);
				return u(Object.keys(e.badges).map(t => e.badges[t]), n, s, t), u(Object.keys(e.products).map(t => e.products[t]), n, s, t), {
					collections: {
						[d.a.Loyalty]: p(t[d.a.Loyalty], e.collections),
						[d.a.Achievement]: p(t[d.a.Achievement], e.collections),
						[d.a.Cosmetic]: {
							[d.c.Gallery]: p(t[d.a.Cosmetic][d.c.Gallery], e.collections),
							[d.c.MyBadges]: p(t[d.a.Cosmetic][d.c.MyBadges], e.collections)
						}
					},
					subscription: e.subscription,
					userOwnedBadges: e.userOwnedBadges.map(t => e.badges[t]).filter(Boolean)
				}
			}
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : c,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case o.a: {
						const {
							subredditId: n
						} = t.payload, r = e[n];
						return r && r.status === s.Fetched ? {
							...e,
							[n]: {
								...r,
								data: {
									...r.data
								},
								raw: {
									...r.raw
								}
							}
						} : e
					}
					case o.h: {
						const {
							subredditId: n
						} = t.payload, r = e[n];
						return r && r.status === s.Fetched ? {
							...e,
							[n]: {
								...r,
								data: {
									...r.data,
									subscription: {
										...r.data.subscription || {},
										settings: {
											renew: !1
										}
									}
								},
								raw: {
									...r.raw,
									subscription: {
										...r.raw.subscription || {},
										settings: {
											renew: !1
										}
									}
								}
							}
						} : e
					}
					case o.i: {
						const n = t.payload;
						return {
							...e,
							[n.subredditId]: {
								raw: n,
								data: b(n),
								status: s.Fetched
							}
						}
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/features/avatar/index.ts": function(e, t, n) {
			"use strict";
			var s, r, o = n("./node_modules/redux/es/redux.js"),
				i = n("./src/reddit/actions/snoovatar.ts");
			! function(e) {
				e.PREMIUM = "PREMIUM"
			}(s || (s = {})),
			function(e) {
				e[e.BACKGROUND = 0] = "BACKGROUND", e[e.ACCESSORY_BACK = 1] = "ACCESSORY_BACK", e[e.HAIR_BACK = 2] = "HAIR_BACK", e[e.BODY_BOTTOM = 3] = "BODY_BOTTOM", e[e.BODY = 4] = "BODY", e[e.ACCESSORY = 5] = "ACCESSORY", e[e.FACE_LOWER = 6] = "FACE_LOWER", e[e.FACE_UPPER = 7] = "FACE_UPPER", e[e.HAIR = 8] = "HAIR", e[e.HEAD_ACCESSORY = 9] = "HEAD_ACCESSORY"
			}(r || (r = {}));
			const a = {
				id: "",
				csrf_token: "",
				snoovatar: null,
				websocketsUrls: {
					renderer: "",
					download: ""
				},
				capabilities: [s.PREMIUM],
				hasActiveClosetSubscription: !1
			};
			var d = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.b:
						return {
							...t.payload
						};
					default:
						return e
				}
			};
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const c = {
					marketingEvent: {
						active: !1,
						assetUrls: null,
						experimentRequired: null
					},
					quickCreateV1: {
						id: "-1",
						active: !1,
						text: "",
						min_days_on_reddit: 0,
						should_have_avatar: !1,
						max_event_views: 0,
						min_days_since_last_event_interaction: 0,
						webAssetUrls: []
					},
					pushcard: null
				},
				l = "avatar_quick_create_event",
				u = "avatar_marketing_event",
				m = "avatar_pushcard",
				p = "avatar_promo_archived";
			var b;
			! function(e) {
				e.MaxEventViews = "targeting:max_event_views", e.Title = "copy:pushcard_title", e.Cta = "copy:pushcard_cta", e.BannerTitle = "copy:banner_title", e.BannerBody = "copy:banner_body", e.Deeplink = "deeplink"
			}(b || (b = {}));
			const f = e => {
					let {
						startsAt: t,
						endsAt: n
					} = e;
					const s = t && new Date(t) <= new Date,
						r = !!n && new Date(n) < new Date;
					return !!s && !r
				},
				h = e => {
					const {
						id: t,
						tags: n,
						webAssetUrls: s
					} = e, [r, o] = s, i = n.reduce((e, t) => {
						if (!t) return e;
						const n = Object.values(b).find(e => t.startsWith(e));
						return n ? (e[n] = t.slice(n.length + 1), e) : e
					}, {});
					return {
						id: t,
						maxViews: parseInt(i[b.MaxEventViews], 10),
						banner: {
							id: t,
							iconUrl: r,
							title: i[b.BannerTitle],
							body: i[b.BannerBody]
						},
						imageUrl: o,
						title: i[b.Title],
						cta: i[b.Cta],
						deeplink: i[b.Deeplink]
					}
				},
				g = e => {
					const t = {};
					return null == e || e.forEach(e => {
						if (null == e ? void 0 : e.startsWith("targeting:")) {
							const n = e.split(":");
							if (!n.length && n.length < 3) return null;
							try {
								t[n[1]] = JSON.parse(n[2])
							} catch {
								t[n[1]] = n[2]
							}
						}
					}), t
				};

			function v(e) {
				const t = {};
				return e.forEach(e => {
					var n;
					const {
						webAssetUrls: s,
						tags: r
					} = e;
					if (!(null == r ? void 0 : r.includes(p))) {
						if ((null == r ? void 0 : r.includes(m)) && s && s.length >= 2 && (t.pushcard = h(e)), null == r ? void 0 : r.includes(l)) {
							const {
								text: n,
								id: o
							} = e, i = s || null, a = g(r);
							t.quickCreateV1 = {
								...a,
								id: o,
								text: n,
								active: f(e) && !!i,
								webAssetUrls: i
							}
						}
						if (null == r ? void 0 : r.includes(u)) {
							const o = s || null,
								i = (null === (n = r.find(e => (null == e ? void 0 : e.startsWith("feature:")) && e.includes("web"))) || void 0 === n ? void 0 : n.split("feature:")[1]) || null;
							t.marketingEvent = {
								active: f(e) && !!o,
								assetUrls: o,
								experimentRequired: i
							}
						}
					}
				}), t
			}
			var x = n("./src/reddit/actions/economics/marketplace/constants.ts"),
				E = n("./src/reddit/actions/goldPurchaseModals/constants.ts"),
				O = n("./src/reddit/actions/modal.ts"),
				C = n("./src/reddit/constants/modals.ts");
			var A = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				var n, s;
				switch (t.type) {
					case E.s:
						const {
							avatarMarketingEvents: r
						} = t.payload;
						return r ? {
							...c,
							...v(r)
						} : c;
					case x.b:
					case x.c:
					case x.f:
						return (null == e ? void 0 : e.pushcard) ? {
							...e,
							pushcard: {
								...e.pushcard
							}
						} : e;
					case O.c:
						return (null === (n = t.payload) || void 0 === n ? void 0 : n.id) === C.a.SNOOVATAR_MODAL ? {
							...c,
							pushcard: null !== (s = null == e ? void 0 : e.pushcard) && void 0 !== s ? s : null
						} : e;
					default:
						return e
				}
			};
			var y = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.a: {
						const {
							image: e,
							accessory_ids: n
						} = t.payload;
						return {
							image: e,
							accessoryIds: n
						}
					}
					default:
						return e
				}
			};
			t.a = Object(o.c)({
				marketing: A,
				avatarUser: d,
				randomAvatar: y
			})
		},
		"./src/reddit/reducers/features/communityChat/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/actions/communityChat/index.ts");
			const r = {
				selectedChannelId: "",
				models: {},
				channelIds: {},
				hasShownToastMessage: !1
			};
			t.a = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : r,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case s.c:
						return {
							...e, selectedChannelId: t.payload
						};
					case s.a: {
						const {
							subredditId: n,
							channelIds: s,
							channels: r
						} = t.payload;
						return {
							...e,
							channelIds: {
								...e.channelIds,
								[n]: s
							},
							models: {
								...e.models,
								...r
							}
						}
					}
					case s.b:
						return {
							...e, hasShownToastMessage: t.payload
						};
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/features/creatorStats/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/creatorStats/constants.ts");
			const o = {};
			var i = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						const {
							postOtherDiscussions: n
						} = t.payload;
						return {
							...e, ...n
						};
					default:
						return e
				}
			};
			const a = {};
			var d = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						const {
							postStats: n
						} = t.payload;
						return {
							...e, ...n
						};
					default:
						return e
				}
			};
			const c = {};
			var l = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : c,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						const {
							subredditKarma: n
						} = t.payload;
						return {
							...e, ...n
						};
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				postOtherDiscussions: i,
				postStats: d,
				subredditKarma: l
			})
		},
		"./src/reddit/reducers/features/crypto/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/actions/economics/claims/constants.ts")),
				o = n("./src/reddit/actions/economics/me/constants.ts");
			const i = {};
			var a = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case o.a: {
							const n = t.payload.claimPoints || {},
								s = Object.keys(n).reduce((t, s) => (t[s] = {
									...e[s],
									availableClaims: n[s]
								}, t), {});
							return Object.keys(e).forEach(t => {
								var n;
								(null === (n = e[t]) || void 0 === n ? void 0 : n.isClaiming) && (s[t] = s[t] || {
									availableClaims: []
								}, s[t].isClaiming = !0)
							}), s
						}
						case r.b:
						case r.a:
							const {
								subredditId: n
							} = t.payload;
							return {
								...e, [n]: {
									...e[n],
									isClaiming: t.type === r.b
								}
							};
						default:
							return e
					}
				},
				d = n("./src/reddit/actions/governance/constants.ts");
			const c = 15e4,
				l = {},
				u = {
					filled: "img/communityPoints/default_filled.png",
					grey: "img/communityPoints/default_grey.png"
				};

			function m(e) {
				var t, n, s, r, o;
				const i = null === (t = e.walletProvider) || void 0 === t ? void 0 : t.extra,
					a = null == i ? void 0 : i.contracts,
					d = null == a ? void 0 : a.unlocked,
					l = null !== (s = null === (n = e.walletProvider) || void 0 === n ? void 0 : n.provider) && void 0 !== s ? s : e.provider,
					m = !!(null === (r = e.walletProvider) || void 0 === r ? void 0 : r.inTransition),
					p = null == i ? void 0 : i.metaTransactions,
					b = (null == p ? void 0 : p.allowedContractMethods) || {},
					f = (null == p ? void 0 : p.gasLimit) || c,
					h = (null == d ? void 0 : d.decimals) || 0,
					g = "1" + "0".repeat(h);
				return {
					allowedContractMethods: b,
					blockchainProvider: l,
					contractAddress: (null == d ? void 0 : d.address) || "",
					contracts: a,
					decimals: h,
					displayConversion: g,
					gasLimit: f,
					images: e.images || u,
					inTransition: m,
					name: e.name,
					nomenclature: null === (o = e.extra) || void 0 === o ? void 0 : o.nomenclature,
					polls: e.polls,
					symbol: (null == d ? void 0 : d.token) || ""
				}
			}
			var p = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.a: {
						const {
							subredditId: n,
							meta: s
						} = t.payload;
						return {
							...e,
							[n]: m(s)
						}
					}
					default:
						return e
				}
			};
			const b = {};
			var f = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : b,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.n: {
						const {
							subredditId: n,
							wallets: s
						} = t.payload, r = Object.keys(s).reduce((t, r) => {
							return {
								...t,
								[r]: {
									...e[r] || {},
									[n]: s[r]
								}
							}
						}, {});
						return {
							...e,
							...r
						}
					}
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				claims: a,
				points: p,
				publicWallets: f
			})
		},
		"./src/reddit/reducers/features/modActivitySummaries/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/actions/modQueue/constants.ts");
			t.a = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case s.l: {
						const {
							summary: n,
							subreddit: s
						} = t.payload;
						return {
							...e,
							[s.id]: {
								...e[s.id],
								...n
							}
						}
					}
					case s.i:
					case s.f:
					case s.r:
					case s.u:
					case s.A: {
						const {
							response: n
						} = t.payload;
						return {
							...e,
							...n.modActivitySummaries
						}
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/features/modUserNotes/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/subredditModeration/constants.ts");
			var o = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.U:
						case r.T:
							return null;
						case r.S:
							return t.payload;
						default:
							return e
					}
				},
				i = n("./src/reddit/models/SubredditModeration/index.ts");
			const a = {};
			var d = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.U: {
							const {
								subredditId: n,
								userId: s,
								filter: r
							} = t.payload, o = Object(i.d)(n, s, r);
							return {
								...e,
								[o]: !0
							}
						}
						case r.T:
						case r.S: {
							const {
								subredditId: n,
								userId: s,
								filter: r
							} = t.payload, o = Object(i.d)(n, s, r);
							return {
								...e,
								[o]: !1
							}
						}
						default:
							return e
					}
				},
				c = Object(s.c)({
					error: o,
					pending: d
				});
			const l = {};
			var u = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.T: {
							const {
								subredditId: n,
								userId: s,
								filter: r,
								fetchedToken: o
							} = t.payload, a = Object(i.d)(n, s, r, o);
							return {
								...e,
								[a]: !0
							}
						}
						default:
							return e
					}
				},
				m = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/redditGQL/types.ts"));
			const p = e => `${e.subredditId}--${e.bannedAtUTC}-usernote`,
				b = e => `${e.subredditId}--${e.bannedAtUTC}-actionnote`,
				f = e => {
					const t = p(e),
						{
							modNote: n
						} = e;
					return n ? {
						__typename: "ModUserNote",
						id: t,
						itemType: m.B.Ban,
						createdAt: new Date(1e3 * e.bannedAtUTC),
						operator: {
							id: e.bannedById,
							displayName: e.bannedBy
						},
						user: {
							id: e.id,
							displayName: e.username
						},
						label: m.I.Ban,
						note: n
					} : null
				},
				h = e => {
					return {
						__typename: "ModActionNote",
						id: b(e),
						itemType: m.B.Ban,
						createdAt: new Date(1e3 * e.bannedAtUTC),
						operator: {
							id: e.bannedById,
							displayName: e.bannedBy
						},
						user: {
							id: e.id,
							displayName: e.username
						},
						description: e.banMessage,
						longDescription: e.banMessage,
						banDays: e.duration,
						isPermanentBan: !e.duration
					}
				},
				g = {};
			var v = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : g,
					t = arguments.length > 1 ? arguments[1] : void 0;
				var n;
				switch (t.type) {
					case r.Q: {
						const {
							subredditId: n,
							newModNote: s
						} = t.payload, r = Object(i.d)(n, s.user.id, m.A.All);
						return {
							...e,
							[r]: s.id
						}
					}
					case r.H: {
						const {
							subredditId: s,
							lastAuthorModNote: r
						} = t.payload, o = null === (n = null == r ? void 0 : r.user) || void 0 === n ? void 0 : n.id, a = Object(i.d)(s, o, m.A.All);
						return {
							...e,
							[a]: r.id
						}
					}
					case r.G: {
						const {
							subredditId: n,
							lastAuthorModNotes: s
						} = t.payload, r = {};
						return s.forEach(e => {
							var t;
							const s = null === (t = null == e ? void 0 : e.user) || void 0 === t ? void 0 : t.id,
								o = Object(i.d)(n, s, m.A.All);
							r[o] = e.id
						}), {
							...e,
							...r
						}
					}
					case r.p: {
						const {
							bannedUsers: n
						} = t.payload, s = Object.values(n)[0], {
							subredditId: r
						} = s, o = s.id;
						if (!s.modNote) return e;
						const a = p(s),
							d = Object(i.d)(r, o, m.A.All);
						return {
							...e,
							[d]: a
						}
					}
					default:
						return e
				}
			};
			const x = {};
			var E = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : x,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.T: {
							const {
								subredditId: e,
								userId: n,
								filter: s,
								loadMoreToken: r
							} = t.payload;
							return {
								[Object(i.d)(e, n, s)]: r
							}
						}
						default:
							return e
					}
				},
				O = n("./node_modules/icepick/icepick.js");
			const C = {};
			var A = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : C,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.Q: {
							const {
								newModNote: n
							} = t.payload;
							return {
								...e,
								[n.id]: n
							}
						}
						case r.H: {
							const {
								lastAuthorModNote: n
							} = t.payload;
							return {
								...e,
								[n.id]: n
							}
						}
						case r.G: {
							const {
								lastAuthorModNotes: n
							} = t.payload;
							return Object(O.merge)(e, n.reduce((e, t) => (e[t.id] = t, e), {}))
						}
						case r.T: {
							const {
								notes: n
							} = t.payload;
							return Object(O.merge)(e, n.reduce((e, t) => (e[t.id] = t, e), {}))
						}
						case r.R: {
							const {
								noteId: n
							} = t.payload, s = {
								...e
							};
							return delete s[n], s
						}
						case r.p: {
							const {
								bannedUsers: n
							} = t.payload;
							return Object(O.merge)(e, Object.values(n).reduce((e, t) => {
								const n = b(t),
									s = h(t);
								e[n] = s;
								const r = p(t),
									o = f(t);
								return o ? (e[r] = o, e) : e
							}, {}))
						}
						default:
							return e
					}
				},
				y = n("./node_modules/lodash/uniq.js"),
				j = n.n(y);
			const I = {};
			var k = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : I,
					t = arguments.length > 1 ? arguments[1] : void 0;
				var n;
				switch (t.type) {
					case r.Q: {
						const {
							subredditId: s,
							newModNote: r,
							filter: o
						} = t.payload;
						if (o !== m.A.All && o !== m.A.Note) return e;
						const a = null === (n = null == r ? void 0 : r.user) || void 0 === n ? void 0 : n.id,
							d = Object(i.d)(s, a, o),
							c = o === m.A.All ? m.A.Note : m.A.All,
							l = Object(i.d)(s, a, c);
						return {
							...e,
							[d]: e[d] ? [r.id, ...e[d]] : [r.id],
							[l]: e[l] ? [r.id, ...e[l]] : [r.id]
						}
					}
					case r.T: {
						const {
							notes: n,
							subredditId: s,
							userId: r,
							filter: o
						} = t.payload, a = Object(i.d)(s, r, o), d = n.map(e => e.id);
						return e[a] ? {
							...e,
							[a]: j()([...e[a], ...d])
						} : {
							...e,
							[a]: d
						}
					}
					case r.R: {
						const {
							subredditId: n,
							userId: s,
							noteId: r
						} = t.payload, o = Object(i.d)(n, s, m.A.All), a = Object(i.d)(n, s, m.A.Note), d = e[o] ? e[o].filter(e => e !== r) : [], c = e[a] ? e[a].filter(e => e !== r) : [];
						return {
							...e,
							...e[o] ? {
								[o]: d
							} : null,
							...e[a] ? {
								[a]: c
							} : null
						}
					}
					case r.p: {
						const {
							bannedUsers: n
						} = t.payload, s = Object.values(n)[0], {
							subredditId: r
						} = s, o = s.id, a = Object(i.d)(r, o, m.A.All), d = Object(i.d)(r, o, m.A.Note), c = Object(i.d)(r, o, m.A.Ban), l = b(s), u = p(s), f = e[a] ? [u, l, ...e[a]] : [], h = e[d] ? [u, ...e[d]] : [], g = e[c] ? [l, ...e[c]] : [];
						return {
							...e,
							...e[a] ? {
								[a]: f
							} : null,
							...e[d] ? {
								[d]: h
							} : null,
							...e[c] ? {
								[c]: g
							} : null
						}
					}
					default:
						return e
				}
			};
			const _ = {};
			var S = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.Q: {
						const {
							subredditId: n,
							newModNote: s
						} = t.payload, r = Object(i.d)(n, s.user.id, m.A.All);
						return {
							...e,
							[r]: {
								...e[r],
								[m.A.All]: (e[r][m.A.All] || 0) + 1,
								[m.A.Note]: (e[r][m.A.Note] || 0) + 1
							}
						}
					}
					case r.lb: {
						const {
							subredditId: n,
							userId: s,
							totalCounts: r
						} = t.payload, o = Object(i.d)(n, s, m.A.All);
						return {
							...e,
							[o]: Object.keys(r).reduce((e, t) => (e[t] = r[t].totalCount, e), {})
						}
					}
					case r.R: {
						const {
							subredditId: n,
							userId: s
						} = t.payload, r = Object(i.d)(n, s, m.A.All);
						return {
							...e,
							...void 0 !== e[r] ? {
								[r]: {
									...e[r],
									[m.A.All]: (e[r][m.A.All] || 1) - 1,
									[m.A.Note]: (e[r][m.A.Note] || 1) - 1
								}
							} : null
						}
					}
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				api: c,
				fetchedTokens: u,
				lastAuthorModNotes: v,
				loadMore: E,
				models: A,
				order: k,
				totalCount: S
			})
		},
		"./src/reddit/reducers/features/realtimeModqueue/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/modQueue/constants.ts");
			var o = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.m: {
							const {
								targetID: n
							} = t.payload;
							return e.includes(n) ? e : [...e, n]
						}
						case r.p: {
							const {
								targetID: n
							} = t.payload, s = e.indexOf(n);
							return s > -1 && e.splice(s, 1), e
						}
						default:
							return e
					}
				},
				i = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/actions/comment/constants.ts")),
				a = n("./src/reddit/actions/platform.ts"),
				d = n("./src/reddit/actions/post.ts");
			const c = ["isApproved", "isRemoved", "isSpam"];
			var l = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.q:
					case d.k: {
						const n = t.payload;
						return Object.keys(n).map(t => {
							const s = Object.keys(n[t]);
							let r = !1;
							s.map(e => {
								c.includes(e) && (r = !0)
							}), !e.includes(t) && r && (e = [...e, t])
						}), e
					}
					case r.p: {
						const {
							targetID: n
						} = t.payload;
						return e.includes(n) ? e : [...e, n]
					}
					case a.g:
						return [];
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				toUpdate: o,
				updated: l
			})
		},
		"./src/reddit/reducers/features/userFlair/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/omit.js"),
				r = n.n(s),
				o = n("./src/reddit/actions/grantUserFlair/constants.ts"),
				i = n("./src/reddit/actions/modQueue/constants.ts"),
				a = n("./src/reddit/actions/pages/constants.ts"),
				d = n("./src/reddit/actions/pages/postCreation.ts"),
				c = n("./src/reddit/actions/pages/postDraft.ts"),
				l = n("./src/reddit/actions/pages/subreddit/index.ts"),
				u = n("./src/reddit/actions/userFlair/constants.ts");
			const m = {};
			t.a = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m,
					t = arguments.length > 1 ? arguments[1] : void 0;
				var n, s, p, b, f;
				switch (t.type) {
					case l.SUBREDDIT_LOADED:
					case d.PAGE_LOADED:
					case c.PAGE_LOADED:
					case a.b:
					case a.f:
					case u.k:
						return {
							...e, ...t.payload.userFlair
						};
					case i.i:
					case i.f:
					case i.r:
					case i.u:
					case i.A: {
						const {
							response: n
						} = t.payload, {
							userFlair: s
						} = n, r = {
							...e
						};
						return Object.keys(s).forEach(e => {
							r[e] || (r[e] = s[e])
						}), r
					}
					case u.s: {
						const {
							subredditId: n,
							applied: s,
							displaySettings: r
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								...s && {
									applied: s
								},
								displaySettings: r
							}
						}
					}
					case o.h: {
						const {
							subredditId: n,
							applied: s
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								applied: s
							}
						}
					}
					case u.j: {
						const {
							subredditId: n,
							isEnabled: s
						} = t.payload, r = {
							...e[n].displaySettings,
							isEnabled: s
						};
						return {
							...e,
							[n]: {
								...e[n],
								displaySettings: r
							}
						}
					}
					case u.d: {
						const {
							subredditId: s,
							canAssignOwn: r
						} = t.payload, o = {
							...null === (n = e[s]) || void 0 === n ? void 0 : n.permissions,
							canAssignOwn: r
						};
						return {
							...e,
							[s]: {
								...e[s],
								permissions: o
							}
						}
					}
					case u.q: {
						const n = t.payload,
							r = e[n.subredditId],
							o = null === (s = e[n.subredditId]) || void 0 === s ? void 0 : s.templates,
							i = null === (p = e[n.subredditId]) || void 0 === p ? void 0 : p.templateIds,
							a = (null === (b = n.template) || void 0 === b ? void 0 : b.id) || (null === (f = n.template) || void 0 === f ? void 0 : f.templateId);
						if (!a) return;
						const d = {
								...o,
								[a]: n.template
							},
							c = [...i];
						return c.includes(a) || c.push(a), {
							...e,
							[n.subredditId]: {
								...r,
								templates: d,
								templateIds: c
							}
						}
					}
					case u.g: {
						const n = t.payload,
							s = e[n.subredditId],
							o = e[n.subredditId].templates,
							i = e[n.subredditId].templateIds,
							a = r()(o, n.templateId),
							d = i.filter(e => e !== n.templateId);
						return {
							...e,
							[n.subredditId]: {
								...s,
								templates: {
									...a
								},
								templateIds: d
							}
						}
					}
					case u.m:
					case u.l: {
						const n = t.payload,
							s = e[n.subredditId];
						return {
							...e,
							[n.subredditId]: {
								...s,
								templateIds: n.templateIds
							}
						}
					}
					case u.r: {
						const {
							subredditId: n,
							templateIds: s,
							templates: r
						} = t.payload, o = e[n];
						return {
							...e,
							[n]: {
								...o,
								templates: r,
								templateIds: s
							}
						}
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/pages/comments/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/ads/constants.ts");
			const o = [];
			var i = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.u:
							return t.payload;
						case r.v:
						default:
							return e
					}
				},
				a = n("./src/reddit/actions/pages/constants.ts");
			const d = {};
			var c = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : d,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a.d:
					case a.b:
					case a.h:
					case a.f: {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: null
						}
					}
					case a.a:
					case a.e: {
						const {
							key: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: s || {}
						}
					}
					default:
						return e
				}
			};
			const l = {};
			var u = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a.c:
					case a.g: {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: !0
						}
					}
					case a.i: {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: !1
						}
					}
					default:
						return e
				}
			};
			const m = {};
			var p = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case a.d:
						case a.h:
						case a.i: {
							const {
								key: n
							} = t.payload;
							return {
								...e,
								[n]: !0
							}
						}
						case a.b:
						case a.a:
						case a.f:
						case a.e: {
							const {
								key: n
							} = t.payload;
							return {
								...e,
								[n]: !1
							}
						}
						default:
							return e
					}
				},
				b = Object(s.c)({
					error: c,
					fullyLoaded: u,
					pending: p
				}),
				f = n("./src/reddit/actions/comment/constants.ts");
			const h = [];
			var g = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : h,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.I:
							return e.find(e => t.payload.id === e.id) ? [...e.filter(e => t.payload.id !== e.id)] : [...e, t.payload];
						case f.b:
							return [...e.filter(e => e.expiresAt > Date.now())];
						case f.w:
							return [...t.payload.comments];
						default:
							return e
					}
				},
				v = n("./src/reddit/actions/comment/websocket/constants.ts"),
				x = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/lodash/uniqBy.js")),
				E = n.n(x);

			function O(e) {
				return E()(e, "id").sort((e, t) => e.created - t.created)
			}

			function C(e, t) {
				return O([...t || [], e])
			}

			function A(e, t) {
				return t && t.length > 0 ? t.filter(t => t.id !== e) : []
			}

			function y(e, t) {
				const n = e.isStickied ? t && t.created || Math.round(Date.now() / 1e3) : e.created;
				return {
					id: e.id,
					created: n,
					stickied: e.isStickied,
					authorId: e.authorId
				}
			}

			function j(e, t) {
				return Object.values(e).map(e => y(e, t))
			}
			const I = {};
			var k = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : I,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case a.f:
						case f.y:
						case a.b: {
							const {
								comments: n,
								key: s
							} = t.payload, r = e[s] ? e[s] : [], o = j(n, r.find(e => e.stickied)), i = O([...r, ...o]);
							return {
								...e,
								[s]: [...i]
							}
						}
						case v.b:
						case v.c:
						case v.d: {
							const {
								comment: n,
								commentsPageKey: s
							} = t.payload;
							return {
								...e,
								[s]: C(y(n), e[s])
							}
						}
						case f.N:
						case f.M: {
							const {
								draftKey: n,
								comment: s,
								commentsPageKey: r
							} = t.payload;
							return {
								...e,
								[r]: A(n, C(y(s), e[r]))
							}
						}
						case f.L: {
							const {
								optimisticComment: n,
								commentsPageKey: s
							} = t.payload;
							return n ? {
								...e,
								[s]: C(y(n), e[s])
							} : e
						}
						case f.H: {
							const {
								commentId: n,
								commentsPageKey: s
							} = t.payload;
							return {
								...e,
								[s]: A(n, e[s])
							}
						}
						default:
							return e
					}
				},
				_ = n("./node_modules/lodash/mapValues.js"),
				S = n.n(_),
				w = n("./src/reddit/helpers/commentList/index.ts"),
				T = n("./src/reddit/models/Comment/index.ts");
			const P = {};

			function N(e) {
				const t = e;
				return S()(t, e => {
					let {
						depth: t,
						next: n,
						prev: s
					} = e;
					return {
						depth: t,
						next: n,
						prev: s
					}
				})
			}
			var D = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : P,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.y: {
						const {
							comments: n,
							commentLists: s,
							continueThreads: r,
							key: o,
							moreCommentsItem: i,
							moreComments: a
						} = t.payload, d = s[i.postId], c = e[o], l = {}, u = c[i.id];
						if (u && u.prev) {
							const {
								id: e
							} = u.prev;
							l[e] = {
								...c[e],
								next: d.head || u.next
							}
						}
						if (u && u.next) {
							const {
								id: e
							} = u.next;
							l[e] = {
								...c[e],
								prev: d.tail || u.prev
							}
						}
						if (d.head && d.tail) {
							const e = Object(w.c)({
									commentLink: d.head,
									commentsDict: n,
									moreCommentsDict: a,
									continueThreadDict: r
								}),
								t = Object(w.c)({
									commentLink: d.tail,
									commentsDict: n,
									moreCommentsDict: a,
									continueThreadDict: r
								});
							u && (e.prev = u.prev, t.next = u.next)
						}
						return {
							...e,
							[o]: {
								...e[o],
								...N(n),
								...N(r),
								...N(a),
								...l
							}
						}
					}
					case a.b:
					case a.f: {
						const {
							comments: n,
							continueThreads: s,
							key: r,
							moreComments: o
						} = t.payload;
						return {
							...e,
							[r]: {
								...e[r],
								...N(n),
								...N(s),
								...N(o)
							}
						}
					}
					case v.b:
					case f.N: {
						const {
							comment: n,
							commentsPageKey: s,
							headCommentId: r
						} = t.payload, o = e[s], i = {};
						let a = null;
						return r && (i[r] = {
							...o[r],
							prev: Object(T.i)(n.id)
						}, a = Object(T.i)(r)), {
							...e,
							[s]: {
								...e[s],
								...i,
								[n.id]: {
									depth: 0,
									next: a,
									prev: null
								}
							}
						}
					}
					case f.M: {
						const {
							comment: n,
							commentsPageKey: s,
							parentCommentId: r,
							depth: o
						} = t.payload, i = e[s], a = {};
						let d = null;
						if (!i[r]) return e;
						const c = i[r].next;
						return c && (a[c.id] = {
							...i[c.id],
							prev: Object(T.i)(n.id)
						}, d = c), a[r] = {
							...i[r],
							next: Object(T.i)(n.id)
						}, {
							...e,
							[s]: {
								...e[s],
								...a,
								[n.id]: {
									depth: o,
									next: d,
									prev: Object(T.i)(r)
								}
							}
						}
					}
					default:
						return e
				}
			};
			const M = {};
			var R = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : M,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case v.b:
					case v.c:
					case f.N: {
						const {
							comment: n,
							commentsPageKey: s
						} = t.payload;
						return {
							...e,
							[s]: n.id
						}
					}
					case a.b:
					case a.f: {
						const {
							commentLists: n,
							key: s,
							postId: r
						} = t.payload;
						return {
							...e,
							[s]: n[r] && n[r].head ? n[r].head.id : null
						}
					}
					case a.i: {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: null
						}
					}
					default:
						return e
				}
			};
			const L = {};
			var B = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : L,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a.d:
					case a.b:
					case a.c:
					case a.h: {
						const {
							key: n,
							postId: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					case f.N: {
						const {
							parentId: n,
							commentsPageKey: s
						} = t.payload;
						return e[s] ? e : {
							...e,
							[s]: n
						}
					}
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				api: b,
				followed: g,
				keyToChatCommentLinks: k,
				keyToCommentThreadLinkSets: D,
				keyToHeadCommentId: R,
				keyToPostId: B,
				ads: i
			})
		},
		"./src/reddit/reducers/pages/modHub/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/subredditModeration/constants.ts");
			var o = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.g:
						case r.f:
							return null;
						case r.e:
							return t.payload;
						default:
							return e
					}
				},
				i = n("./src/reddit/models/SubredditModeration/index.ts");
			const a = {};
			var d = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.g: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(i.e)(n, s);
							return {
								...e,
								[r]: !0
							}
						}
						case r.f:
						case r.e: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(i.e)(n, s);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				c = Object(s.c)({
					error: o,
					pending: d
				});
			const l = {};
			var u = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.f: {
						const {
							fetchedToken: n,
							subredditId: s
						} = t.payload, r = Object(i.e)(s, n);
						return {
							...e,
							[r]: !0
						}
					}
					default:
						return e
				}
			};
			const m = {};
			var p = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.f: {
							const {
								subredditId: e,
								after: n
							} = t.payload;
							return {
								[e]: n
							}
						}
						default:
							return e
					}
				},
				b = n("./node_modules/icepick/icepick.js");
			const f = {};
			var h = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : f,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.d:
					case r.f: {
						const {
							subredditId: n,
							approvedSubmitters: s
						} = t.payload, r = {
							[n]: s
						};
						return Object(b.merge)(e, r)
					}
					case r.k: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(b.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			var g = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.j:
					case r.i:
						return null;
					case r.h:
						return t.payload;
					default:
						return e
				}
			};
			var v = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.j:
							return !0;
						case r.i:
						case r.h:
							return !1;
						default:
							return e
					}
				},
				x = Object(s.c)({
					error: g,
					pending: v
				});
			var E = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.j:
							return null;
						case r.i: {
							const e = t.payload.approvedSubmitterIds[0];
							return e ? t.payload.approvedSubmitters[e] : null
						}
						default:
							return e
					}
				},
				O = Object(s.c)({
					api: x,
					result: E
				});
			const C = {};
			var A = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : C,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.f: {
							const {
								subredditId: n,
								approvedSubmitterIds: s
							} = t.payload;
							return e[n] ? {
								...e,
								[n]: [...e[n], ...s]
							} : {
								...e,
								[n]: s
							}
						}
						case r.k: {
							const {
								subredditId: n,
								userId: s
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== s)
							}
						}
						case r.d: {
							const {
								subredditId: n,
								approvedSubmitterIds: s
							} = t.payload, r = s[0];
							return r && e[n] && -1 === e[n].indexOf(r) ? {
								[n]: [r, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				y = Object(s.c)({
					api: c,
					fetchedTokens: u,
					loadMore: p,
					models: h,
					search: O,
					userOrder: A
				});
			var j = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.n:
					case r.m:
						return null;
					case r.l:
						return t.payload;
					default:
						return e
				}
			};
			const I = {};
			var k = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : I,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.n: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(i.f)(n, s);
							return {
								...e,
								[r]: !0
							}
						}
						case r.m:
						case r.l: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(i.f)(n, s);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				_ = Object(s.c)({
					error: j,
					pending: k
				});
			const S = {};
			var w = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : S,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.m: {
						const {
							fetchedToken: n,
							subredditId: s
						} = t.payload, r = Object(i.f)(s, n);
						return {
							...e,
							[r]: !0
						}
					}
					default:
						return e
				}
			};
			const T = {};
			var P = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : T,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.m: {
						const {
							subredditId: e,
							loadMoreToken: n
						} = t.payload;
						return {
							[e]: n
						}
					}
					default:
						return e
				}
			};
			const N = {};
			var D = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : N,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.m: {
							const {
								subredditId: n,
								approvedTalkHosts: s,
								forceRefresh: r
							} = t.payload, o = {
								[n]: [...r ? [] : e[n] || [], ...s]
							};
							return Object(b.merge)(e, o)
						}
						case r.o: {
							const {
								subredditId: n,
								userId: s
							} = t.payload, r = {
								[n]: e[n].filter(e => e.redditor.id !== s)
							};
							return Object(b.merge)(e, r)
						}
						default:
							return e
					}
				},
				M = Object(s.c)({
					api: _,
					fetchedTokens: w,
					loadMore: P,
					models: D
				}),
				R = n("./src/reddit/actions/grantUserFlair/constants.ts");
			var L = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case R.g:
					case R.i:
						return null;
					case R.f:
						return t.payload;
					default:
						return e
				}
			};
			var B = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case R.i:
							return !0;
						case R.g:
						case R.f:
							return !1;
						default:
							return e
					}
				},
				F = Object(s.c)({
					error: L,
					pending: B
				}),
				U = n("./node_modules/lodash/merge.js"),
				H = n.n(U),
				G = n("./node_modules/lodash/omit.js"),
				Q = n.n(G);
			const q = {};
			var W = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : q,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case R.g:
					case R.k: {
						const {
							subredditId: n,
							flairedUsers: s
						} = t.payload;
						return H()({
							...e
						}, {
							[n]: s
						})
					}
					case R.c: {
						const {
							subredditId: n,
							userName: s
						} = t.payload, r = Q()(e[n], s);
						return {
							...e,
							[n]: r
						}
					}
					case R.a:
					case R.b:
					case R.h:
						const {
							subredditId: n, userName: s, applied: r
						} = t.payload;
						return r ? {
							...e,
							[n]: {
								...e[n],
								[s]: r
							}
						} : e;
					default:
						return e
				}
			};
			const z = {};
			var V = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : z,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case R.g: {
						const {
							key: n,
							pageInfo: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					default:
						return e
				}
			};
			var K = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case R.l:
					case R.k:
						return null;
					case R.j:
						return t.payload;
					default:
						return e
				}
			};
			var Y = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case R.l:
							return !0;
						case R.k:
						case R.j:
							return !1;
						default:
							return e
					}
				},
				J = Object(s.c)({
					error: K,
					pending: Y
				});
			var X = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case R.k: {
							const {
								searchResult: e
							} = t.payload;
							return e
						}
						case R.c: {
							const {
								userName: n
							} = t.payload;
							return e === n ? null : e
						}
						default:
							return e
					}
				},
				Z = Object(s.c)({
					api: J,
					result: X
				});
			const $ = {};
			var ee = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case R.g: {
							const {
								key: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						case R.a: {
							const {
								key: n,
								userName: s
							} = t.payload;
							if (!n) return e;
							if (!e[n].includes(s)) {
								const t = [...e[n], s];
								return {
									...e,
									[n]: t
								}
							}
							return e
						}
						case R.c: {
							const {
								userName: n
							} = t.payload, s = {};
							for (const t in e) s[t] = e[t].filter(e => e !== n);
							return s
						}
						default:
							return e
					}
				},
				te = Object(s.c)({
					api: F,
					models: W,
					pageInfo: V,
					search: Z,
					userOrder: ee
				}),
				ne = n("./src/reddit/actions/moderationLog/constants.ts");
			const se = {};
			var re = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : se,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.b: {
						const {
							normalizedCategories: n
						} = t.payload;
						return Object(b.merge)(e, n)
					}
					default:
						return e
				}
			};
			const oe = {};
			var ie = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oe,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							actionIds: n,
							key: s,
							subredditId: r
						} = t.payload;
						return {
							...e,
							[r]: {
								...e[r] || {},
								[s]: n
							}
						}
					}
					default:
						return e
				}
			};
			const ae = {};
			var de = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ae,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.c: {
							const {
								normalizedModerationLog: n,
								subredditId: s
							} = t.payload, r = {};
							n.forEach(e => {
								r[e.id] = e
							});
							const o = {
								[s]: r
							};
							return H()({
								...e
							}, o)
						}
						default:
							return e
					}
				},
				ce = Object(s.c)({
					itemOrder: ie,
					models: de
				});
			var le = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							approximateCount: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			var ue = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							endCursor: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			const me = {};
			var pe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : me,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							hasNextPage: n,
							subredditId: s
						} = t.payload;
						return {
							...e,
							[s]: n
						}
					}
					default:
						return e
				}
			};
			const be = {};
			var fe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : be,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							hasPreviousPage: n,
							subredditId: s
						} = t.payload;
						return {
							...e,
							[s]: n
						}
					}
					default:
						return e
				}
			};
			var he = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							subredditId: n,
							insightsData: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					default:
						return e
				}
			};
			const ge = [];
			var ve = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ge,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.a: {
						const {
							normalizedModerators: n,
							subredditId: s
						} = t.payload;
						return {
							...e,
							[s]: n
						}
					}
					default:
						return e
				}
			};
			var xe = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.c: {
							const {
								startCursor: e
							} = t.payload;
							return e
						}
						default:
							return e
					}
				},
				Ee = Object(s.c)({
					actionCategories: re,
					actions: ce,
					approximateCount: le,
					endCursor: ue,
					hasNextPage: pe,
					hasPreviousPage: fe,
					moderators: ve,
					startCursor: xe,
					insightsEntrypoint: he
				});
			const Oe = {};
			var Ce = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Oe,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.O:
					case r.y: {
						const {
							subredditId: n,
							moderators: s
						} = t.payload.response || t.payload, r = {
							[n]: s
						};
						return Object(b.merge)(e, r)
					}
					case r.C: {
						const {
							subredditId: n,
							userId: s,
							permissions: r
						} = t.payload;
						return Object(b.setIn)(e, [n, s, "modPermissions"], r)
					}
					case r.jb: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(b.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			const Ae = {};
			var ye = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ae,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.z:
					case r.y: {
						const {
							key: n,
							subredditId: s
						} = t.payload;
						return s ? {
							...e,
							[n]: null
						} : e
					}
					case r.x: {
						const {
							error: n,
							key: s,
							subredditId: r
						} = t.payload;
						return r ? {
							...e,
							[s]: n
						} : e
					}
					default:
						return e
				}
			};
			const je = {};
			var Ie = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : je,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.x:
						case r.y: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? {
								...e,
								[s]: !1
							} : e
						}
						case r.z: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? {
								...e,
								[s]: !0
							} : e
						}
						default:
							return e
					}
				},
				ke = Object(s.c)({
					error: ye,
					pending: Ie
				});
			const _e = {};
			var Se = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _e,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.y: {
							const {
								subredditId: n,
								response: s,
								key: r
							} = t.payload;
							return Object(b.setIn)(e, [n, r], s.moderatorIds)
						}
						case r.jb: {
							const {
								subredditId: n,
								userId: s,
								key: r
							} = t.payload, o = e[n][r].filter(e => e !== s);
							return Object(b.setIn)(e, [n, r], o)
						}
						default:
							return e
					}
				},
				we = Object(s.c)({
					data: Se,
					api: ke
				});
			var Te = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.F:
					case r.E:
						return null;
					case r.D:
						return t.payload;
					default:
						return e
				}
			};
			var Pe = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.E:
						case r.D:
							return !1;
						case r.F:
							return !0;
						default:
							return e
					}
				},
				Ne = Object(s.c)({
					error: Te,
					pending: Pe
				});
			const De = {};
			var Me = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : De,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.E: {
						const {
							subredditId: n,
							moderators: s
						} = t.payload;
						return Object(b.set)(e, n, s)
					}
					case r.gb: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(b.unsetIn)(e, [n, s])
					}
					case r.c: {
						const n = t.payload,
							{
								subredditId: s,
								moderators: r
							} = n,
							o = {
								[s]: r
							};
						return Object(b.merge)(e, o)
					}
					default:
						return e
				}
			};
			const Re = {};
			var Le = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Re,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.E: {
							const {
								subredditId: n,
								moderatorIds: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						case r.gb: {
							const {
								subredditId: n,
								userId: s
							} = t.payload, r = e[n].filter(e => e !== s);
							return {
								...e,
								[n]: r
							}
						}
						case r.c: {
							const n = t.payload,
								{
									subredditId: s,
									moderatorIds: r
								} = n,
								o = [...e[s] || [], ...r];
							return {
								...e,
								[s]: o
							}
						}
						default:
							return e
					}
				},
				Be = Object(s.c)({
					api: Ne,
					models: Me,
					userOrder: Le
				});
			const Fe = {};
			var Ue = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Fe,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.L: {
						const {
							subredditId: n,
							response: s
						} = t.payload, {
							invitePending: r
						} = s, o = {
							[n]: r
						};
						return Object(b.merge)(e, o)
					}
					case r.I:
					case r.J: {
						const {
							subredditId: n
						} = t.payload;
						return Object(b.unset)(e, n)
					}
					default:
						return e
				}
			};
			const He = {};
			var Ge = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : He,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.y: {
						const {
							response: e
						} = t.payload;
						return {
							[e.subredditId]: {
								after: e.after,
								before: e.before
							}
						}
					}
					default:
						return e
				}
			};
			const Qe = {};
			var qe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qe,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.L: {
						const {
							response: e
						} = t.payload;
						return {
							[e.subredditId]: {
								after: e.after,
								before: e.before
							}
						}
					}
					default:
						return e
				}
			};
			const We = {};
			var ze = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : We,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.L: {
						const {
							response: n
						} = t.payload, s = {
							[n.subredditId]: n.moderators
						};
						return Object(b.merge)({
							...e
						}, s)
					}
					case r.C: {
						const n = t.payload,
							{
								subredditId: s,
								userId: r,
								permissions: o
							} = n;
						return e[s] && e[s][r] ? Object(b.setIn)(e, [s, r, "modPermissions"], o) : e
					}
					default:
						return e
				}
			};
			var Ve = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.P:
					case r.O:
						return null;
					case r.N:
						return t.payload;
					default:
						return e
				}
			};
			var Ke = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.P:
							return !0;
						case r.O:
						case r.N:
							return !1;
						default:
							return e
					}
				},
				Ye = Object(s.c)({
					error: Ve,
					pending: Ke
				}),
				Je = n("./node_modules/lodash/isEqual.js"),
				Xe = n.n(Je);
			var Ze = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.P:
						case r.N:
						case r.jb:
							return null;
						case r.O: {
							const e = t.payload.moderatorIds[0];
							return e ? t.payload.moderators[e] : null
						}
						case r.C: {
							const {
								userId: n,
								permissions: s
							} = t.payload;
							return e && e.id === n && !Xe()(e.modPermissions, s) ? {
								...e,
								modPermissions: s
							} : e
						}
						default:
							return e
					}
				},
				$e = Object(s.c)({
					api: Ye,
					result: Ze
				});
			const et = {};
			var tt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : et,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.M:
					case r.L: {
						const {
							subredditId: n,
							key: s
						} = t.payload;
						return n ? {
							...e,
							[s]: null
						} : e
					}
					case r.K: {
						const {
							error: n,
							subredditId: s,
							key: r
						} = t.payload;
						return s ? {
							...e,
							[r]: n
						} : e
					}
					default:
						return e
				}
			};
			const nt = {};
			var st = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.K:
						case r.L: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? {
								...e,
								[s]: !1
							} : e
						}
						case r.M: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? {
								...e,
								[s]: !0
							} : e
						}
						default:
							return e
					}
				},
				rt = Object(s.c)({
					error: tt,
					pending: st
				});
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const ot = {};
			var it = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ot,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.L: {
							const {
								response: n,
								subredditId: s,
								key: r
							} = t.payload, {
								moderatorIds: o
							} = n;
							return Object(b.merge)(e, {
								[s]: {
									[r]: o
								}
							})
						}
						case r.jb: {
							const {
								subredditId: n,
								userId: s
							} = t.payload, r = {
								...e[n]
							};
							return Object.keys(e[n]).forEach(t => {
								const o = e[n][t].filter(e => e !== s);
								r[t] = o
							}), Object(b.set)(e, n, r)
						}
						default:
							return e
					}
				},
				at = Object(s.c)({
					data: it,
					api: rt
				}),
				dt = Object(s.c)({
					editableModerators: Ce,
					editableUserOrder: we,
					invitedModerators: Be,
					invitePending: Ue,
					loadMoreModerators: qe,
					loadMoreEditableModerators: Ge,
					models: ze,
					search: $e,
					userOrder: at
				}),
				ct = n("./src/reddit/actions/bulkActions/constants.ts");
			var lt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ct.c:
						case ct.b:
							return null;
						case ct.a:
							return t.payload;
						default:
							return e
					}
				},
				ut = n("./src/reddit/actions/modQueue/constants.ts");
			var mt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ct.c:
							return !0;
						case ct.b:
						case ct.a:
						case ut.x:
						case ut.w:
							return !1;
						default:
							return e
					}
				},
				pt = Object(s.c)({
					error: lt,
					pending: mt
				});
			const bt = {};
			var ft = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.a: {
							const {
								ids: n
							} = t.payload, s = {};
							return n.forEach(e => s[e] = !0), {
								...e,
								...s
							}
						}
						case ut.d: {
							const {
								ids: n
							} = t.payload;
							return Q()(e, n)
						}
						case ut.c: {
							const {
								ids: e
							} = t.payload, n = {};
							return e.forEach(e => n[e] = !0), n
						}
						default:
							return e
					}
				},
				ht = n("./src/reddit/models/ModQueue/index.ts");
			const gt = {};
			var vt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ct.b: {
							const {
								operation: e,
								ids: n
							} = t.payload;
							return "approve" === e ? gt : {
								[ht.c[e]]: n
							}
						}
						default:
							return e
					}
				},
				xt = Object(s.c)({
					api: pt,
					selectedItems: ft,
					undoLastAction: vt
				});
			var Et = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.g:
					case ut.f:
						return null;
					case ut.e:
						return t.payload;
					default:
						return e
				}
			};
			var Ot = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.g:
							return !0;
						case ut.f:
						case ut.e:
							return !1;
						default:
							return e
					}
				},
				Ct = Object(s.c)({
					error: Et,
					pending: Ot
				});
			const At = {};
			var yt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : At,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.f: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const jt = {};
			var It = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.f: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				kt = Object(s.c)({
					api: Ct,
					itemOrder: yt,
					loadMore: It
				}),
				_t = n("./src/reddit/actions/pages/modListing/constants.ts");
			var St = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case _t.e: {
						const n = t.payload,
							{
								moderatingSubreddits: s
							} = n;
						return s ? null : e
					}
					case ut.i:
					case ut.f:
					case ut.r:
					case ut.u:
					case ut.A: {
						const {
							response: e
						} = t.payload, {
							moderatedAfter: n
						} = e;
						return n
					}
					case ut.n: {
						const e = t.payload,
							{
								moderatedAfter: n
							} = e;
						return n
					}
					default:
						return e
				}
			};
			const wt = [];
			var Tt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.i:
					case ut.f:
					case ut.r:
					case ut.u:
					case ut.A: {
						const {
							response: e
						} = t.payload, {
							listingOrder: n
						} = e;
						return n
					}
					case ut.n: {
						const n = t.payload,
							{
								listingOrder: s
							} = n;
						return [...e, ...s]
					}
					case _t.e: {
						const n = t.payload,
							{
								listingOrder: s
							} = n;
						return s || e
					}
					default:
						return e
				}
			};
			var Pt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.b:
						return !0;
					default:
						return e
				}
			};
			var Nt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.n:
							return !0;
						case ut.b:
							return !1;
						default:
							return e
					}
				},
				Dt = Object(s.c)({
					after: St,
					data: Tt,
					loaded: Pt,
					pending: Nt
				});
			var Mt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.j:
					case ut.i:
						return null;
					case ut.h:
						return t.payload;
					default:
						return e
				}
			};
			var Rt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.j:
							return !0;
						case ut.i:
						case ut.h:
							return !1;
						default:
							return e
					}
				},
				Lt = Object(s.c)({
					error: Mt,
					pending: Rt
				});
			const Bt = {};
			var Ft = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.i: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const Ut = {};
			var Ht = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ut,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.i: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				Gt = Object(s.c)({
					api: Lt,
					itemOrder: Ft,
					loadMore: Ht
				});
			var Qt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.s:
					case ut.r:
						return null;
					case ut.q:
						return t.payload;
					default:
						return e
				}
			};
			var qt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.s:
							return !0;
						case ut.r:
						case ut.q:
							return !1;
						default:
							return e
					}
				},
				Wt = Object(s.c)({
					error: Qt,
					pending: qt
				});
			const zt = {};
			var Vt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.r: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const Kt = {};
			var Yt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Kt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.r: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				Jt = Object(s.c)({
					api: Wt,
					itemOrder: Vt,
					loadMore: Yt
				});
			var Xt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.v:
					case ut.u:
						return null;
					case ut.t:
						return t.payload;
					default:
						return e
				}
			};
			var Zt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.v:
							return !0;
						case ut.u:
						case ut.t:
							return !1;
						default:
							return e
					}
				},
				$t = Object(s.c)({
					error: Xt,
					pending: Zt
				});
			const en = {};
			var tn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : en,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.u: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const nn = {};
			var sn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.u: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				rn = Object(s.c)({
					api: $t,
					itemOrder: tn,
					loadMore: sn
				});
			var on = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.B:
					case ut.A:
						return null;
					case ut.z:
						return t.payload;
					default:
						return e
				}
			};
			var an = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.B:
							return !0;
						case ut.A:
						case ut.z:
							return !1;
						default:
							return e
					}
				},
				dn = Object(s.c)({
					error: on,
					pending: an
				});
			const cn = {};
			var ln = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ut.A: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const un = {};
			var mn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : un,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ut.A: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				pn = Object(s.c)({
					api: dn,
					itemOrder: ln,
					loadMore: mn
				}),
				bn = Object(s.c)({
					bulkAction: xt,
					edited: kt,
					moderatedCommunitiesOrder: Dt,
					modqueue: Gt,
					reports: Jt,
					spam: rn,
					unmoderated: pn
				});
			var fn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.Y:
					case r.W:
						return null;
					case r.V:
						return t.payload;
					default:
						return e
				}
			};
			const hn = {};
			var gn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.Y: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(i.e)(n, s);
							return {
								...e,
								[r]: !0
							}
						}
						case r.W:
						case r.V: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(i.e)(n, s);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				vn = Object(s.c)({
					error: fn,
					pending: gn
				});
			const xn = {};
			var En = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.W: {
							const {
								fetchedToken: n,
								subredditId: s
							} = t.payload, r = Object(i.e)(s, n);
							return {
								...e,
								[r]: !0
							}
						}
						default:
							return e
					}
				},
				On = n("./src/reddit/actions/inContextModeration.ts");
			var Cn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case On.b:
						return t.payload;
					default:
						return e
				}
			};
			const An = {};
			var yn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : An,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.W: {
						const {
							subredditId: e,
							after: n
						} = t.payload;
						return {
							[e]: n
						}
					}
					default:
						return e
				}
			};
			const jn = {};
			var In = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.X:
					case r.W: {
						const {
							subredditId: n,
							mutedUsers: s
						} = t.payload, r = {
							[n]: s
						};
						return Object(b.merge)(e, r)
					}
					case r.cb: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(b.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			var kn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.bb:
					case r.ab:
						return null;
					case r.Z:
						return t.payload;
					default:
						return e
				}
			};
			var _n = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.bb:
							return !0;
						case r.ab:
						case r.Z:
							return !1;
						default:
							return e
					}
				},
				Sn = Object(s.c)({
					error: kn,
					pending: _n
				});
			var wn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.bb:
						case r.Z:
							return null;
						case r.ab: {
							const e = t.payload.mutedUserIds[0];
							return e ? t.payload.mutedUsers[e] : null
						}
						default:
							return e
					}
				},
				Tn = Object(s.c)({
					api: Sn,
					result: wn
				});
			const Pn = {};
			var Nn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.W: {
							const {
								subredditId: n,
								mutedUserIds: s
							} = t.payload;
							return e[n] ? {
								...e,
								[n]: [...e[n], ...s]
							} : {
								...e,
								[n]: s
							}
						}
						case r.cb: {
							const {
								subredditId: n,
								userId: s
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== s)
							}
						}
						case r.X: {
							const {
								subredditId: n,
								mutedUserIds: s
							} = t.payload, r = s[0];
							return r && e[n] && -1 === e[n].indexOf(r) ? {
								[n]: [r, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				Dn = Object(s.c)({
					api: vn,
					fetchedTokens: En,
					inContext: Cn,
					loadMore: yn,
					models: In,
					search: Tn,
					userOrder: Nn
				});
			t.a = Object(s.c)({
				approvedSubmitters: y,
				approvedTalkHosts: M,
				flairedUsers: te,
				moderationLog: Ee,
				moderators: dt,
				modQueue: bn,
				muted: Dn
			})
		},
		"./src/reddit/reducers/tags/selected/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r = n("./node_modules/lodash/uniqWith.js"),
				o = n.n(r),
				i = n("./node_modules/lodash/values.js"),
				a = n.n(i),
				d = n("./src/reddit/actions/tags/constants.ts"),
				c = n("./src/reddit/models/Option/index.ts"),
				l = n("./src/reddit/models/Tags/index.ts");
			! function(e) {
				e.ADD = "ADD", e.REMOVE = "REMOVE"
			}(s || (s = {}));
			const u = {
				selectedPrimaryTagId: {},
				selectedOptions: {},
				selectedSuggestedOptions: {},
				deselectedOptions: {},
				deselectedSuggestedOptions: {},
				inputByItemId: {},
				suggestedInputByItemId: {}
			};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : u,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.w:
					case d.r: {
						const {
							subredditId: n,
							itemTags: s,
							suggestedItemTags: r,
							primaryTag: i
						} = t.payload, d = o()([...(e.selectedOptions[n] || []).map(e => {
							if (!e.id) {
								const t = a()(s[n] || {}).find(t => e.displayText.toLowerCase().trim() === t.tag.text.toLowerCase().trim());
								if (t) return {
									...Object(l.e)(t, !0),
									action: null
								}
							}
							return e
						}), ...a()(s[n] || {}).map(e => ({
							...Object(l.e)(e, !0),
							action: null
						}))], c.a);
						let u = e.selectedPrimaryTagId;
						return i && (u = {
							...u,
							[n]: i.tag.id
						}), {
							...e,
							selectedOptions: {
								...e.selectedOptions,
								[n]: d.map(e => ({
									...e,
									action: e.id ? null : e.action
								}))
							},
							selectedSuggestedOptions: {
								...e.selectedSuggestedOptions,
								[n]: a()(r[n] || {}).map(e => ({
									...Object(l.e)(e, !0),
									action: null
								}))
							},
							deselectedOptions: {
								...e.deselectedOptions,
								[n]: []
							},
							selectedPrimaryTagId: u
						}
					}
					case d.D:
					case d.z: {
						const {
							subredditId: n,
							option: r
						} = t.payload, i = t.type === d.z ? "selectedOptions" : "selectedSuggestedOptions", a = t.type === d.z ? "deselectedOptions" : "deselectedSuggestedOptions", l = (e[a][n] || []).slice(), u = l.findIndex(e => Object(c.a)(e, r));
						let m = s.ADD;
						return u > -1 && (m = null, l.splice(u, 1)), {
							...e,
							[i]: {
								...e[i],
								[n]: o()([...e[i][n] || [], {
									...r,
									action: m
								}], c.a)
							},
							[a]: {
								...e[a],
								[n]: l
							}
						}
					}
					case d.C:
					case d.y: {
						const {
							subredditId: n,
							option: r
						} = t.payload, o = t.type === d.y ? "selectedOptions" : "selectedSuggestedOptions", i = t.type === d.y ? "deselectedOptions" : "deselectedSuggestedOptions", a = (e[i][n] || []).slice(), l = (e[o][n] || []).slice(), u = l.findIndex(e => Object(c.a)(e, r));
						return u > -1 && (null === l[u].action && a.push({
							...l[u],
							action: s.REMOVE
						}), l.splice(u, 1)), {
							...e,
							[o]: {
								...e[o],
								[n]: l
							},
							[i]: {
								...e[i],
								[n]: a
							}
						}
					}
					case d.A: {
						const {
							itemTagsState: n
						} = t.payload, s = Object.keys(n);
						if (!s.length) return e;
						const r = {
								selectedOptions: {},
								deselectedOptions: {},
								inputByItemId: {}
							},
							o = s.reduce((e, t) => (e.selectedOptions[t] = a()(n[t]).map(e => ({
								...Object(l.e)(e, !0),
								action: null
							})), e.deselectedOptions[t] = [], e.inputByItemId[t] = "", e), r);
						return {
							...e,
							inputByItemId: {
								...e.inputByItemId,
								...o.inputByItemId
							},
							selectedOptions: {
								...e.selectedOptions,
								...o.selectedOptions
							},
							deselectedOptions: {
								...e.deselectedOptions,
								...o.deselectedOptions
							}
						}
					}
					case d.B:
					case d.x: {
						const {
							subredditId: n,
							input: s
						} = t.payload, r = t.type === d.x ? "inputByItemId" : "suggestedInputByItemId";
						return {
							...e,
							[r]: {
								...e[r],
								[n]: s
							}
						}
					}
					case d.i:
					case d.h: {
						const {
							subredditId: n,
							primaryTagId: s
						} = t.payload;
						if (!s || !n) return e;
						const r = {
								...e,
								selectedPrimaryTagId: {
									...e.selectedPrimaryTagId,
									[n]: s
								}
							},
							o = e.selectedOptions[n];
						if (o) {
							const t = o.findIndex(e => e.id === s),
								i = [...o];
							return t >= 0 && i.splice(t, 1), {
								...r,
								selectedOptions: {
									...e.selectedOptions,
									[n]: i
								}
							}
						}
						return r
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/user/prefs/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return G
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r = n("./node_modules/lodash/isEqual.js"),
				o = n.n(r),
				i = n("./node_modules/lodash/merge.js"),
				a = n.n(i),
				d = n("./node_modules/lodash/pick.js"),
				c = n.n(d),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/actions/comment/constants.ts"),
				m = n("./src/reddit/actions/contentGate.ts"),
				p = n("./src/reddit/actions/frontpage/constants.ts"),
				b = n("./src/reddit/actions/header.ts"),
				f = n("./src/reddit/actions/modQueue/constants.ts"),
				h = n("./src/reddit/actions/pages/constants.ts"),
				g = n("./src/reddit/actions/pages/modListing/constants.ts"),
				v = n("./src/reddit/actions/pages/multireddit/constants.ts"),
				x = n("./src/reddit/actions/pages/postCreation.ts"),
				E = n("./src/reddit/actions/pages/postDraft.ts"),
				O = n("./src/reddit/actions/pages/profileComments/constants.ts"),
				C = n("./src/reddit/actions/pages/profileOverview/constants.ts"),
				A = n("./src/reddit/actions/pages/profilePosts.ts"),
				y = n("./src/reddit/actions/pages/search/index.ts"),
				j = n("./src/reddit/actions/pages/subreddit/index.ts"),
				I = n("./src/reddit/actions/pages/topic.ts"),
				k = n("./src/reddit/actions/postCreation/constants.ts"),
				_ = n("./src/reddit/actions/postDraft.ts"),
				S = n("./src/reddit/actions/preferences.ts"),
				w = n("./src/reddit/actions/redditEmbed.ts"),
				T = n("./src/reddit/actions/search.ts"),
				P = n("./src/reddit/actions/structuredStyles/constants.ts"),
				N = n("./src/reddit/actions/subreddit.ts"),
				D = n("./src/reddit/actions/users.ts"),
				M = n("./src/reddit/constants/postLayout.ts"),
				R = n("./src/reddit/constants/preferences.ts"),
				L = n("./src/reddit/constants/theme.ts"),
				B = n("./src/reddit/models/PostCreationForm/index.ts"),
				F = n("./src/reddit/models/PostDraft/index.ts"),
				U = n("./src/reddit/models/User/index.ts");
			! function(e) {
				e.Whitelisted = "whitelisted", e.Everyone = "everyone"
			}(s || (s = {}));
			const H = ["acceptPrivateMessages", "allowClickTracking", "autoplayVideo", "collapseReadMessages", "defaultCommentSort", "emailDigests", "emailUnreadMessages", "emailUnsubscribe", "enableFollowers", "feedRecommendationsEnabled", "geopopular", "hideAds", "hideFromRobots", "hideNSFW", "highlightComments", "ignoreSuggestedSort", "inBeta", "labelNSFW", "liveBarRecommendationsEnabled", "markMessagesRead", "nightmode", "over18", "sendWelcomeMessages", "showMessagesInInbox", "showNotifications", "showTwitter", "showUsernameMentionNotifications", "showActiveCommunities", "showPresence", ...R.a, "loginOtpEnabled"],
				G = {
					acceptPrivateMessages: void 0,
					activityRelevantAds: !0,
					allowClickTracking: !1,
					autoplayVideo: !0,
					collapsedTraySections: U.a,
					commentMode: B.i.RICH_TEXT,
					countryCode: "",
					badCommentAutocollapse: l.m.OFF,
					layout: M.d.Card,
					rememberCommunityLayout: !1,
					defaultCommentSort: l.v.CONFIDENCE,
					editorMode: B.i.RICH_TEXT,
					enableFollowers: !0,
					geopopular: void 0,
					globalTheme: L.a,
					hamburgerTray: void 0,
					hasSeenCustomizeFlyout: !0,
					hideNSFW: !0,
					ignoreSuggestedSort: !1,
					labelNSFW: !0,
					liveBarRecommendationsEnabled: !0,
					loginOtpEnabled: !1,
					markMessagesRead: !0,
					nightmode: !1,
					openPostInNewTab: !1,
					over18: !1,
					profileLayout: void 0,
					reduceAnimationsFromAwards: !1,
					searchOver18: !1,
					showActiveCommunities: !0,
					showPresence: !1,
					showTwitter: !1,
					sort: l.db.Hot,
					stylesEnabled: !0,
					subreddit: {},
					subscriptionsPinned: void 0,
					surveyLastSeenTime: void 0,
					thirdPartyDataPersonalizedAds: !0,
					thirdPartyPersonalizedAds: !0,
					thirdPartySiteDataPersonalizedAds: !0,
					thirdPartySiteDataPersonalizedContent: !0,
					showLocationBasedRecommendations: !0,
					topContentDismissalTime: 0,
					topContentTimesDismissed: 0,
					rememberCommunitySort: !1,
					useMarkdown: !1,
					gatedSubredditOptIn: !1,
					quarantineOptIn: !1
				},
				Q = {
					isContributorRequestTimestamp: 0,
					stylesEnabled: !0,
					layout: void 0,
					sort: void 0
				},
				q = (e, t) => {
					if (!t) return e;
					const n = c()({
							...t.account,
							...t
						}, H),
						s = t.subreddit,
						r = {
							...e.subreddit
						};
					Object.keys(s || {}).forEach(e => {
						r[e] = {
							...Q,
							...s && s[e]
						}
					});
					const i = {
						...e,
						...n,
						subreddit: r
					};
					if (i.useMarkdown !== e.useMarkdown) {
						const e = i.useMarkdown ? B.i.MARKDOWN : B.i.RICH_TEXT;
						i.editorMode = e, i.commentMode = e
					}
					return o()(i, e) ? e : i
				},
				W = (e, t, n) => q(e, {
					subreddit: {
						[t]: {
							...Q,
							...e.subreddit[t],
							...n
						}
					}
				});
			t.c = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : G,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case u.o:
					case u.v: {
						const {
							editorMode: n
						} = t.payload;
						return {
							...e,
							commentMode: n
						}
					}
					case k.s:
					case k.R: {
						const {
							editorMode: n
						} = t.payload;
						return {
							...e,
							editorMode: n
						}
					}
					case b.d:
						return {
							...e, subscriptionsPinned: !0
						};
					case b.e:
						return {
							...e, subscriptionsPinned: !1
						};
					case _.g: {
						const {
							kind: n
						} = t.payload;
						return {
							...e,
							editorMode: n === F.b.Markdown ? B.i.MARKDOWN : B.i.RICH_TEXT
						}
					}
					case S.h: {
						const {
							layout: n
						} = t.payload;
						return e.layout === n ? e : {
							...e,
							layout: n
						}
					}
					case S.o: {
						const {
							layout: n,
							subredditId: s
						} = t.payload;
						return W(e, s, {
							layout: n
						})
					}
					case S.f:
						return {
							...e, hasSeenCustomizeFlyout: !0
						};
					case S.m:
						return e.profileLayout === t.payload.profileLayout ? e : {
							...e,
							profileLayout: t.payload.profileLayout
						};
					case m.j:
						return {
							...e, over18: t.payload.over18
						};
					case T.h:
						return {
							...e, searchOver18: t.payload.searchOver18
						};
					case S.c:
						return void 0 !== t.payload ? {
							...e,
							autoplayVideo: t.payload.autoplayVideo
						} : e;
					case S.i:
						return void 0 !== t.payload ? {
							...e,
							nightmode: t.payload.nightmode
						} : e;
					case m.i:
						return {
							...e, gatedSubredditOptIn: t.payload
						};
					case m.k:
						return {
							...e, quarantineOptIn: t.payload
						};
					case S.q:
						if (void 0 !== t.payload) {
							const {
								topContentDismissalTime: n,
								topContentTimesDismissed: s
							} = t.payload;
							return {
								...e,
								topContentDismissalTime: n,
								topContentTimesDismissed: s
							}
						}
						return e;
					case P.d:
						return t.payload.isNightmodeOn ? {
							...e,
							nightmode: !1,
							nightmodeTempUpdated: !0
						} : e;
					case P.e:
						return t.payload.nightmodeTempUpdated ? {
							...e,
							nightmode: !0,
							nightmodeTempUpdated: !1
						} : e;
					case S.g:
						return void 0 !== t.payload ? {
							...e,
							hamburgerTray: t.payload.set
						} : {
							...e,
							hamburgerTray: !e.hamburgerTray
						};
					case S.d:
						return void 0 !== t.payload ? {
							...e,
							collapsedTraySections: a()({}, e.collapsedTraySections, t.payload)
						} : e;
					case m.b:
					case m.c:
					case m.l:
					case m.m:
					case m.h:
					case m.a:
					case m.n:
					case g.e:
					case g.h:
					case h.a:
					case h.e:
					case h.b:
					case h.f:
					case h.d:
					case h.h:
					case p.c:
					case j.SUBREDDIT_LOADED:
					case v.b:
					case v.a:
					case O.e:
					case C.e:
					case C.b:
					case A.PROFILE_POSTS_LOADED:
					case p.g:
					case N.i:
					case T.e:
					case w.b:
					case x.PAGE_LOADED:
					case E.PAGE_LOADED:
					case S.j:
					case S.b:
					case y.c:
					case S.a:
					case D.c:
					case I.TOPIC_DATA_LOADED:
						return t.payload && t.payload.preferences ? q(e, t.payload.preferences) : e;
					case S.p: {
						const {
							subredditId: n,
							prefs: s
						} = t.payload;
						return W(e, n, s)
					}
					case O.d:
					case C.d:
					case C.a:
					case A.PROFILE_POSTS_FAILED: {
						let n = e;
						if (t.payload && t.payload.account) {
							const {
								nightmode: s,
								showPresence: r
							} = t.payload.account;
							e.nightmode !== s && (n = {
								...n,
								nightmode: s
							}), e.showPresence !== r && (n = {
								...n,
								showPresence: r
							})
						}
						return n
					}
					case f.h:
					case f.j:
					case f.i:
					case f.g:
					case f.f:
					case f.s:
					case f.r:
					case f.u:
					case f.v:
					case f.B:
					case f.A:
						return t.payload && t.payload.response && t.payload.response.preferences ? q(e, t.payload.preferences) : e;
					case S.n: {
						const n = t.payload,
							{
								enableFollowers: s,
								showActiveCommunities: r
							} = n.additional;
						let o = e;
						return e.enableFollowers !== s && (o = {
							...o,
							enableFollowers: s
						}), e.showActiveCommunities !== r && (o = {
							...o,
							showActiveCommunities: r
						}), o
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/routes/postCreation/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/loadableAction/index.ts"),
				i = n("./src/reddit/routes/postCreation/constants.ts");
			const a = [i.b, i.c, i.a],
				d = Object(s.a)({
					resolved: {},
					chunkName: () => "PostCreation",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("vendors~CryptoHarbergerTaxManageModal~HarbergerTaxManageModal~ModerationPages~PostCreation~Settings~~f8934a85"), n.e("vendors~ChatMessageInput~CommentRichUnit~FlairEdit~MembershipPaywallPage~PostCreation~PostRichUnit~R~9deab1a0"), n.e("vendors~PostCreation~Subreddit"), n.e("vendors~PostCreation"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~FramedGild~GildModal~GovernanceReleaseNotesModal~Hap~a5d6a3b8"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~FramedGild~GildModal~GovernanceReleaseNotesModal~Hap~cb450973"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~Frontpage~GovernanceReleaseNotesModal~ModListing~Mod~e3d63e32"), n.e("CollectionCommentsPage~CommentsPage~EconTopAwardersModal~ModQueuePages~ModerationPages~PostCreation~~bca2b657"), n.e("CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~ModerationPages~PostCreation~Profile~9a5d9fab"), n.e("PostCreation")]).then(n.bind(null, "./src/reddit/pages/PostCreation/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/pages/PostCreation/index.tsx"
					}
				}),
				c = e => `/${e}/submit`,
				l = (e, t) => {
					return i.c.replace(/:subredditName/, e) + (t ? `?collection=${t}` : "")
				},
				u = e => i.a.replace(/:profileName/, e),
				m = {
					action: Object(o.a)(() => Promise.all([n.e("vendors~CryptoHarbergerTaxManageModal~HarbergerTaxManageModal~ModerationPages~PostCreation~Settings~~f8934a85"), n.e("vendors~ChatMessageInput~CommentRichUnit~FlairEdit~MembershipPaywallPage~PostCreation~PostRichUnit~R~9deab1a0"), n.e("vendors~PostCreation~Subreddit"), n.e("vendors~PostCreation"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~FramedGild~GildModal~GovernanceReleaseNotesModal~Hap~a5d6a3b8"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~FramedGild~GildModal~GovernanceReleaseNotesModal~Hap~cb450973"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~Frontpage~GovernanceReleaseNotesModal~ModListing~Mod~e3d63e32"), n.e("CollectionCommentsPage~CommentsPage~EconTopAwardersModal~ModQueuePages~ModerationPages~PostCreation~~bca2b657"), n.e("CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~ModerationPages~PostCreation~Profile~9a5d9fab"), n.e("PostCreation")]).then(n.bind(null, "./src/reddit/actions/pages/postCreation.ts")).then(e => e.postCreationPageRequested)),
					component: d,
					chunk: r.t.POST_CREATION,
					exact: !0,
					meta: {
						name: r.Tb.POST_CREATION
					},
					path: a,
					prefetches: [r.t.COMMENTS_PAGE]
				};
			t.a = m
		},
		"./src/reddit/selectors/adsSignals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => e.adsSignals
		},
		"./src/reddit/selectors/appBadges.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "h", (function() {
				return m
			})), n.d(t, "j", (function() {
				return p
			}));
			var s = n("./node_modules/reselect/es/index.js");
			const r = e => e.appBadges.badges,
				o = Object(s.a)(r, e => {
					var t;
					return (null === (t = e.chatUnreadMessages) || void 0 === t ? void 0 : t.count) || 0
				}),
				i = e => {
					var t;
					return (null === (t = e.appBadges.badges.chatV2UnreadMessages) || void 0 === t ? void 0 : t.count) || 0
				},
				a = Object(s.a)(r, e => e && e.chatRooms && e.chatRooms.count || 0),
				d = Object(s.a)(r, e => e && e.chatRoomMentions && e.chatRoomMentions.count || 0),
				c = Object(s.a)(o, r, (e, t) => {
					var n;
					return 0 === e && !!(null === (n = t.chatHasNewMessages) || void 0 === n ? void 0 : n.isShowing)
				}),
				l = Object(s.a)(r, e => e && e.activityTab && e.activityTab.count || 0),
				u = Object(s.a)(r, e => e && e.messageTab && e.messageTab.count || 0),
				m = Object(s.a)(l, u, (e, t) => e + t),
				p = Object(s.a)(o, m, (e, t) => e + t)
		},
		"./src/reddit/selectors/authorFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			const s = (e, t) => {
					let {
						post: n
					} = t;
					const s = n.belongsTo.id;
					if (!s) return null;
					const r = e.authorFlair.models[s];
					if (!r) return null;
					const o = n.author;
					return o && r[o] || null
				},
				r = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.authorFlair && e.authorFlair.inContext && e.authorFlair.inContext.username;
					if (!s) return null;
					if (!n) return null;
					const r = e.authorFlair.models[n];
					return r ? r[s] : null
				},
				o = e => e.authorFlair.inContext
		},
		"./src/reddit/selectors/avatar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/avatar/index.ts");
			Object(s.a)({
				features: {
					avatar: r.a
				}
			});
			const o = e => {
					var t, n;
					return null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.avatarUser
				},
				i = e => {
					var t, n;
					return null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.avatarUser.csrf_token
				},
				a = e => {
					var t, n;
					return (null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.randomAvatar) || null
				}
		},
		"./src/reddit/selectors/avatarMarketing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/avatar/index.ts"),
				o = n("./src/reddit/selectors/experiments/econ/simpleExperiment.ts");
			Object(s.a)({
				features: {
					avatar: r.a
				}
			});
			const i = e => {
					var t, n;
					return !!(null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.marketing)
				},
				a = e => {
					var t, n, s, r;
					const i = null === (s = null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.marketing) || void 0 === s ? void 0 : s.marketingEvent;
					if (!(null == i ? void 0 : i.active) || !(null === (r = null == i ? void 0 : i.assetUrls) || void 0 === r ? void 0 : r.length)) return null;
					const a = i.assetUrls[0];
					return !i.experimentRequired || Object(o.a)(i.experimentRequired)(e) ? a : null
				}
		},
		"./src/reddit/selectors/avatarPushcard.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/lib/initializeClient/installReducer.ts"),
				o = n("./src/reddit/helpers/localStorage/index.ts"),
				i = n("./src/reddit/reducers/features/avatar/index.ts"),
				a = n("./src/reddit/selectors/experiments/econ/index.ts");
			Object(r.a)({
				features: {
					avatar: i.a
				}
			});
			const d = e => {
					var t, n, s;
					return null === (s = null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.marketing) || void 0 === s ? void 0 : s.pushcard
				},
				c = Object(s.a)(d, a.b, (e, t) => {
					if (!e || !t) return null;
					const {
						id: n,
						eventViews: s
					} = Object(o.C)();
					return n === e.id && s > e.maxViews ? null : e
				}),
				l = Object(s.a)(c, e => {
					if (!e) return null;
					const {
						id: t,
						lastInteractionTimestamp: n
					} = Object(o.C)();
					return t === e.id && n > 0 ? null : e.banner
				})
		},
		"./src/reddit/selectors/bannedUser.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/components/InboxTooltip/Component.tsx"),
				o = n("./src/reddit/models/SubredditModeration/index.ts"),
				i = n("./src/reddit/selectors/user.ts");
			const a = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.features.banned.models[n]
				},
				d = (e, t) => {
					let {
						subredditId: n,
						username: s
					} = t;
					const r = Object(i.Db)(e, {
						userName: s
					});
					if (!r) return;
					const o = a(e, {
						subredditId: n
					});
					return o ? o[r.id] : void 0
				},
				c = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.features.banned.userOrder[n];
					return s ? s.map(t => e.features.banned.models[n][t]) : r.a
				}),
				l = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = Object(o.e)(n);
					return e.features.banned.api.pending[s]
				},
				u = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.features.banned.loadMore[n]
				},
				m = e => e.features.banned.search.api.pending,
				p = e => e.features.banned.search.result,
				b = e => e.features.banned.inContext
		},
		"./src/reddit/selectors/comments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return g
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "u", (function() {
				return x
			})), n.d(t, "w", (function() {
				return E
			})), n.d(t, "x", (function() {
				return O
			})), n.d(t, "k", (function() {
				return A
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "J", (function() {
				return j
			})), n.d(t, "n", (function() {
				return I
			})), n.d(t, "o", (function() {
				return k
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "l", (function() {
				return S
			})), n.d(t, "h", (function() {
				return w
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "b", (function() {
				return P
			})), n.d(t, "q", (function() {
				return N
			})), n.d(t, "m", (function() {
				return D
			})), n.d(t, "t", (function() {
				return M
			})), n.d(t, "z", (function() {
				return R
			})), n.d(t, "L", (function() {
				return L
			})), n.d(t, "s", (function() {
				return B
			})), n.d(t, "F", (function() {
				return F
			})), n.d(t, "G", (function() {
				return U
			})), n.d(t, "H", (function() {
				return H
			})), n.d(t, "r", (function() {
				return G
			})), n.d(t, "e", (function() {
				return Q
			})), n.d(t, "N", (function() {
				return q
			})), n.d(t, "v", (function() {
				return W
			})), n.d(t, "M", (function() {
				return z
			})), n.d(t, "f", (function() {
				return V
			})), n.d(t, "i", (function() {
				return K
			})), n.d(t, "I", (function() {
				return Y
			})), n.d(t, "E", (function() {
				return J
			})), n.d(t, "K", (function() {
				return X
			})), n.d(t, "p", (function() {
				return Z
			})), n.d(t, "O", (function() {
				return $
			})), n.d(t, "y", (function() {
				return ee
			})), n.d(t, "A", (function() {
				return te
			})), n.d(t, "C", (function() {
				return ne
			})), n.d(t, "D", (function() {
				return se
			})), n.d(t, "B", (function() {
				return re
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/values.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/objectSelector/index.ts"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/constants/comments.ts"),
				c = n("./src/reddit/models/Post/index.ts"),
				l = n("./src/reddit/selectors/experiments/mediaInComments.ts"),
				u = n("./src/reddit/selectors/subreddit.ts"),
				m = n("./src/reddit/selectors/commentSelector.ts"),
				p = n("./src/lib/initializeClient/installReducer.ts"),
				b = n("./src/reddit/reducers/features/comments/index.ts"),
				f = n("./src/reddit/reducers/pages/comments/index.ts"),
				h = n("./src/redditGQL/types.ts");
			Object(p.a)({
				features: {
					comments: b.a
				},
				pages: {
					comments: f.a
				}
			});
			const g = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.pages.comments.api.error[n]
				},
				v = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.pages.comments.api.pending[n]
				},
				x = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.pages.comments.api.fullyLoaded[n]
				},
				E = (e, t) => e.pages.comments.keyToHeadCommentId[t.commentsPageKey],
				O = (e, t) => {
					const n = E(e, t);
					if (n) return Object(m.c)(e, {
						commentId: n
					})
				},
				C = [],
				A = Object(i.a)((e, t) => {
					const n = O(e, t),
						s = n && n.id;
					if (!s) return C;
					const {
						commentsPageKey: r
					} = t, o = e.pages.comments.keyToCommentThreadLinkSets[r], i = [];
					let a = {
						id: s,
						type: d.a.Comment
					};
					do {
						i.push(a), a = o[a.id].next
					} while (a);
					return i
				}),
				y = (e, t) => E(e, t) ? e.pages.comments.keyToChatCommentLinks[t.commentsPageKey] : [],
				j = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					const s = e.pages.comments.keyToPostId[n];
					return s ? e.posts.models[s] : null
				},
				I = (e, t) => {
					let {
						commentId: n,
						commentLink: s,
						commentsPageKey: r
					} = t;
					const o = e.pages.comments.keyToCommentThreadLinkSets[r];
					return o ? s ? o[s.id] : n ? o[n] : null : null
				},
				k = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.pages.comments.keyToCommentThreadLinkSets[n]
				},
				_ = (e, t) => {
					const n = t.commentsPageKey ? I(e, t) : null;
					return n ? n.depth : null
				},
				S = (e, t) => {
					let {
						commentLink: n
					} = t;
					const {
						id: s,
						type: r
					} = n;
					switch (r) {
						case d.a.Comment:
							return e.features.comments.models[s];
						case d.a.MoreComments:
							return e.moreComments.models[s];
						case d.a.ContinueThread:
							return e.continueThreads.models[s];
						default:
							return null
					}
				},
				w = (e, t) => {
					if (e.platform.currentPage && e.platform.currentPage.urlParams && e.platform.currentPage.urlParams.partialPostId) {
						const {
							partialPostId: t
						} = e.platform.currentPage.urlParams, n = Object(c.y)(t);
						return Array.from(new Set(Object.keys(e.features.comments.models).filter(t => e.features.comments.models[t].postId === n && e.features.comments.models[t].author !== o.G).map(t => e.features.comments.models[t].author)))
					}
					return []
				},
				T = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.features.comments.collapsed[n]
				},
				P = e => e.moreComments.models,
				N = e => e.features.comments.models,
				D = (e, t) => {
					let {
						commentId: n
					} = t;
					const s = Object(m.c)(e, {
						commentId: n
					});
					return s ? Object(m.b)(e, s) : ""
				},
				M = (e, t) => {
					let {
						commentId: n
					} = t;
					return !!(n && e.features.comments.focused && e.features.comments.focused[n])
				},
				R = (e, t) => {
					let {
						commentId: n,
						commentsPageKey: s
					} = t;
					return !!(n && e.features.comments.isEditing[s] && e.features.comments.isEditing[s][n])
				},
				L = (e, t) => {
					let {
						commentId: n,
						commentsPageKey: s
					} = t;
					return !!(n && e.features.comments.replyFormOpen[s] && e.features.comments.replyFormOpen[s][n])
				},
				B = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					const s = n && e.features.comments.replyFormOpen[n] || {},
						r = Object.keys(s).find(e => s[e]),
						o = r && Object(m.c)(e, {
							commentId: r
						}),
						i = o && _(e, {
							commentId: o.id,
							commentLink: void 0,
							commentsPageKey: n
						});
					if (o && "number" == typeof i) return {
						...o,
						depth: i
					}
				},
				F = (e, t) => {
					let {
						moreCommentsId: n
					} = t;
					return e.moreComments.models[n]
				},
				U = (e, t) => {
					let {
						moreCommentsId: n
					} = t;
					return !!e.moreComments.api.pending[n]
				},
				H = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					const s = e.pages.comments.keyToPostId[n];
					if (s) {
						const t = r()(e.moreComments.models).find(t => t.postId === s && 0 === t.depth && !(void 0 !== e.moreComments.api.pending[t.id]));
						if (t) return {
							moreCommentId: t.id,
							pending: !!e.moreComments.api.pending[t.id]
						}
					}
					return null
				},
				G = (e, t) => {
					let {
						id: n
					} = t;
					return e.continueThreads.models[n]
				},
				Q = (e, t) => {
					let {
						commentId: n
					} = t;
					const s = n ? e.features.comments.models[n] : void 0;
					if (!s) return null;
					const r = e.authorFlair.models[s.subredditId];
					return r ? r[s.author] : null
				},
				q = (e, t) => {
					let {
						draftKey: n
					} = t;
					var s, r, o;
					return (null === (o = null === (r = null === (s = e.features.comments.submit) || void 0 === s ? void 0 : s.error) || void 0 === r ? void 0 : r[n]) || void 0 === o ? void 0 : o.type) || null
				},
				W = (e, t) => {
					let {
						draftKey: n
					} = t;
					return !!e.features.comments.submit.error[n]
				},
				z = (e, t) => {
					let {
						draftKey: n
					} = t;
					const s = e.features.comments.submit.error[n];
					return s && s.fields ? s.fields.map(e => e.msg) : []
				},
				V = (e, t) => {
					let {
						draftKey: n
					} = t;
					const s = e.features.comments.drafts[n];
					return !!s && s.autofocusDisabled
				},
				K = (e, t) => {
					let {
						draftKey: n
					} = t;
					return e.features.comments.drafts[n]
				},
				Y = (e, t) => {
					let {
						commentId: n
					} = t;
					const s = n ? e.features.comments.submit.error[n] : void 0;
					return s && s.fields ? s.fields.map(e => e.msg) : void 0
				},
				J = (e, t) => {
					let {
						commentId: n
					} = t;
					return !!n && e.features.comments.submit.pending[n]
				},
				X = (e, t) => {
					let {
						commentId: n
					} = t;
					return !!n && e.features.comments.models[n].sendReplies
				},
				Z = e => e.features.comments.visitHighlightFilter,
				$ = (e, t) => {
					const n = Object(m.c)(e, t);
					if (n) return Object(u.cb)(e, n)
				},
				ee = (e, t) => {
					let {
						commentId: n
					} = t;
					var s, r;
					return !!((null === (r = null === (s = e.pages) || void 0 === s ? void 0 : s.comments) || void 0 === r ? void 0 : r.followed) || []).find(e => e.id === n)
				},
				te = (e, t) => {
					let {
						commentId: n
					} = t;
					var s, r;
					const o = ((null === (r = null === (s = e.pages) || void 0 === s ? void 0 : s.comments) || void 0 === r ? void 0 : r.followed) || []).find(e => e.id === n);
					return !!(o && o.expiresAt < Date.now())
				},
				ne = Object(a.a)(l.b, u.y, (e, t) => {
					var n;
					return e && (null === (n = null == t ? void 0 : t.allowedMediaInComments) || void 0 === n ? void 0 : n.includes(h.f.Giphy)) || !1
				}),
				se = (e, t) => {
					let {
						subredditId: n
					} = t;
					var s;
					const r = Object(u.y)(e, {
						subredditId: n
					});
					return (null === (s = null == r ? void 0 : r.allowedMediaInComments) || void 0 === s ? void 0 : s.includes(h.f.Static)) || !1
				},
				re = (e, t) => {
					let {
						subredditId: n
					} = t;
					var s;
					const r = Object(u.y)(e, {
						subredditId: n
					});
					return (null === (s = null == r ? void 0 : r.allowedMediaInComments) || void 0 === s ? void 0 : s.includes(h.f.Animated)) || !1
				}
		},
		"./src/reddit/selectors/contentGate.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/selectors/platform.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = e => {
				if (!Object(o.S)(e)) return !1;
				const t = Object(r.d)(e);
				if (!t) return !1;
				const n = Object(o.h)(e, t);
				if (!n) return !1;
				if (!n.privateSubreddit) return !1;
				const {
					isContributorRequestTimestamp: i
				} = n;
				if (!i) return !1;
				const a = 30 * s.D;
				return i > Date.now() - a
			}
		},
		"./src/reddit/selectors/creatorStats.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/creatorStats/index.ts"),
				o = n("./src/reddit/selectors/moderatorPermissions.ts"),
				i = n("./src/reddit/selectors/posts.ts"),
				a = n("./src/reddit/selectors/user.ts");
			Object(s.a)({
				features: {
					creatorStats: r.a
				}
			});
			const d = (e, t) => {
					var n, s;
					return null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.creatorStats) || void 0 === s ? void 0 : s.postOtherDiscussions[t]
				},
				c = (e, t) => {
					var n, s;
					return null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.creatorStats) || void 0 === s ? void 0 : s.postStats[t]
				},
				l = (e, t) => {
					var n, s, r;
					const o = null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.creatorStats) || void 0 === s ? void 0 : s.subredditKarma[t]) || void 0 === r ? void 0 : r.karma;
					if (!o) return;
					const {
						fromComments: i,
						fromPosts: a
					} = o;
					return {
						fromComments: i,
						fromPosts: a
					}
				},
				u = (e, t, n) => {
					const s = Object(i.F)(e, {
						postId: t
					});
					if (!s || s.isSponsored || s.removedByCategory) return !1;
					const r = Object(i.U)(e, {
						postId: t
					});
					if (r && r.isQuarantined) return !1;
					const d = !n && !!Object(o.m)(e, {
						postId: t
					});
					return Object(a.Gb)(e, {
						postId: t
					}) || d
				}
		},
		"./src/reddit/selectors/crypto/points.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/reddit/contexts/PageLayer/index.tsx"),
				o = n("./src/reddit/endpoints/governance/crypto.ts"),
				i = n("./src/lib/initializeClient/installReducer.ts"),
				a = n("./src/reddit/reducers/features/crypto/index.ts");
			Object(i.a)({
				features: {
					crypto: a.a
				}
			});
			const d = (e, t) => {
				var n, s, r;
				return t ? null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.crypto) || void 0 === s ? void 0 : s.points) || void 0 === r ? void 0 : r[t] : void 0
			};

			function c() {
				const e = Object(r.ib)(),
					t = Object(s.e)(t => Object(r.s)(t, {
						pageLayer: e
					})),
					n = Object(s.e)(e => d(e, null == t ? void 0 : t.id));
				return {
					subreddit: t,
					pointsDetails: n
				}
			}
			const l = (e, t) => {
				var n;
				const s = null === (n = d(e, t)) || void 0 === n ? void 0 : n.blockchainProvider;
				return s === o.a.Ethereum || s === o.a.Rinkeby || s === o.a.EthTraderEthereum || s === o.a.EthTraderRinkeby || s === o.a.ArbitrumRinkeby
			}
		},
		"./src/reddit/selectors/discoveryUnit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "e", (function() {
				return l
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/lib/constants/index.ts"), n("./src/lib/makeListingKey/index.ts"), n("./src/lib/objectSelector/index.ts");
			var s = n("./src/reddit/helpers/name/index.ts"),
				r = n("./src/reddit/models/DiscoveryUnit/index.ts");
			n("./src/reddit/selectors/category.ts"), n("./src/reddit/selectors/listings.ts"), n("./src/reddit/selectors/posts.ts"), n("./src/reddit/selectors/subreddit.ts");
			const o = e => e.discoveryUnits.api.list.loaded,
				i = e => e.discoveryUnits.api.list.pending,
				a = (e, t) => {
					let {
						unitName: n
					} = t;
					const r = e.discoveryUnits.nameToId[Object(s.i)(n)];
					return e.discoveryUnits.models[r]
				},
				d = e => a(e, {
					unitName: r.b
				}),
				c = new Set(["sequence"]),
				l = e => {
					const t = e.platform.currentPage;
					if (t) {
						const {
							meta: e,
							urlParams: n
						} = t, s = e && e.name || "", r = n && n.subredditName || "", o = "subreddit" === s, i = c.has(r.toLowerCase());
						return o && i
					}
					return !1
				}
		},
		"./src/reddit/selectors/emojis.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return l
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "a", (function() {
				return g
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/values.js"),
				r = n.n(s),
				o = n("./node_modules/reselect/es/index.js"),
				i = n("./src/reddit/models/Flair/index.ts"),
				a = n("./src/reddit/selectors/isModeratorOfSubreddit.ts"),
				d = n("./src/reddit/selectors/subreddit.ts");
			const c = [],
				l = e => e.emojis.models,
				u = Object(o.a)(l, (e, t) => t.subredditId, (e, t) => {
					const n = e[t];
					return n ? [...r()(n.emojis), ...r()(n.snoomojis)] : c
				}),
				m = Object(o.a)(u, a.c, (e, t) => t.isFlairModOnly, (e, t) => t.flairTemplateType, (e, t, n, s) => e.filter(e => !(e.modFlairOnly && !t || e.modFlairOnly && !n) && (!(!e.userFlairAllowed && s === i.d.UserFlair) && !(!e.postFlairAllowed && s === i.d.LinkFlair)))),
				p = Object(o.a)(l, (e, t) => t.subredditId, (e, t) => Object.keys(e[t].snoomojis)),
				b = (e, t) => Object(d.z)(e, {
					subredditName: t
				}).emojisEnabled,
				f = {
					emojis: {},
					snoomojis: {}
				},
				h = (e, t) => {
					let {
						subredditId: n
					} = t;
					return l(e)[n] || f
				},
				g = (e, t) => !!e.emojis.api.list.pending[t]
		},
		"./src/reddit/selectors/eventPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./src/lib/makeListingKey/index.ts"),
				r = n("./src/reddit/selectors/posts.ts");
			const o = (e, t) => {
					let {
						subredditName: n
					} = t;
					return Object(s.a)("ModhubPage-EventPosts", "timeline", {
						subredditName: n
					})
				},
				i = (e, t) => {
					const n = o(e, t);
					return Object(r.M)(e, {
						listingKey: n
					}) || []
				},
				a = (e, t) => {
					const n = o(e, t);
					return !!e.listings.postOrder.api.pending[n]
				},
				d = (e, t) => {
					const n = o(e, t);
					return !!(e.listings.postOrder.ids[n] || []).length
				},
				c = (e, t) => {
					const n = o(e, t),
						s = e.listings.postOrder.pageInfo[n];
					return !(!s || !s.hasNextPage)
				},
				l = (e, t) => {
					const n = o(e, t),
						s = e.listings.postOrder.pageInfo[n];
					return s && s.endCursor || null
				}
		},
		"./src/reddit/selectors/experiments/antievil/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => {
				return Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.M
				}) === s.Yd
			}
		},
		"./src/reddit/selectors/experiments/cnc/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => {
					const t = Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.sc
					});
					return !(!t || Object(s.Kg)(t))
				},
				i = e => {
					const t = Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.Ad
					});
					return !(!t || Object(s.Kg)(t))
				},
				a = e => {
					const t = Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.Bc
					});
					return !(!t || Object(s.Kg)(t))
				}
		},
		"./src/reddit/selectors/experiments/commentSearchPdp.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./node_modules/reselect/es/index.js");
			const i = Object(o.a)(e => Object(r.c)(e, {
				experimentEligibilitySelector: r.a,
				experimentName: s.Ab
			}), e => ({
				bucketed: e === s.gd.ExpandedSearch || e === s.gd.CollapsedSearch,
				collapsed: e === s.gd.CollapsedSearch,
				expanded: e === s.gd.ExpandedSearch
			}))
		},
		"./src/reddit/selectors/experiments/communityChat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			}));
			var s = n("./node_modules/reselect/es/index.js");
			var r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/selectors/experiments/econ/simpleExperiment.ts"),
				i = n("./src/reddit/selectors/features/communityChat/index.ts"),
				a = n("./src/reddit/selectors/platform.ts");
			const d = Object(s.a)(a.c, e => "t5_7bf0ce" === e),
				c = Object(o.a)(r.dc),
				l = Object(s.a)(d, c, (e, t) => e && t),
				u = Object(o.a)(r.D),
				m = Object(s.a)(e => e, a.c, u, (e, t, n) => n && Object(i.a)(e, String(t)).length > 0)
		},
		"./src/reddit/selectors/experiments/communityDirectoryBacklinks/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/server/helpers/canonicalUrl.tsx");
			const i = (e, t) => e.find(e => t <= e);

			function a(e, t) {
				return Object(o.c)(`/best/communities/${e}/#${t}`)
			}

			function d(e, t) {
				return e > 50 ? {
					percentile: i([0, 1, 5, 10, 20, 50], t),
					position: e
				} : {
					position: e
				}
			}
			var c = n("./src/reddit/selectors/subreddit.ts");
			const l = e => {
					return Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.L,
						expEventOverride: !1
					}) === s.U.Enabled
				},
				u = (e, t) => {
					let {
						subredditId: n,
						subredditAboutInfo: s
					} = t;
					if (l(e) && n && (null == s ? void 0 : s.directoryRankings)) return function(e, t) {
						const n = null === (s = e.rankings) || void 0 === s ? void 0 : s[0];
						var s;
						if (n && n.position > 0 && t) {
							const e = Math.ceil(n.position / n.totalRanked * 100);
							if (e <= 50) return {
								url: a(n.pageNumber, t),
								...d(n.position, e)
							}
						}
					}(s.directoryRankings, n)
				},
				m = (e, t) => {
					const n = Object(c.C)(e, {
							subredditName: t
						}),
						s = Object(c.z)(e, {
							subredditName: t
						});
					return u(e, {
						subredditId: null == n ? void 0 : n.id,
						subredditAboutInfo: s
					})
				},
				p = e => {
					const t = e.platform.currentPage,
						n = t && t.routeMatch,
						s = n ? n.match.params.subredditName : void 0;
					if (!s) return;
					const r = m(e, s);
					return (null == r ? void 0 : r.url) ? {
						internalLinkUrl: null == r ? void 0 : r.url
					} : void 0
				}
		},
		"./src/reddit/selectors/experiments/contributeBeforeSignUp.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/experiments/utils.ts");
			const a = ["au", "br", "ca", "de", "fr", "gb", "in", "mx", "us", "row"],
				d = Object(s.a)((e, t) => Object(o.c)(e, {
					experimentEligibilitySelector: o.a,
					experimentName: `d2x_start_comment_before_sign_up_${t}`
				}), i.a),
				c = e => a.find(t => !!Object(i.a)(d(e, t))),
				l = Object(s.a)(c, e => !!e),
				u = e => {
					const t = c(e);
					return !!t && d(e, t) === r.Y.SkipOnboarding
				},
				m = e => {
					const t = c(e);
					return !!t && d(e, t) === r.Y.RegOnboarding
				}
		},
		"./src/reddit/selectors/experiments/crosspostRecommendations.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "e", (function() {
				return h
			}));
			var s = n("./src/lib/isUrl/index.ts"),
				r = n("./src/reddit/components/CrosspostRecommendationsModal/constants.tsx"),
				o = n("./src/reddit/constants/experiments.ts"),
				i = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/helpers/isCrosspost.ts"),
				d = n("./src/reddit/models/Media/index.ts"),
				c = n("./src/reddit/selectors/activeModal.ts"),
				l = n("./src/reddit/selectors/experiments/index.ts"),
				u = n("./src/reddit/selectors/posts.ts");
			const m = e => {
					return Object(i.c)(e, {
						experimentEligibilitySelector: l.e,
						experimentName: o.hf
					}) === o.Yd
				},
				p = e => !e.media || e.media.type !== d.o.RTJSON && e.media.type !== d.o.TEXT ? "" : e.media.markdownContent,
				b = e => !e.media && e.source && Object(s.a)(e.source.url) ? e.source.displayText : "",
				f = (e, t) => {
					const n = Object(u.F)(e, {
						postId: t
					});
					return n && !n.isSponsored && n.isCrosspostable && !Object(a.a)(n) && Object(c.c)(r.a)(e)
				},
				h = e => {
					var t;
					return !!(null === (t = e.features) || void 0 === t ? void 0 : t.shouldTryToShowCrosspostModal)
				}
		},
		"./src/reddit/selectors/experiments/devPlatform.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/selectors/experiments/econ/simpleExperiment.ts");
			const o = Object(r.a)(s.Cb)
		},
		"./src/reddit/selectors/experiments/gqlSubredditPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Nb
				}) === s.md.Enabled,
				i = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Mb
				}) === s.ld.Enabled
		},
		"./src/reddit/selectors/experiments/hidePostMitigation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => {
				return Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.ue
				}) === s.Yd
			}
		},
		"./src/reddit/selectors/experiments/imageComment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/comments.ts");
			const i = e => {
					return Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.ye
					}) === s.Yd
				},
				a = e => {
					return Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.ze
					}) === s.Yd
				},
				d = e => {
					return Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.ie
					}) === s.Yd
				},
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return void 0 !== n && Object(o.D)(e, {
						subredditId: n
					}) && i(e)
				},
				l = (e, t) => {
					let {
						subredditId: n
					} = t;
					return void 0 !== n && Object(o.B)(e, {
						subredditId: n
					}) && i(e)
				}
		},
		"./src/reddit/selectors/experiments/joinOptimizations.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/experiments/index.ts");
			const a = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Vb,
					experimentEligibilitySelector: i.e
				}), e => e === r.Z.Enabled),
				d = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Wb,
					experimentEligibilitySelector: i.e
				}), e => e === r.ab.Enabled),
				c = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Xb,
					experimentEligibilitySelector: i.e
				}), e => e === r.bb.Enabled),
				l = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Yb,
					experimentEligibilitySelector: i.e
				}), e => e === r.cb.Enabled),
				u = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.ac,
					experimentEligibilitySelector: i.e
				}), e => e === r.eb.Enabled),
				m = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Zb,
					experimentEligibilitySelector: i.e
				}), e => e === r.db.Enabled)
		},
		"./src/reddit/selectors/experiments/mediaInComments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Ne
				}) === s.Yd,
				i = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Me
				}) === s.Yd,
				a = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Eg
				}) === s.Yd
		},
		"./src/reddit/selectors/experiments/newCommunityProgressV3.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/constants/experiments.ts"),
				i = n("./src/reddit/constants/posts.ts"),
				a = n("./src/reddit/helpers/chooseVariant/index.ts"),
				d = n("./src/reddit/selectors/experiments/index.ts"),
				c = n("./src/reddit/selectors/experiments/utils.ts"),
				l = n("./src/reddit/selectors/moderatorPermissions.ts"),
				u = n("./src/reddit/selectors/platform.ts"),
				m = n("./src/reddit/selectors/subreddit.ts"),
				p = n("./src/reddit/selectors/user.ts");
			const b = e => e.subreddits.progressModule,
				f = e => {
					const t = Object(u.c)(e);
					if (!t) return;
					if (!Object(l.n)(e, {
							subredditId: t
						})) return;
					if (Object(p.P)(e)) return h(e);
					const n = Object(m.M)(e, {
						identifier: {
							id: t,
							type: i.a.SUBREDDIT
						}
					});
					if (!n || !n.created) return;
					const s = n.created;
					return s ? s * r.Xb < 1639443600180 ? void 0 : h(e) : void 0
				},
				h = Object(s.a)(e => Object(a.c)(e, {
					experimentName: o.Ue,
					experimentEligibilitySelector: d.e
				}), c.a)
		},
		"./src/reddit/selectors/experiments/nsfwBlockingExperiment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "i", (function() {
				return h
			})), n.d(t, "j", (function() {
				return x
			})), n.d(t, "h", (function() {
				return A
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "g", (function() {
				return w
			})), n.d(t, "f", (function() {
				return T
			})), n.d(t, "e", (function() {
				return P
			})), n.d(t, "d", (function() {
				return N
			}));
			var s, r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/selectors/subreddit.ts"),
				i = n("./src/reddit/constants/experiments.ts"),
				a = n("./src/reddit/contexts/PageLayer/index.tsx"),
				d = n("./src/reddit/helpers/chooseVariant/index.ts"),
				c = n("./src/reddit/selectors/experiments/index.ts"),
				l = n("./src/reddit/selectors/meta.ts"),
				u = n("./src/reddit/selectors/platform.ts"),
				m = n("./src/reddit/selectors/profile.ts");
			! function(e) {
				e.Blurred = "blurred", e.NoPreview = "noPreview"
			}(s || (s = {}));
			const p = Object(r.a)(l.h, l.d, c.e, (e, t, n) => !e && !t && !n);

			function b(e, t) {
				return n => Object(d.c)(n, {
					experimentName: e,
					experimentEligibilitySelector: p,
					expEventOverride: t
				})
			}
			const f = b(i.lc, !0),
				h = b(i.lc, !1),
				g = b(i.nc, !0),
				v = (b(i.nc, !1), b(i.mc, !0)),
				x = b(i.mc, !1),
				E = b(i.oc, !0),
				O = b(i.oc, !1),
				C = b(i.kc, !0),
				A = b(i.pc, !0),
				y = Object(r.a)(f, g, (e, t) => e === i.od.Enabled || t === i.pd.Enabled),
				j = Object(r.a)(v, E, (e, t) => e === i.lb.BlurredPreview || e === i.lb.NoPreview || t === i.lb.BlurredPreview || t === i.lb.NoPreview),
				I = Object(r.a)(x, O, (e, t) => e === i.lb.BlurredPreview || t === i.lb.BlurredPreview),
				k = Object(r.a)(v, E, C, (e, t, n) => e === i.lb.NoPreview || t === i.lb.NoPreview || n === i.kb.Enabled),
				_ = Object(r.a)(y, k, I, (e, t, n) => (e || t) && !n),
				S = Object(r.a)(l.h, l.d, c.e, l.j, (e, t, n, s) => !e && !t && !n && s),
				w = e => {
					const t = I(e),
						n = _(e),
						r = S(e);
					return t ? s.Blurred : n || r ? s.NoPreview : null
				},
				T = Object(r.a)(C, e => e === i.kb.Enabled),
				P = e => {
					const t = I(e),
						n = Object(o.m)(e);
					return t && n
				},
				N = e => {
					var t;
					const n = I(e),
						s = Object(u.b)(e),
						r = null === (t = null == s ? void 0 : s.routeMatch) || void 0 === t ? void 0 : t.match;
					if (r) {
						const t = Object(m.k)(e, {
								profileName: r.params.profileName
							}),
							o = !!(t && (null == t ? void 0 : t.isNSFW)),
							i = Object(a.G)(e, {
								pageLayer: s
							});
						return n && o && !i
					}
					return !1
				}
		},
		"./src/reddit/selectors/experiments/onboarding.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "g", (function() {
				return x
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/experiments/index.ts"),
				a = n("./src/reddit/selectors/user.ts"),
				d = n("./src/reddit/selectors/experiments/utils.ts");
			const c = Object(s.a)(i.e, a.L, (e, t) => e && !t),
				l = e => Object(o.c)(e, {
					experimentEligibilitySelector: c,
					experimentName: r.Qc
				}),
				u = Object(s.a)(e => Object(o.c)(e, {
					experimentEligibilitySelector: o.a,
					experimentName: r.Pc
				}), e => e),
				m = Object(s.a)(e => {
					var t;
					const n = r.Rb;
					for (let s = 0; s < n.length; s++) {
						const i = n[s],
							a = (null === (t = i.split("_").pop()) || void 0 === t ? void 0 : t.toUpperCase()) || "",
							d = Object(o.c)(e, {
								experimentEligibilitySelector: o.a,
								experimentName: i
							});
						if (d && Object.values(r.nb).includes(d)) return {
							countryCode: a,
							experimentName: i,
							variantName: d
						}
					}
					return null
				}, e => e),
				p = Object(s.a)(e => {
					const t = m(e);
					return (null == t ? void 0 : t.variantName) || void 0
				}, d.a),
				b = (Object(s.a)(p, e => e === r.nb.FruitVeg), Object(s.a)(p, e => e === r.nb.Karma)),
				f = Object(s.a)(p, e => e === r.nb.Randomizer),
				h = Object(s.a)(p, e => e === r.nb.Interactive),
				g = Object(s.a)(p, e => Object.values(r.nb).includes(e)),
				v = e => Object(o.c)(e, {
					experimentEligibilitySelector: o.a,
					experimentName: r.qc
				}),
				x = e => Object(o.c)(e, {
					experimentEligibilitySelector: o.a,
					experimentName: r.rc
				})
		},
		"./src/reddit/selectors/experiments/popularGqlMigration.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/experiments/index.ts");
			const a = Object(s.a)(e => Object(o.c)(e, {
					experimentEligibilitySelector: i.e,
					experimentName: r.vc
				}), e => e === r.Yd),
				d = Object(s.a)(e => Object(o.c)(e, {
					experimentEligibilitySelector: i.f,
					experimentName: r.wc
				}), e => e === r.Yd)
		},
		"./src/reddit/selectors/experiments/postActionBarAnimation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "e", (function() {
				return f
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/experiments/index.ts"),
				i = n("./src/reddit/selectors/experiments/presence.ts"),
				a = n("./src/reddit/selectors/userPrefs.ts");
			const d = 1e4,
				c = e => {
					if (Object(i.a)(e)) return !1;
					const t = Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.h
					});
					return t === s.l.VoteCountOnly || t === s.l.CommentCountOnly || t === s.l.VoteAndCommentCount
				},
				l = e => {
					if (Object(a.d)(e) || Object(i.a)(e)) return !1;
					const t = Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.h
					});
					return t === s.l.VoteCountOnly || t === s.l.VoteAndCommentCount
				},
				u = e => {
					if (Object(a.d)(e) || Object(i.a)(e)) return !1;
					const t = Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.h
					});
					return t === s.l.CommentCountOnly || t === s.l.VoteAndCommentCount
				},
				m = (e, t) => {
					let {
						post: n
					} = t;
					return p(e, {
						postId: n.id
					})
				},
				p = (e, t) => {
					let {
						postId: n
					} = t;
					const r = e.posts.models[n];
					if (Object(a.d)(e) || !r || r.isSponsored || r.isScoreHidden || r.score >= d || Object(i.a)(e)) return !1;
					const c = Object(o.d)(e, {
							experimentName: s.h
						}),
						l = null == c ? void 0 : c.variant;
					return l === s.l.VoteCountOnly || l === s.l.VoteAndCommentCount
				},
				b = (e, t) => {
					let {
						postId: n
					} = t;
					const r = e.posts.models[n];
					if (Object(a.d)(e) || !r || r.isSponsored || r.numComments >= d || Object(i.a)(e)) return !1;
					const c = Object(o.d)(e, {
							experimentName: s.h
						}),
						l = null == c ? void 0 : c.variant;
					return l === s.l.CommentCountOnly || l === s.l.VoteAndCommentCount
				},
				f = e => {
					if (Object(i.a)(e)) return !1;
					return Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.Gc
					}) === s.sd.Enabled
				}
		},
		"./src/reddit/selectors/experiments/postCreationSubRec.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "f", (function() {
				return v
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "l", (function() {
				return C
			})), n.d(t, "k", (function() {
				return A
			})), n.d(t, "m", (function() {
				return y
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				o = n("./src/reddit/constants/experiments.ts"),
				i = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/models/PostCreationForm/index.ts"),
				d = n("./src/reddit/models/SubredditAutocomplete/index.ts"),
				c = n("./src/reddit/selectors/subreddit.ts");
			const l = 3,
				u = e => m(e) ? 1 : (p(e), .5),
				m = e => {
					return Object(i.c)(e, {
						experimentEligibilitySelector: i.a,
						experimentName: o.gf
					}) === o.if.ContentMatch
				},
				p = e => {
					return Object(i.c)(e, {
						experimentEligibilitySelector: i.a,
						experimentName: o.gf
					}) === o.if.ConfidenceAndSuccess
				},
				b = e => {
					const t = Object(i.c)(e, {
						experimentEligibilitySelector: i.a,
						experimentName: o.gf
					});
					return t === o.if.ContentMatch || t === o.if.ConfidenceAndSuccess || t === o.V.Control1 || t === o.V.Control2
				},
				f = e => {
					const t = Object(i.c)(e, {
						experimentEligibilitySelector: i.a,
						experimentName: o.gf
					});
					return t === o.V.Control1 || t === o.V.Control2
				},
				h = e => {
					const t = Object(i.c)(e, {
						experimentEligibilitySelector: i.a,
						experimentName: o.gf
					});
					return t === o.if.ContentMatch || t === o.if.ConfidenceAndSuccess
				},
				g = e => e.creations.subredditRec.api.pending,
				v = e => e.creations.subredditRec.api.error,
				x = e => {
					return e.creations.subredditRec.order.length > 0
				},
				E = e => {
					const t = e.creations.subredditRec.order,
						n = [];
					return t.forEach(t => {
						const s = Object(c.z)(e, {
								subredditName: t
							}),
							r = Object(c.C)(e, {
								subredditName: t
							});
						if (r && s) {
							const e = {
								iconUrl: r.icon.url,
								name: r.name,
								primaryColor: r.primaryColor,
								subscribers: s.subscribers,
								type: d.a.OTHER_SUBREDDIT
							};
							n.push(e)
						}
					}), n
				},
				O = e => e.creations.subredditRec.isInputChanged,
				C = e => {
					if (!(e.creations.formData.submissionType === s.bc.POST)) return "";
					const t = e.creations.formState.editorMode === a.i.RICH_TEXT || null === e.creations.formState.editorMode,
						n = e.creations.formState.editorMode === a.i.MARKDOWN;
					if (t) {
						const t = e.creations.formData.body.rte;
						return r.a.getRawText(t, " ") || ""
					}
					return n && e.creations.formData.body.markdown || ""
				},
				A = e => {
					return e.creations.formData.submissionType === s.bc.LINK_ONLY && e.creations.formData.body.link || ""
				},
				y = e => b(e) && (!v(e) || v(e) && O(e)) && (e => {
					const t = e.creations.formData.title,
						n = A(e),
						s = C(e);
					return !!(t || n || s)
				})(e) && (e.creations.formData.submissionType === s.bc.POST || e.creations.formData.submissionType === s.bc.LINK_ONLY || e.creations.formData.submissionType === s.bc.CROSSPOST)
		},
		"./src/reddit/selectors/experiments/postGuidance.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => {
				return Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.yc
				}) === s.Yd
			}
		},
		"./src/reddit/selectors/experiments/presence.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => {
				return Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.qf
				}) === s.Yd
			}
		},
		"./src/reddit/selectors/experiments/reportAd.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts");
			const i = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Rc,
					experimentEligibilitySelector: o.a
				}), e => e),
				a = Object(s.a)(i, e => e === r.Yd)
		},
		"./src/reddit/selectors/experiments/reportingRevampDesktop.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/runTimeEnvVars.ts"),
				i = n("./src/reddit/selectors/user.ts");
			const a = e => !!Object(o.b)(e) || Object(r.c)(e, {
				experimentEligibilitySelector: i.S,
				experimentName: s.e
			}) === s.c.Enabled
		},
		"./src/reddit/selectors/experiments/shredditModNav.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = (e, t) => t && Object(r.c)(e, {
				experimentEligibilitySelector: o.S,
				experimentName: s.Rf
			}) === s.Yd
		},
		"./src/reddit/selectors/experiments/supportingLinkAds.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./node_modules/reselect/es/index.js");
			const i = Object(o.a)(e => Object(r.c)(e, {
				experimentEligibilitySelector: r.a,
				experimentName: s.Wc
			}), e => e === s.Yd)
		},
		"./src/reddit/selectors/experiments/targetedOnboardingSkip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = e => Object(r.c)(e, {
				experimentEligibilitySelector: o.S,
				experimentName: s.ad
			})
		},
		"./src/reddit/selectors/experiments/topPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/contexts/PageLayer/index.tsx"),
				i = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/selectors/user.ts");
			const d = Object(s.a)(a.S, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(o.B)(n)
				}, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(o.Q)(n)
				}, (e, t, n) => !e && !t && n),
				c = Object(s.a)((e, t) => Object(i.c)(e, {
					experimentName: r.yd,
					experimentEligibilitySelector: e => d(e, t)
				}), e => e),
				l = e => e === r.qg.NoCommunityWidgets,
				u = e => e === r.qg.NoRulesModerators,
				m = e => e === r.qg.RelatedPostsDu
		},
		"./src/reddit/selectors/experiments/web2x_cta.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts");
			const i = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.ug,
					experimentEligibilitySelector: o.a
				}), e => e),
				a = Object(s.a)(i, e => e === r.og)
		},
		"./src/reddit/selectors/externalAccount.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			var s = n("./src/reddit/models/ExternalAccount/index.ts"),
				r = n("./src/reddit/models/User/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = (e, t) => {
					let {
						username: n
					} = t;
					return !!e.externalAccount.api.user.pending[n]
				},
				a = (e, t) => {
					let {
						username: n
					} = t;
					return e.externalAccount.user[n]
				},
				d = e => {
					const t = Object(o.m)(e);
					if (!t) return;
					const n = Object(r.e)(t),
						s = a(e, {
							username: n
						});
					return s ? s.twitter : void 0
				},
				c = e => !!e.externalAccount.api.connect.pending[s.a.Twitter],
				l = (e, t) => {
					let {
						profileName: n
					} = t;
					if (!n) return null;
					const i = a(e, {
						username: n
					});
					if (!i) return null;
					const d = i[s.a.Twitter];
					if (!d) return null;
					const c = Object(o.m)(e);
					if (!(c && Object(r.e)(c).toLowerCase() === n.toLowerCase())) return d;
					const l = Object(o.Db)(e, {
						userName: n
					});
					return l ? l.prefShowTwitter ? d : null : d
				}
		},
		"./src/reddit/selectors/features/communityChat/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "g", (function() {
				return h
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/lib/initializeClient/installReducer.ts"),
				o = n("./src/reddit/models/CommunityChat/index.ts"),
				i = n("./src/reddit/reducers/features/communityChat/index.ts");
			Object(r.a)({
				features: {
					communityChat: i.a
				}
			});
			const a = {
					[o.a.SubredditPostChannel]: 0,
					[o.a.SubredditChatChannel]: 1
				},
				d = (e, t) => {
					var n, s;
					return null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.communityChat) || void 0 === s ? void 0 : s.models[t]
				},
				c = (e, t) => {
					var n, s;
					return (null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.communityChat) || void 0 === s ? void 0 : s.channelIds[t]) || []
				},
				l = Object(s.a)(c, e => !!e.length),
				u = Object(s.a)(e => e, c, (e, t) => t.map(t => d(e, t))),
				m = Object(s.a)(u, e => (e => e.sort((e, t) => {
					var n, s;
					const r = null !== (n = a[e.__typename]) && void 0 !== n ? n : 0,
						o = null !== (s = a[t.__typename]) && void 0 !== s ? s : 0;
					return r !== o ? r - o : e.name - t.name
				}))(e)),
				p = e => {
					var t, n, s;
					return null !== (s = null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.communityChat) || void 0 === n ? void 0 : n.selectedChannelId) && void 0 !== s ? s : ""
				},
				b = Object(s.a)(d, e => {
					var t;
					return (null == e ? void 0 : e.__typename) !== o.a.SubredditChatChannel ? "" : decodeURIComponent(null !== (t = null == e ? void 0 : e.roomId) && void 0 !== t ? t : "")
				}),
				f = Object(s.a)(u, e => e.find(e => e && "SubredditPostChannel" === e.__typename)),
				h = e => {
					var t, n, s;
					return null !== (s = null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.communityChat) || void 0 === n ? void 0 : n.hasShownToastMessage) && void 0 !== s && s
				}
		},
		"./src/reddit/selectors/features/predictions/creation/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/predictions/index.ts"),
				o = n("./src/reddit/selectors/postCreations.ts");
			Object(s.a)({
				features: {
					predictions: r.a
				}
			});
			const i = e => {
					const t = (e => {
						var t, n;
						return null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.predictions) || void 0 === n ? void 0 : n.creation
					})(e);
					return (null == t ? void 0 : t.length) ? null == t ? void 0 : t.map(t => {
						const n = Object(o.hb)({
								...e,
								creations: {
									...e.creations,
									formData: t.formData,
									formState: t.formState
								}
							}, {}),
							s = t.formData.polls,
							r = s.options.map(e => ({
								text: e.text
							})),
							i = {};
						return n.document ? i.richText = JSON.stringify({
							document: n.document
						}) : n.markdown && (i.markdown = n.markdown), {
							title: n.title,
							isLiveChat: n.isChatPost,
							isNsfw: n.isNSFW,
							isSpoiler: n.isSpoiler,
							votingEndsAt: s.endDate.toISOString(),
							body: i,
							options: r
						}
					}) : []
				},
				a = e => {
					var t, n;
					return !!(null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.predictions) || void 0 === n ? void 0 : n.creation.length)
				}
		},
		"./src/reddit/selectors/features/predictions/leaderboards/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/predictions/index.ts");
			Object(s.a)({
				features: {
					predictions: r.a
				}
			});
			const o = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.leaderboards[t.subredditId]) || void 0 === r ? void 0 : r.isFetching) || !1
				},
				i = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.leaderboards[t.subredditId]) || void 0 === r ? void 0 : r.isFetched) || !1
				},
				a = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.leaderboards[t.subredditId]) || void 0 === r ? void 0 : r.error) || !1
				},
				d = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.leaderboards[t.subredditId]) || void 0 === r ? void 0 : r.data) || null
				},
				c = (e, t) => {
					var n, s;
					return (null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.tournamentsLeaderboards[t.tournamentId]) || null
				},
				l = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.queriedLeaderboards[t.tournamentId]) || void 0 === r ? void 0 : r.isFetching) || !1
				},
				u = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.queriedLeaderboards[t.tournamentId]) || void 0 === r ? void 0 : r.isFetched) || !1
				},
				m = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.queriedLeaderboards[t.tournamentId]) || void 0 === r ? void 0 : r.error) || !1
				}
		},
		"./src/reddit/selectors/gild.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			}));
			const s = e => e.gild.gildModalThingId,
				r = e => e.gild.correlationId || void 0,
				o = e => e.gild.isAnonymous,
				i = e => e.gild.isIframed,
				a = e => e.gild.message,
				d = e => e.gild.api.pending,
				c = e => e.gild.api.error
		},
		"./src/reddit/selectors/gold/awardIcon.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "d", (function() {
				return h
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/Gold/Award.ts"),
				o = n("./src/reddit/selectors/commentSelector.ts"),
				i = n("./src/reddit/selectors/gold/giveAwards.ts"),
				a = n("./src/reddit/selectors/posts.ts"),
				d = n("./src/reddit/selectors/user.ts"),
				c = n("./src/reddit/selectors/userPrefs.ts");
			const l = [32, 48, 64, 128],
				u = (e, t, n) => {
					const s = t ? e[`staticIcon${n}`] : e[`icon${n}`];
					return (null == s ? void 0 : s.url) ? s.url : t ? e.staticIcon.url : e.icon.url
				},
				m = e => {
					let {
						award: t,
						size: n,
						prefersReducedMotion: s,
						postOrComment: o
					} = e;
					return t.awardSubType === r.d.Group ? (e => {
						let {
							award: t,
							size: n,
							prefersReducedMotion: s,
							postOrComment: r
						} = e, o = t;
						if ((null == r ? void 0 : r.awardCountsById) && r.awardCountsById[t.id] && t.tiers) {
							const e = r.awardCountsById[t.id];
							o = t.tiers.reduce((t, n) => e >= n.awardingsRequired ? n : t)
						}
						return u(o, s, n)
					})({
						award: t,
						size: n,
						prefersReducedMotion: s,
						postOrComment: o
					}) : u(t, s, n)
				},
				p = Object(s.a)((e, t) => {
					let {
						awards: n,
						minSize: s,
						postOrCommentId: r
					} = t;
					const i = Object(c.d)(e),
						d = l.find(e => e >= s),
						u = r ? Object(a.F)(e, {
							postId: r
						}) || Object(o.c)(e, {
							commentId: r
						}) : void 0;
					return n.reduce((e, t) => (t && (e[t.id] = m({
						award: t,
						size: d,
						prefersReducedMotion: i,
						postOrComment: u
					})), e), {})
				}),
				b = (e, t) => {
					let {
						award: n,
						minSize: s,
						postOrCommentId: r
					} = t;
					return n ? p(e, {
						awards: [n],
						minSize: s,
						postOrCommentId: r
					})[n.id] : void 0
				},
				f = (e, t) => {
					let {
						minSize: n,
						userName: s
					} = t;
					const r = Object(d.Db)(e, {
						userName: s
					});
					if (r && r.awardedLastMonth && r.awardedLastMonth.topAward) return b(e, {
						award: r.awardedLastMonth.topAward,
						minSize: n
					})
				},
				h = e => {
					const t = Object(i.b)(e),
						n = Object(i.a)(e);
					return b(e, {
						award: t,
						postOrCommentId: n || void 0,
						minSize: 512
					})
				}
		},
		"./src/reddit/selectors/gold/giveAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = e => e.gild.selectedAward,
				r = e => e.gild.gildedThing
		},
		"./src/reddit/selectors/goldPurchaseModals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "r", (function() {
				return i
			})), n.d(t, "t", (function() {
				return a
			})), n.d(t, "s", (function() {
				return d
			})), n.d(t, "v", (function() {
				return c
			})), n.d(t, "u", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "q", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "o", (function() {
				return b
			})), n.d(t, "p", (function() {
				return f
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "l", (function() {
				return v
			})), n.d(t, "x", (function() {
				return x
			})), n.d(t, "y", (function() {
				return E
			})), n.d(t, "w", (function() {
				return O
			})), n.d(t, "z", (function() {
				return C
			})), n.d(t, "f", (function() {
				return A
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "i", (function() {
				return j
			})), n.d(t, "k", (function() {
				return I
			})), n.d(t, "m", (function() {
				return k
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "n", (function() {
				return S
			})), n.d(t, "e", (function() {
				return w
			})), n.d(t, "d", (function() {
				return T
			}));
			var s = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				r = n("./src/lib/initializeClient/installReducer.ts"),
				o = n("./src/reddit/reducers/features/goldPurchase/index.ts");
			Object(r.a)({
				features: {
					goldPurchase: o.a
				}
			});
			const i = e => e.features.goldPurchase.purchaseModal.activePage,
				a = e => e.features.goldPurchase.purchaseModal.gildThingId || void 0,
				d = e => e.features.goldPurchase.purchaseModal.correlationId || void 0,
				c = e => e.features.goldPurchase.purchaseModal.showModal,
				l = e => e.features.goldPurchase.purchaseModal.packageId,
				u = e => e.features.goldPurchase.packageOfferModal.packageId,
				m = e => e.features.goldPurchase.premiumPurchaseModal.renewInterval,
				p = e => {
					const t = Object(s.i)(e),
						n = (e => e.features.goldPurchase.premiumPurchaseModal.packageId)(e);
					return t.length && n && t.find(e => e.mobileId === n) || null
				},
				b = e => e.features.goldPurchase.premiumPurchaseModal.activePage,
				f = e => e.features.goldPurchase.premiumPurchaseModal.showModal,
				h = e => e.features.goldPurchase.payment.paymentMethod,
				g = e => e.features.goldPurchase.payment.cardName,
				v = e => e.features.goldPurchase.payment.postalCode,
				x = e => e.features.goldPurchase.payment.savedCardsPending,
				E = e => e.features.goldPurchase.payment.savedCards,
				O = e => e.features.goldPurchase.payment.rememberCard,
				C = e => e.features.goldPurchase.payment.useSavedCard,
				A = e => e.features.goldPurchase.payment.cardValidation.cardCvc,
				y = e => e.features.goldPurchase.payment.cardValidation.cardExpiry,
				j = e => e.features.goldPurchase.payment.cardValidation.cardNumber,
				I = e => e.features.goldPurchase.payment.cardValidation.nameOnCard,
				k = e => e.features.goldPurchase.payment.cardValidation.postalCode,
				_ = e => e.features.goldPurchase.payment.stripeToken.errorMessage,
				S = e => e.features.goldPurchase.payment.stripeToken.pending,
				w = e => e.features.goldPurchase.payment.paypal.passthrough,
				T = e => e.features.goldPurchase.payment.paypal.errorMessage
		},
		"./src/reddit/selectors/inlineSubredditEditing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/reddit/featureFlags/index.ts"),
				r = n("./src/reddit/selectors/moderatorPermissions.ts");
			const o = (e, t) => {
					let {
						subredditId: n
					} = t;
					if (!s.d.subredditInlineEditing(e)) return !1;
					const o = n ? Object(r.n)(e, {
						subredditId: n
					}) : null;
					return !!o && (e => !!e && e.config)(o)
				},
				i = e => e.subreddits.api.inlineEditing.pending
		},
		"./src/reddit/selectors/modUserNotes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "g", (function() {
				return b
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/SubredditModeration/index.ts"),
				o = n("./src/redditGQL/types.ts"),
				i = n("./src/lib/initializeClient/installReducer.ts"),
				a = n("./src/reddit/reducers/features/modUserNotes/index.ts");
			Object(i.a)({
				features: {
					modUserNotes: a.a
				}
			});
			const d = Object(s.a)((e, t) => {
					let {
						subredditId: n,
						userId: s,
						filter: o
					} = t;
					const i = Object(r.d)(n, s, o),
						a = e.features.modUserNotes.order[i];
					return a ? a.map(t => e.features.modUserNotes.models[t]) : []
				}),
				c = (e, t) => {
					let {
						subredditId: n,
						userId: s,
						filter: o
					} = t;
					const i = Object(r.d)(n, s, o);
					return e.features.modUserNotes.api.pending[i]
				},
				l = e => e.features.modUserNotes.api.error,
				u = (e, t) => {
					let {
						subredditId: n,
						userId: s,
						filter: o
					} = t;
					const i = Object(r.d)(n, s, o);
					return e.features.modUserNotes.loadMore[i]
				},
				m = (e, t, n) => {
					if (!t || !n) return;
					const s = e.features.modUserNotes.lastAuthorModNotes[Object(r.d)(n, t, o.A.All)];
					return s ? e.features.modUserNotes.models[s] : void 0
				},
				p = (e, t, n) => {
					if (!t || !n) return;
					return e.features.modUserNotes.totalCount[Object(r.d)(n, t, o.A.All)]
				},
				b = (e, t, n, s) => {
					if (!s) return;
					const r = p(e, t, n);
					return r && r[s] || 0
				}
		},
		"./src/reddit/selectors/moderatingComments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = (e, t) => {
					let {
						commentId: n,
						commentsPageKey: s
					} = t;
					if (!n) return !1;
					if (e.features.comments.collapsed[s] && n in e.features.comments.collapsed[s]) return !!e.features.comments.collapsed[s][n];
					const r = e.features.comments.models[n];
					return !!r && ("computedCollapsed" in r ? !!r.computedCollapsed : r.collapsedBecauseCrowdControl ? !e.modModeEnabled : r.collapsed)
				},
				r = (e, t) => {
					let {
						commentId: n
					} = t;
					if (!n) return !1;
					const s = e.features.comments.models[n];
					return !(!s || !s.collapsedBecauseCrowdControl) && e.modModeEnabled
				}
		},
		"./src/reddit/selectors/moderationLog.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/SubredditModeration/ModerationLog/index.ts");
			const o = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t, s = [];
					const o = a(e),
						i = u(e);
					if (o && i) {
						const t = Object(r.a)(n, o, i),
							a = e.pages.modHub.moderationLog.actions.itemOrder[n] && e.pages.modHub.moderationLog.actions.itemOrder[n][t];
						a && (s = a.map(t => e.pages.modHub.moderationLog.actions.models[n][t]))
					}
					return s
				}),
				i = e => e.pages.modHub.moderationLog.approximateCount,
				a = e => e.pages.modHub.moderationLog.endCursor,
				d = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderationLog.hasNextPage[n]
				},
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderationLog.hasPreviousPage[n]
				},
				l = (e, t) => e.pages.modHub.moderationLog.moderators[t] || [],
				u = e => e.pages.modHub.moderationLog.startCursor,
				m = e => e.pages.modHub.moderationLog.actionCategories || {}
		},
		"./src/reddit/selectors/muted.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/SubredditModeration/index.ts"),
				o = n("./src/lib/initializeClient/installReducer.ts"),
				i = n("./src/reddit/reducers/pages/modHub/index.ts");
			Object(o.a)({
				pages: {
					modHub: i.a
				}
			});
			const a = [],
				d = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.pages.modHub.muted.userOrder[n];
					return s ? s.map(t => e.pages.modHub.muted.models[n][t]) : a
				}),
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = Object(r.e)(n);
					return !!e.pages.modHub.muted.api.pending[s]
				},
				l = (e, t, n) => !!e.pages.modHub.muted.models[t] && !!e.pages.modHub.muted.models[t][n],
				u = e => !!e.pages.modHub.muted.search.api.pending,
				m = e => e.pages.modHub.muted.search.result,
				p = e => {
					var t, n, s;
					return null === (s = null === (n = null === (t = e.pages) || void 0 === t ? void 0 : t.modHub) || void 0 === n ? void 0 : n.muted) || void 0 === s ? void 0 : s.inContext
				},
				b = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.muted.loadMore[n]
				}
		},
		"./src/reddit/selectors/notificationPrefs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "g", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			}));
			const s = e => e.user.notificationPrefs.api.getPreferences.loaded,
				r = e => e.user.notificationPrefs.api.getPreferences.pending,
				o = e => e.user.notificationPrefs.api.setPreferences.pending,
				i = e => e.user.notificationPrefs.preferences,
				a = e => e.user.notificationPrefs.isNotificationPromptVisible,
				d = e => e.user.notificationPrefs.isAskNotificationPromptVisible,
				c = (e, t) => {
					var n, s;
					const r = (e => e.user.notificationPrefs.pushSettingsLayout)(e),
						o = null === (n = null == r ? void 0 : r.rows) || void 0 === n ? void 0 : n.byId;
					return o && (null === (s = o[t]) || void 0 === s ? void 0 : s.isEnabled)
				}
		},
		"./src/reddit/selectors/notificationsInbox.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return i
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "h", (function() {
				return f
			}));
			var s = n("./src/lib/notifications/constants.ts"),
				r = n("./src/reddit/actions/notifications/utils.ts"),
				o = n("./node_modules/reselect/es/index.js");
			const i = e => e.notificationsInbox && e.notificationsInbox.api && e.notificationsInbox.api.pending,
				a = e => e.notificationsInbox && e.notificationsInbox.pageInfo,
				d = Object(o.a)(a, e => !(!e || !e.hasNextPage)),
				c = Object(o.a)(a, e => e && e.endCursor),
				l = e => e.notificationsInbox && e.notificationsInbox.notifications,
				u = Object(o.a)(l, e => e.slice(0, 5)),
				m = e => e.notificationsInbox && e.notificationsInbox.earlierDividerIndex,
				p = Object(o.a)(l, m, (e, t) => {
					if (t) {
						const n = parseInt(t);
						return e.slice(0, n)
					}
					return e
				}),
				b = Object(o.a)(l, m, (e, t) => {
					if (t) {
						const n = parseInt(t);
						return e.slice(n)
					}
					return null
				}),
				f = Object(o.a)(r.a, e => e === s.d.NotificationsSupported)
		},
		"./src/reddit/selectors/onboarding.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return h
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "a", (function() {
				return x
			})), n.d(t, "b", (function() {
				return E
			})), n.d(t, "e", (function() {
				return O
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/safeJSONParse/index.ts"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/lib/isFakeSubreddit/index.ts"),
				i = n("./src/reddit/constants/experiments.ts"),
				a = n("./src/reddit/constants/parameters.ts"),
				d = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				c = n("./src/reddit/helpers/onboarding/reonboarding.ts"),
				l = n("./src/reddit/selectors/activeModal.ts"),
				u = n("./src/reddit/selectors/emailVerification.ts"),
				m = n("./src/reddit/selectors/experiments/onboarding.ts"),
				p = n("./src/reddit/selectors/experiments/targetedOnboardingSkip.ts"),
				b = n("./src/reddit/selectors/platform.ts"),
				f = n("./src/reddit/selectors/user.ts");
			const h = e => {
					const t = Object(b.q)(e);
					return Boolean((null == t ? void 0 : t[a.B]) && Object(s.a)(t[a.B]))
				},
				g = e => e.onboarding.shouldSkipOnboardingState,
				v = Object(r.a)(f.S, f.R, h, g, e => {
					var t;
					const n = null === (t = e.platform.currentPage) || void 0 === t ? void 0 : t.urlParams,
						s = n.subredditName;
					return Object(p.a)(e) !== i.pg.TargetedOnboarding || s && Object(o.a)(s, {
						countryCode: n.countryCode,
						languageCode: n.languageCode
					}) || !Object.keys(n).length
				}, (e, t, n, s, r) => (e || t) && n && !s && r),
				x = e => {
					const {
						genderUpdateState: t
					} = e.onboarding;
					if (t.success || t.failure) return t
				},
				E = Object(r.a)(m.j, e => e.onboarding.interestTopicRecommendationsState, (e, t) => e && !Object(i.Kg)(e) ? t : null),
				O = Object(r.a)(m.j, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(d.K)(n) || Object(d.L)(n) || Object(d.z)(n)
				}, l.b, u.a, g, (e, t, n, s, r) => e === i.pb.PopoverFeed15 && t && Object(c.c)() && !n && !s && !r)
		},
		"./src/reddit/selectors/postGuidance.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			}));
			const s = (e, t) => {
					let {
						subredditName: n
					} = t;
					return e.postGuidance.api.fetch.pending[n.toLowerCase()] || !1
				},
				r = (e, t) => {
					let {
						subredditName: n
					} = t;
					return e.postGuidance.models[n.toLowerCase()]
				},
				o = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.postGuidance.allowlist[n]
				},
				i = e => e.creations.formState.postGuidance.isBlockRuleTriggered,
				a = e => e.creations.formState.postGuidance.titleTriggeredRules,
				d = e => e.creations.formState.postGuidance.bodyTriggeredRules,
				c = e => e.creations.formState.postGuidance.uniqueRules
		},
		"./src/reddit/selectors/removalReasons.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = (e, t) => {
					let {
						subredditId: n
					} = t;
					if (e.features.removalReasons.reasonOrder[n]) {
						return e.features.removalReasons.reasonOrder[n].map(t => e.features.removalReasons.models[t])
					}
					return []
				},
				r = e => e.features.removalReasons.removedItemIds && e.features.removalReasons.removedItemIds.itemIds.length ? e.features.removalReasons.removedItemIds : null,
				o = e => e.features.removalReasons.api.pending
		},
		"./src/reddit/selectors/removedPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "d", (function() {
				return h
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				i = n("./src/reddit/helpers/getRichTextContent/index.ts"),
				a = n("./src/reddit/models/Media/index.ts"),
				d = n("./src/reddit/models/Post/index.ts"),
				c = n("./src/reddit/selectors/user.ts");
			const l = new Set([d.g.AntiEvilOps, d.g.AutomodFiltered, d.g.CommunityOps, d.g.ContentTakedown, d.g.CopyrightTakedown, d.g.Moderator, d.g.Reddit]),
				u = new Set([d.g.Author, d.g.AuthorDeleted]),
				m = Object(r.a)(o.a, e => {
					var t;
					if (!e) return !1;
					if (e.removedByCategory) {
						const t = e.removedByCategory;
						return l.has(t)
					}
					if (e.created > Date.UTC(2019, 0)) return !1;
					const n = s.fbt._("[removed]", null, {
						hk: "2CBRa4"
					}).toString();
					let r = Object(i.b)(e);
					return r || (null === (t = e.media) || void 0 === t ? void 0 : t.type) !== a.o.TEXT || (r = e.media.markdownContent), r === n
				}),
				p = Object(r.a)(o.a, e => {
					var t;
					if (!e) return !1;
					if (e.removedByCategory) {
						const t = e.removedByCategory;
						return u.has(t)
					}
					if (e.created > Date.UTC(2019, 0)) return !1;
					const n = s.fbt._("[deleted]", null, {
						hk: "12mOne"
					}).toString();
					let r = Object(i.b)(e);
					return r || (null === (t = e.media) || void 0 === t ? void 0 : t.type) !== a.o.TEXT || (r = e.media.markdownContent), r === n
				}),
				b = Object(r.a)(o.a, e => {
					if (!e) return !1;
					if (e && e.isSpam) return !1;
					if (e.removedByCategory) {
						const t = e.removedByCategory;
						return u.has(t)
					}
					return !(e.created > Date.UTC(2019, 0))
				}),
				f = Object(r.a)(c.m, o.a, (e, t) => !!((null == e ? void 0 : e.id) && (null == t ? void 0 : t.authorId)) && e.id === t.authorId),
				h = Object(r.a)(o.a, e => !(!e || !1 !== e.isRobotIndexable))
		},
		"./src/reddit/selectors/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return i
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "i", (function() {
				return c
			})), n.d(t, "j", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "q", (function() {
				return b
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "p", (function() {
				return g
			})), n.d(t, "k", (function() {
				return v
			})), n.d(t, "a", (function() {
				return x
			})), n.d(t, "r", (function() {
				return E
			})), n.d(t, "m", (function() {
				return O
			})), n.d(t, "n", (function() {
				return C
			})), n.d(t, "d", (function() {
				return A
			})), n.d(t, "e", (function() {
				return y
			})), n.d(t, "o", (function() {
				return j
			})), n.d(t, "b", (function() {
				return I
			}));
			var s = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				r = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/models/ScheduledPost/index.ts");
			const i = (e, t) => {
					let {
						subredditId: n
					} = t;
					return ((e, t) => {
						let {
							subredditId: n,
							type: s
						} = t;
						return !!e.posts.scheduledPosts[s].models[n]
					})(e, {
						subredditId: n,
						type: o.g.standalonePosts
					})
				},
				a = (e, t) => {
					let {
						subredditId: n,
						type: s
					} = t;
					return !!e.posts.scheduledPosts[s].pageInfo[n] && e.posts.scheduledPosts[s].pageInfo[n].hasNextPage
				},
				d = (e, t) => {
					let {
						subredditId: n,
						type: s
					} = t;
					return e.posts.scheduledPosts[s].pageInfo[n] ? e.posts.scheduledPosts[s].pageInfo[n].endCursor : null
				},
				c = e => e.posts.scheduledPosts.api.pending,
				l = e => e.posts.scheduledPosts.api.pendingUpdate,
				u = e => e.posts.scheduledPosts.api.error,
				m = {},
				p = [],
				b = (e, t) => {
					let {
						subredditId: n
					} = t;
					return (e.posts.scheduledPosts.standalonePosts.postOrder[n] || p).filter(t => !!(e.posts.scheduledPosts.standalonePosts.models[n] || m)[t]).map(t => e.posts.scheduledPosts.standalonePosts.models[n][t])
				},
				f = (e, t) => {
					let {
						subredditId: n
					} = t;
					return (e.posts.scheduledPosts.recurringPosts.postOrder[n] || p).filter(t => !!(e.posts.scheduledPosts.recurringPosts.models[n] || m)[t]).map(t => e.posts.scheduledPosts.recurringPosts.models[n][t])
				},
				h = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s,
						type: r
					} = t;
					return (e.posts.scheduledPosts[r].models[n] || m)[s] || void 0
				},
				g = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s
					} = t;
					return h(e, {
						subredditId: n,
						scheduledPostId: s,
						type: o.g.standalonePosts
					})
				},
				v = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s
					} = t;
					const r = h(e, {
						subredditId: n,
						scheduledPostId: s,
						type: o.g.recurringPosts
					});
					return r || r
				},
				x = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s
					} = t;
					return g(e, {
						subredditId: n,
						scheduledPostId: s
					}) || v(e, {
						subredditId: n,
						scheduledPostId: s
					})
				},
				E = e => e.creations.formData.scheduledPostId,
				O = e => {
					let {
						scheduledPost: t
					} = e;
					return (e => {
						let {
							flair: t,
							isNsfw: n,
							isSpoiler: o,
							isOriginalContent: i
						} = e;
						const a = [];
						return i && a.push({
							text: "OC",
							type: r.f.Oc
						}), t && a.push(...Object(s.c)(t)), o && a.push({
							text: "spoiler",
							type: r.f.Spoiler
						}), n && a.push({
							text: "nsfw",
							type: r.f.Nsfw
						}), a
					})(t)
				},
				C = e => {
					let {
						scheduledPost: t
					} = e;
					const n = O({
							scheduledPost: t
						}),
						s = n.find(e => e.type === r.f.Richtext);
					return s || (n.find(e => e.type === r.f.Text) || null)
				},
				A = e => e.posts.scheduledPosts[o.g.recurringPosts].editModal.scheduledPostId,
				y = e => e.posts.scheduledPosts[o.g.recurringPosts].editModal.subredditId,
				j = e => e.posts.scheduledPosts.api.pendingUpdate,
				I = e => e.posts.scheduledPosts.api.creationToken
		},
		"./src/reddit/selectors/seo/linksModule.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/selectors/user.ts");
			const o = e => !Object(r.S)(e) && e.seo.linksModule.frontpage || null,
				i = e => {
					const t = e.split("/");
					if ("r" === t[1]) return t[2]
				},
				a = Object(s.a)(o, e => e ? e.map(e => ({
					...e,
					links: e.links.map(e => ({
						...e,
						title: i(e.url)
					})).filter(e => e.title)
				})) : null),
				d = Object(s.a)(a, e => e ? e.map(e => ({
					...e,
					links: e.links.filter(e => e.visible)
				})) : null),
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = ((e, t) => {
						let {
							subredditId: n
						} = t;
						return e.seo.linksModule.subreddits && e.seo.linksModule.subreddits[n]
					})(e, {
						subredditId: n
					});
					return s && s.subreddits
				}
		},
		"./src/reddit/selectors/seo/topicLinks.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = (e, t) => {
				let {
					subredditId: n
				} = t;
				return e.seo.topicLinks.subreddits && e.seo.topicLinks.subreddits[n]
			}
		},
		"./src/reddit/selectors/subredditModeration.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return i
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "o", (function() {
				return l
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "k", (function() {
				return b
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "i", (function() {
				return v
			})), n.d(t, "a", (function() {
				return x
			})), n.d(t, "f", (function() {
				return E
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/SubredditModeration/index.ts");
			const o = [],
				i = Object(s.a)((e, t) => {
					let {
						subredditId: n,
						before: s,
						after: o
					} = t;
					const i = Object(r.e)(n, o, s),
						a = e.pages.modHub.moderators.userOrder.data[n] && e.pages.modHub.moderators.userOrder.data[n][i];
					return a ? a.map(t => e.pages.modHub.moderators.models[n][t]) : []
				}),
				a = (e, t, n) => !!e.pages.modHub.moderators.models[t] && !!e.pages.modHub.moderators.models[t][n],
				d = (e, t) => {
					let {
						subredditId: n,
						beforeEditable: s,
						afterEditable: o
					} = t;
					const i = Object(r.e)(n, o, s),
						a = e.pages.modHub.moderators.editableUserOrder.data[n] && e.pages.modHub.moderators.editableUserOrder.data[n][i];
					return a ? a.map(t => e.pages.modHub.moderators.editableModerators[n][t]) : []
				},
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.editableModerators[n] || null
				},
				l = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.models[n] || null
				},
				u = e => !!e.pages.modHub.moderators.search.api.pending,
				m = e => e.pages.modHub.moderators.search.result,
				p = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !!e.pages.modHub.moderators.invitePending[n]
				},
				b = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.loadMoreModerators[n] && e.pages.modHub.moderators.loadMoreModerators[n].after
				},
				f = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.loadMoreModerators[n] && e.pages.modHub.moderators.loadMoreModerators[n].before
				},
				h = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.loadMoreEditableModerators[n] && e.pages.modHub.moderators.loadMoreEditableModerators[n].after
				},
				g = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.loadMoreEditableModerators[n] && e.pages.modHub.moderators.loadMoreEditableModerators[n].before
				},
				v = (e, t) => {
					const n = Object(r.e)(t.subredditId, t.after, t.before);
					return !!e.pages.modHub.moderators.userOrder.api.pending[n]
				},
				x = (e, t) => {
					const n = Object(r.e)(t.subredditId, t.afterEditable, t.beforeEditable);
					return !!e.pages.modHub.moderators.editableUserOrder.api.pending[n]
				},
				E = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.pages.modHub.moderators.invitedModerators.userOrder[n];
					return s ? s.map(t => e.pages.modHub.moderators.invitedModerators.models[n][t]) : o
				})
		},
		"./src/reddit/selectors/subredditWiki.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "p", (function() {
				return c
			})), n.d(t, "q", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "k", (function() {
				return g
			})), n.d(t, "l", (function() {
				return v
			})), n.d(t, "e", (function() {
				return x
			})), n.d(t, "h", (function() {
				return E
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "g", (function() {
				return C
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/helpers/wiki/makeWikiPageKey.ts");
			const o = [],
				i = (e, t) => {
					var n;
					const {
						subredditName: s
					} = t;
					if (null === (n = e.pages) || void 0 === n ? void 0 : n.subredditWiki) return e.pages.subredditWiki.directory[s.toLowerCase()]
				},
				a = (e, t) => {
					const {
						subredditName: n
					} = t;
					return !!e.subreddits.api.wiki.pending[n.toLowerCase()]
				},
				d = (e, t) => {
					var n;
					const s = Object(r.a)(t);
					if (null === (n = e.pages) || void 0 === n ? void 0 : n.subredditWiki) return e.pages.subredditWiki.pages[s]
				},
				c = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.pages.subredditWiki.revisions.listings[n]
				},
				l = (e, t) => {
					let {
						listingKey: n
					} = t;
					return !!e.pages.subredditWiki.revisions.api.pending[n]
				},
				u = (e, t) => {
					let {
						listingKey: n
					} = t;
					return !!e.pages.subredditWiki.revisions.api.error[n]
				},
				m = (e, t) => {
					return (e => e.pages.subredditWiki.revisions.models)(e)[t.revisionId]
				},
				p = (e, t) => {
					let {
						key: n
					} = t;
					return e.pages.subredditWiki.diff[n]
				},
				b = (e, t) => {
					const n = Object(r.a)(t);
					return e.pages.subredditWiki.pageSettings[n]
				},
				f = (e, t) => {
					const {
						subredditName: n
					} = t;
					return !!e.pages.subredditWiki.wikiContributors.listing.api.pending[n.toLowerCase()]
				},
				h = Object(s.a)((e, t) => {
					let {
						subredditName: n
					} = t;
					const s = n.toLowerCase(),
						r = e.pages.subredditWiki.wikiContributors.listing,
						i = r.userOrder[s],
						a = r.models[s];
					return i ? i.map(e => a[e]) : o
				}),
				g = (e, t) => {
					const {
						subredditName: n
					} = t;
					return e.pages.subredditWiki.wikiContributors.listing.afterToken[n.toLowerCase()]
				},
				v = (e, t) => {
					const {
						subredditName: n
					} = t;
					return e.pages.subredditWiki.wikiContributors.search[n.toLowerCase()]
				},
				x = (e, t) => {
					const {
						subredditName: n
					} = t;
					return !!e.pages.subredditWiki.wikiBannedContributors.listing.api.pending[n.toLowerCase()]
				},
				E = Object(s.a)((e, t) => {
					let {
						subredditName: n
					} = t;
					const s = n.toLowerCase(),
						r = e.pages.subredditWiki.wikiBannedContributors.listing,
						i = r.userOrder[s],
						a = r.models[s];
					return i ? i.map(e => a[e]) : o
				}),
				O = (e, t) => {
					const {
						subredditName: n
					} = t;
					return e.pages.subredditWiki.wikiBannedContributors.listing.afterToken[n.toLowerCase()]
				},
				C = (e, t) => {
					const {
						subredditName: n
					} = t;
					return e.pages.subredditWiki.wikiBannedContributors.search[n.toLowerCase()]
				}
		},
		"./src/reddit/selectors/tags.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "n", (function() {
				return b
			})), n.d(t, "A", (function() {
				return f
			})), n.d(t, "B", (function() {
				return h
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "j", (function() {
				return v
			})), n.d(t, "l", (function() {
				return E
			})), n.d(t, "r", (function() {
				return O
			})), n.d(t, "t", (function() {
				return C
			})), n.d(t, "p", (function() {
				return I
			})), n.d(t, "b", (function() {
				return k
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "c", (function() {
				return w
			})), n.d(t, "o", (function() {
				return T
			})), n.d(t, "k", (function() {
				return P
			})), n.d(t, "z", (function() {
				return N
			})), n.d(t, "y", (function() {
				return D
			})), n.d(t, "u", (function() {
				return M
			})), n.d(t, "a", (function() {
				return R
			})), n.d(t, "q", (function() {
				return L
			})), n.d(t, "C", (function() {
				return B
			})), n.d(t, "w", (function() {
				return F
			})), n.d(t, "s", (function() {
				return H
			})), n.d(t, "x", (function() {
				return G
			})), n.d(t, "h", (function() {
				return Q
			})), n.d(t, "v", (function() {
				return q
			})), n.d(t, "D", (function() {
				return W
			})), n.d(t, "m", (function() {
				return z
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/some.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/values.js"),
				i = n.n(o),
				a = n("./src/lib/objectSelector/index.ts"),
				d = n("./src/reddit/helpers/tags/index.ts"),
				c = n("./src/reddit/models/Tags/index.ts");
			const l = e => e.tags.creation.selectedOptions || [],
				u = e => {
					const t = [];
					for (let n = 0; n < l(e).length; n++) l(e)[n].id && t.push(l(e)[n].id);
					return t || []
				},
				m = e => (l(e) || []).filter(e => !!e.displayText).map(e => e.displayText),
				p = e => {
					const t = [];
					for (let n = 0; n < l(e).length; n++) l(e)[n].id || t.push(l(e)[n].displayText);
					return t || []
				},
				b = e => Object.keys(e.tags.models.globalSubredditTags).length > 0,
				f = e => e.tags.api.create.error || e.tags.api.deleteTag.error || e.tags.api.fetch.error || e.tags.api.update.error,
				h = e => e.tags.api.create.pending || e.tags.api.deleteTag.pending || e.tags.api.fetch.pending || e.tags.api.update.pending,
				g = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.inputByItemId[n] || ""
				},
				v = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.suggestedInputByItemId[n] || ""
				},
				x = [],
				E = (e, t) => {
					let {
						subredditId: n
					} = t;
					return r()(O(e, {
						subredditId: n
					}), e => !!e.action) || r()(A(e, {
						subredditId: n
					}), e => !!e.action)
				},
				O = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.selectedOptions[n] || x
				},
				C = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.selectedSuggestedOptions[n] || x
				},
				A = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.deselectedOptions[n] || x
				},
				y = {},
				j = {},
				I = e => e.tags.availableGlobalTagOrder.recommendedGlobal.map(t => e.tags.models.globalSubredditTags[t]),
				k = e => e.tags.models.globalSubredditTags,
				_ = e => e.tags.availableGlobalTagOrder.global.map(t => e.tags.models.globalSubredditTags[t]),
				S = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.models.subredditScopedTags[n] || j
				},
				w = (e, t) => {
					const n = i()(t);
					for (let s = 0; s < n.length; s++)
						if (n[s].text.toLowerCase().trim() === e.toLowerCase().trim()) return n[s];
					return null
				},
				T = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.itemTags[n] || y
				},
				P = (e, t) => {
					let {
						itemId: n
					} = t;
					return !!e.tags.models.itemTags[n]
				},
				N = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.suggestedItemTags[n] || y
				},
				D = (e, t) => {
					let {
						itemId: n
					} = t;
					return i()(N(e, {
						itemId: n
					})).filter(e => e.isRelevant).map(e => Object(c.e)(e, !0))
				},
				M = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.sortedItemTags[n] || []
				},
				R = Object(a.a)((e, t) => {
					let {
						thingId: n,
						suggested: s = !1
					} = t;
					const r = F(e, {
						subredditId: n
					});
					return i()(((e, t) => {
						let {
							thingId: n,
							suggested: s = !1
						} = t;
						const r = (s ? v(e, {
								subredditId: n
							}) : g(e, {
								subredditId: n
							})) ? _(e) : I(e),
							o = s ? C(e, {
								subredditId: n
							}) : O(e, {
								subredditId: n
							}),
							i = r.reduce((e, t) => (e[t.id] = Object(c.f)(t), e), {});
						return o.reduce((e, t) => (t.id && e[t.id] && (e[t.id].selected = !0), e), i)
					})(e, {
						thingId: n,
						suggested: s
					})).filter(e => !e.selected && e.id !== r)
				}),
				L = (e, t) => {
					let {
						subredditId: n
					} = t;
					return O(e, {
						subredditId: n
					}).concat(A(e, {
						subredditId: n
					}))
				},
				B = (e, t) => {
					let {
						subredditId: n
					} = t;
					return O(e, {
						subredditId: n
					}).filter(d.b).map(e => ({
						text: e.displayText,
						type: c.c.CLASSIFICATION
					}))
				},
				F = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.models.subredditPrimaryTagId[n] || null
				},
				U = (e, t) => t && e.tags.models.globalSubredditTags[t] || null,
				H = (e, t) => {
					const n = e.tags.selected.selectedPrimaryTagId[t.subredditId] || null;
					return U(e, n)
				},
				G = (e, t) => {
					const n = F(e, t);
					return U(e, n)
				},
				Q = e => e.tags.creation.selectedPrimaryTagId || null,
				q = e => {
					const t = Q(e);
					return U(e, t)
				},
				W = e => e.tags.api.updatePrimaryTag.pending,
				z = (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object.keys(T(e, {
						itemId: n
					})).length > 0
				}
		},
		"./src/reddit/selectors/tooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			const s = e => e.tooltip.tooltipId,
				r = e => t => t.tooltip.tooltipId === e,
				o = e => e.tooltip.params
		},
		"./src/reddit/selectors/userFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/selectors/gold/powerups/index.ts"),
				i = n("./src/reddit/selectors/moderatorPermissions.ts"),
				a = n("./src/lib/initializeClient/installReducer.ts"),
				d = n("./src/reddit/reducers/features/userFlair/index.ts");
			Object(a.a)({
				features: {
					userFlair: d.a
				}
			});
			const c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.features.userFlair[n]
				},
				l = (e, t) => {
					let {
						subredditId: n
					} = t;
					var s, r;
					return null === (s = e.features.userFlair[n]) || void 0 === s || !s.displaySettings || !!(null === (r = e.features.userFlair[n].displaySettings) || void 0 === r ? void 0 : r.isEnabled)
				},
				u = (e, t) => {
					let {
						subredditId: n
					} = t;
					var s, o;
					return (null === (s = e.features.userFlair[n]) || void 0 === s ? void 0 : s.displaySettings) ? null === (o = e.features.userFlair[n].displaySettings) || void 0 === o ? void 0 : o.position : r.b.Right
				},
				m = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = c(e, {
						subredditId: n
					});
					if (s && s.displaySettings && s.permissions) return {
						type: r.d.UserFlair,
						displaySettings: s.displaySettings,
						permissions: s.permissions
					}
				}),
				p = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = l(e, {
							subredditId: n
						}),
						r = m(e, {
							subredditId: n
						}),
						o = c(e, {
							subredditId: n
						});
					if (!s || !r || !o) return !1;
					if (o.applied) return !0;
					const a = Object(i.g)(e, {
							subredditId: n
						}),
						{
							canUserChange: d
						} = r.permissions;
					return !!(o.templateIds || []).find(e => {
						return !o.templates[e].modOnly || a
					}) && d
				},
				b = (e, t) => {
					let {
						subredditId: n
					} = t;
					if (!n) return !1;
					const s = p(e, {
							subredditId: n
						}),
						r = Object(o.e)(e, {
							subredditId: n
						});
					return s || r
				}
		},
		"./src/reddit/selectors/userPrefs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/selectors/user.ts");
			const o = e => {
					const t = Object(r.S)(e);
					if (i(e)) return !1;
					const {
						subscriptionsPinned: n
					} = e.user.prefs;
					return void 0 === n && !t || !!n
				},
				i = e => !(!e.platform.currentPage || !e.platform.currentPage.meta || e.platform.currentPage.meta.name !== s.Tb.MODERATION_PAGES),
				a = e => e.user.prefs.reduceAnimationsFromAwards,
				d = e => !!e.user.prefs.over18
		},
		"./src/reddit/selectors/widgets.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "k", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "i", (function() {
				return b
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "j", (function() {
				return g
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "g", (function() {
				return x
			})), n.d(t, "b", (function() {
				return E
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/constants/posts.ts"),
				o = n("./src/reddit/helpers/name/index.ts"),
				i = n("./src/reddit/helpers/widgets/index.tsx"),
				a = n("./src/reddit/selectors/profile.ts"),
				d = n("./src/reddit/selectors/subreddit.ts");
			const c = [],
				l = e => e.widgets.models,
				u = Object(s.a)((e, t) => Object(i.l)(t) ? e.widgets.models[t.widgetId] : Object(i.f)(t.widgetKind)),
				m = (e, t) => e.widgets.idCardIds[t.subredditId],
				p = (e, t) => {
					let n = t.subredditId;
					if (!n && t.subredditName && (n = Object(d.I)(e, t.subredditName)), n) {
						const t = m(e, {
							subredditId: n
						});
						if (t) return e.widgets.models[t]
					}
					return null
				},
				b = (e, t) => e.widgets.sidebar[t.subredditId] || [],
				f = (e, t) => e.widgets.menuIds[t.subredditId],
				h = (e, t) => {
					const n = f(e, t);
					return n ? e.widgets.models[n] : null
				},
				g = (e, t) => {
					const n = e.widgets.sidebar[t.subredditId];
					return Array.isArray(n) ? n.reduce((t, n) => {
						const s = e.widgets.models[n];
						return s && t.push(s.kind), t
					}, []) : c
				},
				v = (e, t) => {
					const n = b(e, t);
					for (const s of n) {
						const t = e.widgets.models[s];
						if ("subreddit-rules" === t.kind) return t
					}
					return null
				},
				x = (e, t) => {
					const n = b(e, t).map(t => e.widgets.models[t]).filter(e => "post-flair" === e.kind);
					return n.length ? n : null
				},
				E = Object(s.a)((e, t) => {
					if (t.type === r.a.PROFILE) {
						const n = Object(a.k)(e, {
							profileName: t.name
						});
						return n ? {
							profile: {
								id: n.id,
								name: Object(o.i)(n.name)
							}
						} : {}
					}
					const n = Object(d.C)(e, {
							subredditName: t.name
						}),
						s = Object(d.z)(e, {
							subredditName: t.name
						});
					return {
						subreddit: {
							categoryName: s ? s.contentCategory : null,
							id: n.id,
							name: Object(o.i)(n.name)
						}
					}
				})
		},
		"./src/reddit/singleton/EventSystem.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./src/lib/fastdom/index.ts"),
				o = n("./src/reddit/actions/jsApi.ts");
			const i = "JSAPI customEvent.detail.name is deprecated. Please upgrade to <meta>",
				a = "jsapi.consumer",
				d = "/r/redesign/wiki/jsapi";
			var c = n("./src/reddit/constants/jsapiEvents.ts");
			const l = 100;
			const u = new class {
				constructor() {
					if (this.queue = [], this.active = !1, "undefined" == typeof document) return;
					let e;
					this.store = new Promise(t => e = t), this.attachStore = t => e(t);
					const t = document.querySelectorAll(`meta[name="${a}"]`);
					t.length && (t.forEach(e => {
						const t = e.content;
						this.store.then(e => e.dispatch(o.b(t)))
					}), this.store.then(() => this.fireEventsQueue())), document.addEventListener(c.b, e => this.onReadyEvent(e), !0)
				}
				onReadyEvent(e) {
					let t;
					if (this.active = !0, e.target && e.target instanceof HTMLMetaElement && e.target.name === a && (t = e.target.content), !t) try {
						e.detail && (t = e.detail.name, console.warn(i, `${s.a.redditUrl}${d}`, e))
					} catch (n) {
						return void console.error(i, `${s.a.redditUrl}${d}`, n)
					}
					this.store.then(e => {
						e.dispatch(o.b(t || "")), this.fireEventsQueue()
					})
				}
				publish(e, t, n) {
					const s = {
						name: e,
						props: t,
						element: n
					};
					this.queue.push(s), this.queue.length > l && this.queue.shift(), this.active && this.fireEvent(s)
				}
				fireEvent(e) {
					e.element.dispatchEvent(new CustomEvent(e.name, {
						detail: e.props
					}))
				}
				fireEventsQueue() {
					r.a.read(() => {
						for (let e = 0; e < this.queue.length; e++) {
							const t = this.queue[e];
							this.fireEvent(t)
						}
					})
				}
			};
			t.a = u
		},
		"./src/redditGQL/operations/AddApprovedTalkHost.json": function(e) {
			e.exports = JSON.parse('{"id":"84b1688a0244"}')
		},
		"./src/redditGQL/operations/AddPredictionDrafts.json": function(e) {
			e.exports = JSON.parse('{"id":"c821ca1db9f1"}')
		},
		"./src/redditGQL/operations/AllModerators.json": function(e) {
			e.exports = JSON.parse('{"id":"fcd88a3eea91"}')
		},
		"./src/redditGQL/operations/BadgeIndicators.json": function(e) {
			e.exports = JSON.parse('{"id":"fbbc7389e1ff"}')
		},
		"./src/redditGQL/operations/BlockAwarder.json": function(e) {
			e.exports = JSON.parse('{"id":"9769ffbb7031"}')
		},
		"./src/redditGQL/operations/CancelPrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"fac88c91fec8"}')
		},
		"./src/redditGQL/operations/ChangePrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"614dbb8a54d2"}')
		},
		"./src/redditGQL/operations/ChangePredictionVote.json": function(e) {
			e.exports = JSON.parse('{"id":"90c7b71fa93f"}')
		},
		"./src/redditGQL/operations/CommentToxicity.json": function(e) {
			e.exports = JSON.parse('{"id":"445164f0825f"}')
		},
		"./src/redditGQL/operations/CommentsPageLastAuthorModNotes.json": function(e) {
			e.exports = JSON.parse('{"id":"1b7d106afc6c"}')
		},
		"./src/redditGQL/operations/CreateComment.json": function(e) {
			e.exports = JSON.parse('{"id":"f0b0ca6701b9"}')
		},
		"./src/redditGQL/operations/CreateModUserNote.json": function(e) {
			e.exports = JSON.parse('{"id":"10ad38be41ae"}')
		},
		"./src/redditGQL/operations/CreatePredictionTournament.json": function(e) {
			e.exports = JSON.parse('{"id":"cb5e7bbde98a"}')
		},
		"./src/redditGQL/operations/CreateScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"737d59db38fc"}')
		},
		"./src/redditGQL/operations/CreateSubredditTags.json": function(e) {
			e.exports = JSON.parse('{"id":"80c9a3cd96b8"}')
		},
		"./src/redditGQL/operations/DeleteInboxNotifications.json": function(e) {
			e.exports = JSON.parse('{"id":"ce2deb9deef7"}')
		},
		"./src/redditGQL/operations/DeleteModUserNote.json": function(e) {
			e.exports = JSON.parse('{"id":"c44e6467c4d7"}')
		},
		"./src/redditGQL/operations/DeleteScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"dea861ad7f0d"}')
		},
		"./src/redditGQL/operations/DeleteSubredditMuteSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"c518a45f60a5"}')
		},
		"./src/redditGQL/operations/DoesUserHavePostModPermission.json": function(e) {
			e.exports = JSON.parse('{"id":"124d4a37eca2"}')
		},
		"./src/redditGQL/operations/EndPredictionTournament.json": function(e) {
			e.exports = JSON.parse('{"id":"50c0ba265137"}')
		},
		"./src/redditGQL/operations/EventPostsBySubredditName.json": function(e) {
			e.exports = JSON.parse('{"id":"604fe2a6f1f6"}')
		},
		"./src/redditGQL/operations/FetchContentControls.json": function(e) {
			e.exports = JSON.parse('{"id":"58b71dbd3384"}')
		},
		"./src/redditGQL/operations/FetchGlobalTags.json": function(e) {
			e.exports = JSON.parse('{"id":"f4a581740c21"}')
		},
		"./src/redditGQL/operations/FetchModerationLogActions.json": function(e) {
			e.exports = JSON.parse('{"id":"bf67bf218716"}')
		},
		"./src/redditGQL/operations/FetchPostGuidanceConfig.json": function(e) {
			e.exports = JSON.parse('{"id":"8a6cc0e63320"}')
		},
		"./src/redditGQL/operations/FetchSubredditTags.json": function(e) {
			e.exports = JSON.parse('{"id":"bac623887684"}')
		},
		"./src/redditGQL/operations/FetchSubredditTrafficStats.json": function(e) {
			e.exports = JSON.parse('{"id":"d2b39ab0293a"}')
		},
		"./src/redditGQL/operations/FetchSubredditsNotificationSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"5d042135b4c5"}')
		},
		"./src/redditGQL/operations/GeoPlaceAutocomplete.json": function(e) {
			e.exports = JSON.parse('{"id":"8a89fd7c7db1"}')
		},
		"./src/redditGQL/operations/GetCommentById.json": function(e) {
			e.exports = JSON.parse('{"id":"b499034a4b88"}')
		},
		"./src/redditGQL/operations/GetDevPlatformMetadata.json": function(e) {
			e.exports = JSON.parse('{"id":"fbfb3b396dfe"}')
		},
		"./src/redditGQL/operations/GetModUserNotes.json": function(e) {
			e.exports = JSON.parse('{"id":"0eb0efc0bf02"}')
		},
		"./src/redditGQL/operations/GetPredictionChipPackages.json": function(e) {
			e.exports = JSON.parse('{"id":"5ce83e513fa5"}')
		},
		"./src/redditGQL/operations/GetPredictionCreationAllowance.json": function(e) {
			e.exports = JSON.parse('{"id":"d9fb5ec5128f"}')
		},
		"./src/redditGQL/operations/GetPredictionToken.json": function(e) {
			e.exports = JSON.parse('{"id":"26b911e67a5f"}')
		},
		"./src/redditGQL/operations/GetSingleDynamicConfig.json": function(e) {
			e.exports = JSON.parse('{"id":"02d1493c5e7e"}')
		},
		"./src/redditGQL/operations/GetSubredditCountrySiteSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"abd8b9be540b"}')
		},
		"./src/redditGQL/operations/GetSubredditQuestions.json": function(e) {
			e.exports = JSON.parse('{"id":"15c4ad40a0bc"}')
		},
		"./src/redditGQL/operations/GetSubredditWelcomeMessage.json": function(e) {
			e.exports = JSON.parse('{"id":"ba4eb4e2972f"}')
		},
		"./src/redditGQL/operations/GetTotalModNoteCount.json": function(e) {
			e.exports = JSON.parse('{"id":"bb325c103c55"}')
		},
		"./src/redditGQL/operations/GetTournaments.json": function(e) {
			e.exports = JSON.parse('{"id":"15c20a93ed51"}')
		},
		"./src/redditGQL/operations/GetTournamentsBaseInfo.json": function(e) {
			e.exports = JSON.parse('{"id":"cebfc8734cec"}')
		},
		"./src/redditGQL/operations/LastModActionInSubreddit.json": function(e) {
			e.exports = JSON.parse('{"id":"7888d2d30843"}')
		},
		"./src/redditGQL/operations/MaybeDeleteTagsAndUpdateItemTags.json": function(e) {
			e.exports = JSON.parse('{"id":"023547ccdaf6"}')
		},
		"./src/redditGQL/operations/ModActivitySummaryByID.json": function(e) {
			e.exports = JSON.parse('{"id":"d968e053a7b8"}')
		},
		"./src/redditGQL/operations/ModInsightsModQueueEntrypoint.json": function(e) {
			e.exports = JSON.parse('{"id":"963b46029a60"}')
		},
		"./src/redditGQL/operations/ModQueueItems.json": function(e) {
			e.exports = JSON.parse('{"id":"6fea93cb6fbb"}')
		},
		"./src/redditGQL/operations/ModQueueTriggers.json": function(e) {
			e.exports = JSON.parse('{"id":"0ac619d6eb7e"}')
		},
		"./src/redditGQL/operations/ModerationActionCategories.json": function(e) {
			e.exports = JSON.parse('{"id":"45bc34defbb5"}')
		},
		"./src/redditGQL/operations/MutedSubreddits.json": function(e) {
			e.exports = JSON.parse('{"id":"c09ff0d041c1"}')
		},
		"./src/redditGQL/operations/NotificationInboxFeed.json": function(e) {
			e.exports = JSON.parse('{"id":"be3e43b15ada"}')
		},
		"./src/redditGQL/operations/NotificationInboxFeedSlimmed.json": function(e) {
			e.exports = JSON.parse('{"id":"916e9e9be5e0"}')
		},
		"./src/redditGQL/operations/NotificationSettingsLayoutByChannel.json": function(e) {
			e.exports = JSON.parse('{"id":"d03522f8a8d4"}')
		},
		"./src/redditGQL/operations/OpenAISubRecWithDetail.json": function(e) {
			e.exports = JSON.parse('{"id":"aab58d632d84"}')
		},
		"./src/redditGQL/operations/PollVote.json": function(e) {
			e.exports = JSON.parse('{"id":"a20cc8dd230d"}')
		},
		"./src/redditGQL/operations/PopularFeedElements.json": function(e) {
			e.exports = JSON.parse('{"id":"11db30728cfb"}')
		},
		"./src/redditGQL/operations/ProfileFeed.json": function(e) {
			e.exports = JSON.parse('{"id":"e8d58a13151d"}')
		},
		"./src/redditGQL/operations/RedditorIdByName.json": function(e) {
			e.exports = JSON.parse('{"id":"a24cf5c8adf7"}')
		},
		"./src/redditGQL/operations/RedditorNameById.json": function(e) {
			e.exports = JSON.parse('{"id":"7206aafc3965"}')
		},
		"./src/redditGQL/operations/RemoveApprovedTalkHost.json": function(e) {
			e.exports = JSON.parse('{"id":"e016564e243a"}')
		},
		"./src/redditGQL/operations/ReportMessage.json": function(e) {
			e.exports = JSON.parse('{"id":"ae01229e1caa"}')
		},
		"./src/redditGQL/operations/ResolvePrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"d742e3019cfe"}')
		},
		"./src/redditGQL/operations/SetSubredditGeoPlace.json": function(e) {
			e.exports = JSON.parse('{"id":"ece6b91ed02d"}')
		},
		"./src/redditGQL/operations/SingleCommentById.json": function(e) {
			e.exports = JSON.parse('{"id":"7e1a2a69e2d6"}')
		},
		"./src/redditGQL/operations/SinglePostInfoById.json": function(e) {
			e.exports = JSON.parse('{"id":"7226f3bb6e27"}')
		},
		"./src/redditGQL/operations/SubmitScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"6f9e584d390a"}')
		},
		"./src/redditGQL/operations/SubredditAbout.json": function(e) {
			e.exports = JSON.parse('{"id":"4016ffe922f6"}')
		},
		"./src/redditGQL/operations/SubredditAchievementFlairs.json": function(e) {
			e.exports = JSON.parse('{"id":"97fec841c778"}')
		},
		"./src/redditGQL/operations/SubredditApprovedTalkHosts.json": function(e) {
			e.exports = JSON.parse('{"id":"86107f5fbae2"}')
		},
		"./src/redditGQL/operations/SubredditCustomEmojis.json": function(e) {
			e.exports = JSON.parse('{"id":"76faa900e33f"}')
		},
		"./src/redditGQL/operations/SubredditFlairedRedditorByName.json": function(e) {
			e.exports = JSON.parse('{"id":"11aba1560164"}')
		},
		"./src/redditGQL/operations/SubredditFlairedRedditors.json": function(e) {
			e.exports = JSON.parse('{"id":"d343c3cad2d0"}')
		},
		"./src/redditGQL/operations/SubredditInfo.json": function(e) {
			e.exports = JSON.parse('{"id":"29aee4089528"}')
		},
		"./src/redditGQL/operations/SubredditPage.json": function(e) {
			e.exports = JSON.parse('{"id":"e111e3a11997"}')
		},
		"./src/redditGQL/operations/SubredditPageExtra.json": function(e) {
			e.exports = JSON.parse('{"id":"abb696a96055"}')
		},
		"./src/redditGQL/operations/SubredditRules.json": function(e) {
			e.exports = JSON.parse('{"id":"c398abb500f1"}')
		},
		"./src/redditGQL/operations/SubredditScheduledPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"2289de7a3370"}')
		},
		"./src/redditGQL/operations/SubredditTopPredictors.json": function(e) {
			e.exports = JSON.parse('{"id":"a9f7697930b7"}')
		},
		"./src/redditGQL/operations/SubredditTournamentLeaderboard.json": function(e) {
			e.exports = JSON.parse('{"id":"e14e6d1892e6"}')
		},
		"./src/redditGQL/operations/SubredditWiki.json": function(e) {
			e.exports = JSON.parse('{"id":"5834be60ee7a"}')
		},
		"./src/redditGQL/operations/SubredditWikiBannedContributors.json": function(e) {
			e.exports = JSON.parse('{"id":"9b728f1ed735"}')
		},
		"./src/redditGQL/operations/SubredditWikiContributors.json": function(e) {
			e.exports = JSON.parse('{"id":"6ff60c2af7f1"}')
		},
		"./src/redditGQL/operations/SubredditWikiPageSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"03acb455993d"}')
		},
		"./src/redditGQL/operations/SubscribedSubreddits.json": function(e) {
			e.exports = JSON.parse('{"id":"ca83defc2e15"}')
		},
		"./src/redditGQL/operations/TopAwardedPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"8de8e31af067"}')
		},
		"./src/redditGQL/operations/TopAwardersLeaderboard.json": function(e) {
			e.exports = JSON.parse('{"id":"750ff4a757de"}')
		},
		"./src/redditGQL/operations/UpdateComment.json": function(e) {
			e.exports = JSON.parse('{"id":"3d83ef4f0375"}')
		},
		"./src/redditGQL/operations/UpdateCommentDistinguishState.json": function(e) {
			e.exports = JSON.parse('{"id":"e1f407c8ceba"}')
		},
		"./src/redditGQL/operations/UpdateCommentFollowState.json": function(e) {
			e.exports = JSON.parse('{"id":"0a2ed51664c5"}')
		},
		"./src/redditGQL/operations/UpdateCommentStickyState.json": function(e) {
			e.exports = JSON.parse('{"id":"236938d65d55"}')
		},
		"./src/redditGQL/operations/UpdateHatefulContentFilters.json": function(e) {
			e.exports = JSON.parse('{"id":"026bf4f1acc7"}')
		},
		"./src/redditGQL/operations/UpdateInboxActivitySeenState.json": function(e) {
			e.exports = JSON.parse('{"id":"85d656894a08"}')
		},
		"./src/redditGQL/operations/UpdateNotificationPreferences.json": function(e) {
			e.exports = JSON.parse('{"id":"129085be0500"}')
		},
		"./src/redditGQL/operations/UpdatePostRequirements.json": function(e) {
			e.exports = JSON.parse('{"id":"8732ab4560ce"}')
		},
		"./src/redditGQL/operations/UpdatePredictionTournament.json": function(e) {
			e.exports = JSON.parse('{"id":"87a472f54aa6"}')
		},
		"./src/redditGQL/operations/UpdateScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"db256acfa640"}')
		},
		"./src/redditGQL/operations/UpdateSubredditCountrySiteSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"c21fac68db2d"}')
		},
		"./src/redditGQL/operations/UpdateSubredditMuteAndNotificationLevelSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"2620d72fd633"}')
		},
		"./src/redditGQL/operations/UpdateSubredditMuteSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"432f6b475ece"}')
		},
		"./src/redditGQL/operations/UpdateSubredditNotificationSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"0af4f630a2e1"}')
		},
		"./src/redditGQL/operations/UpdateSubredditPrimaryTag.json": function(e) {
			e.exports = JSON.parse('{"id":"a2d0aa1efdbc"}')
		},
		"./src/redditGQL/operations/UpdateSubredditTagStatesRelevance.json": function(e) {
			e.exports = JSON.parse('{"id":"ee43ccb6e5eb"}')
		},
		"./src/redditGQL/operations/UpdateSubredditWelcomeMessage.json": function(e) {
			e.exports = JSON.parse('{"id":"1e4c7b58a2a4"}')
		},
		"./src/redditGQL/operations/UserSubredditsNotificationsLevel.json": function(e) {
			e.exports = JSON.parse('{"id":"775bcf2e4ca3"}')
		},
		"./src/redditGQL/operations/ValidateCreateSubreddit.json": function(e) {
			e.exports = JSON.parse('{"id":"4c43ed06b3c2"}')
		},
		"./src/redditGQL/operations/VotePrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"484780ada6a2"}')
		},
		"./src/redditGQL/operations/WhereToPostSubRec.json": function(e) {
			e.exports = JSON.parse('{"id":"11eb5d0b3ee3"}')
		},
		"./src/redditGQL/operations/WikiComparisonDiff.json": function(e) {
			e.exports = JSON.parse('{"id":"37afdc03bbf6"}')
		},
		"./src/redditGQL/operations/WikiRevisions.json": function(e) {
			e.exports = JSON.parse('{"id":"83e11ebf7cbf"}')
		}
	}
]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/ModerationPages.2d5960975e83d50fe7a6.js.map