// https://www.redditstatic.com/desktop2x/vendors~community-room.de85f202ce7a3b705a96.js
// Retrieved at 12/5/2022, 1:20:04 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
			["vendors~community-room"], {
				"./node_modules/@reddit/chat/dist/browser-matrix.js": function(e, t, r) {
					(function(e) {
						var t, n, i;
						! function e(r, n, i) {
							function o(a, c) {
								if (!n[a]) {
									if (!r[a]) {
										if (!c && "function" == typeof t && t) return t(a, !0);
										if (s) return s(a, !0);
										var l = new Error("Cannot find module '" + a + "'");
										throw l.code = "MODULE_NOT_FOUND", l
									}
									var u = n[a] = {
										exports: {}
									};
									r[a][0].call(u.exports, (function(e) {
										return o(r[a][1][e] || e)
									}), u, u.exports, e, r, n, i)
								}
								return n[a].exports
							}
							for (var s = "function" == typeof t && t, a = 0; a < i.length; a++) o(i[a]);
							return o
						}({
							1: [function(e, t, r) {
								function n(e) {
									return t.exports = n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
										return typeof e
									} : function(e) {
										return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
									}, t.exports.__esModule = !0, t.exports.default = t.exports, n(e)
								}
								t.exports = n, t.exports.__esModule = !0, t.exports.default = t.exports
							}, {}],
							2: [function(e, t, r) {
								"use strict";
								for (var n = /[\\\"\x00-\x1F]/g, i = {}, o = 0; o < 32; ++o) i[String.fromCharCode(o)] = "\\U" + ("0000" + o.toString(16)).slice(-4).toUpperCase();

								function s(e) {
									return n.lastIndex = 0, e.replace(n, (function(e) {
										return i[e]
									}))
								}

								function a(e) {
									switch (typeof e) {
										case "string":
											return '"' + s(e) + '"';
										case "number":
											return isFinite(e) ? e : "null";
										case "boolean":
											return e;
										case "object":
											return null === e ? "null" : Array.isArray(e) ? function(e) {
												for (var t = "[", r = "", n = 0; n < e.length; ++n) r += t, t = ",", r += a(e[n]);
												return "," != t ? "[]" : r + "]"
											}(e) : function(e) {
												var t = "{",
													r = "",
													n = Object.keys(e);
												n.sort();
												for (var i = 0; i < n.length; ++i) {
													var o = n[i];
													r += t + '"' + s(o) + '":', t = ",", r += a(e[o])
												}
												return "," != t ? "{}" : r + "}"
											}(e);
										default:
											throw new Error("Cannot stringify: " + typeof e)
									}
								}
								i["\b"] = "\\b", i["\t"] = "\\t", i["\n"] = "\\n", i["\f"] = "\\f", i["\r"] = "\\r", i['"'] = '\\"', i["\\"] = "\\\\", t.exports = {
									stringify: a
								}
							}, {}],
							3: [function(e, t, r) {
								"use strict";
								const n = r;
								n.bignum = e("bn.js"), n.define = e("./asn1/api").define, n.base = e("./asn1/base"), n.constants = e("./asn1/constants"), n.decoders = e("./asn1/decoders"), n.encoders = e("./asn1/encoders")
							}, {
								"./asn1/api": 4,
								"./asn1/base": 6,
								"./asn1/constants": 10,
								"./asn1/decoders": 12,
								"./asn1/encoders": 15,
								"bn.js": 19
							}],
							4: [function(e, t, r) {
								"use strict";
								const n = e("./encoders"),
									i = e("./decoders"),
									o = e("inherits");

								function s(e, t) {
									this.name = e, this.body = t, this.decoders = {}, this.encoders = {}
								}
								r.define = function(e, t) {
									return new s(e, t)
								}, s.prototype._createNamed = function(e) {
									const t = this.name;

									function r(e) {
										this._initNamed(e, t)
									}
									return o(r, e), r.prototype._initNamed = function(t, r) {
										e.call(this, t, r)
									}, new r(this)
								}, s.prototype._getDecoder = function(e) {
									return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(i[e])), this.decoders[e]
								}, s.prototype.decode = function(e, t, r) {
									return this._getDecoder(t).decode(e, r)
								}, s.prototype._getEncoder = function(e) {
									return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(n[e])), this.encoders[e]
								}, s.prototype.encode = function(e, t, r) {
									return this._getEncoder(t).encode(e, r)
								}
							}, {
								"./decoders": 12,
								"./encoders": 15,
								inherits: 147
							}],
							5: [function(e, t, r) {
								"use strict";
								const n = e("inherits"),
									i = e("../base/reporter").Reporter,
									o = e("safer-buffer").Buffer;

								function s(e, t) {
									i.call(this, t), o.isBuffer(e) ? (this.base = e, this.offset = 0, this.length = e.length) : this.error("Input not Buffer")
								}

								function a(e, t) {
									if (Array.isArray(e)) this.length = 0, this.value = e.map((function(e) {
										return a.isEncoderBuffer(e) || (e = new a(e, t)), this.length += e.length, e
									}), this);
									else if ("number" == typeof e) {
										if (!(0 <= e && e <= 255)) return t.error("non-byte EncoderBuffer value");
										this.value = e, this.length = 1
									} else if ("string" == typeof e) this.value = e, this.length = o.byteLength(e);
									else {
										if (!o.isBuffer(e)) return t.error("Unsupported type: " + typeof e);
										this.value = e, this.length = e.length
									}
								}
								n(s, i), r.DecoderBuffer = s, s.isDecoderBuffer = function(e) {
									if (e instanceof s) return !0;
									return "object" == typeof e && o.isBuffer(e.base) && "DecoderBuffer" === e.constructor.name && "number" == typeof e.offset && "number" == typeof e.length && "function" == typeof e.save && "function" == typeof e.restore && "function" == typeof e.isEmpty && "function" == typeof e.readUInt8 && "function" == typeof e.skip && "function" == typeof e.raw
								}, s.prototype.save = function() {
									return {
										offset: this.offset,
										reporter: i.prototype.save.call(this)
									}
								}, s.prototype.restore = function(e) {
									const t = new s(this.base);
									return t.offset = e.offset, t.length = this.offset, this.offset = e.offset, i.prototype.restore.call(this, e.reporter), t
								}, s.prototype.isEmpty = function() {
									return this.offset === this.length
								}, s.prototype.readUInt8 = function(e) {
									return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(e || "DecoderBuffer overrun")
								}, s.prototype.skip = function(e, t) {
									if (!(this.offset + e <= this.length)) return this.error(t || "DecoderBuffer overrun");
									const r = new s(this.base);
									return r._reporterState = this._reporterState, r.offset = this.offset, r.length = this.offset + e, this.offset += e, r
								}, s.prototype.raw = function(e) {
									return this.base.slice(e ? e.offset : this.offset, this.length)
								}, r.EncoderBuffer = a, a.isEncoderBuffer = function(e) {
									if (e instanceof a) return !0;
									return "object" == typeof e && "EncoderBuffer" === e.constructor.name && "number" == typeof e.length && "function" == typeof e.join
								}, a.prototype.join = function(e, t) {
									return e || (e = o.alloc(this.length)), t || (t = 0), 0 === this.length ? e : (Array.isArray(this.value) ? this.value.forEach((function(r) {
										r.join(e, t), t += r.length
									})) : ("number" == typeof this.value ? e[t] = this.value : "string" == typeof this.value ? e.write(this.value, t) : o.isBuffer(this.value) && this.value.copy(e, t), t += this.length), e)
								}
							}, {
								"../base/reporter": 8,
								inherits: 147,
								"safer-buffer": 252
							}],
							6: [function(e, t, r) {
								"use strict";
								const n = r;
								n.Reporter = e("./reporter").Reporter, n.DecoderBuffer = e("./buffer").DecoderBuffer, n.EncoderBuffer = e("./buffer").EncoderBuffer, n.Node = e("./node")
							}, {
								"./buffer": 5,
								"./node": 7,
								"./reporter": 8
							}],
							7: [function(e, t, r) {
								"use strict";
								const n = e("../base/reporter").Reporter,
									i = e("../base/buffer").EncoderBuffer,
									o = e("../base/buffer").DecoderBuffer,
									s = e("minimalistic-assert"),
									a = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"],
									c = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(a);

								function l(e, t, r) {
									const n = {};
									this._baseState = n, n.name = r, n.enc = e, n.parent = t || null, n.children = null, n.tag = null, n.args = null, n.reverseArgs = null, n.choice = null, n.optional = !1, n.any = !1, n.obj = !1, n.use = null, n.useDecoder = null, n.key = null, n.default = null, n.explicit = null, n.implicit = null, n.contains = null, n.parent || (n.children = [], this._wrap())
								}
								t.exports = l;
								const u = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
								l.prototype.clone = function() {
									const e = this._baseState,
										t = {};
									u.forEach((function(r) {
										t[r] = e[r]
									}));
									const r = new this.constructor(t.parent);
									return r._baseState = t, r
								}, l.prototype._wrap = function() {
									const e = this._baseState;
									c.forEach((function(t) {
										this[t] = function() {
											const r = new this.constructor(this);
											return e.children.push(r), r[t].apply(r, arguments)
										}
									}), this)
								}, l.prototype._init = function(e) {
									const t = this._baseState;
									s(null === t.parent), e.call(this), t.children = t.children.filter((function(e) {
										return e._baseState.parent === this
									}), this), s.equal(t.children.length, 1, "Root node can have only one child")
								}, l.prototype._useArgs = function(e) {
									const t = this._baseState,
										r = e.filter((function(e) {
											return e instanceof this.constructor
										}), this);
									e = e.filter((function(e) {
										return !(e instanceof this.constructor)
									}), this), 0 !== r.length && (s(null === t.children), t.children = r, r.forEach((function(e) {
										e._baseState.parent = this
									}), this)), 0 !== e.length && (s(null === t.args), t.args = e, t.reverseArgs = e.map((function(e) {
										if ("object" != typeof e || e.constructor !== Object) return e;
										const t = {};
										return Object.keys(e).forEach((function(r) {
											r == (0 | r) && (r |= 0);
											const n = e[r];
											t[n] = r
										})), t
									})))
								}, ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"].forEach((function(e) {
									l.prototype[e] = function() {
										const t = this._baseState;
										throw new Error(e + " not implemented for encoding: " + t.enc)
									}
								})), a.forEach((function(e) {
									l.prototype[e] = function() {
										const t = this._baseState,
											r = Array.prototype.slice.call(arguments);
										return s(null === t.tag), t.tag = e, this._useArgs(r), this
									}
								})), l.prototype.use = function(e) {
									s(e);
									const t = this._baseState;
									return s(null === t.use), t.use = e, this
								}, l.prototype.optional = function() {
									return this._baseState.optional = !0, this
								}, l.prototype.def = function(e) {
									const t = this._baseState;
									return s(null === t.default), t.default = e, t.optional = !0, this
								}, l.prototype.explicit = function(e) {
									const t = this._baseState;
									return s(null === t.explicit && null === t.implicit), t.explicit = e, this
								}, l.prototype.implicit = function(e) {
									const t = this._baseState;
									return s(null === t.explicit && null === t.implicit), t.implicit = e, this
								}, l.prototype.obj = function() {
									const e = this._baseState,
										t = Array.prototype.slice.call(arguments);
									return e.obj = !0, 0 !== t.length && this._useArgs(t), this
								}, l.prototype.key = function(e) {
									const t = this._baseState;
									return s(null === t.key), t.key = e, this
								}, l.prototype.any = function() {
									return this._baseState.any = !0, this
								}, l.prototype.choice = function(e) {
									const t = this._baseState;
									return s(null === t.choice), t.choice = e, this._useArgs(Object.keys(e).map((function(t) {
										return e[t]
									}))), this
								}, l.prototype.contains = function(e) {
									const t = this._baseState;
									return s(null === t.use), t.contains = e, this
								}, l.prototype._decode = function(e, t) {
									const r = this._baseState;
									if (null === r.parent) return e.wrapResult(r.children[0]._decode(e, t));
									let n, i = r.default,
										s = !0,
										a = null;
									if (null !== r.key && (a = e.enterKey(r.key)), r.optional) {
										let n = null;
										if (null !== r.explicit ? n = r.explicit : null !== r.implicit ? n = r.implicit : null !== r.tag && (n = r.tag), null !== n || r.any) {
											if (s = this._peekTag(e, n, r.any), e.isError(s)) return s
										} else {
											const n = e.save();
											try {
												null === r.choice ? this._decodeGeneric(r.tag, e, t) : this._decodeChoice(e, t), s = !0
											} catch (c) {
												s = !1
											}
											e.restore(n)
										}
									}
									if (r.obj && s && (n = e.enterObject()), s) {
										if (null !== r.explicit) {
											const t = this._decodeTag(e, r.explicit);
											if (e.isError(t)) return t;
											e = t
										}
										const n = e.offset;
										if (null === r.use && null === r.choice) {
											let t;
											r.any && (t = e.save());
											const n = this._decodeTag(e, null !== r.implicit ? r.implicit : r.tag, r.any);
											if (e.isError(n)) return n;
											r.any ? i = e.raw(t) : e = n
										}
										if (t && t.track && null !== r.tag && t.track(e.path(), n, e.length, "tagged"), t && t.track && null !== r.tag && t.track(e.path(), e.offset, e.length, "content"), r.any || (i = null === r.choice ? this._decodeGeneric(r.tag, e, t) : this._decodeChoice(e, t)), e.isError(i)) return i;
										if (r.any || null !== r.choice || null === r.children || r.children.forEach((function(r) {
												r._decode(e, t)
											})), r.contains && ("octstr" === r.tag || "bitstr" === r.tag)) {
											const n = new o(i);
											i = this._getUse(r.contains, e._reporterState.obj)._decode(n, t)
										}
									}
									return r.obj && s && (i = e.leaveObject(n)), null === r.key || null === i && !0 !== s ? null !== a && e.exitKey(a) : e.leaveKey(a, r.key, i), i
								}, l.prototype._decodeGeneric = function(e, t, r) {
									const n = this._baseState;
									return "seq" === e || "set" === e ? null : "seqof" === e || "setof" === e ? this._decodeList(t, e, n.args[0], r) : /str$/.test(e) ? this._decodeStr(t, e, r) : "objid" === e && n.args ? this._decodeObjid(t, n.args[0], n.args[1], r) : "objid" === e ? this._decodeObjid(t, null, null, r) : "gentime" === e || "utctime" === e ? this._decodeTime(t, e, r) : "null_" === e ? this._decodeNull(t, r) : "bool" === e ? this._decodeBool(t, r) : "objDesc" === e ? this._decodeStr(t, e, r) : "int" === e || "enum" === e ? this._decodeInt(t, n.args && n.args[0], r) : null !== n.use ? this._getUse(n.use, t._reporterState.obj)._decode(t, r) : t.error("unknown tag: " + e)
								}, l.prototype._getUse = function(e, t) {
									const r = this._baseState;
									return r.useDecoder = this._use(e, t), s(null === r.useDecoder._baseState.parent), r.useDecoder = r.useDecoder._baseState.children[0], r.implicit !== r.useDecoder._baseState.implicit && (r.useDecoder = r.useDecoder.clone(), r.useDecoder._baseState.implicit = r.implicit), r.useDecoder
								}, l.prototype._decodeChoice = function(e, t) {
									const r = this._baseState;
									let n = null,
										i = !1;
									return Object.keys(r.choice).some((function(o) {
										const s = e.save(),
											a = r.choice[o];
										try {
											const r = a._decode(e, t);
											if (e.isError(r)) return !1;
											n = {
												type: o,
												value: r
											}, i = !0
										} catch (c) {
											return e.restore(s), !1
										}
										return !0
									}), this), i ? n : e.error("Choice not matched")
								}, l.prototype._createEncoderBuffer = function(e) {
									return new i(e, this.reporter)
								}, l.prototype._encode = function(e, t, r) {
									const n = this._baseState;
									if (null !== n.default && n.default === e) return;
									const i = this._encodeValue(e, t, r);
									return void 0 === i || this._skipDefault(i, t, r) ? void 0 : i
								}, l.prototype._encodeValue = function(e, t, r) {
									const i = this._baseState;
									if (null === i.parent) return i.children[0]._encode(e, t || new n);
									let o = null;
									if (this.reporter = t, i.optional && void 0 === e) {
										if (null === i.default) return;
										e = i.default
									}
									let s = null,
										a = !1;
									if (i.any) o = this._createEncoderBuffer(e);
									else if (i.choice) o = this._encodeChoice(e, t);
									else if (i.contains) s = this._getUse(i.contains, r)._encode(e, t), a = !0;
									else if (i.children) s = i.children.map((function(r) {
										if ("null_" === r._baseState.tag) return r._encode(null, t, e);
										if (null === r._baseState.key) return t.error("Child should have a key");
										const n = t.enterKey(r._baseState.key);
										if ("object" != typeof e) return t.error("Child expected, but input is not object");
										const i = r._encode(e[r._baseState.key], t, e);
										return t.leaveKey(n), i
									}), this).filter((function(e) {
										return e
									})), s = this._createEncoderBuffer(s);
									else if ("seqof" === i.tag || "setof" === i.tag) {
										if (!i.args || 1 !== i.args.length) return t.error("Too many args for : " + i.tag);
										if (!Array.isArray(e)) return t.error("seqof/setof, but data is not Array");
										const r = this.clone();
										r._baseState.implicit = null, s = this._createEncoderBuffer(e.map((function(r) {
											const n = this._baseState;
											return this._getUse(n.args[0], e)._encode(r, t)
										}), r))
									} else null !== i.use ? o = this._getUse(i.use, r)._encode(e, t) : (s = this._encodePrimitive(i.tag, e), a = !0);
									if (!i.any && null === i.choice) {
										const e = null !== i.implicit ? i.implicit : i.tag,
											r = null === i.implicit ? "universal" : "context";
										null === e ? null === i.use && t.error("Tag could be omitted only for .use()") : null === i.use && (o = this._encodeComposite(e, a, r, s))
									}
									return null !== i.explicit && (o = this._encodeComposite(i.explicit, !1, "context", o)), o
								}, l.prototype._encodeChoice = function(e, t) {
									const r = this._baseState,
										n = r.choice[e.type];
									return n || s(!1, e.type + " not found in " + JSON.stringify(Object.keys(r.choice))), n._encode(e.value, t)
								}, l.prototype._encodePrimitive = function(e, t) {
									const r = this._baseState;
									if (/str$/.test(e)) return this._encodeStr(t, e);
									if ("objid" === e && r.args) return this._encodeObjid(t, r.reverseArgs[0], r.args[1]);
									if ("objid" === e) return this._encodeObjid(t, null, null);
									if ("gentime" === e || "utctime" === e) return this._encodeTime(t, e);
									if ("null_" === e) return this._encodeNull();
									if ("int" === e || "enum" === e) return this._encodeInt(t, r.args && r.reverseArgs[0]);
									if ("bool" === e) return this._encodeBool(t);
									if ("objDesc" === e) return this._encodeStr(t, e);
									throw new Error("Unsupported tag: " + e)
								}, l.prototype._isNumstr = function(e) {
									return /^[0-9 ]*$/.test(e)
								}, l.prototype._isPrintstr = function(e) {
									return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e)
								}
							}, {
								"../base/buffer": 5,
								"../base/reporter": 8,
								"minimalistic-assert": 224
							}],
							8: [function(e, t, r) {
								"use strict";
								const n = e("inherits");

								function i(e) {
									this._reporterState = {
										obj: null,
										path: [],
										options: e || {},
										errors: []
									}
								}

								function o(e, t) {
									this.path = e, this.rethrow(t)
								}
								r.Reporter = i, i.prototype.isError = function(e) {
									return e instanceof o
								}, i.prototype.save = function() {
									const e = this._reporterState;
									return {
										obj: e.obj,
										pathLen: e.path.length
									}
								}, i.prototype.restore = function(e) {
									const t = this._reporterState;
									t.obj = e.obj, t.path = t.path.slice(0, e.pathLen)
								}, i.prototype.enterKey = function(e) {
									return this._reporterState.path.push(e)
								}, i.prototype.exitKey = function(e) {
									const t = this._reporterState;
									t.path = t.path.slice(0, e - 1)
								}, i.prototype.leaveKey = function(e, t, r) {
									const n = this._reporterState;
									this.exitKey(e), null !== n.obj && (n.obj[t] = r)
								}, i.prototype.path = function() {
									return this._reporterState.path.join("/")
								}, i.prototype.enterObject = function() {
									const e = this._reporterState,
										t = e.obj;
									return e.obj = {}, t
								}, i.prototype.leaveObject = function(e) {
									const t = this._reporterState,
										r = t.obj;
									return t.obj = e, r
								}, i.prototype.error = function(e) {
									let t;
									const r = this._reporterState,
										n = e instanceof o;
									if (t = n ? e : new o(r.path.map((function(e) {
											return "[" + JSON.stringify(e) + "]"
										})).join(""), e.message || e, e.stack), !r.options.partial) throw t;
									return n || r.errors.push(t), t
								}, i.prototype.wrapResult = function(e) {
									const t = this._reporterState;
									return t.options.partial ? {
										result: this.isError(e) ? null : e,
										errors: t.errors
									} : e
								}, n(o, Error), o.prototype.rethrow = function(e) {
									if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, o), !this.stack) try {
										throw new Error(this.message)
									} catch (t) {
										this.stack = t.stack
									}
									return this
								}
							}, {
								inherits: 147
							}],
							9: [function(e, t, r) {
								"use strict";

								function n(e) {
									const t = {};
									return Object.keys(e).forEach((function(r) {
										(0 | r) == r && (r |= 0);
										const n = e[r];
										t[n] = r
									})), t
								}
								r.tagClass = {
									0: "universal",
									1: "application",
									2: "context",
									3: "private"
								}, r.tagClassByName = n(r.tagClass), r.tag = {
									0: "end",
									1: "bool",
									2: "int",
									3: "bitstr",
									4: "octstr",
									5: "null_",
									6: "objid",
									7: "objDesc",
									8: "external",
									9: "real",
									10: "enum",
									11: "embed",
									12: "utf8str",
									13: "relativeOid",
									16: "seq",
									17: "set",
									18: "numstr",
									19: "printstr",
									20: "t61str",
									21: "videostr",
									22: "ia5str",
									23: "utctime",
									24: "gentime",
									25: "graphstr",
									26: "iso646str",
									27: "genstr",
									28: "unistr",
									29: "charstr",
									30: "bmpstr"
								}, r.tagByName = n(r.tag)
							}, {}],
							10: [function(e, t, r) {
								"use strict";
								const n = r;
								n._reverse = function(e) {
									const t = {};
									return Object.keys(e).forEach((function(r) {
										(0 | r) == r && (r |= 0);
										const n = e[r];
										t[n] = r
									})), t
								}, n.der = e("./der")
							}, {
								"./der": 9
							}],
							11: [function(e, t, r) {
								"use strict";
								const n = e("inherits"),
									i = e("bn.js"),
									o = e("../base/buffer").DecoderBuffer,
									s = e("../base/node"),
									a = e("../constants/der");

								function c(e) {
									this.enc = "der", this.name = e.name, this.entity = e, this.tree = new l, this.tree._init(e.body)
								}

								function l(e) {
									s.call(this, "der", e)
								}

								function u(e, t) {
									let r = e.readUInt8(t);
									if (e.isError(r)) return r;
									const n = a.tagClass[r >> 6],
										i = 0 == (32 & r);
									if (31 == (31 & r)) {
										let n = r;
										for (r = 0; 128 == (128 & n);) {
											if (n = e.readUInt8(t), e.isError(n)) return n;
											r <<= 7, r |= 127 & n
										}
									} else r &= 31;
									return {
										cls: n,
										primitive: i,
										tag: r,
										tagStr: a.tag[r]
									}
								}

								function d(e, t, r) {
									let n = e.readUInt8(r);
									if (e.isError(n)) return n;
									if (!t && 128 === n) return null;
									if (0 == (128 & n)) return n;
									const i = 127 & n;
									if (i > 4) return e.error("length octect is too long");
									n = 0;
									for (let o = 0; o < i; o++) {
										n <<= 8;
										const t = e.readUInt8(r);
										if (e.isError(t)) return t;
										n |= t
									}
									return n
								}
								t.exports = c, c.prototype.decode = function(e, t) {
									return o.isDecoderBuffer(e) || (e = new o(e, t)), this.tree._decode(e, t)
								}, n(l, s), l.prototype._peekTag = function(e, t, r) {
									if (e.isEmpty()) return !1;
									const n = e.save(),
										i = u(e, 'Failed to peek tag: "' + t + '"');
									return e.isError(i) ? i : (e.restore(n), i.tag === t || i.tagStr === t || i.tagStr + "of" === t || r)
								}, l.prototype._decodeTag = function(e, t, r) {
									const n = u(e, 'Failed to decode tag of "' + t + '"');
									if (e.isError(n)) return n;
									let i = d(e, n.primitive, 'Failed to get length of "' + t + '"');
									if (e.isError(i)) return i;
									if (!r && n.tag !== t && n.tagStr !== t && n.tagStr + "of" !== t) return e.error('Failed to match tag: "' + t + '"');
									if (n.primitive || null !== i) return e.skip(i, 'Failed to match body of: "' + t + '"');
									const o = e.save(),
										s = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
									return e.isError(s) ? s : (i = e.offset - o.offset, e.restore(o), e.skip(i, 'Failed to match body of: "' + t + '"'))
								}, l.prototype._skipUntilEnd = function(e, t) {
									for (;;) {
										const r = u(e, t);
										if (e.isError(r)) return r;
										const n = d(e, r.primitive, t);
										if (e.isError(n)) return n;
										let i;
										if (i = r.primitive || null !== n ? e.skip(n) : this._skipUntilEnd(e, t), e.isError(i)) return i;
										if ("end" === r.tagStr) break
									}
								}, l.prototype._decodeList = function(e, t, r, n) {
									const i = [];
									for (; !e.isEmpty();) {
										const t = this._peekTag(e, "end");
										if (e.isError(t)) return t;
										const o = r.decode(e, "der", n);
										if (e.isError(o) && t) break;
										i.push(o)
									}
									return i
								}, l.prototype._decodeStr = function(e, t) {
									if ("bitstr" === t) {
										const t = e.readUInt8();
										return e.isError(t) ? t : {
											unused: t,
											data: e.raw()
										}
									}
									if ("bmpstr" === t) {
										const t = e.raw();
										if (t.length % 2 == 1) return e.error("Decoding of string type: bmpstr length mismatch");
										let r = "";
										for (let e = 0; e < t.length / 2; e++) r += String.fromCharCode(t.readUInt16BE(2 * e));
										return r
									}
									if ("numstr" === t) {
										const t = e.raw().toString("ascii");
										return this._isNumstr(t) ? t : e.error("Decoding of string type: numstr unsupported characters")
									}
									if ("octstr" === t) return e.raw();
									if ("objDesc" === t) return e.raw();
									if ("printstr" === t) {
										const t = e.raw().toString("ascii");
										return this._isPrintstr(t) ? t : e.error("Decoding of string type: printstr unsupported characters")
									}
									return /str$/.test(t) ? e.raw().toString() : e.error("Decoding of string type: " + t + " unsupported")
								}, l.prototype._decodeObjid = function(e, t, r) {
									let n;
									const i = [];
									let o = 0,
										s = 0;
									for (; !e.isEmpty();) o <<= 7, o |= 127 & (s = e.readUInt8()), 0 == (128 & s) && (i.push(o), o = 0);
									128 & s && i.push(o);
									const a = i[0] / 40 | 0,
										c = i[0] % 40;
									if (n = r ? i : [a, c].concat(i.slice(1)), t) {
										let e = t[n.join(" ")];
										void 0 === e && (e = t[n.join(".")]), void 0 !== e && (n = e)
									}
									return n
								}, l.prototype._decodeTime = function(e, t) {
									const r = e.raw().toString();
									let n, i, o, s, a, c;
									if ("gentime" === t) n = 0 | r.slice(0, 4), i = 0 | r.slice(4, 6), o = 0 | r.slice(6, 8), s = 0 | r.slice(8, 10), a = 0 | r.slice(10, 12), c = 0 | r.slice(12, 14);
									else {
										if ("utctime" !== t) return e.error("Decoding " + t + " time is not supported yet");
										n = 0 | r.slice(0, 2), i = 0 | r.slice(2, 4), o = 0 | r.slice(4, 6), s = 0 | r.slice(6, 8), a = 0 | r.slice(8, 10), c = 0 | r.slice(10, 12), n = n < 70 ? 2e3 + n : 1900 + n
									}
									return Date.UTC(n, i - 1, o, s, a, c, 0)
								}, l.prototype._decodeNull = function() {
									return null
								}, l.prototype._decodeBool = function(e) {
									const t = e.readUInt8();
									return e.isError(t) ? t : 0 !== t
								}, l.prototype._decodeInt = function(e, t) {
									const r = e.raw();
									let n = new i(r);
									return t && (n = t[n.toString(10)] || n), n
								}, l.prototype._use = function(e, t) {
									return "function" == typeof e && (e = e(t)), e._getDecoder("der").tree
								}
							}, {
								"../base/buffer": 5,
								"../base/node": 7,
								"../constants/der": 9,
								"bn.js": 19,
								inherits: 147
							}],
							12: [function(e, t, r) {
								"use strict";
								const n = r;
								n.der = e("./der"), n.pem = e("./pem")
							}, {
								"./der": 11,
								"./pem": 13
							}],
							13: [function(e, t, r) {
								"use strict";
								const n = e("inherits"),
									i = e("safer-buffer").Buffer,
									o = e("./der");

								function s(e) {
									o.call(this, e), this.enc = "pem"
								}
								n(s, o), t.exports = s, s.prototype.decode = function(e, t) {
									const r = e.toString().split(/[\r\n]+/g),
										n = t.label.toUpperCase(),
										s = /^-----(BEGIN|END) ([^-]+)-----$/;
									let a = -1,
										c = -1;
									for (let i = 0; i < r.length; i++) {
										const e = r[i].match(s);
										if (null !== e && e[2] === n) {
											if (-1 !== a) {
												if ("END" !== e[1]) break;
												c = i;
												break
											}
											if ("BEGIN" !== e[1]) break;
											a = i
										}
									}
									if (-1 === a || -1 === c) throw new Error("PEM section not found for: " + n);
									const l = r.slice(a + 1, c).join("");
									l.replace(/[^a-z0-9+/=]+/gi, "");
									const u = i.from(l, "base64");
									return o.prototype.decode.call(this, u, t)
								}
							}, {
								"./der": 11,
								inherits: 147,
								"safer-buffer": 252
							}],
							14: [function(e, t, r) {
								"use strict";
								const n = e("inherits"),
									i = e("safer-buffer").Buffer,
									o = e("../base/node"),
									s = e("../constants/der");

								function a(e) {
									this.enc = "der", this.name = e.name, this.entity = e, this.tree = new c, this.tree._init(e.body)
								}

								function c(e) {
									o.call(this, "der", e)
								}

								function l(e) {
									return e < 10 ? "0" + e : e
								}
								t.exports = a, a.prototype.encode = function(e, t) {
									return this.tree._encode(e, t).join()
								}, n(c, o), c.prototype._encodeComposite = function(e, t, r, n) {
									const o = function(e, t, r, n) {
										let i;
										"seqof" === e ? e = "seq" : "setof" === e && (e = "set");
										if (s.tagByName.hasOwnProperty(e)) i = s.tagByName[e];
										else {
											if ("number" != typeof e || (0 | e) !== e) return n.error("Unknown tag: " + e);
											i = e
										}
										if (i >= 31) return n.error("Multi-octet tag encoding unsupported");
										t || (i |= 32);
										return i |= s.tagClassByName[r || "universal"] << 6
									}(e, t, r, this.reporter);
									if (n.length < 128) {
										const e = i.alloc(2);
										return e[0] = o, e[1] = n.length, this._createEncoderBuffer([e, n])
									}
									let a = 1;
									for (let i = n.length; i >= 256; i >>= 8) a++;
									const c = i.alloc(2 + a);
									c[0] = o, c[1] = 128 | a;
									for (let i = 1 + a, s = n.length; s > 0; i--, s >>= 8) c[i] = 255 & s;
									return this._createEncoderBuffer([c, n])
								}, c.prototype._encodeStr = function(e, t) {
									if ("bitstr" === t) return this._createEncoderBuffer([0 | e.unused, e.data]);
									if ("bmpstr" === t) {
										const t = i.alloc(2 * e.length);
										for (let r = 0; r < e.length; r++) t.writeUInt16BE(e.charCodeAt(r), 2 * r);
										return this._createEncoderBuffer(t)
									}
									return "numstr" === t ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : "printstr" === t ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(t) ? this._createEncoderBuffer(e) : "objDesc" === t ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + t + " unsupported")
								}, c.prototype._encodeObjid = function(e, t, r) {
									if ("string" == typeof e) {
										if (!t) return this.reporter.error("string objid given, but no values map found");
										if (!t.hasOwnProperty(e)) return this.reporter.error("objid not found in values map");
										e = t[e].split(/[\s.]+/g);
										for (let t = 0; t < e.length; t++) e[t] |= 0
									} else if (Array.isArray(e)) {
										e = e.slice();
										for (let t = 0; t < e.length; t++) e[t] |= 0
									}
									if (!Array.isArray(e)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
									if (!r) {
										if (e[1] >= 40) return this.reporter.error("Second objid identifier OOB");
										e.splice(0, 2, 40 * e[0] + e[1])
									}
									let n = 0;
									for (let i = 0; i < e.length; i++) {
										let t = e[i];
										for (n++; t >= 128; t >>= 7) n++
									}
									const o = i.alloc(n);
									let s = o.length - 1;
									for (let i = e.length - 1; i >= 0; i--) {
										let t = e[i];
										for (o[s--] = 127 & t;
											(t >>= 7) > 0;) o[s--] = 128 | 127 & t
									}
									return this._createEncoderBuffer(o)
								}, c.prototype._encodeTime = function(e, t) {
									let r;
									const n = new Date(e);
									return "gentime" === t ? r = [l(n.getUTCFullYear()), l(n.getUTCMonth() + 1), l(n.getUTCDate()), l(n.getUTCHours()), l(n.getUTCMinutes()), l(n.getUTCSeconds()), "Z"].join("") : "utctime" === t ? r = [l(n.getUTCFullYear() % 100), l(n.getUTCMonth() + 1), l(n.getUTCDate()), l(n.getUTCHours()), l(n.getUTCMinutes()), l(n.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + t + " time is not supported yet"), this._encodeStr(r, "octstr")
								}, c.prototype._encodeNull = function() {
									return this._createEncoderBuffer("")
								}, c.prototype._encodeInt = function(e, t) {
									if ("string" == typeof e) {
										if (!t) return this.reporter.error("String int or enum given, but no values map");
										if (!t.hasOwnProperty(e)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
										e = t[e]
									}
									if ("number" != typeof e && !i.isBuffer(e)) {
										const t = e.toArray();
										!e.sign && 128 & t[0] && t.unshift(0), e = i.from(t)
									}
									if (i.isBuffer(e)) {
										let t = e.length;
										0 === e.length && t++;
										const r = i.alloc(t);
										return e.copy(r), 0 === e.length && (r[0] = 0), this._createEncoderBuffer(r)
									}
									if (e < 128) return this._createEncoderBuffer(e);
									if (e < 256) return this._createEncoderBuffer([0, e]);
									let r = 1;
									for (let i = e; i >= 256; i >>= 8) r++;
									const n = new Array(r);
									for (let i = n.length - 1; i >= 0; i--) n[i] = 255 & e, e >>= 8;
									return 128 & n[0] && n.unshift(0), this._createEncoderBuffer(i.from(n))
								}, c.prototype._encodeBool = function(e) {
									return this._createEncoderBuffer(e ? 255 : 0)
								}, c.prototype._use = function(e, t) {
									return "function" == typeof e && (e = e(t)), e._getEncoder("der").tree
								}, c.prototype._skipDefault = function(e, t, r) {
									const n = this._baseState;
									let i;
									if (null === n.default) return !1;
									const o = e.join();
									if (void 0 === n.defaultBuffer && (n.defaultBuffer = this._encodeValue(n.default, t, r).join()), o.length !== n.defaultBuffer.length) return !1;
									for (i = 0; i < o.length; i++)
										if (o[i] !== n.defaultBuffer[i]) return !1;
									return !0
								}
							}, {
								"../base/node": 7,
								"../constants/der": 9,
								inherits: 147,
								"safer-buffer": 252
							}],
							15: [function(e, t, r) {
								"use strict";
								const n = r;
								n.der = e("./der"), n.pem = e("./pem")
							}, {
								"./der": 14,
								"./pem": 16
							}],
							16: [function(e, t, r) {
								"use strict";
								const n = e("inherits"),
									i = e("./der");

								function o(e) {
									i.call(this, e), this.enc = "pem"
								}
								n(o, i), t.exports = o, o.prototype.encode = function(e, t) {
									const r = i.prototype.encode.call(this, e).toString("base64"),
										n = ["-----BEGIN " + t.label + "-----"];
									for (let i = 0; i < r.length; i += 64) n.push(r.slice(i, i + 64));
									return n.push("-----END " + t.label + "-----"), n.join("\n")
								}
							}, {
								"./der": 14,
								inherits: 147
							}],
							17: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var t = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"],
											n = "undefined" == typeof globalThis ? e : globalThis;
										r.exports = function() {
											for (var e = [], r = 0; r < t.length; r++) "function" == typeof n[t[r]] && (e[e.length] = t[r]);
											return e
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {}],
							18: [function(e, t, r) {
								"use strict";
								r.byteLength = function(e) {
									var t = l(e),
										r = t[0],
										n = t[1];
									return 3 * (r + n) / 4 - n
								}, r.toByteArray = function(e) {
									var t, r, n = l(e),
										s = n[0],
										a = n[1],
										c = new o(function(e, t, r) {
											return 3 * (t + r) / 4 - r
										}(0, s, a)),
										u = 0,
										d = a > 0 ? s - 4 : s;
									for (r = 0; r < d; r += 4) t = i[e.charCodeAt(r)] << 18 | i[e.charCodeAt(r + 1)] << 12 | i[e.charCodeAt(r + 2)] << 6 | i[e.charCodeAt(r + 3)], c[u++] = t >> 16 & 255, c[u++] = t >> 8 & 255, c[u++] = 255 & t;
									2 === a && (t = i[e.charCodeAt(r)] << 2 | i[e.charCodeAt(r + 1)] >> 4, c[u++] = 255 & t);
									1 === a && (t = i[e.charCodeAt(r)] << 10 | i[e.charCodeAt(r + 1)] << 4 | i[e.charCodeAt(r + 2)] >> 2, c[u++] = t >> 8 & 255, c[u++] = 255 & t);
									return c
								}, r.fromByteArray = function(e) {
									for (var t, r = e.length, i = r % 3, o = [], s = 0, a = r - i; s < a; s += 16383) o.push(u(e, s, s + 16383 > a ? a : s + 16383));
									1 === i ? (t = e[r - 1], o.push(n[t >> 2] + n[t << 4 & 63] + "==")) : 2 === i && (t = (e[r - 2] << 8) + e[r - 1], o.push(n[t >> 10] + n[t >> 4 & 63] + n[t << 2 & 63] + "="));
									return o.join("")
								};
								for (var n = [], i = [], o = "undefined" != typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, c = s.length; a < c; ++a) n[a] = s[a], i[s.charCodeAt(a)] = a;

								function l(e) {
									var t = e.length;
									if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
									var r = e.indexOf("=");
									return -1 === r && (r = t), [r, r === t ? 0 : 4 - r % 4]
								}

								function u(e, t, r) {
									for (var i, o, s = [], a = t; a < r; a += 3) i = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]), s.push(n[(o = i) >> 18 & 63] + n[o >> 12 & 63] + n[o >> 6 & 63] + n[63 & o]);
									return s.join("")
								}
								i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63
							}, {}],
							19: [function(e, t, r) {
								! function(t, r) {
									"use strict";

									function n(e, t) {
										if (!e) throw new Error(t || "Assertion failed")
									}

									function i(e, t) {
										e.super_ = t;
										var r = function() {};
										r.prototype = t.prototype, e.prototype = new r, e.prototype.constructor = e
									}

									function o(e, t, r) {
										if (o.isBN(e)) return e;
										this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== e && ("le" !== t && "be" !== t || (r = t, t = 10), this._init(e || 0, t || 10, r || "be"))
									}
									var s;
									"object" == typeof t ? t.exports = o : r.BN = o, o.BN = o, o.wordSize = 26;
									try {
										s = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : e("buffer").Buffer
									} catch (T) {}

									function a(e, t) {
										var r = e.charCodeAt(t);
										return r >= 65 && r <= 70 ? r - 55 : r >= 97 && r <= 102 ? r - 87 : r - 48 & 15
									}

									function c(e, t, r) {
										var n = a(e, r);
										return r - 1 >= t && (n |= a(e, r - 1) << 4), n
									}

									function l(e, t, r, n) {
										for (var i = 0, o = Math.min(e.length, r), s = t; s < o; s++) {
											var a = e.charCodeAt(s) - 48;
											i *= n, i += a >= 49 ? a - 49 + 10 : a >= 17 ? a - 17 + 10 : a
										}
										return i
									}
									o.isBN = function(e) {
										return e instanceof o || null !== e && "object" == typeof e && e.constructor.wordSize === o.wordSize && Array.isArray(e.words)
									}, o.max = function(e, t) {
										return e.cmp(t) > 0 ? e : t
									}, o.min = function(e, t) {
										return e.cmp(t) < 0 ? e : t
									}, o.prototype._init = function(e, t, r) {
										if ("number" == typeof e) return this._initNumber(e, t, r);
										if ("object" == typeof e) return this._initArray(e, t, r);
										"hex" === t && (t = 16), n(t === (0 | t) && t >= 2 && t <= 36);
										var i = 0;
										"-" === (e = e.toString().replace(/\s+/g, ""))[0] && (i++, this.negative = 1), i < e.length && (16 === t ? this._parseHex(e, i, r) : (this._parseBase(e, t, i), "le" === r && this._initArray(this.toArray(), t, r)))
									}, o.prototype._initNumber = function(e, t, r) {
										e < 0 && (this.negative = 1, e = -e), e < 67108864 ? (this.words = [67108863 & e], this.length = 1) : e < 4503599627370496 ? (this.words = [67108863 & e, e / 67108864 & 67108863], this.length = 2) : (n(e < 9007199254740992), this.words = [67108863 & e, e / 67108864 & 67108863, 1], this.length = 3), "le" === r && this._initArray(this.toArray(), t, r)
									}, o.prototype._initArray = function(e, t, r) {
										if (n("number" == typeof e.length), e.length <= 0) return this.words = [0], this.length = 1, this;
										this.length = Math.ceil(e.length / 3), this.words = new Array(this.length);
										for (var i = 0; i < this.length; i++) this.words[i] = 0;
										var o, s, a = 0;
										if ("be" === r)
											for (i = e.length - 1, o = 0; i >= 0; i -= 3) s = e[i] | e[i - 1] << 8 | e[i - 2] << 16, this.words[o] |= s << a & 67108863, this.words[o + 1] = s >>> 26 - a & 67108863, (a += 24) >= 26 && (a -= 26, o++);
										else if ("le" === r)
											for (i = 0, o = 0; i < e.length; i += 3) s = e[i] | e[i + 1] << 8 | e[i + 2] << 16, this.words[o] |= s << a & 67108863, this.words[o + 1] = s >>> 26 - a & 67108863, (a += 24) >= 26 && (a -= 26, o++);
										return this.strip()
									}, o.prototype._parseHex = function(e, t, r) {
										this.length = Math.ceil((e.length - t) / 6), this.words = new Array(this.length);
										for (var n = 0; n < this.length; n++) this.words[n] = 0;
										var i, o = 0,
											s = 0;
										if ("be" === r)
											for (n = e.length - 1; n >= t; n -= 2) i = c(e, t, n) << o, this.words[s] |= 67108863 & i, o >= 18 ? (o -= 18, s += 1, this.words[s] |= i >>> 26) : o += 8;
										else
											for (n = (e.length - t) % 2 == 0 ? t + 1 : t; n < e.length; n += 2) i = c(e, t, n) << o, this.words[s] |= 67108863 & i, o >= 18 ? (o -= 18, s += 1, this.words[s] |= i >>> 26) : o += 8;
										this.strip()
									}, o.prototype._parseBase = function(e, t, r) {
										this.words = [0], this.length = 1;
										for (var n = 0, i = 1; i <= 67108863; i *= t) n++;
										n--, i = i / t | 0;
										for (var o = e.length - r, s = o % n, a = Math.min(o, o - s) + r, c = 0, u = r; u < a; u += n) c = l(e, u, u + n, t), this.imuln(i), this.words[0] + c < 67108864 ? this.words[0] += c : this._iaddn(c);
										if (0 !== s) {
											var d = 1;
											for (c = l(e, u, e.length, t), u = 0; u < s; u++) d *= t;
											this.imuln(d), this.words[0] + c < 67108864 ? this.words[0] += c : this._iaddn(c)
										}
										this.strip()
									}, o.prototype.copy = function(e) {
										e.words = new Array(this.length);
										for (var t = 0; t < this.length; t++) e.words[t] = this.words[t];
										e.length = this.length, e.negative = this.negative, e.red = this.red
									}, o.prototype.clone = function() {
										var e = new o(null);
										return this.copy(e), e
									}, o.prototype._expand = function(e) {
										for (; this.length < e;) this.words[this.length++] = 0;
										return this
									}, o.prototype.strip = function() {
										for (; this.length > 1 && 0 === this.words[this.length - 1];) this.length--;
										return this._normSign()
									}, o.prototype._normSign = function() {
										return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
									}, o.prototype.inspect = function() {
										return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
									};
									var u = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
										d = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
										h = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

									function f(e, t, r) {
										r.negative = t.negative ^ e.negative;
										var n = e.length + t.length | 0;
										r.length = n, n = n - 1 | 0;
										var i = 0 | e.words[0],
											o = 0 | t.words[0],
											s = i * o,
											a = 67108863 & s,
											c = s / 67108864 | 0;
										r.words[0] = a;
										for (var l = 1; l < n; l++) {
											for (var u = c >>> 26, d = 67108863 & c, h = Math.min(l, t.length - 1), f = Math.max(0, l - e.length + 1); f <= h; f++) {
												var p = l - f | 0;
												u += (s = (i = 0 | e.words[p]) * (o = 0 | t.words[f]) + d) / 67108864 | 0, d = 67108863 & s
											}
											r.words[l] = 0 | d, c = 0 | u
										}
										return 0 !== c ? r.words[l] = 0 | c : r.length--, r.strip()
									}
									o.prototype.toString = function(e, t) {
										var r;
										if (t = 0 | t || 1, 16 === (e = e || 10) || "hex" === e) {
											r = "";
											for (var i = 0, o = 0, s = 0; s < this.length; s++) {
												var a = this.words[s],
													c = (16777215 & (a << i | o)).toString(16);
												r = 0 !== (o = a >>> 24 - i & 16777215) || s !== this.length - 1 ? u[6 - c.length] + c + r : c + r, (i += 2) >= 26 && (i -= 26, s--)
											}
											for (0 !== o && (r = o.toString(16) + r); r.length % t != 0;) r = "0" + r;
											return 0 !== this.negative && (r = "-" + r), r
										}
										if (e === (0 | e) && e >= 2 && e <= 36) {
											var l = d[e],
												f = h[e];
											r = "";
											var p = this.clone();
											for (p.negative = 0; !p.isZero();) {
												var v = p.modn(f).toString(e);
												r = (p = p.idivn(f)).isZero() ? v + r : u[l - v.length] + v + r
											}
											for (this.isZero() && (r = "0" + r); r.length % t != 0;) r = "0" + r;
											return 0 !== this.negative && (r = "-" + r), r
										}
										n(!1, "Base should be between 2 and 36")
									}, o.prototype.toNumber = function() {
										var e = this.words[0];
										return 2 === this.length ? e += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? e += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -e : e
									}, o.prototype.toJSON = function() {
										return this.toString(16)
									}, o.prototype.toBuffer = function(e, t) {
										return n(void 0 !== s), this.toArrayLike(s, e, t)
									}, o.prototype.toArray = function(e, t) {
										return this.toArrayLike(Array, e, t)
									}, o.prototype.toArrayLike = function(e, t, r) {
										var i = this.byteLength(),
											o = r || Math.max(1, i);
										n(i <= o, "byte array longer than desired length"), n(o > 0, "Requested array length <= 0"), this.strip();
										var s, a, c = "le" === t,
											l = new e(o),
											u = this.clone();
										if (c) {
											for (a = 0; !u.isZero(); a++) s = u.andln(255), u.iushrn(8), l[a] = s;
											for (; a < o; a++) l[a] = 0
										} else {
											for (a = 0; a < o - i; a++) l[a] = 0;
											for (a = 0; !u.isZero(); a++) s = u.andln(255), u.iushrn(8), l[o - a - 1] = s
										}
										return l
									}, Math.clz32 ? o.prototype._countBits = function(e) {
										return 32 - Math.clz32(e)
									} : o.prototype._countBits = function(e) {
										var t = e,
											r = 0;
										return t >= 4096 && (r += 13, t >>>= 13), t >= 64 && (r += 7, t >>>= 7), t >= 8 && (r += 4, t >>>= 4), t >= 2 && (r += 2, t >>>= 2), r + t
									}, o.prototype._zeroBits = function(e) {
										if (0 === e) return 26;
										var t = e,
											r = 0;
										return 0 == (8191 & t) && (r += 13, t >>>= 13), 0 == (127 & t) && (r += 7, t >>>= 7), 0 == (15 & t) && (r += 4, t >>>= 4), 0 == (3 & t) && (r += 2, t >>>= 2), 0 == (1 & t) && r++, r
									}, o.prototype.bitLength = function() {
										var e = this.words[this.length - 1],
											t = this._countBits(e);
										return 26 * (this.length - 1) + t
									}, o.prototype.zeroBits = function() {
										if (this.isZero()) return 0;
										for (var e = 0, t = 0; t < this.length; t++) {
											var r = this._zeroBits(this.words[t]);
											if (e += r, 26 !== r) break
										}
										return e
									}, o.prototype.byteLength = function() {
										return Math.ceil(this.bitLength() / 8)
									}, o.prototype.toTwos = function(e) {
										return 0 !== this.negative ? this.abs().inotn(e).iaddn(1) : this.clone()
									}, o.prototype.fromTwos = function(e) {
										return this.testn(e - 1) ? this.notn(e).iaddn(1).ineg() : this.clone()
									}, o.prototype.isNeg = function() {
										return 0 !== this.negative
									}, o.prototype.neg = function() {
										return this.clone().ineg()
									}, o.prototype.ineg = function() {
										return this.isZero() || (this.negative ^= 1), this
									}, o.prototype.iuor = function(e) {
										for (; this.length < e.length;) this.words[this.length++] = 0;
										for (var t = 0; t < e.length; t++) this.words[t] = this.words[t] | e.words[t];
										return this.strip()
									}, o.prototype.ior = function(e) {
										return n(0 == (this.negative | e.negative)), this.iuor(e)
									}, o.prototype.or = function(e) {
										return this.length > e.length ? this.clone().ior(e) : e.clone().ior(this)
									}, o.prototype.uor = function(e) {
										return this.length > e.length ? this.clone().iuor(e) : e.clone().iuor(this)
									}, o.prototype.iuand = function(e) {
										var t;
										t = this.length > e.length ? e : this;
										for (var r = 0; r < t.length; r++) this.words[r] = this.words[r] & e.words[r];
										return this.length = t.length, this.strip()
									}, o.prototype.iand = function(e) {
										return n(0 == (this.negative | e.negative)), this.iuand(e)
									}, o.prototype.and = function(e) {
										return this.length > e.length ? this.clone().iand(e) : e.clone().iand(this)
									}, o.prototype.uand = function(e) {
										return this.length > e.length ? this.clone().iuand(e) : e.clone().iuand(this)
									}, o.prototype.iuxor = function(e) {
										var t, r;
										this.length > e.length ? (t = this, r = e) : (t = e, r = this);
										for (var n = 0; n < r.length; n++) this.words[n] = t.words[n] ^ r.words[n];
										if (this !== t)
											for (; n < t.length; n++) this.words[n] = t.words[n];
										return this.length = t.length, this.strip()
									}, o.prototype.ixor = function(e) {
										return n(0 == (this.negative | e.negative)), this.iuxor(e)
									}, o.prototype.xor = function(e) {
										return this.length > e.length ? this.clone().ixor(e) : e.clone().ixor(this)
									}, o.prototype.uxor = function(e) {
										return this.length > e.length ? this.clone().iuxor(e) : e.clone().iuxor(this)
									}, o.prototype.inotn = function(e) {
										n("number" == typeof e && e >= 0);
										var t = 0 | Math.ceil(e / 26),
											r = e % 26;
										this._expand(t), r > 0 && t--;
										for (var i = 0; i < t; i++) this.words[i] = 67108863 & ~this.words[i];
										return r > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - r), this.strip()
									}, o.prototype.notn = function(e) {
										return this.clone().inotn(e)
									}, o.prototype.setn = function(e, t) {
										n("number" == typeof e && e >= 0);
										var r = e / 26 | 0,
											i = e % 26;
										return this._expand(r + 1), this.words[r] = t ? this.words[r] | 1 << i : this.words[r] & ~(1 << i), this.strip()
									}, o.prototype.iadd = function(e) {
										var t, r, n;
										if (0 !== this.negative && 0 === e.negative) return this.negative = 0, t = this.isub(e), this.negative ^= 1, this._normSign();
										if (0 === this.negative && 0 !== e.negative) return e.negative = 0, t = this.isub(e), e.negative = 1, t._normSign();
										this.length > e.length ? (r = this, n = e) : (r = e, n = this);
										for (var i = 0, o = 0; o < n.length; o++) t = (0 | r.words[o]) + (0 | n.words[o]) + i, this.words[o] = 67108863 & t, i = t >>> 26;
										for (; 0 !== i && o < r.length; o++) t = (0 | r.words[o]) + i, this.words[o] = 67108863 & t, i = t >>> 26;
										if (this.length = r.length, 0 !== i) this.words[this.length] = i, this.length++;
										else if (r !== this)
											for (; o < r.length; o++) this.words[o] = r.words[o];
										return this
									}, o.prototype.add = function(e) {
										var t;
										return 0 !== e.negative && 0 === this.negative ? (e.negative = 0, t = this.sub(e), e.negative ^= 1, t) : 0 === e.negative && 0 !== this.negative ? (this.negative = 0, t = e.sub(this), this.negative = 1, t) : this.length > e.length ? this.clone().iadd(e) : e.clone().iadd(this)
									}, o.prototype.isub = function(e) {
										if (0 !== e.negative) {
											e.negative = 0;
											var t = this.iadd(e);
											return e.negative = 1, t._normSign()
										}
										if (0 !== this.negative) return this.negative = 0, this.iadd(e), this.negative = 1, this._normSign();
										var r, n, i = this.cmp(e);
										if (0 === i) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
										i > 0 ? (r = this, n = e) : (r = e, n = this);
										for (var o = 0, s = 0; s < n.length; s++) o = (t = (0 | r.words[s]) - (0 | n.words[s]) + o) >> 26, this.words[s] = 67108863 & t;
										for (; 0 !== o && s < r.length; s++) o = (t = (0 | r.words[s]) + o) >> 26, this.words[s] = 67108863 & t;
										if (0 === o && s < r.length && r !== this)
											for (; s < r.length; s++) this.words[s] = r.words[s];
										return this.length = Math.max(this.length, s), r !== this && (this.negative = 1), this.strip()
									}, o.prototype.sub = function(e) {
										return this.clone().isub(e)
									};
									var p = function(e, t, r) {
										var n, i, o, s = e.words,
											a = t.words,
											c = r.words,
											l = 0,
											u = 0 | s[0],
											d = 8191 & u,
											h = u >>> 13,
											f = 0 | s[1],
											p = 8191 & f,
											v = f >>> 13,
											g = 0 | s[2],
											m = 8191 & g,
											y = g >>> 13,
											b = 0 | s[3],
											_ = 8191 & b,
											w = b >>> 13,
											S = 0 | s[4],
											E = 8191 & S,
											k = S >>> 13,
											T = 0 | s[5],
											I = 8191 & T,
											R = T >>> 13,
											C = 0 | s[6],
											M = 8191 & C,
											x = C >>> 13,
											O = 0 | s[7],
											A = 8191 & O,
											P = O >>> 13,
											D = 0 | s[8],
											j = 8191 & D,
											L = D >>> 13,
											N = 0 | s[9],
											B = 8191 & N,
											U = N >>> 13,
											F = 0 | a[0],
											$ = 8191 & F,
											q = F >>> 13,
											K = 0 | a[1],
											V = 8191 & K,
											z = K >>> 13,
											H = 0 | a[2],
											W = 8191 & H,
											G = H >>> 13,
											Y = 0 | a[3],
											Q = 8191 & Y,
											J = Y >>> 13,
											X = 0 | a[4],
											Z = 8191 & X,
											ee = X >>> 13,
											te = 0 | a[5],
											re = 8191 & te,
											ne = te >>> 13,
											ie = 0 | a[6],
											oe = 8191 & ie,
											se = ie >>> 13,
											ae = 0 | a[7],
											ce = 8191 & ae,
											le = ae >>> 13,
											ue = 0 | a[8],
											de = 8191 & ue,
											he = ue >>> 13,
											fe = 0 | a[9],
											pe = 8191 & fe,
											ve = fe >>> 13;
										r.negative = e.negative ^ t.negative, r.length = 19;
										var ge = (l + (n = Math.imul(d, $)) | 0) + ((8191 & (i = (i = Math.imul(d, q)) + Math.imul(h, $) | 0)) << 13) | 0;
										l = ((o = Math.imul(h, q)) + (i >>> 13) | 0) + (ge >>> 26) | 0, ge &= 67108863, n = Math.imul(p, $), i = (i = Math.imul(p, q)) + Math.imul(v, $) | 0, o = Math.imul(v, q);
										var me = (l + (n = n + Math.imul(d, V) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, z) | 0) + Math.imul(h, V) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, z) | 0) + (i >>> 13) | 0) + (me >>> 26) | 0, me &= 67108863, n = Math.imul(m, $), i = (i = Math.imul(m, q)) + Math.imul(y, $) | 0, o = Math.imul(y, q), n = n + Math.imul(p, V) | 0, i = (i = i + Math.imul(p, z) | 0) + Math.imul(v, V) | 0, o = o + Math.imul(v, z) | 0;
										var ye = (l + (n = n + Math.imul(d, W) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, G) | 0) + Math.imul(h, W) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, G) | 0) + (i >>> 13) | 0) + (ye >>> 26) | 0, ye &= 67108863, n = Math.imul(_, $), i = (i = Math.imul(_, q)) + Math.imul(w, $) | 0, o = Math.imul(w, q), n = n + Math.imul(m, V) | 0, i = (i = i + Math.imul(m, z) | 0) + Math.imul(y, V) | 0, o = o + Math.imul(y, z) | 0, n = n + Math.imul(p, W) | 0, i = (i = i + Math.imul(p, G) | 0) + Math.imul(v, W) | 0, o = o + Math.imul(v, G) | 0;
										var be = (l + (n = n + Math.imul(d, Q) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, J) | 0) + Math.imul(h, Q) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, J) | 0) + (i >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, n = Math.imul(E, $), i = (i = Math.imul(E, q)) + Math.imul(k, $) | 0, o = Math.imul(k, q), n = n + Math.imul(_, V) | 0, i = (i = i + Math.imul(_, z) | 0) + Math.imul(w, V) | 0, o = o + Math.imul(w, z) | 0, n = n + Math.imul(m, W) | 0, i = (i = i + Math.imul(m, G) | 0) + Math.imul(y, W) | 0, o = o + Math.imul(y, G) | 0, n = n + Math.imul(p, Q) | 0, i = (i = i + Math.imul(p, J) | 0) + Math.imul(v, Q) | 0, o = o + Math.imul(v, J) | 0;
										var _e = (l + (n = n + Math.imul(d, Z) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, ee) | 0) + Math.imul(h, Z) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, ee) | 0) + (i >>> 13) | 0) + (_e >>> 26) | 0, _e &= 67108863, n = Math.imul(I, $), i = (i = Math.imul(I, q)) + Math.imul(R, $) | 0, o = Math.imul(R, q), n = n + Math.imul(E, V) | 0, i = (i = i + Math.imul(E, z) | 0) + Math.imul(k, V) | 0, o = o + Math.imul(k, z) | 0, n = n + Math.imul(_, W) | 0, i = (i = i + Math.imul(_, G) | 0) + Math.imul(w, W) | 0, o = o + Math.imul(w, G) | 0, n = n + Math.imul(m, Q) | 0, i = (i = i + Math.imul(m, J) | 0) + Math.imul(y, Q) | 0, o = o + Math.imul(y, J) | 0, n = n + Math.imul(p, Z) | 0, i = (i = i + Math.imul(p, ee) | 0) + Math.imul(v, Z) | 0, o = o + Math.imul(v, ee) | 0;
										var we = (l + (n = n + Math.imul(d, re) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, ne) | 0) + Math.imul(h, re) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, ne) | 0) + (i >>> 13) | 0) + (we >>> 26) | 0, we &= 67108863, n = Math.imul(M, $), i = (i = Math.imul(M, q)) + Math.imul(x, $) | 0, o = Math.imul(x, q), n = n + Math.imul(I, V) | 0, i = (i = i + Math.imul(I, z) | 0) + Math.imul(R, V) | 0, o = o + Math.imul(R, z) | 0, n = n + Math.imul(E, W) | 0, i = (i = i + Math.imul(E, G) | 0) + Math.imul(k, W) | 0, o = o + Math.imul(k, G) | 0, n = n + Math.imul(_, Q) | 0, i = (i = i + Math.imul(_, J) | 0) + Math.imul(w, Q) | 0, o = o + Math.imul(w, J) | 0, n = n + Math.imul(m, Z) | 0, i = (i = i + Math.imul(m, ee) | 0) + Math.imul(y, Z) | 0, o = o + Math.imul(y, ee) | 0, n = n + Math.imul(p, re) | 0, i = (i = i + Math.imul(p, ne) | 0) + Math.imul(v, re) | 0, o = o + Math.imul(v, ne) | 0;
										var Se = (l + (n = n + Math.imul(d, oe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, se) | 0) + Math.imul(h, oe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, se) | 0) + (i >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, n = Math.imul(A, $), i = (i = Math.imul(A, q)) + Math.imul(P, $) | 0, o = Math.imul(P, q), n = n + Math.imul(M, V) | 0, i = (i = i + Math.imul(M, z) | 0) + Math.imul(x, V) | 0, o = o + Math.imul(x, z) | 0, n = n + Math.imul(I, W) | 0, i = (i = i + Math.imul(I, G) | 0) + Math.imul(R, W) | 0, o = o + Math.imul(R, G) | 0, n = n + Math.imul(E, Q) | 0, i = (i = i + Math.imul(E, J) | 0) + Math.imul(k, Q) | 0, o = o + Math.imul(k, J) | 0, n = n + Math.imul(_, Z) | 0, i = (i = i + Math.imul(_, ee) | 0) + Math.imul(w, Z) | 0, o = o + Math.imul(w, ee) | 0, n = n + Math.imul(m, re) | 0, i = (i = i + Math.imul(m, ne) | 0) + Math.imul(y, re) | 0, o = o + Math.imul(y, ne) | 0, n = n + Math.imul(p, oe) | 0, i = (i = i + Math.imul(p, se) | 0) + Math.imul(v, oe) | 0, o = o + Math.imul(v, se) | 0;
										var Ee = (l + (n = n + Math.imul(d, ce) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, le) | 0) + Math.imul(h, ce) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, le) | 0) + (i >>> 13) | 0) + (Ee >>> 26) | 0, Ee &= 67108863, n = Math.imul(j, $), i = (i = Math.imul(j, q)) + Math.imul(L, $) | 0, o = Math.imul(L, q), n = n + Math.imul(A, V) | 0, i = (i = i + Math.imul(A, z) | 0) + Math.imul(P, V) | 0, o = o + Math.imul(P, z) | 0, n = n + Math.imul(M, W) | 0, i = (i = i + Math.imul(M, G) | 0) + Math.imul(x, W) | 0, o = o + Math.imul(x, G) | 0, n = n + Math.imul(I, Q) | 0, i = (i = i + Math.imul(I, J) | 0) + Math.imul(R, Q) | 0, o = o + Math.imul(R, J) | 0, n = n + Math.imul(E, Z) | 0, i = (i = i + Math.imul(E, ee) | 0) + Math.imul(k, Z) | 0, o = o + Math.imul(k, ee) | 0, n = n + Math.imul(_, re) | 0, i = (i = i + Math.imul(_, ne) | 0) + Math.imul(w, re) | 0, o = o + Math.imul(w, ne) | 0, n = n + Math.imul(m, oe) | 0, i = (i = i + Math.imul(m, se) | 0) + Math.imul(y, oe) | 0, o = o + Math.imul(y, se) | 0, n = n + Math.imul(p, ce) | 0, i = (i = i + Math.imul(p, le) | 0) + Math.imul(v, ce) | 0, o = o + Math.imul(v, le) | 0;
										var ke = (l + (n = n + Math.imul(d, de) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, he) | 0) + Math.imul(h, de) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, he) | 0) + (i >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, n = Math.imul(B, $), i = (i = Math.imul(B, q)) + Math.imul(U, $) | 0, o = Math.imul(U, q), n = n + Math.imul(j, V) | 0, i = (i = i + Math.imul(j, z) | 0) + Math.imul(L, V) | 0, o = o + Math.imul(L, z) | 0, n = n + Math.imul(A, W) | 0, i = (i = i + Math.imul(A, G) | 0) + Math.imul(P, W) | 0, o = o + Math.imul(P, G) | 0, n = n + Math.imul(M, Q) | 0, i = (i = i + Math.imul(M, J) | 0) + Math.imul(x, Q) | 0, o = o + Math.imul(x, J) | 0, n = n + Math.imul(I, Z) | 0, i = (i = i + Math.imul(I, ee) | 0) + Math.imul(R, Z) | 0, o = o + Math.imul(R, ee) | 0, n = n + Math.imul(E, re) | 0, i = (i = i + Math.imul(E, ne) | 0) + Math.imul(k, re) | 0, o = o + Math.imul(k, ne) | 0, n = n + Math.imul(_, oe) | 0, i = (i = i + Math.imul(_, se) | 0) + Math.imul(w, oe) | 0, o = o + Math.imul(w, se) | 0, n = n + Math.imul(m, ce) | 0, i = (i = i + Math.imul(m, le) | 0) + Math.imul(y, ce) | 0, o = o + Math.imul(y, le) | 0, n = n + Math.imul(p, de) | 0, i = (i = i + Math.imul(p, he) | 0) + Math.imul(v, de) | 0, o = o + Math.imul(v, he) | 0;
										var Te = (l + (n = n + Math.imul(d, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, ve) | 0) + Math.imul(h, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, ve) | 0) + (i >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, n = Math.imul(B, V), i = (i = Math.imul(B, z)) + Math.imul(U, V) | 0, o = Math.imul(U, z), n = n + Math.imul(j, W) | 0, i = (i = i + Math.imul(j, G) | 0) + Math.imul(L, W) | 0, o = o + Math.imul(L, G) | 0, n = n + Math.imul(A, Q) | 0, i = (i = i + Math.imul(A, J) | 0) + Math.imul(P, Q) | 0, o = o + Math.imul(P, J) | 0, n = n + Math.imul(M, Z) | 0, i = (i = i + Math.imul(M, ee) | 0) + Math.imul(x, Z) | 0, o = o + Math.imul(x, ee) | 0, n = n + Math.imul(I, re) | 0, i = (i = i + Math.imul(I, ne) | 0) + Math.imul(R, re) | 0, o = o + Math.imul(R, ne) | 0, n = n + Math.imul(E, oe) | 0, i = (i = i + Math.imul(E, se) | 0) + Math.imul(k, oe) | 0, o = o + Math.imul(k, se) | 0, n = n + Math.imul(_, ce) | 0, i = (i = i + Math.imul(_, le) | 0) + Math.imul(w, ce) | 0, o = o + Math.imul(w, le) | 0, n = n + Math.imul(m, de) | 0, i = (i = i + Math.imul(m, he) | 0) + Math.imul(y, de) | 0, o = o + Math.imul(y, he) | 0;
										var Ie = (l + (n = n + Math.imul(p, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(p, ve) | 0) + Math.imul(v, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(v, ve) | 0) + (i >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, n = Math.imul(B, W), i = (i = Math.imul(B, G)) + Math.imul(U, W) | 0, o = Math.imul(U, G), n = n + Math.imul(j, Q) | 0, i = (i = i + Math.imul(j, J) | 0) + Math.imul(L, Q) | 0, o = o + Math.imul(L, J) | 0, n = n + Math.imul(A, Z) | 0, i = (i = i + Math.imul(A, ee) | 0) + Math.imul(P, Z) | 0, o = o + Math.imul(P, ee) | 0, n = n + Math.imul(M, re) | 0, i = (i = i + Math.imul(M, ne) | 0) + Math.imul(x, re) | 0, o = o + Math.imul(x, ne) | 0, n = n + Math.imul(I, oe) | 0, i = (i = i + Math.imul(I, se) | 0) + Math.imul(R, oe) | 0, o = o + Math.imul(R, se) | 0, n = n + Math.imul(E, ce) | 0, i = (i = i + Math.imul(E, le) | 0) + Math.imul(k, ce) | 0, o = o + Math.imul(k, le) | 0, n = n + Math.imul(_, de) | 0, i = (i = i + Math.imul(_, he) | 0) + Math.imul(w, de) | 0, o = o + Math.imul(w, he) | 0;
										var Re = (l + (n = n + Math.imul(m, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(m, ve) | 0) + Math.imul(y, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(y, ve) | 0) + (i >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, n = Math.imul(B, Q), i = (i = Math.imul(B, J)) + Math.imul(U, Q) | 0, o = Math.imul(U, J), n = n + Math.imul(j, Z) | 0, i = (i = i + Math.imul(j, ee) | 0) + Math.imul(L, Z) | 0, o = o + Math.imul(L, ee) | 0, n = n + Math.imul(A, re) | 0, i = (i = i + Math.imul(A, ne) | 0) + Math.imul(P, re) | 0, o = o + Math.imul(P, ne) | 0, n = n + Math.imul(M, oe) | 0, i = (i = i + Math.imul(M, se) | 0) + Math.imul(x, oe) | 0, o = o + Math.imul(x, se) | 0, n = n + Math.imul(I, ce) | 0, i = (i = i + Math.imul(I, le) | 0) + Math.imul(R, ce) | 0, o = o + Math.imul(R, le) | 0, n = n + Math.imul(E, de) | 0, i = (i = i + Math.imul(E, he) | 0) + Math.imul(k, de) | 0, o = o + Math.imul(k, he) | 0;
										var Ce = (l + (n = n + Math.imul(_, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(_, ve) | 0) + Math.imul(w, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(w, ve) | 0) + (i >>> 13) | 0) + (Ce >>> 26) | 0, Ce &= 67108863, n = Math.imul(B, Z), i = (i = Math.imul(B, ee)) + Math.imul(U, Z) | 0, o = Math.imul(U, ee), n = n + Math.imul(j, re) | 0, i = (i = i + Math.imul(j, ne) | 0) + Math.imul(L, re) | 0, o = o + Math.imul(L, ne) | 0, n = n + Math.imul(A, oe) | 0, i = (i = i + Math.imul(A, se) | 0) + Math.imul(P, oe) | 0, o = o + Math.imul(P, se) | 0, n = n + Math.imul(M, ce) | 0, i = (i = i + Math.imul(M, le) | 0) + Math.imul(x, ce) | 0, o = o + Math.imul(x, le) | 0, n = n + Math.imul(I, de) | 0, i = (i = i + Math.imul(I, he) | 0) + Math.imul(R, de) | 0, o = o + Math.imul(R, he) | 0;
										var Me = (l + (n = n + Math.imul(E, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(E, ve) | 0) + Math.imul(k, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(k, ve) | 0) + (i >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, n = Math.imul(B, re), i = (i = Math.imul(B, ne)) + Math.imul(U, re) | 0, o = Math.imul(U, ne), n = n + Math.imul(j, oe) | 0, i = (i = i + Math.imul(j, se) | 0) + Math.imul(L, oe) | 0, o = o + Math.imul(L, se) | 0, n = n + Math.imul(A, ce) | 0, i = (i = i + Math.imul(A, le) | 0) + Math.imul(P, ce) | 0, o = o + Math.imul(P, le) | 0, n = n + Math.imul(M, de) | 0, i = (i = i + Math.imul(M, he) | 0) + Math.imul(x, de) | 0, o = o + Math.imul(x, he) | 0;
										var xe = (l + (n = n + Math.imul(I, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(I, ve) | 0) + Math.imul(R, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(R, ve) | 0) + (i >>> 13) | 0) + (xe >>> 26) | 0, xe &= 67108863, n = Math.imul(B, oe), i = (i = Math.imul(B, se)) + Math.imul(U, oe) | 0, o = Math.imul(U, se), n = n + Math.imul(j, ce) | 0, i = (i = i + Math.imul(j, le) | 0) + Math.imul(L, ce) | 0, o = o + Math.imul(L, le) | 0, n = n + Math.imul(A, de) | 0, i = (i = i + Math.imul(A, he) | 0) + Math.imul(P, de) | 0, o = o + Math.imul(P, he) | 0;
										var Oe = (l + (n = n + Math.imul(M, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(M, ve) | 0) + Math.imul(x, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(x, ve) | 0) + (i >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, n = Math.imul(B, ce), i = (i = Math.imul(B, le)) + Math.imul(U, ce) | 0, o = Math.imul(U, le), n = n + Math.imul(j, de) | 0, i = (i = i + Math.imul(j, he) | 0) + Math.imul(L, de) | 0, o = o + Math.imul(L, he) | 0;
										var Ae = (l + (n = n + Math.imul(A, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(A, ve) | 0) + Math.imul(P, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(P, ve) | 0) + (i >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, n = Math.imul(B, de), i = (i = Math.imul(B, he)) + Math.imul(U, de) | 0, o = Math.imul(U, he);
										var Pe = (l + (n = n + Math.imul(j, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(j, ve) | 0) + Math.imul(L, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(L, ve) | 0) + (i >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863;
										var De = (l + (n = Math.imul(B, pe)) | 0) + ((8191 & (i = (i = Math.imul(B, ve)) + Math.imul(U, pe) | 0)) << 13) | 0;
										return l = ((o = Math.imul(U, ve)) + (i >>> 13) | 0) + (De >>> 26) | 0, De &= 67108863, c[0] = ge, c[1] = me, c[2] = ye, c[3] = be, c[4] = _e, c[5] = we, c[6] = Se, c[7] = Ee, c[8] = ke, c[9] = Te, c[10] = Ie, c[11] = Re, c[12] = Ce, c[13] = Me, c[14] = xe, c[15] = Oe, c[16] = Ae, c[17] = Pe, c[18] = De, 0 !== l && (c[19] = l, r.length++), r
									};

									function v(e, t, r) {
										return (new g).mulp(e, t, r)
									}

									function g(e, t) {
										this.x = e, this.y = t
									}
									Math.imul || (p = f), o.prototype.mulTo = function(e, t) {
										var r = this.length + e.length;
										return 10 === this.length && 10 === e.length ? p(this, e, t) : r < 63 ? f(this, e, t) : r < 1024 ? function(e, t, r) {
											r.negative = t.negative ^ e.negative, r.length = e.length + t.length;
											for (var n = 0, i = 0, o = 0; o < r.length - 1; o++) {
												var s = i;
												i = 0;
												for (var a = 67108863 & n, c = Math.min(o, t.length - 1), l = Math.max(0, o - e.length + 1); l <= c; l++) {
													var u = o - l,
														d = (0 | e.words[u]) * (0 | t.words[l]),
														h = 67108863 & d;
													a = 67108863 & (h = h + a | 0), i += (s = (s = s + (d / 67108864 | 0) | 0) + (h >>> 26) | 0) >>> 26, s &= 67108863
												}
												r.words[o] = a, n = s, s = i
											}
											return 0 !== n ? r.words[o] = n : r.length--, r.strip()
										}(this, e, t) : v(this, e, t)
									}, g.prototype.makeRBT = function(e) {
										for (var t = new Array(e), r = o.prototype._countBits(e) - 1, n = 0; n < e; n++) t[n] = this.revBin(n, r, e);
										return t
									}, g.prototype.revBin = function(e, t, r) {
										if (0 === e || e === r - 1) return e;
										for (var n = 0, i = 0; i < t; i++) n |= (1 & e) << t - i - 1, e >>= 1;
										return n
									}, g.prototype.permute = function(e, t, r, n, i, o) {
										for (var s = 0; s < o; s++) n[s] = t[e[s]], i[s] = r[e[s]]
									}, g.prototype.transform = function(e, t, r, n, i, o) {
										this.permute(o, e, t, r, n, i);
										for (var s = 1; s < i; s <<= 1)
											for (var a = s << 1, c = Math.cos(2 * Math.PI / a), l = Math.sin(2 * Math.PI / a), u = 0; u < i; u += a)
												for (var d = c, h = l, f = 0; f < s; f++) {
													var p = r[u + f],
														v = n[u + f],
														g = r[u + f + s],
														m = n[u + f + s],
														y = d * g - h * m;
													m = d * m + h * g, g = y, r[u + f] = p + g, n[u + f] = v + m, r[u + f + s] = p - g, n[u + f + s] = v - m, f !== a && (y = c * d - l * h, h = c * h + l * d, d = y)
												}
									}, g.prototype.guessLen13b = function(e, t) {
										var r = 1 | Math.max(t, e),
											n = 1 & r,
											i = 0;
										for (r = r / 2 | 0; r; r >>>= 1) i++;
										return 1 << i + 1 + n
									}, g.prototype.conjugate = function(e, t, r) {
										if (!(r <= 1))
											for (var n = 0; n < r / 2; n++) {
												var i = e[n];
												e[n] = e[r - n - 1], e[r - n - 1] = i, i = t[n], t[n] = -t[r - n - 1], t[r - n - 1] = -i
											}
									}, g.prototype.normalize13b = function(e, t) {
										for (var r = 0, n = 0; n < t / 2; n++) {
											var i = 8192 * Math.round(e[2 * n + 1] / t) + Math.round(e[2 * n] / t) + r;
											e[n] = 67108863 & i, r = i < 67108864 ? 0 : i / 67108864 | 0
										}
										return e
									}, g.prototype.convert13b = function(e, t, r, i) {
										for (var o = 0, s = 0; s < t; s++) o += 0 | e[s], r[2 * s] = 8191 & o, o >>>= 13, r[2 * s + 1] = 8191 & o, o >>>= 13;
										for (s = 2 * t; s < i; ++s) r[s] = 0;
										n(0 === o), n(0 == (-8192 & o))
									}, g.prototype.stub = function(e) {
										for (var t = new Array(e), r = 0; r < e; r++) t[r] = 0;
										return t
									}, g.prototype.mulp = function(e, t, r) {
										var n = 2 * this.guessLen13b(e.length, t.length),
											i = this.makeRBT(n),
											o = this.stub(n),
											s = new Array(n),
											a = new Array(n),
											c = new Array(n),
											l = new Array(n),
											u = new Array(n),
											d = new Array(n),
											h = r.words;
										h.length = n, this.convert13b(e.words, e.length, s, n), this.convert13b(t.words, t.length, l, n), this.transform(s, o, a, c, n, i), this.transform(l, o, u, d, n, i);
										for (var f = 0; f < n; f++) {
											var p = a[f] * u[f] - c[f] * d[f];
											c[f] = a[f] * d[f] + c[f] * u[f], a[f] = p
										}
										return this.conjugate(a, c, n), this.transform(a, c, h, o, n, i), this.conjugate(h, o, n), this.normalize13b(h, n), r.negative = e.negative ^ t.negative, r.length = e.length + t.length, r.strip()
									}, o.prototype.mul = function(e) {
										var t = new o(null);
										return t.words = new Array(this.length + e.length), this.mulTo(e, t)
									}, o.prototype.mulf = function(e) {
										var t = new o(null);
										return t.words = new Array(this.length + e.length), v(this, e, t)
									}, o.prototype.imul = function(e) {
										return this.clone().mulTo(e, this)
									}, o.prototype.imuln = function(e) {
										n("number" == typeof e), n(e < 67108864);
										for (var t = 0, r = 0; r < this.length; r++) {
											var i = (0 | this.words[r]) * e,
												o = (67108863 & i) + (67108863 & t);
											t >>= 26, t += i / 67108864 | 0, t += o >>> 26, this.words[r] = 67108863 & o
										}
										return 0 !== t && (this.words[r] = t, this.length++), this
									}, o.prototype.muln = function(e) {
										return this.clone().imuln(e)
									}, o.prototype.sqr = function() {
										return this.mul(this)
									}, o.prototype.isqr = function() {
										return this.imul(this.clone())
									}, o.prototype.pow = function(e) {
										var t = function(e) {
											for (var t = new Array(e.bitLength()), r = 0; r < t.length; r++) {
												var n = r / 26 | 0,
													i = r % 26;
												t[r] = (e.words[n] & 1 << i) >>> i
											}
											return t
										}(e);
										if (0 === t.length) return new o(1);
										for (var r = this, n = 0; n < t.length && 0 === t[n]; n++, r = r.sqr());
										if (++n < t.length)
											for (var i = r.sqr(); n < t.length; n++, i = i.sqr()) 0 !== t[n] && (r = r.mul(i));
										return r
									}, o.prototype.iushln = function(e) {
										n("number" == typeof e && e >= 0);
										var t, r = e % 26,
											i = (e - r) / 26,
											o = 67108863 >>> 26 - r << 26 - r;
										if (0 !== r) {
											var s = 0;
											for (t = 0; t < this.length; t++) {
												var a = this.words[t] & o,
													c = (0 | this.words[t]) - a << r;
												this.words[t] = c | s, s = a >>> 26 - r
											}
											s && (this.words[t] = s, this.length++)
										}
										if (0 !== i) {
											for (t = this.length - 1; t >= 0; t--) this.words[t + i] = this.words[t];
											for (t = 0; t < i; t++) this.words[t] = 0;
											this.length += i
										}
										return this.strip()
									}, o.prototype.ishln = function(e) {
										return n(0 === this.negative), this.iushln(e)
									}, o.prototype.iushrn = function(e, t, r) {
										var i;
										n("number" == typeof e && e >= 0), i = t ? (t - t % 26) / 26 : 0;
										var o = e % 26,
											s = Math.min((e - o) / 26, this.length),
											a = 67108863 ^ 67108863 >>> o << o,
											c = r;
										if (i -= s, i = Math.max(0, i), c) {
											for (var l = 0; l < s; l++) c.words[l] = this.words[l];
											c.length = s
										}
										if (0 === s);
										else if (this.length > s)
											for (this.length -= s, l = 0; l < this.length; l++) this.words[l] = this.words[l + s];
										else this.words[0] = 0, this.length = 1;
										var u = 0;
										for (l = this.length - 1; l >= 0 && (0 !== u || l >= i); l--) {
											var d = 0 | this.words[l];
											this.words[l] = u << 26 - o | d >>> o, u = d & a
										}
										return c && 0 !== u && (c.words[c.length++] = u), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip()
									}, o.prototype.ishrn = function(e, t, r) {
										return n(0 === this.negative), this.iushrn(e, t, r)
									}, o.prototype.shln = function(e) {
										return this.clone().ishln(e)
									}, o.prototype.ushln = function(e) {
										return this.clone().iushln(e)
									}, o.prototype.shrn = function(e) {
										return this.clone().ishrn(e)
									}, o.prototype.ushrn = function(e) {
										return this.clone().iushrn(e)
									}, o.prototype.testn = function(e) {
										n("number" == typeof e && e >= 0);
										var t = e % 26,
											r = (e - t) / 26,
											i = 1 << t;
										return !(this.length <= r) && !!(this.words[r] & i)
									}, o.prototype.imaskn = function(e) {
										n("number" == typeof e && e >= 0);
										var t = e % 26,
											r = (e - t) / 26;
										if (n(0 === this.negative, "imaskn works only with positive numbers"), this.length <= r) return this;
										if (0 !== t && r++, this.length = Math.min(r, this.length), 0 !== t) {
											var i = 67108863 ^ 67108863 >>> t << t;
											this.words[this.length - 1] &= i
										}
										return this.strip()
									}, o.prototype.maskn = function(e) {
										return this.clone().imaskn(e)
									}, o.prototype.iaddn = function(e) {
										return n("number" == typeof e), n(e < 67108864), e < 0 ? this.isubn(-e) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < e ? (this.words[0] = e - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(e), this.negative = 1, this) : this._iaddn(e)
									}, o.prototype._iaddn = function(e) {
										this.words[0] += e;
										for (var t = 0; t < this.length && this.words[t] >= 67108864; t++) this.words[t] -= 67108864, t === this.length - 1 ? this.words[t + 1] = 1 : this.words[t + 1]++;
										return this.length = Math.max(this.length, t + 1), this
									}, o.prototype.isubn = function(e) {
										if (n("number" == typeof e), n(e < 67108864), e < 0) return this.iaddn(-e);
										if (0 !== this.negative) return this.negative = 0, this.iaddn(e), this.negative = 1, this;
										if (this.words[0] -= e, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
										else
											for (var t = 0; t < this.length && this.words[t] < 0; t++) this.words[t] += 67108864, this.words[t + 1] -= 1;
										return this.strip()
									}, o.prototype.addn = function(e) {
										return this.clone().iaddn(e)
									}, o.prototype.subn = function(e) {
										return this.clone().isubn(e)
									}, o.prototype.iabs = function() {
										return this.negative = 0, this
									}, o.prototype.abs = function() {
										return this.clone().iabs()
									}, o.prototype._ishlnsubmul = function(e, t, r) {
										var i, o, s = e.length + r;
										this._expand(s);
										var a = 0;
										for (i = 0; i < e.length; i++) {
											o = (0 | this.words[i + r]) + a;
											var c = (0 | e.words[i]) * t;
											a = ((o -= 67108863 & c) >> 26) - (c / 67108864 | 0), this.words[i + r] = 67108863 & o
										}
										for (; i < this.length - r; i++) a = (o = (0 | this.words[i + r]) + a) >> 26, this.words[i + r] = 67108863 & o;
										if (0 === a) return this.strip();
										for (n(-1 === a), a = 0, i = 0; i < this.length; i++) a = (o = -(0 | this.words[i]) + a) >> 26, this.words[i] = 67108863 & o;
										return this.negative = 1, this.strip()
									}, o.prototype._wordDiv = function(e, t) {
										var r = (this.length, e.length),
											n = this.clone(),
											i = e,
											s = 0 | i.words[i.length - 1];
										0 !== (r = 26 - this._countBits(s)) && (i = i.ushln(r), n.iushln(r), s = 0 | i.words[i.length - 1]);
										var a, c = n.length - i.length;
										if ("mod" !== t) {
											(a = new o(null)).length = c + 1, a.words = new Array(a.length);
											for (var l = 0; l < a.length; l++) a.words[l] = 0
										}
										var u = n.clone()._ishlnsubmul(i, 1, c);
										0 === u.negative && (n = u, a && (a.words[c] = 1));
										for (var d = c - 1; d >= 0; d--) {
											var h = 67108864 * (0 | n.words[i.length + d]) + (0 | n.words[i.length + d - 1]);
											for (h = Math.min(h / s | 0, 67108863), n._ishlnsubmul(i, h, d); 0 !== n.negative;) h--, n.negative = 0, n._ishlnsubmul(i, 1, d), n.isZero() || (n.negative ^= 1);
											a && (a.words[d] = h)
										}
										return a && a.strip(), n.strip(), "div" !== t && 0 !== r && n.iushrn(r), {
											div: a || null,
											mod: n
										}
									}, o.prototype.divmod = function(e, t, r) {
										return n(!e.isZero()), this.isZero() ? {
											div: new o(0),
											mod: new o(0)
										} : 0 !== this.negative && 0 === e.negative ? (a = this.neg().divmod(e, t), "mod" !== t && (i = a.div.neg()), "div" !== t && (s = a.mod.neg(), r && 0 !== s.negative && s.iadd(e)), {
											div: i,
											mod: s
										}) : 0 === this.negative && 0 !== e.negative ? (a = this.divmod(e.neg(), t), "mod" !== t && (i = a.div.neg()), {
											div: i,
											mod: a.mod
										}) : 0 != (this.negative & e.negative) ? (a = this.neg().divmod(e.neg(), t), "div" !== t && (s = a.mod.neg(), r && 0 !== s.negative && s.isub(e)), {
											div: a.div,
											mod: s
										}) : e.length > this.length || this.cmp(e) < 0 ? {
											div: new o(0),
											mod: this
										} : 1 === e.length ? "div" === t ? {
											div: this.divn(e.words[0]),
											mod: null
										} : "mod" === t ? {
											div: null,
											mod: new o(this.modn(e.words[0]))
										} : {
											div: this.divn(e.words[0]),
											mod: new o(this.modn(e.words[0]))
										} : this._wordDiv(e, t);
										var i, s, a
									}, o.prototype.div = function(e) {
										return this.divmod(e, "div", !1).div
									}, o.prototype.mod = function(e) {
										return this.divmod(e, "mod", !1).mod
									}, o.prototype.umod = function(e) {
										return this.divmod(e, "mod", !0).mod
									}, o.prototype.divRound = function(e) {
										var t = this.divmod(e);
										if (t.mod.isZero()) return t.div;
										var r = 0 !== t.div.negative ? t.mod.isub(e) : t.mod,
											n = e.ushrn(1),
											i = e.andln(1),
											o = r.cmp(n);
										return o < 0 || 1 === i && 0 === o ? t.div : 0 !== t.div.negative ? t.div.isubn(1) : t.div.iaddn(1)
									}, o.prototype.modn = function(e) {
										n(e <= 67108863);
										for (var t = (1 << 26) % e, r = 0, i = this.length - 1; i >= 0; i--) r = (t * r + (0 | this.words[i])) % e;
										return r
									}, o.prototype.idivn = function(e) {
										n(e <= 67108863);
										for (var t = 0, r = this.length - 1; r >= 0; r--) {
											var i = (0 | this.words[r]) + 67108864 * t;
											this.words[r] = i / e | 0, t = i % e
										}
										return this.strip()
									}, o.prototype.divn = function(e) {
										return this.clone().idivn(e)
									}, o.prototype.egcd = function(e) {
										n(0 === e.negative), n(!e.isZero());
										var t = this,
											r = e.clone();
										t = 0 !== t.negative ? t.umod(e) : t.clone();
										for (var i = new o(1), s = new o(0), a = new o(0), c = new o(1), l = 0; t.isEven() && r.isEven();) t.iushrn(1), r.iushrn(1), ++l;
										for (var u = r.clone(), d = t.clone(); !t.isZero();) {
											for (var h = 0, f = 1; 0 == (t.words[0] & f) && h < 26; ++h, f <<= 1);
											if (h > 0)
												for (t.iushrn(h); h-- > 0;)(i.isOdd() || s.isOdd()) && (i.iadd(u), s.isub(d)), i.iushrn(1), s.iushrn(1);
											for (var p = 0, v = 1; 0 == (r.words[0] & v) && p < 26; ++p, v <<= 1);
											if (p > 0)
												for (r.iushrn(p); p-- > 0;)(a.isOdd() || c.isOdd()) && (a.iadd(u), c.isub(d)), a.iushrn(1), c.iushrn(1);
											t.cmp(r) >= 0 ? (t.isub(r), i.isub(a), s.isub(c)) : (r.isub(t), a.isub(i), c.isub(s))
										}
										return {
											a,
											b: c,
											gcd: r.iushln(l)
										}
									}, o.prototype._invmp = function(e) {
										n(0 === e.negative), n(!e.isZero());
										var t = this,
											r = e.clone();
										t = 0 !== t.negative ? t.umod(e) : t.clone();
										for (var i, s = new o(1), a = new o(0), c = r.clone(); t.cmpn(1) > 0 && r.cmpn(1) > 0;) {
											for (var l = 0, u = 1; 0 == (t.words[0] & u) && l < 26; ++l, u <<= 1);
											if (l > 0)
												for (t.iushrn(l); l-- > 0;) s.isOdd() && s.iadd(c), s.iushrn(1);
											for (var d = 0, h = 1; 0 == (r.words[0] & h) && d < 26; ++d, h <<= 1);
											if (d > 0)
												for (r.iushrn(d); d-- > 0;) a.isOdd() && a.iadd(c), a.iushrn(1);
											t.cmp(r) >= 0 ? (t.isub(r), s.isub(a)) : (r.isub(t), a.isub(s))
										}
										return (i = 0 === t.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(e), i
									}, o.prototype.gcd = function(e) {
										if (this.isZero()) return e.abs();
										if (e.isZero()) return this.abs();
										var t = this.clone(),
											r = e.clone();
										t.negative = 0, r.negative = 0;
										for (var n = 0; t.isEven() && r.isEven(); n++) t.iushrn(1), r.iushrn(1);
										for (;;) {
											for (; t.isEven();) t.iushrn(1);
											for (; r.isEven();) r.iushrn(1);
											var i = t.cmp(r);
											if (i < 0) {
												var o = t;
												t = r, r = o
											} else if (0 === i || 0 === r.cmpn(1)) break;
											t.isub(r)
										}
										return r.iushln(n)
									}, o.prototype.invm = function(e) {
										return this.egcd(e).a.umod(e)
									}, o.prototype.isEven = function() {
										return 0 == (1 & this.words[0])
									}, o.prototype.isOdd = function() {
										return 1 == (1 & this.words[0])
									}, o.prototype.andln = function(e) {
										return this.words[0] & e
									}, o.prototype.bincn = function(e) {
										n("number" == typeof e);
										var t = e % 26,
											r = (e - t) / 26,
											i = 1 << t;
										if (this.length <= r) return this._expand(r + 1), this.words[r] |= i, this;
										for (var o = i, s = r; 0 !== o && s < this.length; s++) {
											var a = 0 | this.words[s];
											o = (a += o) >>> 26, a &= 67108863, this.words[s] = a
										}
										return 0 !== o && (this.words[s] = o, this.length++), this
									}, o.prototype.isZero = function() {
										return 1 === this.length && 0 === this.words[0]
									}, o.prototype.cmpn = function(e) {
										var t, r = e < 0;
										if (0 !== this.negative && !r) return -1;
										if (0 === this.negative && r) return 1;
										if (this.strip(), this.length > 1) t = 1;
										else {
											r && (e = -e), n(e <= 67108863, "Number is too big");
											var i = 0 | this.words[0];
											t = i === e ? 0 : i < e ? -1 : 1
										}
										return 0 !== this.negative ? 0 | -t : t
									}, o.prototype.cmp = function(e) {
										if (0 !== this.negative && 0 === e.negative) return -1;
										if (0 === this.negative && 0 !== e.negative) return 1;
										var t = this.ucmp(e);
										return 0 !== this.negative ? 0 | -t : t
									}, o.prototype.ucmp = function(e) {
										if (this.length > e.length) return 1;
										if (this.length < e.length) return -1;
										for (var t = 0, r = this.length - 1; r >= 0; r--) {
											var n = 0 | this.words[r],
												i = 0 | e.words[r];
											if (n !== i) {
												n < i ? t = -1 : n > i && (t = 1);
												break
											}
										}
										return t
									}, o.prototype.gtn = function(e) {
										return 1 === this.cmpn(e)
									}, o.prototype.gt = function(e) {
										return 1 === this.cmp(e)
									}, o.prototype.gten = function(e) {
										return this.cmpn(e) >= 0
									}, o.prototype.gte = function(e) {
										return this.cmp(e) >= 0
									}, o.prototype.ltn = function(e) {
										return -1 === this.cmpn(e)
									}, o.prototype.lt = function(e) {
										return -1 === this.cmp(e)
									}, o.prototype.lten = function(e) {
										return this.cmpn(e) <= 0
									}, o.prototype.lte = function(e) {
										return this.cmp(e) <= 0
									}, o.prototype.eqn = function(e) {
										return 0 === this.cmpn(e)
									}, o.prototype.eq = function(e) {
										return 0 === this.cmp(e)
									}, o.red = function(e) {
										return new E(e)
									}, o.prototype.toRed = function(e) {
										return n(!this.red, "Already a number in reduction context"), n(0 === this.negative, "red works only with positives"), e.convertTo(this)._forceRed(e)
									}, o.prototype.fromRed = function() {
										return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
									}, o.prototype._forceRed = function(e) {
										return this.red = e, this
									}, o.prototype.forceRed = function(e) {
										return n(!this.red, "Already a number in reduction context"), this._forceRed(e)
									}, o.prototype.redAdd = function(e) {
										return n(this.red, "redAdd works only with red numbers"), this.red.add(this, e)
									}, o.prototype.redIAdd = function(e) {
										return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, e)
									}, o.prototype.redSub = function(e) {
										return n(this.red, "redSub works only with red numbers"), this.red.sub(this, e)
									}, o.prototype.redISub = function(e) {
										return n(this.red, "redISub works only with red numbers"), this.red.isub(this, e)
									}, o.prototype.redShl = function(e) {
										return n(this.red, "redShl works only with red numbers"), this.red.shl(this, e)
									}, o.prototype.redMul = function(e) {
										return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, e), this.red.mul(this, e)
									}, o.prototype.redIMul = function(e) {
										return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, e), this.red.imul(this, e)
									}, o.prototype.redSqr = function() {
										return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
									}, o.prototype.redISqr = function() {
										return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
									}, o.prototype.redSqrt = function() {
										return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
									}, o.prototype.redInvm = function() {
										return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
									}, o.prototype.redNeg = function() {
										return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
									}, o.prototype.redPow = function(e) {
										return n(this.red && !e.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, e)
									};
									var m = {
										k256: null,
										p224: null,
										p192: null,
										p25519: null
									};

									function y(e, t) {
										this.name = e, this.p = new o(t, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
									}

									function b() {
										y.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
									}

									function _() {
										y.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
									}

									function w() {
										y.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
									}

									function S() {
										y.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
									}

									function E(e) {
										if ("string" == typeof e) {
											var t = o._prime(e);
											this.m = t.p, this.prime = t
										} else n(e.gtn(1), "modulus must be greater than 1"), this.m = e, this.prime = null
									}

									function k(e) {
										E.call(this, e), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
									}
									y.prototype._tmp = function() {
										var e = new o(null);
										return e.words = new Array(Math.ceil(this.n / 13)), e
									}, y.prototype.ireduce = function(e) {
										var t, r = e;
										do {
											this.split(r, this.tmp), t = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength()
										} while (t > this.n);
										var n = t < this.n ? -1 : r.ucmp(this.p);
										return 0 === n ? (r.words[0] = 0, r.length = 1) : n > 0 ? r.isub(this.p) : void 0 !== r.strip ? r.strip() : r._strip(), r
									}, y.prototype.split = function(e, t) {
										e.iushrn(this.n, 0, t)
									}, y.prototype.imulK = function(e) {
										return e.imul(this.k)
									}, i(b, y), b.prototype.split = function(e, t) {
										for (var r = Math.min(e.length, 9), n = 0; n < r; n++) t.words[n] = e.words[n];
										if (t.length = r, e.length <= 9) return e.words[0] = 0, void(e.length = 1);
										var i = e.words[9];
										for (t.words[t.length++] = 4194303 & i, n = 10; n < e.length; n++) {
											var o = 0 | e.words[n];
											e.words[n - 10] = (4194303 & o) << 4 | i >>> 22, i = o
										}
										i >>>= 22, e.words[n - 10] = i, 0 === i && e.length > 10 ? e.length -= 10 : e.length -= 9
									}, b.prototype.imulK = function(e) {
										e.words[e.length] = 0, e.words[e.length + 1] = 0, e.length += 2;
										for (var t = 0, r = 0; r < e.length; r++) {
											var n = 0 | e.words[r];
											t += 977 * n, e.words[r] = 67108863 & t, t = 64 * n + (t / 67108864 | 0)
										}
										return 0 === e.words[e.length - 1] && (e.length--, 0 === e.words[e.length - 1] && e.length--), e
									}, i(_, y), i(w, y), i(S, y), S.prototype.imulK = function(e) {
										for (var t = 0, r = 0; r < e.length; r++) {
											var n = 19 * (0 | e.words[r]) + t,
												i = 67108863 & n;
											n >>>= 26, e.words[r] = i, t = n
										}
										return 0 !== t && (e.words[e.length++] = t), e
									}, o._prime = function(e) {
										if (m[e]) return m[e];
										var t;
										if ("k256" === e) t = new b;
										else if ("p224" === e) t = new _;
										else if ("p192" === e) t = new w;
										else {
											if ("p25519" !== e) throw new Error("Unknown prime " + e);
											t = new S
										}
										return m[e] = t, t
									}, E.prototype._verify1 = function(e) {
										n(0 === e.negative, "red works only with positives"), n(e.red, "red works only with red numbers")
									}, E.prototype._verify2 = function(e, t) {
										n(0 == (e.negative | t.negative), "red works only with positives"), n(e.red && e.red === t.red, "red works only with red numbers")
									}, E.prototype.imod = function(e) {
										return this.prime ? this.prime.ireduce(e)._forceRed(this) : e.umod(this.m)._forceRed(this)
									}, E.prototype.neg = function(e) {
										return e.isZero() ? e.clone() : this.m.sub(e)._forceRed(this)
									}, E.prototype.add = function(e, t) {
										this._verify2(e, t);
										var r = e.add(t);
										return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this)
									}, E.prototype.iadd = function(e, t) {
										this._verify2(e, t);
										var r = e.iadd(t);
										return r.cmp(this.m) >= 0 && r.isub(this.m), r
									}, E.prototype.sub = function(e, t) {
										this._verify2(e, t);
										var r = e.sub(t);
										return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this)
									}, E.prototype.isub = function(e, t) {
										this._verify2(e, t);
										var r = e.isub(t);
										return r.cmpn(0) < 0 && r.iadd(this.m), r
									}, E.prototype.shl = function(e, t) {
										return this._verify1(e), this.imod(e.ushln(t))
									}, E.prototype.imul = function(e, t) {
										return this._verify2(e, t), this.imod(e.imul(t))
									}, E.prototype.mul = function(e, t) {
										return this._verify2(e, t), this.imod(e.mul(t))
									}, E.prototype.isqr = function(e) {
										return this.imul(e, e.clone())
									}, E.prototype.sqr = function(e) {
										return this.mul(e, e)
									}, E.prototype.sqrt = function(e) {
										if (e.isZero()) return e.clone();
										var t = this.m.andln(3);
										if (n(t % 2 == 1), 3 === t) {
											var r = this.m.add(new o(1)).iushrn(2);
											return this.pow(e, r)
										}
										for (var i = this.m.subn(1), s = 0; !i.isZero() && 0 === i.andln(1);) s++, i.iushrn(1);
										n(!i.isZero());
										var a = new o(1).toRed(this),
											c = a.redNeg(),
											l = this.m.subn(1).iushrn(1),
											u = this.m.bitLength();
										for (u = new o(2 * u * u).toRed(this); 0 !== this.pow(u, l).cmp(c);) u.redIAdd(c);
										for (var d = this.pow(u, i), h = this.pow(e, i.addn(1).iushrn(1)), f = this.pow(e, i), p = s; 0 !== f.cmp(a);) {
											for (var v = f, g = 0; 0 !== v.cmp(a); g++) v = v.redSqr();
											n(g < p);
											var m = this.pow(d, new o(1).iushln(p - g - 1));
											h = h.redMul(m), d = m.redSqr(), f = f.redMul(d), p = g
										}
										return h
									}, E.prototype.invm = function(e) {
										var t = e._invmp(this.m);
										return 0 !== t.negative ? (t.negative = 0, this.imod(t).redNeg()) : this.imod(t)
									}, E.prototype.pow = function(e, t) {
										if (t.isZero()) return new o(1).toRed(this);
										if (0 === t.cmpn(1)) return e.clone();
										var r = new Array(16);
										r[0] = new o(1).toRed(this), r[1] = e;
										for (var n = 2; n < r.length; n++) r[n] = this.mul(r[n - 1], e);
										var i = r[0],
											s = 0,
											a = 0,
											c = t.bitLength() % 26;
										for (0 === c && (c = 26), n = t.length - 1; n >= 0; n--) {
											for (var l = t.words[n], u = c - 1; u >= 0; u--) {
												var d = l >> u & 1;
												i !== r[0] && (i = this.sqr(i)), 0 !== d || 0 !== s ? (s <<= 1, s |= d, (4 === ++a || 0 === n && 0 === u) && (i = this.mul(i, r[s]), a = 0, s = 0)) : a = 0
											}
											c = 26
										}
										return i
									}, E.prototype.convertTo = function(e) {
										var t = e.umod(this.m);
										return t === e ? t.clone() : t
									}, E.prototype.convertFrom = function(e) {
										var t = e.clone();
										return t.red = null, t
									}, o.mont = function(e) {
										return new k(e)
									}, i(k, E), k.prototype.convertTo = function(e) {
										return this.imod(e.ushln(this.shift))
									}, k.prototype.convertFrom = function(e) {
										var t = this.imod(e.mul(this.rinv));
										return t.red = null, t
									}, k.prototype.imul = function(e, t) {
										if (e.isZero() || t.isZero()) return e.words[0] = 0, e.length = 1, e;
										var r = e.imul(t),
											n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
											i = r.isub(n).iushrn(this.shift),
											o = i;
										return i.cmp(this.m) >= 0 ? o = i.isub(this.m) : i.cmpn(0) < 0 && (o = i.iadd(this.m)), o._forceRed(this)
									}, k.prototype.mul = function(e, t) {
										if (e.isZero() || t.isZero()) return new o(0)._forceRed(this);
										var r = e.mul(t),
											n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
											i = r.isub(n).iushrn(this.shift),
											s = i;
										return i.cmp(this.m) >= 0 ? s = i.isub(this.m) : i.cmpn(0) < 0 && (s = i.iadd(this.m)), s._forceRed(this)
									}, k.prototype.invm = function(e) {
										return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this)
									}
								}(void 0 === t || t, this)
							}, {
								buffer: 21
							}],
							20: [function(e, t, r) {
								var n;

								function i(e) {
									this.rand = e
								}
								if (t.exports = function(e) {
										return n || (n = new i(null)), n.generate(e)
									}, t.exports.Rand = i, i.prototype.generate = function(e) {
										return this._rand(e)
									}, i.prototype._rand = function(e) {
										if (this.rand.getBytes) return this.rand.getBytes(e);
										for (var t = new Uint8Array(e), r = 0; r < t.length; r++) t[r] = this.rand.getByte();
										return t
									}, "object" == typeof self) self.crypto && self.crypto.getRandomValues ? i.prototype._rand = function(e) {
									var t = new Uint8Array(e);
									return self.crypto.getRandomValues(t), t
								} : self.msCrypto && self.msCrypto.getRandomValues ? i.prototype._rand = function(e) {
									var t = new Uint8Array(e);
									return self.msCrypto.getRandomValues(t), t
								} : "object" == typeof window && (i.prototype._rand = function() {
									throw new Error("Not implemented yet")
								});
								else try {
									var o = e("crypto");
									if ("function" != typeof o.randomBytes) throw new Error("Not supported");
									i.prototype._rand = function(e) {
										return o.randomBytes(e)
									}
								} catch (s) {}
							}, {
								crypto: 21
							}],
							21: [function(e, t, r) {}, {}],
							22: [function(e, t, r) {
								var n = e("safe-buffer").Buffer;

								function i(e) {
									n.isBuffer(e) || (e = n.from(e));
									for (var t = e.length / 4 | 0, r = new Array(t), i = 0; i < t; i++) r[i] = e.readUInt32BE(4 * i);
									return r
								}

								function o(e) {
									for (; 0 < e.length; e++) e[0] = 0
								}

								function s(e, t, r, n, i) {
									for (var o, s, a, c, l = r[0], u = r[1], d = r[2], h = r[3], f = e[0] ^ t[0], p = e[1] ^ t[1], v = e[2] ^ t[2], g = e[3] ^ t[3], m = 4, y = 1; y < i; y++) o = l[f >>> 24] ^ u[p >>> 16 & 255] ^ d[v >>> 8 & 255] ^ h[255 & g] ^ t[m++], s = l[p >>> 24] ^ u[v >>> 16 & 255] ^ d[g >>> 8 & 255] ^ h[255 & f] ^ t[m++], a = l[v >>> 24] ^ u[g >>> 16 & 255] ^ d[f >>> 8 & 255] ^ h[255 & p] ^ t[m++], c = l[g >>> 24] ^ u[f >>> 16 & 255] ^ d[p >>> 8 & 255] ^ h[255 & v] ^ t[m++], f = o, p = s, v = a, g = c;
									return o = (n[f >>> 24] << 24 | n[p >>> 16 & 255] << 16 | n[v >>> 8 & 255] << 8 | n[255 & g]) ^ t[m++], s = (n[p >>> 24] << 24 | n[v >>> 16 & 255] << 16 | n[g >>> 8 & 255] << 8 | n[255 & f]) ^ t[m++], a = (n[v >>> 24] << 24 | n[g >>> 16 & 255] << 16 | n[f >>> 8 & 255] << 8 | n[255 & p]) ^ t[m++], c = (n[g >>> 24] << 24 | n[f >>> 16 & 255] << 16 | n[p >>> 8 & 255] << 8 | n[255 & v]) ^ t[m++], [o >>>= 0, s >>>= 0, a >>>= 0, c >>>= 0]
								}
								var a = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
									c = function() {
										for (var e = new Array(256), t = 0; t < 256; t++) e[t] = t < 128 ? t << 1 : t << 1 ^ 283;
										for (var r = [], n = [], i = [
												[],
												[],
												[],
												[]
											], o = [
												[],
												[],
												[],
												[]
											], s = 0, a = 0, c = 0; c < 256; ++c) {
											var l = a ^ a << 1 ^ a << 2 ^ a << 3 ^ a << 4;
											l = l >>> 8 ^ 255 & l ^ 99, r[s] = l, n[l] = s;
											var u = e[s],
												d = e[u],
												h = e[d],
												f = 257 * e[l] ^ 16843008 * l;
											i[0][s] = f << 24 | f >>> 8, i[1][s] = f << 16 | f >>> 16, i[2][s] = f << 8 | f >>> 24, i[3][s] = f, f = 16843009 * h ^ 65537 * d ^ 257 * u ^ 16843008 * s, o[0][l] = f << 24 | f >>> 8, o[1][l] = f << 16 | f >>> 16, o[2][l] = f << 8 | f >>> 24, o[3][l] = f, 0 === s ? s = a = 1 : (s = u ^ e[e[e[h ^ u]]], a ^= e[e[a]])
										}
										return {
											SBOX: r,
											INV_SBOX: n,
											SUB_MIX: i,
											INV_SUB_MIX: o
										}
									}();

								function l(e) {
									this._key = i(e), this._reset()
								}
								l.blockSize = 16, l.keySize = 32, l.prototype.blockSize = l.blockSize, l.prototype.keySize = l.keySize, l.prototype._reset = function() {
									for (var e = this._key, t = e.length, r = t + 6, n = 4 * (r + 1), i = [], o = 0; o < t; o++) i[o] = e[o];
									for (o = t; o < n; o++) {
										var s = i[o - 1];
										o % t == 0 ? (s = s << 8 | s >>> 24, s = c.SBOX[s >>> 24] << 24 | c.SBOX[s >>> 16 & 255] << 16 | c.SBOX[s >>> 8 & 255] << 8 | c.SBOX[255 & s], s ^= a[o / t | 0] << 24) : t > 6 && o % t == 4 && (s = c.SBOX[s >>> 24] << 24 | c.SBOX[s >>> 16 & 255] << 16 | c.SBOX[s >>> 8 & 255] << 8 | c.SBOX[255 & s]), i[o] = i[o - t] ^ s
									}
									for (var l = [], u = 0; u < n; u++) {
										var d = n - u,
											h = i[d - (u % 4 ? 0 : 4)];
										l[u] = u < 4 || d <= 4 ? h : c.INV_SUB_MIX[0][c.SBOX[h >>> 24]] ^ c.INV_SUB_MIX[1][c.SBOX[h >>> 16 & 255]] ^ c.INV_SUB_MIX[2][c.SBOX[h >>> 8 & 255]] ^ c.INV_SUB_MIX[3][c.SBOX[255 & h]]
									}
									this._nRounds = r, this._keySchedule = i, this._invKeySchedule = l
								}, l.prototype.encryptBlockRaw = function(e) {
									return s(e = i(e), this._keySchedule, c.SUB_MIX, c.SBOX, this._nRounds)
								}, l.prototype.encryptBlock = function(e) {
									var t = this.encryptBlockRaw(e),
										r = n.allocUnsafe(16);
									return r.writeUInt32BE(t[0], 0), r.writeUInt32BE(t[1], 4), r.writeUInt32BE(t[2], 8), r.writeUInt32BE(t[3], 12), r
								}, l.prototype.decryptBlock = function(e) {
									var t = (e = i(e))[1];
									e[1] = e[3], e[3] = t;
									var r = s(e, this._invKeySchedule, c.INV_SUB_MIX, c.INV_SBOX, this._nRounds),
										o = n.allocUnsafe(16);
									return o.writeUInt32BE(r[0], 0), o.writeUInt32BE(r[3], 4), o.writeUInt32BE(r[2], 8), o.writeUInt32BE(r[1], 12), o
								}, l.prototype.scrub = function() {
									o(this._keySchedule), o(this._invKeySchedule), o(this._key)
								}, t.exports.AES = l
							}, {
								"safe-buffer": 251
							}],
							23: [function(e, t, r) {
								var n = e("./aes"),
									i = e("safe-buffer").Buffer,
									o = e("cipher-base"),
									s = e("inherits"),
									a = e("./ghash"),
									c = e("buffer-xor"),
									l = e("./incr32");

								function u(e, t, r, s) {
									o.call(this);
									var c = i.alloc(4, 0);
									this._cipher = new n.AES(t);
									var u = this._cipher.encryptBlock(c);
									this._ghash = new a(u), r = function(e, t, r) {
										if (12 === t.length) return e._finID = i.concat([t, i.from([0, 0, 0, 1])]), i.concat([t, i.from([0, 0, 0, 2])]);
										var n = new a(r),
											o = t.length,
											s = o % 16;
										n.update(t), s && (s = 16 - s, n.update(i.alloc(s, 0))), n.update(i.alloc(8, 0));
										var c = 8 * o,
											u = i.alloc(8);
										u.writeUIntBE(c, 0, 8), n.update(u), e._finID = n.state;
										var d = i.from(e._finID);
										return l(d), d
									}(this, r, u), this._prev = i.from(r), this._cache = i.allocUnsafe(0), this._secCache = i.allocUnsafe(0), this._decrypt = s, this._alen = 0, this._len = 0, this._mode = e, this._authTag = null, this._called = !1
								}
								s(u, o), u.prototype._update = function(e) {
									if (!this._called && this._alen) {
										var t = 16 - this._alen % 16;
										t < 16 && (t = i.alloc(t, 0), this._ghash.update(t))
									}
									this._called = !0;
									var r = this._mode.encrypt(this, e);
									return this._decrypt ? this._ghash.update(e) : this._ghash.update(r), this._len += e.length, r
								}, u.prototype._final = function() {
									if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
									var e = c(this._ghash.final(8 * this._alen, 8 * this._len), this._cipher.encryptBlock(this._finID));
									if (this._decrypt && function(e, t) {
											var r = 0;
											e.length !== t.length && r++;
											for (var n = Math.min(e.length, t.length), i = 0; i < n; ++i) r += e[i] ^ t[i];
											return r
										}(e, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
									this._authTag = e, this._cipher.scrub()
								}, u.prototype.getAuthTag = function() {
									if (this._decrypt || !i.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
									return this._authTag
								}, u.prototype.setAuthTag = function(e) {
									if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
									this._authTag = e
								}, u.prototype.setAAD = function(e) {
									if (this._called) throw new Error("Attempting to set AAD in unsupported state");
									this._ghash.update(e), this._alen += e.length
								}, t.exports = u
							}, {
								"./aes": 22,
								"./ghash": 27,
								"./incr32": 28,
								"buffer-xor": 68,
								"cipher-base": 72,
								inherits: 147,
								"safe-buffer": 251
							}],
							24: [function(e, t, r) {
								var n = e("./encrypter"),
									i = e("./decrypter"),
									o = e("./modes/list.json");
								r.createCipher = r.Cipher = n.createCipher, r.createCipheriv = r.Cipheriv = n.createCipheriv, r.createDecipher = r.Decipher = i.createDecipher, r.createDecipheriv = r.Decipheriv = i.createDecipheriv, r.listCiphers = r.getCiphers = function() {
									return Object.keys(o)
								}
							}, {
								"./decrypter": 25,
								"./encrypter": 26,
								"./modes/list.json": 36
							}],
							25: [function(e, t, r) {
								var n = e("./authCipher"),
									i = e("safe-buffer").Buffer,
									o = e("./modes"),
									s = e("./streamCipher"),
									a = e("cipher-base"),
									c = e("./aes"),
									l = e("evp_bytestokey");

								function u(e, t, r) {
									a.call(this), this._cache = new d, this._last = void 0, this._cipher = new c.AES(t), this._prev = i.from(r), this._mode = e, this._autopadding = !0
								}

								function d() {
									this.cache = i.allocUnsafe(0)
								}

								function h(e, t, r) {
									var a = o[e.toLowerCase()];
									if (!a) throw new TypeError("invalid suite type");
									if ("string" == typeof r && (r = i.from(r)), "GCM" !== a.mode && r.length !== a.iv) throw new TypeError("invalid iv length " + r.length);
									if ("string" == typeof t && (t = i.from(t)), t.length !== a.key / 8) throw new TypeError("invalid key length " + t.length);
									return "stream" === a.type ? new s(a.module, t, r, !0) : "auth" === a.type ? new n(a.module, t, r, !0) : new u(a.module, t, r)
								}
								e("inherits")(u, a), u.prototype._update = function(e) {
									var t, r;
									this._cache.add(e);
									for (var n = []; t = this._cache.get(this._autopadding);) r = this._mode.decrypt(this, t), n.push(r);
									return i.concat(n)
								}, u.prototype._final = function() {
									var e = this._cache.flush();
									if (this._autopadding) return function(e) {
										var t = e[15];
										if (t < 1 || t > 16) throw new Error("unable to decrypt data");
										var r = -1;
										for (; ++r < t;)
											if (e[r + (16 - t)] !== t) throw new Error("unable to decrypt data");
										if (16 === t) return;
										return e.slice(0, 16 - t)
									}(this._mode.decrypt(this, e));
									if (e) throw new Error("data not multiple of block length")
								}, u.prototype.setAutoPadding = function(e) {
									return this._autopadding = !!e, this
								}, d.prototype.add = function(e) {
									this.cache = i.concat([this.cache, e])
								}, d.prototype.get = function(e) {
									var t;
									if (e) {
										if (this.cache.length > 16) return t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t
									} else if (this.cache.length >= 16) return t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t;
									return null
								}, d.prototype.flush = function() {
									if (this.cache.length) return this.cache
								}, r.createDecipher = function(e, t) {
									var r = o[e.toLowerCase()];
									if (!r) throw new TypeError("invalid suite type");
									var n = l(t, !1, r.key, r.iv);
									return h(e, n.key, n.iv)
								}, r.createDecipheriv = h
							}, {
								"./aes": 22,
								"./authCipher": 23,
								"./modes": 35,
								"./streamCipher": 38,
								"cipher-base": 72,
								evp_bytestokey: 107,
								inherits: 147,
								"safe-buffer": 251
							}],
							26: [function(e, t, r) {
								var n = e("./modes"),
									i = e("./authCipher"),
									o = e("safe-buffer").Buffer,
									s = e("./streamCipher"),
									a = e("cipher-base"),
									c = e("./aes"),
									l = e("evp_bytestokey");

								function u(e, t, r) {
									a.call(this), this._cache = new h, this._cipher = new c.AES(t), this._prev = o.from(r), this._mode = e, this._autopadding = !0
								}
								e("inherits")(u, a), u.prototype._update = function(e) {
									var t, r;
									this._cache.add(e);
									for (var n = []; t = this._cache.get();) r = this._mode.encrypt(this, t), n.push(r);
									return o.concat(n)
								};
								var d = o.alloc(16, 16);

								function h() {
									this.cache = o.allocUnsafe(0)
								}

								function f(e, t, r) {
									var a = n[e.toLowerCase()];
									if (!a) throw new TypeError("invalid suite type");
									if ("string" == typeof t && (t = o.from(t)), t.length !== a.key / 8) throw new TypeError("invalid key length " + t.length);
									if ("string" == typeof r && (r = o.from(r)), "GCM" !== a.mode && r.length !== a.iv) throw new TypeError("invalid iv length " + r.length);
									return "stream" === a.type ? new s(a.module, t, r) : "auth" === a.type ? new i(a.module, t, r) : new u(a.module, t, r)
								}
								u.prototype._final = function() {
									var e = this._cache.flush();
									if (this._autopadding) return e = this._mode.encrypt(this, e), this._cipher.scrub(), e;
									if (!e.equals(d)) throw this._cipher.scrub(), new Error("data not multiple of block length")
								}, u.prototype.setAutoPadding = function(e) {
									return this._autopadding = !!e, this
								}, h.prototype.add = function(e) {
									this.cache = o.concat([this.cache, e])
								}, h.prototype.get = function() {
									if (this.cache.length > 15) {
										var e = this.cache.slice(0, 16);
										return this.cache = this.cache.slice(16), e
									}
									return null
								}, h.prototype.flush = function() {
									for (var e = 16 - this.cache.length, t = o.allocUnsafe(e), r = -1; ++r < e;) t.writeUInt8(e, r);
									return o.concat([this.cache, t])
								}, r.createCipheriv = f, r.createCipher = function(e, t) {
									var r = n[e.toLowerCase()];
									if (!r) throw new TypeError("invalid suite type");
									var i = l(t, !1, r.key, r.iv);
									return f(e, i.key, i.iv)
								}
							}, {
								"./aes": 22,
								"./authCipher": 23,
								"./modes": 35,
								"./streamCipher": 38,
								"cipher-base": 72,
								evp_bytestokey: 107,
								inherits: 147,
								"safe-buffer": 251
							}],
							27: [function(e, t, r) {
								var n = e("safe-buffer").Buffer,
									i = n.alloc(16, 0);

								function o(e) {
									var t = n.allocUnsafe(16);
									return t.writeUInt32BE(e[0] >>> 0, 0), t.writeUInt32BE(e[1] >>> 0, 4), t.writeUInt32BE(e[2] >>> 0, 8), t.writeUInt32BE(e[3] >>> 0, 12), t
								}

								function s(e) {
									this.h = e, this.state = n.alloc(16, 0), this.cache = n.allocUnsafe(0)
								}
								s.prototype.ghash = function(e) {
									for (var t = -1; ++t < e.length;) this.state[t] ^= e[t];
									this._multiply()
								}, s.prototype._multiply = function() {
									for (var e, t, r, n = [(e = this.h).readUInt32BE(0), e.readUInt32BE(4), e.readUInt32BE(8), e.readUInt32BE(12)], i = [0, 0, 0, 0], s = -1; ++s < 128;) {
										for (0 != (this.state[~~(s / 8)] & 1 << 7 - s % 8) && (i[0] ^= n[0], i[1] ^= n[1], i[2] ^= n[2], i[3] ^= n[3]), r = 0 != (1 & n[3]), t = 3; t > 0; t--) n[t] = n[t] >>> 1 | (1 & n[t - 1]) << 31;
										n[0] = n[0] >>> 1, r && (n[0] = n[0] ^ 225 << 24)
									}
									this.state = o(i)
								}, s.prototype.update = function(e) {
									var t;
									for (this.cache = n.concat([this.cache, e]); this.cache.length >= 16;) t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(t)
								}, s.prototype.final = function(e, t) {
									return this.cache.length && this.ghash(n.concat([this.cache, i], 16)), this.ghash(o([0, e, 0, t])), this.state
								}, t.exports = s
							}, {
								"safe-buffer": 251
							}],
							28: [function(e, t, r) {
								t.exports = function(e) {
									for (var t, r = e.length; r--;) {
										if (255 !== (t = e.readUInt8(r))) {
											t++, e.writeUInt8(t, r);
											break
										}
										e.writeUInt8(0, r)
									}
								}
							}, {}],
							29: [function(e, t, r) {
								var n = e("buffer-xor");
								r.encrypt = function(e, t) {
									var r = n(t, e._prev);
									return e._prev = e._cipher.encryptBlock(r), e._prev
								}, r.decrypt = function(e, t) {
									var r = e._prev;
									e._prev = t;
									var i = e._cipher.decryptBlock(t);
									return n(i, r)
								}
							}, {
								"buffer-xor": 68
							}],
							30: [function(e, t, r) {
								var n = e("safe-buffer").Buffer,
									i = e("buffer-xor");

								function o(e, t, r) {
									var o = t.length,
										s = i(t, e._cache);
									return e._cache = e._cache.slice(o), e._prev = n.concat([e._prev, r ? t : s]), s
								}
								r.encrypt = function(e, t, r) {
									for (var i, s = n.allocUnsafe(0); t.length;) {
										if (0 === e._cache.length && (e._cache = e._cipher.encryptBlock(e._prev), e._prev = n.allocUnsafe(0)), !(e._cache.length <= t.length)) {
											s = n.concat([s, o(e, t, r)]);
											break
										}
										i = e._cache.length, s = n.concat([s, o(e, t.slice(0, i), r)]), t = t.slice(i)
									}
									return s
								}
							}, {
								"buffer-xor": 68,
								"safe-buffer": 251
							}],
							31: [function(e, t, r) {
								var n = e("safe-buffer").Buffer;

								function i(e, t, r) {
									for (var n, i, s = -1, a = 0; ++s < 8;) n = t & 1 << 7 - s ? 128 : 0, a += (128 & (i = e._cipher.encryptBlock(e._prev)[0] ^ n)) >> s % 8, e._prev = o(e._prev, r ? n : i);
									return a
								}

								function o(e, t) {
									var r = e.length,
										i = -1,
										o = n.allocUnsafe(e.length);
									for (e = n.concat([e, n.from([t])]); ++i < r;) o[i] = e[i] << 1 | e[i + 1] >> 7;
									return o
								}
								r.encrypt = function(e, t, r) {
									for (var o = t.length, s = n.allocUnsafe(o), a = -1; ++a < o;) s[a] = i(e, t[a], r);
									return s
								}
							}, {
								"safe-buffer": 251
							}],
							32: [function(e, t, r) {
								var n = e("safe-buffer").Buffer;

								function i(e, t, r) {
									var i = e._cipher.encryptBlock(e._prev)[0] ^ t;
									return e._prev = n.concat([e._prev.slice(1), n.from([r ? t : i])]), i
								}
								r.encrypt = function(e, t, r) {
									for (var o = t.length, s = n.allocUnsafe(o), a = -1; ++a < o;) s[a] = i(e, t[a], r);
									return s
								}
							}, {
								"safe-buffer": 251
							}],
							33: [function(e, t, r) {
								var n = e("buffer-xor"),
									i = e("safe-buffer").Buffer,
									o = e("../incr32");

								function s(e) {
									var t = e._cipher.encryptBlockRaw(e._prev);
									return o(e._prev), t
								}
								r.encrypt = function(e, t) {
									var r = Math.ceil(t.length / 16),
										o = e._cache.length;
									e._cache = i.concat([e._cache, i.allocUnsafe(16 * r)]);
									for (var a = 0; a < r; a++) {
										var c = s(e),
											l = o + 16 * a;
										e._cache.writeUInt32BE(c[0], l + 0), e._cache.writeUInt32BE(c[1], l + 4), e._cache.writeUInt32BE(c[2], l + 8), e._cache.writeUInt32BE(c[3], l + 12)
									}
									var u = e._cache.slice(0, t.length);
									return e._cache = e._cache.slice(t.length), n(t, u)
								}
							}, {
								"../incr32": 28,
								"buffer-xor": 68,
								"safe-buffer": 251
							}],
							34: [function(e, t, r) {
								r.encrypt = function(e, t) {
									return e._cipher.encryptBlock(t)
								}, r.decrypt = function(e, t) {
									return e._cipher.decryptBlock(t)
								}
							}, {}],
							35: [function(e, t, r) {
								var n = {
										ECB: e("./ecb"),
										CBC: e("./cbc"),
										CFB: e("./cfb"),
										CFB8: e("./cfb8"),
										CFB1: e("./cfb1"),
										OFB: e("./ofb"),
										CTR: e("./ctr"),
										GCM: e("./ctr")
									},
									i = e("./list.json");
								for (var o in i) i[o].module = n[i[o].mode];
								t.exports = i
							}, {
								"./cbc": 29,
								"./cfb": 30,
								"./cfb1": 31,
								"./cfb8": 32,
								"./ctr": 33,
								"./ecb": 34,
								"./list.json": 36,
								"./ofb": 37
							}],
							36: [function(e, t, r) {
								t.exports = {
									"aes-128-ecb": {
										cipher: "AES",
										key: 128,
										iv: 0,
										mode: "ECB",
										type: "block"
									},
									"aes-192-ecb": {
										cipher: "AES",
										key: 192,
										iv: 0,
										mode: "ECB",
										type: "block"
									},
									"aes-256-ecb": {
										cipher: "AES",
										key: 256,
										iv: 0,
										mode: "ECB",
										type: "block"
									},
									"aes-128-cbc": {
										cipher: "AES",
										key: 128,
										iv: 16,
										mode: "CBC",
										type: "block"
									},
									"aes-192-cbc": {
										cipher: "AES",
										key: 192,
										iv: 16,
										mode: "CBC",
										type: "block"
									},
									"aes-256-cbc": {
										cipher: "AES",
										key: 256,
										iv: 16,
										mode: "CBC",
										type: "block"
									},
									aes128: {
										cipher: "AES",
										key: 128,
										iv: 16,
										mode: "CBC",
										type: "block"
									},
									aes192: {
										cipher: "AES",
										key: 192,
										iv: 16,
										mode: "CBC",
										type: "block"
									},
									aes256: {
										cipher: "AES",
										key: 256,
										iv: 16,
										mode: "CBC",
										type: "block"
									},
									"aes-128-cfb": {
										cipher: "AES",
										key: 128,
										iv: 16,
										mode: "CFB",
										type: "stream"
									},
									"aes-192-cfb": {
										cipher: "AES",
										key: 192,
										iv: 16,
										mode: "CFB",
										type: "stream"
									},
									"aes-256-cfb": {
										cipher: "AES",
										key: 256,
										iv: 16,
										mode: "CFB",
										type: "stream"
									},
									"aes-128-cfb8": {
										cipher: "AES",
										key: 128,
										iv: 16,
										mode: "CFB8",
										type: "stream"
									},
									"aes-192-cfb8": {
										cipher: "AES",
										key: 192,
										iv: 16,
										mode: "CFB8",
										type: "stream"
									},
									"aes-256-cfb8": {
										cipher: "AES",
										key: 256,
										iv: 16,
										mode: "CFB8",
										type: "stream"
									},
									"aes-128-cfb1": {
										cipher: "AES",
										key: 128,
										iv: 16,
										mode: "CFB1",
										type: "stream"
									},
									"aes-192-cfb1": {
										cipher: "AES",
										key: 192,
										iv: 16,
										mode: "CFB1",
										type: "stream"
									},
									"aes-256-cfb1": {
										cipher: "AES",
										key: 256,
										iv: 16,
										mode: "CFB1",
										type: "stream"
									},
									"aes-128-ofb": {
										cipher: "AES",
										key: 128,
										iv: 16,
										mode: "OFB",
										type: "stream"
									},
									"aes-192-ofb": {
										cipher: "AES",
										key: 192,
										iv: 16,
										mode: "OFB",
										type: "stream"
									},
									"aes-256-ofb": {
										cipher: "AES",
										key: 256,
										iv: 16,
										mode: "OFB",
										type: "stream"
									},
									"aes-128-ctr": {
										cipher: "AES",
										key: 128,
										iv: 16,
										mode: "CTR",
										type: "stream"
									},
									"aes-192-ctr": {
										cipher: "AES",
										key: 192,
										iv: 16,
										mode: "CTR",
										type: "stream"
									},
									"aes-256-ctr": {
										cipher: "AES",
										key: 256,
										iv: 16,
										mode: "CTR",
										type: "stream"
									},
									"aes-128-gcm": {
										cipher: "AES",
										key: 128,
										iv: 12,
										mode: "GCM",
										type: "auth"
									},
									"aes-192-gcm": {
										cipher: "AES",
										key: 192,
										iv: 12,
										mode: "GCM",
										type: "auth"
									},
									"aes-256-gcm": {
										cipher: "AES",
										key: 256,
										iv: 12,
										mode: "GCM",
										type: "auth"
									}
								}
							}, {}],
							37: [function(e, t, r) {
								(function(t) {
									(function() {
										var n = e("buffer-xor");

										function i(e) {
											return e._prev = e._cipher.encryptBlock(e._prev), e._prev
										}
										r.encrypt = function(e, r) {
											for (; e._cache.length < r.length;) e._cache = t.concat([e._cache, i(e)]);
											var o = e._cache.slice(0, r.length);
											return e._cache = e._cache.slice(r.length), n(r, o)
										}
									}).call(this)
								}).call(this, e("buffer").Buffer)
							}, {
								buffer: 69,
								"buffer-xor": 68
							}],
							38: [function(e, t, r) {
								var n = e("./aes"),
									i = e("safe-buffer").Buffer,
									o = e("cipher-base");

								function s(e, t, r, s) {
									o.call(this), this._cipher = new n.AES(t), this._prev = i.from(r), this._cache = i.allocUnsafe(0), this._secCache = i.allocUnsafe(0), this._decrypt = s, this._mode = e
								}
								e("inherits")(s, o), s.prototype._update = function(e) {
									return this._mode.encrypt(this, e, this._decrypt)
								}, s.prototype._final = function() {
									this._cipher.scrub()
								}, t.exports = s
							}, {
								"./aes": 22,
								"cipher-base": 72,
								inherits: 147,
								"safe-buffer": 251
							}],
							39: [function(e, t, r) {
								var n = e("browserify-des"),
									i = e("browserify-aes/browser"),
									o = e("browserify-aes/modes"),
									s = e("browserify-des/modes"),
									a = e("evp_bytestokey");

								function c(e, t, r) {
									if (e = e.toLowerCase(), o[e]) return i.createCipheriv(e, t, r);
									if (s[e]) return new n({
										key: t,
										iv: r,
										mode: e
									});
									throw new TypeError("invalid suite type")
								}

								function l(e, t, r) {
									if (e = e.toLowerCase(), o[e]) return i.createDecipheriv(e, t, r);
									if (s[e]) return new n({
										key: t,
										iv: r,
										mode: e,
										decrypt: !0
									});
									throw new TypeError("invalid suite type")
								}
								r.createCipher = r.Cipher = function(e, t) {
									var r, n;
									if (e = e.toLowerCase(), o[e]) r = o[e].key, n = o[e].iv;
									else {
										if (!s[e]) throw new TypeError("invalid suite type");
										r = 8 * s[e].key, n = s[e].iv
									}
									var i = a(t, !1, r, n);
									return c(e, i.key, i.iv)
								}, r.createCipheriv = r.Cipheriv = c, r.createDecipher = r.Decipher = function(e, t) {
									var r, n;
									if (e = e.toLowerCase(), o[e]) r = o[e].key, n = o[e].iv;
									else {
										if (!s[e]) throw new TypeError("invalid suite type");
										r = 8 * s[e].key, n = s[e].iv
									}
									var i = a(t, !1, r, n);
									return l(e, i.key, i.iv)
								}, r.createDecipheriv = r.Decipheriv = l, r.listCiphers = r.getCiphers = function() {
									return Object.keys(s).concat(i.getCiphers())
								}
							}, {
								"browserify-aes/browser": 24,
								"browserify-aes/modes": 35,
								"browserify-des": 40,
								"browserify-des/modes": 41,
								evp_bytestokey: 107
							}],
							40: [function(e, t, r) {
								var n = e("cipher-base"),
									i = e("des.js"),
									o = e("inherits"),
									s = e("safe-buffer").Buffer,
									a = {
										"des-ede3-cbc": i.CBC.instantiate(i.EDE),
										"des-ede3": i.EDE,
										"des-ede-cbc": i.CBC.instantiate(i.EDE),
										"des-ede": i.EDE,
										"des-cbc": i.CBC.instantiate(i.DES),
										"des-ecb": i.DES
									};

								function c(e) {
									n.call(this);
									var t, r = e.mode.toLowerCase(),
										i = a[r];
									t = e.decrypt ? "decrypt" : "encrypt";
									var o = e.key;
									s.isBuffer(o) || (o = s.from(o)), "des-ede" !== r && "des-ede-cbc" !== r || (o = s.concat([o, o.slice(0, 8)]));
									var c = e.iv;
									s.isBuffer(c) || (c = s.from(c)), this._des = i.create({
										key: o,
										iv: c,
										type: t
									})
								}
								a.des = a["des-cbc"], a.des3 = a["des-ede3-cbc"], t.exports = c, o(c, n), c.prototype._update = function(e) {
									return s.from(this._des.update(e))
								}, c.prototype._final = function() {
									return s.from(this._des.final())
								}
							}, {
								"cipher-base": 72,
								"des.js": 80,
								inherits: 147,
								"safe-buffer": 251
							}],
							41: [function(e, t, r) {
								r["des-ecb"] = {
									key: 8,
									iv: 0
								}, r["des-cbc"] = r.des = {
									key: 8,
									iv: 8
								}, r["des-ede3-cbc"] = r.des3 = {
									key: 24,
									iv: 8
								}, r["des-ede3"] = {
									key: 24,
									iv: 0
								}, r["des-ede-cbc"] = {
									key: 16,
									iv: 8
								}, r["des-ede"] = {
									key: 16,
									iv: 0
								}
							}, {}],
							42: [function(e, t, r) {
								(function(r) {
									(function() {
										var n = e("bn.js"),
											i = e("randombytes");

										function o(e) {
											var t, r = e.modulus.byteLength();
											do {
												t = new n(i(r))
											} while (t.cmp(e.modulus) >= 0 || !t.umod(e.prime1) || !t.umod(e.prime2));
											return t
										}

										function s(e, t) {
											var i = function(e) {
													var t = o(e);
													return {
														blinder: t.toRed(n.mont(e.modulus)).redPow(new n(e.publicExponent)).fromRed(),
														unblinder: t.invm(e.modulus)
													}
												}(t),
												s = t.modulus.byteLength(),
												a = new n(e).mul(i.blinder).umod(t.modulus),
												c = a.toRed(n.mont(t.prime1)),
												l = a.toRed(n.mont(t.prime2)),
												u = t.coefficient,
												d = t.prime1,
												h = t.prime2,
												f = c.redPow(t.exponent1).fromRed(),
												p = l.redPow(t.exponent2).fromRed(),
												v = f.isub(p).imul(u).umod(d).imul(h);
											return p.iadd(v).imul(i.unblinder).umod(t.modulus).toArrayLike(r, "be", s)
										}
										s.getr = o, t.exports = s
									}).call(this)
								}).call(this, e("buffer").Buffer)
							}, {
								"bn.js": 43,
								buffer: 69,
								randombytes: 245
							}],
							43: [function(e, t, r) {
								! function(t, r) {
									"use strict";

									function n(e, t) {
										if (!e) throw new Error(t || "Assertion failed")
									}

									function i(e, t) {
										e.super_ = t;
										var r = function() {};
										r.prototype = t.prototype, e.prototype = new r, e.prototype.constructor = e
									}

									function o(e, t, r) {
										if (o.isBN(e)) return e;
										this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== e && ("le" !== t && "be" !== t || (r = t, t = 10), this._init(e || 0, t || 10, r || "be"))
									}
									var s;
									"object" == typeof t ? t.exports = o : r.BN = o, o.BN = o, o.wordSize = 26;
									try {
										s = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : e("buffer").Buffer
									} catch (C) {}

									function a(e, t) {
										var r = e.charCodeAt(t);
										return r >= 48 && r <= 57 ? r - 48 : r >= 65 && r <= 70 ? r - 55 : r >= 97 && r <= 102 ? r - 87 : void n(!1, "Invalid character in " + e)
									}

									function c(e, t, r) {
										var n = a(e, r);
										return r - 1 >= t && (n |= a(e, r - 1) << 4), n
									}

									function l(e, t, r, i) {
										for (var o = 0, s = 0, a = Math.min(e.length, r), c = t; c < a; c++) {
											var l = e.charCodeAt(c) - 48;
											o *= i, s = l >= 49 ? l - 49 + 10 : l >= 17 ? l - 17 + 10 : l, n(l >= 0 && s < i, "Invalid character"), o += s
										}
										return o
									}

									function u(e, t) {
										e.words = t.words, e.length = t.length, e.negative = t.negative, e.red = t.red
									}
									if (o.isBN = function(e) {
											return e instanceof o || null !== e && "object" == typeof e && e.constructor.wordSize === o.wordSize && Array.isArray(e.words)
										}, o.max = function(e, t) {
											return e.cmp(t) > 0 ? e : t
										}, o.min = function(e, t) {
											return e.cmp(t) < 0 ? e : t
										}, o.prototype._init = function(e, t, r) {
											if ("number" == typeof e) return this._initNumber(e, t, r);
											if ("object" == typeof e) return this._initArray(e, t, r);
											"hex" === t && (t = 16), n(t === (0 | t) && t >= 2 && t <= 36);
											var i = 0;
											"-" === (e = e.toString().replace(/\s+/g, ""))[0] && (i++, this.negative = 1), i < e.length && (16 === t ? this._parseHex(e, i, r) : (this._parseBase(e, t, i), "le" === r && this._initArray(this.toArray(), t, r)))
										}, o.prototype._initNumber = function(e, t, r) {
											e < 0 && (this.negative = 1, e = -e), e < 67108864 ? (this.words = [67108863 & e], this.length = 1) : e < 4503599627370496 ? (this.words = [67108863 & e, e / 67108864 & 67108863], this.length = 2) : (n(e < 9007199254740992), this.words = [67108863 & e, e / 67108864 & 67108863, 1], this.length = 3), "le" === r && this._initArray(this.toArray(), t, r)
										}, o.prototype._initArray = function(e, t, r) {
											if (n("number" == typeof e.length), e.length <= 0) return this.words = [0], this.length = 1, this;
											this.length = Math.ceil(e.length / 3), this.words = new Array(this.length);
											for (var i = 0; i < this.length; i++) this.words[i] = 0;
											var o, s, a = 0;
											if ("be" === r)
												for (i = e.length - 1, o = 0; i >= 0; i -= 3) s = e[i] | e[i - 1] << 8 | e[i - 2] << 16, this.words[o] |= s << a & 67108863, this.words[o + 1] = s >>> 26 - a & 67108863, (a += 24) >= 26 && (a -= 26, o++);
											else if ("le" === r)
												for (i = 0, o = 0; i < e.length; i += 3) s = e[i] | e[i + 1] << 8 | e[i + 2] << 16, this.words[o] |= s << a & 67108863, this.words[o + 1] = s >>> 26 - a & 67108863, (a += 24) >= 26 && (a -= 26, o++);
											return this._strip()
										}, o.prototype._parseHex = function(e, t, r) {
											this.length = Math.ceil((e.length - t) / 6), this.words = new Array(this.length);
											for (var n = 0; n < this.length; n++) this.words[n] = 0;
											var i, o = 0,
												s = 0;
											if ("be" === r)
												for (n = e.length - 1; n >= t; n -= 2) i = c(e, t, n) << o, this.words[s] |= 67108863 & i, o >= 18 ? (o -= 18, s += 1, this.words[s] |= i >>> 26) : o += 8;
											else
												for (n = (e.length - t) % 2 == 0 ? t + 1 : t; n < e.length; n += 2) i = c(e, t, n) << o, this.words[s] |= 67108863 & i, o >= 18 ? (o -= 18, s += 1, this.words[s] |= i >>> 26) : o += 8;
											this._strip()
										}, o.prototype._parseBase = function(e, t, r) {
											this.words = [0], this.length = 1;
											for (var n = 0, i = 1; i <= 67108863; i *= t) n++;
											n--, i = i / t | 0;
											for (var o = e.length - r, s = o % n, a = Math.min(o, o - s) + r, c = 0, u = r; u < a; u += n) c = l(e, u, u + n, t), this.imuln(i), this.words[0] + c < 67108864 ? this.words[0] += c : this._iaddn(c);
											if (0 !== s) {
												var d = 1;
												for (c = l(e, u, e.length, t), u = 0; u < s; u++) d *= t;
												this.imuln(d), this.words[0] + c < 67108864 ? this.words[0] += c : this._iaddn(c)
											}
											this._strip()
										}, o.prototype.copy = function(e) {
											e.words = new Array(this.length);
											for (var t = 0; t < this.length; t++) e.words[t] = this.words[t];
											e.length = this.length, e.negative = this.negative, e.red = this.red
										}, o.prototype._move = function(e) {
											u(e, this)
										}, o.prototype.clone = function() {
											var e = new o(null);
											return this.copy(e), e
										}, o.prototype._expand = function(e) {
											for (; this.length < e;) this.words[this.length++] = 0;
											return this
										}, o.prototype._strip = function() {
											for (; this.length > 1 && 0 === this.words[this.length - 1];) this.length--;
											return this._normSign()
										}, o.prototype._normSign = function() {
											return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
										}, "undefined" != typeof Symbol && "function" == typeof Symbol.for) try {
										o.prototype[Symbol.for("nodejs.util.inspect.custom")] = d
									} catch (C) {
										o.prototype.inspect = d
									} else o.prototype.inspect = d;

									function d() {
										return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
									}
									var h = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
										f = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
										p = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
									o.prototype.toString = function(e, t) {
										var r;
										if (t = 0 | t || 1, 16 === (e = e || 10) || "hex" === e) {
											r = "";
											for (var i = 0, o = 0, s = 0; s < this.length; s++) {
												var a = this.words[s],
													c = (16777215 & (a << i | o)).toString(16);
												o = a >>> 24 - i & 16777215, (i += 2) >= 26 && (i -= 26, s--), r = 0 !== o || s !== this.length - 1 ? h[6 - c.length] + c + r : c + r
											}
											for (0 !== o && (r = o.toString(16) + r); r.length % t != 0;) r = "0" + r;
											return 0 !== this.negative && (r = "-" + r), r
										}
										if (e === (0 | e) && e >= 2 && e <= 36) {
											var l = f[e],
												u = p[e];
											r = "";
											var d = this.clone();
											for (d.negative = 0; !d.isZero();) {
												var v = d.modrn(u).toString(e);
												r = (d = d.idivn(u)).isZero() ? v + r : h[l - v.length] + v + r
											}
											for (this.isZero() && (r = "0" + r); r.length % t != 0;) r = "0" + r;
											return 0 !== this.negative && (r = "-" + r), r
										}
										n(!1, "Base should be between 2 and 36")
									}, o.prototype.toNumber = function() {
										var e = this.words[0];
										return 2 === this.length ? e += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? e += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -e : e
									}, o.prototype.toJSON = function() {
										return this.toString(16, 2)
									}, s && (o.prototype.toBuffer = function(e, t) {
										return this.toArrayLike(s, e, t)
									}), o.prototype.toArray = function(e, t) {
										return this.toArrayLike(Array, e, t)
									};

									function v(e, t, r) {
										r.negative = t.negative ^ e.negative;
										var n = e.length + t.length | 0;
										r.length = n, n = n - 1 | 0;
										var i = 0 | e.words[0],
											o = 0 | t.words[0],
											s = i * o,
											a = 67108863 & s,
											c = s / 67108864 | 0;
										r.words[0] = a;
										for (var l = 1; l < n; l++) {
											for (var u = c >>> 26, d = 67108863 & c, h = Math.min(l, t.length - 1), f = Math.max(0, l - e.length + 1); f <= h; f++) {
												var p = l - f | 0;
												u += (s = (i = 0 | e.words[p]) * (o = 0 | t.words[f]) + d) / 67108864 | 0, d = 67108863 & s
											}
											r.words[l] = 0 | d, c = 0 | u
										}
										return 0 !== c ? r.words[l] = 0 | c : r.length--, r._strip()
									}
									o.prototype.toArrayLike = function(e, t, r) {
										this._strip();
										var i = this.byteLength(),
											o = r || Math.max(1, i);
										n(i <= o, "byte array longer than desired length"), n(o > 0, "Requested array length <= 0");
										var s = function(e, t) {
											return e.allocUnsafe ? e.allocUnsafe(t) : new e(t)
										}(e, o);
										return this["_toArrayLike" + ("le" === t ? "LE" : "BE")](s, i), s
									}, o.prototype._toArrayLikeLE = function(e, t) {
										for (var r = 0, n = 0, i = 0, o = 0; i < this.length; i++) {
											var s = this.words[i] << o | n;
											e[r++] = 255 & s, r < e.length && (e[r++] = s >> 8 & 255), r < e.length && (e[r++] = s >> 16 & 255), 6 === o ? (r < e.length && (e[r++] = s >> 24 & 255), n = 0, o = 0) : (n = s >>> 24, o += 2)
										}
										if (r < e.length)
											for (e[r++] = n; r < e.length;) e[r++] = 0
									}, o.prototype._toArrayLikeBE = function(e, t) {
										for (var r = e.length - 1, n = 0, i = 0, o = 0; i < this.length; i++) {
											var s = this.words[i] << o | n;
											e[r--] = 255 & s, r >= 0 && (e[r--] = s >> 8 & 255), r >= 0 && (e[r--] = s >> 16 & 255), 6 === o ? (r >= 0 && (e[r--] = s >> 24 & 255), n = 0, o = 0) : (n = s >>> 24, o += 2)
										}
										if (r >= 0)
											for (e[r--] = n; r >= 0;) e[r--] = 0
									}, Math.clz32 ? o.prototype._countBits = function(e) {
										return 32 - Math.clz32(e)
									} : o.prototype._countBits = function(e) {
										var t = e,
											r = 0;
										return t >= 4096 && (r += 13, t >>>= 13), t >= 64 && (r += 7, t >>>= 7), t >= 8 && (r += 4, t >>>= 4), t >= 2 && (r += 2, t >>>= 2), r + t
									}, o.prototype._zeroBits = function(e) {
										if (0 === e) return 26;
										var t = e,
											r = 0;
										return 0 == (8191 & t) && (r += 13, t >>>= 13), 0 == (127 & t) && (r += 7, t >>>= 7), 0 == (15 & t) && (r += 4, t >>>= 4), 0 == (3 & t) && (r += 2, t >>>= 2), 0 == (1 & t) && r++, r
									}, o.prototype.bitLength = function() {
										var e = this.words[this.length - 1],
											t = this._countBits(e);
										return 26 * (this.length - 1) + t
									}, o.prototype.zeroBits = function() {
										if (this.isZero()) return 0;
										for (var e = 0, t = 0; t < this.length; t++) {
											var r = this._zeroBits(this.words[t]);
											if (e += r, 26 !== r) break
										}
										return e
									}, o.prototype.byteLength = function() {
										return Math.ceil(this.bitLength() / 8)
									}, o.prototype.toTwos = function(e) {
										return 0 !== this.negative ? this.abs().inotn(e).iaddn(1) : this.clone()
									}, o.prototype.fromTwos = function(e) {
										return this.testn(e - 1) ? this.notn(e).iaddn(1).ineg() : this.clone()
									}, o.prototype.isNeg = function() {
										return 0 !== this.negative
									}, o.prototype.neg = function() {
										return this.clone().ineg()
									}, o.prototype.ineg = function() {
										return this.isZero() || (this.negative ^= 1), this
									}, o.prototype.iuor = function(e) {
										for (; this.length < e.length;) this.words[this.length++] = 0;
										for (var t = 0; t < e.length; t++) this.words[t] = this.words[t] | e.words[t];
										return this._strip()
									}, o.prototype.ior = function(e) {
										return n(0 == (this.negative | e.negative)), this.iuor(e)
									}, o.prototype.or = function(e) {
										return this.length > e.length ? this.clone().ior(e) : e.clone().ior(this)
									}, o.prototype.uor = function(e) {
										return this.length > e.length ? this.clone().iuor(e) : e.clone().iuor(this)
									}, o.prototype.iuand = function(e) {
										var t;
										t = this.length > e.length ? e : this;
										for (var r = 0; r < t.length; r++) this.words[r] = this.words[r] & e.words[r];
										return this.length = t.length, this._strip()
									}, o.prototype.iand = function(e) {
										return n(0 == (this.negative | e.negative)), this.iuand(e)
									}, o.prototype.and = function(e) {
										return this.length > e.length ? this.clone().iand(e) : e.clone().iand(this)
									}, o.prototype.uand = function(e) {
										return this.length > e.length ? this.clone().iuand(e) : e.clone().iuand(this)
									}, o.prototype.iuxor = function(e) {
										var t, r;
										this.length > e.length ? (t = this, r = e) : (t = e, r = this);
										for (var n = 0; n < r.length; n++) this.words[n] = t.words[n] ^ r.words[n];
										if (this !== t)
											for (; n < t.length; n++) this.words[n] = t.words[n];
										return this.length = t.length, this._strip()
									}, o.prototype.ixor = function(e) {
										return n(0 == (this.negative | e.negative)), this.iuxor(e)
									}, o.prototype.xor = function(e) {
										return this.length > e.length ? this.clone().ixor(e) : e.clone().ixor(this)
									}, o.prototype.uxor = function(e) {
										return this.length > e.length ? this.clone().iuxor(e) : e.clone().iuxor(this)
									}, o.prototype.inotn = function(e) {
										n("number" == typeof e && e >= 0);
										var t = 0 | Math.ceil(e / 26),
											r = e % 26;
										this._expand(t), r > 0 && t--;
										for (var i = 0; i < t; i++) this.words[i] = 67108863 & ~this.words[i];
										return r > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - r), this._strip()
									}, o.prototype.notn = function(e) {
										return this.clone().inotn(e)
									}, o.prototype.setn = function(e, t) {
										n("number" == typeof e && e >= 0);
										var r = e / 26 | 0,
											i = e % 26;
										return this._expand(r + 1), this.words[r] = t ? this.words[r] | 1 << i : this.words[r] & ~(1 << i), this._strip()
									}, o.prototype.iadd = function(e) {
										var t, r, n;
										if (0 !== this.negative && 0 === e.negative) return this.negative = 0, t = this.isub(e), this.negative ^= 1, this._normSign();
										if (0 === this.negative && 0 !== e.negative) return e.negative = 0, t = this.isub(e), e.negative = 1, t._normSign();
										this.length > e.length ? (r = this, n = e) : (r = e, n = this);
										for (var i = 0, o = 0; o < n.length; o++) t = (0 | r.words[o]) + (0 | n.words[o]) + i, this.words[o] = 67108863 & t, i = t >>> 26;
										for (; 0 !== i && o < r.length; o++) t = (0 | r.words[o]) + i, this.words[o] = 67108863 & t, i = t >>> 26;
										if (this.length = r.length, 0 !== i) this.words[this.length] = i, this.length++;
										else if (r !== this)
											for (; o < r.length; o++) this.words[o] = r.words[o];
										return this
									}, o.prototype.add = function(e) {
										var t;
										return 0 !== e.negative && 0 === this.negative ? (e.negative = 0, t = this.sub(e), e.negative ^= 1, t) : 0 === e.negative && 0 !== this.negative ? (this.negative = 0, t = e.sub(this), this.negative = 1, t) : this.length > e.length ? this.clone().iadd(e) : e.clone().iadd(this)
									}, o.prototype.isub = function(e) {
										if (0 !== e.negative) {
											e.negative = 0;
											var t = this.iadd(e);
											return e.negative = 1, t._normSign()
										}
										if (0 !== this.negative) return this.negative = 0, this.iadd(e), this.negative = 1, this._normSign();
										var r, n, i = this.cmp(e);
										if (0 === i) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
										i > 0 ? (r = this, n = e) : (r = e, n = this);
										for (var o = 0, s = 0; s < n.length; s++) o = (t = (0 | r.words[s]) - (0 | n.words[s]) + o) >> 26, this.words[s] = 67108863 & t;
										for (; 0 !== o && s < r.length; s++) o = (t = (0 | r.words[s]) + o) >> 26, this.words[s] = 67108863 & t;
										if (0 === o && s < r.length && r !== this)
											for (; s < r.length; s++) this.words[s] = r.words[s];
										return this.length = Math.max(this.length, s), r !== this && (this.negative = 1), this._strip()
									}, o.prototype.sub = function(e) {
										return this.clone().isub(e)
									};
									var g = function(e, t, r) {
										var n, i, o, s = e.words,
											a = t.words,
											c = r.words,
											l = 0,
											u = 0 | s[0],
											d = 8191 & u,
											h = u >>> 13,
											f = 0 | s[1],
											p = 8191 & f,
											v = f >>> 13,
											g = 0 | s[2],
											m = 8191 & g,
											y = g >>> 13,
											b = 0 | s[3],
											_ = 8191 & b,
											w = b >>> 13,
											S = 0 | s[4],
											E = 8191 & S,
											k = S >>> 13,
											T = 0 | s[5],
											I = 8191 & T,
											R = T >>> 13,
											C = 0 | s[6],
											M = 8191 & C,
											x = C >>> 13,
											O = 0 | s[7],
											A = 8191 & O,
											P = O >>> 13,
											D = 0 | s[8],
											j = 8191 & D,
											L = D >>> 13,
											N = 0 | s[9],
											B = 8191 & N,
											U = N >>> 13,
											F = 0 | a[0],
											$ = 8191 & F,
											q = F >>> 13,
											K = 0 | a[1],
											V = 8191 & K,
											z = K >>> 13,
											H = 0 | a[2],
											W = 8191 & H,
											G = H >>> 13,
											Y = 0 | a[3],
											Q = 8191 & Y,
											J = Y >>> 13,
											X = 0 | a[4],
											Z = 8191 & X,
											ee = X >>> 13,
											te = 0 | a[5],
											re = 8191 & te,
											ne = te >>> 13,
											ie = 0 | a[6],
											oe = 8191 & ie,
											se = ie >>> 13,
											ae = 0 | a[7],
											ce = 8191 & ae,
											le = ae >>> 13,
											ue = 0 | a[8],
											de = 8191 & ue,
											he = ue >>> 13,
											fe = 0 | a[9],
											pe = 8191 & fe,
											ve = fe >>> 13;
										r.negative = e.negative ^ t.negative, r.length = 19;
										var ge = (l + (n = Math.imul(d, $)) | 0) + ((8191 & (i = (i = Math.imul(d, q)) + Math.imul(h, $) | 0)) << 13) | 0;
										l = ((o = Math.imul(h, q)) + (i >>> 13) | 0) + (ge >>> 26) | 0, ge &= 67108863, n = Math.imul(p, $), i = (i = Math.imul(p, q)) + Math.imul(v, $) | 0, o = Math.imul(v, q);
										var me = (l + (n = n + Math.imul(d, V) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, z) | 0) + Math.imul(h, V) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, z) | 0) + (i >>> 13) | 0) + (me >>> 26) | 0, me &= 67108863, n = Math.imul(m, $), i = (i = Math.imul(m, q)) + Math.imul(y, $) | 0, o = Math.imul(y, q), n = n + Math.imul(p, V) | 0, i = (i = i + Math.imul(p, z) | 0) + Math.imul(v, V) | 0, o = o + Math.imul(v, z) | 0;
										var ye = (l + (n = n + Math.imul(d, W) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, G) | 0) + Math.imul(h, W) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, G) | 0) + (i >>> 13) | 0) + (ye >>> 26) | 0, ye &= 67108863, n = Math.imul(_, $), i = (i = Math.imul(_, q)) + Math.imul(w, $) | 0, o = Math.imul(w, q), n = n + Math.imul(m, V) | 0, i = (i = i + Math.imul(m, z) | 0) + Math.imul(y, V) | 0, o = o + Math.imul(y, z) | 0, n = n + Math.imul(p, W) | 0, i = (i = i + Math.imul(p, G) | 0) + Math.imul(v, W) | 0, o = o + Math.imul(v, G) | 0;
										var be = (l + (n = n + Math.imul(d, Q) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, J) | 0) + Math.imul(h, Q) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, J) | 0) + (i >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, n = Math.imul(E, $), i = (i = Math.imul(E, q)) + Math.imul(k, $) | 0, o = Math.imul(k, q), n = n + Math.imul(_, V) | 0, i = (i = i + Math.imul(_, z) | 0) + Math.imul(w, V) | 0, o = o + Math.imul(w, z) | 0, n = n + Math.imul(m, W) | 0, i = (i = i + Math.imul(m, G) | 0) + Math.imul(y, W) | 0, o = o + Math.imul(y, G) | 0, n = n + Math.imul(p, Q) | 0, i = (i = i + Math.imul(p, J) | 0) + Math.imul(v, Q) | 0, o = o + Math.imul(v, J) | 0;
										var _e = (l + (n = n + Math.imul(d, Z) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, ee) | 0) + Math.imul(h, Z) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, ee) | 0) + (i >>> 13) | 0) + (_e >>> 26) | 0, _e &= 67108863, n = Math.imul(I, $), i = (i = Math.imul(I, q)) + Math.imul(R, $) | 0, o = Math.imul(R, q), n = n + Math.imul(E, V) | 0, i = (i = i + Math.imul(E, z) | 0) + Math.imul(k, V) | 0, o = o + Math.imul(k, z) | 0, n = n + Math.imul(_, W) | 0, i = (i = i + Math.imul(_, G) | 0) + Math.imul(w, W) | 0, o = o + Math.imul(w, G) | 0, n = n + Math.imul(m, Q) | 0, i = (i = i + Math.imul(m, J) | 0) + Math.imul(y, Q) | 0, o = o + Math.imul(y, J) | 0, n = n + Math.imul(p, Z) | 0, i = (i = i + Math.imul(p, ee) | 0) + Math.imul(v, Z) | 0, o = o + Math.imul(v, ee) | 0;
										var we = (l + (n = n + Math.imul(d, re) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, ne) | 0) + Math.imul(h, re) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, ne) | 0) + (i >>> 13) | 0) + (we >>> 26) | 0, we &= 67108863, n = Math.imul(M, $), i = (i = Math.imul(M, q)) + Math.imul(x, $) | 0, o = Math.imul(x, q), n = n + Math.imul(I, V) | 0, i = (i = i + Math.imul(I, z) | 0) + Math.imul(R, V) | 0, o = o + Math.imul(R, z) | 0, n = n + Math.imul(E, W) | 0, i = (i = i + Math.imul(E, G) | 0) + Math.imul(k, W) | 0, o = o + Math.imul(k, G) | 0, n = n + Math.imul(_, Q) | 0, i = (i = i + Math.imul(_, J) | 0) + Math.imul(w, Q) | 0, o = o + Math.imul(w, J) | 0, n = n + Math.imul(m, Z) | 0, i = (i = i + Math.imul(m, ee) | 0) + Math.imul(y, Z) | 0, o = o + Math.imul(y, ee) | 0, n = n + Math.imul(p, re) | 0, i = (i = i + Math.imul(p, ne) | 0) + Math.imul(v, re) | 0, o = o + Math.imul(v, ne) | 0;
										var Se = (l + (n = n + Math.imul(d, oe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, se) | 0) + Math.imul(h, oe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, se) | 0) + (i >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, n = Math.imul(A, $), i = (i = Math.imul(A, q)) + Math.imul(P, $) | 0, o = Math.imul(P, q), n = n + Math.imul(M, V) | 0, i = (i = i + Math.imul(M, z) | 0) + Math.imul(x, V) | 0, o = o + Math.imul(x, z) | 0, n = n + Math.imul(I, W) | 0, i = (i = i + Math.imul(I, G) | 0) + Math.imul(R, W) | 0, o = o + Math.imul(R, G) | 0, n = n + Math.imul(E, Q) | 0, i = (i = i + Math.imul(E, J) | 0) + Math.imul(k, Q) | 0, o = o + Math.imul(k, J) | 0, n = n + Math.imul(_, Z) | 0, i = (i = i + Math.imul(_, ee) | 0) + Math.imul(w, Z) | 0, o = o + Math.imul(w, ee) | 0, n = n + Math.imul(m, re) | 0, i = (i = i + Math.imul(m, ne) | 0) + Math.imul(y, re) | 0, o = o + Math.imul(y, ne) | 0, n = n + Math.imul(p, oe) | 0, i = (i = i + Math.imul(p, se) | 0) + Math.imul(v, oe) | 0, o = o + Math.imul(v, se) | 0;
										var Ee = (l + (n = n + Math.imul(d, ce) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, le) | 0) + Math.imul(h, ce) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, le) | 0) + (i >>> 13) | 0) + (Ee >>> 26) | 0, Ee &= 67108863, n = Math.imul(j, $), i = (i = Math.imul(j, q)) + Math.imul(L, $) | 0, o = Math.imul(L, q), n = n + Math.imul(A, V) | 0, i = (i = i + Math.imul(A, z) | 0) + Math.imul(P, V) | 0, o = o + Math.imul(P, z) | 0, n = n + Math.imul(M, W) | 0, i = (i = i + Math.imul(M, G) | 0) + Math.imul(x, W) | 0, o = o + Math.imul(x, G) | 0, n = n + Math.imul(I, Q) | 0, i = (i = i + Math.imul(I, J) | 0) + Math.imul(R, Q) | 0, o = o + Math.imul(R, J) | 0, n = n + Math.imul(E, Z) | 0, i = (i = i + Math.imul(E, ee) | 0) + Math.imul(k, Z) | 0, o = o + Math.imul(k, ee) | 0, n = n + Math.imul(_, re) | 0, i = (i = i + Math.imul(_, ne) | 0) + Math.imul(w, re) | 0, o = o + Math.imul(w, ne) | 0, n = n + Math.imul(m, oe) | 0, i = (i = i + Math.imul(m, se) | 0) + Math.imul(y, oe) | 0, o = o + Math.imul(y, se) | 0, n = n + Math.imul(p, ce) | 0, i = (i = i + Math.imul(p, le) | 0) + Math.imul(v, ce) | 0, o = o + Math.imul(v, le) | 0;
										var ke = (l + (n = n + Math.imul(d, de) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, he) | 0) + Math.imul(h, de) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, he) | 0) + (i >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, n = Math.imul(B, $), i = (i = Math.imul(B, q)) + Math.imul(U, $) | 0, o = Math.imul(U, q), n = n + Math.imul(j, V) | 0, i = (i = i + Math.imul(j, z) | 0) + Math.imul(L, V) | 0, o = o + Math.imul(L, z) | 0, n = n + Math.imul(A, W) | 0, i = (i = i + Math.imul(A, G) | 0) + Math.imul(P, W) | 0, o = o + Math.imul(P, G) | 0, n = n + Math.imul(M, Q) | 0, i = (i = i + Math.imul(M, J) | 0) + Math.imul(x, Q) | 0, o = o + Math.imul(x, J) | 0, n = n + Math.imul(I, Z) | 0, i = (i = i + Math.imul(I, ee) | 0) + Math.imul(R, Z) | 0, o = o + Math.imul(R, ee) | 0, n = n + Math.imul(E, re) | 0, i = (i = i + Math.imul(E, ne) | 0) + Math.imul(k, re) | 0, o = o + Math.imul(k, ne) | 0, n = n + Math.imul(_, oe) | 0, i = (i = i + Math.imul(_, se) | 0) + Math.imul(w, oe) | 0, o = o + Math.imul(w, se) | 0, n = n + Math.imul(m, ce) | 0, i = (i = i + Math.imul(m, le) | 0) + Math.imul(y, ce) | 0, o = o + Math.imul(y, le) | 0, n = n + Math.imul(p, de) | 0, i = (i = i + Math.imul(p, he) | 0) + Math.imul(v, de) | 0, o = o + Math.imul(v, he) | 0;
										var Te = (l + (n = n + Math.imul(d, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, ve) | 0) + Math.imul(h, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(h, ve) | 0) + (i >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, n = Math.imul(B, V), i = (i = Math.imul(B, z)) + Math.imul(U, V) | 0, o = Math.imul(U, z), n = n + Math.imul(j, W) | 0, i = (i = i + Math.imul(j, G) | 0) + Math.imul(L, W) | 0, o = o + Math.imul(L, G) | 0, n = n + Math.imul(A, Q) | 0, i = (i = i + Math.imul(A, J) | 0) + Math.imul(P, Q) | 0, o = o + Math.imul(P, J) | 0, n = n + Math.imul(M, Z) | 0, i = (i = i + Math.imul(M, ee) | 0) + Math.imul(x, Z) | 0, o = o + Math.imul(x, ee) | 0, n = n + Math.imul(I, re) | 0, i = (i = i + Math.imul(I, ne) | 0) + Math.imul(R, re) | 0, o = o + Math.imul(R, ne) | 0, n = n + Math.imul(E, oe) | 0, i = (i = i + Math.imul(E, se) | 0) + Math.imul(k, oe) | 0, o = o + Math.imul(k, se) | 0, n = n + Math.imul(_, ce) | 0, i = (i = i + Math.imul(_, le) | 0) + Math.imul(w, ce) | 0, o = o + Math.imul(w, le) | 0, n = n + Math.imul(m, de) | 0, i = (i = i + Math.imul(m, he) | 0) + Math.imul(y, de) | 0, o = o + Math.imul(y, he) | 0;
										var Ie = (l + (n = n + Math.imul(p, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(p, ve) | 0) + Math.imul(v, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(v, ve) | 0) + (i >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, n = Math.imul(B, W), i = (i = Math.imul(B, G)) + Math.imul(U, W) | 0, o = Math.imul(U, G), n = n + Math.imul(j, Q) | 0, i = (i = i + Math.imul(j, J) | 0) + Math.imul(L, Q) | 0, o = o + Math.imul(L, J) | 0, n = n + Math.imul(A, Z) | 0, i = (i = i + Math.imul(A, ee) | 0) + Math.imul(P, Z) | 0, o = o + Math.imul(P, ee) | 0, n = n + Math.imul(M, re) | 0, i = (i = i + Math.imul(M, ne) | 0) + Math.imul(x, re) | 0, o = o + Math.imul(x, ne) | 0, n = n + Math.imul(I, oe) | 0, i = (i = i + Math.imul(I, se) | 0) + Math.imul(R, oe) | 0, o = o + Math.imul(R, se) | 0, n = n + Math.imul(E, ce) | 0, i = (i = i + Math.imul(E, le) | 0) + Math.imul(k, ce) | 0, o = o + Math.imul(k, le) | 0, n = n + Math.imul(_, de) | 0, i = (i = i + Math.imul(_, he) | 0) + Math.imul(w, de) | 0, o = o + Math.imul(w, he) | 0;
										var Re = (l + (n = n + Math.imul(m, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(m, ve) | 0) + Math.imul(y, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(y, ve) | 0) + (i >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, n = Math.imul(B, Q), i = (i = Math.imul(B, J)) + Math.imul(U, Q) | 0, o = Math.imul(U, J), n = n + Math.imul(j, Z) | 0, i = (i = i + Math.imul(j, ee) | 0) + Math.imul(L, Z) | 0, o = o + Math.imul(L, ee) | 0, n = n + Math.imul(A, re) | 0, i = (i = i + Math.imul(A, ne) | 0) + Math.imul(P, re) | 0, o = o + Math.imul(P, ne) | 0, n = n + Math.imul(M, oe) | 0, i = (i = i + Math.imul(M, se) | 0) + Math.imul(x, oe) | 0, o = o + Math.imul(x, se) | 0, n = n + Math.imul(I, ce) | 0, i = (i = i + Math.imul(I, le) | 0) + Math.imul(R, ce) | 0, o = o + Math.imul(R, le) | 0, n = n + Math.imul(E, de) | 0, i = (i = i + Math.imul(E, he) | 0) + Math.imul(k, de) | 0, o = o + Math.imul(k, he) | 0;
										var Ce = (l + (n = n + Math.imul(_, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(_, ve) | 0) + Math.imul(w, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(w, ve) | 0) + (i >>> 13) | 0) + (Ce >>> 26) | 0, Ce &= 67108863, n = Math.imul(B, Z), i = (i = Math.imul(B, ee)) + Math.imul(U, Z) | 0, o = Math.imul(U, ee), n = n + Math.imul(j, re) | 0, i = (i = i + Math.imul(j, ne) | 0) + Math.imul(L, re) | 0, o = o + Math.imul(L, ne) | 0, n = n + Math.imul(A, oe) | 0, i = (i = i + Math.imul(A, se) | 0) + Math.imul(P, oe) | 0, o = o + Math.imul(P, se) | 0, n = n + Math.imul(M, ce) | 0, i = (i = i + Math.imul(M, le) | 0) + Math.imul(x, ce) | 0, o = o + Math.imul(x, le) | 0, n = n + Math.imul(I, de) | 0, i = (i = i + Math.imul(I, he) | 0) + Math.imul(R, de) | 0, o = o + Math.imul(R, he) | 0;
										var Me = (l + (n = n + Math.imul(E, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(E, ve) | 0) + Math.imul(k, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(k, ve) | 0) + (i >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, n = Math.imul(B, re), i = (i = Math.imul(B, ne)) + Math.imul(U, re) | 0, o = Math.imul(U, ne), n = n + Math.imul(j, oe) | 0, i = (i = i + Math.imul(j, se) | 0) + Math.imul(L, oe) | 0, o = o + Math.imul(L, se) | 0, n = n + Math.imul(A, ce) | 0, i = (i = i + Math.imul(A, le) | 0) + Math.imul(P, ce) | 0, o = o + Math.imul(P, le) | 0, n = n + Math.imul(M, de) | 0, i = (i = i + Math.imul(M, he) | 0) + Math.imul(x, de) | 0, o = o + Math.imul(x, he) | 0;
										var xe = (l + (n = n + Math.imul(I, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(I, ve) | 0) + Math.imul(R, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(R, ve) | 0) + (i >>> 13) | 0) + (xe >>> 26) | 0, xe &= 67108863, n = Math.imul(B, oe), i = (i = Math.imul(B, se)) + Math.imul(U, oe) | 0, o = Math.imul(U, se), n = n + Math.imul(j, ce) | 0, i = (i = i + Math.imul(j, le) | 0) + Math.imul(L, ce) | 0, o = o + Math.imul(L, le) | 0, n = n + Math.imul(A, de) | 0, i = (i = i + Math.imul(A, he) | 0) + Math.imul(P, de) | 0, o = o + Math.imul(P, he) | 0;
										var Oe = (l + (n = n + Math.imul(M, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(M, ve) | 0) + Math.imul(x, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(x, ve) | 0) + (i >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, n = Math.imul(B, ce), i = (i = Math.imul(B, le)) + Math.imul(U, ce) | 0, o = Math.imul(U, le), n = n + Math.imul(j, de) | 0, i = (i = i + Math.imul(j, he) | 0) + Math.imul(L, de) | 0, o = o + Math.imul(L, he) | 0;
										var Ae = (l + (n = n + Math.imul(A, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(A, ve) | 0) + Math.imul(P, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(P, ve) | 0) + (i >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, n = Math.imul(B, de), i = (i = Math.imul(B, he)) + Math.imul(U, de) | 0, o = Math.imul(U, he);
										var Pe = (l + (n = n + Math.imul(j, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(j, ve) | 0) + Math.imul(L, pe) | 0)) << 13) | 0;
										l = ((o = o + Math.imul(L, ve) | 0) + (i >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863;
										var De = (l + (n = Math.imul(B, pe)) | 0) + ((8191 & (i = (i = Math.imul(B, ve)) + Math.imul(U, pe) | 0)) << 13) | 0;
										return l = ((o = Math.imul(U, ve)) + (i >>> 13) | 0) + (De >>> 26) | 0, De &= 67108863, c[0] = ge, c[1] = me, c[2] = ye, c[3] = be, c[4] = _e, c[5] = we, c[6] = Se, c[7] = Ee, c[8] = ke, c[9] = Te, c[10] = Ie, c[11] = Re, c[12] = Ce, c[13] = Me, c[14] = xe, c[15] = Oe, c[16] = Ae, c[17] = Pe, c[18] = De, 0 !== l && (c[19] = l, r.length++), r
									};

									function m(e, t, r) {
										r.negative = t.negative ^ e.negative, r.length = e.length + t.length;
										for (var n = 0, i = 0, o = 0; o < r.length - 1; o++) {
											var s = i;
											i = 0;
											for (var a = 67108863 & n, c = Math.min(o, t.length - 1), l = Math.max(0, o - e.length + 1); l <= c; l++) {
												var u = o - l,
													d = (0 | e.words[u]) * (0 | t.words[l]),
													h = 67108863 & d;
												a = 67108863 & (h = h + a | 0), i += (s = (s = s + (d / 67108864 | 0) | 0) + (h >>> 26) | 0) >>> 26, s &= 67108863
											}
											r.words[o] = a, n = s, s = i
										}
										return 0 !== n ? r.words[o] = n : r.length--, r._strip()
									}

									function y(e, t, r) {
										return m(e, t, r)
									}

									function b(e, t) {
										this.x = e, this.y = t
									}
									Math.imul || (g = v), o.prototype.mulTo = function(e, t) {
										var r = this.length + e.length;
										return 10 === this.length && 10 === e.length ? g(this, e, t) : r < 63 ? v(this, e, t) : r < 1024 ? m(this, e, t) : y(this, e, t)
									}, b.prototype.makeRBT = function(e) {
										for (var t = new Array(e), r = o.prototype._countBits(e) - 1, n = 0; n < e; n++) t[n] = this.revBin(n, r, e);
										return t
									}, b.prototype.revBin = function(e, t, r) {
										if (0 === e || e === r - 1) return e;
										for (var n = 0, i = 0; i < t; i++) n |= (1 & e) << t - i - 1, e >>= 1;
										return n
									}, b.prototype.permute = function(e, t, r, n, i, o) {
										for (var s = 0; s < o; s++) n[s] = t[e[s]], i[s] = r[e[s]]
									}, b.prototype.transform = function(e, t, r, n, i, o) {
										this.permute(o, e, t, r, n, i);
										for (var s = 1; s < i; s <<= 1)
											for (var a = s << 1, c = Math.cos(2 * Math.PI / a), l = Math.sin(2 * Math.PI / a), u = 0; u < i; u += a)
												for (var d = c, h = l, f = 0; f < s; f++) {
													var p = r[u + f],
														v = n[u + f],
														g = r[u + f + s],
														m = n[u + f + s],
														y = d * g - h * m;
													m = d * m + h * g, g = y, r[u + f] = p + g, n[u + f] = v + m, r[u + f + s] = p - g, n[u + f + s] = v - m, f !== a && (y = c * d - l * h, h = c * h + l * d, d = y)
												}
									}, b.prototype.guessLen13b = function(e, t) {
										var r = 1 | Math.max(t, e),
											n = 1 & r,
											i = 0;
										for (r = r / 2 | 0; r; r >>>= 1) i++;
										return 1 << i + 1 + n
									}, b.prototype.conjugate = function(e, t, r) {
										if (!(r <= 1))
											for (var n = 0; n < r / 2; n++) {
												var i = e[n];
												e[n] = e[r - n - 1], e[r - n - 1] = i, i = t[n], t[n] = -t[r - n - 1], t[r - n - 1] = -i
											}
									}, b.prototype.normalize13b = function(e, t) {
										for (var r = 0, n = 0; n < t / 2; n++) {
											var i = 8192 * Math.round(e[2 * n + 1] / t) + Math.round(e[2 * n] / t) + r;
											e[n] = 67108863 & i, r = i < 67108864 ? 0 : i / 67108864 | 0
										}
										return e
									}, b.prototype.convert13b = function(e, t, r, i) {
										for (var o = 0, s = 0; s < t; s++) o += 0 | e[s], r[2 * s] = 8191 & o, o >>>= 13, r[2 * s + 1] = 8191 & o, o >>>= 13;
										for (s = 2 * t; s < i; ++s) r[s] = 0;
										n(0 === o), n(0 == (-8192 & o))
									}, b.prototype.stub = function(e) {
										for (var t = new Array(e), r = 0; r < e; r++) t[r] = 0;
										return t
									}, b.prototype.mulp = function(e, t, r) {
										var n = 2 * this.guessLen13b(e.length, t.length),
											i = this.makeRBT(n),
											o = this.stub(n),
											s = new Array(n),
											a = new Array(n),
											c = new Array(n),
											l = new Array(n),
											u = new Array(n),
											d = new Array(n),
											h = r.words;
										h.length = n, this.convert13b(e.words, e.length, s, n), this.convert13b(t.words, t.length, l, n), this.transform(s, o, a, c, n, i), this.transform(l, o, u, d, n, i);
										for (var f = 0; f < n; f++) {
											var p = a[f] * u[f] - c[f] * d[f];
											c[f] = a[f] * d[f] + c[f] * u[f], a[f] = p
										}
										return this.conjugate(a, c, n), this.transform(a, c, h, o, n, i), this.conjugate(h, o, n), this.normalize13b(h, n), r.negative = e.negative ^ t.negative, r.length = e.length + t.length, r._strip()
									}, o.prototype.mul = function(e) {
										var t = new o(null);
										return t.words = new Array(this.length + e.length), this.mulTo(e, t)
									}, o.prototype.mulf = function(e) {
										var t = new o(null);
										return t.words = new Array(this.length + e.length), y(this, e, t)
									}, o.prototype.imul = function(e) {
										return this.clone().mulTo(e, this)
									}, o.prototype.imuln = function(e) {
										var t = e < 0;
										t && (e = -e), n("number" == typeof e), n(e < 67108864);
										for (var r = 0, i = 0; i < this.length; i++) {
											var o = (0 | this.words[i]) * e,
												s = (67108863 & o) + (67108863 & r);
											r >>= 26, r += o / 67108864 | 0, r += s >>> 26, this.words[i] = 67108863 & s
										}
										return 0 !== r && (this.words[i] = r, this.length++), t ? this.ineg() : this
									}, o.prototype.muln = function(e) {
										return this.clone().imuln(e)
									}, o.prototype.sqr = function() {
										return this.mul(this)
									}, o.prototype.isqr = function() {
										return this.imul(this.clone())
									}, o.prototype.pow = function(e) {
										var t = function(e) {
											for (var t = new Array(e.bitLength()), r = 0; r < t.length; r++) {
												var n = r / 26 | 0,
													i = r % 26;
												t[r] = e.words[n] >>> i & 1
											}
											return t
										}(e);
										if (0 === t.length) return new o(1);
										for (var r = this, n = 0; n < t.length && 0 === t[n]; n++, r = r.sqr());
										if (++n < t.length)
											for (var i = r.sqr(); n < t.length; n++, i = i.sqr()) 0 !== t[n] && (r = r.mul(i));
										return r
									}, o.prototype.iushln = function(e) {
										n("number" == typeof e && e >= 0);
										var t, r = e % 26,
											i = (e - r) / 26,
											o = 67108863 >>> 26 - r << 26 - r;
										if (0 !== r) {
											var s = 0;
											for (t = 0; t < this.length; t++) {
												var a = this.words[t] & o,
													c = (0 | this.words[t]) - a << r;
												this.words[t] = c | s, s = a >>> 26 - r
											}
											s && (this.words[t] = s, this.length++)
										}
										if (0 !== i) {
											for (t = this.length - 1; t >= 0; t--) this.words[t + i] = this.words[t];
											for (t = 0; t < i; t++) this.words[t] = 0;
											this.length += i
										}
										return this._strip()
									}, o.prototype.ishln = function(e) {
										return n(0 === this.negative), this.iushln(e)
									}, o.prototype.iushrn = function(e, t, r) {
										var i;
										n("number" == typeof e && e >= 0), i = t ? (t - t % 26) / 26 : 0;
										var o = e % 26,
											s = Math.min((e - o) / 26, this.length),
											a = 67108863 ^ 67108863 >>> o << o,
											c = r;
										if (i -= s, i = Math.max(0, i), c) {
											for (var l = 0; l < s; l++) c.words[l] = this.words[l];
											c.length = s
										}
										if (0 === s);
										else if (this.length > s)
											for (this.length -= s, l = 0; l < this.length; l++) this.words[l] = this.words[l + s];
										else this.words[0] = 0, this.length = 1;
										var u = 0;
										for (l = this.length - 1; l >= 0 && (0 !== u || l >= i); l--) {
											var d = 0 | this.words[l];
											this.words[l] = u << 26 - o | d >>> o, u = d & a
										}
										return c && 0 !== u && (c.words[c.length++] = u), 0 === this.length && (this.words[0] = 0, this.length = 1), this._strip()
									}, o.prototype.ishrn = function(e, t, r) {
										return n(0 === this.negative), this.iushrn(e, t, r)
									}, o.prototype.shln = function(e) {
										return this.clone().ishln(e)
									}, o.prototype.ushln = function(e) {
										return this.clone().iushln(e)
									}, o.prototype.shrn = function(e) {
										return this.clone().ishrn(e)
									}, o.prototype.ushrn = function(e) {
										return this.clone().iushrn(e)
									}, o.prototype.testn = function(e) {
										n("number" == typeof e && e >= 0);
										var t = e % 26,
											r = (e - t) / 26,
											i = 1 << t;
										return !(this.length <= r) && !!(this.words[r] & i)
									}, o.prototype.imaskn = function(e) {
										n("number" == typeof e && e >= 0);
										var t = e % 26,
											r = (e - t) / 26;
										if (n(0 === this.negative, "imaskn works only with positive numbers"), this.length <= r) return this;
										if (0 !== t && r++, this.length = Math.min(r, this.length), 0 !== t) {
											var i = 67108863 ^ 67108863 >>> t << t;
											this.words[this.length - 1] &= i
										}
										return this._strip()
									}, o.prototype.maskn = function(e) {
										return this.clone().imaskn(e)
									}, o.prototype.iaddn = function(e) {
										return n("number" == typeof e), n(e < 67108864), e < 0 ? this.isubn(-e) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= e ? (this.words[0] = e - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(e), this.negative = 1, this) : this._iaddn(e)
									}, o.prototype._iaddn = function(e) {
										this.words[0] += e;
										for (var t = 0; t < this.length && this.words[t] >= 67108864; t++) this.words[t] -= 67108864, t === this.length - 1 ? this.words[t + 1] = 1 : this.words[t + 1]++;
										return this.length = Math.max(this.length, t + 1), this
									}, o.prototype.isubn = function(e) {
										if (n("number" == typeof e), n(e < 67108864), e < 0) return this.iaddn(-e);
										if (0 !== this.negative) return this.negative = 0, this.iaddn(e), this.negative = 1, this;
										if (this.words[0] -= e, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
										else
											for (var t = 0; t < this.length && this.words[t] < 0; t++) this.words[t] += 67108864, this.words[t + 1] -= 1;
										return this._strip()
									}, o.prototype.addn = function(e) {
										return this.clone().iaddn(e)
									}, o.prototype.subn = function(e) {
										return this.clone().isubn(e)
									}, o.prototype.iabs = function() {
										return this.negative = 0, this
									}, o.prototype.abs = function() {
										return this.clone().iabs()
									}, o.prototype._ishlnsubmul = function(e, t, r) {
										var i, o, s = e.length + r;
										this._expand(s);
										var a = 0;
										for (i = 0; i < e.length; i++) {
											o = (0 | this.words[i + r]) + a;
											var c = (0 | e.words[i]) * t;
											a = ((o -= 67108863 & c) >> 26) - (c / 67108864 | 0), this.words[i + r] = 67108863 & o
										}
										for (; i < this.length - r; i++) a = (o = (0 | this.words[i + r]) + a) >> 26, this.words[i + r] = 67108863 & o;
										if (0 === a) return this._strip();
										for (n(-1 === a), a = 0, i = 0; i < this.length; i++) a = (o = -(0 | this.words[i]) + a) >> 26, this.words[i] = 67108863 & o;
										return this.negative = 1, this._strip()
									}, o.prototype._wordDiv = function(e, t) {
										var r = (this.length, e.length),
											n = this.clone(),
											i = e,
											s = 0 | i.words[i.length - 1];
										0 !== (r = 26 - this._countBits(s)) && (i = i.ushln(r), n.iushln(r), s = 0 | i.words[i.length - 1]);
										var a, c = n.length - i.length;
										if ("mod" !== t) {
											(a = new o(null)).length = c + 1, a.words = new Array(a.length);
											for (var l = 0; l < a.length; l++) a.words[l] = 0
										}
										var u = n.clone()._ishlnsubmul(i, 1, c);
										0 === u.negative && (n = u, a && (a.words[c] = 1));
										for (var d = c - 1; d >= 0; d--) {
											var h = 67108864 * (0 | n.words[i.length + d]) + (0 | n.words[i.length + d - 1]);
											for (h = Math.min(h / s | 0, 67108863), n._ishlnsubmul(i, h, d); 0 !== n.negative;) h--, n.negative = 0, n._ishlnsubmul(i, 1, d), n.isZero() || (n.negative ^= 1);
											a && (a.words[d] = h)
										}
										return a && a._strip(), n._strip(), "div" !== t && 0 !== r && n.iushrn(r), {
											div: a || null,
											mod: n
										}
									}, o.prototype.divmod = function(e, t, r) {
										return n(!e.isZero()), this.isZero() ? {
											div: new o(0),
											mod: new o(0)
										} : 0 !== this.negative && 0 === e.negative ? (a = this.neg().divmod(e, t), "mod" !== t && (i = a.div.neg()), "div" !== t && (s = a.mod.neg(), r && 0 !== s.negative && s.iadd(e)), {
											div: i,
											mod: s
										}) : 0 === this.negative && 0 !== e.negative ? (a = this.divmod(e.neg(), t), "mod" !== t && (i = a.div.neg()), {
											div: i,
											mod: a.mod
										}) : 0 != (this.negative & e.negative) ? (a = this.neg().divmod(e.neg(), t), "div" !== t && (s = a.mod.neg(), r && 0 !== s.negative && s.isub(e)), {
											div: a.div,
											mod: s
										}) : e.length > this.length || this.cmp(e) < 0 ? {
											div: new o(0),
											mod: this
										} : 1 === e.length ? "div" === t ? {
											div: this.divn(e.words[0]),
											mod: null
										} : "mod" === t ? {
											div: null,
											mod: new o(this.modrn(e.words[0]))
										} : {
											div: this.divn(e.words[0]),
											mod: new o(this.modrn(e.words[0]))
										} : this._wordDiv(e, t);
										var i, s, a
									}, o.prototype.div = function(e) {
										return this.divmod(e, "div", !1).div
									}, o.prototype.mod = function(e) {
										return this.divmod(e, "mod", !1).mod
									}, o.prototype.umod = function(e) {
										return this.divmod(e, "mod", !0).mod
									}, o.prototype.divRound = function(e) {
										var t = this.divmod(e);
										if (t.mod.isZero()) return t.div;
										var r = 0 !== t.div.negative ? t.mod.isub(e) : t.mod,
											n = e.ushrn(1),
											i = e.andln(1),
											o = r.cmp(n);
										return o < 0 || 1 === i && 0 === o ? t.div : 0 !== t.div.negative ? t.div.isubn(1) : t.div.iaddn(1)
									}, o.prototype.modrn = function(e) {
										var t = e < 0;
										t && (e = -e), n(e <= 67108863);
										for (var r = (1 << 26) % e, i = 0, o = this.length - 1; o >= 0; o--) i = (r * i + (0 | this.words[o])) % e;
										return t ? -i : i
									}, o.prototype.modn = function(e) {
										return this.modrn(e)
									}, o.prototype.idivn = function(e) {
										var t = e < 0;
										t && (e = -e), n(e <= 67108863);
										for (var r = 0, i = this.length - 1; i >= 0; i--) {
											var o = (0 | this.words[i]) + 67108864 * r;
											this.words[i] = o / e | 0, r = o % e
										}
										return this._strip(), t ? this.ineg() : this
									}, o.prototype.divn = function(e) {
										return this.clone().idivn(e)
									}, o.prototype.egcd = function(e) {
										n(0 === e.negative), n(!e.isZero());
										var t = this,
											r = e.clone();
										t = 0 !== t.negative ? t.umod(e) : t.clone();
										for (var i = new o(1), s = new o(0), a = new o(0), c = new o(1), l = 0; t.isEven() && r.isEven();) t.iushrn(1), r.iushrn(1), ++l;
										for (var u = r.clone(), d = t.clone(); !t.isZero();) {
											for (var h = 0, f = 1; 0 == (t.words[0] & f) && h < 26; ++h, f <<= 1);
											if (h > 0)
												for (t.iushrn(h); h-- > 0;)(i.isOdd() || s.isOdd()) && (i.iadd(u), s.isub(d)), i.iushrn(1), s.iushrn(1);
											for (var p = 0, v = 1; 0 == (r.words[0] & v) && p < 26; ++p, v <<= 1);
											if (p > 0)
												for (r.iushrn(p); p-- > 0;)(a.isOdd() || c.isOdd()) && (a.iadd(u), c.isub(d)), a.iushrn(1), c.iushrn(1);
											t.cmp(r) >= 0 ? (t.isub(r), i.isub(a), s.isub(c)) : (r.isub(t), a.isub(i), c.isub(s))
										}
										return {
											a,
											b: c,
											gcd: r.iushln(l)
										}
									}, o.prototype._invmp = function(e) {
										n(0 === e.negative), n(!e.isZero());
										var t = this,
											r = e.clone();
										t = 0 !== t.negative ? t.umod(e) : t.clone();
										for (var i, s = new o(1), a = new o(0), c = r.clone(); t.cmpn(1) > 0 && r.cmpn(1) > 0;) {
											for (var l = 0, u = 1; 0 == (t.words[0] & u) && l < 26; ++l, u <<= 1);
											if (l > 0)
												for (t.iushrn(l); l-- > 0;) s.isOdd() && s.iadd(c), s.iushrn(1);
											for (var d = 0, h = 1; 0 == (r.words[0] & h) && d < 26; ++d, h <<= 1);
											if (d > 0)
												for (r.iushrn(d); d-- > 0;) a.isOdd() && a.iadd(c), a.iushrn(1);
											t.cmp(r) >= 0 ? (t.isub(r), s.isub(a)) : (r.isub(t), a.isub(s))
										}
										return (i = 0 === t.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(e), i
									}, o.prototype.gcd = function(e) {
										if (this.isZero()) return e.abs();
										if (e.isZero()) return this.abs();
										var t = this.clone(),
											r = e.clone();
										t.negative = 0, r.negative = 0;
										for (var n = 0; t.isEven() && r.isEven(); n++) t.iushrn(1), r.iushrn(1);
										for (;;) {
											for (; t.isEven();) t.iushrn(1);
											for (; r.isEven();) r.iushrn(1);
											var i = t.cmp(r);
											if (i < 0) {
												var o = t;
												t = r, r = o
											} else if (0 === i || 0 === r.cmpn(1)) break;
											t.isub(r)
										}
										return r.iushln(n)
									}, o.prototype.invm = function(e) {
										return this.egcd(e).a.umod(e)
									}, o.prototype.isEven = function() {
										return 0 == (1 & this.words[0])
									}, o.prototype.isOdd = function() {
										return 1 == (1 & this.words[0])
									}, o.prototype.andln = function(e) {
										return this.words[0] & e
									}, o.prototype.bincn = function(e) {
										n("number" == typeof e);
										var t = e % 26,
											r = (e - t) / 26,
											i = 1 << t;
										if (this.length <= r) return this._expand(r + 1), this.words[r] |= i, this;
										for (var o = i, s = r; 0 !== o && s < this.length; s++) {
											var a = 0 | this.words[s];
											o = (a += o) >>> 26, a &= 67108863, this.words[s] = a
										}
										return 0 !== o && (this.words[s] = o, this.length++), this
									}, o.prototype.isZero = function() {
										return 1 === this.length && 0 === this.words[0]
									}, o.prototype.cmpn = function(e) {
										var t, r = e < 0;
										if (0 !== this.negative && !r) return -1;
										if (0 === this.negative && r) return 1;
										if (this._strip(), this.length > 1) t = 1;
										else {
											r && (e = -e), n(e <= 67108863, "Number is too big");
											var i = 0 | this.words[0];
											t = i === e ? 0 : i < e ? -1 : 1
										}
										return 0 !== this.negative ? 0 | -t : t
									}, o.prototype.cmp = function(e) {
										if (0 !== this.negative && 0 === e.negative) return -1;
										if (0 === this.negative && 0 !== e.negative) return 1;
										var t = this.ucmp(e);
										return 0 !== this.negative ? 0 | -t : t
									}, o.prototype.ucmp = function(e) {
										if (this.length > e.length) return 1;
										if (this.length < e.length) return -1;
										for (var t = 0, r = this.length - 1; r >= 0; r--) {
											var n = 0 | this.words[r],
												i = 0 | e.words[r];
											if (n !== i) {
												n < i ? t = -1 : n > i && (t = 1);
												break
											}
										}
										return t
									}, o.prototype.gtn = function(e) {
										return 1 === this.cmpn(e)
									}, o.prototype.gt = function(e) {
										return 1 === this.cmp(e)
									}, o.prototype.gten = function(e) {
										return this.cmpn(e) >= 0
									}, o.prototype.gte = function(e) {
										return this.cmp(e) >= 0
									}, o.prototype.ltn = function(e) {
										return -1 === this.cmpn(e)
									}, o.prototype.lt = function(e) {
										return -1 === this.cmp(e)
									}, o.prototype.lten = function(e) {
										return this.cmpn(e) <= 0
									}, o.prototype.lte = function(e) {
										return this.cmp(e) <= 0
									}, o.prototype.eqn = function(e) {
										return 0 === this.cmpn(e)
									}, o.prototype.eq = function(e) {
										return 0 === this.cmp(e)
									}, o.red = function(e) {
										return new I(e)
									}, o.prototype.toRed = function(e) {
										return n(!this.red, "Already a number in reduction context"), n(0 === this.negative, "red works only with positives"), e.convertTo(this)._forceRed(e)
									}, o.prototype.fromRed = function() {
										return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
									}, o.prototype._forceRed = function(e) {
										return this.red = e, this
									}, o.prototype.forceRed = function(e) {
										return n(!this.red, "Already a number in reduction context"), this._forceRed(e)
									}, o.prototype.redAdd = function(e) {
										return n(this.red, "redAdd works only with red numbers"), this.red.add(this, e)
									}, o.prototype.redIAdd = function(e) {
										return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, e)
									}, o.prototype.redSub = function(e) {
										return n(this.red, "redSub works only with red numbers"), this.red.sub(this, e)
									}, o.prototype.redISub = function(e) {
										return n(this.red, "redISub works only with red numbers"), this.red.isub(this, e)
									}, o.prototype.redShl = function(e) {
										return n(this.red, "redShl works only with red numbers"), this.red.shl(this, e)
									}, o.prototype.redMul = function(e) {
										return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, e), this.red.mul(this, e)
									}, o.prototype.redIMul = function(e) {
										return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, e), this.red.imul(this, e)
									}, o.prototype.redSqr = function() {
										return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
									}, o.prototype.redISqr = function() {
										return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
									}, o.prototype.redSqrt = function() {
										return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
									}, o.prototype.redInvm = function() {
										return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
									}, o.prototype.redNeg = function() {
										return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
									}, o.prototype.redPow = function(e) {
										return n(this.red && !e.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, e)
									};
									var _ = {
										k256: null,
										p224: null,
										p192: null,
										p25519: null
									};

									function w(e, t) {
										this.name = e, this.p = new o(t, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
									}

									function S() {
										w.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
									}

									function E() {
										w.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
									}

									function k() {
										w.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
									}

									function T() {
										w.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
									}

									function I(e) {
										if ("string" == typeof e) {
											var t = o._prime(e);
											this.m = t.p, this.prime = t
										} else n(e.gtn(1), "modulus must be greater than 1"), this.m = e, this.prime = null
									}

									function R(e) {
										I.call(this, e), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
									}
									w.prototype._tmp = function() {
										var e = new o(null);
										return e.words = new Array(Math.ceil(this.n / 13)), e
									}, w.prototype.ireduce = function(e) {
										var t, r = e;
										do {
											this.split(r, this.tmp), t = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength()
										} while (t > this.n);
										var n = t < this.n ? -1 : r.ucmp(this.p);
										return 0 === n ? (r.words[0] = 0, r.length = 1) : n > 0 ? r.isub(this.p) : void 0 !== r.strip ? r.strip() : r._strip(), r
									}, w.prototype.split = function(e, t) {
										e.iushrn(this.n, 0, t)
									}, w.prototype.imulK = function(e) {
										return e.imul(this.k)
									}, i(S, w), S.prototype.split = function(e, t) {
										for (var r = Math.min(e.length, 9), n = 0; n < r; n++) t.words[n] = e.words[n];
										if (t.length = r, e.length <= 9) return e.words[0] = 0, void(e.length = 1);
										var i = e.words[9];
										for (t.words[t.length++] = 4194303 & i, n = 10; n < e.length; n++) {
											var o = 0 | e.words[n];
											e.words[n - 10] = (4194303 & o) << 4 | i >>> 22, i = o
										}
										i >>>= 22, e.words[n - 10] = i, 0 === i && e.length > 10 ? e.length -= 10 : e.length -= 9
									}, S.prototype.imulK = function(e) {
										e.words[e.length] = 0, e.words[e.length + 1] = 0, e.length += 2;
										for (var t = 0, r = 0; r < e.length; r++) {
											var n = 0 | e.words[r];
											t += 977 * n, e.words[r] = 67108863 & t, t = 64 * n + (t / 67108864 | 0)
										}
										return 0 === e.words[e.length - 1] && (e.length--, 0 === e.words[e.length - 1] && e.length--), e
									}, i(E, w), i(k, w), i(T, w), T.prototype.imulK = function(e) {
										for (var t = 0, r = 0; r < e.length; r++) {
											var n = 19 * (0 | e.words[r]) + t,
												i = 67108863 & n;
											n >>>= 26, e.words[r] = i, t = n
										}
										return 0 !== t && (e.words[e.length++] = t), e
									}, o._prime = function(e) {
										if (_[e]) return _[e];
										var t;
										if ("k256" === e) t = new S;
										else if ("p224" === e) t = new E;
										else if ("p192" === e) t = new k;
										else {
											if ("p25519" !== e) throw new Error("Unknown prime " + e);
											t = new T
										}
										return _[e] = t, t
									}, I.prototype._verify1 = function(e) {
										n(0 === e.negative, "red works only with positives"), n(e.red, "red works only with red numbers")
									}, I.prototype._verify2 = function(e, t) {
										n(0 == (e.negative | t.negative), "red works only with positives"), n(e.red && e.red === t.red, "red works only with red numbers")
									}, I.prototype.imod = function(e) {
										return this.prime ? this.prime.ireduce(e)._forceRed(this) : (u(e, e.umod(this.m)._forceRed(this)), e)
									}, I.prototype.neg = function(e) {
										return e.isZero() ? e.clone() : this.m.sub(e)._forceRed(this)
									}, I.prototype.add = function(e, t) {
										this._verify2(e, t);
										var r = e.add(t);
										return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this)
									}, I.prototype.iadd = function(e, t) {
										this._verify2(e, t);
										var r = e.iadd(t);
										return r.cmp(this.m) >= 0 && r.isub(this.m), r
									}, I.prototype.sub = function(e, t) {
										this._verify2(e, t);
										var r = e.sub(t);
										return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this)
									}, I.prototype.isub = function(e, t) {
										this._verify2(e, t);
										var r = e.isub(t);
										return r.cmpn(0) < 0 && r.iadd(this.m), r
									}, I.prototype.shl = function(e, t) {
										return this._verify1(e), this.imod(e.ushln(t))
									}, I.prototype.imul = function(e, t) {
										return this._verify2(e, t), this.imod(e.imul(t))
									}, I.prototype.mul = function(e, t) {
										return this._verify2(e, t), this.imod(e.mul(t))
									}, I.prototype.isqr = function(e) {
										return this.imul(e, e.clone())
									}, I.prototype.sqr = function(e) {
										return this.mul(e, e)
									}, I.prototype.sqrt = function(e) {
										if (e.isZero()) return e.clone();
										var t = this.m.andln(3);
										if (n(t % 2 == 1), 3 === t) {
											var r = this.m.add(new o(1)).iushrn(2);
											return this.pow(e, r)
										}
										for (var i = this.m.subn(1), s = 0; !i.isZero() && 0 === i.andln(1);) s++, i.iushrn(1);
										n(!i.isZero());
										var a = new o(1).toRed(this),
											c = a.redNeg(),
											l = this.m.subn(1).iushrn(1),
											u = this.m.bitLength();
										for (u = new o(2 * u * u).toRed(this); 0 !== this.pow(u, l).cmp(c);) u.redIAdd(c);
										for (var d = this.pow(u, i), h = this.pow(e, i.addn(1).iushrn(1)), f = this.pow(e, i), p = s; 0 !== f.cmp(a);) {
											for (var v = f, g = 0; 0 !== v.cmp(a); g++) v = v.redSqr();
											n(g < p);
											var m = this.pow(d, new o(1).iushln(p - g - 1));
											h = h.redMul(m), d = m.redSqr(), f = f.redMul(d), p = g
										}
										return h
									}, I.prototype.invm = function(e) {
										var t = e._invmp(this.m);
										return 0 !== t.negative ? (t.negative = 0, this.imod(t).redNeg()) : this.imod(t)
									}, I.prototype.pow = function(e, t) {
										if (t.isZero()) return new o(1).toRed(this);
										if (0 === t.cmpn(1)) return e.clone();
										var r = new Array(16);
										r[0] = new o(1).toRed(this), r[1] = e;
										for (var n = 2; n < r.length; n++) r[n] = this.mul(r[n - 1], e);
										var i = r[0],
											s = 0,
											a = 0,
											c = t.bitLength() % 26;
										for (0 === c && (c = 26), n = t.length - 1; n >= 0; n--) {
											for (var l = t.words[n], u = c - 1; u >= 0; u--) {
												var d = l >> u & 1;
												i !== r[0] && (i = this.sqr(i)), 0 !== d || 0 !== s ? (s <<= 1, s |= d, (4 === ++a || 0 === n && 0 === u) && (i = this.mul(i, r[s]), a = 0, s = 0)) : a = 0
											}
											c = 26
										}
										return i
									}, I.prototype.convertTo = function(e) {
										var t = e.umod(this.m);
										return t === e ? t.clone() : t
									}, I.prototype.convertFrom = function(e) {
										var t = e.clone();
										return t.red = null, t
									}, o.mont = function(e) {
										return new R(e)
									}, i(R, I), R.prototype.convertTo = function(e) {
										return this.imod(e.ushln(this.shift))
									}, R.prototype.convertFrom = function(e) {
										var t = this.imod(e.mul(this.rinv));
										return t.red = null, t
									}, R.prototype.imul = function(e, t) {
										if (e.isZero() || t.isZero()) return e.words[0] = 0, e.length = 1, e;
										var r = e.imul(t),
											n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
											i = r.isub(n).iushrn(this.shift),
											o = i;
										return i.cmp(this.m) >= 0 ? o = i.isub(this.m) : i.cmpn(0) < 0 && (o = i.iadd(this.m)), o._forceRed(this)
									}, R.prototype.mul = function(e, t) {
										if (e.isZero() || t.isZero()) return new o(0)._forceRed(this);
										var r = e.mul(t),
											n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
											i = r.isub(n).iushrn(this.shift),
											s = i;
										return i.cmp(this.m) >= 0 ? s = i.isub(this.m) : i.cmpn(0) < 0 && (s = i.iadd(this.m)), s._forceRed(this)
									}, R.prototype.invm = function(e) {
										return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this)
									}
								}(void 0 === t || t, this)
							}, {
								buffer: 21
							}],
							44: [function(e, t, r) {
								t.exports = e("./browser/algorithms.json")
							}, {
								"./browser/algorithms.json": 45
							}],
							45: [function(e, t, r) {
								t.exports = {
									sha224WithRSAEncryption: {
										sign: "rsa",
										hash: "sha224",
										id: "302d300d06096086480165030402040500041c"
									},
									"RSA-SHA224": {
										sign: "ecdsa/rsa",
										hash: "sha224",
										id: "302d300d06096086480165030402040500041c"
									},
									sha256WithRSAEncryption: {
										sign: "rsa",
										hash: "sha256",
										id: "3031300d060960864801650304020105000420"
									},
									"RSA-SHA256": {
										sign: "ecdsa/rsa",
										hash: "sha256",
										id: "3031300d060960864801650304020105000420"
									},
									sha384WithRSAEncryption: {
										sign: "rsa",
										hash: "sha384",
										id: "3041300d060960864801650304020205000430"
									},
									"RSA-SHA384": {
										sign: "ecdsa/rsa",
										hash: "sha384",
										id: "3041300d060960864801650304020205000430"
									},
									sha512WithRSAEncryption: {
										sign: "rsa",
										hash: "sha512",
										id: "3051300d060960864801650304020305000440"
									},
									"RSA-SHA512": {
										sign: "ecdsa/rsa",
										hash: "sha512",
										id: "3051300d060960864801650304020305000440"
									},
									"RSA-SHA1": {
										sign: "rsa",
										hash: "sha1",
										id: "3021300906052b0e03021a05000414"
									},
									"ecdsa-with-SHA1": {
										sign: "ecdsa",
										hash: "sha1",
										id: ""
									},
									sha256: {
										sign: "ecdsa",
										hash: "sha256",
										id: ""
									},
									sha224: {
										sign: "ecdsa",
										hash: "sha224",
										id: ""
									},
									sha384: {
										sign: "ecdsa",
										hash: "sha384",
										id: ""
									},
									sha512: {
										sign: "ecdsa",
										hash: "sha512",
										id: ""
									},
									"DSA-SHA": {
										sign: "dsa",
										hash: "sha1",
										id: ""
									},
									"DSA-SHA1": {
										sign: "dsa",
										hash: "sha1",
										id: ""
									},
									DSA: {
										sign: "dsa",
										hash: "sha1",
										id: ""
									},
									"DSA-WITH-SHA224": {
										sign: "dsa",
										hash: "sha224",
										id: ""
									},
									"DSA-SHA224": {
										sign: "dsa",
										hash: "sha224",
										id: ""
									},
									"DSA-WITH-SHA256": {
										sign: "dsa",
										hash: "sha256",
										id: ""
									},
									"DSA-SHA256": {
										sign: "dsa",
										hash: "sha256",
										id: ""
									},
									"DSA-WITH-SHA384": {
										sign: "dsa",
										hash: "sha384",
										id: ""
									},
									"DSA-SHA384": {
										sign: "dsa",
										hash: "sha384",
										id: ""
									},
									"DSA-WITH-SHA512": {
										sign: "dsa",
										hash: "sha512",
										id: ""
									},
									"DSA-SHA512": {
										sign: "dsa",
										hash: "sha512",
										id: ""
									},
									"DSA-RIPEMD160": {
										sign: "dsa",
										hash: "rmd160",
										id: ""
									},
									ripemd160WithRSA: {
										sign: "rsa",
										hash: "rmd160",
										id: "3021300906052b2403020105000414"
									},
									"RSA-RIPEMD160": {
										sign: "rsa",
										hash: "rmd160",
										id: "3021300906052b2403020105000414"
									},
									md5WithRSAEncryption: {
										sign: "rsa",
										hash: "md5",
										id: "3020300c06082a864886f70d020505000410"
									},
									"RSA-MD5": {
										sign: "rsa",
										hash: "md5",
										id: "3020300c06082a864886f70d020505000410"
									}
								}
							}, {}],
							46: [function(e, t, r) {
								t.exports = {
									"1.3.132.0.10": "secp256k1",
									"1.3.132.0.33": "p224",
									"1.2.840.10045.3.1.1": "p192",
									"1.2.840.10045.3.1.7": "p256",
									"1.3.132.0.34": "p384",
									"1.3.132.0.35": "p521"
								}
							}, {}],
							47: [function(e, t, r) {
								var n = e("safe-buffer").Buffer,
									i = e("create-hash"),
									o = e("readable-stream"),
									s = e("inherits"),
									a = e("./sign"),
									c = e("./verify"),
									l = e("./algorithms.json");

								function u(e) {
									o.Writable.call(this);
									var t = l[e];
									if (!t) throw new Error("Unknown message digest");
									this._hashType = t.hash, this._hash = i(t.hash), this._tag = t.id, this._signType = t.sign
								}

								function d(e) {
									o.Writable.call(this);
									var t = l[e];
									if (!t) throw new Error("Unknown message digest");
									this._hash = i(t.hash), this._tag = t.id, this._signType = t.sign
								}

								function h(e) {
									return new u(e)
								}

								function f(e) {
									return new d(e)
								}
								Object.keys(l).forEach((function(e) {
									l[e].id = n.from(l[e].id, "hex"), l[e.toLowerCase()] = l[e]
								})), s(u, o.Writable), u.prototype._write = function(e, t, r) {
									this._hash.update(e), r()
								}, u.prototype.update = function(e, t) {
									return "string" == typeof e && (e = n.from(e, t)), this._hash.update(e), this
								}, u.prototype.sign = function(e, t) {
									this.end();
									var r = this._hash.digest(),
										n = a(r, e, this._hashType, this._signType, this._tag);
									return t ? n.toString(t) : n
								}, s(d, o.Writable), d.prototype._write = function(e, t, r) {
									this._hash.update(e), r()
								}, d.prototype.update = function(e, t) {
									return "string" == typeof e && (e = n.from(e, t)), this._hash.update(e), this
								}, d.prototype.verify = function(e, t, r) {
									"string" == typeof t && (t = n.from(t, r)), this.end();
									var i = this._hash.digest();
									return c(t, i, e, this._signType, this._tag)
								}, t.exports = {
									Sign: h,
									Verify: f,
									createSign: h,
									createVerify: f
								}
							}, {
								"./algorithms.json": 45,
								"./sign": 48,
								"./verify": 49,
								"create-hash": 75,
								inherits: 147,
								"readable-stream": 65,
								"safe-buffer": 251
							}],
							48: [function(e, t, r) {
								var n = e("safe-buffer").Buffer,
									i = e("create-hmac"),
									o = e("browserify-rsa"),
									s = e("elliptic").ec,
									a = e("bn.js"),
									c = e("parse-asn1"),
									l = e("./curves.json");

								function u(e, t, r, o) {
									if ((e = n.from(e.toArray())).length < t.byteLength()) {
										var s = n.alloc(t.byteLength() - e.length);
										e = n.concat([s, e])
									}
									var a = r.length,
										c = function(e, t) {
											e = (e = d(e, t)).mod(t);
											var r = n.from(e.toArray());
											if (r.length < t.byteLength()) {
												var i = n.alloc(t.byteLength() - r.length);
												r = n.concat([i, r])
											}
											return r
										}(r, t),
										l = n.alloc(a);
									l.fill(1);
									var u = n.alloc(a);
									return u = i(o, u).update(l).update(n.from([0])).update(e).update(c).digest(), l = i(o, u).update(l).digest(), {
										k: u = i(o, u).update(l).update(n.from([1])).update(e).update(c).digest(),
										v: l = i(o, u).update(l).digest()
									}
								}

								function d(e, t) {
									var r = new a(e),
										n = (e.length << 3) - t.bitLength();
									return n > 0 && r.ishrn(n), r
								}

								function h(e, t, r) {
									var o, s;
									do {
										for (o = n.alloc(0); 8 * o.length < e.bitLength();) t.v = i(r, t.k).update(t.v).digest(), o = n.concat([o, t.v]);
										s = d(o, e), t.k = i(r, t.k).update(t.v).update(n.from([0])).digest(), t.v = i(r, t.k).update(t.v).digest()
									} while (-1 !== s.cmp(e));
									return s
								}

								function f(e, t, r, n) {
									return e.toRed(a.mont(r)).redPow(t).fromRed().mod(n)
								}
								t.exports = function(e, t, r, i, p) {
									var v = c(t);
									if (v.curve) {
										if ("ecdsa" !== i && "ecdsa/rsa" !== i) throw new Error("wrong private key type");
										return function(e, t) {
											var r = l[t.curve.join(".")];
											if (!r) throw new Error("unknown curve " + t.curve.join("."));
											var i = new s(r).keyFromPrivate(t.privateKey).sign(e);
											return n.from(i.toDER())
										}(e, v)
									}
									if ("dsa" === v.type) {
										if ("dsa" !== i) throw new Error("wrong private key type");
										return function(e, t, r) {
											var i, o = t.params.priv_key,
												s = t.params.p,
												c = t.params.q,
												l = t.params.g,
												p = new a(0),
												v = d(e, c).mod(c),
												g = !1,
												m = u(o, c, e, r);
											for (; !1 === g;) i = h(c, m, r), p = f(l, i, s, c), 0 === (g = i.invm(c).imul(v.add(o.mul(p))).mod(c)).cmpn(0) && (g = !1, p = new a(0));
											return function(e, t) {
												e = e.toArray(), t = t.toArray(), 128 & e[0] && (e = [0].concat(e));
												128 & t[0] && (t = [0].concat(t));
												var r = [48, e.length + t.length + 4, 2, e.length];
												return r = r.concat(e, [2, t.length], t), n.from(r)
											}(p, g)
										}(e, v, r)
									}
									if ("rsa" !== i && "ecdsa/rsa" !== i) throw new Error("wrong private key type");
									e = n.concat([p, e]);
									for (var g = v.modulus.byteLength(), m = [0, 1]; e.length + m.length + 1 < g;) m.push(255);
									m.push(0);
									for (var y = -1; ++y < e.length;) m.push(e[y]);
									return o(m, v)
								}, t.exports.getKey = u, t.exports.makeKey = h
							}, {
								"./curves.json": 46,
								"bn.js": 50,
								"browserify-rsa": 42,
								"create-hmac": 77,
								elliptic: 90,
								"parse-asn1": 231,
								"safe-buffer": 251
							}],
							49: [function(e, t, r) {
								var n = e("safe-buffer").Buffer,
									i = e("bn.js"),
									o = e("elliptic").ec,
									s = e("parse-asn1"),
									a = e("./curves.json");

								function c(e, t) {
									if (e.cmpn(0) <= 0) throw new Error("invalid sig");
									if (e.cmp(t) >= t) throw new Error("invalid sig")
								}
								t.exports = function(e, t, r, l, u) {
									var d = s(r);
									if ("ec" === d.type) {
										if ("ecdsa" !== l && "ecdsa/rsa" !== l) throw new Error("wrong public key type");
										return function(e, t, r) {
											var n = a[r.data.algorithm.curve.join(".")];
											if (!n) throw new Error("unknown curve " + r.data.algorithm.curve.join("."));
											var i = new o(n),
												s = r.data.subjectPrivateKey.data;
											return i.verify(t, e, s)
										}(e, t, d)
									}
									if ("dsa" === d.type) {
										if ("dsa" !== l) throw new Error("wrong public key type");
										return function(e, t, r) {
											var n = r.data.p,
												o = r.data.q,
												a = r.data.g,
												l = r.data.pub_key,
												u = s.signature.decode(e, "der"),
												d = u.s,
												h = u.r;
											c(d, o), c(h, o);
											var f = i.mont(n),
												p = d.invm(o);
											return 0 === a.toRed(f).redPow(new i(t).mul(p).mod(o)).fromRed().mul(l.toRed(f).redPow(h.mul(p).mod(o)).fromRed()).mod(n).mod(o).cmp(h)
										}(e, t, d)
									}
									if ("rsa" !== l && "ecdsa/rsa" !== l) throw new Error("wrong public key type");
									t = n.concat([u, t]);
									for (var h = d.modulus.byteLength(), f = [1], p = 0; t.length + f.length + 2 < h;) f.push(255), p++;
									f.push(0);
									for (var v = -1; ++v < t.length;) f.push(t[v]);
									f = n.from(f);
									var g = i.mont(d.modulus);
									e = (e = new i(e).toRed(g)).redPow(new i(d.publicExponent)), e = n.from(e.fromRed().toArray());
									var m = p < 8 ? 1 : 0;
									for (h = Math.min(e.length, f.length), e.length !== f.length && (m = 1), v = -1; ++v < h;) m |= e[v] ^ f[v];
									return 0 === m
								}
							}, {
								"./curves.json": 46,
								"bn.js": 50,
								elliptic: 90,
								"parse-asn1": 231,
								"safe-buffer": 251
							}],
							50: [function(e, t, r) {
								arguments[4][43][0].apply(r, arguments)
							}, {
								buffer: 21,
								dup: 43
							}],
							51: [function(e, t, r) {
								"use strict";
								var n = {};

								function i(e, t, r) {
									r || (r = Error);
									var i = function(e) {
										var r, n;

										function i(r, n, i) {
											return e.call(this, function(e, r, n) {
												return "string" == typeof t ? t : t(e, r, n)
											}(r, n, i)) || this
										}
										return n = e, (r = i).prototype = Object.create(n.prototype), r.prototype.constructor = r, r.__proto__ = n, i
									}(r);
									i.prototype.name = r.name, i.prototype.code = e, n[e] = i
								}

								function o(e, t) {
									if (Array.isArray(e)) {
										var r = e.length;
										return e = e.map((function(e) {
											return String(e)
										})), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : 2 === r ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0])
									}
									return "of ".concat(t, " ").concat(String(e))
								}
								i("ERR_INVALID_OPT_VALUE", (function(e, t) {
									return 'The value "' + t + '" is invalid for option "' + e + '"'
								}), TypeError), i("ERR_INVALID_ARG_TYPE", (function(e, t, r) {
									var n, i, s, a;
									if ("string" == typeof t && (i = "not ", t.substr(!s || s < 0 ? 0 : +s, i.length) === i) ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be", function(e, t, r) {
											return (void 0 === r || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t
										}(e, " argument")) a = "The ".concat(e, " ").concat(n, " ").concat(o(t, "type"));
									else {
										var c = function(e, t, r) {
											return "number" != typeof r && (r = 0), !(r + t.length > e.length) && -1 !== e.indexOf(t, r)
										}(e, ".") ? "property" : "argument";
										a = 'The "'.concat(e, '" ').concat(c, " ").concat(n, " ").concat(o(t, "type"))
									}
									return a += ". Received type ".concat(typeof r)
								}), TypeError), i("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), i("ERR_METHOD_NOT_IMPLEMENTED", (function(e) {
									return "The " + e + " method is not implemented"
								})), i("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), i("ERR_STREAM_DESTROYED", (function(e) {
									return "Cannot call " + e + " after a stream was destroyed"
								})), i("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), i("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), i("ERR_STREAM_WRITE_AFTER_END", "write after end"), i("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), i("ERR_UNKNOWN_ENCODING", (function(e) {
									return "Unknown encoding: " + e
								}), TypeError), i("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t.exports.codes = n
							}, {}],
							52: [function(e, t, r) {
								(function(r) {
									(function() {
										"use strict";
										var n = Object.keys || function(e) {
											var t = [];
											for (var r in e) t.push(r);
											return t
										};
										t.exports = l;
										var i = e("./_stream_readable"),
											o = e("./_stream_writable");
										e("inherits")(l, i);
										for (var s = n(o.prototype), a = 0; a < s.length; a++) {
											var c = s[a];
											l.prototype[c] || (l.prototype[c] = o.prototype[c])
										}

										function l(e) {
											if (!(this instanceof l)) return new l(e);
											i.call(this, e), o.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", u)))
										}

										function u() {
											this._writableState.ended || r.nextTick(d, this)
										}

										function d(e) {
											e.end()
										}
										Object.defineProperty(l.prototype, "writableHighWaterMark", {
											enumerable: !1,
											get: function() {
												return this._writableState.highWaterMark
											}
										}), Object.defineProperty(l.prototype, "writableBuffer", {
											enumerable: !1,
											get: function() {
												return this._writableState && this._writableState.getBuffer()
											}
										}), Object.defineProperty(l.prototype, "writableLength", {
											enumerable: !1,
											get: function() {
												return this._writableState.length
											}
										}), Object.defineProperty(l.prototype, "destroyed", {
											enumerable: !1,
											get: function() {
												return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed)
											},
											set: function(e) {
												void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e)
											}
										})
									}).call(this)
								}).call(this, e("_process"))
							}, {
								"./_stream_readable": 54,
								"./_stream_writable": 56,
								_process: 238,
								inherits: 147
							}],
							53: [function(e, t, r) {
								"use strict";
								t.exports = i;
								var n = e("./_stream_transform");

								function i(e) {
									if (!(this instanceof i)) return new i(e);
									n.call(this, e)
								}
								e("inherits")(i, n), i.prototype._transform = function(e, t, r) {
									r(null, e)
								}
							}, {
								"./_stream_transform": 55,
								inherits: 147
							}],
							54: [function(t, r, n) {
								(function(e, n) {
									(function() {
										"use strict";
										var i;
										r.exports = T, T.ReadableState = k;
										t("events").EventEmitter;
										var o = function(e, t) {
												return e.listeners(t).length
											},
											s = t("./internal/streams/stream"),
											a = t("buffer").Buffer,
											c = n.Uint8Array || function() {};
										var l, u = t("util");
										l = u && u.debuglog ? u.debuglog("stream") : function() {};
										var d, h, f, p = t("./internal/streams/buffer_list"),
											v = t("./internal/streams/destroy"),
											g = t("./internal/streams/state").getHighWaterMark,
											m = t("../errors").codes,
											y = m.ERR_INVALID_ARG_TYPE,
											b = m.ERR_STREAM_PUSH_AFTER_EOF,
											_ = m.ERR_METHOD_NOT_IMPLEMENTED,
											w = m.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
										t("inherits")(T, s);
										var S = v.errorOrDestroy,
											E = ["error", "close", "destroy", "pause", "resume"];

										function k(e, r, n) {
											i = i || t("./_stream_duplex"), e = e || {}, "boolean" != typeof n && (n = r instanceof i), this.objectMode = !!e.objectMode, n && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = g(this, e, "readableHighWaterMark", n), this.buffer = new p, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== e.emitClose, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (d || (d = t("string_decoder/").StringDecoder), this.decoder = new d(e.encoding), this.encoding = e.encoding)
										}

										function T(e) {
											if (i = i || t("./_stream_duplex"), !(this instanceof T)) return new T(e);
											var r = this instanceof i;
											this._readableState = new k(e, this, r), this.readable = !0, e && ("function" == typeof e.read && (this._read = e.read), "function" == typeof e.destroy && (this._destroy = e.destroy)), s.call(this)
										}

										function I(e, t, r, n, i) {
											l("readableAddChunk", t);
											var o, s = e._readableState;
											if (null === t) s.reading = !1,
												function(e, t) {
													if (l("onEofChunk"), t.ended) return;
													if (t.decoder) {
														var r = t.decoder.end();
														r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length)
													}
													t.ended = !0, t.sync ? x(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, O(e)))
												}(e, s);
											else if (i || (o = function(e, t) {
													var r;
													n = t, a.isBuffer(n) || n instanceof c || "string" == typeof t || void 0 === t || e.objectMode || (r = new y("chunk", ["string", "Buffer", "Uint8Array"], t));
													var n;
													return r
												}(s, t)), o) S(e, o);
											else if (s.objectMode || t && t.length > 0)
												if ("string" == typeof t || s.objectMode || Object.getPrototypeOf(t) === a.prototype || (t = function(e) {
														return a.from(e)
													}(t)), n) s.endEmitted ? S(e, new w) : R(e, s, t, !0);
												else if (s.ended) S(e, new b);
											else {
												if (s.destroyed) return !1;
												s.reading = !1, s.decoder && !r ? (t = s.decoder.write(t), s.objectMode || 0 !== t.length ? R(e, s, t, !1) : A(e, s)) : R(e, s, t, !1)
											} else n || (s.reading = !1, A(e, s));
											return !s.ended && (s.length < s.highWaterMark || 0 === s.length)
										}

										function R(e, t, r, n) {
											t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && x(e)), A(e, t)
										}
										Object.defineProperty(T.prototype, "destroyed", {
											enumerable: !1,
											get: function() {
												return void 0 !== this._readableState && this._readableState.destroyed
											},
											set: function(e) {
												this._readableState && (this._readableState.destroyed = e)
											}
										}), T.prototype.destroy = v.destroy, T.prototype._undestroy = v.undestroy, T.prototype._destroy = function(e, t) {
											t(e)
										}, T.prototype.push = function(e, t) {
											var r, n = this._readableState;
											return n.objectMode ? r = !0 : "string" == typeof e && ((t = t || n.defaultEncoding) !== n.encoding && (e = a.from(e, t), t = ""), r = !0), I(this, e, t, !1, r)
										}, T.prototype.unshift = function(e) {
											return I(this, e, null, !0, !1)
										}, T.prototype.isPaused = function() {
											return !1 === this._readableState.flowing
										}, T.prototype.setEncoding = function(e) {
											d || (d = t("string_decoder/").StringDecoder);
											var r = new d(e);
											this._readableState.decoder = r, this._readableState.encoding = this._readableState.decoder.encoding;
											for (var n = this._readableState.buffer.head, i = ""; null !== n;) i += r.write(n.data), n = n.next;
											return this._readableState.buffer.clear(), "" !== i && this._readableState.buffer.push(i), this._readableState.length = i.length, this
										};
										var C = 1073741824;

										function M(e, t) {
											return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = function(e) {
												return e >= C ? e = C : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e
											}(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0))
										}

										function x(t) {
											var r = t._readableState;
											l("emitReadable", r.needReadable, r.emittedReadable), r.needReadable = !1, r.emittedReadable || (l("emitReadable", r.flowing), r.emittedReadable = !0, e.nextTick(O, t))
										}

										function O(e) {
											var t = e._readableState;
											l("emitReadable_", t.destroyed, t.length, t.ended), t.destroyed || !t.length && !t.ended || (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, N(e)
										}

										function A(t, r) {
											r.readingMore || (r.readingMore = !0, e.nextTick(P, t, r))
										}

										function P(e, t) {
											for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);) {
												var r = t.length;
												if (l("maybeReadMore read 0"), e.read(0), r === t.length) break
											}
											t.readingMore = !1
										}

										function D(e) {
											var t = e._readableState;
											t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume()
										}

										function j(e) {
											l("readable nexttick read 0"), e.read(0)
										}

										function L(e, t) {
											l("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), N(e), t.flowing && !t.reading && e.read(0)
										}

										function N(e) {
											var t = e._readableState;
											for (l("flow", t.flowing); t.flowing && null !== e.read(););
										}

										function B(e, t) {
											return 0 === t.length ? null : (t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (r = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r);
											var r
										}

										function U(t) {
											var r = t._readableState;
											l("endReadable", r.endEmitted), r.endEmitted || (r.ended = !0, e.nextTick(F, r, t))
										}

										function F(e, t) {
											if (l("endReadableNT", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
												var r = t._writableState;
												(!r || r.autoDestroy && r.finished) && t.destroy()
											}
										}

										function $(e, t) {
											for (var r = 0, n = e.length; r < n; r++)
												if (e[r] === t) return r;
											return -1
										}
										T.prototype.read = function(e) {
											l("read", e), e = parseInt(e, 10);
											var t = this._readableState,
												r = e;
											if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 !== t.highWaterMark ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return l("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? U(this) : x(this), null;
											if (0 === (e = M(e, t)) && t.ended) return 0 === t.length && U(this), null;
											var n, i = t.needReadable;
											return l("need readable", i), (0 === t.length || t.length - e < t.highWaterMark) && l("length less than watermark", i = !0), t.ended || t.reading ? l("reading or ended", i = !1) : i && (l("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = M(r, t))), null === (n = e > 0 ? B(e, t) : null) ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (t.ended || (t.needReadable = !0), r !== e && t.ended && U(this)), null !== n && this.emit("data", n), n
										}, T.prototype._read = function(e) {
											S(this, new _("_read()"))
										}, T.prototype.pipe = function(t, r) {
											var n = this,
												i = this._readableState;
											switch (i.pipesCount) {
												case 0:
													i.pipes = t;
													break;
												case 1:
													i.pipes = [i.pipes, t];
													break;
												default:
													i.pipes.push(t)
											}
											i.pipesCount += 1, l("pipe count=%d opts=%j", i.pipesCount, r);
											var s = (!r || !1 !== r.end) && t !== e.stdout && t !== e.stderr ? c : g;

											function a(e, r) {
												l("onunpipe"), e === n && r && !1 === r.hasUnpiped && (r.hasUnpiped = !0, l("cleanup"), t.removeListener("close", p), t.removeListener("finish", v), t.removeListener("drain", u), t.removeListener("error", f), t.removeListener("unpipe", a), n.removeListener("end", c), n.removeListener("end", g), n.removeListener("data", h), d = !0, !i.awaitDrain || t._writableState && !t._writableState.needDrain || u())
											}

											function c() {
												l("onend"), t.end()
											}
											i.endEmitted ? e.nextTick(s) : n.once("end", s), t.on("unpipe", a);
											var u = function(e) {
												return function() {
													var t = e._readableState;
													l("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && o(e, "data") && (t.flowing = !0, N(e))
												}
											}(n);
											t.on("drain", u);
											var d = !1;

											function h(e) {
												l("ondata");
												var r = t.write(e);
												l("dest.write", r), !1 === r && ((1 === i.pipesCount && i.pipes === t || i.pipesCount > 1 && -1 !== $(i.pipes, t)) && !d && (l("false write response, pause", i.awaitDrain), i.awaitDrain++), n.pause())
											}

											function f(e) {
												l("onerror", e), g(), t.removeListener("error", f), 0 === o(t, "error") && S(t, e)
											}

											function p() {
												t.removeListener("finish", v), g()
											}

											function v() {
												l("onfinish"), t.removeListener("close", p), g()
											}

											function g() {
												l("unpipe"), n.unpipe(t)
											}
											return n.on("data", h),
												function(e, t, r) {
													if ("function" == typeof e.prependListener) return e.prependListener(t, r);
													e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]] : e.on(t, r)
												}(t, "error", f), t.once("close", p), t.once("finish", v), t.emit("pipe", n), i.flowing || (l("pipe resume"), n.resume()), t
										}, T.prototype.unpipe = function(e) {
											var t = this._readableState,
												r = {
													hasUnpiped: !1
												};
											if (0 === t.pipesCount) return this;
											if (1 === t.pipesCount) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r), this);
											if (!e) {
												var n = t.pipes,
													i = t.pipesCount;
												t.pipes = null, t.pipesCount = 0, t.flowing = !1;
												for (var o = 0; o < i; o++) n[o].emit("unpipe", this, {
													hasUnpiped: !1
												});
												return this
											}
											var s = $(t.pipes, e);
											return -1 === s ? this : (t.pipes.splice(s, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this)
										}, T.prototype.on = function(t, r) {
											var n = s.prototype.on.call(this, t, r),
												i = this._readableState;
											return "data" === t ? (i.readableListening = this.listenerCount("readable") > 0, !1 !== i.flowing && this.resume()) : "readable" === t && (i.endEmitted || i.readableListening || (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, l("on readable", i.length, i.reading), i.length ? x(this) : i.reading || e.nextTick(j, this))), n
										}, T.prototype.addListener = T.prototype.on, T.prototype.removeListener = function(t, r) {
											var n = s.prototype.removeListener.call(this, t, r);
											return "readable" === t && e.nextTick(D, this), n
										}, T.prototype.removeAllListeners = function(t) {
											var r = s.prototype.removeAllListeners.apply(this, arguments);
											return "readable" !== t && void 0 !== t || e.nextTick(D, this), r
										}, T.prototype.resume = function() {
											var t = this._readableState;
											return t.flowing || (l("resume"), t.flowing = !t.readableListening, function(t, r) {
												r.resumeScheduled || (r.resumeScheduled = !0, e.nextTick(L, t, r))
											}(this, t)), t.paused = !1, this
										}, T.prototype.pause = function() {
											return l("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this
										}, T.prototype.wrap = function(e) {
											var t = this,
												r = this._readableState,
												n = !1;
											for (var i in e.on("end", (function() {
													if (l("wrapped end"), r.decoder && !r.ended) {
														var e = r.decoder.end();
														e && e.length && t.push(e)
													}
													t.push(null)
												})), e.on("data", (function(i) {
													(l("wrapped data"), r.decoder && (i = r.decoder.write(i)), r.objectMode && null == i) || (r.objectMode || i && i.length) && (t.push(i) || (n = !0, e.pause()))
												})), e) void 0 === this[i] && "function" == typeof e[i] && (this[i] = function(t) {
												return function() {
													return e[t].apply(e, arguments)
												}
											}(i));
											for (var o = 0; o < E.length; o++) e.on(E[o], this.emit.bind(this, E[o]));
											return this._read = function(t) {
												l("wrapped _read", t), n && (n = !1, e.resume())
											}, this
										}, "function" == typeof Symbol && (T.prototype[Symbol.asyncIterator] = function() {
											return void 0 === h && (h = t("./internal/streams/async_iterator")), h(this)
										}), Object.defineProperty(T.prototype, "readableHighWaterMark", {
											enumerable: !1,
											get: function() {
												return this._readableState.highWaterMark
											}
										}), Object.defineProperty(T.prototype, "readableBuffer", {
											enumerable: !1,
											get: function() {
												return this._readableState && this._readableState.buffer
											}
										}), Object.defineProperty(T.prototype, "readableFlowing", {
											enumerable: !1,
											get: function() {
												return this._readableState.flowing
											},
											set: function(e) {
												this._readableState && (this._readableState.flowing = e)
											}
										}), T._fromList = B, Object.defineProperty(T.prototype, "readableLength", {
											enumerable: !1,
											get: function() {
												return this._readableState.length
											}
										}), "function" == typeof Symbol && (T.from = function(e, r) {
											return void 0 === f && (f = t("./internal/streams/from")), f(T, e, r)
										})
									}).call(this)
								}).call(this, t("_process"), void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"../errors": 51,
								"./_stream_duplex": 52,
								"./internal/streams/async_iterator": 57,
								"./internal/streams/buffer_list": 58,
								"./internal/streams/destroy": 59,
								"./internal/streams/from": 61,
								"./internal/streams/state": 63,
								"./internal/streams/stream": 64,
								_process: 238,
								buffer: 69,
								events: 106,
								inherits: 147,
								"string_decoder/": 280,
								util: 21
							}],
							55: [function(e, t, r) {
								"use strict";
								t.exports = u;
								var n = e("../errors").codes,
									i = n.ERR_METHOD_NOT_IMPLEMENTED,
									o = n.ERR_MULTIPLE_CALLBACK,
									s = n.ERR_TRANSFORM_ALREADY_TRANSFORMING,
									a = n.ERR_TRANSFORM_WITH_LENGTH_0,
									c = e("./_stream_duplex");

								function l(e, t) {
									var r = this._transformState;
									r.transforming = !1;
									var n = r.writecb;
									if (null === n) return this.emit("error", new o);
									r.writechunk = null, r.writecb = null, null != t && this.push(t), n(e);
									var i = this._readableState;
									i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
								}

								function u(e) {
									if (!(this instanceof u)) return new u(e);
									c.call(this, e), this._transformState = {
										afterTransform: l.bind(this),
										needTransform: !1,
										transforming: !1,
										writecb: null,
										writechunk: null,
										writeencoding: null
									}, this._readableState.needReadable = !0, this._readableState.sync = !1, e && ("function" == typeof e.transform && (this._transform = e.transform), "function" == typeof e.flush && (this._flush = e.flush)), this.on("prefinish", d)
								}

								function d() {
									var e = this;
									"function" != typeof this._flush || this._readableState.destroyed ? h(this, null, null) : this._flush((function(t, r) {
										h(e, t, r)
									}))
								}

								function h(e, t, r) {
									if (t) return e.emit("error", t);
									if (null != r && e.push(r), e._writableState.length) throw new a;
									if (e._transformState.transforming) throw new s;
									return e.push(null)
								}
								e("inherits")(u, c), u.prototype.push = function(e, t) {
									return this._transformState.needTransform = !1, c.prototype.push.call(this, e, t)
								}, u.prototype._transform = function(e, t, r) {
									r(new i("_transform()"))
								}, u.prototype._write = function(e, t, r) {
									var n = this._transformState;
									if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
										var i = this._readableState;
										(n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
									}
								}, u.prototype._read = function(e) {
									var t = this._transformState;
									null === t.writechunk || t.transforming ? t.needTransform = !0 : (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform))
								}, u.prototype._destroy = function(e, t) {
									c.prototype._destroy.call(this, e, (function(e) {
										t(e)
									}))
								}
							}, {
								"../errors": 51,
								"./_stream_duplex": 52,
								inherits: 147
							}],
							56: [function(t, r, n) {
								(function(e, n) {
									(function() {
										"use strict";

										function i(e) {
											var t = this;
											this.next = null, this.entry = null, this.finish = function() {
												! function(e, t, r) {
													var n = e.entry;
													e.entry = null;
													for (; n;) {
														var i = n.callback;
														t.pendingcb--, i(r), n = n.next
													}
													t.corkedRequestsFree.next = e
												}(t, e)
											}
										}
										var o;
										r.exports = T, T.WritableState = k;
										var s = {
												deprecate: t("util-deprecate")
											},
											a = t("./internal/streams/stream"),
											c = t("buffer").Buffer,
											l = n.Uint8Array || function() {};
										var u, d = t("./internal/streams/destroy"),
											h = t("./internal/streams/state").getHighWaterMark,
											f = t("../errors").codes,
											p = f.ERR_INVALID_ARG_TYPE,
											v = f.ERR_METHOD_NOT_IMPLEMENTED,
											g = f.ERR_MULTIPLE_CALLBACK,
											m = f.ERR_STREAM_CANNOT_PIPE,
											y = f.ERR_STREAM_DESTROYED,
											b = f.ERR_STREAM_NULL_VALUES,
											_ = f.ERR_STREAM_WRITE_AFTER_END,
											w = f.ERR_UNKNOWN_ENCODING,
											S = d.errorOrDestroy;

										function E() {}

										function k(r, n, s) {
											o = o || t("./_stream_duplex"), r = r || {}, "boolean" != typeof s && (s = n instanceof o), this.objectMode = !!r.objectMode, s && (this.objectMode = this.objectMode || !!r.writableObjectMode), this.highWaterMark = h(this, r, "writableHighWaterMark", s), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
											var a = !1 === r.decodeStrings;
											this.decodeStrings = !a, this.defaultEncoding = r.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(t) {
												! function(t, r) {
													var n = t._writableState,
														i = n.sync,
														o = n.writecb;
													if ("function" != typeof o) throw new g;
													if (function(e) {
															e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0
														}(n), r) ! function(t, r, n, i, o) {
														--r.pendingcb, n ? (e.nextTick(o, i), e.nextTick(O, t, r), t._writableState.errorEmitted = !0, S(t, i)) : (o(i), t._writableState.errorEmitted = !0, S(t, i), O(t, r))
													}(t, n, i, r, o);
													else {
														var s = M(n) || t.destroyed;
														s || n.corked || n.bufferProcessing || !n.bufferedRequest || C(t, n), i ? e.nextTick(R, t, n, s, o) : R(t, n, s, o)
													}
												}(n, t)
											}, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== r.emitClose, this.autoDestroy = !!r.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new i(this)
										}

										function T(e) {
											var r = this instanceof(o = o || t("./_stream_duplex"));
											if (!r && !u.call(T, this)) return new T(e);
											this._writableState = new k(e, this, r), this.writable = !0, e && ("function" == typeof e.write && (this._write = e.write), "function" == typeof e.writev && (this._writev = e.writev), "function" == typeof e.destroy && (this._destroy = e.destroy), "function" == typeof e.final && (this._final = e.final)), a.call(this)
										}

										function I(e, t, r, n, i, o, s) {
											t.writelen = n, t.writecb = s, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new y("write")) : r ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = !1
										}

										function R(e, t, r, n) {
											r || function(e, t) {
												0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"))
											}(e, t), t.pendingcb--, n(), O(e, t)
										}

										function C(e, t) {
											t.bufferProcessing = !0;
											var r = t.bufferedRequest;
											if (e._writev && r && r.next) {
												var n = t.bufferedRequestCount,
													o = new Array(n),
													s = t.corkedRequestsFree;
												s.entry = r;
												for (var a = 0, c = !0; r;) o[a] = r, r.isBuf || (c = !1), r = r.next, a += 1;
												o.allBuffers = c, I(e, t, !0, t.length, o, "", s.finish), t.pendingcb++, t.lastBufferedRequest = null, s.next ? (t.corkedRequestsFree = s.next, s.next = null) : t.corkedRequestsFree = new i(t), t.bufferedRequestCount = 0
											} else {
												for (; r;) {
													var l = r.chunk,
														u = r.encoding,
														d = r.callback;
													if (I(e, t, !1, t.objectMode ? 1 : l.length, l, u, d), r = r.next, t.bufferedRequestCount--, t.writing) break
												}
												null === r && (t.lastBufferedRequest = null)
											}
											t.bufferedRequest = r, t.bufferProcessing = !1
										}

										function M(e) {
											return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing
										}

										function x(e, t) {
											e._final((function(r) {
												t.pendingcb--, r && S(e, r), t.prefinished = !0, e.emit("prefinish"), O(e, t)
											}))
										}

										function O(t, r) {
											var n = M(r);
											if (n && (function(t, r) {
													r.prefinished || r.finalCalled || ("function" != typeof t._final || r.destroyed ? (r.prefinished = !0, t.emit("prefinish")) : (r.pendingcb++, r.finalCalled = !0, e.nextTick(x, t, r)))
												}(t, r), 0 === r.pendingcb && (r.finished = !0, t.emit("finish"), r.autoDestroy))) {
												var i = t._readableState;
												(!i || i.autoDestroy && i.endEmitted) && t.destroy()
											}
											return n
										}
										t("inherits")(T, a), k.prototype.getBuffer = function() {
												for (var e = this.bufferedRequest, t = []; e;) t.push(e), e = e.next;
												return t
											},
											function() {
												try {
													Object.defineProperty(k.prototype, "buffer", {
														get: s.deprecate((function() {
															return this.getBuffer()
														}), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
													})
												} catch (e) {}
											}(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (u = Function.prototype[Symbol.hasInstance], Object.defineProperty(T, Symbol.hasInstance, {
												value: function(e) {
													return !!u.call(this, e) || this === T && (e && e._writableState instanceof k)
												}
											})) : u = function(e) {
												return e instanceof this
											}, T.prototype.pipe = function() {
												S(this, new m)
											}, T.prototype.write = function(t, r, n) {
												var i, o = this._writableState,
													s = !1,
													a = !o.objectMode && (i = t, c.isBuffer(i) || i instanceof l);
												return a && !c.isBuffer(t) && (t = function(e) {
													return c.from(e)
												}(t)), "function" == typeof r && (n = r, r = null), a ? r = "buffer" : r || (r = o.defaultEncoding), "function" != typeof n && (n = E), o.ending ? function(t, r) {
													var n = new _;
													S(t, n), e.nextTick(r, n)
												}(this, n) : (a || function(t, r, n, i) {
													var o;
													return null === n ? o = new b : "string" == typeof n || r.objectMode || (o = new p("chunk", ["string", "Buffer"], n)), !o || (S(t, o), e.nextTick(i, o), !1)
												}(this, o, t, n)) && (o.pendingcb++, s = function(e, t, r, n, i, o) {
													if (!r) {
														var s = function(e, t, r) {
															e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = c.from(t, r));
															return t
														}(t, n, i);
														n !== s && (r = !0, i = "buffer", n = s)
													}
													var a = t.objectMode ? 1 : n.length;
													t.length += a;
													var l = t.length < t.highWaterMark;
													l || (t.needDrain = !0);
													if (t.writing || t.corked) {
														var u = t.lastBufferedRequest;
														t.lastBufferedRequest = {
															chunk: n,
															encoding: i,
															isBuf: r,
															callback: o,
															next: null
														}, u ? u.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1
													} else I(e, t, !1, a, n, i, o);
													return l
												}(this, o, a, t, r, n)), s
											}, T.prototype.cork = function() {
												this._writableState.corked++
											}, T.prototype.uncork = function() {
												var e = this._writableState;
												e.corked && (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || C(this, e))
											}, T.prototype.setDefaultEncoding = function(e) {
												if ("string" == typeof e && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new w(e);
												return this._writableState.defaultEncoding = e, this
											}, Object.defineProperty(T.prototype, "writableBuffer", {
												enumerable: !1,
												get: function() {
													return this._writableState && this._writableState.getBuffer()
												}
											}), Object.defineProperty(T.prototype, "writableHighWaterMark", {
												enumerable: !1,
												get: function() {
													return this._writableState.highWaterMark
												}
											}), T.prototype._write = function(e, t, r) {
												r(new v("_write()"))
											}, T.prototype._writev = null, T.prototype.end = function(t, r, n) {
												var i = this._writableState;
												return "function" == typeof t ? (n = t, t = null, r = null) : "function" == typeof r && (n = r, r = null), null != t && this.write(t, r), i.corked && (i.corked = 1, this.uncork()), i.ending || function(t, r, n) {
													r.ending = !0, O(t, r), n && (r.finished ? e.nextTick(n) : t.once("finish", n));
													r.ended = !0, t.writable = !1
												}(this, i, n), this
											}, Object.defineProperty(T.prototype, "writableLength", {
												enumerable: !1,
												get: function() {
													return this._writableState.length
												}
											}), Object.defineProperty(T.prototype, "destroyed", {
												enumerable: !1,
												get: function() {
													return void 0 !== this._writableState && this._writableState.destroyed
												},
												set: function(e) {
													this._writableState && (this._writableState.destroyed = e)
												}
											}), T.prototype.destroy = d.destroy, T.prototype._undestroy = d.undestroy, T.prototype._destroy = function(e, t) {
												t(e)
											}
									}).call(this)
								}).call(this, t("_process"), void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"../errors": 51,
								"./_stream_duplex": 52,
								"./internal/streams/destroy": 59,
								"./internal/streams/state": 63,
								"./internal/streams/stream": 64,
								_process: 238,
								buffer: 69,
								inherits: 147,
								"util-deprecate": 283
							}],
							57: [function(e, t, r) {
								(function(r) {
									(function() {
										"use strict";
										var n;

										function i(e, t, r) {
											return t in e ? Object.defineProperty(e, t, {
												value: r,
												enumerable: !0,
												configurable: !0,
												writable: !0
											}) : e[t] = r, e
										}
										var o = e("./end-of-stream"),
											s = Symbol("lastResolve"),
											a = Symbol("lastReject"),
											c = Symbol("error"),
											l = Symbol("ended"),
											u = Symbol("lastPromise"),
											d = Symbol("handlePromise"),
											h = Symbol("stream");

										function f(e, t) {
											return {
												value: e,
												done: t
											}
										}

										function p(e) {
											var t = e[s];
											if (null !== t) {
												var r = e[h].read();
												null !== r && (e[u] = null, e[s] = null, e[a] = null, t(f(r, !1)))
											}
										}

										function v(e) {
											r.nextTick(p, e)
										}
										var g = Object.getPrototypeOf((function() {})),
											m = Object.setPrototypeOf((i(n = {
												get stream() {
													return this[h]
												},
												next: function() {
													var e = this,
														t = this[c];
													if (null !== t) return Promise.reject(t);
													if (this[l]) return Promise.resolve(f(void 0, !0));
													if (this[h].destroyed) return new Promise((function(t, n) {
														r.nextTick((function() {
															e[c] ? n(e[c]) : t(f(void 0, !0))
														}))
													}));
													var n, i = this[u];
													if (i) n = new Promise(function(e, t) {
														return function(r, n) {
															e.then((function() {
																t[l] ? r(f(void 0, !0)) : t[d](r, n)
															}), n)
														}
													}(i, this));
													else {
														var o = this[h].read();
														if (null !== o) return Promise.resolve(f(o, !1));
														n = new Promise(this[d])
													}
													return this[u] = n, n
												}
											}, Symbol.asyncIterator, (function() {
												return this
											})), i(n, "return", (function() {
												var e = this;
												return new Promise((function(t, r) {
													e[h].destroy(null, (function(e) {
														e ? r(e) : t(f(void 0, !0))
													}))
												}))
											})), n), g);
										t.exports = function(e) {
											var t, r = Object.create(m, (i(t = {}, h, {
												value: e,
												writable: !0
											}), i(t, s, {
												value: null,
												writable: !0
											}), i(t, a, {
												value: null,
												writable: !0
											}), i(t, c, {
												value: null,
												writable: !0
											}), i(t, l, {
												value: e._readableState.endEmitted,
												writable: !0
											}), i(t, d, {
												value: function(e, t) {
													var n = r[h].read();
													n ? (r[u] = null, r[s] = null, r[a] = null, e(f(n, !1))) : (r[s] = e, r[a] = t)
												},
												writable: !0
											}), t));
											return r[u] = null, o(e, (function(e) {
												if (e && "ERR_STREAM_PREMATURE_CLOSE" !== e.code) {
													var t = r[a];
													return null !== t && (r[u] = null, r[s] = null, r[a] = null, t(e)), void(r[c] = e)
												}
												var n = r[s];
												null !== n && (r[u] = null, r[s] = null, r[a] = null, n(f(void 0, !0))), r[l] = !0
											})), e.on("readable", v.bind(null, r)), r
										}
									}).call(this)
								}).call(this, e("_process"))
							}, {
								"./end-of-stream": 60,
								_process: 238
							}],
							58: [function(e, t, r) {
								"use strict";

								function n(e, t) {
									var r = Object.keys(e);
									if (Object.getOwnPropertySymbols) {
										var n = Object.getOwnPropertySymbols(e);
										t && (n = n.filter((function(t) {
											return Object.getOwnPropertyDescriptor(e, t).enumerable
										}))), r.push.apply(r, n)
									}
									return r
								}

								function i(e, t, r) {
									return t in e ? Object.defineProperty(e, t, {
										value: r,
										enumerable: !0,
										configurable: !0,
										writable: !0
									}) : e[t] = r, e
								}

								function o(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								var s = e("buffer").Buffer,
									a = e("util").inspect,
									c = a && a.custom || "inspect";
								t.exports = function() {
									function e() {
										! function(e, t) {
											if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
										}(this, e), this.head = null, this.tail = null, this.length = 0
									}
									var t, r, l;
									return t = e, (r = [{
										key: "push",
										value: function(e) {
											var t = {
												data: e,
												next: null
											};
											this.length > 0 ? this.tail.next = t : this.head = t, this.tail = t, ++this.length
										}
									}, {
										key: "unshift",
										value: function(e) {
											var t = {
												data: e,
												next: this.head
											};
											0 === this.length && (this.tail = t), this.head = t, ++this.length
										}
									}, {
										key: "shift",
										value: function() {
											if (0 !== this.length) {
												var e = this.head.data;
												return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e
											}
										}
									}, {
										key: "clear",
										value: function() {
											this.head = this.tail = null, this.length = 0
										}
									}, {
										key: "join",
										value: function(e) {
											if (0 === this.length) return "";
											for (var t = this.head, r = "" + t.data; t = t.next;) r += e + t.data;
											return r
										}
									}, {
										key: "concat",
										value: function(e) {
											if (0 === this.length) return s.alloc(0);
											for (var t, r, n, i = s.allocUnsafe(e >>> 0), o = this.head, a = 0; o;) t = o.data, r = i, n = a, s.prototype.copy.call(t, r, n), a += o.data.length, o = o.next;
											return i
										}
									}, {
										key: "consume",
										value: function(e, t) {
											var r;
											return e < this.head.data.length ? (r = this.head.data.slice(0, e), this.head.data = this.head.data.slice(e)) : r = e === this.head.data.length ? this.shift() : t ? this._getString(e) : this._getBuffer(e), r
										}
									}, {
										key: "first",
										value: function() {
											return this.head.data
										}
									}, {
										key: "_getString",
										value: function(e) {
											var t = this.head,
												r = 1,
												n = t.data;
											for (e -= n.length; t = t.next;) {
												var i = t.data,
													o = e > i.length ? i.length : e;
												if (o === i.length ? n += i : n += i.slice(0, e), 0 == (e -= o)) {
													o === i.length ? (++r, t.next ? this.head = t.next : this.head = this.tail = null) : (this.head = t, t.data = i.slice(o));
													break
												}++r
											}
											return this.length -= r, n
										}
									}, {
										key: "_getBuffer",
										value: function(e) {
											var t = s.allocUnsafe(e),
												r = this.head,
												n = 1;
											for (r.data.copy(t), e -= r.data.length; r = r.next;) {
												var i = r.data,
													o = e > i.length ? i.length : e;
												if (i.copy(t, t.length - e, 0, o), 0 == (e -= o)) {
													o === i.length ? (++n, r.next ? this.head = r.next : this.head = this.tail = null) : (this.head = r, r.data = i.slice(o));
													break
												}++n
											}
											return this.length -= n, t
										}
									}, {
										key: c,
										value: function(e, t) {
											return a(this, function(e) {
												for (var t = 1; t < arguments.length; t++) {
													var r = null != arguments[t] ? arguments[t] : {};
													t % 2 ? n(Object(r), !0).forEach((function(t) {
														i(e, t, r[t])
													})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : n(Object(r)).forEach((function(t) {
														Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
													}))
												}
												return e
											}({}, t, {
												depth: 0,
												customInspect: !1
											}))
										}
									}]) && o(t.prototype, r), l && o(t, l), e
								}()
							}, {
								buffer: 69,
								util: 21
							}],
							59: [function(e, t, r) {
								(function(e) {
									(function() {
										"use strict";

										function r(e, t) {
											i(e, t), n(e)
										}

										function n(e) {
											e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close")
										}

										function i(e, t) {
											e.emit("error", t)
										}
										t.exports = {
											destroy: function(t, o) {
												var s = this,
													a = this._readableState && this._readableState.destroyed,
													c = this._writableState && this._writableState.destroyed;
												return a || c ? (o ? o(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(i, this, t)) : e.nextTick(i, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, (function(t) {
													!o && t ? s._writableState ? s._writableState.errorEmitted ? e.nextTick(n, s) : (s._writableState.errorEmitted = !0, e.nextTick(r, s, t)) : e.nextTick(r, s, t) : o ? (e.nextTick(n, s), o(t)) : e.nextTick(n, s)
												})), this)
											},
											undestroy: function() {
												this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
											},
											errorOrDestroy: function(e, t) {
												var r = e._readableState,
													n = e._writableState;
												r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t)
											}
										}
									}).call(this)
								}).call(this, e("_process"))
							}, {
								_process: 238
							}],
							60: [function(e, t, r) {
								"use strict";
								var n = e("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;

								function i() {}
								t.exports = function e(t, r, o) {
									if ("function" == typeof r) return e(t, null, r);
									r || (r = {}), o = function(e) {
										var t = !1;
										return function() {
											if (!t) {
												t = !0;
												for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++) n[i] = arguments[i];
												e.apply(this, n)
											}
										}
									}(o || i);
									var s = r.readable || !1 !== r.readable && t.readable,
										a = r.writable || !1 !== r.writable && t.writable,
										c = function() {
											t.writable || u()
										},
										l = t._writableState && t._writableState.finished,
										u = function() {
											a = !1, l = !0, s || o.call(t)
										},
										d = t._readableState && t._readableState.endEmitted,
										h = function() {
											s = !1, d = !0, a || o.call(t)
										},
										f = function(e) {
											o.call(t, e)
										},
										p = function() {
											var e;
											return s && !d ? (t._readableState && t._readableState.ended || (e = new n), o.call(t, e)) : a && !l ? (t._writableState && t._writableState.ended || (e = new n), o.call(t, e)) : void 0
										},
										v = function() {
											t.req.on("finish", u)
										};
									return ! function(e) {
											return e.setHeader && "function" == typeof e.abort
										}(t) ? a && !t._writableState && (t.on("end", c), t.on("close", c)) : (t.on("complete", u), t.on("abort", p), t.req ? v() : t.on("request", v)), t.on("end", h), t.on("finish", u), !1 !== r.error && t.on("error", f), t.on("close", p),
										function() {
											t.removeListener("complete", u), t.removeListener("abort", p), t.removeListener("request", v), t.req && t.req.removeListener("finish", u), t.removeListener("end", c), t.removeListener("close", c), t.removeListener("finish", u), t.removeListener("end", h), t.removeListener("error", f), t.removeListener("close", p)
										}
								}
							}, {
								"../../../errors": 51
							}],
							61: [function(e, t, r) {
								t.exports = function() {
									throw new Error("Readable.from is not available in the browser")
								}
							}, {}],
							62: [function(e, t, r) {
								"use strict";
								var n;
								var i = e("../../../errors").codes,
									o = i.ERR_MISSING_ARGS,
									s = i.ERR_STREAM_DESTROYED;

								function a(e) {
									if (e) throw e
								}

								function c(e) {
									e()
								}

								function l(e, t) {
									return e.pipe(t)
								}
								t.exports = function() {
									for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];
									var u, d = function(e) {
										return e.length ? "function" != typeof e[e.length - 1] ? a : e.pop() : a
									}(r);
									if (Array.isArray(r[0]) && (r = r[0]), r.length < 2) throw new o("streams");
									var h = r.map((function(t, i) {
										var o = i < r.length - 1;
										return function(t, r, i, o) {
											o = function(e) {
												var t = !1;
												return function() {
													t || (t = !0, e.apply(void 0, arguments))
												}
											}(o);
											var a = !1;
											t.on("close", (function() {
												a = !0
											})), void 0 === n && (n = e("./end-of-stream")), n(t, {
												readable: r,
												writable: i
											}, (function(e) {
												if (e) return o(e);
												a = !0, o()
											}));
											var c = !1;
											return function(e) {
												if (!a && !c) return c = !0,
													function(e) {
														return e.setHeader && "function" == typeof e.abort
													}(t) ? t.abort() : "function" == typeof t.destroy ? t.destroy() : void o(e || new s("pipe"))
											}
										}(t, o, i > 0, (function(e) {
											u || (u = e), e && h.forEach(c), o || (h.forEach(c), d(u))
										}))
									}));
									return r.reduce(l)
								}
							}, {
								"../../../errors": 51,
								"./end-of-stream": 60
							}],
							63: [function(e, t, r) {
								"use strict";
								var n = e("../../../errors").codes.ERR_INVALID_OPT_VALUE;
								t.exports = {
									getHighWaterMark: function(e, t, r, i) {
										var o = function(e, t, r) {
											return null != e.highWaterMark ? e.highWaterMark : t ? e[r] : null
										}(t, i, r);
										if (null != o) {
											if (!isFinite(o) || Math.floor(o) !== o || o < 0) throw new n(i ? r : "highWaterMark", o);
											return Math.floor(o)
										}
										return e.objectMode ? 16 : 16384
									}
								}
							}, {
								"../../../errors": 51
							}],
							64: [function(e, t, r) {
								t.exports = e("events").EventEmitter
							}, {
								events: 106
							}],
							65: [function(e, t, r) {
								(r = t.exports = e("./lib/_stream_readable.js")).Stream = r, r.Readable = r, r.Writable = e("./lib/_stream_writable.js"), r.Duplex = e("./lib/_stream_duplex.js"), r.Transform = e("./lib/_stream_transform.js"), r.PassThrough = e("./lib/_stream_passthrough.js"), r.finished = e("./lib/internal/streams/end-of-stream.js"), r.pipeline = e("./lib/internal/streams/pipeline.js")
							}, {
								"./lib/_stream_duplex.js": 52,
								"./lib/_stream_passthrough.js": 53,
								"./lib/_stream_readable.js": 54,
								"./lib/_stream_transform.js": 55,
								"./lib/_stream_writable.js": 56,
								"./lib/internal/streams/end-of-stream.js": 60,
								"./lib/internal/streams/pipeline.js": 62
							}],
							66: [function(e, t, r) {
								const n = e("base-x");
								t.exports = n("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
							}, {
								"base-x": 67
							}],
							67: [function(e, t, r) {
								"use strict";
								t.exports = function(e) {
									if (e.length >= 255) throw new TypeError("Alphabet too long");
									for (var t = new Uint8Array(256), r = 0; r < t.length; r++) t[r] = 255;
									for (var n = 0; n < e.length; n++) {
										var i = e.charAt(n),
											o = i.charCodeAt(0);
										if (255 !== t[o]) throw new TypeError(i + " is ambiguous");
										t[o] = n
									}
									var s = e.length,
										a = e.charAt(0),
										c = Math.log(s) / Math.log(256),
										l = Math.log(256) / Math.log(s);

									function u(e) {
										if ("string" != typeof e) throw new TypeError("Expected String");
										if (0 === e.length) return new Uint8Array;
										for (var r = 0, n = 0, i = 0; e[r] === a;) n++, r++;
										for (var o = (e.length - r) * c + 1 >>> 0, l = new Uint8Array(o); e[r];) {
											var u = t[e.charCodeAt(r)];
											if (255 === u) return;
											for (var d = 0, h = o - 1;
												(0 !== u || d < i) && -1 !== h; h--, d++) u += s * l[h] >>> 0, l[h] = u % 256 >>> 0, u = u / 256 >>> 0;
											if (0 !== u) throw new Error("Non-zero carry");
											i = d, r++
										}
										for (var f = o - i; f !== o && 0 === l[f];) f++;
										for (var p = new Uint8Array(n + (o - f)), v = n; f !== o;) p[v++] = l[f++];
										return p
									}
									return {
										encode: function(t) {
											if (t instanceof Uint8Array || (ArrayBuffer.isView(t) ? t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : Array.isArray(t) && (t = Uint8Array.from(t))), !(t instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
											if (0 === t.length) return "";
											for (var r = 0, n = 0, i = 0, o = t.length; i !== o && 0 === t[i];) i++, r++;
											for (var c = (o - i) * l + 1 >>> 0, u = new Uint8Array(c); i !== o;) {
												for (var d = t[i], h = 0, f = c - 1;
													(0 !== d || h < n) && -1 !== f; f--, h++) d += 256 * u[f] >>> 0, u[f] = d % s >>> 0, d = d / s >>> 0;
												if (0 !== d) throw new Error("Non-zero carry");
												n = h, i++
											}
											for (var p = c - n; p !== c && 0 === u[p];) p++;
											for (var v = a.repeat(r); p < c; ++p) v += e.charAt(u[p]);
											return v
										},
										decodeUnsafe: u,
										decode: function(e) {
											var t = u(e);
											if (t) return t;
											throw new Error("Non-base" + s + " character")
										}
									}
								}
							}, {}],
							68: [function(e, t, r) {
								(function(e) {
									(function() {
										t.exports = function(t, r) {
											for (var n = Math.min(t.length, r.length), i = new e(n), o = 0; o < n; ++o) i[o] = t[o] ^ r[o];
											return i
										}
									}).call(this)
								}).call(this, e("buffer").Buffer)
							}, {
								buffer: 69
							}],
							69: [function(e, t, r) {
								(function(t) {
									(function() {
										"use strict";
										var t = e("base64-js"),
											n = e("ieee754");
										r.Buffer = s, r.SlowBuffer = function(e) {
											+e != e && (e = 0);
											return s.alloc(+e)
										}, r.INSPECT_MAX_BYTES = 50;
										var i = 2147483647;

										function o(e) {
											if (e > i) throw new RangeError('The value "' + e + '" is invalid for option "size"');
											var t = new Uint8Array(e);
											return t.__proto__ = s.prototype, t
										}

										function s(e, t, r) {
											if ("number" == typeof e) {
												if ("string" == typeof t) throw new TypeError('The "string" argument must be of type string. Received type number');
												return l(e)
											}
											return a(e, t, r)
										}

										function a(e, t, r) {
											if ("string" == typeof e) return function(e, t) {
												"string" == typeof t && "" !== t || (t = "utf8");
												if (!s.isEncoding(t)) throw new TypeError("Unknown encoding: " + t);
												var r = 0 | h(e, t),
													n = o(r),
													i = n.write(e, t);
												i !== r && (n = n.slice(0, i));
												return n
											}(e, t);
											if (ArrayBuffer.isView(e)) return u(e);
											if (null == e) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
											if (F(e, ArrayBuffer) || e && F(e.buffer, ArrayBuffer)) return function(e, t, r) {
												if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds');
												if (e.byteLength < t + (r || 0)) throw new RangeError('"length" is outside of buffer bounds');
												var n;
												n = void 0 === t && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, t) : new Uint8Array(e, t, r);
												return n.__proto__ = s.prototype, n
											}(e, t, r);
											if ("number" == typeof e) throw new TypeError('The "value" argument must not be of type number. Received type number');
											var n = e.valueOf && e.valueOf();
											if (null != n && n !== e) return s.from(n, t, r);
											var i = function(e) {
												if (s.isBuffer(e)) {
													var t = 0 | d(e.length),
														r = o(t);
													return 0 === r.length ? r : (e.copy(r, 0, 0, t), r)
												}
												if (void 0 !== e.length) return "number" != typeof e.length || $(e.length) ? o(0) : u(e);
												if ("Buffer" === e.type && Array.isArray(e.data)) return u(e.data)
											}(e);
											if (i) return i;
											if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e[Symbol.toPrimitive]) return s.from(e[Symbol.toPrimitive]("string"), t, r);
											throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e)
										}

										function c(e) {
											if ("number" != typeof e) throw new TypeError('"size" argument must be of type number');
											if (e < 0) throw new RangeError('The value "' + e + '" is invalid for option "size"')
										}

										function l(e) {
											return c(e), o(e < 0 ? 0 : 0 | d(e))
										}

										function u(e) {
											for (var t = e.length < 0 ? 0 : 0 | d(e.length), r = o(t), n = 0; n < t; n += 1) r[n] = 255 & e[n];
											return r
										}

										function d(e) {
											if (e >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
											return 0 | e
										}

										function h(e, t) {
											if (s.isBuffer(e)) return e.length;
											if (ArrayBuffer.isView(e) || F(e, ArrayBuffer)) return e.byteLength;
											if ("string" != typeof e) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
											var r = e.length,
												n = arguments.length > 2 && !0 === arguments[2];
											if (!n && 0 === r) return 0;
											for (var i = !1;;) switch (t) {
												case "ascii":
												case "latin1":
												case "binary":
													return r;
												case "utf8":
												case "utf-8":
													return N(e).length;
												case "ucs2":
												case "ucs-2":
												case "utf16le":
												case "utf-16le":
													return 2 * r;
												case "hex":
													return r >>> 1;
												case "base64":
													return B(e).length;
												default:
													if (i) return n ? -1 : N(e).length;
													t = ("" + t).toLowerCase(), i = !0
											}
										}

										function f(e, t, r) {
											var n = !1;
											if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
											if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return "";
											if ((r >>>= 0) <= (t >>>= 0)) return "";
											for (e || (e = "utf8");;) switch (e) {
												case "hex":
													return C(this, t, r);
												case "utf8":
												case "utf-8":
													return k(this, t, r);
												case "ascii":
													return I(this, t, r);
												case "latin1":
												case "binary":
													return R(this, t, r);
												case "base64":
													return E(this, t, r);
												case "ucs2":
												case "ucs-2":
												case "utf16le":
												case "utf-16le":
													return M(this, t, r);
												default:
													if (n) throw new TypeError("Unknown encoding: " + e);
													e = (e + "").toLowerCase(), n = !0
											}
										}

										function p(e, t, r) {
											var n = e[t];
											e[t] = e[r], e[r] = n
										}

										function v(e, t, r, n, i) {
											if (0 === e.length) return -1;
											if ("string" == typeof r ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), $(r = +r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
												if (i) return -1;
												r = e.length - 1
											} else if (r < 0) {
												if (!i) return -1;
												r = 0
											}
											if ("string" == typeof t && (t = s.from(t, n)), s.isBuffer(t)) return 0 === t.length ? -1 : g(e, t, r, n, i);
											if ("number" == typeof t) return t &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : g(e, [t], r, n, i);
											throw new TypeError("val must be string, number or Buffer")
										}

										function g(e, t, r, n, i) {
											var o, s = 1,
												a = e.length,
												c = t.length;
											if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
												if (e.length < 2 || t.length < 2) return -1;
												s = 2, a /= 2, c /= 2, r /= 2
											}

											function l(e, t) {
												return 1 === s ? e[t] : e.readUInt16BE(t * s)
											}
											if (i) {
												var u = -1;
												for (o = r; o < a; o++)
													if (l(e, o) === l(t, -1 === u ? 0 : o - u)) {
														if (-1 === u && (u = o), o - u + 1 === c) return u * s
													} else -1 !== u && (o -= o - u), u = -1
											} else
												for (r + c > a && (r = a - c), o = r; o >= 0; o--) {
													for (var d = !0, h = 0; h < c; h++)
														if (l(e, o + h) !== l(t, h)) {
															d = !1;
															break
														} if (d) return o
												}
											return -1
										}

										function m(e, t, r, n) {
											r = Number(r) || 0;
											var i = e.length - r;
											n ? (n = Number(n)) > i && (n = i) : n = i;
											var o = t.length;
											n > o / 2 && (n = o / 2);
											for (var s = 0; s < n; ++s) {
												var a = parseInt(t.substr(2 * s, 2), 16);
												if ($(a)) return s;
												e[r + s] = a
											}
											return s
										}

										function y(e, t, r, n) {
											return U(N(t, e.length - r), e, r, n)
										}

										function b(e, t, r, n) {
											return U(function(e) {
												for (var t = [], r = 0; r < e.length; ++r) t.push(255 & e.charCodeAt(r));
												return t
											}(t), e, r, n)
										}

										function _(e, t, r, n) {
											return b(e, t, r, n)
										}

										function w(e, t, r, n) {
											return U(B(t), e, r, n)
										}

										function S(e, t, r, n) {
											return U(function(e, t) {
												for (var r, n, i, o = [], s = 0; s < e.length && !((t -= 2) < 0); ++s) r = e.charCodeAt(s), n = r >> 8, i = r % 256, o.push(i), o.push(n);
												return o
											}(t, e.length - r), e, r, n)
										}

										function E(e, r, n) {
											return 0 === r && n === e.length ? t.fromByteArray(e) : t.fromByteArray(e.slice(r, n))
										}

										function k(e, t, r) {
											r = Math.min(e.length, r);
											for (var n = [], i = t; i < r;) {
												var o, s, a, c, l = e[i],
													u = null,
													d = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
												if (i + d <= r) switch (d) {
													case 1:
														l < 128 && (u = l);
														break;
													case 2:
														128 == (192 & (o = e[i + 1])) && (c = (31 & l) << 6 | 63 & o) > 127 && (u = c);
														break;
													case 3:
														o = e[i + 1], s = e[i + 2], 128 == (192 & o) && 128 == (192 & s) && (c = (15 & l) << 12 | (63 & o) << 6 | 63 & s) > 2047 && (c < 55296 || c > 57343) && (u = c);
														break;
													case 4:
														o = e[i + 1], s = e[i + 2], a = e[i + 3], 128 == (192 & o) && 128 == (192 & s) && 128 == (192 & a) && (c = (15 & l) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) > 65535 && c < 1114112 && (u = c)
												}
												null === u ? (u = 65533, d = 1) : u > 65535 && (u -= 65536, n.push(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n.push(u), i += d
											}
											return function(e) {
												var t = e.length;
												if (t <= T) return String.fromCharCode.apply(String, e);
												var r = "",
													n = 0;
												for (; n < t;) r += String.fromCharCode.apply(String, e.slice(n, n += T));
												return r
											}(n)
										}
										r.kMaxLength = i, s.TYPED_ARRAY_SUPPORT = function() {
											try {
												var e = new Uint8Array(1);
												return e.__proto__ = {
													__proto__: Uint8Array.prototype,
													foo: function() {
														return 42
													}
												}, 42 === e.foo()
											} catch (t) {
												return !1
											}
										}(), s.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", {
											enumerable: !0,
											get: function() {
												if (s.isBuffer(this)) return this.buffer
											}
										}), Object.defineProperty(s.prototype, "offset", {
											enumerable: !0,
											get: function() {
												if (s.isBuffer(this)) return this.byteOffset
											}
										}), "undefined" != typeof Symbol && null != Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, {
											value: null,
											configurable: !0,
											enumerable: !1,
											writable: !1
										}), s.poolSize = 8192, s.from = function(e, t, r) {
											return a(e, t, r)
										}, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function(e, t, r) {
											return function(e, t, r) {
												return c(e), e <= 0 ? o(e) : void 0 !== t ? "string" == typeof r ? o(e).fill(t, r) : o(e).fill(t) : o(e)
											}(e, t, r)
										}, s.allocUnsafe = function(e) {
											return l(e)
										}, s.allocUnsafeSlow = function(e) {
											return l(e)
										}, s.isBuffer = function(e) {
											return null != e && !0 === e._isBuffer && e !== s.prototype
										}, s.compare = function(e, t) {
											if (F(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), F(t, Uint8Array) && (t = s.from(t, t.offset, t.byteLength)), !s.isBuffer(e) || !s.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
											if (e === t) return 0;
											for (var r = e.length, n = t.length, i = 0, o = Math.min(r, n); i < o; ++i)
												if (e[i] !== t[i]) {
													r = e[i], n = t[i];
													break
												} return r < n ? -1 : n < r ? 1 : 0
										}, s.isEncoding = function(e) {
											switch (String(e).toLowerCase()) {
												case "hex":
												case "utf8":
												case "utf-8":
												case "ascii":
												case "latin1":
												case "binary":
												case "base64":
												case "ucs2":
												case "ucs-2":
												case "utf16le":
												case "utf-16le":
													return !0;
												default:
													return !1
											}
										}, s.concat = function(e, t) {
											if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
											if (0 === e.length) return s.alloc(0);
											var r;
											if (void 0 === t)
												for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
											var n = s.allocUnsafe(t),
												i = 0;
											for (r = 0; r < e.length; ++r) {
												var o = e[r];
												if (F(o, Uint8Array) && (o = s.from(o)), !s.isBuffer(o)) throw new TypeError('"list" argument must be an Array of Buffers');
												o.copy(n, i), i += o.length
											}
											return n
										}, s.byteLength = h, s.prototype._isBuffer = !0, s.prototype.swap16 = function() {
											var e = this.length;
											if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
											for (var t = 0; t < e; t += 2) p(this, t, t + 1);
											return this
										}, s.prototype.swap32 = function() {
											var e = this.length;
											if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
											for (var t = 0; t < e; t += 4) p(this, t, t + 3), p(this, t + 1, t + 2);
											return this
										}, s.prototype.swap64 = function() {
											var e = this.length;
											if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
											for (var t = 0; t < e; t += 8) p(this, t, t + 7), p(this, t + 1, t + 6), p(this, t + 2, t + 5), p(this, t + 3, t + 4);
											return this
										}, s.prototype.toString = function() {
											var e = this.length;
											return 0 === e ? "" : 0 === arguments.length ? k(this, 0, e) : f.apply(this, arguments)
										}, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(e) {
											if (!s.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
											return this === e || 0 === s.compare(this, e)
										}, s.prototype.inspect = function() {
											var e = "",
												t = r.INSPECT_MAX_BYTES;
											return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">"
										}, s.prototype.compare = function(e, t, r, n, i) {
											if (F(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), !s.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
											if (void 0 === t && (t = 0), void 0 === r && (r = e ? e.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), t < 0 || r > e.length || n < 0 || i > this.length) throw new RangeError("out of range index");
											if (n >= i && t >= r) return 0;
											if (n >= i) return -1;
											if (t >= r) return 1;
											if (this === e) return 0;
											for (var o = (i >>>= 0) - (n >>>= 0), a = (r >>>= 0) - (t >>>= 0), c = Math.min(o, a), l = this.slice(n, i), u = e.slice(t, r), d = 0; d < c; ++d)
												if (l[d] !== u[d]) {
													o = l[d], a = u[d];
													break
												} return o < a ? -1 : a < o ? 1 : 0
										}, s.prototype.includes = function(e, t, r) {
											return -1 !== this.indexOf(e, t, r)
										}, s.prototype.indexOf = function(e, t, r) {
											return v(this, e, t, r, !0)
										}, s.prototype.lastIndexOf = function(e, t, r) {
											return v(this, e, t, r, !1)
										}, s.prototype.write = function(e, t, r, n) {
											if (void 0 === t) n = "utf8", r = this.length, t = 0;
											else if (void 0 === r && "string" == typeof t) n = t, r = this.length, t = 0;
											else {
												if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
												t >>>= 0, isFinite(r) ? (r >>>= 0, void 0 === n && (n = "utf8")) : (n = r, r = void 0)
											}
											var i = this.length - t;
											if ((void 0 === r || r > i) && (r = i), e.length > 0 && (r < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
											n || (n = "utf8");
											for (var o = !1;;) switch (n) {
												case "hex":
													return m(this, e, t, r);
												case "utf8":
												case "utf-8":
													return y(this, e, t, r);
												case "ascii":
													return b(this, e, t, r);
												case "latin1":
												case "binary":
													return _(this, e, t, r);
												case "base64":
													return w(this, e, t, r);
												case "ucs2":
												case "ucs-2":
												case "utf16le":
												case "utf-16le":
													return S(this, e, t, r);
												default:
													if (o) throw new TypeError("Unknown encoding: " + n);
													n = ("" + n).toLowerCase(), o = !0
											}
										}, s.prototype.toJSON = function() {
											return {
												type: "Buffer",
												data: Array.prototype.slice.call(this._arr || this, 0)
											}
										};
										var T = 4096;

										function I(e, t, r) {
											var n = "";
											r = Math.min(e.length, r);
											for (var i = t; i < r; ++i) n += String.fromCharCode(127 & e[i]);
											return n
										}

										function R(e, t, r) {
											var n = "";
											r = Math.min(e.length, r);
											for (var i = t; i < r; ++i) n += String.fromCharCode(e[i]);
											return n
										}

										function C(e, t, r) {
											var n = e.length;
											(!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
											for (var i = "", o = t; o < r; ++o) i += L(e[o]);
											return i
										}

										function M(e, t, r) {
											for (var n = e.slice(t, r), i = "", o = 0; o < n.length; o += 2) i += String.fromCharCode(n[o] + 256 * n[o + 1]);
											return i
										}

										function x(e, t, r) {
											if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
											if (e + t > r) throw new RangeError("Trying to access beyond buffer length")
										}

										function O(e, t, r, n, i, o) {
											if (!s.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
											if (t > i || t < o) throw new RangeError('"value" argument is out of bounds');
											if (r + n > e.length) throw new RangeError("Index out of range")
										}

										function A(e, t, r, n, i, o) {
											if (r + n > e.length) throw new RangeError("Index out of range");
											if (r < 0) throw new RangeError("Index out of range")
										}

										function P(e, t, r, i, o) {
											return t = +t, r >>>= 0, o || A(e, 0, r, 4), n.write(e, t, r, i, 23, 4), r + 4
										}

										function D(e, t, r, i, o) {
											return t = +t, r >>>= 0, o || A(e, 0, r, 8), n.write(e, t, r, i, 52, 8), r + 8
										}
										s.prototype.slice = function(e, t) {
											var r = this.length;
											(e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), t < e && (t = e);
											var n = this.subarray(e, t);
											return n.__proto__ = s.prototype, n
										}, s.prototype.readUIntLE = function(e, t, r) {
											e >>>= 0, t >>>= 0, r || x(e, t, this.length);
											for (var n = this[e], i = 1, o = 0; ++o < t && (i *= 256);) n += this[e + o] * i;
											return n
										}, s.prototype.readUIntBE = function(e, t, r) {
											e >>>= 0, t >>>= 0, r || x(e, t, this.length);
											for (var n = this[e + --t], i = 1; t > 0 && (i *= 256);) n += this[e + --t] * i;
											return n
										}, s.prototype.readUInt8 = function(e, t) {
											return e >>>= 0, t || x(e, 1, this.length), this[e]
										}, s.prototype.readUInt16LE = function(e, t) {
											return e >>>= 0, t || x(e, 2, this.length), this[e] | this[e + 1] << 8
										}, s.prototype.readUInt16BE = function(e, t) {
											return e >>>= 0, t || x(e, 2, this.length), this[e] << 8 | this[e + 1]
										}, s.prototype.readUInt32LE = function(e, t) {
											return e >>>= 0, t || x(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
										}, s.prototype.readUInt32BE = function(e, t) {
											return e >>>= 0, t || x(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
										}, s.prototype.readIntLE = function(e, t, r) {
											e >>>= 0, t >>>= 0, r || x(e, t, this.length);
											for (var n = this[e], i = 1, o = 0; ++o < t && (i *= 256);) n += this[e + o] * i;
											return n >= (i *= 128) && (n -= Math.pow(2, 8 * t)), n
										}, s.prototype.readIntBE = function(e, t, r) {
											e >>>= 0, t >>>= 0, r || x(e, t, this.length);
											for (var n = t, i = 1, o = this[e + --n]; n > 0 && (i *= 256);) o += this[e + --n] * i;
											return o >= (i *= 128) && (o -= Math.pow(2, 8 * t)), o
										}, s.prototype.readInt8 = function(e, t) {
											return e >>>= 0, t || x(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
										}, s.prototype.readInt16LE = function(e, t) {
											e >>>= 0, t || x(e, 2, this.length);
											var r = this[e] | this[e + 1] << 8;
											return 32768 & r ? 4294901760 | r : r
										}, s.prototype.readInt16BE = function(e, t) {
											e >>>= 0, t || x(e, 2, this.length);
											var r = this[e + 1] | this[e] << 8;
											return 32768 & r ? 4294901760 | r : r
										}, s.prototype.readInt32LE = function(e, t) {
											return e >>>= 0, t || x(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
										}, s.prototype.readInt32BE = function(e, t) {
											return e >>>= 0, t || x(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
										}, s.prototype.readFloatLE = function(e, t) {
											return e >>>= 0, t || x(e, 4, this.length), n.read(this, e, !0, 23, 4)
										}, s.prototype.readFloatBE = function(e, t) {
											return e >>>= 0, t || x(e, 4, this.length), n.read(this, e, !1, 23, 4)
										}, s.prototype.readDoubleLE = function(e, t) {
											return e >>>= 0, t || x(e, 8, this.length), n.read(this, e, !0, 52, 8)
										}, s.prototype.readDoubleBE = function(e, t) {
											return e >>>= 0, t || x(e, 8, this.length), n.read(this, e, !1, 52, 8)
										}, s.prototype.writeUIntLE = function(e, t, r, n) {
											(e = +e, t >>>= 0, r >>>= 0, n) || O(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
											var i = 1,
												o = 0;
											for (this[t] = 255 & e; ++o < r && (i *= 256);) this[t + o] = e / i & 255;
											return t + r
										}, s.prototype.writeUIntBE = function(e, t, r, n) {
											(e = +e, t >>>= 0, r >>>= 0, n) || O(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
											var i = r - 1,
												o = 1;
											for (this[t + i] = 255 & e; --i >= 0 && (o *= 256);) this[t + i] = e / o & 255;
											return t + r
										}, s.prototype.writeUInt8 = function(e, t, r) {
											return e = +e, t >>>= 0, r || O(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1
										}, s.prototype.writeUInt16LE = function(e, t, r) {
											return e = +e, t >>>= 0, r || O(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
										}, s.prototype.writeUInt16BE = function(e, t, r) {
											return e = +e, t >>>= 0, r || O(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
										}, s.prototype.writeUInt32LE = function(e, t, r) {
											return e = +e, t >>>= 0, r || O(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4
										}, s.prototype.writeUInt32BE = function(e, t, r) {
											return e = +e, t >>>= 0, r || O(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
										}, s.prototype.writeIntLE = function(e, t, r, n) {
											if (e = +e, t >>>= 0, !n) {
												var i = Math.pow(2, 8 * r - 1);
												O(this, e, t, r, i - 1, -i)
											}
											var o = 0,
												s = 1,
												a = 0;
											for (this[t] = 255 & e; ++o < r && (s *= 256);) e < 0 && 0 === a && 0 !== this[t + o - 1] && (a = 1), this[t + o] = (e / s >> 0) - a & 255;
											return t + r
										}, s.prototype.writeIntBE = function(e, t, r, n) {
											if (e = +e, t >>>= 0, !n) {
												var i = Math.pow(2, 8 * r - 1);
												O(this, e, t, r, i - 1, -i)
											}
											var o = r - 1,
												s = 1,
												a = 0;
											for (this[t + o] = 255 & e; --o >= 0 && (s *= 256);) e < 0 && 0 === a && 0 !== this[t + o + 1] && (a = 1), this[t + o] = (e / s >> 0) - a & 255;
											return t + r
										}, s.prototype.writeInt8 = function(e, t, r) {
											return e = +e, t >>>= 0, r || O(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1
										}, s.prototype.writeInt16LE = function(e, t, r) {
											return e = +e, t >>>= 0, r || O(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
										}, s.prototype.writeInt16BE = function(e, t, r) {
											return e = +e, t >>>= 0, r || O(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
										}, s.prototype.writeInt32LE = function(e, t, r) {
											return e = +e, t >>>= 0, r || O(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
										}, s.prototype.writeInt32BE = function(e, t, r) {
											return e = +e, t >>>= 0, r || O(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
										}, s.prototype.writeFloatLE = function(e, t, r) {
											return P(this, e, t, !0, r)
										}, s.prototype.writeFloatBE = function(e, t, r) {
											return P(this, e, t, !1, r)
										}, s.prototype.writeDoubleLE = function(e, t, r) {
											return D(this, e, t, !0, r)
										}, s.prototype.writeDoubleBE = function(e, t, r) {
											return D(this, e, t, !1, r)
										}, s.prototype.copy = function(e, t, r, n) {
											if (!s.isBuffer(e)) throw new TypeError("argument should be a Buffer");
											if (r || (r = 0), n || 0 === n || (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < r && (n = r), n === r) return 0;
											if (0 === e.length || 0 === this.length) return 0;
											if (t < 0) throw new RangeError("targetStart out of bounds");
											if (r < 0 || r >= this.length) throw new RangeError("Index out of range");
											if (n < 0) throw new RangeError("sourceEnd out of bounds");
											n > this.length && (n = this.length), e.length - t < n - r && (n = e.length - t + r);
											var i = n - r;
											if (this === e && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(t, r, n);
											else if (this === e && r < t && t < n)
												for (var o = i - 1; o >= 0; --o) e[o + t] = this[o + r];
											else Uint8Array.prototype.set.call(e, this.subarray(r, n), t);
											return i
										}, s.prototype.fill = function(e, t, r, n) {
											if ("string" == typeof e) {
												if ("string" == typeof t ? (n = t, t = 0, r = this.length) : "string" == typeof r && (n = r, r = this.length), void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
												if ("string" == typeof n && !s.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
												if (1 === e.length) {
													var i = e.charCodeAt(0);
													("utf8" === n && i < 128 || "latin1" === n) && (e = i)
												}
											} else "number" == typeof e && (e &= 255);
											if (t < 0 || this.length < t || this.length < r) throw new RangeError("Out of range index");
											if (r <= t) return this;
											var o;
											if (t >>>= 0, r = void 0 === r ? this.length : r >>> 0, e || (e = 0), "number" == typeof e)
												for (o = t; o < r; ++o) this[o] = e;
											else {
												var a = s.isBuffer(e) ? e : s.from(e, n),
													c = a.length;
												if (0 === c) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
												for (o = 0; o < r - t; ++o) this[o + t] = a[o % c]
											}
											return this
										};
										var j = /[^+/0-9A-Za-z-_]/g;

										function L(e) {
											return e < 16 ? "0" + e.toString(16) : e.toString(16)
										}

										function N(e, t) {
											var r;
											t = t || 1 / 0;
											for (var n = e.length, i = null, o = [], s = 0; s < n; ++s) {
												if ((r = e.charCodeAt(s)) > 55295 && r < 57344) {
													if (!i) {
														if (r > 56319) {
															(t -= 3) > -1 && o.push(239, 191, 189);
															continue
														}
														if (s + 1 === n) {
															(t -= 3) > -1 && o.push(239, 191, 189);
															continue
														}
														i = r;
														continue
													}
													if (r < 56320) {
														(t -= 3) > -1 && o.push(239, 191, 189), i = r;
														continue
													}
													r = 65536 + (i - 55296 << 10 | r - 56320)
												} else i && (t -= 3) > -1 && o.push(239, 191, 189);
												if (i = null, r < 128) {
													if ((t -= 1) < 0) break;
													o.push(r)
												} else if (r < 2048) {
													if ((t -= 2) < 0) break;
													o.push(r >> 6 | 192, 63 & r | 128)
												} else if (r < 65536) {
													if ((t -= 3) < 0) break;
													o.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128)
												} else {
													if (!(r < 1114112)) throw new Error("Invalid code point");
													if ((t -= 4) < 0) break;
													o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128)
												}
											}
											return o
										}

										function B(e) {
											return t.toByteArray(function(e) {
												if ((e = (e = e.split("=")[0]).trim().replace(j, "")).length < 2) return "";
												for (; e.length % 4 != 0;) e += "=";
												return e
											}(e))
										}

										function U(e, t, r, n) {
											for (var i = 0; i < n && !(i + r >= t.length || i >= e.length); ++i) t[i + r] = e[i];
											return i
										}

										function F(e, t) {
											return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name
										}

										function $(e) {
											return e != e
										}
									}).call(this)
								}).call(this, e("buffer").Buffer)
							}, {
								"base64-js": 18,
								buffer: 69,
								ieee754: 146
							}],
							70: [function(e, t, r) {
								"use strict";
								var n = e("get-intrinsic"),
									i = e("./"),
									o = i(n("String.prototype.indexOf"));
								t.exports = function(e, t) {
									var r = n(e, !!t);
									return "function" == typeof r && o(e, ".prototype.") > -1 ? i(r) : r
								}
							}, {
								"./": 71,
								"get-intrinsic": 111
							}],
							71: [function(e, t, r) {
								"use strict";
								var n = e("function-bind"),
									i = e("get-intrinsic"),
									o = i("%Function.prototype.apply%"),
									s = i("%Function.prototype.call%"),
									a = i("%Reflect.apply%", !0) || n.call(s, o),
									c = i("%Object.getOwnPropertyDescriptor%", !0),
									l = i("%Object.defineProperty%", !0),
									u = i("%Math.max%");
								if (l) try {
									l({}, "a", {
										value: 1
									})
								} catch (h) {
									l = null
								}
								t.exports = function(e) {
									var t = a(n, s, arguments);
									if (c && l) {
										var r = c(t, "length");
										r.configurable && l(t, "length", {
											value: 1 + u(0, e.length - (arguments.length - 1))
										})
									}
									return t
								};
								var d = function() {
									return a(n, o, arguments)
								};
								l ? l(t.exports, "apply", {
									value: d
								}) : t.exports.apply = d
							}, {
								"function-bind": 110,
								"get-intrinsic": 111
							}],
							72: [function(e, t, r) {
								var n = e("safe-buffer").Buffer,
									i = e("stream").Transform,
									o = e("string_decoder").StringDecoder;

								function s(e) {
									i.call(this), this.hashMode = "string" == typeof e, this.hashMode ? this[e] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null
								}
								e("inherits")(s, i), s.prototype.update = function(e, t, r) {
									"string" == typeof e && (e = n.from(e, t));
									var i = this._update(e);
									return this.hashMode ? this : (r && (i = this._toString(i, r)), i)
								}, s.prototype.setAutoPadding = function() {}, s.prototype.getAuthTag = function() {
									throw new Error("trying to get auth tag in unsupported state")
								}, s.prototype.setAuthTag = function() {
									throw new Error("trying to set auth tag in unsupported state")
								}, s.prototype.setAAD = function() {
									throw new Error("trying to set aad in unsupported state")
								}, s.prototype._transform = function(e, t, r) {
									var n;
									try {
										this.hashMode ? this._update(e) : this.push(this._update(e))
									} catch (i) {
										n = i
									} finally {
										r(n)
									}
								}, s.prototype._flush = function(e) {
									var t;
									try {
										this.push(this.__final())
									} catch (r) {
										t = r
									}
									e(t)
								}, s.prototype._finalOrDigest = function(e) {
									var t = this.__final() || n.alloc(0);
									return e && (t = this._toString(t, e, !0)), t
								}, s.prototype._toString = function(e, t, r) {
									if (this._decoder || (this._decoder = new o(t), this._encoding = t), this._encoding !== t) throw new Error("can't switch encodings");
									var n = this._decoder.write(e);
									return r && (n += this._decoder.end()), n
								}, t.exports = s
							}, {
								inherits: 147,
								"safe-buffer": 251,
								stream: 265,
								string_decoder: 280
							}],
							73: [function(e, t, r) {
								"use strict";
								var n = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,
									i = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,
									o = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,
									s = /\\([\u000b\u0020-\u00ff])/g,
									a = /([\\"])/g,
									c = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

								function l(e) {
									var t = String(e);
									if (o.test(t)) return t;
									if (t.length > 0 && !i.test(t)) throw new TypeError("invalid parameter value");
									return '"' + t.replace(a, "\\$1") + '"'
								}

								function u(e) {
									this.parameters = Object.create(null), this.type = e
								}
								r.format = function(e) {
									if (!e || "object" != typeof e) throw new TypeError("argument obj is required");
									var t = e.parameters,
										r = e.type;
									if (!r || !c.test(r)) throw new TypeError("invalid type");
									var n = r;
									if (t && "object" == typeof t)
										for (var i, s = Object.keys(t).sort(), a = 0; a < s.length; a++) {
											if (i = s[a], !o.test(i)) throw new TypeError("invalid parameter name");
											n += "; " + i + "=" + l(t[i])
										}
									return n
								}, r.parse = function(e) {
									if (!e) throw new TypeError("argument string is required");
									var t = "object" == typeof e ? function(e) {
										var t;
										"function" == typeof e.getHeader ? t = e.getHeader("content-type") : "object" == typeof e.headers && (t = e.headers && e.headers["content-type"]);
										if ("string" != typeof t) throw new TypeError("content-type header is missing from object");
										return t
									}(e) : e;
									if ("string" != typeof t) throw new TypeError("argument string is required to be a string");
									var r = t.indexOf(";"),
										i = -1 !== r ? t.substr(0, r).trim() : t.trim();
									if (!c.test(i)) throw new TypeError("invalid media type");
									var o = new u(i.toLowerCase());
									if (-1 !== r) {
										var a, l, d;
										for (n.lastIndex = r; l = n.exec(t);) {
											if (l.index !== r) throw new TypeError("invalid parameter format");
											r += l[0].length, a = l[1].toLowerCase(), '"' === (d = l[2])[0] && (d = d.substr(1, d.length - 2).replace(s, "$1")), o.parameters[a] = d
										}
										if (r !== t.length) throw new TypeError("invalid parameter format")
									}
									return o
								}
							}, {}],
							74: [function(e, t, r) {
								(function(r) {
									(function() {
										var n = e("elliptic"),
											i = e("bn.js");
										t.exports = function(e) {
											return new s(e)
										};
										var o = {
											secp256k1: {
												name: "secp256k1",
												byteLength: 32
											},
											secp224r1: {
												name: "p224",
												byteLength: 28
											},
											prime256v1: {
												name: "p256",
												byteLength: 32
											},
											prime192v1: {
												name: "p192",
												byteLength: 24
											},
											ed25519: {
												name: "ed25519",
												byteLength: 32
											},
											secp384r1: {
												name: "p384",
												byteLength: 48
											},
											secp521r1: {
												name: "p521",
												byteLength: 66
											}
										};

										function s(e) {
											this.curveType = o[e], this.curveType || (this.curveType = {
												name: e
											}), this.curve = new n.ec(this.curveType.name), this.keys = void 0
										}

										function a(e, t, n) {
											Array.isArray(e) || (e = e.toArray());
											var i = new r(e);
											if (n && i.length < n) {
												var o = new r(n - i.length);
												o.fill(0), i = r.concat([o, i])
											}
											return t ? i.toString(t) : i
										}
										o.p224 = o.secp224r1, o.p256 = o.secp256r1 = o.prime256v1, o.p192 = o.secp192r1 = o.prime192v1, o.p384 = o.secp384r1, o.p521 = o.secp521r1, s.prototype.generateKeys = function(e, t) {
											return this.keys = this.curve.genKeyPair(), this.getPublicKey(e, t)
										}, s.prototype.computeSecret = function(e, t, n) {
											return t = t || "utf8", r.isBuffer(e) || (e = new r(e, t)), a(this.curve.keyFromPublic(e).getPublic().mul(this.keys.getPrivate()).getX(), n, this.curveType.byteLength)
										}, s.prototype.getPublicKey = function(e, t) {
											var r = this.keys.getPublic("compressed" === t, !0);
											return "hybrid" === t && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), a(r, e)
										}, s.prototype.getPrivateKey = function(e) {
											return a(this.keys.getPrivate(), e)
										}, s.prototype.setPublicKey = function(e, t) {
											return t = t || "utf8", r.isBuffer(e) || (e = new r(e, t)), this.keys._importPublic(e), this
										}, s.prototype.setPrivateKey = function(e, t) {
											t = t || "utf8", r.isBuffer(e) || (e = new r(e, t));
											var n = new i(e);
											return n = n.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(n), this
										}
									}).call(this)
								}).call(this, e("buffer").Buffer)
							}, {
								"bn.js": 19,
								buffer: 69,
								elliptic: 90
							}],
							75: [function(e, t, r) {
								"use strict";
								var n = e("inherits"),
									i = e("md5.js"),
									o = e("ripemd160"),
									s = e("sha.js"),
									a = e("cipher-base");

								function c(e) {
									a.call(this, "digest"), this._hash = e
								}
								n(c, a), c.prototype._update = function(e) {
									this._hash.update(e)
								}, c.prototype._final = function() {
									return this._hash.digest()
								}, t.exports = function(e) {
									return "md5" === (e = e.toLowerCase()) ? new i : "rmd160" === e || "ripemd160" === e ? new o : new c(s(e))
								}
							}, {
								"cipher-base": 72,
								inherits: 147,
								"md5.js": 222,
								ripemd160: 250,
								"sha.js": 258
							}],
							76: [function(e, t, r) {
								var n = e("md5.js");
								t.exports = function(e) {
									return (new n).update(e).digest()
								}
							}, {
								"md5.js": 222
							}],
							77: [function(e, t, r) {
								"use strict";
								var n = e("inherits"),
									i = e("./legacy"),
									o = e("cipher-base"),
									s = e("safe-buffer").Buffer,
									a = e("create-hash/md5"),
									c = e("ripemd160"),
									l = e("sha.js"),
									u = s.alloc(128);

								function d(e, t) {
									o.call(this, "digest"), "string" == typeof t && (t = s.from(t));
									var r = "sha512" === e || "sha384" === e ? 128 : 64;
									(this._alg = e, this._key = t, t.length > r) ? t = ("rmd160" === e ? new c : l(e)).update(t).digest(): t.length < r && (t = s.concat([t, u], r));
									for (var n = this._ipad = s.allocUnsafe(r), i = this._opad = s.allocUnsafe(r), a = 0; a < r; a++) n[a] = 54 ^ t[a], i[a] = 92 ^ t[a];
									this._hash = "rmd160" === e ? new c : l(e), this._hash.update(n)
								}
								n(d, o), d.prototype._update = function(e) {
									this._hash.update(e)
								}, d.prototype._final = function() {
									var e = this._hash.digest();
									return ("rmd160" === this._alg ? new c : l(this._alg)).update(this._opad).update(e).digest()
								}, t.exports = function(e, t) {
									return "rmd160" === (e = e.toLowerCase()) || "ripemd160" === e ? new d("rmd160", t) : "md5" === e ? new i(a, t) : new d(e, t)
								}
							}, {
								"./legacy": 78,
								"cipher-base": 72,
								"create-hash/md5": 76,
								inherits: 147,
								ripemd160: 250,
								"safe-buffer": 251,
								"sha.js": 258
							}],
							78: [function(e, t, r) {
								"use strict";
								var n = e("inherits"),
									i = e("safe-buffer").Buffer,
									o = e("cipher-base"),
									s = i.alloc(128),
									a = 64;

								function c(e, t) {
									o.call(this, "digest"), "string" == typeof t && (t = i.from(t)), this._alg = e, this._key = t, t.length > a ? t = e(t) : t.length < a && (t = i.concat([t, s], a));
									for (var r = this._ipad = i.allocUnsafe(a), n = this._opad = i.allocUnsafe(a), c = 0; c < a; c++) r[c] = 54 ^ t[c], n[c] = 92 ^ t[c];
									this._hash = [r]
								}
								n(c, o), c.prototype._update = function(e) {
									this._hash.push(e)
								}, c.prototype._final = function() {
									var e = this._alg(i.concat(this._hash));
									return this._alg(i.concat([this._opad, e]))
								}, t.exports = c
							}, {
								"cipher-base": 72,
								inherits: 147,
								"safe-buffer": 251
							}],
							79: [function(e, t, r) {
								"use strict";
								r.randomBytes = r.rng = r.pseudoRandomBytes = r.prng = e("randombytes"), r.createHash = r.Hash = e("create-hash"), r.createHmac = r.Hmac = e("create-hmac");
								var n = e("browserify-sign/algos"),
									i = Object.keys(n),
									o = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(i);
								r.getHashes = function() {
									return o
								};
								var s = e("pbkdf2");
								r.pbkdf2 = s.pbkdf2, r.pbkdf2Sync = s.pbkdf2Sync;
								var a = e("browserify-cipher");
								r.Cipher = a.Cipher, r.createCipher = a.createCipher, r.Cipheriv = a.Cipheriv, r.createCipheriv = a.createCipheriv, r.Decipher = a.Decipher, r.createDecipher = a.createDecipher, r.Decipheriv = a.Decipheriv, r.createDecipheriv = a.createDecipheriv, r.getCiphers = a.getCiphers, r.listCiphers = a.listCiphers;
								var c = e("diffie-hellman");
								r.DiffieHellmanGroup = c.DiffieHellmanGroup, r.createDiffieHellmanGroup = c.createDiffieHellmanGroup, r.getDiffieHellman = c.getDiffieHellman, r.createDiffieHellman = c.createDiffieHellman, r.DiffieHellman = c.DiffieHellman;
								var l = e("browserify-sign");
								r.createSign = l.createSign, r.Sign = l.Sign, r.createVerify = l.createVerify, r.Verify = l.Verify, r.createECDH = e("create-ecdh");
								var u = e("public-encrypt");
								r.publicEncrypt = u.publicEncrypt, r.privateEncrypt = u.privateEncrypt, r.publicDecrypt = u.publicDecrypt, r.privateDecrypt = u.privateDecrypt;
								var d = e("randomfill");
								r.randomFill = d.randomFill, r.randomFillSync = d.randomFillSync, r.createCredentials = function() {
									throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join("\n"))
								}, r.constants = {
									DH_CHECK_P_NOT_SAFE_PRIME: 2,
									DH_CHECK_P_NOT_PRIME: 1,
									DH_UNABLE_TO_CHECK_GENERATOR: 4,
									DH_NOT_SUITABLE_GENERATOR: 8,
									NPN_ENABLED: 1,
									ALPN_ENABLED: 1,
									RSA_PKCS1_PADDING: 1,
									RSA_SSLV23_PADDING: 2,
									RSA_NO_PADDING: 3,
									RSA_PKCS1_OAEP_PADDING: 4,
									RSA_X931_PADDING: 5,
									RSA_PKCS1_PSS_PADDING: 6,
									POINT_CONVERSION_COMPRESSED: 2,
									POINT_CONVERSION_UNCOMPRESSED: 4,
									POINT_CONVERSION_HYBRID: 6
								}
							}, {
								"browserify-cipher": 39,
								"browserify-sign": 47,
								"browserify-sign/algos": 44,
								"create-ecdh": 74,
								"create-hash": 75,
								"create-hmac": 77,
								"diffie-hellman": 86,
								pbkdf2: 232,
								"public-encrypt": 239,
								randombytes: 245,
								randomfill: 246
							}],
							80: [function(e, t, r) {
								"use strict";
								r.utils = e("./des/utils"), r.Cipher = e("./des/cipher"), r.DES = e("./des/des"), r.CBC = e("./des/cbc"), r.EDE = e("./des/ede")
							}, {
								"./des/cbc": 81,
								"./des/cipher": 82,
								"./des/des": 83,
								"./des/ede": 84,
								"./des/utils": 85
							}],
							81: [function(e, t, r) {
								"use strict";
								var n = e("minimalistic-assert"),
									i = e("inherits"),
									o = {};

								function s(e) {
									n.equal(e.length, 8, "Invalid IV length"), this.iv = new Array(8);
									for (var t = 0; t < this.iv.length; t++) this.iv[t] = e[t]
								}
								r.instantiate = function(e) {
									function t(t) {
										e.call(this, t), this._cbcInit()
									}
									i(t, e);
									for (var r = Object.keys(o), n = 0; n < r.length; n++) {
										var s = r[n];
										t.prototype[s] = o[s]
									}
									return t.create = function(e) {
										return new t(e)
									}, t
								}, o._cbcInit = function() {
									var e = new s(this.options.iv);
									this._cbcState = e
								}, o._update = function(e, t, r, n) {
									var i = this._cbcState,
										o = this.constructor.super_.prototype,
										s = i.iv;
									if ("encrypt" === this.type) {
										for (var a = 0; a < this.blockSize; a++) s[a] ^= e[t + a];
										o._update.call(this, s, 0, r, n);
										for (a = 0; a < this.blockSize; a++) s[a] = r[n + a]
									} else {
										o._update.call(this, e, t, r, n);
										for (a = 0; a < this.blockSize; a++) r[n + a] ^= s[a];
										for (a = 0; a < this.blockSize; a++) s[a] = e[t + a]
									}
								}
							}, {
								inherits: 147,
								"minimalistic-assert": 224
							}],
							82: [function(e, t, r) {
								"use strict";
								var n = e("minimalistic-assert");

								function i(e) {
									this.options = e, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0
								}
								t.exports = i, i.prototype._init = function() {}, i.prototype.update = function(e) {
									return 0 === e.length ? [] : "decrypt" === this.type ? this._updateDecrypt(e) : this._updateEncrypt(e)
								}, i.prototype._buffer = function(e, t) {
									for (var r = Math.min(this.buffer.length - this.bufferOff, e.length - t), n = 0; n < r; n++) this.buffer[this.bufferOff + n] = e[t + n];
									return this.bufferOff += r, r
								}, i.prototype._flushBuffer = function(e, t) {
									return this._update(this.buffer, 0, e, t), this.bufferOff = 0, this.blockSize
								}, i.prototype._updateEncrypt = function(e) {
									var t = 0,
										r = 0,
										n = (this.bufferOff + e.length) / this.blockSize | 0,
										i = new Array(n * this.blockSize);
									0 !== this.bufferOff && (t += this._buffer(e, t), this.bufferOff === this.buffer.length && (r += this._flushBuffer(i, r)));
									for (var o = e.length - (e.length - t) % this.blockSize; t < o; t += this.blockSize) this._update(e, t, i, r), r += this.blockSize;
									for (; t < e.length; t++, this.bufferOff++) this.buffer[this.bufferOff] = e[t];
									return i
								}, i.prototype._updateDecrypt = function(e) {
									for (var t = 0, r = 0, n = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, i = new Array(n * this.blockSize); n > 0; n--) t += this._buffer(e, t), r += this._flushBuffer(i, r);
									return t += this._buffer(e, t), i
								}, i.prototype.final = function(e) {
									var t, r;
									return e && (t = this.update(e)), r = "encrypt" === this.type ? this._finalEncrypt() : this._finalDecrypt(), t ? t.concat(r) : r
								}, i.prototype._pad = function(e, t) {
									if (0 === t) return !1;
									for (; t < e.length;) e[t++] = 0;
									return !0
								}, i.prototype._finalEncrypt = function() {
									if (!this._pad(this.buffer, this.bufferOff)) return [];
									var e = new Array(this.blockSize);
									return this._update(this.buffer, 0, e, 0), e
								}, i.prototype._unpad = function(e) {
									return e
								}, i.prototype._finalDecrypt = function() {
									n.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
									var e = new Array(this.blockSize);
									return this._flushBuffer(e, 0), this._unpad(e)
								}
							}, {
								"minimalistic-assert": 224
							}],
							83: [function(e, t, r) {
								"use strict";
								var n = e("minimalistic-assert"),
									i = e("inherits"),
									o = e("./utils"),
									s = e("./cipher");

								function a() {
									this.tmp = new Array(2), this.keys = null
								}

								function c(e) {
									s.call(this, e);
									var t = new a;
									this._desState = t, this.deriveKeys(t, e.key)
								}
								i(c, s), t.exports = c, c.create = function(e) {
									return new c(e)
								};
								var l = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
								c.prototype.deriveKeys = function(e, t) {
									e.keys = new Array(32), n.equal(t.length, this.blockSize, "Invalid key length");
									var r = o.readUInt32BE(t, 0),
										i = o.readUInt32BE(t, 4);
									o.pc1(r, i, e.tmp, 0), r = e.tmp[0], i = e.tmp[1];
									for (var s = 0; s < e.keys.length; s += 2) {
										var a = l[s >>> 1];
										r = o.r28shl(r, a), i = o.r28shl(i, a), o.pc2(r, i, e.keys, s)
									}
								}, c.prototype._update = function(e, t, r, n) {
									var i = this._desState,
										s = o.readUInt32BE(e, t),
										a = o.readUInt32BE(e, t + 4);
									o.ip(s, a, i.tmp, 0), s = i.tmp[0], a = i.tmp[1], "encrypt" === this.type ? this._encrypt(i, s, a, i.tmp, 0) : this._decrypt(i, s, a, i.tmp, 0), s = i.tmp[0], a = i.tmp[1], o.writeUInt32BE(r, s, n), o.writeUInt32BE(r, a, n + 4)
								}, c.prototype._pad = function(e, t) {
									for (var r = e.length - t, n = t; n < e.length; n++) e[n] = r;
									return !0
								}, c.prototype._unpad = function(e) {
									for (var t = e[e.length - 1], r = e.length - t; r < e.length; r++) n.equal(e[r], t);
									return e.slice(0, e.length - t)
								}, c.prototype._encrypt = function(e, t, r, n, i) {
									for (var s = t, a = r, c = 0; c < e.keys.length; c += 2) {
										var l = e.keys[c],
											u = e.keys[c + 1];
										o.expand(a, e.tmp, 0), l ^= e.tmp[0], u ^= e.tmp[1];
										var d = o.substitute(l, u),
											h = a;
										a = (s ^ o.permute(d)) >>> 0, s = h
									}
									o.rip(a, s, n, i)
								}, c.prototype._decrypt = function(e, t, r, n, i) {
									for (var s = r, a = t, c = e.keys.length - 2; c >= 0; c -= 2) {
										var l = e.keys[c],
											u = e.keys[c + 1];
										o.expand(s, e.tmp, 0), l ^= e.tmp[0], u ^= e.tmp[1];
										var d = o.substitute(l, u),
											h = s;
										s = (a ^ o.permute(d)) >>> 0, a = h
									}
									o.rip(s, a, n, i)
								}
							}, {
								"./cipher": 82,
								"./utils": 85,
								inherits: 147,
								"minimalistic-assert": 224
							}],
							84: [function(e, t, r) {
								"use strict";
								var n = e("minimalistic-assert"),
									i = e("inherits"),
									o = e("./cipher"),
									s = e("./des");

								function a(e, t) {
									n.equal(t.length, 24, "Invalid key length");
									var r = t.slice(0, 8),
										i = t.slice(8, 16),
										o = t.slice(16, 24);
									this.ciphers = "encrypt" === e ? [s.create({
										type: "encrypt",
										key: r
									}), s.create({
										type: "decrypt",
										key: i
									}), s.create({
										type: "encrypt",
										key: o
									})] : [s.create({
										type: "decrypt",
										key: o
									}), s.create({
										type: "encrypt",
										key: i
									}), s.create({
										type: "decrypt",
										key: r
									})]
								}

								function c(e) {
									o.call(this, e);
									var t = new a(this.type, this.options.key);
									this._edeState = t
								}
								i(c, o), t.exports = c, c.create = function(e) {
									return new c(e)
								}, c.prototype._update = function(e, t, r, n) {
									var i = this._edeState;
									i.ciphers[0]._update(e, t, r, n), i.ciphers[1]._update(r, n, r, n), i.ciphers[2]._update(r, n, r, n)
								}, c.prototype._pad = s.prototype._pad, c.prototype._unpad = s.prototype._unpad
							}, {
								"./cipher": 82,
								"./des": 83,
								inherits: 147,
								"minimalistic-assert": 224
							}],
							85: [function(e, t, r) {
								"use strict";
								r.readUInt32BE = function(e, t) {
									return (e[0 + t] << 24 | e[1 + t] << 16 | e[2 + t] << 8 | e[3 + t]) >>> 0
								}, r.writeUInt32BE = function(e, t, r) {
									e[0 + r] = t >>> 24, e[1 + r] = t >>> 16 & 255, e[2 + r] = t >>> 8 & 255, e[3 + r] = 255 & t
								}, r.ip = function(e, t, r, n) {
									for (var i = 0, o = 0, s = 6; s >= 0; s -= 2) {
										for (var a = 0; a <= 24; a += 8) i <<= 1, i |= t >>> a + s & 1;
										for (a = 0; a <= 24; a += 8) i <<= 1, i |= e >>> a + s & 1
									}
									for (s = 6; s >= 0; s -= 2) {
										for (a = 1; a <= 25; a += 8) o <<= 1, o |= t >>> a + s & 1;
										for (a = 1; a <= 25; a += 8) o <<= 1, o |= e >>> a + s & 1
									}
									r[n + 0] = i >>> 0, r[n + 1] = o >>> 0
								}, r.rip = function(e, t, r, n) {
									for (var i = 0, o = 0, s = 0; s < 4; s++)
										for (var a = 24; a >= 0; a -= 8) i <<= 1, i |= t >>> a + s & 1, i <<= 1, i |= e >>> a + s & 1;
									for (s = 4; s < 8; s++)
										for (a = 24; a >= 0; a -= 8) o <<= 1, o |= t >>> a + s & 1, o <<= 1, o |= e >>> a + s & 1;
									r[n + 0] = i >>> 0, r[n + 1] = o >>> 0
								}, r.pc1 = function(e, t, r, n) {
									for (var i = 0, o = 0, s = 7; s >= 5; s--) {
										for (var a = 0; a <= 24; a += 8) i <<= 1, i |= t >> a + s & 1;
										for (a = 0; a <= 24; a += 8) i <<= 1, i |= e >> a + s & 1
									}
									for (a = 0; a <= 24; a += 8) i <<= 1, i |= t >> a + s & 1;
									for (s = 1; s <= 3; s++) {
										for (a = 0; a <= 24; a += 8) o <<= 1, o |= t >> a + s & 1;
										for (a = 0; a <= 24; a += 8) o <<= 1, o |= e >> a + s & 1
									}
									for (a = 0; a <= 24; a += 8) o <<= 1, o |= e >> a + s & 1;
									r[n + 0] = i >>> 0, r[n + 1] = o >>> 0
								}, r.r28shl = function(e, t) {
									return e << t & 268435455 | e >>> 28 - t
								};
								var n = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
								r.pc2 = function(e, t, r, i) {
									for (var o = 0, s = 0, a = n.length >>> 1, c = 0; c < a; c++) o <<= 1, o |= e >>> n[c] & 1;
									for (c = a; c < n.length; c++) s <<= 1, s |= t >>> n[c] & 1;
									r[i + 0] = o >>> 0, r[i + 1] = s >>> 0
								}, r.expand = function(e, t, r) {
									var n = 0,
										i = 0;
									n = (1 & e) << 5 | e >>> 27;
									for (var o = 23; o >= 15; o -= 4) n <<= 6, n |= e >>> o & 63;
									for (o = 11; o >= 3; o -= 4) i |= e >>> o & 63, i <<= 6;
									i |= (31 & e) << 1 | e >>> 31, t[r + 0] = n >>> 0, t[r + 1] = i >>> 0
								};
								var i = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
								r.substitute = function(e, t) {
									for (var r = 0, n = 0; n < 4; n++) {
										r <<= 4, r |= i[64 * n + (e >>> 18 - 6 * n & 63)]
									}
									for (n = 0; n < 4; n++) {
										r <<= 4, r |= i[256 + 64 * n + (t >>> 18 - 6 * n & 63)]
									}
									return r >>> 0
								};
								var o = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
								r.permute = function(e) {
									for (var t = 0, r = 0; r < o.length; r++) t <<= 1, t |= e >>> o[r] & 1;
									return t >>> 0
								}, r.padSplit = function(e, t, r) {
									for (var n = e.toString(2); n.length < t;) n = "0" + n;
									for (var i = [], o = 0; o < t; o += r) i.push(n.slice(o, o + r));
									return i.join(" ")
								}
							}, {}],
							86: [function(e, t, r) {
								(function(t) {
									(function() {
										var n = e("./lib/generatePrime"),
											i = e("./lib/primes.json"),
											o = e("./lib/dh");
										var s = {
											binary: !0,
											hex: !0,
											base64: !0
										};
										r.DiffieHellmanGroup = r.createDiffieHellmanGroup = r.getDiffieHellman = function(e) {
											var r = new t(i[e].prime, "hex"),
												n = new t(i[e].gen, "hex");
											return new o(r, n)
										}, r.createDiffieHellman = r.DiffieHellman = function e(r, i, a, c) {
											return t.isBuffer(i) || void 0 === s[i] ? e(r, "binary", i, a) : (i = i || "binary", c = c || "binary", a = a || new t([2]), t.isBuffer(a) || (a = new t(a, c)), "number" == typeof r ? new o(n(r, a), a, !0) : (t.isBuffer(r) || (r = new t(r, i)), new o(r, a, !0)))
										}
									}).call(this)
								}).call(this, e("buffer").Buffer)
							}, {
								"./lib/dh": 87,
								"./lib/generatePrime": 88,
								"./lib/primes.json": 89,
								buffer: 69
							}],
							87: [function(e, t, r) {
								(function(r) {
									(function() {
										var n = e("bn.js"),
											i = new(e("miller-rabin")),
											o = new n(24),
											s = new n(11),
											a = new n(10),
											c = new n(3),
											l = new n(7),
											u = e("./generatePrime"),
											d = e("randombytes");

										function h(e, t) {
											return t = t || "utf8", r.isBuffer(e) || (e = new r(e, t)), this._pub = new n(e), this
										}

										function f(e, t) {
											return t = t || "utf8", r.isBuffer(e) || (e = new r(e, t)), this._priv = new n(e), this
										}
										t.exports = v;
										var p = {};

										function v(e, t, r) {
											this.setGenerator(t), this.__prime = new n(e), this._prime = n.mont(this.__prime), this._primeLen = e.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, r ? (this.setPublicKey = h, this.setPrivateKey = f) : this._primeCode = 8
										}

										function g(e, t) {
											var n = new r(e.toArray());
											return t ? n.toString(t) : n
										}
										Object.defineProperty(v.prototype, "verifyError", {
											enumerable: !0,
											get: function() {
												return "number" != typeof this._primeCode && (this._primeCode = function(e, t) {
													var r = t.toString("hex"),
														n = [r, e.toString(16)].join("_");
													if (n in p) return p[n];
													var d, h = 0;
													if (e.isEven() || !u.simpleSieve || !u.fermatTest(e) || !i.test(e)) return h += 1, h += "02" === r || "05" === r ? 8 : 4, p[n] = h, h;
													switch (i.test(e.shrn(1)) || (h += 2), r) {
														case "02":
															e.mod(o).cmp(s) && (h += 8);
															break;
														case "05":
															(d = e.mod(a)).cmp(c) && d.cmp(l) && (h += 8);
															break;
														default:
															h += 4
													}
													return p[n] = h, h
												}(this.__prime, this.__gen)), this._primeCode
											}
										}), v.prototype.generateKeys = function() {
											return this._priv || (this._priv = new n(d(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey()
										}, v.prototype.computeSecret = function(e) {
											var t = (e = (e = new n(e)).toRed(this._prime)).redPow(this._priv).fromRed(),
												i = new r(t.toArray()),
												o = this.getPrime();
											if (i.length < o.length) {
												var s = new r(o.length - i.length);
												s.fill(0), i = r.concat([s, i])
											}
											return i
										}, v.prototype.getPublicKey = function(e) {
											return g(this._pub, e)
										}, v.prototype.getPrivateKey = function(e) {
											return g(this._priv, e)
										}, v.prototype.getPrime = function(e) {
											return g(this.__prime, e)
										}, v.prototype.getGenerator = function(e) {
											return g(this._gen, e)
										}, v.prototype.setGenerator = function(e, t) {
											return t = t || "utf8", r.isBuffer(e) || (e = new r(e, t)), this.__gen = e, this._gen = new n(e), this
										}
									}).call(this)
								}).call(this, e("buffer").Buffer)
							}, {
								"./generatePrime": 88,
								"bn.js": 19,
								buffer: 69,
								"miller-rabin": 223,
								randombytes: 245
							}],
							88: [function(e, t, r) {
								var n = e("randombytes");
								t.exports = y, y.simpleSieve = g, y.fermatTest = m;
								var i = e("bn.js"),
									o = new i(24),
									s = new(e("miller-rabin")),
									a = new i(1),
									c = new i(2),
									l = new i(5),
									u = (new i(16), new i(8), new i(10)),
									d = new i(3),
									h = (new i(7), new i(11)),
									f = new i(4),
									p = (new i(12), null);

								function v() {
									if (null !== p) return p;
									var e = [];
									e[0] = 2;
									for (var t = 1, r = 3; r < 1048576; r += 2) {
										for (var n = Math.ceil(Math.sqrt(r)), i = 0; i < t && e[i] <= n && r % e[i] != 0; i++);
										t !== i && e[i] <= n || (e[t++] = r)
									}
									return p = e, e
								}

								function g(e) {
									for (var t = v(), r = 0; r < t.length; r++)
										if (0 === e.modn(t[r])) return 0 === e.cmpn(t[r]);
									return !0
								}

								function m(e) {
									var t = i.mont(e);
									return 0 === c.toRed(t).redPow(e.subn(1)).fromRed().cmpn(1)
								}

								function y(e, t) {
									if (e < 16) return new i(2 === t || 5 === t ? [140, 123] : [140, 39]);
									var r, p;
									for (t = new i(t);;) {
										for (r = new i(n(Math.ceil(e / 8))); r.bitLength() > e;) r.ishrn(1);
										if (r.isEven() && r.iadd(a), r.testn(1) || r.iadd(c), t.cmp(c)) {
											if (!t.cmp(l))
												for (; r.mod(u).cmp(d);) r.iadd(f)
										} else
											for (; r.mod(o).cmp(h);) r.iadd(f);
										if (g(p = r.shrn(1)) && g(r) && m(p) && m(r) && s.test(p) && s.test(r)) return r
									}
								}
							}, {
								"bn.js": 19,
								"miller-rabin": 223,
								randombytes: 245
							}],
							89: [function(e, t, r) {
								t.exports = {
									modp1: {
										gen: "02",
										prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
									},
									modp2: {
										gen: "02",
										prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
									},
									modp5: {
										gen: "02",
										prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
									},
									modp14: {
										gen: "02",
										prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
									},
									modp15: {
										gen: "02",
										prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
									},
									modp16: {
										gen: "02",
										prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
									},
									modp17: {
										gen: "02",
										prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
									},
									modp18: {
										gen: "02",
										prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
									}
								}
							}, {}],
							90: [function(e, t, r) {
								"use strict";
								var n = r;
								n.version = e("../package.json").version, n.utils = e("./elliptic/utils"), n.rand = e("brorand"), n.curve = e("./elliptic/curve"), n.curves = e("./elliptic/curves"), n.ec = e("./elliptic/ec"), n.eddsa = e("./elliptic/eddsa")
							}, {
								"../package.json": 105,
								"./elliptic/curve": 93,
								"./elliptic/curves": 96,
								"./elliptic/ec": 97,
								"./elliptic/eddsa": 100,
								"./elliptic/utils": 104,
								brorand: 20
							}],
							91: [function(e, t, r) {
								"use strict";
								var n = e("bn.js"),
									i = e("../utils"),
									o = i.getNAF,
									s = i.getJSF,
									a = i.assert;

								function c(e, t) {
									this.type = e, this.p = new n(t.p, 16), this.red = t.prime ? n.red(t.prime) : n.mont(this.p), this.zero = new n(0).toRed(this.red), this.one = new n(1).toRed(this.red), this.two = new n(2).toRed(this.red), this.n = t.n && new n(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
									var r = this.n && this.p.div(this.n);
									!r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
								}

								function l(e, t) {
									this.curve = e, this.type = t, this.precomputed = null
								}
								t.exports = c, c.prototype.point = function() {
									throw new Error("Not implemented")
								}, c.prototype.validate = function() {
									throw new Error("Not implemented")
								}, c.prototype._fixedNafMul = function(e, t) {
									a(e.precomputed);
									var r = e._getDoubles(),
										n = o(t, 1, this._bitLength),
										i = (1 << r.step + 1) - (r.step % 2 == 0 ? 2 : 1);
									i /= 3;
									var s, c, l = [];
									for (s = 0; s < n.length; s += r.step) {
										c = 0;
										for (var u = s + r.step - 1; u >= s; u--) c = (c << 1) + n[u];
										l.push(c)
									}
									for (var d = this.jpoint(null, null, null), h = this.jpoint(null, null, null), f = i; f > 0; f--) {
										for (s = 0; s < l.length; s++)(c = l[s]) === f ? h = h.mixedAdd(r.points[s]) : c === -f && (h = h.mixedAdd(r.points[s].neg()));
										d = d.add(h)
									}
									return d.toP()
								}, c.prototype._wnafMul = function(e, t) {
									var r = 4,
										n = e._getNAFPoints(r);
									r = n.wnd;
									for (var i = n.points, s = o(t, r, this._bitLength), c = this.jpoint(null, null, null), l = s.length - 1; l >= 0; l--) {
										for (var u = 0; l >= 0 && 0 === s[l]; l--) u++;
										if (l >= 0 && u++, c = c.dblp(u), l < 0) break;
										var d = s[l];
										a(0 !== d), c = "affine" === e.type ? d > 0 ? c.mixedAdd(i[d - 1 >> 1]) : c.mixedAdd(i[-d - 1 >> 1].neg()) : d > 0 ? c.add(i[d - 1 >> 1]) : c.add(i[-d - 1 >> 1].neg())
									}
									return "affine" === e.type ? c.toP() : c
								}, c.prototype._wnafMulAdd = function(e, t, r, n, i) {
									var a, c, l, u = this._wnafT1,
										d = this._wnafT2,
										h = this._wnafT3,
										f = 0;
									for (a = 0; a < n; a++) {
										var p = (l = t[a])._getNAFPoints(e);
										u[a] = p.wnd, d[a] = p.points
									}
									for (a = n - 1; a >= 1; a -= 2) {
										var v = a - 1,
											g = a;
										if (1 === u[v] && 1 === u[g]) {
											var m = [t[v], null, null, t[g]];
											0 === t[v].y.cmp(t[g].y) ? (m[1] = t[v].add(t[g]), m[2] = t[v].toJ().mixedAdd(t[g].neg())) : 0 === t[v].y.cmp(t[g].y.redNeg()) ? (m[1] = t[v].toJ().mixedAdd(t[g]), m[2] = t[v].add(t[g].neg())) : (m[1] = t[v].toJ().mixedAdd(t[g]), m[2] = t[v].toJ().mixedAdd(t[g].neg()));
											var y = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
												b = s(r[v], r[g]);
											for (f = Math.max(b[0].length, f), h[v] = new Array(f), h[g] = new Array(f), c = 0; c < f; c++) {
												var _ = 0 | b[0][c],
													w = 0 | b[1][c];
												h[v][c] = y[3 * (_ + 1) + (w + 1)], h[g][c] = 0, d[v] = m
											}
										} else h[v] = o(r[v], u[v], this._bitLength), h[g] = o(r[g], u[g], this._bitLength), f = Math.max(h[v].length, f), f = Math.max(h[g].length, f)
									}
									var S = this.jpoint(null, null, null),
										E = this._wnafT4;
									for (a = f; a >= 0; a--) {
										for (var k = 0; a >= 0;) {
											var T = !0;
											for (c = 0; c < n; c++) E[c] = 0 | h[c][a], 0 !== E[c] && (T = !1);
											if (!T) break;
											k++, a--
										}
										if (a >= 0 && k++, S = S.dblp(k), a < 0) break;
										for (c = 0; c < n; c++) {
											var I = E[c];
											0 !== I && (I > 0 ? l = d[c][I - 1 >> 1] : I < 0 && (l = d[c][-I - 1 >> 1].neg()), S = "affine" === l.type ? S.mixedAdd(l) : S.add(l))
										}
									}
									for (a = 0; a < n; a++) d[a] = null;
									return i ? S : S.toP()
								}, c.BasePoint = l, l.prototype.eq = function() {
									throw new Error("Not implemented")
								}, l.prototype.validate = function() {
									return this.curve.validate(this)
								}, c.prototype.decodePoint = function(e, t) {
									e = i.toArray(e, t);
									var r = this.p.byteLength();
									if ((4 === e[0] || 6 === e[0] || 7 === e[0]) && e.length - 1 == 2 * r) return 6 === e[0] ? a(e[e.length - 1] % 2 == 0) : 7 === e[0] && a(e[e.length - 1] % 2 == 1), this.point(e.slice(1, 1 + r), e.slice(1 + r, 1 + 2 * r));
									if ((2 === e[0] || 3 === e[0]) && e.length - 1 === r) return this.pointFromX(e.slice(1, 1 + r), 3 === e[0]);
									throw new Error("Unknown point format")
								}, l.prototype.encodeCompressed = function(e) {
									return this.encode(e, !0)
								}, l.prototype._encode = function(e) {
									var t = this.curve.p.byteLength(),
										r = this.getX().toArray("be", t);
									return e ? [this.getY().isEven() ? 2 : 3].concat(r) : [4].concat(r, this.getY().toArray("be", t))
								}, l.prototype.encode = function(e, t) {
									return i.encode(this._encode(t), e)
								}, l.prototype.precompute = function(e) {
									if (this.precomputed) return this;
									var t = {
										doubles: null,
										naf: null,
										beta: null
									};
									return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this
								}, l.prototype._hasDoubles = function(e) {
									if (!this.precomputed) return !1;
									var t = this.precomputed.doubles;
									return !!t && t.points.length >= Math.ceil((e.bitLength() + 1) / t.step)
								}, l.prototype._getDoubles = function(e, t) {
									if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
									for (var r = [this], n = this, i = 0; i < t; i += e) {
										for (var o = 0; o < e; o++) n = n.dbl();
										r.push(n)
									}
									return {
										step: e,
										points: r
									}
								}, l.prototype._getNAFPoints = function(e) {
									if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
									for (var t = [this], r = (1 << e) - 1, n = 1 === r ? null : this.dbl(), i = 1; i < r; i++) t[i] = t[i - 1].add(n);
									return {
										wnd: e,
										points: t
									}
								}, l.prototype._getBeta = function() {
									return null
								}, l.prototype.dblp = function(e) {
									for (var t = this, r = 0; r < e; r++) t = t.dbl();
									return t
								}
							}, {
								"../utils": 104,
								"bn.js": 19
							}],
							92: [function(e, t, r) {
								"use strict";
								var n = e("../utils"),
									i = e("bn.js"),
									o = e("inherits"),
									s = e("./base"),
									a = n.assert;

								function c(e) {
									this.twisted = 1 != (0 | e.a), this.mOneA = this.twisted && -1 == (0 | e.a), this.extended = this.mOneA, s.call(this, "edwards", e), this.a = new i(e.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new i(e.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new i(e.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), a(!this.twisted || 0 === this.c.fromRed().cmpn(1)), this.oneC = 1 == (0 | e.c)
								}

								function l(e, t, r, n, o) {
									s.BasePoint.call(this, e, "projective"), null === t && null === r && null === n ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new i(t, 16), this.y = new i(r, 16), this.z = n ? new i(n, 16) : this.curve.one, this.t = o && new i(o, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))))
								}
								o(c, s), t.exports = c, c.prototype._mulA = function(e) {
									return this.mOneA ? e.redNeg() : this.a.redMul(e)
								}, c.prototype._mulC = function(e) {
									return this.oneC ? e : this.c.redMul(e)
								}, c.prototype.jpoint = function(e, t, r, n) {
									return this.point(e, t, r, n)
								}, c.prototype.pointFromX = function(e, t) {
									(e = new i(e, 16)).red || (e = e.toRed(this.red));
									var r = e.redSqr(),
										n = this.c2.redSub(this.a.redMul(r)),
										o = this.one.redSub(this.c2.redMul(this.d).redMul(r)),
										s = n.redMul(o.redInvm()),
										a = s.redSqrt();
									if (0 !== a.redSqr().redSub(s).cmp(this.zero)) throw new Error("invalid point");
									var c = a.fromRed().isOdd();
									return (t && !c || !t && c) && (a = a.redNeg()), this.point(e, a)
								}, c.prototype.pointFromY = function(e, t) {
									(e = new i(e, 16)).red || (e = e.toRed(this.red));
									var r = e.redSqr(),
										n = r.redSub(this.c2),
										o = r.redMul(this.d).redMul(this.c2).redSub(this.a),
										s = n.redMul(o.redInvm());
									if (0 === s.cmp(this.zero)) {
										if (t) throw new Error("invalid point");
										return this.point(this.zero, e)
									}
									var a = s.redSqrt();
									if (0 !== a.redSqr().redSub(s).cmp(this.zero)) throw new Error("invalid point");
									return a.fromRed().isOdd() !== t && (a = a.redNeg()), this.point(a, e)
								}, c.prototype.validate = function(e) {
									if (e.isInfinity()) return !0;
									e.normalize();
									var t = e.x.redSqr(),
										r = e.y.redSqr(),
										n = t.redMul(this.a).redAdd(r),
										i = this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(r)));
									return 0 === n.cmp(i)
								}, o(l, s.BasePoint), c.prototype.pointFromJSON = function(e) {
									return l.fromJSON(this, e)
								}, c.prototype.point = function(e, t, r, n) {
									return new l(this, e, t, r, n)
								}, l.fromJSON = function(e, t) {
									return new l(e, t[0], t[1], t[2])
								}, l.prototype.inspect = function() {
									return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
								}, l.prototype.isInfinity = function() {
									return 0 === this.x.cmpn(0) && (0 === this.y.cmp(this.z) || this.zOne && 0 === this.y.cmp(this.curve.c))
								}, l.prototype._extDbl = function() {
									var e = this.x.redSqr(),
										t = this.y.redSqr(),
										r = this.z.redSqr();
									r = r.redIAdd(r);
									var n = this.curve._mulA(e),
										i = this.x.redAdd(this.y).redSqr().redISub(e).redISub(t),
										o = n.redAdd(t),
										s = o.redSub(r),
										a = n.redSub(t),
										c = i.redMul(s),
										l = o.redMul(a),
										u = i.redMul(a),
										d = s.redMul(o);
									return this.curve.point(c, l, d, u)
								}, l.prototype._projDbl = function() {
									var e, t, r, n, i, o, s = this.x.redAdd(this.y).redSqr(),
										a = this.x.redSqr(),
										c = this.y.redSqr();
									if (this.curve.twisted) {
										var l = (n = this.curve._mulA(a)).redAdd(c);
										this.zOne ? (e = s.redSub(a).redSub(c).redMul(l.redSub(this.curve.two)), t = l.redMul(n.redSub(c)), r = l.redSqr().redSub(l).redSub(l)) : (i = this.z.redSqr(), o = l.redSub(i).redISub(i), e = s.redSub(a).redISub(c).redMul(o), t = l.redMul(n.redSub(c)), r = l.redMul(o))
									} else n = a.redAdd(c), i = this.curve._mulC(this.z).redSqr(), o = n.redSub(i).redSub(i), e = this.curve._mulC(s.redISub(n)).redMul(o), t = this.curve._mulC(n).redMul(a.redISub(c)), r = n.redMul(o);
									return this.curve.point(e, t, r)
								}, l.prototype.dbl = function() {
									return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl()
								}, l.prototype._extAdd = function(e) {
									var t = this.y.redSub(this.x).redMul(e.y.redSub(e.x)),
										r = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),
										n = this.t.redMul(this.curve.dd).redMul(e.t),
										i = this.z.redMul(e.z.redAdd(e.z)),
										o = r.redSub(t),
										s = i.redSub(n),
										a = i.redAdd(n),
										c = r.redAdd(t),
										l = o.redMul(s),
										u = a.redMul(c),
										d = o.redMul(c),
										h = s.redMul(a);
									return this.curve.point(l, u, h, d)
								}, l.prototype._projAdd = function(e) {
									var t, r, n = this.z.redMul(e.z),
										i = n.redSqr(),
										o = this.x.redMul(e.x),
										s = this.y.redMul(e.y),
										a = this.curve.d.redMul(o).redMul(s),
										c = i.redSub(a),
										l = i.redAdd(a),
										u = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(o).redISub(s),
										d = n.redMul(c).redMul(u);
									return this.curve.twisted ? (t = n.redMul(l).redMul(s.redSub(this.curve._mulA(o))), r = c.redMul(l)) : (t = n.redMul(l).redMul(s.redSub(o)), r = this.curve._mulC(c).redMul(l)), this.curve.point(d, t, r)
								}, l.prototype.add = function(e) {
									return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e)
								}, l.prototype.mul = function(e) {
									return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e)
								}, l.prototype.mulAdd = function(e, t, r) {
									return this.curve._wnafMulAdd(1, [this, t], [e, r], 2, !1)
								}, l.prototype.jmulAdd = function(e, t, r) {
									return this.curve._wnafMulAdd(1, [this, t], [e, r], 2, !0)
								}, l.prototype.normalize = function() {
									if (this.zOne) return this;
									var e = this.z.redInvm();
									return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this
								}, l.prototype.neg = function() {
									return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
								}, l.prototype.getX = function() {
									return this.normalize(), this.x.fromRed()
								}, l.prototype.getY = function() {
									return this.normalize(), this.y.fromRed()
								}, l.prototype.eq = function(e) {
									return this === e || 0 === this.getX().cmp(e.getX()) && 0 === this.getY().cmp(e.getY())
								}, l.prototype.eqXToP = function(e) {
									var t = e.toRed(this.curve.red).redMul(this.z);
									if (0 === this.x.cmp(t)) return !0;
									for (var r = e.clone(), n = this.curve.redN.redMul(this.z);;) {
										if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0) return !1;
										if (t.redIAdd(n), 0 === this.x.cmp(t)) return !0
									}
								}, l.prototype.toP = l.prototype.normalize, l.prototype.mixedAdd = l.prototype.add
							}, {
								"../utils": 104,
								"./base": 91,
								"bn.js": 19,
								inherits: 147
							}],
							93: [function(e, t, r) {
								"use strict";
								var n = r;
								n.base = e("./base"), n.short = e("./short"), n.mont = e("./mont"), n.edwards = e("./edwards")
							}, {
								"./base": 91,
								"./edwards": 92,
								"./mont": 94,
								"./short": 95
							}],
							94: [function(e, t, r) {
								"use strict";
								var n = e("bn.js"),
									i = e("inherits"),
									o = e("./base"),
									s = e("../utils");

								function a(e) {
									o.call(this, "mont", e), this.a = new n(e.a, 16).toRed(this.red), this.b = new n(e.b, 16).toRed(this.red), this.i4 = new n(4).toRed(this.red).redInvm(), this.two = new n(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two))
								}

								function c(e, t, r) {
									o.BasePoint.call(this, e, "projective"), null === t && null === r ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new n(t, 16), this.z = new n(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)))
								}
								i(a, o), t.exports = a, a.prototype.validate = function(e) {
									var t = e.normalize().x,
										r = t.redSqr(),
										n = r.redMul(t).redAdd(r.redMul(this.a)).redAdd(t);
									return 0 === n.redSqrt().redSqr().cmp(n)
								}, i(c, o.BasePoint), a.prototype.decodePoint = function(e, t) {
									return this.point(s.toArray(e, t), 1)
								}, a.prototype.point = function(e, t) {
									return new c(this, e, t)
								}, a.prototype.pointFromJSON = function(e) {
									return c.fromJSON(this, e)
								}, c.prototype.precompute = function() {}, c.prototype._encode = function() {
									return this.getX().toArray("be", this.curve.p.byteLength())
								}, c.fromJSON = function(e, t) {
									return new c(e, t[0], t[1] || e.one)
								}, c.prototype.inspect = function() {
									return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
								}, c.prototype.isInfinity = function() {
									return 0 === this.z.cmpn(0)
								}, c.prototype.dbl = function() {
									var e = this.x.redAdd(this.z).redSqr(),
										t = this.x.redSub(this.z).redSqr(),
										r = e.redSub(t),
										n = e.redMul(t),
										i = r.redMul(t.redAdd(this.curve.a24.redMul(r)));
									return this.curve.point(n, i)
								}, c.prototype.add = function() {
									throw new Error("Not supported on Montgomery curve")
								}, c.prototype.diffAdd = function(e, t) {
									var r = this.x.redAdd(this.z),
										n = this.x.redSub(this.z),
										i = e.x.redAdd(e.z),
										o = e.x.redSub(e.z).redMul(r),
										s = i.redMul(n),
										a = t.z.redMul(o.redAdd(s).redSqr()),
										c = t.x.redMul(o.redISub(s).redSqr());
									return this.curve.point(a, c)
								}, c.prototype.mul = function(e) {
									for (var t = e.clone(), r = this, n = this.curve.point(null, null), i = []; 0 !== t.cmpn(0); t.iushrn(1)) i.push(t.andln(1));
									for (var o = i.length - 1; o >= 0; o--) 0 === i[o] ? (r = r.diffAdd(n, this), n = n.dbl()) : (n = r.diffAdd(n, this), r = r.dbl());
									return n
								}, c.prototype.mulAdd = function() {
									throw new Error("Not supported on Montgomery curve")
								}, c.prototype.jumlAdd = function() {
									throw new Error("Not supported on Montgomery curve")
								}, c.prototype.eq = function(e) {
									return 0 === this.getX().cmp(e.getX())
								}, c.prototype.normalize = function() {
									return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this
								}, c.prototype.getX = function() {
									return this.normalize(), this.x.fromRed()
								}
							}, {
								"../utils": 104,
								"./base": 91,
								"bn.js": 19,
								inherits: 147
							}],
							95: [function(e, t, r) {
								"use strict";
								var n = e("../utils"),
									i = e("bn.js"),
									o = e("inherits"),
									s = e("./base"),
									a = n.assert;

								function c(e) {
									s.call(this, "short", e), this.a = new i(e.a, 16).toRed(this.red), this.b = new i(e.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(e), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
								}

								function l(e, t, r, n) {
									s.BasePoint.call(this, e, "affine"), null === t && null === r ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new i(t, 16), this.y = new i(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
								}

								function u(e, t, r, n) {
									s.BasePoint.call(this, e, "jacobian"), null === t && null === r && null === n ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new i(0)) : (this.x = new i(t, 16), this.y = new i(r, 16), this.z = new i(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
								}
								o(c, s), t.exports = c, c.prototype._getEndomorphism = function(e) {
									if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
										var t, r;
										if (e.beta) t = new i(e.beta, 16).toRed(this.red);
										else {
											var n = this._getEndoRoots(this.p);
											t = (t = n[0].cmp(n[1]) < 0 ? n[0] : n[1]).toRed(this.red)
										}
										if (e.lambda) r = new i(e.lambda, 16);
										else {
											var o = this._getEndoRoots(this.n);
											0 === this.g.mul(o[0]).x.cmp(this.g.x.redMul(t)) ? r = o[0] : (r = o[1], a(0 === this.g.mul(r).x.cmp(this.g.x.redMul(t))))
										}
										return {
											beta: t,
											lambda: r,
											basis: e.basis ? e.basis.map((function(e) {
												return {
													a: new i(e.a, 16),
													b: new i(e.b, 16)
												}
											})) : this._getEndoBasis(r)
										}
									}
								}, c.prototype._getEndoRoots = function(e) {
									var t = e === this.p ? this.red : i.mont(e),
										r = new i(2).toRed(t).redInvm(),
										n = r.redNeg(),
										o = new i(3).toRed(t).redNeg().redSqrt().redMul(r);
									return [n.redAdd(o).fromRed(), n.redSub(o).fromRed()]
								}, c.prototype._getEndoBasis = function(e) {
									for (var t, r, n, o, s, a, c, l, u, d = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), h = e, f = this.n.clone(), p = new i(1), v = new i(0), g = new i(0), m = new i(1), y = 0; 0 !== h.cmpn(0);) {
										var b = f.div(h);
										l = f.sub(b.mul(h)), u = g.sub(b.mul(p));
										var _ = m.sub(b.mul(v));
										if (!n && l.cmp(d) < 0) t = c.neg(), r = p, n = l.neg(), o = u;
										else if (n && 2 == ++y) break;
										c = l, f = h, h = l, g = p, p = u, m = v, v = _
									}
									s = l.neg(), a = u;
									var w = n.sqr().add(o.sqr());
									return s.sqr().add(a.sqr()).cmp(w) >= 0 && (s = t, a = r), n.negative && (n = n.neg(), o = o.neg()), s.negative && (s = s.neg(), a = a.neg()), [{
										a: n,
										b: o
									}, {
										a: s,
										b: a
									}]
								}, c.prototype._endoSplit = function(e) {
									var t = this.endo.basis,
										r = t[0],
										n = t[1],
										i = n.b.mul(e).divRound(this.n),
										o = r.b.neg().mul(e).divRound(this.n),
										s = i.mul(r.a),
										a = o.mul(n.a),
										c = i.mul(r.b),
										l = o.mul(n.b);
									return {
										k1: e.sub(s).sub(a),
										k2: c.add(l).neg()
									}
								}, c.prototype.pointFromX = function(e, t) {
									(e = new i(e, 16)).red || (e = e.toRed(this.red));
									var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
										n = r.redSqrt();
									if (0 !== n.redSqr().redSub(r).cmp(this.zero)) throw new Error("invalid point");
									var o = n.fromRed().isOdd();
									return (t && !o || !t && o) && (n = n.redNeg()), this.point(e, n)
								}, c.prototype.validate = function(e) {
									if (e.inf) return !0;
									var t = e.x,
										r = e.y,
										n = this.a.redMul(t),
										i = t.redSqr().redMul(t).redIAdd(n).redIAdd(this.b);
									return 0 === r.redSqr().redISub(i).cmpn(0)
								}, c.prototype._endoWnafMulAdd = function(e, t, r) {
									for (var n = this._endoWnafT1, i = this._endoWnafT2, o = 0; o < e.length; o++) {
										var s = this._endoSplit(t[o]),
											a = e[o],
											c = a._getBeta();
										s.k1.negative && (s.k1.ineg(), a = a.neg(!0)), s.k2.negative && (s.k2.ineg(), c = c.neg(!0)), n[2 * o] = a, n[2 * o + 1] = c, i[2 * o] = s.k1, i[2 * o + 1] = s.k2
									}
									for (var l = this._wnafMulAdd(1, n, i, 2 * o, r), u = 0; u < 2 * o; u++) n[u] = null, i[u] = null;
									return l
								}, o(l, s.BasePoint), c.prototype.point = function(e, t, r) {
									return new l(this, e, t, r)
								}, c.prototype.pointFromJSON = function(e, t) {
									return l.fromJSON(this, e, t)
								}, l.prototype._getBeta = function() {
									if (this.curve.endo) {
										var e = this.precomputed;
										if (e && e.beta) return e.beta;
										var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
										if (e) {
											var r = this.curve,
												n = function(e) {
													return r.point(e.x.redMul(r.endo.beta), e.y)
												};
											e.beta = t, t.precomputed = {
												beta: null,
												naf: e.naf && {
													wnd: e.naf.wnd,
													points: e.naf.points.map(n)
												},
												doubles: e.doubles && {
													step: e.doubles.step,
													points: e.doubles.points.map(n)
												}
											}
										}
										return t
									}
								}, l.prototype.toJSON = function() {
									return this.precomputed ? [this.x, this.y, this.precomputed && {
										doubles: this.precomputed.doubles && {
											step: this.precomputed.doubles.step,
											points: this.precomputed.doubles.points.slice(1)
										},
										naf: this.precomputed.naf && {
											wnd: this.precomputed.naf.wnd,
											points: this.precomputed.naf.points.slice(1)
										}
									}] : [this.x, this.y]
								}, l.fromJSON = function(e, t, r) {
									"string" == typeof t && (t = JSON.parse(t));
									var n = e.point(t[0], t[1], r);
									if (!t[2]) return n;

									function i(t) {
										return e.point(t[0], t[1], r)
									}
									var o = t[2];
									return n.precomputed = {
										beta: null,
										doubles: o.doubles && {
											step: o.doubles.step,
											points: [n].concat(o.doubles.points.map(i))
										},
										naf: o.naf && {
											wnd: o.naf.wnd,
											points: [n].concat(o.naf.points.map(i))
										}
									}, n
								}, l.prototype.inspect = function() {
									return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
								}, l.prototype.isInfinity = function() {
									return this.inf
								}, l.prototype.add = function(e) {
									if (this.inf) return e;
									if (e.inf) return this;
									if (this.eq(e)) return this.dbl();
									if (this.neg().eq(e)) return this.curve.point(null, null);
									if (0 === this.x.cmp(e.x)) return this.curve.point(null, null);
									var t = this.y.redSub(e.y);
									0 !== t.cmpn(0) && (t = t.redMul(this.x.redSub(e.x).redInvm()));
									var r = t.redSqr().redISub(this.x).redISub(e.x),
										n = t.redMul(this.x.redSub(r)).redISub(this.y);
									return this.curve.point(r, n)
								}, l.prototype.dbl = function() {
									if (this.inf) return this;
									var e = this.y.redAdd(this.y);
									if (0 === e.cmpn(0)) return this.curve.point(null, null);
									var t = this.curve.a,
										r = this.x.redSqr(),
										n = e.redInvm(),
										i = r.redAdd(r).redIAdd(r).redIAdd(t).redMul(n),
										o = i.redSqr().redISub(this.x.redAdd(this.x)),
										s = i.redMul(this.x.redSub(o)).redISub(this.y);
									return this.curve.point(o, s)
								}, l.prototype.getX = function() {
									return this.x.fromRed()
								}, l.prototype.getY = function() {
									return this.y.fromRed()
								}, l.prototype.mul = function(e) {
									return e = new i(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e)
								}, l.prototype.mulAdd = function(e, t, r) {
									var n = [this, t],
										i = [e, r];
									return this.curve.endo ? this.curve._endoWnafMulAdd(n, i) : this.curve._wnafMulAdd(1, n, i, 2)
								}, l.prototype.jmulAdd = function(e, t, r) {
									var n = [this, t],
										i = [e, r];
									return this.curve.endo ? this.curve._endoWnafMulAdd(n, i, !0) : this.curve._wnafMulAdd(1, n, i, 2, !0)
								}, l.prototype.eq = function(e) {
									return this === e || this.inf === e.inf && (this.inf || 0 === this.x.cmp(e.x) && 0 === this.y.cmp(e.y))
								}, l.prototype.neg = function(e) {
									if (this.inf) return this;
									var t = this.curve.point(this.x, this.y.redNeg());
									if (e && this.precomputed) {
										var r = this.precomputed,
											n = function(e) {
												return e.neg()
											};
										t.precomputed = {
											naf: r.naf && {
												wnd: r.naf.wnd,
												points: r.naf.points.map(n)
											},
											doubles: r.doubles && {
												step: r.doubles.step,
												points: r.doubles.points.map(n)
											}
										}
									}
									return t
								}, l.prototype.toJ = function() {
									return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one)
								}, o(u, s.BasePoint), c.prototype.jpoint = function(e, t, r) {
									return new u(this, e, t, r)
								}, u.prototype.toP = function() {
									if (this.isInfinity()) return this.curve.point(null, null);
									var e = this.z.redInvm(),
										t = e.redSqr(),
										r = this.x.redMul(t),
										n = this.y.redMul(t).redMul(e);
									return this.curve.point(r, n)
								}, u.prototype.neg = function() {
									return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
								}, u.prototype.add = function(e) {
									if (this.isInfinity()) return e;
									if (e.isInfinity()) return this;
									var t = e.z.redSqr(),
										r = this.z.redSqr(),
										n = this.x.redMul(t),
										i = e.x.redMul(r),
										o = this.y.redMul(t.redMul(e.z)),
										s = e.y.redMul(r.redMul(this.z)),
										a = n.redSub(i),
										c = o.redSub(s);
									if (0 === a.cmpn(0)) return 0 !== c.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
									var l = a.redSqr(),
										u = l.redMul(a),
										d = n.redMul(l),
										h = c.redSqr().redIAdd(u).redISub(d).redISub(d),
										f = c.redMul(d.redISub(h)).redISub(o.redMul(u)),
										p = this.z.redMul(e.z).redMul(a);
									return this.curve.jpoint(h, f, p)
								}, u.prototype.mixedAdd = function(e) {
									if (this.isInfinity()) return e.toJ();
									if (e.isInfinity()) return this;
									var t = this.z.redSqr(),
										r = this.x,
										n = e.x.redMul(t),
										i = this.y,
										o = e.y.redMul(t).redMul(this.z),
										s = r.redSub(n),
										a = i.redSub(o);
									if (0 === s.cmpn(0)) return 0 !== a.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
									var c = s.redSqr(),
										l = c.redMul(s),
										u = r.redMul(c),
										d = a.redSqr().redIAdd(l).redISub(u).redISub(u),
										h = a.redMul(u.redISub(d)).redISub(i.redMul(l)),
										f = this.z.redMul(s);
									return this.curve.jpoint(d, h, f)
								}, u.prototype.dblp = function(e) {
									if (0 === e) return this;
									if (this.isInfinity()) return this;
									if (!e) return this.dbl();
									var t;
									if (this.curve.zeroA || this.curve.threeA) {
										var r = this;
										for (t = 0; t < e; t++) r = r.dbl();
										return r
									}
									var n = this.curve.a,
										i = this.curve.tinv,
										o = this.x,
										s = this.y,
										a = this.z,
										c = a.redSqr().redSqr(),
										l = s.redAdd(s);
									for (t = 0; t < e; t++) {
										var u = o.redSqr(),
											d = l.redSqr(),
											h = d.redSqr(),
											f = u.redAdd(u).redIAdd(u).redIAdd(n.redMul(c)),
											p = o.redMul(d),
											v = f.redSqr().redISub(p.redAdd(p)),
											g = p.redISub(v),
											m = f.redMul(g);
										m = m.redIAdd(m).redISub(h);
										var y = l.redMul(a);
										t + 1 < e && (c = c.redMul(h)), o = v, a = y, l = m
									}
									return this.curve.jpoint(o, l.redMul(i), a)
								}, u.prototype.dbl = function() {
									return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
								}, u.prototype._zeroDbl = function() {
									var e, t, r;
									if (this.zOne) {
										var n = this.x.redSqr(),
											i = this.y.redSqr(),
											o = i.redSqr(),
											s = this.x.redAdd(i).redSqr().redISub(n).redISub(o);
										s = s.redIAdd(s);
										var a = n.redAdd(n).redIAdd(n),
											c = a.redSqr().redISub(s).redISub(s),
											l = o.redIAdd(o);
										l = (l = l.redIAdd(l)).redIAdd(l), e = c, t = a.redMul(s.redISub(c)).redISub(l), r = this.y.redAdd(this.y)
									} else {
										var u = this.x.redSqr(),
											d = this.y.redSqr(),
											h = d.redSqr(),
											f = this.x.redAdd(d).redSqr().redISub(u).redISub(h);
										f = f.redIAdd(f);
										var p = u.redAdd(u).redIAdd(u),
											v = p.redSqr(),
											g = h.redIAdd(h);
										g = (g = g.redIAdd(g)).redIAdd(g), e = v.redISub(f).redISub(f), t = p.redMul(f.redISub(e)).redISub(g), r = (r = this.y.redMul(this.z)).redIAdd(r)
									}
									return this.curve.jpoint(e, t, r)
								}, u.prototype._threeDbl = function() {
									var e, t, r;
									if (this.zOne) {
										var n = this.x.redSqr(),
											i = this.y.redSqr(),
											o = i.redSqr(),
											s = this.x.redAdd(i).redSqr().redISub(n).redISub(o);
										s = s.redIAdd(s);
										var a = n.redAdd(n).redIAdd(n).redIAdd(this.curve.a),
											c = a.redSqr().redISub(s).redISub(s);
										e = c;
										var l = o.redIAdd(o);
										l = (l = l.redIAdd(l)).redIAdd(l), t = a.redMul(s.redISub(c)).redISub(l), r = this.y.redAdd(this.y)
									} else {
										var u = this.z.redSqr(),
											d = this.y.redSqr(),
											h = this.x.redMul(d),
											f = this.x.redSub(u).redMul(this.x.redAdd(u));
										f = f.redAdd(f).redIAdd(f);
										var p = h.redIAdd(h),
											v = (p = p.redIAdd(p)).redAdd(p);
										e = f.redSqr().redISub(v), r = this.y.redAdd(this.z).redSqr().redISub(d).redISub(u);
										var g = d.redSqr();
										g = (g = (g = g.redIAdd(g)).redIAdd(g)).redIAdd(g), t = f.redMul(p.redISub(e)).redISub(g)
									}
									return this.curve.jpoint(e, t, r)
								}, u.prototype._dbl = function() {
									var e = this.curve.a,
										t = this.x,
										r = this.y,
										n = this.z,
										i = n.redSqr().redSqr(),
										o = t.redSqr(),
										s = r.redSqr(),
										a = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(i)),
										c = t.redAdd(t),
										l = (c = c.redIAdd(c)).redMul(s),
										u = a.redSqr().redISub(l.redAdd(l)),
										d = l.redISub(u),
										h = s.redSqr();
									h = (h = (h = h.redIAdd(h)).redIAdd(h)).redIAdd(h);
									var f = a.redMul(d).redISub(h),
										p = r.redAdd(r).redMul(n);
									return this.curve.jpoint(u, f, p)
								}, u.prototype.trpl = function() {
									if (!this.curve.zeroA) return this.dbl().add(this);
									var e = this.x.redSqr(),
										t = this.y.redSqr(),
										r = this.z.redSqr(),
										n = t.redSqr(),
										i = e.redAdd(e).redIAdd(e),
										o = i.redSqr(),
										s = this.x.redAdd(t).redSqr().redISub(e).redISub(n),
										a = (s = (s = (s = s.redIAdd(s)).redAdd(s).redIAdd(s)).redISub(o)).redSqr(),
										c = n.redIAdd(n);
									c = (c = (c = c.redIAdd(c)).redIAdd(c)).redIAdd(c);
									var l = i.redIAdd(s).redSqr().redISub(o).redISub(a).redISub(c),
										u = t.redMul(l);
									u = (u = u.redIAdd(u)).redIAdd(u);
									var d = this.x.redMul(a).redISub(u);
									d = (d = d.redIAdd(d)).redIAdd(d);
									var h = this.y.redMul(l.redMul(c.redISub(l)).redISub(s.redMul(a)));
									h = (h = (h = h.redIAdd(h)).redIAdd(h)).redIAdd(h);
									var f = this.z.redAdd(s).redSqr().redISub(r).redISub(a);
									return this.curve.jpoint(d, h, f)
								}, u.prototype.mul = function(e, t) {
									return e = new i(e, t), this.curve._wnafMul(this, e)
								}, u.prototype.eq = function(e) {
									if ("affine" === e.type) return this.eq(e.toJ());
									if (this === e) return !0;
									var t = this.z.redSqr(),
										r = e.z.redSqr();
									if (0 !== this.x.redMul(r).redISub(e.x.redMul(t)).cmpn(0)) return !1;
									var n = t.redMul(this.z),
										i = r.redMul(e.z);
									return 0 === this.y.redMul(i).redISub(e.y.redMul(n)).cmpn(0)
								}, u.prototype.eqXToP = function(e) {
									var t = this.z.redSqr(),
										r = e.toRed(this.curve.red).redMul(t);
									if (0 === this.x.cmp(r)) return !0;
									for (var n = e.clone(), i = this.curve.redN.redMul(t);;) {
										if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0) return !1;
										if (r.redIAdd(i), 0 === this.x.cmp(r)) return !0
									}
								}, u.prototype.inspect = function() {
									return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
								}, u.prototype.isInfinity = function() {
									return 0 === this.z.cmpn(0)
								}
							}, {
								"../utils": 104,
								"./base": 91,
								"bn.js": 19,
								inherits: 147
							}],
							96: [function(e, t, r) {
								"use strict";
								var n, i = r,
									o = e("hash.js"),
									s = e("./curve"),
									a = e("./utils").assert;

								function c(e) {
									"short" === e.type ? this.curve = new s.short(e) : "edwards" === e.type ? this.curve = new s.edwards(e) : this.curve = new s.mont(e), this.g = this.curve.g, this.n = this.curve.n, this.hash = e.hash, a(this.g.validate(), "Invalid curve"), a(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
								}

								function l(e, t) {
									Object.defineProperty(i, e, {
										configurable: !0,
										enumerable: !0,
										get: function() {
											var r = new c(t);
											return Object.defineProperty(i, e, {
												configurable: !0,
												enumerable: !0,
												value: r
											}), r
										}
									})
								}
								i.PresetCurve = c, l("p192", {
									type: "short",
									prime: "p192",
									p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
									a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
									b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
									n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
									hash: o.sha256,
									gRed: !1,
									g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
								}), l("p224", {
									type: "short",
									prime: "p224",
									p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
									a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
									b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
									n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
									hash: o.sha256,
									gRed: !1,
									g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
								}), l("p256", {
									type: "short",
									prime: null,
									p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
									a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
									b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
									n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
									hash: o.sha256,
									gRed: !1,
									g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
								}), l("p384", {
									type: "short",
									prime: null,
									p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
									a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
									b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
									n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
									hash: o.sha384,
									gRed: !1,
									g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
								}), l("p521", {
									type: "short",
									prime: null,
									p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
									a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
									b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
									n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
									hash: o.sha512,
									gRed: !1,
									g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
								}), l("curve25519", {
									type: "mont",
									prime: "p25519",
									p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
									a: "76d06",
									b: "1",
									n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
									hash: o.sha256,
									gRed: !1,
									g: ["9"]
								}), l("ed25519", {
									type: "edwards",
									prime: "p25519",
									p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
									a: "-1",
									c: "1",
									d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
									n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
									hash: o.sha256,
									gRed: !1,
									g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
								});
								try {
									n = e("./precomputed/secp256k1")
								} catch (u) {
									n = void 0
								}
								l("secp256k1", {
									type: "short",
									prime: "k256",
									p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
									a: "0",
									b: "7",
									n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
									h: "1",
									hash: o.sha256,
									beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
									lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
									basis: [{
										a: "3086d221a7d46bcde86c90e49284eb15",
										b: "-e4437ed6010e88286f547fa90abfe4c3"
									}, {
										a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
										b: "3086d221a7d46bcde86c90e49284eb15"
									}],
									gRed: !1,
									g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", n]
								})
							}, {
								"./curve": 93,
								"./precomputed/secp256k1": 103,
								"./utils": 104,
								"hash.js": 133
							}],
							97: [function(e, t, r) {
								"use strict";
								var n = e("bn.js"),
									i = e("hmac-drbg"),
									o = e("../utils"),
									s = e("../curves"),
									a = e("brorand"),
									c = o.assert,
									l = e("./key"),
									u = e("./signature");

								function d(e) {
									if (!(this instanceof d)) return new d(e);
									"string" == typeof e && (c(Object.prototype.hasOwnProperty.call(s, e), "Unknown curve " + e), e = s[e]), e instanceof s.PresetCurve && (e = {
										curve: e
									}), this.curve = e.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e.curve.g, this.g.precompute(e.curve.n.bitLength() + 1), this.hash = e.hash || e.curve.hash
								}
								t.exports = d, d.prototype.keyPair = function(e) {
									return new l(this, e)
								}, d.prototype.keyFromPrivate = function(e, t) {
									return l.fromPrivate(this, e, t)
								}, d.prototype.keyFromPublic = function(e, t) {
									return l.fromPublic(this, e, t)
								}, d.prototype.genKeyPair = function(e) {
									e || (e = {});
									for (var t = new i({
											hash: this.hash,
											pers: e.pers,
											persEnc: e.persEnc || "utf8",
											entropy: e.entropy || a(this.hash.hmacStrength),
											entropyEnc: e.entropy && e.entropyEnc || "utf8",
											nonce: this.n.toArray()
										}), r = this.n.byteLength(), o = this.n.sub(new n(2));;) {
										var s = new n(t.generate(r));
										if (!(s.cmp(o) > 0)) return s.iaddn(1), this.keyFromPrivate(s)
									}
								}, d.prototype._truncateToN = function(e, t) {
									var r = 8 * e.byteLength() - this.n.bitLength();
									return r > 0 && (e = e.ushrn(r)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
								}, d.prototype.sign = function(e, t, r, o) {
									"object" == typeof r && (o = r, r = null), o || (o = {}), t = this.keyFromPrivate(t, r), e = this._truncateToN(new n(e, 16));
									for (var s = this.n.byteLength(), a = t.getPrivate().toArray("be", s), c = e.toArray("be", s), l = new i({
											hash: this.hash,
											entropy: a,
											nonce: c,
											pers: o.pers,
											persEnc: o.persEnc || "utf8"
										}), d = this.n.sub(new n(1)), h = 0;; h++) {
										var f = o.k ? o.k(h) : new n(l.generate(this.n.byteLength()));
										if (!((f = this._truncateToN(f, !0)).cmpn(1) <= 0 || f.cmp(d) >= 0)) {
											var p = this.g.mul(f);
											if (!p.isInfinity()) {
												var v = p.getX(),
													g = v.umod(this.n);
												if (0 !== g.cmpn(0)) {
													var m = f.invm(this.n).mul(g.mul(t.getPrivate()).iadd(e));
													if (0 !== (m = m.umod(this.n)).cmpn(0)) {
														var y = (p.getY().isOdd() ? 1 : 0) | (0 !== v.cmp(g) ? 2 : 0);
														return o.canonical && m.cmp(this.nh) > 0 && (m = this.n.sub(m), y ^= 1), new u({
															r: g,
															s: m,
															recoveryParam: y
														})
													}
												}
											}
										}
									}
								}, d.prototype.verify = function(e, t, r, i) {
									e = this._truncateToN(new n(e, 16)), r = this.keyFromPublic(r, i);
									var o = (t = new u(t, "hex")).r,
										s = t.s;
									if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return !1;
									if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return !1;
									var a, c = s.invm(this.n),
										l = c.mul(e).umod(this.n),
										d = c.mul(o).umod(this.n);
									return this.curve._maxwellTrick ? !(a = this.g.jmulAdd(l, r.getPublic(), d)).isInfinity() && a.eqXToP(o) : !(a = this.g.mulAdd(l, r.getPublic(), d)).isInfinity() && 0 === a.getX().umod(this.n).cmp(o)
								}, d.prototype.recoverPubKey = function(e, t, r, i) {
									c((3 & r) === r, "The recovery param is more than two bits"), t = new u(t, i);
									var o = this.n,
										s = new n(e),
										a = t.r,
										l = t.s,
										d = 1 & r,
										h = r >> 1;
									if (a.cmp(this.curve.p.umod(this.curve.n)) >= 0 && h) throw new Error("Unable to find sencond key candinate");
									a = h ? this.curve.pointFromX(a.add(this.curve.n), d) : this.curve.pointFromX(a, d);
									var f = t.r.invm(o),
										p = o.sub(s).mul(f).umod(o),
										v = l.mul(f).umod(o);
									return this.g.mulAdd(p, a, v)
								}, d.prototype.getKeyRecoveryParam = function(e, t, r, n) {
									if (null !== (t = new u(t, n)).recoveryParam) return t.recoveryParam;
									for (var i = 0; i < 4; i++) {
										var o;
										try {
											o = this.recoverPubKey(e, t, i)
										} catch (e) {
											continue
										}
										if (o.eq(r)) return i
									}
									throw new Error("Unable to find valid recovery factor")
								}
							}, {
								"../curves": 96,
								"../utils": 104,
								"./key": 98,
								"./signature": 99,
								"bn.js": 19,
								brorand: 20,
								"hmac-drbg": 145
							}],
							98: [function(e, t, r) {
								"use strict";
								var n = e("bn.js"),
									i = e("../utils").assert;

								function o(e, t) {
									this.ec = e, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc)
								}
								t.exports = o, o.fromPublic = function(e, t, r) {
									return t instanceof o ? t : new o(e, {
										pub: t,
										pubEnc: r
									})
								}, o.fromPrivate = function(e, t, r) {
									return t instanceof o ? t : new o(e, {
										priv: t,
										privEnc: r
									})
								}, o.prototype.validate = function() {
									var e = this.getPublic();
									return e.isInfinity() ? {
										result: !1,
										reason: "Invalid public key"
									} : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {
										result: !0,
										reason: null
									} : {
										result: !1,
										reason: "Public key * N != O"
									} : {
										result: !1,
										reason: "Public key is not a point"
									}
								}, o.prototype.getPublic = function(e, t) {
									return "string" == typeof e && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub
								}, o.prototype.getPrivate = function(e) {
									return "hex" === e ? this.priv.toString(16, 2) : this.priv
								}, o.prototype._importPrivate = function(e, t) {
									this.priv = new n(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n)
								}, o.prototype._importPublic = function(e, t) {
									if (e.x || e.y) return "mont" === this.ec.curve.type ? i(e.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || i(e.x && e.y, "Need both x and y coordinate"), void(this.pub = this.ec.curve.point(e.x, e.y));
									this.pub = this.ec.curve.decodePoint(e, t)
								}, o.prototype.derive = function(e) {
									return e.validate() || i(e.validate(), "public point not validated"), e.mul(this.priv).getX()
								}, o.prototype.sign = function(e, t, r) {
									return this.ec.sign(e, this, t, r)
								}, o.prototype.verify = function(e, t) {
									return this.ec.verify(e, t, this)
								}, o.prototype.inspect = function() {
									return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
								}
							}, {
								"../utils": 104,
								"bn.js": 19
							}],
							99: [function(e, t, r) {
								"use strict";
								var n = e("bn.js"),
									i = e("../utils"),
									o = i.assert;

								function s(e, t) {
									if (e instanceof s) return e;
									this._importDER(e, t) || (o(e.r && e.s, "Signature without r or s"), this.r = new n(e.r, 16), this.s = new n(e.s, 16), void 0 === e.recoveryParam ? this.recoveryParam = null : this.recoveryParam = e.recoveryParam)
								}

								function a() {
									this.place = 0
								}

								function c(e, t) {
									var r = e[t.place++];
									if (!(128 & r)) return r;
									var n = 15 & r;
									if (0 === n || n > 4) return !1;
									for (var i = 0, o = 0, s = t.place; o < n; o++, s++) i <<= 8, i |= e[s], i >>>= 0;
									return !(i <= 127) && (t.place = s, i)
								}

								function l(e) {
									for (var t = 0, r = e.length - 1; !e[t] && !(128 & e[t + 1]) && t < r;) t++;
									return 0 === t ? e : e.slice(t)
								}

								function u(e, t) {
									if (t < 128) e.push(t);
									else {
										var r = 1 + (Math.log(t) / Math.LN2 >>> 3);
										for (e.push(128 | r); --r;) e.push(t >>> (r << 3) & 255);
										e.push(t)
									}
								}
								t.exports = s, s.prototype._importDER = function(e, t) {
									e = i.toArray(e, t);
									var r = new a;
									if (48 !== e[r.place++]) return !1;
									var o = c(e, r);
									if (!1 === o) return !1;
									if (o + r.place !== e.length) return !1;
									if (2 !== e[r.place++]) return !1;
									var s = c(e, r);
									if (!1 === s) return !1;
									var l = e.slice(r.place, s + r.place);
									if (r.place += s, 2 !== e[r.place++]) return !1;
									var u = c(e, r);
									if (!1 === u) return !1;
									if (e.length !== u + r.place) return !1;
									var d = e.slice(r.place, u + r.place);
									if (0 === l[0]) {
										if (!(128 & l[1])) return !1;
										l = l.slice(1)
									}
									if (0 === d[0]) {
										if (!(128 & d[1])) return !1;
										d = d.slice(1)
									}
									return this.r = new n(l), this.s = new n(d), this.recoveryParam = null, !0
								}, s.prototype.toDER = function(e) {
									var t = this.r.toArray(),
										r = this.s.toArray();
									for (128 & t[0] && (t = [0].concat(t)), 128 & r[0] && (r = [0].concat(r)), t = l(t), r = l(r); !(r[0] || 128 & r[1]);) r = r.slice(1);
									var n = [2];
									u(n, t.length), (n = n.concat(t)).push(2), u(n, r.length);
									var o = n.concat(r),
										s = [48];
									return u(s, o.length), s = s.concat(o), i.encode(s, e)
								}
							}, {
								"../utils": 104,
								"bn.js": 19
							}],
							100: [function(e, t, r) {
								"use strict";
								var n = e("hash.js"),
									i = e("../curves"),
									o = e("../utils"),
									s = o.assert,
									a = o.parseBytes,
									c = e("./key"),
									l = e("./signature");

								function u(e) {
									if (s("ed25519" === e, "only tested with ed25519 so far"), !(this instanceof u)) return new u(e);
									e = i[e].curve, this.curve = e, this.g = e.g, this.g.precompute(e.n.bitLength() + 1), this.pointClass = e.point().constructor, this.encodingLength = Math.ceil(e.n.bitLength() / 8), this.hash = n.sha512
								}
								t.exports = u, u.prototype.sign = function(e, t) {
									e = a(e);
									var r = this.keyFromSecret(t),
										n = this.hashInt(r.messagePrefix(), e),
										i = this.g.mul(n),
										o = this.encodePoint(i),
										s = this.hashInt(o, r.pubBytes(), e).mul(r.priv()),
										c = n.add(s).umod(this.curve.n);
									return this.makeSignature({
										R: i,
										S: c,
										Rencoded: o
									})
								}, u.prototype.verify = function(e, t, r) {
									e = a(e), t = this.makeSignature(t);
									var n = this.keyFromPublic(r),
										i = this.hashInt(t.Rencoded(), n.pubBytes(), e),
										o = this.g.mul(t.S());
									return t.R().add(n.pub().mul(i)).eq(o)
								}, u.prototype.hashInt = function() {
									for (var e = this.hash(), t = 0; t < arguments.length; t++) e.update(arguments[t]);
									return o.intFromLE(e.digest()).umod(this.curve.n)
								}, u.prototype.keyFromPublic = function(e) {
									return c.fromPublic(this, e)
								}, u.prototype.keyFromSecret = function(e) {
									return c.fromSecret(this, e)
								}, u.prototype.makeSignature = function(e) {
									return e instanceof l ? e : new l(this, e)
								}, u.prototype.encodePoint = function(e) {
									var t = e.getY().toArray("le", this.encodingLength);
									return t[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, t
								}, u.prototype.decodePoint = function(e) {
									var t = (e = o.parseBytes(e)).length - 1,
										r = e.slice(0, t).concat(-129 & e[t]),
										n = 0 != (128 & e[t]),
										i = o.intFromLE(r);
									return this.curve.pointFromY(i, n)
								}, u.prototype.encodeInt = function(e) {
									return e.toArray("le", this.encodingLength)
								}, u.prototype.decodeInt = function(e) {
									return o.intFromLE(e)
								}, u.prototype.isPoint = function(e) {
									return e instanceof this.pointClass
								}
							}, {
								"../curves": 96,
								"../utils": 104,
								"./key": 101,
								"./signature": 102,
								"hash.js": 133
							}],
							101: [function(e, t, r) {
								"use strict";
								var n = e("../utils"),
									i = n.assert,
									o = n.parseBytes,
									s = n.cachedProperty;

								function a(e, t) {
									this.eddsa = e, this._secret = o(t.secret), e.isPoint(t.pub) ? this._pub = t.pub : this._pubBytes = o(t.pub)
								}
								a.fromPublic = function(e, t) {
									return t instanceof a ? t : new a(e, {
										pub: t
									})
								}, a.fromSecret = function(e, t) {
									return t instanceof a ? t : new a(e, {
										secret: t
									})
								}, a.prototype.secret = function() {
									return this._secret
								}, s(a, "pubBytes", (function() {
									return this.eddsa.encodePoint(this.pub())
								})), s(a, "pub", (function() {
									return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv())
								})), s(a, "privBytes", (function() {
									var e = this.eddsa,
										t = this.hash(),
										r = e.encodingLength - 1,
										n = t.slice(0, e.encodingLength);
									return n[0] &= 248, n[r] &= 127, n[r] |= 64, n
								})), s(a, "priv", (function() {
									return this.eddsa.decodeInt(this.privBytes())
								})), s(a, "hash", (function() {
									return this.eddsa.hash().update(this.secret()).digest()
								})), s(a, "messagePrefix", (function() {
									return this.hash().slice(this.eddsa.encodingLength)
								})), a.prototype.sign = function(e) {
									return i(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this)
								}, a.prototype.verify = function(e, t) {
									return this.eddsa.verify(e, t, this)
								}, a.prototype.getSecret = function(e) {
									return i(this._secret, "KeyPair is public only"), n.encode(this.secret(), e)
								}, a.prototype.getPublic = function(e) {
									return n.encode(this.pubBytes(), e)
								}, t.exports = a
							}, {
								"../utils": 104
							}],
							102: [function(e, t, r) {
								"use strict";
								var n = e("bn.js"),
									i = e("../utils"),
									o = i.assert,
									s = i.cachedProperty,
									a = i.parseBytes;

								function c(e, t) {
									this.eddsa = e, "object" != typeof t && (t = a(t)), Array.isArray(t) && (t = {
										R: t.slice(0, e.encodingLength),
										S: t.slice(e.encodingLength)
									}), o(t.R && t.S, "Signature without R or S"), e.isPoint(t.R) && (this._R = t.R), t.S instanceof n && (this._S = t.S), this._Rencoded = Array.isArray(t.R) ? t.R : t.Rencoded, this._Sencoded = Array.isArray(t.S) ? t.S : t.Sencoded
								}
								s(c, "S", (function() {
									return this.eddsa.decodeInt(this.Sencoded())
								})), s(c, "R", (function() {
									return this.eddsa.decodePoint(this.Rencoded())
								})), s(c, "Rencoded", (function() {
									return this.eddsa.encodePoint(this.R())
								})), s(c, "Sencoded", (function() {
									return this.eddsa.encodeInt(this.S())
								})), c.prototype.toBytes = function() {
									return this.Rencoded().concat(this.Sencoded())
								}, c.prototype.toHex = function() {
									return i.encode(this.toBytes(), "hex").toUpperCase()
								}, t.exports = c
							}, {
								"../utils": 104,
								"bn.js": 19
							}],
							103: [function(e, t, r) {
								t.exports = {
									doubles: {
										step: 4,
										points: [
											["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],
											["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],
											["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],
											["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],
											["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],
											["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],
											["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],
											["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],
											["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],
											["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],
											["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],
											["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],
											["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],
											["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],
											["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],
											["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],
											["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],
											["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],
											["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],
											["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],
											["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],
											["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],
											["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],
											["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],
											["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],
											["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],
											["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],
											["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],
											["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],
											["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],
											["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],
											["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],
											["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],
											["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],
											["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],
											["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],
											["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],
											["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],
											["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],
											["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],
											["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],
											["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],
											["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],
											["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],
											["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],
											["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],
											["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],
											["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],
											["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],
											["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],
											["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],
											["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],
											["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],
											["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],
											["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],
											["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],
											["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],
											["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],
											["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],
											["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],
											["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],
											["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],
											["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],
											["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],
											["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]
										]
									},
									naf: {
										wnd: 7,
										points: [
											["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],
											["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],
											["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],
											["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],
											["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],
											["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],
											["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],
											["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],
											["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],
											["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],
											["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],
											["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],
											["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],
											["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],
											["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],
											["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],
											["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],
											["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],
											["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],
											["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],
											["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],
											["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],
											["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],
											["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],
											["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],
											["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],
											["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],
											["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],
											["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],
											["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],
											["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],
											["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],
											["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],
											["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],
											["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],
											["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],
											["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],
											["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],
											["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],
											["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],
											["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],
											["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],
											["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],
											["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],
											["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],
											["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],
											["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],
											["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],
											["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],
											["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],
											["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],
											["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],
											["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],
											["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],
											["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],
											["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],
											["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],
											["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],
											["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],
											["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],
											["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],
											["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],
											["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],
											["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],
											["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],
											["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],
											["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],
											["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],
											["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],
											["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],
											["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],
											["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],
											["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],
											["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],
											["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],
											["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],
											["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],
											["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],
											["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],
											["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],
											["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],
											["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],
											["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],
											["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],
											["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],
											["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],
											["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],
											["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],
											["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],
											["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],
											["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],
											["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],
											["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],
											["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],
											["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],
											["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],
											["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],
											["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],
											["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],
											["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],
											["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],
											["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],
											["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],
											["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],
											["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],
											["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],
											["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],
											["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],
											["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],
											["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],
											["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],
											["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],
											["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],
											["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],
											["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],
											["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],
											["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],
											["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],
											["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],
											["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],
											["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],
											["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],
											["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],
											["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],
											["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],
											["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],
											["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]
										]
									}
								}
							}, {}],
							104: [function(e, t, r) {
								"use strict";
								var n = r,
									i = e("bn.js"),
									o = e("minimalistic-assert"),
									s = e("minimalistic-crypto-utils");
								n.assert = o, n.toArray = s.toArray, n.zero2 = s.zero2, n.toHex = s.toHex, n.encode = s.encode, n.getNAF = function(e, t, r) {
									var n = new Array(Math.max(e.bitLength(), r) + 1);
									n.fill(0);
									for (var i = 1 << t + 1, o = e.clone(), s = 0; s < n.length; s++) {
										var a, c = o.andln(i - 1);
										o.isOdd() ? (a = c > (i >> 1) - 1 ? (i >> 1) - c : c, o.isubn(a)) : a = 0, n[s] = a, o.iushrn(1)
									}
									return n
								}, n.getJSF = function(e, t) {
									var r = [
										[],
										[]
									];
									e = e.clone(), t = t.clone();
									for (var n, i = 0, o = 0; e.cmpn(-i) > 0 || t.cmpn(-o) > 0;) {
										var s, a, c = e.andln(3) + i & 3,
											l = t.andln(3) + o & 3;
										3 === c && (c = -1), 3 === l && (l = -1), s = 0 == (1 & c) ? 0 : 3 !== (n = e.andln(7) + i & 7) && 5 !== n || 2 !== l ? c : -c, r[0].push(s), a = 0 == (1 & l) ? 0 : 3 !== (n = t.andln(7) + o & 7) && 5 !== n || 2 !== c ? l : -l, r[1].push(a), 2 * i === s + 1 && (i = 1 - i), 2 * o === a + 1 && (o = 1 - o), e.iushrn(1), t.iushrn(1)
									}
									return r
								}, n.cachedProperty = function(e, t, r) {
									var n = "_" + t;
									e.prototype[t] = function() {
										return void 0 !== this[n] ? this[n] : this[n] = r.call(this)
									}
								}, n.parseBytes = function(e) {
									return "string" == typeof e ? n.toArray(e, "hex") : e
								}, n.intFromLE = function(e) {
									return new i(e, "hex", "le")
								}
							}, {
								"bn.js": 19,
								"minimalistic-assert": 224,
								"minimalistic-crypto-utils": 225
							}],
							105: [function(e, t, r) {
								t.exports = {
									name: "elliptic",
									version: "6.5.4",
									description: "EC cryptography",
									main: "lib/elliptic.js",
									files: ["lib"],
									scripts: {
										lint: "eslint lib test",
										"lint:fix": "npm run lint -- --fix",
										unit: "istanbul test _mocha --reporter=spec test/index.js",
										test: "npm run lint && npm run unit",
										version: "grunt dist && git add dist/"
									},
									repository: {
										type: "git",
										url: "git@github.com:indutny/elliptic"
									},
									keywords: ["EC", "Elliptic", "curve", "Cryptography"],
									author: "Fedor Indutny <fedor@indutny.com>",
									license: "MIT",
									bugs: {
										url: "https://github.com/indutny/elliptic/issues"
									},
									homepage: "https://github.com/indutny/elliptic",
									devDependencies: {
										brfs: "^2.0.2",
										coveralls: "^3.1.0",
										eslint: "^7.6.0",
										grunt: "^1.2.1",
										"grunt-browserify": "^5.3.0",
										"grunt-cli": "^1.3.2",
										"grunt-contrib-connect": "^3.0.0",
										"grunt-contrib-copy": "^1.0.0",
										"grunt-contrib-uglify": "^5.0.0",
										"grunt-mocha-istanbul": "^5.0.2",
										"grunt-saucelabs": "^9.0.1",
										istanbul: "^0.4.5",
										mocha: "^8.0.1"
									},
									dependencies: {
										"bn.js": "^4.11.9",
										brorand: "^1.1.0",
										"hash.js": "^1.0.0",
										"hmac-drbg": "^1.0.1",
										inherits: "^2.0.4",
										"minimalistic-assert": "^1.0.1",
										"minimalistic-crypto-utils": "^1.0.1"
									}
								}
							}, {}],
							106: [function(e, t, r) {
								"use strict";
								var n, i = "object" == typeof Reflect ? Reflect : null,
									o = i && "function" == typeof i.apply ? i.apply : function(e, t, r) {
										return Function.prototype.apply.call(e, t, r)
									};
								n = i && "function" == typeof i.ownKeys ? i.ownKeys : Object.getOwnPropertySymbols ? function(e) {
									return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
								} : function(e) {
									return Object.getOwnPropertyNames(e)
								};
								var s = Number.isNaN || function(e) {
									return e != e
								};

								function a() {
									a.init.call(this)
								}
								t.exports = a, t.exports.once = function(e, t) {
									return new Promise((function(r, n) {
										function i(r) {
											e.removeListener(t, o), n(r)
										}

										function o() {
											"function" == typeof e.removeListener && e.removeListener("error", i), r([].slice.call(arguments))
										}
										m(e, t, o, {
											once: !0
										}), "error" !== t && function(e, t, r) {
											"function" == typeof e.on && m(e, "error", t, r)
										}(e, i, {
											once: !0
										})
									}))
								}, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._eventsCount = 0, a.prototype._maxListeners = void 0;
								var c = 10;

								function l(e) {
									if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
								}

								function u(e) {
									return void 0 === e._maxListeners ? a.defaultMaxListeners : e._maxListeners
								}

								function d(e, t, r, n) {
									var i, o, s, a;
									if (l(r), void 0 === (o = e._events) ? (o = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== o.newListener && (e.emit("newListener", t, r.listener ? r.listener : r), o = e._events), s = o[t]), void 0 === s) s = o[t] = r, ++e._eventsCount;
									else if ("function" == typeof s ? s = o[t] = n ? [r, s] : [s, r] : n ? s.unshift(r) : s.push(r), (i = u(e)) > 0 && s.length > i && !s.warned) {
										s.warned = !0;
										var c = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
										c.name = "MaxListenersExceededWarning", c.emitter = e, c.type = t, c.count = s.length, a = c, console && console.warn && console.warn(a)
									}
									return e
								}

								function h() {
									if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
								}

								function f(e, t, r) {
									var n = {
											fired: !1,
											wrapFn: void 0,
											target: e,
											type: t,
											listener: r
										},
										i = h.bind(n);
									return i.listener = r, n.wrapFn = i, i
								}

								function p(e, t, r) {
									var n = e._events;
									if (void 0 === n) return [];
									var i = n[t];
									return void 0 === i ? [] : "function" == typeof i ? r ? [i.listener || i] : [i] : r ? function(e) {
										for (var t = new Array(e.length), r = 0; r < t.length; ++r) t[r] = e[r].listener || e[r];
										return t
									}(i) : g(i, i.length)
								}

								function v(e) {
									var t = this._events;
									if (void 0 !== t) {
										var r = t[e];
										if ("function" == typeof r) return 1;
										if (void 0 !== r) return r.length
									}
									return 0
								}

								function g(e, t) {
									for (var r = new Array(t), n = 0; n < t; ++n) r[n] = e[n];
									return r
								}

								function m(e, t, r, n) {
									if ("function" == typeof e.on) n.once ? e.once(t, r) : e.on(t, r);
									else {
										if ("function" != typeof e.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
										e.addEventListener(t, (function i(o) {
											n.once && e.removeEventListener(t, i), r(o)
										}))
									}
								}
								Object.defineProperty(a, "defaultMaxListeners", {
									enumerable: !0,
									get: function() {
										return c
									},
									set: function(e) {
										if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
										c = e
									}
								}), a.init = function() {
									void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
								}, a.prototype.setMaxListeners = function(e) {
									if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
									return this._maxListeners = e, this
								}, a.prototype.getMaxListeners = function() {
									return u(this)
								}, a.prototype.emit = function(e) {
									for (var t = [], r = 1; r < arguments.length; r++) t.push(arguments[r]);
									var n = "error" === e,
										i = this._events;
									if (void 0 !== i) n = n && void 0 === i.error;
									else if (!n) return !1;
									if (n) {
										var s;
										if (t.length > 0 && (s = t[0]), s instanceof Error) throw s;
										var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
										throw a.context = s, a
									}
									var c = i[e];
									if (void 0 === c) return !1;
									if ("function" == typeof c) o(c, this, t);
									else {
										var l = c.length,
											u = g(c, l);
										for (r = 0; r < l; ++r) o(u[r], this, t)
									}
									return !0
								}, a.prototype.addListener = function(e, t) {
									return d(this, e, t, !1)
								}, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function(e, t) {
									return d(this, e, t, !0)
								}, a.prototype.once = function(e, t) {
									return l(t), this.on(e, f(this, e, t)), this
								}, a.prototype.prependOnceListener = function(e, t) {
									return l(t), this.prependListener(e, f(this, e, t)), this
								}, a.prototype.removeListener = function(e, t) {
									var r, n, i, o, s;
									if (l(t), void 0 === (n = this._events)) return this;
									if (void 0 === (r = n[e])) return this;
									if (r === t || r.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, r.listener || t));
									else if ("function" != typeof r) {
										for (i = -1, o = r.length - 1; o >= 0; o--)
											if (r[o] === t || r[o].listener === t) {
												s = r[o].listener, i = o;
												break
											} if (i < 0) return this;
										0 === i ? r.shift() : function(e, t) {
											for (; t + 1 < e.length; t++) e[t] = e[t + 1];
											e.pop()
										}(r, i), 1 === r.length && (n[e] = r[0]), void 0 !== n.removeListener && this.emit("removeListener", e, s || t)
									}
									return this
								}, a.prototype.off = a.prototype.removeListener, a.prototype.removeAllListeners = function(e) {
									var t, r, n;
									if (void 0 === (r = this._events)) return this;
									if (void 0 === r.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== r[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete r[e]), this;
									if (0 === arguments.length) {
										var i, o = Object.keys(r);
										for (n = 0; n < o.length; ++n) "removeListener" !== (i = o[n]) && this.removeAllListeners(i);
										return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
									}
									if ("function" == typeof(t = r[e])) this.removeListener(e, t);
									else if (void 0 !== t)
										for (n = t.length - 1; n >= 0; n--) this.removeListener(e, t[n]);
									return this
								}, a.prototype.listeners = function(e) {
									return p(this, e, !0)
								}, a.prototype.rawListeners = function(e) {
									return p(this, e, !1)
								}, a.listenerCount = function(e, t) {
									return "function" == typeof e.listenerCount ? e.listenerCount(t) : v.call(e, t)
								}, a.prototype.listenerCount = v, a.prototype.eventNames = function() {
									return this._eventsCount > 0 ? n(this._events) : []
								}
							}, {}],
							107: [function(e, t, r) {
								var n = e("safe-buffer").Buffer,
									i = e("md5.js");
								t.exports = function(e, t, r, o) {
									if (n.isBuffer(e) || (e = n.from(e, "binary")), t && (n.isBuffer(t) || (t = n.from(t, "binary")), 8 !== t.length)) throw new RangeError("salt should be Buffer with 8 byte length");
									for (var s = r / 8, a = n.alloc(s), c = n.alloc(o || 0), l = n.alloc(0); s > 0 || o > 0;) {
										var u = new i;
										u.update(l), u.update(e), t && u.update(t), l = u.digest();
										var d = 0;
										if (s > 0) {
											var h = a.length - s;
											d = Math.min(s, l.length), l.copy(a, h, 0, d), s -= d
										}
										if (d < l.length && o > 0) {
											var f = c.length - o,
												p = Math.min(o, l.length - d);
											l.copy(c, f, d, d + p), o -= p
										}
									}
									return l.fill(0), {
										key: a,
										iv: c
									}
								}
							}, {
								"md5.js": 222,
								"safe-buffer": 251
							}],
							108: [function(e, t, r) {
								"use strict";
								var n = e("is-callable"),
									i = Object.prototype.toString,
									o = Object.prototype.hasOwnProperty,
									s = function(e, t, r) {
										for (var n = 0, i = e.length; n < i; n++) o.call(e, n) && (null == r ? t(e[n], n, e) : t.call(r, e[n], n, e))
									},
									a = function(e, t, r) {
										for (var n = 0, i = e.length; n < i; n++) null == r ? t(e.charAt(n), n, e) : t.call(r, e.charAt(n), n, e)
									},
									c = function(e, t, r) {
										for (var n in e) o.call(e, n) && (null == r ? t(e[n], n, e) : t.call(r, e[n], n, e))
									};
								t.exports = function(e, t, r) {
									if (!n(t)) throw new TypeError("iterator must be a function");
									var o;
									arguments.length >= 3 && (o = r), "[object Array]" === i.call(e) ? s(e, t, o) : "string" == typeof e ? a(e, t, o) : c(e, t, o)
								}
							}, {
								"is-callable": 149
							}],
							109: [function(e, t, r) {
								"use strict";
								var n = "Function.prototype.bind called on incompatible ",
									i = Array.prototype.slice,
									o = Object.prototype.toString;
								t.exports = function(e) {
									var t = this;
									if ("function" != typeof t || "[object Function]" !== o.call(t)) throw new TypeError(n + t);
									for (var r, s = i.call(arguments, 1), a = function() {
											if (this instanceof r) {
												var n = t.apply(this, s.concat(i.call(arguments)));
												return Object(n) === n ? n : this
											}
											return t.apply(e, s.concat(i.call(arguments)))
										}, c = Math.max(0, t.length - s.length), l = [], u = 0; u < c; u++) l.push("$" + u);
									if (r = Function("binder", "return function (" + l.join(",") + "){ return binder.apply(this,arguments); }")(a), t.prototype) {
										var d = function() {};
										d.prototype = t.prototype, r.prototype = new d, d.prototype = null
									}
									return r
								}
							}, {}],
							110: [function(e, t, r) {
								"use strict";
								var n = e("./implementation");
								t.exports = Function.prototype.bind || n
							}, {
								"./implementation": 109
							}],
							111: [function(e, t, r) {
								"use strict";
								var n = SyntaxError,
									i = Function,
									o = TypeError,
									s = function(e) {
										try {
											return i('"use strict"; return (' + e + ").constructor;")()
										} catch (t) {}
									},
									a = Object.getOwnPropertyDescriptor;
								if (a) try {
									a({}, "")
								} catch (R) {
									a = null
								}
								var c = function() {
										throw new o
									},
									l = a ? function() {
										try {
											return arguments.callee, c
										} catch (e) {
											try {
												return a(arguments, "callee").get
											} catch (t) {
												return c
											}
										}
									}() : c,
									u = e("has-symbols")(),
									d = Object.getPrototypeOf || function(e) {
										return e.__proto__
									},
									h = {},
									f = "undefined" == typeof Uint8Array ? void 0 : d(Uint8Array),
									p = {
										"%AggregateError%": "undefined" == typeof AggregateError ? void 0 : AggregateError,
										"%Array%": Array,
										"%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer,
										"%ArrayIteratorPrototype%": u ? d([][Symbol.iterator]()) : void 0,
										"%AsyncFromSyncIteratorPrototype%": void 0,
										"%AsyncFunction%": h,
										"%AsyncGenerator%": h,
										"%AsyncGeneratorFunction%": h,
										"%AsyncIteratorPrototype%": h,
										"%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics,
										"%BigInt%": "undefined" == typeof BigInt ? void 0 : BigInt,
										"%Boolean%": Boolean,
										"%DataView%": "undefined" == typeof DataView ? void 0 : DataView,
										"%Date%": Date,
										"%decodeURI%": decodeURI,
										"%decodeURIComponent%": decodeURIComponent,
										"%encodeURI%": encodeURI,
										"%encodeURIComponent%": encodeURIComponent,
										"%Error%": Error,
										"%eval%": eval,
										"%EvalError%": EvalError,
										"%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array,
										"%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array,
										"%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? void 0 : FinalizationRegistry,
										"%Function%": i,
										"%GeneratorFunction%": h,
										"%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array,
										"%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array,
										"%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array,
										"%isFinite%": isFinite,
										"%isNaN%": isNaN,
										"%IteratorPrototype%": u ? d(d([][Symbol.iterator]())) : void 0,
										"%JSON%": "object" == typeof JSON ? JSON : void 0,
										"%Map%": "undefined" == typeof Map ? void 0 : Map,
										"%MapIteratorPrototype%": "undefined" != typeof Map && u ? d((new Map)[Symbol.iterator]()) : void 0,
										"%Math%": Math,
										"%Number%": Number,
										"%Object%": Object,
										"%parseFloat%": parseFloat,
										"%parseInt%": parseInt,
										"%Promise%": "undefined" == typeof Promise ? void 0 : Promise,
										"%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy,
										"%RangeError%": RangeError,
										"%ReferenceError%": ReferenceError,
										"%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect,
										"%RegExp%": RegExp,
										"%Set%": "undefined" == typeof Set ? void 0 : Set,
										"%SetIteratorPrototype%": "undefined" != typeof Set && u ? d((new Set)[Symbol.iterator]()) : void 0,
										"%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer,
										"%String%": String,
										"%StringIteratorPrototype%": u ? d("" [Symbol.iterator]()) : void 0,
										"%Symbol%": u ? Symbol : void 0,
										"%SyntaxError%": n,
										"%ThrowTypeError%": l,
										"%TypedArray%": f,
										"%TypeError%": o,
										"%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array,
										"%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray,
										"%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array,
										"%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array,
										"%URIError%": URIError,
										"%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap,
										"%WeakRef%": "undefined" == typeof WeakRef ? void 0 : WeakRef,
										"%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet
									},
									v = {
										"%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
										"%ArrayPrototype%": ["Array", "prototype"],
										"%ArrayProto_entries%": ["Array", "prototype", "entries"],
										"%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
										"%ArrayProto_keys%": ["Array", "prototype", "keys"],
										"%ArrayProto_values%": ["Array", "prototype", "values"],
										"%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
										"%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
										"%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
										"%BooleanPrototype%": ["Boolean", "prototype"],
										"%DataViewPrototype%": ["DataView", "prototype"],
										"%DatePrototype%": ["Date", "prototype"],
										"%ErrorPrototype%": ["Error", "prototype"],
										"%EvalErrorPrototype%": ["EvalError", "prototype"],
										"%Float32ArrayPrototype%": ["Float32Array", "prototype"],
										"%Float64ArrayPrototype%": ["Float64Array", "prototype"],
										"%FunctionPrototype%": ["Function", "prototype"],
										"%Generator%": ["GeneratorFunction", "prototype"],
										"%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
										"%Int8ArrayPrototype%": ["Int8Array", "prototype"],
										"%Int16ArrayPrototype%": ["Int16Array", "prototype"],
										"%Int32ArrayPrototype%": ["Int32Array", "prototype"],
										"%JSONParse%": ["JSON", "parse"],
										"%JSONStringify%": ["JSON", "stringify"],
										"%MapPrototype%": ["Map", "prototype"],
										"%NumberPrototype%": ["Number", "prototype"],
										"%ObjectPrototype%": ["Object", "prototype"],
										"%ObjProto_toString%": ["Object", "prototype", "toString"],
										"%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
										"%PromisePrototype%": ["Promise", "prototype"],
										"%PromiseProto_then%": ["Promise", "prototype", "then"],
										"%Promise_all%": ["Promise", "all"],
										"%Promise_reject%": ["Promise", "reject"],
										"%Promise_resolve%": ["Promise", "resolve"],
										"%RangeErrorPrototype%": ["RangeError", "prototype"],
										"%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
										"%RegExpPrototype%": ["RegExp", "prototype"],
										"%SetPrototype%": ["Set", "prototype"],
										"%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
										"%StringPrototype%": ["String", "prototype"],
										"%SymbolPrototype%": ["Symbol", "prototype"],
										"%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
										"%TypedArrayPrototype%": ["TypedArray", "prototype"],
										"%TypeErrorPrototype%": ["TypeError", "prototype"],
										"%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
										"%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
										"%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
										"%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
										"%URIErrorPrototype%": ["URIError", "prototype"],
										"%WeakMapPrototype%": ["WeakMap", "prototype"],
										"%WeakSetPrototype%": ["WeakSet", "prototype"]
									},
									g = e("function-bind"),
									m = e("has"),
									y = g.call(Function.call, Array.prototype.concat),
									b = g.call(Function.apply, Array.prototype.splice),
									_ = g.call(Function.call, String.prototype.replace),
									w = g.call(Function.call, String.prototype.slice),
									S = g.call(Function.call, RegExp.prototype.exec),
									E = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
									k = /\\(\\)?/g,
									T = function(e) {
										var t = w(e, 0, 1),
											r = w(e, -1);
										if ("%" === t && "%" !== r) throw new n("invalid intrinsic syntax, expected closing `%`");
										if ("%" === r && "%" !== t) throw new n("invalid intrinsic syntax, expected opening `%`");
										var i = [];
										return _(e, E, (function(e, t, r, n) {
											i[i.length] = r ? _(n, k, "$1") : t || e
										})), i
									},
									I = function(e, t) {
										var r, i = e;
										if (m(v, i) && (i = "%" + (r = v[i])[0] + "%"), m(p, i)) {
											var a = p[i];
											if (a === h && (a = function e(t) {
													var r;
													if ("%AsyncFunction%" === t) r = s("async function () {}");
													else if ("%GeneratorFunction%" === t) r = s("function* () {}");
													else if ("%AsyncGeneratorFunction%" === t) r = s("async function* () {}");
													else if ("%AsyncGenerator%" === t) {
														var n = e("%AsyncGeneratorFunction%");
														n && (r = n.prototype)
													} else if ("%AsyncIteratorPrototype%" === t) {
														var i = e("%AsyncGenerator%");
														i && (r = d(i.prototype))
													}
													return p[t] = r, r
												}(i)), void 0 === a && !t) throw new o("intrinsic " + e + " exists, but is not available. Please file an issue!");
											return {
												alias: r,
												name: i,
												value: a
											}
										}
										throw new n("intrinsic " + e + " does not exist!")
									};
								t.exports = function(e, t) {
									if ("string" != typeof e || 0 === e.length) throw new o("intrinsic name must be a non-empty string");
									if (arguments.length > 1 && "boolean" != typeof t) throw new o('"allowMissing" argument must be a boolean');
									if (null === S(/^%?[^%]*%?$/, e)) throw new n("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
									var r = T(e),
										i = r.length > 0 ? r[0] : "",
										s = I("%" + i + "%", t),
										c = s.name,
										l = s.value,
										u = !1,
										d = s.alias;
									d && (i = d[0], b(r, y([0, 1], d)));
									for (var h = 1, f = !0; h < r.length; h += 1) {
										var v = r[h],
											g = w(v, 0, 1),
											_ = w(v, -1);
										if (('"' === g || "'" === g || "`" === g || '"' === _ || "'" === _ || "`" === _) && g !== _) throw new n("property names with quotes must have matching quotes");
										if ("constructor" !== v && f || (u = !0), m(p, c = "%" + (i += "." + v) + "%")) l = p[c];
										else if (null != l) {
											if (!(v in l)) {
												if (!t) throw new o("base intrinsic for " + e + " exists, but the property is not available.");
												return
											}
											if (a && h + 1 >= r.length) {
												var E = a(l, v);
												l = (f = !!E) && "get" in E && !("originalValue" in E.get) ? E.get : l[v]
											} else f = m(l, v), l = l[v];
											f && !u && (p[c] = l)
										}
									}
									return l
								}
							}, {
								"function-bind": 110,
								has: 116,
								"has-symbols": 113
							}],
							112: [function(e, t, r) {
								"use strict";
								var n = e("get-intrinsic")("%Object.getOwnPropertyDescriptor%", !0);
								if (n) try {
									n([], "length")
								} catch (i) {
									n = null
								}
								t.exports = n
							}, {
								"get-intrinsic": 111
							}],
							113: [function(e, t, r) {
								"use strict";
								var n = "undefined" != typeof Symbol && Symbol,
									i = e("./shams");
								t.exports = function() {
									return "function" == typeof n && ("function" == typeof Symbol && ("symbol" == typeof n("foo") && ("symbol" == typeof Symbol("bar") && i())))
								}
							}, {
								"./shams": 114
							}],
							114: [function(e, t, r) {
								"use strict";
								t.exports = function() {
									if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return !1;
									if ("symbol" == typeof Symbol.iterator) return !0;
									var e = {},
										t = Symbol("test"),
										r = Object(t);
									if ("string" == typeof t) return !1;
									if ("[object Symbol]" !== Object.prototype.toString.call(t)) return !1;
									if ("[object Symbol]" !== Object.prototype.toString.call(r)) return !1;
									for (t in e[t] = 42, e) return !1;
									if ("function" == typeof Object.keys && 0 !== Object.keys(e).length) return !1;
									if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e).length) return !1;
									var n = Object.getOwnPropertySymbols(e);
									if (1 !== n.length || n[0] !== t) return !1;
									if (!Object.prototype.propertyIsEnumerable.call(e, t)) return !1;
									if ("function" == typeof Object.getOwnPropertyDescriptor) {
										var i = Object.getOwnPropertyDescriptor(e, t);
										if (42 !== i.value || !0 !== i.enumerable) return !1
									}
									return !0
								}
							}, {}],
							115: [function(e, t, r) {
								"use strict";
								var n = e("has-symbols/shams");
								t.exports = function() {
									return n() && !!Symbol.toStringTag
								}
							}, {
								"has-symbols/shams": 114
							}],
							116: [function(e, t, r) {
								"use strict";
								var n = e("function-bind");
								t.exports = n.call(Function.call, Object.prototype.hasOwnProperty)
							}, {
								"function-bind": 110
							}],
							117: [function(e, t, r) {
								"use strict";
								var n = e("safe-buffer").Buffer,
									i = e("readable-stream").Transform;

								function o(e) {
									i.call(this), this._block = n.allocUnsafe(e), this._blockSize = e, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1
								}
								e("inherits")(o, i), o.prototype._transform = function(e, t, r) {
									var n = null;
									try {
										this.update(e, t)
									} catch (i) {
										n = i
									}
									r(n)
								}, o.prototype._flush = function(e) {
									var t = null;
									try {
										this.push(this.digest())
									} catch (r) {
										t = r
									}
									e(t)
								}, o.prototype.update = function(e, t) {
									if (function(e, t) {
											if (!n.isBuffer(e) && "string" != typeof e) throw new TypeError(t + " must be a string or a buffer")
										}(e, "Data"), this._finalized) throw new Error("Digest already called");
									n.isBuffer(e) || (e = n.from(e, t));
									for (var r = this._block, i = 0; this._blockOffset + e.length - i >= this._blockSize;) {
										for (var o = this._blockOffset; o < this._blockSize;) r[o++] = e[i++];
										this._update(), this._blockOffset = 0
									}
									for (; i < e.length;) r[this._blockOffset++] = e[i++];
									for (var s = 0, a = 8 * e.length; a > 0; ++s) this._length[s] += a, (a = this._length[s] / 4294967296 | 0) > 0 && (this._length[s] -= 4294967296 * a);
									return this
								}, o.prototype._update = function() {
									throw new Error("_update is not implemented")
								}, o.prototype.digest = function(e) {
									if (this._finalized) throw new Error("Digest already called");
									this._finalized = !0;
									var t = this._digest();
									void 0 !== e && (t = t.toString(e)), this._block.fill(0), this._blockOffset = 0;
									for (var r = 0; r < 4; ++r) this._length[r] = 0;
									return t
								}, o.prototype._digest = function() {
									throw new Error("_digest is not implemented")
								}, t.exports = o
							}, {
								inherits: 147,
								"readable-stream": 132,
								"safe-buffer": 251
							}],
							118: [function(e, t, r) {
								arguments[4][51][0].apply(r, arguments)
							}, {
								dup: 51
							}],
							119: [function(e, t, r) {
								(function(r) {
									(function() {
										"use strict";
										var n = Object.keys || function(e) {
											var t = [];
											for (var r in e) t.push(r);
											return t
										};
										t.exports = l;
										var i = e("./_stream_readable"),
											o = e("./_stream_writable");
										e("inherits")(l, i);
										for (var s = n(o.prototype), a = 0; a < s.length; a++) {
											var c = s[a];
											l.prototype[c] || (l.prototype[c] = o.prototype[c])
										}

										function l(e) {
											if (!(this instanceof l)) return new l(e);
											i.call(this, e), o.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", u)))
										}

										function u() {
											this._writableState.ended || r.nextTick(d, this)
										}

										function d(e) {
											e.end()
										}
										Object.defineProperty(l.prototype, "writableHighWaterMark", {
											enumerable: !1,
											get: function() {
												return this._writableState.highWaterMark
											}
										}), Object.defineProperty(l.prototype, "writableBuffer", {
											enumerable: !1,
											get: function() {
												return this._writableState && this._writableState.getBuffer()
											}
										}), Object.defineProperty(l.prototype, "writableLength", {
											enumerable: !1,
											get: function() {
												return this._writableState.length
											}
										}), Object.defineProperty(l.prototype, "destroyed", {
											enumerable: !1,
											get: function() {
												return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed)
											},
											set: function(e) {
												void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e)
											}
										})
									}).call(this)
								}).call(this, e("_process"))
							}, {
								"./_stream_readable": 121,
								"./_stream_writable": 123,
								_process: 238,
								inherits: 147
							}],
							120: [function(e, t, r) {
								arguments[4][53][0].apply(r, arguments)
							}, {
								"./_stream_transform": 122,
								dup: 53,
								inherits: 147
							}],
							121: [function(t, r, n) {
								(function(e, n) {
									(function() {
										"use strict";
										var i;
										r.exports = T, T.ReadableState = k;
										t("events").EventEmitter;
										var o = function(e, t) {
												return e.listeners(t).length
											},
											s = t("./internal/streams/stream"),
											a = t("buffer").Buffer,
											c = n.Uint8Array || function() {};
										var l, u = t("util");
										l = u && u.debuglog ? u.debuglog("stream") : function() {};
										var d, h, f, p = t("./internal/streams/buffer_list"),
											v = t("./internal/streams/destroy"),
											g = t("./internal/streams/state").getHighWaterMark,
											m = t("../errors").codes,
											y = m.ERR_INVALID_ARG_TYPE,
											b = m.ERR_STREAM_PUSH_AFTER_EOF,
											_ = m.ERR_METHOD_NOT_IMPLEMENTED,
											w = m.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
										t("inherits")(T, s);
										var S = v.errorOrDestroy,
											E = ["error", "close", "destroy", "pause", "resume"];

										function k(e, r, n) {
											i = i || t("./_stream_duplex"), e = e || {}, "boolean" != typeof n && (n = r instanceof i), this.objectMode = !!e.objectMode, n && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = g(this, e, "readableHighWaterMark", n), this.buffer = new p, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== e.emitClose, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (d || (d = t("string_decoder/").StringDecoder), this.decoder = new d(e.encoding), this.encoding = e.encoding)
										}

										function T(e) {
											if (i = i || t("./_stream_duplex"), !(this instanceof T)) return new T(e);
											var r = this instanceof i;
											this._readableState = new k(e, this, r), this.readable = !0, e && ("function" == typeof e.read && (this._read = e.read), "function" == typeof e.destroy && (this._destroy = e.destroy)), s.call(this)
										}

										function I(e, t, r, n, i) {
											l("readableAddChunk", t);
											var o, s = e._readableState;
											if (null === t) s.reading = !1,
												function(e, t) {
													if (l("onEofChunk"), t.ended) return;
													if (t.decoder) {
														var r = t.decoder.end();
														r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length)
													}
													t.ended = !0, t.sync ? x(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, O(e)))
												}(e, s);
											else if (i || (o = function(e, t) {
													var r;
													n = t, a.isBuffer(n) || n instanceof c || "string" == typeof t || void 0 === t || e.objectMode || (r = new y("chunk", ["string", "Buffer", "Uint8Array"], t));
													var n;
													return r
												}(s, t)), o) S(e, o);
											else if (s.objectMode || t && t.length > 0)
												if ("string" == typeof t || s.objectMode || Object.getPrototypeOf(t) === a.prototype || (t = function(e) {
														return a.from(e)
													}(t)), n) s.endEmitted ? S(e, new w) : R(e, s, t, !0);
												else if (s.ended) S(e, new b);
											else {
												if (s.destroyed) return !1;
												s.reading = !1, s.decoder && !r ? (t = s.decoder.write(t), s.objectMode || 0 !== t.length ? R(e, s, t, !1) : A(e, s)) : R(e, s, t, !1)
											} else n || (s.reading = !1, A(e, s));
											return !s.ended && (s.length < s.highWaterMark || 0 === s.length)
										}

										function R(e, t, r, n) {
											t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && x(e)), A(e, t)
										}
										Object.defineProperty(T.prototype, "destroyed", {
											enumerable: !1,
											get: function() {
												return void 0 !== this._readableState && this._readableState.destroyed
											},
											set: function(e) {
												this._readableState && (this._readableState.destroyed = e)
											}
										}), T.prototype.destroy = v.destroy, T.prototype._undestroy = v.undestroy, T.prototype._destroy = function(e, t) {
											t(e)
										}, T.prototype.push = function(e, t) {
											var r, n = this._readableState;
											return n.objectMode ? r = !0 : "string" == typeof e && ((t = t || n.defaultEncoding) !== n.encoding && (e = a.from(e, t), t = ""), r = !0), I(this, e, t, !1, r)
										}, T.prototype.unshift = function(e) {
											return I(this, e, null, !0, !1)
										}, T.prototype.isPaused = function() {
											return !1 === this._readableState.flowing
										}, T.prototype.setEncoding = function(e) {
											d || (d = t("string_decoder/").StringDecoder);
											var r = new d(e);
											this._readableState.decoder = r, this._readableState.encoding = this._readableState.decoder.encoding;
											for (var n = this._readableState.buffer.head, i = ""; null !== n;) i += r.write(n.data), n = n.next;
											return this._readableState.buffer.clear(), "" !== i && this._readableState.buffer.push(i), this._readableState.length = i.length, this
										};
										var C = 1073741824;

										function M(e, t) {
											return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = function(e) {
												return e >= C ? e = C : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e
											}(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0))
										}

										function x(t) {
											var r = t._readableState;
											l("emitReadable", r.needReadable, r.emittedReadable), r.needReadable = !1, r.emittedReadable || (l("emitReadable", r.flowing), r.emittedReadable = !0, e.nextTick(O, t))
										}

										function O(e) {
											var t = e._readableState;
											l("emitReadable_", t.destroyed, t.length, t.ended), t.destroyed || !t.length && !t.ended || (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, N(e)
										}

										function A(t, r) {
											r.readingMore || (r.readingMore = !0, e.nextTick(P, t, r))
										}

										function P(e, t) {
											for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);) {
												var r = t.length;
												if (l("maybeReadMore read 0"), e.read(0), r === t.length) break
											}
											t.readingMore = !1
										}

										function D(e) {
											var t = e._readableState;
											t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume()
										}

										function j(e) {
											l("readable nexttick read 0"), e.read(0)
										}

										function L(e, t) {
											l("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), N(e), t.flowing && !t.reading && e.read(0)
										}

										function N(e) {
											var t = e._readableState;
											for (l("flow", t.flowing); t.flowing && null !== e.read(););
										}

										function B(e, t) {
											return 0 === t.length ? null : (t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (r = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r);
											var r
										}

										function U(t) {
											var r = t._readableState;
											l("endReadable", r.endEmitted), r.endEmitted || (r.ended = !0, e.nextTick(F, r, t))
										}

										function F(e, t) {
											if (l("endReadableNT", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
												var r = t._writableState;
												(!r || r.autoDestroy && r.finished) && t.destroy()
											}
										}

										function $(e, t) {
											for (var r = 0, n = e.length; r < n; r++)
												if (e[r] === t) return r;
											return -1
										}
										T.prototype.read = function(e) {
											l("read", e), e = parseInt(e, 10);
											var t = this._readableState,
												r = e;
											if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 !== t.highWaterMark ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return l("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? U(this) : x(this), null;
											if (0 === (e = M(e, t)) && t.ended) return 0 === t.length && U(this), null;
											var n, i = t.needReadable;
											return l("need readable", i), (0 === t.length || t.length - e < t.highWaterMark) && l("length less than watermark", i = !0), t.ended || t.reading ? l("reading or ended", i = !1) : i && (l("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = M(r, t))), null === (n = e > 0 ? B(e, t) : null) ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (t.ended || (t.needReadable = !0), r !== e && t.ended && U(this)), null !== n && this.emit("data", n), n
										}, T.prototype._read = function(e) {
											S(this, new _("_read()"))
										}, T.prototype.pipe = function(t, r) {
											var n = this,
												i = this._readableState;
											switch (i.pipesCount) {
												case 0:
													i.pipes = t;
													break;
												case 1:
													i.pipes = [i.pipes, t];
													break;
												default:
													i.pipes.push(t)
											}
											i.pipesCount += 1, l("pipe count=%d opts=%j", i.pipesCount, r);
											var s = (!r || !1 !== r.end) && t !== e.stdout && t !== e.stderr ? c : g;

											function a(e, r) {
												l("onunpipe"), e === n && r && !1 === r.hasUnpiped && (r.hasUnpiped = !0, l("cleanup"), t.removeListener("close", p), t.removeListener("finish", v), t.removeListener("drain", u), t.removeListener("error", f), t.removeListener("unpipe", a), n.removeListener("end", c), n.removeListener("end", g), n.removeListener("data", h), d = !0, !i.awaitDrain || t._writableState && !t._writableState.needDrain || u())
											}

											function c() {
												l("onend"), t.end()
											}
											i.endEmitted ? e.nextTick(s) : n.once("end", s), t.on("unpipe", a);
											var u = function(e) {
												return function() {
													var t = e._readableState;
													l("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && o(e, "data") && (t.flowing = !0, N(e))
												}
											}(n);
											t.on("drain", u);
											var d = !1;

											function h(e) {
												l("ondata");
												var r = t.write(e);
												l("dest.write", r), !1 === r && ((1 === i.pipesCount && i.pipes === t || i.pipesCount > 1 && -1 !== $(i.pipes, t)) && !d && (l("false write response, pause", i.awaitDrain), i.awaitDrain++), n.pause())
											}

											function f(e) {
												l("onerror", e), g(), t.removeListener("error", f), 0 === o(t, "error") && S(t, e)
											}

											function p() {
												t.removeListener("finish", v), g()
											}

											function v() {
												l("onfinish"), t.removeListener("close", p), g()
											}

											function g() {
												l("unpipe"), n.unpipe(t)
											}
											return n.on("data", h),
												function(e, t, r) {
													if ("function" == typeof e.prependListener) return e.prependListener(t, r);
													e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]] : e.on(t, r)
												}(t, "error", f), t.once("close", p), t.once("finish", v), t.emit("pipe", n), i.flowing || (l("pipe resume"), n.resume()), t
										}, T.prototype.unpipe = function(e) {
											var t = this._readableState,
												r = {
													hasUnpiped: !1
												};
											if (0 === t.pipesCount) return this;
											if (1 === t.pipesCount) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r), this);
											if (!e) {
												var n = t.pipes,
													i = t.pipesCount;
												t.pipes = null, t.pipesCount = 0, t.flowing = !1;
												for (var o = 0; o < i; o++) n[o].emit("unpipe", this, {
													hasUnpiped: !1
												});
												return this
											}
											var s = $(t.pipes, e);
											return -1 === s ? this : (t.pipes.splice(s, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this)
										}, T.prototype.on = function(t, r) {
											var n = s.prototype.on.call(this, t, r),
												i = this._readableState;
											return "data" === t ? (i.readableListening = this.listenerCount("readable") > 0, !1 !== i.flowing && this.resume()) : "readable" === t && (i.endEmitted || i.readableListening || (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, l("on readable", i.length, i.reading), i.length ? x(this) : i.reading || e.nextTick(j, this))), n
										}, T.prototype.addListener = T.prototype.on, T.prototype.removeListener = function(t, r) {
											var n = s.prototype.removeListener.call(this, t, r);
											return "readable" === t && e.nextTick(D, this), n
										}, T.prototype.removeAllListeners = function(t) {
											var r = s.prototype.removeAllListeners.apply(this, arguments);
											return "readable" !== t && void 0 !== t || e.nextTick(D, this), r
										}, T.prototype.resume = function() {
											var t = this._readableState;
											return t.flowing || (l("resume"), t.flowing = !t.readableListening, function(t, r) {
												r.resumeScheduled || (r.resumeScheduled = !0, e.nextTick(L, t, r))
											}(this, t)), t.paused = !1, this
										}, T.prototype.pause = function() {
											return l("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this
										}, T.prototype.wrap = function(e) {
											var t = this,
												r = this._readableState,
												n = !1;
											for (var i in e.on("end", (function() {
													if (l("wrapped end"), r.decoder && !r.ended) {
														var e = r.decoder.end();
														e && e.length && t.push(e)
													}
													t.push(null)
												})), e.on("data", (function(i) {
													(l("wrapped data"), r.decoder && (i = r.decoder.write(i)), r.objectMode && null == i) || (r.objectMode || i && i.length) && (t.push(i) || (n = !0, e.pause()))
												})), e) void 0 === this[i] && "function" == typeof e[i] && (this[i] = function(t) {
												return function() {
													return e[t].apply(e, arguments)
												}
											}(i));
											for (var o = 0; o < E.length; o++) e.on(E[o], this.emit.bind(this, E[o]));
											return this._read = function(t) {
												l("wrapped _read", t), n && (n = !1, e.resume())
											}, this
										}, "function" == typeof Symbol && (T.prototype[Symbol.asyncIterator] = function() {
											return void 0 === h && (h = t("./internal/streams/async_iterator")), h(this)
										}), Object.defineProperty(T.prototype, "readableHighWaterMark", {
											enumerable: !1,
											get: function() {
												return this._readableState.highWaterMark
											}
										}), Object.defineProperty(T.prototype, "readableBuffer", {
											enumerable: !1,
											get: function() {
												return this._readableState && this._readableState.buffer
											}
										}), Object.defineProperty(T.prototype, "readableFlowing", {
											enumerable: !1,
											get: function() {
												return this._readableState.flowing
											},
											set: function(e) {
												this._readableState && (this._readableState.flowing = e)
											}
										}), T._fromList = B, Object.defineProperty(T.prototype, "readableLength", {
											enumerable: !1,
											get: function() {
												return this._readableState.length
											}
										}), "function" == typeof Symbol && (T.from = function(e, r) {
											return void 0 === f && (f = t("./internal/streams/from")), f(T, e, r)
										})
									}).call(this)
								}).call(this, t("_process"), void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"../errors": 118,
								"./_stream_duplex": 119,
								"./internal/streams/async_iterator": 124,
								"./internal/streams/buffer_list": 125,
								"./internal/streams/destroy": 126,
								"./internal/streams/from": 128,
								"./internal/streams/state": 130,
								"./internal/streams/stream": 131,
								_process: 238,
								buffer: 69,
								events: 106,
								inherits: 147,
								"string_decoder/": 280,
								util: 21
							}],
							122: [function(e, t, r) {
								arguments[4][55][0].apply(r, arguments)
							}, {
								"../errors": 118,
								"./_stream_duplex": 119,
								dup: 55,
								inherits: 147
							}],
							123: [function(t, r, n) {
								(function(e, n) {
									(function() {
										"use strict";

										function i(e) {
											var t = this;
											this.next = null, this.entry = null, this.finish = function() {
												! function(e, t, r) {
													var n = e.entry;
													e.entry = null;
													for (; n;) {
														var i = n.callback;
														t.pendingcb--, i(r), n = n.next
													}
													t.corkedRequestsFree.next = e
												}(t, e)
											}
										}
										var o;
										r.exports = T, T.WritableState = k;
										var s = {
												deprecate: t("util-deprecate")
											},
											a = t("./internal/streams/stream"),
											c = t("buffer").Buffer,
											l = n.Uint8Array || function() {};
										var u, d = t("./internal/streams/destroy"),
											h = t("./internal/streams/state").getHighWaterMark,
											f = t("../errors").codes,
											p = f.ERR_INVALID_ARG_TYPE,
											v = f.ERR_METHOD_NOT_IMPLEMENTED,
											g = f.ERR_MULTIPLE_CALLBACK,
											m = f.ERR_STREAM_CANNOT_PIPE,
											y = f.ERR_STREAM_DESTROYED,
											b = f.ERR_STREAM_NULL_VALUES,
											_ = f.ERR_STREAM_WRITE_AFTER_END,
											w = f.ERR_UNKNOWN_ENCODING,
											S = d.errorOrDestroy;

										function E() {}

										function k(r, n, s) {
											o = o || t("./_stream_duplex"), r = r || {}, "boolean" != typeof s && (s = n instanceof o), this.objectMode = !!r.objectMode, s && (this.objectMode = this.objectMode || !!r.writableObjectMode), this.highWaterMark = h(this, r, "writableHighWaterMark", s), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
											var a = !1 === r.decodeStrings;
											this.decodeStrings = !a, this.defaultEncoding = r.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(t) {
												! function(t, r) {
													var n = t._writableState,
														i = n.sync,
														o = n.writecb;
													if ("function" != typeof o) throw new g;
													if (function(e) {
															e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0
														}(n), r) ! function(t, r, n, i, o) {
														--r.pendingcb, n ? (e.nextTick(o, i), e.nextTick(O, t, r), t._writableState.errorEmitted = !0, S(t, i)) : (o(i), t._writableState.errorEmitted = !0, S(t, i), O(t, r))
													}(t, n, i, r, o);
													else {
														var s = M(n) || t.destroyed;
														s || n.corked || n.bufferProcessing || !n.bufferedRequest || C(t, n), i ? e.nextTick(R, t, n, s, o) : R(t, n, s, o)
													}
												}(n, t)
											}, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== r.emitClose, this.autoDestroy = !!r.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new i(this)
										}

										function T(e) {
											var r = this instanceof(o = o || t("./_stream_duplex"));
											if (!r && !u.call(T, this)) return new T(e);
											this._writableState = new k(e, this, r), this.writable = !0, e && ("function" == typeof e.write && (this._write = e.write), "function" == typeof e.writev && (this._writev = e.writev), "function" == typeof e.destroy && (this._destroy = e.destroy), "function" == typeof e.final && (this._final = e.final)), a.call(this)
										}

										function I(e, t, r, n, i, o, s) {
											t.writelen = n, t.writecb = s, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new y("write")) : r ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = !1
										}

										function R(e, t, r, n) {
											r || function(e, t) {
												0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"))
											}(e, t), t.pendingcb--, n(), O(e, t)
										}

										function C(e, t) {
											t.bufferProcessing = !0;
											var r = t.bufferedRequest;
											if (e._writev && r && r.next) {
												var n = t.bufferedRequestCount,
													o = new Array(n),
													s = t.corkedRequestsFree;
												s.entry = r;
												for (var a = 0, c = !0; r;) o[a] = r, r.isBuf || (c = !1), r = r.next, a += 1;
												o.allBuffers = c, I(e, t, !0, t.length, o, "", s.finish), t.pendingcb++, t.lastBufferedRequest = null, s.next ? (t.corkedRequestsFree = s.next, s.next = null) : t.corkedRequestsFree = new i(t), t.bufferedRequestCount = 0
											} else {
												for (; r;) {
													var l = r.chunk,
														u = r.encoding,
														d = r.callback;
													if (I(e, t, !1, t.objectMode ? 1 : l.length, l, u, d), r = r.next, t.bufferedRequestCount--, t.writing) break
												}
												null === r && (t.lastBufferedRequest = null)
											}
											t.bufferedRequest = r, t.bufferProcessing = !1
										}

										function M(e) {
											return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing
										}

										function x(e, t) {
											e._final((function(r) {
												t.pendingcb--, r && S(e, r), t.prefinished = !0, e.emit("prefinish"), O(e, t)
											}))
										}

										function O(t, r) {
											var n = M(r);
											if (n && (function(t, r) {
													r.prefinished || r.finalCalled || ("function" != typeof t._final || r.destroyed ? (r.prefinished = !0, t.emit("prefinish")) : (r.pendingcb++, r.finalCalled = !0, e.nextTick(x, t, r)))
												}(t, r), 0 === r.pendingcb && (r.finished = !0, t.emit("finish"), r.autoDestroy))) {
												var i = t._readableState;
												(!i || i.autoDestroy && i.endEmitted) && t.destroy()
											}
											return n
										}
										t("inherits")(T, a), k.prototype.getBuffer = function() {
												for (var e = this.bufferedRequest, t = []; e;) t.push(e), e = e.next;
												return t
											},
											function() {
												try {
													Object.defineProperty(k.prototype, "buffer", {
														get: s.deprecate((function() {
															return this.getBuffer()
														}), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
													})
												} catch (e) {}
											}(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (u = Function.prototype[Symbol.hasInstance], Object.defineProperty(T, Symbol.hasInstance, {
												value: function(e) {
													return !!u.call(this, e) || this === T && (e && e._writableState instanceof k)
												}
											})) : u = function(e) {
												return e instanceof this
											}, T.prototype.pipe = function() {
												S(this, new m)
											}, T.prototype.write = function(t, r, n) {
												var i, o = this._writableState,
													s = !1,
													a = !o.objectMode && (i = t, c.isBuffer(i) || i instanceof l);
												return a && !c.isBuffer(t) && (t = function(e) {
													return c.from(e)
												}(t)), "function" == typeof r && (n = r, r = null), a ? r = "buffer" : r || (r = o.defaultEncoding), "function" != typeof n && (n = E), o.ending ? function(t, r) {
													var n = new _;
													S(t, n), e.nextTick(r, n)
												}(this, n) : (a || function(t, r, n, i) {
													var o;
													return null === n ? o = new b : "string" == typeof n || r.objectMode || (o = new p("chunk", ["string", "Buffer"], n)), !o || (S(t, o), e.nextTick(i, o), !1)
												}(this, o, t, n)) && (o.pendingcb++, s = function(e, t, r, n, i, o) {
													if (!r) {
														var s = function(e, t, r) {
															e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = c.from(t, r));
															return t
														}(t, n, i);
														n !== s && (r = !0, i = "buffer", n = s)
													}
													var a = t.objectMode ? 1 : n.length;
													t.length += a;
													var l = t.length < t.highWaterMark;
													l || (t.needDrain = !0);
													if (t.writing || t.corked) {
														var u = t.lastBufferedRequest;
														t.lastBufferedRequest = {
															chunk: n,
															encoding: i,
															isBuf: r,
															callback: o,
															next: null
														}, u ? u.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1
													} else I(e, t, !1, a, n, i, o);
													return l
												}(this, o, a, t, r, n)), s
											}, T.prototype.cork = function() {
												this._writableState.corked++
											}, T.prototype.uncork = function() {
												var e = this._writableState;
												e.corked && (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || C(this, e))
											}, T.prototype.setDefaultEncoding = function(e) {
												if ("string" == typeof e && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new w(e);
												return this._writableState.defaultEncoding = e, this
											}, Object.defineProperty(T.prototype, "writableBuffer", {
												enumerable: !1,
												get: function() {
													return this._writableState && this._writableState.getBuffer()
												}
											}), Object.defineProperty(T.prototype, "writableHighWaterMark", {
												enumerable: !1,
												get: function() {
													return this._writableState.highWaterMark
												}
											}), T.prototype._write = function(e, t, r) {
												r(new v("_write()"))
											}, T.prototype._writev = null, T.prototype.end = function(t, r, n) {
												var i = this._writableState;
												return "function" == typeof t ? (n = t, t = null, r = null) : "function" == typeof r && (n = r, r = null), null != t && this.write(t, r), i.corked && (i.corked = 1, this.uncork()), i.ending || function(t, r, n) {
													r.ending = !0, O(t, r), n && (r.finished ? e.nextTick(n) : t.once("finish", n));
													r.ended = !0, t.writable = !1
												}(this, i, n), this
											}, Object.defineProperty(T.prototype, "writableLength", {
												enumerable: !1,
												get: function() {
													return this._writableState.length
												}
											}), Object.defineProperty(T.prototype, "destroyed", {
												enumerable: !1,
												get: function() {
													return void 0 !== this._writableState && this._writableState.destroyed
												},
												set: function(e) {
													this._writableState && (this._writableState.destroyed = e)
												}
											}), T.prototype.destroy = d.destroy, T.prototype._undestroy = d.undestroy, T.prototype._destroy = function(e, t) {
												t(e)
											}
									}).call(this)
								}).call(this, t("_process"), void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"../errors": 118,
								"./_stream_duplex": 119,
								"./internal/streams/destroy": 126,
								"./internal/streams/state": 130,
								"./internal/streams/stream": 131,
								_process: 238,
								buffer: 69,
								inherits: 147,
								"util-deprecate": 283
							}],
							124: [function(e, t, r) {
								(function(r) {
									(function() {
										"use strict";
										var n;

										function i(e, t, r) {
											return t in e ? Object.defineProperty(e, t, {
												value: r,
												enumerable: !0,
												configurable: !0,
												writable: !0
											}) : e[t] = r, e
										}
										var o = e("./end-of-stream"),
											s = Symbol("lastResolve"),
											a = Symbol("lastReject"),
											c = Symbol("error"),
											l = Symbol("ended"),
											u = Symbol("lastPromise"),
											d = Symbol("handlePromise"),
											h = Symbol("stream");

										function f(e, t) {
											return {
												value: e,
												done: t
											}
										}

										function p(e) {
											var t = e[s];
											if (null !== t) {
												var r = e[h].read();
												null !== r && (e[u] = null, e[s] = null, e[a] = null, t(f(r, !1)))
											}
										}

										function v(e) {
											r.nextTick(p, e)
										}
										var g = Object.getPrototypeOf((function() {})),
											m = Object.setPrototypeOf((i(n = {
												get stream() {
													return this[h]
												},
												next: function() {
													var e = this,
														t = this[c];
													if (null !== t) return Promise.reject(t);
													if (this[l]) return Promise.resolve(f(void 0, !0));
													if (this[h].destroyed) return new Promise((function(t, n) {
														r.nextTick((function() {
															e[c] ? n(e[c]) : t(f(void 0, !0))
														}))
													}));
													var n, i = this[u];
													if (i) n = new Promise(function(e, t) {
														return function(r, n) {
															e.then((function() {
																t[l] ? r(f(void 0, !0)) : t[d](r, n)
															}), n)
														}
													}(i, this));
													else {
														var o = this[h].read();
														if (null !== o) return Promise.resolve(f(o, !1));
														n = new Promise(this[d])
													}
													return this[u] = n, n
												}
											}, Symbol.asyncIterator, (function() {
												return this
											})), i(n, "return", (function() {
												var e = this;
												return new Promise((function(t, r) {
													e[h].destroy(null, (function(e) {
														e ? r(e) : t(f(void 0, !0))
													}))
												}))
											})), n), g);
										t.exports = function(e) {
											var t, r = Object.create(m, (i(t = {}, h, {
												value: e,
												writable: !0
											}), i(t, s, {
												value: null,
												writable: !0
											}), i(t, a, {
												value: null,
												writable: !0
											}), i(t, c, {
												value: null,
												writable: !0
											}), i(t, l, {
												value: e._readableState.endEmitted,
												writable: !0
											}), i(t, d, {
												value: function(e, t) {
													var n = r[h].read();
													n ? (r[u] = null, r[s] = null, r[a] = null, e(f(n, !1))) : (r[s] = e, r[a] = t)
												},
												writable: !0
											}), t));
											return r[u] = null, o(e, (function(e) {
												if (e && "ERR_STREAM_PREMATURE_CLOSE" !== e.code) {
													var t = r[a];
													return null !== t && (r[u] = null, r[s] = null, r[a] = null, t(e)), void(r[c] = e)
												}
												var n = r[s];
												null !== n && (r[u] = null, r[s] = null, r[a] = null, n(f(void 0, !0))), r[l] = !0
											})), e.on("readable", v.bind(null, r)), r
										}
									}).call(this)
								}).call(this, e("_process"))
							}, {
								"./end-of-stream": 127,
								_process: 238
							}],
							125: [function(e, t, r) {
								arguments[4][58][0].apply(r, arguments)
							}, {
								buffer: 69,
								dup: 58,
								util: 21
							}],
							126: [function(e, t, r) {
								(function(e) {
									(function() {
										"use strict";

										function r(e, t) {
											i(e, t), n(e)
										}

										function n(e) {
											e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close")
										}

										function i(e, t) {
											e.emit("error", t)
										}
										t.exports = {
											destroy: function(t, o) {
												var s = this,
													a = this._readableState && this._readableState.destroyed,
													c = this._writableState && this._writableState.destroyed;
												return a || c ? (o ? o(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(i, this, t)) : e.nextTick(i, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, (function(t) {
													!o && t ? s._writableState ? s._writableState.errorEmitted ? e.nextTick(n, s) : (s._writableState.errorEmitted = !0, e.nextTick(r, s, t)) : e.nextTick(r, s, t) : o ? (e.nextTick(n, s), o(t)) : e.nextTick(n, s)
												})), this)
											},
											undestroy: function() {
												this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
											},
											errorOrDestroy: function(e, t) {
												var r = e._readableState,
													n = e._writableState;
												r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t)
											}
										}
									}).call(this)
								}).call(this, e("_process"))
							}, {
								_process: 238
							}],
							127: [function(e, t, r) {
								arguments[4][60][0].apply(r, arguments)
							}, {
								"../../../errors": 118,
								dup: 60
							}],
							128: [function(e, t, r) {
								arguments[4][61][0].apply(r, arguments)
							}, {
								dup: 61
							}],
							129: [function(e, t, r) {
								arguments[4][62][0].apply(r, arguments)
							}, {
								"../../../errors": 118,
								"./end-of-stream": 127,
								dup: 62
							}],
							130: [function(e, t, r) {
								arguments[4][63][0].apply(r, arguments)
							}, {
								"../../../errors": 118,
								dup: 63
							}],
							131: [function(e, t, r) {
								arguments[4][64][0].apply(r, arguments)
							}, {
								dup: 64,
								events: 106
							}],
							132: [function(e, t, r) {
								arguments[4][65][0].apply(r, arguments)
							}, {
								"./lib/_stream_duplex.js": 119,
								"./lib/_stream_passthrough.js": 120,
								"./lib/_stream_readable.js": 121,
								"./lib/_stream_transform.js": 122,
								"./lib/_stream_writable.js": 123,
								"./lib/internal/streams/end-of-stream.js": 127,
								"./lib/internal/streams/pipeline.js": 129,
								dup: 65
							}],
							133: [function(e, t, r) {
								var n = r;
								n.utils = e("./hash/utils"), n.common = e("./hash/common"), n.sha = e("./hash/sha"), n.ripemd = e("./hash/ripemd"), n.hmac = e("./hash/hmac"), n.sha1 = n.sha.sha1, n.sha256 = n.sha.sha256, n.sha224 = n.sha.sha224, n.sha384 = n.sha.sha384, n.sha512 = n.sha.sha512, n.ripemd160 = n.ripemd.ripemd160
							}, {
								"./hash/common": 134,
								"./hash/hmac": 135,
								"./hash/ripemd": 136,
								"./hash/sha": 137,
								"./hash/utils": 144
							}],
							134: [function(e, t, r) {
								"use strict";
								var n = e("./utils"),
									i = e("minimalistic-assert");

								function o() {
									this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
								}
								r.BlockHash = o, o.prototype.update = function(e, t) {
									if (e = n.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
										var r = (e = this.pending).length % this._delta8;
										this.pending = e.slice(e.length - r, e.length), 0 === this.pending.length && (this.pending = null), e = n.join32(e, 0, e.length - r, this.endian);
										for (var i = 0; i < e.length; i += this._delta32) this._update(e, i, i + this._delta32)
									}
									return this
								}, o.prototype.digest = function(e) {
									return this.update(this._pad()), i(null === this.pending), this._digest(e)
								}, o.prototype._pad = function() {
									var e = this.pendingTotal,
										t = this._delta8,
										r = t - (e + this.padLength) % t,
										n = new Array(r + this.padLength);
									n[0] = 128;
									for (var i = 1; i < r; i++) n[i] = 0;
									if (e <<= 3, "big" === this.endian) {
										for (var o = 8; o < this.padLength; o++) n[i++] = 0;
										n[i++] = 0, n[i++] = 0, n[i++] = 0, n[i++] = 0, n[i++] = e >>> 24 & 255, n[i++] = e >>> 16 & 255, n[i++] = e >>> 8 & 255, n[i++] = 255 & e
									} else
										for (n[i++] = 255 & e, n[i++] = e >>> 8 & 255, n[i++] = e >>> 16 & 255, n[i++] = e >>> 24 & 255, n[i++] = 0, n[i++] = 0, n[i++] = 0, n[i++] = 0, o = 8; o < this.padLength; o++) n[i++] = 0;
									return n
								}
							}, {
								"./utils": 144,
								"minimalistic-assert": 224
							}],
							135: [function(e, t, r) {
								"use strict";
								var n = e("./utils"),
									i = e("minimalistic-assert");

								function o(e, t, r) {
									if (!(this instanceof o)) return new o(e, t, r);
									this.Hash = e, this.blockSize = e.blockSize / 8, this.outSize = e.outSize / 8, this.inner = null, this.outer = null, this._init(n.toArray(t, r))
								}
								t.exports = o, o.prototype._init = function(e) {
									e.length > this.blockSize && (e = (new this.Hash).update(e).digest()), i(e.length <= this.blockSize);
									for (var t = e.length; t < this.blockSize; t++) e.push(0);
									for (t = 0; t < e.length; t++) e[t] ^= 54;
									for (this.inner = (new this.Hash).update(e), t = 0; t < e.length; t++) e[t] ^= 106;
									this.outer = (new this.Hash).update(e)
								}, o.prototype.update = function(e, t) {
									return this.inner.update(e, t), this
								}, o.prototype.digest = function(e) {
									return this.outer.update(this.inner.digest()), this.outer.digest(e)
								}
							}, {
								"./utils": 144,
								"minimalistic-assert": 224
							}],
							136: [function(e, t, r) {
								"use strict";
								var n = e("./utils"),
									i = e("./common"),
									o = n.rotl32,
									s = n.sum32,
									a = n.sum32_3,
									c = n.sum32_4,
									l = i.BlockHash;

								function u() {
									if (!(this instanceof u)) return new u;
									l.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
								}

								function d(e, t, r, n) {
									return e <= 15 ? t ^ r ^ n : e <= 31 ? t & r | ~t & n : e <= 47 ? (t | ~r) ^ n : e <= 63 ? t & n | r & ~n : t ^ (r | ~n)
								}

								function h(e) {
									return e <= 15 ? 0 : e <= 31 ? 1518500249 : e <= 47 ? 1859775393 : e <= 63 ? 2400959708 : 2840853838
								}

								function f(e) {
									return e <= 15 ? 1352829926 : e <= 31 ? 1548603684 : e <= 47 ? 1836072691 : e <= 63 ? 2053994217 : 0
								}
								n.inherits(u, l), r.ripemd160 = u, u.blockSize = 512, u.outSize = 160, u.hmacStrength = 192, u.padLength = 64, u.prototype._update = function(e, t) {
									for (var r = this.h[0], n = this.h[1], i = this.h[2], l = this.h[3], u = this.h[4], y = r, b = n, _ = i, w = l, S = u, E = 0; E < 80; E++) {
										var k = s(o(c(r, d(E, n, i, l), e[p[E] + t], h(E)), g[E]), u);
										r = u, u = l, l = o(i, 10), i = n, n = k, k = s(o(c(y, d(79 - E, b, _, w), e[v[E] + t], f(E)), m[E]), S), y = S, S = w, w = o(_, 10), _ = b, b = k
									}
									k = a(this.h[1], i, w), this.h[1] = a(this.h[2], l, S), this.h[2] = a(this.h[3], u, y), this.h[3] = a(this.h[4], r, b), this.h[4] = a(this.h[0], n, _), this.h[0] = k
								}, u.prototype._digest = function(e) {
									return "hex" === e ? n.toHex32(this.h, "little") : n.split32(this.h, "little")
								};
								var p = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
									v = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
									g = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
									m = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]
							}, {
								"./common": 134,
								"./utils": 144
							}],
							137: [function(e, t, r) {
								"use strict";
								r.sha1 = e("./sha/1"), r.sha224 = e("./sha/224"), r.sha256 = e("./sha/256"), r.sha384 = e("./sha/384"), r.sha512 = e("./sha/512")
							}, {
								"./sha/1": 138,
								"./sha/224": 139,
								"./sha/256": 140,
								"./sha/384": 141,
								"./sha/512": 142
							}],
							138: [function(e, t, r) {
								"use strict";
								var n = e("../utils"),
									i = e("../common"),
									o = e("./common"),
									s = n.rotl32,
									a = n.sum32,
									c = n.sum32_5,
									l = o.ft_1,
									u = i.BlockHash,
									d = [1518500249, 1859775393, 2400959708, 3395469782];

								function h() {
									if (!(this instanceof h)) return new h;
									u.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
								}
								n.inherits(h, u), t.exports = h, h.blockSize = 512, h.outSize = 160, h.hmacStrength = 80, h.padLength = 64, h.prototype._update = function(e, t) {
									for (var r = this.W, n = 0; n < 16; n++) r[n] = e[t + n];
									for (; n < r.length; n++) r[n] = s(r[n - 3] ^ r[n - 8] ^ r[n - 14] ^ r[n - 16], 1);
									var i = this.h[0],
										o = this.h[1],
										u = this.h[2],
										h = this.h[3],
										f = this.h[4];
									for (n = 0; n < r.length; n++) {
										var p = ~~(n / 20),
											v = c(s(i, 5), l(p, o, u, h), f, r[n], d[p]);
										f = h, h = u, u = s(o, 30), o = i, i = v
									}
									this.h[0] = a(this.h[0], i), this.h[1] = a(this.h[1], o), this.h[2] = a(this.h[2], u), this.h[3] = a(this.h[3], h), this.h[4] = a(this.h[4], f)
								}, h.prototype._digest = function(e) {
									return "hex" === e ? n.toHex32(this.h, "big") : n.split32(this.h, "big")
								}
							}, {
								"../common": 134,
								"../utils": 144,
								"./common": 143
							}],
							139: [function(e, t, r) {
								"use strict";
								var n = e("../utils"),
									i = e("./256");

								function o() {
									if (!(this instanceof o)) return new o;
									i.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
								}
								n.inherits(o, i), t.exports = o, o.blockSize = 512, o.outSize = 224, o.hmacStrength = 192, o.padLength = 64, o.prototype._digest = function(e) {
									return "hex" === e ? n.toHex32(this.h.slice(0, 7), "big") : n.split32(this.h.slice(0, 7), "big")
								}
							}, {
								"../utils": 144,
								"./256": 140
							}],
							140: [function(e, t, r) {
								"use strict";
								var n = e("../utils"),
									i = e("../common"),
									o = e("./common"),
									s = e("minimalistic-assert"),
									a = n.sum32,
									c = n.sum32_4,
									l = n.sum32_5,
									u = o.ch32,
									d = o.maj32,
									h = o.s0_256,
									f = o.s1_256,
									p = o.g0_256,
									v = o.g1_256,
									g = i.BlockHash,
									m = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

								function y() {
									if (!(this instanceof y)) return new y;
									g.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = m, this.W = new Array(64)
								}
								n.inherits(y, g), t.exports = y, y.blockSize = 512, y.outSize = 256, y.hmacStrength = 192, y.padLength = 64, y.prototype._update = function(e, t) {
									for (var r = this.W, n = 0; n < 16; n++) r[n] = e[t + n];
									for (; n < r.length; n++) r[n] = c(v(r[n - 2]), r[n - 7], p(r[n - 15]), r[n - 16]);
									var i = this.h[0],
										o = this.h[1],
										g = this.h[2],
										m = this.h[3],
										y = this.h[4],
										b = this.h[5],
										_ = this.h[6],
										w = this.h[7];
									for (s(this.k.length === r.length), n = 0; n < r.length; n++) {
										var S = l(w, f(y), u(y, b, _), this.k[n], r[n]),
											E = a(h(i), d(i, o, g));
										w = _, _ = b, b = y, y = a(m, S), m = g, g = o, o = i, i = a(S, E)
									}
									this.h[0] = a(this.h[0], i), this.h[1] = a(this.h[1], o), this.h[2] = a(this.h[2], g), this.h[3] = a(this.h[3], m), this.h[4] = a(this.h[4], y), this.h[5] = a(this.h[5], b), this.h[6] = a(this.h[6], _), this.h[7] = a(this.h[7], w)
								}, y.prototype._digest = function(e) {
									return "hex" === e ? n.toHex32(this.h, "big") : n.split32(this.h, "big")
								}
							}, {
								"../common": 134,
								"../utils": 144,
								"./common": 143,
								"minimalistic-assert": 224
							}],
							141: [function(e, t, r) {
								"use strict";
								var n = e("../utils"),
									i = e("./512");

								function o() {
									if (!(this instanceof o)) return new o;
									i.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
								}
								n.inherits(o, i), t.exports = o, o.blockSize = 1024, o.outSize = 384, o.hmacStrength = 192, o.padLength = 128, o.prototype._digest = function(e) {
									return "hex" === e ? n.toHex32(this.h.slice(0, 12), "big") : n.split32(this.h.slice(0, 12), "big")
								}
							}, {
								"../utils": 144,
								"./512": 142
							}],
							142: [function(e, t, r) {
								"use strict";
								var n = e("../utils"),
									i = e("../common"),
									o = e("minimalistic-assert"),
									s = n.rotr64_hi,
									a = n.rotr64_lo,
									c = n.shr64_hi,
									l = n.shr64_lo,
									u = n.sum64,
									d = n.sum64_hi,
									h = n.sum64_lo,
									f = n.sum64_4_hi,
									p = n.sum64_4_lo,
									v = n.sum64_5_hi,
									g = n.sum64_5_lo,
									m = i.BlockHash,
									y = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

								function b() {
									if (!(this instanceof b)) return new b;
									m.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = y, this.W = new Array(160)
								}

								function _(e, t, r, n, i) {
									var o = e & r ^ ~e & i;
									return o < 0 && (o += 4294967296), o
								}

								function w(e, t, r, n, i, o) {
									var s = t & n ^ ~t & o;
									return s < 0 && (s += 4294967296), s
								}

								function S(e, t, r, n, i) {
									var o = e & r ^ e & i ^ r & i;
									return o < 0 && (o += 4294967296), o
								}

								function E(e, t, r, n, i, o) {
									var s = t & n ^ t & o ^ n & o;
									return s < 0 && (s += 4294967296), s
								}

								function k(e, t) {
									var r = s(e, t, 28) ^ s(t, e, 2) ^ s(t, e, 7);
									return r < 0 && (r += 4294967296), r
								}

								function T(e, t) {
									var r = a(e, t, 28) ^ a(t, e, 2) ^ a(t, e, 7);
									return r < 0 && (r += 4294967296), r
								}

								function I(e, t) {
									var r = s(e, t, 14) ^ s(e, t, 18) ^ s(t, e, 9);
									return r < 0 && (r += 4294967296), r
								}

								function R(e, t) {
									var r = a(e, t, 14) ^ a(e, t, 18) ^ a(t, e, 9);
									return r < 0 && (r += 4294967296), r
								}

								function C(e, t) {
									var r = s(e, t, 1) ^ s(e, t, 8) ^ c(e, t, 7);
									return r < 0 && (r += 4294967296), r
								}

								function M(e, t) {
									var r = a(e, t, 1) ^ a(e, t, 8) ^ l(e, t, 7);
									return r < 0 && (r += 4294967296), r
								}

								function x(e, t) {
									var r = s(e, t, 19) ^ s(t, e, 29) ^ c(e, t, 6);
									return r < 0 && (r += 4294967296), r
								}

								function O(e, t) {
									var r = a(e, t, 19) ^ a(t, e, 29) ^ l(e, t, 6);
									return r < 0 && (r += 4294967296), r
								}
								n.inherits(b, m), t.exports = b, b.blockSize = 1024, b.outSize = 512, b.hmacStrength = 192, b.padLength = 128, b.prototype._prepareBlock = function(e, t) {
									for (var r = this.W, n = 0; n < 32; n++) r[n] = e[t + n];
									for (; n < r.length; n += 2) {
										var i = x(r[n - 4], r[n - 3]),
											o = O(r[n - 4], r[n - 3]),
											s = r[n - 14],
											a = r[n - 13],
											c = C(r[n - 30], r[n - 29]),
											l = M(r[n - 30], r[n - 29]),
											u = r[n - 32],
											d = r[n - 31];
										r[n] = f(i, o, s, a, c, l, u, d), r[n + 1] = p(i, o, s, a, c, l, u, d)
									}
								}, b.prototype._update = function(e, t) {
									this._prepareBlock(e, t);
									var r = this.W,
										n = this.h[0],
										i = this.h[1],
										s = this.h[2],
										a = this.h[3],
										c = this.h[4],
										l = this.h[5],
										f = this.h[6],
										p = this.h[7],
										m = this.h[8],
										y = this.h[9],
										b = this.h[10],
										C = this.h[11],
										M = this.h[12],
										x = this.h[13],
										O = this.h[14],
										A = this.h[15];
									o(this.k.length === r.length);
									for (var P = 0; P < r.length; P += 2) {
										var D = O,
											j = A,
											L = I(m, y),
											N = R(m, y),
											B = _(m, y, b, C, M),
											U = w(m, y, b, C, M, x),
											F = this.k[P],
											$ = this.k[P + 1],
											q = r[P],
											K = r[P + 1],
											V = v(D, j, L, N, B, U, F, $, q, K),
											z = g(D, j, L, N, B, U, F, $, q, K);
										D = k(n, i), j = T(n, i), L = S(n, i, s, a, c), N = E(n, i, s, a, c, l);
										var H = d(D, j, L, N),
											W = h(D, j, L, N);
										O = M, A = x, M = b, x = C, b = m, C = y, m = d(f, p, V, z), y = h(p, p, V, z), f = c, p = l, c = s, l = a, s = n, a = i, n = d(V, z, H, W), i = h(V, z, H, W)
									}
									u(this.h, 0, n, i), u(this.h, 2, s, a), u(this.h, 4, c, l), u(this.h, 6, f, p), u(this.h, 8, m, y), u(this.h, 10, b, C), u(this.h, 12, M, x), u(this.h, 14, O, A)
								}, b.prototype._digest = function(e) {
									return "hex" === e ? n.toHex32(this.h, "big") : n.split32(this.h, "big")
								}
							}, {
								"../common": 134,
								"../utils": 144,
								"minimalistic-assert": 224
							}],
							143: [function(e, t, r) {
								"use strict";
								var n = e("../utils").rotr32;

								function i(e, t, r) {
									return e & t ^ ~e & r
								}

								function o(e, t, r) {
									return e & t ^ e & r ^ t & r
								}

								function s(e, t, r) {
									return e ^ t ^ r
								}
								r.ft_1 = function(e, t, r, n) {
									return 0 === e ? i(t, r, n) : 1 === e || 3 === e ? s(t, r, n) : 2 === e ? o(t, r, n) : void 0
								}, r.ch32 = i, r.maj32 = o, r.p32 = s, r.s0_256 = function(e) {
									return n(e, 2) ^ n(e, 13) ^ n(e, 22)
								}, r.s1_256 = function(e) {
									return n(e, 6) ^ n(e, 11) ^ n(e, 25)
								}, r.g0_256 = function(e) {
									return n(e, 7) ^ n(e, 18) ^ e >>> 3
								}, r.g1_256 = function(e) {
									return n(e, 17) ^ n(e, 19) ^ e >>> 10
								}
							}, {
								"../utils": 144
							}],
							144: [function(e, t, r) {
								"use strict";
								var n = e("minimalistic-assert"),
									i = e("inherits");

								function o(e, t) {
									return 55296 == (64512 & e.charCodeAt(t)) && (!(t < 0 || t + 1 >= e.length) && 56320 == (64512 & e.charCodeAt(t + 1)))
								}

								function s(e) {
									return (e >>> 24 | e >>> 8 & 65280 | e << 8 & 16711680 | (255 & e) << 24) >>> 0
								}

								function a(e) {
									return 1 === e.length ? "0" + e : e
								}

								function c(e) {
									return 7 === e.length ? "0" + e : 6 === e.length ? "00" + e : 5 === e.length ? "000" + e : 4 === e.length ? "0000" + e : 3 === e.length ? "00000" + e : 2 === e.length ? "000000" + e : 1 === e.length ? "0000000" + e : e
								}
								r.inherits = i, r.toArray = function(e, t) {
									if (Array.isArray(e)) return e.slice();
									if (!e) return [];
									var r = [];
									if ("string" == typeof e)
										if (t) {
											if ("hex" === t)
												for ((e = e.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (e = "0" + e), i = 0; i < e.length; i += 2) r.push(parseInt(e[i] + e[i + 1], 16))
										} else
											for (var n = 0, i = 0; i < e.length; i++) {
												var s = e.charCodeAt(i);
												s < 128 ? r[n++] = s : s < 2048 ? (r[n++] = s >> 6 | 192, r[n++] = 63 & s | 128) : o(e, i) ? (s = 65536 + ((1023 & s) << 10) + (1023 & e.charCodeAt(++i)), r[n++] = s >> 18 | 240, r[n++] = s >> 12 & 63 | 128, r[n++] = s >> 6 & 63 | 128, r[n++] = 63 & s | 128) : (r[n++] = s >> 12 | 224, r[n++] = s >> 6 & 63 | 128, r[n++] = 63 & s | 128)
											} else
												for (i = 0; i < e.length; i++) r[i] = 0 | e[i];
									return r
								}, r.toHex = function(e) {
									for (var t = "", r = 0; r < e.length; r++) t += a(e[r].toString(16));
									return t
								}, r.htonl = s, r.toHex32 = function(e, t) {
									for (var r = "", n = 0; n < e.length; n++) {
										var i = e[n];
										"little" === t && (i = s(i)), r += c(i.toString(16))
									}
									return r
								}, r.zero2 = a, r.zero8 = c, r.join32 = function(e, t, r, i) {
									var o = r - t;
									n(o % 4 == 0);
									for (var s = new Array(o / 4), a = 0, c = t; a < s.length; a++, c += 4) {
										var l;
										l = "big" === i ? e[c] << 24 | e[c + 1] << 16 | e[c + 2] << 8 | e[c + 3] : e[c + 3] << 24 | e[c + 2] << 16 | e[c + 1] << 8 | e[c], s[a] = l >>> 0
									}
									return s
								}, r.split32 = function(e, t) {
									for (var r = new Array(4 * e.length), n = 0, i = 0; n < e.length; n++, i += 4) {
										var o = e[n];
										"big" === t ? (r[i] = o >>> 24, r[i + 1] = o >>> 16 & 255, r[i + 2] = o >>> 8 & 255, r[i + 3] = 255 & o) : (r[i + 3] = o >>> 24, r[i + 2] = o >>> 16 & 255, r[i + 1] = o >>> 8 & 255, r[i] = 255 & o)
									}
									return r
								}, r.rotr32 = function(e, t) {
									return e >>> t | e << 32 - t
								}, r.rotl32 = function(e, t) {
									return e << t | e >>> 32 - t
								}, r.sum32 = function(e, t) {
									return e + t >>> 0
								}, r.sum32_3 = function(e, t, r) {
									return e + t + r >>> 0
								}, r.sum32_4 = function(e, t, r, n) {
									return e + t + r + n >>> 0
								}, r.sum32_5 = function(e, t, r, n, i) {
									return e + t + r + n + i >>> 0
								}, r.sum64 = function(e, t, r, n) {
									var i = e[t],
										o = n + e[t + 1] >>> 0,
										s = (o < n ? 1 : 0) + r + i;
									e[t] = s >>> 0, e[t + 1] = o
								}, r.sum64_hi = function(e, t, r, n) {
									return (t + n >>> 0 < t ? 1 : 0) + e + r >>> 0
								}, r.sum64_lo = function(e, t, r, n) {
									return t + n >>> 0
								}, r.sum64_4_hi = function(e, t, r, n, i, o, s, a) {
									var c = 0,
										l = t;
									return c += (l = l + n >>> 0) < t ? 1 : 0, c += (l = l + o >>> 0) < o ? 1 : 0, e + r + i + s + (c += (l = l + a >>> 0) < a ? 1 : 0) >>> 0
								}, r.sum64_4_lo = function(e, t, r, n, i, o, s, a) {
									return t + n + o + a >>> 0
								}, r.sum64_5_hi = function(e, t, r, n, i, o, s, a, c, l) {
									var u = 0,
										d = t;
									return u += (d = d + n >>> 0) < t ? 1 : 0, u += (d = d + o >>> 0) < o ? 1 : 0, u += (d = d + a >>> 0) < a ? 1 : 0, e + r + i + s + c + (u += (d = d + l >>> 0) < l ? 1 : 0) >>> 0
								}, r.sum64_5_lo = function(e, t, r, n, i, o, s, a, c, l) {
									return t + n + o + a + l >>> 0
								}, r.rotr64_hi = function(e, t, r) {
									return (t << 32 - r | e >>> r) >>> 0
								}, r.rotr64_lo = function(e, t, r) {
									return (e << 32 - r | t >>> r) >>> 0
								}, r.shr64_hi = function(e, t, r) {
									return e >>> r
								}, r.shr64_lo = function(e, t, r) {
									return (e << 32 - r | t >>> r) >>> 0
								}
							}, {
								inherits: 147,
								"minimalistic-assert": 224
							}],
							145: [function(e, t, r) {
								"use strict";
								var n = e("hash.js"),
									i = e("minimalistic-crypto-utils"),
									o = e("minimalistic-assert");

								function s(e) {
									if (!(this instanceof s)) return new s(e);
									this.hash = e.hash, this.predResist = !!e.predResist, this.outLen = this.hash.outSize, this.minEntropy = e.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
									var t = i.toArray(e.entropy, e.entropyEnc || "hex"),
										r = i.toArray(e.nonce, e.nonceEnc || "hex"),
										n = i.toArray(e.pers, e.persEnc || "hex");
									o(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(t, r, n)
								}
								t.exports = s, s.prototype._init = function(e, t, r) {
									var n = e.concat(t).concat(r);
									this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
									for (var i = 0; i < this.V.length; i++) this.K[i] = 0, this.V[i] = 1;
									this._update(n), this._reseed = 1, this.reseedInterval = 281474976710656
								}, s.prototype._hmac = function() {
									return new n.hmac(this.hash, this.K)
								}, s.prototype._update = function(e) {
									var t = this._hmac().update(this.V).update([0]);
									e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest())
								}, s.prototype.reseed = function(e, t, r, n) {
									"string" != typeof t && (n = r, r = t, t = null), e = i.toArray(e, t), r = i.toArray(r, n), o(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(r || [])), this._reseed = 1
								}, s.prototype.generate = function(e, t, r, n) {
									if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
									"string" != typeof t && (n = r, r = t, t = null), r && (r = i.toArray(r, n || "hex"), this._update(r));
									for (var o = []; o.length < e;) this.V = this._hmac().update(this.V).digest(), o = o.concat(this.V);
									var s = o.slice(0, e);
									return this._update(r), this._reseed++, i.encode(s, t)
								}
							}, {
								"hash.js": 133,
								"minimalistic-assert": 224,
								"minimalistic-crypto-utils": 225
							}],
							146: [function(e, t, r) {
								r.read = function(e, t, r, n, i) {
									var o, s, a = 8 * i - n - 1,
										c = (1 << a) - 1,
										l = c >> 1,
										u = -7,
										d = r ? i - 1 : 0,
										h = r ? -1 : 1,
										f = e[t + d];
									for (d += h, o = f & (1 << -u) - 1, f >>= -u, u += a; u > 0; o = 256 * o + e[t + d], d += h, u -= 8);
									for (s = o & (1 << -u) - 1, o >>= -u, u += n; u > 0; s = 256 * s + e[t + d], d += h, u -= 8);
									if (0 === o) o = 1 - l;
									else {
										if (o === c) return s ? NaN : 1 / 0 * (f ? -1 : 1);
										s += Math.pow(2, n), o -= l
									}
									return (f ? -1 : 1) * s * Math.pow(2, o - n)
								}, r.write = function(e, t, r, n, i, o) {
									var s, a, c, l = 8 * o - i - 1,
										u = (1 << l) - 1,
										d = u >> 1,
										h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
										f = n ? 0 : o - 1,
										p = n ? 1 : -1,
										v = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
									for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = u) : (s = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -s)) < 1 && (s--, c *= 2), (t += s + d >= 1 ? h / c : h * Math.pow(2, 1 - d)) * c >= 2 && (s++, c /= 2), s + d >= u ? (a = 0, s = u) : s + d >= 1 ? (a = (t * c - 1) * Math.pow(2, i), s += d) : (a = t * Math.pow(2, d - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r + f] = 255 & a, f += p, a /= 256, i -= 8);
									for (s = s << i | a, l += i; l > 0; e[r + f] = 255 & s, f += p, s /= 256, l -= 8);
									e[r + f - p] |= 128 * v
								}
							}, {}],
							147: [function(e, t, r) {
								"function" == typeof Object.create ? t.exports = function(e, t) {
									t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
										constructor: {
											value: e,
											enumerable: !1,
											writable: !0,
											configurable: !0
										}
									}))
								} : t.exports = function(e, t) {
									if (t) {
										e.super_ = t;
										var r = function() {};
										r.prototype = t.prototype, e.prototype = new r, e.prototype.constructor = e
									}
								}
							}, {}],
							148: [function(e, t, r) {
								"use strict";
								var n = e("has-tostringtag/shams")(),
									i = e("call-bind/callBound")("Object.prototype.toString"),
									o = function(e) {
										return !(n && e && "object" == typeof e && Symbol.toStringTag in e) && "[object Arguments]" === i(e)
									},
									s = function(e) {
										return !!o(e) || null !== e && "object" == typeof e && "number" == typeof e.length && e.length >= 0 && "[object Array]" !== i(e) && "[object Function]" === i(e.callee)
									},
									a = function() {
										return o(arguments)
									}();
								o.isLegacyArguments = s, t.exports = a ? o : s
							}, {
								"call-bind/callBound": 70,
								"has-tostringtag/shams": 115
							}],
							149: [function(e, t, r) {
								"use strict";
								var n, i, o = Function.prototype.toString,
									s = "object" == typeof Reflect && null !== Reflect && Reflect.apply;
								if ("function" == typeof s && "function" == typeof Object.defineProperty) try {
									n = Object.defineProperty({}, "length", {
										get: function() {
											throw i
										}
									}), i = {}, s((function() {
										throw 42
									}), null, n)
								} catch (v) {
									v !== i && (s = null)
								} else s = null;
								var a = /^\s*class\b/,
									c = function(e) {
										try {
											var t = o.call(e);
											return a.test(t)
										} catch (r) {
											return !1
										}
									},
									l = function(e) {
										try {
											return !c(e) && (o.call(e), !0)
										} catch (t) {
											return !1
										}
									},
									u = Object.prototype.toString,
									d = "function" == typeof Symbol && !!Symbol.toStringTag,
									h = !(0 in [, ]),
									f = function() {
										return !1
									};
								if ("object" == typeof document) {
									var p = document.all;
									u.call(p) === u.call(document.all) && (f = function(e) {
										if ((h || !e) && (void 0 === e || "object" == typeof e)) try {
											var t = u.call(e);
											return ("[object HTMLAllCollection]" === t || "[object HTML document.all class]" === t || "[object HTMLCollection]" === t || "[object Object]" === t) && null == e("")
										} catch (r) {}
										return !1
									})
								}
								t.exports = s ? function(e) {
									if (f(e)) return !0;
									if (!e) return !1;
									if ("function" != typeof e && "object" != typeof e) return !1;
									try {
										s(e, null, n)
									} catch (t) {
										if (t !== i) return !1
									}
									return !c(e) && l(e)
								} : function(e) {
									if (f(e)) return !0;
									if (!e) return !1;
									if ("function" != typeof e && "object" != typeof e) return !1;
									if (d) return l(e);
									if (c(e)) return !1;
									var t = u.call(e);
									return !("[object Function]" !== t && "[object GeneratorFunction]" !== t && !/^\[object HTML/.test(t)) && l(e)
								}
							}, {}],
							150: [function(e, t, r) {
								"use strict";
								var n, i = Object.prototype.toString,
									o = Function.prototype.toString,
									s = /^\s*(?:function)?\*/,
									a = e("has-tostringtag/shams")(),
									c = Object.getPrototypeOf;
								t.exports = function(e) {
									if ("function" != typeof e) return !1;
									if (s.test(o.call(e))) return !0;
									if (!a) return "[object GeneratorFunction]" === i.call(e);
									if (!c) return !1;
									if (void 0 === n) {
										var t = function() {
											if (!a) return !1;
											try {
												return Function("return function*() {}")()
											} catch (e) {}
										}();
										n = !!t && c(t)
									}
									return c(e) === n
								}
							}, {
								"has-tostringtag/shams": 115
							}],
							151: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var n = t("for-each"),
											i = t("available-typed-arrays"),
											o = t("call-bind/callBound"),
											s = o("Object.prototype.toString"),
											a = t("has-tostringtag/shams")(),
											c = t("gopd"),
											l = "undefined" == typeof globalThis ? e : globalThis,
											u = i(),
											d = o("Array.prototype.indexOf", !0) || function(e, t) {
												for (var r = 0; r < e.length; r += 1)
													if (e[r] === t) return r;
												return -1
											},
											h = o("String.prototype.slice"),
											f = {},
											p = Object.getPrototypeOf;
										a && c && p && n(u, (function(e) {
											var t = new l[e];
											if (Symbol.toStringTag in t) {
												var r = p(t),
													n = c(r, Symbol.toStringTag);
												if (!n) {
													var i = p(r);
													n = c(i, Symbol.toStringTag)
												}
												f[e] = n.get
											}
										}));
										r.exports = function(e) {
											if (!e || "object" != typeof e) return !1;
											if (!(a && Symbol.toStringTag in e)) {
												var t = h(s(e), 8, -1);
												return d(u, t) > -1
											}
											return !!c && function(e) {
												var t = !1;
												return n(f, (function(r, n) {
													if (!t) try {
														t = r.call(e) === n
													} catch (i) {}
												})), t
											}(e)
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"available-typed-arrays": 17,
								"call-bind/callBound": 70,
								"for-each": 108,
								gopd: 112,
								"has-tostringtag/shams": 115
							}],
							152: [function(e, t, o) {
								! function(e, s) {
									"use strict";
									void 0 === (i = "function" == typeof(n = function() {
										var e = function() {},
											t = "undefined",
											r = typeof window !== t && typeof window.navigator !== t && /Trident\/|MSIE /.test(window.navigator.userAgent),
											n = ["trace", "debug", "info", "warn", "error"];

										function i(e, t) {
											var r = e[t];
											if ("function" == typeof r.bind) return r.bind(e);
											try {
												return Function.prototype.bind.call(r, e)
											} catch (n) {
												return function() {
													return Function.prototype.apply.apply(r, [e, arguments])
												}
											}
										}

										function o() {
											console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace()
										}

										function s(t, r) {
											for (var i = 0; i < n.length; i++) {
												var o = n[i];
												this[o] = i < t ? e : this.methodFactory(o, t, r)
											}
											this.log = this.debug
										}

										function a(e, r, n) {
											return function() {
												typeof console !== t && (s.call(this, r, n), this[e].apply(this, arguments))
											}
										}

										function c(n, s, c) {
											return function(n) {
												return "debug" === n && (n = "log"), typeof console !== t && ("trace" === n && r ? o : void 0 !== console[n] ? i(console, n) : void 0 !== console.log ? i(console, "log") : e)
											}(n) || a.apply(this, arguments)
										}

										function l(e, r, i) {
											var o, a = this;
											r = null == r ? "WARN" : r;
											var l = "loglevel";

											function u() {
												var e;
												if (typeof window !== t && l) {
													try {
														e = window.localStorage[l]
													} catch (i) {}
													if (typeof e === t) try {
														var r = window.document.cookie,
															n = r.indexOf(encodeURIComponent(l) + "="); - 1 !== n && (e = /^([^;]+)/.exec(r.slice(n))[1])
													} catch (i) {}
													return void 0 === a.levels[e] && (e = void 0), e
												}
											}
											"string" == typeof e ? l += ":" + e : "symbol" == typeof e && (l = void 0), a.name = e, a.levels = {
												TRACE: 0,
												DEBUG: 1,
												INFO: 2,
												WARN: 3,
												ERROR: 4,
												SILENT: 5
											}, a.methodFactory = i || c, a.getLevel = function() {
												return o
											}, a.setLevel = function(r, i) {
												if ("string" == typeof r && void 0 !== a.levels[r.toUpperCase()] && (r = a.levels[r.toUpperCase()]), !("number" == typeof r && r >= 0 && r <= a.levels.SILENT)) throw "log.setLevel() called with invalid level: " + r;
												if (o = r, !1 !== i && function(e) {
														var r = (n[e] || "silent").toUpperCase();
														if (typeof window !== t && l) {
															try {
																return void(window.localStorage[l] = r)
															} catch (i) {}
															try {
																window.document.cookie = encodeURIComponent(l) + "=" + r + ";"
															} catch (i) {}
														}
													}(r), s.call(a, r, e), typeof console === t && r < a.levels.SILENT) return "No console available for logging"
											}, a.setDefaultLevel = function(e) {
												r = e, u() || a.setLevel(e, !1)
											}, a.resetLevel = function() {
												a.setLevel(r, !1),
													function() {
														if (typeof window !== t && l) {
															try {
																return void window.localStorage.removeItem(l)
															} catch (e) {}
															try {
																window.document.cookie = encodeURIComponent(l) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC"
															} catch (e) {}
														}
													}()
											}, a.enableAll = function(e) {
												a.setLevel(a.levels.TRACE, e)
											}, a.disableAll = function(e) {
												a.setLevel(a.levels.SILENT, e)
											};
											var d = u();
											null == d && (d = r), a.setLevel(d, !1)
										}
										var u = new l,
											d = {};
										u.getLogger = function(e) {
											if ("symbol" != typeof e && "string" != typeof e || "" === e) throw new TypeError("You must supply a name when creating a logger.");
											var t = d[e];
											return t || (t = d[e] = new l(e, u.getLevel(), u.methodFactory)), t
										};
										var h = typeof window !== t ? window.log : void 0;
										return u.noConflict = function() {
											return typeof window !== t && window.log === u && (window.log = h), u
										}, u.getLoggers = function() {
											return d
										}, u.default = u, u
									}) ? n.call(o, r, o, t) : n) || (t.exports = i)
								}()
							}, {}],
							153: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.ExtensibleEvents = void 0;
								var n = e("./NamespacedMap"),
									i = e("./InvalidEventError"),
									o = e("./interpreters/legacy/MRoomMessage"),
									s = e("./interpreters/modern/MMessage"),
									a = e("./events/message_types"),
									c = e("./events/poll_types"),
									l = e("./interpreters/modern/MPoll");

								function u(e, t) {
									var r = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
									if (!r) {
										if (Array.isArray(e) || (r = function(e, t) {
												if (!e) return;
												if ("string" == typeof e) return d(e, t);
												var r = Object.prototype.toString.call(e).slice(8, -1);
												"Object" === r && e.constructor && (r = e.constructor.name);
												if ("Map" === r || "Set" === r) return Array.from(e);
												if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return d(e, t)
											}(e)) || t && e && "number" == typeof e.length) {
											r && (e = r);
											var n = 0,
												i = function() {};
											return {
												s: i,
												n: function() {
													return n >= e.length ? {
														done: !0
													} : {
														done: !1,
														value: e[n++]
													}
												},
												e: function(e) {
													throw e
												},
												f: i
											}
										}
										throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
									}
									var o, s = !0,
										a = !1;
									return {
										s: function() {
											r = r.call(e)
										},
										n: function() {
											var e = r.next();
											return s = e.done, e
										},
										e: function(e) {
											a = !0, o = e
										},
										f: function() {
											try {
												s || null == r.return || r.return()
											} finally {
												if (a) throw o
											}
										}
									}
								}

								function d(e, t) {
									(null == t || t > e.length) && (t = e.length);
									for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
									return n
								}

								function h(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function f(e, t, r) {
									return t in e ? Object.defineProperty(e, t, {
										value: r,
										enumerable: !0,
										configurable: !0,
										writable: !0
									}) : e[t] = r, e
								}
								var p = function() {
									function e() {
										! function(e, t) {
											if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
										}(this, e), f(this, "interpreters", new n.NamespacedMap([
											[o.LEGACY_M_ROOM_MESSAGE, o.parseMRoomMessage],
											[a.M_MESSAGE, s.parseMMessage],
											[a.M_EMOTE, s.parseMMessage],
											[a.M_NOTICE, s.parseMMessage],
											[c.M_POLL_START, l.parseMPoll],
											[c.M_POLL_RESPONSE, l.parseMPoll],
											[c.M_POLL_END, l.parseMPoll]
										])), f(this, "_unknownInterpretOrder", [a.M_MESSAGE])
									}
									var t, r, d;
									return t = e, d = [{
										key: "defaultInstance",
										get: function() {
											return e._defaultInstance
										}
									}, {
										key: "unknownInterpretOrder",
										get: function() {
											return e.defaultInstance.unknownInterpretOrder
										},
										set: function(t) {
											e.defaultInstance.unknownInterpretOrder = t
										}
									}, {
										key: "registerInterpreter",
										value: function(t, r) {
											e.defaultInstance.registerInterpreter(t, r)
										}
									}, {
										key: "parse",
										value: function(t) {
											return e.defaultInstance.parse(t)
										}
									}], (r = [{
										key: "unknownInterpretOrder",
										get: function() {
											var e;
											return null !== (e = this._unknownInterpretOrder) && void 0 !== e ? e : []
										},
										set: function(e) {
											this._unknownInterpretOrder = e
										}
									}, {
										key: "registerInterpreter",
										value: function(e, t) {
											this.interpreters.set(e, t)
										}
									}, {
										key: "parse",
										value: function(e) {
											try {
												if (this.interpreters.hasNamespaced(e.type)) return this.interpreters.getNamespaced(e.type)(e);
												var t, r = u(this.unknownInterpretOrder);
												try {
													for (r.s(); !(t = r.n()).done;) {
														var n = t.value;
														if (this.interpreters.has(n)) {
															var o = this.interpreters.get(n)(e);
															if (o) return o
														}
													}
												} catch (s) {
													r.e(s)
												} finally {
													r.f()
												}
												return null
											} catch (a) {
												if (a instanceof i.InvalidEventError) return null;
												throw a
											}
										}
									}]) && h(t.prototype, r), d && h(t, d), Object.defineProperty(t, "prototype", {
										writable: !1
									}), e
								}();
								r.ExtensibleEvents = p, f(p, "_defaultInstance", new p)
							}, {
								"./InvalidEventError": 155,
								"./NamespacedMap": 156,
								"./events/message_types": 165,
								"./events/poll_types": 166,
								"./interpreters/legacy/MRoomMessage": 169,
								"./interpreters/modern/MMessage": 170,
								"./interpreters/modern/MPoll": 171
							}],
							154: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								})
							}, {}],
							155: [function(e, t, r) {
								"use strict";

								function n(e) {
									return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
										return typeof e
									} : function(e) {
										return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
									})(e)
								}

								function i(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function o(e, t) {
									if (t && ("object" === n(t) || "function" == typeof t)) return t;
									if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
									return function(e) {
										if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
										return e
									}(e)
								}

								function s(e) {
									var t = "function" == typeof Map ? new Map : void 0;
									return (s = function(e) {
										if (null === e || (r = e, -1 === Function.toString.call(r).indexOf("[native code]"))) return e;
										var r;
										if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
										if (void 0 !== t) {
											if (t.has(e)) return t.get(e);
											t.set(e, n)
										}

										function n() {
											return a(e, arguments, u(this).constructor)
										}
										return n.prototype = Object.create(e.prototype, {
											constructor: {
												value: n,
												enumerable: !1,
												writable: !0,
												configurable: !0
											}
										}), l(n, e)
									})(e)
								}

								function a(e, t, r) {
									return (a = c() ? Reflect.construct : function(e, t, r) {
										var n = [null];
										n.push.apply(n, t);
										var i = new(Function.bind.apply(e, n));
										return r && l(i, r.prototype), i
									}).apply(null, arguments)
								}

								function c() {
									if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
									if (Reflect.construct.sham) return !1;
									if ("function" == typeof Proxy) return !0;
									try {
										return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
									} catch (e) {
										return !1
									}
								}

								function l(e, t) {
									return (l = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									})(e, t)
								}

								function u(e) {
									return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
										return e.__proto__ || Object.getPrototypeOf(e)
									})(e)
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.InvalidEventError = void 0;
								var d = function(e) {
									! function(e, t) {
										if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
										e.prototype = Object.create(t && t.prototype, {
											constructor: {
												value: e,
												writable: !0,
												configurable: !0
											}
										}), Object.defineProperty(e, "prototype", {
											writable: !1
										}), t && l(e, t)
									}(h, e);
									var t, r, n, s, a, d = (t = h, r = c(), function() {
										var e, n = u(t);
										if (r) {
											var i = u(this).constructor;
											e = Reflect.construct(n, arguments, i)
										} else e = n.apply(this, arguments);
										return o(this, e)
									});

									function h(e) {
										return function(e, t) {
											if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
										}(this, h), d.call(this, e)
									}
									return n = h, s && i(n.prototype, s), a && i(n, a), Object.defineProperty(n, "prototype", {
										writable: !1
									}), n
								}(s(Error));
								r.InvalidEventError = d
							}, {}],
							156: [function(e, t, r) {
								"use strict";

								function n(e, t) {
									var r = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
									if (!r) {
										if (Array.isArray(e) || (r = function(e, t) {
												if (!e) return;
												if ("string" == typeof e) return i(e, t);
												var r = Object.prototype.toString.call(e).slice(8, -1);
												"Object" === r && e.constructor && (r = e.constructor.name);
												if ("Map" === r || "Set" === r) return Array.from(e);
												if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return i(e, t)
											}(e)) || t && e && "number" == typeof e.length) {
											r && (e = r);
											var n = 0,
												o = function() {};
											return {
												s: o,
												n: function() {
													return n >= e.length ? {
														done: !0
													} : {
														done: !1,
														value: e[n++]
													}
												},
												e: function(e) {
													throw e
												},
												f: o
											}
										}
										throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
									}
									var s, a = !0,
										c = !1;
									return {
										s: function() {
											r = r.call(e)
										},
										n: function() {
											var e = r.next();
											return a = e.done, e
										},
										e: function(e) {
											c = !0, s = e
										},
										f: function() {
											try {
												a || null == r.return || r.return()
											} finally {
												if (c) throw s
											}
										}
									}
								}

								function i(e, t) {
									(null == t || t > e.length) && (t = e.length);
									for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
									return n
								}

								function o(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.NamespacedMap = void 0;
								var s = function() {
									function e(t) {
										var r, i, o;
										if (function(e, t) {
												if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
											}(this, e), r = this, i = "internalMap", o = new Map, i in r ? Object.defineProperty(r, i, {
												value: o,
												enumerable: !0,
												configurable: !0,
												writable: !0
											}) : r[i] = o, t) {
											var s, a = n(t);
											try {
												for (a.s(); !(s = a.n()).done;) {
													var c = s.value;
													this.set(c[0], c[1])
												}
											} catch (l) {
												a.e(l)
											} finally {
												a.f()
											}
										}
									}
									var t, r, i;
									return t = e, (r = [{
										key: "get",
										value: function(e) {
											return e.name && this.internalMap.has(e.name) ? this.internalMap.get(e.name) : e.altName && this.internalMap.has(e.altName) ? this.internalMap.get(e.altName) : null
										}
									}, {
										key: "set",
										value: function(e, t) {
											e.name && this.internalMap.set(e.name, t), e.altName && this.internalMap.set(e.altName, t)
										}
									}, {
										key: "has",
										value: function(e) {
											return !!this.get(e)
										}
									}, {
										key: "delete",
										value: function(e) {
											e.name && this.internalMap.delete(e.name), e.altName && this.internalMap.delete(e.altName)
										}
									}, {
										key: "hasNamespaced",
										value: function(e) {
											return this.internalMap.has(e)
										}
									}, {
										key: "getNamespaced",
										value: function(e) {
											return this.internalMap.get(e)
										}
									}]) && o(t.prototype, r), i && o(t, i), Object.defineProperty(t, "prototype", {
										writable: !1
									}), e
								}();
								r.NamespacedMap = s
							}, {}],
							157: [function(e, t, r) {
								"use strict";

								function n(e) {
									return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
										return typeof e
									} : function(e) {
										return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
									})(e)
								}

								function i(e, t) {
									return (i = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									})(e, t)
								}

								function o(e) {
									var t = function() {
										if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
										if (Reflect.construct.sham) return !1;
										if ("function" == typeof Proxy) return !0;
										try {
											return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
										} catch (e) {
											return !1
										}
									}();
									return function() {
										var r, n = a(e);
										if (t) {
											var i = a(this).constructor;
											r = Reflect.construct(n, arguments, i)
										} else r = n.apply(this, arguments);
										return s(this, r)
									}
								}

								function s(e, t) {
									if (t && ("object" === n(t) || "function" == typeof t)) return t;
									if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
									return function(e) {
										if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
										return e
									}(e)
								}

								function a(e) {
									return (a = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
										return e.__proto__ || Object.getPrototypeOf(e)
									})(e)
								}

								function c(e, t) {
									if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
								}

								function l(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function u(e, t, r) {
									return t && l(e.prototype, t), r && l(e, r), Object.defineProperty(e, "prototype", {
										writable: !1
									}), e
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.UnstableValue = r.NamespacedValue = void 0;
								var d = function() {
									function e(t, r) {
										if (c(this, e), this.stable = t, this.unstable = r, !this.unstable && !this.stable) throw new Error("One of stable or unstable values must be supplied")
									}
									return u(e, [{
										key: "name",
										get: function() {
											return this.stable ? this.stable : this.unstable
										}
									}, {
										key: "altName",
										get: function() {
											return this.stable ? this.unstable : null
										}
									}, {
										key: "matches",
										value: function(e) {
											return !!this.name && this.name === e || !!this.altName && this.altName === e
										}
									}, {
										key: "findIn",
										value: function(e) {
											var t;
											return this.name && (t = null == e ? void 0 : e[this.name]), !t && this.altName && (t = null == e ? void 0 : e[this.altName]), t
										}
									}, {
										key: "includedIn",
										value: function(e) {
											var t = !1;
											return this.name && (t = e.includes(this.name)), !t && this.altName && (t = e.includes(this.altName)), t
										}
									}]), e
								}();
								r.NamespacedValue = d;
								var h = function(e) {
									! function(e, t) {
										if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
										e.prototype = Object.create(t && t.prototype, {
											constructor: {
												value: e,
												writable: !0,
												configurable: !0
											}
										}), Object.defineProperty(e, "prototype", {
											writable: !1
										}), t && i(e, t)
									}(r, e);
									var t = o(r);

									function r(e, n) {
										var i;
										if (c(this, r), !(i = t.call(this, e, n)).unstable) throw new Error("Unstable value must be supplied");
										return i
									}
									return u(r, [{
										key: "name",
										get: function() {
											return this.unstable
										}
									}, {
										key: "altName",
										get: function() {
											return this.stable
										}
									}]), r
								}(d);
								r.UnstableValue = h
							}, {}],
							158: [function(e, t, r) {
								"use strict";

								function n(e) {
									return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
										return typeof e
									} : function(e) {
										return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
									})(e)
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.EmoteEvent = void 0;
								var i = e("./MessageEvent"),
									o = e("./message_types"),
									s = e("../utility/events");

								function a(e, t, r) {
									return t in e ? Object.defineProperty(e, t, {
										value: r,
										enumerable: !0,
										configurable: !0,
										writable: !0
									}) : e[t] = r, e
								}

								function c(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function l() {
									return (l = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, r) {
										var n = u(e, t);
										if (n) {
											var i = Object.getOwnPropertyDescriptor(n, t);
											return i.get ? i.get.call(arguments.length < 3 ? e : r) : i.value
										}
									}).apply(this, arguments)
								}

								function u(e, t) {
									for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = p(e)););
									return e
								}

								function d(e, t) {
									return (d = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									})(e, t)
								}

								function h(e) {
									var t = function() {
										if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
										if (Reflect.construct.sham) return !1;
										if ("function" == typeof Proxy) return !0;
										try {
											return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
										} catch (e) {
											return !1
										}
									}();
									return function() {
										var r, n = p(e);
										if (t) {
											var i = p(this).constructor;
											r = Reflect.construct(n, arguments, i)
										} else r = n.apply(this, arguments);
										return f(this, r)
									}
								}

								function f(e, t) {
									if (t && ("object" === n(t) || "function" == typeof t)) return t;
									if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
									return function(e) {
										if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
										return e
									}(e)
								}

								function p(e) {
									return (p = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
										return e.__proto__ || Object.getPrototypeOf(e)
									})(e)
								}
								var v = function(e) {
									! function(e, t) {
										if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
										e.prototype = Object.create(t && t.prototype, {
											constructor: {
												value: e,
												writable: !0,
												configurable: !0
											}
										}), Object.defineProperty(e, "prototype", {
											writable: !1
										}), t && d(e, t)
									}(u, e);
									var t, r, n, i = h(u);

									function u(e) {
										return function(e, t) {
											if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
										}(this, u), i.call(this, e)
									}
									return t = u, n = [{
										key: "from",
										value: function(e, t) {
											var r;
											return new u({
												type: o.M_EMOTE.name,
												content: (r = {}, a(r, o.M_TEXT.name, e), a(r, o.M_HTML.name, t), r)
											})
										}
									}], (r = [{
										key: "isEmote",
										get: function() {
											return !0
										}
									}, {
										key: "isEquivalentTo",
										value: function(e) {
											return (0, s.isEventTypeSame)(e, o.M_EMOTE) || l(p(u.prototype), "isEquivalentTo", this).call(this, e)
										}
									}, {
										key: "serialize",
										value: function() {
											var e = l(p(u.prototype), "serialize", this).call(this);
											return e.content.msgtype = "m.emote", e
										}
									}]) && c(t.prototype, r), n && c(t, n), Object.defineProperty(t, "prototype", {
										writable: !1
									}), u
								}(i.MessageEvent);
								r.EmoteEvent = v
							}, {
								"../utility/events": 174,
								"./MessageEvent": 160,
								"./message_types": 165
							}],
							159: [function(e, t, r) {
								"use strict";

								function n(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.ExtensibleEvent = void 0;
								var i = function() {
									function e(t) {
										! function(e, t) {
											if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
										}(this, e), this.wireFormat = t
									}
									var t, r, i;
									return t = e, (r = [{
										key: "wireContent",
										get: function() {
											return this.wireFormat.content
										}
									}]) && n(t.prototype, r), i && n(t, i), Object.defineProperty(t, "prototype", {
										writable: !1
									}), e
								}();
								r.ExtensibleEvent = i
							}, {}],
							160: [function(e, t, r) {
								"use strict";

								function n(e) {
									return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
										return typeof e
									} : function(e) {
										return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
									})(e)
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.MessageEvent = void 0;
								var i = e("./ExtensibleEvent"),
									o = e("../types"),
									s = e("../InvalidEventError"),
									a = e("./message_types"),
									c = e("../utility/events");

								function l(e, t) {
									var r = Object.keys(e);
									if (Object.getOwnPropertySymbols) {
										var n = Object.getOwnPropertySymbols(e);
										t && (n = n.filter((function(t) {
											return Object.getOwnPropertyDescriptor(e, t).enumerable
										}))), r.push.apply(r, n)
									}
									return r
								}

								function u(e) {
									for (var t = 1; t < arguments.length; t++) {
										var r = null != arguments[t] ? arguments[t] : {};
										t % 2 ? l(Object(r), !0).forEach((function(t) {
											m(e, t, r[t])
										})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : l(Object(r)).forEach((function(t) {
											Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
										}))
									}
									return e
								}

								function d(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function h(e, t) {
									return (h = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									})(e, t)
								}

								function f(e) {
									var t = function() {
										if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
										if (Reflect.construct.sham) return !1;
										if ("function" == typeof Proxy) return !0;
										try {
											return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
										} catch (e) {
											return !1
										}
									}();
									return function() {
										var r, n = g(e);
										if (t) {
											var i = g(this).constructor;
											r = Reflect.construct(n, arguments, i)
										} else r = n.apply(this, arguments);
										return p(this, r)
									}
								}

								function p(e, t) {
									if (t && ("object" === n(t) || "function" == typeof t)) return t;
									if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
									return v(e)
								}

								function v(e) {
									if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
									return e
								}

								function g(e) {
									return (g = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
										return e.__proto__ || Object.getPrototypeOf(e)
									})(e)
								}

								function m(e, t, r) {
									return t in e ? Object.defineProperty(e, t, {
										value: r,
										enumerable: !0,
										configurable: !0,
										writable: !0
									}) : e[t] = r, e
								}
								var y = function(e) {
									! function(e, t) {
										if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
										e.prototype = Object.create(t && t.prototype, {
											constructor: {
												value: e,
												writable: !0,
												configurable: !0
											}
										}), Object.defineProperty(e, "prototype", {
											writable: !1
										}), t && h(e, t)
									}(l, e);
									var t, r, n, i = f(l);

									function l(e) {
										var t;
										! function(e, t) {
											if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
										}(this, l), m(v(t = i.call(this, e)), "text", void 0), m(v(t), "html", void 0), m(v(t), "renderings", void 0);
										var r = a.M_MESSAGE.findIn(t.wireContent),
											n = a.M_TEXT.findIn(t.wireContent),
											c = a.M_HTML.findIn(t.wireContent);
										if ((0, o.isProvided)(r)) {
											if (!Array.isArray(r)) throw new s.InvalidEventError("m.message contents must be an array");
											var u = r.find((function(e) {
													return !(0, o.isProvided)(e.mimetype) || "text/plain" === e.mimetype
												})),
												d = r.find((function(e) {
													return "text/html" === e.mimetype
												}));
											if (!u) throw new s.InvalidEventError("m.message is missing a plain text representation");
											t.text = u.body, t.html = null == d ? void 0 : d.body, t.renderings = r
										} else {
											if (!(0, o.isOptionalAString)(n)) throw new s.InvalidEventError("Missing textual representation for event");
											t.text = n, t.html = c, t.renderings = [{
												body: n,
												mimetype: "text/plain"
											}], t.html && t.renderings.push({
												body: t.html,
												mimetype: "text/html"
											})
										}
										return t
									}
									return t = l, n = [{
										key: "from",
										value: function(e, t) {
											var r;
											return new l({
												type: a.M_MESSAGE.name,
												content: (r = {}, m(r, a.M_TEXT.name, e), m(r, a.M_HTML.name, t), r)
											})
										}
									}], (r = [{
										key: "isEmote",
										get: function() {
											return a.M_EMOTE.matches(this.wireFormat.type) || (0, o.isProvided)(a.M_EMOTE.findIn(this.wireFormat.content))
										}
									}, {
										key: "isNotice",
										get: function() {
											return a.M_NOTICE.matches(this.wireFormat.type) || (0, o.isProvided)(a.M_NOTICE.findIn(this.wireFormat.content))
										}
									}, {
										key: "isEquivalentTo",
										value: function(e) {
											return (0, c.isEventTypeSame)(e, a.M_MESSAGE)
										}
									}, {
										key: "serializeMMessageOnly",
										value: function() {
											var e = m({}, a.M_MESSAGE.name, this.renderings);
											if (1 === this.renderings.length) {
												var t = this.renderings[0].mimetype;
												void 0 !== t && "text/plain" !== t || (e = m({}, a.M_TEXT.name, this.renderings[0].body))
											}
											return e
										}
									}, {
										key: "serialize",
										value: function() {
											var e;
											return {
												type: "m.room.message",
												content: u(u({}, this.serializeMMessageOnly()), {}, {
													body: this.text,
													msgtype: "m.text",
													format: this.html ? "org.matrix.custom.html" : void 0,
													formatted_body: null !== (e = this.html) && void 0 !== e ? e : void 0
												})
											}
										}
									}]) && d(t.prototype, r), n && d(t, n), Object.defineProperty(t, "prototype", {
										writable: !1
									}), l
								}(i.ExtensibleEvent);
								r.MessageEvent = y
							}, {
								"../InvalidEventError": 155,
								"../types": 172,
								"../utility/events": 174,
								"./ExtensibleEvent": 159,
								"./message_types": 165
							}],
							161: [function(e, t, r) {
								"use strict";

								function n(e) {
									return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
										return typeof e
									} : function(e) {
										return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
									})(e)
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.NoticeEvent = void 0;
								var i = e("./MessageEvent"),
									o = e("./message_types"),
									s = e("../utility/events");

								function a(e, t, r) {
									return t in e ? Object.defineProperty(e, t, {
										value: r,
										enumerable: !0,
										configurable: !0,
										writable: !0
									}) : e[t] = r, e
								}

								function c(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function l() {
									return (l = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, r) {
										var n = u(e, t);
										if (n) {
											var i = Object.getOwnPropertyDescriptor(n, t);
											return i.get ? i.get.call(arguments.length < 3 ? e : r) : i.value
										}
									}).apply(this, arguments)
								}

								function u(e, t) {
									for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = p(e)););
									return e
								}

								function d(e, t) {
									return (d = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									})(e, t)
								}

								function h(e) {
									var t = function() {
										if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
										if (Reflect.construct.sham) return !1;
										if ("function" == typeof Proxy) return !0;
										try {
											return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
										} catch (e) {
											return !1
										}
									}();
									return function() {
										var r, n = p(e);
										if (t) {
											var i = p(this).constructor;
											r = Reflect.construct(n, arguments, i)
										} else r = n.apply(this, arguments);
										return f(this, r)
									}
								}

								function f(e, t) {
									if (t && ("object" === n(t) || "function" == typeof t)) return t;
									if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
									return function(e) {
										if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
										return e
									}(e)
								}

								function p(e) {
									return (p = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
										return e.__proto__ || Object.getPrototypeOf(e)
									})(e)
								}
								var v = function(e) {
									! function(e, t) {
										if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
										e.prototype = Object.create(t && t.prototype, {
											constructor: {
												value: e,
												writable: !0,
												configurable: !0
											}
										}), Object.defineProperty(e, "prototype", {
											writable: !1
										}), t && d(e, t)
									}(u, e);
									var t, r, n, i = h(u);

									function u(e) {
										return function(e, t) {
											if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
										}(this, u), i.call(this, e)
									}
									return t = u, n = [{
										key: "from",
										value: function(e, t) {
											var r;
											return new u({
												type: o.M_NOTICE.name,
												content: (r = {}, a(r, o.M_TEXT.name, e), a(r, o.M_HTML.name, t), r)
											})
										}
									}], (r = [{
										key: "isNotice",
										get: function() {
											return !0
										}
									}, {
										key: "isEquivalentTo",
										value: function(e) {
											return (0, s.isEventTypeSame)(e, o.M_NOTICE) || l(p(u.prototype), "isEquivalentTo", this).call(this, e)
										}
									}, {
										key: "serialize",
										value: function() {
											var e = l(p(u.prototype), "serialize", this).call(this);
											return e.content.msgtype = "m.notice", e
										}
									}]) && c(t.prototype, r), n && c(t, n), Object.defineProperty(t, "prototype", {
										writable: !1
									}), u
								}(i.MessageEvent);
								r.NoticeEvent = v
							}, {
								"../utility/events": 174,
								"./MessageEvent": 160,
								"./message_types": 165
							}],
							162: [function(e, t, r) {
								"use strict";

								function n(e) {
									return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
										return typeof e
									} : function(e) {
										return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
									})(e)
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.PollEndEvent = void 0;
								var i = e("./poll_types"),
									o = e("../InvalidEventError"),
									s = e("./relationship_types"),
									a = e("./MessageEvent"),
									c = e("./message_types"),
									l = e("../utility/events");

								function u(e, t) {
									var r = Object.keys(e);
									if (Object.getOwnPropertySymbols) {
										var n = Object.getOwnPropertySymbols(e);
										t && (n = n.filter((function(t) {
											return Object.getOwnPropertyDescriptor(e, t).enumerable
										}))), r.push.apply(r, n)
									}
									return r
								}

								function d(e) {
									for (var t = 1; t < arguments.length; t++) {
										var r = null != arguments[t] ? arguments[t] : {};
										t % 2 ? u(Object(r), !0).forEach((function(t) {
											y(e, t, r[t])
										})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : u(Object(r)).forEach((function(t) {
											Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
										}))
									}
									return e
								}

								function h(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function f(e, t) {
									return (f = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									})(e, t)
								}

								function p(e) {
									var t = function() {
										if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
										if (Reflect.construct.sham) return !1;
										if ("function" == typeof Proxy) return !0;
										try {
											return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
										} catch (e) {
											return !1
										}
									}();
									return function() {
										var r, n = m(e);
										if (t) {
											var i = m(this).constructor;
											r = Reflect.construct(n, arguments, i)
										} else r = n.apply(this, arguments);
										return v(this, r)
									}
								}

								function v(e, t) {
									if (t && ("object" === n(t) || "function" == typeof t)) return t;
									if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
									return g(e)
								}

								function g(e) {
									if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
									return e
								}

								function m(e) {
									return (m = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
										return e.__proto__ || Object.getPrototypeOf(e)
									})(e)
								}

								function y(e, t, r) {
									return t in e ? Object.defineProperty(e, t, {
										value: r,
										enumerable: !0,
										configurable: !0,
										writable: !0
									}) : e[t] = r, e
								}
								var b = function(e) {
									! function(e, t) {
										if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
										e.prototype = Object.create(t && t.prototype, {
											constructor: {
												value: e,
												writable: !0,
												configurable: !0
											}
										}), Object.defineProperty(e, "prototype", {
											writable: !1
										}), t && f(e, t)
									}(v, e);
									var t, r, n, u = p(v);

									function v(e) {
										var t;
										! function(e, t) {
											if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
										}(this, v), y(g(t = u.call(this, e)), "pollEventId", void 0), y(g(t), "closingMessage", void 0);
										var r = t.wireContent["m.relates_to"];
										if (!s.REFERENCE_RELATION.matches(null == r ? void 0 : r.rel_type) || "string" != typeof(null == r ? void 0 : r.event_id)) throw new o.InvalidEventError("Relationship must be a reference to an event");
										return t.pollEventId = r.event_id, t.closingMessage = new a.MessageEvent(t.wireFormat), t
									}
									return t = v, n = [{
										key: "from",
										value: function(e, t) {
											var r;
											return new v({
												type: i.M_POLL_END.name,
												content: (r = {
													"m.relates_to": {
														rel_type: s.REFERENCE_RELATION.name,
														event_id: e
													}
												}, y(r, i.M_POLL_END.name, {}), y(r, c.M_TEXT.name, t), r)
											})
										}
									}], (r = [{
										key: "isEquivalentTo",
										value: function(e) {
											return (0, l.isEventTypeSame)(e, i.M_POLL_END)
										}
									}, {
										key: "serialize",
										value: function() {
											return {
												type: i.M_POLL_END.name,
												content: d(y({
													"m.relates_to": {
														rel_type: s.REFERENCE_RELATION.name,
														event_id: this.pollEventId
													}
												}, i.M_POLL_END.name, {}), this.closingMessage.serialize().content)
											}
										}
									}]) && h(t.prototype, r), n && h(t, n), Object.defineProperty(t, "prototype", {
										writable: !1
									}), v
								}(e("./ExtensibleEvent").ExtensibleEvent);
								r.PollEndEvent = b
							}, {
								"../InvalidEventError": 155,
								"../utility/events": 174,
								"./ExtensibleEvent": 159,
								"./MessageEvent": 160,
								"./message_types": 165,
								"./poll_types": 166,
								"./relationship_types": 167
							}],
							163: [function(e, t, r) {
								"use strict";

								function n(e) {
									return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
										return typeof e
									} : function(e) {
										return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
									})(e)
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.PollResponseEvent = void 0;
								var i = e("./ExtensibleEvent"),
									o = e("./poll_types"),
									s = e("../InvalidEventError"),
									a = e("./relationship_types"),
									c = e("../utility/events");

								function l(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function u(e, t) {
									return (u = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									})(e, t)
								}

								function d(e) {
									var t = function() {
										if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
										if (Reflect.construct.sham) return !1;
										if ("function" == typeof Proxy) return !0;
										try {
											return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
										} catch (e) {
											return !1
										}
									}();
									return function() {
										var r, n = p(e);
										if (t) {
											var i = p(this).constructor;
											r = Reflect.construct(n, arguments, i)
										} else r = n.apply(this, arguments);
										return h(this, r)
									}
								}

								function h(e, t) {
									if (t && ("object" === n(t) || "function" == typeof t)) return t;
									if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
									return f(e)
								}

								function f(e) {
									if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
									return e
								}

								function p(e) {
									return (p = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
										return e.__proto__ || Object.getPrototypeOf(e)
									})(e)
								}

								function v(e, t, r) {
									return t in e ? Object.defineProperty(e, t, {
										value: r,
										enumerable: !0,
										configurable: !0,
										writable: !0
									}) : e[t] = r, e
								}
								var g = function(e) {
									! function(e, t) {
										if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
										e.prototype = Object.create(t && t.prototype, {
											constructor: {
												value: e,
												writable: !0,
												configurable: !0
											}
										}), Object.defineProperty(e, "prototype", {
											writable: !1
										}), t && u(e, t)
									}(h, e);
									var t, r, n, i = d(h);

									function h(e) {
										var t;
										! function(e, t) {
											if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
										}(this, h), v(f(t = i.call(this, e)), "internalAnswerIds", void 0), v(f(t), "internalSpoiled", void 0), v(f(t), "pollEventId", void 0);
										var r = t.wireContent["m.relates_to"];
										if (!a.REFERENCE_RELATION.matches(null == r ? void 0 : r.rel_type) || "string" != typeof(null == r ? void 0 : r.event_id)) throw new s.InvalidEventError("Relationship must be a reference to an event");
										return t.pollEventId = r.event_id, t.validateAgainst(null), t
									}
									return t = h, n = [{
										key: "from",
										value: function(e, t) {
											return new h({
												type: o.M_POLL_RESPONSE.name,
												content: v({
													"m.relates_to": {
														rel_type: a.REFERENCE_RELATION.name,
														event_id: t
													}
												}, o.M_POLL_RESPONSE.name, {
													answers: e
												})
											})
										}
									}], (r = [{
										key: "answerIds",
										get: function() {
											return this.internalAnswerIds
										}
									}, {
										key: "spoiled",
										get: function() {
											return this.internalSpoiled
										}
									}, {
										key: "validateAgainst",
										value: function(e) {
											var t = o.M_POLL_RESPONSE.findIn(this.wireContent);
											if (!Array.isArray(null == t ? void 0 : t.answers)) return this.internalSpoiled = !0, void(this.internalAnswerIds = []);
											var r = t.answers;
											if (r.some((function(e) {
													return "string" != typeof e
												})) || 0 === r.length) return this.internalSpoiled = !0, void(this.internalAnswerIds = []);
											if (e) {
												if (r.some((function(t) {
														return !e.answers.some((function(e) {
															return e.id === t
														}))
													}))) return this.internalSpoiled = !0, void(this.internalAnswerIds = []);
												r = r.slice(0, e.maxSelections)
											}
											this.internalAnswerIds = r, this.internalSpoiled = !1
										}
									}, {
										key: "isEquivalentTo",
										value: function(e) {
											return (0, c.isEventTypeSame)(e, o.M_POLL_RESPONSE)
										}
									}, {
										key: "serialize",
										value: function() {
											return {
												type: o.M_POLL_RESPONSE.name,
												content: v({
													"m.relates_to": {
														rel_type: a.REFERENCE_RELATION.name,
														event_id: this.pollEventId
													}
												}, o.M_POLL_RESPONSE.name, {
													answers: this.spoiled ? void 0 : this.answerIds
												})
											}
										}
									}]) && l(t.prototype, r), n && l(t, n), Object.defineProperty(t, "prototype", {
										writable: !1
									}), h
								}(i.ExtensibleEvent);
								r.PollResponseEvent = g
							}, {
								"../InvalidEventError": 155,
								"../utility/events": 174,
								"./ExtensibleEvent": 159,
								"./poll_types": 166,
								"./relationship_types": 167
							}],
							164: [function(e, t, r) {
								"use strict";

								function n(e) {
									return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
										return typeof e
									} : function(e) {
										return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
									})(e)
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.PollStartEvent = r.PollAnswerSubevent = void 0;
								var i = e("./poll_types"),
									o = e("./MessageEvent"),
									s = e("./message_types"),
									a = e("../InvalidEventError"),
									c = e("../NamespacedValue"),
									l = e("../utility/events"),
									u = e("./ExtensibleEvent");

								function d(e) {
									return function(e) {
										if (Array.isArray(e)) return h(e)
									}(e) || function(e) {
										if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
									}(e) || function(e, t) {
										if (!e) return;
										if ("string" == typeof e) return h(e, t);
										var r = Object.prototype.toString.call(e).slice(8, -1);
										"Object" === r && e.constructor && (r = e.constructor.name);
										if ("Map" === r || "Set" === r) return Array.from(e);
										if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return h(e, t)
									}(e) || function() {
										throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
									}()
								}

								function h(e, t) {
									(null == t || t > e.length) && (t = e.length);
									for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
									return n
								}

								function f(e, t) {
									var r = Object.keys(e);
									if (Object.getOwnPropertySymbols) {
										var n = Object.getOwnPropertySymbols(e);
										t && (n = n.filter((function(t) {
											return Object.getOwnPropertyDescriptor(e, t).enumerable
										}))), r.push.apply(r, n)
									}
									return r
								}

								function p(e) {
									for (var t = 1; t < arguments.length; t++) {
										var r = null != arguments[t] ? arguments[t] : {};
										t % 2 ? f(Object(r), !0).forEach((function(t) {
											k(e, t, r[t])
										})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : f(Object(r)).forEach((function(t) {
											Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
										}))
									}
									return e
								}

								function v(e, t) {
									if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
								}

								function g(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function m(e, t, r) {
									return t && g(e.prototype, t), r && g(e, r), Object.defineProperty(e, "prototype", {
										writable: !1
									}), e
								}

								function y(e, t) {
									if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
									e.prototype = Object.create(t && t.prototype, {
										constructor: {
											value: e,
											writable: !0,
											configurable: !0
										}
									}), Object.defineProperty(e, "prototype", {
										writable: !1
									}), t && b(e, t)
								}

								function b(e, t) {
									return (b = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									})(e, t)
								}

								function _(e) {
									var t = function() {
										if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
										if (Reflect.construct.sham) return !1;
										if ("function" == typeof Proxy) return !0;
										try {
											return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
										} catch (e) {
											return !1
										}
									}();
									return function() {
										var r, n = E(e);
										if (t) {
											var i = E(this).constructor;
											r = Reflect.construct(n, arguments, i)
										} else r = n.apply(this, arguments);
										return w(this, r)
									}
								}

								function w(e, t) {
									if (t && ("object" === n(t) || "function" == typeof t)) return t;
									if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
									return S(e)
								}

								function S(e) {
									if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
									return e
								}

								function E(e) {
									return (E = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
										return e.__proto__ || Object.getPrototypeOf(e)
									})(e)
								}

								function k(e, t, r) {
									return t in e ? Object.defineProperty(e, t, {
										value: r,
										enumerable: !0,
										configurable: !0,
										writable: !0
									}) : e[t] = r, e
								}
								var T = function(e) {
									y(r, e);
									var t = _(r);

									function r(e) {
										var n;
										v(this, r), k(S(n = t.call(this, e)), "id", void 0);
										var i = e.content.id;
										if (!i || "string" != typeof i) throw new a.InvalidEventError("Answer ID must be a non-empty string");
										return n.id = i, n
									}
									return m(r, [{
										key: "serialize",
										value: function() {
											return {
												type: "org.matrix.sdk.poll.answer",
												content: p({
													id: this.id
												}, this.serializeMMessageOnly())
											}
										}
									}], [{
										key: "from",
										value: function(e, t) {
											return new r({
												type: "org.matrix.sdk.poll.answer",
												content: k({
													id: e
												}, s.M_TEXT.name, t)
											})
										}
									}]), r
								}(o.MessageEvent);
								r.PollAnswerSubevent = T;
								var I = function(e) {
									y(r, e);
									var t = _(r);

									function r(e) {
										var n;
										v(this, r), k(S(n = t.call(this, e)), "question", void 0), k(S(n), "kind", void 0), k(S(n), "rawKind", void 0), k(S(n), "maxSelections", void 0), k(S(n), "answers", void 0);
										var s = i.M_POLL_START.findIn(n.wireContent);
										if (!s.question) throw new a.InvalidEventError("A question is required");
										if (n.question = new o.MessageEvent({
												type: "org.matrix.sdk.poll.question",
												content: s.question
											}), n.rawKind = s.kind, i.M_POLL_KIND_DISCLOSED.matches(n.rawKind) ? n.kind = i.M_POLL_KIND_DISCLOSED : n.kind = i.M_POLL_KIND_UNDISCLOSED, n.maxSelections = Number.isFinite(s.max_selections) && s.max_selections > 0 ? s.max_selections : 1, !Array.isArray(s.answers)) throw new a.InvalidEventError("Poll answers must be an array");
										var c = s.answers.slice(0, 20).map((function(e) {
											return new T({
												type: "org.matrix.sdk.poll.answer",
												content: e
											})
										}));
										if (c.length <= 0) throw new a.InvalidEventError("No answers available");
										return n.answers = c, n
									}
									return m(r, [{
										key: "isEquivalentTo",
										value: function(e) {
											return (0, l.isEventTypeSame)(e, i.M_POLL_START)
										}
									}, {
										key: "serialize",
										value: function() {
											var e;
											return {
												type: i.M_POLL_START.name,
												content: (e = {}, k(e, i.M_POLL_START.name, {
													question: this.question.serialize().content,
													kind: this.rawKind,
													max_selections: this.maxSelections,
													answers: this.answers.map((function(e) {
														return e.serialize().content
													}))
												}), k(e, s.M_TEXT.name, "".concat(this.question.text, "\n").concat(this.answers.map((function(e, t) {
													return "".concat(t + 1, ". ").concat(e.text)
												})).join("\n"))), e)
											}
										}
									}], [{
										key: "from",
										value: function(e, t, n) {
											var o, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
											return new r({
												type: i.M_POLL_START.name,
												content: (o = {}, k(o, s.M_TEXT.name, e), k(o, i.M_POLL_START.name, {
													question: k({}, s.M_TEXT.name, e),
													kind: n instanceof c.NamespacedValue ? n.name : n,
													max_selections: a,
													answers: t.map((function(e) {
														return k({
															id: C()
														}, s.M_TEXT.name, e)
													}))
												}), o)
											})
										}
									}]), r
								}(u.ExtensibleEvent);
								r.PollStartEvent = I;
								var R = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

								function C() {
									return d(Array(16)).map((function() {
										return R.charAt(Math.floor(Math.random() * R.length))
									})).join("")
								}
							}, {
								"../InvalidEventError": 155,
								"../NamespacedValue": 157,
								"../utility/events": 174,
								"./ExtensibleEvent": 159,
								"./MessageEvent": 160,
								"./message_types": 165,
								"./poll_types": 166
							}],
							165: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.M_TEXT = r.M_NOTICE = r.M_MESSAGE = r.M_HTML = r.M_EMOTE = void 0;
								var n = e("../NamespacedValue"),
									i = new n.UnstableValue("m.message", "org.matrix.msc1767.message");
								r.M_MESSAGE = i;
								var o = new n.UnstableValue("m.text", "org.matrix.msc1767.text");
								r.M_TEXT = o;
								var s = new n.UnstableValue("m.html", "org.matrix.msc1767.html");
								r.M_HTML = s;
								var a = new n.UnstableValue("m.emote", "org.matrix.msc1767.emote");
								r.M_EMOTE = a;
								var c = new n.UnstableValue("m.notice", "org.matrix.msc1767.notice");
								r.M_NOTICE = c
							}, {
								"../NamespacedValue": 157
							}],
							166: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.M_POLL_START = r.M_POLL_RESPONSE = r.M_POLL_KIND_UNDISCLOSED = r.M_POLL_KIND_DISCLOSED = r.M_POLL_END = void 0;
								var n = e("../NamespacedValue"),
									i = new n.UnstableValue("m.poll.disclosed", "org.matrix.msc3381.poll.disclosed");
								r.M_POLL_KIND_DISCLOSED = i;
								var o = new n.UnstableValue("m.poll.undisclosed", "org.matrix.msc3381.poll.undisclosed");
								r.M_POLL_KIND_UNDISCLOSED = o;
								var s = new n.UnstableValue("m.poll.start", "org.matrix.msc3381.poll.start");
								r.M_POLL_START = s;
								var a = new n.UnstableValue("m.poll.response", "org.matrix.msc3381.poll.response");
								r.M_POLL_RESPONSE = a;
								var c = new n.UnstableValue("m.poll.end", "org.matrix.msc3381.poll.end");
								r.M_POLL_END = c
							}, {
								"../NamespacedValue": 157
							}],
							167: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.REFERENCE_RELATION = void 0;
								var n = new(e("../NamespacedValue").NamespacedValue)("m.reference");
								r.REFERENCE_RELATION = n
							}, {
								"../NamespacedValue": 157
							}],
							168: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								});
								var n = e("./ExtensibleEvents");
								Object.keys(n).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === n[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return n[e]
										}
									}))
								}));
								var i = e("./IPartialEvent");
								Object.keys(i).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === i[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return i[e]
										}
									}))
								}));
								var o = e("./InvalidEventError");
								Object.keys(o).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === o[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return o[e]
										}
									}))
								}));
								var s = e("./NamespacedValue");
								Object.keys(s).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === s[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return s[e]
										}
									}))
								}));
								var a = e("./NamespacedMap");
								Object.keys(a).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === a[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return a[e]
										}
									}))
								}));
								var c = e("./types");
								Object.keys(c).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === c[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return c[e]
										}
									}))
								}));
								var l = e("./utility/MessageMatchers");
								Object.keys(l).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === l[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return l[e]
										}
									}))
								}));
								var u = e("./utility/events");
								Object.keys(u).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === u[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return u[e]
										}
									}))
								}));
								var d = e("./interpreters/legacy/MRoomMessage");
								Object.keys(d).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === d[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return d[e]
										}
									}))
								}));
								var h = e("./interpreters/modern/MMessage");
								Object.keys(h).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === h[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return h[e]
										}
									}))
								}));
								var f = e("./interpreters/modern/MPoll");
								Object.keys(f).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === f[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return f[e]
										}
									}))
								}));
								var p = e("./events/relationship_types");
								Object.keys(p).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === p[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return p[e]
										}
									}))
								}));
								var v = e("./events/ExtensibleEvent");
								Object.keys(v).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === v[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return v[e]
										}
									}))
								}));
								var g = e("./events/message_types");
								Object.keys(g).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === g[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return g[e]
										}
									}))
								}));
								var m = e("./events/MessageEvent");
								Object.keys(m).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === m[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return m[e]
										}
									}))
								}));
								var y = e("./events/EmoteEvent");
								Object.keys(y).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === y[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return y[e]
										}
									}))
								}));
								var b = e("./events/NoticeEvent");
								Object.keys(b).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === b[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return b[e]
										}
									}))
								}));
								var _ = e("./events/poll_types");
								Object.keys(_).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === _[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return _[e]
										}
									}))
								}));
								var w = e("./events/PollStartEvent");
								Object.keys(w).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === w[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return w[e]
										}
									}))
								}));
								var S = e("./events/PollResponseEvent");
								Object.keys(S).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === S[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return S[e]
										}
									}))
								}));
								var E = e("./events/PollEndEvent");
								Object.keys(E).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === E[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return E[e]
										}
									}))
								}))
							}, {
								"./ExtensibleEvents": 153,
								"./IPartialEvent": 154,
								"./InvalidEventError": 155,
								"./NamespacedMap": 156,
								"./NamespacedValue": 157,
								"./events/EmoteEvent": 158,
								"./events/ExtensibleEvent": 159,
								"./events/MessageEvent": 160,
								"./events/NoticeEvent": 161,
								"./events/PollEndEvent": 162,
								"./events/PollResponseEvent": 163,
								"./events/PollStartEvent": 164,
								"./events/message_types": 165,
								"./events/poll_types": 166,
								"./events/relationship_types": 167,
								"./interpreters/legacy/MRoomMessage": 169,
								"./interpreters/modern/MMessage": 170,
								"./interpreters/modern/MPoll": 171,
								"./types": 172,
								"./utility/MessageMatchers": 173,
								"./utility/events": 174
							}],
							169: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.LEGACY_M_ROOM_MESSAGE = void 0, r.parseMRoomMessage = function(e) {
									var t, r, s;
									if (a.M_MESSAGE.findIn(e.content) || a.M_TEXT.findIn(e.content)) return new n.MessageEvent(e);
									var c, d = null === (t = e.content) || void 0 === t ? void 0 : t.msgtype,
										h = null === (r = e.content) || void 0 === r ? void 0 : r.body,
										f = "org.matrix.custom.html" === (null === (s = e.content) || void 0 === s ? void 0 : s.format) ? e.content.formatted_body : null;
									return "m.text" === d ? new n.MessageEvent(l(l({}, e), {}, {
										content: l(l({}, e.content), {}, (c = {}, u(c, a.M_TEXT.name, h), u(c, a.M_HTML.name, f), c))
									})) : "m.notice" === d ? new i.NoticeEvent(l(l({}, e), {}, {
										content: l(l({}, e.content), {}, (p = {}, u(p, a.M_TEXT.name, h), u(p, a.M_HTML.name, f), p))
									})) : "m.emote" === d ? new o.EmoteEvent(l(l({}, e), {}, {
										content: l(l({}, e.content), {}, (v = {}, u(v, a.M_TEXT.name, h), u(v, a.M_HTML.name, f), v))
									})) : null;
									var p, v
								};
								var n = e("../../events/MessageEvent"),
									i = e("../../events/NoticeEvent"),
									o = e("../../events/EmoteEvent"),
									s = e("../../NamespacedValue"),
									a = e("../../events/message_types");

								function c(e, t) {
									var r = Object.keys(e);
									if (Object.getOwnPropertySymbols) {
										var n = Object.getOwnPropertySymbols(e);
										t && (n = n.filter((function(t) {
											return Object.getOwnPropertyDescriptor(e, t).enumerable
										}))), r.push.apply(r, n)
									}
									return r
								}

								function l(e) {
									for (var t = 1; t < arguments.length; t++) {
										var r = null != arguments[t] ? arguments[t] : {};
										t % 2 ? c(Object(r), !0).forEach((function(t) {
											u(e, t, r[t])
										})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : c(Object(r)).forEach((function(t) {
											Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
										}))
									}
									return e
								}

								function u(e, t, r) {
									return t in e ? Object.defineProperty(e, t, {
										value: r,
										enumerable: !0,
										configurable: !0,
										writable: !0
									}) : e[t] = r, e
								}
								var d = new s.NamespacedValue("m.room.message");
								r.LEGACY_M_ROOM_MESSAGE = d
							}, {
								"../../NamespacedValue": 157,
								"../../events/EmoteEvent": 158,
								"../../events/MessageEvent": 160,
								"../../events/NoticeEvent": 161,
								"../../events/message_types": 165
							}],
							170: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.parseMMessage = function(e) {
									if (i.M_EMOTE.matches(e.type)) return new o.EmoteEvent(e);
									if (i.M_NOTICE.matches(e.type)) return new s.NoticeEvent(e);
									return new n.MessageEvent(e)
								};
								var n = e("../../events/MessageEvent"),
									i = e("../../events/message_types"),
									o = e("../../events/EmoteEvent"),
									s = e("../../events/NoticeEvent")
							}, {
								"../../events/EmoteEvent": 158,
								"../../events/MessageEvent": 160,
								"../../events/NoticeEvent": 161,
								"../../events/message_types": 165
							}],
							171: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.parseMPoll = function(e) {
									if (n.M_POLL_START.matches(e.type)) return new i.PollStartEvent(e);
									if (n.M_POLL_RESPONSE.matches(e.type)) return new o.PollResponseEvent(e);
									if (n.M_POLL_END.matches(e.type)) return new s.PollEndEvent(e);
									return null
								};
								var n = e("../../events/poll_types"),
									i = e("../../events/PollStartEvent"),
									o = e("../../events/PollResponseEvent"),
									s = e("../../events/PollEndEvent")
							}, {
								"../../events/PollEndEvent": 162,
								"../../events/PollResponseEvent": 163,
								"../../events/PollStartEvent": 164,
								"../../events/poll_types": 166
							}],
							172: [function(e, t, r) {
								"use strict";

								function n(e) {
									return null != e
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.isOptionalAString = function(e) {
									return n(e) && "string" == typeof e
								}, r.isProvided = n
							}, {}],
							173: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.LegacyMsgType = void 0, r.isEventLike = function(e, t) {
									var r = e.content;
									if (t === n.Text) return i.M_MESSAGE.matches(e.type) || "m.room.message" === e.type && "m.text" === (null == r ? void 0 : r.msgtype);
									if (t === n.Emote) return i.M_EMOTE.matches(e.type) || "m.room.message" === e.type && "m.emote" === (null == r ? void 0 : r.msgtype);
									if (t === n.Notice) return i.M_NOTICE.matches(e.type) || "m.room.message" === e.type && "m.notice" === (null == r ? void 0 : r.msgtype);
									return !1
								};
								var n, i = e("../events/message_types");
								r.LegacyMsgType = n,
									function(e) {
										e.Text = "m.text", e.Notice = "m.notice", e.Emote = "m.emote"
									}(n || (r.LegacyMsgType = n = {}))
							}, {
								"../events/message_types": 165
							}],
							174: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.isEventTypeSame = function(e, t) {
									if ("string" == typeof e) return "string" == typeof t ? t === e : t.matches(e);
									if ("string" == typeof t) return e.matches(t);
									var r = t,
										n = e;
									return r.matches(n.name) || r.matches(n.altName)
								}
							}, {}],
							175: [function(e, t, r) {
								"use strict";

								function n(e) {
									return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
										return typeof e
									} : function(e) {
										return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
									})(e)
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.ClientWidgetApi = void 0;
								var i = e("events"),
									o = e("./transport/PostmessageTransport"),
									s = e("./interfaces/WidgetApiDirection"),
									a = e("./interfaces/WidgetApiAction"),
									c = e("./interfaces/Capabilities"),
									l = e("./interfaces/ApiVersion"),
									u = e("./models/WidgetEventCapability"),
									d = e("./interfaces/GetOpenIDAction"),
									h = e("./util/SimpleObservable"),
									f = e("./Symbols");

								function p() {
									p = function() {
										return e
									};
									var e = {},
										t = Object.prototype,
										r = t.hasOwnProperty,
										i = "function" == typeof Symbol ? Symbol : {},
										o = i.iterator || "@@iterator",
										s = i.asyncIterator || "@@asyncIterator",
										a = i.toStringTag || "@@toStringTag";

									function c(e, t, r) {
										return Object.defineProperty(e, t, {
											value: r,
											enumerable: !0,
											configurable: !0,
											writable: !0
										}), e[t]
									}
									try {
										c({}, "")
									} catch (C) {
										c = function(e, t, r) {
											return e[t] = r
										}
									}

									function l(e, t, r, n) {
										var i = t && t.prototype instanceof h ? t : h,
											o = Object.create(i.prototype),
											s = new T(n || []);
										return o._invoke = function(e, t, r) {
											var n = "suspendedStart";
											return function(i, o) {
												if ("executing" === n) throw new Error("Generator is already running");
												if ("completed" === n) {
													if ("throw" === i) throw o;
													return R()
												}
												for (r.method = i, r.arg = o;;) {
													var s = r.delegate;
													if (s) {
														var a = S(s, r);
														if (a) {
															if (a === d) continue;
															return a
														}
													}
													if ("next" === r.method) r.sent = r._sent = r.arg;
													else if ("throw" === r.method) {
														if ("suspendedStart" === n) throw n = "completed", r.arg;
														r.dispatchException(r.arg)
													} else "return" === r.method && r.abrupt("return", r.arg);
													n = "executing";
													var c = u(e, t, r);
													if ("normal" === c.type) {
														if (n = r.done ? "completed" : "suspendedYield", c.arg === d) continue;
														return {
															value: c.arg,
															done: r.done
														}
													}
													"throw" === c.type && (n = "completed", r.method = "throw", r.arg = c.arg)
												}
											}
										}(e, r, s), o
									}

									function u(e, t, r) {
										try {
											return {
												type: "normal",
												arg: e.call(t, r)
											}
										} catch (C) {
											return {
												type: "throw",
												arg: C
											}
										}
									}
									e.wrap = l;
									var d = {};

									function h() {}

									function f() {}

									function v() {}
									var g = {};
									c(g, o, (function() {
										return this
									}));
									var m = Object.getPrototypeOf,
										y = m && m(m(I([])));
									y && y !== t && r.call(y, o) && (g = y);
									var b = v.prototype = h.prototype = Object.create(g);

									function _(e) {
										["next", "throw", "return"].forEach((function(t) {
											c(e, t, (function(e) {
												return this._invoke(t, e)
											}))
										}))
									}

									function w(e, t) {
										var i;
										this._invoke = function(o, s) {
											function a() {
												return new t((function(i, a) {
													! function i(o, s, a, c) {
														var l = u(e[o], e, s);
														if ("throw" !== l.type) {
															var d = l.arg,
																h = d.value;
															return h && "object" == n(h) && r.call(h, "__await") ? t.resolve(h.__await).then((function(e) {
																i("next", e, a, c)
															}), (function(e) {
																i("throw", e, a, c)
															})) : t.resolve(h).then((function(e) {
																d.value = e, a(d)
															}), (function(e) {
																return i("throw", e, a, c)
															}))
														}
														c(l.arg)
													}(o, s, i, a)
												}))
											}
											return i = i ? i.then(a, a) : a()
										}
									}

									function S(e, t) {
										var r = e.iterator[t.method];
										if (void 0 === r) {
											if (t.delegate = null, "throw" === t.method) {
												if (e.iterator.return && (t.method = "return", t.arg = void 0, S(e, t), "throw" === t.method)) return d;
												t.method = "throw", t.arg = new TypeError("The iterator does not provide a 'throw' method")
											}
											return d
										}
										var n = u(r, e.iterator, t.arg);
										if ("throw" === n.type) return t.method = "throw", t.arg = n.arg, t.delegate = null, d;
										var i = n.arg;
										return i ? i.done ? (t[e.resultName] = i.value, t.next = e.nextLoc, "return" !== t.method && (t.method = "next", t.arg = void 0), t.delegate = null, d) : i : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, d)
									}

									function E(e) {
										var t = {
											tryLoc: e[0]
										};
										1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
									}

									function k(e) {
										var t = e.completion || {};
										t.type = "normal", delete t.arg, e.completion = t
									}

									function T(e) {
										this.tryEntries = [{
											tryLoc: "root"
										}], e.forEach(E, this), this.reset(!0)
									}

									function I(e) {
										if (e) {
											var t = e[o];
											if (t) return t.call(e);
											if ("function" == typeof e.next) return e;
											if (!isNaN(e.length)) {
												var n = -1,
													i = function t() {
														for (; ++n < e.length;)
															if (r.call(e, n)) return t.value = e[n], t.done = !1, t;
														return t.value = void 0, t.done = !0, t
													};
												return i.next = i
											}
										}
										return {
											next: R
										}
									}

									function R() {
										return {
											value: void 0,
											done: !0
										}
									}
									return f.prototype = v, c(b, "constructor", v), c(v, "constructor", f), f.displayName = c(v, a, "GeneratorFunction"), e.isGeneratorFunction = function(e) {
										var t = "function" == typeof e && e.constructor;
										return !!t && (t === f || "GeneratorFunction" === (t.displayName || t.name))
									}, e.mark = function(e) {
										return Object.setPrototypeOf ? Object.setPrototypeOf(e, v) : (e.__proto__ = v, c(e, a, "GeneratorFunction")), e.prototype = Object.create(b), e
									}, e.awrap = function(e) {
										return {
											__await: e
										}
									}, _(w.prototype), c(w.prototype, s, (function() {
										return this
									})), e.AsyncIterator = w, e.async = function(t, r, n, i, o) {
										void 0 === o && (o = Promise);
										var s = new w(l(t, r, n, i), o);
										return e.isGeneratorFunction(r) ? s : s.next().then((function(e) {
											return e.done ? e.value : s.next()
										}))
									}, _(b), c(b, a, "Generator"), c(b, o, (function() {
										return this
									})), c(b, "toString", (function() {
										return "[object Generator]"
									})), e.keys = function(e) {
										var t = [];
										for (var r in e) t.push(r);
										return t.reverse(),
											function r() {
												for (; t.length;) {
													var n = t.pop();
													if (n in e) return r.value = n, r.done = !1, r
												}
												return r.done = !0, r
											}
									}, e.values = I, T.prototype = {
										constructor: T,
										reset: function(e) {
											if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(k), !e)
												for (var t in this) "t" === t.charAt(0) && r.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0)
										},
										stop: function() {
											this.done = !0;
											var e = this.tryEntries[0].completion;
											if ("throw" === e.type) throw e.arg;
											return this.rval
										},
										dispatchException: function(e) {
											if (this.done) throw e;
											var t = this;

											function n(r, n) {
												return s.type = "throw", s.arg = e, t.next = r, n && (t.method = "next", t.arg = void 0), !!n
											}
											for (var i = this.tryEntries.length - 1; i >= 0; --i) {
												var o = this.tryEntries[i],
													s = o.completion;
												if ("root" === o.tryLoc) return n("end");
												if (o.tryLoc <= this.prev) {
													var a = r.call(o, "catchLoc"),
														c = r.call(o, "finallyLoc");
													if (a && c) {
														if (this.prev < o.catchLoc) return n(o.catchLoc, !0);
														if (this.prev < o.finallyLoc) return n(o.finallyLoc)
													} else if (a) {
														if (this.prev < o.catchLoc) return n(o.catchLoc, !0)
													} else {
														if (!c) throw new Error("try statement without catch or finally");
														if (this.prev < o.finallyLoc) return n(o.finallyLoc)
													}
												}
											}
										},
										abrupt: function(e, t) {
											for (var n = this.tryEntries.length - 1; n >= 0; --n) {
												var i = this.tryEntries[n];
												if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
													var o = i;
													break
												}
											}
											o && ("break" === e || "continue" === e) && o.tryLoc <= t && t <= o.finallyLoc && (o = null);
											var s = o ? o.completion : {};
											return s.type = e, s.arg = t, o ? (this.method = "next", this.next = o.finallyLoc, d) : this.complete(s)
										},
										complete: function(e, t) {
											if ("throw" === e.type) throw e.arg;
											return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), d
										},
										finish: function(e) {
											for (var t = this.tryEntries.length - 1; t >= 0; --t) {
												var r = this.tryEntries[t];
												if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), k(r), d
											}
										},
										catch: function(e) {
											for (var t = this.tryEntries.length - 1; t >= 0; --t) {
												var r = this.tryEntries[t];
												if (r.tryLoc === e) {
													var n = r.completion;
													if ("throw" === n.type) {
														var i = n.arg;
														k(r)
													}
													return i
												}
											}
											throw new Error("illegal catch attempt")
										},
										delegateYield: function(e, t, r) {
											return this.delegate = {
												iterator: I(e),
												resultName: t,
												nextLoc: r
											}, "next" === this.method && (this.arg = void 0), d
										}
									}, e
								}

								function v(e, t, r, n, i, o, s) {
									try {
										var a = e[o](s),
											c = a.value
									} catch (l) {
										return void r(l)
									}
									a.done ? t(c) : Promise.resolve(c).then(n, i)
								}

								function g(e) {
									return function() {
										var t = this,
											r = arguments;
										return new Promise((function(n, i) {
											var o = e.apply(t, r);

											function s(e) {
												v(o, n, i, s, a, "next", e)
											}

											function a(e) {
												v(o, n, i, s, a, "throw", e)
											}
											s(void 0)
										}))
									}
								}

								function m(e, t) {
									var r = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
									if (!r) {
										if (Array.isArray(e) || (r = function(e, t) {
												if (!e) return;
												if ("string" == typeof e) return y(e, t);
												var r = Object.prototype.toString.call(e).slice(8, -1);
												"Object" === r && e.constructor && (r = e.constructor.name);
												if ("Map" === r || "Set" === r) return Array.from(e);
												if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return y(e, t)
											}(e)) || t && e && "number" == typeof e.length) {
											r && (e = r);
											var n = 0,
												i = function() {};
											return {
												s: i,
												n: function() {
													return n >= e.length ? {
														done: !0
													} : {
														done: !1,
														value: e[n++]
													}
												},
												e: function(e) {
													throw e
												},
												f: i
											}
										}
										throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
									}
									var o, s = !0,
										a = !1;
									return {
										s: function() {
											r = r.call(e)
										},
										n: function() {
											var e = r.next();
											return s = e.done, e
										},
										e: function(e) {
											a = !0, o = e
										},
										f: function() {
											try {
												s || null == r.return || r.return()
											} finally {
												if (a) throw o
											}
										}
									}
								}

								function y(e, t) {
									(null == t || t > e.length) && (t = e.length);
									for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
									return n
								}

								function b(e, t) {
									var r = Object.keys(e);
									if (Object.getOwnPropertySymbols) {
										var n = Object.getOwnPropertySymbols(e);
										t && (n = n.filter((function(t) {
											return Object.getOwnPropertyDescriptor(e, t).enumerable
										}))), r.push.apply(r, n)
									}
									return r
								}

								function _(e) {
									for (var t = 1; t < arguments.length; t++) {
										var r = null != arguments[t] ? arguments[t] : {};
										t % 2 ? b(Object(r), !0).forEach((function(t) {
											R(e, t, r[t])
										})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : b(Object(r)).forEach((function(t) {
											Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
										}))
									}
									return e
								}

								function w(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function S(e, t) {
									return (S = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
										return e.__proto__ = t, e
									})(e, t)
								}

								function E(e) {
									var t = function() {
										if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
										if (Reflect.construct.sham) return !1;
										if ("function" == typeof Proxy) return !0;
										try {
											return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
										} catch (e) {
											return !1
										}
									}();
									return function() {
										var r, n = I(e);
										if (t) {
											var i = I(this).constructor;
											r = Reflect.construct(n, arguments, i)
										} else r = n.apply(this, arguments);
										return k(this, r)
									}
								}

								function k(e, t) {
									if (t && ("object" === n(t) || "function" == typeof t)) return t;
									if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
									return T(e)
								}

								function T(e) {
									if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
									return e
								}

								function I(e) {
									return (I = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
										return e.__proto__ || Object.getPrototypeOf(e)
									})(e)
								}

								function R(e, t, r) {
									return t in e ? Object.defineProperty(e, t, {
										value: r,
										enumerable: !0,
										configurable: !0,
										writable: !0
									}) : e[t] = r, e
								}

								function C(e) {
									var t, r, n, i = 2;
									for ("undefined" != typeof Symbol && (r = Symbol.asyncIterator, n = Symbol.iterator); i--;) {
										if (r && null != (t = e[r])) return t.call(e);
										if (n && null != (t = e[n])) return new M(t.call(e));
										r = "@@asyncIterator", n = "@@iterator"
									}
									throw new TypeError("Object is not async iterable")
								}

								function M(e) {
									function t(e) {
										if (Object(e) !== e) return Promise.reject(new TypeError(e + " is not an object."));
										var t = e.done;
										return Promise.resolve(e.value).then((function(e) {
											return {
												value: e,
												done: t
											}
										}))
									}
									return (M = function(e) {
										this.s = e, this.n = e.next
									}).prototype = {
										s: null,
										n: null,
										next: function() {
											return t(this.n.apply(this.s, arguments))
										},
										return: function(e) {
											var r = this.s.return;
											return void 0 === r ? Promise.resolve({
												value: e,
												done: !0
											}) : t(r.apply(this.s, arguments))
										},
										throw: function(e) {
											var r = this.s.return;
											return void 0 === r ? Promise.reject(e) : t(r.apply(this.s, arguments))
										}
									}, new M(e)
								}
								var x = function(e) {
									! function(e, t) {
										if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
										e.prototype = Object.create(t && t.prototype, {
											constructor: {
												value: e,
												writable: !0,
												configurable: !0
											}
										}), Object.defineProperty(e, "prototype", {
											writable: !1
										}), t && S(e, t)
									}(O, e);
									var t, r, n, i, v, y, b, k, I, M, x = E(O);

									function O(e, t, r) {
										var n;
										if (function(e, t) {
												if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
											}(this, O), (n = x.call(this)).widget = e, n.iframe = t, n.driver = r, R(T(n), "transport", void 0), R(T(n), "contentLoadedActionSent", !1), R(T(n), "allowedCapabilities", new Set), R(T(n), "allowedEvents", []), R(T(n), "isStopped", !1), R(T(n), "turnServers", null), null == t || !t.contentWindow) throw new Error("No iframe supplied");
										if (!e) throw new Error("Invalid widget");
										if (!r) throw new Error("Invalid driver");
										return n.transport = new o.PostmessageTransport(s.WidgetApiDirection.ToWidget, e.id, t.contentWindow, window), n.transport.targetOrigin = e.origin, n.transport.on("message", n.handleMessage.bind(T(n))), t.addEventListener("load", n.onIframeLoad.bind(T(n))), n.transport.start(), n
									}
									return t = O, (r = [{
										key: "hasCapability",
										value: function(e) {
											return this.allowedCapabilities.has(e)
										}
									}, {
										key: "canUseRoomTimeline",
										value: function(e) {
											return this.hasCapability("org.matrix.msc2762.timeline:".concat(f.Symbols.AnyRoom)) || this.hasCapability("org.matrix.msc2762.timeline:".concat(e))
										}
									}, {
										key: "canSendRoomEvent",
										value: function(e) {
											var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
											return this.allowedEvents.some((function(r) {
												return r.matchesAsRoomEvent(u.EventDirection.Send, e, t)
											}))
										}
									}, {
										key: "canSendStateEvent",
										value: function(e, t) {
											return this.allowedEvents.some((function(r) {
												return r.matchesAsStateEvent(u.EventDirection.Send, e, t)
											}))
										}
									}, {
										key: "canSendToDeviceEvent",
										value: function(e) {
											return this.allowedEvents.some((function(t) {
												return t.matchesAsToDeviceEvent(u.EventDirection.Send, e)
											}))
										}
									}, {
										key: "canReceiveRoomEvent",
										value: function(e) {
											var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
											return this.allowedEvents.some((function(r) {
												return r.matchesAsRoomEvent(u.EventDirection.Receive, e, t)
											}))
										}
									}, {
										key: "canReceiveStateEvent",
										value: function(e, t) {
											return this.allowedEvents.some((function(r) {
												return r.matchesAsStateEvent(u.EventDirection.Receive, e, t)
											}))
										}
									}, {
										key: "canReceiveToDeviceEvent",
										value: function(e) {
											return this.allowedEvents.some((function(t) {
												return t.matchesAsToDeviceEvent(u.EventDirection.Receive, e)
											}))
										}
									}, {
										key: "stop",
										value: function() {
											this.isStopped = !0, this.transport.stop()
										}
									}, {
										key: "beginCapabilities",
										value: function() {
											var e, t = this;
											this.emit("preparing"), this.transport.send(a.WidgetApiToWidgetAction.Capabilities, {}).then((function(r) {
												return e = r.capabilities, t.driver.validateCapabilities(new Set(r.capabilities))
											})).then((function(r) {
												console.log("Widget ".concat(t.widget.id, " is allowed capabilities:"), Array.from(r)), t.allowedCapabilities = r, t.allowedEvents = u.WidgetEventCapability.findEventCapabilities(r), t.notifyCapabilities(e), t.emit("ready")
											}))
										}
									}, {
										key: "notifyCapabilities",
										value: function(e) {
											var t = this;
											this.transport.send(a.WidgetApiToWidgetAction.NotifyCapabilities, {
												requested: e,
												approved: Array.from(this.allowedCapabilities)
											}).catch((function(e) {
												console.warn("non-fatal error notifying widget of approved capabilities:", e)
											})).then((function() {
												t.emit("capabilitiesNotified")
											}))
										}
									}, {
										key: "onIframeLoad",
										value: function(e) {
											this.widget.waitForIframeLoad ? this.beginCapabilities() : this.contentLoadedActionSent = !1
										}
									}, {
										key: "handleContentLoadedAction",
										value: function(e) {
											if (this.contentLoadedActionSent) throw new Error("Improper sequence: ContentLoaded Action can only be send once after the widget loaded and should only be used if waitForIframeLoad is false (default=true)");
											this.widget.waitForIframeLoad ? this.transport.reply(e, {
												error: {
													message: "Improper sequence: not expecting ContentLoaded event if waitForIframLoad is true (default=true)"
												}
											}) : (this.transport.reply(e, {}), this.beginCapabilities()), this.contentLoadedActionSent = !0
										}
									}, {
										key: "replyVersions",
										value: function(e) {
											this.transport.reply(e, {
												supported_versions: l.CurrentApiVersions
											})
										}
									}, {
										key: "handleCapabilitiesRenegotiate",
										value: function(e) {
											var t, r = this;
											this.transport.reply(e, {});
											var n = (null === (t = e.data) || void 0 === t ? void 0 : t.capabilities) || [],
												i = new Set(n.filter((function(e) {
													return !r.hasCapability(e)
												})));
											if (0 === i.size) return this.notifyCapabilities([]);
											this.driver.validateCapabilities(i).then((function(e) {
												return e.forEach((function(e) {
													return r.allowedCapabilities.add(e)
												})), u.WidgetEventCapability.findEventCapabilities(e).forEach((function(e) {
													return r.allowedEvents.push(e)
												})), r.notifyCapabilities(Array.from(i))
											}))
										}
									}, {
										key: "handleNavigate",
										value: function(e) {
											var t, r, n = this;
											if (!this.hasCapability(c.MatrixCapabilities.MSC2931Navigate)) return this.transport.reply(e, {
												error: {
													message: "Missing capability"
												}
											});
											if (null === (t = e.data) || void 0 === t || !t.uri || null === (r = e.data) || void 0 === r || !r.uri.toString().startsWith("https://matrix.to/#")) return this.transport.reply(e, {
												error: {
													message: "Invalid matrix.to URI"
												}
											});
											var i = function(t) {
												return console.error("[ClientWidgetApi] Failed to handle navigation: ", t), n.transport.reply(e, {
													error: {
														message: "Error handling navigation"
													}
												})
											};
											try {
												this.driver.navigate(e.data.uri.toString()).catch((function(e) {
													return i(e)
												})).then((function() {
													return n.transport.reply(e, {})
												}))
											} catch (o) {
												return i(o)
											}
										}
									}, {
										key: "handleOIDC",
										value: function(e) {
											var t = this,
												r = 1,
												n = function(n, i) {
													return i = i || {}, r > 1 ? t.transport.send(a.WidgetApiToWidgetAction.OpenIDCredentials, _({
														state: n,
														original_request_id: e.requestId
													}, i)) : t.transport.reply(e, _({
														state: n
													}, i))
												},
												i = function(i) {
													return console.error("[ClientWidgetApi] Failed to handle OIDC: ", i), r > 1 ? n(d.OpenIDRequestState.Blocked) : t.transport.reply(e, {
														error: {
															message: i
														}
													})
												},
												o = new h.SimpleObservable((function(e) {
													return e.state === d.OpenIDRequestState.PendingUserConfirmation && r > 1 ? (o.close(), i("client provided out-of-phase response to OIDC flow")) : e.state === d.OpenIDRequestState.PendingUserConfirmation ? (n(e.state), void r++) : e.state !== d.OpenIDRequestState.Allowed || e.token ? (e.state === d.OpenIDRequestState.Blocked && (e.token = null), o.close(), n(e.state, e.token)) : i("client provided invalid OIDC token for an allowed request")
												}));
											this.driver.askOpenID(o)
										}
									}, {
										key: "handleReadEvents",
										value: function(e) {
											var t = this;
											if (!e.data.type) return this.transport.reply(e, {
												error: {
													message: "Invalid request - missing event type"
												}
											});
											if (void 0 !== e.data.limit && (!e.data.limit || e.data.limit < 0)) return this.transport.reply(e, {
												error: {
													message: "Invalid request - limit out of range"
												}
											});
											var r = null;
											if (e.data.room_ids) {
												r = e.data.room_ids, Array.isArray(r) || (r = [r]);
												var n, i = m(r);
												try {
													for (i.s(); !(n = i.n()).done;) {
														var o = n.value;
														if (!this.canUseRoomTimeline(o)) return this.transport.reply(e, {
															error: {
																message: "Unable to access room timeline: ".concat(o)
															}
														})
													}
												} catch (l) {
													i.e(l)
												} finally {
													i.f()
												}
											}
											var s = e.data.limit || 0,
												a = Promise.resolve([]);
											if (void 0 !== e.data.state_key) {
												var c = !0 === e.data.state_key ? void 0 : e.data.state_key.toString();
												if (!this.canReceiveStateEvent(e.data.type, c)) return this.transport.reply(e, {
													error: {
														message: "Cannot read state events of this type"
													}
												});
												a = this.driver.readStateEvents(e.data.type, c, s, r)
											} else {
												if (!this.canReceiveRoomEvent(e.data.type, e.data.msgtype)) return this.transport.reply(e, {
													error: {
														message: "Cannot read room events of this type"
													}
												});
												a = this.driver.readRoomEvents(e.data.type, e.data.msgtype, s, r)
											}
											return a.then((function(r) {
												return t.transport.reply(e, {
													events: r
												})
											}))
										}
									}, {
										key: "handleSendEvent",
										value: function(e) {
											var t, r = this;
											if (!e.data.type) return this.transport.reply(e, {
												error: {
													message: "Invalid request - missing event type"
												}
											});
											if (e.data.room_id && !this.canUseRoomTimeline(e.data.room_id)) return this.transport.reply(e, {
												error: {
													message: "Unable to access room timeline: ".concat(e.data.room_id)
												}
											});
											if (null !== e.data.state_key && void 0 !== e.data.state_key) {
												if (!this.canSendStateEvent(e.data.type, e.data.state_key)) return this.transport.reply(e, {
													error: {
														message: "Cannot send state events of this type"
													}
												});
												t = this.driver.sendEvent(e.data.type, e.data.content || {}, e.data.state_key, e.data.room_id)
											} else {
												var n = e.data.content || {},
													i = n.msgtype;
												if (!this.canSendRoomEvent(e.data.type, i)) return this.transport.reply(e, {
													error: {
														message: "Cannot send room events of this type"
													}
												});
												t = this.driver.sendEvent(e.data.type, n, null, e.data.room_id)
											}
											t.then((function(t) {
												return r.transport.reply(e, {
													room_id: t.roomId,
													event_id: t.eventId
												})
											})).catch((function(t) {
												return console.error("error sending event: ", t), r.transport.reply(e, {
													error: {
														message: "Error sending event"
													}
												})
											}))
										}
									}, {
										key: "handleSendToDevice",
										value: (M = g(p().mark((function e(t) {
											return p().wrap((function(e) {
												for (;;) switch (e.prev = e.next) {
													case 0:
														if (t.data.type) {
															e.next = 5;
															break
														}
														return e.next = 3, this.transport.reply(t, {
															error: {
																message: "Invalid request - missing event type"
															}
														});
													case 3:
														e.next = 32;
														break;
													case 5:
														if (t.data.messages) {
															e.next = 10;
															break
														}
														return e.next = 8, this.transport.reply(t, {
															error: {
																message: "Invalid request - missing event contents"
															}
														});
													case 8:
														e.next = 32;
														break;
													case 10:
														if ("boolean" == typeof t.data.encrypted) {
															e.next = 15;
															break
														}
														return e.next = 13, this.transport.reply(t, {
															error: {
																message: "Invalid request - missing encryption flag"
															}
														});
													case 13:
														e.next = 32;
														break;
													case 15:
														if (this.canSendToDeviceEvent(t.data.type)) {
															e.next = 20;
															break
														}
														return e.next = 18, this.transport.reply(t, {
															error: {
																message: "Cannot send to-device events of this type"
															}
														});
													case 18:
														e.next = 32;
														break;
													case 20:
														return e.prev = 20, e.next = 23, this.driver.sendToDevice(t.data.type, t.data.encrypted, t.data.messages);
													case 23:
														return e.next = 25, this.transport.reply(t, {});
													case 25:
														e.next = 32;
														break;
													case 27:
														return e.prev = 27, e.t0 = e.catch(20), console.error("error sending to-device event", e.t0), e.next = 32, this.transport.reply(t, {
															error: {
																message: "Error sending event"
															}
														});
													case 32:
													case "end":
														return e.stop()
												}
											}), e, this, [
												[20, 27]
											])
										}))), function(e) {
											return M.apply(this, arguments)
										})
									}, {
										key: "pollTurnServers",
										value: (I = g(p().mark((function e(t, r) {
											var n, i, o, s, c, l;
											return p().wrap((function(e) {
												for (;;) switch (e.prev = e.next) {
													case 0:
														return e.prev = 0, e.next = 3, this.transport.send(a.WidgetApiToWidgetAction.UpdateTurnServers, r);
													case 3:
														n = !1, i = !1, e.prev = 5, s = C(t);
													case 7:
														return e.next = 9, s.next();
													case 9:
														if (!(n = !(c = e.sent).done)) {
															e.next = 16;
															break
														}
														return l = c.value, e.next = 13, this.transport.send(a.WidgetApiToWidgetAction.UpdateTurnServers, l);
													case 13:
														n = !1, e.next = 7;
														break;
													case 16:
														e.next = 22;
														break;
													case 18:
														e.prev = 18, e.t0 = e.catch(5), i = !0, o = e.t0;
													case 22:
														if (e.prev = 22, e.prev = 23, !n || null == s.return) {
															e.next = 27;
															break
														}
														return e.next = 27, s.return();
													case 27:
														if (e.prev = 27, !i) {
															e.next = 30;
															break
														}
														throw o;
													case 30:
														return e.finish(27);
													case 31:
														return e.finish(22);
													case 32:
														e.next = 37;
														break;
													case 34:
														e.prev = 34, e.t1 = e.catch(0), console.error("error polling for TURN servers", e.t1);
													case 37:
													case "end":
														return e.stop()
												}
											}), e, this, [
												[0, 34],
												[5, 18, 22, 32],
												[23, , 27, 31]
											])
										}))), function(e, t) {
											return I.apply(this, arguments)
										})
									}, {
										key: "handleWatchTurnServers",
										value: (k = g(p().mark((function e(t) {
											var r, n, i, o;
											return p().wrap((function(e) {
												for (;;) switch (e.prev = e.next) {
													case 0:
														if (this.hasCapability(c.MatrixCapabilities.MSC3846TurnServers)) {
															e.next = 5;
															break
														}
														return e.next = 3, this.transport.reply(t, {
															error: {
																message: "Missing capability"
															}
														});
													case 3:
														e.next = 30;
														break;
													case 5:
														if (!this.turnServers) {
															e.next = 10;
															break
														}
														return e.next = 8, this.transport.reply(t, {});
													case 8:
														e.next = 30;
														break;
													case 10:
														return e.prev = 10, r = this.driver.getTurnServers(), e.next = 14, r.next();
													case 14:
														if (n = e.sent, i = n.done, o = n.value, !i) {
															e.next = 19;
															break
														}
														throw new Error("Client refuses to provide any TURN servers");
													case 19:
														return e.next = 21, this.transport.reply(t, {});
													case 21:
														this.pollTurnServers(r, o), this.turnServers = r, e.next = 30;
														break;
													case 25:
														return e.prev = 25, e.t0 = e.catch(10), console.error("error getting first TURN server results", e.t0), e.next = 30, this.transport.reply(t, {
															error: {
																message: "TURN servers not available"
															}
														});
													case 30:
													case "end":
														return e.stop()
												}
											}), e, this, [
												[10, 25]
											])
										}))), function(e) {
											return k.apply(this, arguments)
										})
									}, {
										key: "handleUnwatchTurnServers",
										value: (b = g(p().mark((function e(t) {
											return p().wrap((function(e) {
												for (;;) switch (e.prev = e.next) {
													case 0:
														if (this.hasCapability(c.MatrixCapabilities.MSC3846TurnServers)) {
															e.next = 5;
															break
														}
														return e.next = 3, this.transport.reply(t, {
															error: {
																message: "Missing capability"
															}
														});
													case 3:
														e.next = 15;
														break;
													case 5:
														if (this.turnServers) {
															e.next = 10;
															break
														}
														return e.next = 8, this.transport.reply(t, {});
													case 8:
														e.next = 15;
														break;
													case 10:
														return e.next = 12, this.turnServers.return(void 0);
													case 12:
														return this.turnServers = null, e.next = 15, this.transport.reply(t, {});
													case 15:
													case "end":
														return e.stop()
												}
											}), e, this)
										}))), function(e) {
											return b.apply(this, arguments)
										})
									}, {
										key: "handleReadRelations",
										value: (y = g(p().mark((function e(t) {
											var r, n, i = this;
											return p().wrap((function(e) {
												for (;;) switch (e.prev = e.next) {
													case 0:
														if (t.data.event_id) {
															e.next = 2;
															break
														}
														return e.abrupt("return", this.transport.reply(t, {
															error: {
																message: "Invalid request - missing event ID"
															}
														}));
													case 2:
														if (!(void 0 !== t.data.limit && t.data.limit < 0)) {
															e.next = 4;
															break
														}
														return e.abrupt("return", this.transport.reply(t, {
															error: {
																message: "Invalid request - limit out of range"
															}
														}));
													case 4:
														if (void 0 === t.data.room_id || this.canUseRoomTimeline(t.data.room_id)) {
															e.next = 6;
															break
														}
														return e.abrupt("return", this.transport.reply(t, {
															error: {
																message: "Unable to access room timeline: ".concat(t.data.room_id)
															}
														}));
													case 6:
														return e.prev = 6, e.next = 9, this.driver.readEventRelations(t.data.event_id, t.data.room_id, t.data.rel_type, t.data.event_type, t.data.from, t.data.to, t.data.limit, t.data.direction);
													case 9:
														if (!(r = e.sent).originalEvent) {
															e.next = 18;
															break
														}
														if (void 0 === r.originalEvent.state_key) {
															e.next = 16;
															break
														}
														if (this.canReceiveStateEvent(r.originalEvent.type, r.originalEvent.state_key)) {
															e.next = 14;
															break
														}
														return e.abrupt("return", this.transport.reply(t, {
															error: {
																message: "Cannot read state events of this type"
															}
														}));
													case 14:
														e.next = 18;
														break;
													case 16:
														if (this.canReceiveRoomEvent(r.originalEvent.type, r.originalEvent.content.msgtype)) {
															e.next = 18;
															break
														}
														return e.abrupt("return", this.transport.reply(t, {
															error: {
																message: "Cannot read room events of this type"
															}
														}));
													case 18:
														return n = r.chunk.filter((function(e) {
															return void 0 !== e.state_key ? i.canReceiveStateEvent(e.type, e.state_key) : i.canReceiveRoomEvent(e.type, e.content.msgtype)
														})), e.abrupt("return", this.transport.reply(t, {
															original_event: r.originalEvent,
															chunk: n,
															prev_batch: r.prevBatch,
															next_batch: r.nextBatch
														}));
													case 22:
														return e.prev = 22, e.t0 = e.catch(6), console.error("error getting the relations", e.t0), e.next = 27, this.transport.reply(t, {
															error: {
																message: "Unexpected error while reading relations"
															}
														});
													case 27:
													case "end":
														return e.stop()
												}
											}), e, this, [
												[6, 22]
											])
										}))), function(e) {
											return y.apply(this, arguments)
										})
									}, {
										key: "handleMessage",
										value: function(e) {
											if (!this.isStopped) {
												var t = new CustomEvent("action:".concat(e.detail.action), {
													detail: e.detail,
													cancelable: !0
												});
												if (this.emit("action:".concat(e.detail.action), t), !t.defaultPrevented) switch (e.detail.action) {
													case a.WidgetApiFromWidgetAction.ContentLoaded:
														return this.handleContentLoadedAction(e.detail);
													case a.WidgetApiFromWidgetAction.SupportedApiVersions:
														return this.replyVersions(e.detail);
													case a.WidgetApiFromWidgetAction.SendEvent:
														return this.handleSendEvent(e.detail);
													case a.WidgetApiFromWidgetAction.SendToDevice:
														return this.handleSendToDevice(e.detail);
													case a.WidgetApiFromWidgetAction.GetOpenIDCredentials:
														return this.handleOIDC(e.detail);
													case a.WidgetApiFromWidgetAction.MSC2931Navigate:
														return this.handleNavigate(e.detail);
													case a.WidgetApiFromWidgetAction.MSC2974RenegotiateCapabilities:
														return this.handleCapabilitiesRenegotiate(e.detail);
													case a.WidgetApiFromWidgetAction.MSC2876ReadEvents:
														return this.handleReadEvents(e.detail);
													case a.WidgetApiFromWidgetAction.WatchTurnServers:
														return this.handleWatchTurnServers(e.detail);
													case a.WidgetApiFromWidgetAction.UnwatchTurnServers:
														return this.handleUnwatchTurnServers(e.detail);
													case a.WidgetApiFromWidgetAction.MSC3869ReadRelations:
														return this.handleReadRelations(e.detail);
													default:
														return this.transport.reply(e.detail, {
															error: {
																message: "Unknown or unsupported action: " + e.detail.action
															}
														})
												}
											}
										}
									}, {
										key: "takeScreenshot",
										value: function() {
											return this.transport.send(a.WidgetApiToWidgetAction.TakeScreenshot, {})
										}
									}, {
										key: "updateVisibility",
										value: function(e) {
											return this.transport.send(a.WidgetApiToWidgetAction.UpdateVisibility, {
												visible: e
											})
										}
									}, {
										key: "sendWidgetConfig",
										value: function(e) {
											return this.transport.send(a.WidgetApiToWidgetAction.WidgetConfig, e).then()
										}
									}, {
										key: "notifyModalWidgetButtonClicked",
										value: function(e) {
											return this.transport.send(a.WidgetApiToWidgetAction.ButtonClicked, {
												id: e
											}).then()
										}
									}, {
										key: "notifyModalWidgetClose",
										value: function(e) {
											return this.transport.send(a.WidgetApiToWidgetAction.CloseModalWidget, e).then()
										}
									}, {
										key: "feedEvent",
										value: (v = g(p().mark((function e(t, r) {
											var n;
											return p().wrap((function(e) {
												for (;;) switch (e.prev = e.next) {
													case 0:
														if (t.room_id === r || this.canUseRoomTimeline(t.room_id)) {
															e.next = 2;
															break
														}
														return e.abrupt("return");
													case 2:
														if (void 0 === t.state_key || null === t.state_key) {
															e.next = 7;
															break
														}
														if (this.canReceiveStateEvent(t.type, t.state_key)) {
															e.next = 5;
															break
														}
														return e.abrupt("return");
													case 5:
														e.next = 9;
														break;
													case 7:
														if (this.canReceiveRoomEvent(t.type, null === (n = t.content) || void 0 === n ? void 0 : n.msgtype)) {
															e.next = 9;
															break
														}
														return e.abrupt("return");
													case 9:
														return e.next = 11, this.transport.send(a.WidgetApiToWidgetAction.SendEvent, t);
													case 11:
													case "end":
														return e.stop()
												}
											}), e, this)
										}))), function(e, t) {
											return v.apply(this, arguments)
										})
									}, {
										key: "feedToDevice",
										value: (i = g(p().mark((function e(t, r) {
											return p().wrap((function(e) {
												for (;;) switch (e.prev = e.next) {
													case 0:
														if (!this.canReceiveToDeviceEvent(t.type)) {
															e.next = 3;
															break
														}
														return e.next = 3, this.transport.send(a.WidgetApiToWidgetAction.SendToDevice, _(_({}, t), {}, {
															encrypted: r
														}));
													case 3:
													case "end":
														return e.stop()
												}
											}), e, this)
										}))), function(e, t) {
											return i.apply(this, arguments)
										})
									}]) && w(t.prototype, r), n && w(t, n), Object.defineProperty(t, "prototype", {
										writable: !1
									}), O
								}(i.EventEmitter);
								r.ClientWidgetApi = x
							}, {
								"./Symbols": 176,
								"./interfaces/ApiVersion": 180,
								"./interfaces/Capabilities": 181,
								"./interfaces/GetOpenIDAction": 184,
								"./interfaces/WidgetApiAction": 208,
								"./interfaces/WidgetApiDirection": 209,
								"./models/WidgetEventCapability": 214,
								"./transport/PostmessageTransport": 220,
								"./util/SimpleObservable": 221,
								events: 106
							}],
							176: [function(e, t, r) {
								"use strict";
								var n;
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.Symbols = void 0, r.Symbols = n,
									function(e) {
										e.AnyRoom = "*"
									}(n || (r.Symbols = n = {}))
							}, {}],
							177: [function(e, t, r) {
								"use strict";

								function n(e) {
									return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
										return typeof e
									} : function(e) {
										return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
									})(e)
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.WidgetApi = void 0;
								var i = e("events"),
									o = e("./interfaces/WidgetApiDirection"),
									s = e("./interfaces/ApiVersion"),
									a = e("./transport/PostmessageTransport"),
									c = e("./interfaces/WidgetApiAction"),
									l = e("./interfaces/GetOpenIDAction"),
									u = e("./interfaces/WidgetType"),
									d = e("./interfaces/ModalWidgetActions"),
									h = e("./models/WidgetEventCapability"),
									f = e("./Symbols");

								function p() {
									p = function() {
										return e
									};
									var e = {},
										t = Object.prototype,
										r = t.hasOwnProperty,
										i = "function" == typeof Symbol ? Symbol : {},
										o = i.iterator || "@@iterator",
										s = i.asyncIterator || "@@asyncIterator",
										a = i.toStringTag || "@@toStringTag";

									function c(e, t, r) {
										return Object.defineProperty(e, t, {
											value: r,
											enumerable: !0,
											configurable: !0,
											writable: !0
										}), e[t]
									}
									try {
										c({}, "")
									} catch (C) {
										c = function(e, t, r) {
											return e[t] = r
										}
									}

									function l(e, t, r, n) {
										var i = t && t.prototype instanceof h ? t : h,
											o = Object.create(i.prototype),
											s = new T(n || []);
										return o._invoke = function(e, t, r) {
											var n = "suspendedStart";
											return function(i, o) {
												if ("executing" === n) throw new Error("Generator is already running");
												if ("completed" === n) {
													if ("throw" === i) throw o;
													return R()
												}
												for (r.method = i, r.arg = o;;) {
													var s = r.delegate;
													if (s) {
														var a = S(s, r);
														if (a) {
															if (a === d) continue;
															return a
														}
													}
													if ("next" === r.method) r.sent = r._sent = r.arg;
													else if ("throw" === r.method) {
														if ("suspendedStart" === n) throw n = "completed", r.arg;
														r.dispatchException(r.arg)
													} else "return" === r.method && r.abrupt("return", r.arg);
													n = "executing";
													var c = u(e, t, r);
													if ("normal" === c.type) {
														if (n = r.done ? "completed" : "suspendedYield", c.arg === d) continue;
														return {
															value: c.arg,
															done: r.done
														}
													}
													"throw" === c.type && (n = "completed", r.method = "throw", r.arg = c.arg)
												}
											}
										}(e, r, s), o
									}

									function u(e, t, r) {
										try {
											return {
												type: "normal",
												arg: e.call(t, r)
											}
										} catch (C) {
											return {
												type: "throw",
												arg: C
											}
										}
									}
									e.wrap = l;
									var d = {};

									function h() {}

									function f() {}

									function v() {}
									var g = {};
									c(g, o, (function() {
										return this
									}));
									var m = Object.getPrototypeOf,
										y = m && m(m(I([])));
									y && y !== t && r.call(y, o) && (g = y);
									var b = v.prototype = h.prototype = Object.create(g);

									function _(e) {
										["next", "throw", "return"].forEach((function(t) {
											c(e, t, (function(e) {
												return this._invoke(t, e)
											}))
										}))
									}

									function w(e, t) {
										var i;
										this._invoke = function(o, s) {
											function a() {
												return new t((function(i, a) {
													! function i(o, s, a, c) {
														var l = u(e[o], e, s);
														if ("throw" !== l.type) {
															var d = l.arg,
																h = d.value;
															return h && "object" == n(h) && r.call(h, "__await") ? t.resolve(h.__await).then((function(e) {
																i("next", e, a, c)
															}), (function(e) {
																i("throw", e, a, c)
															})) : t.resolve(h).then((function(e) {
																d.value = e, a(d)
															}), (function(e) {
																return i("throw", e, a, c)
															}))
														}
														c(l.arg)
													}(o, s, i, a)
												}))
											}
											return i = i ? i.then(a, a) : a()
										}
									}

									function S(e, t) {
										var r = e.iterator[t.method];
										if (void 0 === r) {
											if (t.delegate = null, "throw" === t.method) {
												if (e.iterator.return && (t.method = "return", t.arg = void 0, S(e, t), "throw" === t.method)) return d;
												t.method = "throw", t.arg = new TypeError("The iterator does not provide a 'throw' method")
											}
											return d
										}
										var n = u(r, e.iterator, t.arg);
										if ("throw" === n.type) return t.method = "throw", t.arg = n.arg, t.delegate = null, d;
										var i = n.arg;
										return i ? i.done ? (t[e.resultName] = i.value, t.next = e.nextLoc, "return" !== t.method && (t.method = "next", t.arg = void 0), t.delegate = null, d) : i : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, d)
									}

									function E(e) {
										var t = {
											tryLoc: e[0]
										};
										1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
									}

									function k(e) {
										var t = e.completion || {};
										t.type = "normal", delete t.arg, e.completion = t
									}

									function T(e) {
										this.tryEntries = [{
											tryLoc: "root"
										}], e.forEach(E, this), this.reset(!0)
									}

									function I(e) {
										if (e) {
											var t = e[o];
											if (t) return t.call(e);
											if ("function" == typeof e.next) return e;
											if (!isNaN(e.length)) {
												var n = -1,
													i = function t() {
														for (; ++n < e.length;)
															if (r.call(e, n)) return t.value = e[n], t.done = !1, t;
														return t.value = void 0, t.done = !0, t
													};
												return i.next = i
											}
										}
										return {
											next: R
										}
									}

									function R() {
										return {
											value: void 0,
											done: !0
										}
									}
									return f.prototype = v, c(b, "constructor", v), c(v, "constructor", f), f.displayName = c(v, a, "GeneratorFunction"), e.isGeneratorFunction = function(e) {
										var t = "function" == typeof e && e.constructor;
										return !!t && (t === f || "GeneratorFunction" === (t.displayName || t.name))
									}, e.mark = function(e) {
										return Object.setPrototypeOf ? Object.setPrototypeOf(e, v) : (e.__proto__ = v, c(e, a, "GeneratorFunction")), e.prototype = Object.create(b), e
									}, e.awrap = function(e) {
										return {
											__await: e
										}
									}, _(w.prototype), c(w.prototype, s, (function() {
										return this
									})), e.AsyncIterator = w, e.async = function(t, r, n, i, o) {
										void 0 === o && (o = Promise);
										var s = new w(l(t, r, n, i), o);
										return e.isGeneratorFunction(r) ? s : s.next().then((function(e) {
											return e.done ? e.value : s.next()
										}))
									}, _(b), c(b, a, "Generator"), c(b, o, (function() {
										return this
									})), c(b, "toString", (function() {
										return "[object Generator]"
									})), e.keys = function(e) {
										var t = [];
										for (var r in e) t.push(r);
										return t.reverse(),
											function r() {
												for (; t.length;) {
													var n = t.pop();
													if (n in e) return r.value = n, r.done = !1, r
												}
												return r.done = !0, r
											}
									}, e.values = I, T.prototype = {
										constructor: T,
										reset: function(e) {
											if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(k), !e)
												for (var t in this) "t" === t.charAt(0) && r.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0)
										},
										stop: function() {
											this.done = !0;
											var e = this.tryEntries[0].completion;
											if ("throw" === e.type) throw e.arg;
											return this.rval
										},
										dispatchException: function(e) {
											if (this.done) throw e;
											var t = this;

											function n(r, n) {
												return s.type = "throw", s.arg = e, t.next = r, n && (t.method = "next", t.arg = void 0), !!n
											}
											for (var i = this.tryEntries.length - 1; i >= 0; --i) {
												var o = this.tryEntries[i],
													s = o.completion;
												if ("root" === o.tryLoc) return n("end");
												if (o.tryLoc <= this.prev) {
													var a = r.call(o, "catchLoc"),
														c = r.call(o, "finallyLoc");
													if (a && c) {
														if (this.prev < o.catchLoc) return n(o.catchLoc, !0);
														if (this.prev < o.finallyLoc) return n(o.finallyLoc)
													} else if (a) {
														if (this.prev < o.catchLoc) return n(o.catchLoc, !0)
													} else {
														if (!c) throw new Error("try statement without catch or finally");
														if (this.prev < o.finallyLoc) return n(o.finallyLoc)
													}
												}
											}
										},
										abrupt: function(e, t) {
											for (var n = this.tryEntries.length - 1; n >= 0; --n) {
												var i = this.tryEntries[n];
												if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
													var o = i;
													break
												}
											}
											o && ("break" === e || "continue" === e) && o.tryLoc <= t && t <= o.finallyLoc && (o = null);
											var s = o ? o.completion : {};
											return s.type = e, s.arg = t, o ? (this.method = "next", this.next = o.finallyLoc, d) : this.complete(s)
										},
										complete: function(e, t) {
											if ("throw" === e.type) throw e.arg;
											return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), d
										},
										finish: function(e) {
											for (var t = this.tryEntries.length - 1; t >= 0; --t) {
												var r = this.tryEntries[t];
												if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), k(r), d
											}
										},
										catch: function(e) {
											for (var t = this.tryEntries.length - 1; t >= 0; --t) {
												var r = this.tryEntries[t];
												if (r.tryLoc === e) {
													var n = r.completion;
													if ("throw" === n.type) {
														var i = n.arg;
														k(r)
													}
													return i
												}
											}
											throw new Error("illegal catch attempt")
										},
										delegateYield: function(e, t, r) {
											return this.delegate = {
												iterator: I(e),
												resultName: t,
												nextLoc: r
											}, "next" === this.method && (this.arg = void 0), d
										}
									}, e
								}

								function v(e, t, r, n, i, o, s) {
									try {
										var a = e[o](s),
											c = a.value
									} catch (l) {
										return void r(l)
									}
									a.done ? t(c) : Promise.resolve(c).then(n, i)
								}

								function g(e) {
									return function() {
										var t = this,
											r = arguments;
										return new Promise((function(n, i) {
											var o = e.apply(t, r);

											function s(e) {
												v(o, n, i, s, a, "next", e)
											}

											function a(e) {
												v(o, n, i, s, a, "throw", e)
											}
											s(void 0)
										}))
									}
								}

								function m(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function y(e, t) {
									return (y = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
										return e.__proto__ = t, e
									})(e, t)
								}

								function b(e) {
									var t = function() {
										if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
										if (Reflect.construct.sham) return !1;
										if ("function" == typeof Proxy) return !0;
										try {
											return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
										} catch (e) {
											return !1
										}
									}();
									return function() {
										var r, n = S(e);
										if (t) {
											var i = S(this).constructor;
											r = Reflect.construct(n, arguments, i)
										} else r = n.apply(this, arguments);
										return _(this, r)
									}
								}

								function _(e, t) {
									if (t && ("object" === n(t) || "function" == typeof t)) return t;
									if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
									return w(e)
								}

								function w(e) {
									if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
									return e
								}

								function S(e) {
									return (S = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
										return e.__proto__ || Object.getPrototypeOf(e)
									})(e)
								}

								function E(e, t, r) {
									return t in e ? Object.defineProperty(e, t, {
										value: r,
										enumerable: !0,
										configurable: !0,
										writable: !0
									}) : e[t] = r, e
								}

								function k(e) {
									return new I(e)
								}

								function T(e) {
									var t, r;

									function n(t, r) {
										try {
											var o = e[t](r),
												s = o.value,
												a = s instanceof I;
											Promise.resolve(a ? s.wrapped : s).then((function(e) {
												a ? n("return" === t ? "return" : "next", e) : i(o.done ? "return" : "normal", e)
											}), (function(e) {
												n("throw", e)
											}))
										} catch (c) {
											i("throw", c)
										}
									}

									function i(e, i) {
										switch (e) {
											case "return":
												t.resolve({
													value: i,
													done: !0
												});
												break;
											case "throw":
												t.reject(i);
												break;
											default:
												t.resolve({
													value: i,
													done: !1
												})
										}(t = t.next) ? n(t.key, t.arg): r = null
									}
									this._invoke = function(e, i) {
										return new Promise((function(o, s) {
											var a = {
												key: e,
												arg: i,
												resolve: o,
												reject: s,
												next: null
											};
											r ? r = r.next = a : (t = r = a, n(e, i))
										}))
									}, "function" != typeof e.return && (this.return = void 0)
								}

								function I(e) {
									this.wrapped = e
								}
								T.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
									return this
								}, T.prototype.next = function(e) {
									return this._invoke("next", e)
								}, T.prototype.throw = function(e) {
									return this._invoke("throw", e)
								}, T.prototype.return = function(e) {
									return this._invoke("return", e)
								};
								var R = function(e) {
									! function(e, t) {
										if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
										e.prototype = Object.create(t && t.prototype, {
											constructor: {
												value: e,
												writable: !0,
												configurable: !0
											}
										}), Object.defineProperty(e, "prototype", {
											writable: !1
										}), t && y(e, t)
									}(_, e);
									var t, r, n, i, v = b(_);

									function _() {
										var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
											r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
										if (function(e, t) {
												if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
											}(this, _), (e = v.call(this)).clientOrigin = r, E(w(e), "transport", void 0), E(w(e), "capabilitiesFinished", !1), E(w(e), "supportsMSC2974Renegotiate", !1), E(w(e), "requestedCapabilities", []), E(w(e), "approvedCapabilities", void 0), E(w(e), "cachedClientVersions", void 0), E(w(e), "turnServerWatchers", 0), !window.parent) throw new Error("No parent window. This widget doesn't appear to be embedded properly.");
										return e.transport = new a.PostmessageTransport(o.WidgetApiDirection.FromWidget, t, window.parent, window), e.transport.targetOrigin = r, e.transport.on("message", e.handleMessage.bind(w(e))), e
									}
									return t = _, (r = [{
										key: "hasCapability",
										value: function(e) {
											return Array.isArray(this.approvedCapabilities) ? this.approvedCapabilities.includes(e) : this.requestedCapabilities.includes(e)
										}
									}, {
										key: "requestCapability",
										value: function(e) {
											if (this.capabilitiesFinished && !this.supportsMSC2974Renegotiate) throw new Error("Capabilities have already been negotiated");
											this.requestedCapabilities.push(e)
										}
									}, {
										key: "requestCapabilities",
										value: function(e) {
											var t = this;
											e.forEach((function(e) {
												return t.requestCapability(e)
											}))
										}
									}, {
										key: "requestCapabilityForRoomTimeline",
										value: function(e) {
											this.requestCapability("org.matrix.msc2762.timeline:".concat(e))
										}
									}, {
										key: "requestCapabilityToSendState",
										value: function(e, t) {
											this.requestCapability(h.WidgetEventCapability.forStateEvent(h.EventDirection.Send, e, t).raw)
										}
									}, {
										key: "requestCapabilityToReceiveState",
										value: function(e, t) {
											this.requestCapability(h.WidgetEventCapability.forStateEvent(h.EventDirection.Receive, e, t).raw)
										}
									}, {
										key: "requestCapabilityToSendToDevice",
										value: function(e) {
											this.requestCapability(h.WidgetEventCapability.forToDeviceEvent(h.EventDirection.Send, e).raw)
										}
									}, {
										key: "requestCapabilityToReceiveToDevice",
										value: function(e) {
											this.requestCapability(h.WidgetEventCapability.forToDeviceEvent(h.EventDirection.Receive, e).raw)
										}
									}, {
										key: "requestCapabilityToSendEvent",
										value: function(e) {
											this.requestCapability(h.WidgetEventCapability.forRoomEvent(h.EventDirection.Send, e).raw)
										}
									}, {
										key: "requestCapabilityToReceiveEvent",
										value: function(e) {
											this.requestCapability(h.WidgetEventCapability.forRoomEvent(h.EventDirection.Receive, e).raw)
										}
									}, {
										key: "requestCapabilityToSendMessage",
										value: function(e) {
											this.requestCapability(h.WidgetEventCapability.forRoomMessageEvent(h.EventDirection.Send, e).raw)
										}
									}, {
										key: "requestCapabilityToReceiveMessage",
										value: function(e) {
											this.requestCapability(h.WidgetEventCapability.forRoomMessageEvent(h.EventDirection.Receive, e).raw)
										}
									}, {
										key: "requestOpenIDConnectToken",
										value: function() {
											var e = this;
											return new Promise((function(t, r) {
												e.transport.sendComplete(c.WidgetApiFromWidgetAction.GetOpenIDCredentials, {}).then((function(n) {
													var i = n.response;
													i.state === l.OpenIDRequestState.Allowed ? t(i) : i.state === l.OpenIDRequestState.Blocked ? r(new Error("User declined to verify their identity")) : i.state === l.OpenIDRequestState.PendingUserConfirmation ? e.on("action:".concat(c.WidgetApiToWidgetAction.OpenIDCredentials), (function o(s) {
														s.preventDefault();
														var a = s.detail;
														a.data.original_request_id === n.requestId && (a.data.state === l.OpenIDRequestState.Allowed ? (t(a.data), e.transport.reply(a, {})) : a.data.state === l.OpenIDRequestState.Blocked ? (r(new Error("User declined to verify their identity")), e.transport.reply(a, {})) : (r(new Error("Invalid state on reply: " + i.state)), e.transport.reply(a, {
															error: {
																message: "Invalid state"
															}
														})), e.off("action:".concat(c.WidgetApiToWidgetAction.OpenIDCredentials), o))
													})) : r(new Error("Invalid state: " + i.state))
												})).catch(r)
											}))
										}
									}, {
										key: "updateRequestedCapabilities",
										value: function() {
											return this.transport.send(c.WidgetApiFromWidgetAction.MSC2974RenegotiateCapabilities, {
												capabilities: this.requestedCapabilities
											}).then()
										}
									}, {
										key: "sendContentLoaded",
										value: function() {
											return this.transport.send(c.WidgetApiFromWidgetAction.ContentLoaded, {}).then()
										}
									}, {
										key: "sendSticker",
										value: function(e) {
											return this.transport.send(c.WidgetApiFromWidgetAction.SendSticker, e).then()
										}
									}, {
										key: "setAlwaysOnScreen",
										value: function(e) {
											return this.transport.send(c.WidgetApiFromWidgetAction.UpdateAlwaysOnScreen, {
												value: e
											}).then((function(e) {
												return e.success
											}))
										}
									}, {
										key: "openModalWidget",
										value: function(e, t) {
											var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [],
												n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
												i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : u.MatrixWidgetType.Custom;
											return this.transport.send(c.WidgetApiFromWidgetAction.OpenModalWidget, {
												type: i,
												url: e,
												name: t,
												buttons: r,
												data: n
											}).then()
										}
									}, {
										key: "closeModalWidget",
										value: function() {
											var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
											return this.transport.send(c.WidgetApiFromWidgetAction.CloseModalWidget, e).then()
										}
									}, {
										key: "sendRoomEvent",
										value: function(e, t, r) {
											return this.transport.send(c.WidgetApiFromWidgetAction.SendEvent, {
												type: e,
												content: t,
												room_id: r
											})
										}
									}, {
										key: "sendStateEvent",
										value: function(e, t, r, n) {
											return this.transport.send(c.WidgetApiFromWidgetAction.SendEvent, {
												type: e,
												content: r,
												state_key: t,
												room_id: n
											})
										}
									}, {
										key: "sendToDevice",
										value: function(e, t, r) {
											return this.transport.send(c.WidgetApiFromWidgetAction.SendToDevice, {
												type: e,
												encrypted: t,
												messages: r
											})
										}
									}, {
										key: "readRoomEvents",
										value: function(e, t, r, n) {
											var i = {
												type: e,
												msgtype: r
											};
											return void 0 !== t && (i.limit = t), n && (n.includes(f.Symbols.AnyRoom) ? i.room_ids = f.Symbols.AnyRoom : i.room_ids = n), this.transport.send(c.WidgetApiFromWidgetAction.MSC2876ReadEvents, i).then((function(e) {
												return e.events
											}))
										}
									}, {
										key: "readEventRelations",
										value: (i = g(p().mark((function e(t, r, n, i, o, a, l, u) {
											var d;
											return p().wrap((function(e) {
												for (;;) switch (e.prev = e.next) {
													case 0:
														return e.next = 2, this.getClientVersions();
													case 2:
														if (e.sent.includes(s.UnstableApiVersion.MSC3869)) {
															e.next = 5;
															break
														}
														throw new Error("The read_relations action is not supported by the client.");
													case 5:
														return d = {
															event_id: t,
															rel_type: n,
															event_type: i,
															room_id: r,
															to: l,
															from: a,
															limit: o,
															direction: u
														}, e.abrupt("return", this.transport.send(c.WidgetApiFromWidgetAction.MSC3869ReadRelations, d));
													case 7:
													case "end":
														return e.stop()
												}
											}), e, this)
										}))), function(e, t, r, n, o, s, a, c) {
											return i.apply(this, arguments)
										})
									}, {
										key: "readStateEvents",
										value: function(e, t, r, n) {
											var i = {
												type: e,
												state_key: void 0 === r || r
											};
											return void 0 !== t && (i.limit = t), n && (n.includes(f.Symbols.AnyRoom) ? i.room_ids = f.Symbols.AnyRoom : i.room_ids = n), this.transport.send(c.WidgetApiFromWidgetAction.MSC2876ReadEvents, i).then((function(e) {
												return e.events
											}))
										}
									}, {
										key: "setModalButtonEnabled",
										value: function(e, t) {
											if (e === d.BuiltInModalButtonID.Close) throw new Error("The close button cannot be disabled");
											return this.transport.send(c.WidgetApiFromWidgetAction.SetModalButtonEnabled, {
												button: e,
												enabled: t
											}).then()
										}
									}, {
										key: "navigateTo",
										value: function(e) {
											if (!e || !e.startsWith("https://matrix.to/#")) throw new Error("Invalid matrix.to URI");
											return this.transport.send(c.WidgetApiFromWidgetAction.MSC2931Navigate, {
												uri: e
											}).then()
										}
									}, {
										key: "getTurnServers",
										value: function() {
											var e, t = this;
											return (e = p().mark((function e() {
												var r, n;
												return p().wrap((function(e) {
													for (;;) switch (e.prev = e.next) {
														case 0:
															if (n = function() {
																	var e = g(p().mark((function e(n) {
																		return p().wrap((function(e) {
																			for (;;) switch (e.prev = e.next) {
																				case 0:
																					return n.preventDefault(), r(n.detail.data), e.next = 4, t.transport.reply(n.detail, {});
																				case 4:
																				case "end":
																					return e.stop()
																			}
																		}), e)
																	})));
																	return function(t) {
																		return e.apply(this, arguments)
																	}
																}(), t.on("action:".concat(c.WidgetApiToWidgetAction.UpdateTurnServers), n), 0 !== t.turnServerWatchers) {
																e.next = 12;
																break
															}
															return e.prev = 3, e.next = 6, k(t.transport.send(c.WidgetApiFromWidgetAction.WatchTurnServers, {}));
														case 6:
															e.next = 12;
															break;
														case 8:
															throw e.prev = 8, e.t0 = e.catch(3), t.off("action:".concat(c.WidgetApiToWidgetAction.UpdateTurnServers), n), e.t0;
														case 12:
															t.turnServerWatchers++, e.prev = 13;
														case 14:
															return e.next = 17, k(new Promise((function(e) {
																return r = e
															})));
														case 17:
															return e.next = 19, e.sent;
														case 19:
															e.next = 14;
															break;
														case 21:
															if (e.prev = 21, t.off("action:".concat(c.WidgetApiToWidgetAction.UpdateTurnServers), n), t.turnServerWatchers--, 0 !== t.turnServerWatchers) {
																e.next = 27;
																break
															}
															return e.next = 27, k(t.transport.send(c.WidgetApiFromWidgetAction.UnwatchTurnServers, {}));
														case 27:
															return e.finish(21);
														case 28:
														case "end":
															return e.stop()
													}
												}), e, null, [
													[3, 8],
													[13, , 21, 28]
												])
											})), function() {
												return new T(e.apply(this, arguments))
											})()
										}
									}, {
										key: "start",
										value: function() {
											var e = this;
											this.transport.start(), this.getClientVersions().then((function(t) {
												t.includes(s.UnstableApiVersion.MSC2974) && (e.supportsMSC2974Renegotiate = !0)
											}))
										}
									}, {
										key: "handleMessage",
										value: function(e) {
											var t = new CustomEvent("action:".concat(e.detail.action), {
												detail: e.detail,
												cancelable: !0
											});
											if (this.emit("action:".concat(e.detail.action), t), !t.defaultPrevented) switch (e.detail.action) {
												case c.WidgetApiToWidgetAction.SupportedApiVersions:
													return this.replyVersions(e.detail);
												case c.WidgetApiToWidgetAction.Capabilities:
													return this.handleCapabilities(e.detail);
												case c.WidgetApiToWidgetAction.UpdateVisibility:
												case c.WidgetApiToWidgetAction.NotifyCapabilities:
													return this.transport.reply(e.detail, {});
												default:
													return this.transport.reply(e.detail, {
														error: {
															message: "Unknown or unsupported action: " + e.detail.action
														}
													})
											}
										}
									}, {
										key: "replyVersions",
										value: function(e) {
											this.transport.reply(e, {
												supported_versions: s.CurrentApiVersions
											})
										}
									}, {
										key: "getClientVersions",
										value: function() {
											var e = this;
											return Array.isArray(this.cachedClientVersions) ? Promise.resolve(this.cachedClientVersions) : this.transport.send(c.WidgetApiFromWidgetAction.SupportedApiVersions, {}).then((function(t) {
												return e.cachedClientVersions = t.supported_versions, t.supported_versions
											})).catch((function(e) {
												return console.warn("non-fatal error getting supported client versions: ", e), []
											}))
										}
									}, {
										key: "handleCapabilities",
										value: function(e) {
											var t = this;
											return this.capabilitiesFinished ? this.transport.reply(e, {
												error: {
													message: "Capability negotiation already completed"
												}
											}) : this.getClientVersions().then((function(r) {
												return r.includes(s.UnstableApiVersion.MSC2871) ? t.once("action:".concat(c.WidgetApiToWidgetAction.NotifyCapabilities), (function(e) {
													t.approvedCapabilities = e.detail.data.approved, t.emit("ready")
												})) : t.emit("ready"), t.capabilitiesFinished = !0, t.transport.reply(e, {
													capabilities: t.requestedCapabilities
												})
											}))
										}
									}]) && m(t.prototype, r), n && m(t, n), Object.defineProperty(t, "prototype", {
										writable: !1
									}), _
								}(i.EventEmitter);
								r.WidgetApi = R
							}, {
								"./Symbols": 176,
								"./interfaces/ApiVersion": 180,
								"./interfaces/GetOpenIDAction": 184,
								"./interfaces/ModalWidgetActions": 194,
								"./interfaces/WidgetApiAction": 208,
								"./interfaces/WidgetApiDirection": 209,
								"./interfaces/WidgetType": 212,
								"./models/WidgetEventCapability": 214,
								"./transport/PostmessageTransport": 220,
								events: 106
							}],
							178: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.WidgetDriver = void 0;
								var n = e("..");

								function i(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								var o = function() {
									function e() {
										! function(e, t) {
											if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
										}(this, e)
									}
									var t, r, o;
									return t = e, (r = [{
										key: "validateCapabilities",
										value: function(e) {
											return Promise.resolve(new Set)
										}
									}, {
										key: "sendEvent",
										value: function(e, t) {
											return arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], Promise.reject(new Error("Failed to override function"))
										}
									}, {
										key: "sendToDevice",
										value: function(e, t, r) {
											return Promise.reject(new Error("Failed to override function"))
										}
									}, {
										key: "readRoomEvents",
										value: function(e, t, r) {
											return arguments.length > 3 && void 0 !== arguments[3] && arguments[3], Promise.resolve([])
										}
									}, {
										key: "readStateEvents",
										value: function(e, t, r) {
											return arguments.length > 3 && void 0 !== arguments[3] && arguments[3], Promise.resolve([])
										}
									}, {
										key: "readEventRelations",
										value: function(e, t, r, n, i, o, s, a) {
											return Promise.resolve({
												chunk: []
											})
										}
									}, {
										key: "askOpenID",
										value: function(e) {
											e.update({
												state: n.OpenIDRequestState.Blocked
											})
										}
									}, {
										key: "navigate",
										value: function(e) {
											throw new Error("Navigation is not implemented")
										}
									}, {
										key: "getTurnServers",
										value: function() {
											throw new Error("TURN server support is not implemented")
										}
									}]) && i(t.prototype, r), o && i(t, o), Object.defineProperty(t, "prototype", {
										writable: !1
									}), e
								}();
								r.WidgetDriver = o
							}, {
								"..": 179
							}],
							179: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								});
								var n = e("./WidgetApi");
								Object.keys(n).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === n[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return n[e]
										}
									}))
								}));
								var i = e("./ClientWidgetApi");
								Object.keys(i).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === i[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return i[e]
										}
									}))
								}));
								var o = e("./Symbols");
								Object.keys(o).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === o[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return o[e]
										}
									}))
								}));
								var s = e("./transport/ITransport");
								Object.keys(s).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === s[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return s[e]
										}
									}))
								}));
								var a = e("./transport/PostmessageTransport");
								Object.keys(a).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === a[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return a[e]
										}
									}))
								}));
								var c = e("./interfaces/ICustomWidgetData");
								Object.keys(c).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === c[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return c[e]
										}
									}))
								}));
								var l = e("./interfaces/IJitsiWidgetData");
								Object.keys(l).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === l[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return l[e]
										}
									}))
								}));
								var u = e("./interfaces/IStickerpickerWidgetData");
								Object.keys(u).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === u[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return u[e]
										}
									}))
								}));
								var d = e("./interfaces/IWidget");
								Object.keys(d).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === d[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return d[e]
										}
									}))
								}));
								var h = e("./interfaces/WidgetType");
								Object.keys(h).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === h[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return h[e]
										}
									}))
								}));
								var f = e("./interfaces/IWidgetApiErrorResponse");
								Object.keys(f).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === f[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return f[e]
										}
									}))
								}));
								var p = e("./interfaces/IWidgetApiRequest");
								Object.keys(p).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === p[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return p[e]
										}
									}))
								}));
								var v = e("./interfaces/IWidgetApiResponse");
								Object.keys(v).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === v[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return v[e]
										}
									}))
								}));
								var g = e("./interfaces/WidgetApiAction");
								Object.keys(g).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === g[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return g[e]
										}
									}))
								}));
								var m = e("./interfaces/WidgetApiDirection");
								Object.keys(m).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === m[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return m[e]
										}
									}))
								}));
								var y = e("./interfaces/ApiVersion");
								Object.keys(y).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === y[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return y[e]
										}
									}))
								}));
								var b = e("./interfaces/Capabilities");
								Object.keys(b).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === b[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return b[e]
										}
									}))
								}));
								var _ = e("./interfaces/CapabilitiesAction");
								Object.keys(_).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === _[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return _[e]
										}
									}))
								}));
								var w = e("./interfaces/ContentLoadedAction");
								Object.keys(w).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === w[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return w[e]
										}
									}))
								}));
								var S = e("./interfaces/ScreenshotAction");
								Object.keys(S).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === S[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return S[e]
										}
									}))
								}));
								var E = e("./interfaces/StickerAction");
								Object.keys(E).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === E[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return E[e]
										}
									}))
								}));
								var k = e("./interfaces/StickyAction");
								Object.keys(k).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === k[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return k[e]
										}
									}))
								}));
								var T = e("./interfaces/SupportedVersionsAction");
								Object.keys(T).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === T[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return T[e]
										}
									}))
								}));
								var I = e("./interfaces/VisibilityAction");
								Object.keys(I).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === I[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return I[e]
										}
									}))
								}));
								var R = e("./interfaces/GetOpenIDAction");
								Object.keys(R).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === R[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return R[e]
										}
									}))
								}));
								var C = e("./interfaces/OpenIDCredentialsAction");
								Object.keys(C).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === C[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return C[e]
										}
									}))
								}));
								var M = e("./interfaces/WidgetKind");
								Object.keys(M).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === M[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return M[e]
										}
									}))
								}));
								var x = e("./interfaces/ModalButtonKind");
								Object.keys(x).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === x[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return x[e]
										}
									}))
								}));
								var O = e("./interfaces/ModalWidgetActions");
								Object.keys(O).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === O[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return O[e]
										}
									}))
								}));
								var A = e("./interfaces/SetModalButtonEnabledAction");
								Object.keys(A).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === A[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return A[e]
										}
									}))
								}));
								var P = e("./interfaces/WidgetConfigAction");
								Object.keys(P).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === P[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return P[e]
										}
									}))
								}));
								var D = e("./interfaces/SendEventAction");
								Object.keys(D).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === D[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return D[e]
										}
									}))
								}));
								var j = e("./interfaces/SendToDeviceAction");
								Object.keys(j).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === j[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return j[e]
										}
									}))
								}));
								var L = e("./interfaces/ReadEventAction");
								Object.keys(L).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === L[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return L[e]
										}
									}))
								}));
								var N = e("./interfaces/IRoomEvent");
								Object.keys(N).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === N[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return N[e]
										}
									}))
								}));
								var B = e("./interfaces/NavigateAction");
								Object.keys(B).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === B[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return B[e]
										}
									}))
								}));
								var U = e("./interfaces/TurnServerActions");
								Object.keys(U).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === U[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return U[e]
										}
									}))
								}));
								var F = e("./interfaces/ReadRelationsAction");
								Object.keys(F).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === F[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return F[e]
										}
									}))
								}));
								var $ = e("./models/WidgetEventCapability");
								Object.keys($).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === $[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return $[e]
										}
									}))
								}));
								var q = e("./models/validation/url");
								Object.keys(q).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === q[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return q[e]
										}
									}))
								}));
								var K = e("./models/validation/utils");
								Object.keys(K).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === K[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return K[e]
										}
									}))
								}));
								var V = e("./models/Widget");
								Object.keys(V).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === V[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return V[e]
										}
									}))
								}));
								var z = e("./models/WidgetParser");
								Object.keys(z).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === z[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return z[e]
										}
									}))
								}));
								var H = e("./templating/url-template");
								Object.keys(H).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === H[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return H[e]
										}
									}))
								}));
								var W = e("./util/SimpleObservable");
								Object.keys(W).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === W[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return W[e]
										}
									}))
								}));
								var G = e("./driver/WidgetDriver");
								Object.keys(G).forEach((function(e) {
									"default" !== e && "__esModule" !== e && (e in r && r[e] === G[e] || Object.defineProperty(r, e, {
										enumerable: !0,
										get: function() {
											return G[e]
										}
									}))
								}))
							}, {
								"./ClientWidgetApi": 175,
								"./Symbols": 176,
								"./WidgetApi": 177,
								"./driver/WidgetDriver": 178,
								"./interfaces/ApiVersion": 180,
								"./interfaces/Capabilities": 181,
								"./interfaces/CapabilitiesAction": 182,
								"./interfaces/ContentLoadedAction": 183,
								"./interfaces/GetOpenIDAction": 184,
								"./interfaces/ICustomWidgetData": 185,
								"./interfaces/IJitsiWidgetData": 186,
								"./interfaces/IRoomEvent": 187,
								"./interfaces/IStickerpickerWidgetData": 188,
								"./interfaces/IWidget": 189,
								"./interfaces/IWidgetApiErrorResponse": 190,
								"./interfaces/IWidgetApiRequest": 191,
								"./interfaces/IWidgetApiResponse": 192,
								"./interfaces/ModalButtonKind": 193,
								"./interfaces/ModalWidgetActions": 194,
								"./interfaces/NavigateAction": 195,
								"./interfaces/OpenIDCredentialsAction": 196,
								"./interfaces/ReadEventAction": 197,
								"./interfaces/ReadRelationsAction": 198,
								"./interfaces/ScreenshotAction": 199,
								"./interfaces/SendEventAction": 200,
								"./interfaces/SendToDeviceAction": 201,
								"./interfaces/SetModalButtonEnabledAction": 202,
								"./interfaces/StickerAction": 203,
								"./interfaces/StickyAction": 204,
								"./interfaces/SupportedVersionsAction": 205,
								"./interfaces/TurnServerActions": 206,
								"./interfaces/VisibilityAction": 207,
								"./interfaces/WidgetApiAction": 208,
								"./interfaces/WidgetApiDirection": 209,
								"./interfaces/WidgetConfigAction": 210,
								"./interfaces/WidgetKind": 211,
								"./interfaces/WidgetType": 212,
								"./models/Widget": 213,
								"./models/WidgetEventCapability": 214,
								"./models/WidgetParser": 215,
								"./models/validation/url": 216,
								"./models/validation/utils": 217,
								"./templating/url-template": 218,
								"./transport/ITransport": 219,
								"./transport/PostmessageTransport": 220,
								"./util/SimpleObservable": 221
							}],
							180: [function(e, t, r) {
								"use strict";
								var n, i;
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.UnstableApiVersion = r.MatrixApiVersion = r.CurrentApiVersions = void 0, r.MatrixApiVersion = n,
									function(e) {
										e.Prerelease1 = "0.0.1", e.Prerelease2 = "0.0.2"
									}(n || (r.MatrixApiVersion = n = {})), r.UnstableApiVersion = i,
									function(e) {
										e.MSC2762 = "org.matrix.msc2762", e.MSC2871 = "org.matrix.msc2871", e.MSC2931 = "org.matrix.msc2931", e.MSC2974 = "org.matrix.msc2974", e.MSC2876 = "org.matrix.msc2876", e.MSC3819 = "org.matrix.msc3819", e.MSC3846 = "town.robin.msc3846", e.MSC3869 = "org.matrix.msc3869"
									}(i || (r.UnstableApiVersion = i = {}));
								var o = [n.Prerelease1, n.Prerelease2, i.MSC2762, i.MSC2871, i.MSC2931, i.MSC2974, i.MSC2876, i.MSC3819, i.MSC3846, i.MSC3869];
								r.CurrentApiVersions = o
							}, {}],
							181: [function(e, t, r) {
								"use strict";
								var n;
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.VideoConferenceCapabilities = r.StickerpickerCapabilities = r.MatrixCapabilities = void 0, r.getTimelineRoomIDFromCapability = function(e) {
										return e.substring(e.indexOf(":") + 1)
									}, r.isTimelineCapability = function(e) {
										return null == e ? void 0 : e.startsWith("org.matrix.msc2762.timeline:")
									}, r.isTimelineCapabilityFor = function(e, t) {
										return e === "org.matrix.msc2762.timeline:".concat(t)
									}, r.MatrixCapabilities = n,
									function(e) {
										e.Screenshots = "m.capability.screenshot", e.StickerSending = "m.sticker", e.AlwaysOnScreen = "m.always_on_screen", e.RequiresClient = "io.element.requires_client", e.MSC2931Navigate = "org.matrix.msc2931.navigate", e.MSC3846TurnServers = "town.robin.msc3846.turn_servers"
									}(n || (r.MatrixCapabilities = n = {}));
								var i = [n.StickerSending];
								r.StickerpickerCapabilities = i;
								var o = [n.AlwaysOnScreen];
								r.VideoConferenceCapabilities = o
							}, {}],
							182: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							183: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							184: [function(e, t, r) {
								"use strict";
								var n;
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.OpenIDRequestState = void 0, r.OpenIDRequestState = n,
									function(e) {
										e.Allowed = "allowed", e.Blocked = "blocked", e.PendingUserConfirmation = "request"
									}(n || (r.OpenIDRequestState = n = {}))
							}, {}],
							185: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							186: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							187: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							188: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							189: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							190: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.isErrorResponse = function(e) {
									if ("error" in e) {
										return !!e.error.message
									}
									return !1
								}
							}, {}],
							191: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							192: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							193: [function(e, t, r) {
								"use strict";
								var n;
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.ModalButtonKind = void 0, r.ModalButtonKind = n,
									function(e) {
										e.Primary = "m.primary", e.Secondary = "m.secondary", e.Warning = "m.warning", e.Danger = "m.danger", e.Link = "m.link"
									}(n || (r.ModalButtonKind = n = {}))
							}, {}],
							194: [function(e, t, r) {
								"use strict";
								var n;
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.BuiltInModalButtonID = void 0, r.BuiltInModalButtonID = n,
									function(e) {
										e.Close = "m.close"
									}(n || (r.BuiltInModalButtonID = n = {}))
							}, {}],
							195: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							196: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							197: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							198: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							199: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							200: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							201: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							202: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							203: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							204: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							205: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							206: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							207: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							208: [function(e, t, r) {
								"use strict";
								var n, i;
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.WidgetApiToWidgetAction = r.WidgetApiFromWidgetAction = void 0, r.WidgetApiToWidgetAction = n,
									function(e) {
										e.SupportedApiVersions = "supported_api_versions", e.Capabilities = "capabilities", e.NotifyCapabilities = "notify_capabilities", e.TakeScreenshot = "screenshot", e.UpdateVisibility = "visibility", e.OpenIDCredentials = "openid_credentials", e.WidgetConfig = "widget_config", e.CloseModalWidget = "close_modal", e.ButtonClicked = "button_clicked", e.SendEvent = "send_event", e.SendToDevice = "send_to_device", e.UpdateTurnServers = "update_turn_servers"
									}(n || (r.WidgetApiToWidgetAction = n = {})), r.WidgetApiFromWidgetAction = i,
									function(e) {
										e.SupportedApiVersions = "supported_api_versions", e.ContentLoaded = "content_loaded", e.SendSticker = "m.sticker", e.UpdateAlwaysOnScreen = "set_always_on_screen", e.GetOpenIDCredentials = "get_openid", e.CloseModalWidget = "close_modal", e.OpenModalWidget = "open_modal", e.SetModalButtonEnabled = "set_button_enabled", e.SendEvent = "send_event", e.SendToDevice = "send_to_device", e.WatchTurnServers = "watch_turn_servers", e.UnwatchTurnServers = "unwatch_turn_servers", e.MSC2876ReadEvents = "org.matrix.msc2876.read_events", e.MSC2931Navigate = "org.matrix.msc2931.navigate", e.MSC2974RenegotiateCapabilities = "org.matrix.msc2974.request_capabilities", e.MSC3869ReadRelations = "org.matrix.msc3869.read_relations"
									}(i || (r.WidgetApiFromWidgetAction = i = {}))
							}, {}],
							209: [function(e, t, r) {
								"use strict";
								var n;
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.WidgetApiDirection = void 0, r.invertedDirection = function(e) {
										if (e === n.ToWidget) return n.FromWidget;
										if (e === n.FromWidget) return n.ToWidget;
										throw new Error("Invalid direction")
									}, r.WidgetApiDirection = n,
									function(e) {
										e.ToWidget = "toWidget", e.FromWidget = "fromWidget"
									}(n || (r.WidgetApiDirection = n = {}))
							}, {}],
							210: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							211: [function(e, t, r) {
								"use strict";
								var n;
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.WidgetKind = void 0, r.WidgetKind = n,
									function(e) {
										e.Room = "room", e.Account = "account", e.Modal = "modal"
									}(n || (r.WidgetKind = n = {}))
							}, {}],
							212: [function(e, t, r) {
								"use strict";
								var n;
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.MatrixWidgetType = void 0, r.MatrixWidgetType = n,
									function(e) {
										e.Custom = "m.custom", e.JitsiMeet = "m.jitsi", e.Stickerpicker = "m.stickerpicker"
									}(n || (r.MatrixWidgetType = n = {}))
							}, {}],
							213: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.Widget = void 0;
								var n = e("./validation/utils"),
									i = e("..");

								function o(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								var s = function() {
									function e(t) {
										if (function(e, t) {
												if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
											}(this, e), this.definition = t, !this.definition) throw new Error("Definition is required");
										(0, n.assertPresent)(t, "id"), (0, n.assertPresent)(t, "creatorUserId"), (0, n.assertPresent)(t, "type"), (0, n.assertPresent)(t, "url")
									}
									var t, r, s;
									return t = e, (r = [{
										key: "creatorUserId",
										get: function() {
											return this.definition.creatorUserId
										}
									}, {
										key: "type",
										get: function() {
											return this.definition.type
										}
									}, {
										key: "id",
										get: function() {
											return this.definition.id
										}
									}, {
										key: "name",
										get: function() {
											return this.definition.name || null
										}
									}, {
										key: "title",
										get: function() {
											return this.rawData.title || null
										}
									}, {
										key: "templateUrl",
										get: function() {
											return this.definition.url
										}
									}, {
										key: "origin",
										get: function() {
											return new URL(this.templateUrl).origin
										}
									}, {
										key: "waitForIframeLoad",
										get: function() {
											return !1 !== this.definition.waitForIframeLoad && (this.definition.waitForIframeLoad, !0)
										}
									}, {
										key: "rawData",
										get: function() {
											return this.definition.data || {}
										}
									}, {
										key: "getCompleteUrl",
										value: function(e) {
											return (0, i.runTemplate)(this.templateUrl, this.definition, e)
										}
									}]) && o(t.prototype, r), s && o(t, s), Object.defineProperty(t, "prototype", {
										writable: !1
									}), e
								}();
								r.Widget = s
							}, {
								"..": 179,
								"./validation/utils": 217
							}],
							214: [function(e, t, r) {
								"use strict";

								function n(e, t) {
									var r = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
									if (!r) {
										if (Array.isArray(e) || (r = function(e, t) {
												if (!e) return;
												if ("string" == typeof e) return i(e, t);
												var r = Object.prototype.toString.call(e).slice(8, -1);
												"Object" === r && e.constructor && (r = e.constructor.name);
												if ("Map" === r || "Set" === r) return Array.from(e);
												if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return i(e, t)
											}(e)) || t && e && "number" == typeof e.length) {
											r && (e = r);
											var n = 0,
												o = function() {};
											return {
												s: o,
												n: function() {
													return n >= e.length ? {
														done: !0
													} : {
														done: !1,
														value: e[n++]
													}
												},
												e: function(e) {
													throw e
												},
												f: o
											}
										}
										throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
									}
									var s, a = !0,
										c = !1;
									return {
										s: function() {
											r = r.call(e)
										},
										n: function() {
											var e = r.next();
											return a = e.done, e
										},
										e: function(e) {
											c = !0, s = e
										},
										f: function() {
											try {
												a || null == r.return || r.return()
											} finally {
												if (c) throw s
											}
										}
									}
								}

								function i(e, t) {
									(null == t || t > e.length) && (t = e.length);
									for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
									return n
								}

								function o(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								var s, a;
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.WidgetEventCapability = r.EventKind = r.EventDirection = void 0, r.EventKind = s,
									function(e) {
										e.Event = "event", e.State = "state_event", e.ToDevice = "to_device"
									}(s || (r.EventKind = s = {})), r.EventDirection = a,
									function(e) {
										e.Send = "send", e.Receive = "receive"
									}(a || (r.EventDirection = a = {}));
								var c = function() {
									function e(t, r, n, i, o) {
										! function(e, t) {
											if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
										}(this, e), this.direction = t, this.eventType = r, this.kind = n, this.keyStr = i, this.raw = o
									}
									var t, r, i;
									return t = e, i = [{
										key: "forStateEvent",
										value: function(t, r, n) {
											r = r.replace(/#/g, "\\#"), n = null != n ? "#".concat(n) : "";
											var i = "org.matrix.msc2762.".concat(t, ".state_event:").concat(r).concat(n);
											return e.findEventCapabilities([i])[0]
										}
									}, {
										key: "forToDeviceEvent",
										value: function(t, r) {
											var n = "org.matrix.msc3819.".concat(t, ".to_device:").concat(r);
											return e.findEventCapabilities([n])[0]
										}
									}, {
										key: "forRoomEvent",
										value: function(t, r) {
											var n = "org.matrix.msc2762.".concat(t, ".event:").concat(r);
											return e.findEventCapabilities([n])[0]
										}
									}, {
										key: "forRoomMessageEvent",
										value: function(t, r) {
											r = null == r ? "" : r;
											var n = "org.matrix.msc2762.".concat(t, ".event:m.room.message#").concat(r);
											return e.findEventCapabilities([n])[0]
										}
									}, {
										key: "findEventCapabilities",
										value: function(t) {
											var r, i = [],
												o = n(t);
											try {
												for (o.s(); !(r = o.n()).done;) {
													var c = r.value,
														l = null,
														u = void 0,
														d = null;
													if (c.startsWith("org.matrix.msc2762.send.event:") ? (l = a.Send, d = s.Event, u = c.substring("org.matrix.msc2762.send.event:".length)) : c.startsWith("org.matrix.msc2762.send.state_event:") ? (l = a.Send, d = s.State, u = c.substring("org.matrix.msc2762.send.state_event:".length)) : c.startsWith("org.matrix.msc3819.send.to_device:") ? (l = a.Send, d = s.ToDevice, u = c.substring("org.matrix.msc3819.send.to_device:".length)) : c.startsWith("org.matrix.msc2762.receive.event:") ? (l = a.Receive, d = s.Event, u = c.substring("org.matrix.msc2762.receive.event:".length)) : c.startsWith("org.matrix.msc2762.receive.state_event:") ? (l = a.Receive, d = s.State, u = c.substring("org.matrix.msc2762.receive.state_event:".length)) : c.startsWith("org.matrix.msc3819.receive.to_device:") && (l = a.Receive, d = s.ToDevice, u = c.substring("org.matrix.msc3819.receive.to_device:".length)), null !== l && null !== d) {
														var h = u.startsWith("m.room.message#") || d === s.State,
															f = null;
														if (u.includes("#") && h) {
															var p = u.split("#"),
																v = p.findIndex((function(e) {
																	return !e.endsWith("\\")
																}));
															u = p.slice(0, v + 1).map((function(e) {
																return e.endsWith("\\") ? e.substring(0, e.length - 1) : e
															})).join("#"), f = p.slice(v + 1).join("#")
														}
														i.push(new e(l, u, d, f, c))
													}
												}
											} catch (g) {
												o.e(g)
											} finally {
												o.f()
											}
											return i
										}
									}], (r = [{
										key: "matchesAsStateEvent",
										value: function(e, t, r) {
											return this.kind === s.State && this.direction === e && this.eventType === t && (null === this.keyStr || this.keyStr === r)
										}
									}, {
										key: "matchesAsToDeviceEvent",
										value: function(e, t) {
											return this.kind === s.ToDevice && this.direction === e && this.eventType === t
										}
									}, {
										key: "matchesAsRoomEvent",
										value: function(e, t) {
											var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
											return this.kind === s.Event && this.direction === e && this.eventType === t && ("m.room.message" !== this.eventType || null === this.keyStr || this.keyStr === r)
										}
									}]) && o(t.prototype, r), i && o(t, i), Object.defineProperty(t, "prototype", {
										writable: !1
									}), e
								}();
								r.WidgetEventCapability = c
							}, {}],
							215: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.WidgetParser = void 0;
								var n = e("./Widget"),
									i = e("./validation/url");

								function o(e, t) {
									var r = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
									if (!r) {
										if (Array.isArray(e) || (r = function(e, t) {
												if (!e) return;
												if ("string" == typeof e) return s(e, t);
												var r = Object.prototype.toString.call(e).slice(8, -1);
												"Object" === r && e.constructor && (r = e.constructor.name);
												if ("Map" === r || "Set" === r) return Array.from(e);
												if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return s(e, t)
											}(e)) || t && e && "number" == typeof e.length) {
											r && (e = r);
											var n = 0,
												i = function() {};
											return {
												s: i,
												n: function() {
													return n >= e.length ? {
														done: !0
													} : {
														done: !1,
														value: e[n++]
													}
												},
												e: function(e) {
													throw e
												},
												f: i
											}
										}
										throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
									}
									var o, a = !0,
										c = !1;
									return {
										s: function() {
											r = r.call(e)
										},
										n: function() {
											var e = r.next();
											return a = e.done, e
										},
										e: function(e) {
											c = !0, o = e
										},
										f: function() {
											try {
												a || null == r.return || r.return()
											} finally {
												if (c) throw o
											}
										}
									}
								}

								function s(e, t) {
									(null == t || t > e.length) && (t = e.length);
									for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
									return n
								}

								function a(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								var c = function() {
									function e() {
										! function(e, t) {
											if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
										}(this, e)
									}
									var t, r, s;
									return t = e, s = [{
										key: "parseAccountData",
										value: function(t) {
											if (!t) return [];
											for (var r = [], n = 0, i = Object.keys(t); n < i.length; n++) {
												var o = i[n],
													s = t[o];
												if (s && ("m.widget" === s.type || "im.vector.modular.widgets" === s.type) && s.sender && (s.state_key || s.id) === o) {
													var a = {
															content: s.content,
															sender: s.sender,
															type: "m.widget",
															state_key: o,
															event_id: "$example",
															room_id: "!example",
															origin_server_ts: 1
														},
														c = e.parseRoomWidget(a);
													c && r.push(c)
												}
											}
											return r
										}
									}, {
										key: "parseWidgetsFromRoomState",
										value: function(t) {
											if (!t) return [];
											var r, n = [],
												i = o(t);
											try {
												for (i.s(); !(r = i.n()).done;) {
													var s = r.value,
														a = e.parseRoomWidget(s);
													a && n.push(a)
												}
											} catch (c) {
												i.e(c)
											} finally {
												i.f()
											}
											return n
										}
									}, {
										key: "parseRoomWidget",
										value: function(t) {
											if (!t) return null;
											if ("m.widget" !== t.type && "im.vector.modular.widgets" !== t.type) return null;
											var r = t.content || {},
												n = {
													id: t.state_key,
													creatorUserId: r.creatorUserId || t.sender,
													name: r.name,
													type: r.type,
													url: r.url,
													waitForIframeLoad: r.waitForIframeLoad,
													data: r.data
												};
											return e.processEstimatedWidget(n)
										}
									}, {
										key: "processEstimatedWidget",
										value: function(e) {
											return e.id && e.creatorUserId && e.type && (0, i.isValidUrl)(e.url) ? new n.Widget(e) : null
										}
									}], (r = null) && a(t.prototype, r), s && a(t, s), Object.defineProperty(t, "prototype", {
										writable: !1
									}), e
								}();
								r.WidgetParser = c
							}, {
								"./Widget": 213,
								"./validation/url": 216
							}],
							216: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.isValidUrl = function(e) {
									if (!e) return !1;
									try {
										var t = new URL(e);
										return "http" === t.protocol || "https" === t.protocol
									} catch (r) {
										if (r instanceof TypeError) return !1;
										throw r
									}
								}
							}, {}],
							217: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.assertPresent = function(e, t) {
									if (!e[t]) throw new Error("".concat(t, " is required"))
								}
							}, {}],
							218: [function(e, t, r) {
								"use strict";

								function n(e) {
									return null == e ? "".concat(e) : e.toString()
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.runTemplate = function(e, t, r) {
									for (var i = Object.assign({}, t.data, {
											matrix_room_id: r.widgetRoomId || "",
											matrix_user_id: r.currentUserId,
											matrix_display_name: r.userDisplayName || r.currentUserId,
											matrix_avatar_url: r.userHttpAvatarUrl || "",
											matrix_widget_id: t.id,
											"org.matrix.msc2873.client_id": r.clientId || "",
											"org.matrix.msc2873.client_theme": r.clientTheme || "",
											"org.matrix.msc2873.client_language": r.clientLanguage || ""
										}), o = e, s = 0, a = Object.keys(i); s < a.length; s++) {
										var c = a[s],
											l = "$".concat(c).replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),
											u = new RegExp(l, "g");
										o = o.replace(u, encodeURIComponent(n(i[c])))
									}
									return o
								}, r.toString = n
							}, {}],
							219: [function(e, t, r) {
								arguments[4][154][0].apply(r, arguments)
							}, {
								dup: 154
							}],
							220: [function(e, t, r) {
								"use strict";

								function n(e) {
									return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
										return typeof e
									} : function(e) {
										return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
									})(e)
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.PostmessageTransport = void 0;
								var i = e("events"),
									o = e("..");

								function s(e, t) {
									var r = Object.keys(e);
									if (Object.getOwnPropertySymbols) {
										var n = Object.getOwnPropertySymbols(e);
										t && (n = n.filter((function(t) {
											return Object.getOwnPropertyDescriptor(e, t).enumerable
										}))), r.push.apply(r, n)
									}
									return r
								}

								function a(e) {
									for (var t = 1; t < arguments.length; t++) {
										var r = null != arguments[t] ? arguments[t] : {};
										t % 2 ? s(Object(r), !0).forEach((function(t) {
											p(e, t, r[t])
										})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : s(Object(r)).forEach((function(t) {
											Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
										}))
									}
									return e
								}

								function c(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function l(e, t) {
									return (l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
										return e.__proto__ = t, e
									})(e, t)
								}

								function u(e) {
									var t = function() {
										if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
										if (Reflect.construct.sham) return !1;
										if ("function" == typeof Proxy) return !0;
										try {
											return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
										} catch (e) {
											return !1
										}
									}();
									return function() {
										var r, n = f(e);
										if (t) {
											var i = f(this).constructor;
											r = Reflect.construct(n, arguments, i)
										} else r = n.apply(this, arguments);
										return d(this, r)
									}
								}

								function d(e, t) {
									if (t && ("object" === n(t) || "function" == typeof t)) return t;
									if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
									return h(e)
								}

								function h(e) {
									if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
									return e
								}

								function f(e) {
									return (f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
										return e.__proto__ || Object.getPrototypeOf(e)
									})(e)
								}

								function p(e, t, r) {
									return t in e ? Object.defineProperty(e, t, {
										value: r,
										enumerable: !0,
										configurable: !0,
										writable: !0
									}) : e[t] = r, e
								}
								var v = function(e) {
									! function(e, t) {
										if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
										e.prototype = Object.create(t && t.prototype, {
											constructor: {
												value: e,
												writable: !0,
												configurable: !0
											}
										}), Object.defineProperty(e, "prototype", {
											writable: !1
										}), t && l(e, t)
									}(s, e);
									var t, r, n, i = u(s);

									function s(e, t, r, n) {
										var o;
										return function(e, t) {
											if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
										}(this, s), (o = i.call(this)).sendDirection = e, o.initialWidgetId = t, o.transportWindow = r, o.inboundWindow = n, p(h(o), "strictOriginCheck", void 0), p(h(o), "targetOrigin", void 0), p(h(o), "timeoutSeconds", 10), p(h(o), "_ready", !1), p(h(o), "_widgetId", null), p(h(o), "outboundRequests", new Map), p(h(o), "stopController", new AbortController), o._widgetId = t, o
									}
									return t = s, (r = [{
										key: "ready",
										get: function() {
											return this._ready
										}
									}, {
										key: "widgetId",
										get: function() {
											return this._widgetId || null
										}
									}, {
										key: "nextRequestId",
										get: function() {
											for (var e = "widgetapi-".concat(Date.now()), t = 0, r = e; this.outboundRequests.has(r);) r = "".concat(e, "-").concat(t++);
											return this.outboundRequests.set(r, null), r
										}
									}, {
										key: "sendInternal",
										value: function(e) {
											var t = this.targetOrigin || "*";
											console.log("[PostmessageTransport] Sending object to ".concat(t, ": "), e), this.transportWindow.postMessage(e, t)
										}
									}, {
										key: "reply",
										value: function(e, t) {
											return this.sendInternal(a(a({}, e), {}, {
												response: t
											}))
										}
									}, {
										key: "send",
										value: function(e, t) {
											return this.sendComplete(e, t).then((function(e) {
												return e.response
											}))
										}
									}, {
										key: "sendComplete",
										value: function(e, t) {
											var r = this;
											if (!this.ready || !this.widgetId) return Promise.reject(new Error("Not ready or unknown widget ID"));
											var n = {
												api: this.sendDirection,
												widgetId: this.widgetId,
												requestId: this.nextRequestId,
												action: e,
												data: t
											};
											return e === o.WidgetApiToWidgetAction.UpdateVisibility && (n.visible = t.visible), new Promise((function(e, t) {
												var i = function(e) {
														a(), t(e)
													},
													o = setTimeout((function() {
														return i(new Error("Request timed out"))
													}), 1e3 * (r.timeoutSeconds || 1)),
													s = function() {
														return i(new Error("Transport stopped"))
													};
												r.stopController.signal.addEventListener("abort", s);
												var a = function() {
													r.outboundRequests.delete(n.requestId), clearTimeout(o), r.stopController.signal.removeEventListener("abort", s)
												};
												r.outboundRequests.set(n.requestId, {
													request: n,
													resolve: function(t) {
														a(), e(t)
													},
													reject: i
												}), r.sendInternal(n)
											}))
										}
									}, {
										key: "start",
										value: function() {
											var e = this;
											this.inboundWindow.addEventListener("message", (function(t) {
												e.handleMessage(t)
											})), this._ready = !0
										}
									}, {
										key: "stop",
										value: function() {
											this._ready = !1, this.stopController.abort()
										}
									}, {
										key: "handleMessage",
										value: function(e) {
											if (!this.stopController.signal.aborted && e.data && (!this.strictOriginCheck || e.origin === window.origin)) {
												var t = e.data;
												if (t.action && t.requestId && t.widgetId)
													if (t.response) {
														if (t.api !== this.sendDirection) return;
														this.handleResponse(t)
													} else {
														var r = t;
														if (r.api !== (0, o.invertedDirection)(this.sendDirection)) return;
														this.handleRequest(r)
													}
											}
										}
									}, {
										key: "handleRequest",
										value: function(e) {
											if (this.widgetId) {
												if (this.widgetId !== e.widgetId) return
											} else this._widgetId = e.widgetId;
											this.emit("message", new CustomEvent("message", {
												detail: e
											}))
										}
									}, {
										key: "handleResponse",
										value: function(e) {
											if (e.widgetId === this.widgetId) {
												var t = this.outboundRequests.get(e.requestId);
												if (t)
													if ((0, o.isErrorResponse)(e.response)) {
														var r = e.response;
														t.reject(new Error(r.error.message))
													} else t.resolve(e)
											}
										}
									}]) && c(t.prototype, r), n && c(t, n), Object.defineProperty(t, "prototype", {
										writable: !1
									}), s
								}(i.EventEmitter);
								r.PostmessageTransport = v
							}, {
								"..": 179,
								events: 106
							}],
							221: [function(e, t, r) {
								"use strict";

								function n(e, t) {
									var r = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
									if (!r) {
										if (Array.isArray(e) || (r = function(e, t) {
												if (!e) return;
												if ("string" == typeof e) return i(e, t);
												var r = Object.prototype.toString.call(e).slice(8, -1);
												"Object" === r && e.constructor && (r = e.constructor.name);
												if ("Map" === r || "Set" === r) return Array.from(e);
												if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return i(e, t)
											}(e)) || t && e && "number" == typeof e.length) {
											r && (e = r);
											var n = 0,
												o = function() {};
											return {
												s: o,
												n: function() {
													return n >= e.length ? {
														done: !0
													} : {
														done: !1,
														value: e[n++]
													}
												},
												e: function(e) {
													throw e
												},
												f: o
											}
										}
										throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
									}
									var s, a = !0,
										c = !1;
									return {
										s: function() {
											r = r.call(e)
										},
										n: function() {
											var e = r.next();
											return a = e.done, e
										},
										e: function(e) {
											c = !0, s = e
										},
										f: function() {
											try {
												a || null == r.return || r.return()
											} finally {
												if (c) throw s
											}
										}
									}
								}

								function i(e, t) {
									(null == t || t > e.length) && (t = e.length);
									for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
									return n
								}

								function o(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.SimpleObservable = void 0;
								var s = function() {
									function e(t) {
										var r, n, i;
										! function(e, t) {
											if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
										}(this, e), i = [], (n = "listeners") in (r = this) ? Object.defineProperty(r, n, {
											value: i,
											enumerable: !0,
											configurable: !0,
											writable: !0
										}) : r[n] = i, t && this.listeners.push(t)
									}
									var t, r, i;
									return t = e, (r = [{
										key: "onUpdate",
										value: function(e) {
											this.listeners.push(e)
										}
									}, {
										key: "update",
										value: function(e) {
											var t, r = n(this.listeners);
											try {
												for (r.s(); !(t = r.n()).done;)(0, t.value)(e)
											} catch (i) {
												r.e(i)
											} finally {
												r.f()
											}
										}
									}, {
										key: "close",
										value: function() {
											this.listeners = []
										}
									}]) && o(t.prototype, r), i && o(t, i), Object.defineProperty(t, "prototype", {
										writable: !1
									}), e
								}();
								r.SimpleObservable = s
							}, {}],
							222: [function(e, t, r) {
								"use strict";
								var n = e("inherits"),
									i = e("hash-base"),
									o = e("safe-buffer").Buffer,
									s = new Array(16);

								function a() {
									i.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878
								}

								function c(e, t) {
									return e << t | e >>> 32 - t
								}

								function l(e, t, r, n, i, o, s) {
									return c(e + (t & r | ~t & n) + i + o | 0, s) + t | 0
								}

								function u(e, t, r, n, i, o, s) {
									return c(e + (t & n | r & ~n) + i + o | 0, s) + t | 0
								}

								function d(e, t, r, n, i, o, s) {
									return c(e + (t ^ r ^ n) + i + o | 0, s) + t | 0
								}

								function h(e, t, r, n, i, o, s) {
									return c(e + (r ^ (t | ~n)) + i + o | 0, s) + t | 0
								}
								n(a, i), a.prototype._update = function() {
									for (var e = s, t = 0; t < 16; ++t) e[t] = this._block.readInt32LE(4 * t);
									var r = this._a,
										n = this._b,
										i = this._c,
										o = this._d;
									r = l(r, n, i, o, e[0], 3614090360, 7), o = l(o, r, n, i, e[1], 3905402710, 12), i = l(i, o, r, n, e[2], 606105819, 17), n = l(n, i, o, r, e[3], 3250441966, 22), r = l(r, n, i, o, e[4], 4118548399, 7), o = l(o, r, n, i, e[5], 1200080426, 12), i = l(i, o, r, n, e[6], 2821735955, 17), n = l(n, i, o, r, e[7], 4249261313, 22), r = l(r, n, i, o, e[8], 1770035416, 7), o = l(o, r, n, i, e[9], 2336552879, 12), i = l(i, o, r, n, e[10], 4294925233, 17), n = l(n, i, o, r, e[11], 2304563134, 22), r = l(r, n, i, o, e[12], 1804603682, 7), o = l(o, r, n, i, e[13], 4254626195, 12), i = l(i, o, r, n, e[14], 2792965006, 17), r = u(r, n = l(n, i, o, r, e[15], 1236535329, 22), i, o, e[1], 4129170786, 5), o = u(o, r, n, i, e[6], 3225465664, 9), i = u(i, o, r, n, e[11], 643717713, 14), n = u(n, i, o, r, e[0], 3921069994, 20), r = u(r, n, i, o, e[5], 3593408605, 5), o = u(o, r, n, i, e[10], 38016083, 9), i = u(i, o, r, n, e[15], 3634488961, 14), n = u(n, i, o, r, e[4], 3889429448, 20), r = u(r, n, i, o, e[9], 568446438, 5), o = u(o, r, n, i, e[14], 3275163606, 9), i = u(i, o, r, n, e[3], 4107603335, 14), n = u(n, i, o, r, e[8], 1163531501, 20), r = u(r, n, i, o, e[13], 2850285829, 5), o = u(o, r, n, i, e[2], 4243563512, 9), i = u(i, o, r, n, e[7], 1735328473, 14), r = d(r, n = u(n, i, o, r, e[12], 2368359562, 20), i, o, e[5], 4294588738, 4), o = d(o, r, n, i, e[8], 2272392833, 11), i = d(i, o, r, n, e[11], 1839030562, 16), n = d(n, i, o, r, e[14], 4259657740, 23), r = d(r, n, i, o, e[1], 2763975236, 4), o = d(o, r, n, i, e[4], 1272893353, 11), i = d(i, o, r, n, e[7], 4139469664, 16), n = d(n, i, o, r, e[10], 3200236656, 23), r = d(r, n, i, o, e[13], 681279174, 4), o = d(o, r, n, i, e[0], 3936430074, 11), i = d(i, o, r, n, e[3], 3572445317, 16), n = d(n, i, o, r, e[6], 76029189, 23), r = d(r, n, i, o, e[9], 3654602809, 4), o = d(o, r, n, i, e[12], 3873151461, 11), i = d(i, o, r, n, e[15], 530742520, 16), r = h(r, n = d(n, i, o, r, e[2], 3299628645, 23), i, o, e[0], 4096336452, 6), o = h(o, r, n, i, e[7], 1126891415, 10), i = h(i, o, r, n, e[14], 2878612391, 15), n = h(n, i, o, r, e[5], 4237533241, 21), r = h(r, n, i, o, e[12], 1700485571, 6), o = h(o, r, n, i, e[3], 2399980690, 10), i = h(i, o, r, n, e[10], 4293915773, 15), n = h(n, i, o, r, e[1], 2240044497, 21), r = h(r, n, i, o, e[8], 1873313359, 6), o = h(o, r, n, i, e[15], 4264355552, 10), i = h(i, o, r, n, e[6], 2734768916, 15), n = h(n, i, o, r, e[13], 1309151649, 21), r = h(r, n, i, o, e[4], 4149444226, 6), o = h(o, r, n, i, e[11], 3174756917, 10), i = h(i, o, r, n, e[2], 718787259, 15), n = h(n, i, o, r, e[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + n | 0, this._c = this._c + i | 0, this._d = this._d + o | 0
								}, a.prototype._digest = function() {
									this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
									var e = o.allocUnsafe(16);
									return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e
								}, t.exports = a
							}, {
								"hash-base": 117,
								inherits: 147,
								"safe-buffer": 251
							}],
							223: [function(e, t, r) {
								var n = e("bn.js"),
									i = e("brorand");

								function o(e) {
									this.rand = e || new i.Rand
								}
								t.exports = o, o.create = function(e) {
									return new o(e)
								}, o.prototype._randbelow = function(e) {
									var t = e.bitLength(),
										r = Math.ceil(t / 8);
									do {
										var i = new n(this.rand.generate(r))
									} while (i.cmp(e) >= 0);
									return i
								}, o.prototype._randrange = function(e, t) {
									var r = t.sub(e);
									return e.add(this._randbelow(r))
								}, o.prototype.test = function(e, t, r) {
									var i = e.bitLength(),
										o = n.mont(e),
										s = new n(1).toRed(o);
									t || (t = Math.max(1, i / 48 | 0));
									for (var a = e.subn(1), c = 0; !a.testn(c); c++);
									for (var l = e.shrn(c), u = a.toRed(o); t > 0; t--) {
										var d = this._randrange(new n(2), a);
										r && r(d);
										var h = d.toRed(o).redPow(l);
										if (0 !== h.cmp(s) && 0 !== h.cmp(u)) {
											for (var f = 1; f < c; f++) {
												if (0 === (h = h.redSqr()).cmp(s)) return !1;
												if (0 === h.cmp(u)) break
											}
											if (f === c) return !1
										}
									}
									return !0
								}, o.prototype.getDivisor = function(e, t) {
									var r = e.bitLength(),
										i = n.mont(e),
										o = new n(1).toRed(i);
									t || (t = Math.max(1, r / 48 | 0));
									for (var s = e.subn(1), a = 0; !s.testn(a); a++);
									for (var c = e.shrn(a), l = s.toRed(i); t > 0; t--) {
										var u = this._randrange(new n(2), s),
											d = e.gcd(u);
										if (0 !== d.cmpn(1)) return d;
										var h = u.toRed(i).redPow(c);
										if (0 !== h.cmp(o) && 0 !== h.cmp(l)) {
											for (var f = 1; f < a; f++) {
												if (0 === (h = h.redSqr()).cmp(o)) return h.fromRed().subn(1).gcd(e);
												if (0 === h.cmp(l)) break
											}
											if (f === a) return (h = h.redSqr()).fromRed().subn(1).gcd(e)
										}
									}
									return !1
								}
							}, {
								"bn.js": 19,
								brorand: 20
							}],
							224: [function(e, t, r) {
								function n(e, t) {
									if (!e) throw new Error(t || "Assertion failed")
								}
								t.exports = n, n.equal = function(e, t, r) {
									if (e != t) throw new Error(r || "Assertion failed: " + e + " != " + t)
								}
							}, {}],
							225: [function(e, t, r) {
								"use strict";
								var n = r;

								function i(e) {
									return 1 === e.length ? "0" + e : e
								}

								function o(e) {
									for (var t = "", r = 0; r < e.length; r++) t += i(e[r].toString(16));
									return t
								}
								n.toArray = function(e, t) {
									if (Array.isArray(e)) return e.slice();
									if (!e) return [];
									var r = [];
									if ("string" != typeof e) {
										for (var n = 0; n < e.length; n++) r[n] = 0 | e[n];
										return r
									}
									if ("hex" === t) {
										(e = e.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (e = "0" + e);
										for (n = 0; n < e.length; n += 2) r.push(parseInt(e[n] + e[n + 1], 16))
									} else
										for (n = 0; n < e.length; n++) {
											var i = e.charCodeAt(n),
												o = i >> 8,
												s = 255 & i;
											o ? r.push(o, s) : r.push(s)
										}
									return r
								}, n.zero2 = i, n.toHex = o, n.encode = function(e, t) {
									return "hex" === t ? o(e) : e
								}
							}, {}],
							226: [function(e, t, r) {
								"use strict";
								const n = e("retry"),
									i = ["Failed to fetch", "NetworkError when attempting to fetch resource.", "The Internet connection appears to be offline.", "Network request failed"];
								class AbortError extends Error {
									constructor(e) {
										super(), e instanceof Error ? (this.originalError = e, ({
											message: e
										} = e)) : (this.originalError = new Error(e), this.originalError.stack = this.stack), this.name = "AbortError", this.message = e
									}
								}
								const o = (e, t) => new Promise((r, o) => {
									t = {
										onFailedAttempt: () => {},
										retries: 10,
										...t
									};
									const s = n.operation(t);
									s.attempt(async n => {
										try {
											r(await e(n))
										} catch (a) {
											if (!(a instanceof Error)) return void o(new TypeError(`Non-error was thrown: "${a}". You should only throw errors.`));
											if (a instanceof AbortError) s.stop(), o(a.originalError);
											else if (a instanceof TypeError && !(e => i.includes(e))(a.message)) s.stop(), o(a);
											else {
												((e, t, r) => {
													const n = r.retries - (t - 1);
													e.attemptNumber = t, e.retriesLeft = n
												})(a, n, t);
												try {
													await t.onFailedAttempt(a)
												} catch (a) {
													return void o(a)
												}
												s.retry(a) || o(s.mainError())
											}
										}
									})
								});
								t.exports = o, t.exports.default = o, t.exports.AbortError = AbortError
							}, {
								retry: 247
							}],
							227: [function(e, t, r) {
								t.exports = {
									"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
									"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
									"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
									"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
									"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
									"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
									"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
									"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
									"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
									"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
									"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
									"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
								}
							}, {}],
							228: [function(e, t, r) {
								"use strict";
								var n = e("asn1.js");
								r.certificate = e("./certificate");
								var i = n.define("RSAPrivateKey", (function() {
									this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int())
								}));
								r.RSAPrivateKey = i;
								var o = n.define("RSAPublicKey", (function() {
									this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int())
								}));
								r.RSAPublicKey = o;
								var s = n.define("SubjectPublicKeyInfo", (function() {
									this.seq().obj(this.key("algorithm").use(a), this.key("subjectPublicKey").bitstr())
								}));
								r.PublicKey = s;
								var a = n.define("AlgorithmIdentifier", (function() {
										this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional())
									})),
									c = n.define("PrivateKeyInfo", (function() {
										this.seq().obj(this.key("version").int(), this.key("algorithm").use(a), this.key("subjectPrivateKey").octstr())
									}));
								r.PrivateKey = c;
								var l = n.define("EncryptedPrivateKeyInfo", (function() {
									this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr())
								}));
								r.EncryptedPrivateKey = l;
								var u = n.define("DSAPrivateKey", (function() {
									this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int())
								}));
								r.DSAPrivateKey = u, r.DSAparam = n.define("DSAparam", (function() {
									this.int()
								}));
								var d = n.define("ECPrivateKey", (function() {
									this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(h), this.key("publicKey").optional().explicit(1).bitstr())
								}));
								r.ECPrivateKey = d;
								var h = n.define("ECParameters", (function() {
									this.choice({
										namedCurve: this.objid()
									})
								}));
								r.signature = n.define("signature", (function() {
									this.seq().obj(this.key("r").int(), this.key("s").int())
								}))
							}, {
								"./certificate": 229,
								"asn1.js": 3
							}],
							229: [function(e, t, r) {
								"use strict";
								var n = e("asn1.js"),
									i = n.define("Time", (function() {
										this.choice({
											utcTime: this.utctime(),
											generalTime: this.gentime()
										})
									})),
									o = n.define("AttributeTypeValue", (function() {
										this.seq().obj(this.key("type").objid(), this.key("value").any())
									})),
									s = n.define("AlgorithmIdentifier", (function() {
										this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional())
									})),
									a = n.define("SubjectPublicKeyInfo", (function() {
										this.seq().obj(this.key("algorithm").use(s), this.key("subjectPublicKey").bitstr())
									})),
									c = n.define("RelativeDistinguishedName", (function() {
										this.setof(o)
									})),
									l = n.define("RDNSequence", (function() {
										this.seqof(c)
									})),
									u = n.define("Name", (function() {
										this.choice({
											rdnSequence: this.use(l)
										})
									})),
									d = n.define("Validity", (function() {
										this.seq().obj(this.key("notBefore").use(i), this.key("notAfter").use(i))
									})),
									h = n.define("Extension", (function() {
										this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr())
									})),
									f = n.define("TBSCertificate", (function() {
										this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(s), this.key("issuer").use(u), this.key("validity").use(d), this.key("subject").use(u), this.key("subjectPublicKeyInfo").use(a), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(h).optional())
									})),
									p = n.define("X509Certificate", (function() {
										this.seq().obj(this.key("tbsCertificate").use(f), this.key("signatureAlgorithm").use(s), this.key("signatureValue").bitstr())
									}));
								t.exports = p
							}, {
								"asn1.js": 3
							}],
							230: [function(e, t, r) {
								var n = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m,
									i = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m,
									o = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m,
									s = e("evp_bytestokey"),
									a = e("browserify-aes"),
									c = e("safe-buffer").Buffer;
								t.exports = function(e, t) {
									var r, l = e.toString(),
										u = l.match(n);
									if (u) {
										var d = "aes" + u[1],
											h = c.from(u[2], "hex"),
											f = c.from(u[3].replace(/[\r\n]/g, ""), "base64"),
											p = s(t, h.slice(0, 8), parseInt(u[1], 10)).key,
											v = [],
											g = a.createDecipheriv(d, p, h);
										v.push(g.update(f)), v.push(g.final()), r = c.concat(v)
									} else {
										var m = l.match(o);
										r = c.from(m[2].replace(/[\r\n]/g, ""), "base64")
									}
									return {
										tag: l.match(i)[1],
										data: r
									}
								}
							}, {
								"browserify-aes": 24,
								evp_bytestokey: 107,
								"safe-buffer": 251
							}],
							231: [function(e, t, r) {
								var n = e("./asn1"),
									i = e("./aesid.json"),
									o = e("./fixProc"),
									s = e("browserify-aes"),
									a = e("pbkdf2"),
									c = e("safe-buffer").Buffer;

								function l(e) {
									var t;
									"object" != typeof e || c.isBuffer(e) || (t = e.passphrase, e = e.key), "string" == typeof e && (e = c.from(e));
									var r, l, u = o(e, t),
										d = u.tag,
										h = u.data;
									switch (d) {
										case "CERTIFICATE":
											l = n.certificate.decode(h, "der").tbsCertificate.subjectPublicKeyInfo;
										case "PUBLIC KEY":
											switch (l || (l = n.PublicKey.decode(h, "der")), r = l.algorithm.algorithm.join(".")) {
												case "1.2.840.113549.1.1.1":
													return n.RSAPublicKey.decode(l.subjectPublicKey.data, "der");
												case "1.2.840.10045.2.1":
													return l.subjectPrivateKey = l.subjectPublicKey, {
														type: "ec",
														data: l
													};
												case "1.2.840.10040.4.1":
													return l.algorithm.params.pub_key = n.DSAparam.decode(l.subjectPublicKey.data, "der"), {
														type: "dsa",
														data: l.algorithm.params
													};
												default:
													throw new Error("unknown key id " + r)
											}
											case "ENCRYPTED PRIVATE KEY":
												h = function(e, t) {
													var r = e.algorithm.decrypt.kde.kdeparams.salt,
														n = parseInt(e.algorithm.decrypt.kde.kdeparams.iters.toString(), 10),
														o = i[e.algorithm.decrypt.cipher.algo.join(".")],
														l = e.algorithm.decrypt.cipher.iv,
														u = e.subjectPrivateKey,
														d = parseInt(o.split("-")[1], 10) / 8,
														h = a.pbkdf2Sync(t, r, n, d, "sha1"),
														f = s.createDecipheriv(o, h, l),
														p = [];
													return p.push(f.update(u)), p.push(f.final()), c.concat(p)
												}(h = n.EncryptedPrivateKey.decode(h, "der"), t);
											case "PRIVATE KEY":
												switch (r = (l = n.PrivateKey.decode(h, "der")).algorithm.algorithm.join(".")) {
													case "1.2.840.113549.1.1.1":
														return n.RSAPrivateKey.decode(l.subjectPrivateKey, "der");
													case "1.2.840.10045.2.1":
														return {
															curve: l.algorithm.curve, privateKey: n.ECPrivateKey.decode(l.subjectPrivateKey, "der").privateKey
														};
													case "1.2.840.10040.4.1":
														return l.algorithm.params.priv_key = n.DSAparam.decode(l.subjectPrivateKey, "der"), {
															type: "dsa",
															params: l.algorithm.params
														};
													default:
														throw new Error("unknown key id " + r)
												}
												case "RSA PUBLIC KEY":
													return n.RSAPublicKey.decode(h, "der");
												case "RSA PRIVATE KEY":
													return n.RSAPrivateKey.decode(h, "der");
												case "DSA PRIVATE KEY":
													return {
														type: "dsa", params: n.DSAPrivateKey.decode(h, "der")
													};
												case "EC PRIVATE KEY":
													return {
														curve: (h = n.ECPrivateKey.decode(h, "der")).parameters.value, privateKey: h.privateKey
													};
												default:
													throw new Error("unknown key type " + d)
									}
								}
								t.exports = l, l.signature = n.signature
							}, {
								"./aesid.json": 227,
								"./asn1": 228,
								"./fixProc": 230,
								"browserify-aes": 24,
								pbkdf2: 232,
								"safe-buffer": 251
							}],
							232: [function(e, t, r) {
								r.pbkdf2 = e("./lib/async"), r.pbkdf2Sync = e("./lib/sync")
							}, {
								"./lib/async": 233,
								"./lib/sync": 236
							}],
							233: [function(t, r, n) {
								(function(e) {
									(function() {
										var n, i, o = t("safe-buffer").Buffer,
											s = t("./precondition"),
											a = t("./default-encoding"),
											c = t("./sync"),
											l = t("./to-buffer"),
											u = e.crypto && e.crypto.subtle,
											d = {
												sha: "SHA-1",
												"sha-1": "SHA-1",
												sha1: "SHA-1",
												sha256: "SHA-256",
												"sha-256": "SHA-256",
												sha384: "SHA-384",
												"sha-384": "SHA-384",
												"sha-512": "SHA-512",
												sha512: "SHA-512"
											},
											h = [];

										function f() {
											return i || (i = e.process && e.process.nextTick ? e.process.nextTick : e.queueMicrotask ? e.queueMicrotask : e.setImmediate ? e.setImmediate : e.setTimeout)
										}

										function p(e, t, r, n, i) {
											return u.importKey("raw", e, {
												name: "PBKDF2"
											}, !1, ["deriveBits"]).then((function(e) {
												return u.deriveBits({
													name: "PBKDF2",
													salt: t,
													iterations: r,
													hash: {
														name: i
													}
												}, e, n << 3)
											})).then((function(e) {
												return o.from(e)
											}))
										}
										r.exports = function(t, r, i, v, g, m) {
											"function" == typeof g && (m = g, g = void 0);
											var y = d[(g = g || "sha1").toLowerCase()];
											if (y && "function" == typeof e.Promise) {
												if (s(i, v), t = l(t, a, "Password"), r = l(r, a, "Salt"), "function" != typeof m) throw new Error("No callback provided to pbkdf2");
												! function(e, t) {
													e.then((function(e) {
														f()((function() {
															t(null, e)
														}))
													}), (function(e) {
														f()((function() {
															t(e)
														}))
													}))
												}(function(t) {
													if (e.process && !e.process.browser) return Promise.resolve(!1);
													if (!u || !u.importKey || !u.deriveBits) return Promise.resolve(!1);
													if (void 0 !== h[t]) return h[t];
													var r = p(n = n || o.alloc(8), n, 10, 128, t).then((function() {
														return !0
													})).catch((function() {
														return !1
													}));
													return h[t] = r, r
												}(y).then((function(e) {
													return e ? p(t, r, i, v, y) : c(t, r, i, v, g)
												})), m)
											} else f()((function() {
												var e;
												try {
													e = c(t, r, i, v, g)
												} catch (n) {
													return m(n)
												}
												m(null, e)
											}))
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"./default-encoding": 234,
								"./precondition": 235,
								"./sync": 236,
								"./to-buffer": 237,
								"safe-buffer": 251
							}],
							234: [function(t, r, n) {
								(function(e, t) {
									(function() {
										var n;
										if (t.process && t.process.browser) n = "utf-8";
										else if (t.process && t.process.version) {
											n = parseInt(e.version.split(".")[0].slice(1), 10) >= 6 ? "utf-8" : "binary"
										} else n = "utf-8";
										r.exports = n
									}).call(this)
								}).call(this, t("_process"), void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								_process: 238
							}],
							235: [function(e, t, r) {
								var n = Math.pow(2, 30) - 1;
								t.exports = function(e, t) {
									if ("number" != typeof e) throw new TypeError("Iterations not a number");
									if (e < 0) throw new TypeError("Bad iterations");
									if ("number" != typeof t) throw new TypeError("Key length not a number");
									if (t < 0 || t > n || t != t) throw new TypeError("Bad key length")
								}
							}, {}],
							236: [function(e, t, r) {
								var n = e("create-hash/md5"),
									i = e("ripemd160"),
									o = e("sha.js"),
									s = e("safe-buffer").Buffer,
									a = e("./precondition"),
									c = e("./default-encoding"),
									l = e("./to-buffer"),
									u = s.alloc(128),
									d = {
										md5: 16,
										sha1: 20,
										sha224: 28,
										sha256: 32,
										sha384: 48,
										sha512: 64,
										rmd160: 20,
										ripemd160: 20
									};

								function h(e, t, r) {
									var a = function(e) {
											return "rmd160" === e || "ripemd160" === e ? function(e) {
												return (new i).update(e).digest()
											} : "md5" === e ? n : function(t) {
												return o(e).update(t).digest()
											}
										}(e),
										c = "sha512" === e || "sha384" === e ? 128 : 64;
									t.length > c ? t = a(t) : t.length < c && (t = s.concat([t, u], c));
									for (var l = s.allocUnsafe(c + d[e]), h = s.allocUnsafe(c + d[e]), f = 0; f < c; f++) l[f] = 54 ^ t[f], h[f] = 92 ^ t[f];
									var p = s.allocUnsafe(c + r + 4);
									l.copy(p, 0, 0, c), this.ipad1 = p, this.ipad2 = l, this.opad = h, this.alg = e, this.blocksize = c, this.hash = a, this.size = d[e]
								}
								h.prototype.run = function(e, t) {
									return e.copy(t, this.blocksize), this.hash(t).copy(this.opad, this.blocksize), this.hash(this.opad)
								}, t.exports = function(e, t, r, n, i) {
									a(r, n);
									var o = new h(i = i || "sha1", e = l(e, c, "Password"), (t = l(t, c, "Salt")).length),
										u = s.allocUnsafe(n),
										f = s.allocUnsafe(t.length + 4);
									t.copy(f, 0, 0, t.length);
									for (var p = 0, v = d[i], g = Math.ceil(n / v), m = 1; m <= g; m++) {
										f.writeUInt32BE(m, t.length);
										for (var y = o.run(f, o.ipad1), b = y, _ = 1; _ < r; _++) {
											b = o.run(b, o.ipad2);
											for (var w = 0; w < v; w++) y[w] ^= b[w]
										}
										y.copy(u, p), p += v
									}
									return u
								}
							}, {
								"./default-encoding": 234,
								"./precondition": 235,
								"./to-buffer": 237,
								"create-hash/md5": 76,
								ripemd160: 250,
								"safe-buffer": 251,
								"sha.js": 258
							}],
							237: [function(e, t, r) {
								var n = e("safe-buffer").Buffer;
								t.exports = function(e, t, r) {
									if (n.isBuffer(e)) return e;
									if ("string" == typeof e) return n.from(e, t);
									if (ArrayBuffer.isView(e)) return n.from(e.buffer);
									throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView")
								}
							}, {
								"safe-buffer": 251
							}],
							238: [function(e, t, r) {
								var n, i, o = t.exports = {};

								function s() {
									throw new Error("setTimeout has not been defined")
								}

								function a() {
									throw new Error("clearTimeout has not been defined")
								}

								function c(e) {
									if (n === setTimeout) return setTimeout(e, 0);
									if ((n === s || !n) && setTimeout) return n = setTimeout, setTimeout(e, 0);
									try {
										return n(e, 0)
									} catch (t) {
										try {
											return n.call(null, e, 0)
										} catch (t) {
											return n.call(this, e, 0)
										}
									}
								}! function() {
									try {
										n = "function" == typeof setTimeout ? setTimeout : s
									} catch (e) {
										n = s
									}
									try {
										i = "function" == typeof clearTimeout ? clearTimeout : a
									} catch (e) {
										i = a
									}
								}();
								var l, u = [],
									d = !1,
									h = -1;

								function f() {
									d && l && (d = !1, l.length ? u = l.concat(u) : h = -1, u.length && p())
								}

								function p() {
									if (!d) {
										var e = c(f);
										d = !0;
										for (var t = u.length; t;) {
											for (l = u, u = []; ++h < t;) l && l[h].run();
											h = -1, t = u.length
										}
										l = null, d = !1,
											function(e) {
												if (i === clearTimeout) return clearTimeout(e);
												if ((i === a || !i) && clearTimeout) return i = clearTimeout, clearTimeout(e);
												try {
													i(e)
												} catch (t) {
													try {
														return i.call(null, e)
													} catch (t) {
														return i.call(this, e)
													}
												}
											}(e)
									}
								}

								function v(e, t) {
									this.fun = e, this.array = t
								}

								function g() {}
								o.nextTick = function(e) {
									var t = new Array(arguments.length - 1);
									if (arguments.length > 1)
										for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
									u.push(new v(e, t)), 1 !== u.length || d || c(p)
								}, v.prototype.run = function() {
									this.fun.apply(null, this.array)
								}, o.title = "browser", o.browser = !0, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = g, o.addListener = g, o.once = g, o.off = g, o.removeListener = g, o.removeAllListeners = g, o.emit = g, o.prependListener = g, o.prependOnceListener = g, o.listeners = function(e) {
									return []
								}, o.binding = function(e) {
									throw new Error("process.binding is not supported")
								}, o.cwd = function() {
									return "/"
								}, o.chdir = function(e) {
									throw new Error("process.chdir is not supported")
								}, o.umask = function() {
									return 0
								}
							}, {}],
							239: [function(e, t, r) {
								r.publicEncrypt = e("./publicEncrypt"), r.privateDecrypt = e("./privateDecrypt"), r.privateEncrypt = function(e, t) {
									return r.publicEncrypt(e, t, !0)
								}, r.publicDecrypt = function(e, t) {
									return r.privateDecrypt(e, t, !0)
								}
							}, {
								"./privateDecrypt": 241,
								"./publicEncrypt": 242
							}],
							240: [function(e, t, r) {
								var n = e("create-hash"),
									i = e("safe-buffer").Buffer;

								function o(e) {
									var t = i.allocUnsafe(4);
									return t.writeUInt32BE(e, 0), t
								}
								t.exports = function(e, t) {
									for (var r, s = i.alloc(0), a = 0; s.length < t;) r = o(a++), s = i.concat([s, n("sha1").update(e).update(r).digest()]);
									return s.slice(0, t)
								}
							}, {
								"create-hash": 75,
								"safe-buffer": 251
							}],
							241: [function(e, t, r) {
								var n = e("parse-asn1"),
									i = e("./mgf"),
									o = e("./xor"),
									s = e("bn.js"),
									a = e("browserify-rsa"),
									c = e("create-hash"),
									l = e("./withPublic"),
									u = e("safe-buffer").Buffer;
								t.exports = function(e, t, r) {
									var d;
									d = e.padding ? e.padding : r ? 1 : 4;
									var h, f = n(e),
										p = f.modulus.byteLength();
									if (t.length > p || new s(t).cmp(f.modulus) >= 0) throw new Error("decryption error");
									h = r ? l(new s(t), f) : a(t, f);
									var v = u.alloc(p - h.length);
									if (h = u.concat([v, h], p), 4 === d) return function(e, t) {
										var r = e.modulus.byteLength(),
											n = c("sha1").update(u.alloc(0)).digest(),
											s = n.length;
										if (0 !== t[0]) throw new Error("decryption error");
										var a = t.slice(1, s + 1),
											l = t.slice(s + 1),
											d = o(a, i(l, s)),
											h = o(l, i(d, r - s - 1));
										if (function(e, t) {
												e = u.from(e), t = u.from(t);
												var r = 0,
													n = e.length;
												e.length !== t.length && (r++, n = Math.min(e.length, t.length));
												var i = -1;
												for (; ++i < n;) r += e[i] ^ t[i];
												return r
											}(n, h.slice(0, s))) throw new Error("decryption error");
										var f = s;
										for (; 0 === h[f];) f++;
										if (1 !== h[f++]) throw new Error("decryption error");
										return h.slice(f)
									}(f, h);
									if (1 === d) return function(e, t, r) {
										var n = t.slice(0, 2),
											i = 2,
											o = 0;
										for (; 0 !== t[i++];)
											if (i >= t.length) {
												o++;
												break
											} var s = t.slice(2, i - 1);
										("0002" !== n.toString("hex") && !r || "0001" !== n.toString("hex") && r) && o++;
										s.length < 8 && o++;
										if (o) throw new Error("decryption error");
										return t.slice(i)
									}(0, h, r);
									if (3 === d) return h;
									throw new Error("unknown padding")
								}
							}, {
								"./mgf": 240,
								"./withPublic": 243,
								"./xor": 244,
								"bn.js": 19,
								"browserify-rsa": 42,
								"create-hash": 75,
								"parse-asn1": 231,
								"safe-buffer": 251
							}],
							242: [function(e, t, r) {
								var n = e("parse-asn1"),
									i = e("randombytes"),
									o = e("create-hash"),
									s = e("./mgf"),
									a = e("./xor"),
									c = e("bn.js"),
									l = e("./withPublic"),
									u = e("browserify-rsa"),
									d = e("safe-buffer").Buffer;
								t.exports = function(e, t, r) {
									var h;
									h = e.padding ? e.padding : r ? 1 : 4;
									var f, p = n(e);
									if (4 === h) f = function(e, t) {
										var r = e.modulus.byteLength(),
											n = t.length,
											l = o("sha1").update(d.alloc(0)).digest(),
											u = l.length,
											h = 2 * u;
										if (n > r - h - 2) throw new Error("message too long");
										var f = d.alloc(r - n - h - 2),
											p = r - u - 1,
											v = i(u),
											g = a(d.concat([l, f, d.alloc(1, 1), t], p), s(v, p)),
											m = a(v, s(g, u));
										return new c(d.concat([d.alloc(1), m, g], r))
									}(p, t);
									else if (1 === h) f = function(e, t, r) {
										var n, o = t.length,
											s = e.modulus.byteLength();
										if (o > s - 11) throw new Error("message too long");
										n = r ? d.alloc(s - o - 3, 255) : function(e) {
											var t, r = d.allocUnsafe(e),
												n = 0,
												o = i(2 * e),
												s = 0;
											for (; n < e;) s === o.length && (o = i(2 * e), s = 0), (t = o[s++]) && (r[n++] = t);
											return r
										}(s - o - 3);
										return new c(d.concat([d.from([0, r ? 1 : 2]), n, d.alloc(1), t], s))
									}(p, t, r);
									else {
										if (3 !== h) throw new Error("unknown padding");
										if ((f = new c(t)).cmp(p.modulus) >= 0) throw new Error("data too long for modulus")
									}
									return r ? u(f, p) : l(f, p)
								}
							}, {
								"./mgf": 240,
								"./withPublic": 243,
								"./xor": 244,
								"bn.js": 19,
								"browserify-rsa": 42,
								"create-hash": 75,
								"parse-asn1": 231,
								randombytes: 245,
								"safe-buffer": 251
							}],
							243: [function(e, t, r) {
								var n = e("bn.js"),
									i = e("safe-buffer").Buffer;
								t.exports = function(e, t) {
									return i.from(e.toRed(n.mont(t.modulus)).redPow(new n(t.publicExponent)).fromRed().toArray())
								}
							}, {
								"bn.js": 19,
								"safe-buffer": 251
							}],
							244: [function(e, t, r) {
								t.exports = function(e, t) {
									for (var r = e.length, n = -1; ++n < r;) e[n] ^= t[n];
									return e
								}
							}, {}],
							245: [function(t, r, n) {
								(function(e, n) {
									(function() {
										"use strict";
										var i = 65536,
											o = 4294967295;
										var s = t("safe-buffer").Buffer,
											a = n.crypto || n.msCrypto;
										a && a.getRandomValues ? r.exports = function(t, r) {
											if (t > o) throw new RangeError("requested too many random bytes");
											var n = s.allocUnsafe(t);
											if (t > 0)
												if (t > i)
													for (var c = 0; c < t; c += i) a.getRandomValues(n.slice(c, c + i));
												else a.getRandomValues(n);
											if ("function" == typeof r) return e.nextTick((function() {
												r(null, n)
											}));
											return n
										} : r.exports = function() {
											throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11")
										}
									}).call(this)
								}).call(this, t("_process"), void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								_process: 238,
								"safe-buffer": 251
							}],
							246: [function(t, r, n) {
								(function(e, r) {
									(function() {
										"use strict";

										function i() {
											throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11")
										}
										var o = t("safe-buffer"),
											s = t("randombytes"),
											a = o.Buffer,
											c = o.kMaxLength,
											l = r.crypto || r.msCrypto,
											u = Math.pow(2, 32) - 1;

										function d(e, t) {
											if ("number" != typeof e || e != e) throw new TypeError("offset must be a number");
											if (e > u || e < 0) throw new TypeError("offset must be a uint32");
											if (e > c || e > t) throw new RangeError("offset out of range")
										}

										function h(e, t, r) {
											if ("number" != typeof e || e != e) throw new TypeError("size must be a number");
											if (e > u || e < 0) throw new TypeError("size must be a uint32");
											if (e + t > r || e > c) throw new RangeError("buffer too small")
										}

										function f(t, r, n, i) {
											if (e.browser) {
												var o = t.buffer,
													a = new Uint8Array(o, r, n);
												return l.getRandomValues(a), i ? void e.nextTick((function() {
													i(null, t)
												})) : t
											}
											if (!i) return s(n).copy(t, r), t;
											s(n, (function(e, n) {
												if (e) return i(e);
												n.copy(t, r), i(null, t)
											}))
										}
										l && l.getRandomValues || !e.browser ? (n.randomFill = function(e, t, n, i) {
											if (!(a.isBuffer(e) || e instanceof r.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
											if ("function" == typeof t) i = t, t = 0, n = e.length;
											else if ("function" == typeof n) i = n, n = e.length - t;
											else if ("function" != typeof i) throw new TypeError('"cb" argument must be a function');
											return d(t, e.length), h(n, t, e.length), f(e, t, n, i)
										}, n.randomFillSync = function(e, t, n) {
											void 0 === t && (t = 0);
											if (!(a.isBuffer(e) || e instanceof r.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
											d(t, e.length), void 0 === n && (n = e.length - t);
											return h(n, t, e.length), f(e, t, n)
										}) : (n.randomFill = i, n.randomFillSync = i)
									}).call(this)
								}).call(this, t("_process"), void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								_process: 238,
								randombytes: 245,
								"safe-buffer": 251
							}],
							247: [function(e, t, r) {
								t.exports = e("./lib/retry")
							}, {
								"./lib/retry": 248
							}],
							248: [function(e, t, r) {
								var n = e("./retry_operation");
								r.operation = function(e) {
									var t = r.timeouts(e);
									return new n(t, {
										forever: e && (e.forever || e.retries === 1 / 0),
										unref: e && e.unref,
										maxRetryTime: e && e.maxRetryTime
									})
								}, r.timeouts = function(e) {
									if (e instanceof Array) return [].concat(e);
									var t = {
										retries: 10,
										factor: 2,
										minTimeout: 1e3,
										maxTimeout: 1 / 0,
										randomize: !1
									};
									for (var r in e) t[r] = e[r];
									if (t.minTimeout > t.maxTimeout) throw new Error("minTimeout is greater than maxTimeout");
									for (var n = [], i = 0; i < t.retries; i++) n.push(this.createTimeout(i, t));
									return e && e.forever && !n.length && n.push(this.createTimeout(i, t)), n.sort((function(e, t) {
										return e - t
									})), n
								}, r.createTimeout = function(e, t) {
									var r = t.randomize ? Math.random() + 1 : 1,
										n = Math.round(r * Math.max(t.minTimeout, 1) * Math.pow(t.factor, e));
									return n = Math.min(n, t.maxTimeout)
								}, r.wrap = function(e, t, n) {
									if (t instanceof Array && (n = t, t = null), !n)
										for (var i in n = [], e) "function" == typeof e[i] && n.push(i);
									for (var o = 0; o < n.length; o++) {
										var s = n[o],
											a = e[s];
										e[s] = function(n) {
											var i = r.operation(t),
												o = Array.prototype.slice.call(arguments, 1),
												s = o.pop();
											o.push((function(e) {
												i.retry(e) || (e && (arguments[0] = i.mainError()), s.apply(this, arguments))
											})), i.attempt((function() {
												n.apply(e, o)
											}))
										}.bind(e, a), e[s].options = t
									}
								}
							}, {
								"./retry_operation": 249
							}],
							249: [function(e, t, r) {
								function n(e, t) {
									"boolean" == typeof t && (t = {
										forever: t
									}), this._originalTimeouts = JSON.parse(JSON.stringify(e)), this._timeouts = e, this._options = t || {}, this._maxRetryTime = t && t.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0))
								}
								t.exports = n, n.prototype.reset = function() {
									this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0)
								}, n.prototype.stop = function() {
									this._timeout && clearTimeout(this._timeout), this._timer && clearTimeout(this._timer), this._timeouts = [], this._cachedTimeouts = null
								}, n.prototype.retry = function(e) {
									if (this._timeout && clearTimeout(this._timeout), !e) return !1;
									var t = (new Date).getTime();
									if (e && t - this._operationStart >= this._maxRetryTime) return this._errors.push(e), this._errors.unshift(new Error("RetryOperation timeout occurred")), !1;
									this._errors.push(e);
									var r = this._timeouts.shift();
									if (void 0 === r) {
										if (!this._cachedTimeouts) return !1;
										this._errors.splice(0, this._errors.length - 1), r = this._cachedTimeouts.slice(-1)
									}
									var n = this;
									return this._timer = setTimeout((function() {
										n._attempts++, n._operationTimeoutCb && (n._timeout = setTimeout((function() {
											n._operationTimeoutCb(n._attempts)
										}), n._operationTimeout), n._options.unref && n._timeout.unref()), n._fn(n._attempts)
									}), r), this._options.unref && this._timer.unref(), !0
								}, n.prototype.attempt = function(e, t) {
									this._fn = e, t && (t.timeout && (this._operationTimeout = t.timeout), t.cb && (this._operationTimeoutCb = t.cb));
									var r = this;
									this._operationTimeoutCb && (this._timeout = setTimeout((function() {
										r._operationTimeoutCb()
									}), r._operationTimeout)), this._operationStart = (new Date).getTime(), this._fn(this._attempts)
								}, n.prototype.try = function(e) {
									console.log("Using RetryOperation.try() is deprecated"), this.attempt(e)
								}, n.prototype.start = function(e) {
									console.log("Using RetryOperation.start() is deprecated"), this.attempt(e)
								}, n.prototype.start = n.prototype.try, n.prototype.errors = function() {
									return this._errors
								}, n.prototype.attempts = function() {
									return this._attempts
								}, n.prototype.mainError = function() {
									if (0 === this._errors.length) return null;
									for (var e = {}, t = null, r = 0, n = 0; n < this._errors.length; n++) {
										var i = this._errors[n],
											o = i.message,
											s = (e[o] || 0) + 1;
										e[o] = s, s >= r && (t = i, r = s)
									}
									return t
								}
							}, {}],
							250: [function(e, t, r) {
								"use strict";
								var n = e("buffer").Buffer,
									i = e("inherits"),
									o = e("hash-base"),
									s = new Array(16),
									a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
									c = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
									l = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
									u = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11],
									d = [0, 1518500249, 1859775393, 2400959708, 2840853838],
									h = [1352829926, 1548603684, 1836072691, 2053994217, 0];

								function f() {
									o.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520
								}

								function p(e, t) {
									return e << t | e >>> 32 - t
								}

								function v(e, t, r, n, i, o, s, a) {
									return p(e + (t ^ r ^ n) + o + s | 0, a) + i | 0
								}

								function g(e, t, r, n, i, o, s, a) {
									return p(e + (t & r | ~t & n) + o + s | 0, a) + i | 0
								}

								function m(e, t, r, n, i, o, s, a) {
									return p(e + ((t | ~r) ^ n) + o + s | 0, a) + i | 0
								}

								function y(e, t, r, n, i, o, s, a) {
									return p(e + (t & n | r & ~n) + o + s | 0, a) + i | 0
								}

								function b(e, t, r, n, i, o, s, a) {
									return p(e + (t ^ (r | ~n)) + o + s | 0, a) + i | 0
								}
								i(f, o), f.prototype._update = function() {
									for (var e = s, t = 0; t < 16; ++t) e[t] = this._block.readInt32LE(4 * t);
									for (var r = 0 | this._a, n = 0 | this._b, i = 0 | this._c, o = 0 | this._d, f = 0 | this._e, _ = 0 | this._a, w = 0 | this._b, S = 0 | this._c, E = 0 | this._d, k = 0 | this._e, T = 0; T < 80; T += 1) {
										var I, R;
										T < 16 ? (I = v(r, n, i, o, f, e[a[T]], d[0], l[T]), R = b(_, w, S, E, k, e[c[T]], h[0], u[T])) : T < 32 ? (I = g(r, n, i, o, f, e[a[T]], d[1], l[T]), R = y(_, w, S, E, k, e[c[T]], h[1], u[T])) : T < 48 ? (I = m(r, n, i, o, f, e[a[T]], d[2], l[T]), R = m(_, w, S, E, k, e[c[T]], h[2], u[T])) : T < 64 ? (I = y(r, n, i, o, f, e[a[T]], d[3], l[T]), R = g(_, w, S, E, k, e[c[T]], h[3], u[T])) : (I = b(r, n, i, o, f, e[a[T]], d[4], l[T]), R = v(_, w, S, E, k, e[c[T]], h[4], u[T])), r = f, f = o, o = p(i, 10), i = n, n = I, _ = k, k = E, E = p(S, 10), S = w, w = R
									}
									var C = this._b + i + E | 0;
									this._b = this._c + o + k | 0, this._c = this._d + f + _ | 0, this._d = this._e + r + w | 0, this._e = this._a + n + S | 0, this._a = C
								}, f.prototype._digest = function() {
									this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
									var e = n.alloc ? n.alloc(20) : new n(20);
									return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e.writeInt32LE(this._e, 16), e
								}, t.exports = f
							}, {
								buffer: 69,
								"hash-base": 117,
								inherits: 147
							}],
							251: [function(e, t, r) {
								var n = e("buffer"),
									i = n.Buffer;

								function o(e, t) {
									for (var r in e) t[r] = e[r]
								}

								function s(e, t, r) {
									return i(e, t, r)
								}
								i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = n : (o(n, r), r.Buffer = s), s.prototype = Object.create(i.prototype), o(i, s), s.from = function(e, t, r) {
									if ("number" == typeof e) throw new TypeError("Argument must not be a number");
									return i(e, t, r)
								}, s.alloc = function(e, t, r) {
									if ("number" != typeof e) throw new TypeError("Argument must be a number");
									var n = i(e);
									return void 0 !== t ? "string" == typeof r ? n.fill(t, r) : n.fill(t) : n.fill(0), n
								}, s.allocUnsafe = function(e) {
									if ("number" != typeof e) throw new TypeError("Argument must be a number");
									return i(e)
								}, s.allocUnsafeSlow = function(e) {
									if ("number" != typeof e) throw new TypeError("Argument must be a number");
									return n.SlowBuffer(e)
								}
							}, {
								buffer: 69
							}],
							252: [function(e, t, r) {
								(function(r) {
									(function() {
										"use strict";
										var n, i = e("buffer"),
											o = i.Buffer,
											s = {};
										for (n in i) i.hasOwnProperty(n) && "SlowBuffer" !== n && "Buffer" !== n && (s[n] = i[n]);
										var a = s.Buffer = {};
										for (n in o) o.hasOwnProperty(n) && "allocUnsafe" !== n && "allocUnsafeSlow" !== n && (a[n] = o[n]);
										if (s.Buffer.prototype = o.prototype, a.from && a.from !== Uint8Array.from || (a.from = function(e, t, r) {
												if ("number" == typeof e) throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof e);
												if (e && void 0 === e.length) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
												return o(e, t, r)
											}), a.alloc || (a.alloc = function(e, t, r) {
												if ("number" != typeof e) throw new TypeError('The "size" argument must be of type number. Received type ' + typeof e);
												if (e < 0 || e >= 2 * (1 << 30)) throw new RangeError('The value "' + e + '" is invalid for option "size"');
												var n = o(e);
												return t && 0 !== t.length ? "string" == typeof r ? n.fill(t, r) : n.fill(t) : n.fill(0), n
											}), !s.kStringMaxLength) try {
											s.kStringMaxLength = r.binding("buffer").kStringMaxLength
										} catch (c) {}
										s.constants || (s.constants = {
											MAX_LENGTH: s.kMaxLength
										}, s.kStringMaxLength && (s.constants.MAX_STRING_LENGTH = s.kStringMaxLength)), t.exports = s
									}).call(this)
								}).call(this, e("_process"))
							}, {
								_process: 238,
								buffer: 69
							}],
							253: [function(e, t, r) {
								var n = t.exports = {
									v: [{
										name: "version",
										reg: /^(\d*)$/
									}],
									o: [{
										name: "origin",
										reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
										names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
										format: "%s %s %d %s IP%d %s"
									}],
									s: [{
										name: "name"
									}],
									i: [{
										name: "description"
									}],
									u: [{
										name: "uri"
									}],
									e: [{
										name: "email"
									}],
									p: [{
										name: "phone"
									}],
									z: [{
										name: "timezones"
									}],
									r: [{
										name: "repeats"
									}],
									t: [{
										name: "timing",
										reg: /^(\d*) (\d*)/,
										names: ["start", "stop"],
										format: "%d %d"
									}],
									c: [{
										name: "connection",
										reg: /^IN IP(\d) (\S*)/,
										names: ["version", "ip"],
										format: "IN IP%d %s"
									}],
									b: [{
										push: "bandwidth",
										reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
										names: ["type", "limit"],
										format: "%s:%s"
									}],
									m: [{
										reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
										names: ["type", "port", "protocol", "payloads"],
										format: "%s %d %s %s"
									}],
									a: [{
										push: "rtp",
										reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
										names: ["payload", "codec", "rate", "encoding"],
										format: function(e) {
											return e.encoding ? "rtpmap:%d %s/%s/%s" : e.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s"
										}
									}, {
										push: "fmtp",
										reg: /^fmtp:(\d*) ([\S| ]*)/,
										names: ["payload", "config"],
										format: "fmtp:%d %s"
									}, {
										name: "control",
										reg: /^control:(.*)/,
										format: "control:%s"
									}, {
										name: "rtcp",
										reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
										names: ["port", "netType", "ipVer", "address"],
										format: function(e) {
											return null != e.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d"
										}
									}, {
										push: "rtcpFbTrrInt",
										reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
										names: ["payload", "value"],
										format: "rtcp-fb:%s trr-int %d"
									}, {
										push: "rtcpFb",
										reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
										names: ["payload", "type", "subtype"],
										format: function(e) {
											return null != e.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s"
										}
									}, {
										push: "ext",
										reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
										names: ["value", "direction", "encrypt-uri", "uri", "config"],
										format: function(e) {
											return "extmap:%d" + (e.direction ? "/%s" : "%v") + (e["encrypt-uri"] ? " %s" : "%v") + " %s" + (e.config ? " %s" : "")
										}
									}, {
										name: "extmapAllowMixed",
										reg: /^(extmap-allow-mixed)/
									}, {
										push: "crypto",
										reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
										names: ["id", "suite", "config", "sessionConfig"],
										format: function(e) {
											return null != e.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s"
										}
									}, {
										name: "setup",
										reg: /^setup:(\w*)/,
										format: "setup:%s"
									}, {
										name: "connectionType",
										reg: /^connection:(new|existing)/,
										format: "connection:%s"
									}, {
										name: "mid",
										reg: /^mid:([^\s]*)/,
										format: "mid:%s"
									}, {
										name: "msid",
										reg: /^msid:(.*)/,
										format: "msid:%s"
									}, {
										name: "ptime",
										reg: /^ptime:(\d*(?:\.\d*)*)/,
										format: "ptime:%d"
									}, {
										name: "maxptime",
										reg: /^maxptime:(\d*(?:\.\d*)*)/,
										format: "maxptime:%d"
									}, {
										name: "direction",
										reg: /^(sendrecv|recvonly|sendonly|inactive)/
									}, {
										name: "icelite",
										reg: /^(ice-lite)/
									}, {
										name: "iceUfrag",
										reg: /^ice-ufrag:(\S*)/,
										format: "ice-ufrag:%s"
									}, {
										name: "icePwd",
										reg: /^ice-pwd:(\S*)/,
										format: "ice-pwd:%s"
									}, {
										name: "fingerprint",
										reg: /^fingerprint:(\S*) (\S*)/,
										names: ["type", "hash"],
										format: "fingerprint:%s %s"
									}, {
										push: "candidates",
										reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
										names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
										format: function(e) {
											var t = "candidate:%s %d %s %d %s %d typ %s";
											return t += null != e.raddr ? " raddr %s rport %d" : "%v%v", t += null != e.tcptype ? " tcptype %s" : "%v", null != e.generation && (t += " generation %d"), t += null != e["network-id"] ? " network-id %d" : "%v", t += null != e["network-cost"] ? " network-cost %d" : "%v"
										}
									}, {
										name: "endOfCandidates",
										reg: /^(end-of-candidates)/
									}, {
										name: "remoteCandidates",
										reg: /^remote-candidates:(.*)/,
										format: "remote-candidates:%s"
									}, {
										name: "iceOptions",
										reg: /^ice-options:(\S*)/,
										format: "ice-options:%s"
									}, {
										push: "ssrcs",
										reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
										names: ["id", "attribute", "value"],
										format: function(e) {
											var t = "ssrc:%d";
											return null != e.attribute && (t += " %s", null != e.value && (t += ":%s")), t
										}
									}, {
										push: "ssrcGroups",
										reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
										names: ["semantics", "ssrcs"],
										format: "ssrc-group:%s %s"
									}, {
										name: "msidSemantic",
										reg: /^msid-semantic:\s?(\w*) (\S*)/,
										names: ["semantic", "token"],
										format: "msid-semantic: %s %s"
									}, {
										push: "groups",
										reg: /^group:(\w*) (.*)/,
										names: ["type", "mids"],
										format: "group:%s %s"
									}, {
										name: "rtcpMux",
										reg: /^(rtcp-mux)/
									}, {
										name: "rtcpRsize",
										reg: /^(rtcp-rsize)/
									}, {
										name: "sctpmap",
										reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
										names: ["sctpmapNumber", "app", "maxMessageSize"],
										format: function(e) {
											return null != e.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s"
										}
									}, {
										name: "xGoogleFlag",
										reg: /^x-google-flag:([^\s]*)/,
										format: "x-google-flag:%s"
									}, {
										push: "rids",
										reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
										names: ["id", "direction", "params"],
										format: function(e) {
											return e.params ? "rid:%s %s %s" : "rid:%s %s"
										}
									}, {
										push: "imageattrs",
										reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
										names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
										format: function(e) {
											return "imageattr:%s %s %s" + (e.dir2 ? " %s %s" : "")
										}
									}, {
										name: "simulcast",
										reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
										names: ["dir1", "list1", "dir2", "list2"],
										format: function(e) {
											return "simulcast:%s %s" + (e.dir2 ? " %s %s" : "")
										}
									}, {
										name: "simulcast_03",
										reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
										names: ["value"],
										format: "simulcast: %s"
									}, {
										name: "framerate",
										reg: /^framerate:(\d+(?:$|\.\d+))/,
										format: "framerate:%s"
									}, {
										name: "sourceFilter",
										reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
										names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
										format: "source-filter: %s %s %s %s %s"
									}, {
										name: "bundleOnly",
										reg: /^(bundle-only)/
									}, {
										name: "label",
										reg: /^label:(.+)/,
										format: "label:%s"
									}, {
										name: "sctpPort",
										reg: /^sctp-port:(\d+)$/,
										format: "sctp-port:%s"
									}, {
										name: "maxMessageSize",
										reg: /^max-message-size:(\d+)$/,
										format: "max-message-size:%s"
									}, {
										push: "tsRefClocks",
										reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
										names: ["clksrc", "clksrcExt"],
										format: function(e) {
											return "ts-refclk:%s" + (null != e.clksrcExt ? "=%s" : "")
										}
									}, {
										name: "mediaClk",
										reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
										names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
										format: function(e) {
											var t = "mediaclk:";
											return t += null != e.id ? "id=%s %s" : "%v%s", t += null != e.mediaClockValue ? "=%s" : "", t += null != e.rateNumerator ? " rate=%s" : "", t += null != e.rateDenominator ? "/%s" : ""
										}
									}, {
										name: "keywords",
										reg: /^keywds:(.+)$/,
										format: "keywds:%s"
									}, {
										name: "content",
										reg: /^content:(.+)/,
										format: "content:%s"
									}, {
										name: "bfcpFloorCtrl",
										reg: /^floorctrl:(c-only|s-only|c-s)/,
										format: "floorctrl:%s"
									}, {
										name: "bfcpConfId",
										reg: /^confid:(\d+)/,
										format: "confid:%s"
									}, {
										name: "bfcpUserId",
										reg: /^userid:(\d+)/,
										format: "userid:%s"
									}, {
										name: "bfcpFloorId",
										reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
										names: ["id", "mStream"],
										format: "floorid:%s mstrm:%s"
									}, {
										push: "invalid",
										names: ["value"]
									}]
								};
								Object.keys(n).forEach((function(e) {
									n[e].forEach((function(e) {
										e.reg || (e.reg = /(.*)/), e.format || (e.format = "%s")
									}))
								}))
							}, {}],
							254: [function(e, t, r) {
								var n = e("./parser"),
									i = e("./writer");
								r.write = i, r.parse = n.parse, r.parseParams = n.parseParams, r.parseFmtpConfig = n.parseFmtpConfig, r.parsePayloads = n.parsePayloads, r.parseRemoteCandidates = n.parseRemoteCandidates, r.parseImageAttributes = n.parseImageAttributes, r.parseSimulcastStreamList = n.parseSimulcastStreamList
							}, {
								"./parser": 255,
								"./writer": 256
							}],
							255: [function(e, t, r) {
								var n = function(e) {
										return String(Number(e)) === e ? Number(e) : e
									},
									i = function(e, t, r) {
										var i = e.name && e.names;
										e.push && !t[e.push] ? t[e.push] = [] : i && !t[e.name] && (t[e.name] = {});
										var o = e.push ? {} : i ? t[e.name] : t;
										! function(e, t, r, i) {
											if (i && !r) t[i] = n(e[1]);
											else
												for (var o = 0; o < r.length; o += 1) null != e[o + 1] && (t[r[o]] = n(e[o + 1]))
										}(r.match(e.reg), o, e.names, e.name), e.push && t[e.push].push(o)
									},
									o = e("./grammar"),
									s = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
								r.parse = function(e) {
									var t = {},
										r = [],
										n = t;
									return e.split(/(\r\n|\r|\n)/).filter(s).forEach((function(e) {
										var t = e[0],
											s = e.slice(2);
										"m" === t && (r.push({
											rtp: [],
											fmtp: []
										}), n = r[r.length - 1]);
										for (var a = 0; a < (o[t] || []).length; a += 1) {
											var c = o[t][a];
											if (c.reg.test(s)) return i(c, n, s)
										}
									})), t.media = r, t
								};
								var a = function(e, t) {
									var r = t.split(/=(.+)/, 2);
									return 2 === r.length ? e[r[0]] = n(r[1]) : 1 === r.length && t.length > 1 && (e[r[0]] = void 0), e
								};
								r.parseParams = function(e) {
									return e.split(/;\s?/).reduce(a, {})
								}, r.parseFmtpConfig = r.parseParams, r.parsePayloads = function(e) {
									return e.toString().split(" ").map(Number)
								}, r.parseRemoteCandidates = function(e) {
									for (var t = [], r = e.split(" ").map(n), i = 0; i < r.length; i += 3) t.push({
										component: r[i],
										ip: r[i + 1],
										port: r[i + 2]
									});
									return t
								}, r.parseImageAttributes = function(e) {
									return e.split(" ").map((function(e) {
										return e.substring(1, e.length - 1).split(",").reduce(a, {})
									}))
								}, r.parseSimulcastStreamList = function(e) {
									return e.split(";").map((function(e) {
										return e.split(",").map((function(e) {
											var t, r = !1;
											return "~" !== e[0] ? t = n(e) : (t = n(e.substring(1, e.length)), r = !0), {
												scid: t,
												paused: r
											}
										}))
									}))
								}
							}, {
								"./grammar": 253
							}],
							256: [function(e, t, r) {
								var n = e("./grammar"),
									i = /%[sdv%]/g,
									o = function(e) {
										var t = 1,
											r = arguments,
											n = r.length;
										return e.replace(i, (function(e) {
											if (t >= n) return e;
											var i = r[t];
											switch (t += 1, e) {
												case "%%":
													return "%";
												case "%s":
													return String(i);
												case "%d":
													return Number(i);
												case "%v":
													return ""
											}
										}))
									},
									s = function(e, t, r) {
										var n = [e + "=" + (t.format instanceof Function ? t.format(t.push ? r : r[t.name]) : t.format)];
										if (t.names)
											for (var i = 0; i < t.names.length; i += 1) {
												var s = t.names[i];
												t.name ? n.push(r[t.name][s]) : n.push(r[t.names[i]])
											} else n.push(r[t.name]);
										return o.apply(null, n)
									},
									a = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
									c = ["i", "c", "b", "a"];
								t.exports = function(e, t) {
									t = t || {}, null == e.version && (e.version = 0), null == e.name && (e.name = " "), e.media.forEach((function(e) {
										null == e.payloads && (e.payloads = "")
									}));
									var r = t.outerOrder || a,
										i = t.innerOrder || c,
										o = [];
									return r.forEach((function(t) {
										n[t].forEach((function(r) {
											r.name in e && null != e[r.name] ? o.push(s(t, r, e)) : r.push in e && null != e[r.push] && e[r.push].forEach((function(e) {
												o.push(s(t, r, e))
											}))
										}))
									})), e.media.forEach((function(e) {
										o.push(s("m", n.m[0], e)), i.forEach((function(t) {
											n[t].forEach((function(r) {
												r.name in e && null != e[r.name] ? o.push(s(t, r, e)) : r.push in e && null != e[r.push] && e[r.push].forEach((function(e) {
													o.push(s(t, r, e))
												}))
											}))
										}))
									})), o.join("\r\n") + "\r\n"
								}
							}, {
								"./grammar": 253
							}],
							257: [function(e, t, r) {
								var n = e("safe-buffer").Buffer;

								function i(e, t) {
									this._block = n.alloc(e), this._finalSize = t, this._blockSize = e, this._len = 0
								}
								i.prototype.update = function(e, t) {
									"string" == typeof e && (t = t || "utf8", e = n.from(e, t));
									for (var r = this._block, i = this._blockSize, o = e.length, s = this._len, a = 0; a < o;) {
										for (var c = s % i, l = Math.min(o - a, i - c), u = 0; u < l; u++) r[c + u] = e[a + u];
										a += l, (s += l) % i == 0 && this._update(r)
									}
									return this._len += o, this
								}, i.prototype.digest = function(e) {
									var t = this._len % this._blockSize;
									this._block[t] = 128, this._block.fill(0, t + 1), t >= this._finalSize && (this._update(this._block), this._block.fill(0));
									var r = 8 * this._len;
									if (r <= 4294967295) this._block.writeUInt32BE(r, this._blockSize - 4);
									else {
										var n = (4294967295 & r) >>> 0,
											i = (r - n) / 4294967296;
										this._block.writeUInt32BE(i, this._blockSize - 8), this._block.writeUInt32BE(n, this._blockSize - 4)
									}
									this._update(this._block);
									var o = this._hash();
									return e ? o.toString(e) : o
								}, i.prototype._update = function() {
									throw new Error("_update must be implemented by subclass")
								}, t.exports = i
							}, {
								"safe-buffer": 251
							}],
							258: [function(e, t, r) {
								(r = t.exports = function(e) {
									e = e.toLowerCase();
									var t = r[e];
									if (!t) throw new Error(e + " is not supported (we accept pull requests)");
									return new t
								}).sha = e("./sha"), r.sha1 = e("./sha1"), r.sha224 = e("./sha224"), r.sha256 = e("./sha256"), r.sha384 = e("./sha384"), r.sha512 = e("./sha512")
							}, {
								"./sha": 259,
								"./sha1": 260,
								"./sha224": 261,
								"./sha256": 262,
								"./sha384": 263,
								"./sha512": 264
							}],
							259: [function(e, t, r) {
								var n = e("inherits"),
									i = e("./hash"),
									o = e("safe-buffer").Buffer,
									s = [1518500249, 1859775393, -1894007588, -899497514],
									a = new Array(80);

								function c() {
									this.init(), this._w = a, i.call(this, 64, 56)
								}

								function l(e) {
									return e << 30 | e >>> 2
								}

								function u(e, t, r, n) {
									return 0 === e ? t & r | ~t & n : 2 === e ? t & r | t & n | r & n : t ^ r ^ n
								}
								n(c, i), c.prototype.init = function() {
									return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this
								}, c.prototype._update = function(e) {
									for (var t, r = this._w, n = 0 | this._a, i = 0 | this._b, o = 0 | this._c, a = 0 | this._d, c = 0 | this._e, d = 0; d < 16; ++d) r[d] = e.readInt32BE(4 * d);
									for (; d < 80; ++d) r[d] = r[d - 3] ^ r[d - 8] ^ r[d - 14] ^ r[d - 16];
									for (var h = 0; h < 80; ++h) {
										var f = ~~(h / 20),
											p = 0 | ((t = n) << 5 | t >>> 27) + u(f, i, o, a) + c + r[h] + s[f];
										c = a, a = o, o = l(i), i = n, n = p
									}
									this._a = n + this._a | 0, this._b = i + this._b | 0, this._c = o + this._c | 0, this._d = a + this._d | 0, this._e = c + this._e | 0
								}, c.prototype._hash = function() {
									var e = o.allocUnsafe(20);
									return e.writeInt32BE(0 | this._a, 0), e.writeInt32BE(0 | this._b, 4), e.writeInt32BE(0 | this._c, 8), e.writeInt32BE(0 | this._d, 12), e.writeInt32BE(0 | this._e, 16), e
								}, t.exports = c
							}, {
								"./hash": 257,
								inherits: 147,
								"safe-buffer": 251
							}],
							260: [function(e, t, r) {
								var n = e("inherits"),
									i = e("./hash"),
									o = e("safe-buffer").Buffer,
									s = [1518500249, 1859775393, -1894007588, -899497514],
									a = new Array(80);

								function c() {
									this.init(), this._w = a, i.call(this, 64, 56)
								}

								function l(e) {
									return e << 5 | e >>> 27
								}

								function u(e) {
									return e << 30 | e >>> 2
								}

								function d(e, t, r, n) {
									return 0 === e ? t & r | ~t & n : 2 === e ? t & r | t & n | r & n : t ^ r ^ n
								}
								n(c, i), c.prototype.init = function() {
									return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this
								}, c.prototype._update = function(e) {
									for (var t, r = this._w, n = 0 | this._a, i = 0 | this._b, o = 0 | this._c, a = 0 | this._d, c = 0 | this._e, h = 0; h < 16; ++h) r[h] = e.readInt32BE(4 * h);
									for (; h < 80; ++h) r[h] = (t = r[h - 3] ^ r[h - 8] ^ r[h - 14] ^ r[h - 16]) << 1 | t >>> 31;
									for (var f = 0; f < 80; ++f) {
										var p = ~~(f / 20),
											v = l(n) + d(p, i, o, a) + c + r[f] + s[p] | 0;
										c = a, a = o, o = u(i), i = n, n = v
									}
									this._a = n + this._a | 0, this._b = i + this._b | 0, this._c = o + this._c | 0, this._d = a + this._d | 0, this._e = c + this._e | 0
								}, c.prototype._hash = function() {
									var e = o.allocUnsafe(20);
									return e.writeInt32BE(0 | this._a, 0), e.writeInt32BE(0 | this._b, 4), e.writeInt32BE(0 | this._c, 8), e.writeInt32BE(0 | this._d, 12), e.writeInt32BE(0 | this._e, 16), e
								}, t.exports = c
							}, {
								"./hash": 257,
								inherits: 147,
								"safe-buffer": 251
							}],
							261: [function(e, t, r) {
								var n = e("inherits"),
									i = e("./sha256"),
									o = e("./hash"),
									s = e("safe-buffer").Buffer,
									a = new Array(64);

								function c() {
									this.init(), this._w = a, o.call(this, 64, 56)
								}
								n(c, i), c.prototype.init = function() {
									return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this
								}, c.prototype._hash = function() {
									var e = s.allocUnsafe(28);
									return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e
								}, t.exports = c
							}, {
								"./hash": 257,
								"./sha256": 262,
								inherits: 147,
								"safe-buffer": 251
							}],
							262: [function(e, t, r) {
								var n = e("inherits"),
									i = e("./hash"),
									o = e("safe-buffer").Buffer,
									s = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],
									a = new Array(64);

								function c() {
									this.init(), this._w = a, i.call(this, 64, 56)
								}

								function l(e, t, r) {
									return r ^ e & (t ^ r)
								}

								function u(e, t, r) {
									return e & t | r & (e | t)
								}

								function d(e) {
									return (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10)
								}

								function h(e) {
									return (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7)
								}

								function f(e) {
									return (e >>> 7 | e << 25) ^ (e >>> 18 | e << 14) ^ e >>> 3
								}
								n(c, i), c.prototype.init = function() {
									return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this
								}, c.prototype._update = function(e) {
									for (var t, r = this._w, n = 0 | this._a, i = 0 | this._b, o = 0 | this._c, a = 0 | this._d, c = 0 | this._e, p = 0 | this._f, v = 0 | this._g, g = 0 | this._h, m = 0; m < 16; ++m) r[m] = e.readInt32BE(4 * m);
									for (; m < 64; ++m) r[m] = 0 | (((t = r[m - 2]) >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10) + r[m - 7] + f(r[m - 15]) + r[m - 16];
									for (var y = 0; y < 64; ++y) {
										var b = g + h(c) + l(c, p, v) + s[y] + r[y] | 0,
											_ = d(n) + u(n, i, o) | 0;
										g = v, v = p, p = c, c = a + b | 0, a = o, o = i, i = n, n = b + _ | 0
									}
									this._a = n + this._a | 0, this._b = i + this._b | 0, this._c = o + this._c | 0, this._d = a + this._d | 0, this._e = c + this._e | 0, this._f = p + this._f | 0, this._g = v + this._g | 0, this._h = g + this._h | 0
								}, c.prototype._hash = function() {
									var e = o.allocUnsafe(32);
									return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e.writeInt32BE(this._h, 28), e
								}, t.exports = c
							}, {
								"./hash": 257,
								inherits: 147,
								"safe-buffer": 251
							}],
							263: [function(e, t, r) {
								var n = e("inherits"),
									i = e("./sha512"),
									o = e("./hash"),
									s = e("safe-buffer").Buffer,
									a = new Array(160);

								function c() {
									this.init(), this._w = a, o.call(this, 128, 112)
								}
								n(c, i), c.prototype.init = function() {
									return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this
								}, c.prototype._hash = function() {
									var e = s.allocUnsafe(48);

									function t(t, r, n) {
										e.writeInt32BE(t, n), e.writeInt32BE(r, n + 4)
									}
									return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), e
								}, t.exports = c
							}, {
								"./hash": 257,
								"./sha512": 264,
								inherits: 147,
								"safe-buffer": 251
							}],
							264: [function(e, t, r) {
								var n = e("inherits"),
									i = e("./hash"),
									o = e("safe-buffer").Buffer,
									s = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591],
									a = new Array(160);

								function c() {
									this.init(), this._w = a, i.call(this, 128, 112)
								}

								function l(e, t, r) {
									return r ^ e & (t ^ r)
								}

								function u(e, t, r) {
									return e & t | r & (e | t)
								}

								function d(e, t) {
									return (e >>> 28 | t << 4) ^ (t >>> 2 | e << 30) ^ (t >>> 7 | e << 25)
								}

								function h(e, t) {
									return (e >>> 14 | t << 18) ^ (e >>> 18 | t << 14) ^ (t >>> 9 | e << 23)
								}

								function f(e, t) {
									return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ e >>> 7
								}

								function p(e, t) {
									return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ (e >>> 7 | t << 25)
								}

								function v(e, t) {
									return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ e >>> 6
								}

								function g(e, t) {
									return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ (e >>> 6 | t << 26)
								}

								function m(e, t) {
									return e >>> 0 < t >>> 0 ? 1 : 0
								}
								n(c, i), c.prototype.init = function() {
									return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this
								}, c.prototype._update = function(e) {
									for (var t = this._w, r = 0 | this._ah, n = 0 | this._bh, i = 0 | this._ch, o = 0 | this._dh, a = 0 | this._eh, c = 0 | this._fh, y = 0 | this._gh, b = 0 | this._hh, _ = 0 | this._al, w = 0 | this._bl, S = 0 | this._cl, E = 0 | this._dl, k = 0 | this._el, T = 0 | this._fl, I = 0 | this._gl, R = 0 | this._hl, C = 0; C < 32; C += 2) t[C] = e.readInt32BE(4 * C), t[C + 1] = e.readInt32BE(4 * C + 4);
									for (; C < 160; C += 2) {
										var M = t[C - 30],
											x = t[C - 30 + 1],
											O = f(M, x),
											A = p(x, M),
											P = v(M = t[C - 4], x = t[C - 4 + 1]),
											D = g(x, M),
											j = t[C - 14],
											L = t[C - 14 + 1],
											N = t[C - 32],
											B = t[C - 32 + 1],
											U = A + L | 0,
											F = O + j + m(U, A) | 0;
										F = (F = F + P + m(U = U + D | 0, D) | 0) + N + m(U = U + B | 0, B) | 0, t[C] = F, t[C + 1] = U
									}
									for (var $ = 0; $ < 160; $ += 2) {
										F = t[$], U = t[$ + 1];
										var q = u(r, n, i),
											K = u(_, w, S),
											V = d(r, _),
											z = d(_, r),
											H = h(a, k),
											W = h(k, a),
											G = s[$],
											Y = s[$ + 1],
											Q = l(a, c, y),
											J = l(k, T, I),
											X = R + W | 0,
											Z = b + H + m(X, R) | 0;
										Z = (Z = (Z = Z + Q + m(X = X + J | 0, J) | 0) + G + m(X = X + Y | 0, Y) | 0) + F + m(X = X + U | 0, U) | 0;
										var ee = z + K | 0,
											te = V + q + m(ee, z) | 0;
										b = y, R = I, y = c, I = T, c = a, T = k, a = o + Z + m(k = E + X | 0, E) | 0, o = i, E = S, i = n, S = w, n = r, w = _, r = Z + te + m(_ = X + ee | 0, X) | 0
									}
									this._al = this._al + _ | 0, this._bl = this._bl + w | 0, this._cl = this._cl + S | 0, this._dl = this._dl + E | 0, this._el = this._el + k | 0, this._fl = this._fl + T | 0, this._gl = this._gl + I | 0, this._hl = this._hl + R | 0, this._ah = this._ah + r + m(this._al, _) | 0, this._bh = this._bh + n + m(this._bl, w) | 0, this._ch = this._ch + i + m(this._cl, S) | 0, this._dh = this._dh + o + m(this._dl, E) | 0, this._eh = this._eh + a + m(this._el, k) | 0, this._fh = this._fh + c + m(this._fl, T) | 0, this._gh = this._gh + y + m(this._gl, I) | 0, this._hh = this._hh + b + m(this._hl, R) | 0
								}, c.prototype._hash = function() {
									var e = o.allocUnsafe(64);

									function t(t, r, n) {
										e.writeInt32BE(t, n), e.writeInt32BE(r, n + 4)
									}
									return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), t(this._gh, this._gl, 48), t(this._hh, this._hl, 56), e
								}, t.exports = c
							}, {
								"./hash": 257,
								inherits: 147,
								"safe-buffer": 251
							}],
							265: [function(e, t, r) {
								t.exports = i;
								var n = e("events").EventEmitter;

								function i() {
									n.call(this)
								}
								e("inherits")(i, n), i.Readable = e("readable-stream/lib/_stream_readable.js"), i.Writable = e("readable-stream/lib/_stream_writable.js"), i.Duplex = e("readable-stream/lib/_stream_duplex.js"), i.Transform = e("readable-stream/lib/_stream_transform.js"), i.PassThrough = e("readable-stream/lib/_stream_passthrough.js"), i.finished = e("readable-stream/lib/internal/streams/end-of-stream.js"), i.pipeline = e("readable-stream/lib/internal/streams/pipeline.js"), i.Stream = i, i.prototype.pipe = function(e, t) {
									var r = this;

									function i(t) {
										e.writable && !1 === e.write(t) && r.pause && r.pause()
									}

									function o() {
										r.readable && r.resume && r.resume()
									}
									r.on("data", i), e.on("drain", o), e._isStdio || t && !1 === t.end || (r.on("end", a), r.on("close", c));
									var s = !1;

									function a() {
										s || (s = !0, e.end())
									}

									function c() {
										s || (s = !0, "function" == typeof e.destroy && e.destroy())
									}

									function l(e) {
										if (u(), 0 === n.listenerCount(this, "error")) throw e
									}

									function u() {
										r.removeListener("data", i), e.removeListener("drain", o), r.removeListener("end", a), r.removeListener("close", c), r.removeListener("error", l), e.removeListener("error", l), r.removeListener("end", u), r.removeListener("close", u), e.removeListener("close", u)
									}
									return r.on("error", l), e.on("error", l), r.on("end", u), r.on("close", u), e.on("close", u), e.emit("pipe", r), e
								}
							}, {
								events: 106,
								inherits: 147,
								"readable-stream/lib/_stream_duplex.js": 267,
								"readable-stream/lib/_stream_passthrough.js": 268,
								"readable-stream/lib/_stream_readable.js": 269,
								"readable-stream/lib/_stream_transform.js": 270,
								"readable-stream/lib/_stream_writable.js": 271,
								"readable-stream/lib/internal/streams/end-of-stream.js": 275,
								"readable-stream/lib/internal/streams/pipeline.js": 277
							}],
							266: [function(e, t, r) {
								arguments[4][51][0].apply(r, arguments)
							}, {
								dup: 51
							}],
							267: [function(e, t, r) {
								(function(r) {
									(function() {
										"use strict";
										var n = Object.keys || function(e) {
											var t = [];
											for (var r in e) t.push(r);
											return t
										};
										t.exports = l;
										var i = e("./_stream_readable"),
											o = e("./_stream_writable");
										e("inherits")(l, i);
										for (var s = n(o.prototype), a = 0; a < s.length; a++) {
											var c = s[a];
											l.prototype[c] || (l.prototype[c] = o.prototype[c])
										}

										function l(e) {
											if (!(this instanceof l)) return new l(e);
											i.call(this, e), o.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", u)))
										}

										function u() {
											this._writableState.ended || r.nextTick(d, this)
										}

										function d(e) {
											e.end()
										}
										Object.defineProperty(l.prototype, "writableHighWaterMark", {
											enumerable: !1,
											get: function() {
												return this._writableState.highWaterMark
											}
										}), Object.defineProperty(l.prototype, "writableBuffer", {
											enumerable: !1,
											get: function() {
												return this._writableState && this._writableState.getBuffer()
											}
										}), Object.defineProperty(l.prototype, "writableLength", {
											enumerable: !1,
											get: function() {
												return this._writableState.length
											}
										}), Object.defineProperty(l.prototype, "destroyed", {
											enumerable: !1,
											get: function() {
												return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed)
											},
											set: function(e) {
												void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e)
											}
										})
									}).call(this)
								}).call(this, e("_process"))
							}, {
								"./_stream_readable": 269,
								"./_stream_writable": 271,
								_process: 238,
								inherits: 147
							}],
							268: [function(e, t, r) {
								arguments[4][53][0].apply(r, arguments)
							}, {
								"./_stream_transform": 270,
								dup: 53,
								inherits: 147
							}],
							269: [function(t, r, n) {
								(function(e, n) {
									(function() {
										"use strict";
										var i;
										r.exports = T, T.ReadableState = k;
										t("events").EventEmitter;
										var o = function(e, t) {
												return e.listeners(t).length
											},
											s = t("./internal/streams/stream"),
											a = t("buffer").Buffer,
											c = n.Uint8Array || function() {};
										var l, u = t("util");
										l = u && u.debuglog ? u.debuglog("stream") : function() {};
										var d, h, f, p = t("./internal/streams/buffer_list"),
											v = t("./internal/streams/destroy"),
											g = t("./internal/streams/state").getHighWaterMark,
											m = t("../errors").codes,
											y = m.ERR_INVALID_ARG_TYPE,
											b = m.ERR_STREAM_PUSH_AFTER_EOF,
											_ = m.ERR_METHOD_NOT_IMPLEMENTED,
											w = m.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
										t("inherits")(T, s);
										var S = v.errorOrDestroy,
											E = ["error", "close", "destroy", "pause", "resume"];

										function k(e, r, n) {
											i = i || t("./_stream_duplex"), e = e || {}, "boolean" != typeof n && (n = r instanceof i), this.objectMode = !!e.objectMode, n && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = g(this, e, "readableHighWaterMark", n), this.buffer = new p, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== e.emitClose, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (d || (d = t("string_decoder/").StringDecoder), this.decoder = new d(e.encoding), this.encoding = e.encoding)
										}

										function T(e) {
											if (i = i || t("./_stream_duplex"), !(this instanceof T)) return new T(e);
											var r = this instanceof i;
											this._readableState = new k(e, this, r), this.readable = !0, e && ("function" == typeof e.read && (this._read = e.read), "function" == typeof e.destroy && (this._destroy = e.destroy)), s.call(this)
										}

										function I(e, t, r, n, i) {
											l("readableAddChunk", t);
											var o, s = e._readableState;
											if (null === t) s.reading = !1,
												function(e, t) {
													if (l("onEofChunk"), t.ended) return;
													if (t.decoder) {
														var r = t.decoder.end();
														r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length)
													}
													t.ended = !0, t.sync ? x(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, O(e)))
												}(e, s);
											else if (i || (o = function(e, t) {
													var r;
													n = t, a.isBuffer(n) || n instanceof c || "string" == typeof t || void 0 === t || e.objectMode || (r = new y("chunk", ["string", "Buffer", "Uint8Array"], t));
													var n;
													return r
												}(s, t)), o) S(e, o);
											else if (s.objectMode || t && t.length > 0)
												if ("string" == typeof t || s.objectMode || Object.getPrototypeOf(t) === a.prototype || (t = function(e) {
														return a.from(e)
													}(t)), n) s.endEmitted ? S(e, new w) : R(e, s, t, !0);
												else if (s.ended) S(e, new b);
											else {
												if (s.destroyed) return !1;
												s.reading = !1, s.decoder && !r ? (t = s.decoder.write(t), s.objectMode || 0 !== t.length ? R(e, s, t, !1) : A(e, s)) : R(e, s, t, !1)
											} else n || (s.reading = !1, A(e, s));
											return !s.ended && (s.length < s.highWaterMark || 0 === s.length)
										}

										function R(e, t, r, n) {
											t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && x(e)), A(e, t)
										}
										Object.defineProperty(T.prototype, "destroyed", {
											enumerable: !1,
											get: function() {
												return void 0 !== this._readableState && this._readableState.destroyed
											},
											set: function(e) {
												this._readableState && (this._readableState.destroyed = e)
											}
										}), T.prototype.destroy = v.destroy, T.prototype._undestroy = v.undestroy, T.prototype._destroy = function(e, t) {
											t(e)
										}, T.prototype.push = function(e, t) {
											var r, n = this._readableState;
											return n.objectMode ? r = !0 : "string" == typeof e && ((t = t || n.defaultEncoding) !== n.encoding && (e = a.from(e, t), t = ""), r = !0), I(this, e, t, !1, r)
										}, T.prototype.unshift = function(e) {
											return I(this, e, null, !0, !1)
										}, T.prototype.isPaused = function() {
											return !1 === this._readableState.flowing
										}, T.prototype.setEncoding = function(e) {
											d || (d = t("string_decoder/").StringDecoder);
											var r = new d(e);
											this._readableState.decoder = r, this._readableState.encoding = this._readableState.decoder.encoding;
											for (var n = this._readableState.buffer.head, i = ""; null !== n;) i += r.write(n.data), n = n.next;
											return this._readableState.buffer.clear(), "" !== i && this._readableState.buffer.push(i), this._readableState.length = i.length, this
										};
										var C = 1073741824;

										function M(e, t) {
											return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = function(e) {
												return e >= C ? e = C : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e
											}(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0))
										}

										function x(t) {
											var r = t._readableState;
											l("emitReadable", r.needReadable, r.emittedReadable), r.needReadable = !1, r.emittedReadable || (l("emitReadable", r.flowing), r.emittedReadable = !0, e.nextTick(O, t))
										}

										function O(e) {
											var t = e._readableState;
											l("emitReadable_", t.destroyed, t.length, t.ended), t.destroyed || !t.length && !t.ended || (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, N(e)
										}

										function A(t, r) {
											r.readingMore || (r.readingMore = !0, e.nextTick(P, t, r))
										}

										function P(e, t) {
											for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);) {
												var r = t.length;
												if (l("maybeReadMore read 0"), e.read(0), r === t.length) break
											}
											t.readingMore = !1
										}

										function D(e) {
											var t = e._readableState;
											t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume()
										}

										function j(e) {
											l("readable nexttick read 0"), e.read(0)
										}

										function L(e, t) {
											l("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), N(e), t.flowing && !t.reading && e.read(0)
										}

										function N(e) {
											var t = e._readableState;
											for (l("flow", t.flowing); t.flowing && null !== e.read(););
										}

										function B(e, t) {
											return 0 === t.length ? null : (t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (r = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r);
											var r
										}

										function U(t) {
											var r = t._readableState;
											l("endReadable", r.endEmitted), r.endEmitted || (r.ended = !0, e.nextTick(F, r, t))
										}

										function F(e, t) {
											if (l("endReadableNT", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
												var r = t._writableState;
												(!r || r.autoDestroy && r.finished) && t.destroy()
											}
										}

										function $(e, t) {
											for (var r = 0, n = e.length; r < n; r++)
												if (e[r] === t) return r;
											return -1
										}
										T.prototype.read = function(e) {
											l("read", e), e = parseInt(e, 10);
											var t = this._readableState,
												r = e;
											if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 !== t.highWaterMark ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return l("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? U(this) : x(this), null;
											if (0 === (e = M(e, t)) && t.ended) return 0 === t.length && U(this), null;
											var n, i = t.needReadable;
											return l("need readable", i), (0 === t.length || t.length - e < t.highWaterMark) && l("length less than watermark", i = !0), t.ended || t.reading ? l("reading or ended", i = !1) : i && (l("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = M(r, t))), null === (n = e > 0 ? B(e, t) : null) ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (t.ended || (t.needReadable = !0), r !== e && t.ended && U(this)), null !== n && this.emit("data", n), n
										}, T.prototype._read = function(e) {
											S(this, new _("_read()"))
										}, T.prototype.pipe = function(t, r) {
											var n = this,
												i = this._readableState;
											switch (i.pipesCount) {
												case 0:
													i.pipes = t;
													break;
												case 1:
													i.pipes = [i.pipes, t];
													break;
												default:
													i.pipes.push(t)
											}
											i.pipesCount += 1, l("pipe count=%d opts=%j", i.pipesCount, r);
											var s = (!r || !1 !== r.end) && t !== e.stdout && t !== e.stderr ? c : g;

											function a(e, r) {
												l("onunpipe"), e === n && r && !1 === r.hasUnpiped && (r.hasUnpiped = !0, l("cleanup"), t.removeListener("close", p), t.removeListener("finish", v), t.removeListener("drain", u), t.removeListener("error", f), t.removeListener("unpipe", a), n.removeListener("end", c), n.removeListener("end", g), n.removeListener("data", h), d = !0, !i.awaitDrain || t._writableState && !t._writableState.needDrain || u())
											}

											function c() {
												l("onend"), t.end()
											}
											i.endEmitted ? e.nextTick(s) : n.once("end", s), t.on("unpipe", a);
											var u = function(e) {
												return function() {
													var t = e._readableState;
													l("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && o(e, "data") && (t.flowing = !0, N(e))
												}
											}(n);
											t.on("drain", u);
											var d = !1;

											function h(e) {
												l("ondata");
												var r = t.write(e);
												l("dest.write", r), !1 === r && ((1 === i.pipesCount && i.pipes === t || i.pipesCount > 1 && -1 !== $(i.pipes, t)) && !d && (l("false write response, pause", i.awaitDrain), i.awaitDrain++), n.pause())
											}

											function f(e) {
												l("onerror", e), g(), t.removeListener("error", f), 0 === o(t, "error") && S(t, e)
											}

											function p() {
												t.removeListener("finish", v), g()
											}

											function v() {
												l("onfinish"), t.removeListener("close", p), g()
											}

											function g() {
												l("unpipe"), n.unpipe(t)
											}
											return n.on("data", h),
												function(e, t, r) {
													if ("function" == typeof e.prependListener) return e.prependListener(t, r);
													e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]] : e.on(t, r)
												}(t, "error", f), t.once("close", p), t.once("finish", v), t.emit("pipe", n), i.flowing || (l("pipe resume"), n.resume()), t
										}, T.prototype.unpipe = function(e) {
											var t = this._readableState,
												r = {
													hasUnpiped: !1
												};
											if (0 === t.pipesCount) return this;
											if (1 === t.pipesCount) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r), this);
											if (!e) {
												var n = t.pipes,
													i = t.pipesCount;
												t.pipes = null, t.pipesCount = 0, t.flowing = !1;
												for (var o = 0; o < i; o++) n[o].emit("unpipe", this, {
													hasUnpiped: !1
												});
												return this
											}
											var s = $(t.pipes, e);
											return -1 === s ? this : (t.pipes.splice(s, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this)
										}, T.prototype.on = function(t, r) {
											var n = s.prototype.on.call(this, t, r),
												i = this._readableState;
											return "data" === t ? (i.readableListening = this.listenerCount("readable") > 0, !1 !== i.flowing && this.resume()) : "readable" === t && (i.endEmitted || i.readableListening || (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, l("on readable", i.length, i.reading), i.length ? x(this) : i.reading || e.nextTick(j, this))), n
										}, T.prototype.addListener = T.prototype.on, T.prototype.removeListener = function(t, r) {
											var n = s.prototype.removeListener.call(this, t, r);
											return "readable" === t && e.nextTick(D, this), n
										}, T.prototype.removeAllListeners = function(t) {
											var r = s.prototype.removeAllListeners.apply(this, arguments);
											return "readable" !== t && void 0 !== t || e.nextTick(D, this), r
										}, T.prototype.resume = function() {
											var t = this._readableState;
											return t.flowing || (l("resume"), t.flowing = !t.readableListening, function(t, r) {
												r.resumeScheduled || (r.resumeScheduled = !0, e.nextTick(L, t, r))
											}(this, t)), t.paused = !1, this
										}, T.prototype.pause = function() {
											return l("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this
										}, T.prototype.wrap = function(e) {
											var t = this,
												r = this._readableState,
												n = !1;
											for (var i in e.on("end", (function() {
													if (l("wrapped end"), r.decoder && !r.ended) {
														var e = r.decoder.end();
														e && e.length && t.push(e)
													}
													t.push(null)
												})), e.on("data", (function(i) {
													(l("wrapped data"), r.decoder && (i = r.decoder.write(i)), r.objectMode && null == i) || (r.objectMode || i && i.length) && (t.push(i) || (n = !0, e.pause()))
												})), e) void 0 === this[i] && "function" == typeof e[i] && (this[i] = function(t) {
												return function() {
													return e[t].apply(e, arguments)
												}
											}(i));
											for (var o = 0; o < E.length; o++) e.on(E[o], this.emit.bind(this, E[o]));
											return this._read = function(t) {
												l("wrapped _read", t), n && (n = !1, e.resume())
											}, this
										}, "function" == typeof Symbol && (T.prototype[Symbol.asyncIterator] = function() {
											return void 0 === h && (h = t("./internal/streams/async_iterator")), h(this)
										}), Object.defineProperty(T.prototype, "readableHighWaterMark", {
											enumerable: !1,
											get: function() {
												return this._readableState.highWaterMark
											}
										}), Object.defineProperty(T.prototype, "readableBuffer", {
											enumerable: !1,
											get: function() {
												return this._readableState && this._readableState.buffer
											}
										}), Object.defineProperty(T.prototype, "readableFlowing", {
											enumerable: !1,
											get: function() {
												return this._readableState.flowing
											},
											set: function(e) {
												this._readableState && (this._readableState.flowing = e)
											}
										}), T._fromList = B, Object.defineProperty(T.prototype, "readableLength", {
											enumerable: !1,
											get: function() {
												return this._readableState.length
											}
										}), "function" == typeof Symbol && (T.from = function(e, r) {
											return void 0 === f && (f = t("./internal/streams/from")), f(T, e, r)
										})
									}).call(this)
								}).call(this, t("_process"), void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"../errors": 266,
								"./_stream_duplex": 267,
								"./internal/streams/async_iterator": 272,
								"./internal/streams/buffer_list": 273,
								"./internal/streams/destroy": 274,
								"./internal/streams/from": 276,
								"./internal/streams/state": 278,
								"./internal/streams/stream": 279,
								_process: 238,
								buffer: 69,
								events: 106,
								inherits: 147,
								"string_decoder/": 280,
								util: 21
							}],
							270: [function(e, t, r) {
								arguments[4][55][0].apply(r, arguments)
							}, {
								"../errors": 266,
								"./_stream_duplex": 267,
								dup: 55,
								inherits: 147
							}],
							271: [function(t, r, n) {
								(function(e, n) {
									(function() {
										"use strict";

										function i(e) {
											var t = this;
											this.next = null, this.entry = null, this.finish = function() {
												! function(e, t, r) {
													var n = e.entry;
													e.entry = null;
													for (; n;) {
														var i = n.callback;
														t.pendingcb--, i(r), n = n.next
													}
													t.corkedRequestsFree.next = e
												}(t, e)
											}
										}
										var o;
										r.exports = T, T.WritableState = k;
										var s = {
												deprecate: t("util-deprecate")
											},
											a = t("./internal/streams/stream"),
											c = t("buffer").Buffer,
											l = n.Uint8Array || function() {};
										var u, d = t("./internal/streams/destroy"),
											h = t("./internal/streams/state").getHighWaterMark,
											f = t("../errors").codes,
											p = f.ERR_INVALID_ARG_TYPE,
											v = f.ERR_METHOD_NOT_IMPLEMENTED,
											g = f.ERR_MULTIPLE_CALLBACK,
											m = f.ERR_STREAM_CANNOT_PIPE,
											y = f.ERR_STREAM_DESTROYED,
											b = f.ERR_STREAM_NULL_VALUES,
											_ = f.ERR_STREAM_WRITE_AFTER_END,
											w = f.ERR_UNKNOWN_ENCODING,
											S = d.errorOrDestroy;

										function E() {}

										function k(r, n, s) {
											o = o || t("./_stream_duplex"), r = r || {}, "boolean" != typeof s && (s = n instanceof o), this.objectMode = !!r.objectMode, s && (this.objectMode = this.objectMode || !!r.writableObjectMode), this.highWaterMark = h(this, r, "writableHighWaterMark", s), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
											var a = !1 === r.decodeStrings;
											this.decodeStrings = !a, this.defaultEncoding = r.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(t) {
												! function(t, r) {
													var n = t._writableState,
														i = n.sync,
														o = n.writecb;
													if ("function" != typeof o) throw new g;
													if (function(e) {
															e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0
														}(n), r) ! function(t, r, n, i, o) {
														--r.pendingcb, n ? (e.nextTick(o, i), e.nextTick(O, t, r), t._writableState.errorEmitted = !0, S(t, i)) : (o(i), t._writableState.errorEmitted = !0, S(t, i), O(t, r))
													}(t, n, i, r, o);
													else {
														var s = M(n) || t.destroyed;
														s || n.corked || n.bufferProcessing || !n.bufferedRequest || C(t, n), i ? e.nextTick(R, t, n, s, o) : R(t, n, s, o)
													}
												}(n, t)
											}, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== r.emitClose, this.autoDestroy = !!r.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new i(this)
										}

										function T(e) {
											var r = this instanceof(o = o || t("./_stream_duplex"));
											if (!r && !u.call(T, this)) return new T(e);
											this._writableState = new k(e, this, r), this.writable = !0, e && ("function" == typeof e.write && (this._write = e.write), "function" == typeof e.writev && (this._writev = e.writev), "function" == typeof e.destroy && (this._destroy = e.destroy), "function" == typeof e.final && (this._final = e.final)), a.call(this)
										}

										function I(e, t, r, n, i, o, s) {
											t.writelen = n, t.writecb = s, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new y("write")) : r ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = !1
										}

										function R(e, t, r, n) {
											r || function(e, t) {
												0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"))
											}(e, t), t.pendingcb--, n(), O(e, t)
										}

										function C(e, t) {
											t.bufferProcessing = !0;
											var r = t.bufferedRequest;
											if (e._writev && r && r.next) {
												var n = t.bufferedRequestCount,
													o = new Array(n),
													s = t.corkedRequestsFree;
												s.entry = r;
												for (var a = 0, c = !0; r;) o[a] = r, r.isBuf || (c = !1), r = r.next, a += 1;
												o.allBuffers = c, I(e, t, !0, t.length, o, "", s.finish), t.pendingcb++, t.lastBufferedRequest = null, s.next ? (t.corkedRequestsFree = s.next, s.next = null) : t.corkedRequestsFree = new i(t), t.bufferedRequestCount = 0
											} else {
												for (; r;) {
													var l = r.chunk,
														u = r.encoding,
														d = r.callback;
													if (I(e, t, !1, t.objectMode ? 1 : l.length, l, u, d), r = r.next, t.bufferedRequestCount--, t.writing) break
												}
												null === r && (t.lastBufferedRequest = null)
											}
											t.bufferedRequest = r, t.bufferProcessing = !1
										}

										function M(e) {
											return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing
										}

										function x(e, t) {
											e._final((function(r) {
												t.pendingcb--, r && S(e, r), t.prefinished = !0, e.emit("prefinish"), O(e, t)
											}))
										}

										function O(t, r) {
											var n = M(r);
											if (n && (function(t, r) {
													r.prefinished || r.finalCalled || ("function" != typeof t._final || r.destroyed ? (r.prefinished = !0, t.emit("prefinish")) : (r.pendingcb++, r.finalCalled = !0, e.nextTick(x, t, r)))
												}(t, r), 0 === r.pendingcb && (r.finished = !0, t.emit("finish"), r.autoDestroy))) {
												var i = t._readableState;
												(!i || i.autoDestroy && i.endEmitted) && t.destroy()
											}
											return n
										}
										t("inherits")(T, a), k.prototype.getBuffer = function() {
												for (var e = this.bufferedRequest, t = []; e;) t.push(e), e = e.next;
												return t
											},
											function() {
												try {
													Object.defineProperty(k.prototype, "buffer", {
														get: s.deprecate((function() {
															return this.getBuffer()
														}), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
													})
												} catch (e) {}
											}(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (u = Function.prototype[Symbol.hasInstance], Object.defineProperty(T, Symbol.hasInstance, {
												value: function(e) {
													return !!u.call(this, e) || this === T && (e && e._writableState instanceof k)
												}
											})) : u = function(e) {
												return e instanceof this
											}, T.prototype.pipe = function() {
												S(this, new m)
											}, T.prototype.write = function(t, r, n) {
												var i, o = this._writableState,
													s = !1,
													a = !o.objectMode && (i = t, c.isBuffer(i) || i instanceof l);
												return a && !c.isBuffer(t) && (t = function(e) {
													return c.from(e)
												}(t)), "function" == typeof r && (n = r, r = null), a ? r = "buffer" : r || (r = o.defaultEncoding), "function" != typeof n && (n = E), o.ending ? function(t, r) {
													var n = new _;
													S(t, n), e.nextTick(r, n)
												}(this, n) : (a || function(t, r, n, i) {
													var o;
													return null === n ? o = new b : "string" == typeof n || r.objectMode || (o = new p("chunk", ["string", "Buffer"], n)), !o || (S(t, o), e.nextTick(i, o), !1)
												}(this, o, t, n)) && (o.pendingcb++, s = function(e, t, r, n, i, o) {
													if (!r) {
														var s = function(e, t, r) {
															e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = c.from(t, r));
															return t
														}(t, n, i);
														n !== s && (r = !0, i = "buffer", n = s)
													}
													var a = t.objectMode ? 1 : n.length;
													t.length += a;
													var l = t.length < t.highWaterMark;
													l || (t.needDrain = !0);
													if (t.writing || t.corked) {
														var u = t.lastBufferedRequest;
														t.lastBufferedRequest = {
															chunk: n,
															encoding: i,
															isBuf: r,
															callback: o,
															next: null
														}, u ? u.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1
													} else I(e, t, !1, a, n, i, o);
													return l
												}(this, o, a, t, r, n)), s
											}, T.prototype.cork = function() {
												this._writableState.corked++
											}, T.prototype.uncork = function() {
												var e = this._writableState;
												e.corked && (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || C(this, e))
											}, T.prototype.setDefaultEncoding = function(e) {
												if ("string" == typeof e && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new w(e);
												return this._writableState.defaultEncoding = e, this
											}, Object.defineProperty(T.prototype, "writableBuffer", {
												enumerable: !1,
												get: function() {
													return this._writableState && this._writableState.getBuffer()
												}
											}), Object.defineProperty(T.prototype, "writableHighWaterMark", {
												enumerable: !1,
												get: function() {
													return this._writableState.highWaterMark
												}
											}), T.prototype._write = function(e, t, r) {
												r(new v("_write()"))
											}, T.prototype._writev = null, T.prototype.end = function(t, r, n) {
												var i = this._writableState;
												return "function" == typeof t ? (n = t, t = null, r = null) : "function" == typeof r && (n = r, r = null), null != t && this.write(t, r), i.corked && (i.corked = 1, this.uncork()), i.ending || function(t, r, n) {
													r.ending = !0, O(t, r), n && (r.finished ? e.nextTick(n) : t.once("finish", n));
													r.ended = !0, t.writable = !1
												}(this, i, n), this
											}, Object.defineProperty(T.prototype, "writableLength", {
												enumerable: !1,
												get: function() {
													return this._writableState.length
												}
											}), Object.defineProperty(T.prototype, "destroyed", {
												enumerable: !1,
												get: function() {
													return void 0 !== this._writableState && this._writableState.destroyed
												},
												set: function(e) {
													this._writableState && (this._writableState.destroyed = e)
												}
											}), T.prototype.destroy = d.destroy, T.prototype._undestroy = d.undestroy, T.prototype._destroy = function(e, t) {
												t(e)
											}
									}).call(this)
								}).call(this, t("_process"), void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"../errors": 266,
								"./_stream_duplex": 267,
								"./internal/streams/destroy": 274,
								"./internal/streams/state": 278,
								"./internal/streams/stream": 279,
								_process: 238,
								buffer: 69,
								inherits: 147,
								"util-deprecate": 283
							}],
							272: [function(e, t, r) {
								(function(r) {
									(function() {
										"use strict";
										var n;

										function i(e, t, r) {
											return t in e ? Object.defineProperty(e, t, {
												value: r,
												enumerable: !0,
												configurable: !0,
												writable: !0
											}) : e[t] = r, e
										}
										var o = e("./end-of-stream"),
											s = Symbol("lastResolve"),
											a = Symbol("lastReject"),
											c = Symbol("error"),
											l = Symbol("ended"),
											u = Symbol("lastPromise"),
											d = Symbol("handlePromise"),
											h = Symbol("stream");

										function f(e, t) {
											return {
												value: e,
												done: t
											}
										}

										function p(e) {
											var t = e[s];
											if (null !== t) {
												var r = e[h].read();
												null !== r && (e[u] = null, e[s] = null, e[a] = null, t(f(r, !1)))
											}
										}

										function v(e) {
											r.nextTick(p, e)
										}
										var g = Object.getPrototypeOf((function() {})),
											m = Object.setPrototypeOf((i(n = {
												get stream() {
													return this[h]
												},
												next: function() {
													var e = this,
														t = this[c];
													if (null !== t) return Promise.reject(t);
													if (this[l]) return Promise.resolve(f(void 0, !0));
													if (this[h].destroyed) return new Promise((function(t, n) {
														r.nextTick((function() {
															e[c] ? n(e[c]) : t(f(void 0, !0))
														}))
													}));
													var n, i = this[u];
													if (i) n = new Promise(function(e, t) {
														return function(r, n) {
															e.then((function() {
																t[l] ? r(f(void 0, !0)) : t[d](r, n)
															}), n)
														}
													}(i, this));
													else {
														var o = this[h].read();
														if (null !== o) return Promise.resolve(f(o, !1));
														n = new Promise(this[d])
													}
													return this[u] = n, n
												}
											}, Symbol.asyncIterator, (function() {
												return this
											})), i(n, "return", (function() {
												var e = this;
												return new Promise((function(t, r) {
													e[h].destroy(null, (function(e) {
														e ? r(e) : t(f(void 0, !0))
													}))
												}))
											})), n), g);
										t.exports = function(e) {
											var t, r = Object.create(m, (i(t = {}, h, {
												value: e,
												writable: !0
											}), i(t, s, {
												value: null,
												writable: !0
											}), i(t, a, {
												value: null,
												writable: !0
											}), i(t, c, {
												value: null,
												writable: !0
											}), i(t, l, {
												value: e._readableState.endEmitted,
												writable: !0
											}), i(t, d, {
												value: function(e, t) {
													var n = r[h].read();
													n ? (r[u] = null, r[s] = null, r[a] = null, e(f(n, !1))) : (r[s] = e, r[a] = t)
												},
												writable: !0
											}), t));
											return r[u] = null, o(e, (function(e) {
												if (e && "ERR_STREAM_PREMATURE_CLOSE" !== e.code) {
													var t = r[a];
													return null !== t && (r[u] = null, r[s] = null, r[a] = null, t(e)), void(r[c] = e)
												}
												var n = r[s];
												null !== n && (r[u] = null, r[s] = null, r[a] = null, n(f(void 0, !0))), r[l] = !0
											})), e.on("readable", v.bind(null, r)), r
										}
									}).call(this)
								}).call(this, e("_process"))
							}, {
								"./end-of-stream": 275,
								_process: 238
							}],
							273: [function(e, t, r) {
								arguments[4][58][0].apply(r, arguments)
							}, {
								buffer: 69,
								dup: 58,
								util: 21
							}],
							274: [function(e, t, r) {
								(function(e) {
									(function() {
										"use strict";

										function r(e, t) {
											i(e, t), n(e)
										}

										function n(e) {
											e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close")
										}

										function i(e, t) {
											e.emit("error", t)
										}
										t.exports = {
											destroy: function(t, o) {
												var s = this,
													a = this._readableState && this._readableState.destroyed,
													c = this._writableState && this._writableState.destroyed;
												return a || c ? (o ? o(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(i, this, t)) : e.nextTick(i, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, (function(t) {
													!o && t ? s._writableState ? s._writableState.errorEmitted ? e.nextTick(n, s) : (s._writableState.errorEmitted = !0, e.nextTick(r, s, t)) : e.nextTick(r, s, t) : o ? (e.nextTick(n, s), o(t)) : e.nextTick(n, s)
												})), this)
											},
											undestroy: function() {
												this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
											},
											errorOrDestroy: function(e, t) {
												var r = e._readableState,
													n = e._writableState;
												r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t)
											}
										}
									}).call(this)
								}).call(this, e("_process"))
							}, {
								_process: 238
							}],
							275: [function(e, t, r) {
								arguments[4][60][0].apply(r, arguments)
							}, {
								"../../../errors": 266,
								dup: 60
							}],
							276: [function(e, t, r) {
								arguments[4][61][0].apply(r, arguments)
							}, {
								dup: 61
							}],
							277: [function(e, t, r) {
								arguments[4][62][0].apply(r, arguments)
							}, {
								"../../../errors": 266,
								"./end-of-stream": 275,
								dup: 62
							}],
							278: [function(e, t, r) {
								arguments[4][63][0].apply(r, arguments)
							}, {
								"../../../errors": 266,
								dup: 63
							}],
							279: [function(e, t, r) {
								arguments[4][64][0].apply(r, arguments)
							}, {
								dup: 64,
								events: 106
							}],
							280: [function(e, t, r) {
								"use strict";
								var n = e("safe-buffer").Buffer,
									i = n.isEncoding || function(e) {
										switch ((e = "" + e) && e.toLowerCase()) {
											case "hex":
											case "utf8":
											case "utf-8":
											case "ascii":
											case "binary":
											case "base64":
											case "ucs2":
											case "ucs-2":
											case "utf16le":
											case "utf-16le":
											case "raw":
												return !0;
											default:
												return !1
										}
									};

								function o(e) {
									var t;
									switch (this.encoding = function(e) {
										var t = function(e) {
											if (!e) return "utf8";
											for (var t;;) switch (e) {
												case "utf8":
												case "utf-8":
													return "utf8";
												case "ucs2":
												case "ucs-2":
												case "utf16le":
												case "utf-16le":
													return "utf16le";
												case "latin1":
												case "binary":
													return "latin1";
												case "base64":
												case "ascii":
												case "hex":
													return e;
												default:
													if (t) return;
													e = ("" + e).toLowerCase(), t = !0
											}
										}(e);
										if ("string" != typeof t && (n.isEncoding === i || !i(e))) throw new Error("Unknown encoding: " + e);
										return t || e
									}(e), this.encoding) {
										case "utf16le":
											this.text = c, this.end = l, t = 4;
											break;
										case "utf8":
											this.fillLast = a, t = 4;
											break;
										case "base64":
											this.text = u, this.end = d, t = 3;
											break;
										default:
											return this.write = h, void(this.end = f)
									}
									this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(t)
								}

								function s(e) {
									return e <= 127 ? 0 : e >> 5 == 6 ? 2 : e >> 4 == 14 ? 3 : e >> 3 == 30 ? 4 : e >> 6 == 2 ? -1 : -2
								}

								function a(e) {
									var t = this.lastTotal - this.lastNeed,
										r = function(e, t, r) {
											if (128 != (192 & t[0])) return e.lastNeed = 0, "";
											if (e.lastNeed > 1 && t.length > 1) {
												if (128 != (192 & t[1])) return e.lastNeed = 1, "";
												if (e.lastNeed > 2 && t.length > 2 && 128 != (192 & t[2])) return e.lastNeed = 2, ""
											}
										}(this, e);
									return void 0 !== r ? r : this.lastNeed <= e.length ? (e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e.copy(this.lastChar, t, 0, e.length), void(this.lastNeed -= e.length))
								}

								function c(e, t) {
									if ((e.length - t) % 2 == 0) {
										var r = e.toString("utf16le", t);
										if (r) {
											var n = r.charCodeAt(r.length - 1);
											if (n >= 55296 && n <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1)
										}
										return r
									}
									return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1)
								}

								function l(e) {
									var t = e && e.length ? this.write(e) : "";
									if (this.lastNeed) {
										var r = this.lastTotal - this.lastNeed;
										return t + this.lastChar.toString("utf16le", 0, r)
									}
									return t
								}

								function u(e, t) {
									var r = (e.length - t) % 3;
									return 0 === r ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, 1 === r ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r))
								}

								function d(e) {
									var t = e && e.length ? this.write(e) : "";
									return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t
								}

								function h(e) {
									return e.toString(this.encoding)
								}

								function f(e) {
									return e && e.length ? this.write(e) : ""
								}
								r.StringDecoder = o, o.prototype.write = function(e) {
									if (0 === e.length) return "";
									var t, r;
									if (this.lastNeed) {
										if (void 0 === (t = this.fillLast(e))) return "";
										r = this.lastNeed, this.lastNeed = 0
									} else r = 0;
									return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || ""
								}, o.prototype.end = function(e) {
									var t = e && e.length ? this.write(e) : "";
									return this.lastNeed ? t + "" : t
								}, o.prototype.text = function(e, t) {
									var r = function(e, t, r) {
										var n = t.length - 1;
										if (n < r) return 0;
										var i = s(t[n]);
										if (i >= 0) return i > 0 && (e.lastNeed = i - 1), i;
										if (--n < r || -2 === i) return 0;
										if ((i = s(t[n])) >= 0) return i > 0 && (e.lastNeed = i - 2), i;
										if (--n < r || -2 === i) return 0;
										if ((i = s(t[n])) >= 0) return i > 0 && (2 === i ? i = 0 : e.lastNeed = i - 3), i;
										return 0
									}(this, e, t);
									if (!this.lastNeed) return e.toString("utf8", t);
									this.lastTotal = r;
									var n = e.length - (r - this.lastNeed);
									return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n)
								}, o.prototype.fillLast = function(e) {
									if (this.lastNeed <= e.length) return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
									e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length
								}
							}, {
								"safe-buffer": 251
							}],
							281: [function(e, t, r) {
								t.exports = {
									0: "O",
									1: "l",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"\u2028": " ",
									"\u2029": " ",
									"": " ",
									"": " ",
									"": " ",
									"": " ",
									"": " ",
									"": " ",
									"": " ",
									"": " ",
									"": " ",
									"": " ",
									"": " ",
									"": " ",
									"": " ",
									"": " ",
									"": " ",
									"": "_",
									"": "_",
									"": "_",
									"": "_",
									"": "-",
									"": "-",
									"": "-",
									"": "-",
									"": "-",
									"": "-",
									"": "-",
									"": "-",
									"": "-",
									"": "-",
									"": "-",
									"": "-",
									"": "-",
									"": "-",
									"": "-",
									"": "-",
									"": "-.",
									"": "",
									"": ",",
									"": ",",
									"": ",",
									"": ",",
									"": ",",
									"": "",
									"": "",
									"": ";",
									"": "",
									"": ":",
									"": ":",
									"": ":",
									"": ":",
									"": ":",
									"": ":",
									"": ":",
									"": ":",
									"": ":",
									"": ":",
									"": ":",
									"": ":",
									"": ":",
									"": ":",
									"": ":",
									"": ":",
									"": ":",
									"": "::=",
									"": ":",
									"": "!",
									"": "!",
									"": "!",
									"": "!!",
									"": "!?",
									"": "?",
									"": "?",
									"": "?",
									"": "?",
									"": "?",
									"": "?!",
									"": "??",
									"": "",
									"": ".",
									"": ".",
									"": ".",
									"": ".",
									"": ".",
									"": ".",
									"": ".",
									"": ".",
									"": ".",
									"": ".,",
									"": "..",
									"": "..",
									"": "...",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "<",
									"": ">",
									"": ">",
									"": ">",
									"": "4",
									"": "b",
									"": "b",
									"": "d",
									"": "J",
									"": "L",
									"": "P",
									"": "U",
									"": "V",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"`": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "'",
									"": "''",
									'"': "''",
									"": "''",
									"": "''",
									"": "''",
									"": "''",
									"": "''",
									"": "''",
									"": "''",
									"": "''",
									"": "''",
									"": "''",
									"": "''",
									"": "''",
									"": "''",
									"": "'''",
									"": "'''",
									"": "''''",
									"": "'B",
									"": "'D",
									"": "'n",
									"": "'P",
									"": "'T",
									"": "'Y",
									"": "(",
									"": "(",
									"": "(",
									"": "(",
									"": "(",
									"": "((",
									"": "()",
									"": "(2)",
									"": "(2O)",
									"": "(3)",
									"": "(4)",
									"": "(5)",
									"": "(6)",
									"": "(7)",
									"": "(8)",
									"": "(9)",
									"": "(a)",
									"": "(A)",
									"": "(b)",
									"": "(B)",
									"": "(c)",
									"": "(C)",
									"": "(d)",
									"": "(D)",
									"": "(e)",
									"": "(E)",
									"": "(f)",
									"": "(F)",
									"": "(g)",
									"": "(G)",
									"": "(h)",
									"": "(H)",
									"": "(i)",
									"": "(j)",
									"": "(J)",
									"": "(k)",
									"": "(K)",
									"": "(l)",
									"": "(l)",
									"": "(l)",
									"": "(L)",
									"": "(l2)",
									"": "(l3)",
									"": "(l4)",
									"": "(l5)",
									"": "(l6)",
									"": "(l7)",
									"": "(l8)",
									"": "(l9)",
									"": "(ll)",
									"": "(lO)",
									"": "(M)",
									"": "(n)",
									"": "(N)",
									"": "(o)",
									"": "(O)",
									"": "(p)",
									"": "(P)",
									"": "(q)",
									"": "(Q)",
									"": "(r)",
									"": "(R)",
									"": "(rn)",
									"": "(s)",
									"": "(S)",
									"": "(S)",
									"": "(t)",
									"": "(T)",
									"": "(u)",
									"": "(U)",
									"": "(v)",
									"": "(V)",
									"": "(w)",
									"": "(W)",
									"": "(x)",
									"": "(X)",
									"": "(y)",
									"": "(Y)",
									"": "(z)",
									"": "(Z)",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": "()",
									"": ")",
									"": ")",
									"": ")",
									"": ")",
									"": ")",
									"": "))",
									"": "{",
									"": "{",
									"": "}",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "*",
									"": "*",
									"": "*",
									"": "*",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "//",
									"": "///",
									"": "\\",
									"": "\\",
									"": "\\",
									"": "\\",
									"": "\\",
									"": "\\",
									"": "\\",
									"": "\\",
									"": "\\",
									"": "\\",
									"": "\\",
									"": "\\\\",
									"": "\\\\",
									"": "\\",
									"": "&",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "^",
									"": "^",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "b",
									"": "bi",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "C",
									"": "F",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "+",
									"": "+",
									"": "+",
									"": "+",
									"": "+",
									"": "+",
									"": "+",
									"": "+",
									"": "+",
									"": "+",
									"": "",
									"": "<",
									"": "<",
									"": "<",
									"": "<",
									"": "<",
									"": "<",
									"": "<",
									"": "<",
									"": "<",
									"": "<<",
									"": "<<<",
									"": "=",
									"": "=",
									"": "=",
									"": "=",
									"": "=",
									"": "=",
									"": "=",
									"": "=",
									"": "=",
									"": "=",
									"": "==",
									"": "===",
									"": "=",
									"": ">",
									"": ">",
									"": ">",
									"": ">",
									"": ">",
									"": ">",
									"": ">",
									"": "><",
									"": ">>",
									"": ">>",
									"": ">>>",
									"": "~",
									"": "~",
									"": "~",
									"": "~",
									"": "~",
									"": "~",
									"": "~",
									"": "~",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "$",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "2",
									"": "2",
									"": "2",
									"": "2",
									"": "2",
									"": "2",
									"": "2",
									"": "2",
									"": "2",
									"": "2",
									"": "2",
									"": "2",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "2",
									"": "2,",
									"": "2.",
									"": "22",
									"": "22",
									"": "23",
									"": "23",
									"": "24",
									"": "24",
									"": "25",
									"": "26",
									"": "27",
									"": "28",
									"": "29",
									"": "2l",
									"": "2l",
									"": "2O.",
									"": "2O",
									"": "2O",
									"": "",
									"": "",
									"": "2",
									"": "2",
									"": "2",
									"": "3",
									"": "3",
									"": "3",
									"": "3",
									"": "3",
									"": "3",
									"": "3",
									"": "3",
									"": "3",
									"": "3",
									"": "3",
									"": "3",
									"": "3",
									"": "3",
									"": "3",
									"": "3",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "3",
									"": "3,",
									"": "3.",
									"": "3l",
									"": "3O",
									"": "3",
									"": "3",
									"": "3",
									"": "4",
									"": "4",
									"": "4",
									"": "4",
									"": "4",
									"": "4",
									"": "4",
									"": "4",
									"": "",
									"": "",
									"": "",
									"": "4,",
									"": "4.",
									"": "4",
									"": "4",
									"": "4",
									"": "4",
									"": "5",
									"": "5",
									"": "5",
									"": "5",
									"": "5",
									"": "5",
									"": "5",
									"": "5",
									"": "",
									"": "5,",
									"": "5.",
									"": "5",
									"": "5",
									"": "5",
									"": "6",
									"": "6",
									"": "6",
									"": "6",
									"": "6",
									"": "6",
									"": "6",
									"": "6",
									"": "6",
									"": "6",
									"": "",
									"": "",
									"": "",
									"": "6,",
									"": "6.",
									"": "6",
									"": "6",
									"": "6",
									"": "7",
									"": "7",
									"": "7",
									"": "7",
									"": "7",
									"": "7",
									"": "7",
									"": "7",
									"": "7",
									"": "",
									"": "7,",
									"": "7.",
									"": "7",
									"": "7",
									"": "7",
									"": "8",
									"": "8",
									"": "8",
									"": "8",
									"": "8",
									"": "8",
									"": "8",
									"": "8",
									"": "8",
									"": "8",
									"": "8",
									"": "8",
									"": "8",
									"": "",
									"": "",
									"": "8,",
									"": "8.",
									"": "8",
									"": "8",
									"": "8",
									"": "9",
									"": "9",
									"": "9",
									"": "9",
									"": "9",
									"": "9",
									"": "9",
									"": "9",
									"": "9",
									"": "9",
									"": "9",
									"": "9",
									"": "9",
									"": "9",
									"": "9",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "9,",
									"": "9.",
									"": "9",
									"": "9",
									"": "9",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "a",
									"": "",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "A",
									"": "a",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "a/c",
									"": "a/s",
									"": "aa",
									"": "AA",
									"": "ae",
									"": "ae",
									"": "AE",
									"": "AE",
									"": "ao",
									"": "AO",
									"": "AR",
									"": "au",
									"": "AU",
									"": "av",
									"": "av",
									"": "AV",
									"": "AV",
									"": "ay",
									"": "AY",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "B",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b",
									"": "b'",
									"": "bl",
									"": "",
									"": "",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "c",
									"": "",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "C",
									"": "c",
									"": "c",
									"": "C",
									"": "C",
									"": "c",
									"": "c",
									"": "C",
									"": "C",
									"": "C'",
									"": "c/o",
									"": "c/u",
									"": "\t",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "D",
									"": "d",
									"": "d",
									"": "d",
									"": "d",
									"": "D",
									"": "D",
									"": "D",
									"": "d",
									"": "",
									"": "d",
									"": "d'",
									"": "d",
									"": "dz",
									"": "dz",
									"": "Dz",
									"": "DZ",
									"": "d",
									"": "D",
									"": "D",
									"": "d",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "e",
									"": "",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "E",
									"": "",
									"": "",
									"": "e",
									"": "E",
									"": "e",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "o",
									"": "o",
									"": "o",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "f",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "F",
									"": "f",
									"": "F",
									"": "f",
									"": "FAX",
									"": "ff",
									"": "ffi",
									"": "ffl",
									"": "fi",
									"": "fl",
									"": "f",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "g",
									"": "G",
									"": "G",
									"": "G",
									"": "G",
									"": "G",
									"": "G",
									"": "G",
									"": "G",
									"": "G",
									"": "G",
									"": "G",
									"": "G",
									"": "G",
									"": "G",
									"": "G",
									"": "G",
									"": "G",
									"": "",
									"": "g",
									"": "",
									"": "",
									"": "",
									"": "g",
									"": "G",
									"": "G'",
									"": "",
									"": "",
									"": "",
									"": "h",
									"": "h",
									"": "h",
									"": "h",
									"": "h",
									"": "h",
									"": "h",
									"": "h",
									"": "h",
									"": "h",
									"": "h",
									"": "h",
									"": "h",
									"": "h",
									"": "h",
									"": "h",
									"": "h",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "H",
									"": "",
									"": "h",
									"": "h",
									"": "h",
									"": "H",
									"": "H",
									"": "h",
									"": "h",
									"": "h",
									"": "H",
									"": "H",
									"": "H",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "i",
									"": "",
									"": "i",
									"": "",
									"": "",
									"": "i",
									"": "i",
									"": "i",
									"": "ii",
									"": "iii",
									"": "ij",
									"": "iv",
									"": "ix",
									"": "j",
									"": "j",
									"": "j",
									"": "j",
									"": "j",
									"": "j",
									"": "j",
									"": "j",
									"": "j",
									"": "j",
									"": "j",
									"": "j",
									"": "j",
									"": "j",
									"": "j",
									"": "j",
									"": "j",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "J",
									"": "j",
									"": "J",
									"": "J",
									"": "",
									"": "",
									"": "",
									"": "k",
									"": "k",
									"": "k",
									"": "k",
									"": "k",
									"": "k",
									"": "k",
									"": "k",
									"": "k",
									"": "k",
									"": "k",
									"": "k",
									"": "k",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "k",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K",
									"": "K'",
									"": "l",
									"|": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									I: "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "L",
									"": "l",
									"": "l",
									"": "l",
									"": "L",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l,",
									"": "l.",
									"": "l'",
									"": "l2.",
									"": "l2",
									"": "l2",
									"": "l2",
									"": "l3.",
									"": "l3",
									"": "l3",
									"": "l4.",
									"": "l4",
									"": "l4",
									"": "l5.",
									"": "l5",
									"": "l5",
									"": "l6.",
									"": "l6",
									"": "l6",
									"": "l7.",
									"": "l7",
									"": "l7",
									"": "l8.",
									"": "l8",
									"": "l8",
									"": "l9.",
									"": "l9",
									"": "l9",
									"": "lj",
									"": "lJ",
									"": "Lj",
									"": "LJ",
									"": "ll",
									"": "ll",
									"": "ll",
									"": "ll",
									"": "ll",
									"": "ll",
									"": "ll.",
									"": "lll",
									"": "llS",
									"": "ll",
									"": "ll",
									"": "ll",
									"": "lO",
									"": "lO.",
									"": "lO",
									"": "lO",
									"": "lO",
									"": "ls",
									"": "lt",
									"": "lV",
									"": "lX",
									"": "l",
									"": "lz",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "lo",
									"": "l",
									"": "l",
									"": "l",
									"": "",
									"": "",
									"": "",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "M",
									"": "MB",
									"": "",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "N",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "n",
									"": "N",
									"": "n",
									"": "nj",
									"": "Nj",
									"": "NJ",
									"": "No",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "o",
									"": "",
									"": "o",
									"": "o",
									"": "O",
									"": "O",
									"": "O",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "O",
									"": "o",
									"": "o",
									"": "O,",
									"": "O.",
									"": "o'",
									"": "O'",
									"": "O'",
									"%": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "/",
									"": "oe",
									"": "OE",
									"": "o",
									"": "oo",
									"": "oo",
									"": "oo",
									"": "OO",
									"": "OO",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "oo",
									"": "o",
									"": "O",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "e",
									"": "",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "p",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "P",
									"": "p",
									"": "p",
									"": "p",
									"": "P'",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "q",
									"": "q",
									"": "q",
									"": "q",
									"": "q",
									"": "q",
									"": "q",
									"": "q",
									"": "q",
									"": "q",
									"": "q",
									"": "q",
									"": "q",
									"": "q",
									"": "q",
									"": "q",
									"": "Q",
									"": "Q",
									"": "Q",
									"": "Q",
									"": "Q",
									"": "Q",
									"": "Q",
									"": "Q",
									"": "Q",
									"": "Q",
									"": "Q",
									"": "Q",
									"": "Q",
									"": "Q",
									"": "q",
									"": "QE",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "R",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r",
									"": "r'",
									"": "rn",
									m: "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "rn",
									"": "Rs",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "s",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "S",
									"": "s",
									"": "s",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "sss",
									"": "st",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "t",
									"": "t",
									"": "t",
									"": "t",
									"": "t",
									"": "t",
									"": "t",
									"": "t",
									"": "t",
									"": "t",
									"": "t",
									"": "t",
									"": "t",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "T",
									"": "t",
									"": "T",
									"": "T",
									"": "",
									"": "T",
									"": "T",
									"": "T",
									"": "t",
									"": "T",
									"": "t",
									"": "",
									"": "T3",
									"": "t",
									"": "TEL",
									"": "tf",
									"": "ts",
									"": "t",
									"": "t",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "u",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "U",
									"": "",
									"": "",
									"": "u",
									"": "u",
									"": "U",
									"": "U",
									"": "U",
									"": "U'",
									"": "ue",
									"": "uo",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "v",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "V",
									"": "VB",
									"": "vi",
									"": "vii",
									"": "viii",
									"": "Vl",
									"": "Vll",
									"": "Vlll",
									"": "V",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "w",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "W",
									"": "w",
									"": "w",
									"": "W",
									"": "w",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "x",
									"": "",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "X",
									"": "x",
									"": "X",
									"": "X",
									"": "xi",
									"": "xii",
									"": "Xl",
									"": "Xll",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "y",
									"": "y",
									"": "y",
									"": "Y",
									"": "Y",
									"": "Y",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "z",
									"": "z",
									"": "z",
									"": "z",
									"": "z",
									"": "z",
									"": "z",
									"": "z",
									"": "z",
									"": "z",
									"": "z",
									"": "z",
									"": "z",
									"": "z",
									"": "z",
									"": "z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "Z",
									"": "z",
									"": "z",
									"": "Z",
									"": "z",
									"": "Z",
									"": "z",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "i",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "'",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "l",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "'",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "o",
									"": "o",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "o",
									"": "o",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": " lo",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "l",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": " lo o ",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "o",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "l",
									"": "l",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "l",
									"": "o",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "l",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "o",
									"": "o",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "o",
									"": "o",
									"": "o",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "l",
									"": "l",
									"": "o",
									"": "o",
									"": "o",
									"": "o",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "'",
									"": "/",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "'",
									"": "",
									"": "",
									"": "'",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "<",
									"": "b",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "b",
									"": "b",
									"": "d",
									"": "P",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "J",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "J",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": "",
									"": ""
								}
							}, {}],
							282: [function(e, t, r) {
								"use strict";
								var n = e("./data.json");
								var i = RegExp(Object.keys(n).map((function(e) {
									return e.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1")
								})).join("|"), "g");

								function o(e) {
									return n[e]
								}
								t.exports = function(e) {
									return e.replace(i, o)
								}
							}, {
								"./data.json": 281
							}],
							283: [function(t, r, n) {
								(function(e) {
									(function() {
										function t(t) {
											try {
												if (!e.localStorage) return !1
											} catch (n) {
												return !1
											}
											var r = e.localStorage[t];
											return null != r && "true" === String(r).toLowerCase()
										}
										r.exports = function(e, r) {
											if (t("noDeprecation")) return e;
											var n = !1;
											return function() {
												if (!n) {
													if (t("throwDeprecation")) throw new Error(r);
													t("traceDeprecation") ? console.trace(r) : console.warn(r), n = !0
												}
												return e.apply(this, arguments)
											}
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {}],
							284: [function(e, t, r) {
								t.exports = function(e) {
									return e && "object" == typeof e && "function" == typeof e.copy && "function" == typeof e.fill && "function" == typeof e.readUInt8
								}
							}, {}],
							285: [function(e, t, r) {
								"use strict";
								var n = e("is-arguments"),
									i = e("is-generator-function"),
									o = e("which-typed-array"),
									s = e("is-typed-array");

								function a(e) {
									return e.call.bind(e)
								}
								var c = "undefined" != typeof BigInt,
									l = "undefined" != typeof Symbol,
									u = a(Object.prototype.toString),
									d = a(Number.prototype.valueOf),
									h = a(String.prototype.valueOf),
									f = a(Boolean.prototype.valueOf);
								if (c) var p = a(BigInt.prototype.valueOf);
								if (l) var v = a(Symbol.prototype.valueOf);

								function g(e, t) {
									if ("object" != typeof e) return !1;
									try {
										return t(e), !0
									} catch (r) {
										return !1
									}
								}

								function m(e) {
									return "[object Map]" === u(e)
								}

								function y(e) {
									return "[object Set]" === u(e)
								}

								function b(e) {
									return "[object WeakMap]" === u(e)
								}

								function _(e) {
									return "[object WeakSet]" === u(e)
								}

								function w(e) {
									return "[object ArrayBuffer]" === u(e)
								}

								function S(e) {
									return "undefined" != typeof ArrayBuffer && (w.working ? w(e) : e instanceof ArrayBuffer)
								}

								function E(e) {
									return "[object DataView]" === u(e)
								}

								function k(e) {
									return "undefined" != typeof DataView && (E.working ? E(e) : e instanceof DataView)
								}
								r.isArgumentsObject = n, r.isGeneratorFunction = i, r.isTypedArray = s, r.isPromise = function(e) {
									return "undefined" != typeof Promise && e instanceof Promise || null !== e && "object" == typeof e && "function" == typeof e.then && "function" == typeof e.catch
								}, r.isArrayBufferView = function(e) {
									return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : s(e) || k(e)
								}, r.isUint8Array = function(e) {
									return "Uint8Array" === o(e)
								}, r.isUint8ClampedArray = function(e) {
									return "Uint8ClampedArray" === o(e)
								}, r.isUint16Array = function(e) {
									return "Uint16Array" === o(e)
								}, r.isUint32Array = function(e) {
									return "Uint32Array" === o(e)
								}, r.isInt8Array = function(e) {
									return "Int8Array" === o(e)
								}, r.isInt16Array = function(e) {
									return "Int16Array" === o(e)
								}, r.isInt32Array = function(e) {
									return "Int32Array" === o(e)
								}, r.isFloat32Array = function(e) {
									return "Float32Array" === o(e)
								}, r.isFloat64Array = function(e) {
									return "Float64Array" === o(e)
								}, r.isBigInt64Array = function(e) {
									return "BigInt64Array" === o(e)
								}, r.isBigUint64Array = function(e) {
									return "BigUint64Array" === o(e)
								}, m.working = "undefined" != typeof Map && m(new Map), r.isMap = function(e) {
									return "undefined" != typeof Map && (m.working ? m(e) : e instanceof Map)
								}, y.working = "undefined" != typeof Set && y(new Set), r.isSet = function(e) {
									return "undefined" != typeof Set && (y.working ? y(e) : e instanceof Set)
								}, b.working = "undefined" != typeof WeakMap && b(new WeakMap), r.isWeakMap = function(e) {
									return "undefined" != typeof WeakMap && (b.working ? b(e) : e instanceof WeakMap)
								}, _.working = "undefined" != typeof WeakSet && _(new WeakSet), r.isWeakSet = function(e) {
									return _(e)
								}, w.working = "undefined" != typeof ArrayBuffer && w(new ArrayBuffer), r.isArrayBuffer = S, E.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && E(new DataView(new ArrayBuffer(1), 0, 1)), r.isDataView = k;
								var T = "undefined" != typeof SharedArrayBuffer ? SharedArrayBuffer : void 0;

								function I(e) {
									return "[object SharedArrayBuffer]" === u(e)
								}

								function R(e) {
									return void 0 !== T && (void 0 === I.working && (I.working = I(new T)), I.working ? I(e) : e instanceof T)
								}

								function C(e) {
									return g(e, d)
								}

								function M(e) {
									return g(e, h)
								}

								function x(e) {
									return g(e, f)
								}

								function O(e) {
									return c && g(e, p)
								}

								function A(e) {
									return l && g(e, v)
								}
								r.isSharedArrayBuffer = R, r.isAsyncFunction = function(e) {
									return "[object AsyncFunction]" === u(e)
								}, r.isMapIterator = function(e) {
									return "[object Map Iterator]" === u(e)
								}, r.isSetIterator = function(e) {
									return "[object Set Iterator]" === u(e)
								}, r.isGeneratorObject = function(e) {
									return "[object Generator]" === u(e)
								}, r.isWebAssemblyCompiledModule = function(e) {
									return "[object WebAssembly.Module]" === u(e)
								}, r.isNumberObject = C, r.isStringObject = M, r.isBooleanObject = x, r.isBigIntObject = O, r.isSymbolObject = A, r.isBoxedPrimitive = function(e) {
									return C(e) || M(e) || x(e) || O(e) || A(e)
								}, r.isAnyArrayBuffer = function(e) {
									return "undefined" != typeof Uint8Array && (S(e) || R(e))
								}, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach((function(e) {
									Object.defineProperty(r, e, {
										enumerable: !1,
										value: function() {
											throw new Error(e + " is not supported in userland")
										}
									})
								}))
							}, {
								"is-arguments": 148,
								"is-generator-function": 150,
								"is-typed-array": 151,
								"which-typed-array": 287
							}],
							286: [function(e, t, r) {
								(function(t) {
									(function() {
										var n = Object.getOwnPropertyDescriptors || function(e) {
												for (var t = Object.keys(e), r = {}, n = 0; n < t.length; n++) r[t[n]] = Object.getOwnPropertyDescriptor(e, t[n]);
												return r
											},
											i = /%[sdj%]/g;
										r.format = function(e) {
											if (!y(e)) {
												for (var t = [], r = 0; r < arguments.length; r++) t.push(c(arguments[r]));
												return t.join(" ")
											}
											r = 1;
											for (var n = arguments, o = n.length, s = String(e).replace(i, (function(e) {
													if ("%%" === e) return "%";
													if (r >= o) return e;
													switch (e) {
														case "%s":
															return String(n[r++]);
														case "%d":
															return Number(n[r++]);
														case "%j":
															try {
																return JSON.stringify(n[r++])
															} catch (t) {
																return "[Circular]"
															}
															default:
																return e
													}
												})), a = n[r]; r < o; a = n[++r]) g(a) || !w(a) ? s += " " + a : s += " " + c(a);
											return s
										}, r.deprecate = function(e, n) {
											if (void 0 !== t && !0 === t.noDeprecation) return e;
											if (void 0 === t) return function() {
												return r.deprecate(e, n).apply(this, arguments)
											};
											var i = !1;
											return function() {
												if (!i) {
													if (t.throwDeprecation) throw new Error(n);
													t.traceDeprecation ? console.trace(n) : console.error(n), i = !0
												}
												return e.apply(this, arguments)
											}
										};
										var o = {},
											s = /^$/;
										if (t.env.NODE_DEBUG) {
											var a = t.env.NODE_DEBUG;
											a = a.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), s = new RegExp("^" + a + "$", "i")
										}

										function c(e, t) {
											var n = {
												seen: [],
												stylize: u
											};
											return arguments.length >= 3 && (n.depth = arguments[2]), arguments.length >= 4 && (n.colors = arguments[3]), v(t) ? n.showHidden = t : t && r._extend(n, t), b(n.showHidden) && (n.showHidden = !1), b(n.depth) && (n.depth = 2), b(n.colors) && (n.colors = !1), b(n.customInspect) && (n.customInspect = !0), n.colors && (n.stylize = l), d(n, e, n.depth)
										}

										function l(e, t) {
											var r = c.styles[t];
											return r ? "[" + c.colors[r][0] + "m" + e + "[" + c.colors[r][1] + "m" : e
										}

										function u(e, t) {
											return e
										}

										function d(e, t, n) {
											if (e.customInspect && t && k(t.inspect) && t.inspect !== r.inspect && (!t.constructor || t.constructor.prototype !== t)) {
												var i = t.inspect(n, e);
												return y(i) || (i = d(e, i, n)), i
											}
											var o = function(e, t) {
												if (b(t)) return e.stylize("undefined", "undefined");
												if (y(t)) {
													var r = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
													return e.stylize(r, "string")
												}
												if (m(t)) return e.stylize("" + t, "number");
												if (v(t)) return e.stylize("" + t, "boolean");
												if (g(t)) return e.stylize("null", "null")
											}(e, t);
											if (o) return o;
											var s = Object.keys(t),
												a = function(e) {
													var t = {};
													return e.forEach((function(e, r) {
														t[e] = !0
													})), t
												}(s);
											if (e.showHidden && (s = Object.getOwnPropertyNames(t)), E(t) && (s.indexOf("message") >= 0 || s.indexOf("description") >= 0)) return h(t);
											if (0 === s.length) {
												if (k(t)) {
													var c = t.name ? ": " + t.name : "";
													return e.stylize("[Function" + c + "]", "special")
												}
												if (_(t)) return e.stylize(RegExp.prototype.toString.call(t), "regexp");
												if (S(t)) return e.stylize(Date.prototype.toString.call(t), "date");
												if (E(t)) return h(t)
											}
											var l, u = "",
												w = !1,
												T = ["{", "}"];
											(p(t) && (w = !0, T = ["[", "]"]), k(t)) && (u = " [Function" + (t.name ? ": " + t.name : "") + "]");
											return _(t) && (u = " " + RegExp.prototype.toString.call(t)), S(t) && (u = " " + Date.prototype.toUTCString.call(t)), E(t) && (u = " " + h(t)), 0 !== s.length || w && 0 != t.length ? n < 0 ? _(t) ? e.stylize(RegExp.prototype.toString.call(t), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(t), l = w ? function(e, t, r, n, i) {
												for (var o = [], s = 0, a = t.length; s < a; ++s) M(t, String(s)) ? o.push(f(e, t, r, n, String(s), !0)) : o.push("");
												return i.forEach((function(i) {
													i.match(/^\d+$/) || o.push(f(e, t, r, n, i, !0))
												})), o
											}(e, t, n, a, s) : s.map((function(r) {
												return f(e, t, n, a, r, w)
											})), e.seen.pop(), function(e, t, r) {
												if (e.reduce((function(e, t) {
														return 0, t.indexOf("\n") >= 0 && 0, e + t.replace(/\u001b\[\d\d?m/g, "").length + 1
													}), 0) > 60) return r[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + r[1];
												return r[0] + t + " " + e.join(", ") + " " + r[1]
											}(l, u, T)) : T[0] + u + T[1]
										}

										function h(e) {
											return "[" + Error.prototype.toString.call(e) + "]"
										}

										function f(e, t, r, n, i, o) {
											var s, a, c;
											if ((c = Object.getOwnPropertyDescriptor(t, i) || {
													value: t[i]
												}).get ? a = c.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : c.set && (a = e.stylize("[Setter]", "special")), M(n, i) || (s = "[" + i + "]"), a || (e.seen.indexOf(c.value) < 0 ? (a = g(r) ? d(e, c.value, null) : d(e, c.value, r - 1)).indexOf("\n") > -1 && (a = o ? a.split("\n").map((function(e) {
													return "  " + e
												})).join("\n").slice(2) : "\n" + a.split("\n").map((function(e) {
													return "   " + e
												})).join("\n")) : a = e.stylize("[Circular]", "special")), b(s)) {
												if (o && i.match(/^\d+$/)) return a;
												(s = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.slice(1, -1), s = e.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = e.stylize(s, "string"))
											}
											return s + ": " + a
										}

										function p(e) {
											return Array.isArray(e)
										}

										function v(e) {
											return "boolean" == typeof e
										}

										function g(e) {
											return null === e
										}

										function m(e) {
											return "number" == typeof e
										}

										function y(e) {
											return "string" == typeof e
										}

										function b(e) {
											return void 0 === e
										}

										function _(e) {
											return w(e) && "[object RegExp]" === T(e)
										}

										function w(e) {
											return "object" == typeof e && null !== e
										}

										function S(e) {
											return w(e) && "[object Date]" === T(e)
										}

										function E(e) {
											return w(e) && ("[object Error]" === T(e) || e instanceof Error)
										}

										function k(e) {
											return "function" == typeof e
										}

										function T(e) {
											return Object.prototype.toString.call(e)
										}

										function I(e) {
											return e < 10 ? "0" + e.toString(10) : e.toString(10)
										}
										r.debuglog = function(e) {
											if (e = e.toUpperCase(), !o[e])
												if (s.test(e)) {
													var n = t.pid;
													o[e] = function() {
														var t = r.format.apply(r, arguments);
														console.error("%s %d: %s", e, n, t)
													}
												} else o[e] = function() {};
											return o[e]
										}, r.inspect = c, c.colors = {
											bold: [1, 22],
											italic: [3, 23],
											underline: [4, 24],
											inverse: [7, 27],
											white: [37, 39],
											grey: [90, 39],
											black: [30, 39],
											blue: [34, 39],
											cyan: [36, 39],
											green: [32, 39],
											magenta: [35, 39],
											red: [31, 39],
											yellow: [33, 39]
										}, c.styles = {
											special: "cyan",
											number: "yellow",
											boolean: "yellow",
											undefined: "grey",
											null: "bold",
											string: "green",
											date: "magenta",
											regexp: "red"
										}, r.types = e("./support/types"), r.isArray = p, r.isBoolean = v, r.isNull = g, r.isNullOrUndefined = function(e) {
											return null == e
										}, r.isNumber = m, r.isString = y, r.isSymbol = function(e) {
											return "symbol" == typeof e
										}, r.isUndefined = b, r.isRegExp = _, r.types.isRegExp = _, r.isObject = w, r.isDate = S, r.types.isDate = S, r.isError = E, r.types.isNativeError = E, r.isFunction = k, r.isPrimitive = function(e) {
											return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e
										}, r.isBuffer = e("./support/isBuffer");
										var R = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

										function C() {
											var e = new Date,
												t = [I(e.getHours()), I(e.getMinutes()), I(e.getSeconds())].join(":");
											return [e.getDate(), R[e.getMonth()], t].join(" ")
										}

										function M(e, t) {
											return Object.prototype.hasOwnProperty.call(e, t)
										}
										r.log = function() {
											console.log("%s - %s", C(), r.format.apply(r, arguments))
										}, r.inherits = e("inherits"), r._extend = function(e, t) {
											if (!t || !w(t)) return e;
											for (var r = Object.keys(t), n = r.length; n--;) e[r[n]] = t[r[n]];
											return e
										};
										var x = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;

										function O(e, t) {
											if (!e) {
												var r = new Error("Promise was rejected with a falsy value");
												r.reason = e, e = r
											}
											return t(e)
										}
										r.promisify = function(e) {
											if ("function" != typeof e) throw new TypeError('The "original" argument must be of type Function');
											if (x && e[x]) {
												var t;
												if ("function" != typeof(t = e[x])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
												return Object.defineProperty(t, x, {
													value: t,
													enumerable: !1,
													writable: !1,
													configurable: !0
												}), t
											}

											function t() {
												for (var t, r, n = new Promise((function(e, n) {
														t = e, r = n
													})), i = [], o = 0; o < arguments.length; o++) i.push(arguments[o]);
												i.push((function(e, n) {
													e ? r(e) : t(n)
												}));
												try {
													e.apply(this, i)
												} catch (s) {
													r(s)
												}
												return n
											}
											return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), x && Object.defineProperty(t, x, {
												value: t,
												enumerable: !1,
												writable: !1,
												configurable: !0
											}), Object.defineProperties(t, n(e))
										}, r.promisify.custom = x, r.callbackify = function(e) {
											if ("function" != typeof e) throw new TypeError('The "original" argument must be of type Function');

											function r() {
												for (var r = [], n = 0; n < arguments.length; n++) r.push(arguments[n]);
												var i = r.pop();
												if ("function" != typeof i) throw new TypeError("The last argument must be of type Function");
												var o = this,
													s = function() {
														return i.apply(o, arguments)
													};
												e.apply(this, r).then((function(e) {
													t.nextTick(s.bind(null, null, e))
												}), (function(e) {
													t.nextTick(O.bind(null, e, s))
												}))
											}
											return Object.setPrototypeOf(r, Object.getPrototypeOf(e)), Object.defineProperties(r, n(e)), r
										}
									}).call(this)
								}).call(this, e("_process"))
							}, {
								"./support/isBuffer": 284,
								"./support/types": 285,
								_process: 238,
								inherits: 147
							}],
							287: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var n = t("for-each"),
											i = t("available-typed-arrays"),
											o = t("call-bind/callBound"),
											s = t("gopd"),
											a = o("Object.prototype.toString"),
											c = t("has-tostringtag/shams")(),
											l = "undefined" == typeof globalThis ? e : globalThis,
											u = i(),
											d = o("String.prototype.slice"),
											h = {},
											f = Object.getPrototypeOf;
										c && s && f && n(u, (function(e) {
											if ("function" == typeof l[e]) {
												var t = new l[e];
												if (Symbol.toStringTag in t) {
													var r = f(t),
														n = s(r, Symbol.toStringTag);
													if (!n) {
														var i = f(r);
														n = s(i, Symbol.toStringTag)
													}
													h[e] = n.get
												}
											}
										}));
										var p = t("is-typed-array");
										r.exports = function(e) {
											return !!p(e) && (c && Symbol.toStringTag in e ? function(e) {
												var t = !1;
												return n(h, (function(r, n) {
													if (!t) try {
														var i = r.call(e);
														i === n && (t = i)
													} catch (o) {}
												})), t
											}(e) : d(a(e), 8, -1))
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"available-typed-arrays": 17,
								"call-bind/callBound": 70,
								"for-each": 108,
								gopd: 112,
								"has-tostringtag/shams": 115,
								"is-typed-array": 151
							}],
							288: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.RuleId = r.PushRuleKind = r.ConditionKind = r.isDmMemberCountCondition = r.DMMemberCountCondition = r.ConditionOperator = r.TweakName = r.PushRuleActionName = void 0,
									function(e) {
										e.DontNotify = "dont_notify", e.Notify = "notify", e.Coalesce = "coalesce"
									}(r.PushRuleActionName || (r.PushRuleActionName = {})),
									function(e) {
										e.Highlight = "highlight", e.Sound = "sound"
									}(r.TweakName || (r.TweakName = {})),
									function(e) {
										e.ExactEquals = "==", e.LessThan = "<", e.GreaterThan = ">", e.GreaterThanOrEqual = ">=", e.LessThanOrEqual = "<="
									}(r.ConditionOperator || (r.ConditionOperator = {})), r.DMMemberCountCondition = "2", r.isDmMemberCountCondition = function(e) {
										return "==2" === e || "2" === e
									},
									function(e) {
										e.EventMatch = "event_match", e.ContainsDisplayName = "contains_display_name", e.RoomMemberCount = "room_member_count", e.SenderNotificationPermission = "sender_notification_permission", e.CallStarted = "call_started", e.CallStartedPrefix = "org.matrix.msc3914.call_started"
									}(r.ConditionKind || (r.ConditionKind = {})),
									function(e) {
										e.Override = "override", e.ContentSpecific = "content", e.RoomSpecific = "room", e.SenderSpecific = "sender", e.Underride = "underride"
									}(r.PushRuleKind || (r.PushRuleKind = {})),
									function(e) {
										e.Master = ".m.rule.master", e.ContainsDisplayName = ".m.rule.contains_display_name", e.ContainsUserName = ".m.rule.contains_user_name", e.AtRoomNotification = ".m.rule.roomnotif", e.DM = ".m.rule.room_one_to_one", e.EncryptedDM = ".m.rule.encrypted_room_one_to_one", e.Message = ".m.rule.message", e.EncryptedMessage = ".m.rule.encrypted", e.InviteToSelf = ".m.rule.invite_for_me", e.MemberEvent = ".m.rule.member_event", e.IncomingCall = ".m.rule.call", e.SuppressNotices = ".m.rule.suppress_notices", e.Tombstone = ".m.rule.tombstone"
									}(r.RuleId || (r.RuleId = {}))
							}, {}],
							289: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.M_BEACON = r.M_BEACON_INFO = void 0;
								const n = e("../NamespacedValue");
								r.M_BEACON_INFO = new n.UnstableValue("m.beacon_info", "org.matrix.msc3672.beacon_info"), r.M_BEACON = new n.UnstableValue("m.beacon", "org.matrix.msc3672.beacon")
							}, {
								"../NamespacedValue": 299
							}],
							290: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.LOCAL_NOTIFICATION_SETTINGS_PREFIX = r.PUSHER_DEVICE_ID = r.PUSHER_ENABLED = r.EVENT_VISIBILITY_CHANGE_TYPE = r.UNSTABLE_ELEMENT_FUNCTIONAL_USERS = r.UNSTABLE_MSC2716_MARKER = r.UNSTABLE_MSC3089_BRANCH = r.UNSTABLE_MSC3089_LEAF = r.UNSTABLE_MSC3089_TREE_SUBTYPE = r.UNSTABLE_MSC3088_ENABLED = r.UNSTABLE_MSC3088_PURPOSE = r.RoomType = r.RoomCreateTypeField = r.MsgType = r.RelationType = r.EventType = void 0;
								const n = e("../NamespacedValue");
								! function(e) {
									e.RoomCanonicalAlias = "m.room.canonical_alias", e.RoomCreate = "m.room.create", e.RoomJoinRules = "m.room.join_rules", e.RoomMember = "m.room.member", e.RoomThirdPartyInvite = "m.room.third_party_invite", e.RoomPowerLevels = "m.room.power_levels", e.RoomName = "m.room.name", e.RoomTopic = "m.room.topic", e.RoomAvatar = "m.room.avatar", e.RoomPinnedEvents = "m.room.pinned_events", e.RoomEncryption = "m.room.encryption", e.RoomHistoryVisibility = "m.room.history_visibility", e.RoomGuestAccess = "m.room.guest_access", e.RoomServerAcl = "m.room.server_acl", e.RoomTombstone = "m.room.tombstone", e.SpaceChild = "m.space.child", e.SpaceParent = "m.space.parent", e.RoomRedaction = "m.room.redaction", e.RoomMessage = "m.room.message", e.RoomMessageEncrypted = "m.room.encrypted", e.Sticker = "m.sticker", e.CallInvite = "m.call.invite", e.CallCandidates = "m.call.candidates", e.CallAnswer = "m.call.answer", e.CallHangup = "m.call.hangup", e.CallReject = "m.call.reject", e.CallSelectAnswer = "m.call.select_answer", e.CallNegotiate = "m.call.negotiate", e.CallSDPStreamMetadataChanged = "m.call.sdp_stream_metadata_changed", e.CallSDPStreamMetadataChangedPrefix = "org.matrix.call.sdp_stream_metadata_changed", e.CallReplaces = "m.call.replaces", e.CallAssertedIdentity = "m.call.asserted_identity", e.CallAssertedIdentityPrefix = "org.matrix.call.asserted_identity", e.KeyVerificationRequest = "m.key.verification.request", e.KeyVerificationStart = "m.key.verification.start", e.KeyVerificationCancel = "m.key.verification.cancel", e.KeyVerificationMac = "m.key.verification.mac", e.KeyVerificationDone = "m.key.verification.done", e.KeyVerificationKey = "m.key.verification.key", e.KeyVerificationAccept = "m.key.verification.accept", e.KeyVerificationReady = "m.key.verification.ready", e.RoomMessageFeedback = "m.room.message.feedback", e.Reaction = "m.reaction", e.Typing = "m.typing", e.Receipt = "m.receipt", e.Presence = "m.presence", e.FullyRead = "m.fully_read", e.Tag = "m.tag", e.SpaceOrder = "org.matrix.msc3230.space_order", e.PushRules = "m.push_rules", e.Direct = "m.direct", e.IgnoredUserList = "m.ignored_user_list", e.RoomKey = "m.room_key", e.RoomKeyRequest = "m.room_key_request", e.ForwardedRoomKey = "m.forwarded_room_key", e.Dummy = "m.dummy", e.GroupCallPrefix = "org.matrix.msc3401.call", e.GroupCallMemberPrefix = "org.matrix.msc3401.call.member"
								}(r.EventType || (r.EventType = {})),
								function(e) {
									e.Annotation = "m.annotation", e.Replace = "m.replace", e.Reference = "m.reference", e.Thread = "m.thread"
								}(r.RelationType || (r.RelationType = {})),
								function(e) {
									e.Text = "m.text", e.Emote = "m.emote", e.Notice = "m.notice", e.Image = "m.image", e.File = "m.file", e.Audio = "m.audio", e.Location = "m.location", e.Video = "m.video", e.KeyVerificationRequest = "m.key.verification.request"
								}(r.MsgType || (r.MsgType = {})), r.RoomCreateTypeField = "type",
									function(e) {
										e.Space = "m.space", e.UnstableCall = "org.matrix.msc3417.call", e.ElementVideo = "io.element.video"
									}(r.RoomType || (r.RoomType = {})), r.UNSTABLE_MSC3088_PURPOSE = new n.UnstableValue("m.room.purpose", "org.matrix.msc3088.purpose"), r.UNSTABLE_MSC3088_ENABLED = new n.UnstableValue("m.enabled", "org.matrix.msc3088.enabled"), r.UNSTABLE_MSC3089_TREE_SUBTYPE = new n.UnstableValue("m.data_tree", "org.matrix.msc3089.data_tree"), r.UNSTABLE_MSC3089_LEAF = new n.UnstableValue("m.leaf", "org.matrix.msc3089.leaf"), r.UNSTABLE_MSC3089_BRANCH = new n.UnstableValue("m.branch", "org.matrix.msc3089.branch"), r.UNSTABLE_MSC2716_MARKER = new n.UnstableValue("m.room.marker", "org.matrix.msc2716.marker"), r.UNSTABLE_ELEMENT_FUNCTIONAL_USERS = new n.UnstableValue("io.element.functional_members", "io.element.functional_members"), r.EVENT_VISIBILITY_CHANGE_TYPE = new n.UnstableValue("m.visibility", "org.matrix.msc3531.visibility"), r.PUSHER_ENABLED = new n.UnstableValue("enabled", "org.matrix.msc3881.enabled"), r.PUSHER_DEVICE_ID = new n.UnstableValue("device_id", "org.matrix.msc3881.device_id"), r.LOCAL_NOTIFICATION_SETTINGS_PREFIX = new n.UnstableValue("m.local_notification_settings", "org.matrix.msc3890.local_notification_settings")
							}, {
								"../NamespacedValue": 299
							}],
							291: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.TEXT_NODE_TYPE = void 0;
								const n = e("../NamespacedValue");
								r.TEXT_NODE_TYPE = new n.UnstableValue("m.text", "org.matrix.msc1767.text")
							}, {
								"../NamespacedValue": 299
							}],
							292: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.M_LOCATION = r.M_TIMESTAMP = r.M_ASSET = r.LocationAssetType = void 0;
								const n = e("../NamespacedValue");
								e("./extensible_events");
								! function(e) {
									e.Self = "m.self", e.Pin = "m.pin"
								}(r.LocationAssetType || (r.LocationAssetType = {})), r.M_ASSET = new n.UnstableValue("m.asset", "org.matrix.msc3488.asset"), r.M_TIMESTAMP = new n.UnstableValue("m.ts", "org.matrix.msc3488.ts"), r.M_LOCATION = new n.UnstableValue("m.location", "org.matrix.msc3488.location")
							}, {
								"../NamespacedValue": 299,
								"./extensible_events": 291
							}],
							293: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.HistoryVisibility = r.GuestAccess = r.RestrictedAllowType = r.JoinRule = r.Preset = r.Visibility = void 0,
									function(e) {
										e.Public = "public", e.Private = "private"
									}(r.Visibility || (r.Visibility = {})),
									function(e) {
										e.PrivateChat = "private_chat", e.TrustedPrivateChat = "trusted_private_chat", e.PublicChat = "public_chat"
									}(r.Preset || (r.Preset = {})),
									function(e) {
										e.Public = "public", e.Invite = "invite", e.Private = "private", e.Knock = "knock", e.Restricted = "restricted"
									}(r.JoinRule || (r.JoinRule = {})),
									function(e) {
										e.RoomMembership = "m.room_membership"
									}(r.RestrictedAllowType || (r.RestrictedAllowType = {})),
									function(e) {
										e.CanJoin = "can_join", e.Forbidden = "forbidden"
									}(r.GuestAccess || (r.GuestAccess = {})),
									function(e) {
										e.Invited = "invited", e.Joined = "joined", e.Shared = "shared", e.WorldReadable = "world_readable"
									}(r.HistoryVisibility || (r.HistoryVisibility = {}))
							}, {}],
							294: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.ReceiptType = void 0,
									function(e) {
										e.Read = "m.read", e.FullyRead = "m.fully_read", e.ReadPrivate = "m.read.private"
									}(r.ReceiptType || (r.ReceiptType = {}))
							}, {}],
							295: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								})
							}, {}],
							296: [function(e, t, r) {
								"use strict";
								var n;
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.SearchOrderBy = void 0,
									function(e) {
										e.RoomId = "room_id", e.Sender = "sender"
									}(n || (n = {})),
									function(e) {
										e.Recent = "recent", e.Rank = "rank"
									}(r.SearchOrderBy || (r.SearchOrderBy = {}))
							}, {}],
							297: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.UNREAD_THREAD_NOTIFICATIONS = void 0;
								const n = e("../NamespacedValue");
								r.UNREAD_THREAD_NOTIFICATIONS = new n.ServerControlledNamespacedValue("unread_thread_notifications", "org.matrix.msc3773.unread_thread_notifications")
							}, {
								"../NamespacedValue": 299
							}],
							298: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.M_TOPIC = void 0;
								const n = e("../NamespacedValue");
								r.M_TOPIC = new n.UnstableValue("m.topic", "org.matrix.msc3765.topic")
							}, {
								"../NamespacedValue": 299
							}],
							299: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.UnstableValue = r.ServerControlledNamespacedValue = r.NamespacedValue = void 0;
								class n {
									constructor(e, t) {
										if (this.stable = e, this.unstable = t, !this.unstable && !this.stable) throw new Error("One of stable or unstable values must be supplied")
									}
									get name() {
										return this.stable ? this.stable : this.unstable
									}
									get altName() {
										return this.stable ? this.unstable : null
									}
									get names() {
										const e = [this.name],
											t = this.altName;
										return t && e.push(t), e
									}
									matches(e) {
										return this.name === e || this.altName === e
									}
									findIn(e) {
										let t = void 0;
										return this.name && (t = null == e ? void 0 : e[this.name]), !t && this.altName && (t = null == e ? void 0 : e[this.altName]), t
									}
									includedIn(e) {
										let t = !1;
										return this.name && (t = e.includes(this.name)), !t && this.altName && (t = e.includes(this.altName)), t
									}
								}
								r.NamespacedValue = n;
								r.ServerControlledNamespacedValue = class extends n {
									constructor() {
										super(...arguments), this.preferUnstable = !1
									}
									setPreferUnstable(e) {
										this.preferUnstable = e
									}
									get name() {
										return this.stable && !this.preferUnstable ? this.stable : this.unstable
									}
								};
								r.UnstableValue = class extends n {
									constructor(e, t) {
										if (super(e, t), !this.unstable) throw new Error("Unstable value must be supplied")
									}
									get name() {
										return this.unstable
									}
									get altName() {
										return this.stable
									}
								}
							}, {}],
							300: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.TypedReEmitter = r.ReEmitter = void 0;
								class n {
									constructor(e) {
										this.target = e, this.reEmitters = new Map
									}
									reEmit(e, t) {
										let r = this.reEmitters.get(e);
										r || (r = new Map, this.reEmitters.set(e, r));
										for (const n of t) {
											const t = (...t) => {
												"error" === n && 0 === this.target.listenerCount("error") || this.target.emit(n, ...t, e)
											};
											e.on(n, t), r.set(n, t)
										}
									}
									stopReEmitting(e, t) {
										const r = this.reEmitters.get(e);
										if (r) {
											for (const n of t) e.off(n, r.get(n)), r.delete(n);
											0 === r.size && this.reEmitters.delete(e)
										}
									}
								}
								r.ReEmitter = n;
								r.TypedReEmitter = class extends n {
									constructor(e) {
										super(e)
									}
									reEmit(e, t) {
										super.reEmit(e, t)
									}
									stopReEmitting(e, t) {
										super.stopReEmitting(e, t)
									}
								}
							}, {}],
							301: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.ToDeviceMessageQueue = void 0;
								const i = e("./logger"),
									o = e("./scheduler"),
									s = 20;
								r.ToDeviceMessageQueue = class {
									constructor(e) {
										this.client = e, this.sending = !1, this.running = !0, this.retryTimeout = null, this.retryAttempts = 0, this.sendQueue = () => n(this, void 0, void 0, (function*() {
											if (null !== this.retryTimeout && clearTimeout(this.retryTimeout), this.retryTimeout = null, this.sending || !this.running) return;
											let e;
											i.logger.debug("Attempting to send queued to-device messages"), this.sending = !0;
											try {
												for (; this.running && null !== (e = yield this.client.store.getOldestToDeviceBatch());) yield this.sendBatch(e), yield this.client.store.removeToDeviceBatch(e.id), this.retryAttempts = 0;
												if (!this.running) return;
												i.logger.debug("All queued to-device messages sent")
											} catch (t) {
												++this.retryAttempts;
												const r = o.MatrixScheduler.RETRY_BACKOFF_RATELIMIT(null, this.retryAttempts, t);
												if (-1 === r) return void(4 === Math.floor(t.httpStatus / 100) ? (i.logger.error("Fatal error when sending to-device message - dropping to-device batch!", t), yield this.client.store.removeToDeviceBatch(e.id)) : i.logger.info("Automatic retry limit reached for to-device messages."));
												i.logger.info(`Failed to send batch of to-device messages. Will retry in ${r}ms`, t), this.retryTimeout = setTimeout(this.sendQueue, r)
											} finally {
												this.sending = !1
											}
										}))
									}
									start() {
										this.running = !0, this.sendQueue()
									}
									stop() {
										this.running = !1, null !== this.retryTimeout && clearTimeout(this.retryTimeout), this.retryTimeout = null
									}
									queueBatch(e) {
										return n(this, void 0, void 0, (function*() {
											const t = [];
											for (let r = 0; r < e.batch.length; r += s) {
												const n = {
													eventType: e.eventType,
													batch: e.batch.slice(r, r + s),
													txnId: this.client.makeTxnId()
												};
												t.push(n);
												const o = n.batch.map(e => `${e.userId}:${e.deviceId}`);
												i.logger.info(`Created batch of to-device messages with txn id ${n.txnId} for ${o}`)
											}
											yield this.client.store.saveToDeviceBatches(t), i.logger.info(`Enqueued to-device messages with txn ids ${t.map(e=>e.txnId)}`), this.sendQueue()
										}))
									}
									sendBatch(e) {
										return n(this, void 0, void 0, (function*() {
											const t = {};
											for (const r of e.batch) t[r.userId] || (t[r.userId] = {}), t[r.userId][r.deviceId] = r.payload;
											i.logger.info(`Sending batch of ${e.batch.length} to-device messages with ID ${e.id} and txnId ${e.txnId}`), yield this.client.sendToDevice(e.eventType, t, e.txnId)
										}))
									}
								}
							}, {
								"./logger": 356,
								"./scheduler": 381
							}],
							302: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var r = this && this.__awaiter || function(e, t, r, n) {
											return new(r || (r = Promise))((function(i, o) {
												function s(e) {
													try {
														c(n.next(e))
													} catch (t) {
														o(t)
													}
												}

												function a(e) {
													try {
														c(n.throw(e))
													} catch (t) {
														o(t)
													}
												}

												function c(e) {
													var t;
													e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
														e(t)
													}))).then(s, a)
												}
												c((n = n.apply(e, t || [])).next())
											}))
										};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.AutoDiscovery = n.AutoDiscoveryAction = void 0;
										const i = t("./logger"),
											o = t("./http-api");
										var s, a;
										! function(e) {
											e.SUCCESS = "SUCCESS", e.IGNORE = "IGNORE", e.PROMPT = "PROMPT", e.FAIL_PROMPT = "FAIL_PROMPT", e.FAIL_ERROR = "FAIL_ERROR"
										}(s = n.AutoDiscoveryAction || (n.AutoDiscoveryAction = {})),
										function(e) {
											e.Invalid = "Invalid homeserver discovery response", e.GenericFailure = "Failed to get autodiscovery configuration from server", e.InvalidHsBaseUrl = "Invalid base_url for m.homeserver", e.InvalidHomeserver = "Homeserver URL does not appear to be a valid Matrix homeserver", e.InvalidIsBaseUrl = "Invalid base_url for m.identity_server", e.InvalidIdentityServer = "Identity server URL does not appear to be a valid identity server", e.InvalidIs = "Invalid identity server discovery response", e.MissingWellknown = "No .well-known JSON file found", e.InvalidJson = "Invalid JSON"
										}(a || (a = {}));
										class c {
											static fromDiscoveryConfig(e) {
												return r(this, void 0, void 0, (function*() {
													const t = {
														"m.homeserver": {
															state: c.FAIL_ERROR,
															error: c.ERROR_INVALID,
															base_url: null
														},
														"m.identity_server": {
															state: c.PROMPT,
															error: null,
															base_url: null
														}
													};
													if (!e || !e["m.homeserver"]) return i.logger.error("No m.homeserver key in config"), t["m.homeserver"].state = c.FAIL_PROMPT, t["m.homeserver"].error = c.ERROR_INVALID, Promise.resolve(t);
													if (!e["m.homeserver"].base_url) return i.logger.error("No m.homeserver base_url in config"), t["m.homeserver"].state = c.FAIL_PROMPT, t["m.homeserver"].error = c.ERROR_INVALID_HS_BASE_URL, Promise.resolve(t);
													const r = this.sanitizeWellKnownUrl(e["m.homeserver"].base_url);
													if (!r) return i.logger.error("Invalid base_url for m.homeserver"), t["m.homeserver"].error = c.ERROR_INVALID_HS_BASE_URL, Promise.resolve(t);
													const n = yield this.fetchWellKnownObject(`${r}/_matrix/client/versions`);
													if (!n || !n.raw.versions) return i.logger.error("Invalid /versions response"), t["m.homeserver"].error = c.ERROR_INVALID_HOMESERVER, t["m.homeserver"].base_url = r, Promise.resolve(t);
													t["m.homeserver"] = {
														state: c.SUCCESS,
														error: null,
														base_url: r
													};
													let o = "";
													if (e["m.identity_server"]) {
														const r = {
															"m.homeserver": t["m.homeserver"],
															"m.identity_server": {
																state: c.FAIL_PROMPT,
																error: c.ERROR_INVALID_IS,
																base_url: null
															}
														};
														if (!(o = this.sanitizeWellKnownUrl(e["m.identity_server"].base_url))) return i.logger.error("Invalid base_url for m.identity_server"), r["m.identity_server"].error = c.ERROR_INVALID_IS_BASE_URL, Promise.resolve(r);
														const n = yield this.fetchWellKnownObject(`${o}/_matrix/identity/api/v1`);
														if (!n || !n.raw || n.action !== s.SUCCESS) return i.logger.error("Invalid /api/v1 response"), r["m.identity_server"].error = c.ERROR_INVALID_IDENTITY_SERVER, r["m.identity_server"].base_url = o, Promise.resolve(r)
													}
													return o && o.toString().length > 0 && (t["m.identity_server"] = {
														state: c.SUCCESS,
														error: null,
														base_url: o
													}), Object.keys(e).forEach(r => {
														if ("m.homeserver" === r || "m.identity_server" === r) {
															const n = ["error", "state", "base_url"];
															for (const i of Object.keys(e[r])) n.includes(i) || (t[r][i] = e[r][i])
														} else t[r] = e[r]
													}), Promise.resolve(t)
												}))
											}
											static findClientConfig(e) {
												return r(this, void 0, void 0, (function*() {
													if (!e || "string" != typeof e || 0 === e.length) throw new Error("'domain' must be a string of non-zero length");
													const t = {
															"m.homeserver": {
																state: c.FAIL_ERROR,
																error: c.ERROR_INVALID,
																base_url: null
															},
															"m.identity_server": {
																state: c.PROMPT,
																error: null,
																base_url: null
															}
														},
														r = yield this.fetchWellKnownObject(`https://${e}/.well-known/matrix/client`);
													return r && r.action === s.SUCCESS ? c.fromDiscoveryConfig(r.raw) : (i.logger.error("No response or error when parsing .well-known"), r.reason && i.logger.error(r.reason), r.action === s.IGNORE ? t["m.homeserver"] = {
														state: c.PROMPT,
														error: null,
														base_url: null
													} : (t["m.homeserver"].state = c.FAIL_PROMPT, t["m.homeserver"].error = c.ERROR_INVALID), Promise.resolve(t))
												}))
											}
											static getRawClientConfig(e) {
												return r(this, void 0, void 0, (function*() {
													if (!e || "string" != typeof e || 0 === e.length) throw new Error("'domain' must be a string of non-zero length");
													const t = yield this.fetchWellKnownObject(`https://${e}/.well-known/matrix/client`);
													return t && t.raw || {}
												}))
											}
											static sanitizeWellKnownUrl(e) {
												if (!e) return !1;
												try {
													let r;
													try {
														r = new URL(e)
													} catch (t) {
														i.logger.error("Could not parse url", t)
													}
													if (!(null == r ? void 0 : r.hostname)) return !1;
													if ("http:" !== r.protocol && "https:" !== r.protocol) return !1;
													const n = r.port ? `:${r.port}` : "",
														o = r.pathname ? r.pathname : "";
													let s = `${r.protocol}//${r.hostname}${n}${o}`;
													return s.endsWith("/") && (s = s.substring(0, s.length - 1)), s
												} catch (t) {
													return i.logger.error(t), !1
												}
											}
											static fetch(t, r) {
												return this.fetchFn ? this.fetchFn(t, r) : e.fetch(t, r)
											}
											static setFetchFn(e) {
												c.fetchFn = e
											}
											static fetchWellKnownObject(e) {
												return r(this, void 0, void 0, (function*() {
													let t;
													try {
														if (404 === (t = yield c.fetch(e, {
																method: o.Method.Get,
																signal: (0, o.timeoutSignal)(5e3)
															})).status) return {
															raw: {},
															action: s.IGNORE,
															reason: c.ERROR_MISSING_WELLKNOWN
														};
														if (!t.ok) return {
															raw: {},
															action: s.FAIL_PROMPT,
															reason: "General failure"
														}
													} catch (r) {
														const e = r;
														let t = "";
														return "object" == typeof e && (t = null == e ? void 0 : e.message), {
															error: e,
															raw: {},
															action: s.FAIL_PROMPT,
															reason: t || "General failure"
														}
													}
													try {
														return {
															raw: yield t.json(),
															action: s.SUCCESS
														}
													} catch (r) {
														const e = r;
														return {
															error: e,
															raw: {},
															action: s.FAIL_PROMPT,
															reason: "SyntaxError" === (null == e ? void 0 : e.name) ? c.ERROR_INVALID_JSON : c.ERROR_INVALID
														}
													}
												}))
											}
										}
										n.AutoDiscovery = c, c.ERROR_INVALID = a.Invalid, c.ERROR_GENERIC_FAILURE = a.GenericFailure, c.ERROR_INVALID_HS_BASE_URL = a.InvalidHsBaseUrl, c.ERROR_INVALID_HOMESERVER = a.InvalidHomeserver, c.ERROR_INVALID_IS_BASE_URL = a.InvalidIsBaseUrl, c.ERROR_INVALID_IDENTITY_SERVER = a.InvalidIdentityServer, c.ERROR_INVALID_IS = a.InvalidIs, c.ERROR_MISSING_WELLKNOWN = a.MissingWellknown, c.ERROR_INVALID_JSON = a.InvalidJson, c.ALL_ERRORS = Object.keys(a), c.FAIL_ERROR = s.FAIL_ERROR, c.FAIL_PROMPT = s.FAIL_PROMPT, c.PROMPT = s.PROMPT, c.SUCCESS = s.SUCCESS
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"./http-api": 349,
								"./logger": 356
							}],
							303: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var r = t("@babel/runtime/helpers/typeof");
										Object.defineProperty(n, "__esModule", {
											value: !0
										});
										var i = {};
										n.default = void 0;
										var o, s = function(e, t) {
											if (!t && e && e.__esModule) return e;
											if (null === e || "object" !== r(e) && "function" != typeof e) return {
												default: e
											};
											var n = a(t);
											if (n && n.has(e)) return n.get(e);
											var i = {},
												o = Object.defineProperty && Object.getOwnPropertyDescriptor;
											for (var s in e)
												if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
													var c = o ? Object.getOwnPropertyDescriptor(e, s) : null;
													c && (c.get || c.set) ? Object.defineProperty(i, s, c) : i[s] = e[s]
												} i.default = e, n && n.set(e, i);
											return i
										}(t("./matrix"));

										function a(e) {
											if ("function" != typeof WeakMap) return null;
											var t = new WeakMap,
												r = new WeakMap;
											return (a = function(e) {
												return e ? r : t
											})(e)
										}
										if (Object.keys(s).forEach((function(e) {
												"default" !== e && "__esModule" !== e && (Object.prototype.hasOwnProperty.call(i, e) || e in n && n[e] === s[e] || Object.defineProperty(n, e, {
													enumerable: !0,
													get: function() {
														return s[e]
													}
												}))
											})), e.__js_sdk_entrypoint) throw new Error("Multiple matrix-js-sdk entrypoints detected!");
										e.__js_sdk_entrypoint = !0;
										try {
											o = e.indexedDB
										} catch (l) {}
										o && s.setCryptoStoreFactory((function() {
											return new s.IndexedDBCryptoStore(o, "matrix-js-sdk:crypto")
										}));
										var c = s;
										n.default = c, e.matrixcs = s
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"./matrix": 357,
								"@babel/runtime/helpers/typeof": 1
							}],
							304: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var r = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
												void 0 === n && (n = r);
												var i = Object.getOwnPropertyDescriptor(t, r);
												i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
													enumerable: !0,
													get: function() {
														return t[r]
													}
												}), Object.defineProperty(e, n, i)
											} : function(e, t, r, n) {
												void 0 === n && (n = r), e[n] = t[r]
											}),
											i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
												Object.defineProperty(e, "default", {
													enumerable: !0,
													value: t
												})
											} : function(e, t) {
												e.default = t
											}),
											o = this && this.__importStar || function(e) {
												if (e && e.__esModule) return e;
												var t = {};
												if (null != e)
													for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);
												return i(t, e), t
											},
											s = this && this.__awaiter || function(e, t, r, n) {
												return new(r || (r = Promise))((function(i, o) {
													function s(e) {
														try {
															c(n.next(e))
														} catch (t) {
															o(t)
														}
													}

													function a(e) {
														try {
															c(n.throw(e))
														} catch (t) {
															o(t)
														}
													}

													function c(e) {
														var t;
														e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
															e(t)
														}))).then(s, a)
													}
													c((n = n.apply(e, t || [])).next())
												}))
											},
											a = this && this.__rest || function(e, t) {
												var r = {};
												for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
												if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
													var i = 0;
													for (n = Object.getOwnPropertySymbols(e); i < n.length; i++) t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]])
												}
												return r
											};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.fixNotificationCountOnDecryption = n.MatrixClient = n.ClientEvent = n.M_AUTHENTICATION = n.RoomVersionStability = n.PendingEventOrdering = n.UNSTABLE_MSC3852_LAST_SEEN_UA = n.CRYPTO_ENABLED = void 0;
										const c = t("matrix-events-sdk"),
											l = t("./sync"),
											u = t("./models/event"),
											d = t("./store/stub"),
											h = t("./webrtc/call"),
											f = t("./filter"),
											p = t("./webrtc/callEventHandler"),
											v = o(t("./utils")),
											g = t("./utils"),
											m = t("./models/event-timeline"),
											y = t("./pushprocessor"),
											b = t("./autodiscovery"),
											_ = o(t("./crypto/olmlib")),
											w = t("./crypto/olmlib"),
											S = t("./ReEmitter"),
											E = t("./crypto/RoomList"),
											k = t("./logger"),
											T = t("./service-types"),
											I = t("./http-api"),
											R = t("./crypto"),
											C = t("./crypto/recoverykey"),
											M = t("./crypto/key_passphrase"),
											x = t("./models/user"),
											O = t("./content-repo"),
											A = t("./models/search-result"),
											P = t("./crypto/dehydration"),
											D = t("./crypto/api"),
											j = o(t("./content-helpers")),
											L = t("./models/room"),
											N = t("./@types/event"),
											B = t("./@types/partials"),
											U = t("./event-mapper"),
											F = t("./randomstring"),
											$ = t("./crypto/backup"),
											q = t("./models/MSC3089TreeSpace"),
											K = t("./@types/search"),
											V = t("./@types/PushRules"),
											z = t("./webrtc/groupCall"),
											H = t("./webrtc/mediaHandler"),
											W = t("./webrtc/groupCallEventHandler"),
											G = t("./models/typed-event-emitter"),
											Y = t("./@types/read_receipts"),
											Q = t("./sliding-sync-sdk"),
											J = t("./models/thread"),
											X = t("./@types/beacon"),
											Z = t("./NamespacedValue"),
											ee = t("./ToDeviceMessageQueue"),
											te = t("./models/read-receipt"),
											re = t("./models/invites-ignorer"),
											ne = t("./@types/sync"),
											ie = t("./feature"),
											oe = 3e3;
										n.CRYPTO_ENABLED = (0, R.isCryptoAvailable)();
										const se = 216e5,
											ae = 6e5;
										var ce;
										n.UNSTABLE_MSC3852_LAST_SEEN_UA = new Z.UnstableValue("last_seen_user_agent", "org.matrix.msc3852.last_seen_user_agent"),
											function(e) {
												e.Chronological = "chronological", e.Detached = "detached"
											}(n.PendingEventOrdering || (n.PendingEventOrdering = {})),
											function(e) {
												e.Stable = "stable", e.Unstable = "unstable"
											}(n.RoomVersionStability || (n.RoomVersionStability = {})),
											function(e) {
												e.MasterKey = "master_key", e.SelfSigningKey = "self_signing_key", e.UserSigningKey = "user_signing_key"
											}(ce || (ce = {})), n.M_AUTHENTICATION = new Z.UnstableValue("m.authentication", "org.matrix.msc2965.authentication");
										const le = "$";
										var ue;
										! function(e) {
											e.Sync = "sync", e.Event = "event", e.ToDeviceEvent = "toDeviceEvent", e.AccountData = "accountData", e.Room = "Room", e.DeleteRoom = "deleteRoom", e.SyncUnexpectedError = "sync.unexpectedError", e.ClientWellKnown = "WellKnown.client", e.ReceivedVoipEvent = "received_voip_event", e.TurnServers = "turnServers", e.TurnServersError = "turnServers.error"
										}(ue = n.ClientEvent || (n.ClientEvent = {}));
										const de = new Z.UnstableValue("action", "org.matrix.msc3824.action");
										class he extends G.TypedEventEmitter {
											constructor(e) {
												var t;
												super(), this.reEmitter = new S.TypedReEmitter(this), this.olmVersion = null, this.usingExternalCrypto = !1, this.clientRunning = !1, this.timelineSupport = !1, this.urlPreviewCache = {}, this.supportsCallTransfer = !1, this.forceTURN = !1, this.iceCandidatePoolSize = 0, this.canSupportVoip = !1, this.peekSync = null, this.isGuestAccount = !1, this.ongoingScrollbacks = {}, this.notifTimelineSet = null, this.fallbackICEServerAllowed = !1, this.syncedLeftRooms = !1, this.canSupport = new Map, this.pushProcessor = new y.PushProcessor(this), this.turnServers = [], this.turnServersExpiry = 0, this.txnCtr = 0, this.mediaHandler = new H.MediaHandler(this), this.pendingEventEncryption = new Map, this.useE2eForGroupCall = !0, this.startCallEventHandler = () => {
													this.isInitialSyncComplete() && (this.callEventHandler.start(), this.groupCallEventHandler.start(), this.off(ue.Sync, this.startCallEventHandler))
												}, e.baseUrl = v.ensureNoTrailingSlash(e.baseUrl), e.idBaseUrl = v.ensureNoTrailingSlash(e.idBaseUrl), this.baseUrl = e.baseUrl, this.idBaseUrl = e.idBaseUrl, this.identityServer = e.identityServer, this.usingExternalCrypto = null !== (t = e.usingExternalCrypto) && void 0 !== t && t, this.store = e.store || new d.StubStore, this.deviceId = e.deviceId || null, this.sessionId = (0, F.randomString)(10);
												const r = e.userId || null;
												this.credentials = {
													userId: r
												}, this.http = new I.MatrixHttpApi(this, {
													fetchFn: e.fetchFn,
													baseUrl: e.baseUrl,
													idBaseUrl: e.idBaseUrl,
													accessToken: e.accessToken,
													prefix: I.ClientPrefix.R0,
													onlyData: !0,
													extraParams: e.queryParams,
													localTimeoutMs: e.localTimeoutMs,
													useAuthorizationHeader: e.useAuthorizationHeader
												}), e.deviceToImport ? this.deviceId ? k.logger.warn("not importing device because device ID is provided to constructor independently of exported data") : this.credentials.userId ? k.logger.warn("not importing device because user ID is provided to constructor independently of exported data") : e.deviceToImport.deviceId ? (this.deviceId = e.deviceToImport.deviceId, this.credentials.userId = e.deviceToImport.userId, this.exportedOlmDeviceToImport = e.deviceToImport.olmDevice) : k.logger.warn("not importing device because no device ID in exported data") : e.pickleKey && (this.pickleKey = e.pickleKey), this.scheduler = e.scheduler, this.scheduler && this.scheduler.setProcessFunction(e => s(this, void 0, void 0, (function*() {
													const t = this.getRoom(e.getRoomId());
													e.status !== u.EventStatus.SENDING && this.updatePendingEventStatus(t, e, u.EventStatus.SENDING);
													const r = yield this.sendEventHttpRequest(e);
													return t && t.updatePendingEvent(e, u.EventStatus.SENT, r.event_id), r
												}))), (0, h.supportsMatrixCall)() && (this.callEventHandler = new p.CallEventHandler(this), this.groupCallEventHandler = new W.GroupCallEventHandler(this), this.canSupportVoip = !0, this.on(ue.Sync, this.startCallEventHandler)), this.timelineSupport = Boolean(e.timelineSupport), this.cryptoStore = e.cryptoStore, this.verificationMethods = e.verificationMethods, this.cryptoCallbacks = e.cryptoCallbacks || {}, this.forceTURN = e.forceTURN || !1, this.iceCandidatePoolSize = void 0 === e.iceCandidatePoolSize ? 0 : e.iceCandidatePoolSize, this.supportsCallTransfer = e.supportsCallTransfer || !1, this.fallbackICEServerAllowed = e.fallbackICEServerAllowed || !1, void 0 !== e.useE2eForGroupCall && (this.useE2eForGroupCall = e.useE2eForGroupCall), this.roomList = new E.RoomList(this.cryptoStore), this.roomNameGenerator = e.roomNameGenerator, this.toDeviceMessageQueue = new ee.ToDeviceMessageQueue(this), this.on(u.MatrixEventEvent.Decrypted, e => {
													fe(this, e)
												}), this.on(L.RoomEvent.Receipt, (e, t) => {
													var r;
													if (t && this.isRoomEncrypted(t.roomId)) {
														const n = e.getContent();
														if (!(Object.keys(n).filter(e => {
																for (const [t, r] of Object.entries(n[e]))
																	if (v.isSupportedReceiptType(t) && r && Object.keys(r).includes(this.getUserId())) return !0;
																return !1
															}).length > 0)) return;
														const i = 20,
															o = t.getLiveTimeline().getEvents();
														let s = 0;
														for (let e = o.length - 1; e >= 0; e--) {
															if (e === o.length - i) return;
															const n = o[e];
															if (t.hasUserReadEvent(this.getUserId(), n.getId())) break;
															const a = this.getPushActionsForEvent(n);
															s += (null === (r = null == a ? void 0 : a.tweaks) || void 0 === r ? void 0 : r.highlight) ? 1 : 0
														}
														t.setUnreadNotificationCount(L.NotificationCountType.Highlight, s)
													}
												}), this.ignoredInvites = new re.IgnoredInvites(this)
											}
											startClient(e) {
												return s(this, void 0, void 0, (function*() {
													if (this.clientRunning) return;
													this.clientRunning = !0, "number" == typeof e && (e = {
														initialSyncLimit: e
													});
													const t = this.getUserId();
													t && this.store.storeUser(new x.User(t)), this.crypto && this.crypto.uploadDeviceKeys(), this.canSupportVoip && (this.checkTurnServersIntervalID = setInterval(() => {
														this.checkTurnServers()
													}, ae), this.checkTurnServers()), this.syncApi && (k.logger.error("Still have sync object whilst not running: stopping old one"), this.syncApi.stop());
													try {
														yield this.getVersions();
														const {
															threads: e,
															list: t,
															fwdPagination: r
														} = yield this.doesServerSupportThread();
														J.Thread.setServerSideSupport(e), J.Thread.setServerSideListSupport(t), J.Thread.setServerSideFwdPaginationSupport(r)
													} catch (r) {
														k.logger.error("Can't fetch server versions, continuing to initialise sync, this will be retried later", r)
													}
													this.clientOpts = Object.assign({}, e), this.clientOpts.crypto = this.crypto, this.clientOpts.canResetEntireTimeline = e => !!this.canResetTimelineCallback && this.canResetTimelineCallback(e), this.clientOpts.slidingSync ? this.syncApi = new Q.SlidingSyncSdk(this.clientOpts.slidingSync, this, this.clientOpts) : this.syncApi = new l.SyncApi(this, this.clientOpts), this.syncApi.sync(), void 0 !== this.clientOpts.clientWellKnownPollPeriod && (this.clientWellKnownIntervalID = setInterval(() => {
														this.fetchClientWellKnown()
													}, 1e3 * this.clientOpts.clientWellKnownPollPeriod), this.fetchClientWellKnown()), this.toDeviceMessageQueue.start()
												}))
											}
											stopClient() {
												var t, r, n, i, o;
												null === (t = this.crypto) || void 0 === t || t.stop(), this.clientRunning && (k.logger.log("stopping MatrixClient"), this.clientRunning = !1, null === (r = this.syncApi) || void 0 === r || r.stop(), this.syncApi = void 0, null === (n = this.peekSync) || void 0 === n || n.stopPeeking(), null === (i = this.callEventHandler) || void 0 === i || i.stop(), null === (o = this.groupCallEventHandler) || void 0 === o || o.stop(), this.callEventHandler = void 0, this.groupCallEventHandler = void 0, e.clearInterval(this.checkTurnServersIntervalID), this.checkTurnServersIntervalID = void 0, void 0 !== this.clientWellKnownIntervalID && e.clearInterval(this.clientWellKnownIntervalID), this.toDeviceMessageQueue.stop())
											}
											rehydrateDevice() {
												return s(this, void 0, void 0, (function*() {
													if (this.crypto) throw new Error("Cannot rehydrate device after crypto is initialized");
													if (!this.cryptoCallbacks.getDehydrationKey) return;
													const t = yield this.getDehydratedDevice();
													if (!t) return;
													if (!t.device_data || !t.device_id) return void k.logger.info("no dehydrated device found");
													const r = new e.Olm.Account;
													try {
														const e = t.device_data;
														if (e.algorithm !== P.DEHYDRATION_ALGORITHM) return void k.logger.warn("Wrong algorithm for dehydrated device");
														k.logger.log("unpickling dehydrated device");
														const n = yield this.cryptoCallbacks.getDehydrationKey(e, t => {
															r.unpickle(new Uint8Array(t), e.account)
														});
														if (r.unpickle(n, e.account), k.logger.log("unpickled device"), (yield this.http.authedRequest(I.Method.Post, "/dehydrated_device/claim", void 0, {
																device_id: t.device_id
															}, {
																prefix: "/_matrix/client/unstable/org.matrix.msc2697.v2"
															})).success) {
															this.deviceId = t.device_id, k.logger.info("using dehydrated device");
															const e = this.pickleKey || "DEFAULT_KEY";
															return this.exportedOlmDeviceToImport = {
																pickledAccount: r.pickle(e),
																sessions: [],
																pickleKey: e
															}, r.free(), this.deviceId
														}
														return r.free(), void k.logger.info("not using dehydrated device")
													} catch (n) {
														r.free(), k.logger.warn("could not unpickle", n)
													}
												}))
											}
											getDehydratedDevice() {
												return s(this, void 0, void 0, (function*() {
													try {
														return yield this.http.authedRequest(I.Method.Get, "/dehydrated_device", void 0, void 0, {
															prefix: "/_matrix/client/unstable/org.matrix.msc2697.v2"
														})
													} catch (e) {
														return void k.logger.info("could not get dehydrated device", e)
													}
												}))
											}
											setDehydrationKey(e, t, r) {
												return s(this, void 0, void 0, (function*() {
													if (this.crypto) return this.crypto.dehydrationManager.setKeyAndQueueDehydration(e, t, r);
													k.logger.warn("not dehydrating device if crypto is not enabled")
												}))
											}
											createDehydratedDevice(e, t, r) {
												return s(this, void 0, void 0, (function*() {
													if (this.crypto) return yield this.crypto.dehydrationManager.setKey(e, t, r), this.crypto.dehydrationManager.dehydrateDevice();
													k.logger.warn("not dehydrating device if crypto is not enabled")
												}))
											}
											exportDevice() {
												return s(this, void 0, void 0, (function*() {
													if (this.crypto) return {
														userId: this.credentials.userId,
														deviceId: this.deviceId,
														olmDevice: yield this.crypto.olmDevice.export()
													};
													k.logger.warn("not exporting device if crypto is not enabled")
												}))
											}
											clearStores() {
												if (this.clientRunning) throw new Error("Cannot clear stores while client is running");
												const e = [];
												return e.push(this.store.deleteAllData()), this.cryptoStore && e.push(this.cryptoStore.deleteAllData()), Promise.all(e).then()
											}
											getUserId() {
												return this.credentials && this.credentials.userId ? this.credentials.userId : null
											}
											getDomain() {
												return this.credentials && this.credentials.userId ? this.credentials.userId.replace(/^.*?:/, "") : null
											}
											getUserIdLocalpart() {
												return this.credentials && this.credentials.userId ? this.credentials.userId.split(":")[0].substring(1) : null
											}
											getDeviceId() {
												return this.deviceId
											}
											getSessionId() {
												return this.sessionId
											}
											supportsVoip() {
												return this.canSupportVoip
											}
											getMediaHandler() {
												return this.mediaHandler
											}
											setForceTURN(e) {
												this.forceTURN = e
											}
											setSupportsCallTransfer(e) {
												this.supportsCallTransfer = e
											}
											getUseE2eForGroupCall() {
												return this.useE2eForGroupCall
											}
											createCall(e) {
												return (0, h.createNewMatrixCall)(this, e)
											}
											createGroupCall(e, t, r, n, i, o) {
												return s(this, void 0, void 0, (function*() {
													if (this.getGroupCallForRoom(e)) throw new Error(`${e} already has an existing group call`);
													const s = this.getRoom(e);
													if (!s) throw new Error(`Cannot find room ${e}`);
													return new z.GroupCall(this, s, t, r, n, void 0, i, o).create()
												}))
											}
											waitUntilRoomReadyForGroupCalls(e) {
												return this.groupCallEventHandler.waitUntilRoomReadyForGroupCalls(e)
											}
											getGroupCallForRoom(e) {
												return this.groupCallEventHandler.groupCalls.get(e) || null
											}
											getSyncState() {
												var e, t;
												return null !== (t = null === (e = this.syncApi) || void 0 === e ? void 0 : e.getSyncState()) && void 0 !== t ? t : null
											}
											getSyncStateData() {
												return this.syncApi ? this.syncApi.getSyncStateData() : null
											}
											isInitialSyncComplete() {
												const e = this.getSyncState();
												return !!e && (e === l.SyncState.Prepared || e === l.SyncState.Syncing)
											}
											isGuest() {
												return this.isGuestAccount
											}
											setGuest(e) {
												this.isGuestAccount = e
											}
											getScheduler() {
												return this.scheduler
											}
											retryImmediately() {
												var e, t;
												return this.toDeviceMessageQueue.sendQueue(), null !== (t = null === (e = this.syncApi) || void 0 === e ? void 0 : e.retryImmediately()) && void 0 !== t && t
											}
											getNotifTimelineSet() {
												return this.notifTimelineSet
											}
											setNotifTimelineSet(e) {
												this.notifTimelineSet = e
											}
											getCapabilities(e = !1) {
												const t = (new Date).getTime();
												return this.cachedCapabilities && !e && t < this.cachedCapabilities.expiration ? (k.logger.log("Returning cached capabilities"), Promise.resolve(this.cachedCapabilities.capabilities)) : this.http.authedRequest(I.Method.Get, "/capabilities").catch(e => {
													k.logger.error(e)
												}).then((e = {}) => {
													const r = e.capabilities || {},
														n = Object.keys(r).length ? se : 6e4 + 5e3 * Math.random();
													return this.cachedCapabilities = {
														capabilities: r,
														expiration: t + n
													}, k.logger.log("Caching capabilities: ", r), r
												})
											}
											initCrypto() {
												return s(this, void 0, void 0, (function*() {
													if (!(0, R.isCryptoAvailable)()) throw new Error("End-to-end encryption not supported in this js-sdk build: did you remember to load the olm library?");
													if (this.crypto) return void k.logger.warn("Attempt to re-initialise e2e encryption on MatrixClient");
													if (!this.cryptoStore) throw new Error("Cannot enable encryption: no cryptoStore provided");
													k.logger.log("Crypto: Starting up crypto store..."), yield this.cryptoStore.startup(), k.logger.log("Crypto: initialising roomlist..."), yield this.roomList.init();
													const e = this.getUserId();
													if (null === e) throw new Error("Cannot enable encryption on MatrixClient with unknown userId: ensure userId is passed in createClient().");
													if (null === this.deviceId) throw new Error("Cannot enable encryption on MatrixClient with unknown deviceId: ensure deviceId is passed in createClient().");
													const t = new R.Crypto(this, e, this.deviceId, this.store, this.cryptoStore, this.roomList, this.verificationMethods);
													this.reEmitter.reEmit(t, [R.CryptoEvent.KeyBackupFailed, R.CryptoEvent.KeyBackupSessionsRemaining, R.CryptoEvent.RoomKeyRequest, R.CryptoEvent.RoomKeyRequestCancellation, R.CryptoEvent.Warning, R.CryptoEvent.DevicesUpdated, R.CryptoEvent.WillUpdateDevices, R.CryptoEvent.DeviceVerificationChanged, R.CryptoEvent.UserTrustStatusChanged, R.CryptoEvent.KeysChanged]), k.logger.log("Crypto: initialising crypto object..."), yield t.init({
														exportedOlmDevice: this.exportedOlmDeviceToImport,
														pickleKey: this.pickleKey
													}), delete this.exportedOlmDeviceToImport, this.olmVersion = R.Crypto.getOlmVersion(), t.registerEventHandlers(this), this.crypto = t
												}))
											}
											isCryptoEnabled() {
												return !!this.crypto
											}
											getDeviceEd25519Key() {
												var e, t;
												return null !== (t = null === (e = this.crypto) || void 0 === e ? void 0 : e.getDeviceEd25519Key()) && void 0 !== t ? t : null
											}
											getDeviceCurve25519Key() {
												var e, t;
												return null !== (t = null === (e = this.crypto) || void 0 === e ? void 0 : e.getDeviceCurve25519Key()) && void 0 !== t ? t : null
											}
											uploadKeys() {
												return s(this, void 0, void 0, (function*() {
													if (!this.crypto) throw new Error("End-to-end encryption disabled");
													yield this.crypto.uploadDeviceKeys()
												}))
											}
											downloadKeys(e, t) {
												return this.crypto ? this.crypto.downloadKeys(e, t) : Promise.reject(new Error("End-to-end encryption disabled"))
											}
											getStoredDevicesForUser(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.getStoredDevicesForUser(e) || []
											}
											getStoredDevice(e, t) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.getStoredDevice(e, t) || null
											}
											setDeviceVerified(e, t, r = !0) {
												const n = this.setDeviceVerification(e, t, r, null, null);
												return e == this.credentials.userId && this.checkKeyBackup(), n
											}
											setDeviceBlocked(e, t, r = !0) {
												return this.setDeviceVerification(e, t, null, r, null)
											}
											setDeviceKnown(e, t, r = !0) {
												return this.setDeviceVerification(e, t, null, null, r)
											}
											setDeviceVerification(e, t, r, n, i) {
												return s(this, void 0, void 0, (function*() {
													if (!this.crypto) throw new Error("End-to-end encryption disabled");
													yield this.crypto.setDeviceVerification(e, t, r, n, i)
												}))
											}
											requestVerificationDM(e, t) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.requestVerificationDM(e, t)
											}
											findVerificationRequestDMInProgress(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.findVerificationRequestDMInProgress(e)
											}
											getVerificationRequestsToDeviceInProgress(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.getVerificationRequestsToDeviceInProgress(e)
											}
											requestVerification(e, t) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.requestVerification(e, t)
											}
											beginKeyVerification(e, t, r) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.beginKeyVerification(e, t, r)
											}
											checkSecretStorageKey(e, t) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.checkSecretStorageKey(e, t)
											}
											setGlobalBlacklistUnverifiedDevices(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.globalBlacklistUnverifiedDevices = e, e
											}
											getGlobalBlacklistUnverifiedDevices() {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.globalBlacklistUnverifiedDevices
											}
											setGlobalErrorOnUnknownDevices(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												this.crypto.globalErrorOnUnknownDevices = e
											}
											getGlobalErrorOnUnknownDevices() {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.globalErrorOnUnknownDevices
											}
											getCrossSigningId(e = D.CrossSigningKey.Master) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.getCrossSigningId(e)
											}
											getStoredCrossSigningForUser(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.getStoredCrossSigningForUser(e)
											}
											checkUserTrust(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.checkUserTrust(e)
											}
											checkDeviceTrust(e, t) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.checkDeviceTrust(e, t)
											}
											checkIfOwnDeviceCrossSigned(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.checkIfOwnDeviceCrossSigned(e)
											}
											checkOwnCrossSigningTrust(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.checkOwnCrossSigningTrust(e)
											}
											checkCrossSigningPrivateKey(e, t) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.checkCrossSigningPrivateKey(e, t)
											}
											legacyDeviceVerification(e, t, r) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.legacyDeviceVerification(e, t, r)
											}
											prepareToEncrypt(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.prepareToEncrypt(e)
											}
											isCrossSigningReady() {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.isCrossSigningReady()
											}
											bootstrapCrossSigning(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.bootstrapCrossSigning(e)
											}
											getCryptoTrustCrossSignedDevices() {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.getCryptoTrustCrossSignedDevices()
											}
											setCryptoTrustCrossSignedDevices(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.setCryptoTrustCrossSignedDevices(e)
											}
											countSessionsNeedingBackup() {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.countSessionsNeedingBackup()
											}
											getEventEncryptionInfo(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.getEventEncryptionInfo(e)
											}
											createRecoveryKeyFromPassphrase(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.createRecoveryKeyFromPassphrase(e)
											}
											isSecretStorageReady() {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.isSecretStorageReady()
											}
											bootstrapSecretStorage(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.bootstrapSecretStorage(e)
											}
											addSecretStorageKey(e, t, r) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.addSecretStorageKey(e, t, r)
											}
											hasSecretStorageKey(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.hasSecretStorageKey(e)
											}
											storeSecret(e, t, r) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.storeSecret(e, t, r)
											}
											getSecret(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.getSecret(e)
											}
											isSecretStored(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.isSecretStored(e)
											}
											requestSecret(e, t) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.requestSecret(e, t)
											}
											getDefaultSecretStorageKeyId() {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.getDefaultSecretStorageKeyId()
											}
											setDefaultSecretStorageKeyId(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.setDefaultSecretStorageKeyId(e)
											}
											checkSecretStoragePrivateKey(e, t) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.checkSecretStoragePrivateKey(e, t)
											}
											getEventSenderDeviceInfo(e) {
												return s(this, void 0, void 0, (function*() {
													return this.crypto ? this.crypto.getEventSenderDeviceInfo(e) : null
												}))
											}
											isEventSenderVerified(e) {
												return s(this, void 0, void 0, (function*() {
													const t = yield this.getEventSenderDeviceInfo(e);
													return !!t && t.isVerified()
												}))
											}
											cancelAndResendEventRoomKeyRequest(e) {
												if (!this.crypto) throw new Error("End-to-End encryption disabled");
												return e.cancelAndResendKeyRequest(this.crypto, this.getUserId())
											}
											setRoomEncryption(e, t) {
												if (!this.crypto) throw new Error("End-to-End encryption disabled");
												return this.crypto.setRoomEncryption(e, t)
											}
											isRoomEncrypted(e) {
												const t = this.getRoom(e);
												return !!t && (!!t.currentState.getStateEvents(N.EventType.RoomEncryption, "") || this.roomList.isRoomEncrypted(e))
											}
											encryptAndSendToDevices(e, t) {
												if (!this.crypto) throw new Error("End-to-End encryption disabled");
												return this.crypto.encryptAndSendToDevices(e, t)
											}
											forceDiscardSession(e) {
												if (!this.crypto) throw new Error("End-to-End encryption disabled");
												this.crypto.forceDiscardSession(e)
											}
											exportRoomKeys() {
												return this.crypto ? this.crypto.exportRoomKeys() : Promise.reject(new Error("End-to-end encryption disabled"))
											}
											importRoomKeys(e, t) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.importRoomKeys(e, t)
											}
											checkKeyBackup() {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.backupManager.checkKeyBackup()
											}
											getKeyBackupVersion() {
												return s(this, void 0, void 0, (function*() {
													let e;
													try {
														e = yield this.http.authedRequest(I.Method.Get, "/room_keys/version", void 0, void 0, {
															prefix: I.ClientPrefix.V3
														})
													} catch (t) {
														if ("M_NOT_FOUND" === t.errcode) return null;
														throw t
													}
													return $.BackupManager.checkBackupVersion(e), e
												}))
											}
											isKeyBackupTrusted(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.backupManager.isKeyBackupTrusted(e)
											}
											getKeyBackupEnabled() {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.backupManager.getKeyBackupEnabled()
											}
											enableKeyBackup(e) {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.backupManager.enableKeyBackup(e)
											}
											disableKeyBackup() {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												this.crypto.backupManager.disableKeyBackup()
											}
											prepareKeyBackupVersion(e, t = {
												secureSecretStorage: !1
											}) {
												return s(this, void 0, void 0, (function*() {
													if (!this.crypto) throw new Error("End-to-end encryption disabled");
													const {
														algorithm: r,
														auth_data: n,
														recovery_key: i,
														privateKey: o
													} = yield this.crypto.backupManager.prepareKeyBackupVersion(e);
													return t.secureSecretStorage && (yield this.storeSecret("m.megolm_backup.v1", (0, w.encodeBase64)(o)), k.logger.info("Key backup private key stored in secret storage")), {
														algorithm: r,
														auth_data: n,
														recovery_key: i
													}
												}))
											}
											isKeyBackupKeyStored() {
												return Promise.resolve(this.isSecretStored("m.megolm_backup.v1"))
											}
											createKeyBackupVersion(e) {
												return s(this, void 0, void 0, (function*() {
													if (!this.crypto) throw new Error("End-to-end encryption disabled");
													yield this.crypto.backupManager.createKeyBackupVersion(e);
													const t = {
														algorithm: e.algorithm,
														auth_data: e.auth_data
													};
													yield this.crypto.signObject(t.auth_data), this.cryptoCallbacks.getCrossSigningKey && this.crypto.crossSigningInfo.getId() && (yield this.crypto.crossSigningInfo.signObject(t.auth_data, "master"));
													const r = yield this.http.authedRequest(I.Method.Post, "/room_keys/version", void 0, t, {
														prefix: I.ClientPrefix.V3
													});
													return yield this.checkKeyBackup(), this.getKeyBackupEnabled() || k.logger.error("Key backup not usable even though we just created it"), r
												}))
											}
											deleteKeyBackupVersion(e) {
												return s(this, void 0, void 0, (function*() {
													if (!this.crypto) throw new Error("End-to-end encryption disabled");
													this.crypto.backupManager.version && this.crypto.backupManager.disableKeyBackup();
													const t = v.encodeUri("/room_keys/version/$version", {
														$version: e
													});
													yield this.http.authedRequest(I.Method.Delete, t, void 0, void 0, {
														prefix: I.ClientPrefix.V3
													})
												}))
											}
											makeKeyBackupPath(e, t, r) {
												let n;
												return {
													path: n = void 0 !== t ? v.encodeUri("/room_keys/keys/$roomId/$sessionId", {
														$roomId: e,
														$sessionId: t
													}) : void 0 !== e ? v.encodeUri("/room_keys/keys/$roomId", {
														$roomId: e
													}) : "/room_keys/keys",
													queryData: void 0 === r ? void 0 : {
														version: r
													}
												}
											}
											sendKeyBackup(e, t, r, n) {
												return s(this, void 0, void 0, (function*() {
													if (!this.crypto) throw new Error("End-to-end encryption disabled");
													const i = this.makeKeyBackupPath(e, t, r);
													yield this.http.authedRequest(I.Method.Put, i.path, i.queryData, n, {
														prefix: I.ClientPrefix.V3
													})
												}))
											}
											scheduleAllGroupSessionsForBackup() {
												return s(this, void 0, void 0, (function*() {
													if (!this.crypto) throw new Error("End-to-end encryption disabled");
													yield this.crypto.backupManager.scheduleAllGroupSessionsForBackup()
												}))
											}
											flagAllGroupSessionsForBackup() {
												if (!this.crypto) throw new Error("End-to-end encryption disabled");
												return this.crypto.backupManager.flagAllGroupSessionsForBackup()
											}
											isValidRecoveryKey(e) {
												try {
													return (0, C.decodeRecoveryKey)(e), !0
												} catch (t) {
													return !1
												}
											}
											keyBackupKeyFromPassword(e, t) {
												return (0, M.keyFromAuthData)(t.auth_data, e)
											}
											keyBackupKeyFromRecoveryKey(e) {
												return (0, C.decodeRecoveryKey)(e)
											}
											restoreKeyBackupWithPassword(e, t, r, n, i) {
												return s(this, void 0, void 0, (function*() {
													const o = yield(0, M.keyFromAuthData)(n.auth_data, e);
													return this.restoreKeyBackup(o, t, r, n, i)
												}))
											}
											restoreKeyBackupWithSecretStorage(e, t, r, n) {
												return s(this, void 0, void 0, (function*() {
													if (!this.crypto) throw new Error("End-to-end encryption disabled");
													const i = yield this.getSecret("m.megolm_backup.v1"), o = (0, R.fixBackupKey)(i);
													if (o) {
														const e = yield this.crypto.getSecretStorageKey();
														yield this.storeSecret("m.megolm_backup.v1", o, [e[0]])
													}
													const s = (0, w.decodeBase64)(o || i);
													return this.restoreKeyBackup(s, t, r, e, n)
												}))
											}
											restoreKeyBackupWithRecoveryKey(e, t, r, n, i) {
												const o = (0, C.decodeRecoveryKey)(e);
												return this.restoreKeyBackup(o, t, r, n, i)
											}
											restoreKeyBackupWithCache(e, t, r, n) {
												return s(this, void 0, void 0, (function*() {
													if (!this.crypto) throw new Error("End-to-end encryption disabled");
													const i = yield this.crypto.getSessionBackupPrivateKey();
													if (!i) throw new Error("Couldn't get key");
													return this.restoreKeyBackup(i, e, t, r, n)
												}))
											}
											restoreKeyBackup(e, t, r, n, i) {
												return s(this, void 0, void 0, (function*() {
													const o = null == i ? void 0 : i.cacheCompleteCallback,
														a = null == i ? void 0 : i.progressCallback;
													if (!this.crypto) throw new Error("End-to-end encryption disabled");
													let c = 0,
														l = [];
													const u = this.makeKeyBackupPath(t, r, n.version),
														d = yield $.BackupManager.makeAlgorithm(n, () => s(this, void 0, void 0, (function*() {
															return e
														}))), h = d.untrusted;
													try {
														if (!(yield d.keyMatches(e))) return Promise.reject(new I.MatrixError({
															errcode: he.RESTORE_BACKUP_ERROR_BAD_KEY
														}));
														this.crypto.storeSessionBackupPrivateKey(e).catch(e => {
															k.logger.warn("Error caching session backup key:", e)
														}).then(o), a && a({
															stage: "fetch"
														});
														const n = yield this.http.authedRequest(I.Method.Get, u.path, u.queryData, void 0, {
															prefix: I.ClientPrefix.V3
														});
														if (n.rooms) {
															const e = n.rooms;
															for (const [t, r] of Object.entries(e)) {
																if (!r.sessions) continue;
																c += Object.keys(r.sessions).length;
																const e = yield d.decryptSessions(r.sessions);
																for (const r of e) r.room_id = t, l.push(r)
															}
														} else if (n.sessions) {
															const e = n.sessions;
															c = Object.keys(e).length, l = yield d.decryptSessions(e);
															for (const r of l) r.room_id = t
														} else {
															c = 1;
															try {
																const [e] = yield d.decryptSessions({
																	[r]: n
																});
																e.room_id = t, e.session_id = r, l.push(e)
															} catch (f) {
																k.logger.log("Failed to decrypt megolm session from backup", f)
															}
														}
													} finally {
														d.free()
													}
													return yield this.importRoomKeys(l, {
														progressCallback: a,
														untrusted: h,
														source: "backup"
													}), yield this.checkKeyBackup(), {
														total: c,
														imported: l.length
													}
												}))
											}
											deleteKeysFromBackup(e, t, r) {
												return s(this, void 0, void 0, (function*() {
													if (!this.crypto) throw new Error("End-to-end encryption disabled");
													const n = this.makeKeyBackupPath(e, t, r);
													yield this.http.authedRequest(I.Method.Delete, n.path, n.queryData, void 0, {
														prefix: I.ClientPrefix.V3
													})
												}))
											}
											sendSharedHistoryKeys(e, t) {
												return s(this, void 0, void 0, (function*() {
													if (!this.crypto) throw new Error("End-to-end encryption disabled");
													const r = this.roomList.getRoomEncryption(e);
													if (!r) return void k.logger.error("Unknown room.  Not sharing decryption keys");
													const n = yield this.crypto.downloadKeys(t), i = {};
													for (const [e, t] of Object.entries(n)) i[e] = Object.values(t);
													const o = this.crypto.getRoomDecryptor(e, r.algorithm);
													o.sendSharedHistoryInboundSessions ? yield o.sendSharedHistoryInboundSessions(i): k.logger.warn("Algorithm does not support sharing previous keys", r.algorithm)
												}))
											}
											getMediaConfig() {
												return this.http.authedRequest(I.Method.Get, "/config", void 0, void 0, {
													prefix: I.MediaPrefix.R0
												})
											}
											getRoom(e) {
												return e ? this.store.getRoom(e) : null
											}
											getRooms() {
												return this.store.getRooms()
											}
											getVisibleRooms() {
												const e = this.store.getRooms(),
													t = new Set;
												for (const r of e) {
													const e = r.currentState.getStateEvents(N.EventType.RoomCreate, "");
													if (e) {
														const r = e.getContent().predecessor;
														r && r.room_id && t.add(r.room_id)
													}
												}
												return e.filter(e => {
													return !e.currentState.getStateEvents(N.EventType.RoomTombstone, "") || !t.has(e.roomId)
												})
											}
											getUser(e) {
												return this.store.getUser(e)
											}
											getUsers() {
												return this.store.getUsers()
											}
											setAccountData(e, t) {
												const r = v.encodeUri("/user/$userId/account_data/$type", {
													$userId: this.credentials.userId,
													$type: e
												});
												return (0, I.retryNetworkOperation)(5, () => this.http.authedRequest(I.Method.Put, r, void 0, t))
											}
											getAccountData(e) {
												return this.store.getAccountData(e)
											}
											getAccountDataFromServer(e) {
												var t;
												return s(this, void 0, void 0, (function*() {
													if (this.isInitialSyncComplete()) {
														const t = this.store.getAccountData(e);
														return t ? t.getContent() : null
													}
													const r = v.encodeUri("/user/$userId/account_data/$type", {
														$userId: this.credentials.userId,
														$type: e
													});
													try {
														return yield this.http.authedRequest(I.Method.Get, r)
													} catch (n) {
														if ("M_NOT_FOUND" === (null === (t = n.data) || void 0 === t ? void 0 : t.errcode)) return null;
														throw n
													}
												}))
											}
											getIgnoredUsers() {
												const e = this.getAccountData("m.ignored_user_list");
												return e && e.getContent() && e.getContent().ignored_users ? Object.keys(e.getContent().ignored_users) : []
											}
											setIgnoredUsers(e) {
												const t = {
													ignored_users: {}
												};
												return e.forEach(e => {
													t.ignored_users[e] = {}
												}), this.setAccountData("m.ignored_user_list", t)
											}
											isUserIgnored(e) {
												return this.getIgnoredUsers().includes(e)
											}
											joinRoom(e, t = {}) {
												return s(this, void 0, void 0, (function*() {
													void 0 === t.syncRoom && (t.syncRoom = !0);
													const r = this.getRoom(e);
													if (null == r ? void 0 : r.hasMembershipState(this.credentials.userId, "join")) return Promise.resolve(r);
													let n = Promise.resolve();
													t.inviteSignUrl && (n = this.http.requestOtherUrl(I.Method.Post, new URL(t.inviteSignUrl), {
														mxid: this.credentials.userId
													}));
													const i = {};
													t.viaServers && (i.server_name = t.viaServers);
													try {
														const r = {},
															o = yield n;
														o && (r.third_party_signed = o);
														const s = v.encodeUri("/join/$roomid", {
																$roomid: e
															}),
															a = (yield this.http.authedRequest(I.Method.Post, s, i, r)).room_id,
															c = new l.SyncApi(this, this.clientOpts).createRoom(a);
														return t.syncRoom, c
													} catch (o) {
														throw o
													}
												}))
											}
											resendEvent(e, t) {
												return this.toDeviceMessageQueue.sendQueue(), this.updatePendingEventStatus(t, e, u.EventStatus.SENDING), this.encryptAndSendEvent(t, e)
											}
											cancelPendingEvent(e) {
												if (![u.EventStatus.QUEUED, u.EventStatus.NOT_SENT, u.EventStatus.ENCRYPTING].includes(e.status)) throw new Error("cannot cancel an event with status " + e.status);
												e.status === u.EventStatus.ENCRYPTING ? this.pendingEventEncryption.delete(e.getId()) : this.scheduler && e.status === u.EventStatus.QUEUED && this.scheduler.removeEventFromQueue(e);
												const t = this.getRoom(e.getRoomId());
												this.updatePendingEventStatus(t, e, u.EventStatus.CANCELLED)
											}
											setRoomName(e, t) {
												return this.sendStateEvent(e, N.EventType.RoomName, {
													name: t
												})
											}
											setRoomTopic(e, t, r) {
												const n = j.makeTopicContent(t, r);
												return this.sendStateEvent(e, N.EventType.RoomTopic, n)
											}
											getRoomTags(e) {
												const t = v.encodeUri("/user/$userId/rooms/$roomId/tags", {
													$userId: this.credentials.userId,
													$roomId: e
												});
												return this.http.authedRequest(I.Method.Get, t)
											}
											setRoomTag(e, t, r) {
												const n = v.encodeUri("/user/$userId/rooms/$roomId/tags/$tag", {
													$userId: this.credentials.userId,
													$roomId: e,
													$tag: t
												});
												return this.http.authedRequest(I.Method.Put, n, void 0, r)
											}
											deleteRoomTag(e, t) {
												const r = v.encodeUri("/user/$userId/rooms/$roomId/tags/$tag", {
													$userId: this.credentials.userId,
													$roomId: e,
													$tag: t
												});
												return this.http.authedRequest(I.Method.Delete, r)
											}
											setRoomAccountData(e, t, r) {
												const n = v.encodeUri("/user/$userId/rooms/$roomId/account_data/$type", {
													$userId: this.credentials.userId,
													$roomId: e,
													$type: t
												});
												return this.http.authedRequest(I.Method.Put, n, void 0, r)
											}
											setPowerLevel(e, t, r, n) {
												let i = {
													users: {}
												};
												(null == n ? void 0 : n.getType()) === N.EventType.RoomPowerLevels && (i = v.deepCopy(n.getContent())), i.users[t] = r;
												const o = v.encodeUri("/rooms/$roomId/state/m.room.power_levels", {
													$roomId: e
												});
												return this.http.authedRequest(I.Method.Put, o, void 0, i)
											}
											unstable_createLiveBeacon(e, t) {
												return s(this, void 0, void 0, (function*() {
													return this.unstable_setLiveBeacon(e, t)
												}))
											}
											unstable_setLiveBeacon(e, t) {
												return s(this, void 0, void 0, (function*() {
													return this.sendStateEvent(e, X.M_BEACON_INFO.name, t, this.getUserId())
												}))
											}
											sendEvent(e, t, r, n, i) {
												var o, s, a, c, l;
												if ((null == t ? void 0 : t.startsWith(le)) || null === t || (i = n, n = r, r = t, t = null), t && !(null === (o = n["m.relates_to"]) || void 0 === o ? void 0 : o.rel_type)) {
													const r = !!(null === (s = n["m.relates_to"]) || void 0 === s ? void 0 : s["m.in_reply_to"]);
													n["m.relates_to"] = Object.assign(Object.assign({}, n["m.relates_to"]), {
														rel_type: J.THREAD_RELATION_TYPE.name,
														event_id: t,
														is_falling_back: !r
													});
													const i = null === (a = this.getRoom(e)) || void 0 === a ? void 0 : a.getThread(t);
													i && !r && (n["m.relates_to"]["m.in_reply_to"] = {
														event_id: null !== (l = null === (c = i.lastReply(e => e.isRelation(J.THREAD_RELATION_TYPE.name) && !e.status)) || void 0 === c ? void 0 : c.getId()) && void 0 !== l ? l : t
													})
												}
												return this.sendCompleteEvent(e, t, {
													type: r,
													content: n
												}, i)
											}
											sendCompleteEvent(e, t, r, n) {
												n || (n = this.makeTxnId());
												const i = new u.MatrixEvent(Object.assign(r, {
														event_id: "~" + e + ":" + n,
														user_id: this.credentials.userId,
														sender: this.credentials.userId,
														room_id: e,
														origin_server_ts: (new Date).getTime()
													})),
													o = this.getRoom(e),
													s = t ? null == o ? void 0 : o.getThread(t) : void 0;
												s && i.setThread(s), this.reEmitter.reEmit(i, [u.MatrixEventEvent.Replaced, u.MatrixEventEvent.VisibilityChange]), null == o || o.reEmitter.reEmit(i, [u.MatrixEventEvent.BeforeRedaction]);
												const a = i.getAssociatedId();
												if (null == a ? void 0 : a.startsWith("~")) {
													const e = null == o ? void 0 : o.getPendingEvents().find(e => e.getId() === a);
													null == e || e.once(u.MatrixEventEvent.LocalEventIdReplaced, () => {
														i.updateAssociatedId(e.getId())
													})
												}
												const c = i.getType();
												return k.logger.log(`sendEvent of type ${c} in ${e} with txnId ${n}`), i.setTxnId(n), i.setStatus(u.EventStatus.SENDING), null == o || o.addPendingEvent(i, n), i.status === u.EventStatus.NOT_SENT ? Promise.reject(new Error("Event blocked by other events not yet sent")) : this.encryptAndSendEvent(o, i)
											}
											encryptAndSendEvent(e, t) {
												let r = !1;
												return Promise.resolve().then(() => {
													const n = this.encryptEventIfNeeded(t, null != e ? e : void 0);
													return n ? (this.pendingEventEncryption.set(t.getId(), n), this.updatePendingEventStatus(e, t, u.EventStatus.ENCRYPTING), n.then(() => {
														this.pendingEventEncryption.has(t.getId()) ? this.updatePendingEventStatus(e, t, u.EventStatus.SENDING) : r = !0
													})) : null
												}).then(() => {
													if (r) return {};
													let n = null;
													return this.scheduler && (n = this.scheduler.queueEvent(t)) && this.scheduler.getQueueForEvent(t).length > 1 && this.updatePendingEventStatus(e, t, u.EventStatus.QUEUED), n || (n = this.sendEventHttpRequest(t), e && (n = n.then(r => (e.updatePendingEvent(t, u.EventStatus.SENT, r.event_id), r)))), n
												}).catch(r => {
													k.logger.error("Error sending event", r.stack || r);
													try {
														t.error = r, this.updatePendingEventStatus(e, t, u.EventStatus.NOT_SENT)
													} catch (n) {
														k.logger.error("Exception in error handler!", n.stack || r)
													}
													throw r instanceof I.MatrixError && (r.event = t), r
												})
											}
											encryptEventIfNeeded(e, t) {
												if (e.isEncrypted()) return null;
												if (e.isRedaction()) return null;
												if (!this.isRoomEncrypted(e.getRoomId())) return null;
												if (!this.crypto && this.usingExternalCrypto) return null;
												if (e.getType() === N.EventType.Reaction) return null;
												if (!this.crypto) throw new Error("This room is configured to use encryption, but your client does not support encryption.");
												return this.crypto.encryptEvent(e, t)
											}
											getEncryptedIfNeededEventType(e, t) {
												return t === N.EventType.Reaction ? t : this.isRoomEncrypted(e) ? N.EventType.RoomMessageEncrypted : t
											}
											updatePendingEventStatus(e, t, r) {
												e ? e.updatePendingEvent(t, r) : t.setStatus(r)
											}
											sendEventHttpRequest(e) {
												let t = e.getTxnId();
												t || (t = this.makeTxnId(), e.setTxnId(t));
												const r = {
													$roomId: e.getRoomId(),
													$eventType: e.getWireType(),
													$stateKey: e.getStateKey(),
													$txnId: t
												};
												let n;
												if (e.isState()) {
													let t = "/rooms/$roomId/state/$eventType";
													e.getStateKey() && e.getStateKey().length > 0 && (t = "/rooms/$roomId/state/$eventType/$stateKey"), n = v.encodeUri(t, r)
												} else if (e.isRedaction()) {
													const t = "/rooms/$roomId/redact/$redactsEventId/$txnId";
													n = v.encodeUri(t, Object.assign({
														$redactsEventId: e.event.redacts
													}, r))
												} else n = v.encodeUri("/rooms/$roomId/send/$eventType/$txnId", r);
												return this.http.authedRequest(I.Method.Put, n, void 0, e.getWireContent()).then(t => (k.logger.log(`Event sent to ${e.getRoomId()} with event id ${t.event_id}`), t))
											}
											redactEvent(e, t, r, n, i) {
												(null == r ? void 0 : r.startsWith(le)) || (i = n, n = r, r = t, t = null);
												const o = null == i ? void 0 : i.reason;
												return this.sendCompleteEvent(e, t, {
													type: N.EventType.RoomRedaction,
													content: {
														reason: o
													},
													redacts: r
												}, n)
											}
											sendMessage(e, t, r, n) {
												"string" != typeof t && null !== t && (n = r, r = t, t = null);
												let i = N.EventType.RoomMessage,
													o = r;
												const s = (e = {}, t = !0) => {
														let r;
														if (e.msgtype === N.MsgType.Text ? r = c.MessageEvent.from(e.body, e.formatted_body).serialize() : e.msgtype === N.MsgType.Emote ? r = c.EmoteEvent.from(e.body, e.formatted_body).serialize() : e.msgtype === N.MsgType.Notice && (r = c.NoticeEvent.from(e.body, e.formatted_body).serialize()), r && e["m.new_content"] && t) {
															const t = s(e["m.new_content"], !1);
															t && (r.content["m.new_content"] = t.content)
														}
														if (r)
															for (const [n, i] of Object.entries(e)) r.content.hasOwnProperty(n) || (r.content[n] = i);
														return r
													},
													a = s(o);
												return a && (i = a.type, o = a.content), this.sendEvent(e, t, i, o, n)
											}
											sendTextMessage(e, t, r, n) {
												(null == t ? void 0 : t.startsWith(le)) || null === t || (n = r, r = t, t = null);
												const i = j.makeTextMessage(r);
												return this.sendMessage(e, t, i, n)
											}
											sendNotice(e, t, r, n) {
												(null == t ? void 0 : t.startsWith(le)) || null === t || (n = r, r = t, t = null);
												const i = j.makeNotice(r);
												return this.sendMessage(e, t, i, n)
											}
											sendEmoteMessage(e, t, r, n) {
												(null == t ? void 0 : t.startsWith(le)) || null === t || (n = r, r = t, t = null);
												const i = j.makeEmoteMessage(r);
												return this.sendMessage(e, t, i, n)
											}
											sendImageMessage(e, t, r, n, i = "Image") {
												(null == t ? void 0 : t.startsWith(le)) || null === t || (i = n || "Image", n = r, r = t, t = null);
												const o = {
													msgtype: N.MsgType.Image,
													url: r,
													info: n,
													body: i
												};
												return this.sendMessage(e, t, o)
											}
											sendStickerMessage(e, t, r, n, i = "Sticker") {
												(null == t ? void 0 : t.startsWith(le)) || null === t || (i = n || "Sticker", n = r, r = t, t = null);
												const o = {
													url: r,
													info: n,
													body: i
												};
												return this.sendEvent(e, t, N.EventType.Sticker, o)
											}
											sendHtmlMessage(e, t, r, n) {
												(null == t ? void 0 : t.startsWith(le)) || null === t || (n = r, r = t, t = null);
												const i = j.makeHtmlMessage(r, n);
												return this.sendMessage(e, t, i)
											}
											sendHtmlNotice(e, t, r, n) {
												(null == t ? void 0 : t.startsWith(le)) || null === t || (n = r, r = t, t = null);
												const i = j.makeHtmlNotice(r, n);
												return this.sendMessage(e, t, i)
											}
											sendHtmlEmote(e, t, r, n) {
												(null == t ? void 0 : t.startsWith(le)) || null === t || (n = r, r = t, t = null);
												const i = j.makeHtmlEmote(r, n);
												return this.sendMessage(e, t, i)
											}
											sendReceipt(e, t, r, n = !1) {
												return s(this, void 0, void 0, (function*() {
													if (this.isGuest()) return Promise.resolve({});
													const i = v.encodeUri("/rooms/$roomId/receipt/$receiptType/$eventId", {
														$roomId: e.getRoomId(),
														$receiptType: t,
														$eventId: e.getId()
													});
													if (this.canSupport.get(ie.Feature.ThreadUnreadNotifications) !== ie.ServerSupport.Unsupported && !n) {
														const t = !!e.threadRootId;
														r = Object.assign(Object.assign({}, r), {
															thread_id: t ? e.threadRootId : te.MAIN_ROOM_TIMELINE
														})
													}
													const o = this.http.authedRequest(I.Method.Post, i, void 0, r || {}),
														s = this.getRoom(e.getRoomId());
													return s && this.credentials.userId && s.addLocalEchoReceipt(this.credentials.userId, e, t), o
												}))
											}
											sendReadReceipt(e, t = Y.ReceiptType.Read, r = !1) {
												return s(this, void 0, void 0, (function*() {
													if (!e) return;
													const n = e.getId(),
														i = this.getRoom(e.getRoomId());
													if (null == i ? void 0 : i.hasPendingEvent(n)) throw new Error(`Cannot set read receipt to a pending event (${n})`);
													return this.sendReceipt(e, t, {}, r)
												}))
											}
											setRoomReadMarkers(e, t, r, n) {
												return s(this, void 0, void 0, (function*() {
													const i = this.getRoom(e);
													if (i && i.hasPendingEvent(t)) throw new Error(`Cannot set read marker to a pending event (${t})`);
													let o, s;
													if (r) {
														if (o = r.getId(), null == i ? void 0 : i.hasPendingEvent(o)) throw new Error(`Cannot set read receipt to a pending event (${o})`);
														null == i || i.addLocalEchoReceipt(this.credentials.userId, r, Y.ReceiptType.Read)
													}
													if (n) {
														if (s = n.getId(), null == i ? void 0 : i.hasPendingEvent(s)) throw new Error(`Cannot set read receipt to a pending event (${s})`);
														null == i || i.addLocalEchoReceipt(this.credentials.userId, n, Y.ReceiptType.ReadPrivate)
													}
													return yield this.setRoomReadMarkersHttpRequest(e, t, o, s)
												}))
											}
											getUrlPreview(e, t) {
												t = 6e4 * Math.floor(t / 6e4);
												const r = new URL(e);
												r.hash = "";
												const n = t + "_" + (e = r.toString()),
													i = this.urlPreviewCache[n];
												if (i) return i;
												const o = this.http.authedRequest(I.Method.Get, "/preview_url", {
													url: e,
													ts: t.toString()
												}, void 0, {
													prefix: I.MediaPrefix.R0
												});
												return this.urlPreviewCache[n] = o, o
											}
											sendTyping(e, t, r) {
												if (this.isGuest()) return Promise.resolve({});
												const n = v.encodeUri("/rooms/$roomId/typing/$userId", {
														$roomId: e,
														$userId: this.getUserId()
													}),
													i = {
														typing: t
													};
												return t && (i.timeout = r || 2e4), this.http.authedRequest(I.Method.Put, n, void 0, i)
											}
											getRoomUpgradeHistory(e, t = !1) {
												let r = this.getRoom(e);
												if (!r) return [];
												const n = [r];
												let i = r.currentState.getStateEvents(N.EventType.RoomCreate, "");
												for (; i;) {
													const e = i.getContent().predecessor;
													if (!e || !e.room_id) break; {
														const r = this.getRoom(e.room_id);
														if (!r) break;
														if (t) {
															const e = r.currentState.getStateEvents(N.EventType.RoomTombstone, "");
															if (!e || e.getContent().replacement_room !== r.roomId) break
														}
														n.splice(0, 0, r), i = r.currentState.getStateEvents(N.EventType.RoomCreate, "")
													}
												}
												let o = r.currentState.getStateEvents(N.EventType.RoomTombstone, "");
												for (; o;) {
													const e = this.getRoom(o.getContent().replacement_room);
													if (!e) break;
													if (e.roomId === r.roomId) break;
													if (t) {
														if (!(i = e.currentState.getStateEvents(N.EventType.RoomCreate, "")) || !i.getContent().predecessor) break;
														if (i.getContent().predecessor.room_id !== r.roomId) break
													}
													if (n.push(e), new Set(n.map(e => e.roomId)).size < n.length) return n.slice(0, n.length - 1);
													o = (r = e).currentState.getStateEvents(N.EventType.RoomTombstone, "")
												}
												return n
											}
											invite(e, t, r) {
												return this.membershipChange(e, t, "invite", r)
											}
											inviteByEmail(e, t) {
												return this.inviteByThreePid(e, "email", t)
											}
											inviteByThreePid(e, t, r) {
												var n;
												return s(this, void 0, void 0, (function*() {
													const i = v.encodeUri("/rooms/$roomId/invite", {
															$roomId: e
														}),
														o = this.getIdentityServerUrl(!0);
													if (!o) return Promise.reject(new I.MatrixError({
														error: "No supplied identity server URL",
														errcode: "ORG.MATRIX.JSSDK_MISSING_PARAM"
													}));
													const s = {
														id_server: o,
														medium: t,
														address: r
													};
													if ((null === (n = this.identityServer) || void 0 === n ? void 0 : n.getAccessToken) && (yield this.doesServerAcceptIdentityAccessToken())) {
														const e = yield this.identityServer.getAccessToken();
														e && (s.id_access_token = e)
													}
													return this.http.authedRequest(I.Method.Post, i, void 0, s)
												}))
											}
											leave(e) {
												return this.membershipChange(e, void 0, "leave")
											}
											leaveRoomChain(e, t = !0) {
												const r = this.getRoomUpgradeHistory(e);
												let n = r;
												if (!t) {
													n = [];
													for (const t of r)
														if (n.push(t), t.roomId === e) break
												}
												const i = {},
													o = [],
													s = e => this.leave(e).then(() => {
														delete i[e]
													}).catch(t => (i[e] = t, null));
												for (const a of n) o.push(s(a.roomId));
												return Promise.all(o).then(() => i)
											}
											ban(e, t, r) {
												return this.membershipChange(e, t, "ban", r)
											}
											forget(e, t = !0) {
												const r = this.membershipChange(e, void 0, "forget");
												return t ? r.then(t => (this.store.removeRoom(e), this.emit(ue.DeleteRoom, e), t)) : r
											}
											unban(e, t) {
												const r = v.encodeUri("/rooms/$roomId/unban", {
														$roomId: e
													}),
													n = {
														user_id: t
													};
												return this.http.authedRequest(I.Method.Post, r, void 0, n)
											}
											kick(e, t, r) {
												const n = v.encodeUri("/rooms/$roomId/kick", {
														$roomId: e
													}),
													i = {
														user_id: t,
														reason: r
													};
												return this.http.authedRequest(I.Method.Post, n, void 0, i)
											}
											membershipChange(e, t, r, n) {
												const i = v.encodeUri("/rooms/$room_id/$membership", {
													$room_id: e,
													$membership: r
												});
												return this.http.authedRequest(I.Method.Post, i, void 0, {
													user_id: t,
													reason: n
												})
											}
											getPushActionsForEvent(e, t = !1) {
												return e.getPushActions() && !t || e.setPushActions(this.pushProcessor.actionsForEvent(e)), e.getPushActions()
											}
											setProfileInfo(e, t) {
												const r = v.encodeUri("/profile/$userId/$info", {
													$userId: this.credentials.userId,
													$info: e
												});
												return this.http.authedRequest(I.Method.Put, r, void 0, t)
											}
											setDisplayName(e) {
												return s(this, void 0, void 0, (function*() {
													const t = yield this.setProfileInfo("displayname", {
														displayname: e
													}), r = this.getUser(this.getUserId());
													return r && (r.displayName = e, r.emit(x.UserEvent.DisplayName, r.events.presence, r)), t
												}))
											}
											setAvatarUrl(e) {
												return s(this, void 0, void 0, (function*() {
													const t = yield this.setProfileInfo("avatar_url", {
														avatar_url: e
													}), r = this.getUser(this.getUserId());
													return r && (r.avatarUrl = e, r.emit(x.UserEvent.AvatarUrl, r.events.presence, r)), t
												}))
											}
											mxcUrlToHttp(e, t, r, n, i) {
												return (0, O.getHttpUriForMxc)(this.baseUrl, e, t, r, n, i)
											}
											setPresence(e) {
												return s(this, void 0, void 0, (function*() {
													const t = v.encodeUri("/presence/$userId/status", {
														$userId: this.credentials.userId
													});
													if (-1 === ["offline", "online", "unavailable"].indexOf(e.presence)) throw new Error("Bad presence value: " + e.presence);
													yield this.http.authedRequest(I.Method.Put, t, void 0, e)
												}))
											}
											getPresence(e) {
												const t = v.encodeUri("/presence/$userId/status", {
													$userId: e
												});
												return this.http.authedRequest(I.Method.Get, t)
											}
											scrollback(e, t = 30) {
												let r = 0,
													n = this.ongoingScrollbacks[e.roomId] || {};
												if (n.promise) return n.promise;
												if (n.errorTs) {
													const e = Date.now() - n.errorTs;
													r = Math.max(oe - e, 0)
												}
												if (null === e.oldState.paginationToken) return Promise.resolve(e);
												const i = this.store.scrollback(e, t).length;
												if (i === t) return Promise.resolve(e);
												t -= i;
												const o = new Promise((n, i) => {
													(0, g.sleep)(r).then(() => this.createMessagesRequest(e.roomId, e.oldState.paginationToken, t, m.Direction.Backward)).then(t => {
														const r = t.chunk.map(this.getEventMapper());
														if (t.state) {
															const r = t.state.map(this.getEventMapper());
															e.currentState.setUnknownStateEvents(r)
														}
														const [i, o] = e.partitionThreadedEvents(r);
														this.processBeaconEvents(e, i), e.addEventsToTimeline(i, !0, e.getLiveTimeline()), this.processThreadEvents(e, o, !0), e.oldState.paginationToken = t.end, 0 === t.chunk.length && (e.oldState.paginationToken = null), this.store.storeEvents(e, r, t.end, !0), delete this.ongoingScrollbacks[e.roomId], n(e)
													}).catch(t => {
														this.ongoingScrollbacks[e.roomId] = {
															errorTs: Date.now()
														}, i(t)
													})
												});
												return n = {
													promise: o
												}, this.ongoingScrollbacks[e.roomId] = n, o
											}
											getEventMapper(e) {
												return (0, U.eventMapperFor)(this, e || {})
											}
											getEventTimeline(e, t) {
												var r, n, i, o;
												return s(this, void 0, void 0, (function*() {
													if (!this.timelineSupport) throw new Error("timeline support is disabled. Set the 'timelineSupport' parameter to true when creating MatrixClient to enable it.");
													if (!(null == e ? void 0 : e.room)) throw new Error("getEventTimeline only supports room timelines");
													if (e.getTimelineForEvent(t)) return e.getTimelineForEvent(t);
													if (e.thread && this.supportsExperimentalThreads()) return this.getThreadTimeline(e, t);
													const s = v.encodeUri("/rooms/$roomId/context/$eventId", {
														$roomId: e.room.roomId,
														$eventId: t
													});
													let a = void 0;
													(null === (r = this.clientOpts) || void 0 === r ? void 0 : r.lazyLoadMembers) && (a = {
														filter: JSON.stringify(f.Filter.LAZY_LOADING_MESSAGES_FILTER)
													});
													const c = yield this.http.authedRequest(I.Method.Get, s, a);
													if (!c.event) throw new Error("'event' not in '/context' result - homeserver too old?");
													if (e.getTimelineForEvent(t)) return e.getTimelineForEvent(t);
													const l = this.getEventMapper(),
														u = l(c.event);
													if (u.isRelation(J.THREAD_RELATION_TYPE.name)) return void k.logger.warn("Tried loading a regular timeline at the position of a thread event");
													const d = [...c.events_after.reverse().map(l), u, ...c.events_before.map(l)];
													let h = e.getTimelineForEvent(d[0].getId());
													h ? h.getState(m.EventTimeline.BACKWARDS).setUnknownStateEvents(c.state.map(l)) : ((h = e.addTimeline()).initialiseState(c.state.map(l)), h.getState(m.EventTimeline.FORWARDS).paginationToken = c.end);
													const [p, g] = e.room.partitionThreadedEvents(d);
													return e.addEventsToTimeline(p, !0, h, c.start), this.processThreadEvents(e.room, g, !0), this.processBeaconEvents(e.room, p), null !== (o = null !== (n = e.getTimelineForEvent(t)) && void 0 !== n ? n : null === (i = e.room.findThreadForEvent(u)) || void 0 === i ? void 0 : i.liveTimeline) && void 0 !== o ? o : h
												}))
											}
											getThreadTimeline(e, t) {
												var r, n, i, o, a, c, l, u;
												return s(this, void 0, void 0, (function*() {
													if (!this.supportsExperimentalThreads()) throw new Error("could not get thread timeline: no client support");
													if (!e.room) throw new Error("could not get thread timeline: not a room timeline");
													if (!e.thread) throw new Error("could not get thread timeline: not a thread timeline");
													const s = v.encodeUri("/rooms/$roomId/context/$eventId", {
															$roomId: e.room.roomId,
															$eventId: t
														}),
														d = {
															limit: "0"
														};
													(null === (r = this.clientOpts) || void 0 === r ? void 0 : r.lazyLoadMembers) && (d.filter = JSON.stringify(f.Filter.LAZY_LOADING_MESSAGES_FILTER));
													const h = yield this.http.authedRequest(I.Method.Get, s, d), p = this.getEventMapper(), g = p(h.event);
													if (e.canContain(g) && J.Thread.hasServerSideSupport) {
														if (J.Thread.hasServerSideFwdPaginationSupport) {
															if (!e.thread) throw new Error("could not get thread timeline: not a thread timeline");
															const r = e.thread,
																s = yield this.fetchRelations(e.room.roomId, r.id, J.THREAD_RELATION_TYPE.name, null, {
																	dir: m.Direction.Backward,
																	from: h.start
																}), c = yield this.fetchRelations(e.room.roomId, r.id, J.THREAD_RELATION_TYPE.name, null, {
																	dir: m.Direction.Forward,
																	from: h.end
																}), l = [...c.chunk.reverse().map(p), g, ...s.chunk.map(p)];
															for (const t of l) yield null === (n = e.thread) || void 0 === n ? void 0 : n.processEvent(t);
															let u = e.getTimelineForEvent(g.getId());
															return u ? u.getState(m.EventTimeline.BACKWARDS).setUnknownStateEvents(h.state.map(p)) : (u = e.addTimeline()).initialiseState(h.state.map(p)), e.addEventsToTimeline(l, !0, u, c.next_batch), s.next_batch || e.addEventsToTimeline([p(s.original_event)], !0, u, null), u.setPaginationToken(null !== (i = s.next_batch) && void 0 !== i ? i : null, m.Direction.Backward), u.setPaginationToken(null !== (o = c.next_batch) && void 0 !== o ? o : null, m.Direction.Forward), this.processBeaconEvents(e.room, l), null !== (a = e.getTimelineForEvent(t)) && void 0 !== a ? a : u
														} {
															const t = e.thread,
																r = yield this.fetchRelations(e.room.roomId, t.id, J.THREAD_RELATION_TYPE.name, null, {
																	dir: m.Direction.Backward,
																	from: h.start
																}), n = [];
															let i = h.end;
															for (; i;) {
																const r = yield this.fetchRelations(e.room.roomId, t.id, J.THREAD_RELATION_TYPE.name, null, {
																	dir: m.Direction.Forward,
																	from: i
																});
																i = null !== (c = r.next_batch) && void 0 !== c ? c : null, n.push(...r.chunk)
															}
															const o = [...n.reverse().map(p), g, ...r.chunk.map(p)];
															for (const a of o) yield null === (l = e.thread) || void 0 === l ? void 0 : l.processEvent(a);
															const s = e.getLiveTimeline();
															return s.getState(m.EventTimeline.BACKWARDS).setUnknownStateEvents(h.state.map(p)), e.addEventsToTimeline(o, !0, s, null), r.next_batch || e.addEventsToTimeline([p(r.original_event)], !0, s, null), s.setPaginationToken(null !== (u = r.next_batch) && void 0 !== u ? u : null, m.Direction.Backward), s.setPaginationToken(null, m.Direction.Forward), this.processBeaconEvents(e.room, o), s
														}
													}
												}))
											}
											getLatestTimeline(e) {
												var t, r, n, i;
												return s(this, void 0, void 0, (function*() {
													if (!this.timelineSupport) throw new Error("timeline support is disabled. Set the 'timelineSupport' parameter to true when creating MatrixClient to enable it.");
													if (!e.room) throw new Error("getLatestTimeline only supports room timelines");
													let o;
													if (null !== e.threadListType) {
														const r = yield this.createThreadListMessagesRequest(e.room.roomId, null, 1, m.Direction.Backward, e.threadListType, e.getFilter());
														o = null === (t = r.chunk) || void 0 === t ? void 0 : t[0]
													} else if (e.thread && J.Thread.hasServerSideSupport) {
														const t = yield this.fetchRelations(e.room.roomId, e.thread.id, J.THREAD_RELATION_TYPE.name, null, {
															dir: m.Direction.Backward,
															limit: 1
														});
														o = null === (r = t.chunk) || void 0 === r ? void 0 : r[0]
													} else {
														const t = v.encodeUri("/rooms/$roomId/messages", {
																$roomId: e.room.roomId
															}),
															r = {
																dir: "b"
															};
														(null === (n = this.clientOpts) || void 0 === n ? void 0 : n.lazyLoadMembers) && (r.filter = JSON.stringify(f.Filter.LAZY_LOADING_MESSAGES_FILTER));
														const s = yield this.http.authedRequest(I.Method.Get, t, r);
														o = null === (i = s.chunk) || void 0 === i ? void 0 : i[0]
													}
													if (!o) throw new Error("No message returned when trying to construct getLatestTimeline");
													return this.getEventTimeline(e, o.event_id)
												}))
											}
											createMessagesRequest(e, t, r = 30, n, i) {
												var o, s;
												const a = v.encodeUri("/rooms/$roomId/messages", {
														$roomId: e
													}),
													c = {
														limit: r.toString(),
														dir: n
													};
												t && (c.from = t);
												let l = null;
												return (null === (o = this.clientOpts) || void 0 === o ? void 0 : o.lazyLoadMembers) && (l = Object.assign({}, f.Filter.LAZY_LOADING_MESSAGES_FILTER)), i && (l = l || {}, Object.assign(l, null === (s = i.getRoomTimelineFilterComponent()) || void 0 === s ? void 0 : s.toJSON())), l && (c.filter = JSON.stringify(l)), this.http.authedRequest(I.Method.Get, a, c)
											}
											createThreadListMessagesRequest(e, t, r = 30, n = m.Direction.Backward, i = J.ThreadFilterType.All, o) {
												var s, a;
												const c = v.encodeUri("/rooms/$roomId/threads", {
														$roomId: e
													}),
													l = {
														limit: r.toString(),
														dir: n,
														include: (0, J.threadFilterTypeToFilter)(i)
													};
												t && (l.from = t);
												let u = {};
												(null === (s = this.clientOpts) || void 0 === s ? void 0 : s.lazyLoadMembers) && (u = Object.assign({}, f.Filter.LAZY_LOADING_MESSAGES_FILTER)), o && (u = Object.assign(Object.assign({}, u), null === (a = o.getRoomTimelineFilterComponent()) || void 0 === a ? void 0 : a.toJSON())), Object.keys(u).length && (l.filter = JSON.stringify(u));
												const d = {
													prefix: J.Thread.hasServerSideListSupport === J.FeatureSupport.Stable ? "/_matrix/client/v1" : "/_matrix/client/unstable/org.matrix.msc3856"
												};
												return this.http.authedRequest(I.Method.Get, c, l, void 0, d).then(e => {
													var t;
													return Object.assign(Object.assign({}, e), {
														chunk: null === (t = e.chunk) || void 0 === t ? void 0 : t.reverse(),
														start: e.prev_batch,
														end: e.next_batch
													})
												})
											}
											paginateEventTimeline(e, t) {
												var r, n, i;
												const o = e.getTimelineSet() === this.notifTimelineSet,
													a = this.getRoom(e.getRoomId()),
													c = e.getTimelineSet().threadListType,
													l = e.getTimelineSet().thread,
													u = (t = t || {}).backwards || !1;
												if (o && !u) throw new Error("paginateNotifTimeline can only paginate backwards");
												const d = u ? m.EventTimeline.BACKWARDS : m.EventTimeline.FORWARDS,
													h = e.getPaginationToken(d),
													f = e.paginationRequests[d];
												if (f) return f;
												let p, v, g;
												if (o) p = "/notifications", v = {
													limit: (null !== (r = t.limit) && void 0 !== r ? r : 30).toString(),
													only: "highlight"
												}, h && "end" !== h && (v.from = h), g = this.http.authedRequest(I.Method.Get, "/notifications", v).then(t => s(this, void 0, void 0, (function*() {
													const r = t.next_token,
														n = [];
													for (let e = 0; e < t.notifications.length; e++) {
														const r = t.notifications[e],
															i = this.getEventMapper()(r.event);
														i.setPushActions(y.PushProcessor.actionListToActionsObject(r.actions)), i.event.room_id = r.room_id, n[e] = i
													}
													const i = e.getTimelineSet();
													return i.addEventsToTimeline(n, u, e, r), this.processBeaconEvents(i.room, n), u && !t.next_token && e.setPaginationToken(null, d), Boolean(t.next_token)
												}))).finally(() => {
													e.paginationRequests[d] = null
												}), e.paginationRequests[d] = g;
												else if (null !== c) {
													if (!a) throw new Error("Unknown room " + e.getRoomId());
													if (!J.Thread.hasServerSideFwdPaginationSupport && d === m.Direction.Forward) throw new Error("Cannot paginate threads forwards without server-side support for MSC 3715");
													g = this.createThreadListMessagesRequest(e.getRoomId(), h, t.limit, d, c, e.getFilter()).then(t => {
														if (t.state) {
															const r = e.getState(d),
																n = t.state.map(this.getEventMapper());
															r.setUnknownStateEvents(n)
														}
														const r = t.end,
															n = t.chunk.map(this.getEventMapper());
														return e.getTimelineSet().addEventsToTimeline(n, u, e, r), this.processBeaconEvents(a, n), this.processThreadRoots(a, n, u), u && t.end == t.start && e.setPaginationToken(null, d), t.end !== t.start
													}).finally(() => {
														e.paginationRequests[d] = null
													}), e.paginationRequests[d] = g
												} else if (l) {
													if (!this.getRoom(null !== (n = e.getRoomId()) && void 0 !== n ? n : void 0)) throw new Error("Unknown room " + e.getRoomId());
													g = this.fetchRelations(null !== (i = e.getRoomId()) && void 0 !== i ? i : "", l.id, J.THREAD_RELATION_TYPE.name, null, {
														dir: d,
														limit: t.limit,
														from: null != h ? h : void 0
													}).then(t => s(this, void 0, void 0, (function*() {
														var r, n;
														const i = this.getEventMapper(),
															o = t.chunk.map(i);
														for (const t of o) yield null === (n = null === (r = e.getTimelineSet()) || void 0 === r ? void 0 : r.thread) || void 0 === n ? void 0 : n.processEvent(t);
														const s = t.next_batch,
															a = e.getTimelineSet();
														return a.addEventsToTimeline(o, u, e, null != s ? s : null), !s && u && a.addEventsToTimeline([i(t.original_event)], !0, e, null), this.processBeaconEvents(a.room, o), u && !s && e.setPaginationToken(null, d), Boolean(s)
													}))).finally(() => {
														e.paginationRequests[d] = null
													}), e.paginationRequests[d] = g
												} else {
													if (!a) throw new Error("Unknown room " + e.getRoomId());
													g = this.createMessagesRequest(e.getRoomId(), h, t.limit, d, e.getFilter()).then(t => {
														if (t.state) {
															const r = e.getState(d),
																n = t.state.map(this.getEventMapper());
															r.setUnknownStateEvents(n)
														}
														const r = t.end,
															n = t.chunk.map(this.getEventMapper()),
															i = e.getTimelineSet(),
															[o] = a.partitionThreadedEvents(n);
														i.addEventsToTimeline(o, u, e, r), this.processBeaconEvents(a, o), this.processThreadRoots(a, o.filter(e => e.isRelation(J.THREAD_RELATION_TYPE.name)), !1);
														const s = void 0 === t.end || t.end === t.start;
														return u && s && e.setPaginationToken(null, d), !s
													}).finally(() => {
														e.paginationRequests[d] = null
													}), e.paginationRequests[d] = g
												}
												return g
											}
											resetNotifTimelineSet() {
												this.notifTimelineSet && this.notifTimelineSet.resetLiveTimeline("end")
											}
											peekInRoom(e) {
												var t;
												return null === (t = this.peekSync) || void 0 === t || t.stopPeeking(), this.peekSync = new l.SyncApi(this, this.clientOpts), this.peekSync.peek(e)
											}
											stopPeeking() {
												this.peekSync && (this.peekSync.stopPeeking(), this.peekSync = null)
											}
											setGuestAccess(e, t) {
												const r = this.sendStateEvent(e, N.EventType.RoomGuestAccess, {
													guest_access: t.allowJoin ? "can_join" : "forbidden"
												}, "");
												let n = Promise.resolve(void 0);
												return t.allowRead && (n = this.sendStateEvent(e, N.EventType.RoomHistoryVisibility, {
													history_visibility: "world_readable"
												}, "")), Promise.all([n, r]).then()
											}
											requestRegisterEmailToken(e, t, r, n) {
												return this.requestTokenFromEndpoint("/register/email/requestToken", {
													email: e,
													client_secret: t,
													send_attempt: r,
													next_link: n
												})
											}
											requestRegisterMsisdnToken(e, t, r, n, i) {
												return this.requestTokenFromEndpoint("/register/msisdn/requestToken", {
													country: e,
													phone_number: t,
													client_secret: r,
													send_attempt: n,
													next_link: i
												})
											}
											requestAdd3pidEmailToken(e, t, r, n) {
												return this.requestTokenFromEndpoint("/account/3pid/email/requestToken", {
													email: e,
													client_secret: t,
													send_attempt: r,
													next_link: n
												})
											}
											requestAdd3pidMsisdnToken(e, t, r, n, i) {
												return this.requestTokenFromEndpoint("/account/3pid/msisdn/requestToken", {
													country: e,
													phone_number: t,
													client_secret: r,
													send_attempt: n,
													next_link: i
												})
											}
											requestPasswordEmailToken(e, t, r, n) {
												return this.requestTokenFromEndpoint("/account/password/email/requestToken", {
													email: e,
													client_secret: t,
													send_attempt: r,
													next_link: n
												})
											}
											requestPasswordMsisdnToken(e, t, r, n, i) {
												return this.requestTokenFromEndpoint("/account/password/msisdn/requestToken", {
													country: e,
													phone_number: t,
													client_secret: r,
													send_attempt: n,
													next_link: i
												})
											}
											requestTokenFromEndpoint(e, t) {
												var r;
												return s(this, void 0, void 0, (function*() {
													const n = Object.assign({}, t);
													if (!(yield this.doesServerSupportSeparateAddAndBind()) && this.idBaseUrl) {
														const e = new URL(this.idBaseUrl);
														if (n.id_server = e.host, (null === (r = this.identityServer) || void 0 === r ? void 0 : r.getAccessToken) && (yield this.doesServerAcceptIdentityAccessToken())) {
															const e = yield this.identityServer.getAccessToken();
															e && (n.id_access_token = e)
														}
													}
													return this.http.request(I.Method.Post, e, void 0, n)
												}))
											}
											getRoomPushRule(e, t) {
												var r, n;
												if (this.pushRules) return null === (n = null === (r = this.pushRules[e]) || void 0 === r ? void 0 : r.room) || void 0 === n ? void 0 : n.find(e => e.rule_id === t);
												throw new Error("SyncApi.sync() must be done before accessing to push rules.")
											}
											setRoomMutePushRule(e, t, r) {
												let n, i = !1;
												const o = this.getRoomPushRule(e, t);
												if ((null == o ? void 0 : o.actions.includes(V.PushRuleActionName.DontNotify)) && (i = !0), r)
													if (o) {
														if (!i) {
															const r = v.defer();
															this.deletePushRule(e, V.PushRuleKind.RoomSpecific, o.rule_id).then(() => {
																this.addPushRule(e, V.PushRuleKind.RoomSpecific, t, {
																	actions: [V.PushRuleActionName.DontNotify]
																}).then(() => {
																	r.resolve()
																}).catch(e => {
																	r.reject(e)
																})
															}).catch(e => {
																r.reject(e)
															}), n = r.promise
														}
													} else n = this.addPushRule(e, V.PushRuleKind.RoomSpecific, t, {
														actions: [V.PushRuleActionName.DontNotify]
													});
												else i && (n = this.deletePushRule(e, V.PushRuleKind.RoomSpecific, o.rule_id));
												if (n) return new Promise((e, t) => {
													n.then(() => {
														this.getPushRules().then(t => {
															this.pushRules = t, e()
														}).catch(e => {
															t(e)
														})
													}).catch(e => {
														this.getPushRules().then(r => {
															this.pushRules = r, t(e)
														}).catch(r => {
															t(e)
														})
													})
												})
											}
											searchMessageText(e) {
												const t = {
													search_term: e.query
												};
												return "keys" in e && (t.keys = e.keys), this.search({
													body: {
														search_categories: {
															room_events: t
														}
													}
												})
											}
											searchRoomEvents(e) {
												const t = {
														search_categories: {
															room_events: {
																search_term: e.term,
																filter: e.filter,
																order_by: K.SearchOrderBy.Recent,
																event_context: {
																	before_limit: 1,
																	after_limit: 1,
																	include_profile: !0
																}
															}
														}
													},
													r = {
														_query: t,
														results: [],
														highlights: []
													};
												return this.search({
													body: t
												}).then(e => this.processRoomEventsSearch(r, e))
											}
											backPaginateRoomEventsSearch(e) {
												if (!e.next_batch) return Promise.reject(new Error("Cannot backpaginate event search any further"));
												if (e.pendingRequest) return e.pendingRequest;
												const t = {
														body: e._query,
														next_batch: e.next_batch
													},
													r = this.search(t, e.abortSignal).then(t => this.processRoomEventsSearch(e, t)).finally(() => {
														e.pendingRequest = void 0
													});
												return e.pendingRequest = r, r
											}
											processRoomEventsSearch(e, t) {
												var r, n;
												const i = t.search_categories.room_events;
												e.count = i.count, e.next_batch = i.next_batch;
												const o = new Set(i.highlights);
												e.highlights.forEach(e => {
													o.add(e)
												}), e.highlights = Array.from(o);
												const s = this.getEventMapper(),
													a = null !== (n = null === (r = i.results) || void 0 === r ? void 0 : r.length) && void 0 !== n ? n : 0;
												for (let c = 0; c < a; c++) {
													const t = A.SearchResult.fromJson(i.results[c], s),
														r = this.getRoom(t.context.getEvent().getRoomId());
													if (r)
														for (const e of t.context.getTimeline()) {
															const t = r.getMember(e.getSender());
															!e.sender && t && (e.sender = t)
														}
													e.results.push(t)
												}
												return e
											}
											syncLeftRooms() {
												if (this.syncedLeftRooms) return Promise.resolve([]);
												if (this.syncLeftRoomsPromise) return this.syncLeftRoomsPromise;
												const e = new l.SyncApi(this, this.clientOpts);
												return this.syncLeftRoomsPromise = e.syncLeftRooms(), this.syncLeftRoomsPromise.then(() => {
													k.logger.log("Marking success of sync left room request"), this.syncedLeftRooms = !0
												}).finally(() => {
													this.syncLeftRoomsPromise = void 0
												}), this.syncLeftRoomsPromise
											}
											createFilter(e) {
												const t = v.encodeUri("/user/$userId/filter", {
													$userId: this.credentials.userId
												});
												return this.http.authedRequest(I.Method.Post, t, void 0, e).then(t => {
													const r = f.Filter.fromJson(this.credentials.userId, t.filter_id, e);
													return this.store.storeFilter(r), r
												})
											}
											getFilter(e, t, r) {
												if (r) {
													const r = this.store.getFilter(e, t);
													if (r) return Promise.resolve(r)
												}
												const n = v.encodeUri("/user/$userId/filter/$filterId", {
													$userId: e,
													$filterId: t
												});
												return this.http.authedRequest(I.Method.Get, n).then(r => {
													const n = f.Filter.fromJson(e, t, r);
													return this.store.storeFilter(n), n
												})
											}
											getOrCreateFilter(e, t) {
												return s(this, void 0, void 0, (function*() {
													const r = this.store.getFilterIdByName(e);
													let n;
													if (r) {
														try {
															const e = yield this.getFilter(this.credentials.userId, r, !0);
															if (e) {
																const i = e.getDefinition(),
																	o = t.getDefinition();
																v.deepCompare(i, o) && (n = r)
															}
														} catch (o) {
															if ("M_UNKNOWN" !== o.errcode && "M_NOT_FOUND" !== o.errcode) throw o
														}
														n || this.store.setFilterIdByName(e, void 0)
													}
													if (n) return n;
													const i = yield this.createFilter(t.getDefinition());
													return this.store.setFilterIdByName(e, i.filterId), i.filterId
												}))
											}
											getOpenIdToken() {
												const e = v.encodeUri("/user/$userId/openid/request_token", {
													$userId: this.credentials.userId
												});
												return this.http.authedRequest(I.Method.Post, e, void 0, {})
											}
											turnServer() {
												return this.http.authedRequest(I.Method.Get, "/voip/turnServer")
											}
											getTurnServers() {
												return this.turnServers || []
											}
											getTurnServersExpiry() {
												return this.turnServersExpiry
											}
											get pollingTurnServers() {
												return void 0 !== this.checkTurnServersIntervalID
											}
											checkTurnServers() {
												return s(this, void 0, void 0, (function*() {
													if (!this.canSupportVoip) return;
													let t = !1;
													const r = this.turnServersExpiry - Date.now();
													if (r > ae) k.logger.debug("TURN creds are valid for another " + r + " ms: not fetching new ones."), t = !0;
													else {
														k.logger.debug("Fetching new TURN credentials");
														try {
															const e = yield this.turnServer();
															if (e.uris) {
																k.logger.log("Got TURN URIs: " + e.uris + " refresh in " + e.ttl + " secs");
																const r = {
																	urls: e.uris,
																	username: e.username,
																	credential: e.password
																};
																this.turnServers = [r], this.turnServersExpiry = Date.now() + 1e3 * e.ttl, t = !0, this.emit(ue.TurnServers, this.turnServers)
															}
														} catch (n) {
															k.logger.error("Failed to get TURN URIs", n), 403 === n.httpStatus ? (k.logger.info("TURN access unavailable for this account: stopping credentials checks"), null !== this.checkTurnServersIntervalID && e.clearInterval(this.checkTurnServersIntervalID), this.checkTurnServersIntervalID = void 0, this.emit(ue.TurnServersError, n, !0)) : this.emit(ue.TurnServersError, n, !1)
														}
													}
													return t
												}))
											}
											setFallbackICEServerAllowed(e) {
												this.fallbackICEServerAllowed = e
											}
											isFallbackICEServerAllowed() {
												return this.fallbackICEServerAllowed
											}
											isSynapseAdministrator() {
												const e = v.encodeUri("/_synapse/admin/v1/users/$userId/admin", {
													$userId: this.getUserId()
												});
												return this.http.authedRequest(I.Method.Get, e, void 0, void 0, {
													prefix: ""
												}).then(e => e.admin)
											}
											whoisSynapseUser(e) {
												const t = v.encodeUri("/_synapse/admin/v1/whois/$userId", {
													$userId: e
												});
												return this.http.authedRequest(I.Method.Get, t, void 0, void 0, {
													prefix: ""
												})
											}
											deactivateSynapseUser(e) {
												const t = v.encodeUri("/_synapse/admin/v1/deactivate/$userId", {
													$userId: e
												});
												return this.http.authedRequest(I.Method.Post, t, void 0, void 0, {
													prefix: ""
												})
											}
											fetchClientWellKnown() {
												var e;
												return s(this, void 0, void 0, (function*() {
													this.clientWellKnownPromise = b.AutoDiscovery.getRawClientConfig(null !== (e = this.getDomain()) && void 0 !== e ? e : void 0), this.clientWellKnown = yield this.clientWellKnownPromise, this.emit(ue.ClientWellKnown, this.clientWellKnown)
												}))
											}
											getClientWellKnown() {
												return this.clientWellKnown
											}
											waitForClientWellKnown() {
												if (!this.clientRunning) throw new Error("Client is not running");
												return this.clientWellKnownPromise
											}
											storeClientOptions() {
												const e = ["boolean", "string", "number"],
													t = Object.entries(this.clientOpts).filter(([t, r]) => e.includes(typeof r)).reduce((e, [t, r]) => (e[t] = r, e), {});
												return this.store.storeClientOptions(t)
											}
											_unstable_getSharedRooms(e) {
												return s(this, void 0, void 0, (function*() {
													const t = yield this.doesServerSupportUnstableFeature("uk.half-shot.msc2666"), r = yield this.doesServerSupportUnstableFeature("uk.half-shot.msc2666.mutual_rooms");
													if (!t && !r) throw Error("Server does not support mutual_rooms API");
													const n = v.encodeUri(`/uk.half-shot.msc2666/user/${r?"mutual_rooms":"shared_rooms"}/$userId`, {
														$userId: e
													});
													return (yield this.http.authedRequest(I.Method.Get, n, void 0, void 0, {
														prefix: I.ClientPrefix.Unstable
													})).joined
												}))
											}
											getVersions() {
												return s(this, void 0, void 0, (function*() {
													if (this.serverVersionsPromise) return this.serverVersionsPromise;
													this.serverVersionsPromise = this.http.request(I.Method.Get, "/_matrix/client/versions", void 0, void 0, {
														prefix: ""
													}).catch(e => {
														throw this.serverVersionsPromise = void 0, e
													});
													const e = yield this.serverVersionsPromise;
													this.canSupport = yield(0, ie.buildFeatureSupportMap)(e);
													const t = this.canSupport.get(ie.Feature.ThreadUnreadNotifications);
													return ne.UNREAD_THREAD_NOTIFICATIONS.setPreferUnstable(t === ie.ServerSupport.Unstable), this.serverVersionsPromise
												}))
											}
											isVersionSupported(e) {
												return s(this, void 0, void 0, (function*() {
													const {
														versions: t
													} = yield this.getVersions();
													return t && t.includes(e)
												}))
											}
											doesServerSupportLazyLoading() {
												return s(this, void 0, void 0, (function*() {
													const e = yield this.getVersions();
													if (!e) return !1;
													const t = e.versions,
														r = e.unstable_features;
													return t && t.includes("r0.5.0") || r && r["m.lazy_load_members"]
												}))
											}
											doesServerRequireIdServerParam() {
												return s(this, void 0, void 0, (function*() {
													const e = yield this.getVersions();
													if (!e) return !0;
													const t = e.versions;
													if (t && t.includes("r0.6.0")) return !1;
													const r = e.unstable_features;
													return !r || (void 0 === r["m.require_identity_server"] || r["m.require_identity_server"])
												}))
											}
											doesServerAcceptIdentityAccessToken() {
												return s(this, void 0, void 0, (function*() {
													const e = yield this.getVersions();
													if (!e) return !1;
													const t = e.versions,
														r = e.unstable_features;
													return t && t.includes("r0.6.0") || r && r["m.id_access_token"]
												}))
											}
											doesServerSupportSeparateAddAndBind() {
												return s(this, void 0, void 0, (function*() {
													const e = yield this.getVersions();
													if (!e) return !1;
													const t = e.versions,
														r = e.unstable_features;
													return (null == t ? void 0 : t.includes("r0.6.0")) || (null == r ? void 0 : r["m.separate_add_and_bind"])
												}))
											}
											doesServerSupportUnstableFeature(e) {
												return s(this, void 0, void 0, (function*() {
													const t = yield this.getVersions();
													if (!t) return !1;
													const r = t.unstable_features;
													return r && !!r[e]
												}))
											}
											doesServerForceEncryptionForPreset(e) {
												return s(this, void 0, void 0, (function*() {
													const t = yield this.getVersions();
													if (!t) return !1;
													const r = t.unstable_features,
														n = e.includes("_chat") ? e.substring(0, e.indexOf("_chat")) : e;
													return r && !!r[`io.element.e2ee_forced.${n}`]
												}))
											}
											doesServerSupportThread() {
												return s(this, void 0, void 0, (function*() {
													if (yield this.isVersionSupported("v1.4")) return {
														threads: J.FeatureSupport.Stable,
														list: J.FeatureSupport.Stable,
														fwdPagination: J.FeatureSupport.Stable
													};
													try {
														const [e, t, r, n, i, o] = yield Promise.all([this.doesServerSupportUnstableFeature("org.matrix.msc3440"), this.doesServerSupportUnstableFeature("org.matrix.msc3440.stable"), this.doesServerSupportUnstableFeature("org.matrix.msc3856"), this.doesServerSupportUnstableFeature("org.matrix.msc3856.stable"), this.doesServerSupportUnstableFeature("org.matrix.msc3715"), this.doesServerSupportUnstableFeature("org.matrix.msc3715.stable")]);
														return {
															threads: (0, J.determineFeatureSupport)(t, e),
															list: (0, J.determineFeatureSupport)(n, r),
															fwdPagination: (0, J.determineFeatureSupport)(o, i)
														}
													} catch (e) {
														return {
															threads: J.FeatureSupport.None,
															list: J.FeatureSupport.None,
															fwdPagination: J.FeatureSupport.None
														}
													}
												}))
											}
											doesServerSupportLogoutDevices() {
												return this.isVersionSupported("r0.6.1")
											}
											hasLazyLoadMembersEnabled() {
												var e;
												return !!(null === (e = this.clientOpts) || void 0 === e ? void 0 : e.lazyLoadMembers)
											}
											setCanResetTimelineCallback(e) {
												this.canResetTimelineCallback = e
											}
											getCanResetTimelineCallback() {
												return this.canResetTimelineCallback
											}
											relations(e, t, r, n, i = {
												dir: m.Direction.Backward
											}) {
												var o, a;
												return s(this, void 0, void 0, (function*() {
													const s = n ? this.getEncryptedIfNeededEventType(e, n) : null,
														c = yield this.fetchRelations(e, t, r, s, i), l = this.getEventMapper(), u = c.original_event ? l(c.original_event) : void 0;
													let d = c.chunk.map(l);
													if (s === N.EventType.RoomMessageEncrypted) {
														const e = u ? d.concat(u) : d;
														yield Promise.all(e.map(e => this.decryptEventIfNeeded(e))), null !== n && (d = d.filter(e => e.getType() === n))
													}
													return u && r === N.RelationType.Replace && (d = d.filter(e => e.getSender() === u.getSender())), {
														originalEvent: null != u ? u : null,
														events: d,
														nextBatch: null !== (o = c.next_batch) && void 0 !== o ? o : null,
														prevBatch: null !== (a = c.prev_batch) && void 0 !== a ? a : null
													}
												}))
											}
											getCrossSigningCacheCallbacks() {
												var e;
												return null === (e = this.crypto) || void 0 === e ? void 0 : e.crossSigningInfo.getCacheCallbacks()
											}
											generateClientSecret() {
												return (0, F.randomString)(32)
											}
											decryptEventIfNeeded(e, t) {
												return e.shouldAttemptDecryption() && this.isCryptoEnabled() && e.attemptDecryption(this.crypto, t), e.isBeingDecrypted() ? e.getDecryptionPromise() : Promise.resolve()
											}
											termsUrlForService(e, t) {
												switch (e) {
													case T.SERVICE_TYPES.IS:
														return this.http.getUrl("/terms", void 0, I.IdentityPrefix.V2, t);
													case T.SERVICE_TYPES.IM:
														return this.http.getUrl("/terms", void 0, "/_matrix/integrations/v1", t);
													default:
														throw new Error("Unsupported service type")
												}
											}
											getHomeserverUrl() {
												return this.baseUrl
											}
											getIdentityServerUrl(e = !1) {
												var t, r;
												return e && ((null === (t = this.idBaseUrl) || void 0 === t ? void 0 : t.startsWith("http://")) || (null === (r = this.idBaseUrl) || void 0 === r ? void 0 : r.startsWith("https://"))) ? this.idBaseUrl.split("://")[1] : this.idBaseUrl
											}
											setIdentityServerUrl(e) {
												this.idBaseUrl = v.ensureNoTrailingSlash(e), this.http.setIdBaseUrl(this.idBaseUrl)
											}
											getAccessToken() {
												return this.http.opts.accessToken || null
											}
											setAccessToken(e) {
												this.http.opts.accessToken = e
											}
											isLoggedIn() {
												return void 0 !== this.http.opts.accessToken
											}
											makeTxnId() {
												return "m" + (new Date).getTime() + "." + this.txnCtr++
											}
											isUsernameAvailable(e) {
												return this.http.authedRequest(I.Method.Get, "/register/available", {
													username: e
												}).then(e => e.available).catch(e => "M_USER_IN_USE" !== e.errcode && Promise.reject(e))
											}
											register(e, t, r, n, i, o, s) {
												!0 === i ? i = {
													email: !0
												} : null != i && !1 !== i || (i = {}), r && (n.session = r);
												const a = {
													auth: n,
													refresh_token: !0
												};
												return null != e && (a.username = e), null != t && (a.password = t), i.email && (a.bind_email = !0), i.msisdn && (a.bind_msisdn = !0), null != o && (a.guest_access_token = o), null != s && (a.inhibit_login = s), null != t && (a.x_show_msisdn = !0), this.registerRequest(a)
											}
											registerGuest(e) {
												return (e = e || {}).body = e.body || {}, this.registerRequest(e.body, "guest")
											}
											registerRequest(e, t) {
												const r = {};
												return t && (r.kind = t), this.http.request(I.Method.Post, "/register", r, e)
											}
											refreshToken(e) {
												return this.http.authedRequest(I.Method.Post, "/refresh", void 0, {
													refresh_token: e
												}, {
													prefix: I.ClientPrefix.V1,
													inhibitLogoutEmit: !0
												})
											}
											loginFlows() {
												return this.http.request(I.Method.Get, "/login")
											}
											login(e, t) {
												const r = {
													type: e
												};
												return Object.assign(r, t), this.http.authedRequest(I.Method.Post, "/login", void 0, r).then(e => (e.access_token && e.user_id && (this.http.opts.accessToken = e.access_token, this.credentials = {
													userId: e.user_id
												}), e))
											}
											loginWithPassword(e, t) {
												return this.login("m.login.password", {
													user: e,
													password: t
												})
											}
											loginWithSAML2(e) {
												return this.login("m.login.saml2", {
													relay_state: e
												})
											}
											getCasLoginUrl(e) {
												return this.getSsoLoginUrl(e, "cas")
											}
											getSsoLoginUrl(e, t = "sso", r, n) {
												let i = "/login/" + t + "/redirect";
												r && (i += "/" + r);
												const o = {
													redirectUrl: e,
													[de.unstable]: n
												};
												return this.http.getUrl(i, o, I.ClientPrefix.R0).href
											}
											loginWithToken(e) {
												return this.login("m.login.token", {
													token: e
												})
											}
											logout(e = !1) {
												var t, r;
												return s(this, void 0, void 0, (function*() {
													if (null === (r = null === (t = this.crypto) || void 0 === t ? void 0 : t.backupManager) || void 0 === r ? void 0 : r.getKeyBackupEnabled()) try {
														for (;
															(yield this.crypto.backupManager.backupPendingKeys(200)) > 0;);
													} catch (n) {
														k.logger.error("Key backup request failed when logging out. Some keys may be missing from backup", n)
													}
													return e && (this.stopClient(), this.http.abort()), this.http.authedRequest(I.Method.Post, "/logout")
												}))
											}
											deactivateAccount(e, t) {
												const r = {};
												return e && (r.auth = e), void 0 !== t && (r.erase = t), this.http.authedRequest(I.Method.Post, "/account/deactivate", void 0, r)
											}
											requestLoginToken(e) {
												const t = {
													auth: e
												};
												return this.http.authedRequest(I.Method.Post, "/org.matrix.msc3882/login/token", void 0, t, {
													prefix: I.ClientPrefix.Unstable
												})
											}
											getFallbackAuthUrl(e, t) {
												const r = v.encodeUri("/auth/$loginType/fallback/web", {
													$loginType: e
												});
												return this.http.getUrl(r, {
													session: t
												}, I.ClientPrefix.R0).href
											}
											createRoom(e) {
												var t;
												return s(this, void 0, void 0, (function*() {
													const r = (e.invite_3pid || []).filter(e => !e.id_access_token);
													if (r.length > 0 && (null === (t = this.identityServer) || void 0 === t ? void 0 : t.getAccessToken) && (yield this.doesServerAcceptIdentityAccessToken())) {
														const e = yield this.identityServer.getAccessToken();
														if (e)
															for (const t of r) t.id_access_token = e
													}
													return this.http.authedRequest(I.Method.Post, "/createRoom", void 0, e)
												}))
											}
											fetchRelations(e, t, r, n, i = {
												dir: m.Direction.Backward
											}) {
												let o = i;
												J.Thread.hasServerSideFwdPaginationSupport === J.FeatureSupport.Experimental && (o = (0, g.replaceParam)("dir", "org.matrix.msc3715.dir", o));
												const s = v.encodeParams(o);
												let a = "/rooms/$roomId/relations/$eventId";
												null !== r ? (a += "/$relationType", null !== n && (a += "/$eventType")) : null !== n && (k.logger.warn(`eventType: ${n} ignored when fetching\n            relations as relationType is null`), n = null);
												const c = v.encodeUri(a + "?" + s, {
													$roomId: e,
													$eventId: t,
													$relationType: r,
													$eventType: n
												});
												return this.http.authedRequest(I.Method.Get, c, void 0, void 0, {
													prefix: I.ClientPrefix.Unstable
												})
											}
											roomState(e) {
												const t = v.encodeUri("/rooms/$roomId/state", {
													$roomId: e
												});
												return this.http.authedRequest(I.Method.Get, t)
											}
											fetchRoomEvent(e, t) {
												const r = v.encodeUri("/rooms/$roomId/event/$eventId", {
													$roomId: e,
													$eventId: t
												});
												return this.http.authedRequest(I.Method.Get, r)
											}
											members(e, t, r, n) {
												const i = {};
												t && (i.membership = t), r && (i.not_membership = r), n && (i.at = n);
												const o = v.encodeParams(i),
													s = v.encodeUri("/rooms/$roomId/members?" + o, {
														$roomId: e
													});
												return this.http.authedRequest(I.Method.Get, s)
											}
											upgradeRoom(e, t) {
												const r = v.encodeUri("/rooms/$roomId/upgrade", {
													$roomId: e
												});
												return this.http.authedRequest(I.Method.Post, r, void 0, {
													new_version: t
												})
											}
											getStateEvent(e, t, r) {
												const n = {
													$roomId: e,
													$eventType: t,
													$stateKey: r
												};
												let i = v.encodeUri("/rooms/$roomId/state/$eventType", n);
												return void 0 !== r && (i = v.encodeUri(i + "/$stateKey", n)), this.http.authedRequest(I.Method.Get, i)
											}
											sendStateEvent(e, t, r, n = "", i = {}) {
												const o = {
													$roomId: e,
													$eventType: t,
													$stateKey: n
												};
												let s = v.encodeUri("/rooms/$roomId/state/$eventType", o);
												return void 0 !== n && (s = v.encodeUri(s + "/$stateKey", o)), this.http.authedRequest(I.Method.Put, s, void 0, r, i)
											}
											roomInitialSync(e, t) {
												var r;
												const n = v.encodeUri("/rooms/$roomId/initialSync", {
													$roomId: e
												});
												return this.http.authedRequest(I.Method.Get, n, {
													limit: null !== (r = null == t ? void 0 : t.toString()) && void 0 !== r ? r : "30"
												})
											}
											setRoomReadMarkersHttpRequest(e, t, r, n) {
												return s(this, void 0, void 0, (function*() {
													const i = v.encodeUri("/rooms/$roomId/read_markers", {
															$roomId: e
														}),
														o = {
															[Y.ReceiptType.FullyRead]: t,
															[Y.ReceiptType.Read]: r
														};
													return ((yield this.doesServerSupportUnstableFeature("org.matrix.msc2285.stable")) || (yield this.isVersionSupported("v1.4"))) && (o[Y.ReceiptType.ReadPrivate] = n), this.http.authedRequest(I.Method.Post, i, void 0, o)
												}))
											}
											getJoinedRooms() {
												const e = v.encodeUri("/joined_rooms", {});
												return this.http.authedRequest(I.Method.Get, e)
											}
											getJoinedRoomMembers(e) {
												const t = v.encodeUri("/rooms/$roomId/joined_members", {
													$roomId: e
												});
												return this.http.authedRequest(I.Method.Get, t)
											}
											publicRooms(e = {}) {
												var {
													server: t,
													limit: r,
													since: n
												} = e, i = a(e, ["server", "limit", "since"]);
												const o = {
													server: t,
													limit: r,
													since: n
												};
												return 0 === Object.keys(i).length ? this.http.authedRequest(I.Method.Get, "/publicRooms", o) : this.http.authedRequest(I.Method.Post, "/publicRooms", o, i)
											}
											createAlias(e, t) {
												const r = v.encodeUri("/directory/room/$alias", {
														$alias: e
													}),
													n = {
														room_id: t
													};
												return this.http.authedRequest(I.Method.Put, r, void 0, n)
											}
											deleteAlias(e) {
												const t = v.encodeUri("/directory/room/$alias", {
													$alias: e
												});
												return this.http.authedRequest(I.Method.Delete, t)
											}
											getLocalAliases(e) {
												const t = v.encodeUri("/rooms/$roomId/aliases", {
														$roomId: e
													}),
													r = I.ClientPrefix.V3;
												return this.http.authedRequest(I.Method.Get, t, void 0, void 0, {
													prefix: r
												})
											}
											getRoomIdForAlias(e) {
												const t = v.encodeUri("/directory/room/$alias", {
													$alias: e
												});
												return this.http.authedRequest(I.Method.Get, t)
											}
											resolveRoomAlias(e) {
												const t = v.encodeUri("/directory/room/$alias", {
													$alias: e
												});
												return this.http.request(I.Method.Get, t)
											}
											getRoomDirectoryVisibility(e) {
												const t = v.encodeUri("/directory/list/room/$roomId", {
													$roomId: e
												});
												return this.http.authedRequest(I.Method.Get, t)
											}
											setRoomDirectoryVisibility(e, t) {
												const r = v.encodeUri("/directory/list/room/$roomId", {
													$roomId: e
												});
												return this.http.authedRequest(I.Method.Put, r, void 0, {
													visibility: t
												})
											}
											setRoomDirectoryVisibilityAppService(e, t, r) {
												const n = v.encodeUri("/directory/list/appservice/$networkId/$roomId", {
													$networkId: e,
													$roomId: t
												});
												return this.http.authedRequest(I.Method.Put, n, void 0, {
													visibility: r
												})
											}
											searchUserDirectory(e) {
												const t = {
													search_term: e.term
												};
												return void 0 !== e.limit && (t.limit = e.limit), this.http.authedRequest(I.Method.Post, "/user_directory/search", void 0, t)
											}
											uploadContent(e, t) {
												return this.http.uploadContent(e, t)
											}
											cancelUpload(e) {
												return this.http.cancelUpload(e)
											}
											getCurrentUploads() {
												return this.http.getCurrentUploads()
											}
											getProfileInfo(e, t) {
												const r = t ? v.encodeUri("/profile/$userId/$info", {
													$userId: e,
													$info: t
												}) : v.encodeUri("/profile/$userId", {
													$userId: e
												});
												return this.http.authedRequest(I.Method.Get, r)
											}
											getThreePids() {
												return this.http.authedRequest(I.Method.Get, "/account/3pid")
											}
											addThreePid(e, t) {
												const r = {
													threePidCreds: e,
													bind: t
												};
												return this.http.authedRequest(I.Method.Post, "/account/3pid", void 0, r)
											}
											addThreePidOnly(e) {
												return s(this, void 0, void 0, (function*() {
													const t = (yield this.isVersionSupported("r0.6.0")) ? I.ClientPrefix.R0 : I.ClientPrefix.Unstable;
													return this.http.authedRequest(I.Method.Post, "/account/3pid/add", void 0, e, {
														prefix: t
													})
												}))
											}
											bindThreePid(e) {
												return s(this, void 0, void 0, (function*() {
													const t = (yield this.isVersionSupported("r0.6.0")) ? I.ClientPrefix.R0 : I.ClientPrefix.Unstable;
													return this.http.authedRequest(I.Method.Post, "/account/3pid/bind", void 0, e, {
														prefix: t
													})
												}))
											}
											unbindThreePid(e, t) {
												return s(this, void 0, void 0, (function*() {
													const r = {
															medium: e,
															address: t,
															id_server: this.getIdentityServerUrl(!0)
														},
														n = (yield this.isVersionSupported("r0.6.0")) ? I.ClientPrefix.R0 : I.ClientPrefix.Unstable;
													return this.http.authedRequest(I.Method.Post, "/account/3pid/unbind", void 0, r, {
														prefix: n
													})
												}))
											}
											deleteThreePid(e, t) {
												return this.http.authedRequest(I.Method.Post, "/account/3pid/delete", void 0, {
													medium: e,
													address: t
												})
											}
											setPassword(e, t, r) {
												const n = {
													auth: e,
													new_password: t,
													logout_devices: r
												};
												return this.http.authedRequest(I.Method.Post, "/account/password", void 0, n)
											}
											getDevices() {
												return this.http.authedRequest(I.Method.Get, "/devices")
											}
											getDevice(e) {
												const t = v.encodeUri("/devices/$device_id", {
													$device_id: e
												});
												return this.http.authedRequest(I.Method.Get, t)
											}
											setDeviceDetails(e, t) {
												const r = v.encodeUri("/devices/$device_id", {
													$device_id: e
												});
												return this.http.authedRequest(I.Method.Put, r, void 0, t)
											}
											deleteDevice(e, t) {
												const r = v.encodeUri("/devices/$device_id", {
														$device_id: e
													}),
													n = {};
												return t && (n.auth = t), this.http.authedRequest(I.Method.Delete, r, void 0, n)
											}
											deleteMultipleDevices(e, t) {
												const r = {
													devices: e
												};
												t && (r.auth = t);
												return this.http.authedRequest(I.Method.Post, "/delete_devices", void 0, r)
											}
											getPushers() {
												return s(this, void 0, void 0, (function*() {
													const e = yield this.http.authedRequest(I.Method.Get, "/pushers");
													return (yield this.doesServerSupportUnstableFeature("org.matrix.msc3881")) || (e.pushers = e.pushers.map(e => (e.hasOwnProperty(N.PUSHER_ENABLED.name) || (e[N.PUSHER_ENABLED.name] = !0), e))), e
												}))
											}
											setPusher(e) {
												return this.http.authedRequest(I.Method.Post, "/pushers/set", void 0, e)
											}
											setLocalNotificationSettings(e, t) {
												const r = `${N.LOCAL_NOTIFICATION_SETTINGS_PREFIX.name}.${e}`;
												return this.setAccountData(r, t)
											}
											getPushRules() {
												return this.http.authedRequest(I.Method.Get, "/pushrules/").then(e => y.PushProcessor.rewriteDefaultRules(e))
											}
											addPushRule(e, t, r, n) {
												const i = v.encodeUri("/pushrules/" + e + "/$kind/$ruleId", {
													$kind: t,
													$ruleId: r
												});
												return this.http.authedRequest(I.Method.Put, i, void 0, n)
											}
											deletePushRule(e, t, r) {
												const n = v.encodeUri("/pushrules/" + e + "/$kind/$ruleId", {
													$kind: t,
													$ruleId: r
												});
												return this.http.authedRequest(I.Method.Delete, n)
											}
											setPushRuleEnabled(e, t, r, n) {
												const i = v.encodeUri("/pushrules/" + e + "/$kind/$ruleId/enabled", {
													$kind: t,
													$ruleId: r
												});
												return this.http.authedRequest(I.Method.Put, i, void 0, {
													enabled: n
												})
											}
											setPushRuleActions(e, t, r, n) {
												const i = v.encodeUri("/pushrules/" + e + "/$kind/$ruleId/actions", {
													$kind: t,
													$ruleId: r
												});
												return this.http.authedRequest(I.Method.Put, i, void 0, {
													actions: n
												})
											}
											search(e, t) {
												const r = {};
												return e.next_batch && (r.next_batch = e.next_batch), this.http.authedRequest(I.Method.Post, "/search", r, e.body, {
													abortSignal: t
												})
											}
											uploadKeysRequest(e, t) {
												return this.http.authedRequest(I.Method.Post, "/keys/upload", void 0, e)
											}
											uploadKeySignatures(e) {
												return this.http.authedRequest(I.Method.Post, "/keys/signatures/upload", void 0, e, {
													prefix: I.ClientPrefix.V3
												})
											}
											downloadKeysForUsers(e, t = {}) {
												const r = {
													device_keys: {}
												};
												return "token" in t && (r.token = t.token), e.forEach(e => {
													r.device_keys[e] = []
												}), this.http.authedRequest(I.Method.Post, "/keys/query", void 0, r)
											}
											claimOneTimeKeys(e, t = "signed_curve25519", r) {
												const n = {};
												void 0 === t && (t = "signed_curve25519");
												for (const [o, s] of e) {
													const e = n[o] || {};
													n[o] = e, e[s] = t
												}
												const i = {
													one_time_keys: n
												};
												r && (i.timeout = r);
												return this.http.authedRequest(I.Method.Post, "/keys/claim", void 0, i)
											}
											getKeyChanges(e, t) {
												const r = {
													from: e,
													to: t
												};
												return this.http.authedRequest(I.Method.Get, "/keys/changes", r)
											}
											uploadDeviceSigningKeys(e, t) {
												const r = Object.assign({}, t);
												return e && Object.assign(r, {
													auth: e
												}), this.http.authedRequest(I.Method.Post, "/keys/device_signing/upload", void 0, r, {
													prefix: I.ClientPrefix.Unstable
												})
											}
											registerWithIdentityServer(e) {
												if (!this.idBaseUrl) throw new Error("No identity server base URL set");
												const t = this.http.getUrl("/account/register", void 0, I.IdentityPrefix.V2, this.idBaseUrl);
												return this.http.requestOtherUrl(I.Method.Post, t, e)
											}
											requestEmailToken(e, t, r, n, i) {
												const o = {
													client_secret: t,
													email: e,
													send_attempt: null == r ? void 0 : r.toString(),
													next_link: n
												};
												return this.http.idServerRequest(I.Method.Post, "/validate/email/requestToken", o, I.IdentityPrefix.V2, i)
											}
											requestMsisdnToken(e, t, r, n, i, o) {
												const s = {
													client_secret: r,
													country: e,
													phone_number: t,
													send_attempt: null == n ? void 0 : n.toString(),
													next_link: i
												};
												return this.http.idServerRequest(I.Method.Post, "/validate/msisdn/requestToken", s, I.IdentityPrefix.V2, o)
											}
											submitMsisdnToken(e, t, r, n) {
												const i = {
													sid: e,
													client_secret: t,
													token: r
												};
												return this.http.idServerRequest(I.Method.Post, "/validate/msisdn/submitToken", i, I.IdentityPrefix.V2, n)
											}
											submitMsisdnTokenOtherUrl(e, t, r, n) {
												const i = {
													sid: t,
													client_secret: r,
													token: n
												};
												return this.http.requestOtherUrl(I.Method.Post, e, i)
											}
											getIdentityHashDetails(e) {
												return this.http.idServerRequest(I.Method.Get, "/hash_details", void 0, I.IdentityPrefix.V2, e)
											}
											identityHashedLookup(t, r) {
												return s(this, void 0, void 0, (function*() {
													const n = {},
														i = yield this.getIdentityHashDetails(r);
													if (!i || !i.lookup_pepper || !i.algorithms) throw new Error("Unsupported identity server: bad response");
													n.pepper = i.lookup_pepper;
													const o = {};
													if (i.algorithms.includes("sha256")) {
														const r = new e.Olm.Utility;
														n.addresses = t.map(e => {
															const t = e[0].toLowerCase(),
																i = e[1].toLowerCase(),
																s = r.sha256(`${t} ${i} ${n.pepper}`).replace(/\+/g, "-").replace(/\//g, "_");
															return o[s] = e[0], s
														}), n.algorithm = "sha256"
													} else {
														if (!i.algorithms.includes("none")) throw new Error("Unsupported identity server: unknown hash algorithm");
														n.addresses = t.map(e => {
															const t = `${e[0].toLowerCase()} ${e[1].toLowerCase()}`;
															return o[t] = e[0], t
														}), n.algorithm = "none"
													}
													const s = yield this.http.idServerRequest(I.Method.Post, "/lookup", n, I.IdentityPrefix.V2, r);
													if (!s || !s.mappings) return [];
													const a = [];
													for (const e of Object.keys(s.mappings)) {
														const t = s.mappings[e],
															r = o[e];
														if (!r) throw new Error("Identity server returned more results than expected");
														a.push({
															address: r,
															mxid: t
														})
													}
													return a
												}))
											}
											lookupThreePid(e, t, r) {
												return s(this, void 0, void 0, (function*() {
													const n = (yield this.identityHashedLookup([
														[t, e]
													], r)).find(e => e.address === t);
													return n ? {
														address: t,
														medium: e,
														mxid: n.mxid
													} : {}
												}))
											}
											bulkLookupThreePids(e, t) {
												return s(this, void 0, void 0, (function*() {
													const r = yield this.identityHashedLookup(e.map(e => [e[1], e[0]]), t), n = [];
													for (const t of r) {
														const r = e.find(e => e[1] === t.address);
														if (!r) throw new Error("Identity sever returned unexpected results");
														n.push([r[0], t.address, t.mxid])
													}
													return {
														threepids: n
													}
												}))
											}
											getIdentityAccount(e) {
												return this.http.idServerRequest(I.Method.Get, "/account", void 0, I.IdentityPrefix.V2, e)
											}
											sendToDevice(e, t, r) {
												const n = v.encodeUri("/sendToDevice/$eventType/$txnId", {
														$eventType: e,
														$txnId: r || this.makeTxnId()
													}),
													i = {
														messages: t
													},
													o = Object.keys(t).reduce((e, r) => (e[r] = Object.keys(t[r]), e), {});
												return k.logger.log(`PUT ${n}`, o), this.http.authedRequest(I.Method.Put, n, void 0, i)
											}
											queueToDevice(e) {
												return this.toDeviceMessageQueue.queueBatch(e)
											}
											getThirdpartyProtocols() {
												return this.http.authedRequest(I.Method.Get, "/thirdparty/protocols").then(e => {
													if (!e || "object" != typeof e) throw new Error(`/thirdparty/protocols did not return an object: ${e}`);
													return e
												})
											}
											getThirdpartyLocation(e, t) {
												const r = v.encodeUri("/thirdparty/location/$protocol", {
													$protocol: e
												});
												return this.http.authedRequest(I.Method.Get, r, t)
											}
											getThirdpartyUser(e, t) {
												const r = v.encodeUri("/thirdparty/user/$protocol", {
													$protocol: e
												});
												return this.http.authedRequest(I.Method.Get, r, t)
											}
											getTerms(e, t) {
												const r = this.termsUrlForService(e, t);
												return this.http.requestOtherUrl(I.Method.Get, r)
											}
											agreeToTerms(e, t, r, n) {
												const i = this.termsUrlForService(e, t),
													o = {
														Authorization: "Bearer " + r
													};
												return this.http.requestOtherUrl(I.Method.Post, i, {
													user_accepts: n
												}, {
													headers: o
												})
											}
											reportEvent(e, t, r, n) {
												const i = v.encodeUri("/rooms/$roomId/report/$eventId", {
													$roomId: e,
													$eventId: t
												});
												return this.http.authedRequest(I.Method.Post, i, void 0, {
													score: r,
													reason: n
												})
											}
											getRoomHierarchy(e, t, r, n = !1, i) {
												const o = v.encodeUri("/rooms/$roomId/hierarchy", {
														$roomId: e
													}),
													s = {
														suggested_only: String(n),
														max_depth: null == r ? void 0 : r.toString(),
														from: i,
														limit: null == t ? void 0 : t.toString()
													};
												return this.http.authedRequest(I.Method.Get, o, s, void 0, {
													prefix: I.ClientPrefix.V1
												}).catch(e => {
													if ("M_UNRECOGNIZED" === e.errcode) return this.http.authedRequest(I.Method.Get, o, s, void 0, {
														prefix: "/_matrix/client/unstable/org.matrix.msc2946"
													});
													throw e
												})
											}
											unstableCreateFileTree(e) {
												return s(this, void 0, void 0, (function*() {
													const {
														room_id: t
													} = yield this.createRoom({
														name: e,
														preset: B.Preset.PrivateChat,
														power_level_content_override: Object.assign(Object.assign({}, q.DEFAULT_TREE_POWER_LEVELS_TEMPLATE), {
															users: {
																[this.getUserId()]: 100
															}
														}),
														creation_content: {
															[N.RoomCreateTypeField]: N.RoomType.Space
														},
														initial_state: [{
															type: N.UNSTABLE_MSC3088_PURPOSE.name,
															state_key: N.UNSTABLE_MSC3089_TREE_SUBTYPE.name,
															content: {
																[N.UNSTABLE_MSC3088_ENABLED.name]: !0
															}
														}, {
															type: N.EventType.RoomEncryption,
															state_key: "",
															content: {
																algorithm: _.MEGOLM_ALGORITHM
															}
														}]
													});
													return new q.MSC3089TreeSpace(this, t)
												}))
											}
											unstableGetFileTreeSpace(e) {
												var t, r;
												const n = this.getRoom(e);
												if ("join" !== (null == n ? void 0 : n.getMyMembership())) return null;
												const i = n.currentState.getStateEvents(N.EventType.RoomCreate, ""),
													o = n.currentState.getStateEvents(N.UNSTABLE_MSC3088_PURPOSE.name, N.UNSTABLE_MSC3089_TREE_SUBTYPE.name);
												if (!i) throw new Error("Expected single room create event");
												return (null === (t = null == o ? void 0 : o.getContent()) || void 0 === t ? void 0 : t[N.UNSTABLE_MSC3088_ENABLED.name]) ? (null === (r = i.getContent()) || void 0 === r ? void 0 : r[N.RoomCreateTypeField]) !== N.RoomType.Space ? null : new q.MSC3089TreeSpace(this, e) : null
											}
											slidingSync(e, t, r) {
												const n = {};
												e.pos && (n.pos = e.pos, delete e.pos), e.timeout && (n.timeout = e.timeout, delete e.timeout);
												const i = e.clientTimeout;
												return delete e.clientTimeout, this.http.authedRequest(I.Method.Post, "/sync", n, e, {
													prefix: "/_matrix/client/unstable/org.matrix.msc3575",
													baseUrl: t,
													localTimeoutMs: i,
													abortSignal: r
												})
											}
											supportsExperimentalThreads() {
												var e;
												return (null === (e = this.clientOpts) || void 0 === e ? void 0 : e.experimentalThreadSupport) || !1
											}
											getRoomSummary(e, t) {
												return s(this, void 0, void 0, (function*() {
													const r = v.encodeUri("/rooms/$roomid/summary", {
														$roomid: e
													});
													return this.http.authedRequest(I.Method.Get, r, {
														via: t
													}, void 0, {
														prefix: "/_matrix/client/unstable/im.nheko.summary"
													})
												}))
											}
											processThreadEvents(e, t, r) {
												e.processThreadedEvents(t, r)
											}
											processThreadRoots(e, t, r) {
												e.processThreadRoots(t, r)
											}
											processBeaconEvents(e, t) {
												(null == t ? void 0 : t.length) && e && e.currentState.processBeaconEvents(t, this)
											}
											whoami() {
												return s(this, void 0, void 0, (function*() {
													return this.http.authedRequest(I.Method.Get, "/account/whoami")
												}))
											}
											timestampToEvent(e, t, r) {
												const n = v.encodeUri("/rooms/$roomId/timestamp_to_event", {
													$roomId: e
												});
												return this.http.authedRequest(I.Method.Get, n, {
													ts: t.toString(),
													dir: r
												}, void 0, {
													prefix: "/_matrix/client/unstable/org.matrix.msc3030"
												})
											}
										}

										function fe(e, t) {
											var r, n, i, o, s;
											const a = t.getPushActions(),
												c = e.getPushActionsForEvent(t, !0),
												l = e.getRoom(t.getRoomId());
											if (!l || !e.getUserId()) return;
											const u = !!t.threadRootId && !t.isThreadRoot,
												d = null !== (r = u ? l.getThreadUnreadNotificationCount(t.threadRootId, L.NotificationCountType.Highlight) : l.getUnreadNotificationCount(L.NotificationCountType.Highlight)) && void 0 !== r ? r : 0,
												h = !!(null === (n = null == a ? void 0 : a.tweaks) || void 0 === n ? void 0 : n.highlight),
												f = !!(null === (i = null == c ? void 0 : c.tweaks) || void 0 === i ? void 0 : i.highlight);
											if (h !== f || d > 0) {
												if (!(u ? null === (o = l.getThread(t.threadRootId)) || void 0 === o ? void 0 : o.hasUserReadEvent(e.getUserId(), t.getId()) : l.hasUserReadEvent(e.getUserId(), t.getId()))) {
													let e = d;
													f && !h && e++, !f && h && e--, u ? l.setThreadUnreadNotificationCount(t.threadRootId, L.NotificationCountType.Highlight, e) : l.setUnreadNotificationCount(L.NotificationCountType.Highlight, e), (null !== (s = u ? l.getThreadUnreadNotificationCount(t.threadRootId, L.NotificationCountType.Total) : l.getUnreadNotificationCount(L.NotificationCountType.Total)) && void 0 !== s ? s : 0) < e && (u ? l.setThreadUnreadNotificationCount(t.threadRootId, L.NotificationCountType.Total, e) : l.setUnreadNotificationCount(L.NotificationCountType.Total, e))
												}
											}
										}
										n.MatrixClient = he, he.RESTORE_BACKUP_ERROR_BAD_KEY = "RESTORE_BACKUP_ERROR_BAD_KEY", n.fixNotificationCountOnDecryption = fe
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"./@types/PushRules": 288,
								"./@types/beacon": 289,
								"./@types/event": 290,
								"./@types/partials": 293,
								"./@types/read_receipts": 294,
								"./@types/search": 296,
								"./@types/sync": 297,
								"./NamespacedValue": 299,
								"./ReEmitter": 300,
								"./ToDeviceMessageQueue": 301,
								"./autodiscovery": 302,
								"./content-helpers": 305,
								"./content-repo": 306,
								"./crypto": 324,
								"./crypto/RoomList": 312,
								"./crypto/api": 319,
								"./crypto/backup": 320,
								"./crypto/dehydration": 322,
								"./crypto/key_passphrase": 325,
								"./crypto/olmlib": 326,
								"./crypto/recoverykey": 327,
								"./event-mapper": 343,
								"./feature": 344,
								"./filter": 346,
								"./http-api": 349,
								"./logger": 356,
								"./models/MSC3089TreeSpace": 359,
								"./models/event": 365,
								"./models/event-timeline": 364,
								"./models/invites-ignorer": 366,
								"./models/read-receipt": 367,
								"./models/room": 373,
								"./models/search-result": 374,
								"./models/thread": 375,
								"./models/typed-event-emitter": 376,
								"./models/user": 377,
								"./pushprocessor": 378,
								"./randomstring": 379,
								"./service-types": 382,
								"./sliding-sync-sdk": 383,
								"./store/stub": 389,
								"./sync": 391,
								"./utils": 393,
								"./webrtc/call": 395,
								"./webrtc/callEventHandler": 396,
								"./webrtc/groupCall": 399,
								"./webrtc/groupCallEventHandler": 400,
								"./webrtc/mediaHandler": 401,
								"matrix-events-sdk": 168
							}],
							305: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.parseBeaconContent = r.makeBeaconContent = r.parseBeaconInfoContent = r.makeBeaconInfoContent = r.parseTopicContent = r.makeTopicContent = r.parseLocationEvent = r.makeLocationContent = r.getTextForLocationEvent = r.makeEmoteMessage = r.makeNotice = r.makeTextMessage = r.makeHtmlEmote = r.makeHtmlNotice = r.makeHtmlMessage = void 0;
								const n = e("matrix-events-sdk"),
									i = e("./@types/event"),
									o = e("./@types/extensible_events"),
									s = e("./@types/location"),
									a = e("./@types/topic");
								r.makeHtmlMessage = function(e, t) {
									return {
										msgtype: i.MsgType.Text,
										format: "org.matrix.custom.html",
										body: e,
										formatted_body: t
									}
								}, r.makeHtmlNotice = function(e, t) {
									return {
										msgtype: i.MsgType.Notice,
										format: "org.matrix.custom.html",
										body: e,
										formatted_body: t
									}
								}, r.makeHtmlEmote = function(e, t) {
									return {
										msgtype: i.MsgType.Emote,
										format: "org.matrix.custom.html",
										body: e,
										formatted_body: t
									}
								}, r.makeTextMessage = function(e) {
									return {
										msgtype: i.MsgType.Text,
										body: e
									}
								}, r.makeNotice = function(e) {
									return {
										msgtype: i.MsgType.Notice,
										body: e
									}
								}, r.makeEmoteMessage = function(e) {
									return {
										msgtype: i.MsgType.Emote,
										body: e
									}
								};
								r.getTextForLocationEvent = (e, t, r, n) => {
									const i = `at ${new Date(r).toISOString()}`;
									return [t === s.LocationAssetType.Self ? "User" : void 0, "Location", n ? `"${n}"` : void 0, e, i].filter(Boolean).join(" ")
								};
								r.makeLocationContent = (e, t, n, a, c) => {
									const l = null != e ? e : (0, r.getTextForLocationEvent)(t, c || s.LocationAssetType.Self, n, a),
										u = n ? {
											[s.M_TIMESTAMP.name]: n
										} : {};
									return Object.assign({
										msgtype: i.MsgType.Location,
										body: l,
										geo_uri: t,
										[s.M_LOCATION.name]: {
											description: a,
											uri: t
										},
										[s.M_ASSET.name]: {
											type: c || s.LocationAssetType.Self
										},
										[o.TEXT_NODE_TYPE.name]: l
									}, u)
								};
								r.parseLocationEvent = e => {
									var t, n;
									const i = s.M_LOCATION.findIn(e),
										a = s.M_ASSET.findIn(e),
										c = s.M_TIMESTAMP.findIn(e),
										l = o.TEXT_NODE_TYPE.findIn(e),
										u = null !== (t = null == i ? void 0 : i.uri) && void 0 !== t ? t : null == e ? void 0 : e.geo_uri,
										d = null == i ? void 0 : i.description,
										h = null !== (n = null == a ? void 0 : a.type) && void 0 !== n ? n : s.LocationAssetType.Self,
										f = null != l ? l : e.body;
									return (0, r.makeLocationContent)(f, u, null != c ? c : void 0, d, h)
								};
								r.makeTopicContent = (e, t) => {
									const r = [{
										body: e,
										mimetype: "text/plain"
									}];
									return (0, n.isProvided)(t) && r.push({
										body: t,
										mimetype: "text/html"
									}), {
										topic: e,
										[a.M_TOPIC.name]: r
									}
								};
								r.parseTopicContent = e => {
									var t, r, i;
									const o = a.M_TOPIC.findIn(e);
									return {
										text: null !== (r = null === (t = null == o ? void 0 : o.find(e => !(0, n.isProvided)(e.mimetype) || "text/plain" === e.mimetype)) || void 0 === t ? void 0 : t.body) && void 0 !== r ? r : e.topic,
										html: null === (i = null == o ? void 0 : o.find(e => "text/html" === e.mimetype)) || void 0 === i ? void 0 : i.body
									}
								};
								r.makeBeaconInfoContent = (e, t, r, n, i) => ({
									description: r,
									timeout: e,
									live: t,
									[s.M_TIMESTAMP.name]: i || Date.now(),
									[s.M_ASSET.name]: {
										type: null != n ? n : s.LocationAssetType.Self
									}
								});
								r.parseBeaconInfoContent = e => {
									var t;
									const {
										description: r,
										timeout: n,
										live: i
									} = e, o = null !== (t = s.M_TIMESTAMP.findIn(e)) && void 0 !== t ? t : void 0, a = s.M_ASSET.findIn(e);
									return {
										description: r,
										timeout: n,
										live: i,
										assetType: null == a ? void 0 : a.type,
										timestamp: o
									}
								};
								r.makeBeaconContent = (e, t, r, i) => ({
									[s.M_LOCATION.name]: {
										description: i,
										uri: e
									},
									[s.M_TIMESTAMP.name]: t,
									"m.relates_to": {
										rel_type: n.REFERENCE_RELATION.name,
										event_id: r
									}
								});
								r.parseBeaconContent = e => {
									var t;
									const r = s.M_LOCATION.findIn(e),
										n = null !== (t = s.M_TIMESTAMP.findIn(e)) && void 0 !== t ? t : void 0;
									return {
										description: null == r ? void 0 : r.description,
										uri: null == r ? void 0 : r.uri,
										timestamp: n
									}
								}
							}, {
								"./@types/event": 290,
								"./@types/extensible_events": 291,
								"./@types/location": 292,
								"./@types/topic": 298,
								"matrix-events-sdk": 168
							}],
							306: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
										Object.defineProperty(e, "default", {
											enumerable: !0,
											value: t
										})
									} : function(e, t) {
										e.default = t
									}),
									o = this && this.__importStar || function(e) {
										if (e && e.__esModule) return e;
										var t = {};
										if (null != e)
											for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
										return i(t, e), t
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.getHttpUriForMxc = void 0;
								const s = o(e("./utils"));
								r.getHttpUriForMxc = function(e, t, r, n, i, o = !1) {
									if ("string" != typeof t || !t) return "";
									if (0 !== t.indexOf("mxc://")) return o ? t : "";
									let a = t.slice(6),
										c = "/_matrix/media/r0/download/";
									const l = {};
									r && (l.width = Math.round(r).toString()), n && (l.height = Math.round(n).toString()), i && (l.method = i), Object.keys(l).length > 0 && (c = "/_matrix/media/r0/thumbnail/");
									const u = a.indexOf("#");
									let d = "";
									return u >= 0 && (d = a.slice(u), a = a.slice(0, u)), e + c + a + (0 === Object.keys(l).length ? "" : "?" + s.encodeParams(l)) + d
								}
							}, {
								"./utils": 393
							}],
							307: [function(t, r, n) {
								(function(e, r) {
									(function() {
										"use strict";
										var i = this && this.__awaiter || function(e, t, r, n) {
											return new(r || (r = Promise))((function(i, o) {
												function s(e) {
													try {
														c(n.next(e))
													} catch (t) {
														o(t)
													}
												}

												function a(e) {
													try {
														c(n.throw(e))
													} catch (t) {
														o(t)
													}
												}

												function c(e) {
													var t;
													e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
														e(t)
													}))).then(s, a)
												}
												c((n = n.apply(e, t || [])).next())
											}))
										};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.requestKeysDuringVerification = n.createCryptoStoreCacheCallbacks = n.DeviceTrustLevel = n.UserTrustLevel = n.CrossSigningLevel = n.CrossSigningInfo = void 0;
										const o = t("./olmlib"),
											s = t("../logger"),
											a = t("../crypto/store/indexeddb-crypto-store"),
											c = t("./aes"),
											l = 6e4;

										function u(e) {
											return Object.values(e.keys)[0]
										}
										class d {
											constructor(e, t = {}, r = {}) {
												this.userId = e, this.callbacks = t, this.cacheCallbacks = r, this.keys = {}, this.firstUse = !0, this.crossSigningVerifiedBefore = !1
											}
											static fromStorage(e, t) {
												const r = new d(t);
												for (const n in e) e.hasOwnProperty(n) && (r[n] = e[n]);
												return r
											}
											toStorage() {
												return {
													keys: this.keys,
													firstUse: this.firstUse,
													crossSigningVerifiedBefore: this.crossSigningVerifiedBefore
												}
											}
											getCrossSigningKey(t, r) {
												return i(this, void 0, void 0, (function*() {
													const n = ["master", "self_signing", "user_signing"].indexOf(t) >= 0;
													if (!this.callbacks.getCrossSigningKey) throw new Error("No getCrossSigningKey callback supplied");

													function i(t) {
														if (!t) return;
														const n = new e.Olm.PkSigning,
															i = n.init_with_seed(t);
														if (i === r) return [i, n];
														n.free()
													}
													void 0 === r && (r = this.getId(t));
													let o = null;
													this.cacheCallbacks.getCrossSigningKeyCache && n && (o = yield this.cacheCallbacks.getCrossSigningKeyCache(t, r));
													const s = i(o);
													if (s) return s;
													const a = i(o = yield this.callbacks.getCrossSigningKey(t, r));
													if (a) return this.cacheCallbacks.storeCrossSigningKeyCache && n && (yield this.cacheCallbacks.storeCrossSigningKeyCache(t, o)), a;
													if (!o) throw new Error("getCrossSigningKey callback for " + t + " returned falsey");
													throw new Error("Key type " + t + " from getCrossSigningKey callback did not match")
												}))
											}
											isStoredInSecretStorage(e) {
												return i(this, void 0, void 0, (function*() {
													const t = (yield e.isStored("m.cross_signing.master")) || {};

													function r(e) {
														for (const r of Object.keys(t)) e[r] || delete t[r]
													}
													for (const n of ["self_signing", "user_signing"]) r((yield e.isStored(`m.cross_signing.${n}`)) || {});
													return Object.keys(t).length ? t : null
												}))
											}
											static storeInSecretStorage(e, t) {
												return i(this, void 0, void 0, (function*() {
													for (const [r, n] of e) {
														const e = (0, o.encodeBase64)(n);
														yield t.store(`m.cross_signing.${r}`, e)
													}
												}))
											}
											static getFromSecretStorage(e, t) {
												return i(this, void 0, void 0, (function*() {
													const r = yield t.get(`m.cross_signing.${e}`);
													return r ? (0, o.decodeBase64)(r) : null
												}))
											}
											isStoredInKeyCache(e) {
												var t;
												return i(this, void 0, void 0, (function*() {
													const r = this.cacheCallbacks;
													if (!r) return !1;
													const n = e ? [e] : ["master", "self_signing", "user_signing"];
													for (const e of n)
														if (!(yield null === (t = r.getCrossSigningKeyCache) || void 0 === t ? void 0 : t.call(r, e))) return !1;
													return !0
												}))
											}
											getCrossSigningKeysFromCache() {
												var e;
												return i(this, void 0, void 0, (function*() {
													const t = new Map,
														r = this.cacheCallbacks;
													if (!r) return t;
													for (const n of ["master", "self_signing", "user_signing"]) {
														const i = yield null === (e = r.getCrossSigningKeyCache) || void 0 === e ? void 0 : e.call(r, n);
														i && t.set(n, i)
													}
													return t
												}))
											}
											getId(e = "master") {
												if (!this.keys[e]) return null;
												return u(this.keys[e])
											}
											resetKeys(t) {
												return i(this, void 0, void 0, (function*() {
													if (!this.callbacks.saveCrossSigningKeys) throw new Error("No saveCrossSigningKeys callback supplied");
													if (void 0 === t || t & h.MASTER || !this.keys.master) t = h.MASTER | h.USER_SIGNING | h.SELF_SIGNING;
													else if (0 === t) return;
													const r = {},
														n = {};
													let i, s;
													try {
														if (t & h.MASTER ? (i = new e.Olm.PkSigning, r.master = i.generate_seed(), s = i.init_with_seed(r.master), n.master = {
																user_id: this.userId,
																usage: ["master"],
																keys: {
																	["ed25519:" + s]: s
																}
															}) : [s, i] = yield this.getCrossSigningKey("master"), t & h.SELF_SIGNING) {
															const t = new e.Olm.PkSigning;
															try {
																r.self_signing = t.generate_seed();
																const e = t.init_with_seed(r.self_signing);
																n.self_signing = {
																	user_id: this.userId,
																	usage: ["self_signing"],
																	keys: {
																		["ed25519:" + e]: e
																	}
																}, (0, o.pkSign)(n.self_signing, i, this.userId, s)
															} finally {
																t.free()
															}
														}
														if (t & h.USER_SIGNING) {
															const t = new e.Olm.PkSigning;
															try {
																r.user_signing = t.generate_seed();
																const e = t.init_with_seed(r.user_signing);
																n.user_signing = {
																	user_id: this.userId,
																	usage: ["user_signing"],
																	keys: {
																		["ed25519:" + e]: e
																	}
																}, (0, o.pkSign)(n.user_signing, i, this.userId, s)
															} finally {
																t.free()
															}
														}
														Object.assign(this.keys, n), this.callbacks.saveCrossSigningKeys(r)
													} finally {
														i && i.free()
													}
												}))
											}
											clearKeys() {
												this.keys = {}
											}
											setKeys(e) {
												const t = {};
												if (e.master) {
													if (e.master.user_id !== this.userId) {
														const t = "Mismatched user ID " + e.master.user_id + " in master key from " + this.userId;
														throw s.logger.error(t), new Error(t)
													}
													this.keys.master ? u(e.master) !== this.getId() && (this.firstUse = !1) : this.firstUse = !0, t.master = e.master
												} else {
													if (!this.keys.master) throw new Error("Tried to set cross-signing keys without a master key");
													t.master = this.keys.master
												}
												const r = u(t.master);
												if (e.user_signing) {
													if (e.user_signing.user_id !== this.userId) {
														const t = "Mismatched user ID " + e.master.user_id + " in user_signing key from " + this.userId;
														throw s.logger.error(t), new Error(t)
													}
													try {
														(0, o.pkVerify)(e.user_signing, r, this.userId)
													} catch (n) {
														throw s.logger.error("invalid signature on user-signing key"), n
													}
												}
												if (e.self_signing) {
													if (e.self_signing.user_id !== this.userId) {
														const t = "Mismatched user ID " + e.master.user_id + " in self_signing key from " + this.userId;
														throw s.logger.error(t), new Error(t)
													}
													try {
														(0, o.pkVerify)(e.self_signing, r, this.userId)
													} catch (n) {
														throw s.logger.error("invalid signature on self-signing key"), n
													}
												}
												e.master && (this.keys.master = e.master, delete this.keys.self_signing, delete this.keys.user_signing), e.self_signing && (this.keys.self_signing = e.self_signing), e.user_signing && (this.keys.user_signing = e.user_signing)
											}
											updateCrossSigningVerifiedBefore(e) {
												!this.crossSigningVerifiedBefore && e && (this.crossSigningVerifiedBefore = !0)
											}
											signObject(e, t) {
												return i(this, void 0, void 0, (function*() {
													if (!this.keys[t]) throw new Error("Attempted to sign with " + t + " key but no such key present");
													const [r, n] = yield this.getCrossSigningKey(t);
													try {
														return (0, o.pkSign)(e, n, this.userId, r), e
													} finally {
														n.free()
													}
												}))
											}
											signUser(e) {
												return i(this, void 0, void 0, (function*() {
													if (this.keys.user_signing) return this.signObject(e.keys.master, "user_signing");
													s.logger.info("No user signing key: not signing user")
												}))
											}
											signDevice(e, t) {
												return i(this, void 0, void 0, (function*() {
													if (e !== this.userId) throw new Error(`Trying to sign ${e}'s device; can only sign our own device`);
													if (this.keys.self_signing) return this.signObject({
														algorithms: t.algorithms,
														keys: t.keys,
														device_id: t.deviceId,
														user_id: e
													}, "self_signing");
													s.logger.info("No self signing key: not signing device")
												}))
											}
											checkUserTrust(e) {
												if (this.userId === e.userId && this.getId() && this.getId() === e.getId() && this.getId("self_signing") && this.getId("self_signing") === e.getId("self_signing")) return new f(!0, !0, this.firstUse);
												if (!this.keys.user_signing) return new f(!1, !1, e.firstUse);
												let t;
												const r = e.keys.master,
													n = this.getId("user_signing");
												try {
													(0, o.pkVerify)(r, n, this.userId), t = !0
												} catch (i) {
													t = !1
												}
												return new f(t, e.crossSigningVerifiedBefore, e.firstUse)
											}
											checkDeviceTrust(e, t, r, n) {
												const i = this.checkUserTrust(e),
													s = e.keys.self_signing;
												if (!s) return new p(!1, !1, r, n);
												const a = function(e, t) {
													return {
														algorithms: e.algorithms,
														keys: e.keys,
														device_id: e.deviceId,
														user_id: t,
														signatures: e.signatures
													}
												}(t, e.userId);
												try {
													return (0, o.pkVerify)(s, e.getId(), e.userId), (0, o.pkVerify)(a, u(s), e.userId), p.fromUserTrustLevel(i, r, n)
												} catch (c) {
													return new p(!1, !1, r, n)
												}
											}
											getCacheCallbacks() {
												return this.cacheCallbacks
											}
										}
										var h;
										n.CrossSigningInfo = d,
											function(e) {
												e[e.MASTER = 4] = "MASTER", e[e.USER_SIGNING = 2] = "USER_SIGNING", e[e.SELF_SIGNING = 1] = "SELF_SIGNING"
											}(h = n.CrossSigningLevel || (n.CrossSigningLevel = {}));
										class f {
											constructor(e, t, r) {
												this.crossSigningVerified = e, this.crossSigningVerifiedBefore = t, this.tofu = r
											}
											isVerified() {
												return this.isCrossSigningVerified()
											}
											isCrossSigningVerified() {
												return this.crossSigningVerified
											}
											wasCrossSigningVerified() {
												return this.crossSigningVerifiedBefore
											}
											isTofu() {
												return this.tofu
											}
										}
										n.UserTrustLevel = f;
										class p {
											constructor(e, t, r, n) {
												this.crossSigningVerified = e, this.tofu = t, this.localVerified = r, this.trustCrossSignedDevices = n
											}
											static fromUserTrustLevel(e, t, r) {
												return new p(e.isCrossSigningVerified(), e.isTofu(), t, r)
											}
											isVerified() {
												return Boolean(this.isLocallyVerified() || this.trustCrossSignedDevices && this.isCrossSigningVerified())
											}
											isCrossSigningVerified() {
												return this.crossSigningVerified
											}
											isLocallyVerified() {
												return this.localVerified
											}
											isTofu() {
												return this.tofu
											}
										}
										n.DeviceTrustLevel = p, n.createCryptoStoreCacheCallbacks = function(e, t) {
											return {
												getCrossSigningKeyCache: function(n, s) {
													return i(this, void 0, void 0, (function*() {
														const i = yield new Promise(t => e.doTxn("readonly", [a.IndexedDBCryptoStore.STORE_ACCOUNT], r => {
															e.getSecretStorePrivateKey(r, t, n)
														}));
														if (i && i.ciphertext) {
															const e = r.from(t.pickleKey),
																s = yield(0, c.decryptAES)(i, e, n);
															return (0, o.decodeBase64)(s)
														}
														return i
													}))
												},
												storeCrossSigningKeyCache: function(n, s) {
													return i(this, void 0, void 0, (function*() {
														if (!(s instanceof Uint8Array)) throw new Error(`storeCrossSigningKeyCache expects Uint8Array, got ${s}`);
														const i = r.from(t.pickleKey),
															l = yield(0, c.encryptAES)((0, o.encodeBase64)(s), i, n);
														return e.doTxn("readwrite", [a.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
															e.storeSecretStorePrivateKey(t, n, l)
														})
													}))
												}
											}
										}, n.requestKeysDuringVerification = function(e, t, r) {
											return i(this, void 0, void 0, (function*() {
												if (e.getUserId() === t) return s.logger.log("Cross-signing: Self-verification done; requesting keys"), new Promise((t, n) => {
													const a = e,
														c = a.crypto.crossSigningInfo,
														u = new d(c.userId, {
															getCrossSigningKey: e => i(this, void 0, void 0, (function*() {
																s.logger.debug("Cross-signing: requesting secret", e, r);
																const {
																	promise: t
																} = a.requestSecret(`m.cross_signing.${e}`, [r]), n = yield t, i = (0, o.decodeBase64)(n);
																return Uint8Array.from(i)
															}))
														}, c.getCacheCallbacks());
													u.keys = c.keys;
													const h = new Promise(e => {
															setTimeout(e, l, new Error("Timeout"))
														}),
														f = (() => i(this, void 0, void 0, (function*() {
															if (!(yield a.crypto.getSessionBackupPrivateKey())) {
																s.logger.info("No cached backup key found. Requesting...");
																const e = a.requestSecret("m.megolm_backup.v1", [r]),
																	t = yield e.promise;
																s.logger.info("Got key backup key, decoding...");
																const n = (0, o.decodeBase64)(t);
																s.logger.info("Decoded backup key, storing..."), yield a.crypto.storeSessionBackupPrivateKey(Uint8Array.from(n)), s.logger.info("Backup key stored. Starting backup restore...");
																const i = yield a.getKeyBackupVersion();
																a.restoreKeyBackupWithCache(void 0, void 0, i).then(() => {
																	s.logger.info("Backup restored.")
																})
															}
														})))();
													return Promise.race([Promise.all([u.getCrossSigningKey("master"), u.getCrossSigningKey("self_signing"), u.getCrossSigningKey("user_signing"), f]), h]).then(t, n)
												}).catch(e => {
													s.logger.warn("Cross-signing: failure while requesting keys:", e)
												})
											}))
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, t("buffer").Buffer)
							}, {
								"../crypto/store/indexeddb-crypto-store": 329,
								"../logger": 356,
								"./aes": 314,
								"./olmlib": 326,
								buffer: 69
							}],
							308: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
										Object.defineProperty(e, "default", {
											enumerable: !0,
											value: t
										})
									} : function(e, t) {
										e.default = t
									}),
									o = this && this.__importStar || function(e) {
										if (e && e.__esModule) return e;
										var t = {};
										if (null != e)
											for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
										return i(t, e), t
									},
									s = this && this.__awaiter || function(e, t, r, n) {
										return new(r || (r = Promise))((function(i, o) {
											function s(e) {
												try {
													c(n.next(e))
												} catch (t) {
													o(t)
												}
											}

											function a(e) {
												try {
													c(n.throw(e))
												} catch (t) {
													o(t)
												}
											}

											function c(e) {
												var t;
												e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
													e(t)
												}))).then(s, a)
											}
											c((n = n.apply(e, t || [])).next())
										}))
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.DeviceList = r.TrackingStatus = void 0;
								const a = e("../logger"),
									c = e("./deviceinfo"),
									l = e("./CrossSigning"),
									u = o(e("./olmlib")),
									d = e("./store/indexeddb-crypto-store"),
									h = e("../utils"),
									f = e("../models/typed-event-emitter"),
									p = e("./index");
								var v;
								! function(e) {
									e[e.NotTracked = 0] = "NotTracked", e[e.PendingDownload = 1] = "PendingDownload", e[e.DownloadInProgress = 2] = "DownloadInProgress", e[e.UpToDate = 3] = "UpToDate"
								}(v = r.TrackingStatus || (r.TrackingStatus = {}));
								class g extends f.TypedEventEmitter {
									constructor(e, t, r, n = 250) {
										super(), this.cryptoStore = t, this.keyDownloadChunkSize = n, this.devices = {}, this.crossSigningInfo = {}, this.userByIdentityKey = {}, this.deviceTrackingStatus = {}, this.syncToken = null, this.keyDownloadsInProgressByUser = new Map, this.dirty = !1, this.savePromise = null, this.resolveSavePromise = null, this.savePromiseTime = null, this.saveTimer = null, this.hasFetched = null, this.serialiser = new m(e, r, this)
									}
									load() {
										return s(this, void 0, void 0, (function*() {
											yield this.cryptoStore.doTxn("readonly", [d.IndexedDBCryptoStore.STORE_DEVICE_DATA], e => {
												this.cryptoStore.getEndToEndDeviceData(e, e => {
													var t;
													this.hasFetched = Boolean(e && e.devices), this.devices = e ? e.devices : {}, this.crossSigningInfo = e && e.crossSigningInfo || {}, this.deviceTrackingStatus = e ? e.trackingStatus : {}, this.syncToken = null !== (t = null == e ? void 0 : e.syncToken) && void 0 !== t ? t : null, this.userByIdentityKey = {};
													for (const r of Object.keys(this.devices)) {
														const e = this.devices[r];
														for (const t of Object.keys(e)) {
															const n = e[t].keys["curve25519:" + t];
															void 0 !== n && (this.userByIdentityKey[n] = r)
														}
													}
												})
											});
											for (const e of Object.keys(this.deviceTrackingStatus)) this.deviceTrackingStatus[e] == v.DownloadInProgress && (this.deviceTrackingStatus[e] = v.PendingDownload)
										}))
									}
									stop() {
										null !== this.saveTimer && clearTimeout(this.saveTimer)
									}
									saveIfDirty(e = 500) {
										return s(this, void 0, void 0, (function*() {
											if (!this.dirty) return Promise.resolve(!1);
											const t = Date.now() + e;
											this.savePromiseTime && t < this.savePromiseTime && (clearTimeout(this.saveTimer), this.saveTimer = null, this.savePromiseTime = null);
											let r = this.savePromise;
											if (null === r && (r = new Promise(e => {
													this.resolveSavePromise = e
												}), this.savePromise = r), null === this.saveTimer) {
												const r = this.resolveSavePromise;
												this.savePromiseTime = t, this.saveTimer = setTimeout(() => {
													a.logger.log("Saving device tracking data", this.syncToken), this.savePromiseTime = null, this.saveTimer = null, this.savePromise = null, this.resolveSavePromise = null, this.cryptoStore.doTxn("readwrite", [d.IndexedDBCryptoStore.STORE_DEVICE_DATA], e => {
														var t;
														this.cryptoStore.storeEndToEndDeviceData({
															devices: this.devices,
															crossSigningInfo: this.crossSigningInfo,
															trackingStatus: this.deviceTrackingStatus,
															syncToken: null !== (t = this.syncToken) && void 0 !== t ? t : void 0
														}, e)
													}).then(() => {
														this.dirty = !1, null == r || r(!0)
													}, e => {
														a.logger.error("Failed to save device tracking data", this.syncToken), a.logger.error(e)
													})
												}, e)
											}
											return r
										}))
									}
									getSyncToken() {
										return this.syncToken
									}
									setSyncToken(e) {
										this.syncToken = e
									}
									downloadKeys(e, t) {
										const r = [],
											n = [];
										if (e.forEach(e => {
												const i = this.deviceTrackingStatus[e];
												this.keyDownloadsInProgressByUser.has(e) ? (a.logger.log("downloadKeys: already have a download in progress for " + `${e}: awaiting its result`), n.push(this.keyDownloadsInProgressByUser.get(e))) : (t || i != v.UpToDate) && r.push(e)
											}), 0 != r.length) {
											a.logger.log("downloadKeys: downloading for", r);
											const e = this.doKeyDownload(r);
											n.push(e)
										}
										return 0 === n.length && a.logger.log("downloadKeys: already have all necessary keys"), Promise.all(n).then(() => this.getDevicesFromStore(e))
									}
									getDevicesFromStore(e) {
										const t = {};
										return e.forEach(e => {
											t[e] = {}, (this.getStoredDevicesForUser(e) || []).forEach((function(r) {
												t[e][r.deviceId] = r
											}))
										}), t
									}
									getKnownUserIds() {
										return Object.keys(this.devices)
									}
									getStoredDevicesForUser(e) {
										const t = this.devices[e];
										if (!t) return null;
										const r = [];
										for (const n in t) t.hasOwnProperty(n) && r.push(c.DeviceInfo.fromStorage(t[n], n));
										return r
									}
									getRawStoredDevicesForUser(e) {
										return this.devices[e]
									}
									getStoredCrossSigningForUser(e) {
										return this.crossSigningInfo[e] ? l.CrossSigningInfo.fromStorage(this.crossSigningInfo[e], e) : null
									}
									storeCrossSigningForUser(e, t) {
										this.crossSigningInfo[e] = t, this.dirty = !0
									}
									getStoredDevice(e, t) {
										const r = this.devices[e];
										if (null == r ? void 0 : r[t]) return c.DeviceInfo.fromStorage(r[t], t)
									}
									getUserByIdentityKey(e, t) {
										return e !== u.OLM_ALGORITHM && e !== u.MEGOLM_ALGORITHM ? null : this.userByIdentityKey[t]
									}
									getDeviceByIdentityKey(e, t) {
										const r = this.getUserByIdentityKey(e, t);
										if (!r) return null;
										const n = this.devices[r];
										if (!n) return null;
										for (const i in n) {
											if (!n.hasOwnProperty(i)) continue;
											const e = n[i];
											for (const r in e.keys) {
												if (!e.keys.hasOwnProperty(r)) continue;
												if (0 !== r.indexOf("curve25519:")) continue;
												if (e.keys[r] == t) return c.DeviceInfo.fromStorage(e, i)
											}
										}
										return null
									}
									storeDevicesForUser(e, t) {
										this.setRawStoredDevicesForUser(e, t), this.dirty = !0
									}
									startTrackingDeviceList(e) {
										if ("string" != typeof e) throw new Error("userId must be a string; was " + e);
										this.deviceTrackingStatus[e] || (a.logger.log("Now tracking device list for " + e), this.deviceTrackingStatus[e] = v.PendingDownload, this.dirty = !0)
									}
									stopTrackingDeviceList(e) {
										this.deviceTrackingStatus[e] && (a.logger.log("No longer tracking device list for " + e), this.deviceTrackingStatus[e] = v.NotTracked, this.dirty = !0)
									}
									stopTrackingAllDeviceLists() {
										for (const e of Object.keys(this.deviceTrackingStatus)) this.deviceTrackingStatus[e] = v.NotTracked;
										this.dirty = !0
									}
									invalidateUserDeviceList(e) {
										this.deviceTrackingStatus[e] && (a.logger.log("Marking device list outdated for", e), this.deviceTrackingStatus[e] = v.PendingDownload, this.dirty = !0)
									}
									refreshOutdatedDeviceLists() {
										this.saveIfDirty();
										const e = [];
										for (const t of Object.keys(this.deviceTrackingStatus)) {
											this.deviceTrackingStatus[t] == v.PendingDownload && e.push(t)
										}
										return this.doKeyDownload(e)
									}
									setRawStoredDevicesForUser(e, t) {
										if (void 0 !== this.devices[e])
											for (const [r, n] of Object.entries(this.devices[e])) {
												const e = n.keys["curve25519:" + r];
												delete this.userByIdentityKey[e]
											}
										this.devices[e] = t;
										for (const [r, n] of Object.entries(t)) {
											const t = n.keys["curve25519:" + r];
											this.userByIdentityKey[t] = e
										}
									}
									setRawStoredCrossSigningForUser(e, t) {
										this.crossSigningInfo[e] = t
									}
									doKeyDownload(e) {
										if (0 === e.length) return Promise.resolve();
										const t = this.serialiser.updateDevicesForUsers(e, this.syncToken).then(() => {
											r(!0)
										}, t => {
											throw a.logger.error("Error downloading keys for " + e + ":", t), r(!1), t
										});
										e.forEach(e => {
											this.keyDownloadsInProgressByUser.set(e, t), this.deviceTrackingStatus[e] == v.PendingDownload && (this.deviceTrackingStatus[e] = v.DownloadInProgress)
										});
										const r = r => {
											this.emit(p.CryptoEvent.WillUpdateDevices, e, !this.hasFetched), e.forEach(e => {
												if (this.dirty = !0, this.keyDownloadsInProgressByUser.get(e) !== t) return void a.logger.log("Another update in the queue for", e, "- not marking up-to-date");
												this.keyDownloadsInProgressByUser.delete(e), this.deviceTrackingStatus[e] == v.DownloadInProgress && (r ? (this.deviceTrackingStatus[e] = v.UpToDate, a.logger.log("Device list for", e, "now up to date")) : this.deviceTrackingStatus[e] = v.PendingDownload)
											}), this.saveIfDirty(), this.emit(p.CryptoEvent.DevicesUpdated, e, !this.hasFetched), this.hasFetched = !0
										};
										return t
									}
								}
								r.DeviceList = g;
								class m {
									constructor(e, t, r) {
										this.baseApis = e, this.olmDevice = t, this.deviceList = r, this.downloadInProgress = !1, this.keyDownloadsQueuedByUser = {}
									}
									updateDevicesForUsers(e, t) {
										return e.forEach(e => {
											this.keyDownloadsQueuedByUser[e] = !0
										}), this.queuedQueryDeferred || (this.queuedQueryDeferred = (0, h.defer)()), this.syncToken = t, this.downloadInProgress ? (a.logger.log("Queued key download for", e), this.queuedQueryDeferred.promise) : this.doQueuedQueries()
									}
									doQueuedQueries() {
										if (this.downloadInProgress) throw new Error("DeviceListUpdateSerialiser.doQueuedQueries called with request active");
										const e = Object.keys(this.keyDownloadsQueuedByUser);
										this.keyDownloadsQueuedByUser = {};
										const t = this.queuedQueryDeferred;
										this.queuedQueryDeferred = void 0, a.logger.log("Starting key download for", e), this.downloadInProgress = !0;
										const r = {};
										this.syncToken && (r.token = this.syncToken);
										const n = [];
										for (let i = 0; i < e.length; i += this.deviceList.keyDownloadChunkSize) {
											const t = e.slice(i, i + this.deviceList.keyDownloadChunkSize);
											n.push(() => this.baseApis.downloadKeysForUsers(t, r))
										}
										return (0, h.chunkPromises)(n, 3).then(t => s(this, void 0, void 0, (function*() {
											const r = Object.assign({}, ...t.map(e => e.device_keys || {})),
												n = Object.assign({}, ...t.map(e => e.master_keys || {})),
												i = Object.assign({}, ...t.map(e => e.self_signing_keys || {})),
												o = Object.assign({}, ...t.map(e => e.user_signing_keys || {}));
											for (const t of e) {
												yield(0, h.sleep)(5);
												try {
													yield this.processQueryResponseForUser(t, r[t], {
														master: null == n ? void 0 : n[t],
														self_signing: null == i ? void 0 : i[t],
														user_signing: null == o ? void 0 : o[t]
													})
												} catch (s) {
													a.logger.error(`Error processing keys for ${t}:`, s)
												}
											}
										}))).then(() => {
											a.logger.log("Completed key download for " + e), this.downloadInProgress = !1, null == t || t.resolve(), this.queuedQueryDeferred && this.doQueuedQueries()
										}, r => {
											a.logger.warn("Error downloading keys for " + e + ":", r), this.downloadInProgress = !1, null == t || t.reject(r)
										}), t.promise
									}
									processQueryResponseForUser(e, t, r) {
										return s(this, void 0, void 0, (function*() {
											a.logger.log("got device keys for " + e + ":", t), a.logger.log("got cross-signing keys for " + e + ":", r); {
												const r = {},
													n = this.deviceList.getRawStoredDevicesForUser(e);
												n && Object.keys(n).forEach(e => {
													const t = c.DeviceInfo.fromStorage(n[e], e);
													r[e] = t
												}), yield function(e, t, r, n, i, o) {
													return s(this, void 0, void 0, (function*() {
														let s = !1;
														for (const e in r)
															if (r.hasOwnProperty(e) && !(e in n)) {
																if (t === i && e === o) {
																	a.logger.warn(`Local device ${e} missing from sync, skipping removal`);
																	continue
																}
																a.logger.log("Device " + t + ":" + e + " has been removed"), delete r[e], s = !0
															} for (const i in n) {
															if (!n.hasOwnProperty(i)) continue;
															const o = n[i];
															o.user_id === t ? o.device_id === i ? (yield y(e, r, o)) && (s = !0) : a.logger.warn("Mismatched device_id " + o.device_id + " in keys from " + t + ":" + i) : a.logger.warn("Mismatched user_id " + o.user_id + " in keys from " + t + ":" + i)
														}
														return s
													}))
												}(this.olmDevice, e, r, t || {}, this.baseApis.getUserId(), this.baseApis.deviceId);
												const i = {};
												Object.keys(r).forEach(e => {
													i[e] = r[e].toStorage()
												}), this.deviceList.setRawStoredDevicesForUser(e, i)
											}
											if (r && (r.master || r.self_signing || r.user_signing)) {
												const t = this.deviceList.getStoredCrossSigningForUser(e) || new l.CrossSigningInfo(e);
												t.setKeys(r), this.deviceList.setRawStoredCrossSigningForUser(e, t.toStorage()), this.deviceList.emit(p.CryptoEvent.UserCrossSigningUpdated, e)
											}
										}))
									}
								}

								function y(e, t, r) {
									return s(this, void 0, void 0, (function*() {
										if (!r.keys) return !1;
										const n = r.device_id,
											i = r.user_id,
											o = "ed25519:" + n,
											s = r.keys[o];
										if (!s) return a.logger.warn("Device " + i + ":" + n + " has no ed25519 key"), !1;
										const l = r.unsigned || {},
											d = r.signatures || {};
										try {
											yield u.verifySignature(e, r, i, n, s)
										} catch (f) {
											return a.logger.warn("Unable to verify signature on device " + i + ":" + n + ":" + f), !1
										}
										let h;
										if (n in t) {
											if ((h = t[n]).getFingerprint() != s) return a.logger.warn("Ed25519 key for device " + i + ":" + n + " has changed"), !1
										} else t[n] = h = new c.DeviceInfo(n);
										return h.keys = r.keys || {}, h.algorithms = r.algorithms || [], h.unsigned = l, h.signatures = d, !0
									}))
								}
							}, {
								"../logger": 356,
								"../models/typed-event-emitter": 376,
								"../utils": 393,
								"./CrossSigning": 307,
								"./deviceinfo": 323,
								"./index": 324,
								"./olmlib": 326,
								"./store/indexeddb-crypto-store": 329
							}],
							309: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.EncryptionSetupOperation = r.EncryptionSetupBuilder = void 0;
								const i = e("../logger"),
									o = e("../models/event"),
									s = e("./CrossSigning"),
									a = e("./store/indexeddb-crypto-store"),
									c = e("../http-api"),
									l = e("../client"),
									u = e("../models/typed-event-emitter");
								r.EncryptionSetupBuilder = class {
									constructor(e, t) {
										this.accountDataClientAdapter = new h(e), this.crossSigningCallbacks = new f, this.ssssCryptoCallbacks = new p(t)
									}
									addCrossSigningKeys(e, t) {
										this.crossSigningKeys = {
											authUpload: e,
											keys: t
										}
									}
									addSessionBackup(e) {
										this.keyBackupInfo = e
									}
									addSessionBackupPrivateKeyToCache(e) {
										this.sessionBackupPrivateKey = e
									}
									addKeySignature(e, t, r) {
										this.keySignatures || (this.keySignatures = {});
										const n = this.keySignatures[e] || {};
										this.keySignatures[e] = n, n[t] = r
									}
									setAccountData(e, t) {
										return n(this, void 0, void 0, (function*() {
											yield this.accountDataClientAdapter.setAccountData(e, t)
										}))
									}
									buildOperation() {
										const e = this.accountDataClientAdapter.values;
										return new d(e, this.crossSigningKeys, this.keyBackupInfo, this.keySignatures)
									}
									persist(e) {
										var t;
										return n(this, void 0, void 0, (function*() {
											if (this.crossSigningKeys) {
												const r = (0, s.createCryptoStoreCacheCallbacks)(e.cryptoStore, e.olmDevice);
												for (const e of ["master", "self_signing", "user_signing"]) {
													i.logger.log(`Cache ${e} cross-signing private key locally`);
													const n = this.crossSigningCallbacks.privateKeys.get(e);
													yield null === (t = r.storeCrossSigningKeyCache) || void 0 === t ? void 0 : t.call(r, e, n)
												}
												yield e.cryptoStore.doTxn("readwrite", [a.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
													e.cryptoStore.storeCrossSigningKeys(t, this.crossSigningKeys.keys)
												})
											}
											this.sessionBackupPrivateKey && (yield e.storeSessionBackupPrivateKey(this.sessionBackupPrivateKey))
										}))
									}
								};
								class d {
									constructor(e, t, r, n) {
										this.accountData = e, this.crossSigningKeys = t, this.keyBackupInfo = r, this.keySignatures = n
									}
									apply(e) {
										var t, r;
										return n(this, void 0, void 0, (function*() {
											const n = e.baseApis;
											if (this.crossSigningKeys) {
												const i = {};
												for (const [e, t] of Object.entries(this.crossSigningKeys.keys)) i[e + "_key"] = t;
												yield null === (r = (t = this.crossSigningKeys).authUpload) || void 0 === r ? void 0 : r.call(t, e => n.uploadDeviceSigningKeys(e, i)), e.crossSigningInfo.setKeys(this.crossSigningKeys.keys)
											}
											if (this.accountData)
												for (const [e, t] of this.accountData) yield n.setAccountData(e, t);
											this.keySignatures && (yield n.uploadKeySignatures(this.keySignatures)), this.keyBackupInfo && (this.keyBackupInfo.version ? yield n.http.authedRequest(c.Method.Put, "/room_keys/version/" + this.keyBackupInfo.version, void 0, {
												algorithm: this.keyBackupInfo.algorithm,
												auth_data: this.keyBackupInfo.auth_data
											}, {
												prefix: c.ClientPrefix.V3
											}): yield n.http.authedRequest(c.Method.Post, "/room_keys/version", void 0, this.keyBackupInfo, {
												prefix: c.ClientPrefix.V3
											}))
										}))
									}
								}
								r.EncryptionSetupOperation = d;
								class h extends u.TypedEventEmitter {
									constructor(e) {
										super(), this.existingValues = e, this.values = new Map
									}
									getAccountDataFromServer(e) {
										return Promise.resolve(this.getAccountData(e))
									}
									getAccountData(e) {
										const t = this.values.get(e);
										if (t) return t;
										const r = this.existingValues[e];
										return r ? r.getContent() : null
									}
									setAccountData(e, t) {
										const r = this.values.get(e);
										return this.values.set(e, t), Promise.resolve().then(() => {
											const n = new o.MatrixEvent({
												type: e,
												content: t
											});
											return this.emit(l.ClientEvent.AccountData, n, r), {}
										})
									}
								}
								class f {
									constructor() {
										this.privateKeys = new Map
									}
									getCrossSigningKeyCache(e, t) {
										return this.getCrossSigningKey(e, t)
									}
									storeCrossSigningKeyCache(e, t) {
										return this.privateKeys.set(e, t), Promise.resolve()
									}
									getCrossSigningKey(e, t) {
										var r;
										return Promise.resolve(null !== (r = this.privateKeys.get(e)) && void 0 !== r ? r : null)
									}
									saveCrossSigningKeys(e) {
										for (const [t, r] of Object.entries(e)) this.privateKeys.set(t, r)
									}
								}
								class p {
									constructor(e) {
										this.delegateCryptoCallbacks = e, this.privateKeys = new Map
									}
									getSecretStorageKey({
										keys: e
									}, t) {
										var r;
										return n(this, void 0, void 0, (function*() {
											for (const t of Object.keys(e)) {
												const e = this.privateKeys.get(t);
												if (e) return [t, e]
											}
											if (null === (r = null == this ? void 0 : this.delegateCryptoCallbacks) || void 0 === r ? void 0 : r.getSecretStorageKey) {
												const r = yield this.delegateCryptoCallbacks.getSecretStorageKey({
													keys: e
												}, t);
												if (r) {
													const [e, t] = r;
													this.privateKeys.set(e, t)
												}
												return r
											}
											return null
										}))
									}
									addPrivateKey(e, t, r) {
										var n, i;
										this.privateKeys.set(e, r), null === (i = null === (n = this.delegateCryptoCallbacks) || void 0 === n ? void 0 : n.cacheSecretStorageKey) || void 0 === i || i.call(n, e, t, r)
									}
								}
							}, {
								"../client": 304,
								"../http-api": 349,
								"../logger": 356,
								"../models/event": 365,
								"../models/typed-event-emitter": 376,
								"./CrossSigning": 307,
								"./store/indexeddb-crypto-store": 329
							}],
							310: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var r = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
												void 0 === n && (n = r);
												var i = Object.getOwnPropertyDescriptor(t, r);
												i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
													enumerable: !0,
													get: function() {
														return t[r]
													}
												}), Object.defineProperty(e, n, i)
											} : function(e, t, r, n) {
												void 0 === n && (n = r), e[n] = t[r]
											}),
											i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
												Object.defineProperty(e, "default", {
													enumerable: !0,
													value: t
												})
											} : function(e, t) {
												e.default = t
											}),
											o = this && this.__importStar || function(e) {
												if (e && e.__esModule) return e;
												var t = {};
												if (null != e)
													for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);
												return i(t, e), t
											},
											s = this && this.__awaiter || function(e, t, r, n) {
												return new(r || (r = Promise))((function(i, o) {
													function s(e) {
														try {
															c(n.next(e))
														} catch (t) {
															o(t)
														}
													}

													function a(e) {
														try {
															c(n.throw(e))
														} catch (t) {
															o(t)
														}
													}

													function c(e) {
														var t;
														e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
															e(t)
														}))).then(s, a)
													}
													c((n = n.apply(e, t || [])).next())
												}))
											};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.WITHHELD_MESSAGES = n.OlmDevice = void 0;
										const a = t("../logger"),
											c = t("./store/indexeddb-crypto-store"),
											l = o(t("./algorithms")),
											u = 49152;

										function d(e) {
											if (void 0 === e) throw new Error("payloadString undefined");
											if (e.length > u) {
												const t = new Error("Message too long (" + e.length + " bytes). The maximum for an encrypted message is " + u + " bytes.");
												throw t.data = {
													errcode: "M_TOO_LARGE",
													error: "Payload too large for encrypted message"
												}, t
											}
										}

										function h(e) {
											return e.code && e.code in n.WITHHELD_MESSAGES ? n.WITHHELD_MESSAGES[e.code] : e.reason ? e.reason : "decryption key withheld"
										}
										n.OlmDevice = class {
											constructor(e) {
												this.cryptoStore = e, this.pickleKey = "DEFAULT_KEY", this.deviceCurve25519Key = null, this.deviceEd25519Key = null, this.maxOneTimeKeys = null, this.outboundGroupSessionStore = {}, this.inboundGroupSessionMessageIndexes = {}, this.sessionsInProgress = {}, this.olmPrekeyPromise = Promise.resolve()
											}
											static getOlmVersion() {
												return e.Olm.get_library_version()
											}
											init({
												pickleKey: t,
												fromExportedDevice: r
											} = {}) {
												return s(this, void 0, void 0, (function*() {
													let n;
													const i = new e.Olm.Account;
													try {
														r ? (t && a.logger.warn("ignoring opts.pickleKey because opts.fromExportedDevice is present."), this.pickleKey = r.pickleKey, yield this.initialiseFromExportedDevice(r, i)) : (t && (this.pickleKey = t), yield this.initialiseAccount(i)), n = JSON.parse(i.identity_keys()), this.maxOneTimeKeys = i.max_number_of_one_time_keys()
													} finally {
														i.free()
													}
													this.deviceCurve25519Key = n.curve25519, this.deviceEd25519Key = n.ed25519
												}))
											}
											initialiseFromExportedDevice(e, t) {
												return s(this, void 0, void 0, (function*() {
													yield this.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_ACCOUNT, c.IndexedDBCryptoStore.STORE_SESSIONS], t => {
														this.cryptoStore.storeAccount(t, e.pickledAccount), e.sessions.forEach(e => {
															const {
																deviceKey: r,
																sessionId: n
															} = e, i = {
																session: e.session,
																lastReceivedMessageTs: e.lastReceivedMessageTs
															};
															this.cryptoStore.storeEndToEndSession(r, n, i, t)
														})
													}), t.unpickle(this.pickleKey, e.pickledAccount)
												}))
											}
											initialiseAccount(e) {
												return s(this, void 0, void 0, (function*() {
													yield this.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
														this.cryptoStore.getAccount(t, r => {
															null !== r ? e.unpickle(this.pickleKey, r) : (e.create(), r = e.pickle(this.pickleKey), this.cryptoStore.storeAccount(t, r))
														})
													})
												}))
											}
											getAccount(t, r) {
												this.cryptoStore.getAccount(t, t => {
													const n = new e.Olm.Account;
													try {
														n.unpickle(this.pickleKey, t), r(n)
													} finally {
														n.free()
													}
												})
											}
											storeAccount(e, t) {
												this.cryptoStore.storeAccount(e, t.pickle(this.pickleKey))
											}
											export () {
												return s(this, void 0, void 0, (function*() {
													const e = {
														pickleKey: this.pickleKey
													};
													return yield this.cryptoStore.doTxn("readonly", [c.IndexedDBCryptoStore.STORE_ACCOUNT, c.IndexedDBCryptoStore.STORE_SESSIONS], t => {
														this.cryptoStore.getAccount(t, t => {
															e.pickledAccount = t
														}), e.sessions = [], this.cryptoStore.getAllEndToEndSessions(t, t => {
															e.sessions.push(t)
														})
													}), e
												}))
											}
											getSession(e, t, r, n) {
												this.cryptoStore.getEndToEndSession(e, t, r, e => {
													this.unpickleSession(e, n)
												})
											}
											unpickleSession(t, r) {
												const n = new e.Olm.Session;
												try {
													n.unpickle(this.pickleKey, t.session), r(Object.assign({}, t, {
														session: n
													}))
												} finally {
													n.free()
												}
											}
											saveSession(e, t, r) {
												const n = t.session.session_id(),
													i = Object.assign(t, {
														session: t.session.pickle(this.pickleKey)
													});
												this.cryptoStore.storeEndToEndSession(e, n, i, r)
											}
											getUtility(t) {
												const r = new e.Olm.Utility;
												try {
													return t(r)
												} finally {
													r.free()
												}
											}
											sign(e) {
												return s(this, void 0, void 0, (function*() {
													let t;
													return yield this.cryptoStore.doTxn("readonly", [c.IndexedDBCryptoStore.STORE_ACCOUNT], r => {
														this.getAccount(r, r => {
															t = r.sign(e)
														})
													}), t
												}))
											}
											getOneTimeKeys() {
												return s(this, void 0, void 0, (function*() {
													let e;
													return yield this.cryptoStore.doTxn("readonly", [c.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
														this.getAccount(t, t => {
															e = JSON.parse(t.one_time_keys())
														})
													}), e
												}))
											}
											maxNumberOfOneTimeKeys() {
												var e;
												return null !== (e = this.maxOneTimeKeys) && void 0 !== e ? e : -1
											}
											markKeysAsPublished() {
												return s(this, void 0, void 0, (function*() {
													yield this.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
														this.getAccount(e, t => {
															t.mark_keys_as_published(), this.storeAccount(e, t)
														})
													})
												}))
											}
											generateOneTimeKeys(e) {
												return this.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
													this.getAccount(t, r => {
														r.generate_one_time_keys(e), this.storeAccount(t, r)
													})
												})
											}
											generateFallbackKey() {
												return s(this, void 0, void 0, (function*() {
													yield this.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
														this.getAccount(e, t => {
															t.generate_fallback_key(), this.storeAccount(e, t)
														})
													})
												}))
											}
											getFallbackKey() {
												return s(this, void 0, void 0, (function*() {
													let e;
													return yield this.cryptoStore.doTxn("readonly", [c.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
														this.getAccount(t, t => {
															e = JSON.parse(t.unpublished_fallback_key())
														})
													}), e
												}))
											}
											forgetOldFallbackKey() {
												return s(this, void 0, void 0, (function*() {
													yield this.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
														this.getAccount(e, t => {
															t.forget_old_fallback_key(), this.storeAccount(e, t)
														})
													})
												}))
											}
											createOutboundSession(t, r) {
												return s(this, void 0, void 0, (function*() {
													let n;
													return yield this.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_ACCOUNT, c.IndexedDBCryptoStore.STORE_SESSIONS], i => {
														this.getAccount(i, o => {
															const s = new e.Olm.Session;
															try {
																s.create_outbound(o, t, r), n = s.session_id(), this.storeAccount(i, o);
																const e = {
																	session: s,
																	lastReceivedMessageTs: Date.now()
																};
																this.saveSession(t, e, i)
															} finally {
																s.free()
															}
														})
													}, a.logger.withPrefix("[createOutboundSession]")), n
												}))
											}
											createInboundSession(t, r, n) {
												return s(this, void 0, void 0, (function*() {
													if (0 !== r) throw new Error("Need messageType == 0 to create inbound session");
													let i;
													return yield this.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_ACCOUNT, c.IndexedDBCryptoStore.STORE_SESSIONS], o => {
														this.getAccount(o, s => {
															const a = new e.Olm.Session;
															try {
																a.create_inbound_from(s, t, n), s.remove_one_time_keys(a), this.storeAccount(o, s);
																const e = a.decrypt(r, n),
																	c = {
																		session: a,
																		lastReceivedMessageTs: Date.now()
																	};
																this.saveSession(t, c, o), i = {
																	payload: e,
																	session_id: a.session_id()
																}
															} finally {
																a.free()
															}
														})
													}, a.logger.withPrefix("[createInboundSession]")), i
												}))
											}
											getSessionIdsForDevice(e) {
												return s(this, void 0, void 0, (function*() {
													const t = a.logger.withPrefix("[getSessionIdsForDevice]");
													if (e in this.sessionsInProgress) {
														t.debug(`Waiting for Olm session for ${e} to be created`);
														try {
															yield this.sessionsInProgress[e]
														} catch (n) {}
													}
													let r;
													return yield this.cryptoStore.doTxn("readonly", [c.IndexedDBCryptoStore.STORE_SESSIONS], t => {
														this.cryptoStore.getEndToEndSessions(e, t, e => {
															r = Object.keys(e)
														})
													}, t), r
												}))
											}
											getSessionIdForDevice(e, t = !1, r) {
												return s(this, void 0, void 0, (function*() {
													const n = yield this.getSessionInfoForDevice(e, t, r);
													if (0 === n.length) return null;
													let i = 0;
													for (let e = 1; e < n.length; e++) {
														const t = n[e],
															r = void 0 === t.lastReceivedMessageTs ? 0 : t.lastReceivedMessageTs,
															o = n[i],
															s = void 0 === o.lastReceivedMessageTs ? 0 : o.lastReceivedMessageTs;
														(r > s || r === s && t.sessionId < o.sessionId) && (i = e)
													}
													return n[i].sessionId
												}))
											}
											getSessionInfoForDevice(e, t = !1, r = a.logger) {
												return s(this, void 0, void 0, (function*() {
													if (r = r.withPrefix("[getSessionInfoForDevice]"), e in this.sessionsInProgress && !t) {
														r.debug(`Waiting for Olm session for ${e} to be created`);
														try {
															yield this.sessionsInProgress[e]
														} catch (i) {}
													}
													const n = [];
													return yield this.cryptoStore.doTxn("readonly", [c.IndexedDBCryptoStore.STORE_SESSIONS], t => {
														this.cryptoStore.getEndToEndSessions(e, t, e => {
															const t = Object.keys(e).sort();
															for (const r of t) this.unpickleSession(e[r], e => {
																n.push({
																	lastReceivedMessageTs: e.lastReceivedMessageTs,
																	hasReceivedMessage: e.session.has_received_message(),
																	sessionId: r
																})
															})
														})
													}, r), n
												}))
											}
											encryptMessage(e, t, r) {
												return s(this, void 0, void 0, (function*() {
													let n;
													return d(r), yield this.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_SESSIONS], i => {
														this.getSession(e, t, i, o => {
															const s = o.session.describe();
															a.logger.log("encryptMessage: Olm Session ID " + t + " to " + e + ": " + s), n = o.session.encrypt(r), this.saveSession(e, o, i)
														})
													}, a.logger.withPrefix("[encryptMessage]")), n
												}))
											}
											decryptMessage(e, t, r, n) {
												return s(this, void 0, void 0, (function*() {
													let i;
													return yield this.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_SESSIONS], o => {
														this.getSession(e, t, o, s => {
															const c = s.session.describe();
															a.logger.log("decryptMessage: Olm Session ID " + t + " from " + e + ": " + c), i = s.session.decrypt(r, n), s.lastReceivedMessageTs = Date.now(), this.saveSession(e, s, o)
														})
													}, a.logger.withPrefix("[decryptMessage]")), i
												}))
											}
											matchesSession(e, t, r, n) {
												return s(this, void 0, void 0, (function*() {
													if (0 !== r) return !1;
													let i;
													return yield this.cryptoStore.doTxn("readonly", [c.IndexedDBCryptoStore.STORE_SESSIONS], r => {
														this.getSession(e, t, r, e => {
															i = e.session.matches_inbound(n)
														})
													}, a.logger.withPrefix("[matchesSession]")), i
												}))
											}
											recordSessionProblem(e, t, r) {
												return s(this, void 0, void 0, (function*() {
													yield this.cryptoStore.storeEndToEndSessionProblem(e, t, r)
												}))
											}
											sessionMayHaveProblems(e, t) {
												return this.cryptoStore.getEndToEndSessionProblem(e, t)
											}
											filterOutNotifiedErrorDevices(e) {
												return this.cryptoStore.filterOutNotifiedErrorDevices(e)
											}
											saveOutboundGroupSession(e) {
												this.outboundGroupSessionStore[e.session_id()] = e.pickle(this.pickleKey)
											}
											getOutboundGroupSession(t, r) {
												const n = this.outboundGroupSessionStore[t];
												if (void 0 === n) throw new Error("Unknown outbound group session " + t);
												const i = new e.Olm.OutboundGroupSession;
												try {
													return i.unpickle(this.pickleKey, n), r(i)
												} finally {
													i.free()
												}
											}
											createOutboundGroupSession() {
												const t = new e.Olm.OutboundGroupSession;
												try {
													return t.create(), this.saveOutboundGroupSession(t), t.session_id()
												} finally {
													t.free()
												}
											}
											encryptGroupMessage(e, t) {
												return a.logger.log(`encrypting msg with megolm session ${e}`), d(t), this.getOutboundGroupSession(e, e => {
													const r = e.encrypt(t);
													return this.saveOutboundGroupSession(e), r
												})
											}
											getOutboundGroupSessionKey(e) {
												return this.getOutboundGroupSession(e, (function(e) {
													return {
														chain_index: e.message_index(),
														key: e.session_key()
													}
												}))
											}
											unpickleInboundGroupSession(t, r) {
												const n = new e.Olm.InboundGroupSession;
												try {
													return n.unpickle(this.pickleKey, t.session), r(n)
												} finally {
													n.free()
												}
											}
											getInboundGroupSession(e, t, r, n, i) {
												this.cryptoStore.getEndToEndInboundGroupSession(t, r, n, (t, r) => {
													if (null !== t) {
														if (null !== e && e !== t.room_id) throw new Error("Mismatched room_id for inbound group session (expected " + t.room_id + ", was " + e + ")");
														this.unpickleInboundGroupSession(t, e => {
															i(e, t, r)
														})
													} else i(null, null, r)
												})
											}
											addInboundGroupSession(t, r, n, i, o, l, u, d = {}) {
												return s(this, void 0, void 0, (function*() {
													yield this.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, c.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD, c.IndexedDBCryptoStore.STORE_SHARED_HISTORY_INBOUND_GROUP_SESSIONS], s => {
														this.getInboundGroupSession(t, r, i, s, (c, h) => {
															const f = new e.Olm.InboundGroupSession;
															try {
																if (u ? f.import_session(o) : f.create(o), i != f.session_id()) throw new Error("Mismatched group session ID from senderKey: " + r);
																if (c && (a.logger.log("Update for megolm session " + r + "/" + i), c.first_known_index() <= f.first_known_index())) {
																	if (!h.untrusted || d.untrusted) return void a.logger.log(`Keeping existing megolm session ${i}`);
																	if (c.first_known_index() < f.first_known_index()) return void(c.export_session(f.first_known_index()) === f.export_session(f.first_known_index()) ? (a.logger.info("Upgrading trust of existing megolm session " + i + " based on newly-received trusted session"), h.untrusted = !1, this.cryptoStore.storeEndToEndInboundGroupSession(r, i, h, s)) : a.logger.warn("Newly-received megolm session " + i + " does not match existing session! Keeping existing session"))
																}
																a.logger.info("Storing megolm session " + r + "/" + i + " with first index " + f.first_known_index());
																const e = Object.assign({}, d, {
																	room_id: t,
																	session: f.pickle(this.pickleKey),
																	keysClaimed: l,
																	forwardingCurve25519KeyChain: n
																});
																this.cryptoStore.storeEndToEndInboundGroupSession(r, i, e, s), !c && d.sharedHistory && this.cryptoStore.addSharedHistoryInboundGroupSession(t, r, i, s)
															} finally {
																f.free()
															}
														})
													}, a.logger.withPrefix("[addInboundGroupSession]"))
												}))
											}
											addInboundGroupSessionWithheld(e, t, r, n, i) {
												return s(this, void 0, void 0, (function*() {
													yield this.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], o => {
														this.cryptoStore.storeEndToEndInboundGroupSessionWithheld(t, r, {
															room_id: e,
															code: n,
															reason: i
														}, o)
													})
												}))
											}
											decryptGroupMessage(e, t, r, n, i, o) {
												return s(this, void 0, void 0, (function*() {
													let s, u = null;
													if (yield this.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, c.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], a => {
															this.getInboundGroupSession(e, t, r, a, (e, c, d) => {
																if (null === e || null === c) return d && (s = new l.DecryptionError("MEGOLM_UNKNOWN_INBOUND_SESSION_ID", h(d), {
																	session: t + "|" + r
																})), void(u = null);
																let f;
																try {
																	f = e.decrypt(n)
																} catch (v) {
																	return void(s = "OLM.UNKNOWN_MESSAGE_INDEX" === (null == v ? void 0 : v.message) && d ? new l.DecryptionError("MEGOLM_UNKNOWN_INBOUND_SESSION_ID", h(d), {
																		session: t + "|" + r
																	}) : v)
																}
																let p = f.plaintext;
																if (void 0 === p) p = f;
																else {
																	const e = t + "|" + r + "|" + f.message_index;
																	if (e in this.inboundGroupSessionMessageIndexes) {
																		const t = this.inboundGroupSessionMessageIndexes[e];
																		if (t.id !== i || t.timestamp !== o) return void(s = new Error("Duplicate message index, possible replay attack: " + e))
																	}
																	this.inboundGroupSessionMessageIndexes[e] = {
																		id: i,
																		timestamp: o
																	}
																}
																c.session = e.pickle(this.pickleKey), this.cryptoStore.storeEndToEndInboundGroupSession(t, r, c, a), u = {
																	result: p,
																	keysClaimed: c.keysClaimed || {},
																	senderKey: t,
																	forwardingCurve25519KeyChain: c.forwardingCurve25519KeyChain || [],
																	untrusted: !!c.untrusted
																}
															})
														}, a.logger.withPrefix("[decryptGroupMessage]")), s) throw s;
													return u
												}))
											}
											hasInboundSessionKeys(e, t, r) {
												return s(this, void 0, void 0, (function*() {
													let n;
													return yield this.cryptoStore.doTxn("readonly", [c.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, c.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], i => {
														this.cryptoStore.getEndToEndInboundGroupSession(t, r, i, i => {
															null !== i ? e !== i.room_id ? (a.logger.warn(`requested keys for inbound group session ${t}|` + `${r}, with incorrect room_id ` + `(expected ${i.room_id}, ` + `was ${e})`), n = !1) : n = !0 : n = !1
														})
													}, a.logger.withPrefix("[hasInboundSessionKeys]")), n
												}))
											}
											getInboundGroupSessionKey(e, t, r, n) {
												return s(this, void 0, void 0, (function*() {
													let i = null;
													return yield this.cryptoStore.doTxn("readonly", [c.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, c.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], o => {
														this.getInboundGroupSession(e, t, r, o, (e, t) => {
															if (null === e || null === t) return void(i = null);
															void 0 === n && (n = e.first_known_index());
															const r = e.export_session(n),
																o = (t.keysClaimed || {}).ed25519 || null,
																s = t.forwardingCurve25519KeyChain || [],
																a = "untrusted" in t ? t.untrusted : s.length > 0;
															i = {
																chain_index: n,
																key: r,
																forwarding_curve25519_key_chain: s,
																sender_claimed_ed25519_key: o,
																shared_history: t.sharedHistory || !1,
																untrusted: a
															}
														})
													}, a.logger.withPrefix("[getInboundGroupSessionKey]")), i
												}))
											}
											exportInboundGroupSession(e, t, r) {
												return this.unpickleInboundGroupSession(r, n => {
													const i = n.first_known_index();
													return {
														sender_key: e,
														sender_claimed_keys: r.keysClaimed,
														room_id: r.room_id,
														session_id: t,
														session_key: n.export_session(i),
														forwarding_curve25519_key_chain: r.forwardingCurve25519KeyChain || [],
														first_known_index: n.first_known_index(),
														"org.matrix.msc3061.shared_history": r.sharedHistory || !1
													}
												})
											}
											getSharedHistoryInboundGroupSessions(e) {
												return s(this, void 0, void 0, (function*() {
													let t;
													return yield this.cryptoStore.doTxn("readonly", [c.IndexedDBCryptoStore.STORE_SHARED_HISTORY_INBOUND_GROUP_SESSIONS], r => {
														t = this.cryptoStore.getSharedHistoryInboundGroupSessions(e, r)
													}, a.logger.withPrefix("[getSharedHistoryInboundGroupSessionsForRoom]")), t
												}))
											}
											verifySignature(e, t, r) {
												this.getUtility((function(n) {
													n.ed25519_verify(e, t, r)
												}))
											}
										}, n.WITHHELD_MESSAGES = {
											"m.unverified": "The sender has disabled encrypting to unverified devices.",
											"m.blacklisted": "The sender has blocked you.",
											"m.unauthorised": "You are not authorised to read the message.",
											"m.no_olm": "Unable to establish a secure channel."
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"../logger": 356,
								"./algorithms": 316,
								"./store/indexeddb-crypto-store": 329
							}],
							311: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.OutgoingRoomKeyRequestManager = r.RoomKeyRequestState = void 0;
								const i = e("../logger"),
									o = e("../@types/event"),
									s = 500;
								var a;
								! function(e) {
									e[e.Unsent = 0] = "Unsent", e[e.Sent = 1] = "Sent", e[e.CancellationPending = 2] = "CancellationPending", e[e.CancellationPendingAndWillResend = 3] = "CancellationPendingAndWillResend"
								}(a = r.RoomKeyRequestState || (r.RoomKeyRequestState = {}));

								function c(e) {
									return e.room_id + " / " + e.session_id
								}

								function l(e) {
									return `[${e.map(e=>`${e.userId}:${e.deviceId}`).join(",")}]`
								}
								r.OutgoingRoomKeyRequestManager = class {
									constructor(e, t, r) {
										this.baseApis = e, this.deviceId = t, this.cryptoStore = r, this.sendOutgoingRoomKeyRequestsRunning = !1, this.clientRunning = !0
									}
									stop() {
										i.logger.log("stopping OutgoingRoomKeyRequestManager"), this.clientRunning = !1
									}
									sendQueuedRequests() {
										this.startTimer()
									}
									queueRoomKeyRequest(e, t, r = !1) {
										return n(this, void 0, void 0, (function*() {
											const n = yield this.cryptoStore.getOutgoingRoomKeyRequest(e);
											if (n) switch (n.state) {
												case a.CancellationPendingAndWillResend:
												case a.Unsent:
													return;
												case a.CancellationPending: {
													const e = r ? a.CancellationPendingAndWillResend : a.Sent;
													yield this.cryptoStore.updateOutgoingRoomKeyRequest(n.requestId, a.CancellationPending, {
														state: e,
														cancellationTxnId: this.baseApis.makeTxnId()
													});
													break
												}
												case a.Sent:
													if (r) {
														const s = a.CancellationPendingAndWillResend,
															c = yield this.cryptoStore.updateOutgoingRoomKeyRequest(n.requestId, a.Sent, {
																state: s,
																cancellationTxnId: this.baseApis.makeTxnId(),
																requestTxnId: this.baseApis.makeTxnId()
															});
														if (!c) return this.queueRoomKeyRequest(e, t, r);
														try {
															yield this.sendOutgoingRoomKeyRequestCancellation(c, !0)
														} catch (o) {
															i.logger.error("Error sending room key request cancellation; will retry later.", o)
														}
													}
													break;
												default:
													throw new Error("unhandled state: " + n.state)
											} else yield this.cryptoStore.getOrAddOutgoingRoomKeyRequest({
												requestBody: e,
												recipients: t,
												requestId: this.baseApis.makeTxnId(),
												state: a.Unsent
											})
										}))
									}
									cancelRoomKeyRequest(e) {
										return this.cryptoStore.getOutgoingRoomKeyRequest(e).then(t => {
											if (t) switch (t.state) {
												case a.CancellationPending:
												case a.CancellationPendingAndWillResend:
													return;
												case a.Unsent:
													return i.logger.log("deleting unnecessary room key request for " + c(e)), this.cryptoStore.deleteOutgoingRoomKeyRequest(t.requestId, a.Unsent);
												case a.Sent:
													return this.cryptoStore.updateOutgoingRoomKeyRequest(t.requestId, a.Sent, {
														state: a.CancellationPending,
														cancellationTxnId: this.baseApis.makeTxnId()
													}).then(t => {
														t ? this.sendOutgoingRoomKeyRequestCancellation(t).catch(e => {
															i.logger.error("Error sending room key request cancellation; will retry later.", e), this.startTimer()
														}) : i.logger.log("Tried to cancel room key request for " + c(e) + " but it was already cancelled in another tab")
													});
												default:
													throw new Error("unhandled state: " + t.state)
											}
										})
									}
									getOutgoingSentRoomKeyRequest(e, t) {
										return this.cryptoStore.getOutgoingRoomKeyRequestsByTarget(e, t, [a.Sent])
									}
									cancelAndResendAllOutgoingRequests() {
										return n(this, void 0, void 0, (function*() {
											const e = yield this.cryptoStore.getAllOutgoingRoomKeyRequestsByState(a.Sent);
											return Promise.all(e.map(({
												requestBody: e,
												recipients: t
											}) => this.queueRoomKeyRequest(e, t, !0)))
										}))
									}
									startTimer() {
										if (this.sendOutgoingRoomKeyRequestsTimer) return;
										this.sendOutgoingRoomKeyRequestsTimer = setTimeout(() => {
											if (this.sendOutgoingRoomKeyRequestsRunning) throw new Error("RoomKeyRequestSend already in progress!");
											this.sendOutgoingRoomKeyRequestsRunning = !0, this.sendOutgoingRoomKeyRequests().finally(() => {
												this.sendOutgoingRoomKeyRequestsRunning = !1
											}).catch(e => {
												i.logger.warn(`error in OutgoingRoomKeyRequestManager: ${e}`)
											})
										}, s)
									}
									sendOutgoingRoomKeyRequests() {
										return n(this, void 0, void 0, (function*() {
											if (!this.clientRunning) return void(this.sendOutgoingRoomKeyRequestsTimer = void 0);
											const e = yield this.cryptoStore.getOutgoingRoomKeyRequestByState([a.CancellationPending, a.CancellationPendingAndWillResend, a.Unsent]);
											if (e) try {
												switch (e.state) {
													case a.Unsent:
														yield this.sendOutgoingRoomKeyRequest(e);
														break;
													case a.CancellationPending:
														yield this.sendOutgoingRoomKeyRequestCancellation(e);
														break;
													case a.CancellationPendingAndWillResend:
														yield this.sendOutgoingRoomKeyRequestCancellation(e, !0)
												}
												return this.sendOutgoingRoomKeyRequests()
											} catch (t) {
												i.logger.error("Error sending room key request; will retry later.", t), this.sendOutgoingRoomKeyRequestsTimer = void 0
											} else this.sendOutgoingRoomKeyRequestsTimer = void 0
										}))
									}
									sendOutgoingRoomKeyRequest(e) {
										i.logger.log(`Requesting keys for ${c(e.requestBody)}` + ` from ${l(e.recipients)}` + `(id ${e.requestId})`);
										const t = {
											action: "request",
											requesting_device_id: this.deviceId,
											request_id: e.requestId,
											body: e.requestBody
										};
										return this.sendMessageToDevices(t, e.recipients, e.requestTxnId || e.requestId).then(() => this.cryptoStore.updateOutgoingRoomKeyRequest(e.requestId, a.Unsent, {
											state: a.Sent
										}))
									}
									sendOutgoingRoomKeyRequestCancellation(e, t = !1) {
										i.logger.log("Sending cancellation for key request for " + `${c(e.requestBody)} to ` + `${l(e.recipients)} ` + `(cancellation id ${e.cancellationTxnId})`);
										const r = {
											action: "request_cancellation",
											requesting_device_id: this.deviceId,
											request_id: e.requestId
										};
										return this.sendMessageToDevices(r, e.recipients, e.cancellationTxnId).then(() => t ? this.cryptoStore.updateOutgoingRoomKeyRequest(e.requestId, a.CancellationPendingAndWillResend, {
											state: a.Unsent
										}) : this.cryptoStore.deleteOutgoingRoomKeyRequest(e.requestId, a.CancellationPending))
									}
									sendMessageToDevices(e, t, r) {
										const n = {};
										for (const i of t) n[i.userId] || (n[i.userId] = {}), n[i.userId][i.deviceId] = e;
										return this.baseApis.sendToDevice(o.EventType.RoomKeyRequest, n, r)
									}
								}
							}, {
								"../@types/event": 290,
								"../logger": 356
							}],
							312: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.RoomList = void 0;
								const i = e("./store/indexeddb-crypto-store");
								r.RoomList = class {
									constructor(e) {
										this.cryptoStore = e, this.roomEncryption = {}
									}
									init() {
										return n(this, void 0, void 0, (function*() {
											yield this.cryptoStore.doTxn("readwrite", [i.IndexedDBCryptoStore.STORE_ROOMS], e => {
												this.cryptoStore.getEndToEndRooms(e, e => {
													this.roomEncryption = e
												})
											})
										}))
									}
									getRoomEncryption(e) {
										return this.roomEncryption[e] || null
									}
									isRoomEncrypted(e) {
										return Boolean(this.getRoomEncryption(e))
									}
									setRoomEncryption(e, t) {
										return n(this, void 0, void 0, (function*() {
											this.roomEncryption[e] = t, yield this.cryptoStore.doTxn("readwrite", [i.IndexedDBCryptoStore.STORE_ROOMS], r => {
												this.cryptoStore.storeEndToEndRoom(e, t, r)
											})
										}))
									}
								}
							}, {
								"./store/indexeddb-crypto-store": 329
							}],
							313: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
										Object.defineProperty(e, "default", {
											enumerable: !0,
											value: t
										})
									} : function(e, t) {
										e.default = t
									}),
									o = this && this.__importStar || function(e) {
										if (e && e.__esModule) return e;
										var t = {};
										if (null != e)
											for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
										return i(t, e), t
									},
									s = this && this.__awaiter || function(e, t, r, n) {
										return new(r || (r = Promise))((function(i, o) {
											function s(e) {
												try {
													c(n.next(e))
												} catch (t) {
													o(t)
												}
											}

											function a(e) {
												try {
													c(n.throw(e))
												} catch (t) {
													o(t)
												}
											}

											function c(e) {
												var t;
												e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
													e(t)
												}))).then(s, a)
											}
											c((n = n.apply(e, t || [])).next())
										}))
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.SecretStorage = r.SECRET_STORAGE_ALGORITHM_V1_AES = void 0;
								const a = e("../logger"),
									c = o(e("./olmlib")),
									l = e("./olmlib"),
									u = e("../randomstring"),
									d = e("./aes"),
									h = e("../client"),
									f = e("../utils");
								r.SECRET_STORAGE_ALGORITHM_V1_AES = "m.secret_storage.v1.aes-hmac-sha2";
								r.SecretStorage = class {
									constructor(e, t, r) {
										this.accountDataAdapter = e, this.cryptoCallbacks = t, this.baseApis = r, this.requests = new Map
									}
									getDefaultKeyId() {
										return s(this, void 0, void 0, (function*() {
											const e = yield this.accountDataAdapter.getAccountDataFromServer("m.secret_storage.default_key");
											return e ? e.key : null
										}))
									}
									setDefaultKeyId(e) {
										return new Promise((t, r) => {
											const n = r => {
												"m.secret_storage.default_key" === r.getType() && r.getContent().key === e && (this.accountDataAdapter.removeListener(h.ClientEvent.AccountData, n), t())
											};
											this.accountDataAdapter.on(h.ClientEvent.AccountData, n), this.accountDataAdapter.setAccountData("m.secret_storage.default_key", {
												key: e
											}).catch(e => {
												this.accountDataAdapter.removeListener(h.ClientEvent.AccountData, n), r(e)
											})
										})
									}
									addKey(e, t = {}, n) {
										return s(this, void 0, void 0, (function*() {
											const i = {
												algorithm: e
											};
											if (t.name && (i.name = t.name), e !== r.SECRET_STORAGE_ALGORITHM_V1_AES) throw new Error(`Unknown key algorithm ${e}`);
											if (t.passphrase && (i.passphrase = t.passphrase), t.key) {
												const {
													iv: e,
													mac: r
												} = yield(0, d.calculateKeyCheck)(t.key);
												i.iv = e, i.mac = r
											}
											if (!n)
												do {
													n = (0, u.randomString)(32)
												} while (yield this.accountDataAdapter.getAccountDataFromServer(`m.secret_storage.key.${n}`));
											return yield this.accountDataAdapter.setAccountData(`m.secret_storage.key.${n}`, i), {
												keyId: n,
												keyInfo: i
											}
										}))
									}
									getKey(e) {
										return s(this, void 0, void 0, (function*() {
											if (e || (e = yield this.getDefaultKeyId()), !e) return null;
											const t = yield this.accountDataAdapter.getAccountDataFromServer("m.secret_storage.key." + e);
											return t ? [e, t] : null
										}))
									}
									hasKey(e) {
										return s(this, void 0, void 0, (function*() {
											return Boolean(yield this.getKey(e))
										}))
									}
									checkKey(e, t) {
										return s(this, void 0, void 0, (function*() {
											if (t.algorithm === r.SECRET_STORAGE_ALGORITHM_V1_AES) {
												if (t.mac) {
													const {
														mac: r
													} = yield(0, d.calculateKeyCheck)(e, t.iv);
													return t.mac.replace(/=+$/g, "") === r.replace(/=+$/g, "")
												}
												return !0
											}
											throw new Error("Unknown algorithm")
										}))
									}
									store(e, t, n) {
										return s(this, void 0, void 0, (function*() {
											const i = {};
											if (!n) {
												const e = yield this.getDefaultKeyId();
												if (!e) throw new Error("No keys specified and no default key present");
												n = [e]
											}
											if (0 === n.length) throw new Error("Zero keys given to encrypt with!");
											for (const o of n) {
												const n = yield this.accountDataAdapter.getAccountDataFromServer("m.secret_storage.key." + o);
												if (!n) throw new Error("Unknown key: " + o);
												if (n.algorithm === r.SECRET_STORAGE_ALGORITHM_V1_AES) {
													const r = {
															[o]: n
														},
														[, s] = yield this.getSecretStorageKey(r, e);
													i[o] = yield s.encrypt(t)
												} else a.logger.warn("unknown algorithm for secret storage key " + o + ": " + n.algorithm)
											}
											yield this.accountDataAdapter.setAccountData(e, {
												encrypted: i
											})
										}))
									}
									get(e) {
										return s(this, void 0, void 0, (function*() {
											const t = yield this.accountDataAdapter.getAccountDataFromServer(e);
											if (!t) return;
											if (!t.encrypted) throw new Error("Content is not encrypted!");
											const n = {};
											for (const e of Object.keys(t.encrypted)) {
												const i = yield this.accountDataAdapter.getAccountDataFromServer("m.secret_storage.key." + e), o = t.encrypted[e];
												i.algorithm === r.SECRET_STORAGE_ALGORITHM_V1_AES && o.iv && o.ciphertext && o.mac && (n[e] = i)
											}
											if (0 === Object.keys(n).length) throw new Error(`Could not decrypt ${e} because none of ` + "the keys it is encrypted with are for a supported algorithm");
											let i, o;
											try {
												[i, o] = yield this.getSecretStorageKey(n, e);
												const r = t.encrypted[i];
												return r.passthrough ? (0, l.encodeBase64)(o.get_private_key()) : o.decrypt(r)
											} finally {
												o && o.free && o.free()
											}
										}))
									}
									isStored(e) {
										return s(this, void 0, void 0, (function*() {
											const t = yield this.accountDataAdapter.getAccountDataFromServer(e);
											if (!(null == t ? void 0 : t.encrypted)) return null;
											const n = {};
											for (const e of Object.keys(t.encrypted)) {
												const i = yield this.accountDataAdapter.getAccountDataFromServer("m.secret_storage.key." + e);
												if (!i) continue;
												const o = t.encrypted[e];
												i.algorithm === r.SECRET_STORAGE_ALGORITHM_V1_AES && o.iv && o.ciphertext && o.mac && (n[e] = i)
											}
											return Object.keys(n).length ? n : null
										}))
									}
									request(e, t) {
										const r = this.baseApis.makeTxnId(),
											n = (0, f.defer)();
										this.requests.set(r, {
											name: e,
											devices: t,
											deferred: n
										});
										const i = {
												name: e,
												action: "request",
												requesting_device_id: this.baseApis.deviceId,
												request_id: r
											},
											o = {};
										for (const s of t) o[s] = i;
										return a.logger.info(`Request secret ${e} from ${t}, id ${r}`), this.baseApis.sendToDevice("m.secret.request", {
											[this.baseApis.getUserId()]: o
										}), {
											requestId: r,
											promise: n.promise,
											cancel: e => {
												const i = {
														action: "request_cancellation",
														requesting_device_id: this.baseApis.deviceId,
														request_id: r
													},
													o = {};
												for (const r of t) o[r] = i;
												this.baseApis.sendToDevice("m.secret.request", {
													[this.baseApis.getUserId()]: o
												}), n.reject(new Error(e || "Cancelled"))
											}
										}
									}
									onRequestReceived(e) {
										return s(this, void 0, void 0, (function*() {
											const t = e.getSender(),
												r = e.getContent();
											if (t !== this.baseApis.getUserId() || !(r.name && r.action && r.requesting_device_id && r.request_id)) return;
											const n = r.requesting_device_id;
											if ("request_cancellation" === r.action);
											else if ("request" === r.action) {
												if (n === this.baseApis.deviceId) return;
												if (a.logger.info("received request for secret (" + t + ", " + n + ", " + r.request_id + ")"), !this.cryptoCallbacks.onSecretRequested) return;
												const e = yield this.cryptoCallbacks.onSecretRequested(t, n, r.request_id, r.name, this.baseApis.checkDeviceTrust(t, n));
												if (e) {
													a.logger.info(`Preparing ${r.name} secret for ${n}`);
													const i = {
															type: "m.secret.send",
															content: {
																request_id: r.request_id,
																secret: e
															}
														},
														o = {
															algorithm: c.OLM_ALGORITHM,
															sender_key: this.baseApis.crypto.olmDevice.deviceCurve25519Key,
															ciphertext: {}
														};
													yield c.ensureOlmSessionsForDevices(this.baseApis.crypto.olmDevice, this.baseApis, {
														[t]: [this.baseApis.getStoredDevice(t, n)]
													}), yield c.encryptMessageForDevice(o.ciphertext, this.baseApis.getUserId(), this.baseApis.deviceId, this.baseApis.crypto.olmDevice, t, this.baseApis.getStoredDevice(t, n), i);
													const s = {
														[t]: {
															[n]: o
														}
													};
													a.logger.info(`Sending ${r.name} secret for ${n}`), this.baseApis.sendToDevice("m.room.encrypted", s)
												} else a.logger.info(`Request denied for ${r.name} secret for ${n}`)
											}
										}))
									}
									onSecretReceived(e) {
										if (e.getSender() !== this.baseApis.getUserId()) return;
										if (!c.isOlmEncrypted(e)) return void a.logger.error("secret event not properly encrypted");
										const t = e.getContent();
										if (this.baseApis.crypto.deviceList.getUserByIdentityKey(c.OLM_ALGORITHM, e.getSenderKey() || "") !== e.getSender()) return void a.logger.error("sending device does not belong to the user it claims to be from");
										a.logger.log("got secret share for request", t.request_id);
										const r = this.requests.get(t.request_id);
										if (r) {
											const n = this.baseApis.crypto.deviceList.getDeviceByIdentityKey(c.OLM_ALGORITHM, e.getSenderKey());
											if (!n) return void a.logger.log("secret share from unknown device with key", e.getSenderKey());
											if (!r.devices.includes(n.deviceId)) return void a.logger.log("unsolicited secret share from device", n.deviceId);
											if (!this.baseApis.crypto.checkDeviceInfoTrust(e.getSender(), n).isVerified()) return void a.logger.log("secret share from unverified device");
											a.logger.log(`Successfully received secret ${r.name} ` + `from ${n.deviceId}`), r.deferred.resolve(t.secret)
										}
									}
									getSecretStorageKey(e, t) {
										return s(this, void 0, void 0, (function*() {
											if (!this.cryptoCallbacks.getSecretStorageKey) throw new Error("No getSecretStorageKey callback supplied");
											const n = yield this.cryptoCallbacks.getSecretStorageKey({
												keys: e
											}, t);
											if (!n) throw new Error("getSecretStorageKey callback returned falsey");
											if (n.length < 2) throw new Error("getSecretStorageKey callback returned invalid data");
											const [i, o] = n;
											if (!e[i]) throw new Error("App returned unknown key from getSecretStorageKey!");
											if (e[i].algorithm === r.SECRET_STORAGE_ALGORITHM_V1_AES) {
												return [i, {
													encrypt: function(e) {
														return (0, d.encryptAES)(e, o, t)
													},
													decrypt: function(e) {
														return (0, d.decryptAES)(e, o, t)
													}
												}]
											}
											throw new Error("Unknown key type: " + e[i].algorithm)
										}))
									}
								}
							}, {
								"../client": 304,
								"../logger": 356,
								"../randomstring": 379,
								"../utils": 393,
								"./aes": 314,
								"./olmlib": 326
							}],
							314: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.calculateKeyCheck = r.decryptAES = r.encryptAES = void 0;
								const i = e("./olmlib"),
									o = e("./crypto"),
									s = new Uint8Array(8);

								function a(e, t, r, s) {
									return n(this, void 0, void 0, (function*() {
										let n;
										s ? n = (0, i.decodeBase64)(s) : (n = new Uint8Array(16), o.crypto.getRandomValues(n), n[8] &= 127);
										const [a, l] = yield c(t, r), u = (new o.TextEncoder).encode(e), d = yield o.subtleCrypto.encrypt({
											name: "AES-CTR",
											counter: n,
											length: 64
										}, a, u), h = yield o.subtleCrypto.sign({
											name: "HMAC"
										}, l, d);
										return {
											iv: (0, i.encodeBase64)(n),
											ciphertext: (0, i.encodeBase64)(d),
											mac: (0, i.encodeBase64)(h)
										}
									}))
								}

								function c(e, t) {
									return n(this, void 0, void 0, (function*() {
										const r = yield o.subtleCrypto.importKey("raw", e, {
											name: "HKDF"
										}, !1, ["deriveBits"]), n = yield o.subtleCrypto.deriveBits({
											name: "HKDF",
											salt: s,
											info: (new o.TextEncoder).encode(t),
											hash: "SHA-256"
										}, r, 512), i = n.slice(0, 32), a = n.slice(32), c = o.subtleCrypto.importKey("raw", i, {
											name: "AES-CTR"
										}, !1, ["encrypt", "decrypt"]), l = o.subtleCrypto.importKey("raw", a, {
											name: "HMAC",
											hash: {
												name: "SHA-256"
											}
										}, !1, ["sign", "verify"]);
										return Promise.all([c, l])
									}))
								}
								r.encryptAES = a, r.decryptAES = function(e, t, r) {
									return n(this, void 0, void 0, (function*() {
										const [n, s] = yield c(t, r), a = (0, i.decodeBase64)(e.ciphertext);
										if (!(yield o.subtleCrypto.verify({
												name: "HMAC"
											}, s, (0, i.decodeBase64)(e.mac), a))) throw new Error(`Error decrypting secret ${r}: bad MAC`);
										const l = yield o.subtleCrypto.decrypt({
											name: "AES-CTR",
											counter: (0, i.decodeBase64)(e.iv),
											length: 64
										}, n, a);
										return (new TextDecoder).decode(new Uint8Array(l))
									}))
								};
								const l = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
								r.calculateKeyCheck = function(e, t) {
									return a(l, e, "", t)
								}
							}, {
								"./crypto": 321,
								"./olmlib": 326
							}],
							315: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.registerAlgorithm = r.UnknownDeviceError = r.DecryptionError = r.DecryptionAlgorithm = r.EncryptionAlgorithm = r.DECRYPTION_CLASSES = r.ENCRYPTION_CLASSES = void 0, r.ENCRYPTION_CLASSES = new Map, r.DECRYPTION_CLASSES = new Map;
								r.EncryptionAlgorithm = class {
									constructor(e) {
										this.userId = e.userId, this.deviceId = e.deviceId, this.crypto = e.crypto, this.olmDevice = e.olmDevice, this.baseApis = e.baseApis, this.roomId = e.roomId
									}
									prepareToEncrypt(e) {}
									onRoomMembership(e, t, r) {}
								};
								r.DecryptionAlgorithm = class {
									constructor(e) {
										this.userId = e.userId, this.crypto = e.crypto, this.olmDevice = e.olmDevice, this.baseApis = e.baseApis, this.roomId = e.roomId
									}
									onRoomKeyEvent(e) {
										return n(this, void 0, void 0, (function*() {}))
									}
									importRoomKey(e, t) {
										return n(this, void 0, void 0, (function*() {}))
									}
									hasKeysForKeyRequest(e) {
										return Promise.resolve(!1)
									}
									shareKeysWithDevice(e) {
										throw new Error("shareKeysWithDevice not supported for this DecryptionAlgorithm")
									}
									retryDecryptionFromSender(e) {
										return n(this, void 0, void 0, (function*() {
											return !1
										}))
									}
								};
								class DecryptionError extends Error {
									constructor(e, t, r) {
										super(t), this.code = e, this.code = e, this.name = "DecryptionError", this.detailedString = function(e, t) {
											let r = e.name + "[msg: " + e.message;
											t && (r += ", " + Object.keys(t).map(e => e + ": " + t[e]).join(", "));
											return r += "]"
										}(this, r)
									}
								}
								r.DecryptionError = DecryptionError;
								class UnknownDeviceError extends Error {
									constructor(e, t, r) {
										super(e), this.devices = t, this.event = r, this.name = "UnknownDeviceError", this.devices = t
									}
								}
								r.UnknownDeviceError = UnknownDeviceError, r.registerAlgorithm = function(e, t, n) {
									r.ENCRYPTION_CLASSES.set(e, t), r.DECRYPTION_CLASSES.set(e, n)
								}
							}, {}],
							316: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__exportStar || function(e, t) {
										for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), e("./olm"), e("./megolm"), i(e("./base"), r)
							}, {
								"./base": 315,
								"./megolm": 317,
								"./olm": 318
							}],
							317: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
										Object.defineProperty(e, "default", {
											enumerable: !0,
											value: t
										})
									} : function(e, t) {
										e.default = t
									}),
									o = this && this.__importStar || function(e) {
										if (e && e.__esModule) return e;
										var t = {};
										if (null != e)
											for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
										return i(t, e), t
									},
									s = this && this.__awaiter || function(e, t, r, n) {
										return new(r || (r = Promise))((function(i, o) {
											function s(e) {
												try {
													c(n.next(e))
												} catch (t) {
													o(t)
												}
											}

											function a(e) {
												try {
													c(n.throw(e))
												} catch (t) {
													o(t)
												}
											}

											function c(e) {
												var t;
												e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
													e(t)
												}))).then(s, a)
											}
											c((n = n.apply(e, t || [])).next())
										}))
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.isRoomSharedHistory = void 0;
								const a = e("../../logger"),
									c = o(e("../olmlib")),
									l = e("./base"),
									u = e("../OlmDevice"),
									d = e("../../@types/event"),
									h = e("../OutgoingRoomKeyRequestManager");

								function f(e) {
									var t, r;
									const n = null === (t = null == e ? void 0 : e.currentState) || void 0 === t ? void 0 : t.getStateEvents("m.room.history_visibility", ""),
										i = null === (r = null == n ? void 0 : n.getContent()) || void 0 === r ? void 0 : r.history_visibility;
									return ["world_readable", "shared"].includes(i)
								}
								r.isRoomSharedHistory = f;
								class p {
									constructor(e, t = !1) {
										this.sessionId = e, this.sharedHistory = t, this.useCount = 0, this.sharedWithDevices = {}, this.blockedDevicesNotified = {}, this.creationTime = (new Date).getTime()
									}
									needsRotation(e, t) {
										const r = (new Date).getTime() - this.creationTime;
										return (this.useCount >= e || r >= t) && (a.logger.log("Rotating megolm session after " + this.useCount + " messages, " + r + "ms"), !0)
									}
									markSharedWithDevice(e, t, r, n) {
										this.sharedWithDevices[e] || (this.sharedWithDevices[e] = {}), this.sharedWithDevices[e][t] = {
											deviceKey: r,
											messageIndex: n
										}
									}
									markNotifiedBlockedDevice(e, t) {
										this.blockedDevicesNotified[e] || (this.blockedDevicesNotified[e] = {}), this.blockedDevicesNotified[e][t] = !0
									}
									sharedWithTooManyDevices(e) {
										for (const t in this.sharedWithDevices)
											if (this.sharedWithDevices.hasOwnProperty(t)) {
												if (!e.hasOwnProperty(t)) return a.logger.log("Starting new megolm session because we shared with " + t), !0;
												for (const r in this.sharedWithDevices[t])
													if (this.sharedWithDevices[t].hasOwnProperty(r) && !e[t].hasOwnProperty(r)) return a.logger.log("Starting new megolm session because we shared with " + t + ":" + r), !0
											} return !1
									}
								}
								class v extends l.EncryptionAlgorithm {
									constructor(e) {
										var t, r, n, i;
										super(e), this.setupPromise = Promise.resolve(null), this.outboundSessions = {}, this.roomId = e.roomId, this.sessionRotationPeriodMsgs = null !== (r = null === (t = e.config) || void 0 === t ? void 0 : t.rotation_period_msgs) && void 0 !== r ? r : 100, this.sessionRotationPeriodMs = null !== (i = null === (n = e.config) || void 0 === n ? void 0 : n.rotation_period_ms) && void 0 !== i ? i : 6048e5
									}
									ensureOutboundSession(e, t, r, n = !1) {
										return s(this, void 0, void 0, (function*() {
											const i = this.setupPromise.then(i => s(this, void 0, void 0, (function*() {
												const o = f(e),
													s = yield this.prepareSession(t, o, i);
												try {
													yield this.shareSession(t, o, n, r, s)
												} catch (c) {
													a.logger.error(`Failed to ensure outbound session in ${this.roomId}`, c)
												}
												return s
											})));
											return i.catch(e => {
												a.logger.error(`Failed to setup outbound session in ${this.roomId}`, e)
											}), this.setupPromise = i, i
										}))
									}
									prepareSession(e, t, r) {
										return s(this, void 0, void 0, (function*() {
											return r && t !== r.sharedHistory && (r = null), (null == r ? void 0 : r.needsRotation(this.sessionRotationPeriodMsgs, this.sessionRotationPeriodMs)) && (a.logger.log("Starting new megolm session because we need to rotate."), r = null), (null == r ? void 0 : r.sharedWithTooManyDevices(e)) && (r = null), r || (a.logger.log(`Starting new megolm session for room ${this.roomId}`), r = yield this.prepareNewSession(t), a.logger.log(`Started new megolm session ${r.sessionId} ` + `for room ${this.roomId}`), this.outboundSessions[r.sessionId] = r), r
										}))
									}
									shareSession(e, t, r, n, i) {
										return s(this, void 0, void 0, (function*() {
											const o = {};
											for (const [t, r] of Object.entries(e))
												for (const [e, n] of Object.entries(r)) {
													n.getIdentityKey() != this.olmDevice.deviceCurve25519Key && (i.sharedWithDevices[t] && void 0 !== i.sharedWithDevices[t][e] || (o[t] = o[t] || [], o[t].push(n)))
												}
											const l = this.olmDevice.getOutboundGroupSessionKey(i.sessionId),
												u = {
													type: "m.room_key",
													content: {
														algorithm: c.MEGOLM_ALGORITHM,
														room_id: this.roomId,
														session_id: i.sessionId,
														session_key: l.key,
														chain_index: l.chain_index,
														"org.matrix.msc3061.shared_history": t
													}
												},
												[d, h] = yield c.getExistingOlmSessions(this.olmDevice, this.baseApis, o);
											yield Promise.all([(() => s(this, void 0, void 0, (function*() {
												a.logger.debug(`Sharing keys with existing Olm sessions in ${this.roomId}`, h), yield this.shareKeyWithOlmSessions(i, l, u, h), a.logger.debug(`Shared keys with existing Olm sessions in ${this.roomId}`)
											})))(), (() => s(this, void 0, void 0, (function*() {
												a.logger.debug(`Sharing keys (start phase 1) with new Olm sessions in ${this.roomId}`, d);
												const e = [],
													t = Date.now(),
													n = [];
												yield this.shareKeyWithDevices(i, l, u, d, e, r ? 1e4 : 2e3, n), a.logger.debug(`Shared keys (end phase 1) with new Olm sessions in ${this.roomId}`), !r && Date.now() - t < 1e4 ? (() => s(this, void 0, void 0, (function*() {
													const t = {},
														r = new Set;
													for (const e of n) r.add(e);
													const o = [];
													for (const {
															userId: n,
															deviceInfo: i
														} of e) {
														const e = n.slice(n.indexOf(":") + 1);
														r.has(e) ? (t[n] = t[n] || [], t[n].push(i)) : o.push({
															userId: n,
															deviceInfo: i
														})
													}
													a.logger.debug(`Sharing keys (start phase 2) with new Olm sessions in ${this.roomId}`), yield this.shareKeyWithDevices(i, l, u, t, o, 3e4), a.logger.debug(`Shared keys (end phase 2) with new Olm sessions in ${this.roomId}`), yield this.notifyFailedOlmDevices(i, l, o)
												})))() : yield this.notifyFailedOlmDevices(i, l, e), a.logger.debug(`Shared keys (all phases done) with new Olm sessions in ${this.roomId}`)
											})))(), (() => s(this, void 0, void 0, (function*() {
												a.logger.debug(`There are ${Object.entries(n).length} blocked devices in ${this.roomId}`, Object.entries(n)), a.logger.debug(`Notifying newly blocked devices in ${this.roomId}`);
												const e = {};
												let t = 0;
												for (const [r, o] of Object.entries(n))
													for (const [n, s] of Object.entries(o)) i.blockedDevicesNotified[r] && void 0 !== i.blockedDevicesNotified[r][n] || (e[r] = e[r] || {}, e[r][n] = {
														device: s
													}, t++);
												yield this.notifyBlockedDevices(i, e), a.logger.debug(`Notified ${t} newly blocked devices in ${this.roomId}`, e)
											})))()])
										}))
									}
									prepareNewSession(e) {
										return s(this, void 0, void 0, (function*() {
											const t = this.olmDevice.createOutboundGroupSession(),
												r = this.olmDevice.getOutboundGroupSessionKey(t);
											return yield this.olmDevice.addInboundGroupSession(this.roomId, this.olmDevice.deviceCurve25519Key, [], t, r.key, {
												ed25519: this.olmDevice.deviceEd25519Key
											}, !1, {
												sharedHistory: e
											}), this.crypto.backupManager.backupGroupSession(this.olmDevice.deviceCurve25519Key, t), new p(t, e)
										}))
									}
									getDevicesWithoutSessions(e, t, r = []) {
										for (const [n, i] of Object.entries(t)) {
											const t = e[n];
											for (const e of i) {
												const i = e.deviceId;
												t[i].sessionId || (r.push({
													userId: n,
													deviceInfo: e
												}), delete t[i])
											}
										}
										return r
									}
									splitDevices(e) {
										let t = [];
										const r = [t];
										for (const [n, i] of Object.entries(e)) {
											for (const e of Object.values(i)) t.push({
												userId: n,
												deviceInfo: e.device
											});
											t.length > 20 && (t = [], r.push(t))
										}
										return 0 === t.length && r.pop(), r
									}
									encryptAndSendKeysToDevices(e, t, r, n) {
										return this.crypto.encryptAndSendToDevices(r, n).then(() => {
											for (const n of r) e.markSharedWithDevice(n.userId, n.deviceInfo.deviceId, n.deviceInfo.getIdentityKey(), t)
										}).catch(e => {
											throw a.logger.error("failed to encryptAndSendToDevices", e), e
										})
									}
									sendBlockedNotificationsToDevices(e, t, r) {
										return s(this, void 0, void 0, (function*() {
											const n = {};
											for (const e of t) {
												const t = e.userId,
													i = e.deviceInfo,
													o = i.deviceInfo.deviceId,
													s = Object.assign({}, r);
												s.code = i.code, s.reason = i.reason, "m.no_olm" === s.code && (delete s.room_id, delete s.session_id), n[t] || (n[t] = {}), n[t][o] = s
											}
											yield this.baseApis.sendToDevice("m.room_key.withheld", n);
											for (const t of Object.keys(n))
												for (const r of Object.keys(n[t])) e.markNotifiedBlockedDevice(t, r)
										}))
									}
									reshareKeyWithDevice(e, t, r, n) {
										return s(this, void 0, void 0, (function*() {
											const i = this.outboundSessions[t];
											if (!i) return void a.logger.debug(`megolm session ${t} not found: not re-sharing keys`);
											if (void 0 === i.sharedWithDevices[r]) return void a.logger.debug(`megolm session ${t} never shared with user ${r}`);
											const o = i.sharedWithDevices[r][n.deviceId];
											if (void 0 === o) return void a.logger.debug("megolm session ID " + t + " never shared with device " + r + ":" + n.deviceId);
											if (o.deviceKey !== n.getIdentityKey()) return void a.logger.warn(`Session has been shared with device ${n.deviceId} but with identity ` + `key ${o.deviceKey}. Key is now ${n.getIdentityKey()}!`);
											const s = yield this.olmDevice.getInboundGroupSessionKey(this.roomId, e, t, o.messageIndex);
											if (!s) return void a.logger.warn(`No inbound session key found for megolm ${t}: not re-sharing keys`);
											yield c.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, {
												[r]: [n]
											});
											const l = {
													type: "m.forwarded_room_key",
													content: {
														algorithm: c.MEGOLM_ALGORITHM,
														room_id: this.roomId,
														session_id: t,
														session_key: s.key,
														chain_index: s.chain_index,
														sender_key: e,
														sender_claimed_ed25519_key: s.sender_claimed_ed25519_key,
														forwarding_curve25519_key_chain: s.forwarding_curve25519_key_chain,
														"org.matrix.msc3061.shared_history": s.shared_history || !1
													}
												},
												u = {
													algorithm: c.OLM_ALGORITHM,
													sender_key: this.olmDevice.deviceCurve25519Key,
													ciphertext: {}
												};
											yield c.encryptMessageForDevice(u.ciphertext, this.userId, this.deviceId, this.olmDevice, r, n, l), yield this.baseApis.sendToDevice("m.room.encrypted", {
												[r]: {
													[n.deviceId]: u
												}
											}), a.logger.debug(`Re-shared key for megolm session ${t} with ${r}:${n.deviceId}`)
										}))
									}
									shareKeyWithDevices(e, t, r, n, i, o, l) {
										var u;
										return s(this, void 0, void 0, (function*() {
											a.logger.debug(`Ensuring Olm sessions for devices in ${this.roomId}`);
											const s = yield c.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, n, !1, o, l, null === (u = a.logger.withPrefix) || void 0 === u ? void 0 : u.call(a.logger, `[${this.roomId}]`));
											a.logger.debug(`Ensured Olm sessions for devices in ${this.roomId}`), this.getDevicesWithoutSessions(s, n, i), a.logger.debug(`Sharing keys with newly created Olm sessions in ${this.roomId}`), yield this.shareKeyWithOlmSessions(e, t, r, s), a.logger.debug(`Shared keys with newly created Olm sessions in ${this.roomId}`)
										}))
									}
									shareKeyWithOlmSessions(e, t, r, n) {
										return s(this, void 0, void 0, (function*() {
											const i = this.splitDevices(n);
											for (let n = 0; n < i.length; n++) {
												const s = `megolm keys for ${e.sessionId} ` + `in ${this.roomId} (slice ${n+1}/${i.length})`;
												try {
													a.logger.debug(`Sharing ${s}`, i[n].map(e => `${e.userId}/${e.deviceInfo.deviceId}`)), yield this.encryptAndSendKeysToDevices(e, t.chain_index, i[n], r), a.logger.debug(`Shared ${s}`)
												} catch (o) {
													throw a.logger.error(`Failed to share ${s}`), o
												}
											}
										}))
									}
									notifyFailedOlmDevices(e, t, r) {
										return s(this, void 0, void 0, (function*() {
											a.logger.debug(`Notifying ${r.length} devices we failed to ` + `create Olm sessions in ${this.roomId}`);
											for (const {
													userId: o,
													deviceInfo: s
												} of r) {
												const r = s.deviceId;
												e.markSharedWithDevice(o, r, s.getIdentityKey(), t.chain_index)
											}
											const n = yield this.olmDevice.filterOutNotifiedErrorDevices(r);
											a.logger.debug(`Need to notify ${n.length} failed devices ` + `which haven't been notified before in ${this.roomId}`);
											const i = {};
											for (const {
													userId: e,
													deviceInfo: t
												} of n) i[e] = i[e] || {}, i[e][t.deviceId] = {
												device: {
													code: "m.no_olm",
													reason: u.WITHHELD_MESSAGES["m.no_olm"],
													deviceInfo: t
												}
											};
											yield this.notifyBlockedDevices(e, i), a.logger.debug(`Notified ${n.length} devices we failed to ` + `create Olm sessions in ${this.roomId}`)
										}))
									}
									notifyBlockedDevices(e, t) {
										return s(this, void 0, void 0, (function*() {
											const r = {
													room_id: this.roomId,
													session_id: e.sessionId,
													algorithm: c.MEGOLM_ALGORITHM,
													sender_key: this.olmDevice.deviceCurve25519Key
												},
												n = this.splitDevices(t);
											for (let t = 0; t < n.length; t++) try {
												yield this.sendBlockedNotificationsToDevices(e, n[t], r), a.logger.log(`Completed blacklist notification for ${e.sessionId} ` + `in ${this.roomId} (slice ${t+1}/${n.length})`)
											} catch (i) {
												throw a.logger.log(`blacklist notification for ${e.sessionId} in ` + `${this.roomId} (slice ${t+1}/${n.length}) failed`), i
											}
										}))
									}
									prepareToEncrypt(e) {
										if (null == this.encryptionPreparation) a.logger.debug(`Preparing to encrypt events for ${this.roomId}`), this.encryptionPreparation = {
											startTime: Date.now(),
											promise: (() => s(this, void 0, void 0, (function*() {
												try {
													a.logger.debug(`Getting devices in ${this.roomId}`);
													const [t, r] = yield this.getDevicesInRoom(e);
													this.crypto.globalErrorOnUnknownDevices && this.removeUnknownDevices(t), a.logger.debug(`Ensuring outbound session in ${this.roomId}`), yield this.ensureOutboundSession(e, t, r, !0), a.logger.debug(`Ready to encrypt events for ${this.roomId}`)
												} catch (t) {
													a.logger.error(`Failed to prepare to encrypt events for ${this.roomId}`, t)
												} finally {
													delete this.encryptionPreparation
												}
											})))()
										};
										else {
											const e = Date.now() - this.encryptionPreparation.startTime;
											a.logger.debug(`Already started preparing to encrypt for ${this.roomId} ` + `${e} ms ago, skipping`)
										}
									}
									encryptMessage(e, t, r) {
										return s(this, void 0, void 0, (function*() {
											if (a.logger.log(`Starting to encrypt event for ${this.roomId}`), null != this.encryptionPreparation) try {
												yield this.encryptionPreparation.promise
											} catch (h) {}
											const n = this.isVerificationEvent(t, r),
												[i, o] = yield this.getDevicesInRoom(e, n);
											this.crypto.globalErrorOnUnknownDevices && this.checkForUnknownDevices(i);
											const s = yield this.ensureOutboundSession(e, i, o), l = {
												room_id: this.roomId,
												type: t,
												content: r
											}, u = this.olmDevice.encryptGroupMessage(s.sessionId, JSON.stringify(l)), d = {
												algorithm: c.MEGOLM_ALGORITHM,
												sender_key: this.olmDevice.deviceCurve25519Key,
												ciphertext: u,
												session_id: s.sessionId,
												device_id: this.deviceId
											};
											return s.useCount++, d
										}))
									}
									isVerificationEvent(e, t) {
										switch (e) {
											case d.EventType.KeyVerificationCancel:
											case d.EventType.KeyVerificationDone:
											case d.EventType.KeyVerificationMac:
											case d.EventType.KeyVerificationStart:
											case d.EventType.KeyVerificationKey:
											case d.EventType.KeyVerificationReady:
											case d.EventType.KeyVerificationAccept:
												return !0;
											case d.EventType.RoomMessage:
												return t.msgtype === d.MsgType.KeyVerificationRequest;
											default:
												return !1
										}
									}
									forceDiscardSession() {
										this.setupPromise = this.setupPromise.then(() => null)
									}
									checkForUnknownDevices(e) {
										const t = {};
										if (Object.keys(e).forEach(r => {
												Object.keys(e[r]).forEach(n => {
													const i = e[r][n];
													i.isUnverified() && !i.isKnown() && (t[r] || (t[r] = {}), t[r][n] = i)
												})
											}), Object.keys(t).length) throw new l.UnknownDeviceError("This room contains unknown devices which have not been verified. We strongly recommend you verify them before continuing.", t)
									}
									removeUnknownDevices(e) {
										for (const [t, r] of Object.entries(e)) {
											for (const [e, t] of Object.entries(r)) t.isUnverified() && !t.isKnown() && delete r[e];
											0 === Object.keys(r).length && delete e[t]
										}
									}
									getDevicesInRoom(e, t = !1) {
										return s(this, void 0, void 0, (function*() {
											const r = (yield e.getEncryptionTargetMembers()).map((function(e) {
												return e.userId
											}));
											let n = this.crypto.globalBlacklistUnverifiedDevices;
											const i = e.getBlacklistUnverifiedDevices();
											"boolean" == typeof i && (n = i);
											const o = yield this.crypto.downloadKeys(r, !1), s = {};
											for (const e in o) {
												if (!o.hasOwnProperty(e)) continue;
												const r = o[e];
												for (const i in r) {
													if (!r.hasOwnProperty(i)) continue;
													const o = this.crypto.checkDeviceTrust(e, i);
													if (r[i].isBlocked() || !o.isVerified() && n && !t) {
														s[e] || (s[e] = {});
														const t = r[i].isBlocked();
														s[e][i] = {
															code: t ? "m.blacklisted" : "m.unverified",
															reason: u.WITHHELD_MESSAGES[t ? "m.blacklisted" : "m.unverified"],
															deviceInfo: r[i]
														}, delete r[i]
													}
												}
											}
											return [o, s]
										}))
									}
								}
								class g extends l.DecryptionAlgorithm {
									constructor(e) {
										super(e), this.pendingEvents = new Map, this.olmlib = c, this.roomId = e.roomId
									}
									decryptEvent(e) {
										return s(this, void 0, void 0, (function*() {
											const t = e.getWireContent();
											if (!t.sender_key || !t.session_id || !t.ciphertext) throw new l.DecryptionError("MEGOLM_MISSING_FIELDS", "Missing fields in input");
											let r;
											this.addEventToPendingList(e);
											try {
												r = yield this.olmDevice.decryptGroupMessage(e.getRoomId(), t.sender_key, t.session_id, t.ciphertext, e.getId(), e.getTs())
											} catch (i) {
												if ("DecryptionError" === i.name) throw i;
												let r = "OLM_DECRYPT_GROUP_MESSAGE_ERROR";
												throw "OLM.UNKNOWN_MESSAGE_INDEX" === (null == i ? void 0 : i.message) && (this.requestKeysForEvent(e), r = "OLM_UNKNOWN_MESSAGE_INDEX"), new l.DecryptionError(r, i ? i.toString() : "Unknown Error: Error is undefined", {
													session: t.sender_key + "|" + t.session_id
												})
											}
											if (null === r) {
												this.crypto.backupManager.queryKeyBackupRateLimited(e.getRoomId(), t.session_id).catch(() => {}), this.requestKeysForEvent(e);
												const r = yield this.olmDevice.sessionMayHaveProblems(t.sender_key, e.getTs() - 12e4);
												if (r) {
													let e = m[r.type] || m.unknown;
													throw r.fixed && (e += " Trying to create a new secure channel and re-requesting the keys."), new l.DecryptionError("MEGOLM_UNKNOWN_INBOUND_SESSION_ID", e, {
														session: t.sender_key + "|" + t.session_id
													})
												}
												throw new l.DecryptionError("MEGOLM_UNKNOWN_INBOUND_SESSION_ID", "The sender's device has not sent us the keys for this message.", {
													session: t.sender_key + "|" + t.session_id
												})
											}
											r.untrusted || this.removeEventFromPendingList(e);
											const n = JSON.parse(r.result);
											if (n.room_id !== e.getRoomId()) throw new l.DecryptionError("MEGOLM_BAD_ROOM", "Message intended for room " + n.room_id);
											return {
												clearEvent: n,
												senderCurve25519Key: r.senderKey,
												claimedEd25519Key: r.keysClaimed.ed25519,
												forwardingCurve25519KeyChain: r.forwardingCurve25519KeyChain,
												untrusted: r.untrusted
											}
										}))
									}
									requestKeysForEvent(e) {
										const t = e.getWireContent(),
											r = e.getKeyRequestRecipients(this.userId);
										this.crypto.requestRoomKey({
											room_id: e.getRoomId(),
											algorithm: t.algorithm,
											sender_key: t.sender_key,
											session_id: t.session_id
										}, r)
									}
									addEventToPendingList(e) {
										var t;
										const r = e.getWireContent(),
											n = r.sender_key,
											i = r.session_id;
										this.pendingEvents.has(n) || this.pendingEvents.set(n, new Map);
										const o = this.pendingEvents.get(n);
										o.has(i) || o.set(i, new Set), null === (t = o.get(i)) || void 0 === t || t.add(e)
									}
									removeEventFromPendingList(e) {
										const t = e.getWireContent(),
											r = t.sender_key,
											n = t.session_id,
											i = this.pendingEvents.get(r),
											o = null == i ? void 0 : i.get(n);
										o && (o.delete(e), 0 === o.size && i.delete(n), 0 === i.size && this.pendingEvents.delete(r))
									}
									onRoomKeyEvent(e) {
										var t, r, n, i;
										return s(this, void 0, void 0, (function*() {
											const o = e.getContent();
											let s, l = e.getSenderKey(),
												u = [],
												d = !1;
											const f = {};
											if (o.room_id && o.session_key && o.session_id && o.algorithm)
												if (c.isOlmEncrypted(e)) {
													if (o["org.matrix.msc3061.shared_history"] && (f.sharedHistory = !0), "m.forwarded_room_key" == e.getType()) {
														const p = this.crypto.deviceList.getDeviceByIdentityKey(c.OLM_ALGORITHM, l);
														if (this.baseApis.crypto.deviceList.getUserByIdentityKey(c.OLM_ALGORITHM, l) !== e.getSender()) return void a.logger.error("sending device does not belong to the user it claims to be from");
														const v = (p ? yield this.crypto.cryptoStore.getOutgoingRoomKeyRequestsByTarget(e.getSender(), p.deviceId, [h.RoomKeyRequestState.Sent]): []).some(e => e.requestBody.room_id === o.room_id && e.requestBody.session_id === o.session_id),
															g = this.baseApis.getRoom(o.room_id),
															m = null === (t = null == g ? void 0 : g.getMember(this.userId)) || void 0 === t ? void 0 : t.events.member,
															y = (null == m ? void 0 : m.getSender()) === e.getSender() || (null === (r = null == m ? void 0 : m.getUnsigned()) || void 0 === r ? void 0 : r.prev_sender) === e.getSender() && "invite" === (null === (n = null == m ? void 0 : m.getPrevContent()) || void 0 === n ? void 0 : n.membership),
															b = e.getSender() === this.baseApis.getUserId();
														if (!v && !b) {
															if (!f.sharedHistory) return void a.logger.log("forwarded key not shared history - ignoring");
															if (g && !y) return void a.logger.log("forwarded key not from inviter or from us - ignoring")
														}
														if (d = !0, (u = (u = Array.isArray(o.forwarding_curve25519_key_chain) ? o.forwarding_curve25519_key_chain : []).slice()).push(l), !o.sender_key) return void a.logger.error("forwarded_room_key event is missing sender_key field");
														const _ = o.sender_claimed_ed25519_key;
														if (!_) return void a.logger.error("forwarded_room_key_event is missing sender_claimed_ed25519_key field");
														if (s = {
																ed25519: _
															}, !g) {
															const t = {
																senderId: e.getSender(),
																senderKey: o.sender_key,
																sessionId: o.session_id,
																sessionKey: o.session_key,
																keysClaimed: s,
																forwardingCurve25519KeyChain: u
															};
															return void(yield this.crypto.cryptoStore.doTxn("readwrite", ["parked_shared_history"], e => this.crypto.cryptoStore.addParkedSharedHistory(o.room_id, t, e), a.logger.withPrefix("[addParkedSharedHistory]")))
														}
														const w = null !== (i = this.crypto.deviceList.getDeviceByIdentityKey(c.OLM_ALGORITHM, l)) && void 0 !== i ? i : void 0,
															S = this.crypto.checkDeviceInfoTrust(e.getSender(), w);
														if (b && !S.isVerified()) return;
														f.untrusted = !0, l = o.sender_key
													} else s = e.getKeysClaimed();
													o["org.matrix.msc3061.shared_history"] && (f.sharedHistory = !0);
													try {
														yield this.olmDevice.addInboundGroupSession(o.room_id, l, u, o.session_id, o.session_key, s, d, f), (yield this.retryDecryption(l, o.session_id, !f.untrusted)) && this.crypto.cancelRoomKeyRequest({
															algorithm: o.algorithm,
															room_id: o.room_id,
															session_id: o.session_id,
															sender_key: l
														}), yield this.crypto.backupManager.backupGroupSession(l, o.session_id)
													} catch (p) {
														a.logger.error(`Error handling m.room_key_event: ${p}`)
													}
												} else a.logger.error("key event not properly encrypted");
											else a.logger.error("key event is missing fields")
										}))
									}
									onRoomKeyWithheldEvent(e) {
										return s(this, void 0, void 0, (function*() {
											const t = e.getContent(),
												r = t.sender_key;
											if ("m.no_olm" === t.code) {
												const n = e.getSender();
												if (a.logger.warn(`${n}:${r} was unable to establish an olm session with us`), yield this.olmDevice.getSessionIdForDevice(r)) return a.logger.debug("New session already created.  Not creating a new one."), yield this.olmDevice.recordSessionProblem(r, "no_olm", !0), void this.retryDecryptionFromSender(r);
												let i = this.crypto.deviceList.getDeviceByIdentityKey(t.algorithm, r);
												if (!(i || (yield this.crypto.downloadKeys([n], !1), i = this.crypto.deviceList.getDeviceByIdentityKey(t.algorithm, r)))) return a.logger.info("Couldn't find device for identity key " + r + ": not establishing session"), yield this.olmDevice.recordSessionProblem(r, "no_olm", !1), void this.retryDecryptionFromSender(r);
												yield c.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, {
													[n]: [i]
												}, !1);
												const o = {
													algorithm: c.OLM_ALGORITHM,
													sender_key: this.olmDevice.deviceCurve25519Key,
													ciphertext: {}
												};
												yield c.encryptMessageForDevice(o.ciphertext, this.userId, void 0, this.olmDevice, n, i, {
													type: "m.dummy"
												}), yield this.olmDevice.recordSessionProblem(r, "no_olm", !0), this.retryDecryptionFromSender(r), yield this.baseApis.sendToDevice("m.room.encrypted", {
													[n]: {
														[i.deviceId]: o
													}
												})
											} else yield this.olmDevice.addInboundGroupSessionWithheld(t.room_id, r, t.session_id, t.code, t.reason)
										}))
									}
									hasKeysForKeyRequest(e) {
										const t = e.requestBody;
										return this.olmDevice.hasInboundSessionKeys(t.room_id, t.sender_key, t.session_id)
									}
									shareKeysWithDevice(e) {
										const t = e.userId,
											r = e.deviceId,
											n = this.crypto.getStoredDevice(t, r),
											i = e.requestBody;
										this.olmlib.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, {
											[t]: [n]
										}).then(e => {
											return e[t][r].sessionId ? (a.logger.log("sharing keys for session " + i.sender_key + "|" + i.session_id + " with device " + t + ":" + r), this.buildKeyForwardingMessage(i.room_id, i.sender_key, i.session_id)) : null
										}).then(e => {
											const i = {
												algorithm: c.OLM_ALGORITHM,
												sender_key: this.olmDevice.deviceCurve25519Key,
												ciphertext: {}
											};
											return this.olmlib.encryptMessageForDevice(i.ciphertext, this.userId, void 0, this.olmDevice, t, n, e).then(() => {
												const e = {
													[t]: {
														[r]: i
													}
												};
												return this.baseApis.sendToDevice("m.room.encrypted", e)
											})
										})
									}
									buildKeyForwardingMessage(e, t, r) {
										return s(this, void 0, void 0, (function*() {
											const n = yield this.olmDevice.getInboundGroupSessionKey(e, t, r);
											return {
												type: "m.forwarded_room_key",
												content: {
													algorithm: c.MEGOLM_ALGORITHM,
													room_id: e,
													sender_key: t,
													sender_claimed_ed25519_key: n.sender_claimed_ed25519_key,
													session_id: r,
													session_key: n.key,
													chain_index: n.chain_index,
													forwarding_curve25519_key_chain: n.forwarding_curve25519_key_chain,
													"org.matrix.msc3061.shared_history": n.shared_history || !1
												}
											}
										}))
									}
									importRoomKey(e, t = {}) {
										const r = {};
										return (t.untrusted || e.untrusted) && (r.untrusted = !0), e["org.matrix.msc3061.shared_history"] && (r.sharedHistory = !0), this.olmDevice.addInboundGroupSession(e.room_id, e.sender_key, e.forwarding_curve25519_key_chain, e.session_id, e.session_key, e.sender_claimed_keys, !0, r).then(() => {
											"backup" !== t.source && this.crypto.backupManager.backupGroupSession(e.sender_key, e.session_id).catch(e => {
												a.logger.log("Failed to back up megolm session", e)
											}), this.retryDecryption(e.sender_key, e.session_id, !r.untrusted)
										})
									}
									retryDecryption(e, t, r) {
										var n;
										return s(this, void 0, void 0, (function*() {
											const i = this.pendingEvents.get(e);
											if (!i) return !0;
											const o = i.get(t);
											return !o || (a.logger.debug("Retrying decryption on events", [...o]), yield Promise.all([...o].map(e => s(this, void 0, void 0, (function*() {
												try {
													yield e.attemptDecryption(this.crypto, {
														isRetry: !0,
														forceRedecryptIfUntrusted: r
													})
												} catch (t) {}
											})))), !(null === (n = this.pendingEvents.get(e)) || void 0 === n ? void 0 : n.has(t)))
										}))
									}
									retryDecryptionFromSender(e) {
										return s(this, void 0, void 0, (function*() {
											const t = this.pendingEvents.get(e);
											return !t || (this.pendingEvents.delete(e), yield Promise.all([...t].map(([e, t]) => s(this, void 0, void 0, (function*() {
												yield Promise.all([...t].map(e => s(this, void 0, void 0, (function*() {
													try {
														yield e.attemptDecryption(this.crypto)
													} catch (t) {}
												}))))
											})))), !this.pendingEvents.has(e))
										}))
									}
									sendSharedHistoryInboundSessions(e) {
										return s(this, void 0, void 0, (function*() {
											yield c.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, e), a.logger.log("sendSharedHistoryInboundSessions to users", Object.keys(e));
											const t = yield this.olmDevice.getSharedHistoryInboundGroupSessions(this.roomId);
											a.logger.log("shared-history sessions", t);
											for (const [r, n] of t) {
												const t = yield this.buildKeyForwardingMessage(this.roomId, r, n), i = [], o = {};
												for (const [r, n] of Object.entries(e)) {
													o[r] = {};
													for (const e of n) {
														const n = {
															algorithm: c.OLM_ALGORITHM,
															sender_key: this.olmDevice.deviceCurve25519Key,
															ciphertext: {}
														};
														o[r][e.deviceId] = n, i.push(c.encryptMessageForDevice(n.ciphertext, this.userId, void 0, this.olmDevice, r, e, t))
													}
												}
												yield Promise.all(i);
												for (const e of Object.keys(o)) {
													for (const t of Object.keys(o[e])) 0 === Object.keys(o[e][t].ciphertext).length && (a.logger.log("No ciphertext for device " + e + ":" + t + ": pruning"), delete o[e][t]);
													0 === Object.keys(o[e]).length && (a.logger.log("Pruned all devices for user " + e), delete o[e])
												}
												if (0 === Object.keys(o).length) return void a.logger.log("No users left to send to: aborting");
												yield this.baseApis.sendToDevice("m.room.encrypted", o)
											}
										}))
									}
								}
								const m = {
									no_olm: "The sender was unable to establish a secure channel.",
									unknown: "The secure channel with the sender was corrupted."
								};
								(0, l.registerAlgorithm)(c.MEGOLM_ALGORITHM, v, g)
							}, {
								"../../@types/event": 290,
								"../../logger": 356,
								"../OlmDevice": 310,
								"../OutgoingRoomKeyRequestManager": 311,
								"../olmlib": 326,
								"./base": 315
							}],
							318: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
										Object.defineProperty(e, "default", {
											enumerable: !0,
											value: t
										})
									} : function(e, t) {
										e.default = t
									}),
									o = this && this.__importStar || function(e) {
										if (e && e.__esModule) return e;
										var t = {};
										if (null != e)
											for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
										return i(t, e), t
									},
									s = this && this.__awaiter || function(e, t, r, n) {
										return new(r || (r = Promise))((function(i, o) {
											function s(e) {
												try {
													c(n.next(e))
												} catch (t) {
													o(t)
												}
											}

											function a(e) {
												try {
													c(n.throw(e))
												} catch (t) {
													o(t)
												}
											}

											function c(e) {
												var t;
												e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
													e(t)
												}))).then(s, a)
											}
											c((n = n.apply(e, t || [])).next())
										}))
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								});
								const a = e("../../logger"),
									c = o(e("../olmlib")),
									l = e("../deviceinfo"),
									u = e("./base"),
									d = l.DeviceInfo.DeviceVerification;
								class h extends u.EncryptionAlgorithm {
									constructor() {
										super(...arguments), this.sessionPrepared = !1, this.prepPromise = null
									}
									ensureSession(e) {
										return this.prepPromise ? this.prepPromise : this.sessionPrepared ? Promise.resolve() : (this.prepPromise = this.crypto.downloadKeys(e).then(() => this.crypto.ensureOlmSessionsForUsers(e)).then(() => {
											this.sessionPrepared = !0
										}).finally(() => {
											this.prepPromise = null
										}), this.prepPromise)
									}
									encryptMessage(e, t, r) {
										return s(this, void 0, void 0, (function*() {
											const n = (yield e.getEncryptionTargetMembers()).map((function(e) {
												return e.userId
											}));
											yield this.ensureSession(n);
											const i = {
													room_id: e.roomId,
													type: t,
													content: r
												},
												o = {
													algorithm: c.OLM_ALGORITHM,
													sender_key: this.olmDevice.deviceCurve25519Key,
													ciphertext: {}
												},
												s = [];
											for (const e of n) {
												const t = this.crypto.getStoredDevicesForUser(e) || [];
												for (const r of t) {
													r.getIdentityKey() != this.olmDevice.deviceCurve25519Key && (r.verified != d.BLOCKED && s.push(c.encryptMessageForDevice(o.ciphertext, this.userId, this.deviceId, this.olmDevice, e, r, i)))
												}
											}
											return Promise.all(s).then(() => o)
										}))
									}
								}
								class f extends u.DecryptionAlgorithm {
									decryptEvent(e) {
										return s(this, void 0, void 0, (function*() {
											const t = e.getWireContent(),
												r = t.sender_key,
												n = t.ciphertext;
											if (!n) throw new u.DecryptionError("OLM_MISSING_CIPHERTEXT", "Missing ciphertext");
											if (!(this.olmDevice.deviceCurve25519Key in n)) throw new u.DecryptionError("OLM_NOT_INCLUDED_IN_RECIPIENTS", "Not included in recipients");
											const i = n[this.olmDevice.deviceCurve25519Key];
											let o;
											try {
												o = yield this.decryptMessage(r, i)
											} catch (l) {
												throw new u.DecryptionError("OLM_BAD_ENCRYPTED_MESSAGE", "Bad Encrypted Message", {
													sender: r,
													err: l
												})
											}
											const s = JSON.parse(o);
											if (s.recipient != this.userId) throw new u.DecryptionError("OLM_BAD_RECIPIENT", "Message was intented for " + s.recipient);
											if (s.recipient_keys.ed25519 != this.olmDevice.deviceEd25519Key) throw new u.DecryptionError("OLM_BAD_RECIPIENT_KEY", "Message not intended for this device", {
												intended: s.recipient_keys.ed25519,
												our_key: this.olmDevice.deviceEd25519Key
											});
											yield this.crypto.deviceList.downloadKeys([e.getSender()], !1);
											const a = this.crypto.deviceList.getUserByIdentityKey(c.OLM_ALGORITHM, r);
											if (a !== e.getSender() && null != a) throw new u.DecryptionError("OLM_BAD_SENDER", "Message claimed to be from " + e.getSender(), {
												real_sender: a
											});
											if (s.sender != e.getSender()) throw new u.DecryptionError("OLM_FORWARDED_MESSAGE", "Message forwarded from " + s.sender, {
												reported_sender: e.getSender()
											});
											if (s.room_id !== e.getRoomId()) throw new u.DecryptionError("OLM_BAD_ROOM", "Message intended for room " + s.room_id, {
												reported_room: e.getRoomId() || "ROOM_ID_UNDEFINED"
											});
											return {
												clearEvent: s,
												senderCurve25519Key: r,
												claimedEd25519Key: (s.keys || {}).ed25519 || null
											}
										}))
									}
									decryptMessage(e, t) {
										if (0 !== t.type) return this.reallyDecryptMessage(e, t); {
											const r = this.olmDevice.olmPrekeyPromise.then(() => this.reallyDecryptMessage(e, t));
											return this.olmDevice.olmPrekeyPromise = r.catch(() => {}), r
										}
									}
									reallyDecryptMessage(e, t) {
										return s(this, void 0, void 0, (function*() {
											const r = yield this.olmDevice.getSessionIdsForDevice(e), n = {};
											for (const s of r) try {
												const r = yield this.olmDevice.decryptMessage(e, s, t.type, t.body);
												return a.logger.log("Decrypted Olm message from " + e + " with session " + s), r
											} catch (o) {
												if (yield this.olmDevice.matchesSession(e, s, t.type, t.body)) throw new Error("Error decrypting prekey message with existing session id " + s + ": " + o.message);
												n[s] = o.message
											}
											if (0 !== t.type) {
												if (0 === r.length) throw new Error("No existing sessions");
												throw new Error("Error decrypting non-prekey message with existing sessions: " + JSON.stringify(n))
											}
											let i;
											try {
												i = yield this.olmDevice.createInboundSession(e, t.type, t.body)
											} catch (o) {
												throw n["(new)"] = o.message, new Error("Error decrypting prekey message: " + JSON.stringify(n))
											}
											return a.logger.log("created new inbound Olm session ID " + i.session_id + " with " + e), i.payload
										}))
									}
								}(0, u.registerAlgorithm)(c.OLM_ALGORITHM, h, f)
							}, {
								"../../logger": 356,
								"../deviceinfo": 323,
								"../olmlib": 326,
								"./base": 315
							}],
							319: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.CrossSigningKey = void 0,
									function(e) {
										e.Master = "master", e.SelfSigning = "self_signing", e.UserSigning = "user_signing"
									}(r.CrossSigningKey || (r.CrossSigningKey = {}))
							}, {}],
							320: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var r = this && this.__awaiter || function(e, t, r, n) {
											return new(r || (r = Promise))((function(i, o) {
												function s(e) {
													try {
														c(n.next(e))
													} catch (t) {
														o(t)
													}
												}

												function a(e) {
													try {
														c(n.throw(e))
													} catch (t) {
														o(t)
													}
												}

												function c(e) {
													var t;
													e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
														e(t)
													}))).then(s, a)
												}
												c((n = n.apply(e, t || [])).next())
											}))
										};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.DefaultAlgorithm = n.algorithmsByName = n.Aes256 = n.Curve25519 = n.BackupManager = void 0;
										const i = t("../client"),
											o = t("../logger"),
											s = t("./olmlib"),
											a = t("./key_passphrase"),
											c = t("../utils"),
											l = t("./store/indexeddb-crypto-store"),
											u = t("./recoverykey"),
											d = t("./aes"),
											h = t("../NamespacedValue"),
											f = t("./index"),
											p = t("./crypto"),
											v = t("../http-api"),
											g = 200,
											m = 5e3;
										class y {
											constructor(e, t) {
												this.baseApis = e, this.getKey = t, this.sessionLastCheckAttemptedTime = {}, this.checkedForBackup = !1, this.sendingBackups = !1
											}
											get version() {
												return this.backupInfo && this.backupInfo.version
											}
											static checkBackupVersion(e) {
												const t = n.algorithmsByName[e.algorithm];
												if (!t) throw new Error("Unknown backup algorithm: " + e.algorithm);
												if ("object" != typeof e.auth_data) throw new Error("Invalid backup data returned");
												return t.checkBackupVersion(e)
											}
											static makeAlgorithm(e, t) {
												const r = n.algorithmsByName[e.algorithm];
												if (!r) throw new Error("Unknown backup algorithm");
												return r.init(e.auth_data, t)
											}
											enableKeyBackup(e) {
												return r(this, void 0, void 0, (function*() {
													this.backupInfo = e, this.algorithm && this.algorithm.free(), this.algorithm = yield y.makeAlgorithm(e, this.getKey), this.baseApis.emit(f.CryptoEvent.KeyBackupStatus, !0), this.scheduleKeyBackupSend()
												}))
											}
											disableKeyBackup() {
												this.algorithm && this.algorithm.free(), this.algorithm = void 0, this.backupInfo = void 0, this.baseApis.emit(f.CryptoEvent.KeyBackupStatus, !1)
											}
											getKeyBackupEnabled() {
												return this.checkedForBackup ? Boolean(this.algorithm) : null
											}
											prepareKeyBackupVersion(e, t) {
												return r(this, void 0, void 0, (function*() {
													const r = t ? n.algorithmsByName[t] : n.DefaultAlgorithm;
													if (!r) throw new Error("Unknown backup algorithm");
													const [i, o] = yield r.prepare(e), s = (0, u.encodeRecoveryKey)(i);
													return {
														algorithm: r.algorithmName,
														auth_data: o,
														recovery_key: s,
														privateKey: i
													}
												}))
											}
											createKeyBackupVersion(e) {
												return r(this, void 0, void 0, (function*() {
													this.algorithm = yield y.makeAlgorithm(e, this.getKey)
												}))
											}
											checkAndStart() {
												var e;
												return r(this, void 0, void 0, (function*() {
													if (o.logger.log("Checking key backup status..."), this.baseApis.isGuest()) return o.logger.log("Skipping key backup check since user is guest"), this.checkedForBackup = !0, null;
													let t;
													try {
														t = null !== (e = yield this.baseApis.getKeyBackupVersion()) && void 0 !== e ? e : void 0
													} catch (n) {
														return o.logger.log("Error checking for active key backup", n), 404 === n.httpStatus && (this.checkedForBackup = !0), null
													}
													this.checkedForBackup = !0;
													const r = yield this.isKeyBackupTrusted(t);
													return r.usable && !this.backupInfo ? (o.logger.log(`Found usable key backup v${t.version}: enabling key backups`), yield this.enableKeyBackup(t)) : !r.usable && this.backupInfo ? (o.logger.log("No usable key backup: disabling key backup"), this.disableKeyBackup()) : r.usable || this.backupInfo ? r.usable && this.backupInfo && (t.version !== this.backupInfo.version ? (o.logger.log(`On backup version ${this.backupInfo.version} but ` + `found version ${t.version}: switching.`), this.disableKeyBackup(), yield this.enableKeyBackup(t), yield this.scheduleAllGroupSessionsForBackup()) : o.logger.log(`Backup version ${t.version} still current`)) : o.logger.log("No usable key backup: not enabling key backup"), {
														backupInfo: t,
														trustInfo: r
													}
												}))
											}
											checkKeyBackup() {
												return r(this, void 0, void 0, (function*() {
													return this.checkedForBackup = !1, this.checkAndStart()
												}))
											}
											queryKeyBackupRateLimited(e, t) {
												return r(this, void 0, void 0, (function*() {
													if (!this.backupInfo) return;
													const r = (new Date).getTime();
													(!this.sessionLastCheckAttemptedTime[t] || r - this.sessionLastCheckAttemptedTime[t] > m) && (this.sessionLastCheckAttemptedTime[t] = r, yield this.baseApis.restoreKeyBackupWithCache(e, t, this.backupInfo, {}))
												}))
											}
											isKeyBackupTrusted(e) {
												return r(this, void 0, void 0, (function*() {
													const t = {
														usable: !1,
														trusted_locally: !1,
														sigs: []
													};
													if (!(e && e.algorithm && e.auth_data && e.auth_data.signatures)) return o.logger.info("Key backup is absent or missing required data"), t;
													const n = this.baseApis.getUserId(),
														i = yield this.baseApis.crypto.getSessionBackupPrivateKey();
													if (i) {
														let n = null;
														try {
															n = yield y.makeAlgorithm(e, () => r(this, void 0, void 0, (function*() {
																return i
															}))), (yield n.keyMatches(i)) && (o.logger.info("Backup is trusted locally"), t.trusted_locally = !0)
														} catch (c) {} finally {
															null == n || n.free()
														}
													}
													const a = e.auth_data.signatures[n] || {};
													for (const r of Object.keys(a)) {
														const i = r.split(":");
														if ("ed25519" !== i[0]) {
															o.logger.log("Ignoring unknown signature type: " + i[0]);
															continue
														}
														const a = {
																deviceId: i[1]
															},
															c = this.baseApis.crypto.crossSigningInfo.getId();
														if (c === a.deviceId) {
															a.crossSigningId = !0;
															try {
																yield(0, s.verifySignature)(this.baseApis.crypto.olmDevice, e.auth_data, n, a.deviceId, c), a.valid = !0
															} catch (l) {
																o.logger.warn("Bad signature from cross signing key " + c, l), a.valid = !1
															}
															t.sigs.push(a);
															continue
														}
														const u = this.baseApis.crypto.deviceList.getStoredDevice(n, a.deviceId);
														if (u) {
															a.device = u, a.deviceTrust = this.baseApis.checkDeviceTrust(n, a.deviceId);
															try {
																yield(0, s.verifySignature)(this.baseApis.crypto.olmDevice, e.auth_data, n, u.deviceId, u.getFingerprint()), a.valid = !0
															} catch (l) {
																o.logger.info("Bad signature from key ID " + r + " userID " + this.baseApis.getUserId() + " device ID " + u.deviceId + " fingerprint: " + u.getFingerprint(), e.auth_data, l), a.valid = !1
															}
														} else a.valid = null, o.logger.info("Ignoring signature from unknown key " + r);
														t.sigs.push(a)
													}
													return t.usable = t.sigs.some(e => {
														var t;
														return e.valid && (e.device && (null === (t = e.deviceTrust) || void 0 === t ? void 0 : t.isVerified()) || e.crossSigningId)
													}), t
												}))
											}
											scheduleKeyBackupSend(e = 1e4) {
												return r(this, void 0, void 0, (function*() {
													if (!this.sendingBackups) {
														this.sendingBackups = !0;
														try {
															const r = Math.random() * e;
															yield(0, c.sleep)(r);
															let n = 0;
															for (;;) {
																if (!this.algorithm) return;
																try {
																	if (0 === (yield this.backupPendingKeys(g))) return;
																	n = 0
																} catch (t) {
																	if (n++, o.logger.log("Key backup request failed", t), t.data && ("M_NOT_FOUND" == t.data.errcode || "M_WRONG_ROOM_KEYS_VERSION" == t.data.errcode)) throw yield this.checkKeyBackup(), this.baseApis.crypto.emit(f.CryptoEvent.KeyBackupFailed, t.data.errcode), t
																}
																n && (yield(0, c.sleep)(1e3 * Math.pow(2, Math.min(n - 1, 4))))
															}
														} finally {
															this.sendingBackups = !1
														}
													}
												}))
											}
											backupPendingKeys(e) {
												var t;
												return r(this, void 0, void 0, (function*() {
													const r = yield this.baseApis.crypto.cryptoStore.getSessionsNeedingBackup(e);
													if (!r.length) return 0;
													let n = yield this.baseApis.crypto.cryptoStore.countSessionsNeedingBackup();
													this.baseApis.crypto.emit(f.CryptoEvent.KeyBackupSessionsRemaining, n);
													const i = {};
													for (const e of r) {
														const r = e.sessionData.room_id;
														void 0 === i[r] && (i[r] = {
															sessions: {}
														});
														const n = this.baseApis.crypto.olmDevice.exportInboundGroupSession(e.senderKey, e.sessionId, e.sessionData);
														n.algorithm = s.MEGOLM_ALGORITHM;
														const o = (n.forwarding_curve25519_key_chain || []).length,
															a = this.baseApis.crypto.deviceList.getUserByIdentityKey(s.MEGOLM_ALGORITHM, e.senderKey),
															c = null !== (t = this.baseApis.crypto.deviceList.getDeviceByIdentityKey(s.MEGOLM_ALGORITHM, e.senderKey)) && void 0 !== t ? t : void 0,
															l = this.baseApis.crypto.checkDeviceInfoTrust(a, c).isVerified();
														i[r].sessions[e.sessionId] = {
															first_message_index: n.first_known_index,
															forwarded_count: o,
															is_verified: l,
															session_data: yield this.algorithm.encryptSession(n)
														}
													}
													return yield this.baseApis.sendKeyBackup(void 0, void 0, this.backupInfo.version, {
														rooms: i
													}), yield this.baseApis.crypto.cryptoStore.unmarkSessionsNeedingBackup(r), n = yield this.baseApis.crypto.cryptoStore.countSessionsNeedingBackup(), this.baseApis.crypto.emit(f.CryptoEvent.KeyBackupSessionsRemaining, n), r.length
												}))
											}
											backupGroupSession(e, t) {
												return r(this, void 0, void 0, (function*() {
													yield this.baseApis.crypto.cryptoStore.markSessionsNeedingBackup([{
														senderKey: e,
														sessionId: t
													}]), this.backupInfo && this.scheduleKeyBackupSend()
												}))
											}
											scheduleAllGroupSessionsForBackup() {
												return r(this, void 0, void 0, (function*() {
													yield this.flagAllGroupSessionsForBackup(), this.scheduleKeyBackupSend(0)
												}))
											}
											flagAllGroupSessionsForBackup() {
												return r(this, void 0, void 0, (function*() {
													yield this.baseApis.crypto.cryptoStore.doTxn("readwrite", [l.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, l.IndexedDBCryptoStore.STORE_BACKUP], e => {
														this.baseApis.crypto.cryptoStore.getAllEndToEndInboundGroupSessions(e, t => {
															null !== t && this.baseApis.crypto.cryptoStore.markSessionsNeedingBackup([t], e)
														})
													});
													const e = yield this.baseApis.crypto.cryptoStore.countSessionsNeedingBackup();
													return this.baseApis.emit(f.CryptoEvent.KeyBackupSessionsRemaining, e), e
												}))
											}
											countSessionsNeedingBackup() {
												return this.baseApis.crypto.cryptoStore.countSessionsNeedingBackup()
											}
										}
										n.BackupManager = y;
										class b {
											constructor(e, t, r) {
												this.authData = e, this.publicKey = t, this.getKey = r
											}
											static init(t, n) {
												return r(this, void 0, void 0, (function*() {
													if (!(t && "public_key" in t)) throw new Error("auth_data missing required information");
													const r = new e.Olm.PkEncryption;
													return r.set_recipient_key(t.public_key), new b(t, r, n)
												}))
											}
											static prepare(t) {
												return r(this, void 0, void 0, (function*() {
													const r = new e.Olm.PkDecryption;
													try {
														const n = {};
														if (t)
															if (t instanceof Uint8Array) n.public_key = r.init_with_private_key(t);
															else {
																const e = yield(0, a.keyFromPassphrase)(t);
																n.private_key_salt = e.salt, n.private_key_iterations = e.iterations, n.public_key = r.init_with_private_key(e.key)
															}
														else n.public_key = r.generate_key();
														return (new e.Olm.PkEncryption).set_recipient_key(n.public_key), [r.get_private_key(), n]
													} finally {
														r.free()
													}
												}))
											}
											static checkBackupVersion(e) {
												if (!("public_key" in e.auth_data)) throw new Error("Invalid backup data returned")
											}
											get untrusted() {
												return !0
											}
											encryptSession(e) {
												return r(this, void 0, void 0, (function*() {
													const t = Object.assign({}, e);
													return delete t.session_id, delete t.room_id, delete t.first_known_index, this.publicKey.encrypt(JSON.stringify(t))
												}))
											}
											decryptSessions(t) {
												return r(this, void 0, void 0, (function*() {
													const r = yield this.getKey(), n = new e.Olm.PkDecryption;
													try {
														if (n.init_with_private_key(r) !== this.authData.public_key) throw new v.MatrixError({
															errcode: i.MatrixClient.RESTORE_BACKUP_ERROR_BAD_KEY
														});
														const e = [];
														for (const [r, i] of Object.entries(t)) try {
															const t = JSON.parse(n.decrypt(i.session_data.ephemeral, i.session_data.mac, i.session_data.ciphertext));
															t.session_id = r, e.push(t)
														} catch (s) {
															o.logger.log("Failed to decrypt megolm session from backup", s, i)
														}
														return e
													} finally {
														n.free()
													}
												}))
											}
											keyMatches(t) {
												return r(this, void 0, void 0, (function*() {
													const r = new e.Olm.PkDecryption;
													let n;
													try {
														n = r.init_with_private_key(t)
													} finally {
														r.free()
													}
													return n === this.authData.public_key
												}))
											}
											free() {
												this.publicKey.free()
											}
										}
										n.Curve25519 = b, b.algorithmName = "m.megolm_backup.v1.curve25519-aes-sha2";
										const _ = new h.UnstableValue("m.megolm_backup.v1.aes-hmac-sha2", "org.matrix.msc3270.v1.aes-hmac-sha2");
										class w {
											constructor(e, t) {
												this.authData = e, this.key = t
											}
											static init(e, t) {
												return r(this, void 0, void 0, (function*() {
													if (!e) throw new Error("auth_data missing");
													const r = yield t();
													if (e.mac) {
														const {
															mac: t
														} = yield(0, d.calculateKeyCheck)(r, e.iv);
														if (e.mac.replace(/=+$/g, "") !== t.replace(/=+/g, "")) throw new Error("Key does not match")
													}
													return new w(e, r)
												}))
											}
											static prepare(e) {
												return r(this, void 0, void 0, (function*() {
													let t;
													const r = {};
													if (e)
														if (e instanceof Uint8Array) t = new Uint8Array(e);
														else {
															const n = yield(0, a.keyFromPassphrase)(e);
															r.private_key_salt = n.salt, r.private_key_iterations = n.iterations, t = n.key
														}
													else t = function(e) {
														const t = new Uint8Array(e);
														return p.crypto.getRandomValues(t), t
													}(32);
													const {
														iv: n,
														mac: i
													} = yield(0, d.calculateKeyCheck)(t);
													return r.iv = n, r.mac = i, [t, r]
												}))
											}
											static checkBackupVersion(e) {
												if (!("iv" in e.auth_data && "mac" in e.auth_data)) throw new Error("Invalid backup data returned")
											}
											get untrusted() {
												return !1
											}
											encryptSession(e) {
												const t = Object.assign({}, e);
												return delete t.session_id, delete t.room_id, delete t.first_known_index, (0, d.encryptAES)(JSON.stringify(t), this.key, e.session_id)
											}
											decryptSessions(e) {
												return r(this, void 0, void 0, (function*() {
													const t = [];
													for (const [n, i] of Object.entries(e)) try {
														const e = JSON.parse(yield(0, d.decryptAES)(i.session_data, this.key, n));
														e.session_id = n, t.push(e)
													} catch (r) {
														o.logger.log("Failed to decrypt megolm session from backup", r, i)
													}
													return t
												}))
											}
											keyMatches(e) {
												return r(this, void 0, void 0, (function*() {
													if (this.authData.mac) {
														const {
															mac: t
														} = yield(0, d.calculateKeyCheck)(e, this.authData.iv);
														return this.authData.mac.replace(/=+$/g, "") === t.replace(/=+/g, "")
													}
													return !0
												}))
											}
											free() {
												this.key.fill(0)
											}
										}
										n.Aes256 = w, w.algorithmName = _.name, n.algorithmsByName = {
											[b.algorithmName]: b,
											[w.algorithmName]: w
										}, n.DefaultAlgorithm = b
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"../NamespacedValue": 299,
								"../client": 304,
								"../http-api": 349,
								"../logger": 356,
								"../utils": 393,
								"./aes": 314,
								"./crypto": 321,
								"./index": 324,
								"./key_passphrase": 325,
								"./olmlib": 326,
								"./recoverykey": 327,
								"./store/indexeddb-crypto-store": 329
							}],
							321: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var r, i, o, s, a, c, l;
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.setTextEncoder = n.setCrypto = n.TextEncoder = n.subtleCrypto = n.crypto = void 0;
										const u = t("../logger");
										if (n.crypto = null === (r = e.window) || void 0 === r ? void 0 : r.crypto, n.subtleCrypto = null !== (s = null === (o = null === (i = e.window) || void 0 === i ? void 0 : i.crypto) || void 0 === o ? void 0 : o.subtle) && void 0 !== s ? s : null === (c = null === (a = e.window) || void 0 === a ? void 0 : a.crypto) || void 0 === c ? void 0 : c.webkitSubtle, n.TextEncoder = null === (l = e.window) || void 0 === l ? void 0 : l.TextEncoder, !n.crypto) try {
											n.crypto = t("crypto").webcrypto
										} catch (d) {
											u.logger.error("Failed to load webcrypto", d)
										}
										if (n.subtleCrypto || (n.subtleCrypto = null === n.crypto || void 0 === n.crypto ? void 0 : n.crypto.subtle), !n.TextEncoder) try {
											n.TextEncoder = t("util").TextEncoder
										} catch (d) {
											u.logger.error("Failed to load TextEncoder util", d)
										}
										n.setCrypto = function(e) {
											var t;
											n.crypto = e, n.subtleCrypto = null !== (t = e.subtle) && void 0 !== t ? t : e.webkitSubtle
										}, n.setTextEncoder = function(e) {
											n.TextEncoder = e
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"../logger": 356,
								crypto: 79,
								util: 286
							}],
							322: [function(t, r, n) {
								(function(e, r) {
									(function() {
										"use strict";
										var i = this && this.__awaiter || function(e, t, r, n) {
												return new(r || (r = Promise))((function(i, o) {
													function s(e) {
														try {
															c(n.next(e))
														} catch (t) {
															o(t)
														}
													}

													function a(e) {
														try {
															c(n.throw(e))
														} catch (t) {
															o(t)
														}
													}

													function c(e) {
														var t;
														e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
															e(t)
														}))).then(s, a)
													}
													c((n = n.apply(e, t || [])).next())
												}))
											},
											o = this && this.__importDefault || function(e) {
												return e && e.__esModule ? e : {
													default: e
												}
											};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.DehydrationManager = n.DEHYDRATION_ALGORITHM = void 0;
										const s = o(t("another-json")),
											a = t("./olmlib"),
											c = t("../crypto/store/indexeddb-crypto-store"),
											l = t("./aes"),
											u = t("../logger"),
											d = t("../http-api");
										n.DEHYDRATION_ALGORITHM = "org.matrix.msc2697.v1.olm.libolm_pickle";
										const h = 6048e5;
										n.DehydrationManager = class {
											constructor(e) {
												this.crypto = e, this.inProgress = !1, this.getDehydrationKeyFromCache()
											}
											getDehydrationKeyFromCache() {
												return this.crypto.cryptoStore.doTxn("readonly", [c.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
													this.crypto.cryptoStore.getSecretStorePrivateKey(t, t => i(this, void 0, void 0, (function*() {
														if (t) {
															const {
																key: i,
																keyInfo: o,
																deviceDisplayName: s,
																time: c
															} = t, u = r.from(this.crypto.olmDevice.pickleKey), d = yield(0, l.decryptAES)(i, u, n.DEHYDRATION_ALGORITHM);
															this.key = (0, a.decodeBase64)(d), this.keyInfo = o, this.deviceDisplayName = s;
															const f = Date.now(),
																p = Math.max(1, c + h - f);
															this.timeoutId = e.setTimeout(this.dehydrateDevice.bind(this), p)
														}
													})), "dehydration")
												})
											}
											setKeyAndQueueDehydration(e, t = {}, r) {
												return i(this, void 0, void 0, (function*() {
													(yield this.setKey(e, t, r)) || this.dehydrateDevice()
												}))
											}
											setKey(t, r = {}, n) {
												return i(this, void 0, void 0, (function*() {
													if (!t) return this.timeoutId && (e.clearTimeout(this.timeoutId), this.timeoutId = void 0), yield this.crypto.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
														this.crypto.cryptoStore.storeSecretStorePrivateKey(e, "dehydration", null)
													}), this.key = void 0, void(this.keyInfo = void 0);
													let i = !!this.key && t.length == this.key.length;
													for (let e = 0; i && e < t.length; e++) t[e] != this.key[e] && (i = !1);
													return i || (this.key = t, this.keyInfo = r, this.deviceDisplayName = n), i
												}))
											}
											dehydrateDevice() {
												return i(this, void 0, void 0, (function*() {
													if (this.inProgress) u.logger.log("Dehydration already in progress -- not starting new dehydration");
													else {
														this.inProgress = !0, this.timeoutId && (e.clearTimeout(this.timeoutId), this.timeoutId = void 0);
														try {
															const t = r.from(this.crypto.olmDevice.pickleKey),
																i = yield(0, l.encryptAES)((0, a.encodeBase64)(this.key), t, n.DEHYDRATION_ALGORITHM);
															yield this.crypto.cryptoStore.doTxn("readwrite", [c.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
																this.crypto.cryptoStore.storeSecretStorePrivateKey(e, "dehydration", {
																	keyInfo: this.keyInfo,
																	key: i,
																	deviceDisplayName: this.deviceDisplayName,
																	time: Date.now()
																})
															}), u.logger.log("Attempting to dehydrate device"), u.logger.log("Creating account");
															const o = new e.Olm.Account;
															o.create();
															const f = JSON.parse(o.identity_keys()),
																p = o.max_number_of_one_time_keys();
															o.generate_one_time_keys(p / 2), o.generate_fallback_key();
															const v = JSON.parse(o.one_time_keys()),
																g = JSON.parse(o.fallback_key());
															o.mark_keys_as_published();
															const m = o.pickle(new Uint8Array(this.key)),
																y = {
																	algorithm: n.DEHYDRATION_ALGORITHM,
																	account: m
																};
															this.keyInfo.passphrase && (y.passphrase = this.keyInfo.passphrase), u.logger.log("Uploading account to server");
															const b = (yield this.crypto.baseApis.http.authedRequest(d.Method.Put, "/dehydrated_device", void 0, {
																device_data: y,
																initial_device_display_name: this.deviceDisplayName
															}, {
																prefix: "/_matrix/client/unstable/org.matrix.msc2697.v2"
															})).device_id;
															u.logger.log("Preparing device keys", b);
															const _ = {
																	algorithms: this.crypto.supportedAlgorithms,
																	device_id: b,
																	user_id: this.crypto.userId,
																	keys: {
																		[`ed25519:${b}`]: f.ed25519,
																		[`curve25519:${b}`]: f.curve25519
																	}
																},
																w = o.sign(s.default.stringify(_));
															_.signatures = {
																[this.crypto.userId]: {
																	[`ed25519:${b}`]: w
																}
															}, this.crypto.crossSigningInfo.getId("self_signing") && (yield this.crypto.crossSigningInfo.signObject(_, "self_signing")), u.logger.log("Preparing one-time keys");
															const S = {};
															for (const [e, r] of Object.entries(v.curve25519)) {
																const t = {
																		key: r
																	},
																	n = o.sign(s.default.stringify(t));
																t.signatures = {
																	[this.crypto.userId]: {
																		[`ed25519:${b}`]: n
																	}
																}, S[`signed_curve25519:${e}`] = t
															}
															u.logger.log("Preparing fallback keys");
															const E = {};
															for (const [e, r] of Object.entries(g.curve25519)) {
																const t = {
																		key: r,
																		fallback: !0
																	},
																	n = o.sign(s.default.stringify(t));
																t.signatures = {
																	[this.crypto.userId]: {
																		[`ed25519:${b}`]: n
																	}
																}, E[`signed_curve25519:${e}`] = t
															}
															return u.logger.log("Uploading keys to server"), yield this.crypto.baseApis.http.authedRequest(d.Method.Post, "/keys/upload/" + encodeURI(b), void 0, {
																device_keys: _,
																one_time_keys: S,
																"org.matrix.msc2732.fallback_keys": E
															}), u.logger.log("Done dehydrating"), this.timeoutId = e.setTimeout(this.dehydrateDevice.bind(this), h), b
														} finally {
															this.inProgress = !1
														}
													}
												}))
											}
											stop() {
												this.timeoutId && (e.clearTimeout(this.timeoutId), this.timeoutId = void 0)
											}
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, t("buffer").Buffer)
							}, {
								"../crypto/store/indexeddb-crypto-store": 329,
								"../http-api": 349,
								"../logger": 356,
								"./aes": 314,
								"./olmlib": 326,
								"another-json": 2,
								buffer: 69
							}],
							323: [function(e, t, r) {
								"use strict";
								var n;
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.DeviceInfo = void 0,
									function(e) {
										e[e.Blocked = -1] = "Blocked", e[e.Unverified = 0] = "Unverified", e[e.Verified = 1] = "Verified"
									}(n || (n = {}));
								class i {
									constructor(e) {
										this.deviceId = e, this.algorithms = [], this.keys = {}, this.verified = n.Unverified, this.known = !1, this.unsigned = {}, this.signatures = {}
									}
									static fromStorage(e, t) {
										const r = new i(t);
										for (const n in e) e.hasOwnProperty(n) && (r[n] = e[n]);
										return r
									}
									toStorage() {
										return {
											algorithms: this.algorithms,
											keys: this.keys,
											verified: this.verified,
											known: this.known,
											unsigned: this.unsigned,
											signatures: this.signatures
										}
									}
									getFingerprint() {
										return this.keys["ed25519:" + this.deviceId]
									}
									getIdentityKey() {
										return this.keys["curve25519:" + this.deviceId]
									}
									getDisplayName() {
										return this.unsigned.device_display_name || null
									}
									isBlocked() {
										return this.verified == n.Blocked
									}
									isVerified() {
										return this.verified == n.Verified
									}
									isUnverified() {
										return this.verified == n.Unverified
									}
									isKnown() {
										return !0 === this.known
									}
								}
								r.DeviceInfo = i, i.DeviceVerification = {
									VERIFIED: n.Verified,
									UNVERIFIED: n.Unverified,
									BLOCKED: n.Blocked
								}
							}, {}],
							324: [function(t, r, n) {
								(function(e, r) {
									(function() {
										"use strict";
										var i = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
												void 0 === n && (n = r);
												var i = Object.getOwnPropertyDescriptor(t, r);
												i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
													enumerable: !0,
													get: function() {
														return t[r]
													}
												}), Object.defineProperty(e, n, i)
											} : function(e, t, r, n) {
												void 0 === n && (n = r), e[n] = t[r]
											}),
											o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
												Object.defineProperty(e, "default", {
													enumerable: !0,
													value: t
												})
											} : function(e, t) {
												e.default = t
											}),
											s = this && this.__importStar || function(e) {
												if (e && e.__esModule) return e;
												var t = {};
												if (null != e)
													for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && i(t, e, r);
												return o(t, e), t
											},
											a = this && this.__awaiter || function(e, t, r, n) {
												return new(r || (r = Promise))((function(i, o) {
													function s(e) {
														try {
															c(n.next(e))
														} catch (t) {
															o(t)
														}
													}

													function a(e) {
														try {
															c(n.throw(e))
														} catch (t) {
															o(t)
														}
													}

													function c(e) {
														var t;
														e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
															e(t)
														}))).then(s, a)
													}
													c((n = n.apply(e, t || [])).next())
												}))
											},
											c = this && this.__importDefault || function(e) {
												return e && e.__esModule ? e : {
													default: e
												}
											};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.IncomingRoomKeyRequest = n.fixBackupKey = n.Crypto = n.CryptoEvent = n.isCryptoAvailable = n.verificationMethods = void 0;
										const l = c(t("another-json")),
											u = t("../@types/event"),
											d = t("../ReEmitter"),
											h = t("../logger"),
											f = t("./OlmDevice"),
											p = s(t("./olmlib")),
											v = t("./DeviceList"),
											g = t("./deviceinfo"),
											m = s(t("./algorithms")),
											y = t("./CrossSigning"),
											b = t("./EncryptionSetup"),
											_ = t("./SecretStorage"),
											w = t("./OutgoingRoomKeyRequestManager"),
											S = t("./store/indexeddb-crypto-store"),
											E = t("./verification/QRCode"),
											k = t("./verification/SAS"),
											T = t("./key_passphrase"),
											I = t("./recoverykey"),
											R = t("./verification/request/VerificationRequest"),
											C = t("./verification/request/InRoomChannel"),
											M = t("./verification/request/ToDeviceChannel"),
											x = t("./verification/IllegalMethod"),
											O = t("../errors"),
											A = t("./aes"),
											P = t("./dehydration"),
											D = t("./backup"),
											j = t("../models/room"),
											L = t("../models/room-member"),
											N = t("../models/event"),
											B = t("../client"),
											U = t("../models/typed-event-emitter"),
											F = g.DeviceInfo.DeviceVerification,
											$ = {
												[E.ReciprocateQRCode.NAME]: E.ReciprocateQRCode,
												[k.SAS.NAME]: k.SAS,
												[E.SHOW_QR_CODE_METHOD]: x.IllegalMethod,
												[E.SCAN_QR_CODE_METHOD]: x.IllegalMethod
											};
										n.verificationMethods = {
											RECIPROCATE_QR_CODE: E.ReciprocateQRCode.NAME,
											SAS: k.SAS.NAME
										}, n.isCryptoAvailable = function() {
											return Boolean(e.Olm)
										};
										const q = 36e5;
										var K;
										! function(e) {
											e.DeviceVerificationChanged = "deviceVerificationChanged", e.UserTrustStatusChanged = "userTrustStatusChanged", e.UserCrossSigningUpdated = "userCrossSigningUpdated", e.RoomKeyRequest = "crypto.roomKeyRequest", e.RoomKeyRequestCancellation = "crypto.roomKeyRequestCancellation", e.KeyBackupStatus = "crypto.keyBackupStatus", e.KeyBackupFailed = "crypto.keyBackupFailed", e.KeyBackupSessionsRemaining = "crypto.keyBackupSessionsRemaining", e.KeySignatureUploadFailure = "crypto.keySignatureUploadFailure", e.VerificationRequest = "crypto.verification.request", e.Warning = "crypto.warning", e.WillUpdateDevices = "crypto.willUpdateDevices", e.DevicesUpdated = "crypto.devicesUpdated", e.KeysChanged = "crossSigning.keysChanged"
										}(K = n.CryptoEvent || (n.CryptoEvent = {}));
										class V extends U.TypedEventEmitter {
											constructor(e, t, r, n, i, o, s) {
												if (super(), this.baseApis = e, this.userId = t, this.deviceId = r, this.clientStore = n, this.cryptoStore = i, this.roomList = o, this.trustCrossSignedDevices = !0, this.lastOneTimeKeyCheck = null, this.oneTimeKeyCheckInProgress = !1, this.roomEncryptors = new Map, this.roomDecryptors = new Map, this.deviceKeys = {}, this.globalBlacklistUnverifiedDevices = !1, this.globalErrorOnUnknownDevices = !0, this.receivedRoomKeyRequests = [], this.receivedRoomKeyRequestCancellations = [], this.processingRoomKeyRequests = !1, this.lazyLoadMembers = !1, this.roomDeviceTrackingState = {}, this.lastNewSessionForced = {}, this.sendKeyRequestsImmediately = !1, this.onDeviceListUserCrossSigningUpdated = e => a(this, void 0, void 0, (function*() {
														if (e === this.userId) {
															const t = this.deviceList.getStoredCrossSigningForUser(e),
																r = t ? t.getId() : null,
																n = this.crossSigningInfo.getId(),
																i = n !== r;
															n && r && !i ? yield this.checkOwnCrossSigningTrust(): (this.storeTrustedSelfKeys(null), this.emit(K.KeysChanged, {}), this.emit(K.UserTrustStatusChanged, this.userId, this.checkUserTrust(e)))
														} else {
															yield this.checkDeviceVerifications(e);
															const t = this.deviceList.getStoredCrossSigningForUser(e);
															t && (t.updateCrossSigningVerifiedBefore(this.checkUserTrust(e).isCrossSigningVerified()), this.deviceList.setRawStoredCrossSigningForUser(e, t.toStorage())), this.emit(K.UserTrustStatusChanged, e, this.checkUserTrust(e))
														}
													})), this.onMembership = (e, t, r) => {
														try {
															this.onRoomMembership(e, t, r)
														} catch (n) {
															h.logger.error("Error handling membership change:", n)
														}
													}, this.onToDeviceEvent = e => {
														try {
															h.logger.log(`received to_device ${e.getType()} from: ` + `${e.getSender()} id: ${e.getId()}`), "m.room_key" == e.getType() || "m.forwarded_room_key" == e.getType() ? this.onRoomKeyEvent(e) : "m.room_key_request" == e.getType() ? this.onRoomKeyRequestEvent(e) : "m.secret.request" === e.getType() ? this.secretStorage.onRequestReceived(e) : "m.secret.send" === e.getType() ? this.secretStorage.onSecretReceived(e) : "m.room_key.withheld" === e.getType() ? this.onRoomKeyWithheldEvent(e) : e.getContent().transaction_id ? this.onKeyVerificationMessage(e) : "m.bad.encrypted" === e.getContent().msgtype ? this.onToDeviceBadEncrypted(e) : (e.isBeingDecrypted() || e.shouldAttemptDecryption()) && (e.isBeingDecrypted() || e.attemptDecryption(this), e.once(N.MatrixEventEvent.Decrypted, e => {
																this.onToDeviceEvent(e)
															}))
														} catch (t) {
															h.logger.error("Error handling toDeviceEvent:", t)
														}
													}, this.onTimelineEvent = (e, t, r, n, {
														liveEvent: i = !0
													} = {}) => {
														if (!C.InRoomChannel.validateEvent(e, this.baseApis)) return;
														this.handleVerificationEvent(e, this.inRoomVerificationRequests, e => {
															const t = new C.InRoomChannel(this.baseApis, e.getRoomId());
															return new R.VerificationRequest(t, this.verificationMethods, this.baseApis)
														}, i)
													}, this.reEmitter = new d.TypedReEmitter(this), s) {
													this.verificationMethods = new Map;
													for (const e of s) "string" == typeof e ? $[e] && this.verificationMethods.set(e, $[e]) : e.NAME ? this.verificationMethods.set(e.NAME, e) : h.logger.warn(`Excluding unknown verification method ${e}`)
												} else this.verificationMethods = new Map(Object.entries($));
												this.backupManager = new D.BackupManager(e, () => a(this, void 0, void 0, (function*() {
													const e = yield this.getSessionBackupPrivateKey();
													if (e) return e;
													const t = yield this.getSecret("m.megolm_backup.v1");
													if (t) {
														const e = z(t);
														if (e) {
															const t = yield this.getSecretStorageKey();
															yield this.storeSecret("m.megolm_backup.v1", e, [t[0]])
														}
														return p.decodeBase64(e || t)
													}
													if (this.baseApis.cryptoCallbacks && this.baseApis.cryptoCallbacks.getBackupKey) return this.baseApis.cryptoCallbacks.getBackupKey();
													throw new Error("Unable to get private key")
												}))), this.olmDevice = new f.OlmDevice(i), this.deviceList = new v.DeviceList(e, i, this.olmDevice), this.deviceList.on(K.UserCrossSigningUpdated, this.onDeviceListUserCrossSigningUpdated), this.reEmitter.reEmit(this.deviceList, [K.DevicesUpdated, K.WillUpdateDevices]), this.supportedAlgorithms = Array.from(m.DECRYPTION_CLASSES.keys()), this.outgoingRoomKeyRequestManager = new w.OutgoingRoomKeyRequestManager(e, this.deviceId, this.cryptoStore), this.toDeviceVerificationRequests = new M.ToDeviceRequests, this.inRoomVerificationRequests = new C.InRoomRequests;
												const c = this.baseApis.cryptoCallbacks || {},
													l = (0, y.createCryptoStoreCacheCallbacks)(i, this.olmDevice);
												this.crossSigningInfo = new y.CrossSigningInfo(t, c, l), this.secretStorage = new _.SecretStorage(e, c, e), this.dehydrationManager = new P.DehydrationManager(this), !c.getCrossSigningKey && c.getSecretStorageKey && (c.getCrossSigningKey = e => a(this, void 0, void 0, (function*() {
													return y.CrossSigningInfo.getFromSecretStorage(e, this.secretStorage)
												})))
											}
											static getOlmVersion() {
												return f.OlmDevice.getOlmVersion()
											}
											init({
												exportedOlmDevice: t,
												pickleKey: r
											} = {}) {
												return a(this, void 0, void 0, (function*() {
													h.logger.log("Crypto: initialising Olm..."), yield e.Olm.init(), h.logger.log(t ? "Crypto: initialising Olm device from exported device..." : "Crypto: initialising Olm device..."), yield this.olmDevice.init({
														fromExportedDevice: t,
														pickleKey: r
													}), h.logger.log("Crypto: loading device list..."), yield this.deviceList.load(), this.deviceKeys["ed25519:" + this.deviceId] = this.olmDevice.deviceEd25519Key, this.deviceKeys["curve25519:" + this.deviceId] = this.olmDevice.deviceCurve25519Key, h.logger.log("Crypto: fetching own devices...");
													let n = this.deviceList.getRawStoredDevicesForUser(this.userId);
													if (n || (n = {}), !n[this.deviceId]) {
														h.logger.log("Crypto: adding this device to the store...");
														const e = {
															keys: this.deviceKeys,
															algorithms: this.supportedAlgorithms,
															verified: F.VERIFIED,
															known: !0
														};
														n[this.deviceId] = e, this.deviceList.storeDevicesForUser(this.userId, n), this.deviceList.saveIfDirty()
													}
													yield this.cryptoStore.doTxn("readonly", [S.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
														this.cryptoStore.getCrossSigningKeys(e, e => {
															e && 0 !== Object.keys(e).length && (h.logger.log("Loaded cross-signing public keys from crypto store"), this.crossSigningInfo.setKeys(e))
														})
													}), this.deviceList.startTrackingDeviceList(this.userId), h.logger.log("Crypto: checking for key backup..."), this.backupManager.checkAndStart()
												}))
											}
											getCryptoTrustCrossSignedDevices() {
												return this.trustCrossSignedDevices
											}
											setCryptoTrustCrossSignedDevices(e) {
												this.trustCrossSignedDevices = e;
												for (const t of this.deviceList.getKnownUserIds()) {
													const e = this.deviceList.getRawStoredDevicesForUser(t);
													for (const r of Object.keys(e)) {
														const e = this.checkDeviceTrust(t, r);
														if (!e.isLocallyVerified() && e.isCrossSigningVerified()) {
															const e = this.deviceList.getStoredDevice(t, r);
															this.emit(K.DeviceVerificationChanged, t, r, e)
														}
													}
												}
											}
											createRecoveryKeyFromPassphrase(t) {
												return a(this, void 0, void 0, (function*() {
													const r = new e.Olm.PkDecryption;
													try {
														const e = {};
														if (t) {
															const n = yield(0, T.keyFromPassphrase)(t);
															e.passphrase = {
																algorithm: "m.pbkdf2",
																iterations: n.iterations,
																salt: n.salt
															}, e.pubkey = r.init_with_private_key(n.key)
														} else e.pubkey = r.generate_key();
														const n = r.get_private_key();
														return {
															keyInfo: e,
															encodedPrivateKey: (0, I.encodeRecoveryKey)(n),
															privateKey: n
														}
													} finally {
														null == r || r.free()
													}
												}))
											}
											isCrossSigningReady() {
												return a(this, void 0, void 0, (function*() {
													const e = this.crossSigningInfo.getId(),
														t = (yield this.crossSigningInfo.isStoredInKeyCache()) || (yield this.crossSigningInfo.isStoredInSecretStorage(this.secretStorage));
													return !(!e || !t)
												}))
											}
											isSecretStorageReady() {
												return a(this, void 0, void 0, (function*() {
													const e = yield this.secretStorage.hasKey(), t = yield this.crossSigningInfo.isStoredInSecretStorage(this.secretStorage), r = !this.backupManager.getKeyBackupEnabled() || (yield this.baseApis.isKeyBackupKeyStored());
													return !!(e && t && r)
												}))
											}
											bootstrapCrossSigning({
												authUploadDeviceSigningKeys: e,
												setupNewCrossSigning: t
											} = {}) {
												return a(this, void 0, void 0, (function*() {
													h.logger.log("Bootstrapping cross-signing");
													const r = this.baseApis.cryptoCallbacks,
														n = new b.EncryptionSetupBuilder(this.baseApis.store.accountData, r),
														i = new y.CrossSigningInfo(this.userId, n.crossSigningCallbacks, n.crossSigningCallbacks),
														o = () => a(this, void 0, void 0, (function*() {
															i.resetKeys(), yield this.signObject(i.keys.master), n.addCrossSigningKeys(e, i.keys);
															const t = this.deviceList.getStoredDevice(this.userId, this.deviceId),
																r = yield i.signDevice(this.userId, t);
															n.addKeySignature(this.userId, this.deviceId, r), this.backupManager.backupInfo && (yield i.signObject(this.backupManager.backupInfo.auth_data, "master"), n.addSessionBackup(this.backupManager.backupInfo))
														})),
														s = this.crossSigningInfo.getId(),
														c = yield this.crossSigningInfo.isStoredInKeyCache(), l = yield this.crossSigningInfo.isStoredInSecretStorage(this.secretStorage), u = c || l;
													h.logger.log({
														setupNewCrossSigning: t,
														publicKeysOnDevice: s,
														privateKeysInCache: c,
														privateKeysInStorage: l,
														privateKeysExistSomewhere: u
													}), !u || t ? (h.logger.log("Cross-signing private keys not found locally or in secret storage, creating new keys"), yield o()) : s && c ? h.logger.log("Cross-signing public keys trusted and private keys found locally") : l && (h.logger.log("Cross-signing private keys not found locally, but they are available in secret storage, reading storage and caching locally"), yield this.checkOwnCrossSigningTrust({
														allowPrivateKeyRequests: !0
													}));
													const d = n.crossSigningCallbacks.privateKeys;
													if (d.size && !this.baseApis.cryptoCallbacks.saveCrossSigningKeys) {
														const e = new _.SecretStorage(n.accountDataClientAdapter, n.ssssCryptoCallbacks, void 0);
														(yield e.hasKey()) && (h.logger.log("Storing new cross-signing private keys in secret storage"), yield y.CrossSigningInfo.storeInSecretStorage(d, e))
													}
													const f = n.buildOperation();
													yield f.apply(this), yield n.persist(this), h.logger.log("Cross-signing ready")
												}))
											}
											bootstrapSecretStorage({
												createSecretStorageKey: e = (() => a(this, void 0, void 0, (function*() {
													return {}
												}))),
												keyBackupInfo: t,
												setupNewKeyBackup: r,
												setupNewSecretStorage: n,
												getKeyBackupPassphrase: i
											} = {}) {
												return a(this, void 0, void 0, (function*() {
													h.logger.log("Bootstrapping Secure Secret Storage");
													const o = this.baseApis.cryptoCallbacks,
														s = new b.EncryptionSetupBuilder(this.baseApis.store.accountData, o),
														c = new _.SecretStorage(s.accountDataClientAdapter, s.ssssCryptoCallbacks, void 0);
													let l = null;
													const u = (e, t) => a(this, void 0, void 0, (function*() {
															t && (e.key = t);
															const {
																keyId: r,
																keyInfo: n
															} = yield c.addKey(_.SECRET_STORAGE_ALGORITHM_V1_AES, e);
															return t && s.ssssCryptoCallbacks.addPrivateKey(r, n, t), yield c.setDefaultKeyId(r), r
														})),
														d = (e, t) => a(this, void 0, void 0, (function*() {
															var r, n;
															if (!t.mac) {
																const i = yield null === (n = (r = this.baseApis.cryptoCallbacks).getSecretStorageKey) || void 0 === n ? void 0 : n.call(r, {
																	keys: {
																		[e]: t
																	}
																}, "");
																if (i) {
																	const r = i[1];
																	s.ssssCryptoCallbacks.addPrivateKey(e, t, r);
																	const {
																		iv: n,
																		mac: o
																	} = yield(0, A.calculateKeyCheck)(r);
																	t.iv = n, t.mac = o, yield s.setAccountData(`m.secret_storage.key.${e}`, t)
																}
															}
														})),
														f = e => a(this, void 0, void 0, (function*() {
															if (this.crossSigningInfo.getId() && (yield this.crossSigningInfo.isStoredInKeyCache("master"))) try {
																h.logger.log("Adding cross-signing signature to key backup"), yield this.crossSigningInfo.signObject(e, "master")
															} catch (t) {
																h.logger.error("Signing key backup with cross-signing keys failed", t)
															} else h.logger.warn("Cross-signing keys not available, skipping signature on key backup")
														})),
														v = yield this.getSecretStorageKey(), [g, m] = v || [null, null], w = !n && m && m.algorithm === _.SECRET_STORAGE_ALGORITHM_V1_AES;
													if (h.logger.log({
															keyBackupInfo: t,
															setupNewKeyBackup: r,
															setupNewSecretStorage: n,
															storageExists: w,
															oldKeyInfo: m
														}), w || t)
														if (!w && t) {
															h.logger.log("Secret storage does not exist, using key backup key");
															const e = (yield this.getSessionBackupPrivateKey()) || (yield null == i ? void 0 : i()),
																r = {};
															t.auth_data.private_key_salt && t.auth_data.private_key_iterations && (r.passphrase = {
																algorithm: "m.pbkdf2",
																iterations: t.auth_data.private_key_iterations,
																salt: t.auth_data.private_key_salt,
																bits: 256
															}), l = yield u(r, e), yield c.store("m.megolm_backup.v1", p.encodeBase64(e), [l]), yield f(t.auth_data), s.addSessionBackup(t)
														} else h.logger.log("Secret storage exists"), m && m.algorithm === _.SECRET_STORAGE_ALGORITHM_V1_AES && (yield d(g, m));
													else {
														h.logger.log("Secret storage does not exist, creating new storage key");
														const {
															keyInfo: t = {},
															privateKey: r
														} = yield e();
														l = yield u(t, r)
													}
													if (!this.baseApis.cryptoCallbacks.saveCrossSigningKeys && (yield this.isCrossSigningReady()) && (l || !(yield this.crossSigningInfo.isStoredInSecretStorage(c)))) {
														h.logger.log("Copying cross-signing private keys from cache to secret storage");
														const e = yield this.crossSigningInfo.getCrossSigningKeysFromCache();
														yield y.CrossSigningInfo.storeInSecretStorage(e, c)
													}
													if (r && !t) {
														h.logger.log("Creating new message key backup version");
														const e = yield this.baseApis.prepareKeyBackupVersion(null, {
															secureSecretStorage: !1
														}), t = (0, I.decodeRecoveryKey)(e.recovery_key);
														yield c.store("m.megolm_backup.v1", p.encodeBase64(t));
														const r = {
															algorithm: e.algorithm,
															auth_data: e.auth_data
														};
														yield f(r.auth_data), yield this.signObject(r.auth_data), s.addSessionBackup(r)
													}
													const S = yield c.get("m.megolm_backup.v1");
													if (S) {
														h.logger.info("Got session backup key from secret storage: caching");
														const e = z(S);
														if (e) {
															const t = l || g;
															yield c.store("m.megolm_backup.v1", e, t ? [t] : null)
														}
														const t = new Uint8Array(p.decodeBase64(e || S));
														s.addSessionBackupPrivateKeyToCache(t)
													} else if (this.backupManager.getKeyBackupEnabled()) {
														const e = (yield this.getSessionBackupPrivateKey()) || (yield null == i ? void 0 : i());
														if (!e) return void h.logger.error("Key backup is enabled but couldn't get key backup key!");
														h.logger.info("Got session backup key from cache/user that wasn't in SSSS: saving to SSSS"), yield c.store("m.megolm_backup.v1", p.encodeBase64(e))
													}
													const E = s.buildOperation();
													yield E.apply(this), yield s.persist(this), h.logger.log("Secure Secret Storage ready")
												}))
											}
											addSecretStorageKey(e, t, r) {
												return this.secretStorage.addKey(e, t, r)
											}
											hasSecretStorageKey(e) {
												return this.secretStorage.hasKey(e)
											}
											getSecretStorageKey(e) {
												return this.secretStorage.getKey(e)
											}
											storeSecret(e, t, r) {
												return this.secretStorage.store(e, t, r)
											}
											getSecret(e) {
												return this.secretStorage.get(e)
											}
											isSecretStored(e) {
												return this.secretStorage.isStored(e)
											}
											requestSecret(e, t) {
												return t || (t = Object.keys(this.deviceList.getRawStoredDevicesForUser(this.userId))), this.secretStorage.request(e, t)
											}
											getDefaultSecretStorageKeyId() {
												return this.secretStorage.getDefaultKeyId()
											}
											setDefaultSecretStorageKeyId(e) {
												return this.secretStorage.setDefaultKeyId(e)
											}
											checkSecretStorageKey(e, t) {
												return this.secretStorage.checkKey(e, t)
											}
											checkSecretStoragePrivateKey(t, r) {
												let n = null;
												try {
													return (n = new e.Olm.PkDecryption).init_with_private_key(t) === r
												} finally {
													null == n || n.free()
												}
											}
											getSessionBackupPrivateKey() {
												return a(this, void 0, void 0, (function*() {
													let e = yield new Promise(e => {
														this.cryptoStore.doTxn("readonly", [S.IndexedDBCryptoStore.STORE_ACCOUNT], t => {
															this.cryptoStore.getSecretStorePrivateKey(t, e, "m.megolm_backup.v1")
														})
													});
													if (e && "string" == typeof e && (e = new Uint8Array(p.decodeBase64(z(e) || e)), yield this.storeSessionBackupPrivateKey(e)), e && e.ciphertext) {
														const t = r.from(this.olmDevice.pickleKey),
															n = yield(0, A.decryptAES)(e, t, "m.megolm_backup.v1");
														e = p.decodeBase64(n)
													}
													return e
												}))
											}
											storeSessionBackupPrivateKey(e) {
												return a(this, void 0, void 0, (function*() {
													if (!(e instanceof Uint8Array)) throw new Error(`storeSessionBackupPrivateKey expects Uint8Array, got ${e}`);
													const t = r.from(this.olmDevice.pickleKey),
														n = yield(0, A.encryptAES)(p.encodeBase64(e), t, "m.megolm_backup.v1");
													return this.cryptoStore.doTxn("readwrite", [S.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
														this.cryptoStore.storeSecretStorePrivateKey(e, "m.megolm_backup.v1", n)
													})
												}))
											}
											checkCrossSigningPrivateKey(t, r) {
												let n = null;
												try {
													return (n = new e.Olm.PkSigning).init_with_seed(t) === r
												} finally {
													null == n || n.free()
												}
											}
											afterCrossSigningLocalKeyChange() {
												return a(this, void 0, void 0, (function*() {
													h.logger.info("Starting cross-signing key change post-processing");
													const e = this.deviceList.getStoredDevice(this.userId, this.deviceId),
														t = yield this.crossSigningInfo.signDevice(this.userId, e);
													h.logger.info(`Starting background key sig upload for ${this.deviceId}`);
													const r = ({
														shouldEmit: e = !1
													}) => this.baseApis.uploadKeySignatures({
														[this.userId]: {
															[this.deviceId]: t
														}
													}).then(t => {
														const {
															failures: n
														} = t || {};
														if (Object.keys(n || []).length > 0) throw e && this.baseApis.emit(K.KeySignatureUploadFailure, n, "afterCrossSigningLocalKeyChange", r), new O.KeySignatureUploadError("Key upload failed", {
															failures: n
														});
														h.logger.info(`Finished background key sig upload for ${this.deviceId}`)
													}).catch(e => {
														h.logger.error(`Error during background key sig upload for ${this.deviceId}`, e)
													});
													r({
														shouldEmit: !0
													});
													const n = this.baseApis.cryptoCallbacks.shouldUpgradeDeviceVerifications;
													if (n) {
														h.logger.info("Starting device verification upgrade");
														const e = {};
														for (const [t, r] of Object.entries(this.deviceList.crossSigningInfo)) {
															const n = yield this.checkForDeviceVerificationUpgrade(t, y.CrossSigningInfo.fromStorage(r, t));
															n && (e[t] = n)
														}
														if (Object.keys(e).length > 0) {
															h.logger.info(`Found ${Object.keys(e).length} verif users to upgrade`);
															try {
																const t = yield n({
																	users: e
																});
																if (t)
																	for (const r of t) r in e && (yield this.baseApis.setDeviceVerified(r, e[r].crossSigningInfo.getId()))
															} catch (i) {
																h.logger.log("shouldUpgradeDeviceVerifications threw an error: not upgrading", i)
															}
														}
														h.logger.info("Finished device verification upgrade")
													}
													h.logger.info("Finished cross-signing key change post-processing")
												}))
											}
											checkForDeviceVerificationUpgrade(e, t) {
												return a(this, void 0, void 0, (function*() {
													const r = this.crossSigningInfo.checkUserTrust(t);
													if (t.firstUse && !r.isVerified()) {
														const r = this.deviceList.getRawStoredDevicesForUser(e),
															n = yield this.checkForValidDeviceSignature(e, t.keys.master, r);
														if (n.length) return {
															devices: n.map(e => g.DeviceInfo.fromStorage(r[e], e)),
															crossSigningInfo: t
														}
													}
												}))
											}
											checkForValidDeviceSignature(e, t, r) {
												return a(this, void 0, void 0, (function*() {
													const n = [];
													if (r && t.signatures && t.signatures[e])
														for (const o of Object.keys(t.signatures[e])) {
															const [, s] = o.split(":", 2);
															if (s in r && r[s].verified === F.VERIFIED) try {
																yield p.verifySignature(this.olmDevice, t, e, s, r[s].keys[o]), n.push(s)
															} catch (i) {}
														}
													return n
												}))
											}
											getCrossSigningId(e) {
												return this.crossSigningInfo.getId(e)
											}
											getStoredCrossSigningForUser(e) {
												return this.deviceList.getStoredCrossSigningForUser(e)
											}
											checkUserTrust(e) {
												const t = this.deviceList.getStoredCrossSigningForUser(e);
												return t ? this.crossSigningInfo.checkUserTrust(t) : new y.UserTrustLevel(!1, !1, !1)
											}
											checkDeviceTrust(e, t) {
												const r = this.deviceList.getStoredDevice(e, t);
												return this.checkDeviceInfoTrust(e, r)
											}
											checkDeviceInfoTrust(e, t) {
												const r = !!(null == t ? void 0 : t.isVerified()),
													n = this.deviceList.getStoredCrossSigningForUser(e);
												if (t && n) {
													const i = this.trustCrossSignedDevices || e === this.userId;
													return this.crossSigningInfo.checkDeviceTrust(n, t, r, i)
												}
												return new y.DeviceTrustLevel(!1, !1, r, !1)
											}
											checkIfOwnDeviceCrossSigned(e) {
												var t;
												const r = this.deviceList.getStoredDevice(this.userId, e);
												if (!r) return !1;
												const n = this.deviceList.getStoredCrossSigningForUser(this.userId);
												return null !== (t = null == n ? void 0 : n.checkDeviceTrust(n, r, !1, !0).isCrossSigningVerified()) && void 0 !== t && t
											}
											checkOwnCrossSigningTrust({
												allowPrivateKeyRequests: e = !1
											} = {}) {
												return a(this, void 0, void 0, (function*() {
													const t = this.userId;
													yield this.downloadKeys([this.userId]);
													const r = yield this.crossSigningInfo.getCrossSigningKeysFromCache(), n = this.deviceList.getStoredCrossSigningForUser(t);
													if (!n) return void h.logger.error("Got cross-signing update event for user " + t + " but no new cross-signing information found!");
													const i = n.getId(),
														o = this.crossSigningInfo.getId() !== i,
														s = n.getId() && !r.has("master");
													if (o && h.logger.info("Got new master public key", i), e && (o || s)) {
														h.logger.info("Attempting to retrieve cross-signing master private key");
														let e = null;
														try {
															e = (yield this.crossSigningInfo.getCrossSigningKey("master", i))[1], h.logger.info("Got cross-signing master private key")
														} finally {
															null == e || e.free()
														}
													}
													const a = this.crossSigningInfo.getId("self_signing"),
														c = this.crossSigningInfo.getId("user_signing");
													this.storeTrustedSelfKeys(n.keys);
													const l = a !== n.getId("self_signing"),
														u = c !== n.getId("user_signing"),
														d = n.getId("self_signing") && !r.has("self_signing"),
														f = n.getId("user_signing") && !r.has("user_signing"),
														p = {};
													if (l && h.logger.info("Got new self-signing key", n.getId("self_signing")), e && (l || d)) {
														h.logger.info("Attempting to retrieve cross-signing self-signing private key");
														let e = null;
														try {
															e = (yield this.crossSigningInfo.getCrossSigningKey("self_signing", n.getId("self_signing")))[1], h.logger.info("Got cross-signing self-signing private key")
														} finally {
															null == e || e.free()
														}
														const t = this.deviceList.getStoredDevice(this.userId, this.deviceId),
															r = yield this.crossSigningInfo.signDevice(this.userId, t);
														p[this.deviceId] = r
													}
													if (u && h.logger.info("Got new user-signing key", n.getId("user_signing")), e && (u || f)) {
														h.logger.info("Attempting to retrieve cross-signing user-signing private key");
														let e = null;
														try {
															e = (yield this.crossSigningInfo.getCrossSigningKey("user_signing", n.getId("user_signing")))[1], h.logger.info("Got cross-signing user-signing private key")
														} finally {
															null == e || e.free()
														}
													}
													if (o) {
														const e = this.crossSigningInfo.keys.master;
														yield this.signObject(e);
														const t = e.signatures[this.userId]["ed25519:" + this.deviceId];
														p[this.crossSigningInfo.getId()] = Object.assign({}, e, {
															signatures: {
																[this.userId]: {
																	["ed25519:" + this.deviceId]: t
																}
															}
														})
													}
													const v = Object.keys(p);
													if (v.length) {
														const e = ({
															shouldEmit: t = !1
														}) => (h.logger.info(`Starting background key sig upload for ${v}`), this.baseApis.uploadKeySignatures({
															[this.userId]: p
														}).then(r => {
															const {
																failures: n
															} = r || {};
															if (h.logger.info(`Finished background key sig upload for ${v}`), Object.keys(n || []).length > 0) throw t && this.baseApis.emit(K.KeySignatureUploadFailure, n, "checkOwnCrossSigningTrust", e), new O.KeySignatureUploadError("Key upload failed", {
																failures: n
															})
														}).catch(e => {
															h.logger.error(`Error during background key sig upload for ${v}`, e)
														}));
														e({
															shouldEmit: !0
														})
													}
													this.emit(K.UserTrustStatusChanged, t, this.checkUserTrust(t)), o && (this.emit(K.KeysChanged, {}), yield this.afterCrossSigningLocalKeyChange()), yield this.backupManager.checkKeyBackup()
												}))
											}
											storeTrustedSelfKeys(e) {
												return a(this, void 0, void 0, (function*() {
													e ? this.crossSigningInfo.setKeys(e) : this.crossSigningInfo.clearKeys(), yield this.cryptoStore.doTxn("readwrite", [S.IndexedDBCryptoStore.STORE_ACCOUNT], e => {
														this.cryptoStore.storeCrossSigningKeys(e, this.crossSigningInfo.keys)
													})
												}))
											}
											checkDeviceVerifications(e) {
												return a(this, void 0, void 0, (function*() {
													const t = this.baseApis.cryptoCallbacks.shouldUpgradeDeviceVerifications;
													if (t) {
														if (h.logger.info(`Starting device verification upgrade for ${e}`), this.crossSigningInfo.keys.user_signing) {
															const r = this.deviceList.getStoredCrossSigningForUser(e);
															if (r) {
																const n = yield this.checkForDeviceVerificationUpgrade(e, r);
																if (n) {
																	(yield t({
																		users: {
																			[e]: n
																		}
																	})).includes(e) && (yield this.baseApis.setDeviceVerified(e, r.getId()))
																}
															}
														}
														h.logger.info(`Finished device verification upgrade for ${e}`)
													}
												}))
											}
											enableLazyLoading() {
												this.lazyLoadMembers = !0
											}
											registerEventHandlers(e) {
												e.on(L.RoomMemberEvent.Membership, this.onMembership), e.on(B.ClientEvent.ToDeviceEvent, this.onToDeviceEvent), e.on(j.RoomEvent.Timeline, this.onTimelineEvent), e.on(N.MatrixEventEvent.Decrypted, this.onTimelineEvent)
											}
											start() {
												h.logger.warn("MatrixClient.crypto.start() is deprecated")
											}
											stop() {
												this.outgoingRoomKeyRequestManager.stop(), this.deviceList.stop(), this.dehydrationManager.stop()
											}
											getDeviceEd25519Key() {
												return this.olmDevice.deviceEd25519Key
											}
											getDeviceCurve25519Key() {
												return this.olmDevice.deviceCurve25519Key
											}
											setGlobalBlacklistUnverifiedDevices(e) {
												this.globalBlacklistUnverifiedDevices = e
											}
											getGlobalBlacklistUnverifiedDevices() {
												return this.globalBlacklistUnverifiedDevices
											}
											uploadDeviceKeys() {
												const e = {
													algorithms: this.supportedAlgorithms,
													device_id: this.deviceId,
													keys: this.deviceKeys,
													user_id: this.userId
												};
												return this.signObject(e).then(() => this.baseApis.uploadKeysRequest({
													device_keys: e
												}))
											}
											updateOneTimeKeyCount(e) {
												if (!isFinite(e)) throw new TypeError("Parameter for updateOneTimeKeyCount has to be a number");
												this.oneTimeKeyCount = e
											}
											setNeedsNewFallback(e) {
												this.needsNewFallback = e
											}
											getNeedsNewFallback() {
												return !!this.needsNewFallback
											}
											maybeUploadOneTimeKeys() {
												if (this.oneTimeKeyCheckInProgress) return;
												const e = Date.now();
												if (null !== this.lastOneTimeKeyCheck && e - this.lastOneTimeKeyCheck < 6e4) return;
												this.lastOneTimeKeyCheck = e;
												const t = this.olmDevice.maxNumberOfOneTimeKeys(),
													r = Math.floor(t / 2),
													n = e => a(this, void 0, void 0, (function*() {
														for (; r > e || this.getNeedsNewFallback();) {
															if (r > e) {
																h.logger.info("generating oneTimeKeys");
																const t = Math.min(r - e, 5);
																yield this.olmDevice.generateOneTimeKeys(t)
															}
															if (this.getNeedsNewFallback()) {
																const e = yield this.olmDevice.getFallbackKey();
																e.curve25519 && 0 != Object.keys(e.curve25519).length || (h.logger.info("generating fallback key"), this.fallbackCleanup && (clearTimeout(this.fallbackCleanup), delete this.fallbackCleanup), yield this.olmDevice.generateFallbackKey())
															}
															h.logger.info("calling uploadOneTimeKeys");
															const t = yield this.uploadOneTimeKeys();
															if (!t.one_time_key_counts || !t.one_time_key_counts.signed_curve25519) throw new Error("response for uploading keys does not contain one_time_key_counts.signed_curve25519");
															e = t.one_time_key_counts.signed_curve25519
														}
													}));
												this.oneTimeKeyCheckInProgress = !0, Promise.resolve().then(() => void 0 !== this.oneTimeKeyCount ? Promise.resolve(this.oneTimeKeyCount) : this.baseApis.uploadKeysRequest({}).then(e => e.one_time_key_counts.signed_curve25519 || 0)).then(e => n(e)).catch(e => {
													h.logger.error("Error uploading one-time keys", e.stack || e)
												}).finally(() => {
													this.oneTimeKeyCount = void 0, this.oneTimeKeyCheckInProgress = !1
												})
											}
											uploadOneTimeKeys() {
												return a(this, void 0, void 0, (function*() {
													const e = [];
													let t;
													if (this.getNeedsNewFallback()) {
														t = {};
														const r = yield this.olmDevice.getFallbackKey();
														for (const [n, i] of Object.entries(r.curve25519)) {
															const r = {
																key: i,
																fallback: !0
															};
															t["signed_curve25519:" + n] = r, e.push(this.signObject(r))
														}
														this.setNeedsNewFallback(!1)
													}
													const r = yield this.olmDevice.getOneTimeKeys(), n = {};
													for (const s in r.curve25519)
														if (r.curve25519.hasOwnProperty(s)) {
															const t = {
																key: r.curve25519[s]
															};
															n["signed_curve25519:" + s] = t, e.push(this.signObject(t))
														} yield Promise.all(e);
													const i = {
														one_time_keys: n
													};
													t && (i["org.matrix.msc2732.fallback_keys"] = t, i.fallback_keys = t);
													const o = yield this.baseApis.uploadKeysRequest(i);
													return t && (this.fallbackCleanup = setTimeout(() => {
														delete this.fallbackCleanup, this.olmDevice.forgetOldFallbackKey()
													}, 36e5)), yield this.olmDevice.markKeysAsPublished(), o
												}))
											}
											downloadKeys(e, t) {
												return this.deviceList.downloadKeys(e, !!t)
											}
											getStoredDevicesForUser(e) {
												return this.deviceList.getStoredDevicesForUser(e)
											}
											getStoredDevice(e, t) {
												return this.deviceList.getStoredDevice(e, t)
											}
											saveDeviceList(e) {
												return this.deviceList.saveIfDirty(e)
											}
											setDeviceVerification(e, t, r = null, n = null, i = null, o) {
												return a(this, void 0, void 0, (function*() {
													const s = this.deviceList.getStoredCrossSigningForUser(e);
													if (s && s.getId() === t) {
														if (null !== n || null !== i) throw new Error("Cannot set blocked or known for a cross-signing key");
														if (!r) throw new Error("Cannot set a cross-signing key as unverified");
														const c = o ? Object.values(o)[0] : null;
														if (o && (1 !== Object.values(o).length || c !== s.getId())) throw new Error(`Key did not match expected value: expected ${s.getId()}, got ${c}`);
														if (this.crossSigningInfo.getId() || e !== this.crossSigningInfo.userId || (this.storeTrustedSelfKeys(s.keys), this.emit(K.UserTrustStatusChanged, this.userId, this.checkUserTrust(e))), e !== this.userId) {
															h.logger.info("Master key " + s.getId() + " for " + e + " marked verified. Signing...");
															const r = yield this.crossSigningInfo.signUser(s);
															if (r) {
																const n = ({
																	shouldEmit: i = !1
																}) => a(this, void 0, void 0, (function*() {
																	h.logger.info("Uploading signature for " + e + "...");
																	const o = yield this.baseApis.uploadKeySignatures({
																		[e]: {
																			[t]: r
																		}
																	}), {
																		failures: s
																	} = o || {};
																	if (Object.keys(s || []).length > 0) throw i && this.baseApis.emit(K.KeySignatureUploadFailure, s, "setDeviceVerification", n), new O.KeySignatureUploadError("Key upload failed", {
																		failures: s
																	})
																}));
																yield n({
																	shouldEmit: !0
																})
															}
															return r
														}
														return s
													}
													const c = this.deviceList.getRawStoredDevicesForUser(e);
													if (!c || !c[t]) throw new Error("Unknown device " + e + ":" + t);
													const l = c[t];
													let u = l.verified;
													if (r) {
														if (o)
															for (const [e, t] of Object.entries(o))
																if (l.keys[e] !== t) throw new Error(`Key did not match expected value: expected ${t}, got ${l.keys[e]}`);
														u = F.VERIFIED
													} else null !== r && u == F.VERIFIED && (u = F.UNVERIFIED);
													n ? u = F.BLOCKED : null !== n && u == F.BLOCKED && (u = F.UNVERIFIED);
													let d = l.known;
													if (null !== i && (d = i), l.verified === u && l.known === d || (l.verified = u, l.known = d, this.deviceList.storeDevicesForUser(e, c), this.deviceList.saveIfDirty()), r && e === this.userId) {
														let r;
														if (h.logger.info("Own device " + t + " marked verified: signing"), this.checkDeviceTrust(e, t).isCrossSigningVerified() ? h.logger.log(`Own device ${t} already cross-signing verified`) : r = yield this.crossSigningInfo.signDevice(e, g.DeviceInfo.fromStorage(l, t)), r) {
															const n = ({
																shouldEmit: i = !1
															}) => a(this, void 0, void 0, (function*() {
																h.logger.info("Uploading signature for " + t);
																const o = yield this.baseApis.uploadKeySignatures({
																	[e]: {
																		[t]: r
																	}
																}), {
																	failures: s
																} = o || {};
																if (Object.keys(s || []).length > 0) throw i && this.baseApis.emit(K.KeySignatureUploadFailure, s, "setDeviceVerification", n), new O.KeySignatureUploadError("Key upload failed", {
																	failures: s
																})
															}));
															yield n({
																shouldEmit: !0
															})
														}
													}
													const f = g.DeviceInfo.fromStorage(l, t);
													return this.emit(K.DeviceVerificationChanged, e, t, f), f
												}))
											}
											findVerificationRequestDMInProgress(e) {
												return this.inRoomVerificationRequests.findRequestInProgress(e)
											}
											getVerificationRequestsToDeviceInProgress(e) {
												return this.toDeviceVerificationRequests.getRequestsInProgress(e)
											}
											requestVerificationDM(e, t) {
												const r = this.inRoomVerificationRequests.findRequestInProgress(t);
												if (r) return Promise.resolve(r);
												const n = new C.InRoomChannel(this.baseApis, t, e);
												return this.requestVerificationWithChannel(e, n, this.inRoomVerificationRequests)
											}
											requestVerification(e, t) {
												t || (t = Object.keys(this.deviceList.getRawStoredDevicesForUser(e)));
												const r = this.toDeviceVerificationRequests.findRequestInProgress(e, t);
												if (r) return Promise.resolve(r);
												const n = new M.ToDeviceChannel(this.baseApis, e, t, M.ToDeviceChannel.makeTransactionId());
												return this.requestVerificationWithChannel(e, n, this.toDeviceVerificationRequests)
											}
											requestVerificationWithChannel(e, t, r) {
												return a(this, void 0, void 0, (function*() {
													let e = new R.VerificationRequest(t, this.verificationMethods, this.baseApis);
													t.transactionId && r.setRequestByChannel(t, e), yield e.sendRequest();
													const n = r.getRequestByChannel(t);
													return n ? e = n : (h.logger.log("Crypto: adding new request to " + `requestsByTxnId with id ${t.transactionId} ${t.roomId}`), r.setRequestByChannel(t, e)), e
												}))
											}
											beginKeyVerification(e, t, r, n = null) {
												let i;
												if (n) {
													if (!(i = this.toDeviceVerificationRequests.getRequestBySenderAndTxnId(t, n))) throw new Error(`No request found for user ${t} with ` + `transactionId ${n}`)
												} else {
													n = M.ToDeviceChannel.makeTransactionId();
													const e = new M.ToDeviceChannel(this.baseApis, t, [r], n, r);
													i = new R.VerificationRequest(e, this.verificationMethods, this.baseApis), this.toDeviceVerificationRequests.setRequestBySenderAndTxnId(t, n, i)
												}
												return i.beginKeyVerification(e, {
													userId: t,
													deviceId: r
												})
											}
											legacyDeviceVerification(e, t, r) {
												return a(this, void 0, void 0, (function*() {
													const n = M.ToDeviceChannel.makeTransactionId(),
														i = new M.ToDeviceChannel(this.baseApis, e, [t], n, t),
														o = new R.VerificationRequest(i, this.verificationMethods, this.baseApis);
													this.toDeviceVerificationRequests.setRequestBySenderAndTxnId(e, n, o);
													const s = o.beginKeyVerification(r, {
														userId: e,
														deviceId: t
													});
													return yield Promise.race([s.verify(), o.waitFor(e => e.started)]), o
												}))
											}
											getOlmSessionsForUser(e) {
												return a(this, void 0, void 0, (function*() {
													const t = this.getStoredDevicesForUser(e) || [],
														r = {};
													for (const e of t) {
														const t = e.getIdentityKey(),
															n = yield this.olmDevice.getSessionInfoForDevice(t);
														r[e.deviceId] = {
															deviceIdKey: t,
															sessions: n
														}
													}
													return r
												}))
											}
											getEventSenderDeviceInfo(e) {
												const t = e.getSenderKey(),
													r = e.getWireContent().algorithm;
												if (!t || !r) return null;
												if (e.isKeySourceUntrusted()) return null;
												const n = this.deviceList.getDeviceByIdentityKey(r, t);
												if (null === n) return null;
												const i = e.getClaimedEd25519Key();
												return i ? i !== n.getFingerprint() ? (h.logger.warn("Event " + e.getId() + " claims ed25519 key " + i + " but sender device has key " + n.getFingerprint()), null) : n : (h.logger.warn("Event " + e.getId() + " claims no ed25519 key: cannot verify sending device"), null)
											}
											getEventEncryptionInfo(e) {
												var t, r;
												const n = {};
												if (n.senderKey = null !== (t = e.getSenderKey()) && void 0 !== t ? t : void 0, n.algorithm = e.getWireContent().algorithm, !n.senderKey || !n.algorithm) return n.encrypted = !1, n;
												n.encrypted = !0, e.isKeySourceUntrusted() ? n.authenticated = !1 : n.authenticated = !0, n.sender = null !== (r = this.deviceList.getDeviceByIdentityKey(n.algorithm, n.senderKey)) && void 0 !== r ? r : void 0;
												const i = e.getClaimedEd25519Key();
												return i || (h.logger.warn("Event " + e.getId() + " claims no ed25519 key: cannot verify sending device"), n.mismatchedSender = !0), n.sender && i !== n.sender.getFingerprint() && (h.logger.warn("Event " + e.getId() + " claims ed25519 key " + i + "but sender device has key " + n.sender.getFingerprint()), n.mismatchedSender = !0), n
											}
											forceDiscardSession(e) {
												const t = this.roomEncryptors.get(e);
												if (void 0 === t) throw new Error("Room not encrypted");
												if (void 0 === t.forceDiscardSession) throw new Error("Room encryption algorithm doesn't support session discarding");
												t.forceDiscardSession()
											}
											setRoomEncryption(e, t, r) {
												return a(this, void 0, void 0, (function*() {
													if (!t.algorithm) return void h.logger.log("Ignoring setRoomEncryption with no algorithm");
													const n = this.roomList.getRoomEncryption(e);
													if (n && JSON.stringify(n) != JSON.stringify(t)) return void h.logger.error("Ignoring m.room.encryption event which requests a change of config in " + e);
													if (this.roomEncryptors.get(e)) return;
													let i = null;
													n || (i = this.roomList.setRoomEncryption(e, t));
													const o = m.ENCRYPTION_CLASSES.get(t.algorithm);
													if (!o) throw new Error("Unable to encrypt with " + t.algorithm);
													const s = new o({
														userId: this.userId,
														deviceId: this.deviceId,
														crypto: this,
														olmDevice: this.olmDevice,
														baseApis: this.baseApis,
														roomId: e,
														config: t
													});
													this.roomEncryptors.set(e, s), i && (yield i), this.lazyLoadMembers ? h.logger.log("Enabling encryption in " + e) : (h.logger.log("Enabling encryption in " + e + "; starting to track device lists for all users therein"), yield this.trackRoomDevices(e), r || this.deviceList.refreshOutdatedDeviceLists())
												}))
											}
											trackRoomDevices(e) {
												const t = () => a(this, void 0, void 0, (function*() {
													if (!this.roomEncryptors.has(e)) return;
													const t = this.clientStore.getRoom(e);
													if (!t) throw new Error(`Unable to start tracking devices in unknown room ${e}`);
													h.logger.log(`Starting to track devices for room ${e} ...`), (yield t.getEncryptionTargetMembers()).forEach(e => {
														this.deviceList.startTrackingDeviceList(e.userId)
													})
												}));
												let r = this.roomDeviceTrackingState[e];
												return r || (r = t(), this.roomDeviceTrackingState[e] = r.catch(t => {
													throw delete this.roomDeviceTrackingState[e], t
												})), r
											}
											ensureOlmSessionsForUsers(e, t) {
												const r = {};
												for (const n of e) {
													r[n] = [];
													const e = this.getStoredDevicesForUser(n) || [];
													for (const t of e) {
														t.getIdentityKey() != this.olmDevice.deviceCurve25519Key && (t.verified != F.BLOCKED && r[n].push(t))
													}
												}
												return p.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, r, t)
											}
											exportRoomKeys() {
												return a(this, void 0, void 0, (function*() {
													const e = [];
													return yield this.cryptoStore.doTxn("readonly", [S.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS], t => {
														this.cryptoStore.getAllEndToEndInboundGroupSessions(t, t => {
															if (null === t) return;
															const r = this.olmDevice.exportInboundGroupSession(t.senderKey, t.sessionId, t.sessionData);
															delete r.first_known_index, r.algorithm = p.MEGOLM_ALGORITHM, e.push(r)
														})
													}), e
												}))
											}
											importRoomKeys(e, t = {}) {
												let r = 0,
													n = 0;
												const i = e.length;

												function o() {
													var e;
													null === (e = t.progressCallback) || void 0 === e || e.call(t, {
														stage: "load_keys",
														successes: r,
														failures: n,
														total: i
													})
												}
												return Promise.all(e.map(e => {
													if (!e.room_id || !e.algorithm) return h.logger.warn("ignoring room key entry with missing fields", e), n++, t.progressCallback && o(), null;
													return this.getRoomDecryptor(e.room_id, e.algorithm).importRoomKey(e, t).finally(() => {
														r++, t.progressCallback && o()
													})
												})).then()
											}
											countSessionsNeedingBackup() {
												return this.backupManager.countSessionsNeedingBackup()
											}
											prepareToEncrypt(e) {
												const t = this.roomEncryptors.get(e.roomId);
												t && t.prepareToEncrypt(e)
											}
											encryptEvent(e, t) {
												return a(this, void 0, void 0, (function*() {
													if (!t) throw new Error("Cannot send encrypted messages in unknown rooms");
													const r = e.getRoomId(),
														n = this.roomEncryptors.get(r);
													if (!n) throw new Error("Room was previously configured to use encryption, but is no longer. Perhaps the homeserver is hiding the configuration event.");
													this.roomDeviceTrackingState[r] || this.trackRoomDevices(r), yield this.roomDeviceTrackingState[r];
													let i = e.getContent();
													const o = i["m.relates_to"];
													o && delete(i = Object.assign({}, i))["m.relates_to"];
													const s = i["io.element.performance_metrics"];
													s && delete(i = Object.assign({}, i))["io.element.performance_metrics"];
													const a = yield n.encryptMessage(t, e.getType(), i);
													o && (a["m.relates_to"] = o), s && (a["io.element.performance_metrics"] = s), e.makeEncrypted("m.room.encrypted", a, this.olmDevice.deviceCurve25519Key, this.olmDevice.deviceEd25519Key)
												}))
											}
											decryptEvent(e) {
												return a(this, void 0, void 0, (function*() {
													if (e.isRedacted()) {
														const t = new N.MatrixEvent(Object.assign({
																room_id: e.getRoomId()
															}, e.getUnsigned().redacted_because)),
															r = yield this.decryptEvent(t);
														return {
															clearEvent: {
																room_id: e.getRoomId(),
																type: "m.room.message",
																content: {},
																unsigned: {
																	redacted_because: r.clearEvent
																}
															}
														}
													} {
														const t = e.getWireContent();
														return this.getRoomDecryptor(e.getRoomId(), t.algorithm).decryptEvent(e)
													}
												}))
											}
											handleDeviceListChanges(e, t) {
												return a(this, void 0, void 0, (function*() {
													e.oldSyncToken && (yield this.evalDeviceListChanges(t))
												}))
											}
											requestRoomKey(e, t, r = !1) {
												return this.outgoingRoomKeyRequestManager.queueRoomKeyRequest(e, t, r).then(() => {
													this.sendKeyRequestsImmediately && this.outgoingRoomKeyRequestManager.sendQueuedRequests()
												}).catch(e => {
													h.logger.error("Error requesting key for event", e)
												})
											}
											cancelRoomKeyRequest(e) {
												this.outgoingRoomKeyRequestManager.cancelRoomKeyRequest(e).catch(e => {
													h.logger.warn("Error clearing pending room key requests", e)
												})
											}
											cancelAndResendAllOutgoingKeyRequests() {
												return a(this, void 0, void 0, (function*() {
													yield this.outgoingRoomKeyRequestManager.cancelAndResendAllOutgoingRequests()
												}))
											}
											onCryptoEvent(e) {
												return a(this, void 0, void 0, (function*() {
													const t = e.getRoomId(),
														r = e.getContent();
													try {
														yield this.setRoomEncryption(t, r, !0)
													} catch (n) {
														h.logger.error(`Error configuring encryption in room ${t}`, n)
													}
												}))
											}
											onSyncWillProcess(e) {
												return a(this, void 0, void 0, (function*() {
													e.oldSyncToken || (h.logger.log("Initial sync performed - resetting device tracking state"), this.deviceList.stopTrackingAllDeviceLists(), this.deviceList.startTrackingDeviceList(this.userId), this.roomDeviceTrackingState = {}), this.sendKeyRequestsImmediately = !1
												}))
											}
											onSyncCompleted(e) {
												var t;
												return a(this, void 0, void 0, (function*() {
													this.deviceList.setSyncToken(null !== (t = e.nextSyncToken) && void 0 !== t ? t : null), this.deviceList.saveIfDirty(), this.deviceList.startTrackingDeviceList(this.userId), this.deviceList.refreshOutdatedDeviceLists(), e.catchingUp || (this.maybeUploadOneTimeKeys(), this.processReceivedRoomKeyRequests(), this.outgoingRoomKeyRequestManager.sendQueuedRequests(), this.sendKeyRequestsImmediately = !0)
												}))
											}
											evalDeviceListChanges(e) {
												return a(this, void 0, void 0, (function*() {
													if (e.changed && Array.isArray(e.changed) && e.changed.forEach(e => {
															this.deviceList.invalidateUserDeviceList(e)
														}), e.left && Array.isArray(e.left) && e.left.length) {
														const t = new Set(yield this.getTrackedE2eUsers());
														e.left.forEach(e => {
															t.has(e) || this.deviceList.stopTrackingDeviceList(e)
														})
													}
												}))
											}
											getTrackedE2eUsers() {
												return a(this, void 0, void 0, (function*() {
													const e = [];
													for (const t of this.getTrackedE2eRooms()) {
														const r = yield t.getEncryptionTargetMembers();
														for (const t of r) e.push(t.userId)
													}
													return e
												}))
											}
											getTrackedE2eRooms() {
												return this.clientStore.getRooms().filter(e => {
													if (!this.roomEncryptors.get(e.roomId)) return !1;
													if (!this.roomDeviceTrackingState[e.roomId]) return !1;
													const t = e.getMyMembership();
													return "join" === t || "invite" === t
												})
											}
											encryptAndSendToDevices(e, t) {
												return a(this, void 0, void 0, (function*() {
													const r = {
														eventType: u.EventType.RoomMessageEncrypted,
														batch: []
													};
													try {
														yield Promise.all(e.map(({
															userId: e,
															deviceInfo: n
														}) => a(this, void 0, void 0, (function*() {
															const i = n.deviceId,
																o = {
																	algorithm: p.OLM_ALGORITHM,
																	sender_key: this.olmDevice.deviceCurve25519Key,
																	ciphertext: {}
																};
															r.batch.push({
																userId: e,
																deviceId: i,
																payload: o
															}), yield p.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, {
																[e]: [n]
															}), yield p.encryptMessageForDevice(o.ciphertext, this.userId, this.deviceId, this.olmDevice, e, n, t)
														})))), r.batch = r.batch.filter(e => Object.keys(e.payload.ciphertext).length > 0 || (h.logger.log(`No ciphertext for device ${e.userId}:${e.deviceId}: pruning`), !1));
														try {
															yield this.baseApis.queueToDevice(r)
														} catch (n) {
															throw h.logger.error("sendToDevice failed", n), n
														}
													} catch (n) {
														throw h.logger.error("encryptAndSendToDevices promises failed", n), n
													}
												}))
											}
											onRoomKeyEvent(e) {
												const t = e.getContent();
												t.room_id && t.algorithm ? (this.backupManager.checkedForBackup || this.backupManager.checkAndStart(), this.getRoomDecryptor(t.room_id, t.algorithm).onRoomKeyEvent(e)) : h.logger.error("key event is missing fields")
											}
											onRoomKeyWithheldEvent(e) {
												const t = e.getContent();
												if (!(("m.no_olm" === t.code || t.room_id && t.session_id) && t.algorithm && t.sender_key)) return void h.logger.error("key withheld event is missing fields");
												h.logger.info(`Got room key withheld event from ${e.getSender()} (${t.sender_key}) ` + `for ${t.algorithm}/${t.room_id}/${t.session_id} ` + `with reason ${t.code} (${t.reason})`);
												const r = this.getRoomDecryptor(t.room_id, t.algorithm);
												if (r.onRoomKeyWithheldEvent && r.onRoomKeyWithheldEvent(e), !t.room_id) {
													const e = this.getRoomDecryptors(t.algorithm);
													for (const r of e) r.retryDecryptionFromSender(t.sender_key)
												}
											}
											onKeyVerificationMessage(e) {
												if (!M.ToDeviceChannel.validateEvent(e, this.baseApis)) return;
												this.handleVerificationEvent(e, this.toDeviceVerificationRequests, e => {
													if (!M.ToDeviceChannel.canCreateRequest(M.ToDeviceChannel.getEventType(e))) return;
													const t = e.getContent(),
														r = t && t.from_device;
													if (!r) return;
													const n = e.getSender(),
														i = new M.ToDeviceChannel(this.baseApis, n, [r]);
													return new R.VerificationRequest(i, this.verificationMethods, this.baseApis)
												})
											}
											handleVerificationEvent(e, t, r, n = !0) {
												return a(this, void 0, void 0, (function*() {
													if (e.isSending() && e.status != N.EventStatus.SENT) {
														let t, r;
														try {
															yield new Promise((n, i) => {
																t = n, r = () => {
																	e.status == N.EventStatus.CANCELLED && i(new Error("Event status set to CANCELLED."))
																}, e.once(N.MatrixEventEvent.LocalEventIdReplaced, t), e.on(N.MatrixEventEvent.Status, r)
															})
														} catch (s) {
															return void h.logger.error("error while waiting for the verification event to be sent: ", s)
														} finally {
															e.removeListener(N.MatrixEventEvent.LocalEventIdReplaced, t), e.removeListener(N.MatrixEventEvent.Status, r)
														}
													}
													let i = t.getRequest(e),
														o = !1;
													if (!i) {
														if (!(i = r(e))) return void h.logger.log("Crypto: could not find VerificationRequest for " + `${e.getType()}, and could not create one, so ignoring.`);
														o = !0, t.setRequest(e, i)
													}
													e.setVerificationRequest(i);
													try {
														yield i.channel.handleEvent(e, i, n)
													} catch (s) {
														h.logger.error("error while handling verification event", s)
													}
													o && !i.initiatedByMe && !i.invalid && !i.observeOnly && this.baseApis.emit(K.VerificationRequest, i)
												}))
											}
											onToDeviceBadEncrypted(e) {
												return a(this, void 0, void 0, (function*() {
													const t = e.getWireContent(),
														r = e.getSender(),
														n = t.algorithm,
														i = t.sender_key,
														o = () => {
															const e = this.getRoomDecryptors(p.MEGOLM_ALGORITHM);
															for (const t of e) t.retryDecryptionFromSender(i)
														};
													if (void 0 === r || void 0 === i || void 0 === i) return;
													this.lastNewSessionForced[r] = this.lastNewSessionForced[r] || {};
													const s = this.lastNewSessionForced[r][i] || 0;
													if (s + q > Date.now()) return h.logger.debug("New session already forced with device " + r + ":" + i + " at " + s + ": not forcing another"), yield this.olmDevice.recordSessionProblem(i, "wedged", !0), void o();
													let a = this.deviceList.getDeviceByIdentityKey(n, i);
													if (!(a || (yield this.downloadKeys([r], !1), a = this.deviceList.getDeviceByIdentityKey(n, i)))) return h.logger.info("Couldn't find device for identity key " + i + ": not re-establishing session"), yield this.olmDevice.recordSessionProblem(i, "wedged", !1), void o();
													const c = {};
													c[r] = [a], yield p.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, c, !0), this.lastNewSessionForced[r][i] = Date.now();
													const l = {
														algorithm: p.OLM_ALGORITHM,
														sender_key: this.olmDevice.deviceCurve25519Key,
														ciphertext: {}
													};
													yield p.encryptMessageForDevice(l.ciphertext, this.userId, this.deviceId, this.olmDevice, r, a, {
														type: "m.dummy"
													}), yield this.olmDevice.recordSessionProblem(i, "wedged", !0), o(), yield this.baseApis.sendToDevice("m.room.encrypted", {
														[r]: {
															[a.deviceId]: l
														}
													});
													const u = yield this.outgoingRoomKeyRequestManager.getOutgoingSentRoomKeyRequest(r, a.deviceId);
													for (const e of u) this.requestRoomKey(e.requestBody, e.recipients, !0)
												}))
											}
											onRoomMembership(e, t, r) {
												var n;
												const i = t.roomId,
													o = this.roomEncryptors.get(i);
												o && (i in this.roomDeviceTrackingState && ("join" == t.membership ? (h.logger.log("Join event for " + t.userId + " in " + i), this.deviceList.startTrackingDeviceList(t.userId)) : "invite" == t.membership && (null === (n = this.clientStore.getRoom(i)) || void 0 === n ? void 0 : n.shouldEncryptForInvitedMembers()) && (h.logger.log("Invite event for " + t.userId + " in " + i), this.deviceList.startTrackingDeviceList(t.userId))), o.onRoomMembership(e, t, r))
											}
											onRoomKeyRequestEvent(e) {
												const t = e.getContent();
												if ("request" === t.action) {
													const t = new H(e);
													this.receivedRoomKeyRequests.push(t)
												} else if ("request_cancellation" === t.action) {
													const t = new W(e);
													this.receivedRoomKeyRequestCancellations.push(t)
												}
											}
											processReceivedRoomKeyRequests() {
												return a(this, void 0, void 0, (function*() {
													if (!this.processingRoomKeyRequests) {
														this.processingRoomKeyRequests = !0;
														try {
															const e = this.receivedRoomKeyRequests;
															this.receivedRoomKeyRequests = [];
															const t = this.receivedRoomKeyRequestCancellations;
															this.receivedRoomKeyRequestCancellations = [], yield Promise.all(e.map(e => this.processReceivedRoomKeyRequest(e))), yield Promise.all(t.map(e => this.processReceivedRoomKeyRequestCancellation(e)))
														} catch (e) {
															h.logger.error(`Error processing room key requsts: ${e}`)
														} finally {
															this.processingRoomKeyRequests = !1
														}
													}
												}))
											}
											processReceivedRoomKeyRequest(e) {
												return a(this, void 0, void 0, (function*() {
													const t = e.userId,
														r = e.deviceId,
														n = e.requestBody,
														i = n.room_id,
														o = n.algorithm;
													if (h.logger.log(`m.room_key_request from ${t}:${r}` + ` for ${i} / ${n.session_id} (id ${e.requestId})`), t !== this.userId) {
														if (!this.roomEncryptors.get(i)) return void h.logger.debug(`room key request for unencrypted room ${i}`);
														const e = this.roomEncryptors.get(i),
															o = this.deviceList.getStoredDevice(t, r);
														if (!o) return void h.logger.debug(`Ignoring keyshare for unknown device ${t}:${r}`);
														try {
															yield e.reshareKeyWithDevice(n.sender_key, n.session_id, t, o)
														} catch (a) {
															h.logger.warn("Failed to re-share keys for session " + n.session_id + " with device " + t + ":" + o.deviceId, a)
														}
														return
													}
													if (r === this.deviceId) return void h.logger.log("Ignoring room key request from ourselves");
													if (!this.roomDecryptors.has(i)) return void h.logger.log(`room key request for unencrypted room ${i}`);
													const s = this.roomDecryptors.get(i).get(o);
													if (s)
														if (yield s.hasKeysForKeyRequest(e)) {
															if (e.share = () => {
																	s.shareKeysWithDevice(e)
																}, this.checkDeviceTrust(t, r).isVerified()) return h.logger.log("device is already verified: sharing keys"), void e.share();
															this.emit(K.RoomKeyRequest, e)
														} else h.logger.log(`room key request for unknown session ${i} / ` + n.session_id);
													else h.logger.log(`room key request for unknown alg ${o} in room ${i}`)
												}))
											}
											processReceivedRoomKeyRequestCancellation(e) {
												return a(this, void 0, void 0, (function*() {
													h.logger.log(`m.room_key_request cancellation for ${e.userId}:` + `${e.deviceId} (id ${e.requestId})`), this.emit(K.RoomKeyRequestCancellation, e)
												}))
											}
											getRoomDecryptor(e, t) {
												let r, n;
												if (e && ((r = this.roomDecryptors.get(e)) || (r = new Map, this.roomDecryptors.set(e, r)), n = r.get(t))) return n;
												const i = m.DECRYPTION_CLASSES.get(t);
												if (!i) throw new m.DecryptionError("UNKNOWN_ENCRYPTION_ALGORITHM", 'Unknown encryption algorithm "' + t + '".');
												return n = new i({
													userId: this.userId,
													crypto: this,
													olmDevice: this.olmDevice,
													baseApis: this.baseApis,
													roomId: null != e ? e : void 0
												}), r && r.set(t, n), n
											}
											getRoomDecryptors(e) {
												const t = [];
												for (const r of this.roomDecryptors.values()) r.has(e) && t.push(r.get(e));
												return t
											}
											signObject(e) {
												return a(this, void 0, void 0, (function*() {
													const t = e.signatures || {},
														r = e.unsigned;
													delete e.signatures, delete e.unsigned, t[this.userId] = t[this.userId] || {}, t[this.userId]["ed25519:" + this.deviceId] = yield this.olmDevice.sign(l.default.stringify(e)), e.signatures = t, void 0 !== r && (e.unsigned = r)
												}))
											}
										}

										function z(e) {
											if ("string" != typeof e || e.indexOf(",") < 0) return null;
											const t = Uint8Array.from(e.split(","), e => parseInt(e));
											return p.encodeBase64(t)
										}
										n.Crypto = V, n.fixBackupKey = z;
										class H {
											constructor(e) {
												const t = e.getContent();
												this.userId = e.getSender(), this.deviceId = t.requesting_device_id, this.requestId = t.request_id, this.requestBody = t.body || {}, this.share = () => {
													throw new Error("don't know how to share keys for this request yet")
												}
											}
										}
										n.IncomingRoomKeyRequest = H;
										class W {
											constructor(e) {
												const t = e.getContent();
												this.userId = e.getSender(), this.deviceId = t.requesting_device_id, this.requestId = t.request_id
											}
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, t("buffer").Buffer)
							}, {
								"../@types/event": 290,
								"../ReEmitter": 300,
								"../client": 304,
								"../errors": 342,
								"../logger": 356,
								"../models/event": 365,
								"../models/room": 373,
								"../models/room-member": 370,
								"../models/typed-event-emitter": 376,
								"./CrossSigning": 307,
								"./DeviceList": 308,
								"./EncryptionSetup": 309,
								"./OlmDevice": 310,
								"./OutgoingRoomKeyRequestManager": 311,
								"./SecretStorage": 313,
								"./aes": 314,
								"./algorithms": 316,
								"./backup": 320,
								"./dehydration": 322,
								"./deviceinfo": 323,
								"./key_passphrase": 325,
								"./olmlib": 326,
								"./recoverykey": 327,
								"./store/indexeddb-crypto-store": 329,
								"./verification/IllegalMethod": 334,
								"./verification/QRCode": 335,
								"./verification/SAS": 336,
								"./verification/request/InRoomChannel": 338,
								"./verification/request/ToDeviceChannel": 339,
								"./verification/request/VerificationRequest": 340,
								"another-json": 2,
								buffer: 69
							}],
							325: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var r = this && this.__awaiter || function(e, t, r, n) {
											return new(r || (r = Promise))((function(i, o) {
												function s(e) {
													try {
														c(n.next(e))
													} catch (t) {
														o(t)
													}
												}

												function a(e) {
													try {
														c(n.throw(e))
													} catch (t) {
														o(t)
													}
												}

												function c(e) {
													var t;
													e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
														e(t)
													}))).then(s, a)
												}
												c((n = n.apply(e, t || [])).next())
											}))
										};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.deriveKey = n.keyFromPassphrase = n.keyFromAuthData = void 0;
										const i = t("../randomstring"),
											o = t("./crypto"),
											s = 5e5,
											a = 256;

										function c(e, t, n, i = a) {
											return r(this, void 0, void 0, (function*() {
												if (!o.subtleCrypto || !o.TextEncoder) throw new Error("Password-based backup is not available on this platform");
												const r = yield o.subtleCrypto.importKey("raw", (new o.TextEncoder).encode(e), {
													name: "PBKDF2"
												}, !1, ["deriveBits"]), s = yield o.subtleCrypto.deriveBits({
													name: "PBKDF2",
													salt: (new o.TextEncoder).encode(t),
													iterations: n,
													hash: "SHA-512"
												}, r, i);
												return new Uint8Array(s)
											}))
										}
										n.keyFromAuthData = function(t, r) {
											if (!e.Olm) throw new Error("Olm is not available");
											if (!t.private_key_salt || !t.private_key_iterations) throw new Error("Salt and/or iterations not found: this backup cannot be restored with a passphrase");
											return c(r, t.private_key_salt, t.private_key_iterations, t.private_key_bits || a)
										}, n.keyFromPassphrase = function(t) {
											return r(this, void 0, void 0, (function*() {
												if (!e.Olm) throw new Error("Olm is not available");
												const r = (0, i.randomString)(32);
												return {
													key: yield c(t, r, s, a),
													salt: r,
													iterations: s
												}
											}))
										}, n.deriveKey = c
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"../randomstring": 379,
								"./crypto": 321
							}],
							326: [function(t, r, n) {
								(function(e, r) {
									(function() {
										"use strict";
										var i = this && this.__awaiter || function(e, t, r, n) {
												return new(r || (r = Promise))((function(i, o) {
													function s(e) {
														try {
															c(n.next(e))
														} catch (t) {
															o(t)
														}
													}

													function a(e) {
														try {
															c(n.throw(e))
														} catch (t) {
															o(t)
														}
													}

													function c(e) {
														var t;
														e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
															e(t)
														}))).then(s, a)
													}
													c((n = n.apply(e, t || [])).next())
												}))
											},
											o = this && this.__importDefault || function(e) {
												return e && e.__esModule ? e : {
													default: e
												}
											};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.decodeBase64 = n.encodeUnpaddedBase64 = n.encodeBase64 = n.isOlmEncrypted = n.pkVerify = n.pkSign = n.verifySignature = n.ensureOlmSessionsForDevices = n.getExistingOlmSessions = n.encryptMessageForDevice = n.MEGOLM_BACKUP_ALGORITHM = n.MEGOLM_ALGORITHM = n.OLM_ALGORITHM = void 0;
										const s = o(t("another-json")),
											a = t("../logger"),
											c = t("../@types/event");
										var l;

										function u(e, t, r, n) {
											return i(this, void 0, void 0, (function*() {
												const i = n.deviceId;
												try {
													yield d(e, t, r, i, n.getFingerprint())
												} catch (s) {
													return a.logger.error("Unable to verify signature on one-time key for device " + r + ":" + i + ":", s), null
												}
												let o;
												try {
													o = yield e.createOutboundSession(n.getIdentityKey(), t.key)
												} catch (s) {
													return a.logger.error("Error starting olm session with device " + r + ":" + i + ": " + s), null
												}
												return a.logger.log("Started new olm sessionid " + o + " for device " + r + ":" + i), o
											}))
										}

										function d(e, t, r, n, o) {
											return i(this, void 0, void 0, (function*() {
												const i = "ed25519:" + n,
													a = ((t.signatures || {})[r] || {})[i];
												if (!a) throw Error("No signature");
												const c = Object.assign({}, t);
												"unsigned" in c && delete c.unsigned, delete c.signatures;
												const l = s.default.stringify(c);
												e.verifySignature(o, l, a)
											}))
										}

										function h(e) {
											return r.from(e).toString("base64")
										}! function(e) {
											e.Olm = "m.olm.v1.curve25519-aes-sha2", e.Megolm = "m.megolm.v1.aes-sha2", e.MegolmBackup = "m.megolm_backup.v1.curve25519-aes-sha2"
										}(l || (l = {})), n.OLM_ALGORITHM = l.Olm, n.MEGOLM_ALGORITHM = l.Megolm, n.MEGOLM_BACKUP_ALGORITHM = l.MegolmBackup, n.encryptMessageForDevice = function(e, t, r, n, o, s, c) {
											return i(this, void 0, void 0, (function*() {
												const i = s.getIdentityKey(),
													l = yield n.getSessionIdForDevice(i);
												if (null === l) return void a.logger.log("[olmlib.encryptMessageForDevice] Unable to find Olm session for device " + `${o}:${s.deviceId}`);
												a.logger.log(`[olmlib.encryptMessageForDevice] Using Olm session ${l} for device ` + `${o}:${s.deviceId}`);
												const u = {
													sender: t,
													sender_device: r,
													keys: {
														ed25519: n.deviceEd25519Key
													},
													recipient: o,
													recipient_keys: {
														ed25519: s.getFingerprint()
													}
												};
												Object.assign(u, c), e[i] = yield n.encryptMessage(i, l, JSON.stringify(u))
											}))
										}, n.getExistingOlmSessions = function(e, t, r) {
											return i(this, void 0, void 0, (function*() {
												const t = {},
													n = {},
													o = [];
												for (const [s, a] of Object.entries(r))
													for (const r of a) {
														const a = r.deviceId,
															c = r.getIdentityKey();
														o.push((() => i(this, void 0, void 0, (function*() {
															const i = yield e.getSessionIdForDevice(c, !0);
															null === i ? (t[s] = t[s] || [], t[s].push(r)) : (n[s] = n[s] || {}, n[s][a] = {
																device: r,
																sessionId: i
															})
														})))())
													}
												return yield Promise.all(o), [t, n]
											}))
										}, n.ensureOlmSessionsForDevices = function(e, t, r, n = !1, o, s, c = a.logger) {
											return i(this, void 0, void 0, (function*() {
												const i = [],
													a = {},
													l = {};
												for (const [, t] of Object.entries(r))
													for (const r of t) {
														const t = r.getIdentityKey();
														t !== e.deviceCurve25519Key && (e.sessionsInProgress[t] || (e.sessionsInProgress[t] = new Promise(r => {
															l[t] = n => {
																delete e.sessionsInProgress[t], r(n)
															}
														})))
													}
												for (const [t, o] of Object.entries(r)) {
													a[t] = {};
													for (const r of o) {
														const o = r.deviceId,
															s = r.getIdentityKey();
														if (s === e.deviceCurve25519Key) {
															c.info("Attempted to start session with ourself! Ignoring"), a[t][o] = {
																device: r,
																sessionId: null
															};
															continue
														}
														const u = `for ${s} (${t}:${o})`,
															d = yield e.getSessionIdForDevice(s, !!l[s], c);
														null !== d && l[s] && l[s](), (null === d || n) && (n ? c.info(`Forcing new Olm session ${u}`) : c.info(`Making new Olm session ${u}`), i.push([t, o])), a[t][o] = {
															device: r,
															sessionId: d
														}
													}
												}
												if (0 === i.length) return a;
												let d, h = `one-time keys for ${i.length} devices`;
												try {
													c.debug(`Claiming ${h}`), d = yield t.claimOneTimeKeys(i, "signed_curve25519", o), c.debug(`Claimed ${h}`)
												} catch (v) {
													for (const e of Object.values(l)) e();
													throw c.log(`Failed to claim ${h}`, v, i), v
												}
												s && "failures" in d && s.push(...Object.keys(d.failures));
												const f = d.one_time_keys || {},
													p = [];
												for (const [t, o] of Object.entries(r)) {
													const r = f[t] || {};
													for (const i of o) {
														const o = i.deviceId,
															s = i.getIdentityKey();
														if (s === e.deviceCurve25519Key) continue;
														if (a[t][o].sessionId && !n) continue;
														const d = r[o] || {};
														let h = null;
														for (const e in d) 0 === e.indexOf("signed_curve25519:") && (h = d[e]);
														h ? p.push(u(e, h, t, i).then(e => {
															l[s] && l[s](null != e ? e : void 0), a[t][o].sessionId = e
														}, e => {
															throw l[s] && l[s](), e
														})) : (c.warn("No one-time keys (alg=signed_curve25519) " + `for device ${t}:${o}`), l[s] && l[s]())
													}
												}
												return h = `Olm sessions for ${p.length} devices`, c.debug(`Starting ${h}`), yield Promise.all(p), c.debug(`Started ${h}`), a
											}))
										}, n.verifySignature = d, n.pkSign = function(t, r, n, i) {
											let o = !1;
											if (r instanceof Uint8Array) {
												const t = new e.Olm.PkSigning;
												i = t.init_with_seed(r), r = t, o = !0
											}
											const a = t.signatures || {};
											delete t.signatures;
											const c = t.unsigned;
											t.unsigned && delete t.unsigned;
											try {
												const e = a[n] || {};
												return a[n] = e, e["ed25519:" + i] = r.sign(s.default.stringify(t))
											} finally {
												t.signatures = a, c && (t.unsigned = c), o && r.free()
											}
										}, n.pkVerify = function(t, r, n) {
											const i = "ed25519:" + r;
											if (!(t.signatures && t.signatures[n] && t.signatures[n][i])) throw new Error("No signature");
											const o = t.signatures[n][i],
												a = new e.Olm.Utility,
												c = t.signatures;
											delete t.signatures;
											const l = t.unsigned;
											t.unsigned && delete t.unsigned;
											try {
												a.ed25519_verify(r, s.default.stringify(t), o)
											} finally {
												t.signatures = c, l && (t.unsigned = l), a.free()
											}
										}, n.isOlmEncrypted = function(e) {
											return e.getSenderKey() ? !(e.getWireType() !== c.EventType.RoomMessageEncrypted || !["m.olm.v1.curve25519-aes-sha2"].includes(e.getWireContent().algorithm)) || (a.logger.error("Event was not encrypted using an appropriate algorithm"), !1) : (a.logger.error("Event has no sender key (not encrypted?)"), !1)
										}, n.encodeBase64 = h, n.encodeUnpaddedBase64 = function(e) {
											return h(e).replace(/=+$/g, "")
										}, n.decodeBase64 = function(e) {
											return r.from(e, "base64")
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, t("buffer").Buffer)
							}, {
								"../@types/event": 290,
								"../logger": 356,
								"another-json": 2,
								buffer: 69
							}],
							327: [function(t, r, n) {
								(function(e, r) {
									(function() {
										"use strict";
										var i = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
												void 0 === n && (n = r);
												var i = Object.getOwnPropertyDescriptor(t, r);
												i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
													enumerable: !0,
													get: function() {
														return t[r]
													}
												}), Object.defineProperty(e, n, i)
											} : function(e, t, r, n) {
												void 0 === n && (n = r), e[n] = t[r]
											}),
											o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
												Object.defineProperty(e, "default", {
													enumerable: !0,
													value: t
												})
											} : function(e, t) {
												e.default = t
											}),
											s = this && this.__importStar || function(e) {
												if (e && e.__esModule) return e;
												var t = {};
												if (null != e)
													for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && i(t, e, r);
												return o(t, e), t
											};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.decodeRecoveryKey = n.encodeRecoveryKey = void 0;
										const a = s(t("bs58")),
											c = [139, 1];
										n.encodeRecoveryKey = function(e) {
											var t;
											const n = r.alloc(c.length + e.length + 1);
											n.set(c, 0), n.set(e, c.length);
											let i = 0;
											for (let r = 0; r < n.length - 1; ++r) i ^= n[r];
											return n[n.length - 1] = i, null === (t = a.encode(n).match(/.{1,4}/g)) || void 0 === t ? void 0 : t.join(" ")
										}, n.decodeRecoveryKey = function(t) {
											const r = a.decode(t.replace(/ /g, ""));
											let n = 0;
											for (const e of r) n ^= e;
											if (0 !== n) throw new Error("Incorrect parity");
											for (let e = 0; e < c.length; ++e)
												if (r[e] !== c[e]) throw new Error("Incorrect prefix");
											if (r.length !== c.length + e.Olm.PRIVATE_KEY_LENGTH + 1) throw new Error("Incorrect length");
											return Uint8Array.from(r.slice(c.length, c.length + e.Olm.PRIVATE_KEY_LENGTH))
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, t("buffer").Buffer)
							}, {
								bs58: 66,
								buffer: 69
							}],
							328: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
										Object.defineProperty(e, "default", {
											enumerable: !0,
											value: t
										})
									} : function(e, t) {
										e.default = t
									}),
									o = this && this.__importStar || function(e) {
										if (e && e.__esModule) return e;
										var t = {};
										if (null != e)
											for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
										return i(t, e), t
									},
									s = this && this.__awaiter || function(e, t, r, n) {
										return new(r || (r = Promise))((function(i, o) {
											function s(e) {
												try {
													c(n.next(e))
												} catch (t) {
													o(t)
												}
											}

											function a(e) {
												try {
													c(n.throw(e))
												} catch (t) {
													o(t)
												}
											}

											function c(e) {
												var t;
												e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
													e(t)
												}))).then(s, a)
											}
											c((n = n.apply(e, t || [])).next())
										}))
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.upgradeDatabase = r.VERSION = r.Backend = void 0;
								const a = e("../../logger"),
									c = o(e("../../utils")),
									l = !1;
								r.Backend = class {
									constructor(e) {
										this.db = e, this.nextTxnId = 0, e.onversionchange = () => {
											a.logger.log(`versionchange for indexeddb ${this.db.name}: closing`), e.close()
										}
									}
									startup() {
										return s(this, void 0, void 0, (function*() {
											return this
										}))
									}
									deleteAllData() {
										return s(this, void 0, void 0, (function*() {
											throw Error("This is not implemented, call IDBFactory::deleteDatabase(dbName) instead.")
										}))
									}
									getOrAddOutgoingRoomKeyRequest(e) {
										const t = e.requestBody;
										return new Promise((r, n) => {
											const i = this.db.transaction("outgoingRoomKeyRequests", "readwrite");
											i.onerror = n, this._getOutgoingRoomKeyRequest(i, t, n => {
												if (n) return a.logger.log("already have key request outstanding for " + `${t.room_id} / ${t.session_id}: ` + "not sending another"), void r(n);
												a.logger.log(`enqueueing key request for ${t.room_id} / ` + t.session_id), i.oncomplete = () => {
													r(e)
												}, i.objectStore("outgoingRoomKeyRequests").add(e)
											})
										})
									}
									getOutgoingRoomKeyRequest(e) {
										return new Promise((t, r) => {
											const n = this.db.transaction("outgoingRoomKeyRequests", "readonly");
											n.onerror = r, this._getOutgoingRoomKeyRequest(n, e, e => {
												t(e)
											})
										})
									}
									_getOutgoingRoomKeyRequest(e, t, r) {
										const n = e.objectStore("outgoingRoomKeyRequests").index("session").openCursor([t.room_id, t.session_id]);
										n.onsuccess = () => {
											const e = n.result;
											if (!e) return void r(null);
											const i = e.value;
											c.deepCompare(i.requestBody, t) ? r(i) : e.continue()
										}
									}
									getOutgoingRoomKeyRequestByState(e) {
										if (0 === e.length) return Promise.resolve(null);
										let t, r = 0;
										const n = this.db.transaction("outgoingRoomKeyRequests", "readonly"),
											i = n.objectStore("outgoingRoomKeyRequests"),
											o = e[r];
										return i.index("state").openCursor(o).onsuccess = function n() {
											const i = this.result;
											if (i) return void(t = i.value);
											if (++r >= e.length) return;
											const o = e[r];
											this.source.openCursor(o).onsuccess = n
										}, h(n).then(() => t)
									}
									getAllOutgoingRoomKeyRequestsByState(e) {
										return new Promise((t, r) => {
											const n = this.db.transaction("outgoingRoomKeyRequests", "readonly").objectStore("outgoingRoomKeyRequests").index("state").getAll(e);
											n.onsuccess = () => t(n.result), n.onerror = () => r(n.error)
										})
									}
									getOutgoingRoomKeyRequestsByTarget(e, t, r) {
										let n = 0;
										const i = [];
										const o = this.db.transaction("outgoingRoomKeyRequests", "readonly"),
											s = o.objectStore("outgoingRoomKeyRequests"),
											a = r[n];
										return s.index("state").openCursor(a).onsuccess = function o() {
											const s = this.result;
											if (s) {
												const r = s.value;
												r.recipients.some(r => r.userId === e && r.deviceId === t) && i.push(r), s.continue()
											} else {
												if (++n >= r.length) return;
												const e = r[n];
												this.source.openCursor(e).onsuccess = o
											}
										}, h(o).then(() => i)
									}
									updateOutgoingRoomKeyRequest(e, t, r) {
										let n = null;
										const i = this.db.transaction("outgoingRoomKeyRequests", "readwrite");
										return i.objectStore("outgoingRoomKeyRequests").openCursor(e).onsuccess = function() {
											const e = this.result;
											if (!e) return;
											const i = e.value;
											i.state == t ? (Object.assign(i, r), e.update(i), n = i) : a.logger.warn(`Cannot update room key request from ${t} ` + `as it was already updated to ${i.state}`)
										}, h(i).then(() => n)
									}
									deleteOutgoingRoomKeyRequest(e, t) {
										const r = this.db.transaction("outgoingRoomKeyRequests", "readwrite"),
											n = r.objectStore("outgoingRoomKeyRequests").openCursor(e);
										return n.onsuccess = () => {
											const e = n.result;
											if (!e) return;
											const r = e.value;
											r.state == t ? e.delete() : a.logger.warn(`Cannot delete room key request in state ${r.state} ` + `(expected ${t})`)
										}, h(r)
									}
									getAccount(e, t) {
										const r = e.objectStore("account").get("-");
										r.onsuccess = function() {
											try {
												t(r.result || null)
											} catch (n) {
												d(e, n)
											}
										}
									}
									storeAccount(e, t) {
										e.objectStore("account").put(t, "-")
									}
									getCrossSigningKeys(e, t) {
										const r = e.objectStore("account").get("crossSigningKeys");
										r.onsuccess = function() {
											try {
												t(r.result || null)
											} catch (n) {
												d(e, n)
											}
										}
									}
									getSecretStorePrivateKey(e, t, r) {
										const n = e.objectStore("account").get(`ssss_cache:${r}`);
										n.onsuccess = function() {
											try {
												t(n.result || null)
											} catch (r) {
												d(e, r)
											}
										}
									}
									storeCrossSigningKeys(e, t) {
										e.objectStore("account").put(t, "crossSigningKeys")
									}
									storeSecretStorePrivateKey(e, t, r) {
										e.objectStore("account").put(r, `ssss_cache:${t}`)
									}
									countEndToEndSessions(e, t) {
										const r = e.objectStore("sessions").count();
										r.onsuccess = function() {
											try {
												t(r.result)
											} catch (n) {
												d(e, n)
											}
										}
									}
									getEndToEndSessions(e, t, r) {
										const n = t.objectStore("sessions").index("deviceKey").openCursor(e),
											i = {};
										n.onsuccess = function() {
											const e = n.result;
											if (e) i[e.value.sessionId] = {
												session: e.value.session,
												lastReceivedMessageTs: e.value.lastReceivedMessageTs
											}, e.continue();
											else try {
												r(i)
											} catch (o) {
												d(t, o)
											}
										}
									}
									getEndToEndSession(e, t, r, n) {
										const i = r.objectStore("sessions").get([e, t]);
										i.onsuccess = function() {
											try {
												i.result ? n({
													session: i.result.session,
													lastReceivedMessageTs: i.result.lastReceivedMessageTs
												}) : n(null)
											} catch (e) {
												d(r, e)
											}
										}
									}
									getAllEndToEndSessions(e, t) {
										const r = e.objectStore("sessions").openCursor();
										r.onsuccess = function() {
											try {
												const e = r.result;
												e ? (t(e.value), e.continue()) : t(null)
											} catch (n) {
												d(e, n)
											}
										}
									}
									storeEndToEndSession(e, t, r, n) {
										n.objectStore("sessions").put({
											deviceKey: e,
											sessionId: t,
											session: r.session,
											lastReceivedMessageTs: r.lastReceivedMessageTs
										})
									}
									storeEndToEndSessionProblem(e, t, r) {
										return s(this, void 0, void 0, (function*() {
											const n = this.db.transaction("session_problems", "readwrite");
											n.objectStore("session_problems").put({
												deviceKey: e,
												type: t,
												fixed: r,
												time: Date.now()
											}), yield h(n)
										}))
									}
									getEndToEndSessionProblem(e, t) {
										return s(this, void 0, void 0, (function*() {
											let r = null;
											const n = this.db.transaction("session_problems", "readwrite"),
												i = n.objectStore("session_problems").index("deviceKey").getAll(e);
											return i.onsuccess = () => {
												const e = i.result;
												if (!e.length) return void(r = null);
												e.sort((e, t) => e.time - t.time);
												const n = e[e.length - 1];
												for (const i of e)
													if (i.time > t) return void(r = Object.assign({}, i, {
														fixed: n.fixed
													}));
												r = n.fixed ? null : n
											}, yield h(n), r
										}))
									}
									filterOutNotifiedErrorDevices(e) {
										return s(this, void 0, void 0, (function*() {
											const t = this.db.transaction("notified_error_devices", "readwrite").objectStore("notified_error_devices"),
												r = [];
											return yield Promise.all(e.map(e => new Promise(n => {
												const {
													userId: i,
													deviceInfo: o
												} = e, s = t.get([i, o.deviceId]);
												s.onsuccess = function() {
													s.result || (t.put({
														userId: i,
														deviceId: o.deviceId
													}), r.push(e)), n()
												}
											}))), r
										}))
									}
									getEndToEndInboundGroupSession(e, t, r, n) {
										let i = !1,
											o = !1;
										const s = r.objectStore("inbound_group_sessions").get([e, t]);
										s.onsuccess = function() {
											try {
												i = s.result ? s.result.session : null, !1 !== o && n(i, o)
											} catch (e) {
												d(r, e)
											}
										};
										const a = r.objectStore("inbound_group_sessions_withheld").get([e, t]);
										a.onsuccess = function() {
											try {
												o = a.result ? a.result.session : null, !1 !== i && n(i, o)
											} catch (e) {
												d(r, e)
											}
										}
									}
									getAllEndToEndInboundGroupSessions(e, t) {
										const r = e.objectStore("inbound_group_sessions").openCursor();
										r.onsuccess = function() {
											const n = r.result;
											if (n) {
												try {
													t({
														senderKey: n.value.senderCurve25519Key,
														sessionId: n.value.sessionId,
														sessionData: n.value.session
													})
												} catch (i) {
													d(e, i)
												}
												n.continue()
											} else try {
												t(null)
											} catch (i) {
												d(e, i)
											}
										}
									}
									addEndToEndInboundGroupSession(e, t, r, n) {
										const i = n.objectStore("inbound_group_sessions").add({
											senderCurve25519Key: e,
											sessionId: t,
											session: r
										});
										i.onerror = r => {
											var o;
											"ConstraintError" === (null === (o = i.error) || void 0 === o ? void 0 : o.name) ? (r.stopPropagation(), r.preventDefault(), a.logger.log("Ignoring duplicate inbound group session: " + e + " / " + t)) : d(n, new Error("Failed to add inbound group session: " + i.error))
										}
									}
									storeEndToEndInboundGroupSession(e, t, r, n) {
										n.objectStore("inbound_group_sessions").put({
											senderCurve25519Key: e,
											sessionId: t,
											session: r
										})
									}
									storeEndToEndInboundGroupSessionWithheld(e, t, r, n) {
										n.objectStore("inbound_group_sessions_withheld").put({
											senderCurve25519Key: e,
											sessionId: t,
											session: r
										})
									}
									getEndToEndDeviceData(e, t) {
										const r = e.objectStore("device_data").get("-");
										r.onsuccess = function() {
											try {
												t(r.result || null)
											} catch (n) {
												d(e, n)
											}
										}
									}
									storeEndToEndDeviceData(e, t) {
										t.objectStore("device_data").put(e, "-")
									}
									storeEndToEndRoom(e, t, r) {
										r.objectStore("rooms").put(t, e)
									}
									getEndToEndRooms(e, t) {
										const r = {},
											n = e.objectStore("rooms").openCursor();
										n.onsuccess = function() {
											const i = n.result;
											if (i) r[i.key] = i.value, i.continue();
											else try {
												t(r)
											} catch (o) {
												d(e, o)
											}
										}
									}
									getSessionsNeedingBackup(e) {
										return new Promise((t, r) => {
											const n = [],
												i = this.db.transaction(["sessions_needing_backup", "inbound_group_sessions"], "readonly");
											i.onerror = r, i.oncomplete = function() {
												t(n)
											};
											const o = i.objectStore("sessions_needing_backup"),
												s = i.objectStore("inbound_group_sessions"),
												a = o.openCursor();
											a.onsuccess = function() {
												const t = a.result;
												if (t) {
													const r = s.get(t.key);
													r.onsuccess = function() {
														n.push({
															senderKey: r.result.senderCurve25519Key,
															sessionId: r.result.sessionId,
															sessionData: r.result.session
														})
													}, (!e || n.length < e) && t.continue()
												}
											}
										})
									}
									countSessionsNeedingBackup(e) {
										e || (e = this.db.transaction("sessions_needing_backup", "readonly"));
										const t = e.objectStore("sessions_needing_backup");
										return new Promise((e, r) => {
											const n = t.count();
											n.onerror = r, n.onsuccess = () => e(n.result)
										})
									}
									unmarkSessionsNeedingBackup(e, t) {
										return s(this, void 0, void 0, (function*() {
											t || (t = this.db.transaction("sessions_needing_backup", "readwrite"));
											const r = t.objectStore("sessions_needing_backup");
											yield Promise.all(e.map(e => new Promise((t, n) => {
												const i = r.delete([e.senderKey, e.sessionId]);
												i.onsuccess = t, i.onerror = n
											})))
										}))
									}
									markSessionsNeedingBackup(e, t) {
										return s(this, void 0, void 0, (function*() {
											t || (t = this.db.transaction("sessions_needing_backup", "readwrite"));
											const r = t.objectStore("sessions_needing_backup");
											yield Promise.all(e.map(e => new Promise((t, n) => {
												const i = r.put({
													senderCurve25519Key: e.senderKey,
													sessionId: e.sessionId
												});
												i.onsuccess = t, i.onerror = n
											})))
										}))
									}
									addSharedHistoryInboundGroupSession(e, t, r, n) {
										n || (n = this.db.transaction("shared_history_inbound_group_sessions", "readwrite"));
										const i = n.objectStore("shared_history_inbound_group_sessions"),
											o = i.get([e]);
										o.onsuccess = () => {
											const {
												sessions: n
											} = o.result || {
												sessions: []
											};
											n.push([t, r]), i.put({
												roomId: e,
												sessions: n
											})
										}
									}
									getSharedHistoryInboundGroupSessions(e, t) {
										t || (t = this.db.transaction("shared_history_inbound_group_sessions", "readonly"));
										const r = t.objectStore("shared_history_inbound_group_sessions").get([e]);
										return new Promise((e, t) => {
											r.onsuccess = () => {
												const {
													sessions: t
												} = r.result || {
													sessions: []
												};
												e(t)
											}, r.onerror = t
										})
									}
									addParkedSharedHistory(e, t, r) {
										r || (r = this.db.transaction("parked_shared_history", "readwrite"));
										const n = r.objectStore("parked_shared_history"),
											i = n.get([e]);
										i.onsuccess = () => {
											const {
												parked: r
											} = i.result || {
												parked: []
											};
											r.push(t), n.put({
												roomId: e,
												parked: r
											})
										}
									}
									takeParkedSharedHistory(e, t) {
										t || (t = this.db.transaction("parked_shared_history", "readwrite"));
										const r = t.objectStore("parked_shared_history").openCursor(e);
										return new Promise((e, t) => {
											r.onsuccess = () => {
												const t = r.result;
												if (!t) return void e([]);
												const n = t.value;
												t.delete(), e(n)
											}, r.onerror = t
										})
									}
									doTxn(e, t, r, n = a.logger) {
										let i, o;
										if (l) {
											const r = this.nextTxnId++;
											i = Date.now(), o = `${e} crypto store transaction ${r} in ${t}`, n.debug(`Starting ${o}`)
										}
										const s = this.db.transaction(t, e),
											c = h(s),
											u = r(s);
										return l && c.then(() => {
											const e = Date.now() - i;
											n.debug(`Finished ${o}, took ${e} ms`)
										}, () => {
											const e = Date.now() - i;
											n.error(`Failed ${o}, took ${e} ms`)
										}), c.then(() => u)
									}
								};
								const u = [e => {
									! function(e) {
										const t = e.createObjectStore("outgoingRoomKeyRequests", {
											keyPath: "requestId"
										});
										t.createIndex("session", ["requestBody.room_id", "requestBody.session_id"]), t.createIndex("state", "state")
									}(e)
								}, e => {
									e.createObjectStore("account")
								}, e => {
									e.createObjectStore("sessions", {
										keyPath: ["deviceKey", "sessionId"]
									}).createIndex("deviceKey", "deviceKey")
								}, e => {
									e.createObjectStore("inbound_group_sessions", {
										keyPath: ["senderCurve25519Key", "sessionId"]
									})
								}, e => {
									e.createObjectStore("device_data")
								}, e => {
									e.createObjectStore("rooms")
								}, e => {
									e.createObjectStore("sessions_needing_backup", {
										keyPath: ["senderCurve25519Key", "sessionId"]
									})
								}, e => {
									e.createObjectStore("inbound_group_sessions_withheld", {
										keyPath: ["senderCurve25519Key", "sessionId"]
									})
								}, e => {
									e.createObjectStore("session_problems", {
										keyPath: ["deviceKey", "time"]
									}).createIndex("deviceKey", "deviceKey"), e.createObjectStore("notified_error_devices", {
										keyPath: ["userId", "deviceId"]
									})
								}, e => {
									e.createObjectStore("shared_history_inbound_group_sessions", {
										keyPath: ["roomId"]
									})
								}, e => {
									e.createObjectStore("parked_shared_history", {
										keyPath: ["roomId"]
									})
								}];

								function d(e, t) {
									e._mx_abortexception = t;
									try {
										e.abort()
									} catch (t) {}
								}

								function h(e) {
									return new Promise((t, r) => {
										e.oncomplete = () => {
											void 0 !== e._mx_abortexception && r(e._mx_abortexception), t(null)
										}, e.onerror = t => {
											void 0 !== e._mx_abortexception ? r(e._mx_abortexception) : (a.logger.log("Error performing indexeddb txn", t), r(e.error))
										}, e.onabort = t => {
											void 0 !== e._mx_abortexception ? r(e._mx_abortexception) : (a.logger.log("Error performing indexeddb txn", t), r(e.error))
										}
									})
								}
								r.VERSION = u.length, r.upgradeDatabase = function(e, t) {
									a.logger.log(`Upgrading IndexedDBCryptoStore from version ${t}` + ` to ${r.VERSION}`), u.forEach((r, n) => {
										t <= n && r(e)
									})
								}
							}, {
								"../../logger": 356,
								"../../utils": 393
							}],
							329: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var r = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
												void 0 === n && (n = r);
												var i = Object.getOwnPropertyDescriptor(t, r);
												i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
													enumerable: !0,
													get: function() {
														return t[r]
													}
												}), Object.defineProperty(e, n, i)
											} : function(e, t, r, n) {
												void 0 === n && (n = r), e[n] = t[r]
											}),
											i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
												Object.defineProperty(e, "default", {
													enumerable: !0,
													value: t
												})
											} : function(e, t) {
												e.default = t
											}),
											o = this && this.__importStar || function(e) {
												if (e && e.__esModule) return e;
												var t = {};
												if (null != e)
													for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);
												return i(t, e), t
											};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.IndexedDBCryptoStore = void 0;
										const s = t("../../logger"),
											a = t("./localStorage-crypto-store"),
											c = t("./memory-crypto-store"),
											l = o(t("./indexeddb-crypto-store-backend")),
											u = t("../../errors"),
											d = o(t("../../indexeddb-helpers"));
										class h {
											constructor(e, t) {
												this.indexedDB = e, this.dbName = t
											}
											static exists(e, t) {
												return d.exists(e, t)
											}
											startup() {
												return this.backendPromise ? this.backendPromise : (this.backendPromise = new Promise((e, t) => {
													if (!this.indexedDB) return void t(new Error("no indexeddb support available"));
													s.logger.log(`connecting to indexeddb ${this.dbName}`);
													const r = this.indexedDB.open(this.dbName, l.VERSION);
													r.onupgradeneeded = e => {
														const t = r.result,
															n = e.oldVersion;
														l.upgradeDatabase(t, n)
													}, r.onblocked = () => {
														s.logger.log("can't yet open IndexedDBCryptoStore because it is open elsewhere")
													}, r.onerror = e => {
														s.logger.log("Error connecting to indexeddb", e), t(r.error)
													}, r.onsuccess = () => {
														const t = r.result;
														s.logger.log(`connected to indexeddb ${this.dbName}`), e(new l.Backend(t))
													}
												}).then(e => e.doTxn("readonly", [h.STORE_INBOUND_GROUP_SESSIONS, h.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], t => {
													e.getEndToEndInboundGroupSession("", "", t, () => {})
												}).then(() => e)).catch(t => {
													if ("VersionError" === t.name) throw s.logger.warn("Crypto DB is too new for us to use!", t), new u.InvalidCryptoStoreError(u.InvalidCryptoStoreState.TooNew);
													s.logger.warn(`unable to connect to indexeddb ${this.dbName}` + `: falling back to localStorage store: ${t}`);
													try {
														return new a.LocalStorageCryptoStore(e.localStorage)
													} catch (t) {
														return s.logger.warn(`unable to open localStorage: falling back to in-memory store: ${t}`), new c.MemoryCryptoStore
													}
												}).then(e => (this.backend = e, e)), this.backendPromise)
											}
											deleteAllData() {
												return new Promise((e, t) => {
													if (!this.indexedDB) return void t(new Error("no indexeddb support available"));
													s.logger.log(`Removing indexeddb instance: ${this.dbName}`);
													const r = this.indexedDB.deleteDatabase(this.dbName);
													r.onblocked = () => {
														s.logger.log("can't yet delete IndexedDBCryptoStore because it is open elsewhere")
													}, r.onerror = e => {
														s.logger.log("Error deleting data from indexeddb", e), t(r.error)
													}, r.onsuccess = () => {
														s.logger.log(`Removed indexeddb instance: ${this.dbName}`), e()
													}
												}).catch(e => {
													s.logger.warn(`unable to delete IndexedDBCryptoStore: ${e}`)
												})
											}
											getOrAddOutgoingRoomKeyRequest(e) {
												return this.backend.getOrAddOutgoingRoomKeyRequest(e)
											}
											getOutgoingRoomKeyRequest(e) {
												return this.backend.getOutgoingRoomKeyRequest(e)
											}
											getOutgoingRoomKeyRequestByState(e) {
												return this.backend.getOutgoingRoomKeyRequestByState(e)
											}
											getAllOutgoingRoomKeyRequestsByState(e) {
												return this.backend.getAllOutgoingRoomKeyRequestsByState(e)
											}
											getOutgoingRoomKeyRequestsByTarget(e, t, r) {
												return this.backend.getOutgoingRoomKeyRequestsByTarget(e, t, r)
											}
											updateOutgoingRoomKeyRequest(e, t, r) {
												return this.backend.updateOutgoingRoomKeyRequest(e, t, r)
											}
											deleteOutgoingRoomKeyRequest(e, t) {
												return this.backend.deleteOutgoingRoomKeyRequest(e, t)
											}
											getAccount(e, t) {
												this.backend.getAccount(e, t)
											}
											storeAccount(e, t) {
												this.backend.storeAccount(e, t)
											}
											getCrossSigningKeys(e, t) {
												this.backend.getCrossSigningKeys(e, t)
											}
											getSecretStorePrivateKey(e, t, r) {
												this.backend.getSecretStorePrivateKey(e, t, r)
											}
											storeCrossSigningKeys(e, t) {
												this.backend.storeCrossSigningKeys(e, t)
											}
											storeSecretStorePrivateKey(e, t, r) {
												this.backend.storeSecretStorePrivateKey(e, t, r)
											}
											countEndToEndSessions(e, t) {
												this.backend.countEndToEndSessions(e, t)
											}
											getEndToEndSession(e, t, r, n) {
												this.backend.getEndToEndSession(e, t, r, n)
											}
											getEndToEndSessions(e, t, r) {
												this.backend.getEndToEndSessions(e, t, r)
											}
											getAllEndToEndSessions(e, t) {
												this.backend.getAllEndToEndSessions(e, t)
											}
											storeEndToEndSession(e, t, r, n) {
												this.backend.storeEndToEndSession(e, t, r, n)
											}
											storeEndToEndSessionProblem(e, t, r) {
												return this.backend.storeEndToEndSessionProblem(e, t, r)
											}
											getEndToEndSessionProblem(e, t) {
												return this.backend.getEndToEndSessionProblem(e, t)
											}
											filterOutNotifiedErrorDevices(e) {
												return this.backend.filterOutNotifiedErrorDevices(e)
											}
											getEndToEndInboundGroupSession(e, t, r, n) {
												this.backend.getEndToEndInboundGroupSession(e, t, r, n)
											}
											getAllEndToEndInboundGroupSessions(e, t) {
												this.backend.getAllEndToEndInboundGroupSessions(e, t)
											}
											addEndToEndInboundGroupSession(e, t, r, n) {
												this.backend.addEndToEndInboundGroupSession(e, t, r, n)
											}
											storeEndToEndInboundGroupSession(e, t, r, n) {
												this.backend.storeEndToEndInboundGroupSession(e, t, r, n)
											}
											storeEndToEndInboundGroupSessionWithheld(e, t, r, n) {
												this.backend.storeEndToEndInboundGroupSessionWithheld(e, t, r, n)
											}
											storeEndToEndDeviceData(e, t) {
												this.backend.storeEndToEndDeviceData(e, t)
											}
											getEndToEndDeviceData(e, t) {
												this.backend.getEndToEndDeviceData(e, t)
											}
											storeEndToEndRoom(e, t, r) {
												this.backend.storeEndToEndRoom(e, t, r)
											}
											getEndToEndRooms(e, t) {
												this.backend.getEndToEndRooms(e, t)
											}
											getSessionsNeedingBackup(e) {
												return this.backend.getSessionsNeedingBackup(e)
											}
											countSessionsNeedingBackup(e) {
												return this.backend.countSessionsNeedingBackup(e)
											}
											unmarkSessionsNeedingBackup(e, t) {
												return this.backend.unmarkSessionsNeedingBackup(e, t)
											}
											markSessionsNeedingBackup(e, t) {
												return this.backend.markSessionsNeedingBackup(e, t)
											}
											addSharedHistoryInboundGroupSession(e, t, r, n) {
												this.backend.addSharedHistoryInboundGroupSession(e, t, r, n)
											}
											getSharedHistoryInboundGroupSessions(e, t) {
												return this.backend.getSharedHistoryInboundGroupSessions(e, t)
											}
											addParkedSharedHistory(e, t, r) {
												this.backend.addParkedSharedHistory(e, t, r)
											}
											takeParkedSharedHistory(e, t) {
												return this.backend.takeParkedSharedHistory(e, t)
											}
											doTxn(e, t, r, n) {
												return this.backend.doTxn(e, t, r, n)
											}
										}
										n.IndexedDBCryptoStore = h, h.STORE_ACCOUNT = "account", h.STORE_SESSIONS = "sessions", h.STORE_INBOUND_GROUP_SESSIONS = "inbound_group_sessions", h.STORE_INBOUND_GROUP_SESSIONS_WITHHELD = "inbound_group_sessions_withheld", h.STORE_SHARED_HISTORY_INBOUND_GROUP_SESSIONS = "shared_history_inbound_group_sessions", h.STORE_PARKED_SHARED_HISTORY = "parked_shared_history", h.STORE_DEVICE_DATA = "device_data", h.STORE_ROOMS = "rooms", h.STORE_BACKUP = "sessions_needing_backup"
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"../../errors": 342,
								"../../indexeddb-helpers": 354,
								"../../logger": 356,
								"./indexeddb-crypto-store-backend": 328,
								"./localStorage-crypto-store": 330,
								"./memory-crypto-store": 331
							}],
							330: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.LocalStorageCryptoStore = void 0;
								const i = e("../../logger"),
									o = e("./memory-crypto-store"),
									s = "crypto.",
									a = s + "account",
									c = s + "cross_signing_keys",
									l = s + "notified_error_devices",
									u = s + "device_data",
									d = s + "inboundgroupsessions/",
									h = s + "inboundgroupsessions.withheld/",
									f = s + "rooms/",
									p = s + "sessionsneedingbackup";

								function v(e) {
									return s + "sessions/" + e
								}

								function g(e) {
									return s + "session.problems/" + e
								}

								function m(e, t) {
									return d + e + "/" + t
								}

								function y(e, t) {
									return h + e + "/" + t
								}

								function b(e) {
									return f + e
								}
								class _ extends o.MemoryCryptoStore {
									constructor(e) {
										super(), this.store = e
									}
									static exists(e) {
										var t;
										const r = e.length;
										for (let n = 0; n < r; n++)
											if (null === (t = e.key(n)) || void 0 === t ? void 0 : t.startsWith(s)) return !0;
										return !1
									}
									countEndToEndSessions(e, t) {
										var r;
										let n = 0;
										for (let i = 0; i < this.store.length; ++i)(null === (r = this.store.key(i)) || void 0 === r ? void 0 : r.startsWith(v(""))) && ++n;
										t(n)
									}
									_getEndToEndSessions(e) {
										const t = w(this.store, v(e)),
											r = {};
										for (const [n, i] of Object.entries(t || {})) r[n] = "string" == typeof i ? {
											session: i
										} : i;
										return r
									}
									getEndToEndSession(e, t, r, n) {
										n(this._getEndToEndSessions(e)[t] || {})
									}
									getEndToEndSessions(e, t, r) {
										r(this._getEndToEndSessions(e) || {})
									}
									getAllEndToEndSessions(e, t) {
										var r;
										for (let n = 0; n < this.store.length; ++n)
											if (null === (r = this.store.key(n)) || void 0 === r ? void 0 : r.startsWith(v(""))) {
												const e = this.store.key(n).split("/")[1];
												for (const r of Object.values(this._getEndToEndSessions(e))) t(r)
											}
									}
									storeEndToEndSession(e, t, r, n) {
										const i = this._getEndToEndSessions(e) || {};
										i[t] = r, S(this.store, v(e), i)
									}
									storeEndToEndSessionProblem(e, t, r) {
										return n(this, void 0, void 0, (function*() {
											const n = g(e),
												i = w(this.store, n) || [];
											i.push({
												type: t,
												fixed: r,
												time: Date.now()
											}), i.sort((e, t) => e.time - t.time), S(this.store, n, i)
										}))
									}
									getEndToEndSessionProblem(e, t) {
										return n(this, void 0, void 0, (function*() {
											const r = g(e),
												n = w(this.store, r) || [];
											if (!n.length) return null;
											const i = n[n.length - 1];
											for (const e of n)
												if (e.time > t) return Object.assign({}, e, {
													fixed: i.fixed
												});
											return i.fixed ? null : i
										}))
									}
									filterOutNotifiedErrorDevices(e) {
										return n(this, void 0, void 0, (function*() {
											const t = w(this.store, l) || {},
												r = [];
											for (const n of e) {
												const {
													userId: e,
													deviceInfo: i
												} = n;
												e in t ? i.deviceId in t[e] || (r.push(n), t[e][i.deviceId] = !0) : (r.push(n), t[e] = {
													[i.deviceId]: !0
												})
											}
											return S(this.store, l, t), r
										}))
									}
									getEndToEndInboundGroupSession(e, t, r, n) {
										n(w(this.store, m(e, t)), w(this.store, y(e, t)))
									}
									getAllEndToEndInboundGroupSessions(e, t) {
										for (let r = 0; r < this.store.length; ++r) {
											const e = this.store.key(r);
											(null == e ? void 0 : e.startsWith(d)) && t({
												senderKey: e.slice(d.length, d.length + 43),
												sessionId: e.slice(d.length + 44),
												sessionData: w(this.store, e)
											})
										}
										t(null)
									}
									addEndToEndInboundGroupSession(e, t, r, n) {
										w(this.store, m(e, t)) || this.storeEndToEndInboundGroupSession(e, t, r, n)
									}
									storeEndToEndInboundGroupSession(e, t, r, n) {
										S(this.store, m(e, t), r)
									}
									storeEndToEndInboundGroupSessionWithheld(e, t, r, n) {
										S(this.store, y(e, t), r)
									}
									getEndToEndDeviceData(e, t) {
										t(w(this.store, u))
									}
									storeEndToEndDeviceData(e, t) {
										S(this.store, u, e)
									}
									storeEndToEndRoom(e, t, r) {
										S(this.store, b(e), t)
									}
									getEndToEndRooms(e, t) {
										const r = {},
											n = b("");
										for (let i = 0; i < this.store.length; ++i) {
											const e = this.store.key(i);
											if (null == e ? void 0 : e.startsWith(n)) {
												r[e.slice(n.length)] = w(this.store, e)
											}
										}
										t(r)
									}
									getSessionsNeedingBackup(e) {
										const t = w(this.store, p) || {},
											r = [];
										for (const n in t)
											if (Object.prototype.hasOwnProperty.call(t, n)) {
												const t = n.slice(0, 43),
													i = n.slice(44);
												if (this.getEndToEndInboundGroupSession(t, i, null, e => {
														r.push({
															senderKey: t,
															sessionId: i,
															sessionData: e
														})
													}), e && r.length >= e) break
											} return Promise.resolve(r)
									}
									countSessionsNeedingBackup() {
										const e = w(this.store, p) || {};
										return Promise.resolve(Object.keys(e).length)
									}
									unmarkSessionsNeedingBackup(e) {
										const t = w(this.store, p) || {};
										for (const r of e) delete t[r.senderKey + "/" + r.sessionId];
										return S(this.store, p, t), Promise.resolve()
									}
									markSessionsNeedingBackup(e) {
										const t = w(this.store, p) || {};
										for (const r of e) t[r.senderKey + "/" + r.sessionId] = !0;
										return S(this.store, p, t), Promise.resolve()
									}
									deleteAllData() {
										return this.store.removeItem(a), Promise.resolve()
									}
									getAccount(e, t) {
										t(w(this.store, a))
									}
									storeAccount(e, t) {
										S(this.store, a, t)
									}
									getCrossSigningKeys(e, t) {
										t(w(this.store, c))
									}
									getSecretStorePrivateKey(e, t, r) {
										t(w(this.store, s + `ssss_cache.${r}`))
									}
									storeCrossSigningKeys(e, t) {
										S(this.store, c, t)
									}
									storeSecretStorePrivateKey(e, t, r) {
										S(this.store, s + `ssss_cache.${t}`, r)
									}
									doTxn(e, t, r) {
										return Promise.resolve(r(null))
									}
								}

								function w(e, t) {
									try {
										return JSON.parse(e.getItem(t))
									} catch (r) {
										i.logger.log("Error: Failed to get key %s: %s", t, r.message), i.logger.log(r.stack)
									}
									return null
								}

								function S(e, t, r) {
									e.setItem(t, JSON.stringify(r))
								}
								r.LocalStorageCryptoStore = _
							}, {
								"../../logger": 356,
								"./memory-crypto-store": 331
							}],
							331: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
										Object.defineProperty(e, "default", {
											enumerable: !0,
											value: t
										})
									} : function(e, t) {
										e.default = t
									}),
									o = this && this.__importStar || function(e) {
										if (e && e.__esModule) return e;
										var t = {};
										if (null != e)
											for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
										return i(t, e), t
									},
									s = this && this.__awaiter || function(e, t, r, n) {
										return new(r || (r = Promise))((function(i, o) {
											function s(e) {
												try {
													c(n.next(e))
												} catch (t) {
													o(t)
												}
											}

											function a(e) {
												try {
													c(n.throw(e))
												} catch (t) {
													o(t)
												}
											}

											function c(e) {
												var t;
												e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
													e(t)
												}))).then(s, a)
											}
											c((n = n.apply(e, t || [])).next())
										}))
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.MemoryCryptoStore = void 0;
								const a = e("../../logger"),
									c = o(e("../../utils"));
								r.MemoryCryptoStore = class {
									constructor() {
										this.outgoingRoomKeyRequests = [], this.account = null, this.crossSigningKeys = null, this.privateKeys = {}, this.sessions = {}, this.sessionProblems = {}, this.notifiedErrorDevices = {}, this.inboundGroupSessions = {}, this.inboundGroupSessionsWithheld = {}, this.deviceData = null, this.rooms = {}, this.sessionsNeedingBackup = {}, this.sharedHistoryInboundGroupSessions = {}, this.parkedSharedHistory = new Map
									}
									startup() {
										return s(this, void 0, void 0, (function*() {
											return this
										}))
									}
									deleteAllData() {
										return Promise.resolve()
									}
									getOrAddOutgoingRoomKeyRequest(e) {
										const t = e.requestBody;
										return c.promiseTry(() => {
											const r = this._getOutgoingRoomKeyRequest(t);
											return r ? (a.logger.log("already have key request outstanding for " + `${t.room_id} / ${t.session_id}: ` + "not sending another"), r) : (a.logger.log(`enqueueing key request for ${t.room_id} / ` + t.session_id), this.outgoingRoomKeyRequests.push(e), e)
										})
									}
									getOutgoingRoomKeyRequest(e) {
										return Promise.resolve(this._getOutgoingRoomKeyRequest(e))
									}
									_getOutgoingRoomKeyRequest(e) {
										for (const t of this.outgoingRoomKeyRequests)
											if (c.deepCompare(t.requestBody, e)) return t;
										return null
									}
									getOutgoingRoomKeyRequestByState(e) {
										for (const t of this.outgoingRoomKeyRequests)
											for (const r of e)
												if (t.state === r) return Promise.resolve(t);
										return Promise.resolve(null)
									}
									getAllOutgoingRoomKeyRequestsByState(e) {
										return Promise.resolve(this.outgoingRoomKeyRequests.filter(t => t.state == e))
									}
									getOutgoingRoomKeyRequestsByTarget(e, t, r) {
										const n = [];
										for (const i of this.outgoingRoomKeyRequests)
											for (const o of r) i.state === o && i.recipients.some(r => r.userId === e && r.deviceId === t) && n.push(i);
										return Promise.resolve(n)
									}
									updateOutgoingRoomKeyRequest(e, t, r) {
										for (const n of this.outgoingRoomKeyRequests)
											if (n.requestId === e) return n.state !== t ? (a.logger.warn(`Cannot update room key request from ${t} ` + `as it was already updated to ${n.state}`), Promise.resolve(null)) : (Object.assign(n, r), Promise.resolve(n));
										return Promise.resolve(null)
									}
									deleteOutgoingRoomKeyRequest(e, t) {
										for (let r = 0; r < this.outgoingRoomKeyRequests.length; r++) {
											const n = this.outgoingRoomKeyRequests[r];
											if (n.requestId === e) return n.state != t ? (a.logger.warn(`Cannot delete room key request in state ${n.state} ` + `(expected ${t})`), Promise.resolve(null)) : (this.outgoingRoomKeyRequests.splice(r, 1), Promise.resolve(n))
										}
										return Promise.resolve(null)
									}
									getAccount(e, t) {
										t(this.account)
									}
									storeAccount(e, t) {
										this.account = t
									}
									getCrossSigningKeys(e, t) {
										t(this.crossSigningKeys)
									}
									getSecretStorePrivateKey(e, t, r) {
										t(this.privateKeys[r] || null)
									}
									storeCrossSigningKeys(e, t) {
										this.crossSigningKeys = t
									}
									storeSecretStorePrivateKey(e, t, r) {
										this.privateKeys[t] = r
									}
									countEndToEndSessions(e, t) {
										t(Object.keys(this.sessions).length)
									}
									getEndToEndSession(e, t, r, n) {
										n((this.sessions[e] || {})[t] || null)
									}
									getEndToEndSessions(e, t, r) {
										r(this.sessions[e] || {})
									}
									getAllEndToEndSessions(e, t) {
										Object.entries(this.sessions).forEach(([e, r]) => {
											Object.entries(r).forEach(([r, n]) => {
												t(Object.assign(Object.assign({}, n), {
													deviceKey: e,
													sessionId: r
												}))
											})
										})
									}
									storeEndToEndSession(e, t, r, n) {
										let i = this.sessions[e];
										void 0 === i && (i = {}, this.sessions[e] = i), i[t] = r
									}
									storeEndToEndSessionProblem(e, t, r) {
										return s(this, void 0, void 0, (function*() {
											const n = this.sessionProblems[e] = this.sessionProblems[e] || [];
											n.push({
												type: t,
												fixed: r,
												time: Date.now()
											}), n.sort((e, t) => e.time - t.time)
										}))
									}
									getEndToEndSessionProblem(e, t) {
										return s(this, void 0, void 0, (function*() {
											const r = this.sessionProblems[e] || [];
											if (!r.length) return null;
											const n = r[r.length - 1];
											for (const e of r)
												if (e.time > t) return Object.assign({}, e, {
													fixed: n.fixed
												});
											return n.fixed ? null : n
										}))
									}
									filterOutNotifiedErrorDevices(e) {
										return s(this, void 0, void 0, (function*() {
											const t = this.notifiedErrorDevices,
												r = [];
											for (const n of e) {
												const {
													userId: e,
													deviceInfo: i
												} = n;
												e in t ? i.deviceId in t[e] || (r.push(n), t[e][i.deviceId] = !0) : (r.push(n), t[e] = {
													[i.deviceId]: !0
												})
											}
											return r
										}))
									}
									getEndToEndInboundGroupSession(e, t, r, n) {
										const i = e + "/" + t;
										n(this.inboundGroupSessions[i] || null, this.inboundGroupSessionsWithheld[i] || null)
									}
									getAllEndToEndInboundGroupSessions(e, t) {
										for (const r of Object.keys(this.inboundGroupSessions)) t({
											senderKey: r.slice(0, 43),
											sessionId: r.slice(44),
											sessionData: this.inboundGroupSessions[r]
										});
										t(null)
									}
									addEndToEndInboundGroupSession(e, t, r, n) {
										const i = e + "/" + t;
										void 0 === this.inboundGroupSessions[i] && (this.inboundGroupSessions[i] = r)
									}
									storeEndToEndInboundGroupSession(e, t, r, n) {
										this.inboundGroupSessions[e + "/" + t] = r
									}
									storeEndToEndInboundGroupSessionWithheld(e, t, r, n) {
										const i = e + "/" + t;
										this.inboundGroupSessionsWithheld[i] = r
									}
									getEndToEndDeviceData(e, t) {
										t(this.deviceData)
									}
									storeEndToEndDeviceData(e, t) {
										this.deviceData = e
									}
									storeEndToEndRoom(e, t, r) {
										this.rooms[e] = t
									}
									getEndToEndRooms(e, t) {
										t(this.rooms)
									}
									getSessionsNeedingBackup(e) {
										const t = [];
										for (const r in this.sessionsNeedingBackup)
											if (this.inboundGroupSessions[r] && (t.push({
													senderKey: r.slice(0, 43),
													sessionId: r.slice(44),
													sessionData: this.inboundGroupSessions[r]
												}), e && r.length >= e)) break;
										return Promise.resolve(t)
									}
									countSessionsNeedingBackup() {
										return Promise.resolve(Object.keys(this.sessionsNeedingBackup).length)
									}
									unmarkSessionsNeedingBackup(e) {
										for (const t of e) {
											const e = t.senderKey + "/" + t.sessionId;
											delete this.sessionsNeedingBackup[e]
										}
										return Promise.resolve()
									}
									markSessionsNeedingBackup(e) {
										for (const t of e) {
											const e = t.senderKey + "/" + t.sessionId;
											this.sessionsNeedingBackup[e] = !0
										}
										return Promise.resolve()
									}
									addSharedHistoryInboundGroupSession(e, t, r) {
										const n = this.sharedHistoryInboundGroupSessions[e] || [];
										n.push([t, r]), this.sharedHistoryInboundGroupSessions[e] = n
									}
									getSharedHistoryInboundGroupSessions(e) {
										return Promise.resolve(this.sharedHistoryInboundGroupSessions[e] || [])
									}
									addParkedSharedHistory(e, t) {
										var r;
										const n = null !== (r = this.parkedSharedHistory.get(e)) && void 0 !== r ? r : [];
										n.push(t), this.parkedSharedHistory.set(e, n)
									}
									takeParkedSharedHistory(e) {
										var t;
										const r = null !== (t = this.parkedSharedHistory.get(e)) && void 0 !== t ? t : [];
										return this.parkedSharedHistory.delete(e), Promise.resolve(r)
									}
									doTxn(e, t, r) {
										return Promise.resolve(r(null))
									}
								}
							}, {
								"../../logger": 356,
								"../../utils": 393
							}],
							332: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.VerificationBase = r.VerificationEvent = r.SwitchStartEventError = void 0;
								const i = e("../../models/event"),
									o = e("../../@types/event"),
									s = e("../../logger"),
									a = e("../deviceinfo"),
									c = e("./Error"),
									l = e("../CrossSigning"),
									u = e("../../models/typed-event-emitter"),
									d = new Error("Verification timed out");
								class SwitchStartEventError extends Error {
									constructor(e) {
										super(), this.startEvent = e
									}
								}
								var h;
								r.SwitchStartEventError = SwitchStartEventError,
									function(e) {
										e.Cancel = "cancel"
									}(h = r.VerificationEvent || (r.VerificationEvent = {}));
								class f extends u.TypedEventEmitter {
									constructor(e, t, r, n, i, o) {
										super(), this.channel = e, this.baseApis = t, this.userId = r, this.deviceId = n, this.startEvent = i, this.request = o, this.cancelled = !1, this._done = !1, this.promise = null, this.transactionTimeoutTimer = null
									}
									get initiatedByMe() {
										if (!this.startEvent) return !0;
										const e = this.startEvent.getSender(),
											t = this.startEvent.getContent();
										return e === this.baseApis.getUserId() && t.from_device === this.baseApis.getDeviceId()
									}
									get hasBeenCancelled() {
										return this.cancelled
									}
									resetTimer() {
										s.logger.info("Refreshing/starting the verification transaction timeout timer"), null !== this.transactionTimeoutTimer && clearTimeout(this.transactionTimeoutTimer), this.transactionTimeoutTimer = setTimeout(() => {
											this._done || this.cancelled || (s.logger.info("Triggering verification timeout"), this.cancel(d))
										}, 6e5)
									}
									endTimer() {
										null !== this.transactionTimeoutTimer && (clearTimeout(this.transactionTimeoutTimer), this.transactionTimeoutTimer = null)
									}
									send(e, t) {
										return this.channel.send(e, t)
									}
									waitForEvent(e) {
										if (this._done) return Promise.reject(new Error("Verification is already done"));
										const t = this.request.getEventFromOtherParty(e);
										return t ? Promise.resolve(t) : (this.expectedEvent = e, new Promise((e, t) => {
											this.resolveEvent = e, this.rejectEvent = t
										}))
									}
									canSwitchStartEvent(e) {
										return !1
									}
									switchStartEvent(e) {
										if (this.canSwitchStartEvent(e))
											if (s.logger.log("Verification Base: switching verification start event", {
													restartingFlow: !!this.rejectEvent
												}), this.rejectEvent) {
												const t = this.rejectEvent;
												this.rejectEvent = void 0, t(new SwitchStartEventError(e))
											} else this.startEvent = e
									}
									handleEvent(e) {
										var t;
										if (!this._done)
											if (e.getType() === this.expectedEvent) this.expectedEvent !== o.EventType.KeyVerificationDone && (this.expectedEvent = void 0, this.rejectEvent = void 0, this.resetTimer(), null === (t = this.resolveEvent) || void 0 === t || t.call(this, e));
											else if (e.getType() === o.EventType.KeyVerificationCancel) {
											const t = this.reject;
											if (this.reject = void 0, t) {
												const r = e.getContent(),
													{
														reason: n,
														code: i
													} = r;
												t(new Error("Other side cancelled verification " + `because ${n} (${i})`))
											}
										} else if (this.expectedEvent) {
											const t = new Error("Unexpected message: expecting " + this.expectedEvent + " but got " + e.getType());
											if (this.expectedEvent = void 0, this.rejectEvent) {
												const e = this.rejectEvent;
												this.rejectEvent = void 0, e(t)
											}
											this.cancel(t)
										}
									}
									done() {
										var e;
										return n(this, void 0, void 0, (function*() {
											if (this.endTimer(), !this._done) return this.request.onVerifierFinished(), null === (e = this.resolve) || void 0 === e || e.call(this), (0, l.requestKeysDuringVerification)(this.baseApis, this.userId, this.deviceId)
										}))
									}
									cancel(e) {
										if (this.endTimer(), !this._done) {
											if (this.cancelled = !0, this.request.onVerifierCancelled(), this.userId && this.deviceId)
												if (e === d) {
													const e = (0, c.newTimeoutError)();
													this.send(e.getType(), e.getContent())
												} else if (e instanceof i.MatrixEvent) {
												if (e.getSender() !== this.userId) {
													const t = e.getContent();
													e.getType() === o.EventType.KeyVerificationCancel ? (t.code = t.code || "m.unknown", t.reason = t.reason || t.body || "Unknown reason", this.send(o.EventType.KeyVerificationCancel, t)) : this.send(o.EventType.KeyVerificationCancel, {
														code: "m.unknown",
														reason: t.body || "Unknown reason"
													})
												}
											} else this.send(o.EventType.KeyVerificationCancel, {
												code: "m.unknown",
												reason: e.toString()
											});
											null !== this.promise ? this.reject && this.reject(e) : this.promise = Promise.reject(e), this.emit(h.Cancel, e)
										}
									}
									verify() {
										return this.promise ? this.promise : (this.promise = new Promise((e, t) => {
											this.resolve = (...t) => {
												this._done = !0, this.endTimer(), e(...t)
											}, this.reject = e => {
												this._done = !0, this.endTimer(), t(e)
											}
										}), this.doVerification && !this.started && (this.started = !0, this.resetTimer(), new Promise((e, t) => {
											var r;
											(null === (r = this.baseApis.crypto.deviceList.getStoredCrossSigningForUser(this.userId)) || void 0 === r ? void 0 : r.getId()) === this.deviceId && t(new Error("Device ID is the same as the cross-signing ID")), e()
										}).then(() => this.doVerification()).then(this.done.bind(this), this.cancel.bind(this))), this.promise)
									}
									verifyKeys(e, t, r) {
										return n(this, void 0, void 0, (function*() {
											const n = [];
											for (const [i, o] of Object.entries(t)) {
												const t = i.split(":", 2)[1],
													c = this.baseApis.getStoredDevice(e, t);
												if (c) r(i, c, o), n.push([t, i, c.keys[i]]);
												else {
													const c = this.baseApis.crypto.deviceList.getStoredCrossSigningForUser(e);
													c && c.getId() === t ? (r(i, a.DeviceInfo.fromStorage({
														keys: {
															[i]: t
														}
													}, t), o), n.push([t, i, t])) : s.logger.warn(`verification: Could not find device ${t} to verify`)
												}
											}
											if (!n.length) throw new Error("No devices could be verified");
											s.logger.info("Verification completed! Marking devices verified: ", n);
											for (const [t, r, i] of n) yield this.baseApis.crypto.setDeviceVerification(e, t, !0, null, null, {
												[r]: i
											});
											e == this.baseApis.credentials.userId && (yield this.baseApis.checkKeyBackup())
										}))
									}
									get events() {}
								}
								r.VerificationBase = f
							}, {
								"../../@types/event": 290,
								"../../logger": 356,
								"../../models/event": 365,
								"../../models/typed-event-emitter": 376,
								"../CrossSigning": 307,
								"../deviceinfo": 323,
								"./Error": 333
							}],
							333: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.errorFromEvent = r.newInvalidMessageError = r.newKeyMismatchError = r.newUnexpectedMessageError = r.newUnknownMethodError = r.newTimeoutError = r.newUserCancelledError = r.errorFactory = r.newVerificationError = void 0;
								const n = e("../../models/event"),
									i = e("../../@types/event");

								function o(e, t, r) {
									const o = Object.assign({}, {
										code: e,
										reason: t
									}, r);
									return new n.MatrixEvent({
										type: i.EventType.KeyVerificationCancel,
										content: o
									})
								}

								function s(e, t) {
									return function(r) {
										return o(e, t, r)
									}
								}
								r.newVerificationError = o, r.errorFactory = s, r.newUserCancelledError = s("m.user", "Cancelled by user"), r.newTimeoutError = s("m.timeout", "Timed out"), r.newUnknownMethodError = s("m.unknown_method", "Unknown method"), r.newUnexpectedMessageError = s("m.unexpected_message", "Unexpected message"), r.newKeyMismatchError = s("m.key_mismatch", "Key mismatch"), r.newInvalidMessageError = s("m.invalid_message", "Invalid message"), r.errorFromEvent = function(e) {
									const t = e.getContent();
									if (t) {
										const {
											code: e,
											reason: r
										} = t;
										return {
											code: e,
											reason: r
										}
									}
									return {
										code: "Unknown error",
										reason: "m.unknown"
									}
								}
							}, {
								"../../@types/event": 290,
								"../../models/event": 365
							}],
							334: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.IllegalMethod = void 0;
								const i = e("./Base");
								class o extends i.VerificationBase {
									constructor() {
										super(...arguments), this.doVerification = () => n(this, void 0, void 0, (function*() {
											throw new Error("Verification is not possible with this method")
										}))
									}
									static factory(e, t, r, n, i, s) {
										return new o(e, t, r, n, i, s)
									}
									static get NAME() {
										return "org.matrix.illegal_method"
									}
								}
								r.IllegalMethod = o
							}, {
								"./Base": 332
							}],
							335: [function(t, r, n) {
								(function(e, r) {
									(function() {
										"use strict";
										var i = this && this.__awaiter || function(e, t, r, n) {
											return new(r || (r = Promise))((function(i, o) {
												function s(e) {
													try {
														c(n.next(e))
													} catch (t) {
														o(t)
													}
												}

												function a(e) {
													try {
														c(n.throw(e))
													} catch (t) {
														o(t)
													}
												}

												function c(e) {
													var t;
													e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
														e(t)
													}))).then(s, a)
												}
												c((n = n.apply(e, t || [])).next())
											}))
										};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.QRCodeData = n.ReciprocateQRCode = n.QrCodeEvent = n.SCAN_QR_CODE_METHOD = n.SHOW_QR_CODE_METHOD = void 0;
										const o = t("./Base"),
											s = t("./Error"),
											a = t("../olmlib"),
											c = t("../../logger");
										var l;
										n.SHOW_QR_CODE_METHOD = "m.qr_code.show.v1", n.SCAN_QR_CODE_METHOD = "m.qr_code.scan.v1",
											function(e) {
												e.ShowReciprocateQr = "show_reciprocate_qr"
											}(l = n.QrCodeEvent || (n.QrCodeEvent = {}));
										class u extends o.VerificationBase {
											constructor() {
												super(...arguments), this.doVerification = () => i(this, void 0, void 0, (function*() {
													if (!this.startEvent) throw new Error("It is not currently possible to start verificationwith this method yet.");
													const {
														qrCodeData: e
													} = this.request;
													if (this.startEvent.getContent().secret !== (null == e ? void 0 : e.encodedSharedSecret)) throw (0, s.newKeyMismatchError)();
													yield new Promise((e, t) => {
														this.reciprocateQREvent = {
															confirm: e,
															cancel: () => t((0, s.newUserCancelledError)())
														}, this.emit(l.ShowReciprocateQr, this.reciprocateQREvent)
													});
													const t = {};
													switch (null == e ? void 0 : e.mode) {
														case f.VerifyOtherUser: {
															const r = e.otherUserMasterKey;
															t[`ed25519:${r}`] = r;
															break
														}
														case f.VerifySelfTrusted: {
															const r = this.request.targetDevice.deviceId;
															t[`ed25519:${r}`] = e.otherDeviceKey;
															break
														}
														case f.VerifySelfUntrusted: {
															const r = e.myMasterKey;
															t[`ed25519:${r}`] = r;
															break
														}
													}
													yield this.verifyKeys(this.userId, t, (e, r, n) => {
														const i = t[e];
														if (!i) throw (0, s.newKeyMismatchError)();
														if (n !== i) throw c.logger.error("key ID from key info does not match"), (0, s.newKeyMismatchError)();
														for (const o in r.keys) {
															if (!o.startsWith("ed25519")) continue;
															const e = t[o];
															if (!e) throw (0, s.newKeyMismatchError)();
															if (r.keys[o] !== e) throw c.logger.error("master key does not match"), (0, s.newKeyMismatchError)()
														}
													})
												}))
											}
											static factory(e, t, r, n, i, o) {
												return new u(e, t, r, n, i, o)
											}
											static get NAME() {
												return "m.reciprocate.v1"
											}
										}
										n.ReciprocateQRCode = u;
										const d = 2,
											h = "MATRIX";
										var f;
										! function(e) {
											e[e.VerifyOtherUser = 0] = "VerifyOtherUser", e[e.VerifySelfTrusted = 1] = "VerifySelfTrusted", e[e.VerifySelfUntrusted = 2] = "VerifySelfUntrusted"
										}(f || (f = {}));
										class p {
											constructor(e, t, r, n, i, o) {
												this.mode = e, this.sharedSecret = t, this.otherUserMasterKey = r, this.otherDeviceKey = n, this.myMasterKey = i, this.buffer = o
											}
											static create(e, t) {
												return i(this, void 0, void 0, (function*() {
													const r = p.generateSharedSecret(),
														n = p.determineMode(e, t);
													let i = null,
														o = null,
														s = null;
													if (n === f.VerifyOtherUser) {
														i = t.getStoredCrossSigningForUser(e.otherUserId).getId("master")
													} else if (n === f.VerifySelfTrusted) o = yield p.getOtherDeviceKey(e, t);
													else if (n === f.VerifySelfUntrusted) {
														const e = t.getUserId();
														s = t.getStoredCrossSigningForUser(e).getId("master")
													}
													const a = p.generateQrData(e, t, n, r, i, o, s),
														c = p.generateBuffer(a);
													return new p(n, r, i, o, s, c)
												}))
											}
											get encodedSharedSecret() {
												return this.sharedSecret
											}
											getBuffer() {
												return this.buffer
											}
											static generateSharedSecret() {
												const t = new Uint8Array(11);
												return e.crypto.getRandomValues(t), (0, a.encodeUnpaddedBase64)(t)
											}
											static getOtherDeviceKey(e, t) {
												return i(this, void 0, void 0, (function*() {
													const r = t.getUserId(),
														n = e.targetDevice,
														i = n.deviceId ? t.getStoredDevice(r, n.deviceId) : void 0;
													if (!i) throw new Error("could not find device " + (null == n ? void 0 : n.deviceId));
													return i.getFingerprint()
												}))
											}
											static determineMode(e, t) {
												const r = t.getUserId(),
													n = e.otherUserId;
												let i = f.VerifyOtherUser;
												if (r === n) {
													i = t.checkUserTrust(r).isCrossSigningVerified() ? f.VerifySelfTrusted : f.VerifySelfUntrusted
												}
												return i
											}
											static generateQrData(e, t, r, n, i, o, s) {
												const a = t.getUserId(),
													c = e.channel.transactionId,
													l = {
														prefix: h,
														version: d,
														mode: r,
														transactionId: c,
														firstKeyB64: "",
														secondKeyB64: "",
														secretB64: n
													},
													u = t.getStoredCrossSigningForUser(a);
												return r === f.VerifyOtherUser ? (l.firstKeyB64 = u.getId("master"), l.secondKeyB64 = i) : r === f.VerifySelfTrusted ? (l.firstKeyB64 = u.getId("master"), l.secondKeyB64 = o) : r === f.VerifySelfUntrusted && (l.firstKeyB64 = t.getDeviceEd25519Key(), l.secondKeyB64 = s), l
											}
											static generateBuffer(e) {
												let t = r.alloc(0);
												const n = e => {
														const n = r.from([e]);
														t = r.concat([t, n])
													},
													i = (e, n, i = !0) => {
														const o = r.from(e, n);
														i && (e => {
															const n = r.alloc(2);
															n.writeInt16BE(e, 0), t = r.concat([t, n])
														})(o.byteLength), t = r.concat([t, o])
													},
													o = e => {
														const n = (0, a.decodeBase64)(e),
															i = r.from(n);
														t = r.concat([t, i])
													};
												return i(e.prefix, "ascii", !1), n(e.version), n(e.mode), i(e.transactionId, "utf-8"), o(e.firstKeyB64), o(e.secondKeyB64), o(e.secretB64), t
											}
										}
										n.QRCodeData = p
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, t("buffer").Buffer)
							}, {
								"../../logger": 356,
								"../olmlib": 326,
								"./Base": 332,
								"./Error": 333,
								buffer: 69
							}],
							336: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var r = this && this.__awaiter || function(e, t, r, n) {
												return new(r || (r = Promise))((function(i, o) {
													function s(e) {
														try {
															c(n.next(e))
														} catch (t) {
															o(t)
														}
													}

													function a(e) {
														try {
															c(n.throw(e))
														} catch (t) {
															o(t)
														}
													}

													function c(e) {
														var t;
														e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
															e(t)
														}))).then(s, a)
													}
													c((n = n.apply(e, t || [])).next())
												}))
											},
											i = this && this.__importDefault || function(e) {
												return e && e.__esModule ? e : {
													default: e
												}
											};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.SAS = n.SasEvent = void 0;
										const o = i(t("another-json")),
											s = t("./Base"),
											a = t("./Error"),
											c = t("../../logger"),
											l = t("./SASDecimal"),
											u = t("../../@types/event"),
											d = u.EventType.KeyVerificationStart,
											h = [u.EventType.KeyVerificationAccept, u.EventType.KeyVerificationKey, u.EventType.KeyVerificationMac];
										let f;
										const p = (0, a.errorFactory)("m.mismatched_sas", "Mismatched short authentication string"),
											v = (0, a.errorFactory)("m.mismatched_commitment", "Mismatched commitment"),
											g = [
												["", "dog"],
												["", "cat"],
												["", "lion"],
												["", "horse"],
												["", "unicorn"],
												["", "pig"],
												["", "elephant"],
												["", "rabbit"],
												["", "panda"],
												["", "rooster"],
												["", "penguin"],
												["", "turtle"],
												["", "fish"],
												["", "octopus"],
												["", "butterfly"],
												["", "flower"],
												["", "tree"],
												["", "cactus"],
												["", "mushroom"],
												["", "globe"],
												["", "moon"],
												["", "cloud"],
												["", "fire"],
												["", "banana"],
												["", "apple"],
												["", "strawberry"],
												["", "corn"],
												["", "pizza"],
												["", "cake"],
												["", "heart"],
												["", "smiley"],
												["", "robot"],
												["", "hat"],
												["", "glasses"],
												["", "spanner"],
												["", "santa"],
												["", "thumbs up"],
												["", "umbrella"],
												["", "hourglass"],
												["", "clock"],
												["", "gift"],
												["", "light bulb"],
												["", "book"],
												["", "pencil"],
												["", "paperclip"],
												["", "scissors"],
												["", "lock"],
												["", "key"],
												["", "hammer"],
												["", "telephone"],
												["", "flag"],
												["", "train"],
												["", "bicycle"],
												["", "aeroplane"],
												["", "rocket"],
												["", "trophy"],
												["", "ball"],
												["", "guitar"],
												["", "trumpet"],
												["", "bell"],
												["", "anchor"],
												["", "headphones"],
												["", "folder"],
												["", "pin"]
											];
										const m = {
											decimal: l.generateDecimalSas,
											emoji: function(e) {
												return [e[0] >> 2, (3 & e[0]) << 4 | e[1] >> 4, (15 & e[1]) << 2 | e[2] >> 6, 63 & e[2], e[3] >> 2, (3 & e[3]) << 4 | e[4] >> 4, (15 & e[4]) << 2 | e[5] >> 6].map(e => g[e])
											}
										};

										function y(e, t) {
											const r = {};
											for (const n of t) n in m && (r[n] = m[n](e));
											return r
										}
										const b = {
											"hkdf-hmac-sha256": "calculate_mac",
											"org.matrix.msc3783.hkdf-hmac-sha256": "calculate_mac_fixed_base64",
											"hmac-sha256": "calculate_mac_long_kdf"
										};

										function _(e, t) {
											return function(...r) {
												const n = e[b[t]].apply(e, r);
												return c.logger.log("SAS calculateMAC:", t, r, n), n
											}
										}
										const w = {
												"curve25519-hkdf-sha256": function(e, t, r) {
													const n = `${e.baseApis.getUserId()}|${e.baseApis.deviceId}|` + `${e.ourSASPubKey}|`,
														i = `${e.userId}|${e.deviceId}|${e.theirSASPubKey}|`,
														o = "MATRIX_KEY_VERIFICATION_SAS|" + (e.initiatedByMe ? n + i : i + n) + e.channel.transactionId;
													return t.generate_bytes(o, r)
												},
												curve25519: function(e, t, r) {
													const n = `${e.baseApis.getUserId()}${e.baseApis.deviceId}`,
														i = `${e.userId}${e.deviceId}`,
														o = "MATRIX_KEY_VERIFICATION_SAS" + (e.initiatedByMe ? n + i : i + n) + e.channel.transactionId;
													return t.generate_bytes(o, r)
												}
											},
											S = ["curve25519-hkdf-sha256", "curve25519"],
											E = ["sha256"],
											k = ["org.matrix.msc3783.hkdf-hmac-sha256", "hkdf-hmac-sha256", "hmac-sha256"],
											T = Object.keys(m),
											I = new Set(S),
											R = new Set(E),
											C = new Set(k),
											M = new Set(T);

										function x(e, t) {
											return Array.isArray(e) ? e.filter(e => t.has(e)) : []
										}
										var O;
										! function(e) {
											e.ShowSas = "show_sas"
										}(O = n.SasEvent || (n.SasEvent = {}));
										class A extends s.VerificationBase {
											constructor() {
												super(...arguments), this.doVerification = () => r(this, void 0, void 0, (function*() {
													yield e.Olm.init(), f = f || new e.Olm.Utility, yield this.baseApis.downloadKeys([this.userId]);
													let t = !1;
													do {
														try {
															return this.initiatedByMe ? yield this.doSendVerification(): yield this.doRespondVerification()
														} catch (r) {
															if (!(r instanceof s.SwitchStartEventError)) throw r;
															this.startEvent = r.startEvent, t = !0
														}
													} while (t)
												}))
											}
											static get NAME() {
												return "m.sas.v1"
											}
											get events() {
												return h
											}
											canSwitchStartEvent(e) {
												if (e.getType() !== d) return !1;
												const t = e.getContent();
												return (null == t ? void 0 : t.method) === A.NAME && !!this.waitingForAccept
											}
											sendStart() {
												return r(this, void 0, void 0, (function*() {
													const e = this.channel.completeContent(d, {
														method: A.NAME,
														from_device: this.baseApis.deviceId,
														key_agreement_protocols: S,
														hashes: E,
														message_authentication_codes: k,
														short_authentication_string: T
													});
													return yield this.channel.sendCompleted(d, e), e
												}))
											}
											verifyAndCheckMAC(e, t, n, i) {
												return r(this, void 0, void 0, (function*() {
													const o = w[e](this, n, 6),
														s = new Promise((e, s) => {
															this.sasEvent = {
																sas: y(o, t),
																confirm: () => r(this, void 0, void 0, (function*() {
																	try {
																		yield this.sendMAC(n, i), e()
																	} catch (t) {
																		s(t)
																	}
																})),
																cancel: () => s((0, a.newUserCancelledError)()),
																mismatch: () => s(p())
															}, this.emit(O.ShowSas, this.sasEvent)
														}),
														[c] = yield Promise.all([this.waitForEvent(u.EventType.KeyVerificationMac).then(e => (this.expectedEvent = u.EventType.KeyVerificationDone, e)), s]), l = c.getContent();
													yield this.checkMAC(n, l, i)
												}))
											}
											doSendVerification() {
												return r(this, void 0, void 0, (function*() {
													let t, r;
													if (this.waitingForAccept = !0, t = this.startEvent ? this.channel.completedContentFromEvent(this.startEvent) : yield this.sendStart(), !this.initiatedByMe) throw new s.SwitchStartEventError(this.startEvent);
													try {
														r = yield this.waitForEvent(u.EventType.KeyVerificationAccept)
													} finally {
														this.waitingForAccept = !1
													}
													let n = r.getContent();
													const i = x(n.short_authentication_string, M);
													if (!(I.has(n.key_agreement_protocol) && R.has(n.hash) && C.has(n.message_authentication_code) && i.length)) throw (0, a.newUnknownMethodError)();
													if ("string" != typeof n.commitment) throw (0, a.newInvalidMessageError)();
													const c = n.key_agreement_protocol,
														l = n.message_authentication_code,
														d = n.commitment,
														h = new e.Olm.SAS;
													try {
														this.ourSASPubKey = h.get_pubkey(), yield this.send(u.EventType.KeyVerificationKey, {
															key: this.ourSASPubKey
														});
														const e = (n = (r = yield this.waitForEvent(u.EventType.KeyVerificationKey)).getContent()).key + o.default.stringify(t);
														if (f.sha256(e) !== d) throw v();
														this.theirSASPubKey = n.key, h.set_their_key(n.key), yield this.verifyAndCheckMAC(c, i, h, l)
													} finally {
														h.free()
													}
												}))
											}
											doRespondVerification() {
												return r(this, void 0, void 0, (function*() {
													let t = this.channel.completedContentFromEvent(this.startEvent);
													const r = x(S, new Set(t.key_agreement_protocols))[0],
														n = x(E, new Set(t.hashes))[0],
														i = x(k, new Set(t.message_authentication_codes))[0],
														s = x(t.short_authentication_string, M);
													if (void 0 === r || void 0 === n || void 0 === i || !s.length) throw (0, a.newUnknownMethodError)();
													const c = new e.Olm.SAS;
													try {
														const e = c.get_pubkey() + o.default.stringify(t);
														yield this.send(u.EventType.KeyVerificationAccept, {
															key_agreement_protocol: r,
															hash: n,
															message_authentication_code: i,
															short_authentication_string: s,
															commitment: f.sha256(e)
														}), t = (yield this.waitForEvent(u.EventType.KeyVerificationKey)).getContent(), this.theirSASPubKey = t.key, c.set_their_key(t.key), this.ourSASPubKey = c.get_pubkey(), yield this.send(u.EventType.KeyVerificationKey, {
															key: this.ourSASPubKey
														}), yield this.verifyAndCheckMAC(r, s, c, i)
													} finally {
														c.free()
													}
												}))
											}
											sendMAC(e, t) {
												const r = {},
													n = [],
													i = "MATRIX_KEY_VERIFICATION_MAC" + this.baseApis.getUserId() + this.baseApis.deviceId + this.userId + this.deviceId + this.channel.transactionId,
													o = `ed25519:${this.baseApis.deviceId}`;
												r[o] = _(e, t)(this.baseApis.getDeviceEd25519Key(), i + o), n.push(o);
												const s = this.baseApis.getCrossSigningId();
												if (s) {
													const o = `ed25519:${s}`;
													r[o] = _(e, t)(s, i + o), n.push(o)
												}
												const a = _(e, t)(n.sort().join(","), i + "KEY_IDS");
												return this.send(u.EventType.KeyVerificationMac, {
													mac: r,
													keys: a
												})
											}
											checkMAC(e, t, n) {
												return r(this, void 0, void 0, (function*() {
													const r = "MATRIX_KEY_VERIFICATION_MAC" + this.userId + this.deviceId + this.baseApis.getUserId() + this.baseApis.deviceId + this.channel.transactionId;
													if (t.keys !== _(e, n)(Object.keys(t.mac).sort().join(","), r + "KEY_IDS")) throw (0, a.newKeyMismatchError)();
													yield this.verifyKeys(this.userId, t.mac, (t, i, o) => {
														if (o !== _(e, n)(i.keys[t], r + t)) throw (0, a.newKeyMismatchError)()
													})
												}))
											}
										}
										n.SAS = A
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"../../@types/event": 290,
								"../../logger": 356,
								"./Base": 332,
								"./Error": 333,
								"./SASDecimal": 337,
								"another-json": 2
							}],
							337: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.generateDecimalSas = void 0, r.generateDecimalSas = function(e) {
									return [1e3 + (e[0] << 5 | e[1] >> 3), 1e3 + ((7 & e[1]) << 10 | e[2] << 2 | e[3] >> 6), 1e3 + ((63 & e[3]) << 7 | e[4] >> 1)]
								}
							}, {}],
							338: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.InRoomRequests = r.InRoomChannel = void 0;
								const i = e("./VerificationRequest"),
									o = e("../../../logger"),
									s = e("../../../@types/event").EventType.RoomMessage,
									a = "m.reference",
									c = "m.relates_to";
								class l {
									constructor(e, t, r) {
										this.client = e, this.roomId = t, this.userId = r
									}
									get receiveStartFromOtherDevices() {
										return !0
									}
									get transactionId() {
										return this.requestEventId
									}
									static getOtherPartyUserId(e, t) {
										if (l.getEventType(e) !== i.REQUEST_TYPE) return;
										const r = t.getUserId(),
											n = e.getSender(),
											o = e.getContent().to;
										return n === r ? o : o === r ? n : void 0
									}
									getTimestamp(e) {
										return e.getTs()
									}
									static canCreateRequest(e) {
										return e === i.REQUEST_TYPE
									}
									canCreateRequest(e) {
										return l.canCreateRequest(e)
									}
									static getTransactionId(e) {
										if (l.getEventType(e) === i.REQUEST_TYPE) return e.getId(); {
											const t = e.getRelation();
											if ((null == t ? void 0 : t.rel_type) === a) return t.event_id
										}
									}
									static validateEvent(e, t) {
										const r = l.getTransactionId(e);
										if ("string" != typeof r || 0 === r.length) return !1;
										const n = l.getEventType(e),
											s = e.getContent();
										if (n === i.REQUEST_TYPE) {
											if (!s || "string" != typeof s.to || !s.to.length) return o.logger.log("InRoomChannel: validateEvent: no valid to " + (s && s.to)), !1;
											if (!l.getOtherPartyUserId(e, t)) return o.logger.log("InRoomChannel: validateEvent: " + `not directed to or sent by me: ${e.getSender()}` + `, ${s&&s.to}`), !1
										}
										return i.VerificationRequest.validateEvent(n, e, t)
									}
									static getEventType(e) {
										const t = e.getType();
										if (t === s) {
											const t = e.getContent();
											if (t) {
												const {
													msgtype: e
												} = t;
												if (e === i.REQUEST_TYPE) return i.REQUEST_TYPE
											}
										}
										return t && t !== i.REQUEST_TYPE ? t : ""
									}
									handleEvent(e, t, r = !1) {
										return n(this, void 0, void 0, (function*() {
											if (t.hasEventId(e.getId())) return;
											const n = l.getEventType(e);
											if (e.getRoomId() !== this.roomId) return;
											if (!this.userId) {
												const t = l.getOtherPartyUserId(e, this.client);
												t && (this.userId = t)
											}
											const i = this.client.getUserId(),
												s = e.getSender();
											if (this.userId && s !== i && s !== this.userId) return void o.logger.log(`InRoomChannel: ignoring verification event from non-participating sender ${s}`);
											this.requestEventId || (this.requestEventId = l.getTransactionId(e));
											const a = !!e.getUnsigned().transaction_id,
												c = e.getSender() === this.client.getUserId();
											return t.handleEvent(n, e, r, a, c)
										}))
									}
									completedContentFromEvent(e) {
										const t = Object.assign({}, e.getContent());
										return t[c] = e.getRelation(), t
									}
									completeContent(e, t) {
										return t = Object.assign({}, t), e !== i.REQUEST_TYPE && e !== i.READY_TYPE && e !== i.START_TYPE || (t.from_device = this.client.getDeviceId()), e === i.REQUEST_TYPE ? t = {
											body: this.client.getUserId() + " is requesting to verify your key, but your client does not support in-chat key verification.  You will need to use legacy key verification to verify keys.",
											msgtype: i.REQUEST_TYPE,
											to: this.userId,
											from_device: t.from_device,
											methods: t.methods
										} : t[c] = {
											rel_type: a,
											event_id: this.transactionId
										}, t
									}
									send(e, t) {
										const r = this.completeContent(e, t);
										return this.sendCompleted(e, r)
									}
									sendCompleted(e, t) {
										return n(this, void 0, void 0, (function*() {
											let r = e;
											e === i.REQUEST_TYPE && (r = s);
											const n = yield this.client.sendEvent(this.roomId, r, t);
											e === i.REQUEST_TYPE && (this.requestEventId = n.event_id)
										}))
									}
								}
								r.InRoomChannel = l;
								r.InRoomRequests = class {
									constructor() {
										this.requestsByRoomId = new Map
									}
									getRequest(e) {
										const t = e.getRoomId(),
											r = l.getTransactionId(e);
										return this.getRequestByTxnId(t, r)
									}
									getRequestByChannel(e) {
										return this.getRequestByTxnId(e.roomId, e.transactionId)
									}
									getRequestByTxnId(e, t) {
										const r = this.requestsByRoomId.get(e);
										if (r) return r.get(t)
									}
									setRequest(e, t) {
										this.doSetRequest(e.getRoomId(), l.getTransactionId(e), t)
									}
									setRequestByChannel(e, t) {
										this.doSetRequest(e.roomId, e.transactionId, t)
									}
									doSetRequest(e, t, r) {
										let n = this.requestsByRoomId.get(e);
										n || (n = new Map, this.requestsByRoomId.set(e, n)), n.set(t, r)
									}
									removeRequest(e) {
										const t = e.getRoomId(),
											r = this.requestsByRoomId.get(t);
										r && (r.delete(l.getTransactionId(e)), 0 === r.size && this.requestsByRoomId.delete(t))
									}
									findRequestInProgress(e) {
										const t = this.requestsByRoomId.get(e);
										if (t)
											for (const r of t.values())
												if (r.pending) return r
									}
								}
							}, {
								"../../../@types/event": 290,
								"../../../logger": 356,
								"./VerificationRequest": 340
							}],
							339: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.ToDeviceRequests = r.ToDeviceChannel = void 0;
								const i = e("../../../randomstring"),
									o = e("../../../logger"),
									s = e("./VerificationRequest"),
									a = e("../Error"),
									c = e("../../../models/event");
								class l {
									constructor(e, t, r, n, i) {
										this.client = e, this.userId = t, this.devices = r, this.transactionId = n, this.deviceId = i
									}
									isToDevices(e) {
										if (e.length === this.devices.length) {
											for (const t of e)
												if (!this.devices.includes(t)) return !1;
											return !0
										}
										return !1
									}
									static getEventType(e) {
										return e.getType()
									}
									static getTransactionId(e) {
										const t = e.getContent();
										return t && t.transaction_id
									}
									static canCreateRequest(e) {
										return e === s.REQUEST_TYPE || e === s.START_TYPE
									}
									canCreateRequest(e) {
										return l.canCreateRequest(e)
									}
									static validateEvent(e, t) {
										if (e.isCancelled()) return o.logger.warn("Ignoring flagged verification request from " + e.getSender()), !1;
										const r = e.getContent();
										if (!r) return o.logger.warn("ToDeviceChannel.validateEvent: invalid: no content"), !1;
										if (!r.transaction_id) return o.logger.warn("ToDeviceChannel.validateEvent: invalid: no transaction_id"), !1;
										const n = e.getType();
										if (n === s.REQUEST_TYPE) {
											if (!Number.isFinite(r.timestamp)) return o.logger.warn("ToDeviceChannel.validateEvent: invalid: no timestamp"), !1;
											if (e.getSender() === t.getUserId() && r.from_device == t.getDeviceId()) return o.logger.warn("ToDeviceChannel.validateEvent: invalid: from own device"), !1
										}
										return s.VerificationRequest.validateEvent(n, e, t)
									}
									getTimestamp(e) {
										const t = e.getContent();
										return t && t.timestamp
									}
									handleEvent(e, t, r = !1) {
										return n(this, void 0, void 0, (function*() {
											const n = e.getType(),
												i = e.getContent();
											if (n === s.REQUEST_TYPE || n === s.READY_TYPE || n === s.START_TYPE) {
												this.transactionId || (this.transactionId = i.transaction_id);
												const e = i.from_device;
												if (!this.deviceId && this.devices.includes(e) && (this.deviceId = e), !this.deviceId || this.deviceId !== e) {
													const t = this.completeContent(s.CANCEL_TYPE, (0, a.errorFromEvent)((0, a.newUnexpectedMessageError)()));
													return this.sendToDevices(s.CANCEL_TYPE, t, [e])
												}
											}
											const o = t.phase === s.PHASE_STARTED || t.phase === s.PHASE_READY;
											yield t.handleEvent(e.getType(), e, r, !1, !1);
											const c = t.phase === s.PHASE_STARTED || t.phase === s.PHASE_READY;
											if ((n === s.START_TYPE || n === s.READY_TYPE) && !o && c && this.deviceId) {
												const e = this.devices.filter(e => e !== this.deviceId && e !== this.client.getDeviceId());
												if (e.length) {
													const t = this.completeContent(s.CANCEL_TYPE, {
														code: "m.accepted",
														reason: "Verification request accepted by another device"
													});
													yield this.sendToDevices(s.CANCEL_TYPE, t, e)
												}
											}
										}))
									}
									completedContentFromEvent(e) {
										return e.getContent()
									}
									completeContent(e, t) {
										return t = Object.assign({}, t), this.transactionId && (t.transaction_id = this.transactionId), e !== s.REQUEST_TYPE && e !== s.READY_TYPE && e !== s.START_TYPE || (t.from_device = this.client.getDeviceId()), e === s.REQUEST_TYPE && (t.timestamp = Date.now()), t
									}
									send(e, t = {}) {
										e !== s.REQUEST_TYPE && e !== s.START_TYPE || this.transactionId || (this.transactionId = l.makeTransactionId());
										const r = this.completeContent(e, t);
										return this.sendCompleted(e, r)
									}
									sendCompleted(e, t) {
										return n(this, void 0, void 0, (function*() {
											let r;
											r = e === s.REQUEST_TYPE || e === s.CANCEL_TYPE && !this.deviceId ? yield this.sendToDevices(e, t, this.devices): yield this.sendToDevices(e, t, [this.deviceId]);
											const n = new c.MatrixEvent({
												sender: this.client.getUserId(),
												content: t,
												type: e
											});
											return yield this.request.handleEvent(e, n, !0, !0, !0), r
										}))
									}
									sendToDevices(e, t, r) {
										return n(this, void 0, void 0, (function*() {
											if (r.length) {
												const n = {};
												for (const e of r) n[e] = t;
												yield this.client.sendToDevice(e, {
													[this.userId]: n
												})
											}
										}))
									}
									static makeTransactionId() {
										return (0, i.randomString)(32)
									}
								}
								r.ToDeviceChannel = l;
								r.ToDeviceRequests = class {
									constructor() {
										this.requestsByUserId = new Map
									}
									getRequest(e) {
										return this.getRequestBySenderAndTxnId(e.getSender(), l.getTransactionId(e))
									}
									getRequestByChannel(e) {
										return this.getRequestBySenderAndTxnId(e.userId, e.transactionId)
									}
									getRequestBySenderAndTxnId(e, t) {
										const r = this.requestsByUserId.get(e);
										if (r) return r.get(t)
									}
									setRequest(e, t) {
										this.setRequestBySenderAndTxnId(e.getSender(), l.getTransactionId(e), t)
									}
									setRequestByChannel(e, t) {
										this.setRequestBySenderAndTxnId(e.userId, e.transactionId, t)
									}
									setRequestBySenderAndTxnId(e, t, r) {
										let n = this.requestsByUserId.get(e);
										n || (n = new Map, this.requestsByUserId.set(e, n)), n.set(t, r)
									}
									removeRequest(e) {
										const t = e.getSender(),
											r = this.requestsByUserId.get(t);
										r && (r.delete(l.getTransactionId(e)), 0 === r.size && this.requestsByUserId.delete(t))
									}
									findRequestInProgress(e, t) {
										const r = this.requestsByUserId.get(e);
										if (r)
											for (const n of r.values())
												if (n.pending && n.channel.isToDevices(t)) return n
									}
									getRequestsInProgress(e) {
										const t = this.requestsByUserId.get(e);
										return t ? Array.from(t.values()).filter(e => e.pending) : []
									}
								}
							}, {
								"../../../logger": 356,
								"../../../models/event": 365,
								"../../../randomstring": 379,
								"../Error": 333,
								"./VerificationRequest": 340
							}],
							340: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.VerificationRequest = r.VerificationRequestEvent = r.PHASE_DONE = r.PHASE_CANCELLED = r.PHASE_STARTED = r.PHASE_READY = r.PHASE_REQUESTED = r.PHASE_UNSENT = r.Phase = r.READY_TYPE = r.DONE_TYPE = r.CANCEL_TYPE = r.START_TYPE = r.REQUEST_TYPE = r.EVENT_PREFIX = void 0;
								const i = e("../../../logger"),
									o = e("../Error"),
									s = e("../QRCode"),
									a = e("../../../@types/event"),
									c = e("../../../models/typed-event-emitter"),
									l = 6e5,
									u = 12e4,
									d = 3e3;
								var h, f;
								r.EVENT_PREFIX = "m.key.verification.", r.REQUEST_TYPE = r.EVENT_PREFIX + "request", r.START_TYPE = r.EVENT_PREFIX + "start", r.CANCEL_TYPE = r.EVENT_PREFIX + "cancel", r.DONE_TYPE = r.EVENT_PREFIX + "done", r.READY_TYPE = r.EVENT_PREFIX + "ready",
									function(e) {
										e[e.Unsent = 1] = "Unsent", e[e.Requested = 2] = "Requested", e[e.Ready = 3] = "Ready", e[e.Started = 4] = "Started", e[e.Cancelled = 5] = "Cancelled", e[e.Done = 6] = "Done"
									}(h = r.Phase || (r.Phase = {})), r.PHASE_UNSENT = h.Unsent, r.PHASE_REQUESTED = h.Requested, r.PHASE_READY = h.Ready, r.PHASE_STARTED = h.Started, r.PHASE_CANCELLED = h.Cancelled, r.PHASE_DONE = h.Done,
									function(e) {
										e.Change = "change"
									}(f = r.VerificationRequestEvent || (r.VerificationRequestEvent = {}));
								class p extends c.TypedEventEmitter {
									constructor(e, t, o) {
										super(), this.channel = e, this.verificationMethods = t, this.client = o, this.eventsByUs = new Map, this.eventsByThem = new Map, this._observeOnly = !1, this.timeoutTimer = null, this._accepting = !1, this._declining = !1, this.verifierHasFinished = !1, this._cancelled = !1, this._chosenMethod = null, this._qrCodeData = null, this.requestReceivedAt = null, this.commonMethods = [], this.cancelOnTimeout = () => n(this, void 0, void 0, (function*() {
											try {
												this.initiatedByMe ? yield this.cancel({
													reason: "Other party didn't accept in time",
													code: "m.timeout"
												}): yield this.cancel({
													reason: "User didn't accept in time",
													code: "m.timeout"
												})
											} catch (e) {
												i.logger.error("Error while cancelling verification request", e)
											}
										})), this.channel.request = this, this.setPhase(r.PHASE_UNSENT, !1)
									}
									static validateEvent(e, t, n) {
										const o = t.getContent();
										return !(!e || !e.startsWith(r.EVENT_PREFIX)) && (o ? e !== r.REQUEST_TYPE && e !== r.READY_TYPE || Array.isArray(o.methods) ? e !== r.REQUEST_TYPE && e !== r.READY_TYPE && e !== r.START_TYPE || "string" == typeof o.from_device && 0 !== o.from_device.length || (i.logger.log("VerificationRequest: validateEvent: fail because from_device"), !1) : (i.logger.log("VerificationRequest: validateEvent: fail because methods"), !1) : (i.logger.log("VerificationRequest: validateEvent: no content"), !1))
									}
									get invalid() {
										return this.phase === r.PHASE_UNSENT
									}
									get requested() {
										return this.phase === r.PHASE_REQUESTED
									}
									get cancelled() {
										return this.phase === r.PHASE_CANCELLED
									}
									get ready() {
										return this.phase === r.PHASE_READY
									}
									get started() {
										return this.phase === r.PHASE_STARTED
									}
									get done() {
										return this.phase === r.PHASE_DONE
									}
									get methods() {
										return this.commonMethods
									}
									get chosenMethod() {
										return this._chosenMethod
									}
									calculateEventTimeout(e) {
										let t = this.channel.getTimestamp(e) + l;
										if (this.requestReceivedAt && !this.initiatedByMe && this.phase <= r.PHASE_REQUESTED) {
											const e = this.requestReceivedAt + u;
											t = Math.min(t, e)
										}
										return Math.max(0, t - Date.now())
									}
									get timeout() {
										const e = this.getEventByEither(r.REQUEST_TYPE);
										return e ? this.calculateEventTimeout(e) : 0
									}
									get requestEvent() {
										return this.getEventByEither(r.REQUEST_TYPE)
									}
									get phase() {
										return this._phase
									}
									get verifier() {
										return this._verifier
									}
									get canAccept() {
										return this.phase < r.PHASE_READY && !this._accepting && !this._declining
									}
									get accepting() {
										return this._accepting
									}
									get declining() {
										return this._declining
									}
									get pending() {
										return !this.observeOnly && this._phase !== r.PHASE_DONE && this._phase !== r.PHASE_CANCELLED
									}
									get qrCodeData() {
										return this._qrCodeData
									}
									otherPartySupportsMethod(e, t = !1) {
										if (!t && !this.ready && !this.started) return !1;
										const n = this.eventsByThem.get(r.REQUEST_TYPE) || this.eventsByThem.get(r.READY_TYPE);
										if (!n) {
											if (this.started && this.initiatedByMe) {
												const t = this.eventsByUs.get(r.START_TYPE),
													n = t && t.getContent();
												return e == (n && n.method)
											}
											return !1
										}
										const i = n.getContent();
										if (!i) return !1;
										const {
											methods: o
										} = i;
										return !!Array.isArray(o) && o.includes(e)
									}
									get initiatedByMe() {
										const e = this.eventsByUs.size + this.eventsByThem.size === 0;
										if (this._phase === r.PHASE_UNSENT && e) return !0;
										const t = this.eventsByUs.has(r.REQUEST_TYPE),
											n = this.eventsByThem.has(r.REQUEST_TYPE);
										if (t && !n) return !0;
										if (!t && n) return !1;
										const i = this.eventsByUs.has(r.START_TYPE),
											o = this.eventsByThem.has(r.START_TYPE);
										return !(!i || o)
									}
									get requestingUserId() {
										return this.initiatedByMe ? this.client.getUserId() : this.otherUserId
									}
									get receivingUserId() {
										return this.initiatedByMe ? this.otherUserId : this.client.getUserId()
									}
									get otherUserId() {
										return this.channel.userId
									}
									get isSelfVerification() {
										return this.client.getUserId() === this.otherUserId
									}
									get cancellingUserId() {
										const e = this.eventsByUs.get(r.CANCEL_TYPE),
											t = this.eventsByThem.get(r.CANCEL_TYPE);
										return e && (!t || e.getId() < t.getId()) ? e.getSender() : t ? t.getSender() : void 0
									}
									get cancellationCode() {
										const e = this.getEventByEither(r.CANCEL_TYPE);
										return e ? e.getContent().code : null
									}
									get observeOnly() {
										return this._observeOnly
									}
									get targetDevice() {
										const e = this.eventsByThem.get(r.REQUEST_TYPE) || this.eventsByThem.get(r.READY_TYPE) || this.eventsByThem.get(r.START_TYPE),
											t = null == e ? void 0 : e.getContent(),
											n = null == t ? void 0 : t.from_device;
										return {
											userId: this.otherUserId,
											deviceId: n
										}
									}
									beginKeyVerification(e, t = null) {
										if (!this.observeOnly && !this._verifier) {
											if (this.phase === r.PHASE_REQUESTED || this.phase === r.PHASE_READY || this.phase === r.PHASE_UNSENT && this.channel.canCreateRequest(r.START_TYPE)) {
												if (this.commonMethods.length && !this.commonMethods.includes(e)) throw (0, o.newUnknownMethodError)();
												if (this._verifier = this.createVerifier(e, null, t), !this._verifier) throw (0, o.newUnknownMethodError)();
												this._chosenMethod = e
											}
										}
										return this._verifier
									}
									sendRequest() {
										return n(this, void 0, void 0, (function*() {
											if (!this.observeOnly && this._phase === r.PHASE_UNSENT) {
												const e = [...this.verificationMethods.keys()];
												yield this.channel.send(r.REQUEST_TYPE, {
													methods: e
												})
											}
										}))
									}
									cancel({
										reason: e = "User declined",
										code: t = "m.user"
									} = {}) {
										return n(this, void 0, void 0, (function*() {
											if (!this.observeOnly && this._phase !== r.PHASE_CANCELLED) {
												if (this._declining = !0, this.emit(f.Change), this._verifier) return this._verifier.cancel((0, o.errorFactory)(t, e)());
												this._cancellingUserId = this.client.getUserId(), yield this.channel.send(r.CANCEL_TYPE, {
													code: t,
													reason: e
												})
											}
										}))
									}
									accept() {
										return n(this, void 0, void 0, (function*() {
											if (!this.observeOnly && this.phase === r.PHASE_REQUESTED && !this.initiatedByMe) {
												const e = [...this.verificationMethods.keys()];
												this._accepting = !0, this.emit(f.Change), yield this.channel.send(r.READY_TYPE, {
													methods: e
												})
											}
										}))
									}
									waitFor(e) {
										return new Promise((t, r) => {
											const n = () => {
												let i = !1;
												return e(this) ? (t(this), i = !0) : this.cancelled && (r(new Error("cancelled")), i = !0), i && this.off(f.Change, n), i
											};
											n() || this.on(f.Change, n)
										})
									}
									setPhase(e, t = !0) {
										this._phase = e, t && this.emit(f.Change)
									}
									getEventByEither(e) {
										return this.eventsByThem.get(e) || this.eventsByUs.get(e)
									}
									getEventBy(e, t = !1) {
										return t ? this.eventsByThem.get(e) : this.eventsByUs.get(e)
									}
									calculatePhaseTransitions() {
										const e = [{
												phase: r.PHASE_UNSENT
											}],
											t = () => e[e.length - 1].phase,
											n = this.eventsByThem.has(r.REQUEST_TYPE),
											i = this.getEventBy(r.REQUEST_TYPE, n);
										i && e.push({
											phase: r.PHASE_REQUESTED,
											event: i
										});
										const o = i && this.getEventBy(r.READY_TYPE, !n);
										let s;
										if (o && t() === r.PHASE_REQUESTED && e.push({
												phase: r.PHASE_READY,
												event: o
											}), o || !i) {
											const e = this.eventsByThem.get(r.START_TYPE),
												t = this.eventsByUs.get(r.START_TYPE);
											s = e && t ? e.getSender() < t.getSender() ? e : t : e || t
										} else s = this.getEventBy(r.START_TYPE, !n);
										if (s) {
											const n = t() === r.PHASE_REQUESTED && (null == i ? void 0 : i.getSender()) !== s.getSender(),
												o = t() === r.PHASE_UNSENT && this.channel.canCreateRequest(r.START_TYPE);
											(n || t() === r.PHASE_READY || o) && e.push({
												phase: r.PHASE_STARTED,
												event: s
											})
										}
										const a = this.eventsByUs.get(r.DONE_TYPE);
										(this.verifierHasFinished || a && t() === r.PHASE_STARTED) && e.push({
											phase: r.PHASE_DONE
										});
										const c = this.getEventByEither(r.CANCEL_TYPE);
										return (this._cancelled || c) && t() !== r.PHASE_DONE ? (e.push({
											phase: r.PHASE_CANCELLED,
											event: c
										}), e) : e
									}
									transitionToPhase(e) {
										const {
											phase: t,
											event: n
										} = e;
										if ((t === r.PHASE_REQUESTED || t === r.PHASE_READY) && !this.wasSentByOwnDevice(n)) {
											const e = n.getContent();
											this.commonMethods = e.methods.filter(e => this.verificationMethods.has(e))
										}
										if (this.observeOnly || t !== r.PHASE_REQUESTED && t !== r.PHASE_STARTED && t !== r.PHASE_READY || this.channel.receiveStartFromOtherDevices && this.wasSentByOwnUser(n) && !this.wasSentByOwnDevice(n) && (this._observeOnly = !0), t === r.PHASE_STARTED) {
											const {
												method: e
											} = n.getContent();
											this._verifier || this.observeOnly || (this._verifier = this.createVerifier(e, n), this._verifier ? this._chosenMethod = e : this.cancel({
												code: "m.unknown_method",
												reason: `Unknown method: ${e}`
											}))
										}
									}
									applyPhaseTransitions() {
										const e = this.calculatePhaseTransitions(),
											t = e.findIndex(e => e.phase === this.phase),
											r = e.slice(t + 1);
										for (const n of r) this.transitionToPhase(n);
										return r
									}
									isWinningStartRace(e) {
										if (e.getType() !== r.START_TYPE) return !1;
										const t = this._verifier.startEvent;
										let n, i;
										if (this.isSelfVerification)
											if (t) {
												const e = t.getContent();
												n = e && e.from_device
											} else n = this.client.getDeviceId();
										else n = t ? t.getSender() : this.client.getUserId();
										if (this.isSelfVerification) {
											const t = e.getContent();
											i = t && t.from_device
										} else i = e.getSender();
										return i < n
									}
									hasEventId(e) {
										for (const t of this.eventsByUs.values())
											if (t.getId() === e) return !0;
										for (const t of this.eventsByThem.values())
											if (t.getId() === e) return !0;
										return !1
									}
									handleEvent(e, t, o, a, c) {
										var l;
										return n(this, void 0, void 0, (function*() {
											if (this.done || this.cancelled) return;
											const n = this._observeOnly;
											if (this.adjustObserveOnly(t, o), !this.observeOnly && !a && (yield this.cancelOnError(e, t))) return;
											if (c ? this.eventsByUs.has(e) : this.eventsByThem.has(e)) return;
											const u = this.phase;
											this.addEvent(e, t, c);
											const d = this.applyPhaseTransitions();
											try {
												if (this._verifier && !this.observeOnly) {
													const n = this.isWinningStartRace(t);
													this._verifier.canSwitchStartEvent(t) && n ? this._verifier.switchStartEvent(t) : a || (e === r.CANCEL_TYPE || (null === (l = this._verifier.events) || void 0 === l ? void 0 : l.includes(e))) && this._verifier.handleEvent(t)
												}
												if (d.length) {
													if (o && d.some(e => e.phase === r.PHASE_READY)) {
														this.otherPartySupportsMethod(s.SCAN_QR_CODE_METHOD, !0) && (this._qrCodeData = yield s.QRCodeData.create(this, this.client))
													}
													const e = d[d.length - 1],
														{
															phase: t
														} = e;
													this.setupTimeout(t), this.setPhase(t)
												} else this._observeOnly !== n && this.emit(f.Change)
											} finally {
												i.logger.log(`Verification request ${this.channel.transactionId}: ` + `${e} event with id:${t.getId()}, ` + `content:${JSON.stringify(t.getContent())} ` + `deviceId:${this.channel.deviceId}, ` + `sender:${t.getSender()}, isSentByUs:${c}, ` + `isLiveEvent:${o}, isRemoteEcho:${a}, ` + `phase:${u}=>${this.phase}, ` + `observeOnly:${n}=>${this._observeOnly}`)
											}
										}))
									}
									setupTimeout(e) {
										if (!this.timeoutTimer && !this.observeOnly && e === r.PHASE_REQUESTED && (this.timeoutTimer = setTimeout(this.cancelOnTimeout, this.timeout)), this.timeoutTimer) {
											(e === r.PHASE_STARTED || e === r.PHASE_READY || e === r.PHASE_DONE || e === r.PHASE_CANCELLED) && (clearTimeout(this.timeoutTimer), this.timeoutTimer = null)
										}
									}
									cancelOnError(e, t) {
										return n(this, void 0, void 0, (function*() {
											if (e === r.START_TYPE) {
												const e = t.getContent().method;
												if (!this.verificationMethods.has(e)) return yield this.cancel((0, o.errorFromEvent)((0, o.newUnknownMethodError)())), !0
											}
											const n = e === r.REQUEST_TYPE && this.phase !== r.PHASE_UNSENT,
												s = e === r.READY_TYPE && this.phase !== r.PHASE_REQUESTED && this.phase !== r.PHASE_STARTED;
											if (this.phase !== r.PHASE_UNSENT && (n || s)) {
												i.logger.warn(`Cancelling, unexpected ${e} verification ` + `event from ${t.getSender()}`);
												const r = `Unexpected ${e} event in phase ${this.phase}`;
												return yield this.cancel((0, o.errorFromEvent)((0, o.newUnexpectedMessageError)({
													reason: r
												}))), !0
											}
											return !1
										}))
									}
									adjustObserveOnly(e, t = !1) {
										t || (this._observeOnly = !0), this.calculateEventTimeout(e) < d && (this._observeOnly = !0)
									}
									addEvent(e, t, n = !1) {
										if (n ? this.eventsByUs.set(e, t) : this.eventsByThem.set(e, t), e === r.REQUEST_TYPE) {
											for (const [e, t] of this.eventsByThem.entries()) t.getSender() !== this.otherUserId && this.eventsByThem.delete(e);
											this.requestReceivedAt = Date.now()
										}
									}
									createVerifier(e, t = null, r = null) {
										r || (r = this.targetDevice);
										const {
											userId: n,
											deviceId: o
										} = r, s = this.verificationMethods.get(e);
										if (s) return new s(this.channel, this.client, n, o, t, this);
										i.logger.warn("could not find verifier constructor for method", e)
									}
									wasSentByOwnUser(e) {
										return (null == e ? void 0 : e.getSender()) === this.client.getUserId()
									}
									wasSentByOwnDevice(e) {
										if (!this.wasSentByOwnUser(e)) return !1;
										const t = e.getContent();
										return !(!t || t.from_device !== this.client.getDeviceId())
									}
									onVerifierCancelled() {
										this._cancelled = !0;
										const e = this.applyPhaseTransitions();
										e.length && this.setPhase(e[e.length - 1].phase)
									}
									onVerifierFinished() {
										this.channel.send(a.EventType.KeyVerificationDone, {}), this.verifierHasFinished = !0;
										const e = this.applyPhaseTransitions();
										e.length && this.setPhase(e[e.length - 1].phase)
									}
									getEventFromOtherParty(e) {
										return this.eventsByThem.get(e)
									}
								}
								r.VerificationRequest = p
							}, {
								"../../../@types/event": 290,
								"../../../logger": 356,
								"../../../models/typed-event-emitter": 376,
								"../Error": 333,
								"../QRCode": 335
							}],
							341: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
										return new(r || (r = Promise))((function(i, o) {
											function s(e) {
												try {
													c(n.next(e))
												} catch (t) {
													o(t)
												}
											}

											function a(e) {
												try {
													c(n.throw(e))
												} catch (t) {
													o(t)
												}
											}

											function c(e) {
												var t;
												e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
													e(t)
												}))).then(s, a)
											}
											c((n = n.apply(e, t || [])).next())
										}))
									},
									i = this && this.__asyncValues || function(e) {
										if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
										var t, r = e[Symbol.asyncIterator];
										return r ? r.call(e) : (e = "function" == typeof __values ? __values(e) : e[Symbol.iterator](), t = {}, n("next"), n("throw"), n("return"), t[Symbol.asyncIterator] = function() {
											return this
										}, t);

										function n(r) {
											t[r] = e[r] && function(t) {
												return new Promise((function(n, i) {
													(function(e, t, r, n) {
														Promise.resolve(n).then((function(t) {
															e({
																value: t,
																done: r
															})
														}), t)
													})(n, i, (t = e[r](t)).done, t.value)
												}))
											}
										}
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.RoomWidgetClient = void 0;
								const o = e("matrix-widget-api"),
									s = e("./models/event"),
									a = e("./@types/event"),
									c = e("./logger"),
									l = e("./client"),
									u = e("./sync"),
									d = e("./sliding-sync-sdk"),
									h = e("./models/event"),
									f = e("./models/user");
								class p extends l.MatrixClient {
									constructor(e, t, r, i) {
										var s, d, f, p, v, g, m, y, b, _;
										super(i), this.widgetApi = e, this.capabilities = t, this.roomId = r, this.widgetApiReady = new Promise(e => this.widgetApi.once("ready", e)), this.syncState = null, this.onEvent = e => n(this, void 0, void 0, (function*() {
											if (e.preventDefault(), e.detail.data.room_id === this.roomId) {
												const t = new h.MatrixEvent(e.detail.data);
												yield this.syncApi.injectRoomEvents(this.room, [], [t]), this.emit(l.ClientEvent.Event, t), this.setSyncState(u.SyncState.Syncing), c.logger.info(`Received event ${t.getId()} ${t.getType()} ${t.getStateKey()}`)
											} else {
												const {
													event_id: t,
													room_id: r
												} = e.detail.data;
												c.logger.info(`Received event ${t} for a different room ${r}; discarding`)
											}
											yield this.ack(e)
										})), this.onToDevice = e => n(this, void 0, void 0, (function*() {
											e.preventDefault();
											const t = new h.MatrixEvent({
												type: e.detail.data.type,
												sender: e.detail.data.sender,
												content: e.detail.data.content
											});
											e.detail.data.encrypted && t.makeEncrypted(a.EventType.RoomMessageEncrypted, {}, "", ""), this.emit(l.ClientEvent.ToDeviceEvent, t), this.setSyncState(u.SyncState.Syncing), yield this.ack(e)
										})), ((null === (s = t.sendEvent) || void 0 === s ? void 0 : s.length) || (null === (d = t.receiveEvent) || void 0 === d ? void 0 : d.length) || !0 === t.sendMessage || Array.isArray(t.sendMessage) && t.sendMessage.length || !0 === t.receiveMessage || Array.isArray(t.receiveMessage) && t.receiveMessage.length || (null === (f = t.sendState) || void 0 === f ? void 0 : f.length) || (null === (p = t.receiveState) || void 0 === p ? void 0 : p.length)) && e.requestCapabilityForRoomTimeline(r), null === (v = t.sendEvent) || void 0 === v || v.forEach(t => e.requestCapabilityToSendEvent(t)), null === (g = t.receiveEvent) || void 0 === g || g.forEach(t => e.requestCapabilityToReceiveEvent(t)), !0 === t.sendMessage ? e.requestCapabilityToSendMessage() : Array.isArray(t.sendMessage) && t.sendMessage.forEach(t => e.requestCapabilityToSendMessage(t)), !0 === t.receiveMessage ? e.requestCapabilityToReceiveMessage() : Array.isArray(t.receiveMessage) && t.receiveMessage.forEach(t => e.requestCapabilityToReceiveMessage(t)), null === (m = t.sendState) || void 0 === m || m.forEach(({
											eventType: t,
											stateKey: r
										}) => e.requestCapabilityToSendState(t, r)), null === (y = t.receiveState) || void 0 === y || y.forEach(({
											eventType: t,
											stateKey: r
										}) => e.requestCapabilityToReceiveState(t, r)), null === (b = t.sendToDevice) || void 0 === b || b.forEach(t => e.requestCapabilityToSendToDevice(t)), null === (_ = t.receiveToDevice) || void 0 === _ || _.forEach(t => e.requestCapabilityToReceiveToDevice(t)), t.turnServers && e.requestCapability(o.MatrixCapabilities.MSC3846TurnServers), e.on(`action:${o.WidgetApiToWidgetAction.SendEvent}`, this.onEvent), e.on(`action:${o.WidgetApiToWidgetAction.SendToDevice}`, this.onToDevice), e.start()
									}
									startClient(e = {}) {
										var t, r;
										return n(this, void 0, void 0, (function*() {
											this.lifecycle = new AbortController;
											const i = this.getUserId();
											i && this.store.storeUser(new f.User(i)), e.slidingSync ? this.syncApi = new d.SlidingSyncSdk(e.slidingSync, this, e) : this.syncApi = new u.SyncApi(this, e), this.room = this.syncApi.createRoom(this.roomId), this.store.storeRoom(this.room), yield this.widgetApiReady, yield Promise.all(null !== (r = null === (t = this.capabilities.receiveState) || void 0 === t ? void 0 : t.map(({
												eventType: e,
												stateKey: t
											}) => n(this, void 0, void 0, (function*() {
												const r = (yield this.widgetApi.readStateEvents(e, void 0, t, [this.roomId])).map(e => new h.MatrixEvent(e));
												yield this.syncApi.injectRoomEvents(this.room, [], r), r.forEach(e => {
													this.emit(l.ClientEvent.Event, e), c.logger.info(`Backfilled event ${e.getId()} ${e.getType()} ${e.getStateKey()}`)
												})
											})))) && void 0 !== r ? r : []), this.setSyncState(u.SyncState.Syncing), c.logger.info("Finished backfilling events"), this.capabilities.turnServers && this.watchTurnServers()
										}))
									}
									stopClient() {
										this.widgetApi.off(`action:${o.WidgetApiToWidgetAction.SendEvent}`, this.onEvent), this.widgetApi.off(`action:${o.WidgetApiToWidgetAction.SendToDevice}`, this.onToDevice), super.stopClient(), this.lifecycle.abort()
									}
									joinRoom(e) {
										return n(this, void 0, void 0, (function*() {
											if (e === this.roomId) return this.room;
											throw new Error(`Unknown room: ${e}`)
										}))
									}
									encryptAndSendEvent(e, t) {
										return n(this, void 0, void 0, (function*() {
											let r;
											try {
												r = yield this.widgetApi.sendRoomEvent(t.getType(), t.getContent(), e.roomId)
											} catch (n) {
												throw this.updatePendingEventStatus(e, t, s.EventStatus.NOT_SENT), n
											}
											return e.updatePendingEvent(t, s.EventStatus.SENT, r.event_id), {
												event_id: r.event_id
											}
										}))
									}
									sendStateEvent(e, t, r, i = "") {
										return n(this, void 0, void 0, (function*() {
											return yield this.widgetApi.sendStateEvent(t, i, r, e)
										}))
									}
									sendToDevice(e, t) {
										return n(this, void 0, void 0, (function*() {
											return yield this.widgetApi.sendToDevice(e, !1, t), {}
										}))
									}
									queueToDevice({
										eventType: e,
										batch: t
									}) {
										return n(this, void 0, void 0, (function*() {
											const r = {};
											for (const {
													userId: e,
													deviceId: n,
													payload: i
												} of t) r[e] || (r[e] = {}), r[e][n] = i;
											yield this.widgetApi.sendToDevice(e, !1, r)
										}))
									}
									encryptAndSendToDevices(e, t) {
										return n(this, void 0, void 0, (function*() {
											const r = {};
											for (const {
													userId: n,
													deviceInfo: {
														deviceId: i
													}
												} of e) r[n] || (r[n] = {}), r[n][i] = t;
											yield this.widgetApi.sendToDevice(t.type, !0, r)
										}))
									}
									checkTurnServers() {
										return n(this, void 0, void 0, (function*() {
											return this.turnServers.length > 0
										}))
									}
									getSyncState() {
										return this.syncState
									}
									setSyncState(e) {
										const t = this.syncState;
										this.syncState = e, this.emit(l.ClientEvent.Sync, e, t)
									}
									ack(e) {
										return n(this, void 0, void 0, (function*() {
											yield this.widgetApi.transport.reply(e.detail, {})
										}))
									}
									watchTurnServers() {
										var e, t;
										return n(this, void 0, void 0, (function*() {
											const r = this.widgetApi.getTurnServers(),
												n = () => r.return(void 0);
											this.lifecycle.signal.addEventListener("abort", n);
											try {
												try {
													for (var o, s = i(r); !(o = yield s.next()).done;) {
														const e = o.value;
														this.turnServers = [{
															urls: e.uris,
															username: e.username,
															credential: e.password
														}], this.emit(l.ClientEvent.TurnServers, this.turnServers), c.logger.log(`Received TURN server: ${e.uris}`)
													}
												} catch (a) {
													e = {
														error: a
													}
												} finally {
													try {
														o && !o.done && (t = s.return) && (yield t.call(s))
													} finally {
														if (e) throw e.error
													}
												}
											} catch (u) {
												c.logger.warn("Error watching TURN servers", u)
											} finally {
												this.lifecycle.signal.removeEventListener("abort", n)
											}
										}))
									}
								}
								r.RoomWidgetClient = p
							}, {
								"./@types/event": 290,
								"./client": 304,
								"./logger": 356,
								"./models/event": 365,
								"./models/user": 377,
								"./sliding-sync-sdk": 383,
								"./sync": 391,
								"matrix-widget-api": 179
							}],
							342: [function(e, t, r) {
								"use strict";
								var n, i;
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.KeySignatureUploadError = r.InvalidCryptoStoreError = r.InvalidCryptoStoreState = r.InvalidStoreError = r.InvalidStoreState = void 0,
									function(e) {
										e[e.ToggledLazyLoading = 0] = "ToggledLazyLoading"
									}(n = r.InvalidStoreState || (r.InvalidStoreState = {}));
								class InvalidStoreError extends Error {
									constructor(e, t) {
										super(`Store is invalid because ${e}, ` + "please stop the client, delete all data and start the client again"), this.reason = e, this.value = t, this.name = "InvalidStoreError"
									}
								}
								r.InvalidStoreError = InvalidStoreError, InvalidStoreError.TOGGLED_LAZY_LOADING = n.ToggledLazyLoading,
									function(e) {
										e.TooNew = "TOO_NEW"
									}(i = r.InvalidCryptoStoreState || (r.InvalidCryptoStoreState = {}));
								class InvalidCryptoStoreError extends Error {
									constructor(e) {
										super(`Crypto store is invalid because ${e}, ` + "please stop the client, delete all data and start the client again"), this.reason = e, this.name = "InvalidCryptoStoreError"
									}
								}
								r.InvalidCryptoStoreError = InvalidCryptoStoreError, InvalidCryptoStoreError.TOO_NEW = i.TooNew;
								class KeySignatureUploadError extends Error {
									constructor(e, t) {
										super(e), this.value = t
									}
								}
								r.KeySignatureUploadError = KeySignatureUploadError
							}, {}],
							343: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.eventMapperFor = void 0;
								const n = e("./models/event");
								r.eventMapperFor = function(e, t) {
									let r = Boolean(t.preventReEmit);
									const i = !1 !== t.decrypt;
									return function(o) {
										t.toDevice && delete o.room_id;
										const s = e.getRoom(o.room_id);
										let a;
										s && void 0 === o.state_key && (a = s.findEventById(o.event_id)), !a || a.status ? a = new n.MatrixEvent(o) : (a.setUnsigned(Object.assign(Object.assign({}, a.getUnsigned()), o.unsigned)), r = !0);
										const c = null == s ? void 0 : s.findThreadForEvent(a);
										return c && a.setThread(c), a.isEncrypted() && (r || e.reEmitter.reEmit(a, [n.MatrixEventEvent.Decrypted]), i && e.decryptEventIfNeeded(a)), r || (e.reEmitter.reEmit(a, [n.MatrixEventEvent.Replaced, n.MatrixEventEvent.VisibilityChange]), null == s || s.reEmitter.reEmit(a, [n.MatrixEventEvent.BeforeRedaction])), a
									}
								}
							}, {
								"./models/event": 365
							}],
							344: [function(e, t, r) {
								"use strict";
								var n, i, o = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.buildFeatureSupportMap = r.Feature = r.ServerSupport = void 0,
									function(e) {
										e[e.Stable = 0] = "Stable", e[e.Unstable = 1] = "Unstable", e[e.Unsupported = 2] = "Unsupported"
									}(n = r.ServerSupport || (r.ServerSupport = {})),
									function(e) {
										e.Thread = "Thread", e.ThreadUnreadNotifications = "ThreadUnreadNotifications", e.LoginTokenRequest = "LoginTokenRequest"
									}(i = r.Feature || (r.Feature = {}));
								const s = {
									[i.Thread]: {
										unstablePrefixes: ["org.matrix.msc3440"],
										matrixVersion: "v1.3"
									},
									[i.ThreadUnreadNotifications]: {
										unstablePrefixes: ["org.matrix.msc3771", "org.matrix.msc3773"],
										matrixVersion: "v1.4"
									},
									[i.LoginTokenRequest]: {
										unstablePrefixes: ["org.matrix.msc3882"]
									}
								};
								r.buildFeatureSupportMap = function(e) {
									var t, r, i, a;
									return o(this, void 0, void 0, (function*() {
										const o = new Map;
										for (const [c, l] of Object.entries(s)) {
											const s = null !== (r = null === (t = e.versions) || void 0 === t ? void 0 : t.includes(l.matrixVersion || "")) && void 0 !== r && r,
												u = null !== (a = null === (i = l.unstablePrefixes) || void 0 === i ? void 0 : i.every(t => {
													var r;
													return !0 === (null === (r = e.unstable_features) || void 0 === r ? void 0 : r[t])
												})) && void 0 !== a && a;
											s ? o.set(c, n.Stable) : u ? o.set(c, n.Unstable) : o.set(c, n.Unsupported)
										}
										return o
									}))
								}
							}, {}],
							345: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.FilterComponent = void 0;
								const n = e("./models/thread");
								r.FilterComponent = class {
									constructor(e, t) {
										this.filterJson = e, this.userId = t
									}
									check(e) {
										var t, r;
										const i = (null === (t = e.getUnsigned()) || void 0 === t ? void 0 : t["m.relations"]) || {},
											o = Object.keys(i),
											s = [];
										return this.userId && (null === (r = null == i ? void 0 : i[n.THREAD_RELATION_TYPE.name]) || void 0 === r ? void 0 : r.current_user_participated) && s.push(this.userId), this.checkFields(e.getRoomId(), e.getSender(), e.getType(), !!e.getContent() && void 0 !== e.getContent().url, o, s)
									}
									toJSON() {
										return {
											types: this.filterJson.types || null,
											not_types: this.filterJson.not_types || [],
											rooms: this.filterJson.rooms || null,
											not_rooms: this.filterJson.not_rooms || [],
											senders: this.filterJson.senders || null,
											not_senders: this.filterJson.not_senders || [],
											contains_url: this.filterJson.contains_url || null,
											[n.FILTER_RELATED_BY_SENDERS.name]: this.filterJson[n.FILTER_RELATED_BY_SENDERS.name] || [],
											[n.FILTER_RELATED_BY_REL_TYPES.name]: this.filterJson[n.FILTER_RELATED_BY_REL_TYPES.name] || []
										}
									}
									checkFields(e, t, r, i, o, s) {
										const a = {
											rooms: function(t) {
												return e === t
											},
											senders: function(e) {
												return t === e
											},
											types: function(e) {
												return function(e, t) {
													if (t.endsWith("*")) {
														const r = t.slice(0, -1);
														return e.slice(0, r.length) === r
													}
													return e === t
												}(r, e)
											}
										};
										for (const n in a) {
											const e = a[n],
												t = "not_" + n,
												r = this.filterJson[t];
											if (null == r ? void 0 : r.some(e)) return !1;
											const i = this.filterJson[n];
											if (i && !i.some(e)) return !1
										}
										const c = this.filterJson.contains_url;
										if (void 0 !== c && c !== i) return !1;
										const l = this.filterJson[n.FILTER_RELATED_BY_REL_TYPES.name];
										if (void 0 !== l && !this.arrayMatchesFilter(l, o)) return !1;
										const u = this.filterJson[n.FILTER_RELATED_BY_SENDERS.name];
										return !(void 0 !== u && !this.arrayMatchesFilter(u, s))
									}
									arrayMatchesFilter(e, t) {
										return t.length > 0 && e.every(e => t.includes(e))
									}
									filter(e) {
										return e.filter(this.check, this)
									}
									limit() {
										return void 0 !== this.filterJson.limit ? this.filterJson.limit : 10
									}
								}
							}, {
								"./models/thread": 375
							}],
							346: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.Filter = void 0;
								const n = e("./@types/sync"),
									i = e("./filter-component");

								function o(e, t, r) {
									const n = t.split(".");
									let i = e;
									for (let o = 0; o < n.length - 1; o++) i[n[o]] || (i[n[o]] = {}), i = i[n[o]];
									i[n[n.length - 1]] = r
								}
								class s {
									constructor(e, t) {
										this.userId = e, this.filterId = t, this.definition = {}
									}
									static fromJson(e, t, r) {
										const n = new s(e, t);
										return n.setDefinition(r), n
									}
									getFilterId() {
										return this.filterId
									}
									getDefinition() {
										return this.definition
									}
									setDefinition(e) {
										this.definition = e;
										const t = e.room,
											r = {};
										t && (t.rooms && (r.rooms = t.rooms), t.rooms && (r.not_rooms = t.not_rooms)), this.roomFilter = new i.FilterComponent(r, this.userId), this.roomTimelineFilter = new i.FilterComponent((null == t ? void 0 : t.timeline) || {}, this.userId)
									}
									getRoomTimelineFilterComponent() {
										return this.roomTimelineFilter
									}
									filterRoomTimeline(e) {
										return this.roomFilter && (e = this.roomFilter.filter(e)), this.roomTimelineFilter && (e = this.roomTimelineFilter.filter(e)), e
									}
									setTimelineLimit(e) {
										o(this.definition, "room.timeline.limit", e)
									}
									setUnreadThreadNotifications(e) {
										var t, r, i;
										this.definition = Object.assign(Object.assign({}, this.definition), {
											room: Object.assign(Object.assign({}, null === (t = this.definition) || void 0 === t ? void 0 : t.room), {
												timeline: Object.assign(Object.assign({}, null === (i = null === (r = this.definition) || void 0 === r ? void 0 : r.room) || void 0 === i ? void 0 : i.timeline), {
													[n.UNREAD_THREAD_NOTIFICATIONS.name]: e
												})
											})
										})
									}
									setLazyLoadMembers(e) {
										o(this.definition, "room.state.lazy_load_members", e)
									}
									setIncludeLeaveRooms(e) {
										o(this.definition, "room.include_leave", e)
									}
								}
								r.Filter = s, s.LAZY_LOADING_MESSAGES_FILTER = {
									lazy_load_members: !0
								}
							}, {
								"./@types/sync": 297,
								"./filter-component": 345
							}],
							347: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.ConnectionError = r.MatrixError = r.HTTPError = void 0;
								class HTTPError extends Error {
									constructor(e, t) {
										super(e), this.httpStatus = t
									}
								}
								r.HTTPError = HTTPError;
								r.MatrixError = class MatrixError extends HTTPError {
									constructor(e = {}, t, r, n) {
										let i = e.error || "Unknown message";
										t && (i = `[${t}] ${i}`), r && (i = `${i} (${r})`), super(`MatrixError: ${i}`, t), this.httpStatus = t, this.url = r, this.event = n, this.errcode = e.errcode, this.name = e.errcode || "Unknown error code", this.data = e
									}
								};
								class ConnectionError extends Error {
									constructor(e, t) {
										super(e + (t ? `: ${t.message}` : ""))
									}
									get name() {
										return "ConnectionError"
									}
								}
								r.ConnectionError = ConnectionError
							}, {}],
							348: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var r = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
												void 0 === n && (n = r);
												var i = Object.getOwnPropertyDescriptor(t, r);
												i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
													enumerable: !0,
													get: function() {
														return t[r]
													}
												}), Object.defineProperty(e, n, i)
											} : function(e, t, r, n) {
												void 0 === n && (n = r), e[n] = t[r]
											}),
											i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
												Object.defineProperty(e, "default", {
													enumerable: !0,
													value: t
												})
											} : function(e, t) {
												e.default = t
											}),
											o = this && this.__importStar || function(e) {
												if (e && e.__esModule) return e;
												var t = {};
												if (null != e)
													for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);
												return i(t, e), t
											},
											s = this && this.__awaiter || function(e, t, r, n) {
												return new(r || (r = Promise))((function(i, o) {
													function s(e) {
														try {
															c(n.next(e))
														} catch (t) {
															o(t)
														}
													}

													function a(e) {
														try {
															c(n.throw(e))
														} catch (t) {
															o(t)
														}
													}

													function c(e) {
														var t;
														e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
															e(t)
														}))).then(s, a)
													}
													c((n = n.apply(e, t || [])).next())
												}))
											};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.FetchHttpApi = void 0;
										const a = o(t("../utils")),
											c = t("./method"),
											l = t("./errors"),
											u = t("./interface"),
											d = t("./utils");
										n.FetchHttpApi = class {
											constructor(e, t) {
												var r;
												this.eventEmitter = e, this.opts = t, this.abortController = new AbortController, a.checkObjectHasKeys(t, ["baseUrl", "prefix"]), t.onlyData = !!t.onlyData, t.useAuthorizationHeader = null === (r = t.useAuthorizationHeader) || void 0 === r || r
											}
											abort() {
												this.abortController.abort(), this.abortController = new AbortController
											}
											fetch(t, r) {
												return this.opts.fetchFn ? this.opts.fetchFn(t, r) : e.fetch(t, r)
											}
											setIdBaseUrl(e) {
												this.opts.idBaseUrl = e
											}
											idServerRequest(e, t, r, n, i) {
												if (!this.opts.idBaseUrl) throw new Error("No identity server base URL set");
												let o = void 0,
													s = void 0;
												e === c.Method.Get ? o = r : s = r;
												const a = this.getUrl(t, o, n, this.opts.idBaseUrl),
													l = {
														json: !0,
														headers: {}
													};
												return i && (l.headers.Authorization = `Bearer ${i}`), this.requestOtherUrl(e, a, s, l)
											}
											authedRequest(e, t, r, n, i = {}) {
												r || (r = {}), this.opts.accessToken && (this.opts.useAuthorizationHeader ? (i.headers || (i.headers = {}), i.headers.Authorization || (i.headers.Authorization = "Bearer " + this.opts.accessToken), r.access_token && delete r.access_token) : r.access_token || (r.access_token = this.opts.accessToken));
												const o = this.request(e, t, r, n, i);
												return o.catch(e => {
													"M_UNKNOWN_TOKEN" != e.errcode || (null == i ? void 0 : i.inhibitLogoutEmit) ? "M_CONSENT_NOT_GIVEN" == e.errcode && this.eventEmitter.emit(u.HttpApiEvent.NoConsent, e.message, e.data.consent_uri) : this.eventEmitter.emit(u.HttpApiEvent.SessionLoggedOut, e)
												}), o
											}
											request(e, t, r, n, i) {
												const o = this.getUrl(t, r, null == i ? void 0 : i.prefix, null == i ? void 0 : i.baseUrl);
												return this.requestOtherUrl(e, o, n, i)
											}
											requestOtherUrl(e, t, r, n = {}) {
												var i, o, a, c;
												return s(this, void 0, void 0, (function*() {
													const s = Object.assign({}, n.headers || {}),
														u = null === (i = n.json) || void 0 === i || i,
														h = u && (null === (o = null == r ? void 0 : r.constructor) || void 0 === o ? void 0 : o.name) === Object.name;
													u && (h && !s["Content-Type"] && (s["Content-Type"] = "application/json"), s.Accept || (s.Accept = "application/json"));
													const f = null !== (a = n.localTimeoutMs) && void 0 !== a ? a : this.opts.localTimeoutMs,
														p = null !== (c = n.keepAlive) && void 0 !== c && c,
														v = [this.abortController.signal];
													let g;
													void 0 !== f && v.push((0, d.timeoutSignal)(f)), n.abortSignal && v.push(n.abortSignal), g = h ? JSON.stringify(r) : r;
													const {
														signal: m,
														cleanup: y
													} = (0, d.anySignal)(v);
													let b;
													try {
														b = yield this.fetch(t, {
															signal: m,
															method: e,
															body: g,
															headers: s,
															mode: "cors",
															redirect: "follow",
															referrer: "",
															referrerPolicy: "no-referrer",
															cache: "no-cache",
															credentials: "omit",
															keepalive: p
														})
													} catch (_) {
														if ("AbortError" === _.name) throw _;
														throw new l.ConnectionError("fetch failed", _)
													} finally {
														y()
													}
													if (!b.ok) throw (0, d.parseErrorResponse)(b, yield b.text());
													return this.opts.onlyData ? u ? b.json() : b.text() : b
												}))
											}
											getUrl(e, t, r, n) {
												const i = new URL((null != n ? n : this.opts.baseUrl) + (null != r ? r : this.opts.prefix) + e);
												return t && a.encodeParams(t, i.searchParams), i
											}
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"../utils": 393,
								"./errors": 347,
								"./interface": 350,
								"./method": 351,
								"./utils": 353
							}],
							349: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var r = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
												void 0 === n && (n = r);
												var i = Object.getOwnPropertyDescriptor(t, r);
												i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
													enumerable: !0,
													get: function() {
														return t[r]
													}
												}), Object.defineProperty(e, n, i)
											} : function(e, t, r, n) {
												void 0 === n && (n = r), e[n] = t[r]
											}),
											i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
												Object.defineProperty(e, "default", {
													enumerable: !0,
													value: t
												})
											} : function(e, t) {
												e.default = t
											}),
											o = this && this.__importStar || function(e) {
												if (e && e.__esModule) return e;
												var t = {};
												if (null != e)
													for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);
												return i(t, e), t
											},
											s = this && this.__exportStar || function(e, t) {
												for (var n in e) "default" === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n)
											};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.MatrixHttpApi = void 0;
										const a = t("./fetch"),
											c = t("./prefix"),
											l = o(t("../utils")),
											u = o(t("../realtime-callbacks")),
											d = t("./method"),
											h = t("./errors"),
											f = t("./utils");
										s(t("./interface"), n), s(t("./prefix"), n), s(t("./errors"), n), s(t("./method"), n), s(t("./utils"), n);
										class p extends a.FetchHttpApi {
											constructor() {
												super(...arguments), this.uploads = []
											}
											uploadContent(t, r = {}) {
												var n, i, o, s, a;
												const p = null === (n = r.includeFilename) || void 0 === n || n,
													v = null !== (i = r.abortController) && void 0 !== i ? i : new AbortController,
													g = null !== (s = null !== (o = r.type) && void 0 !== o ? o : t.type) && void 0 !== s ? s : "application/octet-stream",
													m = null !== (a = r.name) && void 0 !== a ? a : t.name,
													y = {
														loaded: 0,
														total: 0,
														abortController: v
													},
													b = l.defer();
												if (e.XMLHttpRequest) {
													const n = new e.XMLHttpRequest,
														i = function() {
															n.abort(), b.reject(new Error("Timeout"))
														};
													let o = u.setTimeout(i, 3e4);
													n.onreadystatechange = function() {
														switch (n.readyState) {
															case e.XMLHttpRequest.DONE:
																u.clearTimeout(o);
																try {
																	if (0 === n.status) throw new DOMException(n.statusText, "AbortError");
																	if (!n.responseText) throw new Error("No response body.");
																	n.status >= 400 ? b.reject((0, f.parseErrorResponse)(n, n.responseText)) : b.resolve(JSON.parse(n.responseText))
																} catch (t) {
																	if ("AbortError" === t.name) return void b.reject(t);
																	b.reject(new h.ConnectionError("request failed", t))
																}
														}
													}, n.upload.onprogress = e => {
														var t;
														u.clearTimeout(o), y.loaded = e.loaded, y.total = e.total, o = u.setTimeout(i, 3e4), null === (t = r.progressHandler) || void 0 === t || t.call(r, {
															loaded: e.loaded,
															total: e.total
														})
													};
													const s = this.getUrl("/upload", void 0, c.MediaPrefix.R0);
													p && m && s.searchParams.set("filename", encodeURIComponent(m)), !this.opts.useAuthorizationHeader && this.opts.accessToken && s.searchParams.set("access_token", encodeURIComponent(this.opts.accessToken)), n.open(d.Method.Post, s.href), this.opts.useAuthorizationHeader && this.opts.accessToken && n.setRequestHeader("Authorization", "Bearer " + this.opts.accessToken), n.setRequestHeader("Content-Type", g), n.send(t), v.signal.addEventListener("abort", () => {
														n.abort()
													})
												} else {
													const e = {};
													p && m && (e.filename = m);
													const r = {
														"Content-Type": g
													};
													this.authedRequest(d.Method.Post, "/upload", e, t, {
														prefix: c.MediaPrefix.R0,
														headers: r,
														abortSignal: v.signal
													}).then(e => this.opts.onlyData ? e : e.json()).then(b.resolve, b.reject)
												}
												return y.promise = b.promise.finally(() => {
													l.removeElement(this.uploads, e => e === y)
												}), v.signal.addEventListener("abort", () => {
													l.removeElement(this.uploads, e => e === y), b.reject(new DOMException("Aborted", "AbortError"))
												}), this.uploads.push(y), y.promise
											}
											cancelUpload(e) {
												const t = this.uploads.find(t => t.promise === e);
												return !!t && (t.abortController.abort(), !0)
											}
											getCurrentUploads() {
												return this.uploads
											}
											getContentUri() {
												return {
													base: this.opts.baseUrl,
													path: c.MediaPrefix.R0 + "/upload",
													params: {
														access_token: this.opts.accessToken
													}
												}
											}
										}
										n.MatrixHttpApi = p
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"../realtime-callbacks": 380,
								"../utils": 393,
								"./errors": 347,
								"./fetch": 348,
								"./interface": 350,
								"./method": 351,
								"./prefix": 352,
								"./utils": 353
							}],
							350: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.HttpApiEvent = void 0,
									function(e) {
										e.SessionLoggedOut = "Session.logged_out", e.NoConsent = "no_consent"
									}(r.HttpApiEvent || (r.HttpApiEvent = {}))
							}, {}],
							351: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.Method = void 0,
									function(e) {
										e.Get = "GET", e.Put = "PUT", e.Post = "POST", e.Delete = "DELETE"
									}(r.Method || (r.Method = {}))
							}, {}],
							352: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.MediaPrefix = r.IdentityPrefix = r.ClientPrefix = void 0,
									function(e) {
										e.R0 = "/_matrix/client/r0", e.V1 = "/_matrix/client/v1", e.V3 = "/_matrix/client/v3", e.Unstable = "/_matrix/client/unstable"
									}(r.ClientPrefix || (r.ClientPrefix = {})),
									function(e) {
										e.V1 = "/_matrix/identity/api/v1", e.V2 = "/_matrix/identity/v2"
									}(r.IdentityPrefix || (r.IdentityPrefix = {})),
									function(e) {
										e.R0 = "/_matrix/media/r0"
									}(r.MediaPrefix || (r.MediaPrefix = {}))
							}, {}],
							353: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.retryNetworkOperation = r.parseErrorResponse = r.anySignal = r.timeoutSignal = void 0;
								const i = e("content-type"),
									o = e("../logger"),
									s = e("../utils"),
									a = e("./errors");

								function c(e) {
									return "getResponseHeader" in e
								}
								r.timeoutSignal = function(e) {
									const t = new AbortController;
									return setTimeout(() => {
										t.abort()
									}, e), t.signal
								}, r.anySignal = function(e) {
									const t = new AbortController;

									function r() {
										for (const t of e) t.removeEventListener("abort", n)
									}

									function n() {
										t.abort(), r()
									}
									for (const i of e) {
										if (i.aborted) {
											n();
											break
										}
										i.addEventListener("abort", n)
									}
									return {
										signal: t.signal,
										cleanup: r
									}
								}, r.parseErrorResponse = function(e, t) {
									let r;
									try {
										r = function(e) {
											let t;
											t = c(e) ? e.getResponseHeader("Content-Type") : e.headers.get("Content-Type");
											if (!t) return null;
											try {
												return (0, i.parse)(t)
											} catch (r) {
												throw new Error(`Error parsing Content-Type '${t}': ${r}`)
											}
										}(e)
									} catch (n) {
										return n
									}
									return "application/json" === (null == r ? void 0 : r.type) && t ? new a.MatrixError(JSON.parse(t), e.status, c(e) ? e.responseURL : e.url) : "text/plain" === (null == r ? void 0 : r.type) ? new a.HTTPError(`Server returned ${e.status} error: ${t}`, e.status) : new a.HTTPError(`Server returned ${e.status} error`, e.status)
								}, r.retryNetworkOperation = function(e, t) {
									return n(this, void 0, void 0, (function*() {
										let r = 0,
											n = null;
										for (; r < e;) try {
											if (r > 0) {
												const e = 1e3 * Math.pow(2, r);
												o.logger.log(`network operation failed ${r} times, retrying in ${e}ms...`), yield(0, s.sleep)(e)
											}
											return yield t()
										} catch (i) {
											if (!(i instanceof a.ConnectionError)) throw i;
											r += 1, n = i
										}
										throw n
									}))
								}
							}, {
								"../logger": 356,
								"../utils": 393,
								"./errors": 347,
								"content-type": 73
							}],
							354: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.exists = void 0, r.exists = function(e, t) {
									return new Promise((r, n) => {
										let i = !0;
										const o = e.open(t);
										o.onupgradeneeded = () => {
											i = !1
										}, o.onblocked = () => n(o.error), o.onsuccess = () => {
											o.result.close(), i || e.deleteDatabase(t), r(i)
										}, o.onerror = e => n(o.error)
									})
								}
							}, {}],
							355: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.InteractiveAuth = r.AuthType = void 0;
								const i = e("./logger"),
									o = e("./utils"),
									s = "m.login.email.identity",
									a = "m.login.msisdn";
								var c;
								! function(e) {
									e.Password = "m.login.password", e.Recaptcha = "m.login.recaptcha", e.Terms = "m.login.terms", e.Email = "m.login.email.identity", e.Msisdn = "m.login.msisdn", e.Sso = "m.login.sso", e.SsoUnstable = "org.matrix.login.sso", e.Dummy = "m.login.dummy", e.RegistrationToken = "m.login.registration_token", e.UnstableRegistrationToken = "org.matrix.msc3231.login.registration_token"
								}(c = r.AuthType || (r.AuthType = {}));
								class NoAuthFlowFoundError extends Error {
									constructor(e, t, r) {
										super(e), this.required_stages = t, this.flows = r, this.name = "NoAuthFlowFoundError"
									}
								}
								r.InteractiveAuth = class {
									constructor(e) {
										this.requestingEmailToken = !1, this.attemptAuthDeferred = null, this.chosenFlow = null, this.currentStage = null, this.emailAttempt = 1, this.submitPromise = null, this.requestEmailToken = () => n(this, void 0, void 0, (function*() {
											if (this.requestingEmailToken) i.logger.warn("Could not request email token: Already requesting");
											else {
												i.logger.trace("Requesting email token. Attempt: " + this.emailAttempt), this.requestingEmailToken = !0;
												try {
													const e = yield this.requestEmailTokenCallback(this.inputs.emailAddress, this.clientSecret, this.emailAttempt++, this.data.session);
													this.emailSid = e.sid, i.logger.trace("Email token request succeeded")
												} finally {
													this.requestingEmailToken = !1
												}
											}
										})), this.matrixClient = e.matrixClient, this.data = e.authData || {}, this.requestCallback = e.doRequest, this.busyChangedCallback = e.busyChanged, this.stateUpdatedCallback = e.stateUpdated || e.startAuthStage, this.requestEmailTokenCallback = e.requestEmailToken, this.inputs = e.inputs || {}, e.sessionId && (this.data.session = e.sessionId), this.clientSecret = e.clientSecret || this.matrixClient.generateClientSecret(), this.emailSid = e.emailSid
									}
									attemptAuth() {
										var e, t;
										this.attemptAuthDeferred = (0, o.defer)();
										const r = this.attemptAuthDeferred.promise;
										if (null === (e = this.data) || void 0 === e ? void 0 : e.flows) this.startNextAuthStage();
										else {
											null === (t = this.busyChangedCallback) || void 0 === t || t.call(this, !0);
											const e = this.data.session ? {
												session: this.data.session
											} : null;
											this.doRequest(e).finally(() => {
												var e;
												null === (e = this.busyChangedCallback) || void 0 === e || e.call(this, !1)
											})
										}
										return r
									}
									poll() {
										return n(this, void 0, void 0, (function*() {
											if (!this.data.session) return;
											if (!this.attemptAuthDeferred) return;
											if (this.submitPromise) return;
											let e = {};
											if (this.currentStage == s && this.emailSid) {
												const t = {
													sid: this.emailSid,
													client_secret: this.clientSecret
												};
												if (yield this.matrixClient.doesServerRequireIdServerParam()) {
													const e = new URL(this.matrixClient.getIdentityServerUrl());
													t.id_server = e.host
												}
												e = {
													type: s,
													threepid_creds: t,
													threepidCreds: t
												}
											}
											this.submitAuthDict(e, !0)
										}))
									}
									getSessionId() {
										var e;
										return null === (e = this.data) || void 0 === e ? void 0 : e.session
									}
									getClientSecret() {
										return this.clientSecret
									}
									getStageParams(e) {
										var t;
										return null === (t = this.data.params) || void 0 === t ? void 0 : t[e]
									}
									getChosenFlow() {
										return this.chosenFlow
									}
									submitAuthDict(e, t = !1) {
										var r, i;
										return n(this, void 0, void 0, (function*() {
											if (!this.attemptAuthDeferred) throw new Error("submitAuthDict() called before attemptAuth()");
											for (t || null === (r = this.busyChangedCallback) || void 0 === r || r.call(this, !0); this.submitPromise;) try {
												yield this.submitPromise
											} catch (o) {}
											let n;
											this.data.session ? (n = {
												session: this.data.session
											}, Object.assign(n, e)) : n = e;
											try {
												this.submitPromise = this.doRequest(n, t), yield this.submitPromise
											} finally {
												this.submitPromise = null, t || null === (i = this.busyChangedCallback) || void 0 === i || i.call(this, !1)
											}
										}))
									}
									getEmailSid() {
										return this.emailSid
									}
									setEmailSid(e) {
										this.emailSid = e
									}
									doRequest(e, t = !1) {
										var r, o, s, a;
										return n(this, void 0, void 0, (function*() {
											try {
												const r = yield this.requestCallback(e, t);
												this.attemptAuthDeferred.resolve(r), this.attemptAuthDeferred = null
											} catch (n) {
												const e = null !== (o = null === (r = n.data) || void 0 === r ? void 0 : r.flows) && void 0 !== o ? o : null,
													u = this.data.flows || Boolean(e);
												401 === n.httpStatus && n.data && u || (t ? i.logger.log("Background poll request failed doing UI auth: ignoring", n) : null === (s = this.attemptAuthDeferred) || void 0 === s || s.reject(n)), n.data || (n.data = {}), n.data.flows || n.data.completed || n.data.session || (n.data.flows = this.data.flows, n.data.completed = this.data.completed, n.data.session = this.data.session), this.data = n.data;
												try {
													this.startNextAuthStage()
												} catch (l) {
													return this.attemptAuthDeferred.reject(l), void(this.attemptAuthDeferred = null)
												}
												if (!this.emailSid && (null === (a = this.chosenFlow) || void 0 === a ? void 0 : a.stages.includes(c.Email))) try {
													yield this.requestEmailToken()
												} catch (l) {
													this.attemptAuthDeferred.reject(l), this.attemptAuthDeferred = null
												}
											}
										}))
									}
									startNextAuthStage() {
										var e, t, r, n;
										const i = this.chooseStage();
										if (!i) throw new Error("No incomplete flows from the server");
										this.currentStage = i, i !== c.Dummy ? (null === (e = this.data) || void 0 === e ? void 0 : e.errcode) || (null === (t = this.data) || void 0 === t ? void 0 : t.error) ? this.stateUpdatedCallback(i, {
											errcode: (null === (r = this.data) || void 0 === r ? void 0 : r.errcode) || "",
											error: (null === (n = this.data) || void 0 === n ? void 0 : n.error) || ""
										}) : this.stateUpdatedCallback(i, i === s ? {
											emailSid: this.emailSid
										} : {}) : this.submitAuthDict({
											type: "m.login.dummy"
										})
									}
									chooseStage() {
										null === this.chosenFlow && (this.chosenFlow = this.chooseFlow()), i.logger.log("Active flow => %s", JSON.stringify(this.chosenFlow));
										const e = this.firstUncompletedStage(this.chosenFlow);
										return i.logger.log("Next stage: %s", e), e
									}
									chooseFlow() {
										const e = this.data.flows || [],
											t = Boolean(this.inputs.emailAddress) || Boolean(this.emailSid),
											r = Boolean(this.inputs.phoneCountry) && Boolean(this.inputs.phoneNumber);
										for (const i of e) {
											let e = !1,
												n = !1;
											for (const t of i.stages) t === s ? e = !0 : t == a && (n = !0);
											if (e == t && n == r) return i
										}
										const n = [];
										throw t && n.push(s), r && n.push(a), new NoAuthFlowFoundError("No appropriate authentication flow found", n, e)
									}
									firstUncompletedStage(e) {
										const t = this.data.completed || [];
										return e.stages.find(e => !t.includes(e))
									}
								}
							}, {
								"./logger": 356,
								"./utils": 393
							}],
							356: [function(e, t, r) {
								"use strict";
								var n = this && this.__importDefault || function(e) {
									return e && e.__esModule ? e : {
										default: e
									}
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.logger = void 0;
								const i = n(e("loglevel")),
									o = "matrix";

								function s(e) {
									e.withPrefix = function(e) {
										return function(e) {
											const t = i.default.getLogger(`${o}-${e}`);
											t.prefix !== e && (s(t), t.prefix = e, t.setLevel(i.default.levels.DEBUG, !1));
											return t
										}((this.prefix || "") + e)
									}
								}
								i.default.methodFactory = function(e, t, r) {
									return function(...t) {
										return this.prefix && t.unshift(this.prefix), "error" === e || "warn" === e || "trace" === e || "info" === e ? console[e](...t) : console.log(...t)
									}
								}, r.logger = i.default.getLogger(o), r.logger.setLevel(i.default.levels.DEBUG, !1), s(r.logger)
							}, {
								loglevel: 152
							}],
							357: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var r = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
												void 0 === n && (n = r);
												var i = Object.getOwnPropertyDescriptor(t, r);
												i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
													enumerable: !0,
													get: function() {
														return t[r]
													}
												}), Object.defineProperty(e, n, i)
											} : function(e, t, r, n) {
												void 0 === n && (n = r), e[n] = t[r]
											}),
											i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
												Object.defineProperty(e, "default", {
													enumerable: !0,
													value: t
												})
											} : function(e, t) {
												e.default = t
											}),
											o = this && this.__exportStar || function(e, t) {
												for (var n in e) "default" === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n)
											},
											s = this && this.__importStar || function(e) {
												if (e && e.__esModule) return e;
												var t = {};
												if (null != e)
													for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);
												return i(t, e), t
											};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.createRoomWidgetClient = n.createClient = n.setCryptoStoreFactory = n.GroupCallType = n.GroupCallState = n.GroupCallIntent = n.GroupCallEvent = n.createNewMatrixCall = n.ContentHelpers = void 0;
										const a = t("./crypto/store/memory-crypto-store"),
											c = t("./store/memory"),
											l = t("./scheduler"),
											u = t("./client"),
											d = t("./embedded");
										o(t("./client"), n), o(t("./embedded"), n), o(t("./http-api"), n), o(t("./autodiscovery"), n), o(t("./sync-accumulator"), n), o(t("./errors"), n), o(t("./models/beacon"), n), o(t("./models/event"), n), o(t("./models/room"), n), o(t("./models/event-timeline"), n), o(t("./models/event-timeline-set"), n), o(t("./models/room-member"), n), o(t("./models/room-state"), n), o(t("./models/user"), n), o(t("./scheduler"), n), o(t("./filter"), n), o(t("./timeline-window"), n), o(t("./interactive-auth"), n), o(t("./service-types"), n), o(t("./store/memory"), n), o(t("./store/indexeddb"), n), o(t("./crypto/store/memory-crypto-store"), n), o(t("./crypto/store/indexeddb-crypto-store"), n), o(t("./content-repo"), n), o(t("./@types/event"), n), o(t("./@types/PushRules"), n), o(t("./@types/partials"), n), o(t("./@types/requests"), n), o(t("./@types/search"), n), o(t("./models/room-summary"), n), n.ContentHelpers = s(t("./content-helpers"));
										var h = t("./webrtc/call");
										Object.defineProperty(n, "createNewMatrixCall", {
											enumerable: !0,
											get: function() {
												return h.createNewMatrixCall
											}
										});
										var f = t("./webrtc/groupCall");
										Object.defineProperty(n, "GroupCallEvent", {
											enumerable: !0,
											get: function() {
												return f.GroupCallEvent
											}
										}), Object.defineProperty(n, "GroupCallIntent", {
											enumerable: !0,
											get: function() {
												return f.GroupCallIntent
											}
										}), Object.defineProperty(n, "GroupCallState", {
											enumerable: !0,
											get: function() {
												return f.GroupCallState
											}
										}), Object.defineProperty(n, "GroupCallType", {
											enumerable: !0,
											get: function() {
												return f.GroupCallType
											}
										});
										let p = () => new a.MemoryCryptoStore;

										function v(t) {
											var r, n, i;
											return t.store = null !== (r = t.store) && void 0 !== r ? r : new c.MemoryStore({
												localStorage: e.localStorage
											}), t.scheduler = null !== (n = t.scheduler) && void 0 !== n ? n : new l.MatrixScheduler, t.cryptoStore = null !== (i = t.cryptoStore) && void 0 !== i ? i : p(), t
										}
										n.setCryptoStoreFactory = function(e) {
											p = e
										}, n.createClient = function(e) {
											return new u.MatrixClient(v(e))
										}, n.createRoomWidgetClient = function(e, t, r, n) {
											return new d.RoomWidgetClient(e, t, r, v(n))
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"./@types/PushRules": 288,
								"./@types/event": 290,
								"./@types/partials": 293,
								"./@types/requests": 295,
								"./@types/search": 296,
								"./autodiscovery": 302,
								"./client": 304,
								"./content-helpers": 305,
								"./content-repo": 306,
								"./crypto/store/indexeddb-crypto-store": 329,
								"./crypto/store/memory-crypto-store": 331,
								"./embedded": 341,
								"./errors": 342,
								"./filter": 346,
								"./http-api": 349,
								"./interactive-auth": 355,
								"./models/beacon": 360,
								"./models/event": 365,
								"./models/event-timeline": 364,
								"./models/event-timeline-set": 363,
								"./models/room": 373,
								"./models/room-member": 370,
								"./models/room-state": 371,
								"./models/room-summary": 372,
								"./models/user": 377,
								"./scheduler": 381,
								"./service-types": 382,
								"./store/indexeddb": 387,
								"./store/memory": 388,
								"./sync-accumulator": 390,
								"./timeline-window": 392,
								"./webrtc/call": 395,
								"./webrtc/groupCall": 399
							}],
							358: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.MSC3089Branch = void 0;
								const i = e("../@types/event"),
									o = e("./event-timeline");
								r.MSC3089Branch = class {
									constructor(e, t, r) {
										this.client = e, this.indexEvent = t, this.directory = r
									}
									get id() {
										const e = this.indexEvent.getStateKey();
										if (!e) throw new Error("State key not found for branch");
										return e
									}
									get isActive() {
										return !0 === this.indexEvent.getContent().active
									}
									get version() {
										var e;
										return null !== (e = this.indexEvent.getContent().version) && void 0 !== e ? e : 1
									}
									get roomId() {
										return this.indexEvent.getRoomId()
									}
									delete() {
										return n(this, void 0, void 0, (function*() {
											yield this.client.sendStateEvent(this.roomId, i.UNSTABLE_MSC3089_BRANCH.name, {}, this.id), yield this.client.redactEvent(this.roomId, this.id);
											const e = (yield this.getVersionHistory())[1];
											e && (yield e.delete())
										}))
									}
									getName() {
										return this.indexEvent.getContent().name || "Unnamed File"
									}
									setName(e) {
										return n(this, void 0, void 0, (function*() {
											yield this.client.sendStateEvent(this.roomId, i.UNSTABLE_MSC3089_BRANCH.name, Object.assign(Object.assign({}, this.indexEvent.getContent()), {
												name: e
											}), this.id)
										}))
									}
									isLocked() {
										return this.indexEvent.getContent().locked || !1
									}
									setLocked(e) {
										return n(this, void 0, void 0, (function*() {
											yield this.client.sendStateEvent(this.roomId, i.UNSTABLE_MSC3089_BRANCH.name, Object.assign(Object.assign({}, this.indexEvent.getContent()), {
												locked: e
											}), this.id)
										}))
									}
									getFileInfo() {
										return n(this, void 0, void 0, (function*() {
											const e = (yield this.getFileEvent()).getOriginalContent().file,
												t = this.client.mxcUrlToHttp(e.url);
											if (!t) throw new Error(`No HTTP URL available for ${e.url}`);
											return {
												info: e,
												httpUrl: t
											}
										}))
									}
									getFileEvent() {
										return n(this, void 0, void 0, (function*() {
											const e = this.client.getRoom(this.roomId);
											if (!e) throw new Error("Unknown room");
											let t = e.getUnfilteredTimelineSet().findEventById(this.id);
											for (; !t && e.getLiveTimeline().getState(o.EventTimeline.BACKWARDS).paginationToken;) yield this.client.scrollback(e, 100), t = e.getUnfilteredTimelineSet().findEventById(this.id);
											if (!t) throw new Error("Failed to find event");
											return yield this.client.decryptEventIfNeeded(t, {
												emit: !0,
												isRetry: !0
											}), t
										}))
									}
									createNewVersion(e, t, r, o) {
										return n(this, void 0, void 0, (function*() {
											const n = yield this.directory.createFile(e, t, r, Object.assign(Object.assign({}, null != o ? o : {}), {
												"m.new_content": !0,
												"m.relates_to": {
													rel_type: i.RelationType.Replace,
													event_id: this.id
												}
											}));
											return yield this.client.sendStateEvent(this.roomId, i.UNSTABLE_MSC3089_BRANCH.name, {
												active: !0,
												name: e,
												version: this.version + 1
											}, n.event_id), yield this.client.sendStateEvent(this.roomId, i.UNSTABLE_MSC3089_BRANCH.name, Object.assign(Object.assign({}, this.indexEvent.getContent()), {
												active: !1
											}), this.id), n
										}))
									}
									getVersionHistory() {
										return n(this, void 0, void 0, (function*() {
											const e = [];
											e.push(this);
											const t = this.client.getRoom(this.roomId);
											if (!t) throw new Error("Invalid or unknown room");
											const r = [...t.getLiveTimeline().getEvents()].reverse();
											let n, i = yield this.getFileEvent();
											do {
												if (n = r.find(e => e.replacingEventId() === i.getId())) {
													const t = this.directory.getFile(n.getId());
													if (!t) break;
													e.push(t), i = n
												}
											} while (n);
											return e
										}))
									}
								}
							}, {
								"../@types/event": 290,
								"./event-timeline": 364
							}],
							359: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
										return new(r || (r = Promise))((function(i, o) {
											function s(e) {
												try {
													c(n.next(e))
												} catch (t) {
													o(t)
												}
											}

											function a(e) {
												try {
													c(n.throw(e))
												} catch (t) {
													o(t)
												}
											}

											function c(e) {
												var t;
												e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
													e(t)
												}))).then(s, a)
											}
											c((n = n.apply(e, t || [])).next())
										}))
									},
									i = this && this.__importDefault || function(e) {
										return e && e.__esModule ? e : {
											default: e
										}
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.MSC3089TreeSpace = r.TreePermissions = r.DEFAULT_TREE_POWER_LEVELS_TEMPLATE = void 0;
								const o = i(e("p-retry")),
									s = e("../@types/event"),
									a = e("../logger"),
									c = e("../utils"),
									l = e("./MSC3089Branch"),
									u = e("../crypto/algorithms/megolm");
								var d;
								r.DEFAULT_TREE_POWER_LEVELS_TEMPLATE = {
										invite: 100,
										kick: 100,
										ban: 100,
										redact: 50,
										state_default: 50,
										events_default: 50,
										users_default: 0,
										events: {
											[s.EventType.RoomPowerLevels]: 100,
											[s.EventType.RoomHistoryVisibility]: 100,
											[s.EventType.RoomTombstone]: 100,
											[s.EventType.RoomEncryption]: 100,
											[s.EventType.RoomName]: 50,
											[s.EventType.RoomMessage]: 50,
											[s.EventType.RoomMessageEncrypted]: 50,
											[s.EventType.Sticker]: 50
										},
										users: {}
									},
									function(e) {
										e.Viewer = "viewer", e.Editor = "editor", e.Owner = "owner"
									}(d = r.TreePermissions || (r.TreePermissions = {}));
								r.MSC3089TreeSpace = class {
									constructor(e, t) {
										if (this.client = e, this.roomId = t, this.room = this.client.getRoom(this.roomId), !this.room) throw new Error("Unknown room")
									}
									get id() {
										return this.roomId
									}
									get isTopLevel() {
										const e = this.room.currentState.getStateEvents(s.EventType.SpaceParent);
										return null == e || !e.length || e.every(e => {
											var t;
											return !(null === (t = e.getContent()) || void 0 === t ? void 0 : t.via)
										})
									}
									setName(e) {
										return n(this, void 0, void 0, (function*() {
											yield this.client.sendStateEvent(this.roomId, s.EventType.RoomName, {
												name: e
											}, "")
										}))
									}
									invite(e, t = !0, r = !0) {
										return n(this, void 0, void 0, (function*() {
											const n = [this.retryInvite(e)];
											return t && n.push(...this.getDirectories().map(n => n.invite(e, t, r))), Promise.all(n).then(() => {
												r && (0, u.isRoomSharedHistory)(this.room) && this.client.sendSharedHistoryKeys(this.roomId, [e])
											})
										}))
									}
									retryInvite(e) {
										return (0, c.simpleRetryOperation)(() => n(this, void 0, void 0, (function*() {
											yield this.client.invite(this.roomId, e).catch(e => {
												if ("M_FORBIDDEN" === (null == e ? void 0 : e.errcode)) throw new o.default.AbortError(e);
												throw e
											})
										})))
									}
									setPermissions(e, t) {
										var r;
										return n(this, void 0, void 0, (function*() {
											const n = this.room.currentState.getStateEvents(s.EventType.RoomPowerLevels, "");
											if (Array.isArray(n)) throw new Error("Unexpected return type for power levels");
											const i = n.getContent() || {},
												o = i.users_default || 0,
												a = i.events_default || 50,
												c = (null === (r = i.events) || void 0 === r ? void 0 : r[s.EventType.RoomPowerLevels]) || 100,
												l = i.users || {};
											switch (t) {
												case d.Viewer:
													l[e] = o;
													break;
												case d.Editor:
													l[e] = a;
													break;
												case d.Owner:
													l[e] = c;
													break;
												default:
													throw new Error("Invalid role: " + t)
											}
											i.users = l, yield this.client.sendStateEvent(this.roomId, s.EventType.RoomPowerLevels, i, "")
										}))
									}
									getPermissions(e) {
										var t, r;
										const n = this.room.currentState.getStateEvents(s.EventType.RoomPowerLevels, "");
										if (Array.isArray(n)) throw new Error("Unexpected return type for power levels");
										const i = n.getContent() || {},
											o = i.users_default || 0,
											a = i.events_default || 50,
											c = (null === (t = i.events) || void 0 === t ? void 0 : t[s.EventType.RoomPowerLevels]) || 100,
											l = (null === (r = i.users) || void 0 === r ? void 0 : r[e]) || o;
										return l >= c ? d.Owner : l >= a ? d.Editor : d.Viewer
									}
									createDirectory(e) {
										return n(this, void 0, void 0, (function*() {
											const t = yield this.client.unstableCreateFileTree(e);
											return yield this.client.sendStateEvent(this.roomId, s.EventType.SpaceChild, {
												via: [this.client.getDomain()]
											}, t.roomId), yield this.client.sendStateEvent(t.roomId, s.EventType.SpaceParent, {
												via: [this.client.getDomain()]
											}, this.roomId), t
										}))
									}
									getDirectories() {
										const e = [],
											t = this.room.currentState.getStateEvents(s.EventType.SpaceChild);
										for (const n of t) try {
											const t = n.getStateKey();
											if (t) {
												const r = this.client.unstableGetFileTreeSpace(t);
												r && e.push(r)
											}
										} catch (r) {
											a.logger.warn("Unable to create tree space instance for listing. Are we joined?", r)
										}
										return e
									}
									getDirectory(e) {
										return this.getDirectories().find(t => t.roomId === e)
									}
									delete() {
										return n(this, void 0, void 0, (function*() {
											const e = this.getDirectories();
											for (const n of e) yield n.delete();
											const t = ["invite", "knock", "join"],
												r = this.room.currentState.getStateEvents(s.EventType.RoomMember);
											for (const n of r) {
												if (n.getStateKey() !== this.client.getUserId() && t.includes(n.getContent().membership)) {
													const e = n.getStateKey();
													if (!e) throw new Error("State key not found for branch");
													yield this.client.kick(this.roomId, e, "Room deleted")
												}
											}
											yield this.client.leave(this.roomId)
										}))
									}
									getOrderedChildren(e) {
										const t = e.map(e => ({
											roomId: e.getStateKey(),
											order: e.getContent().order
										})).filter(e => e.roomId);
										return t.sort((e, t) => {
											var r, n, i, o;
											if (e.order && !t.order) return -1;
											if (!e.order && t.order) return 1;
											if (e.order || t.order) return (0, c.lexicographicCompare)(e.order, t.order); {
												const a = this.client.getRoom(e.roomId),
													l = this.client.getRoom(t.roomId);
												if (!a || !l) return (0, c.lexicographicCompare)(e.roomId, t.roomId);
												const u = null !== (n = null === (r = a.currentState.getStateEvents(s.EventType.RoomCreate, "")) || void 0 === r ? void 0 : r.getTs()) && void 0 !== n ? n : 0,
													d = null !== (o = null === (i = l.currentState.getStateEvents(s.EventType.RoomCreate, "")) || void 0 === i ? void 0 : i.getTs()) && void 0 !== o ? o : 0;
												return u === d ? (0, c.lexicographicCompare)(e.roomId, t.roomId) : u - d
											}
										}), t
									}
									getParentRoom() {
										const e = this.room.currentState.getStateEvents(s.EventType.SpaceParent)[0];
										if (!e) throw new Error("Expected to have a parent in a non-top level space");
										const t = e.getStateKey();
										if (!t) throw new Error("No state key found for parent");
										const r = this.client.getRoom(t);
										if (!r) throw new Error("Unable to locate room for parent");
										return r
									}
									getOrder() {
										if (this.isTopLevel) return -1;
										const e = this.getParentRoom().currentState.getStateEvents(s.EventType.SpaceChild);
										return this.getOrderedChildren(e).findIndex(e => e.roomId === this.roomId)
									}
									setOrder(e) {
										var t, r;
										return n(this, void 0, void 0, (function*() {
											if (this.isTopLevel) throw new Error("Cannot set order of top level spaces currently");
											const n = this.getParentRoom(),
												i = n.currentState.getStateEvents(s.EventType.SpaceChild),
												o = this.getOrderedChildren(i);
											e = Math.max(Math.min(e, o.length - 1), 0);
											const a = this.getOrder() < e;
											a && e === o.length - 1 ? e-- : a || 0 !== e || e++;
											const l = o[a ? e : e - 1],
												u = o[a ? e + 1 : e];
											let d = c.DEFAULT_ALPHABET[0],
												h = !1;
											if (l)
												if (e === o.length - 1)(null == u ? void 0 : u.order) && (d = (0, c.nextString)(u.order));
												else {
													const e = null == l ? void 0 : l.order,
														t = null == u ? void 0 : u.order;
													e && t ? d = e === t ? (0, c.nextString)(e) : (0, c.averageBetweenStrings)(e, t) : e ? d = (0, c.nextString)(e) : t ? d = (0, c.prevString)(t) : h = !0
												}
											else(null == u ? void 0 : u.order) && (d = (0, c.prevString)(u.order));
											if (h) {
												let r;
												for (let i = 0; i <= e; i++) {
													const e = o[i];
													if (0 === i && (r = e.order), e.order) r = e.order;
													else {
														r = r ? (0, c.nextString)(r) : c.DEFAULT_ALPHABET[0];
														const i = n.currentState.getStateEvents(s.EventType.SpaceChild, e.roomId),
															o = null !== (t = null == i ? void 0 : i.getContent()) && void 0 !== t ? t : {
																via: [this.client.getDomain()]
															};
														yield this.client.sendStateEvent(n.roomId, s.EventType.SpaceChild, Object.assign(Object.assign({}, o), {
															order: r
														}), e.roomId)
													}
												}
												r && (d = (0, c.nextString)(r))
											}
											const f = n.currentState.getStateEvents(s.EventType.SpaceChild, this.roomId),
												p = null !== (r = null == f ? void 0 : f.getContent()) && void 0 !== r ? r : {
													via: [this.client.getDomain()]
												};
											yield this.client.sendStateEvent(n.roomId, s.EventType.SpaceChild, Object.assign(Object.assign({}, p), {
												order: d
											}), this.roomId)
										}))
									}
									createFile(e, t, r, i) {
										return n(this, void 0, void 0, (function*() {
											const {
												content_uri: n
											} = yield this.client.uploadContent(t, {
												includeFilename: !1
											});
											r.url = n;
											const o = {
												msgtype: s.MsgType.File,
												body: e,
												url: n,
												file: r
											};
											(i = null != i ? i : {})["m.new_content"] && (i["m.new_content"] = o);
											const a = yield this.client.sendMessage(this.roomId, Object.assign(Object.assign(Object.assign({}, i), o), {
												[s.UNSTABLE_MSC3089_LEAF.name]: {}
											}));
											return yield this.client.sendStateEvent(this.roomId, s.UNSTABLE_MSC3089_BRANCH.name, {
												active: !0,
												name: e
											}, a.event_id), a
										}))
									}
									getFile(e) {
										const t = this.room.currentState.getStateEvents(s.UNSTABLE_MSC3089_BRANCH.name, e);
										return t ? new l.MSC3089Branch(this.client, t, this) : null
									}
									listFiles() {
										return this.listAllFiles().filter(e => e.isActive)
									}
									listAllFiles() {
										var e;
										return (null !== (e = this.room.currentState.getStateEvents(s.UNSTABLE_MSC3089_BRANCH.name)) && void 0 !== e ? e : []).map(e => new l.MSC3089Branch(this.client, e, this))
									}
								}
							}, {
								"../@types/event": 290,
								"../crypto/algorithms/megolm": 317,
								"../logger": 356,
								"../utils": 393,
								"./MSC3089Branch": 358,
								"p-retry": 226
							}],
							360: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.Beacon = r.getBeaconInfoIdentifier = r.isTimestampInDuration = r.BeaconEvent = void 0;
								const n = e("../content-helpers"),
									i = e("../utils"),
									o = e("./typed-event-emitter");
								var s;
								! function(e) {
									e.New = "Beacon.new", e.Update = "Beacon.update", e.LivenessChange = "Beacon.LivenessChange", e.Destroy = "Beacon.Destroy", e.LocationUpdate = "Beacon.LocationUpdate"
								}(s = r.BeaconEvent || (r.BeaconEvent = {}));
								r.isTimestampInDuration = (e, t, r) => r >= e && e + t >= r;
								r.getBeaconInfoIdentifier = e => `${e.getRoomId()}_${e.getStateKey()}`;
								class a extends o.TypedEventEmitter {
									constructor(e) {
										super(), this.rootEvent = e, this.clearLatestLocation = () => {
											this._latestLocationEvent = void 0, this.emit(s.LocationUpdate, this.latestLocationState)
										}, this.setBeaconInfo(this.rootEvent), this.roomId = this.rootEvent.getRoomId()
									}
									get isLive() {
										return !!this._isLive
									}
									get identifier() {
										return (0, r.getBeaconInfoIdentifier)(this.rootEvent)
									}
									get beaconInfoId() {
										return this.rootEvent.getId()
									}
									get beaconInfoOwner() {
										return this.rootEvent.getStateKey()
									}
									get beaconInfoEventType() {
										return this.rootEvent.getType()
									}
									get beaconInfo() {
										return this._beaconInfo
									}
									get latestLocationState() {
										return this._latestLocationEvent && (0, n.parseBeaconContent)(this._latestLocationEvent.getContent())
									}
									get latestLocationEvent() {
										return this._latestLocationEvent
									}
									update(e) {
										if ((0, r.getBeaconInfoIdentifier)(e) !== this.identifier) throw new Error("Invalid updating event");
										e.getTs() < this.rootEvent.getTs() || (this.rootEvent = e, this.setBeaconInfo(this.rootEvent), this.emit(s.Update, e, this), this.clearLatestLocation())
									}
									destroy() {
										this.livenessWatchTimeout && clearTimeout(this.livenessWatchTimeout), this._isLive = !1, this.emit(s.Destroy, this.identifier)
									}
									monitorLiveness() {
										if (this.livenessWatchTimeout && clearTimeout(this.livenessWatchTimeout), this.checkLiveness(), this.beaconInfo)
											if (this.isLive) {
												const e = this.beaconInfo.timestamp + this.beaconInfo.timeout - Date.now();
												e > 1 && (this.livenessWatchTimeout = setTimeout(() => {
													this.monitorLiveness()
												}, e))
											} else this.beaconInfo.timestamp > Date.now() && (this.livenessWatchTimeout = setTimeout(() => {
												this.monitorLiveness()
											}, this.beaconInfo.timestamp - Date.now()))
									}
									addLocations(e) {
										var t;
										if (!this.isLive) return;
										const o = null === (t = e.filter(e => {
											const t = e.getContent(),
												i = (0, n.parseBeaconContent)(t);
											if (!i.uri || !i.timestamp) return !1;
											const {
												timestamp: o
											} = i;
											return this._beaconInfo.timestamp && (0, r.isTimestampInDuration)(this._beaconInfo.timestamp, this._beaconInfo.timeout, o) && (!this.latestLocationState || o > this.latestLocationState.timestamp)
										}).sort(i.sortEventsByLatestContentTimestamp)) || void 0 === t ? void 0 : t[0];
										o && (this._latestLocationEvent = o, this.emit(s.LocationUpdate, this.latestLocationState))
									}
									setBeaconInfo(e) {
										this._beaconInfo = (0, n.parseBeaconInfoContent)(e.getContent()), this.checkLiveness()
									}
									checkLiveness() {
										var e, t;
										const n = this.isLive;
										if (!this.beaconInfo) return;
										const i = this.beaconInfo.timestamp > Date.now() ? this.beaconInfo.timestamp - 36e4 : this.beaconInfo.timestamp;
										this._isLive = !!(null === (e = this._beaconInfo) || void 0 === e ? void 0 : e.live) && !!i && (0, r.isTimestampInDuration)(i, null === (t = this._beaconInfo) || void 0 === t ? void 0 : t.timeout, Date.now()), n !== this.isLive && this.emit(s.LivenessChange, this.isLive, this)
									}
								}
								r.Beacon = a
							}, {
								"../content-helpers": 305,
								"../utils": 393,
								"./typed-event-emitter": 376
							}],
							361: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.EventContext = void 0;
								const n = e("./event-timeline");
								r.EventContext = class {
									constructor(e) {
										this.ourEvent = e, this.ourEventIndex = 0, this.paginateTokens = {
											[n.Direction.Backward]: null,
											[n.Direction.Forward]: null
										}, this.timeline = [e]
									}
									getEvent() {
										return this.timeline[this.ourEventIndex]
									}
									getTimeline() {
										return this.timeline
									}
									getOurEventIndex() {
										return this.ourEventIndex
									}
									getPaginateToken(e = !1) {
										return this.paginateTokens[e ? n.Direction.Backward : n.Direction.Forward]
									}
									setPaginateToken(e, t = !1) {
										this.paginateTokens[t ? n.Direction.Backward : n.Direction.Forward] = null != e ? e : null
									}
									addEvents(e, t = !1) {
										t ? (this.timeline = e.concat(this.timeline), this.ourEventIndex += e.length) : this.timeline = this.timeline.concat(e)
									}
								}
							}, {
								"./event-timeline": 364
							}],
							362: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.EventStatus = void 0,
									function(e) {
										e.NOT_SENT = "not_sent", e.ENCRYPTING = "encrypting", e.SENDING = "sending", e.QUEUED = "queued", e.SENT = "sent", e.CANCELLED = "cancelled"
									}(r.EventStatus || (r.EventStatus = {}))
							}, {}],
							363: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.EventTimelineSet = r.DuplicateStrategy = void 0;
								const n = e("./event-timeline"),
									i = e("../logger"),
									o = e("./room"),
									s = e("./typed-event-emitter"),
									a = e("./relations-container");
								let c;
								var l;
								c = i.logger.log.bind(i.logger),
									function(e) {
										e.Ignore = "ignore", e.Replace = "replace"
									}(l = r.DuplicateStrategy || (r.DuplicateStrategy = {}));
								class u extends s.TypedEventEmitter {
									constructor(e, t = {}, r, i, o = null) {
										var s, c, l;
										super(), this.room = e, this.thread = i, this.threadListType = o, this._eventIdToTimeline = new Map, this.timelineSupport = Boolean(t.timelineSupport), this.liveTimeline = new n.EventTimeline(this), this.displayPendingEvents = !1 !== t.pendingEvents, this.timelines = [this.liveTimeline], this._eventIdToTimeline = new Map, this.filter = t.filter, this.relations = null !== (c = null === (s = this.room) || void 0 === s ? void 0 : s.relations) && void 0 !== c ? c : new a.RelationsContainer(null !== (l = null == e ? void 0 : e.client) && void 0 !== l ? l : r)
									}
									getTimelines() {
										return this.timelines
									}
									getFilter() {
										return this.filter
									}
									setFilter(e) {
										this.filter = e
									}
									getPendingEvents() {
										return this.room && this.displayPendingEvents ? this.room.getPendingEvents() : []
									}
									getLiveTimeline() {
										return this.liveTimeline
									}
									setLiveTimeline(e) {
										this.liveTimeline = e
									}
									eventIdToTimeline(e) {
										return this._eventIdToTimeline.get(e)
									}
									replaceEventId(e, t) {
										const r = this._eventIdToTimeline.get(e);
										r && (this._eventIdToTimeline.delete(e), this._eventIdToTimeline.set(t, r))
									}
									resetLiveTimeline(e, t) {
										const r = !this.timelineSupport || !t,
											i = this.liveTimeline,
											s = r ? i.forkLive(n.EventTimeline.FORWARDS) : i.fork(n.EventTimeline.FORWARDS);
										r ? (this.timelines = [s], this._eventIdToTimeline = new Map) : this.timelines.push(s), t && i.setPaginationToken(t, n.EventTimeline.FORWARDS), s.setPaginationToken(null != e ? e : null, n.EventTimeline.BACKWARDS), this.liveTimeline = s, this.emit(o.RoomEvent.TimelineReset, this.room, this, r)
									}
									getTimelineForEvent(e) {
										if (null == e) return null;
										const t = this._eventIdToTimeline.get(e);
										return void 0 === t ? null : t
									}
									findEventById(e) {
										const t = this.getTimelineForEvent(e);
										if (t) return t.getEvents().find((function(t) {
											return t.getId() == e
										}))
									}
									addTimeline() {
										if (!this.timelineSupport) throw new Error("timeline support is disabled. Set the 'timelineSupport' parameter to true when creating MatrixClient to enable it.");
										const e = new n.EventTimeline(this);
										return this.timelines.push(e), e
									}
									addEventsToTimeline(e, t, r, o) {
										if (!r) throw new Error("'timeline' not specified for EventTimelineSet.addEventsToTimeline");
										if (!t && r == this.liveTimeline) throw new Error("EventTimelineSet.addEventsToTimeline cannot be used for adding events to the live timeline - use Room.addLiveEvents instead");
										if (this.filter && !(e = this.filter.filterRoomTimeline(e)).length) return;
										const s = t ? n.EventTimeline.BACKWARDS : n.EventTimeline.FORWARDS,
											a = t ? n.EventTimeline.FORWARDS : n.EventTimeline.BACKWARDS;
										let l = !1,
											u = !1;
										for (const d of e) {
											const e = d.getId(),
												o = this._eventIdToTimeline.get(e);
											if (!o) {
												this.addEventToTimeline(d, r, {
													toStartOfTimeline: t
												}), u = !0, l = !0;
												continue
											}
											if (u = !1, o == r) {
												c("Event " + e + " already in timeline " + r);
												continue
											}
											const h = r.getNeighbouringTimeline(s);
											if (h) {
												c(o == h ? "Event " + e + " in neighbouring timeline - switching to " + o : "Event " + e + " already in a different timeline " + o), r = o;
												continue
											}
											i.logger.info("Already have timeline for " + e + " - joining timeline " + r + " to " + o);
											const f = o === this.liveTimeline,
												p = r === this.liveTimeline,
												v = s === n.EventTimeline.BACKWARDS && f,
												g = s === n.EventTimeline.FORWARDS && p;
											v || g ? (v && i.logger.warn("Refusing to set a preceding existingTimeLine on our timeline as the existingTimeLine is live (" + o + ")"), g && i.logger.warn("Refusing to set our preceding timeline on a existingTimeLine as our timeline is live (" + r + ")")) : (r.setNeighbouringTimeline(o, s), o.setNeighbouringTimeline(r, a), r = o, l = !0)
										}
										if (u || !l) {
											if (s === n.EventTimeline.FORWARDS && r === this.liveTimeline) return i.logger.warn({
												lastEventWasNew: u,
												didUpdate: l
											}), void i.logger.warn("Refusing to set forwards pagination token of live timeline " + `${r} to ${o}`);
											r.setPaginationToken(null != o ? o : null, s)
										}
									}
									addLiveEvent(e, t, r = !1, o) {
										let s, a = t || l.Ignore;
										if ("object" == typeof t ? ({
												duplicateStrategy: a = l.Ignore,
												fromCache: r = !1,
												roomState: o,
												timelineWasEmpty: s
											} = t) : void 0 !== t && i.logger.warn("Overload deprecated: `EventTimelineSet.addLiveEvent(event, duplicateStrategy?, fromCache?, roomState?)` is deprecated in favor of the overload with `EventTimelineSet.addLiveEvent(event, IAddLiveEventOptions)`"), this.filter) {
											if (!this.filter.filterRoomTimeline([e]).length) return
										}
										const u = this._eventIdToTimeline.get(e.getId());
										if (u)
											if (a === l.Replace) {
												c("EventTimelineSet.addLiveEvent: replacing duplicate event " + e.getId());
												const t = u.getEvents();
												for (let r = 0; r < t.length; r++)
													if (t[r].getId() === e.getId()) {
														o || (o = u.getState(n.EventTimeline.FORWARDS)), n.EventTimeline.setEventMetadata(e, o, !1), t[r] = e;
														break
													}
											} else c("EventTimelineSet.addLiveEvent: ignoring duplicate event " + e.getId());
										else this.addEventToTimeline(e, this.liveTimeline, {
											toStartOfTimeline: !1,
											fromCache: r,
											roomState: o,
											timelineWasEmpty: s
										})
									}
									addEventToTimeline(e, t, r, n = !1, s) {
										var a, c;
										let l, u = !!r;
										if ("object" == typeof r ? ({
												toStartOfTimeline: u,
												fromCache: n = !1,
												roomState: s,
												timelineWasEmpty: l
											} = r) : void 0 !== r && i.logger.warn("Overload deprecated: `EventTimelineSet.addEventToTimeline(event, timeline, toStartOfTimeline, fromCache?, roomState?)` is deprecated in favor of the overload with `EventTimelineSet.addEventToTimeline(event, timeline, IAddEventToTimelineOptions)`"), t.getTimelineSet() !== this) throw new Error(`EventTimelineSet.addEventToTimeline: Timeline=${t.toString()} does not belong " + \n                "in timelineSet(threadId=${null===(a=this.thread)||void 0===a?void 0:a.id})`);
										if (this.room && !this.canContain(e)) {
											let r = `event=${e.getId()}`;
											return e.threadRootId && (r += `(belongs to thread=${e.threadRootId})`), void i.logger.warn(`EventTimelineSet.addEventToTimeline: Ignoring ${r} that does not belong ` + `in timeline=${t.toString()} timelineSet(threadId=${null===(c=this.thread)||void 0===c?void 0:c.id})`)
										}
										const d = e.getId();
										t.addEvent(e, {
											toStartOfTimeline: u,
											roomState: s,
											timelineWasEmpty: l
										}), this._eventIdToTimeline.set(d, t), this.relations.aggregateParentEvent(e), this.relations.aggregateChildEvent(e, this);
										const h = {
											timeline: t,
											liveEvent: !u && t == this.liveTimeline && !n
										};
										this.emit(o.RoomEvent.Timeline, e, this.room, Boolean(u), !1, h)
									}
									handleRemoteEcho(e, t, r) {
										const n = this._eventIdToTimeline.get(t);
										n ? (this._eventIdToTimeline.delete(t), this._eventIdToTimeline.set(r, n)) : this.filter && !this.filter.filterRoomTimeline([e]).length || this.addEventToTimeline(e, this.liveTimeline, {
											toStartOfTimeline: !1
										})
									}
									removeEvent(e) {
										const t = this._eventIdToTimeline.get(e);
										if (!t) return null;
										const r = t.removeEvent(e);
										if (r) {
											this._eventIdToTimeline.delete(e);
											const n = {
												timeline: t
											};
											this.emit(o.RoomEvent.Timeline, r, this.room, void 0, !0, n)
										}
										return r
									}
									compareEventOrdering(e, t) {
										if (e == t) return 0;
										const r = this._eventIdToTimeline.get(e),
											i = this._eventIdToTimeline.get(t);
										if (void 0 === r) return null;
										if (void 0 === i) return null;
										if (r === i) {
											let n = void 0,
												i = void 0;
											const o = r.getEvents();
											for (let r = 0; r < o.length && (void 0 === n || void 0 === i); r++) {
												const s = o[r].getId();
												s == e && (n = r), s == t && (i = r)
											}
											return n - i
										}
										let o = r;
										for (; o;) {
											if (o === i) return -1;
											o = o.getNeighbouringTimeline(n.EventTimeline.FORWARDS)
										}
										for (o = r; o;) {
											if (o === i) return 1;
											o = o.getNeighbouringTimeline(n.EventTimeline.BACKWARDS)
										}
										return null
									}
									canContain(e) {
										if (!this.room) throw new Error("Cannot call `EventTimelineSet::canContain without a `room` set. Set the room when creating the EventTimelineSet to call this method.");
										const {
											threadId: t,
											shouldLiveInRoom: r
										} = this.room.eventShouldLiveIn(e);
										return this.thread ? this.thread.id === t : r
									}
								}
								r.EventTimelineSet = u
							}, {
								"../logger": 356,
								"./event-timeline": 364,
								"./relations-container": 368,
								"./room": 373,
								"./typed-event-emitter": 376
							}],
							364: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.EventTimeline = r.Direction = void 0;
								const n = e("../logger"),
									i = e("./room-state"),
									o = e("../@types/event");
								var s;
								! function(e) {
									e.Backward = "b", e.Forward = "f"
								}(s = r.Direction || (r.Direction = {}));
								class a {
									constructor(e) {
										var t, r;
										this.eventTimelineSet = e, this.events = [], this.baseIndex = 0, this.startToken = null, this.endToken = null, this.prevTimeline = null, this.nextTimeline = null, this.paginationRequests = {
											[s.Backward]: null,
											[s.Forward]: null
										}, this.roomId = null !== (r = null === (t = e.room) || void 0 === t ? void 0 : t.roomId) && void 0 !== r ? r : null, this.roomId && (this.startState = new i.RoomState(this.roomId), this.endState = new i.RoomState(this.roomId)), this.paginationRequests = {
											b: null,
											f: null
										}, this.name = this.roomId + ":" + (new Date).toISOString()
									}
									static setEventMetadata(e, t, r) {
										var n, i, s, a;
										(null === (i = null === (n = e.sender) || void 0 === n ? void 0 : n.events) || void 0 === i ? void 0 : i.member) || (e.sender = t.getSentinelMember(e.getSender())), (null === (a = null === (s = e.target) || void 0 === s ? void 0 : s.events) || void 0 === a ? void 0 : a.member) || e.getType() !== o.EventType.RoomMember || (e.target = t.getSentinelMember(e.getStateKey())), e.isState() && r && (e.forwardLooking = !1)
									}
									initialiseState(e, {
										timelineWasEmpty: t
									} = {}) {
										var r, n;
										if (this.events.length > 0) throw new Error("Cannot initialise state after events are added");
										null === (r = this.startState) || void 0 === r || r.setStateEvents(e, {
											timelineWasEmpty: t
										}), null === (n = this.endState) || void 0 === n || n.setStateEvents(e, {
											timelineWasEmpty: t
										})
									}
									forkLive(e) {
										const t = this.getState(e),
											r = new a(this.eventTimelineSet);
										return r.startState = null == t ? void 0 : t.clone(), r.endState = t, this.endState = null == t ? void 0 : t.clone(), r
									}
									fork(e) {
										const t = this.getState(e),
											r = new a(this.eventTimelineSet);
										return r.startState = null == t ? void 0 : t.clone(), r.endState = null == t ? void 0 : t.clone(), r
									}
									getRoomId() {
										return this.roomId
									}
									getFilter() {
										return this.eventTimelineSet.getFilter()
									}
									getTimelineSet() {
										return this.eventTimelineSet
									}
									getBaseIndex() {
										return this.baseIndex
									}
									getEvents() {
										return this.events
									}
									getState(e) {
										if (e == a.BACKWARDS) return this.startState;
										if (e == a.FORWARDS) return this.endState;
										throw new Error("Invalid direction '" + e + "'")
									}
									getPaginationToken(e) {
										return this.roomId ? this.getState(e).paginationToken : e === s.Backward ? this.startToken : this.endToken
									}
									setPaginationToken(e, t) {
										this.roomId ? this.getState(t).paginationToken = e : t === s.Backward ? this.startToken = e : this.endToken = e
									}
									getNeighbouringTimeline(e) {
										if (e == a.BACKWARDS) return this.prevTimeline;
										if (e == a.FORWARDS) return this.nextTimeline;
										throw new Error("Invalid direction '" + e + "'")
									}
									setNeighbouringTimeline(e, t) {
										if (this.getNeighbouringTimeline(t)) throw new Error("timeline already has a neighbouring timeline - cannot reset neighbour (direction: " + t + ")");
										if (t == a.BACKWARDS) this.prevTimeline = e;
										else {
											if (t != a.FORWARDS) throw new Error("Invalid direction '" + t + "'");
											this.nextTimeline = e
										}
										this.setPaginationToken(null, t)
									}
									addEvent(e, t, r) {
										let i, s = !!t;
										"object" == typeof t ? ({
											toStartOfTimeline: s,
											roomState: r,
											timelineWasEmpty: i
										} = t) : void 0 !== t && n.logger.warn("Overload deprecated: `EventTimeline.addEvent(event, toStartOfTimeline, roomState?)` is deprecated in favor of the overload with `EventTimeline.addEvent(event, IAddEventOptions)`"), r || (r = s ? this.startState : this.endState);
										const c = this.getTimelineSet();
										let l;
										c.room && (a.setEventMetadata(e, r, s), e.isState() && c.room.getUnfilteredTimelineSet() === c && (null == r || r.setStateEvents([e], {
											timelineWasEmpty: i
										}), e.sender && (e.getType() !== o.EventType.RoomMember || s) || a.setEventMetadata(e, r, s))), l = s ? 0 : this.events.length, this.events.splice(l, 0, e), s && this.baseIndex++
									}
									removeEvent(e) {
										for (let t = this.events.length - 1; t >= 0; t--) {
											const r = this.events[t];
											if (r.getId() == e) return this.events.splice(t, 1), t < this.baseIndex && this.baseIndex--, r
										}
										return null
									}
									toString() {
										return this.name
									}
								}
								r.EventTimeline = a, a.BACKWARDS = s.Backward, a.FORWARDS = s.Forward
							}, {
								"../@types/event": 290,
								"../logger": 356,
								"./room-state": 371
							}],
							365: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.MatrixEvent = r.MatrixEventEvent = r.EventStatus = void 0;
								const i = e("matrix-events-sdk"),
									o = e("../logger"),
									s = e("../@types/event"),
									a = e("../utils"),
									c = e("./thread"),
									l = e("../ReEmitter"),
									u = e("./typed-event-emitter");
								var d = e("./event-status");
								Object.defineProperty(r, "EventStatus", {
									enumerable: !0,
									get: function() {
										return d.EventStatus
									}
								});
								const h = Object.freeze({
									visible: !0
								});
								var f;
								! function(e) {
									e.Decrypted = "Event.decrypted", e.BeforeRedaction = "Event.beforeRedaction", e.VisibilityChange = "Event.visibilityChange", e.LocalEventIdReplaced = "Event.localEventIdReplaced", e.Status = "Event.status", e.Replaced = "Event.replaced", e.RelationsCreated = "Event.relationsCreated"
								}(f = r.MatrixEventEvent || (r.MatrixEventEvent = {}));
								class p extends u.TypedEventEmitter {
									constructor(e = {}) {
										var t;
										super(), this.event = e, this.pushActions = null, this._replacingEvent = null, this._localRedactionEvent = null, this._isCancelled = !1, this.visibility = h, this._hasCachedExtEv = !1, this._cachedExtEv = void 0, this.senderCurve25519Key = null, this.claimedEd25519Key = null, this.forwardingCurve25519KeyChain = [], this.untrusted = null, this.decryptionPromise = null, this.retryDecryption = !1, this.sender = null, this.target = null, this.status = null, this.error = null, this.forwardLooking = !0, ["state_key", "type", "sender", "room_id", "membership"].forEach(t => {
											"string" == typeof e[t] && (e[t] = (0, a.internaliseString)(e[t]))
										}), ["membership", "avatar_url", "displayname"].forEach(t => {
											var r;
											"string" == typeof(null === (r = e.content) || void 0 === r ? void 0 : r[t]) && (e.content[t] = (0, a.internaliseString)(e.content[t]))
										}), ["rel_type"].forEach(t => {
											var r, n;
											"string" == typeof(null === (n = null === (r = e.content) || void 0 === r ? void 0 : r["m.relates_to"]) || void 0 === n ? void 0 : n[t]) && (e.content["m.relates_to"][t] = (0, a.internaliseString)(e.content["m.relates_to"][t]))
										}), this.txnId = e.txn_id, this.localTimestamp = Date.now() - (null !== (t = this.getAge()) && void 0 !== t ? t : 0), this.reEmitter = new l.TypedReEmitter(this)
									}
									get unstableExtensibleEvent() {
										return this._hasCachedExtEv || (this._cachedExtEv = i.ExtensibleEvents.parse(this.getEffectiveEvent())), this._cachedExtEv
									}
									invalidateExtensibleEvent() {
										this._hasCachedExtEv = !1
									}
									getEffectiveEvent() {
										const e = Object.assign({}, this.getContent());
										if (this.getWireType() === s.EventType.RoomMessageEncrypted)
											for (const [t, r] of Object.entries(this.getWireContent()))["algorithm", "ciphertext", "device_id", "sender_key", "session_id"].includes(t) || void 0 === e[t] && (e[t] = r);
										return Object.assign({}, this.event, this.clearEvent, {
											content: e
										})
									}
									getId() {
										return this.event.event_id
									}
									getSender() {
										return this.event.sender || this.event.user_id
									}
									getType() {
										return this.clearEvent ? this.clearEvent.type : this.event.type
									}
									getWireType() {
										return this.event.type
									}
									getRoomId() {
										return this.event.room_id
									}
									getTs() {
										return this.event.origin_server_ts
									}
									getDate() {
										return this.event.origin_server_ts ? new Date(this.event.origin_server_ts) : null
									}
									getDetails() {
										let e = `id=${this.getId()} type=${this.getWireType()} sender=${this.getSender()}`;
										const t = this.getRoomId();
										t && (e += ` room=${t}`);
										const r = this.getDate();
										return r && (e += ` ts=${r.toISOString()}`), e
									}
									getOriginalContent() {
										return this._localRedactionEvent ? {} : this.clearEvent ? this.clearEvent.content || {} : this.event.content || {}
									}
									getContent() {
										return this._localRedactionEvent ? {} : this._replacingEvent ? this._replacingEvent.getContent()["m.new_content"] || {} : this.getOriginalContent()
									}
									getWireContent() {
										return this.event.content || {}
									}
									get threadRootId() {
										var e, t;
										const r = null === (e = this.getWireContent()) || void 0 === e ? void 0 : e["m.relates_to"];
										return (null == r ? void 0 : r.rel_type) === c.THREAD_RELATION_TYPE.name ? r.event_id : (null === (t = this.getThread()) || void 0 === t ? void 0 : t.id) || this.threadId
									}
									get isThreadRoot() {
										var e;
										return !!this.getServerAggregatedRelation(c.THREAD_RELATION_TYPE.name) || (null === (e = this.getThread()) || void 0 === e ? void 0 : e.id) === this.getId()
									}
									get replyEventId() {
										var e;
										const t = this.getContent()["m.relates_to"] || this.getWireContent()["m.relates_to"];
										return null === (e = null == t ? void 0 : t["m.in_reply_to"]) || void 0 === e ? void 0 : e.event_id
									}
									get relationEventId() {
										var e, t;
										return null === (t = null === (e = this.getWireContent()) || void 0 === e ? void 0 : e["m.relates_to"]) || void 0 === t ? void 0 : t.event_id
									}
									getPrevContent() {
										return this.getUnsigned().prev_content || this.event.prev_content || {}
									}
									getDirectionalContent() {
										return this.forwardLooking ? this.getContent() : this.getPrevContent()
									}
									getAge() {
										return this.getUnsigned().age || this.event.age
									}
									getLocalAge() {
										return Date.now() - this.localTimestamp
									}
									getStateKey() {
										return this.event.state_key
									}
									isState() {
										return void 0 !== this.event.state_key
									}
									makeEncrypted(e, t, r, n) {
										this.clearEvent = {
											type: this.event.type,
											content: this.event.content
										}, this.event.type = e, this.event.content = t, this.senderCurve25519Key = r, this.claimedEd25519Key = n
									}
									isBeingDecrypted() {
										return null != this.decryptionPromise
									}
									getDecryptionPromise() {
										return this.decryptionPromise
									}
									isDecryptionFailure() {
										var e, t;
										return "m.bad.encrypted" === (null === (t = null === (e = this.clearEvent) || void 0 === e ? void 0 : e.content) || void 0 === t ? void 0 : t.msgtype)
									}
									shouldAttemptDecryption() {
										return !this.isRedacted() && (!this.isBeingDecrypted() && (!this.clearEvent && !!this.isEncrypted()))
									}
									attemptDecryption(e, t = {}) {
										return n(this, void 0, void 0, (function*() {
											if (!this.isEncrypted()) throw new Error("Attempt to decrypt event which isn't encrypted");
											const r = this.clearEvent && !this.isDecryptionFailure(),
												n = t.forceRedecryptIfUntrusted && this.isKeySourceUntrusted();
											if (r && !n) throw new Error("Attempt to decrypt event which has already been decrypted");
											return this.decryptionPromise ? (o.logger.log(`Event ${this.getId()} already being decrypted; queueing a retry`), this.retryDecryption = !0, this.decryptionPromise) : (this.decryptionPromise = this.decryptionLoop(e, t), this.decryptionPromise)
										}))
									}
									cancelAndResendKeyRequest(e, t) {
										const r = this.getWireContent();
										return e.requestRoomKey({
											algorithm: r.algorithm,
											room_id: this.getRoomId(),
											session_id: r.session_id,
											sender_key: r.sender_key
										}, this.getKeyRequestRecipients(t), !0)
									}
									getKeyRequestRecipients(e) {
										const t = this.getWireContent(),
											r = [{
												userId: e,
												deviceId: "*"
											}],
											n = this.getSender();
										return n !== e && r.push({
											userId: n,
											deviceId: t.device_id
										}), r
									}
									decryptionLoop(e, t = {}) {
										return n(this, void 0, void 0, (function*() {
											for (yield Promise.resolve();;) {
												let n;
												this.retryDecryption = !1;
												let i = void 0;
												try {
													e ? (n = yield e.decryptEvent(this), !0 === t.isRetry && o.logger.info(`Decrypted event on retry (${this.getDetails()})`)) : n = this.badEncryptedMessage("Encryption not enabled")
												} catch (r) {
													if ("DecryptionError" !== r.name) {
														const e = t.isRetry ? "re" : "";
														return o.logger.error(`Error ${e}decrypting event (${this.getDetails()})`, r), this.decryptionPromise = null, void(this.retryDecryption = !1)
													}
													if (i = r, this.retryDecryption) {
														o.logger.log(`Error decrypting event (${this.getDetails()}), but retrying: ` + r.detailedString);
														continue
													}
													o.logger.warn(`Error decrypting event (${this.getDetails()}): ` + r.detailedString), n = this.badEncryptedMessage(r.message)
												}
												return this.decryptionPromise = null, this.retryDecryption = !1, this.setClearData(n), this.setPushActions(null), void(!1 !== t.emit && this.emit(f.Decrypted, this, i))
											}
										}))
									}
									badEncryptedMessage(e) {
										return {
											clearEvent: {
												type: s.EventType.RoomMessage,
												content: {
													msgtype: "m.bad.encrypted",
													body: "** Unable to decrypt: " + e + " **"
												}
											}
										}
									}
									setClearData(e) {
										var t, r;
										this.clearEvent = e.clearEvent, this.senderCurve25519Key = null !== (t = e.senderCurve25519Key) && void 0 !== t ? t : null, this.claimedEd25519Key = null !== (r = e.claimedEd25519Key) && void 0 !== r ? r : null, this.forwardingCurve25519KeyChain = e.forwardingCurve25519KeyChain || [], this.untrusted = e.untrusted || !1, this.invalidateExtensibleEvent()
									}
									getClearContent() {
										return this.clearEvent ? this.clearEvent.content : null
									}
									isEncrypted() {
										return !this.isState() && this.event.type === s.EventType.RoomMessageEncrypted
									}
									getSenderKey() {
										return this.senderCurve25519Key
									}
									getKeysClaimed() {
										return this.claimedEd25519Key ? {
											ed25519: this.claimedEd25519Key
										} : {}
									}
									getClaimedEd25519Key() {
										return this.claimedEd25519Key
									}
									getForwardingCurve25519KeyChain() {
										return this.forwardingCurve25519KeyChain
									}
									isKeySourceUntrusted() {
										return !!this.untrusted
									}
									getUnsigned() {
										return this.event.unsigned || {}
									}
									setUnsigned(e) {
										this.event.unsigned = e
									}
									unmarkLocallyRedacted() {
										const e = this._localRedactionEvent;
										return this._localRedactionEvent = null, this.event.unsigned && (this.event.unsigned.redacted_because = void 0), !!e
									}
									markLocallyRedacted(e) {
										this._localRedactionEvent || (this.emit(f.BeforeRedaction, this, e), this._localRedactionEvent = e, this.event.unsigned || (this.event.unsigned = {}), this.event.unsigned.redacted_because = e.event)
									}
									applyVisibilityEvent(e) {
										var t, r;
										const n = null === (t = null == e ? void 0 : e.visible) || void 0 === t || t,
											i = null !== (r = null == e ? void 0 : e.reason) && void 0 !== r ? r : null;
										let o = !1;
										this.visibility.visible !== n ? o = !0 : this.visibility.visible || this.visibility.reason === i || (o = !0), o && (this.visibility = n ? h : Object.freeze({
											visible: !1,
											reason: i
										}), this.emit(f.VisibilityChange, this, n))
									}
									messageVisibility() {
										return this.visibility
									}
									makeRedacted(e) {
										if (!e.event) throw new Error("invalid redactionEvent in makeRedacted");
										this._localRedactionEvent = null, this.emit(f.BeforeRedaction, this, e), this._replacingEvent = null, this.event.unsigned || (this.event.unsigned = {}), this.event.unsigned.redacted_because = e.event;
										for (const n in this.event) this.event.hasOwnProperty(n) && !v.has(n) && delete this.event[n];
										this.isEncrypted() && (this.clearEvent = void 0);
										const t = g[this.getType()] || {},
											r = this.getContent();
										for (const n in r) r.hasOwnProperty(n) && !t[n] && delete r[n];
										this.invalidateExtensibleEvent()
									}
									isRedacted() {
										return Boolean(this.getUnsigned().redacted_because)
									}
									isRedaction() {
										return this.getType() === s.EventType.RoomRedaction
									}
									asVisibilityChange() {
										if (!s.EVENT_VISIBILITY_CHANGE_TYPE.matches(this.getType())) return null;
										const e = this.getRelation();
										if (!e || "m.reference" != e.rel_type) return null;
										const t = e.event_id;
										if (!t) return null;
										const r = this.getWireContent(),
											n = !!r.visible,
											i = r.reason;
										return i && "string" != typeof i ? null : {
											visible: n,
											reason: i,
											eventId: t
										}
									}
									isVisibilityEvent() {
										return s.EVENT_VISIBILITY_CHANGE_TYPE.matches(this.getType())
									}
									getRedactionEvent() {
										var e, t, r, n;
										return this.isRedacted() ? (null === (e = this.clearEvent) || void 0 === e ? void 0 : e.unsigned) ? null !== (r = null === (t = this.clearEvent) || void 0 === t ? void 0 : t.unsigned.redacted_because) && void 0 !== r ? r : null : (null === (n = this.event.unsigned) || void 0 === n ? void 0 : n.redacted_because) ? this.event.unsigned.redacted_because : {} : null
									}
									getPushActions() {
										return this.pushActions
									}
									setPushActions(e) {
										this.pushActions = e
									}
									handleRemoteEcho(e) {
										const t = this.getUnsigned(),
											r = this.getId();
										this.event = e, t.redacted_because && (this.event.unsigned || (this.event.unsigned = {}), this.event.unsigned.redacted_because = t.redacted_because), this.setStatus(null), this.getId() !== r && this.emit(f.LocalEventIdReplaced, this), this.localTimestamp = Date.now() - this.getAge()
									}
									isSending() {
										return !!this.status
									}
									setStatus(e) {
										this.status = e, this.emit(f.Status, this, e)
									}
									replaceLocalEventId(e) {
										this.event.event_id = e, this.emit(f.LocalEventIdReplaced, this)
									}
									isRelation(e) {
										var t;
										const r = null === (t = this.getWireContent()) || void 0 === t ? void 0 : t["m.relates_to"];
										return (!this.isState() || (null == r ? void 0 : r.rel_type) !== s.RelationType.Replace) && !(!((null == r ? void 0 : r.rel_type) && r.event_id) || e && r.rel_type !== e)
									}
									getRelation() {
										var e;
										return this.isRelation() && null !== (e = this.getWireContent()["m.relates_to"]) && void 0 !== e ? e : null
									}
									makeReplaced(e) {
										this.isRedacted() && e || this.isState() || this._replacingEvent !== e && (this._replacingEvent = null != e ? e : null, this.emit(f.Replaced, this), this.invalidateExtensibleEvent())
									}
									getAssociatedStatus() {
										return this._replacingEvent ? this._replacingEvent.status : this._localRedactionEvent ? this._localRedactionEvent.status : this.status
									}
									getServerAggregatedRelation(e) {
										var t;
										return null === (t = this.getUnsigned()["m.relations"]) || void 0 === t ? void 0 : t[e]
									}
									replacingEventId() {
										const e = this.getServerAggregatedRelation(s.RelationType.Replace);
										return e ? e.event_id : this._replacingEvent ? this._replacingEvent.getId() : void 0
									}
									replacingEvent() {
										return this._replacingEvent
									}
									replacingEventDate() {
										var e;
										const t = this.getServerAggregatedRelation(s.RelationType.Replace);
										if (t) {
											const e = t.origin_server_ts;
											if (Number.isFinite(e)) return new Date(e)
										} else if (this._replacingEvent) return null !== (e = this._replacingEvent.getDate()) && void 0 !== e ? e : void 0
									}
									localRedactionEvent() {
										return this._localRedactionEvent
									}
									getAssociatedId() {
										const e = this.getRelation();
										return this.replyEventId ? this.replyEventId : e ? e.event_id : this.isRedaction() ? this.event.redacts : void 0
									}
									hasAssocation() {
										return !!this.getAssociatedId()
									}
									updateAssociatedId(e) {
										const t = this.getRelation();
										t ? t.event_id = e : this.isRedaction() && (this.event.redacts = e)
									}
									flagCancelled(e = !0) {
										this._isCancelled = e
									}
									isCancelled() {
										return this._isCancelled
									}
									toSnapshot() {
										const e = new p(JSON.parse(JSON.stringify(this.event)));
										for (const [t, r] of Object.entries(this)) "event" !== t && (e[t] = r);
										return e
									}
									isEquivalentTo(e) {
										if (!e) return !1;
										if (e === this) return !0;
										const t = (0, a.deepSortedObjectEntries)(this.event),
											r = (0, a.deepSortedObjectEntries)(e.event);
										return JSON.stringify(t) === JSON.stringify(r)
									}
									toJSON() {
										const e = this.getEffectiveEvent();
										return this.isEncrypted() ? {
											decrypted: e,
											encrypted: this.event
										} : e
									}
									setVerificationRequest(e) {
										this.verificationRequest = e
									}
									setTxnId(e) {
										this.txnId = e
									}
									getTxnId() {
										return this.txnId
									}
									setThread(e) {
										this.thread && this.reEmitter.stopReEmitting(this.thread, [c.ThreadEvent.Update]), this.thread = e, this.setThreadId(null == e ? void 0 : e.id), e && this.reEmitter.reEmit(e, [c.ThreadEvent.Update])
									}
									getThread() {
										return this.thread
									}
									setThreadId(e) {
										this.threadId = e
									}
								}
								r.MatrixEvent = p;
								const v = new Set(["event_id", "type", "room_id", "user_id", "sender", "state_key", "prev_state", "content", "unsigned", "origin_server_ts"]),
									g = {
										[s.EventType.RoomMember]: {
											membership: 1
										},
										[s.EventType.RoomCreate]: {
											creator: 1
										},
										[s.EventType.RoomJoinRules]: {
											join_rule: 1
										},
										[s.EventType.RoomPowerLevels]: {
											ban: 1,
											events: 1,
											events_default: 1,
											kick: 1,
											redact: 1,
											state_default: 1,
											users: 1,
											users_default: 1
										}
									}
							}, {
								"../@types/event": 290,
								"../ReEmitter": 300,
								"../logger": 356,
								"../utils": 393,
								"./event-status": 362,
								"./thread": 375,
								"./typed-event-emitter": 376,
								"matrix-events-sdk": 168
							}],
							366: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.IgnoredInvites = r.PolicyScope = r.IGNORE_INVITES_ACCOUNT_EVENT_KEY = r.POLICIES_ACCOUNT_EVENT_TYPE = void 0;
								const i = e("matrix-events-sdk"),
									o = e("./event-timeline"),
									s = e("../@types/partials"),
									a = e("../utils");
								var c, l;
								r.POLICIES_ACCOUNT_EVENT_TYPE = new i.UnstableValue("m.policies", "org.matrix.msc3847.policies"), r.IGNORE_INVITES_ACCOUNT_EVENT_KEY = new i.UnstableValue("m.ignore.invites", "org.matrix.msc3847.ignore.invites"),
									function(e) {
										e.Ban = "m.ban"
									}(c || (c = {})),
									function(e) {
										e.User = "m.policy.user", e.Room = "m.policy.room", e.Server = "m.policy.server"
									}(l = r.PolicyScope || (r.PolicyScope = {}));
								r.IgnoredInvites = class {
									constructor(e) {
										this.client = e
									}
									addRule(e, t, r) {
										return n(this, void 0, void 0, (function*() {
											const n = yield this.getOrCreateTargetRoom();
											return (yield this.client.sendStateEvent(n.roomId, e, {
												entity: t,
												reason: r,
												recommendation: c.Ban
											})).event_id
										}))
									}
									removeRule(e) {
										return n(this, void 0, void 0, (function*() {
											yield this.client.redactEvent(e.getRoomId(), e.getId())
										}))
									}
									addSource(e) {
										return n(this, void 0, void 0, (function*() {
											yield this.client.joinRoom(e);
											const t = (yield this.getOrCreateSourceRooms()).map(e => e.roomId);
											return !t.includes(e) && (t.push(e), yield this.withIgnoreInvitesPolicies(e => {
												e.sources = t
											}), !0)
										}))
									}
									getRuleForInvite({
										sender: e,
										roomId: t
									}) {
										return n(this, void 0, void 0, (function*() {
											const r = yield this.getOrCreateSourceRooms(), n = e.split(":")[1], i = t.split(":")[1];
											for (const u of r) {
												const r = u.getUnfilteredTimelineSet().getLiveTimeline().getState(o.EventTimeline.FORWARDS);
												for (const {
														scope: o,
														entities: u
													} of [{
														scope: l.Room,
														entities: [t]
													}, {
														scope: l.User,
														entities: [e]
													}, {
														scope: l.Server,
														entities: [n, i]
													}]) {
													const e = r.getStateEvents(o);
													for (const t of e) {
														const e = t.getContent();
														if ((null == e ? void 0 : e.recommendation) != c.Ban) continue;
														const r = null == e ? void 0 : e.entity;
														if (!r) continue;
														let n;
														try {
															n = new RegExp((0, a.globToRegexp)(r, !1))
														} catch (s) {
															continue
														}
														for (const i of u)
															if (i && n.test(i)) return t
													}
												}
											}
											return null
										}))
									}
									getOrCreateTargetRoom() {
										return n(this, void 0, void 0, (function*() {
											let e = this.getIgnoreInvitesPolicies().target;
											if ("string" != typeof e && (e = null), e) {
												const t = this.client.getRoom(e);
												if (t) return t;
												e = null
											}
											return e = (yield this.client.createRoom({
												name: "Individual Policy Room",
												preset: s.Preset.PrivateChat
											})).room_id, yield this.withIgnoreInvitesPolicies(t => {
												t.target = e
											}), this.client.getRoom(e)
										}))
									}
									getOrCreateSourceRooms() {
										return n(this, void 0, void 0, (function*() {
											let e = this.getIgnoreInvitesPolicies().sources,
												t = !1;
											Array.isArray(e) || (t = !0, e = []);
											let r = e.filter(e => "string" == typeof e).map(e => this.client.getRoom(e)).filter(e => !!e);
											if (r.length != e.length && (t = !0), 0 == r.length) {
												t = !0, r = [yield this.getOrCreateTargetRoom()]
											}
											return t && (yield this.withIgnoreInvitesPolicies(t => {
												t.sources = e
											})), r
										}))
									}
									getIgnoreInvitesPolicies() {
										return this.getPoliciesAndIgnoreInvitesPolicies().ignoreInvitesPolicies
									}
									withIgnoreInvitesPolicies(e) {
										return n(this, void 0, void 0, (function*() {
											const {
												policies: t,
												ignoreInvitesPolicies: n
											} = this.getPoliciesAndIgnoreInvitesPolicies();
											e(n), t[r.IGNORE_INVITES_ACCOUNT_EVENT_KEY.name] = n, yield this.client.setAccountData(r.POLICIES_ACCOUNT_EVENT_TYPE.name, t)
										}))
									}
									getPoliciesAndIgnoreInvitesPolicies() {
										var e;
										let t = {};
										for (const o of [r.POLICIES_ACCOUNT_EVENT_TYPE.name, r.POLICIES_ACCOUNT_EVENT_TYPE.altName]) {
											if (!o) continue;
											const r = null === (e = this.client.getAccountData(o)) || void 0 === e ? void 0 : e.getContent();
											if (r) {
												t = r;
												break
											}
										}
										let n = {},
											i = !1;
										for (const o of [r.IGNORE_INVITES_ACCOUNT_EVENT_KEY.name, r.IGNORE_INVITES_ACCOUNT_EVENT_KEY.altName]) {
											if (!o) continue;
											const e = t[o];
											if (e && "object" == typeof e) {
												n = e, i = !0;
												break
											}
										}
										return i || (t[r.IGNORE_INVITES_ACCOUNT_EVENT_KEY.name] = n), {
											policies: t,
											ignoreInvitesPolicies: n
										}
									}
								}
							}, {
								"../@types/partials": 293,
								"../utils": 393,
								"./event-timeline": 364,
								"matrix-events-sdk": 168
							}],
							367: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
										Object.defineProperty(e, "default", {
											enumerable: !0,
											value: t
										})
									} : function(e, t) {
										e.default = t
									}),
									o = this && this.__importStar || function(e) {
										if (e && e.__esModule) return e;
										var t = {};
										if (null != e)
											for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
										return i(t, e), t
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.ReadReceipt = r.synthesizeReceipt = r.MAIN_ROOM_TIMELINE = void 0;
								const s = e("../@types/read_receipts"),
									a = e("./typed-event-emitter"),
									c = o(e("../utils")),
									l = e("./event"),
									u = e("../@types/event");

								function d(e, t, n) {
									var i;
									return new l.MatrixEvent({
										content: {
											[t.getId()]: {
												[n]: {
													[e]: {
														ts: t.getTs(),
														threadId: null !== (i = t.threadRootId) && void 0 !== i ? i : r.MAIN_ROOM_TIMELINE
													}
												}
											}
										},
										type: u.EventType.Receipt,
										room_id: t.getRoomId()
									})
								}
								r.MAIN_ROOM_TIMELINE = "main", r.synthesizeReceipt = d;
								const h = 0,
									f = 1;
								class p extends a.TypedEventEmitter {
									constructor() {
										super(...arguments), this.receipts = {}, this.receiptCacheByEventId = {}
									}
									getReadReceiptForUserId(e, t = !1, r = s.ReceiptType.Read) {
										var n, i;
										const [o, a] = null !== (i = null === (n = this.receipts[r]) || void 0 === n ? void 0 : n[e]) && void 0 !== i ? i : [];
										return t ? o : null != a ? a : o
									}
									getEventReadUpTo(e, t = !1) {
										var r, n, i, o, a, c, l;
										const u = this.getUnfilteredTimelineSet(),
											d = this.getReadReceiptForUserId(e, t, s.ReceiptType.Read),
											h = this.getReadReceiptForUserId(e, t, s.ReceiptType.ReadPrivate);
										let f;
										return (null == d ? void 0 : d.eventId) && (null == h ? void 0 : h.eventId) && (f = u.compareEventOrdering(null == d ? void 0 : d.eventId, null == h ? void 0 : h.eventId)), !f && (null === (r = null == d ? void 0 : d.data) || void 0 === r ? void 0 : r.ts) && (null === (n = null == h ? void 0 : h.data) || void 0 === n ? void 0 : n.ts) && (f = (null === (i = null == d ? void 0 : d.data) || void 0 === i ? void 0 : i.ts) - (null === (o = null == h ? void 0 : h.data) || void 0 === o ? void 0 : o.ts)), f ? null !== (l = f < 0 ? null == h ? void 0 : h.eventId : null == d ? void 0 : d.eventId) && void 0 !== l ? l : null : null !== (c = null !== (a = null == h ? void 0 : h.eventId) && void 0 !== a ? a : null == d ? void 0 : d.eventId) && void 0 !== c ? c : null
									}
									addReceiptToStructure(e, t, r, n, i) {
										var o, s, a;
										this.receipts[t] || (this.receipts[t] = {}), this.receipts[t][r] || (this.receipts[t][r] = [null, null]);
										const c = this.receipts[t][r];
										let l = c[h];
										if (i && (l = null !== (o = c[f]) && void 0 !== o ? o : c[h]), l) {
											const t = this.getUnfilteredTimelineSet().compareEventOrdering(l.eventId, e);
											if (null !== t && t >= 0) return
										}
										const u = {
												eventId: e,
												data: n
											},
											d = i ? c[h] : u,
											p = i ? u : c[f];
										let v = null;
										d && p && (v = this.getUnfilteredTimelineSet().compareEventOrdering(d.eventId, p.eventId));
										const g = null === v || v < 0,
											m = null !== (s = c[f]) && void 0 !== s ? s : c[h];
										if (i && g ? c[f] = u : i || (c[h] = u, g || (c[f] = null)), m !== (null !== (a = c[f]) && void 0 !== a ? a : c[h])) {
											if (m && this.receiptCacheByEventId[m.eventId]) {
												const e = m.eventId;
												this.receiptCacheByEventId[e] = this.receiptCacheByEventId[e].filter(e => e.type !== t || e.userId !== r), this.receiptCacheByEventId[e].length < 1 && delete this.receiptCacheByEventId[e]
											}
											this.receiptCacheByEventId[e] || (this.receiptCacheByEventId[e] = []), this.receiptCacheByEventId[e].push({
												userId: r,
												type: t,
												data: n
											})
										}
									}
									getReceiptsForEvent(e) {
										return this.receiptCacheByEventId[e.getId()] || []
									}
									addLocalEchoReceipt(e, t, r) {
										this.addReceipt(d(e, t, r), !0)
									}
									getUsersReadUpTo(e) {
										return this.getReceiptsForEvent(e).filter((function(e) {
											return c.isSupportedReceiptType(e.type)
										})).map((function(e) {
											return e.userId
										}))
									}
									hasUserReadEvent(e, t) {
										var r, n;
										const i = this.getEventReadUpTo(e, !1);
										if (i === t) return !0;
										if ((null === (r = this.timeline) || void 0 === r ? void 0 : r.length) && this.timeline[this.timeline.length - 1].getSender() && this.timeline[this.timeline.length - 1].getSender() === e) return !0;
										for (let o = (null === (n = this.timeline) || void 0 === n ? void 0 : n.length) - 1; o >= 0; --o) {
											const e = this.timeline[o];
											if (e.getId() === t) return !1;
											if (e.getId() === i) return !0
										}
										return !1
									}
								}
								r.ReadReceipt = p
							}, {
								"../@types/event": 290,
								"../@types/read_receipts": 294,
								"../utils": 393,
								"./event": 365,
								"./typed-event-emitter": 376
							}],
							368: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.RelationsContainer = void 0;
								const n = e("./relations"),
									i = e("./event");
								r.RelationsContainer = class {
									constructor(e, t) {
										this.client = e, this.room = t, this.relations = new Map
									}
									getChildEventsForEvent(e, t, r) {
										var n, i;
										return null === (i = null === (n = this.relations.get(e)) || void 0 === n ? void 0 : n.get(t)) || void 0 === i ? void 0 : i.get(r)
									}
									getAllChildEventsForEvent(e) {
										var t;
										const r = null !== (t = this.relations.get(e)) && void 0 !== t ? t : new Map,
											n = [];
										for (const i of r.values())
											for (const e of i.values()) n.push(...e.getRelations());
										return n
									}
									aggregateParentEvent(e) {
										const t = this.relations.get(e.getId());
										if (t)
											for (const r of t.values())
												for (const t of r.values()) t.setTargetEvent(e)
									}
									aggregateChildEvent(e, t) {
										var r, o, s;
										if (e.isRedacted() || e.status === i.EventStatus.CANCELLED) return;
										const a = e.getRelation();
										if (!a) return;
										const c = () => {
											e.isDecryptionFailure() ? e.once(i.MatrixEventEvent.Decrypted, c) : this.aggregateChildEvent(e, t)
										};
										if (e.isBeingDecrypted() || e.shouldAttemptDecryption()) return void e.once(i.MatrixEventEvent.Decrypted, c);
										const {
											event_id: l,
											rel_type: u
										} = a, d = e.getType();
										let h = this.relations.get(l);
										h || (h = new Map, this.relations.set(l, h));
										let f = h.get(u);
										f || (f = new Map, h.set(u, f));
										let p = f.get(d);
										if (!p) {
											p = new n.Relations(u, d, this.client), f.set(d, p);
											const e = null !== (r = this.room) && void 0 !== r ? r : null == t ? void 0 : t.room,
												i = null !== (s = null !== (o = null == t ? void 0 : t.findEventById(l)) && void 0 !== o ? o : null == e ? void 0 : e.findEventById(l)) && void 0 !== s ? s : null == e ? void 0 : e.getPendingEvent(l);
											i && p.setTargetEvent(i)
										}
										p.addEvent(e)
									}
								}
							}, {
								"./event": 365,
								"./relations": 369
							}],
							369: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.Relations = r.RelationsEvent = void 0;
								const i = e("./event"),
									o = e("../logger"),
									s = e("../@types/event"),
									a = e("./typed-event-emitter"),
									c = e("./room");
								var l;
								! function(e) {
									e.Add = "Relations.add", e.Remove = "Relations.remove", e.Redaction = "Relations.redaction"
								}(l = r.RelationsEvent || (r.RelationsEvent = {}));
								class u extends a.TypedEventEmitter {
									constructor(e, t, r) {
										super(), this.relationType = e, this.eventType = t, this.relationEventIds = new Set, this.relations = new Set, this.annotationsByKey = {}, this.annotationsBySender = {}, this.sortedAnnotationsByKey = [], this.targetEvent = null, this.creationEmitted = !1, this.onEventStatus = (e, t) => {
											e.isSending() ? t === i.EventStatus.CANCELLED && (e.removeListener(i.MatrixEventEvent.Status, this.onEventStatus), this.removeEvent(e)) : e.removeListener(i.MatrixEventEvent.Status, this.onEventStatus)
										}, this.onBeforeRedaction = e => n(this, void 0, void 0, (function*() {
											if (this.relations.has(e)) {
												if (this.relations.delete(e), this.relationType === s.RelationType.Annotation) this.removeAnnotationFromAggregation(e);
												else if (this.relationType === s.RelationType.Replace && this.targetEvent && !this.targetEvent.isState()) {
													const e = yield this.getLastReplacement();
													this.targetEvent.makeReplaced(e)
												}
												e.removeListener(i.MatrixEventEvent.BeforeRedaction, this.onBeforeRedaction), this.emit(l.Redaction, e)
											}
										})), this.client = r instanceof c.Room ? r.client : r
									}
									addEvent(e) {
										return n(this, void 0, void 0, (function*() {
											if (this.relationEventIds.has(e.getId())) return;
											const t = e.getRelation();
											if (!t) return void o.logger.error("Event must have relation info");
											const r = t.rel_type,
												n = e.getType();
											if (this.relationType === r && this.eventType === n) {
												if (e.isSending() && e.on(i.MatrixEventEvent.Status, this.onEventStatus), this.relations.add(e), this.relationEventIds.add(e.getId()), this.relationType === s.RelationType.Annotation) this.addAnnotationToAggregation(e);
												else if (this.relationType === s.RelationType.Replace && this.targetEvent && !this.targetEvent.isState()) {
													const e = yield this.getLastReplacement();
													this.targetEvent.makeReplaced(e)
												}
												e.on(i.MatrixEventEvent.BeforeRedaction, this.onBeforeRedaction), this.emit(l.Add, e), this.maybeEmitCreated()
											} else o.logger.error("Event relation info doesn't match this container")
										}))
									}
									removeEvent(e) {
										return n(this, void 0, void 0, (function*() {
											if (!this.relations.has(e)) return;
											const t = e.getRelation();
											if (!t) return void o.logger.error("Event must have relation info");
											const r = t.rel_type,
												n = e.getType();
											if (this.relationType === r && this.eventType === n) {
												if (this.relations.delete(e), this.relationType === s.RelationType.Annotation) this.removeAnnotationFromAggregation(e);
												else if (this.relationType === s.RelationType.Replace && this.targetEvent && !this.targetEvent.isState()) {
													const e = yield this.getLastReplacement();
													this.targetEvent.makeReplaced(e)
												}
												this.emit(l.Remove, e)
											} else o.logger.error("Event relation info doesn't match this container")
										}))
									}
									getRelations() {
										return [...this.relations]
									}
									addAnnotationToAggregation(e) {
										var t;
										const {
											key: r
										} = null !== (t = e.getRelation()) && void 0 !== t ? t : {};
										if (!r) return;
										let n = this.annotationsByKey[r];
										n || (n = this.annotationsByKey[r] = new Set, this.sortedAnnotationsByKey.push([r, n])), n.add(e), this.sortedAnnotationsByKey.sort((e, t) => {
											const r = e[1];
											return t[1].size - r.size
										});
										const i = e.getSender();
										let o = this.annotationsBySender[i];
										o || (o = this.annotationsBySender[i] = new Set), o.add(e)
									}
									removeAnnotationFromAggregation(e) {
										var t;
										const {
											key: r
										} = null !== (t = e.getRelation()) && void 0 !== t ? t : {};
										if (!r) return;
										const n = this.annotationsByKey[r];
										n && (n.delete(e), this.sortedAnnotationsByKey.sort((e, t) => {
											const r = e[1];
											return t[1].size - r.size
										}));
										const i = e.getSender(),
											o = this.annotationsBySender[i];
										o && o.delete(e)
									}
									getSortedAnnotationsByKey() {
										return this.relationType !== s.RelationType.Annotation ? null : this.sortedAnnotationsByKey
									}
									getAnnotationsBySender() {
										return this.relationType !== s.RelationType.Annotation ? null : this.annotationsBySender
									}
									getLastReplacement() {
										return n(this, void 0, void 0, (function*() {
											if (this.relationType !== s.RelationType.Replace) return null;
											if (!this.targetEvent) return null;
											const e = this.targetEvent.getServerAggregatedRelation(s.RelationType.Replace),
												t = null == e ? void 0 : e.origin_server_ts,
												r = this.getRelations().reduce((e, r) => r.getSender() !== this.targetEvent.getSender() ? e : t && t > r.getTs() ? e : e && e.getTs() > r.getTs() ? e : r, null);
											return (null == r ? void 0 : r.shouldAttemptDecryption()) && this.client.isCryptoEnabled() ? yield r.attemptDecryption(this.client.crypto): (null == r ? void 0 : r.isBeingDecrypted()) && (yield r.getDecryptionPromise()), r
										}))
									}
									setTargetEvent(e) {
										return n(this, void 0, void 0, (function*() {
											if (!this.targetEvent) {
												if (this.targetEvent = e, this.relationType === s.RelationType.Replace && !this.targetEvent.isState()) {
													const e = yield this.getLastReplacement();
													e && this.targetEvent.makeReplaced(e)
												}
												this.maybeEmitCreated()
											}
										}))
									}
									maybeEmitCreated() {
										this.creationEmitted || this.targetEvent && this.relations.size && (this.creationEmitted = !0, this.targetEvent.emit(i.MatrixEventEvent.RelationsCreated, this.relationType, this.eventType))
									}
								}
								r.Relations = u
							}, {
								"../@types/event": 290,
								"../logger": 356,
								"./event": 365,
								"./room": 373,
								"./typed-event-emitter": 376
							}],
							370: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
										Object.defineProperty(e, "default", {
											enumerable: !0,
											value: t
										})
									} : function(e, t) {
										e.default = t
									}),
									o = this && this.__importStar || function(e) {
										if (e && e.__esModule) return e;
										var t = {};
										if (null != e)
											for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
										return i(t, e), t
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.RoomMember = r.RoomMemberEvent = void 0;
								const s = e("../content-repo"),
									a = o(e("../utils")),
									c = e("../logger"),
									l = e("./typed-event-emitter"),
									u = e("../@types/event");
								var d;
								! function(e) {
									e.Membership = "RoomMember.membership", e.Name = "RoomMember.name", e.PowerLevel = "RoomMember.powerLevel", e.Typing = "RoomMember.typing"
								}(d = r.RoomMemberEvent || (r.RoomMemberEvent = {}));
								class h extends l.TypedEventEmitter {
									constructor(e, t) {
										super(), this.roomId = e, this.userId = t, this._isOutOfBand = !1, this.modified = -1, this.requestedProfileInfo = !1, this.typing = !1, this.powerLevel = 0, this.powerLevelNorm = 0, this.disambiguate = !1, this.events = {}, this.name = t, this.rawDisplayName = t, this.updateModifiedTime()
									}
									markOutOfBand() {
										this._isOutOfBand = !0
									}
									isOutOfBand() {
										return this._isOutOfBand
									}
									setMembershipEvent(e, t) {
										var r, n;
										const i = null !== (r = e.getDirectionalContent().displayname) && void 0 !== r ? r : "";
										if (e.getType() !== u.EventType.RoomMember) return;
										this._isOutOfBand = !1, this.events.member = e;
										const o = this.membership;
										this.membership = e.getDirectionalContent().membership, void 0 === this.membership && c.logger.trace(`membership event with membership undefined (forwardLooking: ${e.forwardLooking})!`, e.getContent(), "prevcontent is ", e.getPrevContent()), this.disambiguate = function(e, t, r) {
											if (!t || t === e) return !1;
											if (!a.removeHiddenChars(t)) return !1;
											if (!r) return !1;
											if (f.test(t)) return !0;
											if (p.test(t)) return !0;
											return !!r.getUserIdsWithDisplayName(t).some(t => t !== e)
										}(this.userId, i, t);
										const s = this.name;
										this.name = function(e, t, r) {
											return t && t !== e ? r ? a.removeDirectionOverrideChars(t) + " (" + e + ")" : a.removeHiddenChars(t) ? a.removeDirectionOverrideChars(t) : e : e
										}(this.userId, i, this.disambiguate), this.rawDisplayName = a.removeDirectionOverrideChars(null !== (n = e.getDirectionalContent().displayname) && void 0 !== n ? n : ""), this.rawDisplayName && a.removeHiddenChars(this.rawDisplayName) || (this.rawDisplayName = this.userId), o !== this.membership && (this.updateModifiedTime(), this.emit(d.Membership, e, this, o)), s !== this.name && (this.updateModifiedTime(), this.emit(d.Name, e, this, s))
									}
									setPowerLevelEvent(e) {
										if (e.getType() !== u.EventType.RoomPowerLevels || "" !== e.getStateKey()) return;
										const t = e.getDirectionalContent();
										let r = t.users_default || 0;
										const n = t.users || {};
										Object.values(n).forEach(e => {
											r = Math.max(r, e)
										});
										const i = this.powerLevel,
											o = this.powerLevelNorm;
										void 0 !== n[this.userId] && Number.isInteger(n[this.userId]) ? this.powerLevel = n[this.userId] : void 0 !== t.users_default ? this.powerLevel = t.users_default : this.powerLevel = 0, this.powerLevelNorm = 0, r > 0 && (this.powerLevelNorm = 100 * this.powerLevel / r), i === this.powerLevel && o === this.powerLevelNorm || (this.updateModifiedTime(), this.emit(d.PowerLevel, e, this))
									}
									setTypingEvent(e) {
										if ("m.typing" !== e.getType()) return;
										const t = this.typing;
										this.typing = !1;
										const r = e.getContent().user_ids;
										Array.isArray(r) && (-1 !== r.indexOf(this.userId) && (this.typing = !0), t !== this.typing && (this.updateModifiedTime(), this.emit(d.Typing, e, this)))
									}
									updateModifiedTime() {
										this.modified = Date.now()
									}
									getLastModifiedTime() {
										return this.modified
									}
									isKicked() {
										return "leave" === this.membership && void 0 !== this.events.member && this.events.member.getSender() !== this.events.member.getStateKey()
									}
									getDMInviter() {
										if (this.events.member) {
											const e = this.events.member;
											let t = e.getContent(),
												r = e.getSender();
											if ("join" === t.membership && (t = e.getPrevContent(), r = e.getUnsigned().prev_sender), "invite" === t.membership && t.is_direct) return r
										}
									}
									getAvatarUrl(e, t, r, n, i = !0, o) {
										const a = this.getMxcAvatarUrl();
										if (!a && !i) return null;
										const c = (0, s.getHttpUriForMxc)(e, a, t, r, n, o);
										return c || null
									}
									getMxcAvatarUrl() {
										return this.events.member ? this.events.member.getDirectionalContent().avatar_url : this.user ? this.user.avatarUrl : void 0
									}
								}
								r.RoomMember = h;
								const f = /@.+:.+/,
									p = /[\u200E\u200F\u202A-\u202F]/
							}, {
								"../@types/event": 290,
								"../content-repo": 306,
								"../logger": 356,
								"../utils": 393,
								"./typed-event-emitter": 376
							}],
							371: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
										Object.defineProperty(e, "default", {
											enumerable: !0,
											value: t
										})
									} : function(e, t) {
										e.default = t
									}),
									o = this && this.__importStar || function(e) {
										if (e && e.__esModule) return e;
										var t = {};
										if (null != e)
											for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
										return i(t, e), t
									},
									s = this && this.__awaiter || function(e, t, r, n) {
										return new(r || (r = Promise))((function(i, o) {
											function s(e) {
												try {
													c(n.next(e))
												} catch (t) {
													o(t)
												}
											}

											function a(e) {
												try {
													c(n.throw(e))
												} catch (t) {
													o(t)
												}
											}

											function c(e) {
												var t;
												e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
													e(t)
												}))).then(s, a)
											}
											c((n = n.apply(e, t || [])).next())
										}))
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.RoomState = r.RoomStateEvent = void 0;
								const a = e("./room-member"),
									c = e("../logger"),
									l = o(e("../utils")),
									u = e("../@types/event"),
									d = e("./event"),
									h = e("../@types/partials"),
									f = e("./typed-event-emitter"),
									p = e("./beacon"),
									v = e("../ReEmitter"),
									g = e("../@types/beacon");
								var m, y;
								! function(e) {
									e[e.NotStarted = 0] = "NotStarted", e[e.InProgress = 1] = "InProgress", e[e.Finished = 2] = "Finished"
								}(m || (m = {})),
								function(e) {
									e.Events = "RoomState.events", e.Members = "RoomState.members", e.NewMember = "RoomState.newMember", e.Update = "RoomState.update", e.BeaconLiveness = "RoomState.BeaconLiveness", e.Marker = "RoomState.Marker"
								}(y = r.RoomStateEvent || (r.RoomStateEvent = {}));
								class b extends f.TypedEventEmitter {
									constructor(e, t = {
										status: m.NotStarted
									}) {
										super(), this.roomId = e, this.oobMemberFlags = t, this.reEmitter = new v.TypedReEmitter(this), this.sentinels = {}, this.displayNameToUserIds = new Map, this.userIdsToDisplayNames = {}, this.tokenToInvite = {}, this.joinedMemberCount = null, this.summaryJoinedMemberCount = null, this.invitedMemberCount = null, this.summaryInvitedMemberCount = null, this.modified = -1, this.members = {}, this.events = new Map, this.paginationToken = null, this.beacons = new Map, this._liveBeaconIds = [], this.updateModifiedTime()
									}
									getJoinedMemberCount() {
										return null !== this.summaryJoinedMemberCount ? this.summaryJoinedMemberCount : (null === this.joinedMemberCount && (this.joinedMemberCount = this.getMembers().reduce((e, t) => "join" === t.membership ? e + 1 : e, 0)), this.joinedMemberCount)
									}
									setJoinedMemberCount(e) {
										this.summaryJoinedMemberCount = e
									}
									getInvitedMemberCount() {
										return null !== this.summaryInvitedMemberCount ? this.summaryInvitedMemberCount : (null === this.invitedMemberCount && (this.invitedMemberCount = this.getMembers().reduce((e, t) => "invite" === t.membership ? e + 1 : e, 0)), this.invitedMemberCount)
									}
									setInvitedMemberCount(e) {
										this.summaryInvitedMemberCount = e
									}
									getMembers() {
										return Object.values(this.members)
									}
									getMembersExcept(e) {
										return this.getMembers().filter(t => !e.includes(t.userId))
									}
									getMember(e) {
										return this.members[e] || null
									}
									getSentinelMember(e) {
										if (!e) return null;
										let t = this.sentinels[e];
										if (void 0 === t) {
											t = new a.RoomMember(this.roomId, e);
											const r = this.members[e];
											(null == r ? void 0 : r.events.member) && t.setMembershipEvent(r.events.member, this), this.sentinels[e] = t
										}
										return t
									}
									getStateEvents(e, t) {
										if (!this.events.has(e)) return void 0 === t ? [] : null;
										if (void 0 === t) return Array.from(this.events.get(e).values());
										const r = this.events.get(e).get(t);
										return r || null
									}
									get hasLiveBeacons() {
										var e;
										return !!(null === (e = this.liveBeaconIds) || void 0 === e ? void 0 : e.length)
									}
									get liveBeaconIds() {
										return this._liveBeaconIds
									}
									clone() {
										const e = new b(this.roomId, this.oobMemberFlags),
											t = this.oobMemberFlags.status;
										return this.oobMemberFlags.status = m.NotStarted, Array.from(this.events.values()).forEach(t => {
											e.setStateEvents(Array.from(t.values()))
										}), this.oobMemberFlags.status = t, null !== this.summaryInvitedMemberCount && e.setInvitedMemberCount(this.getInvitedMemberCount()), null !== this.summaryJoinedMemberCount && e.setJoinedMemberCount(this.getJoinedMemberCount()), this.oobMemberFlags.status == m.Finished && this.getMembers().forEach(t => {
											var r;
											t.isOutOfBand() && (null === (r = e.getMember(t.userId)) || void 0 === r || r.markOutOfBand())
										}), e
									}
									setUnknownStateEvents(e) {
										const t = e.filter(e => !this.events.has(e.getType()) || !this.events.get(e.getType()).has(e.getStateKey()));
										this.setStateEvents(t)
									}
									setStateEvents(e, t) {
										this.updateModifiedTime(), e.forEach(e => {
											var t;
											if (e.getRoomId() !== this.roomId || !e.isState()) return;
											g.M_BEACON_INFO.matches(e.getType()) && this.setBeacon(e);
											const r = this.getStateEventMatching(e);
											this.setStateEvent(e), e.getType() === u.EventType.RoomMember && (this.updateDisplayNameCache(e.getStateKey(), null !== (t = e.getContent().displayname) && void 0 !== t ? t : ""), this.updateThirdPartyTokenCache(e)), this.emit(y.Events, e, this, r)
										}), this.onBeaconLivenessChange(), e.forEach(e => {
											if (e.getRoomId() === this.roomId && e.isState())
												if (e.getType() === u.EventType.RoomMember) {
													const t = e.getStateKey();
													"leave" !== e.getContent().membership && "ban" !== e.getContent().membership || (e.getContent().avatar_url = e.getContent().avatar_url || e.getPrevContent().avatar_url, e.getContent().displayname = e.getContent().displayname || e.getPrevContent().displayname);
													const r = this.getOrCreateMember(t, e);
													r.setMembershipEvent(e, this), this.updateMember(r), this.emit(y.Members, e, this, r)
												} else if (e.getType() === u.EventType.RoomPowerLevels) {
												if ("" !== e.getStateKey()) return;
												Object.values(this.members).forEach(t => {
													const r = t.getLastModifiedTime();
													t.setPowerLevelEvent(e), r !== t.getLastModifiedTime() && this.emit(y.Members, e, this, t)
												}), this.sentinels = {}
											} else u.UNSTABLE_MSC2716_MARKER.matches(e.getType()) && this.emit(y.Marker, e, t)
										}), this.emit(y.Update, this)
									}
									processBeaconEvents(e, t) {
										if (!e.length || !this.beacons.size) return;
										const r = [...this.beacons.values()].reduce((e, t) => Object.assign(Object.assign({}, e), {
												[t.beaconInfoId]: t
											}), {}),
											n = (e, t) => {
												if (!g.M_BEACON.matches(t.getType())) return;
												const n = r[e];
												n && n.addLocations([t])
											};
										e.forEach(e => {
											var i;
											const o = null === (i = e.getRelation()) || void 0 === i ? void 0 : i.event_id;
											o && r[o] && (t.decryptEventIfNeeded(e), e.isBeingDecrypted() || e.isDecryptionFailure() ? e.once(d.MatrixEventEvent.Decrypted, () => s(this, void 0, void 0, (function*() {
												n(o, e)
											}))) : n(o, e))
										})
									}
									getOrCreateMember(e, t) {
										let r = this.members[e];
										return r || (r = new a.RoomMember(this.roomId, e), this.members[e] = r, this.emit(y.NewMember, t, this, r)), r
									}
									setStateEvent(e) {
										this.events.has(e.getType()) || this.events.set(e.getType(), new Map), this.events.get(e.getType()).set(e.getStateKey(), e)
									}
									setBeacon(e) {
										var t;
										const r = (0, p.getBeaconInfoIdentifier)(e);
										if (this.beacons.has(r)) {
											const n = this.beacons.get(r);
											return e.isRedacted() ? void(n.beaconInfoId === (null === (t = e.getRedactionEvent()) || void 0 === t ? void 0 : t.redacts) && (n.destroy(), this.beacons.delete(r))) : n.update(e)
										}
										if (e.isRedacted()) return;
										const n = new p.Beacon(e);
										this.reEmitter.reEmit(n, [p.BeaconEvent.New, p.BeaconEvent.Update, p.BeaconEvent.Destroy, p.BeaconEvent.LivenessChange]), this.emit(p.BeaconEvent.New, e, n), n.on(p.BeaconEvent.LivenessChange, this.onBeaconLivenessChange.bind(this)), n.on(p.BeaconEvent.Destroy, this.onBeaconLivenessChange.bind(this)), this.beacons.set(n.identifier, n)
									}
									onBeaconLivenessChange() {
										this._liveBeaconIds = Array.from(this.beacons.values()).filter(e => e.isLive).map(e => e.identifier), this.emit(y.BeaconLiveness, this, this.hasLiveBeacons)
									}
									getStateEventMatching(e) {
										var t, r;
										return null !== (r = null === (t = this.events.get(e.getType())) || void 0 === t ? void 0 : t.get(e.getStateKey())) && void 0 !== r ? r : null
									}
									updateMember(e) {
										const t = this.getStateEvents(u.EventType.RoomPowerLevels, "");
										t && e.setPowerLevelEvent(t), delete this.sentinels[e.userId], this.members[e.userId] = e, this.joinedMemberCount = null, this.invitedMemberCount = null
									}
									needsOutOfBandMembers() {
										return this.oobMemberFlags.status === m.NotStarted
									}
									markOutOfBandMembersStarted() {
										this.oobMemberFlags.status === m.NotStarted && (this.oobMemberFlags.status = m.InProgress)
									}
									markOutOfBandMembersFailed() {
										this.oobMemberFlags.status === m.InProgress && (this.oobMemberFlags.status = m.NotStarted)
									}
									clearOutOfBandMembers() {
										let e = 0;
										Object.keys(this.members).forEach(t => {
											this.members[t].isOutOfBand() && (++e, delete this.members[t])
										}), c.logger.log(`LL: RoomState removed ${e} members...`), this.oobMemberFlags.status = m.NotStarted
									}
									setOutOfBandMembers(e) {
										c.logger.log(`LL: RoomState about to set ${e.length} OOB members ...`), this.oobMemberFlags.status === m.InProgress && (c.logger.log("LL: RoomState put in finished state ..."), this.oobMemberFlags.status = m.Finished, e.forEach(e => this.setOutOfBandMember(e)), this.emit(y.Update, this))
									}
									setOutOfBandMember(e) {
										if (e.getType() !== u.EventType.RoomMember) return;
										const t = e.getStateKey(),
											r = this.getMember(t);
										if (r && !r.isOutOfBand()) return;
										const n = this.getOrCreateMember(t, e);
										n.setMembershipEvent(e, this), n.markOutOfBand(), this.updateDisplayNameCache(n.userId, n.name), this.setStateEvent(e), this.updateMember(n), this.emit(y.Members, e, this, n)
									}
									setTypingEvent(e) {
										Object.values(this.members).forEach((function(t) {
											t.setTypingEvent(e)
										}))
									}
									getInviteForThreePidToken(e) {
										return this.tokenToInvite[e] || null
									}
									updateModifiedTime() {
										this.modified = Date.now()
									}
									getLastModifiedTime() {
										return this.modified
									}
									getUserIdsWithDisplayName(e) {
										var t;
										return null !== (t = this.displayNameToUserIds.get(l.removeHiddenChars(e))) && void 0 !== t ? t : []
									}
									maySendRedactionForEvent(e, t) {
										const r = this.getMember(t);
										if (!r || "leave" === r.membership) return !1;
										if (e.status || e.isRedacted()) return !1;
										const n = this.maySendEvent(u.EventType.RoomRedaction, t);
										return e.getSender() === t ? n : this.hasSufficientPowerLevelFor("redact", r.powerLevel)
									}
									hasSufficientPowerLevelFor(e, t) {
										const r = this.getStateEvents(u.EventType.RoomPowerLevels, "");
										let n = {};
										r && (n = r.getContent());
										let i = 50;
										return l.isNumber(n[e]) && (i = n[e]), t >= i
									}
									maySendMessage(e) {
										return this.maySendEventOfType(u.EventType.RoomMessage, e, !1)
									}
									maySendEvent(e, t) {
										return this.maySendEventOfType(e, t, !1)
									}
									mayClientSendStateEvent(e, t) {
										return !(t.isGuest() || !t.credentials.userId) && this.maySendStateEvent(e, t.credentials.userId)
									}
									maySendStateEvent(e, t) {
										return this.maySendEventOfType(e, t, !0)
									}
									maySendEventOfType(e, t, r) {
										const n = this.getStateEvents(u.EventType.RoomPowerLevels, "");
										let i, o = {},
											s = 0,
											a = 0,
											c = 0;
										if (n) {
											o = (i = n.getContent()).events || {}, s = Number.isSafeInteger(i.state_default) ? i.state_default : 50;
											const e = i.users && i.users[t];
											Number.isSafeInteger(e) ? c = e : Number.isSafeInteger(i.users_default) && (c = i.users_default), Number.isSafeInteger(i.events_default) && (a = i.events_default)
										}
										let l = r ? s : a;
										return Number.isSafeInteger(o[e]) && (l = o[e]), c >= l
									}
									mayTriggerNotifOfType(e, t) {
										const r = this.getMember(t);
										if (!r) return !1;
										const n = this.getStateEvents(u.EventType.RoomPowerLevels, "");
										let i = 50;
										return n && n.getContent() && n.getContent().notifications && l.isNumber(n.getContent().notifications[e]) && (i = n.getContent().notifications[e]), r.powerLevel >= i
									}
									getJoinRule() {
										var e;
										const t = this.getStateEvents(u.EventType.RoomJoinRules, "");
										return (null !== (e = null == t ? void 0 : t.getContent()) && void 0 !== e ? e : {}).join_rule || h.JoinRule.Invite
									}
									getHistoryVisibility() {
										var e;
										const t = this.getStateEvents(u.EventType.RoomHistoryVisibility, "");
										return (null !== (e = null == t ? void 0 : t.getContent()) && void 0 !== e ? e : {}).history_visibility || h.HistoryVisibility.Shared
									}
									getGuestAccess() {
										var e;
										const t = this.getStateEvents(u.EventType.RoomGuestAccess, "");
										return (null !== (e = null == t ? void 0 : t.getContent()) && void 0 !== e ? e : {}).guest_access || h.GuestAccess.Forbidden
									}
									updateThirdPartyTokenCache(e) {
										if (!e.getContent().third_party_invite) return;
										const t = (e.getContent().third_party_invite.signed || {}).token;
										t && this.getStateEvents(u.EventType.RoomThirdPartyInvite, t) && (this.tokenToInvite[t] = e)
									}
									updateDisplayNameCache(e, t) {
										var r;
										const n = this.userIdsToDisplayNames[e];
										if (delete this.userIdsToDisplayNames[e], n) {
											const t = l.removeHiddenChars(n),
												r = this.displayNameToUserIds.get(t);
											if (r) {
												const n = r.filter(t => t !== e);
												this.displayNameToUserIds.set(t, n)
											}
										}
										this.userIdsToDisplayNames[e] = t;
										const i = t && l.removeHiddenChars(t);
										if (i) {
											const t = null !== (r = this.displayNameToUserIds.get(i)) && void 0 !== r ? r : [];
											t.push(e), this.displayNameToUserIds.set(i, t)
										}
									}
								}
								r.RoomState = b
							}, {
								"../@types/beacon": 289,
								"../@types/event": 290,
								"../@types/partials": 293,
								"../ReEmitter": 300,
								"../logger": 356,
								"../utils": 393,
								"./beacon": 360,
								"./event": 365,
								"./room-member": 370,
								"./typed-event-emitter": 376
							}],
							372: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.RoomSummary = void 0;
								r.RoomSummary = class {
									constructor(e, t) {
										this.roomId = e
									}
								}
							}, {}],
							373: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
										Object.defineProperty(e, "default", {
											enumerable: !0,
											value: t
										})
									} : function(e, t) {
										e.default = t
									}),
									o = this && this.__importStar || function(e) {
										if (e && e.__esModule) return e;
										var t = {};
										if (null != e)
											for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
										return i(t, e), t
									},
									s = this && this.__awaiter || function(e, t, r, n) {
										return new(r || (r = Promise))((function(i, o) {
											function s(e) {
												try {
													c(n.next(e))
												} catch (t) {
													o(t)
												}
											}

											function a(e) {
												try {
													c(n.throw(e))
												} catch (t) {
													o(t)
												}
											}

											function c(e) {
												var t;
												e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
													e(t)
												}))).then(s, a)
											}
											c((n = n.apply(e, t || [])).next())
										}))
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.RoomNameType = r.Room = r.RoomEvent = r.NotificationCountType = r.KNOWN_SAFE_ROOM_VERSION = void 0;
								const a = e("./event-timeline-set"),
									c = e("./event-timeline"),
									l = e("../content-repo"),
									u = o(e("../utils")),
									d = e("../utils"),
									h = e("./event"),
									f = e("./event-status"),
									p = e("./room-member"),
									v = e("./room-summary"),
									g = e("../logger"),
									m = e("../ReEmitter"),
									y = e("../@types/event"),
									b = e("../client"),
									_ = e("../filter"),
									w = e("./room-state"),
									S = e("./beacon"),
									E = e("./thread"),
									k = e("../@types/read_receipts"),
									T = e("./relations-container"),
									I = e("./read-receipt"),
									R = e("../feature");
								r.KNOWN_SAFE_ROOM_VERSION = "9";
								const C = ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
									M = 30;
								var x, O;
								! function(e) {
									e.Highlight = "highlight", e.Total = "total"
								}(x = r.NotificationCountType || (r.NotificationCountType = {})),
								function(e) {
									e.MyMembership = "Room.myMembership", e.Tags = "Room.tags", e.AccountData = "Room.accountData", e.Receipt = "Room.receipt", e.Name = "Room.name", e.Redaction = "Room.redaction", e.RedactionCancelled = "Room.redactionCancelled", e.LocalEchoUpdated = "Room.localEchoUpdated", e.Timeline = "Room.timeline", e.TimelineReset = "Room.timelineReset", e.TimelineRefresh = "Room.TimelineRefresh", e.OldStateUpdated = "Room.OldStateUpdated", e.CurrentStateUpdated = "Room.CurrentStateUpdated", e.HistoryImportedWithinTimeline = "Room.historyImportedWithinTimeline", e.UnreadNotifications = "Room.UnreadNotifications"
								}(O = r.RoomEvent || (r.RoomEvent = {}));
								class A extends I.ReadReceipt {
									constructor(e, t, r, n = {}) {
										super(), this.roomId = e, this.client = t, this.myUserId = r, this.opts = n, this.txnToEvent = {}, this.notificationCounts = {}, this.threadNotifications = new Map, this.threadsTimelineSets = [], this.filteredTimelineSets = {}, this.timelineNeedsRefresh = !1, this.summaryHeroes = null, this.getTypeWarning = !1, this.getVersionWarning = !1, this.tags = {}, this.accountData = {}, this.summary = null, this.relations = new T.RelationsContainer(this.client, this), this.threads = new Map, this.visibilityEvents = new Map, this.threadTimelineSetsPromise = null, this.threadsReady = !1, this.updateThreadRootEvents = (e, t) => {
											var r, n;
											e.length && (this.updateThreadRootEvent(null === (r = this.threadsTimelineSets) || void 0 === r ? void 0 : r[0], e, t), e.hasCurrentUserParticipated && this.updateThreadRootEvent(null === (n = this.threadsTimelineSets) || void 0 === n ? void 0 : n[1], e, t))
										}, this.updateThreadRootEvent = (e, t, r) => {
											e && t.rootEvent && (E.Thread.hasServerSideSupport ? e.addLiveEvent(t.rootEvent, {
												duplicateStrategy: a.DuplicateStrategy.Replace,
												fromCache: !1,
												roomState: this.currentState
											}) : e.addEventToTimeline(t.rootEvent, e.getLiveTimeline(), {
												toStartOfTimeline: r
											}))
										}, this.applyRedaction = e => {
											if (e.isRedaction()) {
												const t = e.event.redacts,
													r = t ? this.findEventById(t) : void 0;
												if (r) {
													if (r.makeRedacted(e), r.isState()) {
														this.currentState.getStateEvents(r.getType(), r.getStateKey()).getId() === r.getId() && this.currentState.setStateEvents([r])
													}
													this.emit(O.Redaction, e, this), this.visibilityEvents.delete(t), r.isVisibilityEvent() && this.redactVisibilityChangeEvent(e)
												}
											}
										}, this.setMaxListeners(100), this.reEmitter = new m.TypedReEmitter(this), n.pendingEventOrdering = n.pendingEventOrdering || b.PendingEventOrdering.Chronological, this.name = e, this.normalizedName = e, this.timelineSets = [new a.EventTimelineSet(this, n)], this.reEmitter.reEmit(this.getUnfilteredTimelineSet(), [O.Timeline, O.TimelineReset]), this.fixUpLegacyTimelineFields(), this.opts.pendingEventOrdering === b.PendingEventOrdering.Detached && (this.pendingEventList = [], this.client.store.getPendingEvents(this.roomId).then(e => {
											const t = this.client.getEventMapper({
												toDevice: !1,
												decrypt: !1
											});
											e.forEach(e => s(this, void 0, void 0, (function*() {
												const r = t(e);
												r.getType() === y.EventType.RoomMessageEncrypted && this.client.isCryptoEnabled() && (yield r.attemptDecryption(this.client.crypto)), r.setStatus(f.EventStatus.NOT_SENT), this.addPendingEvent(r, r.getTxnId())
											})))
										})), this.opts.lazyLoadMembers ? this.membersPromise = void 0 : this.membersPromise = Promise.resolve(!1)
									}
									createThreadsTimelineSets() {
										var e;
										return s(this, void 0, void 0, (function*() {
											if (this.threadTimelineSetsPromise) return this.threadTimelineSetsPromise;
											if (null === (e = this.client) || void 0 === e ? void 0 : e.supportsExperimentalThreads()) try {
												this.threadTimelineSetsPromise = Promise.all([this.createThreadTimelineSet(), this.createThreadTimelineSet(E.ThreadFilterType.My)]);
												const e = yield this.threadTimelineSetsPromise;
												return this.threadsTimelineSets.push(...e), e
											} catch (t) {
												return this.threadTimelineSetsPromise = null, null
											}
											return null
										}))
									}
									decryptCriticalEvents() {
										return s(this, void 0, void 0, (function*() {
											if (!this.client.isCryptoEnabled()) return;
											const e = this.getEventReadUpTo(this.client.getUserId(), !0),
												t = this.getLiveTimeline().getEvents(),
												r = t.findIndex(t => t.event.event_id === e),
												n = t.slice(r).filter(e => e.shouldAttemptDecryption()).reverse().map(e => e.attemptDecryption(this.client.crypto, {
													isRetry: !0
												}));
											yield Promise.allSettled(n)
										}))
									}
									decryptAllEvents() {
										return s(this, void 0, void 0, (function*() {
											if (!this.client.isCryptoEnabled()) return;
											const e = this.getUnfilteredTimelineSet().getLiveTimeline().getEvents().filter(e => e.shouldAttemptDecryption()).reverse().map(e => e.attemptDecryption(this.client.crypto, {
												isRetry: !0
											}));
											yield Promise.allSettled(e)
										}))
									}
									getCreator() {
										var e;
										const t = this.currentState.getStateEvents(y.EventType.RoomCreate, "");
										return null !== (e = null == t ? void 0 : t.getContent().creator) && void 0 !== e ? e : null
									}
									getVersion() {
										var e;
										const t = this.currentState.getStateEvents(y.EventType.RoomCreate, "");
										return t ? null !== (e = t.getContent().room_version) && void 0 !== e ? e : "1" : (this.getVersionWarning || (g.logger.warn("[getVersion] Room " + this.roomId + " does not have an m.room.create event"), this.getVersionWarning = !0), "1")
									}
									shouldUpgradeToVersion() {
										return C.includes(this.getVersion()) ? null : r.KNOWN_SAFE_ROOM_VERSION
									}
									getRecommendedVersion() {
										return s(this, void 0, void 0, (function*() {
											let e = (yield this.client.getCapabilities())["m.room_versions"];
											if (!e) {
												e = {
													default: r.KNOWN_SAFE_ROOM_VERSION,
													available: {}
												};
												for (const t of C) e.available[t] = b.RoomVersionStability.Stable
											}
											let t = this.checkVersionAgainstCapability(e);
											if (t.urgent && t.needsUpgrade) {
												if (g.logger.warn("Refreshing room version capability because the server looks to be supporting a newer room version we don't know about."), !(e = (yield this.client.getCapabilities(!0))["m.room_versions"])) return g.logger.warn("No room version capability - assuming upgrade required."), t;
												t = this.checkVersionAgainstCapability(e)
											}
											return t
										}))
									}
									checkVersionAgainstCapability(e) {
										const t = this.getVersion();
										g.logger.log(`[${this.roomId}] Current version: ${t}`), g.logger.log(`[${this.roomId}] Version capability: `, e);
										const r = {
											version: t,
											needsUpgrade: !1,
											urgent: !1
										};
										return t === e.default ? r : Object.keys(e.available).filter(t => "stable" === e.available[t]).includes(t) ? r : (r.version = e.default, r.needsUpgrade = !0, r.urgent = !!this.getVersion().match(/^[0-9]+[0-9.]*$/g), r.urgent ? g.logger.warn(`URGENT upgrade required on ${this.roomId}`) : g.logger.warn(`Non-urgent upgrade required on ${this.roomId}`), r)
									}
									userMayUpgradeRoom(e) {
										return this.currentState.maySendStateEvent(y.EventType.RoomTombstone, e)
									}
									getPendingEvents() {
										if (!this.pendingEventList) throw new Error("Cannot call getPendingEvents with pendingEventOrdering == " + this.opts.pendingEventOrdering);
										return this.pendingEventList
									}
									removePendingEvent(e) {
										if (!this.pendingEventList) throw new Error("Cannot call removePendingEvent with pendingEventOrdering == " + this.opts.pendingEventOrdering);
										const t = u.removeElement(this.pendingEventList, (function(t) {
											return t.getId() == e
										}), !1);
										return this.savePendingEvents(), t
									}
									hasPendingEvent(e) {
										var t, r;
										return null !== (r = null === (t = this.pendingEventList) || void 0 === t ? void 0 : t.some(t => t.getId() === e)) && void 0 !== r && r
									}
									getPendingEvent(e) {
										var t, r;
										return null !== (r = null === (t = this.pendingEventList) || void 0 === t ? void 0 : t.find(t => t.getId() === e)) && void 0 !== r ? r : null
									}
									getLiveTimeline() {
										return this.getUnfilteredTimelineSet().getLiveTimeline()
									}
									getLastActiveTimestamp() {
										const e = this.getLiveTimeline().getEvents();
										if (e.length) {
											return e[e.length - 1].getTs()
										}
										return Number.MIN_SAFE_INTEGER
									}
									getMyMembership() {
										var e;
										return null !== (e = this.selfMembership) && void 0 !== e ? e : "leave"
									}
									getDMInviter() {
										var e;
										const t = this.getMember(this.myUserId);
										if (t) return t.getDMInviter();
										if ("invite" === this.selfMembership) {
											if (2 === this.getInvitedAndJoinedMemberCount()) return null === (e = this.summaryHeroes) || void 0 === e ? void 0 : e[0]
										}
									}
									guessDMUserId() {
										const e = this.getMember(this.myUserId);
										if (e) {
											const t = e.getDMInviter();
											if (t) return t
										}
										if (Array.isArray(this.summaryHeroes) && this.summaryHeroes.length) return this.summaryHeroes[0];
										const t = this.currentState.getMembers().find(e => e.userId !== this.myUserId);
										return t ? t.userId : this.myUserId
									}
									getAvatarFallbackMember() {
										if (this.getInvitedAndJoinedMemberCount() > 2) return;
										const e = Array.isArray(this.summaryHeroes) && this.summaryHeroes.length;
										if (e) {
											const e = this.summaryHeroes.map(e => this.getMember(e)).find(e => !!e);
											if (e) return e
										}
										const t = this.currentState.getMembers();
										if (t.length <= 2) {
											const e = t.find(e => e.userId !== this.myUserId);
											if (e) return e
										}
										if (e) {
											const e = this.summaryHeroes.map(e => this.client.getUser(e)).find(e => !!e);
											if (e) {
												const t = new p.RoomMember(this.roomId, e.userId);
												return t.user = e, t
											}
										}
									}
									updateMyMembership(e) {
										const t = this.selfMembership;
										this.selfMembership = e, t !== e && ("leave" === e && this.cleanupAfterLeaving(), this.emit(O.MyMembership, this, e, t))
									}
									loadMembersFromServer() {
										return s(this, void 0, void 0, (function*() {
											const e = this.client.store.getSyncToken();
											return (yield this.client.members(this.roomId, void 0, "leave", null != e ? e : void 0)).chunk
										}))
									}
									loadMembers() {
										return s(this, void 0, void 0, (function*() {
											let e = !1,
												t = yield this.client.store.getOutOfBandMembers(this.roomId);
											return (null === t || this.client.isCryptoEnabled() && this.client.isRoomEncrypted(this.roomId)) && (e = !0, t = yield this.loadMembersFromServer(), g.logger.log(`LL: got ${t.length} ` + `members from server for room ${this.roomId}`)), {
												memberEvents: t.map(this.client.getEventMapper()),
												fromServer: e
											}
										}))
									}
									loadMembersIfNeeded() {
										if (this.membersPromise) return this.membersPromise;
										this.currentState.markOutOfBandMembersStarted();
										const e = this.loadMembers().then(e => (this.currentState.setOutOfBandMembers(e.memberEvents), this.client.isCryptoEnabled() && this.client.isRoomEncrypted(this.roomId) && this.client.crypto.trackRoomDevices(this.roomId), e.fromServer)).catch(e => {
											throw this.membersPromise = void 0, this.currentState.markOutOfBandMembersFailed(), e
										});
										return e.then(e => {
											if (e) {
												const e = this.currentState.getMembers().filter(e => e.isOutOfBand()).map(e => {
													var t;
													return null === (t = e.events.member) || void 0 === t ? void 0 : t.event
												});
												return g.logger.log(`LL: telling store to write ${e.length}` + ` members for room ${this.roomId}`), this.client.store.setOutOfBandMembers(this.roomId, e).catch(e => {
													g.logger.log("LL: storing OOB room members failed, oh well", e)
												})
											}
										}).catch(e => {
											g.logger.error(e)
										}), this.membersPromise = e, this.membersPromise
									}
									clearLoadedMembersIfNeeded() {
										return s(this, void 0, void 0, (function*() {
											this.opts.lazyLoadMembers && this.membersPromise && (yield this.loadMembersIfNeeded(), yield this.client.store.clearOutOfBandMembers(this.roomId), this.currentState.clearOutOfBandMembers(), this.membersPromise = void 0)
										}))
									}
									cleanupAfterLeaving() {
										this.clearLoadedMembersIfNeeded().catch(e => {
											g.logger.error("error after clearing loaded members from " + `room ${this.roomId} after leaving`), g.logger.log(e)
										})
									}
									refreshLiveTimeline() {
										return s(this, void 0, void 0, (function*() {
											const e = this.getLiveTimeline(),
												t = e.getPaginationToken(c.EventTimeline.FORWARDS),
												r = e.getPaginationToken(c.EventTimeline.BACKWARDS),
												n = e.getEvents(),
												i = n[n.length - 1];
											g.logger.log(`[refreshLiveTimeline for ${this.roomId}] at ` + `mostRecentEventInTimeline=${i&&i.getId()} ` + `liveTimelineBefore=${e.toString()} ` + `forwardPaginationToken=${t} ` + `backwardPaginationToken=${r}`);
											const o = this.getUnfilteredTimelineSet();
											let s;
											i ? (this.resetLiveTimeline(null, null), this.emit(O.TimelineRefresh, this, o), s = yield this.client.getEventTimeline(o, i.getId())) : s = yield this.client.getLatestTimeline(o);
											const a = o.getLiveTimeline();
											!a || null === a.getPaginationToken(c.Direction.Forward) && null === a.getPaginationToken(c.Direction.Backward) && 0 === a.getEvents().length ? (g.logger.log(`[refreshLiveTimeline for ${this.roomId}] using our new live timeline`), s.setPaginationToken(t, c.EventTimeline.FORWARDS), o.setLiveTimeline(s), this.fixUpLegacyTimelineFields()) : g.logger.log(`[refreshLiveTimeline for ${this.roomId}] \`/sync\` or some other request beat us to creating a new ` + "live timeline after we reset it. We'll use that instead since any events in the scrollback from this timeline will include the history."), this.setTimelineNeedsRefresh(!1), this.emit(O.TimelineRefresh, this, o)
										}))
									}
									resetLiveTimeline(e, t) {
										for (const r of this.timelineSets) r.resetLiveTimeline(null != e ? e : void 0, null != t ? t : void 0);
										this.fixUpLegacyTimelineFields()
									}
									fixUpLegacyTimelineFields() {
										const e = this.oldState,
											t = this.currentState;
										this.timeline = this.getLiveTimeline().getEvents(), this.oldState = this.getLiveTimeline().getState(c.EventTimeline.BACKWARDS), this.currentState = this.getLiveTimeline().getState(c.EventTimeline.FORWARDS), e !== this.oldState && this.emit(O.OldStateUpdated, this, e, this.oldState), t !== this.currentState && (this.emit(O.CurrentStateUpdated, this, t, this.currentState), this.reEmitter.stopReEmitting(t, [w.RoomStateEvent.Events, w.RoomStateEvent.Members, w.RoomStateEvent.NewMember, w.RoomStateEvent.Update, w.RoomStateEvent.Marker, S.BeaconEvent.New, S.BeaconEvent.Update, S.BeaconEvent.Destroy, S.BeaconEvent.LivenessChange]), this.reEmitter.reEmit(this.currentState, [w.RoomStateEvent.Events, w.RoomStateEvent.Members, w.RoomStateEvent.NewMember, w.RoomStateEvent.Update, w.RoomStateEvent.Marker, S.BeaconEvent.New, S.BeaconEvent.Update, S.BeaconEvent.Destroy, S.BeaconEvent.LivenessChange]))
									}
									hasUnverifiedDevices() {
										return s(this, void 0, void 0, (function*() {
											if (!this.client.isRoomEncrypted(this.roomId)) return !1;
											const e = yield this.getEncryptionTargetMembers();
											for (const t of e) {
												if (this.client.getStoredDevicesForUser(t.userId).some(e => e.isUnverified())) return !0
											}
											return !1
										}))
									}
									getTimelineSets() {
										return this.timelineSets
									}
									getUnfilteredTimelineSet() {
										return this.timelineSets[0]
									}
									getTimelineForEvent(e) {
										const t = this.findEventById(e),
											r = this.findThreadForEvent(t);
										return r ? r.timelineSet.getLiveTimeline() : this.getUnfilteredTimelineSet().getTimelineForEvent(e)
									}
									addTimeline() {
										return this.getUnfilteredTimelineSet().addTimeline()
									}
									setTimelineNeedsRefresh(e) {
										this.timelineNeedsRefresh = e
									}
									getTimelineNeedsRefresh() {
										return this.timelineNeedsRefresh
									}
									findEventById(e) {
										let t = this.getUnfilteredTimelineSet().findEventById(e);
										if (!t) {
											const r = this.getThreads();
											for (let n = 0; n < r.length; n++) {
												if (t = r[n].findEventById(e)) return t
											}
										}
										return t
									}
									getUnreadNotificationCount(e = x.Total) {
										var t, r;
										let n = null !== (t = this.notificationCounts[e]) && void 0 !== t ? t : 0;
										if (this.client.canSupport.get(R.Feature.ThreadUnreadNotifications) !== R.ServerSupport.Unsupported)
											for (const i of this.threadNotifications.values()) n += null !== (r = i[e]) && void 0 !== r ? r : 0;
										return n
									}
									getThreadUnreadNotificationCount(e, t = x.Total) {
										var r, n;
										return null !== (n = null === (r = this.threadNotifications.get(e)) || void 0 === r ? void 0 : r[t]) && void 0 !== n ? n : 0
									}
									hasThreadUnreadNotification() {
										var e, t;
										for (const r of this.threadNotifications.values())
											if ((null !== (e = r.highlight) && void 0 !== e ? e : 0) > 0 || (null !== (t = r.total) && void 0 !== t ? t : 0) > 0) return !0;
										return !1
									}
									setThreadUnreadNotificationCount(e, t, r) {
										var n, i;
										const o = Object.assign({
											highlight: null === (n = this.threadNotifications.get(e)) || void 0 === n ? void 0 : n.highlight,
											total: null === (i = this.threadNotifications.get(e)) || void 0 === i ? void 0 : i.total
										}, {
											[t]: r
										});
										this.threadNotifications.set(e, o), this.emit(O.UnreadNotifications, o, e)
									}
									get threadsAggregateNotificationType() {
										var e, t;
										let r = null;
										for (const n of this.threadNotifications.values()) {
											if ((null !== (e = n.highlight) && void 0 !== e ? e : 0) > 0) return x.Highlight;
											(null !== (t = n.total) && void 0 !== t ? t : 0) > 0 && !r && (r = x.Total)
										}
										return r
									}
									resetThreadUnreadNotificationCount(e) {
										if (e)
											for (const [t] of this.threadNotifications) e.includes(t) || this.threadNotifications.delete(t);
										else this.threadNotifications.clear();
										this.emit(O.UnreadNotifications)
									}
									setUnreadNotificationCount(e, t) {
										this.notificationCounts[e] = t, this.emit(O.UnreadNotifications, this.notificationCounts)
									}
									setSummary(e) {
										const t = e["m.heroes"],
											r = e["m.joined_member_count"],
											n = e["m.invited_member_count"];
										Number.isInteger(r) && this.currentState.setJoinedMemberCount(r), Number.isInteger(n) && this.currentState.setInvitedMemberCount(n), Array.isArray(t) && (this.summaryHeroes = t.filter(e => e !== this.myUserId))
									}
									setBlacklistUnverifiedDevices(e) {
										this.blacklistUnverifiedDevices = e
									}
									getBlacklistUnverifiedDevices() {
										return void 0 === this.blacklistUnverifiedDevices ? null : this.blacklistUnverifiedDevices
									}
									getAvatarUrl(e, t, r, n, i = !0) {
										const o = this.currentState.getStateEvents(y.EventType.RoomAvatar, "");
										if (!o && !i) return null;
										const s = o ? o.getContent().url : null;
										return s ? (0, l.getHttpUriForMxc)(e, s, t, r, n) : null
									}
									getMxcAvatarUrl() {
										var e, t;
										return (null === (t = null === (e = this.currentState.getStateEvents(y.EventType.RoomAvatar, "")) || void 0 === e ? void 0 : e.getContent()) || void 0 === t ? void 0 : t.url) || null
									}
									getCanonicalAlias() {
										const e = this.currentState.getStateEvents(y.EventType.RoomCanonicalAlias, "");
										return e && e.getContent().alias || null
									}
									getAltAliases() {
										const e = this.currentState.getStateEvents(y.EventType.RoomCanonicalAlias, "");
										return e && e.getContent().alt_aliases || []
									}
									addEventsToTimeline(e, t, r, n) {
										r.getTimelineSet().addEventsToTimeline(e, t, r, n)
									}
									getThread(e) {
										var t;
										return null !== (t = this.threads.get(e)) && void 0 !== t ? t : null
									}
									getThreads() {
										return Array.from(this.threads.values())
									}
									getMember(e) {
										return this.currentState.getMember(e)
									}
									getMembers() {
										return this.currentState.getMembers()
									}
									getJoinedMembers() {
										return this.getMembersWithMembership("join")
									}
									getJoinedMemberCount() {
										return this.currentState.getJoinedMemberCount()
									}
									getInvitedMemberCount() {
										return this.currentState.getInvitedMemberCount()
									}
									getInvitedAndJoinedMemberCount() {
										return this.getInvitedMemberCount() + this.getJoinedMemberCount()
									}
									getMembersWithMembership(e) {
										return this.currentState.getMembers().filter((function(t) {
											return t.membership === e
										}))
									}
									getEncryptionTargetMembers() {
										return s(this, void 0, void 0, (function*() {
											yield this.loadMembersIfNeeded();
											let e = this.getMembersWithMembership("join");
											return this.shouldEncryptForInvitedMembers() && (e = e.concat(this.getMembersWithMembership("invite"))), e
										}))
									}
									shouldEncryptForInvitedMembers() {
										var e;
										const t = this.currentState.getStateEvents(y.EventType.RoomHistoryVisibility, "");
										return "joined" !== (null === (e = null == t ? void 0 : t.getContent()) || void 0 === e ? void 0 : e.history_visibility)
									}
									getDefaultRoomName(e) {
										return this.calculateRoomName(e, !0)
									}
									hasMembershipState(e, t) {
										const r = this.getMember(e);
										return !!r && r.membership === t
									}
									getOrCreateFilteredTimelineSet(e, {
										prepopulateTimeline: t = !0,
										useSyncEvents: r = !0,
										pendingEvents: n = !0
									} = {}) {
										if (this.filteredTimelineSets[e.filterId]) return this.filteredTimelineSets[e.filterId];
										const i = Object.assign({
												filter: e,
												pendingEvents: n
											}, this.opts),
											o = new a.EventTimelineSet(this, i);
										this.reEmitter.reEmit(o, [O.Timeline, O.TimelineReset]), r && (this.filteredTimelineSets[e.filterId] = o, this.timelineSets.push(o));
										const s = this.getLiveTimeline();
										if (t) {
											s.getEvents().forEach((function(e) {
												o.addLiveEvent(e)
											}));
											let e = s;
											for (; e.getNeighbouringTimeline(c.EventTimeline.BACKWARDS);) e = e.getNeighbouringTimeline(c.EventTimeline.BACKWARDS);
											o.getLiveTimeline().setPaginationToken(e.getPaginationToken(c.EventTimeline.BACKWARDS), c.EventTimeline.BACKWARDS)
										} else if (r) {
											const e = s.getPaginationToken(c.Direction.Forward);
											o.getLiveTimeline().setPaginationToken(e, c.Direction.Backward)
										}
										return o
									}
									getThreadListFilter(e = E.ThreadFilterType.All) {
										return s(this, void 0, void 0, (function*() {
											const t = this.client.getUserId(),
												r = new _.Filter(t),
												n = {
													room: {
														timeline: {
															[E.FILTER_RELATED_BY_REL_TYPES.name]: [E.THREAD_RELATION_TYPE.name]
														}
													}
												};
											e === E.ThreadFilterType.My && (n.room.timeline[E.FILTER_RELATED_BY_SENDERS.name] = [t]), r.setDefinition(n);
											const i = yield this.client.getOrCreateFilter(`THREAD_PANEL_${this.roomId}_${e}`, r);
											return r.filterId = i, r
										}))
									}
									createThreadTimelineSet(e) {
										return s(this, void 0, void 0, (function*() {
											let t;
											if (E.Thread.hasServerSideListSupport) t = new a.EventTimelineSet(this, Object.assign(Object.assign({}, this.opts), {
												pendingEvents: !1
											}), void 0, void 0, null != e ? e : E.ThreadFilterType.All), this.reEmitter.reEmit(t, [O.Timeline, O.TimelineReset]);
											else if (E.Thread.hasServerSideSupport) {
												const r = yield this.getThreadListFilter(e);
												t = this.getOrCreateFilteredTimelineSet(r, {
													prepopulateTimeline: !1,
													useSyncEvents: !1,
													pendingEvents: !1
												})
											} else t = new a.EventTimelineSet(this, {
												pendingEvents: !1
											}), Array.from(this.threads).forEach(([, r]) => {
												if (0 === r.length) return;
												const n = r.events.some(e => e.getSender() === this.client.getUserId());
												(e !== E.ThreadFilterType.My || n) && t.getLiveTimeline().addEvent(r.rootEvent, {
													toStartOfTimeline: !1
												})
											});
											return t
										}))
									}
									processThreadRoots(e, t) {
										for (const r of e) c.EventTimeline.setEventMetadata(r, this.currentState, t), this.getThread(r.getId()) || this.createThread(r.getId(), r, [], t)
									}
									fetchRoomThreads() {
										var e, t;
										return s(this, void 0, void 0, (function*() {
											if (!this.threadsReady && this.client.supportsExperimentalThreads()) {
												if (E.Thread.hasServerSideListSupport) yield Promise.all([this.fetchRoomThreadList(E.ThreadFilterType.All), this.fetchRoomThreadList(E.ThreadFilterType.My)]);
												else {
													const r = yield this.getThreadListFilter(), {
														chunk: n
													} = yield this.client.createMessagesRequest(this.roomId, "", Number.MAX_SAFE_INTEGER, c.Direction.Backward, r);
													if (!n.length) return;
													const i = n.map(this.client.getEventMapper()).sort((e, t) => {
														const r = e.getServerAggregatedRelation(E.THREAD_RELATION_TYPE.name),
															n = t.getServerAggregatedRelation(E.THREAD_RELATION_TYPE.name);
														return r.latest_event.origin_server_ts - n.latest_event.origin_server_ts
													});
													let o;
													const s = this.getLiveTimeline().getState(c.EventTimeline.FORWARDS);
													for (const c of i) {
														null === (e = this.threadsTimelineSets[0]) || void 0 === e || e.addLiveEvent(c, {
															duplicateStrategy: a.DuplicateStrategy.Ignore,
															fromCache: !1,
															roomState: s
														});
														const r = c.getServerAggregatedRelation(E.THREAD_RELATION_TYPE.name);
														(null == r ? void 0 : r.current_user_participated) && (null === (t = this.threadsTimelineSets[1]) || void 0 === t || t.addLiveEvent(c, {
															duplicateStrategy: a.DuplicateStrategy.Ignore,
															fromCache: !1,
															roomState: s
														}), o = c)
													}
													this.processThreadRoots(i, !0), this.client.decryptEventIfNeeded(i[i.length - 1]), o && this.client.decryptEventIfNeeded(o)
												}
												this.on(E.ThreadEvent.NewReply, this.onThreadNewReply), this.on(E.ThreadEvent.Delete, this.onThreadDelete), this.threadsReady = !0
											}
										}))
									}
									fetchRoomThreadList(e) {
										return s(this, void 0, void 0, (function*() {
											const t = e === E.ThreadFilterType.My ? this.threadsTimelineSets[1] : this.threadsTimelineSets[0],
												{
													chunk: r,
													end: n
												} = yield this.client.createThreadListMessagesRequest(this.roomId, null, void 0, c.Direction.Backward, t.threadListType, t.getFilter());
											if (t.getLiveTimeline().setPaginationToken(n, c.Direction.Backward), !r.length) return;
											const i = r.map(this.client.getEventMapper());
											this.processThreadRoots(i, !0);
											const o = this.getLiveTimeline().getState(c.EventTimeline.FORWARDS);
											for (const e of i) t.addLiveEvent(e, {
												duplicateStrategy: a.DuplicateStrategy.Replace,
												fromCache: !1,
												roomState: o
											})
										}))
									}
									onThreadNewReply(e) {
										this.updateThreadRootEvents(e, !1)
									}
									onThreadDelete(e) {
										var t;
										this.threads.delete(e.id);
										const r = this.getTimelineForEvent(e.id),
											n = null === (t = null == r ? void 0 : r.getEvents()) || void 0 === t ? void 0 : t.find(t => t.getId() === e.id);
										n ? e.clearEventMetadata(n) : g.logger.debug("onThreadDelete: Could not find root event in room timeline");
										for (const i of this.threadsTimelineSets) i.removeEvent(e.id)
									}
									removeFilteredTimelineSet(e) {
										const t = this.filteredTimelineSets[e.filterId];
										delete this.filteredTimelineSets[e.filterId];
										const r = this.timelineSets.indexOf(t);
										r > -1 && this.timelineSets.splice(r, 1)
									}
									eventShouldLiveIn(e, t, r) {
										var n, i;
										if (!(null === (n = this.client) || void 0 === n ? void 0 : n.supportsExperimentalThreads())) return {
											shouldLiveInRoom: !0,
											shouldLiveInThread: !1
										};
										if (e.isThreadRoot || (null == r ? void 0 : r.has(e.getId()))) return {
											shouldLiveInRoom: !0,
											shouldLiveInThread: !0,
											threadId: e.getId()
										};
										if (e.isRelation(E.THREAD_RELATION_TYPE.name)) return {
											shouldLiveInRoom: !1,
											shouldLiveInThread: !0,
											threadId: e.threadRootId
										};
										const o = e.getAssociatedId(),
											s = null !== (i = this.findEventById(o)) && void 0 !== i ? i : null == t ? void 0 : t.find(e => e.getId() === o);
										return s && (e.isRelation() || e.isRedaction()) ? this.eventShouldLiveIn(s, t, r) : (null == r ? void 0 : r.has(e.relationEventId)) ? {
											shouldLiveInRoom: !0,
											shouldLiveInThread: !0,
											threadId: e.relationEventId
										} : {
											shouldLiveInRoom: !0,
											shouldLiveInThread: !1
										}
									}
									findThreadForEvent(e) {
										if (!e) return null;
										const {
											threadId: t
										} = this.eventShouldLiveIn(e);
										return t ? this.getThread(t) : null
									}
									addThreadedEvents(e, t, r = !1) {
										var n;
										let i = this.getThread(e);
										if (!i) {
											const o = null !== (n = this.findEventById(e)) && void 0 !== n ? n : t.find(t => t.getId() === e);
											i = this.createThread(e, o, t, r)
										}
										i.addEvents(t, r)
									}
									processThreadedEvents(e, t) {
										var r;
										e.forEach(this.applyRedaction);
										const n = {};
										for (const i of e) {
											const {
												threadId: e,
												shouldLiveInThread: t
											} = this.eventShouldLiveIn(i);
											t && !n[e] && (n[e] = []), null === (r = n[e]) || void 0 === r || r.push(i)
										}
										Object.entries(n).map(([e, r]) => this.addThreadedEvents(e, r, t))
									}
									createThread(e, t, r = [], n) {
										var i, o;
										if (t) {
											const e = this.relations.getAllChildEventsForEvent(t.getId());
											(null == e ? void 0 : e.length) && (r = r.concat(e.filter(e => !e.isRelation(y.RelationType.Replace))))
										}
										const s = new E.Thread(e, t, {
											room: this,
											client: this.client
										});
										for (const c of r) s.setEventMetadata(c);
										this.threads.set(s.id, s), this.reEmitter.reEmit(s, [E.ThreadEvent.Delete, E.ThreadEvent.Update, E.ThreadEvent.NewReply, O.Timeline, O.TimelineReset]);
										const a = (null === (i = this.lastThread) || void 0 === i ? void 0 : i.rootEvent) && (null == t ? void 0 : t.localTimestamp) && (null === (o = this.lastThread.rootEvent) || void 0 === o ? void 0 : o.localTimestamp) < (null == t ? void 0 : t.localTimestamp);
										return this.lastThread && !a || (this.lastThread = s), this.threadsReady && this.updateThreadRootEvents(s, n), this.emit(E.ThreadEvent.New, s, n), s
									}
									processLiveEvent(e) {
										if (this.applyRedaction(e), e.isVisibilityEvent() && this.applyNewVisibilityEvent(e), this.applyPendingVisibilityEvents(e), !e.getUnsigned().transaction_id && e.getSender() === this.myUserId)
											for (const t in this.txnToEvent) {
												if (this.txnToEvent[t].getId() === e.getId()) {
													g.logger.debug("processLiveEvent: found sent event without txn ID: ", t, e.getId());
													const r = e.getUnsigned();
													r.transaction_id = t, e.setUnsigned(r);
													break
												}
											}
									}
									addLiveEvent(e, t) {
										const {
											duplicateStrategy: r,
											timelineWasEmpty: n,
											fromCache: i
										} = t;
										for (const o of this.timelineSets) o.addLiveEvent(e, {
											duplicateStrategy: r,
											fromCache: i,
											timelineWasEmpty: n
										});
										e.sender && e.getType() !== y.EventType.RoomRedaction && this.addReceipt((0, I.synthesizeReceipt)(e.sender.userId, e, k.ReceiptType.Read), !0)
									}
									addPendingEvent(e, t) {
										if (e.status !== f.EventStatus.SENDING && e.status !== f.EventStatus.NOT_SENT) throw new Error("addPendingEvent called on an event with status " + e.status);
										if (this.txnToEvent[t]) throw new Error("addPendingEvent called on an event with known txnId " + t);
										if (c.EventTimeline.setEventMetadata(e, this.getLiveTimeline().getState(c.EventTimeline.FORWARDS), !1), this.txnToEvent[t] = e, this.pendingEventList) {
											if (this.pendingEventList.some(e => e.status === f.EventStatus.NOT_SENT) && (g.logger.warn("Setting event as NOT_SENT due to messages in the same state"), e.setStatus(f.EventStatus.NOT_SENT)), this.pendingEventList.push(e), this.savePendingEvents(), e.isRelation() && this.aggregateNonLiveRelation(e), e.isRedaction()) {
												const t = e.event.redacts;
												let r = this.pendingEventList.find(e => e.getId() === t);
												!r && t && (r = this.findEventById(t)), r && (r.markLocallyRedacted(e), this.emit(O.Redaction, e, this))
											}
										} else
											for (const r of this.timelineSets) r.getFilter() ? r.getFilter().filterRoomTimeline([e]).length && r.addEventToTimeline(e, r.getLiveTimeline(), {
												toStartOfTimeline: !1
											}) : r.addEventToTimeline(e, r.getLiveTimeline(), {
												toStartOfTimeline: !1
											});
										this.emit(O.LocalEchoUpdated, e, this)
									}
									savePendingEvents() {
										if (this.pendingEventList) {
											const e = this.pendingEventList.map(e => Object.assign(Object.assign({}, e.event), {
												txn_id: e.getTxnId()
											})).filter(e => {
												const t = e.type === y.EventType.RoomMessageEncrypted,
													r = this.client.isRoomEncrypted(this.roomId);
												return t || !r
											});
											this.client.store.setPendingEvents(this.roomId, e)
										}
									}
									aggregateNonLiveRelation(e) {
										this.relations.aggregateChildEvent(e)
									}
									getEventForTxnId(e) {
										return this.txnToEvent[e]
									}
									handleRemoteEcho(e, t) {
										const r = t.getId(),
											n = e.getId(),
											i = t.status;
										g.logger.debug(`Got remote echo for event ${r} -> ${n} old status ${i}`), delete this.txnToEvent[e.getUnsigned().transaction_id], this.pendingEventList && this.removePendingEvent(r), t.handleRemoteEcho(e.event);
										const {
											shouldLiveInRoom: o,
											threadId: s
										} = this.eventShouldLiveIn(e), a = s ? this.getThread(s) : null;
										if (null == a || a.timelineSet.handleRemoteEcho(t, r, n), o)
											for (const c of this.timelineSets) c.handleRemoteEcho(t, r, n);
										this.emit(O.LocalEchoUpdated, t, this, r, i)
									}
									updatePendingEvent(e, t, r) {
										if (g.logger.log(`setting pendingEvent status to ${t} in ${e.getRoomId()} ` + `event ID ${e.getId()} -> ${r}`), t == f.EventStatus.SENT && !r) throw new Error("updatePendingEvent called with status=SENT, but no new event id");
										if (t == f.EventStatus.SENT) {
											if (this.getTimelineForEvent(r)) {
												const t = this.findEventById(r);
												if (!(null == t ? void 0 : t.getUnsigned().transaction_id) && t) {
													const r = t.getUnsigned();
													r.transaction_id = e.getTxnId(), t.setUnsigned(r), this.removeEvent(t.getId()), this.handleRemoteEcho(t, e)
												}
												return
											}
										}
										const n = e.status,
											i = e.getId();
										if (!n) throw new Error("updatePendingEventStatus called on an event which is not a local echo.");
										const o = P[n];
										if (!(null == o ? void 0 : o.includes(t))) throw new Error(`Invalid EventStatus transition ${n}->${t}`);
										if (e.setStatus(t), t == f.EventStatus.SENT) {
											e.replaceLocalEventId(r);
											const {
												shouldLiveInRoom: t,
												threadId: n
											} = this.eventShouldLiveIn(e), o = n ? this.getThread(n) : void 0;
											if (null == o || o.timelineSet.replaceEventId(i, r), t)
												for (const e of this.timelineSets) e.replaceEventId(i, r)
										} else if (t == f.EventStatus.CANCELLED) {
											if (this.pendingEventList) {
												const e = this.getPendingEvent(i);
												this.removePendingEvent(i), (null == e ? void 0 : e.isRedaction()) && this.revertRedactionLocalEcho(e)
											}
											this.removeEvent(i)
										}
										this.savePendingEvents(), this.emit(O.LocalEchoUpdated, e, this, i, n)
									}
									revertRedactionLocalEcho(e) {
										const t = e.event.redacts;
										if (!t) return;
										const r = this.getUnfilteredTimelineSet().findEventById(t);
										r && (r.unmarkLocallyRedacted(), this.emit(O.RedactionCancelled, e, this), r.isRelation() && this.aggregateNonLiveRelation(r))
									}
									addLiveEvents(e, t, r = !1) {
										var n;
										let i = t,
											o = !1;
										if ("object" == typeof t ? ({
												duplicateStrategy: i,
												fromCache: r = !1,
												timelineWasEmpty: o
											} = t) : void 0 !== t && g.logger.warn("Overload deprecated: `Room.addLiveEvents(events, duplicateStrategy?, fromCache?)` is deprecated in favor of the overload with `Room.addLiveEvents(events, IAddLiveEventOptions)`"), i && -1 === ["replace", "ignore"].indexOf(i)) throw new Error("duplicateStrategy MUST be either 'replace' or 'ignore'");
										for (let u = 0; u < this.timelineSets.length; u++) {
											const e = this.timelineSets[u].getLiveTimeline();
											if (e.getPaginationToken(c.EventTimeline.FORWARDS)) throw new Error("live timeline " + u + " is no longer live - it has a pagination token (" + e.getPaginationToken(c.EventTimeline.FORWARDS) + ")");
											if (e.getNeighbouringTimeline(c.EventTimeline.FORWARDS)) throw new Error(`live timeline ${u} is no longer live - it has a neighbouring timeline`)
										}
										const s = this.findThreadRoots(e),
											a = {},
											l = {
												duplicateStrategy: i,
												fromCache: r,
												timelineWasEmpty: o
											};
										for (const c of e) {
											if (this.processLiveEvent(c), c.getUnsigned().transaction_id) {
												const e = this.txnToEvent[c.getUnsigned().transaction_id];
												if (e) {
													this.handleRemoteEcho(c, e);
													continue
												}
											}
											const {
												shouldLiveInRoom: t,
												shouldLiveInThread: r,
												threadId: i
											} = this.eventShouldLiveIn(c, e, s);
											r && !a[null != i ? i : ""] && (a[null != i ? i : ""] = []), null === (n = a[null != i ? i : ""]) || void 0 === n || n.push(c), t && this.addLiveEvent(c, l)
										}
										Object.entries(a).forEach(([e, t]) => {
											this.addThreadedEvents(e, t, !1)
										})
									}
									partitionThreadedEvents(e) {
										if (this.client.supportsExperimentalThreads()) {
											const t = this.findThreadRoots(e);
											return e.reduce((r, n) => {
												const {
													shouldLiveInRoom: i,
													shouldLiveInThread: o,
													threadId: s
												} = this.eventShouldLiveIn(n, e, t);
												return i && r[0].push(n), o && (n.setThreadId(null != s ? s : ""), r[1].push(n)), r
											}, [
												[],
												[]
											])
										}
										return [e, []]
									}
									findThreadRoots(e) {
										var t;
										const r = new Set;
										for (const n of e) n.isRelation(E.THREAD_RELATION_TYPE.name) && r.add(null !== (t = n.relationEventId) && void 0 !== t ? t : "");
										return r
									}
									addReceipt(e, t = !1) {
										const r = e.getContent();
										Object.keys(r).forEach(e => {
											Object.keys(r[e]).forEach(n => {
												Object.keys(r[e][n]).forEach(i => {
													var o;
													const s = r[e][n][i],
														a = !s.thread_id || s.thread_id === I.MAIN_ROOM_TIMELINE ? this : this.threads.get(null !== (o = s.thread_id) && void 0 !== o ? o : "");
													null == a || a.addReceiptToStructure(e, n, i, s, t)
												})
											})
										}), this.emit(O.Receipt, e, this)
									}
									addEphemeralEvents(e) {
										for (const t of e) t.getType() === y.EventType.Typing ? this.currentState.setTypingEvent(t) : t.getType() === y.EventType.Receipt && this.addReceipt(t)
									}
									removeEvents(e) {
										for (const t of e) this.removeEvent(t)
									}
									removeEvent(e) {
										let t = !1;
										for (const r of this.timelineSets) {
											const n = r.removeEvent(e);
											n && (n.isRedaction() && this.revertRedactionLocalEcho(n), t = !0)
										}
										return t
									}
									recalculate() {
										const e = this.currentState.getStateEvents(y.EventType.RoomMember, this.myUserId);
										if (e) {
											const t = e.getContent().membership;
											if (this.updateMyMembership(t), "invite" === t) {
												(e.getUnsigned().invite_room_state || []).forEach(e => {
													this.currentState.getStateEvents(e.type, e.state_key) || this.currentState.setStateEvents([new h.MatrixEvent({
														type: e.type,
														state_key: e.state_key,
														content: e.content,
														event_id: "$fake" + Date.now(),
														room_id: this.roomId,
														user_id: this.myUserId
													})])
												})
											}
										}
										const t = this.name;
										this.name = this.calculateRoomName(this.myUserId), this.normalizedName = (0, d.normalize)(this.name), this.summary = new v.RoomSummary(this.roomId, {
											title: this.name
										}), t !== this.name && this.emit(O.Name, this)
									}
									addTags(e) {
										this.tags = e.getContent().tags || {}, this.emit(O.Tags, e, this)
									}
									addAccountData(e) {
										for (const t of e) {
											"m.tag" === t.getType() && this.addTags(t);
											const e = this.accountData[t.getType()];
											this.accountData[t.getType()] = t, this.emit(O.AccountData, t, this, e)
										}
									}
									getAccountData(e) {
										return this.accountData[e]
									}
									maySendMessage() {
										return "join" === this.getMyMembership() && (this.client.isRoomEncrypted(this.roomId) ? this.currentState.maySendEvent(y.EventType.RoomMessageEncrypted, this.myUserId) : this.currentState.maySendEvent(y.EventType.RoomMessage, this.myUserId))
									}
									canInvite(e) {
										let t = "join" === this.getMyMembership();
										const r = this.currentState.getStateEvents(y.EventType.RoomPowerLevels, ""),
											n = r && r.getContent(),
											i = this.getMember(e);
										return n && i && n.invite > i.powerLevel && (t = !1), t
									}
									getJoinRule() {
										return this.currentState.getJoinRule()
									}
									getHistoryVisibility() {
										return this.currentState.getHistoryVisibility()
									}
									getGuestAccess() {
										return this.currentState.getGuestAccess()
									}
									getType() {
										const e = this.currentState.getStateEvents(y.EventType.RoomCreate, "");
										if (e) return e.getContent()[y.RoomCreateTypeField];
										this.getTypeWarning || (g.logger.warn("[getType] Room " + this.roomId + " does not have an m.room.create event"), this.getTypeWarning = !0)
									}
									isSpaceRoom() {
										return this.getType() === y.RoomType.Space
									}
									isCallRoom() {
										return this.getType() === y.RoomType.UnstableCall
									}
									isElementVideoRoom() {
										return this.getType() === y.RoomType.ElementVideo
									}
									roomNameGenerator(e) {
										if (this.client.roomNameGenerator) {
											const t = this.client.roomNameGenerator(this.roomId, e);
											if (null !== t) return t
										}
										switch (e.type) {
											case D.Actual:
												return e.name;
											case D.Generated:
												switch (e.subtype) {
													case "Inviting":
														return `Inviting ${j(e.names,e.count)}`;
													default:
														return j(e.names, e.count)
												}
												case D.EmptyRoom:
													return e.oldName ? `Empty room (was ${e.oldName})` : "Empty room"
										}
									}
									calculateRoomName(e, t = !1) {
										if (!t) {
											const e = this.currentState.getStateEvents(y.EventType.RoomName, "");
											if (null == e ? void 0 : e.getContent().name) return this.roomNameGenerator({
												type: D.Actual,
												name: e.getContent().name
											})
										}
										const r = this.getCanonicalAlias();
										if (r) return this.roomNameGenerator({
											type: D.Actual,
											name: r
										});
										let n = this.currentState.getJoinedMemberCount() + this.currentState.getInvitedMemberCount() - 1,
											i = [];
										const o = this.currentState.getStateEvents(y.UNSTABLE_ELEMENT_FUNCTIONAL_USERS.name, "");
										Array.isArray(null == o ? void 0 : o.getContent().service_members) && (i = o.getContent().service_members);
										let s = [];
										if (this.summaryHeroes) this.summaryHeroes.forEach(e => {
											if (i.includes(e)) return void n--;
											const t = this.getMember(e);
											s.push(t ? t.name : e)
										});
										else {
											let t = this.currentState.getMembers().filter(t => t.userId !== e && ("invite" === t.membership || "join" === t.membership));
											(t = t.filter(({
												userId: e
											}) => !i.includes(e) || (n--, !1))).sort((e, t) => u.compare(e.userId, t.userId)), t = t.slice(0, 5), s = t.map(e => e.name)
										}
										if (n) return this.roomNameGenerator({
											type: D.Generated,
											names: s,
											count: n
										});
										if ("join" == this.getMyMembership()) {
											const e = this.currentState.getStateEvents(y.EventType.RoomThirdPartyInvite);
											if (null == e ? void 0 : e.length) {
												const t = e.map(e => e.getContent().display_name);
												return this.roomNameGenerator({
													type: D.Generated,
													subtype: "Inviting",
													names: t,
													count: t.length + 1
												})
											}
										}
										let a, c = s;
										return c.length || (c = this.currentState.getMembers().filter(t => t.userId !== e && "invite" !== t.membership && "join" !== t.membership).map(e => e.name)), c.length && (a = this.roomNameGenerator({
											type: D.Generated,
											names: c,
											count: c.length + 1
										})), this.roomNameGenerator({
											type: D.EmptyRoom,
											oldName: a
										})
									}
									applyNewVisibilityEvent(e) {
										const t = e.asVisibilityChange();
										if (!t) return;
										const r = e.getSender();
										if (!r) return;
										if (!(y.EVENT_VISIBILITY_CHANGE_TYPE.name && this.currentState.maySendStateEvent(y.EVENT_VISIBILITY_CHANGE_TYPE.name, r) || y.EVENT_VISIBILITY_CHANGE_TYPE.altName && this.currentState.maySendStateEvent(y.EVENT_VISIBILITY_CHANGE_TYPE.altName, r))) return;
										const n = this.visibilityEvents.get(t.eventId);
										if (n) {
											let t = n.length - 1;
											const r = Math.max(0, n.length - M);
											for (; t >= r; --t) {
												if (n[t].getTs() < e.getTs()) break
											} - 1 === t ? n.unshift(e) : n.splice(t + 1, 0, e)
										} else this.visibilityEvents.set(t.eventId, [e]);
										const i = this.findEventById(t.eventId);
										i && i.applyVisibilityEvent(t)
									}
									redactVisibilityChangeEvent(e) {
										if (!e.isVisibilityEvent) throw new Error("expected a visibility change event");
										const t = e.getRelation(),
											r = null == t ? void 0 : t.event_id,
											n = this.visibilityEvents.get(r);
										if (!n) return;
										const i = n.findIndex(t => t.getId() === e.getId());
										if (-1 !== i && (n.splice(i, 1), i === n.length)) {
											const e = this.findEventById(r);
											if (!e) return;
											if (0 === i) this.visibilityEvents.delete(r), e.applyVisibilityEvent();
											else {
												const t = n[n.length - 1].asVisibilityChange();
												if (!t) throw new Error("at this stage, visibility changes should be well-formed");
												e.applyVisibilityEvent(t)
											}
										}
									}
									applyPendingVisibilityEvents(e) {
										const t = this.visibilityEvents.get(e.getId());
										if (!t || 0 == t.length) return;
										const r = t[t.length - 1],
											n = r.asVisibilityChange();
										n && (n.visible, r.getTs() < e.getTs() || e.applyVisibilityEvent(n))
									}
								}
								r.Room = A;
								const P = {
									[f.EventStatus.ENCRYPTING]: [f.EventStatus.SENDING, f.EventStatus.NOT_SENT, f.EventStatus.CANCELLED],
									[f.EventStatus.SENDING]: [f.EventStatus.ENCRYPTING, f.EventStatus.QUEUED, f.EventStatus.NOT_SENT, f.EventStatus.SENT],
									[f.EventStatus.QUEUED]: [f.EventStatus.SENDING, f.EventStatus.CANCELLED],
									[f.EventStatus.SENT]: [],
									[f.EventStatus.NOT_SENT]: [f.EventStatus.SENDING, f.EventStatus.QUEUED, f.EventStatus.CANCELLED],
									[f.EventStatus.CANCELLED]: []
								};
								var D;

								function j(e, t) {
									const r = t - 1;
									if (e.length) {
										if (1 === e.length && r <= 1) return e[0];
										if (2 === e.length && r <= 2) return `${e[0]} and ${e[1]}`;
										return r > 1 ? `${e[0]} and ${r} others` : `${e[0]} and 1 other`
									}
									return "Empty room"
								}! function(e) {
									e[e.EmptyRoom = 0] = "EmptyRoom", e[e.Generated = 1] = "Generated", e[e.Actual = 2] = "Actual"
								}(D = r.RoomNameType || (r.RoomNameType = {}))
							}, {
								"../@types/event": 290,
								"../@types/read_receipts": 294,
								"../ReEmitter": 300,
								"../client": 304,
								"../content-repo": 306,
								"../feature": 344,
								"../filter": 346,
								"../logger": 356,
								"../utils": 393,
								"./beacon": 360,
								"./event": 365,
								"./event-status": 362,
								"./event-timeline": 364,
								"./event-timeline-set": 363,
								"./read-receipt": 367,
								"./relations-container": 368,
								"./room-member": 370,
								"./room-state": 371,
								"./room-summary": 372,
								"./thread": 375
							}],
							374: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.SearchResult = void 0;
								const n = e("./event-context");
								class i {
									constructor(e, t) {
										this.rank = e, this.context = t
									}
									static fromJson(e, t) {
										const r = e.context || {};
										let o = (r.events_before || []).map(t),
											s = (r.events_after || []).map(t);
										const a = new n.EventContext(t(e.result)),
											c = a.ourEvent.threadRootId;
										return o = o.filter(e => e.threadRootId === c), s = s.filter(e => e.threadRootId === c), a.setPaginateToken(r.start, !0), a.addEvents(o, !0), a.addEvents(s, !1), a.setPaginateToken(r.end, !1), new i(e.rank, a)
									}
								}
								r.SearchResult = i
							}, {
								"./event-context": 361
							}],
							375: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.threadFilterTypeToFilter = r.ThreadFilterType = r.THREAD_RELATION_TYPE = r.FILTER_RELATED_BY_REL_TYPES = r.FILTER_RELATED_BY_SENDERS = r.Thread = r.determineFeatureSupport = r.FeatureSupport = r.ThreadEvent = void 0;
								const i = e("../ReEmitter"),
									o = e("../@types/event"),
									s = e("./event"),
									a = e("./event-timeline"),
									c = e("./event-timeline-set"),
									l = e("./room"),
									u = e("../NamespacedValue"),
									d = e("../logger"),
									h = e("./read-receipt"),
									f = e("../@types/read_receipts");
								var p, v, g;
								! function(e) {
									e.New = "Thread.new", e.Update = "Thread.update", e.NewReply = "Thread.newReply", e.ViewThread = "Thread.viewThread", e.Delete = "Thread.delete"
								}(p = r.ThreadEvent || (r.ThreadEvent = {})),
								function(e) {
									e[e.None = 0] = "None", e[e.Experimental = 1] = "Experimental", e[e.Stable = 2] = "Stable"
								}(v = r.FeatureSupport || (r.FeatureSupport = {})), r.determineFeatureSupport = function(e, t) {
									return e ? v.Stable : t ? v.Experimental : v.None
								};
								class m extends h.ReadReceipt {
									constructor(e, t, o) {
										if (super(), this.id = e, this.rootEvent = t, this._currentUserParticipated = !1, this.replyCount = 0, this.initialEventsFetched = !m.hasServerSideSupport, this.onBeforeRedaction = (e, t) => {
												(null == e ? void 0 : e.isRelation(r.THREAD_RELATION_TYPE.name)) && this.room.eventShouldLiveIn(e).threadId === this.id && e.getId() !== this.id && !t.status && (this.replyCount--, this.emit(p.Update, this))
											}, this.onRedaction = e => n(this, void 0, void 0, (function*() {
												if (e.threadRootId === this.id)
													if (this.replyCount <= 0) {
														for (const e of this.events) this.clearEventMetadata(e);
														this.lastEvent = this.rootEvent, this._currentUserParticipated = !1, this.emit(p.Delete, this)
													} else yield this.initialiseThread()
											})), this.onEcho = e => n(this, void 0, void 0, (function*() {
												e.threadRootId === this.id && this.lastEvent !== e && e.isRelation(r.THREAD_RELATION_TYPE.name) && (yield this.initialiseThread(), this.emit(p.NewReply, this, e))
											})), !(null == o ? void 0 : o.room)) throw new Error("element-web#22141: A thread requires a room in order to function");
										this.room = o.room, this.client = o.client, this.timelineSet = new c.EventTimelineSet(this.room, {
											timelineSupport: !0,
											pendingEvents: !0
										}, this.client, this), this.reEmitter = new i.TypedReEmitter(this), this.reEmitter.reEmit(this.timelineSet, [l.RoomEvent.Timeline, l.RoomEvent.TimelineReset]), this.room.on(s.MatrixEventEvent.BeforeRedaction, this.onBeforeRedaction), this.room.on(l.RoomEvent.Redaction, this.onRedaction), this.room.on(l.RoomEvent.LocalEchoUpdated, this.onEcho), this.timelineSet.on(l.RoomEvent.Timeline, this.onEcho), this.initialiseThread(), this.setEventMetadata(this.rootEvent)
									}
									fetchRootEvent() {
										return n(this, void 0, void 0, (function*() {
											this.rootEvent = this.room.findEventById(this.id);
											try {
												const e = yield this.client.fetchRoomEvent(this.roomId, this.id), t = this.client.getEventMapper();
												this.rootEvent = t(e)
											} catch (e) {
												d.logger.error("Failed to fetch thread root to construct thread with", e)
											}
											yield this.processEvent(this.rootEvent)
										}))
									}
									static setServerSideSupport(e) {
										m.hasServerSideSupport = e, e !== v.Stable && (r.FILTER_RELATED_BY_SENDERS.setPreferUnstable(!0), r.FILTER_RELATED_BY_REL_TYPES.setPreferUnstable(!0), r.THREAD_RELATION_TYPE.setPreferUnstable(!0))
									}
									static setServerSideListSupport(e) {
										m.hasServerSideListSupport = e
									}
									static setServerSideFwdPaginationSupport(e) {
										m.hasServerSideFwdPaginationSupport = e
									}
									get roomState() {
										return this.room.getLiveTimeline().getState(a.EventTimeline.FORWARDS)
									}
									addEventToTimeline(e, t) {
										this.findEventById(e.getId()) || this.timelineSet.addEventToTimeline(e, this.liveTimeline, {
											toStartOfTimeline: t,
											fromCache: !1,
											roomState: this.roomState
										})
									}
									addEvents(e, t) {
										e.forEach(e => this.addEvent(e, t, !1)), this.initialiseThread()
									}
									addEvent(e, t, i = !0) {
										var s, a;
										return n(this, void 0, void 0, (function*() {
											this.setEventMetadata(e);
											const n = this.lastReply(),
												c = !n || e.localTimestamp > n.localTimestamp;
											if (m.hasServerSideSupport) {
												if (!t && this.initialEventsFetched && c) yield this.fetchEditsWhereNeeded(e), this.addEventToTimeline(e, !1);
												else if (e.isRelation(o.RelationType.Annotation) || e.isRelation(o.RelationType.Replace)) return null === (s = this.timelineSet.relations) || void 0 === s || s.aggregateParentEvent(e), void(null === (a = this.timelineSet.relations) || void 0 === a || a.aggregateChildEvent(e, this.timelineSet))
											} else this.addEventToTimeline(e, t), this.client.decryptEventIfNeeded(e, {});
											m.hasServerSideSupport && this.rootEvent || !e.isRelation(r.THREAD_RELATION_TYPE.name) || this.replyCount++, i && (this.emit(p.NewReply, this, e), this.initialiseThread())
										}))
									}
									processEvent(e) {
										return n(this, void 0, void 0, (function*() {
											e && (this.setEventMetadata(e), yield this.fetchEditsWhereNeeded(e))
										}))
									}
									getRootEventBundledRelationship(e = this.rootEvent) {
										return null == e ? void 0 : e.getServerAggregatedRelation(r.THREAD_RELATION_TYPE.name)
									}
									initialiseThread() {
										return n(this, void 0, void 0, (function*() {
											let e = this.getRootEventBundledRelationship();
											if (m.hasServerSideSupport && (yield this.fetchRootEvent(), e = this.getRootEventBundledRelationship()), m.hasServerSideSupport && e) {
												this.replyCount = e.count, this._currentUserParticipated = !!e.current_user_participated;
												const t = this.client.getEventMapper();
												this.lastEvent = t(e.latest_event), yield this.processEvent(this.lastEvent)
											}
											if (!this.initialEventsFetched) {
												this.initialEventsFetched = !0;
												try {
													yield this.client.paginateEventTimeline(this.liveTimeline, {
														backwards: !0,
														limit: 1
													}), this.emit(l.RoomEvent.TimelineReset, this.room, this.timelineSet, !0)
												} catch (t) {
													d.logger.error("Failed to load start of newly created thread: ", t), this.initialEventsFetched = !1
												}
											}
											this.emit(p.Update, this)
										}))
									}
									fetchEditsWhereNeeded(...e) {
										return n(this, void 0, void 0, (function*() {
											return Promise.all(e.filter(e => e.isEncrypted()).map(e => {
												if (!e.isRelation()) return this.client.relations(this.roomId, e.getId(), o.RelationType.Replace, e.getType(), {
													limit: 1
												}).then(t => {
													t.events.length && e.makeReplaced(t.events[0])
												}).catch(e => {
													d.logger.error("Failed to load edits for encrypted thread event", e)
												})
											}))
										}))
									}
									setEventMetadata(e) {
										e && (a.EventTimeline.setEventMetadata(e, this.roomState, !1), e.setThread(this))
									}
									clearEventMetadata(e) {
										var t, n, i;
										e && (e.setThread(void 0), null === (i = null === (n = null === (t = e.event) || void 0 === t ? void 0 : t.unsigned) || void 0 === n ? void 0 : n["m.relations"]) || void 0 === i || delete i[r.THREAD_RELATION_TYPE.name])
									}
									findEventById(e) {
										var t;
										return (null === (t = this.lastEvent) || void 0 === t ? void 0 : t.getId()) === e ? this.lastEvent : this.timelineSet.findEventById(e)
									}
									lastReply(e = (() => !0)) {
										for (let t = this.events.length - 1; t >= 0; t--) {
											const r = this.events[t];
											if (e(r)) return r
										}
										return null
									}
									get roomId() {
										return this.room.roomId
									}
									get length() {
										return this.replyCount
									}
									get replyToEvent() {
										var e;
										return null !== (e = this.lastEvent) && void 0 !== e ? e : this.lastReply()
									}
									get events() {
										return this.liveTimeline.getEvents()
									}
									has(e) {
										return this.timelineSet.findEventById(e) instanceof s.MatrixEvent
									}
									get hasCurrentUserParticipated() {
										return this._currentUserParticipated
									}
									get liveTimeline() {
										return this.timelineSet.getLiveTimeline()
									}
									getUnfilteredTimelineSet() {
										return this.timelineSet
									}
									get timeline() {
										return this.events
									}
									addReceipt(e, t) {
										throw new Error("Unsupported function on the thread model")
									}
									hasUserReadEvent(e, t) {
										if (e === this.client.getUserId()) {
											const t = this.getReadReceiptForUserId(e, !1, f.ReceiptType.Read),
												r = this.getReadReceiptForUserId(e, !1, f.ReceiptType.ReadPrivate),
												n = this.room.getThreadUnreadNotificationCount(this.id, l.NotificationCountType.Total) > 0;
											if (!t && !r && !n) return !0
										}
										return super.hasUserReadEvent(e, t)
									}
								}
								r.Thread = m, m.hasServerSideSupport = v.None, m.hasServerSideListSupport = v.None, m.hasServerSideFwdPaginationSupport = v.None, r.FILTER_RELATED_BY_SENDERS = new u.ServerControlledNamespacedValue("related_by_senders", "io.element.relation_senders"), r.FILTER_RELATED_BY_REL_TYPES = new u.ServerControlledNamespacedValue("related_by_rel_types", "io.element.relation_types"), r.THREAD_RELATION_TYPE = new u.ServerControlledNamespacedValue("m.thread", "io.element.thread"),
									function(e) {
										e[e.My = 0] = "My", e[e.All = 1] = "All"
									}(g = r.ThreadFilterType || (r.ThreadFilterType = {})), r.threadFilterTypeToFilter = function(e) {
										switch (e) {
											case g.My:
												return "participated";
											default:
												return "all"
										}
									}
							}, {
								"../@types/event": 290,
								"../@types/read_receipts": 294,
								"../NamespacedValue": 299,
								"../ReEmitter": 300,
								"../logger": 356,
								"./event": 365,
								"./event-timeline": 364,
								"./event-timeline-set": 363,
								"./read-receipt": 367,
								"./room": 373
							}],
							376: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.TypedEventEmitter = r.EventEmitterEvents = void 0;
								const n = e("events");
								! function(e) {
									e.NewListener = "newListener", e.RemoveListener = "removeListener", e.Error = "error"
								}(r.EventEmitterEvents || (r.EventEmitterEvents = {}));
								class i extends n.EventEmitter {
									addListener(e, t) {
										return super.addListener(e, t)
									}
									emit(e, ...t) {
										return super.emit(e, ...t)
									}
									eventNames() {
										return super.eventNames()
									}
									listenerCount(e) {
										return super.listenerCount(e)
									}
									listeners(e) {
										return super.listeners(e)
									}
									off(e, t) {
										return super.off(e, t)
									}
									on(e, t) {
										return super.on(e, t)
									}
									once(e, t) {
										return super.once(e, t)
									}
									prependListener(e, t) {
										return super.prependListener(e, t)
									}
									prependOnceListener(e, t) {
										return super.prependOnceListener(e, t)
									}
									removeAllListeners(e) {
										return super.removeAllListeners(e)
									}
									removeListener(e, t) {
										return super.removeListener(e, t)
									}
									rawListeners(e) {
										return super.rawListeners(e)
									}
								}
								r.TypedEventEmitter = i
							}, {
								events: 106
							}],
							377: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.User = r.UserEvent = void 0;
								const n = e("./typed-event-emitter");
								var i;
								! function(e) {
									e.DisplayName = "User.displayName", e.AvatarUrl = "User.avatarUrl", e.Presence = "User.presence", e.CurrentlyActive = "User.currentlyActive", e.LastPresenceTs = "User.lastPresenceTs"
								}(i = r.UserEvent || (r.UserEvent = {}));
								class o extends n.TypedEventEmitter {
									constructor(e) {
										super(), this.userId = e, this.modified = -1, this.presence = "offline", this.lastActiveAgo = 0, this.lastPresenceTs = 0, this.currentlyActive = !1, this.events = {}, this.displayName = e, this.rawDisplayName = e, this.updateModifiedTime()
									}
									setPresenceEvent(e) {
										if ("m.presence" !== e.getType()) return;
										const t = null === this.events.presence;
										this.events.presence = e;
										const r = [];
										(e.getContent().presence !== this.presence || t) && r.push(i.Presence), e.getContent().avatar_url && e.getContent().avatar_url !== this.avatarUrl && r.push(i.AvatarUrl), e.getContent().displayname && e.getContent().displayname !== this.displayName && r.push(i.DisplayName), void 0 !== e.getContent().currently_active && e.getContent().currently_active !== this.currentlyActive && r.push(i.CurrentlyActive), this.presence = e.getContent().presence, r.push(i.LastPresenceTs), e.getContent().status_msg && (this.presenceStatusMsg = e.getContent().status_msg), e.getContent().displayname && (this.displayName = e.getContent().displayname), e.getContent().avatar_url && (this.avatarUrl = e.getContent().avatar_url), this.lastActiveAgo = e.getContent().last_active_ago, this.lastPresenceTs = Date.now(), this.currentlyActive = e.getContent().currently_active, this.updateModifiedTime();
										for (const n of r) this.emit(n, e, this)
									}
									setDisplayName(e) {
										const t = this.displayName;
										this.displayName = e, e !== t && this.updateModifiedTime()
									}
									setRawDisplayName(e) {
										this.rawDisplayName = e
									}
									setAvatarUrl(e) {
										const t = this.avatarUrl;
										this.avatarUrl = e, e !== t && this.updateModifiedTime()
									}
									updateModifiedTime() {
										this.modified = Date.now()
									}
									getLastModifiedTime() {
										return this.modified
									}
									getLastActiveTs() {
										return this.lastPresenceTs - this.lastActiveAgo
									}
								}
								r.User = o
							}, {
								"./typed-event-emitter": 376
							}],
							378: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.PushProcessor = void 0;
								const n = e("./utils"),
									i = e("./logger"),
									o = e("./@types/PushRules"),
									s = e("./@types/event"),
									a = [o.PushRuleKind.Override, o.PushRuleKind.ContentSpecific, o.PushRuleKind.RoomSpecific, o.PushRuleKind.SenderSpecific, o.PushRuleKind.Underride],
									c = [{
										rule_id: ".m.rule.reaction",
										default: !0,
										enabled: !0,
										conditions: [{
											kind: o.ConditionKind.EventMatch,
											key: "type",
											pattern: "m.reaction"
										}],
										actions: [o.PushRuleActionName.DontNotify]
									}, {
										rule_id: ".org.matrix.msc3786.rule.room.server_acl",
										default: !0,
										enabled: !0,
										conditions: [{
											kind: o.ConditionKind.EventMatch,
											key: "type",
											pattern: s.EventType.RoomServerAcl
										}, {
											kind: o.ConditionKind.EventMatch,
											key: "state_key",
											pattern: ""
										}],
										actions: []
									}],
									l = [{
										rule_id: ".org.matrix.msc3914.rule.room.call",
										default: !0,
										enabled: !0,
										conditions: [{
											kind: o.ConditionKind.EventMatch,
											key: "type",
											pattern: "org.matrix.msc3401.call"
										}, {
											kind: o.ConditionKind.CallStarted
										}],
										actions: [o.PushRuleActionName.Notify, {
											set_tweak: o.TweakName.Sound,
											value: "default"
										}]
									}];
								class u {
									constructor(e) {
										this.client = e
									}
									static actionListToActionsObject(e) {
										const t = {
											notify: !1,
											tweaks: {}
										};
										for (const r of e) r === o.PushRuleActionName.Notify ? t.notify = !0 : "object" == typeof r && (void 0 === r.value && (r.value = !0), t.tweaks[r.set_tweak] = r.value);
										return t
									}
									static rewriteDefaultRules(e) {
										var t;
										let r = JSON.parse(JSON.stringify(e));
										r || (r = {}), r.global || (r.global = {}), r.global.override || (r.global.override = []), r.global.override || (r.global.underride = []);
										const n = r.global.override;
										for (const s of c) {
											const e = n.find(e => e.rule_id === s.rule_id);
											if (e) e.default = s.default, e.conditions = s.conditions, e.actions = s.actions;
											else {
												const e = s.rule_id;
												i.logger.warn(`Adding default global override for ${e}`), n.push(s)
											}
										}
										const o = null !== (t = r.global.underride) && void 0 !== t ? t : [];
										for (const s of l) {
											const e = o.find(e => e.rule_id === s.rule_id);
											if (e) e.default = s.default, e.conditions = s.conditions, e.actions = s.actions;
											else {
												const e = s.rule_id;
												i.logger.warn(`Adding default global underride for ${e}`), o.push(s)
											}
										}
										return r
									}
									matchingRuleFromKindSet(e, t) {
										for (const r of a) {
											const n = t[r];
											if (n)
												for (const t of n) {
													if (!t.enabled) continue;
													const n = this.templateRuleToRaw(r, t);
													if (n && this.ruleMatchesEvent(n, e)) return Object.assign(Object.assign({}, t), {
														kind: r
													})
												}
										}
										return null
									}
									templateRuleToRaw(e, t) {
										const r = {
											rule_id: t.rule_id,
											actions: t.actions,
											conditions: []
										};
										switch (e) {
											case o.PushRuleKind.Underride:
											case o.PushRuleKind.Override:
												r.conditions = t.conditions;
												break;
											case o.PushRuleKind.RoomSpecific:
												if (!t.rule_id) return null;
												r.conditions.push({
													kind: o.ConditionKind.EventMatch,
													key: "room_id",
													value: t.rule_id
												});
												break;
											case o.PushRuleKind.SenderSpecific:
												if (!t.rule_id) return null;
												r.conditions.push({
													kind: o.ConditionKind.EventMatch,
													key: "user_id",
													value: t.rule_id
												});
												break;
											case o.PushRuleKind.ContentSpecific:
												if (!t.pattern) return null;
												r.conditions.push({
													kind: o.ConditionKind.EventMatch,
													key: "content.body",
													pattern: t.pattern
												})
										}
										return r
									}
									eventFulfillsCondition(e, t) {
										switch (e.kind) {
											case o.ConditionKind.EventMatch:
												return this.eventFulfillsEventMatchCondition(e, t);
											case o.ConditionKind.ContainsDisplayName:
												return this.eventFulfillsDisplayNameCondition(e, t);
											case o.ConditionKind.RoomMemberCount:
												return this.eventFulfillsRoomMemberCountCondition(e, t);
											case o.ConditionKind.SenderNotificationPermission:
												return this.eventFulfillsSenderNotifPermCondition(e, t);
											case o.ConditionKind.CallStarted:
											case o.ConditionKind.CallStartedPrefix:
												return this.eventFulfillsCallStartedCondition(e, t)
										}
										return !1
									}
									eventFulfillsSenderNotifPermCondition(e, t) {
										const r = e.key;
										if (!r) return !1;
										const n = this.client.getRoom(t.getRoomId());
										return !(null == n || !n.currentState) && n.currentState.mayTriggerNotifOfType(r, t.getSender())
									}
									eventFulfillsRoomMemberCountCondition(e, t) {
										if (!e.is) return !1;
										const r = this.client.getRoom(t.getRoomId());
										if (!r || !r.currentState || !r.currentState.members) return !1;
										const n = r.currentState.getJoinedMemberCount(),
											i = e.is.match(/^([=<>]*)(\d*)$/);
										if (!i) return !1;
										const o = i[1],
											s = parseInt(i[2]);
										if (isNaN(s)) return !1;
										switch (o) {
											case "":
											case "==":
												return n == s;
											case "<":
												return n < s;
											case ">":
												return n > s;
											case "<=":
												return n <= s;
											case ">=":
												return n >= s;
											default:
												return !1
										}
									}
									eventFulfillsDisplayNameCondition(e, t) {
										var r;
										let i = t.getContent();
										if (t.isEncrypted() && t.getClearContent() && (i = t.getClearContent()), !i || !i.body || "string" != typeof i.body) return !1;
										const o = this.client.getRoom(t.getRoomId()),
											s = null === (r = null == o ? void 0 : o.currentState) || void 0 === r ? void 0 : r.getMember(this.client.credentials.userId);
										if (!s) return !1;
										const a = s.name,
											c = new RegExp("(^|\\W)" + (0, n.escapeRegExp)(a) + "(\\W|$)", "i");
										return i.body.search(c) > -1
									}
									eventFulfillsEventMatchCondition(e, t) {
										if (!e.key) return !1;
										const r = this.valueForDottedKey(e.key, t);
										if ("string" != typeof r) return !1;
										if (e.value) return e.value === r;
										if ("string" != typeof e.pattern) return !1;
										const n = "content.body" === e.key ? this.createCachedRegex("(^|\\W)", e.pattern, "(\\W|$)") : this.createCachedRegex("^", e.pattern, "$");
										return !!r.match(n)
									}
									eventFulfillsCallStartedCondition(e, t) {
										return ["m.ring", "m.prompt"].includes(t.getContent()["m.intent"]) && !("m.terminated" in t.getContent()) && (t.getPrevContent()["m.terminated"] !== t.getContent()["m.terminated"] || (0, n.deepCompare)(t.getPrevContent(), {}))
									}
									createCachedRegex(e, t, r) {
										return u.cachedGlobToRegex[t] ? u.cachedGlobToRegex[t] : (u.cachedGlobToRegex[t] = new RegExp(e + (0, n.globToRegexp)(t) + r, "i"), u.cachedGlobToRegex[t])
									}
									valueForDottedKey(e, t) {
										const r = e.split(".");
										let i;
										const o = r[0];
										for ("content" === o ? (i = t.getContent(), r.shift()) : "type" === o ? (i = t.getType(), r.shift()) : i = t.event; r.length > 0;) {
											const e = r.shift();
											if ((0, n.isNullOrUndefined)(i[e])) return null;
											i = i[e]
										}
										return i
									}
									matchingRuleForEventWithRulesets(e, t) {
										return t ? e.getSender() === this.client.credentials.userId ? null : this.matchingRuleFromKindSet(e, t.global) : null
									}
									pushActionsForEventAndRulesets(e, t) {
										const r = this.matchingRuleForEventWithRulesets(e, t);
										if (!r) return {};
										const n = u.actionListToActionsObject(r.actions);
										return void 0 === n.tweaks.highlight && (n.tweaks.highlight = r.kind == o.PushRuleKind.ContentSpecific), n
									}
									ruleMatchesEvent(e, t) {
										var r;
										return !(null === (r = e.conditions) || void 0 === r ? void 0 : r.some(e => !this.eventFulfillsCondition(e, t)))
									}
									actionsForEvent(e) {
										return this.pushActionsForEventAndRulesets(e, this.client.pushRules)
									}
									getPushRuleById(e) {
										var t;
										for (const r of ["global"])
											if (void 0 !== (null === (t = this.client.pushRules) || void 0 === t ? void 0 : t[r]))
												for (const t of a)
													if (void 0 !== this.client.pushRules[r][t])
														for (const n of this.client.pushRules[r][t])
															if (n.rule_id === e) return n;
										return null
									}
								}
								r.PushProcessor = u, u.cachedGlobToRegex = {}
							}, {
								"./@types/PushRules": 288,
								"./@types/event": 290,
								"./logger": 356,
								"./utils": 393
							}],
							379: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.randomUppercaseString = r.randomLowercaseString = r.randomString = void 0;
								const n = "abcdefghijklmnopqrstuvwxyz",
									i = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
									o = "0123456789";

								function s(e, t) {
									let r = "";
									for (let n = 0; n < e; ++n) r += t.charAt(Math.floor(Math.random() * t.length));
									return r
								}
								r.randomString = function(e) {
									return s(e, i + n + o)
								}, r.randomLowercaseString = function(e) {
									return s(e, n)
								}, r.randomUppercaseString = function(e) {
									return s(e, i)
								}
							}, {}],
							380: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n.clearTimeout = n.setTimeout = void 0;
										const r = t("./logger"),
											i = 1e3;
										let o, s = 0;
										const a = [],
											c = function(...e) {};

										function l() {
											o && e.clearTimeout(o);
											const t = a[0];
											if (!t) return void c("scheduleRealCallback: no more callbacks, not rescheduling");
											const r = Date.now(),
												n = Math.min(t.runAt - r, i);
											c("scheduleRealCallback: now:", r, "delay:", n), o = e.setTimeout(u, n)
										}

										function u() {
											const t = Date.now();
											c("runCallbacks: now:", t);
											const n = [];
											for (;;) {
												const e = a[0];
												if (!e || e.runAt > t) break;
												const r = a.shift();
												c("runCallbacks: popping", r.key), n.push(r)
											}
											l();
											for (const o of n) try {
												o.func.apply(e, o.params)
											} catch (i) {
												r.logger.error("Uncaught exception in callback function", i)
											}
										}
										n.setTimeout = function(e, t, ...r) {
											(t = t || 0) < 0 && (t = 0);
											const n = Date.now() + t,
												i = s++;
											c("setTimeout: scheduling cb", i, "at", n, "(delay", t, ")");
											const o = {
													runAt: n,
													func: e,
													params: r,
													key: i
												},
												u = function(e, t) {
													let r = 0,
														n = e.length;
													for (; r < n;) {
														const i = r + n >> 1;
														t(e[i]) > 0 ? n = i : r = i + 1
													}
													return r
												}(a, (function(e) {
													return e.runAt - n
												}));
											return a.splice(u, 0, o), l(), i
										}, n.clearTimeout = function(e) {
											if (0 === a.length) return;
											let t;
											for (t = 0; t < a.length; t++) {
												if (a[t].key == e) {
													a.splice(t, 1);
													break
												}
											}
											0 === t && l()
										}
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"./logger": 356
							}],
							381: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
										Object.defineProperty(e, "default", {
											enumerable: !0,
											value: t
										})
									} : function(e, t) {
										e.default = t
									}),
									o = this && this.__importStar || function(e) {
										if (e && e.__esModule) return e;
										var t = {};
										if (null != e)
											for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
										return i(t, e), t
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.MatrixScheduler = void 0;
								const s = o(e("./utils")),
									a = e("./logger"),
									c = e("./@types/event"),
									l = e("./http-api"),
									u = !1;
								class d {
									constructor(e = d.RETRY_BACKOFF_RATELIMIT, t = d.QUEUE_MESSAGES) {
										this.retryAlgorithm = e, this.queueAlgorithm = t, this.queues = {}, this.activeQueues = [], this.procFn = null, this.processQueue = e => {
											const t = this.peekNextEvent(e);
											if (!t) {
												const t = this.activeQueues.indexOf(e);
												return t >= 0 && this.activeQueues.splice(t, 1), void h("Stopping queue '%s' as it is now empty", e)
											}
											h("Queue '%s' has %s pending events", e, this.queues[e].length), Promise.resolve().then(() => this.procFn(t.event)).then(r => {
												this.removeNextEvent(e), h("Queue '%s' sent event %s", e, t.event.getId()), t.defer.resolve(r), this.processQueue(e)
											}, r => {
												t.attempts += 1;
												const n = this.retryAlgorithm(t.event, t.attempts, r);
												h("retry(%s) err=%s event_id=%s waitTime=%s", t.attempts, r, t.event.getId(), n), -1 === n ? (h("Queue '%s' giving up on event %s", e, t.event.getId()), this.removeNextEvent(e), t.defer.reject(r), this.processQueue(e)) : setTimeout(this.processQueue, n, e)
											})
										}
									}
									static RETRY_BACKOFF_RATELIMIT(e, t, r) {
										if (400 === r.httpStatus || 403 === r.httpStatus || 401 === r.httpStatus) return -1;
										if (r instanceof l.ConnectionError) return -1;
										if ("M_TOO_LARGE" === r.name) return -1;
										if ("M_LIMIT_EXCEEDED" === r.name) {
											const e = r.data.retry_after_ms;
											if (e > 0) return e
										}
										return t > 4 ? -1 : 1e3 * Math.pow(2, t)
									}
									static QUEUE_MESSAGES(e) {
										return e.getType() === c.EventType.RoomMessage || e.hasAssocation() ? "message" : null
									}
									getQueueForEvent(e) {
										const t = this.queueAlgorithm(e);
										return t && this.queues[t] ? this.queues[t].map((function(e) {
											return e.event
										})) : null
									}
									removeEventFromQueue(e) {
										const t = this.queueAlgorithm(e);
										if (!t || !this.queues[t]) return !1;
										let r = !1;
										return s.removeElement(this.queues[t], t => t.event.getId() === e.getId() && (r = !0, !0)), r
									}
									setProcessFunction(e) {
										this.procFn = e, this.startProcessingQueues()
									}
									queueEvent(e) {
										const t = this.queueAlgorithm(e);
										if (!t) return null;
										this.queues[t] || (this.queues[t] = []);
										const r = s.defer();
										return this.queues[t].push({
											event: e,
											defer: r,
											attempts: 0
										}), h("Queue algorithm dumped event %s into queue '%s'", e.getId(), t), this.startProcessingQueues(), r.promise
									}
									startProcessingQueues() {
										this.procFn && Object.keys(this.queues).filter(e => -1 === this.activeQueues.indexOf(e) && this.queues[e].length > 0).forEach(e => {
											this.activeQueues.push(e), h("Spinning up queue: '%s'", e), this.processQueue(e)
										})
									}
									peekNextEvent(e) {
										const t = this.queues[e];
										if (Array.isArray(t)) return t[0]
									}
									removeNextEvent(e) {
										const t = this.queues[e];
										if (Array.isArray(t)) return t.shift()
									}
								}

								function h(...e) {
									u && a.logger.log(...e)
								}
								r.MatrixScheduler = d
							}, {
								"./@types/event": 290,
								"./http-api": 349,
								"./logger": 356,
								"./utils": 393
							}],
							382: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.SERVICE_TYPES = void 0,
									function(e) {
										e.IS = "SERVICE_TYPE_IS", e.IM = "SERVICE_TYPE_IM"
									}(r.SERVICE_TYPES || (r.SERVICE_TYPES = {}))
							}, {}],
							383: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
										Object.defineProperty(e, "default", {
											enumerable: !0,
											value: t
										})
									} : function(e, t) {
										e.default = t
									}),
									o = this && this.__importStar || function(e) {
										if (e && e.__esModule) return e;
										var t = {};
										if (null != e)
											for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
										return i(t, e), t
									},
									s = this && this.__awaiter || function(e, t, r, n) {
										return new(r || (r = Promise))((function(i, o) {
											function s(e) {
												try {
													c(n.next(e))
												} catch (t) {
													o(t)
												}
											}

											function a(e) {
												try {
													c(n.throw(e))
												} catch (t) {
													o(t)
												}
											}

											function c(e) {
												var t;
												e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
													e(t)
												}))).then(s, a)
											}
											c((n = n.apply(e, t || [])).next())
										}))
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.SlidingSyncSdk = void 0;
								const a = e("./models/room"),
									c = e("./logger"),
									l = o(e("./utils")),
									u = e("./models/event-timeline"),
									d = e("./client"),
									h = e("./sync"),
									f = e("./http-api"),
									p = e("./sliding-sync"),
									v = e("./@types/event"),
									g = e("./pushprocessor"),
									m = e("./models/room-state"),
									y = e("./models/room-member"),
									b = 3;
								class _ {
									constructor(e) {
										this.crypto = e
									}
									name() {
										return "e2ee"
									}
									when() {
										return p.ExtensionState.PreProcess
									}
									onRequest(e) {
										if (e) return {
											enabled: !0
										}
									}
									onResponse(e) {
										return s(this, void 0, void 0, (function*() {
											if (e.device_lists && (yield this.crypto.handleDeviceListChanges({
													oldSyncToken: "yep"
												}, e.device_lists)), e.device_one_time_keys_count) {
												const t = e.device_one_time_keys_count.signed_curve25519 || 0;
												this.crypto.updateOneTimeKeyCount(t)
											}
											if (e.device_unused_fallback_key_types || e["org.matrix.msc2732.device_unused_fallback_key_types"]) {
												const t = e.device_unused_fallback_key_types || e["org.matrix.msc2732.device_unused_fallback_key_types"];
												this.crypto.setNeedsNewFallback(Array.isArray(t) && !t.includes("signed_curve25519"))
											}
										}))
									}
								}
								class w {
									constructor(e) {
										this.client = e, this.nextBatch = null
									}
									name() {
										return "to_device"
									}
									when() {
										return p.ExtensionState.PreProcess
									}
									onRequest(e) {
										const t = {
											since: null !== this.nextBatch ? this.nextBatch : void 0
										};
										return e && (t.limit = 100, t.enabled = !0), t
									}
									onResponse(e) {
										return s(this, void 0, void 0, (function*() {
											const t = [];
											e.events = e.events || [], e.events.map(this.client.getEventMapper()).map(e => {
												if ("m.key.verification.cancel" === e.getType()) {
													const r = e.getContent().transaction_id;
													r && t.push(r)
												}
												return e
											}).forEach(e => {
												const r = e.getContent();
												if ("m.room.message" != e.getType() || "m.bad.encrypted" != r.msgtype) {
													if ("m.key.verification.start" === e.getType() || "m.key.verification.request" === e.getType()) {
														const n = r.transaction_id;
														t.includes(n) && e.flagCancelled()
													}
													this.client.emit(d.ClientEvent.ToDeviceEvent, e)
												} else c.logger.log("Ignoring undecryptable to-device event from " + e.getSender())
											}), this.nextBatch = e.next_batch
										}))
									}
								}
								class S {
									constructor(e) {
										this.client = e
									}
									name() {
										return "account_data"
									}
									when() {
										return p.ExtensionState.PostProcess
									}
									onRequest(e) {
										if (e) return {
											enabled: !0
										}
									}
									onResponse(e) {
										e.global && e.global.length > 0 && this.processGlobalAccountData(e.global);
										for (const t in e.rooms) {
											const r = E(this.client, t, e.rooms[t]),
												n = this.client.getRoom(t);
											n ? (n.addAccountData(r), r.forEach(e => {
												this.client.emit(d.ClientEvent.Event, e)
											})) : c.logger.warn("got account data for room but room doesn't exist on client:", t)
										}
									}
									processGlobalAccountData(e) {
										const t = E(this.client, void 0, e),
											r = t.reduce((e, t) => (e[t.getType()] = this.client.store.getAccountData(t.getType()), e), {});
										this.client.store.storeAccountDataEvents(t), t.forEach(e => {
											if (e.getType() === v.EventType.PushRules) {
												const t = e.getContent();
												this.client.pushRules = g.PushProcessor.rewriteDefaultRules(t)
											}
											const t = r[e.getType()];
											return this.client.emit(d.ClientEvent.AccountData, e, t), e
										})
									}
								}

								function E(e, t, r, n = !0) {
									const i = e.getEventMapper({
										decrypt: n
									});
									return r.map((function(e) {
										return e.room_id = t, i(e)
									}))
								}
								r.SlidingSyncSdk = class {
									constructor(e, t, r = {}) {
										var n;
										this.slidingSync = e, this.client = t, this.opts = r, this.syncState = null, this.lastPos = null, this.failCount = 0, this.notifEvents = [], this.opts.initialSyncLimit = null !== (n = this.opts.initialSyncLimit) && void 0 !== n ? n : 8, this.opts.resolveInvitesToProfiles = this.opts.resolveInvitesToProfiles || !1, this.opts.pollTimeout = this.opts.pollTimeout || 3e4, this.opts.pendingEventOrdering = this.opts.pendingEventOrdering || d.PendingEventOrdering.Chronological, this.opts.experimentalThreadSupport = !0 === this.opts.experimentalThreadSupport, r.canResetEntireTimeline || (r.canResetEntireTimeline = e => !1), t.getNotifTimelineSet() && t.reEmitter.reEmit(t.getNotifTimelineSet(), [a.RoomEvent.Timeline, a.RoomEvent.TimelineReset]), this.slidingSync.on(p.SlidingSyncEvent.Lifecycle, this.onLifecycle.bind(this)), this.slidingSync.on(p.SlidingSyncEvent.RoomData, this.onRoomData.bind(this));
										const i = [new w(this.client), new S(this.client)];
										this.opts.crypto && i.push(new _(this.opts.crypto)), i.forEach(e => {
											this.slidingSync.registerExtension(e)
										})
									}
									onRoomData(e, t) {
										let r = this.client.store.getRoom(e);
										if (!r) {
											if (!t.initial) return void c.logger.debug("initial flag not set but no stored room exists for room ", e, t);
											r = (0, h._createAndReEmitRoom)(this.client, e, this.opts)
										}
										this.processRoomData(this.client, r, t)
									}
									onLifecycle(e, t, r) {
										switch (r && c.logger.debug("onLifecycle", e, r), e) {
											case p.SlidingSyncState.Complete:
												if (this.purgeNotifications(), !t) break;
												this.lastPos || this.updateSyncState(h.SyncState.Prepared, {
													oldSyncToken: void 0,
													nextSyncToken: t.pos,
													catchingUp: !1,
													fromCache: !1
												}), this.updateSyncState(h.SyncState.Syncing, {
													oldSyncToken: this.lastPos,
													nextSyncToken: t.pos,
													catchingUp: !1,
													fromCache: !1
												}), this.lastPos = t.pos;
												break;
											case p.SlidingSyncState.RequestFinished:
												if (r) {
													if (this.failCount += 1, this.updateSyncState(this.failCount > b ? h.SyncState.Error : h.SyncState.Reconnecting, {
															error: new f.MatrixError(r)
														}), this.shouldAbortSync(new f.MatrixError(r))) return
												} else this.failCount = 0
										}
									}
									syncLeftRooms() {
										return s(this, void 0, void 0, (function*() {
											return []
										}))
									}
									peek(e) {
										return s(this, void 0, void 0, (function*() {
											return null
										}))
									}
									stopPeeking() {}
									getSyncState() {
										return this.syncState
									}
									getSyncStateData() {
										var e;
										return null !== (e = this.syncStateData) && void 0 !== e ? e : null
									}
									createRoom(e) {
										const {
											timelineSupport: t
										} = this.client, r = new a.Room(e, this.client, this.client.getUserId(), {
											lazyLoadMembers: this.opts.lazyLoadMembers,
											pendingEventOrdering: this.opts.pendingEventOrdering,
											timelineSupport: t
										});
										return this.client.reEmitter.reEmit(r, [a.RoomEvent.Name, a.RoomEvent.Redaction, a.RoomEvent.RedactionCancelled, a.RoomEvent.Receipt, a.RoomEvent.Tags, a.RoomEvent.LocalEchoUpdated, a.RoomEvent.AccountData, a.RoomEvent.MyMembership, a.RoomEvent.Timeline, a.RoomEvent.TimelineReset]), this.registerStateListeners(r), r
									}
									registerStateListeners(e) {
										this.client.reEmitter.reEmit(e.currentState, [m.RoomStateEvent.Events, m.RoomStateEvent.Members, m.RoomStateEvent.NewMember, m.RoomStateEvent.Update]), e.currentState.on(m.RoomStateEvent.NewMember, (e, t, r) => {
											var n;
											r.user = null !== (n = this.client.getUser(r.userId)) && void 0 !== n ? n : void 0, this.client.reEmitter.reEmit(r, [y.RoomMemberEvent.Name, y.RoomMemberEvent.Typing, y.RoomMemberEvent.PowerLevel, y.RoomMemberEvent.Membership])
										})
									}
									shouldAbortSync(e) {
										return "M_UNKNOWN_TOKEN" === e.errcode && (c.logger.warn("Token no longer valid - assuming logout"), this.stop(), this.updateSyncState(h.SyncState.Error, {
											error: e
										}), !0)
									}
									processRoomData(e, t, r) {
										var n;
										return s(this, void 0, void 0, (function*() {
											r = function(e, t, r) {
												if (!r.name) return r;
												for (const n of r.required_state)
													if (n.type === v.EventType.RoomName && "" === n.state_key) return n.content = {
														name: r.name
													}, r;
												return r.required_state.push({
													event_id: "$fake-sliding-sync-name-event-" + t,
													state_key: "",
													type: v.EventType.RoomName,
													content: {
														name: r.name
													},
													sender: e.getUserId(),
													origin_server_ts: (new Date).getTime()
												}), r
											}(e, t.roomId, r);
											const i = E(this.client, t.roomId, r.required_state);
											let o = E(this.client, t.roomId, r.timeline, !1);
											const c = [];
											if (r.initial) {
												const e = new Set;
												t.getLiveTimeline().getEvents().forEach(t => {
													e.add(t.getId())
												});
												const n = [],
													i = [];
												let s = !1;
												for (let t = o.length - 1; t >= 0; t--) {
													const r = o[t];
													e.has(r.getId()) ? s = !0 : s ? n.push(r) : i.unshift(r)
												}
												o = i, n.length > 0 && t.addEventsToTimeline(n, !0, t.getLiveTimeline(), r.prev_batch)
											}
											const h = this.client.isRoomEncrypted(t.roomId);
											if (null != r.notification_count && t.setUnreadNotificationCount(a.NotificationCountType.Total, r.notification_count), null != r.highlight_count && (!h || h && t.getUnreadNotificationCount(a.NotificationCountType.Highlight) <= 0) && t.setUnreadNotificationCount(a.NotificationCountType.Highlight, r.highlight_count), Number.isInteger(r.invited_count) && t.currentState.setInvitedMemberCount(r.invited_count), Number.isInteger(r.joined_count) && t.currentState.setJoinedMemberCount(r.joined_count), r.invite_state) {
												const e = E(this.client, t.roomId, r.invite_state);
												return this.injectRoomEvents(t, e), r.initial && (t.recalculate(), this.client.store.storeRoom(t), this.client.emit(d.ClientEvent.Room, t)), e.forEach(e => {
													this.client.emit(d.ClientEvent.Event, e)
												}), void t.updateMyMembership("invite")
											}
											r.initial && t.getLiveTimeline().setPaginationToken(null !== (n = r.prev_batch) && void 0 !== n ? n : null, u.EventTimeline.BACKWARDS), this.injectRoomEvents(t, i, o, !1), t.addEphemeralEvents(c), t.updateMyMembership("join"), t.recalculate(), r.initial && (e.store.storeRoom(t), e.emit(d.ClientEvent.Room, t)), this.addNotifications(o);
											const f = t => s(this, void 0, void 0, (function*() {
												e.emit(d.ClientEvent.Event, t), t.isState() && t.getType() == v.EventType.RoomEncryption && this.opts.crypto && (yield this.opts.crypto.onCryptoEvent(t))
											}));
											yield l.promiseMapSeries(i, f), yield l.promiseMapSeries(o, f), c.forEach((function(t) {
												e.emit(d.ClientEvent.Event, t)
											})), t.decryptCriticalEvents()
										}))
									}
									injectRoomEvents(e, t, r, n = !1) {
										r = r || [], t = t || [];
										const i = e.getLiveTimeline(),
											o = 0 == i.getEvents().length;
										if (o) {
											for (const e of t) this.client.getPushActionsForEvent(e);
											i.initialiseState(t)
										}
										o || (e.oldState.setStateEvents(t), e.currentState.setStateEvents(t)), e.addLiveEvents(r, {
											fromCache: n
										}), e.recalculate(), this.resolveInvites(e)
									}
									resolveInvites(e) {
										if (!e || !this.opts.resolveInvitesToProfiles) return;
										const t = this.client;
										e.getMembersWithMembership("invite").forEach((function(r) {
											if (r.requestedProfileInfo) return;
											r.requestedProfileInfo = !0;
											const n = t.getUser(r.userId);
											let i;
											(i = n ? Promise.resolve({
												avatar_url: n.avatarUrl,
												displayname: n.displayName
											}) : t.getProfileInfo(r.userId)).then((function(t) {
												const n = r.events.member;
												"invite" === n.getContent().membership && (n.getContent().avatar_url = t.avatar_url, n.getContent().displayname = t.displayname, r.setMembershipEvent(n, e.currentState))
											}), (function(e) {}))
										}))
									}
									retryImmediately() {
										return !0
									}
									sync() {
										return s(this, void 0, void 0, (function*() {
											for (c.logger.debug("Sliding sync init loop"); !this.client.isGuest();) try {
												c.logger.debug("Getting push rules...");
												const e = yield this.client.getPushRules();
												c.logger.debug("Got push rules"), this.client.pushRules = e;
												break
											} catch (e) {
												if (c.logger.error("Getting push rules failed", e), this.shouldAbortSync(e)) return
											}
											yield this.slidingSync.start()
										}))
									}
									stop() {
										c.logger.debug("SyncApi.stop"), this.slidingSync.stop()
									}
									updateSyncState(e, t) {
										const r = this.syncState;
										this.syncState = e, this.syncStateData = t, this.client.emit(d.ClientEvent.Sync, this.syncState, r, t)
									}
									addNotifications(e) {
										if (this.client.getNotifTimelineSet())
											for (const t of e) {
												const e = this.client.getPushActionsForEvent(t);
												e && e.notify && e.tweaks && e.tweaks.highlight && this.notifEvents.push(t)
											}
									}
									purgeNotifications() {
										this.notifEvents.sort((function(e, t) {
											return e.getTs() - t.getTs()
										})), this.notifEvents.forEach(e => {
											var t;
											null === (t = this.client.getNotifTimelineSet()) || void 0 === t || t.addLiveEvent(e)
										}), this.notifEvents = []
									}
								}
							}, {
								"./@types/event": 290,
								"./client": 304,
								"./http-api": 349,
								"./logger": 356,
								"./models/event-timeline": 364,
								"./models/room": 373,
								"./models/room-member": 370,
								"./models/room-state": 371,
								"./pushprocessor": 378,
								"./sliding-sync": 384,
								"./sync": 391,
								"./utils": 393
							}],
							384: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.SlidingSync = r.SlidingSyncEvent = r.ExtensionState = r.SlidingSyncState = void 0;
								const i = e("./logger"),
									o = e("./models/typed-event-emitter"),
									s = e("./utils"),
									a = 1e4;
								var c, l, u;
								! function(e) {
									e.RequestFinished = "FINISHED", e.Complete = "COMPLETE"
								}(c = r.SlidingSyncState || (r.SlidingSyncState = {}));
								class d {
									constructor(e) {
										this.roomIndexToRoomId = {}, this.joinedCount = 0, this.replaceList(e)
									}
									setModified(e) {
										this.isModified = e
									}
									updateListRange(e) {
										this.list.ranges = JSON.parse(JSON.stringify(e))
									}
									replaceList(e) {
										e.filters = e.filters || {}, e.ranges = e.ranges || [], this.list = JSON.parse(JSON.stringify(e)), this.isModified = !0, this.roomIndexToRoomId = {}, this.joinedCount = 0
									}
									getList(e) {
										let t = {
											ranges: JSON.parse(JSON.stringify(this.list.ranges))
										};
										return (this.isModified || e) && (t = JSON.parse(JSON.stringify(this.list))), t
									}
									isIndexInRange(e) {
										for (const t of this.list.ranges)
											if (t[0] <= e && e <= t[1]) return !0;
										return !1
									}
								}! function(e) {
									e.PreProcess = "ExtState.PreProcess", e.PostProcess = "ExtState.PostProcess"
								}(l = r.ExtensionState || (r.ExtensionState = {})),
								function(e) {
									e.RoomData = "SlidingSync.RoomData", e.Lifecycle = "SlidingSync.Lifecycle", e.List = "SlidingSync.List"
								}(u = r.SlidingSyncEvent || (r.SlidingSyncEvent = {}));
								class h extends o.TypedEventEmitter {
									constructor(e, t, r, n, i) {
										super(), this.proxyBaseUrl = e, this.roomSubscriptionInfo = r, this.client = n, this.timeoutMS = i, this.listModifiedCount = 0, this.terminated = !1, this.needsResend = !1, this.txnId = null, this.txnIdDefers = [], this.extensions = {}, this.desiredRoomSubscriptions = new Set, this.confirmedRoomSubscriptions = new Set, this.customSubscriptions = new Map, this.roomIdToCustomSubscription = new Map, this.lists = t.map(e => new d(e))
									}
									addCustomSubscription(e, t) {
										this.customSubscriptions.set(e, t)
									}
									useCustomSubscription(e, t) {
										this.roomIdToCustomSubscription.set(e, t), this.confirmedRoomSubscriptions.delete(e)
									}
									listLength() {
										return this.lists.length
									}
									getListData(e) {
										return this.lists[e] ? {
											joinedCount: this.lists[e].joinedCount,
											roomIndexToRoomId: Object.assign({}, this.lists[e].roomIndexToRoomId)
										} : null
									}
									getList(e) {
										return this.lists[e] ? this.lists[e].getList(!0) : null
									}
									setListRanges(e, t) {
										return this.lists[e].updateListRange(t), this.resend()
									}
									setList(e, t) {
										return this.lists[e] ? this.lists[e].replaceList(t) : this.lists[e] = new d(t), this.listModifiedCount += 1, this.resend()
									}
									getRoomSubscriptions() {
										return new Set(Array.from(this.desiredRoomSubscriptions))
									}
									modifyRoomSubscriptions(e) {
										return this.desiredRoomSubscriptions = e, this.resend()
									}
									modifyRoomSubscriptionInfo(e) {
										return this.roomSubscriptionInfo = e, this.confirmedRoomSubscriptions = new Set, this.resend()
									}
									registerExtension(e) {
										if (this.extensions[e.name()]) throw new Error(`registerExtension: ${e.name()} already exists as an extension`);
										this.extensions[e.name()] = e
									}
									getExtensionRequest(e) {
										const t = {};
										return Object.keys(this.extensions).forEach(r => {
											t[r] = this.extensions[r].onRequest(e)
										}), t
									}
									onPreExtensionsResponse(e) {
										Object.keys(e).forEach(t => {
											this.extensions[t].when() == l.PreProcess && this.extensions[t].onResponse(e[t])
										})
									}
									onPostExtensionsResponse(e) {
										Object.keys(e).forEach(t => {
											this.extensions[t].when() == l.PostProcess && this.extensions[t].onResponse(e[t])
										})
									}
									invokeRoomDataListeners(e, t) {
										t.required_state || (t.required_state = []), t.timeline || (t.timeline = []), this.emit(u.RoomData, e, t)
									}
									invokeLifecycleListeners(e, t, r) {
										this.emit(u.Lifecycle, e, t, r)
									}
									shiftRight(e, t, r) {
										for (let n = t; n > r; n--) this.lists[e].isIndexInRange(n) && (this.lists[e].roomIndexToRoomId[n] = this.lists[e].roomIndexToRoomId[n - 1])
									}
									shiftLeft(e, t, r) {
										for (let n = r; n < t; n++) this.lists[e].isIndexInRange(n) && (this.lists[e].roomIndexToRoomId[n] = this.lists[e].roomIndexToRoomId[n + 1])
									}
									removeEntry(e, t) {
										let r = -1;
										for (const n in this.lists[e].roomIndexToRoomId) Number(n) > r && (r = Number(n));
										r < 0 || t > r || (this.shiftLeft(e, r, t), delete this.lists[e].roomIndexToRoomId[r])
									}
									addEntry(e, t) {
										let r = -1;
										for (const n in this.lists[e].roomIndexToRoomId) Number(n) > r && (r = Number(n));
										r < 0 || t > r || this.shiftRight(e, r + 1, t)
									}
									processListOps(e, t) {
										let r = -1;
										e.ops.forEach(e => {
											switch (e.op) {
												case "DELETE":
													i.logger.debug("DELETE", t, e.index, ";"), delete this.lists[t].roomIndexToRoomId[e.index], -1 !== r && this.removeEntry(t, r), r = e.index;
													break;
												case "INSERT":
													i.logger.debug("INSERT", t, e.index, e.room_id, ";"), this.lists[t].roomIndexToRoomId[e.index] && (r < 0 ? this.addEntry(t, e.index) : r > e.index ? this.shiftRight(t, r, e.index) : r < e.index && this.shiftLeft(t, e.index, r)), r = -1, this.lists[t].roomIndexToRoomId[e.index] = e.room_id;
													break;
												case "INVALIDATE":
													for (let r = e.range[0]; r <= e.range[1]; r++) delete this.lists[t].roomIndexToRoomId[r];
													i.logger.debug("INVALIDATE", t, e.range[0], e.range[1], ";");
													break;
												case "SYNC": {
													const r = e.range[0];
													for (let n = r; n <= e.range[1]; n++) {
														const i = e.room_ids[n - r];
														if (!i) break;
														this.lists[t].roomIndexToRoomId[n] = i
													}
													i.logger.debug("SYNC", t, e.range[0], e.range[1], (e.room_ids || []).join(" "), ";");
													break
												}
											}
										}), -1 !== r && this.removeEntry(t, r)
									}
									resend() {
										var e;
										if (this.needsResend && this.txnIdDefers.length > 0) return this.txnIdDefers[this.txnIdDefers.length - 1].promise;
										this.needsResend = !0, this.txnId = this.client.makeTxnId();
										const t = (0, s.defer)();
										return this.txnIdDefers.push(Object.assign(Object.assign({}, t), {
											txnId: this.txnId
										})), null === (e = this.abortController) || void 0 === e || e.abort(), this.abortController = new AbortController, t.promise
									}
									resolveTransactionDefers(e) {
										if (!e) return;
										let t = -1;
										for (let r = 0; r < this.txnIdDefers.length; r++)
											if (this.txnIdDefers[r].txnId === e) {
												t = r;
												break
											} if (-1 !== t) {
											for (let e = 0; e < t; e++) this.txnIdDefers[e].reject(this.txnIdDefers[e].txnId);
											this.txnIdDefers[t].resolve(e), this.txnIdDefers = this.txnIdDefers.slice(t + 1)
										} else i.logger.warn(`resolveTransactionDefers: seen ${e} but it isn't a pending txn, ignoring.`)
									}
									stop() {
										var e;
										this.terminated = !0, null === (e = this.abortController) || void 0 === e || e.abort(), this.removeAllListeners(u.Lifecycle), this.removeAllListeners(u.List), this.removeAllListeners(u.RoomData)
									}
									resetup() {
										var e;
										i.logger.warn("SlidingSync: resetting connection info"), this.txnIdDefers.forEach(e => {
											e.reject(e.txnId)
										}), this.txnIdDefers = [], this.lists.forEach(e => {
											e.setModified(!0)
										}), this.confirmedRoomSubscriptions = new Set, this.needsResend = !0, null === (e = this.abortController) || void 0 === e || e.abort(), this.abortController = new AbortController
									}
									start() {
										return n(this, void 0, void 0, (function*() {
											let e;
											for (this.abortController = new AbortController; !this.terminated;) {
												this.needsResend = !1;
												let r, n = !1;
												try {
													const t = this.listModifiedCount,
														o = {
															lists: this.lists.map(e => e.getList(!1)),
															pos: e,
															timeout: this.timeoutMS,
															clientTimeout: this.timeoutMS + a,
															extensions: this.getExtensionRequest(void 0 === e)
														},
														s = f(this.desiredRoomSubscriptions, this.confirmedRoomSubscriptions),
														l = f(this.confirmedRoomSubscriptions, this.desiredRoomSubscriptions);
													if (l.size > 0 && (o.unsubscribe_rooms = Array.from(l)), s.size > 0) {
														o.room_subscriptions = {};
														for (const e of s) {
															const t = this.roomIdToCustomSubscription.get(e);
															let r = this.roomSubscriptionInfo;
															t && this.customSubscriptions.has(t) && (r = this.customSubscriptions.get(t)), o.room_subscriptions[e] = r
														}
													}
													this.txnId && (o.txn_id = this.txnId, this.txnId = null), this.pendingReq = this.client.slidingSync(o, this.proxyBaseUrl, this.abortController.signal), e = (r = yield this.pendingReq).pos;
													for (const e of s) this.confirmedRoomSubscriptions.add(e);
													for (const e of l) this.confirmedRoomSubscriptions.delete(e);
													t !== this.listModifiedCount && (i.logger.debug("list modified during await call, not updating list"), n = !0), this.lists.forEach(e => {
														e.setModified(!1)
													}), r.lists = r.lists || [], r.rooms = r.rooms || {}, r.extensions = r.extensions || {}, r.lists.forEach((e, t) => {
														this.lists[t].joinedCount = e.count
													}), this.invokeLifecycleListeners(c.RequestFinished, r)
												} catch (t) {
													if (t.httpStatus) {
														if (this.invokeLifecycleListeners(c.RequestFinished, null, t), 400 === t.httpStatus) {
															this.resetup(), e = void 0, yield(0, s.sleep)(50);
															continue
														}
													} else if (this.needsResend || "AbortError" === t.name) continue;
													i.logger.error(t), yield(0, s.sleep)(5e3)
												}
												if (!r) continue;
												this.onPreExtensionsResponse(r.extensions), Object.keys(r.rooms).forEach(e => {
													this.invokeRoomDataListeners(e, r.rooms[e])
												});
												const o = new Set;
												n || r.lists.forEach((e, t) => {
													e.ops = e.ops || [], e.ops.length > 0 && o.add(t), this.processListOps(e, t)
												}), this.invokeLifecycleListeners(c.Complete, r), this.onPostExtensionsResponse(r.extensions), o.forEach(e => {
													this.emit(u.List, e, this.lists[e].joinedCount, Object.assign({}, this.lists[e].roomIndexToRoomId))
												}), this.resolveTransactionDefers(r.txn_id)
											}
										}))
									}
								}
								r.SlidingSync = h;
								const f = (e, t) => {
									const r = new Set(e);
									for (const n of t) r.delete(n);
									return r
								}
							}, {
								"./logger": 356,
								"./models/typed-event-emitter": 376,
								"./utils": 393
							}],
							385: [function(e, t, r) {
								"use strict";
								var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
										void 0 === n && (n = r);
										var i = Object.getOwnPropertyDescriptor(t, r);
										i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
											enumerable: !0,
											get: function() {
												return t[r]
											}
										}), Object.defineProperty(e, n, i)
									} : function(e, t, r, n) {
										void 0 === n && (n = r), e[n] = t[r]
									}),
									i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
										Object.defineProperty(e, "default", {
											enumerable: !0,
											value: t
										})
									} : function(e, t) {
										e.default = t
									}),
									o = this && this.__importStar || function(e) {
										if (e && e.__esModule) return e;
										var t = {};
										if (null != e)
											for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
										return i(t, e), t
									},
									s = this && this.__awaiter || function(e, t, r, n) {
										return new(r || (r = Promise))((function(i, o) {
											function s(e) {
												try {
													c(n.next(e))
												} catch (t) {
													o(t)
												}
											}

											function a(e) {
												try {
													c(n.throw(e))
												} catch (t) {
													o(t)
												}
											}

											function c(e) {
												var t;
												e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
													e(t)
												}))).then(s, a)
											}
											c((n = n.apply(e, t || [])).next())
										}))
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.LocalIndexedDBStoreBackend = void 0;
								const a = e("../sync-accumulator"),
									c = o(e("../utils")),
									l = o(e("../indexeddb-helpers")),
									u = e("../logger"),
									d = [e => {
										e.createObjectStore("users", {
											keyPath: ["userId"]
										}), e.createObjectStore("accountData", {
											keyPath: ["type"]
										}), e.createObjectStore("sync", {
											keyPath: ["clobber"]
										})
									}, e => {
										e.createObjectStore("oob_membership_events", {
											keyPath: ["room_id", "state_key"]
										}).createIndex("room", "room_id")
									}, e => {
										e.createObjectStore("client_options", {
											keyPath: ["clobber"]
										})
									}, e => {
										e.createObjectStore("to_device_queue", {
											autoIncrement: !0
										})
									}],
									h = d.length;

								function f(e, t, r) {
									const n = e.openCursor(t);
									return new Promise((e, t) => {
										const i = [];
										n.onerror = () => {
											t(new Error("Query failed: " + n.error))
										}, n.onsuccess = () => {
											const t = n.result;
											t ? (i.push(r(t)), t.continue()) : e(i)
										}
									})
								}

								function p(e) {
									return new Promise((t, r) => {
										e.oncomplete = function(e) {
											t(e)
										}, e.onerror = function() {
											r(e.error)
										}
									})
								}

								function v(e) {
									return new Promise((t, r) => {
										e.onsuccess = function(e) {
											t(e)
										}, e.onerror = function() {
											r(e.error)
										}
									})
								}

								function g(e) {
									return v(e).then(t => e.result)
								}
								r.LocalIndexedDBStoreBackend = class {
									constructor(e, t = "default") {
										this.indexedDB = e, this.disconnected = !0, this._isNewlyCreated = !1, this.isPersisting = !1, this.pendingUserPresenceData = [], this.dbName = "matrix-js-sdk:" + t, this.syncAccumulator = new a.SyncAccumulator
									}
									static exists(e, t) {
										return t = "matrix-js-sdk:" + (t || "default"), l.exists(e, t)
									}
									connect() {
										if (!this.disconnected) return u.logger.log("LocalIndexedDBStoreBackend.connect: already connected or connecting"), Promise.resolve();
										this.disconnected = !1, u.logger.log("LocalIndexedDBStoreBackend.connect: connecting...");
										const e = this.indexedDB.open(this.dbName, h);
										return e.onupgradeneeded = t => {
											const r = e.result,
												n = t.oldVersion;
											u.logger.log(`LocalIndexedDBStoreBackend.connect: upgrading from ${n}`), n < 1 && (this._isNewlyCreated = !0), d.forEach((e, t) => {
												n <= t && e(r)
											})
										}, e.onblocked = () => {
											u.logger.log("can't yet open LocalIndexedDBStoreBackend because it is open elsewhere")
										}, u.logger.log("LocalIndexedDBStoreBackend.connect: awaiting connection..."), v(e).then(() => (u.logger.log("LocalIndexedDBStoreBackend.connect: connected"), this.db = e.result, this.db.onversionchange = () => {
											var e;
											null === (e = this.db) || void 0 === e || e.close()
										}, this.init()))
									}
									isNewlyCreated() {
										return Promise.resolve(this._isNewlyCreated)
									}
									init() {
										return Promise.all([this.loadAccountData(), this.loadSyncData()]).then(([e, t]) => {
											u.logger.log("LocalIndexedDBStoreBackend: loaded initial data"), this.syncAccumulator.accumulate({
												next_batch: t.nextBatch,
												rooms: t.roomsData,
												account_data: {
													events: e
												}
											}, !0)
										})
									}
									getOutOfBandMembers(e) {
										return new Promise((t, r) => {
											const n = this.db.transaction(["oob_membership_events"], "readonly").objectStore("oob_membership_events").index("room"),
												i = IDBKeyRange.only(e),
												o = n.openCursor(i),
												s = [];
											let a = !1;
											o.onsuccess = () => {
												const e = o.result;
												if (!e) return s.length || a ? t(s) : t(null);
												const r = e.value;
												r.oob_written ? a = !0 : s.push(r), e.continue()
											}, o.onerror = e => {
												r(e)
											}
										}).then(t => (u.logger.log(`LL: got ${null==t?void 0:t.length} membershipEvents from storage for room ${e} ...`), t))
									}
									setOutOfBandMembers(e, t) {
										return s(this, void 0, void 0, (function*() {
											u.logger.log(`LL: backend about to store ${t.length}` + ` members for ${e}`);
											const r = this.db.transaction(["oob_membership_events"], "readwrite"),
												n = r.objectStore("oob_membership_events");
											t.forEach(e => {
												n.put(e)
											});
											const i = {
												room_id: e,
												oob_written: !0,
												state_key: 0
											};
											n.put(i), yield p(r), u.logger.log(`LL: backend done storing for ${e}!`)
										}))
									}
									clearOutOfBandMembers(e) {
										return s(this, void 0, void 0, (function*() {
											const t = this.db.transaction(["oob_membership_events"], "readonly").objectStore("oob_membership_events").index("room"),
												r = IDBKeyRange.only(e),
												n = g(t.openKeyCursor(r, "next")).then(e => e && e.primaryKey[1]),
												i = g(t.openKeyCursor(r, "prev")).then(e => e && e.primaryKey[1]),
												[o, s] = yield Promise.all([n, i]), a = this.db.transaction(["oob_membership_events"], "readwrite").objectStore("oob_membership_events"), c = IDBKeyRange.bound([e, o], [e, s]);
											var l;
											u.logger.log(`LL: Deleting all users + marker in storage for room ${e}, with key range:`, [e, o], [e, s]), yield(l = a.delete(c), new Promise((e, t) => {
												l.onsuccess = () => e(l), l.onerror = e => t(e)
											}))
										}))
									}
									clearDatabase() {
										return new Promise(e => {
											u.logger.log(`Removing indexeddb instance: ${this.dbName}`);
											const t = this.indexedDB.deleteDatabase(this.dbName);
											t.onblocked = () => {
												u.logger.log(`can't yet delete indexeddb ${this.dbName} because it is open elsewhere`)
											}, t.onerror = () => {
												u.logger.warn(`unable to delete js-sdk store indexeddb: ${t.error}`), e()
											}, t.onsuccess = () => {
												u.logger.log(`Removed indexeddb instance: ${this.dbName}`), e()
											}
										})
									}
									getSavedSync(e = !0) {
										const t = this.syncAccumulator.getJSON();
										return t.nextBatch ? e ? Promise.resolve(c.deepCopy(t)) : Promise.resolve(t) : Promise.resolve(null)
									}
									getNextBatchToken() {
										return Promise.resolve(this.syncAccumulator.getNextBatchToken())
									}
									setSyncData(e) {
										return Promise.resolve().then(() => {
											this.syncAccumulator.accumulate(e)
										})
									}
									syncToDatabase(e) {
										return s(this, void 0, void 0, (function*() {
											if (this.isPersisting) return u.logger.warn("Skipping syncToDatabase() as persist already in flight"), void this.pendingUserPresenceData.push(...e);
											e.unshift(...this.pendingUserPresenceData), this.isPersisting = !0;
											try {
												const t = this.syncAccumulator.getJSON(!0);
												yield Promise.all([this.persistUserPresenceEvents(e), this.persistAccountData(t.accountData), this.persistSyncData(t.nextBatch, t.roomsData)])
											} finally {
												this.isPersisting = !1
											}
										}))
									}
									persistSyncData(e, t) {
										return u.logger.log("Persisting sync data up to", e), c.promiseTry(() => {
											const r = this.db.transaction(["sync"], "readwrite");
											return r.objectStore("sync").put({
												clobber: "-",
												nextBatch: e,
												roomsData: t
											}), p(r).then(() => {
												u.logger.log("Persisted sync data up to", e)
											})
										})
									}
									persistAccountData(e) {
										return c.promiseTry(() => {
											const t = this.db.transaction(["accountData"], "readwrite"),
												r = t.objectStore("accountData");
											for (const n of e) r.put(n);
											return p(t).then()
										})
									}
									persistUserPresenceEvents(e) {
										return c.promiseTry(() => {
											const t = this.db.transaction(["users"], "readwrite"),
												r = t.objectStore("users");
											for (const n of e) r.put({
												userId: n[0],
												event: n[1]
											});
											return p(t).then()
										})
									}
									getUserPresenceEvents() {
										return c.promiseTry(() => {
											return f(this.db.transaction(["users"], "readonly").objectStore("users"), void 0, e => [e.value.userId, e.value.event])
										})
									}
									loadAccountData() {
										return u.logger.log("LocalIndexedDBStoreBackend: loading account data..."), c.promiseTry(() => {
											return f(this.db.transaction(["accountData"], "readonly").objectStore("accountData"), void 0, e => e.value).then(e => (u.logger.log("LocalIndexedDBStoreBackend: loaded account data"), e))
										})
									}
									loadSyncData() {
										return u.logger.log("LocalIndexedDBStoreBackend: loading sync data..."), c.promiseTry(() => {
											return f(this.db.transaction(["sync"], "readonly").objectStore("sync"), void 0, e => e.value).then(e => (u.logger.log("LocalIndexedDBStoreBackend: loaded sync data"), e.length > 1 && u.logger.warn("loadSyncData: More than 1 sync row found."), e.length > 0 ? e[0] : {}))
										})
									}
									getClientOptions() {
										return Promise.resolve().then(() => {
											return f(this.db.transaction(["client_options"], "readonly").objectStore("client_options"), void 0, e => {
												var t;
												return null === (t = e.value) || void 0 === t ? void 0 : t.options
											}).then(e => e[0])
										})
									}
									storeClientOptions(e) {
										return s(this, void 0, void 0, (function*() {
											const t = this.db.transaction(["client_options"], "readwrite");
											t.objectStore("client_options").put({
												clobber: "-",
												options: e
											}), yield p(t)
										}))
									}
									saveToDeviceBatches(e) {
										return s(this, void 0, void 0, (function*() {
											const t = this.db.transaction(["to_device_queue"], "readwrite"),
												r = t.objectStore("to_device_queue");
											for (const n of e) r.add(n);
											yield p(t)
										}))
									}
									getOldestToDeviceBatch() {
										return s(this, void 0, void 0, (function*() {
											const e = this.db.transaction(["to_device_queue"], "readonly").objectStore("to_device_queue"),
												t = yield g(e.openCursor());
											if (!t) return null;
											const r = t.value;
											return {
												id: t.key,
												txnId: r.txnId,
												eventType: r.eventType,
												batch: r.batch
											}
										}))
									}
									removeToDeviceBatch(e) {
										return s(this, void 0, void 0, (function*() {
											const t = this.db.transaction(["to_device_queue"], "readwrite");
											t.objectStore("to_device_queue").delete(e), yield p(t)
										}))
									}
								}
							}, {
								"../indexeddb-helpers": 354,
								"../logger": 356,
								"../sync-accumulator": 390,
								"../utils": 393
							}],
							386: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.RemoteIndexedDBStoreBackend = void 0;
								const i = e("../logger"),
									o = e("../utils");
								r.RemoteIndexedDBStoreBackend = class {
									constructor(e, t) {
										this.workerFactory = e, this.dbName = t, this.nextSeq = 0, this.inFlight = {}, this.onWorkerMessage = e => {
											const t = e.data;
											if ("cmd_success" == t.command || "cmd_fail" == t.command) {
												if (void 0 === t.seq) return void i.logger.error("Got reply from worker with no seq");
												const e = this.inFlight[t.seq];
												if (void 0 === e) return void i.logger.error("Got reply for unknown seq " + t.seq);
												if (delete this.inFlight[t.seq], "cmd_success" == t.command) e.resolve(t.result);
												else {
													const r = new Error(t.error.message);
													r.name = t.error.name, e.reject(r)
												}
											} else i.logger.warn("Unrecognised message from worker: ", t)
										}
									}
									connect() {
										return this.ensureStarted().then(() => this.doCmd("connect"))
									}
									clearDatabase() {
										return this.ensureStarted().then(() => this.doCmd("clearDatabase"))
									}
									isNewlyCreated() {
										return this.doCmd("isNewlyCreated")
									}
									getSavedSync() {
										return this.doCmd("getSavedSync")
									}
									getNextBatchToken() {
										return this.doCmd("getNextBatchToken")
									}
									setSyncData(e) {
										return this.doCmd("setSyncData", [e])
									}
									syncToDatabase(e) {
										return this.doCmd("syncToDatabase", [e])
									}
									getOutOfBandMembers(e) {
										return this.doCmd("getOutOfBandMembers", [e])
									}
									setOutOfBandMembers(e, t) {
										return this.doCmd("setOutOfBandMembers", [e, t])
									}
									clearOutOfBandMembers(e) {
										return this.doCmd("clearOutOfBandMembers", [e])
									}
									getClientOptions() {
										return this.doCmd("getClientOptions")
									}
									storeClientOptions(e) {
										return this.doCmd("storeClientOptions", [e])
									}
									getUserPresenceEvents() {
										return this.doCmd("getUserPresenceEvents")
									}
									saveToDeviceBatches(e) {
										return n(this, void 0, void 0, (function*() {
											return this.doCmd("saveToDeviceBatches", [e])
										}))
									}
									getOldestToDeviceBatch() {
										return n(this, void 0, void 0, (function*() {
											return this.doCmd("getOldestToDeviceBatch")
										}))
									}
									removeToDeviceBatch(e) {
										return n(this, void 0, void 0, (function*() {
											return this.doCmd("removeToDeviceBatch", [e])
										}))
									}
									ensureStarted() {
										return this.startPromise || (this.worker = this.workerFactory(), this.worker.onmessage = this.onWorkerMessage, this.startPromise = this.doCmd("setupWorker", [this.dbName]).then(() => {
											i.logger.log("IndexedDB worker is ready")
										})), this.startPromise
									}
									doCmd(e, t) {
										return Promise.resolve().then(() => {
											var r;
											const n = this.nextSeq++,
												i = (0, o.defer)();
											return this.inFlight[n] = i, null === (r = this.worker) || void 0 === r || r.postMessage({
												command: e,
												seq: n,
												args: t
											}), i.promise
										})
									}
								}
							}, {
								"../logger": 356,
								"../utils": 393
							}],
							387: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.IndexedDBStore = void 0;
								const i = e("./memory"),
									o = e("./indexeddb-local-backend"),
									s = e("./indexeddb-remote-backend"),
									a = e("../models/user"),
									c = e("../models/event"),
									l = e("../logger"),
									u = e("../models/typed-event-emitter"),
									d = 3e5;
								class h extends i.MemoryStore {
									constructor(e) {
										if (super(e), this.startedUp = !1, this.syncTs = 0, this.userModifiedMap = {}, this.emitter = new u.TypedEventEmitter, this.on = this.emitter.on.bind(this.emitter), this.getSavedSync = this.degradable(() => this.backend.getSavedSync(), "getSavedSync"), this.isNewlyCreated = this.degradable(() => this.backend.isNewlyCreated(), "isNewlyCreated"), this.getSavedSyncToken = this.degradable(() => this.backend.getNextBatchToken(), "getSavedSyncToken"), this.deleteAllData = this.degradable(() => (super.deleteAllData(), this.backend.clearDatabase().then(() => {
												l.logger.log("Deleted indexeddb data.")
											}, e => {
												throw l.logger.error(`Failed to delete indexeddb data: ${e}`), e
											}))), this.reallySave = this.degradable(() => {
												this.syncTs = Date.now();
												const e = [];
												for (const t of this.getUsers()) this.userModifiedMap[t.userId] !== t.getLastModifiedTime() && t.events.presence && (e.push([t.userId, t.events.presence.event]), this.userModifiedMap[t.userId] = t.getLastModifiedTime());
												return this.backend.syncToDatabase(e)
											}), this.setSyncData = this.degradable(e => this.backend.setSyncData(e), "setSyncData"), this.getOutOfBandMembers = this.degradable(e => this.backend.getOutOfBandMembers(e), "getOutOfBandMembers"), this.setOutOfBandMembers = this.degradable((e, t) => (super.setOutOfBandMembers(e, t), this.backend.setOutOfBandMembers(e, t)), "setOutOfBandMembers"), this.clearOutOfBandMembers = this.degradable(e => (super.clearOutOfBandMembers(e), this.backend.clearOutOfBandMembers(e)), "clearOutOfBandMembers"), this.getClientOptions = this.degradable(() => this.backend.getClientOptions(), "getClientOptions"), this.storeClientOptions = this.degradable(e => (super.storeClientOptions(e), this.backend.storeClientOptions(e)), "storeClientOptions"), !e.indexedDB) throw new Error("Missing required option: indexedDB");
										e.workerFactory ? this.backend = new s.RemoteIndexedDBStoreBackend(e.workerFactory, e.dbName) : this.backend = new o.LocalIndexedDBStoreBackend(e.indexedDB, e.dbName)
									}
									static exists(e, t) {
										return o.LocalIndexedDBStoreBackend.exists(e, t)
									}
									startup() {
										return this.startedUp ? (l.logger.log("IndexedDBStore.startup: already started"), Promise.resolve()) : (l.logger.log("IndexedDBStore.startup: connecting to backend"), this.backend.connect().then(() => (l.logger.log("IndexedDBStore.startup: loading presence events"), this.backend.getUserPresenceEvents())).then(e => {
											l.logger.log("IndexedDBStore.startup: processing presence events"), e.forEach(([e, t]) => {
												const r = new a.User(e);
												t && r.setPresenceEvent(new c.MatrixEvent(t)), this.userModifiedMap[r.userId] = r.getLastModifiedTime(), this.storeUser(r)
											})
										}))
									}
									wantsSave() {
										return Date.now() - this.syncTs > d
									}
									save(e = !1) {
										return e || this.wantsSave() ? this.reallySave() : Promise.resolve()
									}
									degradable(e, t) {
										const r = t ? super[t] : null;
										return (...t) => n(this, void 0, void 0, (function*() {
											try {
												return yield e.call(this, ...t)
											} catch (n) {
												l.logger.error("IndexedDBStore failure, degrading to MemoryStore", n), this.emitter.emit("degraded", n);
												try {
													l.logger.log("IndexedDBStore trying to delete degraded data"), yield this.backend.clearDatabase(), l.logger.log("IndexedDBStore delete after degrading succeeded")
												} catch (n) {
													l.logger.warn("IndexedDBStore delete after degrading failed", n)
												}
												if (r) return r.call(this, ...t)
											}
										}))
									}
									getPendingEvents(e) {
										const t = Object.create(null, {
											getPendingEvents: {
												get: () => super.getPendingEvents
											}
										});
										return n(this, void 0, void 0, (function*() {
											if (!this.localStorage) return t.getPendingEvents.call(this, e);
											const r = this.localStorage.getItem(f(e));
											if (r) try {
												return JSON.parse(r)
											} catch (n) {
												l.logger.error("Could not parse persisted pending events", n)
											}
											return []
										}))
									}
									setPendingEvents(e, t) {
										const r = Object.create(null, {
											setPendingEvents: {
												get: () => super.setPendingEvents
											}
										});
										return n(this, void 0, void 0, (function*() {
											if (!this.localStorage) return r.setPendingEvents.call(this, e, t);
											t.length > 0 ? this.localStorage.setItem(f(e), JSON.stringify(t)) : this.localStorage.removeItem(f(e))
										}))
									}
									saveToDeviceBatches(e) {
										return this.backend.saveToDeviceBatches(e)
									}
									getOldestToDeviceBatch() {
										return this.backend.getOldestToDeviceBatch()
									}
									removeToDeviceBatch(e) {
										return this.backend.removeToDeviceBatch(e)
									}
								}

								function f(e) {
									return `mx_pending_events_${e}`
								}
								r.IndexedDBStore = h
							}, {
								"../logger": 356,
								"../models/event": 365,
								"../models/typed-event-emitter": 376,
								"../models/user": 377,
								"./indexeddb-local-backend": 385,
								"./indexeddb-remote-backend": 386,
								"./memory": 388
							}],
							388: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.MemoryStore = void 0;
								const i = e("../models/user"),
									o = e("../models/room-state");

								function s(e) {
									return "string" == typeof e && !!e && "undefined" !== e && "null" !== e || "number" == typeof e
								}
								r.MemoryStore = class {
									constructor(e = {}) {
										this.rooms = {}, this.users = {}, this.syncToken = null, this.filters = {}, this.accountData = {}, this.oobMembers = {}, this.pendingEvents = {}, this.pendingToDeviceBatches = [], this.nextToDeviceBatchId = 0, this.onRoomMember = (e, t, r) => {
											if ("invite" === r.membership) return;
											const n = this.users[r.userId] || new i.User(r.userId);
											r.name && (n.setDisplayName(r.name), r.events.member && n.setRawDisplayName(r.events.member.getDirectionalContent().displayname)), r.events.member && r.events.member.getContent().avatar_url && n.setAvatarUrl(r.events.member.getContent().avatar_url), this.users[n.userId] = n
										}, this.localStorage = e.localStorage
									}
									getSyncToken() {
										return this.syncToken
									}
									isNewlyCreated() {
										return Promise.resolve(!0)
									}
									setSyncToken(e) {
										this.syncToken = e
									}
									storeRoom(e) {
										this.rooms[e.roomId] = e, e.currentState.on(o.RoomStateEvent.Members, this.onRoomMember), e.currentState.getMembers().forEach(t => {
											this.onRoomMember(null, e.currentState, t)
										})
									}
									getRoom(e) {
										return this.rooms[e] || null
									}
									getRooms() {
										return Object.values(this.rooms)
									}
									removeRoom(e) {
										this.rooms[e] && this.rooms[e].currentState.removeListener(o.RoomStateEvent.Members, this.onRoomMember), delete this.rooms[e]
									}
									getRoomSummaries() {
										return Object.values(this.rooms).map((function(e) {
											return e.summary
										}))
									}
									storeUser(e) {
										this.users[e.userId] = e
									}
									getUser(e) {
										return this.users[e] || null
									}
									getUsers() {
										return Object.values(this.users)
									}
									scrollback(e, t) {
										return []
									}
									storeEvents(e, t, r, n) {}
									storeFilter(e) {
										(null == e ? void 0 : e.userId) && (null == e ? void 0 : e.filterId) && (this.filters[e.userId] || (this.filters[e.userId] = {}), this.filters[e.userId][e.filterId] = e)
									}
									getFilter(e, t) {
										return this.filters[e] && this.filters[e][t] ? this.filters[e][t] : null
									}
									getFilterIdByName(e) {
										if (!this.localStorage) return null;
										const t = "mxjssdk_memory_filter_" + e;
										try {
											const e = this.localStorage.getItem(t);
											if (s(e)) return e
										} catch (r) {}
										return null
									}
									setFilterIdByName(e, t) {
										if (!this.localStorage) return;
										const r = "mxjssdk_memory_filter_" + e;
										try {
											s(t) ? this.localStorage.setItem(r, t) : this.localStorage.removeItem(r)
										} catch (n) {}
									}
									storeAccountDataEvents(e) {
										e.forEach(e => {
											this.accountData[e.getType()] = e
										})
									}
									getAccountData(e) {
										return this.accountData[e]
									}
									setSyncData(e) {
										return Promise.resolve()
									}
									wantsSave() {
										return !1
									}
									save(e) {}
									startup() {
										return Promise.resolve()
									}
									getSavedSync() {
										return Promise.resolve(null)
									}
									getSavedSyncToken() {
										return Promise.resolve(null)
									}
									deleteAllData() {
										return this.rooms = {}, this.users = {}, this.syncToken = null, this.filters = {}, this.accountData = {}, Promise.resolve()
									}
									getOutOfBandMembers(e) {
										return Promise.resolve(this.oobMembers[e] || null)
									}
									setOutOfBandMembers(e, t) {
										return this.oobMembers[e] = t, Promise.resolve()
									}
									clearOutOfBandMembers(e) {
										return this.oobMembers = {}, Promise.resolve()
									}
									getClientOptions() {
										return Promise.resolve(this.clientOptions)
									}
									storeClientOptions(e) {
										return this.clientOptions = Object.assign({}, e), Promise.resolve()
									}
									getPendingEvents(e) {
										var t;
										return n(this, void 0, void 0, (function*() {
											return null !== (t = this.pendingEvents[e]) && void 0 !== t ? t : []
										}))
									}
									setPendingEvents(e, t) {
										return n(this, void 0, void 0, (function*() {
											this.pendingEvents[e] = t
										}))
									}
									saveToDeviceBatches(e) {
										for (const t of e) this.pendingToDeviceBatches.push({
											id: this.nextToDeviceBatchId++,
											eventType: t.eventType,
											txnId: t.txnId,
											batch: t.batch
										});
										return Promise.resolve()
									}
									getOldestToDeviceBatch() {
										return n(this, void 0, void 0, (function*() {
											return 0 === this.pendingToDeviceBatches.length ? null : this.pendingToDeviceBatches[0]
										}))
									}
									removeToDeviceBatch(e) {
										return this.pendingToDeviceBatches = this.pendingToDeviceBatches.filter(t => t.id !== e), Promise.resolve()
									}
								}
							}, {
								"../models/room-state": 371,
								"../models/user": 377
							}],
							389: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.StubStore = void 0;
								r.StubStore = class {
									constructor() {
										this.accountData = {}, this.fromToken = null
									}
									isNewlyCreated() {
										return Promise.resolve(!0)
									}
									getSyncToken() {
										return this.fromToken
									}
									setSyncToken(e) {
										this.fromToken = e
									}
									storeRoom(e) {}
									getRoom(e) {
										return null
									}
									getRooms() {
										return []
									}
									removeRoom(e) {}
									getRoomSummaries() {
										return []
									}
									storeUser(e) {}
									getUser(e) {
										return null
									}
									getUsers() {
										return []
									}
									scrollback(e, t) {
										return []
									}
									storeEvents(e, t, r, n) {}
									storeFilter(e) {}
									getFilter(e, t) {
										return null
									}
									getFilterIdByName(e) {
										return null
									}
									setFilterIdByName(e, t) {}
									storeAccountDataEvents(e) {}
									getAccountData(e) {}
									setSyncData(e) {
										return Promise.resolve()
									}
									wantsSave() {
										return !1
									}
									save() {}
									startup() {
										return Promise.resolve()
									}
									getSavedSync() {
										return Promise.resolve(null)
									}
									getSavedSyncToken() {
										return Promise.resolve(null)
									}
									deleteAllData() {
										return Promise.resolve()
									}
									getOutOfBandMembers() {
										return Promise.resolve(null)
									}
									setOutOfBandMembers(e, t) {
										return Promise.resolve()
									}
									clearOutOfBandMembers() {
										return Promise.resolve()
									}
									getClientOptions() {
										return Promise.resolve(void 0)
									}
									storeClientOptions(e) {
										return Promise.resolve()
									}
									getPendingEvents(e) {
										return n(this, void 0, void 0, (function*() {
											return []
										}))
									}
									setPendingEvents(e, t) {
										return Promise.resolve()
									}
									saveToDeviceBatches(e) {
										return n(this, void 0, void 0, (function*() {
											return Promise.resolve()
										}))
									}
									getOldestToDeviceBatch() {
										return Promise.resolve(null)
									}
									removeToDeviceBatch(e) {
										return n(this, void 0, void 0, (function*() {
											return Promise.resolve()
										}))
									}
								}
							}, {}],
							390: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.SyncAccumulator = r.Category = void 0;
								const n = e("./logger"),
									i = e("./utils"),
									o = e("./@types/event"),
									s = e("./@types/sync");
								var a;
								! function(e) {
									e.Invite = "invite", e.Leave = "leave", e.Join = "join"
								}(a = r.Category || (r.Category = {}));

								function c(e, t) {
									null !== t.state_key && void 0 !== t.state_key && t.type && (e[t.type] || (e[t.type] = Object.create(null)), e[t.type][t.state_key] = t)
								}
								r.SyncAccumulator = class {
									constructor(e = {}) {
										this.opts = e, this.accountData = {}, this.inviteRooms = {}, this.joinRooms = {}, this.nextBatch = null, this.opts.maxTimelineEntries = this.opts.maxTimelineEntries || 50
									}
									accumulate(e, t = !1) {
										this.accumulateRooms(e, t), this.accumulateAccountData(e), this.nextBatch = e.next_batch
									}
									accumulateAccountData(e) {
										e.account_data && e.account_data.events && e.account_data.events.forEach(e => {
											this.accountData[e.type] = e
										})
									}
									accumulateRooms(e, t = !1) {
										e.rooms && (e.rooms.invite && Object.keys(e.rooms.invite).forEach(r => {
											this.accumulateRoom(r, a.Invite, e.rooms.invite[r], t)
										}), e.rooms.join && Object.keys(e.rooms.join).forEach(r => {
											this.accumulateRoom(r, a.Join, e.rooms.join[r], t)
										}), e.rooms.leave && Object.keys(e.rooms.leave).forEach(r => {
											this.accumulateRoom(r, a.Leave, e.rooms.leave[r], t)
										}))
									}
									accumulateRoom(e, t, r, i = !1) {
										switch (t) {
											case a.Invite:
												this.accumulateInviteState(e, r);
												break;
											case a.Join:
												this.inviteRooms[e] && delete this.inviteRooms[e], this.accumulateJoinState(e, r, i);
												break;
											case a.Leave:
												this.inviteRooms[e] ? delete this.inviteRooms[e] : delete this.joinRooms[e];
												break;
											default:
												n.logger.error("Unknown cateogory: ", t)
										}
									}
									accumulateInviteState(e, t) {
										if (!t.invite_state || !t.invite_state.events) return;
										if (!this.inviteRooms[e]) return void(this.inviteRooms[e] = {
											invite_state: t.invite_state
										});
										const r = this.inviteRooms[e];
										t.invite_state.events.forEach(e => {
											let t = !1;
											for (let n = 0; n < r.invite_state.events.length; n++) {
												const i = r.invite_state.events[n];
												i.type === e.type && i.state_key == e.state_key && (r.invite_state.events[n] = e, t = !0)
											}
											t || r.invite_state.events.push(e)
										})
									}
									accumulateJoinState(e, t, r = !1) {
										var n, a, l, u;
										this.joinRooms[e] || (this.joinRooms[e] = {
											_currentState: Object.create(null),
											_timeline: [],
											_accountData: Object.create(null),
											_unreadNotifications: {},
											_unreadThreadNotifications: {},
											_summary: {},
											_readReceipts: {}
										});
										const d = this.joinRooms[e];
										if (t.account_data && t.account_data.events && t.account_data.events.forEach(e => {
												d._accountData[e.type] = e
											}), t.unread_notifications && (d._unreadNotifications = t.unread_notifications), d._unreadThreadNotifications = null !== (a = null !== (n = t[s.UNREAD_THREAD_NOTIFICATIONS.stable]) && void 0 !== n ? n : t[s.UNREAD_THREAD_NOTIFICATIONS.unstable]) && void 0 !== a ? a : void 0, t.summary) {
											const e = "m.heroes",
												r = "m.invited_member_count",
												n = "m.joined_member_count",
												i = d._summary,
												o = t.summary;
											i[e] = o[e] || i[e], i[n] = o[n] || i[n], i[r] = o[r] || i[r]
										}
										if (null === (u = null === (l = t.ephemeral) || void 0 === l ? void 0 : l.events) || void 0 === u || u.forEach(e => {
												e.type === o.EventType.Receipt && e.content && Object.keys(e.content).forEach(t => {
													Object.entries(e.content[t]).forEach(([r, n]) => {
														(0, i.isSupportedReceiptType)(r) && Object.keys(n).forEach(n => {
															d._readReceipts[n] = {
																data: e.content[t][r][n],
																type: r,
																eventId: t
															}
														})
													})
												})
											}), t.timeline && t.timeline.limited && (d._timeline = []), t.state && t.state.events && t.state.events.forEach(e => {
												c(d._currentState, e)
											}), t.timeline && t.timeline.events && t.timeline.events.forEach((e, n) => {
												var i;
												let o;
												if (c(d._currentState, e), r) o = e;
												else {
													void 0 !== (o = Object.assign({}, e)).unsigned && (o.unsigned = Object.assign({}, o.unsigned));
													const t = e.unsigned ? e.unsigned.age : e.age;
													void 0 !== t && (o._localTs = Date.now() - t)
												}
												d._timeline.push({
													event: o,
													token: 0 === n && null !== (i = t.timeline.prev_batch) && void 0 !== i ? i : null
												})
											}), d._timeline.length > this.opts.maxTimelineEntries) {
											for (let e = d._timeline.length - this.opts.maxTimelineEntries; e < d._timeline.length; e++)
												if (d._timeline[e].token) {
													d._timeline = d._timeline.slice(e, d._timeline.length);
													break
												}
										}
									}
									getJSON(e = !1) {
										const t = {
											join: {},
											invite: {},
											leave: {}
										};
										Object.keys(this.inviteRooms).forEach(e => {
											t.invite[e] = this.inviteRooms[e]
										}), Object.keys(this.joinRooms).forEach(r => {
											const n = this.joinRooms[r],
												s = {
													ephemeral: {
														events: []
													},
													account_data: {
														events: []
													},
													state: {
														events: []
													},
													timeline: {
														events: [],
														prev_batch: null
													},
													unread_notifications: n._unreadNotifications,
													unread_thread_notifications: n._unreadThreadNotifications,
													summary: n._summary
												};
											Object.keys(n._accountData).forEach(e => {
												s.account_data.events.push(n._accountData[e])
											});
											const a = {
												type: o.EventType.Receipt,
												room_id: r,
												content: {}
											};
											Object.keys(n._readReceipts).forEach(e => {
												const t = n._readReceipts[e];
												a.content[t.eventId] || (a.content[t.eventId] = {}), a.content[t.eventId][t.type] || (a.content[t.eventId][t.type] = {}), a.content[t.eventId][t.type][e] = t.data
											}), Object.keys(a.content).length > 0 && s.ephemeral.events.push(a), n._timeline.forEach(t => {
												if (!s.timeline.prev_batch) {
													if (!t.token) return;
													s.timeline.prev_batch = t.token
												}
												let r;
												!e && t.event._localTs ? (void 0 !== (r = Object.assign({}, t.event)).unsigned && (r.unsigned = Object.assign({}, r.unsigned)), delete r._localTs, r.unsigned = r.unsigned || {}, r.unsigned.age = Date.now() - t.event._localTs) : r = t.event, s.timeline.events.push(r)
											});
											const l = Object.create(null);
											for (let e = s.timeline.events.length - 1; e >= 0; e--) {
												const t = s.timeline.events[e];
												if (null === t.state_key || void 0 === t.state_key) continue;
												const r = (0, i.deepCopy)(t);
												r.unsigned && (r.unsigned.prev_content && (r.content = r.unsigned.prev_content), r.unsigned.prev_sender && (r.sender = r.unsigned.prev_sender)), c(l, r)
											}
											Object.keys(n._currentState).forEach(e => {
												Object.keys(n._currentState[e]).forEach(t => {
													let r = n._currentState[e][t];
													l[e] && l[e][t] && (r = l[e][t]), s.state.events.push(r)
												})
											}), t.join[r] = s
										});
										const r = [];
										return Object.keys(this.accountData).forEach(e => {
											r.push(this.accountData[e])
										}), {
											nextBatch: this.nextBatch,
											roomsData: t,
											accountData: r
										}
									}
									getNextBatchToken() {
										return this.nextBatch
									}
								}
							}, {
								"./@types/event": 290,
								"./@types/sync": 297,
								"./logger": 356,
								"./utils": 393
							}],
							391: [function(t, r, n) {
								(function(e) {
									(function() {
										"use strict";
										var r = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
												void 0 === n && (n = r);
												var i = Object.getOwnPropertyDescriptor(t, r);
												i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
													enumerable: !0,
													get: function() {
														return t[r]
													}
												}), Object.defineProperty(e, n, i)
											} : function(e, t, r, n) {
												void 0 === n && (n = r), e[n] = t[r]
											}),
											i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
												Object.defineProperty(e, "default", {
													enumerable: !0,
													value: t
												})
											} : function(e, t) {
												e.default = t
											}),
											o = this && this.__importStar || function(e) {
												if (e && e.__esModule) return e;
												var t = {};
												if (null != e)
													for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);
												return i(t, e), t
											},
											s = this && this.__awaiter || function(e, t, r, n) {
												return new(r || (r = Promise))((function(i, o) {
													function s(e) {
														try {
															c(n.next(e))
														} catch (t) {
															o(t)
														}
													}

													function a(e) {
														try {
															c(n.throw(e))
														} catch (t) {
															o(t)
														}
													}

													function c(e) {
														var t;
														e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
															e(t)
														}))).then(s, a)
													}
													c((n = n.apply(e, t || [])).next())
												}))
											};
										Object.defineProperty(n, "__esModule", {
											value: !0
										}), n._createAndReEmitRoom = n.SyncApi = n.SyncState = void 0;
										const a = t("./models/user"),
											c = t("./models/room"),
											l = o(t("./utils")),
											u = t("./filter"),
											d = t("./models/event-timeline"),
											h = t("./pushprocessor"),
											f = t("./logger"),
											p = t("./errors"),
											v = t("./client"),
											g = t("./http-api"),
											m = t("./@types/event"),
											y = t("./models/room-state"),
											b = t("./models/room-member"),
											_ = t("./models/beacon"),
											w = t("./@types/sync"),
											S = t("./feature"),
											E = !0,
											k = 8e4,
											T = 3;
										var I;
										! function(e) {
											e.Error = "ERROR", e.Prepared = "PREPARED", e.Stopped = "STOPPED", e.Syncing = "SYNCING", e.Catchup = "CATCHUP", e.Reconnecting = "RECONNECTING"
										}(I = n.SyncState || (n.SyncState = {}));
										const R = ["org.matrix.msc2716v3"];

										function C(e, t) {
											return `FILTER_SYNC_${e}` + (t ? "_" + t : "")
										}

										function M(...e) {
											E && f.logger.log(...e)
										}
										var x;
										! function(e) {
											e.Offline = "offline", e.Online = "online", e.Unavailable = "unavailable"
										}(x || (x = {}));

										function O(e, t) {
											const r = new a.User(t);
											return e.reEmitter.reEmit(r, [a.UserEvent.AvatarUrl, a.UserEvent.DisplayName, a.UserEvent.Presence, a.UserEvent.CurrentlyActive, a.UserEvent.LastPresenceTs]), r
										}

										function A(e, t, r) {
											const {
												timelineSupport: n
											} = e, i = new c.Room(t, e, e.getUserId(), {
												lazyLoadMembers: r.lazyLoadMembers,
												pendingEventOrdering: r.pendingEventOrdering,
												timelineSupport: n
											});
											return e.reEmitter.reEmit(i, [c.RoomEvent.Name, c.RoomEvent.Redaction, c.RoomEvent.RedactionCancelled, c.RoomEvent.Receipt, c.RoomEvent.Tags, c.RoomEvent.LocalEchoUpdated, c.RoomEvent.AccountData, c.RoomEvent.MyMembership, c.RoomEvent.Timeline, c.RoomEvent.TimelineReset, y.RoomStateEvent.Events, y.RoomStateEvent.Members, y.RoomStateEvent.NewMember, y.RoomStateEvent.Update, _.BeaconEvent.New, _.BeaconEvent.Update, _.BeaconEvent.Destroy, _.BeaconEvent.LivenessChange]), i.on(y.RoomStateEvent.NewMember, (t, r, n) => {
												var i;
												n.user = null !== (i = e.getUser(n.userId)) && void 0 !== i ? i : void 0, e.reEmitter.reEmit(n, [b.RoomMemberEvent.Name, b.RoomMemberEvent.Typing, b.RoomMemberEvent.PowerLevel, b.RoomMemberEvent.Membership])
											}), i
										}
										n.SyncApi = class {
											constructor(e, t = {}) {
												var r;
												this.client = e, this.opts = t, this._peekRoom = null, this.syncState = null, this.catchingUp = !1, this.running = !1, this.notifEvents = [], this.failedSyncCount = 0, this.storeIsInvalid = !1, this.getPushRules = () => s(this, void 0, void 0, (function*() {
													try {
														M("Getting push rules...");
														const e = yield this.client.getPushRules();
														M("Got push rules"), this.client.pushRules = e
													} catch (e) {
														if (f.logger.error("Getting push rules failed", e), this.shouldAbortSync(e)) return;
														return M("Waiting for saved sync before retrying push rules..."), yield this.recoverFromSyncStartupError(this.savedSyncPromise, e), this.getPushRules()
													}
												})), this.buildDefaultFilter = () => {
													const e = new u.Filter(this.client.credentials.userId);
													return this.client.canSupport.get(S.Feature.ThreadUnreadNotifications) !== S.ServerSupport.Unsupported && e.setUnreadThreadNotifications(!0), e
												}, this.checkLazyLoadStatus = () => s(this, void 0, void 0, (function*() {
													var e;
													if (M("Checking lazy load status..."), this.opts.lazyLoadMembers && this.client.isGuest() && (this.opts.lazyLoadMembers = !1), this.opts.lazyLoadMembers) {
														M("Checking server lazy load support..."), (yield this.client.doesServerSupportLazyLoading()) ? (M("Enabling lazy load on sync filter..."), this.opts.filter || (this.opts.filter = this.buildDefaultFilter()), this.opts.filter.setLazyLoadMembers(!0)) : (M("LL: lazy loading requested but not supported by server, so disabling"), this.opts.lazyLoadMembers = !1)
													}
													if (M("Checking whether lazy loading has changed in store..."), yield this.wasLazyLoadingToggled(this.opts.lazyLoadMembers)) {
														this.storeIsInvalid = !0;
														const e = new p.InvalidStoreError(p.InvalidStoreState.ToggledLazyLoading, !!this.opts.lazyLoadMembers);
														return this.updateSyncState(I.Error, {
															error: e
														}), void f.logger.warn("InvalidStoreError: store is not usable: stopping sync.")
													}
													this.opts.lazyLoadMembers && (null === (e = this.opts.crypto) || void 0 === e || e.enableLazyLoading());
													try {
														M("Storing client options..."), yield this.client.storeClientOptions(), M("Stored client options")
													} catch (t) {
														throw f.logger.error("Storing client options failed", t), t
													}
												})), this.getFilter = () => s(this, void 0, void 0, (function*() {
													let e, t;
													M("Getting filter..."), e = this.opts.filter ? this.opts.filter : this.buildDefaultFilter();
													try {
														t = yield this.client.getOrCreateFilter(C(this.client.credentials.userId), e)
													} catch (r) {
														return f.logger.error("Getting filter failed", r), this.shouldAbortSync(r) ? {} : (M("Waiting for saved sync before retrying filter..."), yield this.recoverFromSyncStartupError(this.savedSyncPromise, r), this.getFilter())
													}
													return {
														filter: e,
														filterId: t
													}
												})), this.onOnline = () => {
													M("Browser thinks we are back online"), this.startKeepAlives(0)
												}, this.opts.initialSyncLimit = null !== (r = this.opts.initialSyncLimit) && void 0 !== r ? r : 8, this.opts.resolveInvitesToProfiles = this.opts.resolveInvitesToProfiles || !1, this.opts.pollTimeout = this.opts.pollTimeout || 3e4, this.opts.pendingEventOrdering = this.opts.pendingEventOrdering || v.PendingEventOrdering.Chronological, this.opts.experimentalThreadSupport = !0 === this.opts.experimentalThreadSupport, t.canResetEntireTimeline || (t.canResetEntireTimeline = e => !1), e.getNotifTimelineSet() && e.reEmitter.reEmit(e.getNotifTimelineSet(), [c.RoomEvent.Timeline, c.RoomEvent.TimelineReset])
											}
											createRoom(e) {
												const t = A(this.client, e, this.opts);
												return t.on(y.RoomStateEvent.Marker, (e, r) => {
													this.onMarkerStateEvent(t, e, r)
												}), t
											}
											onMarkerStateEvent(e, t, {
												timelineWasEmpty: r
											} = {}) {
												if (r) return void f.logger.debug(`MarkerState: Ignoring markerEventId=${t.getId()} in roomId=${e.roomId} ` + "because the timeline was empty before the marker arrived which means there is nothing to refresh.");
												R.includes(e.getVersion()) || t.getSender() === e.getCreator() ? (f.logger.debug("MarkerState: Timeline needs to be refreshed because " + `a new markerEventId=${t.getId()} was sent in roomId=${e.roomId}`), e.setTimelineNeedsRefresh(!0), e.emit(c.RoomEvent.HistoryImportedWithinTimeline, t, e)) : f.logger.debug(`MarkerState: Ignoring markerEventId=${t.getId()} in roomId=${e.roomId} because ` + "MSC2716 is not supported in the room version or for any room version, the marker wasn't sent by the room creator.")
											}
											syncLeftRooms() {
												var e;
												return s(this, void 0, void 0, (function*() {
													const t = this.client,
														r = new u.Filter(this.client.credentials.userId);
													r.setTimelineLimit(1), r.setIncludeLeaveRooms(!0);
													const n = this.opts.pollTimeout + k,
														i = {
															timeout: 0,
															filter: yield t.getOrCreateFilter(C(t.credentials.userId, "LEFT_ROOMS"), r)
														},
														o = yield t.http.authedRequest(g.Method.Get, "/sync", i, void 0, {
															localTimeoutMs: n
														});
													let a = [];
													return (null === (e = o.rooms) || void 0 === e ? void 0 : e.leave) && (a = this.mapSyncResponseToRoomArray(o.rooms.leave)), (yield Promise.all(a.map(e => s(this, void 0, void 0, (function*() {
														const r = e.room;
														if (!e.isBrandNewRoom) return;
														e.timeline = e.timeline || {
															prev_batch: null,
															events: []
														};
														const n = this.mapSyncEventsFormat(e.timeline, r),
															i = this.mapSyncEventsFormat(e.state, r);
														return r.getLiveTimeline().setPaginationToken(e.timeline.prev_batch, d.EventTimeline.BACKWARDS), yield this.injectRoomEvents(r, i, n), r.recalculate(), t.store.storeRoom(r), t.emit(v.ClientEvent.Room, r), this.processEventsForNotifs(r, n), r
													}))))).filter(Boolean)
												}))
											}
											peek(e) {
												var t;
												if ((null === (t = this._peekRoom) || void 0 === t ? void 0 : t.roomId) === e) return Promise.resolve(this._peekRoom);
												const r = this.client;
												return this._peekRoom = this.createRoom(e), this.client.roomInitialSync(e, 20).then(e => {
													e.messages = e.messages || {
														chunk: []
													}, e.messages.chunk = e.messages.chunk || [], e.state = e.state || [];
													const t = l.deepCopy(e.state).map(r.getEventMapper()),
														n = e.state.map(r.getEventMapper()),
														i = e.messages.chunk.map(r.getEventMapper());
													return Array.isArray(e.presence) && e.presence.map(r.getEventMapper()).forEach((function(e) {
														let t = r.store.getUser(e.getContent().user_id);
														t ? t.setPresenceEvent(e) : ((t = O(r, e.getContent().user_id)).setPresenceEvent(e), r.store.storeUser(t)), r.emit(v.ClientEvent.Event, e)
													})), e.messages.start && (this._peekRoom.oldState.paginationToken = e.messages.start), this._peekRoom.oldState.setStateEvents(t), this._peekRoom.currentState.setStateEvents(n), this.resolveInvites(this._peekRoom), this._peekRoom.recalculate(), this._peekRoom.addEventsToTimeline(i.reverse(), !0, this._peekRoom.getLiveTimeline(), e.messages.start), r.store.storeRoom(this._peekRoom), r.emit(v.ClientEvent.Room, this._peekRoom), this.peekPoll(this._peekRoom), this._peekRoom
												})
											}
											stopPeeking() {
												this._peekRoom = null
											}
											peekPoll(e, t) {
												var r;
												this._peekRoom === e ? this.client.http.authedRequest(g.Method.Get, "/events", {
													room_id: e.roomId,
													timeout: String(3e4),
													from: t
												}, void 0, {
													localTimeoutMs: 5e4,
													abortSignal: null === (r = this.abortController) || void 0 === r ? void 0 : r.signal
												}).then(t => {
													if (this._peekRoom !== e) return void M("Stopped peeking in room %s", e.roomId);
													t.chunk.filter((function(e) {
														return "m.presence" === e.type
													})).map(this.client.getEventMapper()).forEach(e => {
														let t = this.client.store.getUser(e.getContent().user_id);
														t ? t.setPresenceEvent(e) : ((t = O(this.client, e.getContent().user_id)).setPresenceEvent(e), this.client.store.storeUser(t)), this.client.emit(v.ClientEvent.Event, e)
													});
													const r = t.chunk.filter((function(t) {
														return t.room_id === e.roomId && t.event_id
													})).map(this.client.getEventMapper());
													e.addLiveEvents(r), this.peekPoll(e, t.end)
												}, r => {
													f.logger.error("[%s] Peek poll failed: %s", e.roomId, r), setTimeout(() => {
														this.peekPoll(e, t)
													}, 3e4)
												}) : M("Stopped peeking in room %s", e.roomId)
											}
											getSyncState() {
												return this.syncState
											}
											getSyncStateData() {
												var e;
												return null !== (e = this.syncStateData) && void 0 !== e ? e : null
											}
											recoverFromSyncStartupError(e, t) {
												return s(this, void 0, void 0, (function*() {
													yield e;
													const r = this.startKeepAlives();
													this.updateSyncState(I.Error, {
														error: t
													}), yield r
												}))
											}
											wasLazyLoadingToggled(e = !1) {
												return s(this, void 0, void 0, (function*() {
													let t = !1;
													if (!(yield this.client.store.isNewlyCreated())) {
														const r = yield this.client.store.getClientOptions();
														return r && (t = !!r.lazyLoadMembers), t !== e
													}
													return !1
												}))
											}
											shouldAbortSync(e) {
												return "M_UNKNOWN_TOKEN" === e.errcode && (f.logger.warn("Token no longer valid - assuming logout"), this.stop(), this.updateSyncState(I.Error, {
													error: e
												}), !0)
											}
											sync() {
												var t, r;
												return s(this, void 0, void 0, (function*() {
													if (this.running = !0, this.abortController = new AbortController, null === (r = null === (t = e.window) || void 0 === t ? void 0 : t.addEventListener) || void 0 === r || r.call(t, "online", this.onOnline, !1), this.client.isGuest()) return this.doSync({});
													M("Getting saved sync token...");
													const n = this.client.store.getSavedSyncToken().then(e => (M("Got saved sync token"), e));
													this.savedSyncPromise = this.client.store.getSavedSync().then(e => {
														if (M(`Got reply from saved sync, exists? ${!!e}`), e) return this.syncFromCache(e)
													}).catch(e => {
														f.logger.error("Getting saved sync failed", e)
													}), yield this.getPushRules(), yield this.checkLazyLoadStatus();
													const {
														filterId: i,
														filter: o
													} = yield this.getFilter();
													if (o) {
														if (this.client.resetNotifTimelineSet(), !this.currentSyncRequest) {
															let e = i;
															const t = yield n;
															if (t) M("Sending first sync request...");
															else {
																M("Sending initial sync request...");
																const t = this.buildDefaultFilter();
																t.setDefinition(o.getDefinition()), t.setTimelineLimit(this.opts.initialSyncLimit), e = JSON.stringify(t.getDefinition())
															}
															this.currentSyncRequest = this.doSyncRequest({
																filter: e
															}, t)
														}
														return M("Waiting for saved sync before starting sync processing..."), yield this.savedSyncPromise, this.doSync({
															filter: i
														})
													}
												}))
											}
											stop() {
												var t, r, n;
												M("SyncApi.stop"), null === (r = null === (t = e.window) || void 0 === t ? void 0 : t.removeEventListener) || void 0 === r || r.call(t, "online", this.onOnline, !1), this.running = !1, null === (n = this.abortController) || void 0 === n || n.abort(), this.keepAliveTimer && (clearTimeout(this.keepAliveTimer), this.keepAliveTimer = void 0)
											}
											retryImmediately() {
												return !!this.connectionReturnedDefer && (this.startKeepAlives(0), !0)
											}
											syncFromCache(e) {
												return s(this, void 0, void 0, (function*() {
													M("sync(): not doing HTTP hit, instead returning stored /sync data");
													const t = e.nextBatch;
													this.client.store.setSyncToken(t);
													const r = {
															nextSyncToken: t,
															catchingUp: !1,
															fromCache: !0
														},
														n = {
															next_batch: t,
															rooms: e.roomsData,
															account_data: {
																events: e.accountData
															}
														};
													try {
														yield this.processSyncResponse(r, n)
													} catch (i) {
														f.logger.error("Error processing cached sync", i)
													}
													this.storeIsInvalid || this.updateSyncState(I.Prepared, r)
												}))
											}
											doSync(e) {
												return s(this, void 0, void 0, (function*() {
													for (; this.running;) {
														const r = this.client.store.getSyncToken();
														let n;
														try {
															this.currentSyncRequest || (this.currentSyncRequest = this.doSyncRequest(e, r)), n = yield this.currentSyncRequest
														} catch (t) {
															if (yield this.onSyncError(t)) return;
															continue
														} finally {
															this.currentSyncRequest = void 0
														}
														this.client.store.setSyncToken(n.next_batch), this.failedSyncCount = 0, yield this.client.store.setSyncData(n);
														const i = {
															oldSyncToken: null != r ? r : void 0,
															nextSyncToken: n.next_batch,
															catchingUp: this.catchingUp
														};
														this.opts.crypto && (yield this.opts.crypto.onSyncWillProcess(i));
														try {
															yield this.processSyncResponse(i, n)
														} catch (t) {
															f.logger.error("Caught /sync error", t), this.client.emit(v.ClientEvent.SyncUnexpectedError, t)
														}
														i.catchingUp = this.catchingUp, e.hasSyncedBefore || (this.updateSyncState(I.Prepared, i), e.hasSyncedBefore = !0), this.opts.crypto && (yield this.opts.crypto.onSyncCompleted(i)), this.updateSyncState(I.Syncing, i), this.client.store.wantsSave() && (this.opts.crypto && (yield this.opts.crypto.saveDeviceList(0)), this.client.store.save())
													}
													this.running || (M("Sync no longer running: exiting."), this.connectionReturnedDefer && (this.connectionReturnedDefer.reject(), this.connectionReturnedDefer = void 0), this.updateSyncState(I.Stopped))
												}))
											}
											doSyncRequest(e, t) {
												var r;
												const n = this.getSyncParams(e, t);
												return this.client.http.authedRequest(g.Method.Get, "/sync", n, void 0, {
													localTimeoutMs: n.timeout + k,
													abortSignal: null === (r = this.abortController) || void 0 === r ? void 0 : r.signal
												})
											}
											getSyncParams(e, t) {
												let r = this.opts.pollTimeout;
												(this.getSyncState() !== I.Syncing || this.catchingUp) && (this.catchingUp = !0, r = 0);
												let n = e.filter;
												this.client.isGuest() && !n && (n = this.getGuestFilter());
												const i = {
													filter: n,
													timeout: r
												};
												return this.opts.disablePresence && (i.set_presence = x.Offline), t ? i.since = t : i._cacheBuster = Date.now(), [I.Reconnecting, I.Error].includes(this.getSyncState()) && (i.timeout = 0), i
											}
											onSyncError(e) {
												return s(this, void 0, void 0, (function*() {
													if (!this.running) return M("Sync no longer running: exiting"), this.connectionReturnedDefer && (this.connectionReturnedDefer.reject(), this.connectionReturnedDefer = void 0), this.updateSyncState(I.Stopped), !0;
													if (f.logger.error("/sync error %s", e), this.shouldAbortSync(e)) return !0;
													this.failedSyncCount++, f.logger.log("Number of consecutive failed sync requests:", this.failedSyncCount), M("Starting keep-alive");
													const t = this.startKeepAlives();
													return this.currentSyncRequest = void 0, this.updateSyncState(this.failedSyncCount >= T ? I.Error : I.Reconnecting, {
														error: e
													}), (yield t) && this.getSyncState() === I.Error && this.updateSyncState(I.Catchup, {
														catchingUp: !0
													}), !1
												}))
											}
											processSyncResponse(e, t) {
												var r, n, i;
												return s(this, void 0, void 0, (function*() {
													const o = this.client;
													if (Array.isArray(null === (r = t.presence) || void 0 === r ? void 0 : r.events) && t.presence.events.map(o.getEventMapper()).forEach((function(e) {
															let t = o.store.getUser(e.getSender());
															t ? t.setPresenceEvent(e) : ((t = O(o, e.getSender())).setPresenceEvent(e), o.store.storeUser(t)), o.emit(v.ClientEvent.Event, e)
														})), Array.isArray(null === (n = t.account_data) || void 0 === n ? void 0 : n.events)) {
														const e = t.account_data.events.map(o.getEventMapper()),
															r = e.reduce((e, t) => (e[t.getType()] = o.store.getAccountData(t.getType()), e), {});
														o.store.storeAccountDataEvents(e), e.forEach((function(e) {
															if (e.getType() === m.EventType.PushRules) {
																const t = e.getContent();
																o.pushRules = h.PushProcessor.rewriteDefaultRules(t)
															}
															const t = r[e.getType()];
															return o.emit(v.ClientEvent.AccountData, e, t), e
														}))
													}
													if (Array.isArray(null === (i = t.to_device) || void 0 === i ? void 0 : i.events) && t.to_device.events.length > 0) {
														const e = [];
														t.to_device.events.filter(e => {
															var t;
															return !(e.type === m.EventType.RoomMessageEncrypted && !["m.olm.v1.curve25519-aes-sha2"].includes(null === (t = e.content) || void 0 === t ? void 0 : t.algorithm)) || (f.logger.log("Ignoring invalid encrypted to-device event from " + e.sender), !1)
														}).map(o.getEventMapper({
															toDevice: !0
														})).map(t => {
															if ("m.key.verification.cancel" === t.getType()) {
																const r = t.getContent().transaction_id;
																r && e.push(r)
															}
															return t
														}).forEach((function(t) {
															const r = t.getContent();
															if ("m.room.message" != t.getType() || "m.bad.encrypted" != r.msgtype) {
																if ("m.key.verification.start" === t.getType() || "m.key.verification.request" === t.getType()) {
																	const n = r.transaction_id;
																	e.includes(n) && t.flagCancelled()
																}
																o.emit(v.ClientEvent.ToDeviceEvent, t)
															} else f.logger.log("Ignoring undecryptable to-device event from " + t.getSender())
														}))
													} else this.catchingUp = !1;
													let a = [],
														u = [],
														p = [];
													if (t.rooms && (t.rooms.invite && (a = this.mapSyncResponseToRoomArray(t.rooms.invite)), t.rooms.join && (u = this.mapSyncResponseToRoomArray(t.rooms.join)), t.rooms.leave && (p = this.mapSyncResponseToRoomArray(t.rooms.leave))), this.notifEvents = [], yield l.promiseMapSeries(a, e => s(this, void 0, void 0, (function*() {
															var t;
															const r = e.room,
																n = this.mapSyncEventsFormat(e.invite_state, r);
															yield this.injectRoomEvents(r, n);
															const i = null === (t = r.currentState.getStateEvents(m.EventType.RoomMember, o.getUserId())) || void 0 === t ? void 0 : t.getSender();
															if (o.isCryptoEnabled()) {
																const e = yield o.crypto.cryptoStore.takeParkedSharedHistory(r.roomId);
																for (const t of e) t.senderId === i && (yield o.crypto.olmDevice.addInboundGroupSession(r.roomId, t.senderKey, t.forwardingCurve25519KeyChain, t.sessionId, t.sessionKey, t.keysClaimed, !0, {
																	sharedHistory: !0,
																	untrusted: !0
																}))
															}
															e.isBrandNewRoom ? (r.recalculate(), o.store.storeRoom(r), o.emit(v.ClientEvent.Room, r)) : r.recalculate(), n.forEach((function(e) {
																o.emit(v.ClientEvent.Event, e)
															}))
														}))), yield l.promiseMapSeries(u, t => s(this, void 0, void 0, (function*() {
															var r, n, i, a, u, h;
															const p = t.room,
																g = this.mapSyncEventsFormat(t.state, p),
																m = this.mapSyncEventsFormat(t.timeline, p, !1),
																y = this.mapSyncEventsFormat(t.ephemeral),
																b = this.mapSyncEventsFormat(t.account_data),
																_ = o.isRoomEncrypted(p.roomId);
															t.unread_notifications && (p.setUnreadNotificationCount(c.NotificationCountType.Total, null !== (r = t.unread_notifications.notification_count) && void 0 !== r ? r : 0), (!_ || p.getUnreadNotificationCount(c.NotificationCountType.Highlight) <= 0) && p.setUnreadNotificationCount(c.NotificationCountType.Highlight, null !== (n = t.unread_notifications.highlight_count) && void 0 !== n ? n : 0));
															const S = null !== (i = t[w.UNREAD_THREAD_NOTIFICATIONS.name]) && void 0 !== i ? i : t[w.UNREAD_THREAD_NOTIFICATIONS.altName];
															if (S) {
																p.resetThreadUnreadNotificationCount(Object.keys(S));
																for (const [e, t] of Object.entries(S)) {
																	p.setThreadUnreadNotificationCount(e, c.NotificationCountType.Total, null !== (a = t.notification_count) && void 0 !== a ? a : 0);
																	const r = p.getThreadUnreadNotificationCount(e, c.NotificationCountType.Highlight) <= 0;
																	(!_ || _ && r) && p.setThreadUnreadNotificationCount(e, c.NotificationCountType.Highlight, null !== (u = t.highlight_count) && void 0 !== u ? u : 0)
																}
															} else p.resetThreadUnreadNotificationCount();
															if (t.timeline = t.timeline || {}, t.isBrandNewRoom) null !== t.timeline.prev_batch && p.getLiveTimeline().setPaginationToken(t.timeline.prev_batch, d.EventTimeline.BACKWARDS);
															else if (t.timeline.limited) {
																let r = !0;
																for (let e = m.length - 1; e >= 0; e--) {
																	const t = m[e].getId();
																	if (p.getTimelineForEvent(t)) {
																		M(`Already have event ${t} in limited sync - not resetting`), r = !1, m.splice(0, e);
																		break
																	}
																}
																r && (p.resetLiveTimeline(t.timeline.prev_batch, this.opts.canResetEntireTimeline(p.roomId) ? null : null !== (h = e.oldSyncToken) && void 0 !== h ? h : null), o.resetNotifTimelineSet())
															}
															try {
																yield this.injectRoomEvents(p, g, m, e.fromCache)
															} catch (k) {
																f.logger.error(`Failed to process events on room ${p.roomId}:`, k)
															}
															t.summary && p.setSummary(t.summary), p.addEphemeralEvents(y), p.addAccountData(b), p.recalculate(), t.isBrandNewRoom && (o.store.storeRoom(p), o.emit(v.ClientEvent.Room, p)), this.processEventsForNotifs(p, m);
															const E = e => s(this, void 0, void 0, (function*() {
																o.emit(v.ClientEvent.Event, e), e.isState() && "m.room.encryption" == e.getType() && this.opts.crypto && (yield this.opts.crypto.onCryptoEvent(e))
															}));
															yield l.promiseMapSeries(g, E), yield l.promiseMapSeries(m, E), y.forEach((function(e) {
																o.emit(v.ClientEvent.Event, e)
															})), b.forEach((function(e) {
																o.emit(v.ClientEvent.Event, e)
															})), p.decryptCriticalEvents()
														}))), yield l.promiseMapSeries(p, e => s(this, void 0, void 0, (function*() {
															const t = e.room,
																r = this.mapSyncEventsFormat(e.state, t),
																n = this.mapSyncEventsFormat(e.timeline, t),
																i = this.mapSyncEventsFormat(e.account_data);
															yield this.injectRoomEvents(t, r, n), t.addAccountData(i), t.recalculate(), e.isBrandNewRoom && (o.store.storeRoom(t), o.emit(v.ClientEvent.Room, t)), this.processEventsForNotifs(t, n), r.forEach((function(e) {
																o.emit(v.ClientEvent.Event, e)
															})), n.forEach((function(e) {
																o.emit(v.ClientEvent.Event, e)
															})), i.forEach((function(e) {
																o.emit(v.ClientEvent.Event, e)
															}))
														}))), e.oldSyncToken && this.notifEvents.length && (this.notifEvents.sort((function(e, t) {
															return e.getTs() - t.getTs()
														})), this.notifEvents.forEach((function(e) {
															var t;
															null === (t = o.getNotifTimelineSet()) || void 0 === t || t.addLiveEvent(e)
														}))), t.device_lists && this.opts.crypto && (yield this.opts.crypto.handleDeviceListChanges(e, t.device_lists)), this.opts.crypto && t.device_one_time_keys_count) {
														const e = t.device_one_time_keys_count.signed_curve25519 || 0;
														this.opts.crypto.updateOneTimeKeyCount(e)
													}
													if (this.opts.crypto && (t.device_unused_fallback_key_types || t["org.matrix.msc2732.device_unused_fallback_key_types"])) {
														const e = t.device_unused_fallback_key_types || t["org.matrix.msc2732.device_unused_fallback_key_types"];
														this.opts.crypto.setNeedsNewFallback(Array.isArray(e) && !e.includes("signed_curve25519"))
													}
												}))
											}
											startKeepAlives(e) {
												return void 0 === e && (e = 2e3 + Math.floor(5e3 * Math.random())), null !== this.keepAliveTimer && clearTimeout(this.keepAliveTimer), e > 0 ? this.keepAliveTimer = setTimeout(this.pokeKeepAlive.bind(this), e) : this.pokeKeepAlive(), this.connectionReturnedDefer || (this.connectionReturnedDefer = l.defer()), this.connectionReturnedDefer.promise
											}
											pokeKeepAlive(e = !1) {
												var t;
												const r = () => {
													clearTimeout(this.keepAliveTimer), this.connectionReturnedDefer && (this.connectionReturnedDefer.resolve(e), this.connectionReturnedDefer = void 0)
												};
												this.client.http.request(g.Method.Get, "/_matrix/client/versions", void 0, void 0, {
													prefix: "",
													localTimeoutMs: 15e3,
													abortSignal: null === (t = this.abortController) || void 0 === t ? void 0 : t.signal
												}).then(() => {
													r()
												}, t => {
													400 == t.httpStatus || 404 == t.httpStatus ? this.keepAliveTimer = setTimeout(r, 2e3) : (e = !0, this.keepAliveTimer = setTimeout(this.pokeKeepAlive.bind(this, e), 5e3 + Math.floor(5e3 * Math.random())), this.updateSyncState(I.Error, {
														error: t
													}))
												})
											}
											mapSyncResponseToRoomArray(e) {
												const t = this.client;
												return Object.keys(e).map(r => {
													const n = e[r];
													let i = t.store.getRoom(r),
														o = !1;
													return i || (i = this.createRoom(r), o = !0), n.room = i, n.isBrandNewRoom = o, n
												})
											}
											mapSyncEventsFormat(e, t, r = !0) {
												if (!e || !Array.isArray(e.events)) return [];
												const n = this.client.getEventMapper({
													decrypt: r
												});
												return e.events.map((function(e) {
													return t && (e.room_id = t.roomId), n(e)
												}))
											}
											resolveInvites(e) {
												if (!e || !this.opts.resolveInvitesToProfiles) return;
												const t = this.client;
												e.getMembersWithMembership("invite").forEach((function(r) {
													if (r.requestedProfileInfo) return;
													r.requestedProfileInfo = !0;
													const n = t.getUser(r.userId);
													let i;
													(i = n ? Promise.resolve({
														avatar_url: n.avatarUrl,
														displayname: n.displayName
													}) : t.getProfileInfo(r.userId)).then((function(t) {
														const n = r.events.member;
														"invite" === (null == n ? void 0 : n.getContent().membership) && (n.getContent().avatar_url = t.avatar_url, n.getContent().displayname = t.displayname, r.setMembershipEvent(n, e.currentState))
													}), (function(e) {}))
												}))
											}
											injectRoomEvents(e, t, r, n = !1) {
												return s(this, void 0, void 0, (function*() {
													const i = e.getLiveTimeline(),
														o = 0 == i.getEvents().length;
													if (o) {
														for (const e of t) this.client.getPushActionsForEvent(e);
														i.initialiseState(t, {
															timelineWasEmpty: o
														})
													}
													this.resolveInvites(e), e.recalculate(), o || (e.oldState.setStateEvents(t || []), e.currentState.setStateEvents(t || [])), e.addLiveEvents(r || [], {
														fromCache: n,
														timelineWasEmpty: o
													}), this.client.processBeaconEvents(e, r)
												}))
											}
											processEventsForNotifs(e, t) {
												var r;
												if (this.client.getNotifTimelineSet())
													for (const n of t) {
														const e = this.client.getPushActionsForEvent(n);
														(null == e ? void 0 : e.notify) && (null === (r = e.tweaks) || void 0 === r ? void 0 : r.highlight) && this.notifEvents.push(n)
													}
											}
											getGuestFilter() {
												return "{}"
											}
											updateSyncState(e, t) {
												const r = this.syncState;
												this.syncState = e, this.syncStateData = t, this.client.emit(v.ClientEvent.Sync, this.syncState, r, t)
											}
										}, n._createAndReEmitRoom = A
									}).call(this)
								}).call(this, void 0 !== e ? e : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
							}, {
								"./@types/event": 290,
								"./@types/sync": 297,
								"./client": 304,
								"./errors": 342,
								"./feature": 344,
								"./filter": 346,
								"./http-api": 349,
								"./logger": 356,
								"./models/beacon": 360,
								"./models/event-timeline": 364,
								"./models/room": 373,
								"./models/room-member": 370,
								"./models/room-state": 371,
								"./models/user": 377,
								"./pushprocessor": 378,
								"./utils": 393
							}],
							392: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.TimelineIndex = r.TimelineWindow = void 0;
								const i = e("./models/event-timeline"),
									o = (e("./logger"), function() {}),
									s = 5;
								r.TimelineWindow = class {
									constructor(e, t, r = {}) {
										this.client = e, this.timelineSet = t, this.eventCount = 0, this.windowLimit = r.windowLimit || 1e3
									}
									load(e, t = 20) {
										const r = r => {
											if (!r) throw new Error("No timeline given to initFields");
											let n;
											const i = r.getEvents();
											if (e) {
												if ((n = i.findIndex(t => t.getId() === e)) < 0) throw new Error("getEventTimeline result didn't include requested event")
											} else n = i.length;
											const o = Math.min(i.length, n + Math.ceil(t / 2)),
												s = Math.max(0, o - t);
											this.start = new a(r, s - r.getBaseIndex()), this.end = new a(r, o - r.getBaseIndex()), this.eventCount = o - s
										};
										return this.timelineSet.getTimelineForEvent(e) ? (r(this.timelineSet.getTimelineForEvent(e)), Promise.resolve()) : e ? this.client.getEventTimeline(this.timelineSet, e).then(r) : (r(this.timelineSet.getLiveTimeline()), Promise.resolve())
									}
									getTimelineIndex(e) {
										var t, r;
										if (e == i.EventTimeline.BACKWARDS) return null !== (t = this.start) && void 0 !== t ? t : null;
										if (e == i.EventTimeline.FORWARDS) return null !== (r = this.end) && void 0 !== r ? r : null;
										throw new Error("Invalid direction '" + e + "'")
									}
									extend(e, t) {
										const r = this.getTimelineIndex(e);
										if (!r) return o("TimelineWindow: no timeline yet"), !1;
										const n = e == i.EventTimeline.BACKWARDS ? r.retreat(t) : r.advance(t);
										if (n) {
											this.eventCount += n, o("TimelineWindow: increased cap by " + n + " (now " + this.eventCount + ")");
											const t = this.eventCount - this.windowLimit;
											return t > 0 && this.unpaginate(t, e != i.EventTimeline.BACKWARDS), !0
										}
										return !1
									}
									canPaginate(e) {
										const t = this.getTimelineIndex(e);
										if (!t) return o("TimelineWindow: no timeline yet"), !1;
										if (e == i.EventTimeline.BACKWARDS) {
											if (t.index > t.minIndex()) return !0
										} else if (t.index < t.maxIndex()) return !0;
										const r = t.timeline.getNeighbouringTimeline(e),
											n = t.timeline.getPaginationToken(e);
										return Boolean(r) || Boolean(n)
									}
									paginate(e, t, r = !0, a = s) {
										return n(this, void 0, void 0, (function*() {
											const n = this.getTimelineIndex(e);
											if (!n) return o("TimelineWindow: no timeline yet"), !1;
											if (n.pendingPaginate) return n.pendingPaginate;
											if (this.extend(e, t)) return !0;
											if (!r || 0 === a) return !1;
											if (!n.timeline.getPaginationToken(e)) return o("TimelineWindow: no token"), !1;
											o("TimelineWindow: starting request");
											const s = this.client.paginateEventTimeline(n.timeline, {
												backwards: e == i.EventTimeline.BACKWARDS,
												limit: t
											}).finally((function() {
												n.pendingPaginate = void 0
											})).then(r => (o("TimelineWindow: request completed with result " + r), r ? this.paginate(e, t, !0, a - 1) : this.paginate(e, t, !1, 0)));
											return n.pendingPaginate = s, s
										}))
									}
									unpaginate(e, t) {
										const r = t ? this.start : this.end;
										if (!r) throw new Error(`Attempting to unpaginate startOfTimeline=${t} but don't have this direction`);
										if (e > this.eventCount || e < 0) throw new Error(`Attemting to unpaginate ${e} events, but only have ${this.eventCount} in the timeline`);
										for (; e > 0;) {
											const n = t ? r.advance(e) : r.retreat(e);
											if (n <= 0) throw new Error("Unable to unpaginate any further, but still have " + this.eventCount + " events");
											e -= n, this.eventCount -= n, o("TimelineWindow.unpaginate: dropped " + n + " (now " + this.eventCount + ")")
										}
									}
									getEvents() {
										var e, t;
										if (!this.start) return [];
										const r = [];
										let n = this.start.timeline;
										for (;;) {
											const o = n.getEvents();
											let s = 0,
												a = o.length;
											n === this.start.timeline && (s = this.start.index + n.getBaseIndex()), n === (null === (e = this.end) || void 0 === e ? void 0 : e.timeline) && (a = this.end.index + n.getBaseIndex());
											for (let e = s; e < a; e++) r.push(o[e]);
											if (n === (null === (t = this.end) || void 0 === t ? void 0 : t.timeline)) break;
											n = n.getNeighbouringTimeline(i.EventTimeline.FORWARDS)
										}
										return r
									}
								};
								class a {
									constructor(e, t) {
										this.timeline = e, this.index = t
									}
									minIndex() {
										return -1 * this.timeline.getBaseIndex()
									}
									maxIndex() {
										return this.timeline.getEvents().length - this.timeline.getBaseIndex()
									}
									advance(e) {
										if (!e) return 0;
										let t;
										if (e < 0) {
											if ((t = Math.max(e, this.minIndex() - this.index)) < 0) return this.index += t, t
										} else if ((t = Math.min(e, this.maxIndex() - this.index)) > 0) return this.index += t, t;
										const r = this.timeline.getNeighbouringTimeline(e < 0 ? i.EventTimeline.BACKWARDS : i.EventTimeline.FORWARDS);
										return r ? (this.timeline = r, this.index = e < 0 ? this.maxIndex() : this.minIndex(), o("paginate: switched to new neighbour"), this.advance(e)) : 0
									}
									retreat(e) {
										return -1 * this.advance(-1 * e)
									}
								}
								r.TimelineIndex = a
							}, {
								"./logger": 356,
								"./models/event-timeline": 364
							}],
							393: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
										return new(r || (r = Promise))((function(i, o) {
											function s(e) {
												try {
													c(n.next(e))
												} catch (t) {
													o(t)
												}
											}

											function a(e) {
												try {
													c(n.throw(e))
												} catch (t) {
													o(t)
												}
											}

											function c(e) {
												var t;
												e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
													e(t)
												}))).then(s, a)
											}
											c((n = n.apply(e, t || [])).next())
										}))
									},
									i = this && this.__importDefault || function(e) {
										return e && e.__esModule ? e : {
											default: e
										}
									};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.isSupportedReceiptType = r.sortEventsByLatestContentTimestamp = r.recursivelyAssign = r.compare = r.lexicographicCompare = r.prevString = r.nextString = r.averageBetweenStrings = r.stringToBase = r.baseToString = r.alphabetPad = r.DEFAULT_ALPHABET = r.simpleRetryOperation = r.chunkPromises = r.promiseTry = r.promiseMapSeries = r.defer = r.isNullOrUndefined = r.sleep = r.ensureNoTrailingSlash = r.globToRegexp = r.escapeRegExp = r.normalize = r.removeDirectionOverrideChars = r.removeHiddenChars = r.isNumber = r.deepSortedObjectEntries = r.deepCompare = r.deepCopy = r.checkObjectHasKeys = r.isFunction = r.removeElement = r.encodeUri = r.decodeParams = r.replaceParam = r.encodeParams = r.internaliseString = void 0;
								const o = i(e("unhomoglyph")),
									s = i(e("p-retry")),
									a = e("./@types/location"),
									c = e("./@types/read_receipts"),
									l = new Map;

								function u(e) {
									return "string" == typeof e ? (0, o.default)(e.normalize("NFD").replace(d, "")) : ""
								}
								r.internaliseString = function(e) {
									return e instanceof String && (e = e.toString()), l.has(e) || l.set(e, e), l.get(e)
								}, r.encodeParams = function(e, t) {
									const r = null != t ? t : new URLSearchParams;
									for (const [n, i] of Object.entries(e)) null != i && (Array.isArray(i) ? i.forEach(e => {
										r.append(n, String(e))
									}) : r.append(n, String(i)));
									return r
								}, r.replaceParam = function(e, t, r) {
									const n = Object.assign(Object.assign({}, r), {
										[t]: r[e]
									});
									return delete n[e], n
								}, r.decodeParams = function(e) {
									const t = {},
										r = new URLSearchParams(e);
									for (const n of r.keys()) {
										const e = r.getAll(n);
										t[n] = 1 === e.length ? e[0] : e
									}
									return t
								}, r.encodeUri = function(e, t) {
									for (const r in t) {
										if (!t.hasOwnProperty(r)) continue;
										const n = t[r];
										null != n && (e = e.replace(r, encodeURIComponent(n)))
									}
									return e
								}, r.removeElement = function(e, t, r) {
									let n;
									if (r) {
										for (n = e.length - 1; n >= 0; n--)
											if (t(e[n], n, e)) return e.splice(n, 1), !0
									} else
										for (n = 0; n < e.length; n++)
											if (t(e[n], n, e)) return e.splice(n, 1), !0;
									return !1
								}, r.isFunction = function(e) {
									return "[object Function]" === Object.prototype.toString.call(e)
								}, r.checkObjectHasKeys = function(e, t) {
									for (const r of t)
										if (!e.hasOwnProperty(r)) throw new Error("Missing required key: " + r)
								}, r.deepCopy = function(e) {
									return JSON.parse(JSON.stringify(e))
								}, r.deepCompare = function e(t, r) {
									if (t === r) return !0;
									if (typeof t != typeof r) return !1;
									if ("number" == typeof t && isNaN(t) && isNaN(r)) return !0;
									if (null === t || null === r) return t === r;
									if (!(t instanceof Object)) return !1;
									if (t.constructor !== r.constructor || t.prototype !== r.prototype) return !1;
									if (t instanceof RegExp || t instanceof Date) return t.toString() === r.toString();
									if (Array.isArray(t)) {
										if (t.length !== r.length) return !1;
										for (let n = 0; n < t.length; n++)
											if (!e(t[n], r[n])) return !1
									} else {
										for (const e in r)
											if (r.hasOwnProperty(e) !== t.hasOwnProperty(e)) return !1;
										for (const n in t)
											if (r.hasOwnProperty(n) !== t.hasOwnProperty(n) || !e(t[n], r[n])) return !1
									}
									return !0
								}, r.deepSortedObjectEntries = function e(t) {
									if ("object" != typeof t) return t;
									if (null == t || Array.isArray(t)) return t;
									const r = [];
									for (const [n, i] of Object.entries(t)) r.push([n, e(i)]);
									return r.sort((e, t) => g(e[0], t[0])), r
								}, r.isNumber = function(e) {
									return "number" == typeof e && isFinite(e)
								}, r.removeHiddenChars = u, r.removeDirectionOverrideChars = function(e) {
									return "string" == typeof e ? e.replace(/[\u202d-\u202e]/g, "") : ""
								}, r.normalize = function(e) {
									return u(e.toLowerCase()).replace(/[\\'!"#$%&()*+,\-./:;<=>?@[\]^_`{|}~\u2000-\u206f\u2e00-\u2e7f]/g, "").toLowerCase()
								};
								const d = /[\u2000-\u200F\u202A-\u202F\u0300-\u036F\uFEFF\u061C\u2800\u2062-\u2063\s]/g;

								function h(e) {
									return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
								}

								function f(e, t, n = r.DEFAULT_ALPHABET) {
									return e.padEnd(t, n[0])
								}

								function p(e, t = r.DEFAULT_ALPHABET) {
									var n;
									const i = BigInt(t.length);
									if (e <= i) return null !== (n = t[Number(e) - 1]) && void 0 !== n ? n : "";
									let o = e / i,
										s = Number(e % i) - 1;
									return s < 0 && (o -= BigInt(Math.abs(s)), s = Number(i) - 1), p(o, t) + t[s]
								}

								function v(e, t = r.DEFAULT_ALPHABET) {
									const n = BigInt(t.length);
									let i = BigInt(0);
									for (let r = e.length - 1, o = BigInt(0); r >= 0; r--, o++) {
										const s = e.charCodeAt(r) - t.charCodeAt(0);
										i += BigInt(1 + s) * n ** o
									}
									return i
								}

								function g(e, t) {
									return e < t ? -1 : e > t ? 1 : 0
								}
								r.escapeRegExp = h, r.globToRegexp = function(e, t = !1) {
									const r = [
										[/\\\*/g, ".*"],
										[/\?/g, "."]
									];
									return t || r.push([/\\\[(!|)(.*)\\]/g, (e, t, r) => ["[", t ? "^" : "", r.replace(/\\-/, "-"), "]"].join("")]), r.reduce((e, t) => t ? e.replace(t[0], t[1]) : e, h(e))
								}, r.ensureNoTrailingSlash = function(e) {
									return (null == e ? void 0 : e.endsWith("/")) ? e.slice(0, -1) : e
								}, r.sleep = function(e, t) {
									return new Promise(r => {
										setTimeout(r, e, t)
									})
								}, r.isNullOrUndefined = function(e) {
									return null == e
								}, r.defer = function() {
									let e, t;
									const r = new Promise((r, n) => {
										e = r, t = n
									});
									return {
										resolve: e,
										reject: t,
										promise: r
									}
								}, r.promiseMapSeries = function(e, t) {
									return n(this, void 0, void 0, (function*() {
										for (const r of e) yield t(yield r)
									}))
								}, r.promiseTry = function(e) {
									return Promise.resolve(e())
								}, r.chunkPromises = function(e, t) {
									return n(this, void 0, void 0, (function*() {
										const r = [];
										for (let n = 0; n < e.length; n += t) r.push(...yield Promise.all(e.slice(n, n + t).map(e => e())));
										return r
									}))
								}, r.simpleRetryOperation = function(e) {
									return (0, s.default)(t => e(t), {
										forever: !0,
										factor: 2,
										minTimeout: 3e3,
										maxTimeout: 15e3
									})
								}, r.DEFAULT_ALPHABET = (() => {
									let e = "";
									for (let t = 32; t <= 126; t++) e += String.fromCharCode(t);
									return e
								})(), r.alphabetPad = f, r.baseToString = p, r.stringToBase = v, r.averageBetweenStrings = function(e, t, n = r.DEFAULT_ALPHABET) {
									const i = Math.max(e.length, t.length),
										o = v(f(e, i, n), n),
										s = v(f(t, i, n), n),
										a = (o + s) / BigInt(2);
									return a === o || a == s ? p(a, n) + n[0] : p(a, n)
								}, r.nextString = function(e, t = r.DEFAULT_ALPHABET) {
									return p(v(e, t) + BigInt(1), t)
								}, r.prevString = function(e, t = r.DEFAULT_ALPHABET) {
									return p(v(e, t) - BigInt(1), t)
								}, r.lexicographicCompare = g;
								const m = new Intl.Collator;

								function y(e) {
									var t;
									return null !== (t = a.M_TIMESTAMP.findIn(e.getContent())) && void 0 !== t ? t : -1
								}
								r.compare = function(e, t) {
									return m.compare(e, t)
								}, r.recursivelyAssign = function e(t, r, n = !1) {
									for (const [i, o] of Object.entries(r)) t[i] instanceof Object && o ? e(t[i], o) : null == o && n || (t[i] = o);
									return t
								}, r.sortEventsByLatestContentTimestamp = function(e, t) {
									return y(t) - y(e)
								}, r.isSupportedReceiptType = function(e) {
									return [c.ReceiptType.Read, c.ReceiptType.ReadPrivate].includes(e)
								}
							}, {
								"./@types/location": 292,
								"./@types/read_receipts": 294,
								"p-retry": 226,
								unhomoglyph: 282
							}],
							394: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.releaseContext = r.acquireContext = void 0;
								let n = null,
									i = 0;
								r.acquireContext = () => (null === n && (n = new AudioContext), i++, n);
								r.releaseContext = () => {
									0 === --i && (null == n || n.close(), n = null)
								}
							}, {}],
							395: [function(e, t, r) {
								(function(t) {
									(function() {
										"use strict";
										var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
												void 0 === n && (n = r);
												var i = Object.getOwnPropertyDescriptor(t, r);
												i && ("get" in i ? t.__esModule : !i.writable && !i.configurable) || (i = {
													enumerable: !0,
													get: function() {
														return t[r]
													}
												}), Object.defineProperty(e, n, i)
											} : function(e, t, r, n) {
												void 0 === n && (n = r), e[n] = t[r]
											}),
											i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
												Object.defineProperty(e, "default", {
													enumerable: !0,
													value: t
												})
											} : function(e, t) {
												e.default = t
											}),
											o = this && this.__importStar || function(e) {
												if (e && e.__esModule) return e;
												var t = {};
												if (null != e)
													for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
												return i(t, e), t
											},
											s = this && this.__awaiter || function(e, t, r, n) {
												return new(r || (r = Promise))((function(i, o) {
													function s(e) {
														try {
															c(n.next(e))
														} catch (t) {
															o(t)
														}
													}

													function a(e) {
														try {
															c(n.throw(e))
														} catch (t) {
															o(t)
														}
													}

													function c(e) {
														var t;
														e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
															e(t)
														}))).then(s, a)
													}
													c((n = n.apply(e, t || [])).next())
												}))
											};
										Object.defineProperty(r, "__esModule", {
											value: !0
										}), r.createNewMatrixCall = r.supportsMatrixCall = r.setTracksEnabled = r.MatrixCall = r.genCallID = r.CallError = r.CallErrorCode = r.CallEvent = r.CallParty = r.CallDirection = r.CallType = r.CallState = void 0;
										const a = e("sdp-transform"),
											c = e("../logger"),
											l = o(e("../utils")),
											u = e("../@types/event"),
											d = e("../randomstring"),
											h = e("./callEventTypes"),
											f = e("./callFeed"),
											p = e("../models/typed-event-emitter"),
											v = e("../crypto/deviceinfo"),
											g = e("./groupCall"),
											m = e("../http-api");
										var y, b, _, w, S, E, k, T;
										! function(e) {
											e.AUDIO = "audio", e.VIDEO = "video"
										}(y || (y = {})),
										function(e) {
											e.OPUS = "opus"
										}(b || (b = {})),
										function(e) {
											e.Fledgling = "fledgling", e.InviteSent = "invite_sent", e.WaitLocalMedia = "wait_local_media", e.CreateOffer = "create_offer", e.CreateAnswer = "create_answer", e.Connecting = "connecting", e.Connected = "connected", e.Ringing = "ringing", e.Ended = "ended"
										}(_ = r.CallState || (r.CallState = {})),
										function(e) {
											e.Voice = "voice", e.Video = "video"
										}(w = r.CallType || (r.CallType = {})),
										function(e) {
											e.Inbound = "inbound", e.Outbound = "outbound"
										}(S = r.CallDirection || (r.CallDirection = {})),
										function(e) {
											e.Local = "local", e.Remote = "remote"
										}(E = r.CallParty || (r.CallParty = {})),
										function(e) {
											e.Hangup = "hangup", e.State = "state", e.Error = "error", e.Replaced = "replaced", e.LocalHoldUnhold = "local_hold_unhold", e.RemoteHoldUnhold = "remote_hold_unhold", e.HoldUnhold = "hold_unhold", e.FeedsChanged = "feeds_changed", e.AssertedIdentityChanged = "asserted_identity_changed", e.LengthChanged = "length_changed", e.DataChannel = "datachannel", e.SendVoipEvent = "send_voip_event"
										}(k = r.CallEvent || (r.CallEvent = {})),
										function(e) {
											e.UserHangup = "user_hangup", e.LocalOfferFailed = "local_offer_failed", e.NoUserMedia = "no_user_media", e.UnknownDevices = "unknown_devices", e.SendInvite = "send_invite", e.CreateAnswer = "create_answer", e.CreateOffer = "create_offer", e.SendAnswer = "send_answer", e.SetRemoteDescription = "set_remote_description", e.SetLocalDescription = "set_local_description", e.AnsweredElsewhere = "answered_elsewhere", e.IceFailed = "ice_failed", e.InviteTimeout = "invite_timeout", e.Replaced = "replaced", e.SignallingFailed = "signalling_timeout", e.UserBusy = "user_busy", e.Transfered = "transferred", e.NewSession = "new_session"
										}(T = r.CallErrorCode || (r.CallErrorCode = {}));
										const I = "1",
											R = "stun:turn.matrix.org",
											C = 6e4;
										class CallError extends Error {
											constructor(e, t, r) {
												super(t + ": " + r), this.code = e
											}
										}

										function M() {
											return Date.now().toString() + (0, d.randomString)(16)
										}

										function x(e) {
											return [{
												mediaType: "audio",
												codec: "opus",
												enableDtx: !0,
												maxAverageBitrate: e ? 12e3 : void 0
											}]
										}

										function O(e, t) {
											return e + ":" + t
										}
										r.CallError = CallError, r.genCallID = M;
										class A extends p.TypedEventEmitter {
											constructor(e) {
												var t;
												if (super(), this.state = _.Fledgling, this.toDeviceSeq = 0, this.isPtt = !1, this.candidateSendQueue = [], this.candidateSendTries = 0, this.candidatesEnded = !1, this.feeds = [], this.transceivers = new Map, this.inviteOrAnswerSent = !1, this.waitForLocalAVStream = !1, this.removeTrackListeners = new Map, this.remoteOnHold = !1, this.makingOffer = !1, this.ignoreOffer = !1, this.remoteCandidateBuffer = new Map, this.callLength = 0, this.gotLocalIceCandidate = e => {
														if (e.candidate) {
															if (this.candidatesEnded) return void c.logger.warn("Got candidate after candidates have ended - ignoring!");
															if (c.logger.debug("Call " + this.callId + " got local ICE " + e.candidate.sdpMid + " candidate: " + e.candidate.candidate), this.callHasEnded()) return;
															"" === e.candidate.candidate ? this.queueCandidate(null) : this.queueCandidate(e.candidate)
														}
													}, this.onIceGatheringStateChange = e => {
														var t;
														c.logger.debug(`Call ${this.callId} ice gathering state changed to  ${this.peerConn.iceGatheringState}`), "complete" === (null === (t = this.peerConn) || void 0 === t ? void 0 : t.iceGatheringState) && this.queueCandidate(null)
													}, this.getLocalOfferFailed = e => {
														c.logger.error(`Call ${this.callId} Failed to get local offer`, e), this.emit(k.Error, new CallError(T.LocalOfferFailed, "Failed to get local offer!", e)), this.terminate(E.Local, T.LocalOfferFailed, !1)
													}, this.getUserMediaFailed = e => {
														this.successor ? this.successor.getUserMediaFailed(e) : (c.logger.warn(`Failed to get user media - ending call ${this.callId}`, e), this.emit(k.Error, new CallError(T.NoUserMedia, "Couldn't start capturing media! Is your microphone set up and does this app have permission?", e)), this.terminate(E.Local, T.NoUserMedia, !1))
													}, this.onIceConnectionStateChanged = () => {
														var e, t, r, n, i, o;
														if (!this.callHasEnded() && (c.logger.debug("Call ID " + this.callId + ": ICE connection state changed to: " + (null === (e = this.peerConn) || void 0 === e ? void 0 : e.iceConnectionState)), ["connected", "completed"].includes(null !== (r = null === (t = this.peerConn) || void 0 === t ? void 0 : t.iceConnectionState) && void 0 !== r ? r : "") ? (clearTimeout(this.iceDisconnectedTimeout), this.setState(_.Connected), this.callLengthInterval || (this.callLengthInterval = setInterval(() => {
																this.callLength++, this.emit(k.LengthChanged, this.callLength)
															}, 1e3))) : "failed" == (null === (n = this.peerConn) || void 0 === n ? void 0 : n.iceConnectionState) ? (null === (i = this.peerConn) || void 0 === i ? void 0 : i.restartIce) ? (this.candidatesEnded = !1, this.peerConn.restartIce()) : (c.logger.info(`Hanging up call ${this.callId} (ICE failed and no ICE restart method)`), this.hangup(T.IceFailed, !1)) : "disconnected" == (null === (o = this.peerConn) || void 0 === o ? void 0 : o.iceConnectionState) && (this.iceDisconnectedTimeout = setTimeout(() => {
																c.logger.info(`Hanging up call ${this.callId} (ICE disconnected for too long)`), this.hangup(T.IceFailed, !1)
															}, 3e4), this.setState(_.Connecting)), this.isPtt && ["failed", "disconnected"].includes(this.peerConn.iceConnectionState)))
															for (const s of this.getRemoteFeeds()) s.setAudioVideoMuted(!0, !0)
													}, this.onSignallingStateChanged = () => {
														var e;
														c.logger.debug(`call ${this.callId}: Signalling state changed to: ${null===(e=this.peerConn)||void 0===e?void 0:e.signalingState}`)
													}, this.onTrack = e => {
														if (0 === e.streams.length) return void c.logger.warn(`Call ${this.callId} Streamless ${e.track.kind} found: ignoring.`);
														const t = e.streams[0];
														if (this.pushRemoteFeed(t), !this.removeTrackListeners.has(t)) {
															const e = () => {
																0 === t.getTracks().length && (c.logger.info(`Call ${this.callId} removing track streamId: ${t.id}`), this.deleteFeedByStream(t), t.removeEventListener("removetrack", e), this.removeTrackListeners.delete(t))
															};
															t.addEventListener("removetrack", e), this.removeTrackListeners.set(t, e)
														}
													}, this.onDataChannel = e => {
														this.emit(k.DataChannel, e.channel)
													}, this.onNegotiationNeeded = () => s(this, void 0, void 0, (function*() {
														c.logger.info(`Call ${this.callId} Negotiation is needed!`), this.state === _.CreateOffer || 0 !== this.opponentVersion ? this.queueGotLocalOffer() : c.logger.info(`Call ${this.callId} Opponent does not support renegotiation: ignoring negotiationneeded event`)
													})), this.onHangupReceived = e => {
														c.logger.debug("Hangup received for call ID " + this.callId), this.partyIdMatches(e) || this.state === _.Ringing ? this.terminate(E.Remote, e.reason || T.UserHangup, !0) : c.logger.info(`Call ${this.callId} Ignoring message from party ID ${e.party_id}: our partner is ${this.opponentPartyId}`)
													}, this.onRejectReceived = e => {
														c.logger.debug("Reject received for call ID " + this.callId), [_.InviteSent, _.Ringing].includes(this.state) || this.state === _.Fledgling && this.direction === S.Inbound ? this.terminate(E.Remote, e.reason || T.UserHangup, !0) : c.logger.debug(`Call ${this.callId} is in state: ${this.state}: ignoring reject`)
													}, this.onAnsweredElsewhere = e => {
														c.logger.debug("Call " + this.callId + " answered elsewhere"), this.terminate(E.Remote, T.AnsweredElsewhere, !0)
													}, this.roomId = e.roomId, this.invitee = e.invitee, this.client = e.client, !this.client.deviceId) throw new Error("Client must have a device ID to start calls");
												this.forceTURN = null !== (t = e.forceTURN) && void 0 !== t && t, this.ourPartyId = this.client.deviceId, this.opponentDeviceId = e.opponentDeviceId, this.opponentSessionId = e.opponentSessionId, this.groupCallId = e.groupCallId, this.turnServers = e.turnServers || [], 0 === this.turnServers.length && this.client.isFallbackICEServerAllowed() && this.turnServers.push({
													urls: [R]
												});
												for (const r of this.turnServers) l.checkObjectHasKeys(r, ["urls"]);
												this.callId = M()
											}
											placeVoiceCall() {
												return s(this, void 0, void 0, (function*() {
													yield this.placeCall(!0, !1)
												}))
											}
											placeVideoCall() {
												return s(this, void 0, void 0, (function*() {
													yield this.placeCall(!0, !0)
												}))
											}
											createDataChannel(e, t) {
												const r = this.peerConn.createDataChannel(e, t);
												return this.emit(k.DataChannel, r), r
											}
											getOpponentMember() {
												return this.opponentMember
											}
											getOpponentSessionId() {
												return this.opponentSessionId
											}
											opponentCanBeTransferred() {
												return Boolean(this.opponentCaps && this.opponentCaps["m.call.transferee"])
											}
											opponentSupportsDTMF() {
												return Boolean(this.opponentCaps && this.opponentCaps["m.call.dtmf"])
											}
											getRemoteAssertedIdentity() {
												return this.remoteAssertedIdentity
											}
											get type() {
												return this.hasLocalUserMediaVideoTrack || this.hasRemoteUserMediaVideoTrack ? w.Video : w.Voice
											}
											get hasLocalUserMediaVideoTrack() {
												var e;
												return !!(null === (e = this.localUsermediaStream) || void 0 === e ? void 0 : e.getVideoTracks().length)
											}
											get hasRemoteUserMediaVideoTrack() {
												return this.getRemoteFeeds().some(e => {
													var t;
													return e.purpose === h.SDPStreamMetadataPurpose.Usermedia && (null === (t = e.stream) || void 0 === t ? void 0 : t.getVideoTracks().length)
												})
											}
											get hasLocalUserMediaAudioTrack() {
												var e;
												return !!(null === (e = this.localUsermediaStream) || void 0 === e ? void 0 : e.getAudioTracks().length)
											}
											get hasRemoteUserMediaAudioTrack() {
												return this.getRemoteFeeds().some(e => {
													var t;
													return e.purpose === h.SDPStreamMetadataPurpose.Usermedia && !!(null === (t = e.stream) || void 0 === t ? void 0 : t.getAudioTracks().length)
												})
											}
											get localUsermediaFeed() {
												return this.getLocalFeeds().find(e => e.purpose === h.SDPStreamMetadataPurpose.Usermedia)
											}
											get localScreensharingFeed() {
												return this.getLocalFeeds().find(e => e.purpose === h.SDPStreamMetadataPurpose.Screenshare)
											}
											get localUsermediaStream() {
												var e;
												return null === (e = this.localUsermediaFeed) || void 0 === e ? void 0 : e.stream
											}
											get localScreensharingStream() {
												var e;
												return null === (e = this.localScreensharingFeed) || void 0 === e ? void 0 : e.stream
											}
											get remoteUsermediaFeed() {
												return this.getRemoteFeeds().find(e => e.purpose === h.SDPStreamMetadataPurpose.Usermedia)
											}
											get remoteScreensharingFeed() {
												return this.getRemoteFeeds().find(e => e.purpose === h.SDPStreamMetadataPurpose.Screenshare)
											}
											get remoteUsermediaStream() {
												var e;
												return null === (e = this.remoteUsermediaFeed) || void 0 === e ? void 0 : e.stream
											}
											get remoteScreensharingStream() {
												var e;
												return null === (e = this.remoteScreensharingFeed) || void 0 === e ? void 0 : e.stream
											}
											getFeedByStreamId(e) {
												return this.getFeeds().find(t => t.stream.id === e)
											}
											getFeeds() {
												return this.feeds
											}
											getLocalFeeds() {
												return this.feeds.filter(e => e.isLocal())
											}
											getRemoteFeeds() {
												return this.feeds.filter(e => !e.isLocal())
											}
											initOpponentCrypto() {
												var e;
												return s(this, void 0, void 0, (function*() {
													if (!this.opponentDeviceId) return;
													if (!this.client.getUseE2eForGroupCall()) return;
													if (!this.client.isCryptoEnabled()) return void(this.opponentDeviceInfo = new v.DeviceInfo(this.opponentDeviceId));
													if (!this.client.crypto) throw new Error("Crypto is not initialised.");
													const t = this.invitee || (null === (e = this.getOpponentMember()) || void 0 === e ? void 0 : e.userId);
													if (!t) throw new Error("Couldn't find opponent user ID to init crypto");
													const r = yield this.client.crypto.deviceList.downloadKeys([t], !1);
													if (this.opponentDeviceInfo = r[t][this.opponentDeviceId], void 0 === this.opponentDeviceInfo) throw new g.GroupCallUnknownDeviceError(t)
												}))
											}
											getLocalSDPStreamMetadata(e = !1) {
												const t = {};
												for (const r of this.getLocalFeeds()) e && (r.sdpMetadataStreamId = r.stream.id), t[r.sdpMetadataStreamId] = {
													purpose: r.purpose,
													audio_muted: r.isAudioMuted(),
													video_muted: r.isVideoMuted()
												};
												return t
											}
											noIncomingFeeds() {
												return !this.feeds.some(e => !e.isLocal())
											}
											pushRemoteFeed(e) {
												if (!this.opponentSupportsSDPStreamMetadata()) return void this.pushRemoteFeedWithoutMetadata(e);
												const t = this.getOpponentMember().userId,
													r = this.remoteSDPStreamMetadata[e.id].purpose,
													n = this.remoteSDPStreamMetadata[e.id].audio_muted,
													i = this.remoteSDPStreamMetadata[e.id].video_muted;
												r ? this.getFeedByStreamId(e.id) ? c.logger.warn(`Ignoring stream with id ${e.id} because we already have a feed for it`) : (this.feeds.push(new f.CallFeed({
													client: this.client,
													roomId: this.roomId,
													userId: t,
													stream: e,
													purpose: r,
													audioMuted: n,
													videoMuted: i
												})), this.emit(k.FeedsChanged, this.feeds), c.logger.info(`Call ${this.callId} pushed remote stream (id="${e.id}", ` + `active="${e.active}", purpose=${r})`)) : c.logger.warn(`Call ${this.callId} Ignoring stream with id ${e.id} because we didn't get any metadata about it`)
											}
											pushRemoteFeedWithoutMetadata(e) {
												var t;
												const r = this.getOpponentMember().userId,
													n = h.SDPStreamMetadataPurpose.Usermedia,
													i = null === (t = this.feeds.find(e => !e.isLocal())) || void 0 === t ? void 0 : t.stream;
												i && e.id !== i.id ? c.logger.warn(`Call ${this.callId} Ignoring new stream ID ${e.id}: we already have stream ID ${i.id}`) : this.getFeedByStreamId(e.id) ? c.logger.warn(`Ignoring stream with id ${e.id} because we already have a feed for it`) : (this.feeds.push(new f.CallFeed({
													client: this.client,
													roomId: this.roomId,
													audioMuted: !1,
													videoMuted: !1,
													userId: r,
													stream: e,
													purpose: n
												})), this.emit(k.FeedsChanged, this.feeds), c.logger.info(`Call ${this.callId} pushed remote stream (id="${e.id}", active="${e.active}")`))
											}
											pushNewLocalFeed(e, t, r = !0) {
												const n = this.client.getUserId();
												P(e.getAudioTracks(), !0), P(e.getVideoTracks(), !0), this.getFeedByStreamId(e.id) ? c.logger.warn(`Ignoring stream with id ${e.id} because we already have a feed for it`) : this.pushLocalFeed(new f.CallFeed({
													client: this.client,
													roomId: this.roomId,
													audioMuted: !1,
													videoMuted: !1,
													userId: n,
													stream: e,
													purpose: t
												}), r)
											}
											pushLocalFeed(e, t = !0) {
												if (this.feeds.some(t => e.stream.id === t.stream.id)) c.logger.info(`Ignoring duplicate local stream ${e.stream.id} in call ${this.callId}`);
												else {
													if (this.feeds.push(e), t)
														for (const t of e.stream.getTracks()) {
															c.logger.info(`Call ${this.callId} ` + "Adding track (" + `id="${t.id}", ` + `kind="${t.kind}", ` + `streamId="${e.stream.id}", ` + `streamPurpose="${e.purpose}", ` + `enabled=${t.enabled}` + ") to peer connection");
															const r = O(e.purpose, t.kind);
															if (this.transceivers.has(r)) {
																const n = this.transceivers.get(r);
																n.sender.setStreams && n.sender.setStreams(e.stream), n.sender.replaceTrack(t), n.direction = "inactive" === n.direction ? "sendonly" : "sendrecv"
															} else {
																const n = this.peerConn.addTrack(t, e.stream),
																	i = this.peerConn.getTransceivers().find(e => e.sender === n);
																i ? this.transceivers.set(r, i) : c.logger.warn("Didn't find a matching transceiver after adding track!")
															}
														}
													c.logger.info(`Call ${this.callId} ` + "Pushed local stream " + `(id="${e.stream.id}", ` + `active="${e.stream.active}", ` + `purpose="${e.purpose}")`), this.emit(k.FeedsChanged, this.feeds)
												}
											}
											removeLocalFeed(e) {
												const t = O(e.purpose, "audio"),
													r = O(e.purpose, "video");
												for (const n of [t, r])
													if (this.transceivers.has(n)) {
														const e = this.transceivers.get(n);
														e.sender && this.peerConn.removeTrack(e.sender)
													} e.purpose === h.SDPStreamMetadataPurpose.Screenshare && this.client.getMediaHandler().stopScreensharingStream(e.stream), this.deleteFeed(e)
											}
											deleteAllFeeds() {
												for (const e of this.feeds) e.isLocal() && this.groupCallId || e.dispose();
												this.feeds = [], this.emit(k.FeedsChanged, this.feeds)
											}
											deleteFeedByStream(e) {
												const t = this.getFeedByStreamId(e.id);
												t ? this.deleteFeed(t) : c.logger.warn(`Call ${this.callId} Didn't find the feed with stream id ${e.id} to delete`)
											}
											deleteFeed(e) {
												e.dispose(), this.feeds.splice(this.feeds.indexOf(e), 1), this.emit(k.FeedsChanged, this.feeds)
											}
											getCurrentCallStats() {
												return s(this, void 0, void 0, (function*() {
													return this.callHasEnded() ? this.callStatsAtEnd : this.collectCallStats()
												}))
											}
											collectCallStats() {
												return s(this, void 0, void 0, (function*() {
													if (!this.peerConn) return;
													const e = yield this.peerConn.getStats(), t = [];
													return e.forEach(e => {
														t.push(e)
													}), t
												}))
											}
											initWithInvite(e) {
												var t;
												return s(this, void 0, void 0, (function*() {
													const r = e.getContent();
													this.direction = S.Inbound, (yield this.client.checkTurnServers()) || c.logger.warn(`Call ${this.callId} Failed to get TURN credentials! Proceeding with call anyway...`);
													const n = r[h.SDPStreamMetadataKey];
													n ? this.updateRemoteSDPStreamMetadata(n) : c.logger.debug(`Call ${this.callId} did not get any SDPStreamMetadata! Can not send/receive multiple streams`), this.peerConn = this.createPeerConnection(), this.chooseOpponent(e), yield this.initOpponentCrypto();
													try {
														yield this.peerConn.setRemoteDescription(r.offer), yield this.addBufferedIceCandidates()
													} catch (o) {
														return c.logger.debug(`Call ${this.callId} failed to set remote description`, o), void this.terminate(E.Local, T.SetRemoteDescription, !1)
													}
													const i = null === (t = this.feeds.find(e => !e.isLocal())) || void 0 === t ? void 0 : t.stream;
													if (!i || 0 === i.getTracks().length) return c.logger.error(`Call ${this.callId} no remote stream or no tracks after setting remote description!`), void this.terminate(E.Local, T.SetRemoteDescription, !1);
													if (this.setState(_.Ringing), e.getLocalAge()) {
														const t = setTimeout(() => {
																this.state == _.Ringing && (c.logger.debug(`Call ${this.callId} invite has expired. Hanging up.`), this.hangupParty = E.Remote, this.setState(_.Ended), this.stopAllMedia(), "closed" != this.peerConn.signalingState && this.peerConn.close(), this.emit(k.Hangup, this))
															}, r.lifetime - e.getLocalAge()),
															n = e => {
																e !== _.Ringing && (clearTimeout(t), this.off(k.State, n))
															};
														this.on(k.State, n)
													}
												}))
											}
											initWithHangup(e) {
												this.setState(_.Ended)
											}
											shouldAnswerWithMediaType(e, t, r) {
												return e && !t ? (c.logger.warn(`Call ${this.callId} Unable to answer with ${r} because the other side isn't sending it either.`), !1) : l.isNullOrUndefined(e) || e === t || this.opponentSupportsSDPStreamMetadata() ? null != e ? e : t : (c.logger.warn(`Call ${this.callId} Unable to answer with ${r}=${e} because the other side doesn't support it. Answering with ${r}=${t}.`), t)
											}
											answer(e, t) {
												return s(this, void 0, void 0, (function*() {
													if (!this.inviteOrAnswerSent) {
														if (!1 === e && !1 === t) throw new Error("You CANNOT answer a call without media");
														if (this.localUsermediaStream || this.waitForLocalAVStream) this.waitForLocalAVStream && this.setState(_.WaitLocalMedia);
														else {
															const n = this.state,
																i = this.shouldAnswerWithMediaType(e, this.hasRemoteUserMediaAudioTrack, "audio"),
																o = this.shouldAnswerWithMediaType(t, this.hasRemoteUserMediaVideoTrack, "video");
															this.setState(_.WaitLocalMedia), this.waitForLocalAVStream = !0;
															try {
																const e = yield this.client.getMediaHandler().getUserMediaStream(i, o);
																this.waitForLocalAVStream = !1;
																const t = [new f.CallFeed({
																	client: this.client,
																	roomId: this.roomId,
																	userId: this.client.getUserId(),
																	stream: e,
																	purpose: h.SDPStreamMetadataPurpose.Usermedia,
																	audioMuted: !1,
																	videoMuted: !1
																})];
																this.localScreensharingFeed && t.push(this.localScreensharingFeed), this.answerWithCallFeeds(t)
															} catch (r) {
																if (!o) return void this.getUserMediaFailed(r);
																c.logger.warn(`Call ${this.callId} Failed to getUserMedia(), trying to getUserMedia() without video`), this.setState(n), this.waitForLocalAVStream = !1, yield this.answer(i, !1)
															}
														}
													}
												}))
											}
											answerWithCallFeeds(e) {
												this.inviteOrAnswerSent || this.queueGotCallFeedsForAnswer(e)
											}
											replacedBy(e) {
												c.logger.debug(`Call ${this.callId} replaced by ${e.callId}`), this.state === _.WaitLocalMedia ? (c.logger.debug(`Call ${this.callId} telling new call ${e.callId} to wait for local media`), e.waitForLocalAVStream = !0) : [_.CreateOffer, _.InviteSent].includes(this.state) && (e.direction === S.Outbound ? e.queueGotCallFeedsForAnswer([]) : (c.logger.debug(`Call ${this.callId} handing local stream to new call ${e.callId}`), e.queueGotCallFeedsForAnswer(this.getLocalFeeds().map(e => e.clone())))), this.successor = e, this.emit(k.Replaced, e), this.hangup(T.Replaced, !0)
											}
											hangup(e, t) {
												if (this.callHasEnded()) return;
												if (c.logger.debug(`Ending call ${this.callId} with reason ${e}`), this.terminate(E.Local, e, !t), this.state === _.WaitLocalMedia) return;
												const r = {};
												(this.opponentVersion && 0 !== this.opponentVersion || e !== T.UserHangup) && (r.reason = e), this.sendVoipEvent(u.EventType.CallHangup, r)
											}
											reject() {
												if (this.state !== _.Ringing) throw Error("Call must be in 'ringing' state to reject!");
												if (0 === this.opponentVersion) return c.logger.info(`Call ${this.callId} Opponent version is less than 1 (${this.opponentVersion}): sending hangup instead of reject`), void this.hangup(T.UserHangup, !0);
												c.logger.debug("Rejecting call: " + this.callId), this.terminate(E.Local, T.UserHangup, !0), this.sendVoipEvent(u.EventType.CallReject, {})
											}
											upgradeCall(e, t) {
												return s(this, void 0, void 0, (function*() {
													if ((e || t) && this.opponentSupportsSDPStreamMetadata()) try {
														c.logger.debug(`Upgrading call ${this.callId}: audio?=${e} video?=${t}`);
														const r = e || this.hasLocalUserMediaAudioTrack,
															n = t || this.hasLocalUserMediaVideoTrack,
															i = yield this.client.getMediaHandler().getUserMediaStream(r, n, !1);
														yield this.updateLocalUsermediaStream(i, e, t)
													} catch (r) {
														c.logger.error(`Call ${this.callId} Failed to upgrade the call`, r), this.emit(k.Error, new CallError(T.NoUserMedia, "Failed to get camera access: ", r))
													}
												}))
											}
											opponentSupportsSDPStreamMetadata() {
												return Boolean(this.remoteSDPStreamMetadata)
											}
											isScreensharing() {
												return Boolean(this.localScreensharingStream)
											}
											setScreensharingEnabled(e, t) {
												return s(this, void 0, void 0, (function*() {
													if (e && this.isScreensharing()) return c.logger.warn(`Call ${this.callId} There is already a screensharing stream - there is nothing to do!`), !0;
													if (!e && !this.isScreensharing()) return c.logger.warn(`Call ${this.callId} There already isn't a screensharing stream - there is nothing to do!`), !1;
													if (!this.opponentSupportsSDPStreamMetadata()) return this.setScreensharingEnabledWithoutMetadataSupport(e, t);
													if (c.logger.debug(`Call ${this.callId} set screensharing enabled? ${e}`), !e) {
														const e = this.transceivers.get(O(h.SDPStreamMetadataPurpose.Screenshare, "audio")),
															t = this.transceivers.get(O(h.SDPStreamMetadataPurpose.Screenshare, "video"));
														for (const r of [e, t]) r && r.sender && this.peerConn.removeTrack(r.sender);
														return this.client.getMediaHandler().stopScreensharingStream(this.localScreensharingStream), this.deleteFeedByStream(this.localScreensharingStream), !1
													}
													try {
														const e = yield this.client.getMediaHandler().getScreensharingStream(t);
														return !!e && (this.pushNewLocalFeed(e, h.SDPStreamMetadataPurpose.Screenshare), !0)
													} catch (r) {
														return c.logger.error(`Call ${this.callId} Failed to get screen-sharing stream:`, r), !1
													}
												}))
											}
											setScreensharingEnabledWithoutMetadataSupport(e, t) {
												var r, n, i;
												return s(this, void 0, void 0, (function*() {
													if (c.logger.debug(`Call ${this.callId} Set screensharing enabled? ${e} using replaceTrack()`), !e) {
														const e = null === (n = this.localUsermediaStream) || void 0 === n ? void 0 : n.getTracks().find(e => "video" === e.kind),
															t = null === (i = this.transceivers.get(O(h.SDPStreamMetadataPurpose.Usermedia, "video"))) || void 0 === i ? void 0 : i.sender;
														return null == t || t.replaceTrack(null != e ? e : null), this.client.getMediaHandler().stopScreensharingStream(this.localScreensharingStream), this.deleteFeedByStream(this.localScreensharingStream), !1
													}
													try {
														const e = yield this.client.getMediaHandler().getScreensharingStream(t);
														if (!e) return !1;
														const n = e.getTracks().find(e => "video" === e.kind),
															i = null === (r = this.transceivers.get(O(h.SDPStreamMetadataPurpose.Usermedia, "video"))) || void 0 === r ? void 0 : r.sender;
														return null == i || i.replaceTrack(null != n ? n : null), this.pushNewLocalFeed(e, h.SDPStreamMetadataPurpose.Screenshare, !1), !0
													} catch (o) {
														return c.logger.error(`Call ${this.callId} Failed to get screen-sharing stream:`, o), !1
													}
												}))
											}
											updateLocalUsermediaStream(e, t = !1, r = !1) {
												var n;
												return s(this, void 0, void 0, (function*() {
													const i = this.localUsermediaFeed,
														o = t || !i.isAudioMuted() && !this.remoteOnHold,
														s = r || !i.isVideoMuted() && !this.remoteOnHold;
													c.logger.log(`call ${this.callId} updateLocalUsermediaStream stream ${e.id} audioEnabled ${o} videoEnabled ${s}`), P(e.getAudioTracks(), o), P(e.getVideoTracks(), s);
													for (const e of this.localUsermediaStream.getTracks()) this.localUsermediaStream.removeTrack(e), e.stop();
													for (const t of e.getTracks()) this.localUsermediaStream.addTrack(t);
													for (const t of e.getTracks()) {
														const r = O(h.SDPStreamMetadataPurpose.Usermedia, t.kind),
															o = null === (n = this.transceivers.get(r)) || void 0 === n ? void 0 : n.sender;
														let s = !1;
														if (o) try {
															c.logger.info(`Call ${this.callId} ` + "Replacing track (" + `id="${t.id}", ` + `kind="${t.kind}", ` + `streamId="${e.id}", ` + `streamPurpose="${i.purpose}"` + ") to peer connection"), yield o.replaceTrack(t), s = !0
														} catch (a) {
															c.logger.warn("replaceTrack failed: adding new transceiver instead", a)
														}
														if (!s) {
															c.logger.info(`Call ${this.callId} ` + "Adding track (" + `id="${t.id}", ` + `kind="${t.kind}", ` + `streamId="${e.id}", ` + `streamPurpose="${i.purpose}"` + ") to peer connection");
															const n = this.peerConn.addTrack(t, this.localUsermediaStream),
																o = this.peerConn.getTransceivers().find(e => e.sender === n);
															o ? this.transceivers.set(r, o) : c.logger.warn("Couldn't find matching transceiver for newly added track!")
														}
													}
												}))
											}
											setLocalVideoMuted(e) {
												var t;
												return s(this, void 0, void 0, (function*() {
													return c.logger.log(`call ${this.callId} setLocalVideoMuted ${e}`), (yield this.client.getMediaHandler().hasVideoDevice()) ? this.hasLocalUserMediaVideoTrack || e ? (null === (t = this.localUsermediaFeed) || void 0 === t || t.setAudioVideoMuted(null, e), this.updateMuteStatus(), yield this.sendMetadataUpdate(), this.isLocalVideoMuted()) : (yield this.upgradeCall(!1, !0), this.isLocalVideoMuted()) : this.isLocalVideoMuted()
												}))
											}
											isLocalVideoMuted() {
												var e, t;
												return null !== (t = null === (e = this.localUsermediaFeed) || void 0 === e ? void 0 : e.isVideoMuted()) && void 0 !== t && t
											}
											setMicrophoneMuted(e) {
												var t;
												return s(this, void 0, void 0, (function*() {
													return c.logger.log(`call ${this.callId} setMicrophoneMuted ${e}`), (yield this.client.getMediaHandler().hasAudioDevice()) ? this.hasLocalUserMediaAudioTrack || e ? (null === (t = this.localUsermediaFeed) || void 0 === t || t.setAudioVideoMuted(e, null), this.updateMuteStatus(), yield this.sendMetadataUpdate(), this.isMicrophoneMuted()) : (yield this.upgradeCall(!0, !1), this.isMicrophoneMuted()) : this.isMicrophoneMuted()
												}))
											}
											isMicrophoneMuted() {
												var e, t;
												return null !== (t = null === (e = this.localUsermediaFeed) || void 0 === e ? void 0 : e.isAudioMuted()) && void 0 !== t && t
											}
											isRemoteOnHold() {
												return this.remoteOnHold
											}
											setRemoteOnHold(e) {
												if (this.isRemoteOnHold() !== e) {
													this.remoteOnHold = e;
													for (const t of this.peerConn.getTransceivers()) t.direction = e ? "sendonly" : "sendrecv";
													this.updateMuteStatus(), this.sendMetadataUpdate(), this.emit(k.RemoteHoldUnhold, this.remoteOnHold)
												}
											}
											isLocalOnHold() {
												if (this.state !== _.Connected) return !1;
												let e = !0;
												for (const t of this.peerConn.getTransceivers()) {
													["inactive", "recvonly"].includes(t.currentDirection) || (e = !1)
												}
												return e
											}
											sendDtmfDigit(e) {
												var t;
												for (const r of this.peerConn.getSenders())
													if ("audio" === (null === (t = r.track) || void 0 === t ? void 0 : t.kind) && r.dtmf) return void r.dtmf.insertDTMF(e);
												throw new Error("Unable to find a track to send DTMF on")
											}
											updateMuteStatus() {
												const e = this.isMicrophoneMuted() || this.remoteOnHold,
													t = this.isLocalVideoMuted() || this.remoteOnHold;
												c.logger.log(`call ${this.callId} updateMuteStatus stream ${this.localUsermediaStream.id} micShouldBeMuted ${e} vidShouldBeMuted ${t}`), P(this.localUsermediaStream.getAudioTracks(), !e), P(this.localUsermediaStream.getVideoTracks(), !t)
											}
											sendMetadataUpdate() {
												return s(this, void 0, void 0, (function*() {
													yield this.sendVoipEvent(u.EventType.CallSDPStreamMetadataChangedPrefix, {
														[h.SDPStreamMetadataKey]: this.getLocalSDPStreamMetadata()
													})
												}))
											}
											gotCallFeedsForInvite(e, t = !1) {
												if (this.successor) this.successor.queueGotCallFeedsForAnswer(e);
												else if (this.callHasEnded()) this.stopAllMedia();
												else {
													for (const t of e) this.pushLocalFeed(t);
													t && this.peerConn.addTransceiver("video", {
														direction: "recvonly"
													}), this.setState(_.CreateOffer), c.logger.debug(`Call ${this.callId} gotUserMediaForInvite`)
												}
											}
											sendAnswer() {
												return s(this, void 0, void 0, (function*() {
													const e = {
														answer: {
															sdp: this.peerConn.localDescription.sdp,
															type: this.peerConn.localDescription.type
														},
														[h.SDPStreamMetadataKey]: this.getLocalSDPStreamMetadata(!0)
													};
													e.capabilities = {
														"m.call.transferee": this.client.supportsCallTransfer,
														"m.call.dtmf": !1
													};
													const t = this.discardDuplicateCandidates();
													c.logger.info(`Call ${this.callId} Discarding ${t} candidates that will be sent in answer`);
													try {
														yield this.sendVoipEvent(u.EventType.CallAnswer, e), this.inviteOrAnswerSent = !0
													} catch (r) {
														this.setState(_.Ringing), r instanceof m.MatrixError && r.event && this.client.cancelPendingEvent(r.event);
														let e = T.SendAnswer,
															t = "Failed to send answer";
														throw "UnknownDeviceError" == r.name && (e = T.UnknownDevices, t = "Unknown devices present in the room"), this.emit(k.Error, new CallError(e, t, r)), r
													}
													this.sendCandidateQueue()
												}))
											}
											queueGotCallFeedsForAnswer(e) {
												this.responsePromiseChain ? this.responsePromiseChain = this.responsePromiseChain.then(() => this.gotCallFeedsForAnswer(e)) : this.responsePromiseChain = this.gotCallFeedsForAnswer(e)
											}
											mungeSdp(e, t) {
												const r = (0, a.parse)(e.sdp);
												r.media.forEach(e => {
													const r = new Map,
														n = new Map;
													for (const t of e.rtp) r.set(t.payload, t.codec), n.set(t.codec, t.payload);
													for (const i of t) {
														if (i.mediaType !== e.type) continue;
														if (!n.has(i.codec)) {
															c.logger.info(`Ignoring SDP modifications for ${i.codec} as it's not present.`);
															continue
														}
														const t = [];
														void 0 !== i.enableDtx && t.push(`usedtx=${i.enableDtx?"1":"0"}`), void 0 !== i.maxAverageBitrate && t.push(`maxaveragebitrate=${i.maxAverageBitrate}`);
														let o = !1;
														for (const n of e.fmtp) r.get(n.payload) === i.codec && (o = !0, n.config += ";" + t.join(";"));
														o || e.fmtp.push({
															payload: n.get(i.codec),
															config: t.join(";")
														})
													}
												}), e.sdp = (0, a.write)(r)
											}
											createOffer() {
												return s(this, void 0, void 0, (function*() {
													const e = yield this.peerConn.createOffer();
													return this.mungeSdp(e, x(this.isPtt)), e
												}))
											}
											createAnswer() {
												return s(this, void 0, void 0, (function*() {
													const e = yield this.peerConn.createAnswer();
													return this.mungeSdp(e, x(this.isPtt)), e
												}))
											}
											gotCallFeedsForAnswer(e) {
												return s(this, void 0, void 0, (function*() {
													if (this.callHasEnded()) return;
													this.waitForLocalAVStream = !1;
													for (const n of e) this.pushLocalFeed(n);
													let t;
													this.setState(_.CreateAnswer);
													try {
														this.getRidOfRTXCodecs(), t = yield this.createAnswer()
													} catch (r) {
														return c.logger.debug(`Call ${this.callId} Failed to create answer: `, r), void this.terminate(E.Local, T.CreateAnswer, !0)
													}
													try {
														if (yield this.peerConn.setLocalDescription(t), this.callHasEnded()) return;
														if (this.setState(_.Connecting), yield new Promise(e => {
																setTimeout(e, 200)
															}), this.callHasEnded()) return;
														this.sendAnswer()
													} catch (r) {
														return c.logger.debug(`Call ${this.callId} Error setting local description!`, r), void this.terminate(E.Local, T.SetLocalDescription, !0)
													}
												}))
											}
											onRemoteIceCandidatesReceived(e) {
												return s(this, void 0, void 0, (function*() {
													if (this.callHasEnded()) return;
													const t = e.getContent(),
														r = t.candidates;
													if (!r) return void c.logger.info(`Call ${this.callId} Ignoring candidates event with no candidates!`);
													const n = 0 === t.version ? null : t.party_id || null;
													if (void 0 !== this.opponentPartyId) this.partyIdMatches(t) ? yield this.addIceCandidates(r): c.logger.info(`Call ${this.callId} ` + `Ignoring candidates from party ID ${t.party_id}: ` + `we have chosen party ID ${this.opponentPartyId}`);
													else if (n) {
														c.logger.info(`Call ${this.callId} Buffering ${r.length} candidates until we pick an opponent`);
														const e = this.remoteCandidateBuffer.get(n) || [];
														e.push(...r), this.remoteCandidateBuffer.set(n, e)
													}
												}))
											}
											onAnswerReceived(e) {
												return s(this, void 0, void 0, (function*() {
													const t = e.getContent();
													if (c.logger.debug(`Got answer for call ID ${this.callId} from party ID ${t.party_id}`), this.callHasEnded()) return void c.logger.debug(`Ignoring answer because call ID ${this.callId} has ended`);
													if (void 0 !== this.opponentPartyId) return void c.logger.info(`Call ${this.callId} ` + `Ignoring answer from party ID ${t.party_id}: ` + `we already have an answer/reject from ${this.opponentPartyId}`);
													this.chooseOpponent(e), yield this.addBufferedIceCandidates(), this.setState(_.Connecting);
													const r = t[h.SDPStreamMetadataKey];
													r ? this.updateRemoteSDPStreamMetadata(r) : c.logger.warn(`Call ${this.callId} Did not get any SDPStreamMetadata! Can not send/receive multiple streams`);
													try {
														yield this.peerConn.setRemoteDescription(t.answer)
													} catch (n) {
														return c.logger.debug(`Call ${this.callId} Failed to set remote description`, n), void this.terminate(E.Local, T.SetRemoteDescription, !1)
													}
													if (null !== this.opponentPartyId) try {
														yield this.sendVoipEvent(u.EventType.CallSelectAnswer, {
															selected_party_id: this.opponentPartyId
														})
													} catch (i) {
														c.logger.warn(`Call ${this.callId} Failed to send select_answer event`, i)
													}
												}))
											}
											onSelectAnswerReceived(e) {
												return s(this, void 0, void 0, (function*() {
													if (this.direction !== S.Inbound) return void c.logger.warn(`Call ${this.callId} Got select_answer for an outbound call: ignoring`);
													const t = e.getContent().selected_party_id;
													null != t ? t !== this.ourPartyId && (c.logger.info(`Call ${this.callId} Got select_answer for party ID ${t}: we are party ID ${this.ourPartyId}.`), yield this.terminate(E.Remote, T.AnsweredElsewhere, !0)) : c.logger.warn(`Call ${this.callId} Got nonsensical select_answer with null/undefined selected_party_id: ignoring`)
												}))
											}
											onNegotiateReceived(e) {
												var t;
												return s(this, void 0, void 0, (function*() {
													const r = e.getContent(),
														n = r.description;
													if (!n || !n.sdp || !n.type) return void c.logger.info(`Call ${this.callId} Ignoring invalid m.call.negotiate event`);
													const i = this.direction === S.Inbound,
														o = "offer" === n.type && (this.makingOffer || "stable" !== this.peerConn.signalingState);
													if (this.ignoreOffer = !i && o, this.ignoreOffer) return void c.logger.info(`Call ${this.callId} Ignoring colliding negotiate event because we're impolite`);
													const s = this.isLocalOnHold(),
														a = r[h.SDPStreamMetadataKey];
													a ? this.updateRemoteSDPStreamMetadata(a) : c.logger.warn(`Call ${this.callId} Received negotiation event without SDPStreamMetadata!`);
													try {
														if (yield this.peerConn.setRemoteDescription(n), "offer" === n.type) {
															let e;
															try {
																this.getRidOfRTXCodecs(), e = yield this.createAnswer()
															} catch (d) {
																return c.logger.debug(`Call ${this.callId} Failed to create answer: `, d), void this.terminate(E.Local, T.CreateAnswer, !0)
															}
															yield this.peerConn.setLocalDescription(e), this.sendVoipEvent(u.EventType.CallNegotiate, {
																description: null === (t = this.peerConn.localDescription) || void 0 === t ? void 0 : t.toJSON(),
																[h.SDPStreamMetadataKey]: this.getLocalSDPStreamMetadata(!0)
															})
														}
													} catch (d) {
														c.logger.warn(`Call ${this.callId} Failed to complete negotiation`, d)
													}
													const l = this.isLocalOnHold();
													s !== l && (this.emit(k.LocalHoldUnhold, l), this.emit(k.HoldUnhold, l))
												}))
											}
											updateRemoteSDPStreamMetadata(e) {
												var t;
												this.remoteSDPStreamMetadata = l.recursivelyAssign(this.remoteSDPStreamMetadata || {}, e, !0);
												for (const r of this.getRemoteFeeds()) {
													const e = r.stream.id,
														n = this.remoteSDPStreamMetadata[e];
													r.setAudioVideoMuted(null == n ? void 0 : n.audio_muted, null == n ? void 0 : n.video_muted), r.purpose = null === (t = this.remoteSDPStreamMetadata[e]) || void 0 === t ? void 0 : t.purpose
												}
											}
											onSDPStreamMetadataChangedReceived(e) {
												const t = e.getContent()[h.SDPStreamMetadataKey];
												this.updateRemoteSDPStreamMetadata(t)
											}
											onAssertedIdentityReceived(e) {
												return s(this, void 0, void 0, (function*() {
													const t = e.getContent();
													t.asserted_identity && (this.remoteAssertedIdentity = {
														id: t.asserted_identity.id,
														displayName: t.asserted_identity.display_name
													}, this.emit(k.AssertedIdentityChanged))
												}))
											}
											callHasEnded() {
												return this.state === _.Ended
											}
											queueGotLocalOffer() {
												this.responsePromiseChain ? this.responsePromiseChain = this.responsePromiseChain.then(() => this.wrappedGotLocalOffer()) : this.responsePromiseChain = this.wrappedGotLocalOffer()
											}
											wrappedGotLocalOffer() {
												return s(this, void 0, void 0, (function*() {
													this.makingOffer = !0;
													try {
														yield this.gotLocalOffer()
													} catch (e) {
														return void this.getLocalOfferFailed(e)
													} finally {
														this.makingOffer = !1
													}
												}))
											}
											gotLocalOffer() {
												var e, t;
												return s(this, void 0, void 0, (function*() {
													if (c.logger.debug(`Call ${this.callId} Setting local description`), this.callHasEnded()) return void c.logger.debug("Ignoring newly created offer on call ID " + this.callId + " because the call has ended");
													let r;
													try {
														this.getRidOfRTXCodecs(), r = yield this.createOffer()
													} catch (s) {
														return c.logger.debug(`Call ${this.callId} Failed to create offer: `, s), void this.terminate(E.Local, T.CreateOffer, !0)
													}
													try {
														yield this.peerConn.setLocalDescription(r)
													} catch (s) {
														return c.logger.debug(`Call ${this.callId} Error setting local description!`, s), void this.terminate(E.Local, T.SetLocalDescription, !0)
													}
													if ("gathering" === this.peerConn.iceGatheringState && (yield new Promise(e => {
															setTimeout(e, 200)
														})), this.callHasEnded()) return;
													const n = this.state === _.CreateOffer ? u.EventType.CallInvite : u.EventType.CallNegotiate,
														i = {
															lifetime: C
														};
													n === u.EventType.CallInvite && this.invitee && (i.invitee = this.invitee), this.state === _.CreateOffer ? i.offer = null === (e = this.peerConn.localDescription) || void 0 === e ? void 0 : e.toJSON() : i.description = null === (t = this.peerConn.localDescription) || void 0 === t ? void 0 : t.toJSON(), i.capabilities = {
														"m.call.transferee": this.client.supportsCallTransfer,
														"m.call.dtmf": !1
													}, i[h.SDPStreamMetadataKey] = this.getLocalSDPStreamMetadata(!0);
													const o = this.discardDuplicateCandidates();
													c.logger.info(`Call ${this.callId} Discarding ${o} candidates that will be sent in offer`);
													try {
														yield this.sendVoipEvent(n, i)
													} catch (a) {
														c.logger.error(`Call ${this.callId} Failed to send invite`, a), a instanceof m.MatrixError && a.event && this.client.cancelPendingEvent(a.event);
														let e = T.SignallingFailed,
															t = "Signalling failed";
														return this.state === _.CreateOffer && (e = T.SendInvite, t = "Failed to send invite"), "UnknownDeviceError" == a.name && (e = T.UnknownDevices, t = "Unknown devices present in the room"), this.emit(k.Error, new CallError(e, t, a)), void this.terminate(E.Local, e, !1)
													}
													this.sendCandidateQueue(), this.state === _.CreateOffer && (this.inviteOrAnswerSent = !0, this.setState(_.InviteSent), this.inviteTimeout = setTimeout(() => {
														this.inviteTimeout = void 0, this.state === _.InviteSent && this.hangup(T.InviteTimeout, !1)
													}, C))
												}))
											}
											getRidOfRTXCodecs() {
												if (!RTCRtpReceiver.getCapabilities || !RTCRtpSender.getCapabilities) return;
												const e = RTCRtpReceiver.getCapabilities("video").codecs,
													t = [...RTCRtpSender.getCapabilities("video").codecs, ...e];
												for (const n of t)
													if ("video/rtx" === n.mimeType) {
														const e = t.indexOf(n);
														t.splice(e, 1)
													} const r = this.transceivers.get(O(h.SDPStreamMetadataPurpose.Screenshare, "video"));
												r && r.setCodecPreferences(t)
											}
											setState(e) {
												const t = this.state;
												this.state = e, this.emit(k.State, e, t)
											}
											sendVoipEvent(e, t) {
												var r, n;
												return s(this, void 0, void 0, (function*() {
													const i = Object.assign({}, t, {
														version: I,
														call_id: this.callId,
														party_id: this.ourPartyId,
														conf_id: this.groupCallId
													});
													if (this.opponentDeviceId) {
														const t = this.toDeviceSeq++,
															n = Object.assign(Object.assign({}, i), {
																device_id: this.client.deviceId,
																sender_session_id: this.client.getSessionId(),
																dest_session_id: this.opponentSessionId,
																seq: t
															});
														this.emit(k.SendVoipEvent, {
															type: "toDevice",
															eventType: e,
															userId: this.invitee || (null === (r = this.getOpponentMember()) || void 0 === r ? void 0 : r.userId),
															opponentDeviceId: this.opponentDeviceId,
															content: n
														});
														const o = this.invitee || this.getOpponentMember().userId;
														this.client.getUseE2eForGroupCall() ? yield this.client.encryptAndSendToDevices([{
															userId: o,
															deviceInfo: this.opponentDeviceInfo
														}], {
															type: e,
															content: n
														}): yield this.client.sendToDevice(e, {
															[o]: {
																[this.opponentDeviceId]: n
															}
														})
													} else this.emit(k.SendVoipEvent, {
														type: "sendEvent",
														eventType: e,
														roomId: this.roomId,
														content: i,
														userId: this.invitee || (null === (n = this.getOpponentMember()) || void 0 === n ? void 0 : n.userId)
													}), yield this.client.sendEvent(this.roomId, e, i)
												}))
											}
											queueCandidate(e) {
												if (e ? this.candidateSendQueue.push(e) : this.candidatesEnded = !0, this.state === _.Ringing || !this.inviteOrAnswerSent) return;
												const t = this.direction === S.Inbound ? 500 : 2e3;
												0 === this.candidateSendTries && setTimeout(() => {
													this.sendCandidateQueue()
												}, t)
											}
											discardDuplicateCandidates() {
												let e = 0;
												const t = [];
												for (let r = 0; r < this.candidateSendQueue.length; r++) {
													const n = this.candidateSendQueue[r];
													"" === n.candidate ? t.push(n) : e++
												}
												return this.candidateSendQueue = t, e
											}
											transfer(e) {
												return s(this, void 0, void 0, (function*() {
													const t = yield this.client.getProfileInfo(e), r = M(), n = {
														replacement_id: M(),
														target_user: {
															id: e,
															display_name: t.displayname,
															avatar_url: t.avatar_url
														},
														create_call: r
													};
													yield this.sendVoipEvent(u.EventType.CallReplaces, n), yield this.terminate(E.Local, T.Transfered, !0)
												}))
											}
											transferToCall(e) {
												var t, r;
												return s(this, void 0, void 0, (function*() {
													const n = null === (t = e.getOpponentMember()) || void 0 === t ? void 0 : t.userId,
														i = n ? yield this.client.getProfileInfo(n): void 0, o = null === (r = this.getOpponentMember()) || void 0 === r ? void 0 : r.userId, s = o ? yield this.client.getProfileInfo(o): void 0, a = M(), c = {
															replacement_id: M(),
															target_user: {
																id: o,
																display_name: null == s ? void 0 : s.displayname,
																avatar_url: null == s ? void 0 : s.avatar_url
															},
															await_call: a
														};
													yield e.sendVoipEvent(u.EventType.CallReplaces, c);
													const l = {
														replacement_id: M(),
														target_user: {
															id: n,
															display_name: null == i ? void 0 : i.displayname,
															avatar_url: null == i ? void 0 : i.avatar_url
														},
														create_call: a
													};
													yield this.sendVoipEvent(u.EventType.CallReplaces, l), yield this.terminate(E.Local, T.Transfered, !0), yield e.terminate(E.Local, T.Transfered, !0)
												}))
											}
											terminate(e, t, r) {
												return s(this, void 0, void 0, (function*() {
													if (!this.callHasEnded()) {
														this.hangupParty = e, this.hangupReason = t, this.setState(_.Ended), this.inviteTimeout && (clearTimeout(this.inviteTimeout), this.inviteTimeout = void 0), this.callLengthInterval && (clearInterval(this.callLengthInterval), this.callLengthInterval = void 0);
														for (const [e, t] of this.removeTrackListeners) e.removeEventListener("removetrack", t);
														this.removeTrackListeners.clear(), this.callStatsAtEnd = yield this.collectCallStats(), this.stopAllMedia(), this.deleteAllFeeds(), this.peerConn && "closed" !== this.peerConn.signalingState && this.peerConn.close(), r && this.emit(k.Hangup, this), this.client.callEventHandler.calls.delete(this.callId)
													}
												}))
											}
											stopAllMedia() {
												c.logger.debug(this.groupCallId ? `Call ${this.callId} stopping all media except local feeds` : `Call ${this.callId} stopping all media`);
												for (const e of this.feeds)
													if (e.isLocal() && e.purpose === h.SDPStreamMetadataPurpose.Usermedia && !this.groupCallId) this.client.getMediaHandler().stopUserMediaStream(e.stream);
													else if (e.isLocal() && e.purpose === h.SDPStreamMetadataPurpose.Screenshare && !this.groupCallId) this.client.getMediaHandler().stopScreensharingStream(e.stream);
												else if (!e.isLocal() || !this.groupCallId) {
													c.logger.debug("Stopping remote stream", e.stream.id);
													for (const t of e.stream.getTracks()) t.stop()
												}
											}
											checkForErrorListener() {
												if (0 === this.listeners(p.EventEmitterEvents.Error).length) throw new Error("You MUST attach an error listener using call.on('error', function() {})")
											}
											sendCandidateQueue() {
												return s(this, void 0, void 0, (function*() {
													if (0 === this.candidateSendQueue.length || this.callHasEnded()) return;
													const e = this.candidateSendQueue;
													this.candidateSendQueue = [], ++this.candidateSendTries;
													const t = {
														candidates: e.map(e => e.toJSON())
													};
													this.candidatesEnded && t.candidates.push({
														candidate: ""
													}), c.logger.debug(`Call ${this.callId} attempting to send ${e.length} candidates`);
													try {
														yield this.sendVoipEvent(u.EventType.CallCandidates, t), this.candidateSendTries = 0, this.sendCandidateQueue()
													} catch (r) {
														if (r instanceof m.MatrixError && r.event && this.client.cancelPendingEvent(r.event), this.candidateSendQueue.push(...e), this.candidateSendTries > 5) {
															c.logger.debug(`Call ${this.callId} failed to send candidates on attempt ${this.candidateSendTries}. Giving up on this call.`, r);
															const e = T.SignallingFailed,
																t = "Signalling failed";
															return this.emit(k.Error, new CallError(e, t, r)), void this.hangup(e, !1)
														}
														const t = 500 * Math.pow(2, this.candidateSendTries);
														++this.candidateSendTries, c.logger.debug(`Call ${this.callId} failed to send candidates. Retrying in ${t}ms`, r), setTimeout(() => {
															this.sendCandidateQueue()
														}, t)
													}
												}))
											}
											placeCall(e, t) {
												return s(this, void 0, void 0, (function*() {
													if (!e) throw new Error("You CANNOT start a call without audio");
													this.setState(_.WaitLocalMedia);
													try {
														const r = yield this.client.getMediaHandler().getUserMediaStream(e, t);
														P(r.getAudioTracks(), !0), P(r.getVideoTracks(), !0);
														const n = new f.CallFeed({
															client: this.client,
															roomId: this.roomId,
															userId: this.client.getUserId(),
															stream: r,
															purpose: h.SDPStreamMetadataPurpose.Usermedia,
															audioMuted: !1,
															videoMuted: !1
														});
														yield this.placeCallWithCallFeeds([n])
													} catch (r) {
														return void this.getUserMediaFailed(r)
													}
												}))
											}
											placeCallWithCallFeeds(e, t = !1) {
												return s(this, void 0, void 0, (function*() {
													this.checkForErrorListener(), this.direction = S.Outbound, yield this.initOpponentCrypto(), this.client.callEventHandler.calls.set(this.callId, this), (yield this.client.checkTurnServers()) || c.logger.warn(`Call ${this.callId} Failed to get TURN credentials! Proceeding with call anyway...`), this.peerConn = this.createPeerConnection(), this.gotCallFeedsForInvite(e, t)
												}))
											}
											createPeerConnection() {
												const e = new window.RTCPeerConnection({
													iceTransportPolicy: this.forceTURN ? "relay" : void 0,
													iceServers: this.turnServers,
													iceCandidatePoolSize: this.client.iceCandidatePoolSize,
													bundlePolicy: "max-bundle"
												});
												return e.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChanged), e.addEventListener("signalingstatechange", this.onSignallingStateChanged), e.addEventListener("icecandidate", this.gotLocalIceCandidate), e.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange), e.addEventListener("track", this.onTrack), e.addEventListener("negotiationneeded", this.onNegotiationNeeded), e.addEventListener("datachannel", this.onDataChannel), e
											}
											partyIdMatches(e) {
												return (0 === e.version ? null : e.party_id || null) === this.opponentPartyId
											}
											chooseOpponent(e) {
												var t;
												const r = e.getContent();
												c.logger.debug(`Call ${this.callId} choosing opponent party ID ${r.party_id}`), this.opponentVersion = r.version, 0 === this.opponentVersion ? this.opponentPartyId = null : this.opponentPartyId = r.party_id || null, this.opponentCaps = r.capabilities || {}, this.opponentMember = null !== (t = this.client.getRoom(this.roomId).getMember(e.getSender())) && void 0 !== t ? t : void 0
											}
											addBufferedIceCandidates() {
												return s(this, void 0, void 0, (function*() {
													const e = this.remoteCandidateBuffer.get(this.opponentPartyId);
													e && (c.logger.info(`Call ${this.callId} Adding ${e.length} buffered candidates for opponent ${this.opponentPartyId}`), yield this.addIceCandidates(e)), this.remoteCandidateBuffer.clear()
												}))
											}
											addIceCandidates(e) {
												return s(this, void 0, void 0, (function*() {
													for (const r of e) {
														null !== r.sdpMid && void 0 !== r.sdpMid || null !== r.sdpMLineIndex && void 0 !== r.sdpMLineIndex ? c.logger.debug(`Call ${this.callId} got remote ICE ${r.sdpMid} candidate: ${r.candidate}`) : c.logger.debug(`Call ${this.callId} got remote ICE end-of-candidates`);
														try {
															yield this.peerConn.addIceCandidate(r)
														} catch (t) {
															this.ignoreOffer || c.logger.info(`Call ${this.callId} failed to add remote ICE candidate`, t)
														}
													}
												}))
											}
											get hasPeerConnection() {
												return Boolean(this.peerConn)
											}
										}

										function P(e, t) {
											for (const r of e) r.enabled = t
										}

										function D() {
											if ("undefined" == typeof window || "undefined" == typeof document) return !1;
											try {
												if (!Boolean(window.RTCPeerConnection || window.RTCSessionDescription || window.RTCIceCandidate || navigator.mediaDevices)) return "test" !== t.env.NODE_ENV && c.logger.error("WebRTC is not supported in this browser / environment"), !1
											} catch (e) {
												return c.logger.error("Exception thrown when trying to access WebRTC", e), !1
											}
											return !0
										}
										r.MatrixCall = A, r.setTracksEnabled = P, r.supportsMatrixCall = D, r.createNewMatrixCall = function(e, t, r) {
											if (!D()) return null;
											const n = !!r && r.forceTURN,
												i = {
													client: e,
													roomId: t,
													invitee: null == r ? void 0 : r.invitee,
													turnServers: e.getTurnServers(),
													forceTURN: e.forceTURN || n,
													opponentDeviceId: null == r ? void 0 : r.opponentDeviceId,
													opponentSessionId: null == r ? void 0 : r.opponentSessionId,
													groupCallId: null == r ? void 0 : r.groupCallId
												},
												o = new A(i);
											return e.reEmitter.reEmit(o, Object.values(k)), o
										}
									}).call(this)
								}).call(this, e("_process"))
							}, {
								"../@types/event": 290,
								"../crypto/deviceinfo": 323,
								"../http-api": 349,
								"../logger": 356,
								"../models/typed-event-emitter": 376,
								"../randomstring": 379,
								"../utils": 393,
								"./callEventTypes": 397,
								"./callFeed": 398,
								"./groupCall": 399,
								_process: 238,
								"sdp-transform": 254
							}],
							396: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.CallEventHandler = r.CallEventHandlerEvent = void 0;
								const i = e("../logger"),
									o = e("./call"),
									s = e("../@types/event"),
									a = e("../client"),
									c = e("./groupCall"),
									l = e("../models/room"),
									u = 3e3;
								var d;
								! function(e) {
									e.Incoming = "Call.incoming"
								}(d = r.CallEventHandlerEvent || (r.CallEventHandlerEvent = {}));
								r.CallEventHandler = class {
									constructor(e) {
										this.nextSeqByCall = new Map, this.toDeviceEventBuffers = new Map, this.onSync = () => {
											const e = this.callEventBuffer;
											this.callEventBuffer = [], this.eventBufferPromiseChain ? this.eventBufferPromiseChain = this.eventBufferPromiseChain.then(() => this.evaluateEventBuffer(e)) : this.eventBufferPromiseChain = this.evaluateEventBuffer(e)
										}, this.onRoomTimeline = e => {
											this.callEventBuffer.push(e)
										}, this.onToDeviceEvent = e => {
											const t = e.getContent();
											if (!t.call_id) return void this.callEventBuffer.push(e);
											if (this.nextSeqByCall.has(t.call_id) || this.nextSeqByCall.set(t.call_id, 0), void 0 === t.seq) return void this.callEventBuffer.push(e);
											const r = this.nextSeqByCall.get(t.call_id) || 0;
											if (t.seq !== r) {
												this.toDeviceEventBuffers.has(t.call_id) || this.toDeviceEventBuffers.set(t.call_id, []);
												const r = this.toDeviceEventBuffers.get(t.call_id),
													n = r.findIndex(e => e.getContent().seq > t.seq); - 1 === n ? r.push(e) : r.splice(n, 0, e)
											} else {
												const r = t.call_id;
												this.callEventBuffer.push(e), this.nextSeqByCall.set(r, t.seq + 1);
												const n = this.toDeviceEventBuffers.get(r);
												let i = n && n.shift();
												for (; i && i.getContent().seq === this.nextSeqByCall.get(r);) this.callEventBuffer.push(i), this.nextSeqByCall.set(r, i.getContent().seq + 1), i = n.shift()
											}
										}, this.client = e, this.calls = new Map, this.callEventBuffer = [], this.candidateEventsByCall = new Map
									}
									start() {
										this.client.on(a.ClientEvent.Sync, this.onSync), this.client.on(l.RoomEvent.Timeline, this.onRoomTimeline), this.client.on(a.ClientEvent.ToDeviceEvent, this.onToDeviceEvent)
									}
									stop() {
										this.client.removeListener(a.ClientEvent.Sync, this.onSync), this.client.removeListener(l.RoomEvent.Timeline, this.onRoomTimeline), this.client.removeListener(a.ClientEvent.ToDeviceEvent, this.onToDeviceEvent)
									}
									evaluateEventBuffer(e) {
										return n(this, void 0, void 0, (function*() {
											yield Promise.all(e.map(e => this.client.decryptEventIfNeeded(e)));
											const t = e.filter(e => {
													const t = e.getType();
													return t.startsWith("m.call.") || t.startsWith("org.matrix.call.")
												}),
												r = new Set;
											for (const e of t) {
												const t = e.getType();
												t !== s.EventType.CallAnswer && t !== s.EventType.CallHangup || r.add(e.getContent().call_id)
											}
											for (const e of t) {
												const t = e.getType(),
													o = e.getContent().call_id;
												if (t !== s.EventType.CallInvite || !r.has(o)) try {
													yield this.handleCallEvent(e)
												} catch (n) {
													i.logger.error("Caught exception handling call event", n)
												}
											}
										}))
									}
									handleCallEvent(e) {
										var t, r, l, h, f, p;
										return n(this, void 0, void 0, (function*() {
											this.client.emit(a.ClientEvent.ReceivedVoipEvent, e);
											const n = e.getContent(),
												v = e.getRoomId() || (null === (r = null === (t = this.client.groupCallEventHandler.getGroupCallById(n.conf_id)) || void 0 === t ? void 0 : t.room) || void 0 === r ? void 0 : r.roomId),
												g = n.conf_id,
												m = e.getType(),
												y = e.getSender(),
												b = y === this.client.credentials.userId;
											let _, w, S = n.call_id ? this.calls.get(n.call_id) : void 0;
											if (g) {
												if (!(w = this.client.groupCallEventHandler.getGroupCallById(g))) return void i.logger.warn(`Cannot find a group call ${g} for event ${m}. Ignoring event.`);
												if (!(_ = n.device_id)) return i.logger.warn(`Cannot find a device id for ${y}. Ignoring event.`), void w.emit(c.GroupCallEvent.Error, new c.GroupCallUnknownDeviceError(y));
												if (n.dest_session_id !== this.client.getSessionId()) return void i.logger.warn("Call event does not match current session id, ignoring.")
											}
											if (v)
												if (m !== s.EventType.CallInvite)
													if (m !== s.EventType.CallCandidates)
														if ([s.EventType.CallHangup, s.EventType.CallReject].includes(m)) S ? S.state !== o.CallState.Ended && (m === s.EventType.CallHangup ? S.onHangupReceived(n) : S.onRejectReceived(n), S.state === o.CallState.Ended && this.calls.delete(n.call_id)) : (S = null !== (p = (0, o.createNewMatrixCall)(this.client, v, {
															opponentDeviceId: _,
															opponentSessionId: n.sender_session_id
														})) && void 0 !== p ? p : void 0) && (S.callId = n.call_id, S.initWithHangup(e), this.calls.set(n.call_id, S));
														else if (S && S.hasPeerConnection) {
												if (e.getContent().party_id !== S.ourPartyId) switch (m) {
													case s.EventType.CallAnswer:
														b ? S.state === o.CallState.Ringing && S.onAnsweredElsewhere(n) : S.onAnswerReceived(e);
														break;
													case s.EventType.CallSelectAnswer:
														S.onSelectAnswerReceived(e);
														break;
													case s.EventType.CallNegotiate:
														S.onNegotiateReceived(e);
														break;
													case s.EventType.CallAssertedIdentity:
													case s.EventType.CallAssertedIdentityPrefix:
														S.onAssertedIdentityReceived(e);
														break;
													case s.EventType.CallSDPStreamMetadataChanged:
													case s.EventType.CallSDPStreamMetadataChangedPrefix:
														S.onSDPStreamMetadataChangedReceived(e)
												}
											} else i.logger.info(`Discarding possible call event ${e.getId()} as we don't have a call/peerConn`, m);
											else {
												if (b) return;
												S ? S.onRemoteIceCandidatesReceived(e) : (this.candidateEventsByCall.has(n.call_id) || this.candidateEventsByCall.set(n.call_id, []), this.candidateEventsByCall.get(n.call_id).push(e))
											} else {
												if (b) return;
												if (e.getLocalAge() > n.lifetime - u) return;
												if (S && S.state === o.CallState.Ended) return;
												if (S && i.logger.log(`WARN: Already have a MatrixCall with id ${n.call_id} but got an ` + "invite. Clobbering."), n.invitee && n.invitee !== this.client.getUserId()) return;
												const t = (null !== (l = this.client.getTurnServersExpiry()) && void 0 !== l ? l : 0) - Date.now();
												if (i.logger.info("Current turn creds expire in " + t + " ms"), !(S = null !== (h = (0, o.createNewMatrixCall)(this.client, v, {
														forceTURN: this.client.forceTURN,
														opponentDeviceId: _,
														groupCallId: g,
														opponentSessionId: n.sender_session_id
													})) && void 0 !== h ? h : void 0)) return void i.logger.log("Incoming call ID " + n.call_id + " but this client doesn't support WebRTC");
												S.callId = n.call_id;
												try {
													yield S.initWithInvite(e)
												} catch (E) {
													E instanceof o.CallError && (E.code === c.GroupCallErrorCode.UnknownDevice ? null == w || w.emit(c.GroupCallEvent.Error, E) : i.logger.error(E))
												}
												if (this.calls.set(S.callId, S), this.candidateEventsByCall.get(S.callId))
													for (const e of this.candidateEventsByCall.get(S.callId)) S.onRemoteIceCandidatesReceived(e);
												let r;
												for (const e of this.calls.values()) {
													const t = [o.CallState.WaitLocalMedia, o.CallState.CreateOffer, o.CallState.InviteSent].includes(e.state);
													if (S.roomId === e.roomId && e.direction === o.CallDirection.Outbound && (null === (f = S.getOpponentMember()) || void 0 === f ? void 0 : f.userId) === e.invitee && t) {
														r = e;
														break
													}
												}
												r ? r.callId > S.callId ? (i.logger.log("Glare detected: answering incoming call " + S.callId + " and canceling outgoing call " + r.callId), r.replacedBy(S)) : (i.logger.log("Glare detected: rejecting incoming call " + S.callId + " and keeping outgoing call " + r.callId), S.hangup(o.CallErrorCode.Replaced, !0)) : this.client.emit(d.Incoming, S)
											}
										}))
									}
								}
							}, {
								"../@types/event": 290,
								"../client": 304,
								"../logger": 356,
								"../models/room": 373,
								"./call": 395,
								"./groupCall": 399
							}],
							397: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
										value: !0
									}), r.SDPStreamMetadataPurpose = r.SDPStreamMetadataKey = void 0, r.SDPStreamMetadataKey = "org.matrix.msc3077.sdp_stream_metadata",
									function(e) {
										e.Usermedia = "m.usermedia", e.Screenshare = "m.screenshare"
									}(r.SDPStreamMetadataPurpose || (r.SDPStreamMetadataPurpose = {}))
							}, {}],
							398: [function(e, t, r) {
								"use strict";
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.CallFeed = r.CallFeedEvent = r.SPEAKING_THRESHOLD = void 0;
								const n = e("./callEventTypes"),
									i = e("./audioContext"),
									o = e("../logger"),
									s = e("../models/typed-event-emitter"),
									a = 200;
								r.SPEAKING_THRESHOLD = -60;
								const c = 8;
								var l;
								! function(e) {
									e.NewStream = "new_stream", e.MuteStateChanged = "mute_state_changed", e.LocalVolumeChanged = "local_volume_changed", e.VolumeChanged = "volume_changed", e.Speaking = "speaking", e.Disposed = "disposed"
								}(l = r.CallFeedEvent || (r.CallFeedEvent = {}));
								class u extends s.TypedEventEmitter {
									constructor(e) {
										super(), this.localVolume = 1, this.measuringVolumeActivity = !1, this.speakingThreshold = r.SPEAKING_THRESHOLD, this.speaking = !1, this._disposed = !1, this.onAddTrack = () => {
											this.emit(l.NewStream, this.stream)
										}, this.volumeLooper = () => {
											if (!this.analyser) return;
											if (!this.measuringVolumeActivity) return;
											this.analyser.getFloatFrequencyData(this.frequencyBinCount);
											let e = -1 / 0;
											for (const r of this.frequencyBinCount) r > e && (e = r);
											this.speakingVolumeSamples.shift(), this.speakingVolumeSamples.push(e), this.emit(l.VolumeChanged, e);
											let t = !1;
											for (const r of this.speakingVolumeSamples)
												if (r > this.speakingThreshold) {
													t = !0;
													break
												} this.speaking !== t && (this.speaking = t, this.emit(l.Speaking, this.speaking)), this.volumeLooperTimeout = setTimeout(this.volumeLooper, a)
										}, this.client = e.client, this.roomId = e.roomId, this.userId = e.userId, this.purpose = e.purpose, this.audioMuted = e.audioMuted, this.videoMuted = e.videoMuted, this.speakingVolumeSamples = new Array(c).fill(-1 / 0), this.sdpMetadataStreamId = e.stream.id, this.updateStream(null, e.stream), this.stream = e.stream, this.hasAudioTrack && this.initVolumeMeasuring()
									}
									get hasAudioTrack() {
										return this.stream.getAudioTracks().length > 0
									}
									updateStream(e, t) {
										t !== e && (e && (e.removeEventListener("addtrack", this.onAddTrack), this.measureVolumeActivity(!1)), this.stream = t, t.addEventListener("addtrack", this.onAddTrack), this.hasAudioTrack ? this.initVolumeMeasuring() : this.measureVolumeActivity(!1), this.emit(l.NewStream, this.stream))
									}
									initVolumeMeasuring() {
										if (!this.hasAudioTrack) return;
										this.audioContext || (this.audioContext = (0, i.acquireContext)()), this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 512, this.analyser.smoothingTimeConstant = .1, this.audioContext.createMediaStreamSource(this.stream).connect(this.analyser), this.frequencyBinCount = new Float32Array(this.analyser.frequencyBinCount)
									}
									getMember() {
										var e;
										const t = this.client.getRoom(this.roomId);
										return null !== (e = null == t ? void 0 : t.getMember(this.userId)) && void 0 !== e ? e : null
									}
									isLocal() {
										return this.userId === this.client.getUserId()
									}
									isAudioMuted() {
										return 0 === this.stream.getAudioTracks().length || this.audioMuted
									}
									isVideoMuted() {
										return 0 === this.stream.getVideoTracks().length || this.videoMuted
									}
									isSpeaking() {
										return this.speaking
									}
									setNewStream(e) {
										this.updateStream(this.stream, e)
									}
									setAudioVideoMuted(e, t) {
										null !== e && (this.audioMuted !== e && this.speakingVolumeSamples.fill(-1 / 0), this.audioMuted = e), null !== t && (this.videoMuted = t), this.emit(l.MuteStateChanged, this.audioMuted, this.videoMuted)
									}
									measureVolumeActivity(e) {
										if (e) {
											if (!this.analyser || !this.frequencyBinCount || !this.hasAudioTrack) return;
											this.measuringVolumeActivity = !0, this.volumeLooper()
										} else this.measuringVolumeActivity = !1, this.speakingVolumeSamples.fill(-1 / 0), this.emit(l.VolumeChanged, -1 / 0)
									}
									setSpeakingThreshold(e) {
										this.speakingThreshold = e
									}
									clone() {
										const e = this.client.getMediaHandler(),
											t = this.stream.clone();
										return o.logger.log(`callFeed cloning stream ${this.stream.id} newStream ${t.id}`), this.purpose === n.SDPStreamMetadataPurpose.Usermedia ? e.userMediaStreams.push(t) : e.screensharingStreams.push(t), new u({
											client: this.client,
											roomId: this.roomId,
											userId: this.userId,
											stream: t,
											purpose: this.purpose,
											audioMuted: this.audioMuted,
											videoMuted: this.videoMuted
										})
									}
									dispose() {
										var e;
										clearTimeout(this.volumeLooperTimeout), null === (e = this.stream) || void 0 === e || e.removeEventListener("addtrack", this.onAddTrack), this.audioContext && (this.audioContext = void 0, this.analyser = void 0, (0, i.releaseContext)()), this._disposed = !0, this.emit(l.Disposed)
									}
									get disposed() {
										return this._disposed
									}
									set disposed(e) {
										this._disposed = e
									}
									getLocalVolume() {
										return this.localVolume
									}
									setLocalVolume(e) {
										this.localVolume = e, this.emit(l.LocalVolumeChanged, e)
									}
								}
								r.CallFeed = u
							}, {
								"../logger": 356,
								"../models/typed-event-emitter": 376,
								"./audioContext": 394,
								"./callEventTypes": 397
							}],
							399: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.GroupCall = r.GroupCallState = r.OtherUserSpeakingError = r.GroupCallUnknownDeviceError = r.GroupCallError = r.GroupCallErrorCode = r.GroupCallEvent = r.GroupCallTerminationReason = r.GroupCallType = r.GroupCallIntent = void 0;
								const i = e("../models/typed-event-emitter"),
									o = e("./callFeed"),
									s = e("./call"),
									a = e("../logger"),
									c = e("../ReEmitter"),
									l = e("./callEventTypes"),
									u = e("../@types/event"),
									d = e("./callEventHandler"),
									h = e("./groupCallEventHandler");
								var f, p, v, g, m;
								! function(e) {
									e.Ring = "m.ring", e.Prompt = "m.prompt", e.Room = "m.room"
								}(r.GroupCallIntent || (r.GroupCallIntent = {})),
								function(e) {
									e.Video = "m.video", e.Voice = "m.voice"
								}(f = r.GroupCallType || (r.GroupCallType = {})),
								function(e) {
									e.CallEnded = "call_ended"
								}(p = r.GroupCallTerminationReason || (r.GroupCallTerminationReason = {})),
								function(e) {
									e.GroupCallStateChanged = "group_call_state_changed", e.ActiveSpeakerChanged = "active_speaker_changed", e.CallsChanged = "calls_changed", e.UserMediaFeedsChanged = "user_media_feeds_changed", e.ScreenshareFeedsChanged = "screenshare_feeds_changed", e.LocalScreenshareStateChanged = "local_screenshare_state_changed", e.LocalMuteStateChanged = "local_mute_state_changed", e.ParticipantsChanged = "participants_changed", e.Error = "error"
								}(v = r.GroupCallEvent || (r.GroupCallEvent = {})),
								function(e) {
									e.NoUserMedia = "no_user_media", e.UnknownDevice = "unknown_device", e.PlaceCallFailed = "place_call_failed"
								}(g = r.GroupCallErrorCode || (r.GroupCallErrorCode = {}));
								class GroupCallError extends Error {
									constructor(e, t, r) {
										super(r ? t + ": " + r : t), this.code = e
									}
								}
								r.GroupCallError = GroupCallError;
								class GroupCallUnknownDeviceError extends GroupCallError {
									constructor(e) {
										super(g.UnknownDevice, "No device found for " + e), this.userId = e
									}
								}
								r.GroupCallUnknownDeviceError = GroupCallUnknownDeviceError;
								class OtherUserSpeakingError extends Error {
									constructor() {
										super("Cannot unmute: another user is speaking")
									}
								}
								r.OtherUserSpeakingError = OtherUserSpeakingError,
									function(e) {
										e.LocalCallFeedUninitialized = "local_call_feed_uninitialized", e.InitializingLocalCallFeed = "initializing_local_call_feed", e.LocalCallFeedInitialized = "local_call_feed_initialized", e.Entering = "entering", e.Entered = "entered", e.Ended = "ended"
									}(m = r.GroupCallState || (r.GroupCallState = {}));
								const y = 36e5,
									b = e => {
										var t;
										const r = Date.now(),
											n = null !== (t = null == e ? void 0 : e.getContent()) && void 0 !== t ? t : {};
										return ("number" == typeof n["m.expires_ts"] ? n["m.expires_ts"] : -1 / 0) <= r
									};

								function _(e) {
									var t;
									return (null === (t = e.getOpponentMember()) || void 0 === t ? void 0 : t.userId) || e.invitee || null
								}
								class w extends i.TypedEventEmitter {
									constructor(e, t, r, i, u, d, h, f) {
										super(), this.client = e, this.room = t, this.type = r, this.isPtt = i, this.intent = u, this.dataChannelsEnabled = h, this.dataChannelOptions = f, this.activeSpeakerInterval = 1e3, this.retryCallInterval = 5e3, this.participantTimeout = 15e3, this.pttMaxTransmitTime = 2e4, this.state = m.LocalCallFeedUninitialized, this.calls = [], this.participants = [], this.userMediaFeeds = [], this.screenshareFeeds = [], this.callHandlers = new Map, this.retryCallCounts = new Map, this.transmitTimer = null, this.memberStateExpirationTimers = new Map, this.resendMemberStateTimer = null, this.initWithAudioMuted = !1, this.initWithVideoMuted = !1, this.onIncomingCall = e => {
											var t;
											if (e.roomId !== this.room.roomId) return;
											if (e.state !== s.CallState.Ringing) return void a.logger.warn("Incoming call no longer in ringing state. Ignoring.");
											if (!e.groupCallId || e.groupCallId !== this.groupCallId) return a.logger.log(`Incoming call with groupCallId ${e.groupCallId} ignored because it doesn't match the current group call`), void e.reject();
											const r = null === (t = e.getOpponentMember()) || void 0 === t ? void 0 : t.userId,
												n = r ? this.getCallByUserId(r) : null;
											n && n.callId === e.callId || (a.logger.log(`GroupCall: incoming call from: ${r} with ID ${e.callId}`), e.isPtt = this.isPtt, n ? this.replaceCall(n, e) : this.addCall(e), e.answerWithCallFeeds(this.getLocalFeeds().map(e => e.clone())))
										}, this.onMemberStateChanged = e => n(this, void 0, void 0, (function*() {
											if (this.state !== m.Entered) return;
											if (e.getRoomId() !== this.room.roomId) return;
											const t = this.room.getMember(e.getStateKey());
											if (!t) return void a.logger.warn(`Couldn't find room member for ${e.getStateKey()}: ignoring member state event!`);
											const r = this.client.getUserId();
											if (t.userId === r) return;
											a.logger.debug(`Processing member state event for ${t.userId}`);
											const n = () => {
													this.removeParticipant(t), clearTimeout(this.memberStateExpirationTimers.get(t.userId)), this.memberStateExpirationTimers.delete(t.userId)
												},
												i = e.getContent(),
												o = !b(e) && Array.isArray(i["m.calls"]) ? i["m.calls"].filter(e => e) : [];
											if (0 === o.length) return a.logger.info(`Ignoring member state from ${t.userId} member not in any calls.`), void n();
											const c = o[0]["m.call_id"];
											if (!c) return a.logger.warn(`Room member ${t.userId} does not have a valid m.call_id set. Ignoring.`), void n();
											if (c !== this.groupCallId) return a.logger.warn(`Call id ${c} does not match group call id ${this.groupCallId}, ignoring.`), void n();
											if (this.addParticipant(t), clearTimeout(this.memberStateExpirationTimers.get(t.userId)), this.memberStateExpirationTimers.set(t.userId, setTimeout(() => {
													a.logger.warn(`Call member state for ${t.userId} has expired`), this.removeParticipant(t)
												}, i["m.expires_ts"] - Date.now())), t.userId < r) return void a.logger.debug(`Waiting for ${t.userId} to send call invite.`);
											const u = this.getDeviceForMember(t.userId);
											if (!u) return a.logger.warn(`No opponent device found for ${t.userId}, ignoring.`), void this.emit(v.Error, new GroupCallUnknownDeviceError(t.userId));
											const d = this.getCallByUserId(t.userId);
											if (d && d.getOpponentSessionId() === u.session_id) return;
											const h = (0, s.createNewMatrixCall)(this.client, this.room.roomId, {
												invitee: t.userId,
												opponentDeviceId: u.device_id,
												opponentSessionId: u.session_id,
												groupCallId: this.groupCallId
											});
											if (!h) return void a.logger.error("Failed to create call!");
											d ? (a.logger.debug(`Replacing call ${d.callId} to ${t.userId} with ${h.callId}`), this.replaceCall(d, h, s.CallErrorCode.NewSession)) : (a.logger.debug(`Adding call ${h.callId} to ${t.userId}`), this.addCall(h)), h.isPtt = this.isPtt;
											const f = u.feeds.some(e => e.purpose === l.SDPStreamMetadataPurpose.Screenshare);
											a.logger.debug(`Placing call to ${t.userId}/${u.device_id} session ID ${u.session_id}.`);
											try {
												yield h.placeCallWithCallFeeds(this.getLocalFeeds().map(e => e.clone()), f)
											} catch (p) {
												return a.logger.warn(`Failed to place call to ${t.userId}!`, p), p instanceof s.CallError && p.code === g.UnknownDevice ? this.emit(v.Error, p) : this.emit(v.Error, new GroupCallError(g.PlaceCallFailed, `Failed to place call to ${t.userId}.`)), void this.removeCall(h, s.CallErrorCode.SignallingFailed)
											}
											this.dataChannelsEnabled && h.createDataChannel("datachannel", this.dataChannelOptions)
										})), this.onRetryCallLoop = () => {
											for (const e of this.getMemberStateEvents()) {
												const t = e.getStateKey(),
													r = this.calls.find(e => _(e) === t),
													n = this.retryCallCounts.get(t) || 0;
												!r && n < 3 && (this.retryCallCounts.set(t, n + 1), this.onMemberStateChanged(e))
											}
											this.retryCallLoopTimeout = setTimeout(this.onRetryCallLoop, this.retryCallInterval)
										}, this.onCallFeedsChanged = e => {
											const t = _(e);
											if (!t) throw new Error("Cannot change call feeds without user id");
											const r = this.getUserMediaFeedByUserId(t),
												n = e.remoteUsermediaFeed;
											n !== r && (!r && n ? this.addUserMediaFeed(n) : r && n ? this.replaceUserMediaFeed(r, n) : r && !n && this.removeUserMediaFeed(r));
											const i = this.getScreenshareFeedByUserId(t),
												o = e.remoteScreensharingFeed;
											o !== i && (!i && o ? this.addScreenshareFeed(o) : i && o ? this.replaceScreenshareFeed(i, o) : i && !o && this.removeScreenshareFeed(i))
										}, this.onCallStateChanged = (e, t, r) => {
											const n = this.localCallFeed.isAudioMuted();
											e.localUsermediaStream && e.isMicrophoneMuted() !== n && e.setMicrophoneMuted(n);
											const i = this.localCallFeed.isVideoMuted();
											e.localUsermediaStream && e.isLocalVideoMuted() !== i && e.setLocalVideoMuted(i), t === s.CallState.Connected && this.retryCallCounts.delete(_(e))
										}, this.onCallHangup = e => {
											e.hangupReason !== s.CallErrorCode.Replaced && this.removeCall(e, e.hangupReason)
										}, this.onActiveSpeakerLoop = () => {
											let e = void 0,
												t = void 0;
											for (const r of this.userMediaFeeds) {
												if (r.userId === this.client.getUserId() && this.userMediaFeeds.length > 1) continue;
												let n = 0;
												for (let e = 0; e < r.speakingVolumeSamples.length; e++) {
													const t = r.speakingVolumeSamples[e];
													n += Math.max(t, o.SPEAKING_THRESHOLD)
												}
												const i = n / r.speakingVolumeSamples.length;
												(!e || i > e) && (e = i, t = r.userId)
											}
											t && this.activeSpeaker !== t && e && e > o.SPEAKING_THRESHOLD && (this.activeSpeaker = t, this.emit(v.ActiveSpeakerChanged, this.activeSpeaker)), this.activeSpeakerLoopTimeout = setTimeout(this.onActiveSpeakerLoop, this.activeSpeakerInterval)
										}, this.reEmitter = new c.ReEmitter(this), this.groupCallId = d || (0, s.genCallID)();
										for (const n of this.getMemberStateEvents()) this.onMemberStateChanged(n)
									}
									create() {
										return n(this, void 0, void 0, (function*() {
											return this.client.groupCallEventHandler.groupCalls.set(this.room.roomId, this), yield this.client.sendStateEvent(this.room.roomId, u.EventType.GroupCallPrefix, {
												"m.intent": this.intent,
												"m.type": this.type,
												"io.element.ptt": this.isPtt,
												dataChannelsEnabled: this.dataChannelsEnabled,
												dataChannelOptions: this.dataChannelOptions
											}, this.groupCallId), this
										}))
									}
									setState(e) {
										const t = this.state;
										this.state = e, this.emit(v.GroupCallStateChanged, e, t)
									}
									getLocalFeeds() {
										const e = [];
										return this.localCallFeed && e.push(this.localCallFeed), this.localScreenshareFeed && e.push(this.localScreenshareFeed), e
									}
									hasLocalParticipant() {
										const e = this.client.getUserId();
										return this.participants.some(t => t.userId === e)
									}
									initLocalCallFeed() {
										return n(this, void 0, void 0, (function*() {
											if (a.logger.log(`groupCall ${this.groupCallId} initLocalCallFeed`), this.state !== m.LocalCallFeedUninitialized) throw new Error(`Cannot initialize local call feed in the "${this.state}" state.`);
											let e;
											this.setState(m.InitializingLocalCallFeed);
											let t = !1;
											const r = e => {
												e === m.LocalCallFeedUninitialized && (t = !0)
											};
											this.on(v.GroupCallStateChanged, r);
											try {
												e = yield this.client.getMediaHandler().getUserMediaStream(!0, this.type === f.Video)
											} catch (c) {
												throw this.setState(m.LocalCallFeedUninitialized), c
											} finally {
												this.off(v.GroupCallStateChanged, r)
											}
											if (t) throw new Error("Group call disposed");
											const n = this.client.getUserId(),
												i = new o.CallFeed({
													client: this.client,
													roomId: this.room.roomId,
													userId: n,
													stream: e,
													purpose: l.SDPStreamMetadataPurpose.Usermedia,
													audioMuted: this.initWithAudioMuted || 0 === e.getAudioTracks().length || this.isPtt,
													videoMuted: this.initWithVideoMuted || 0 === e.getVideoTracks().length
												});
											return (0, s.setTracksEnabled)(e.getAudioTracks(), !i.isAudioMuted()), (0, s.setTracksEnabled)(e.getVideoTracks(), !i.isVideoMuted()), this.localCallFeed = i, this.addUserMediaFeed(i), this.setState(m.LocalCallFeedInitialized), i
										}))
									}
									updateLocalUsermediaStream(e) {
										return n(this, void 0, void 0, (function*() {
											if (this.localCallFeed) {
												const t = this.localCallFeed.stream;
												this.localCallFeed.setNewStream(e);
												const r = this.localCallFeed.isAudioMuted(),
													n = this.localCallFeed.isVideoMuted();
												a.logger.log(`groupCall ${this.groupCallId} updateLocalUsermediaStream oldStream ${t.id} newStream ${e.id} micShouldBeMuted ${r} vidShouldBeMuted ${n}`), (0, s.setTracksEnabled)(e.getAudioTracks(), !r), (0, s.setTracksEnabled)(e.getVideoTracks(), !n), this.client.getMediaHandler().stopUserMediaStream(t)
											}
										}))
									}
									enter() {
										return n(this, void 0, void 0, (function*() {
											if (this.state !== m.LocalCallFeedUninitialized && this.state !== m.LocalCallFeedInitialized) throw new Error(`Cannot enter call in the "${this.state}" state`);
											this.state === m.LocalCallFeedUninitialized && (yield this.initLocalCallFeed()), this.addParticipant(this.room.getMember(this.client.getUserId())), yield this.sendMemberStateEvent(), this.activeSpeaker = void 0, this.setState(m.Entered), a.logger.log(`Entered group call ${this.groupCallId}`), this.client.on(d.CallEventHandlerEvent.Incoming, this.onIncomingCall);
											const e = this.client.callEventHandler.calls.values();
											for (const t of e) this.onIncomingCall(t);
											for (const t of this.getMemberStateEvents()) this.onMemberStateChanged(t);
											this.retryCallLoopTimeout = setTimeout(this.onRetryCallLoop, this.retryCallInterval), this.onActiveSpeakerLoop()
										}))
									}
									dispose() {
										if (this.localCallFeed && (this.removeUserMediaFeed(this.localCallFeed), this.localCallFeed = void 0), this.localScreenshareFeed && (this.client.getMediaHandler().stopScreensharingStream(this.localScreenshareFeed.stream), this.removeScreenshareFeed(this.localScreenshareFeed), this.localScreenshareFeed = void 0, this.localDesktopCapturerSourceId = void 0), this.client.getMediaHandler().stopAllStreams(), this.state === m.Entered) {
											for (this.removeParticipant(this.room.getMember(this.client.getUserId())), this.removeMemberStateEvent(); this.calls.length > 0;) this.removeCall(this.calls[this.calls.length - 1], s.CallErrorCode.UserHangup);
											this.activeSpeaker = void 0, clearTimeout(this.activeSpeakerLoopTimeout), this.retryCallCounts.clear(), clearTimeout(this.retryCallLoopTimeout);
											for (const [e] of this.memberStateExpirationTimers) clearTimeout(this.memberStateExpirationTimers.get(e)), this.memberStateExpirationTimers.delete(e);
											null !== this.transmitTimer && (clearTimeout(this.transmitTimer), this.transmitTimer = null), this.client.removeListener(d.CallEventHandlerEvent.Incoming, this.onIncomingCall)
										}
									}
									leave() {
										null !== this.transmitTimer && (clearTimeout(this.transmitTimer), this.transmitTimer = null), this.dispose(), this.setState(m.LocalCallFeedUninitialized)
									}
									terminate(e = !0) {
										return n(this, void 0, void 0, (function*() {
											if (this.dispose(), null !== this.transmitTimer && (clearTimeout(this.transmitTimer), this.transmitTimer = null), this.participants = [], this.client.groupCallEventHandler.groupCalls.delete(this.room.roomId), e) {
												const e = this.room.currentState.getStateEvents(u.EventType.GroupCallPrefix, this.groupCallId);
												yield this.client.sendStateEvent(this.room.roomId, u.EventType.GroupCallPrefix, Object.assign(Object.assign({}, e.getContent()), {
													"m.terminated": p.CallEnded
												}), this.groupCallId)
											}
											this.client.emit(h.GroupCallEventHandlerEvent.Ended, this), this.setState(m.Ended)
										}))
									}
									isLocalVideoMuted() {
										return !this.localCallFeed || this.localCallFeed.isVideoMuted()
									}
									isMicrophoneMuted() {
										return !this.localCallFeed || this.localCallFeed.isAudioMuted()
									}
									setMicrophoneMuted(e) {
										var t;
										return n(this, void 0, void 0, (function*() {
											if (!e && !(yield this.client.getMediaHandler().hasAudioDevice())) return !1;
											const r = !e && this.isPtt;
											this.isPtt && (!e && this.isMicrophoneMuted() ? this.transmitTimer = setTimeout(() => {
												this.setMicrophoneMuted(!0)
											}, this.pttMaxTransmitTime) : e && !this.isMicrophoneMuted() && (null !== this.transmitTimer && clearTimeout(this.transmitTimer), this.transmitTimer = null));
											for (const i of this.calls) null === (t = i.localUsermediaFeed) || void 0 === t || t.setAudioVideoMuted(e, null);
											if (r) try {
												yield Promise.all(this.calls.map(e => e.sendMetadataUpdate()))
											} catch (n) {
												a.logger.info("Failed to send one or more metadata updates", n)
											}
											this.localCallFeed ? (a.logger.log(`groupCall ${this.groupCallId} setMicrophoneMuted stream ${this.localCallFeed.stream.id} muted ${e}`), this.localCallFeed.setAudioVideoMuted(e, null), (0, s.setTracksEnabled)(this.localCallFeed.stream.getAudioTracks(), !e)) : (a.logger.log(`groupCall ${this.groupCallId} setMicrophoneMuted no stream muted ${e}`), this.initWithAudioMuted = e);
											for (const t of this.calls)(0, s.setTracksEnabled)(t.localUsermediaFeed.stream.getAudioTracks(), !e);
											if (this.emit(v.LocalMuteStateChanged, e, this.isLocalVideoMuted()), !r) try {
												yield Promise.all(this.calls.map(e => e.sendMetadataUpdate()))
											} catch (n) {
												a.logger.info("Failed to send one or more metadata updates", n)
											}
											return !0
										}))
									}
									setLocalVideoMuted(e) {
										return n(this, void 0, void 0, (function*() {
											if (!e && !(yield this.client.getMediaHandler().hasVideoDevice())) return !1;
											this.localCallFeed ? (a.logger.log(`groupCall ${this.groupCallId} setLocalVideoMuted stream ${this.localCallFeed.stream.id} muted ${e}`), this.localCallFeed.setAudioVideoMuted(null, e), (0, s.setTracksEnabled)(this.localCallFeed.stream.getVideoTracks(), !e)) : (a.logger.log(`groupCall ${this.groupCallId} setLocalVideoMuted no stream muted ${e}`), this.initWithVideoMuted = e);
											for (const t of this.calls) t.setLocalVideoMuted(e);
											return this.emit(v.LocalMuteStateChanged, this.isMicrophoneMuted(), e), !0
										}))
									}
									setScreensharingEnabled(e, t = {}) {
										return n(this, void 0, void 0, (function*() {
											if (e === this.isScreensharing()) return e;
											if (!e) return yield Promise.all(this.calls.map(e => {
												e.localScreensharingFeed && e.removeLocalFeed(e.localScreensharingFeed)
											})), this.client.getMediaHandler().stopScreensharingStream(this.localScreenshareFeed.stream), this.removeScreenshareFeed(this.localScreenshareFeed), this.localScreenshareFeed = void 0, this.localDesktopCapturerSourceId = void 0, yield this.sendMemberStateEvent(), this.emit(v.LocalScreenshareStateChanged, !1, void 0, void 0), !1;
											try {
												a.logger.log("Asking for screensharing permissions...");
												const e = yield this.client.getMediaHandler().getScreensharingStream(t);
												for (const t of e.getTracks()) {
													const e = () => {
														this.setScreensharingEnabled(!1), t.removeEventListener("ended", e)
													};
													t.addEventListener("ended", e)
												}
												return a.logger.log("Screensharing permissions granted. Setting screensharing enabled on all calls"), this.localDesktopCapturerSourceId = t.desktopCapturerSourceId, this.localScreenshareFeed = new o.CallFeed({
													client: this.client,
													roomId: this.room.roomId,
													userId: this.client.getUserId(),
													stream: e,
													purpose: l.SDPStreamMetadataPurpose.Screenshare,
													audioMuted: !1,
													videoMuted: !1
												}), this.addScreenshareFeed(this.localScreenshareFeed), this.emit(v.LocalScreenshareStateChanged, !0, this.localScreenshareFeed, this.localDesktopCapturerSourceId), yield Promise.all(this.calls.map(e => e.pushLocalFeed(this.localScreenshareFeed.clone()))), yield this.sendMemberStateEvent(), !0
											} catch (r) {
												if (t.throwOnFail) throw r;
												return a.logger.error("Enabling screensharing error", r), this.emit(v.Error, new GroupCallError(g.NoUserMedia, "Failed to get screen-sharing stream: ", r)), !1
											}
										}))
									}
									isScreensharing() {
										return !!this.localScreenshareFeed
									}
									getMemberStateEvents(e) {
										if (null != e) {
											const t = this.room.currentState.getStateEvents(u.EventType.GroupCallMemberPrefix, e);
											return b(t) ? null : t
										}
										return this.room.currentState.getStateEvents(u.EventType.GroupCallMemberPrefix).filter(e => !b(e))
									}
									sendMemberStateEvent() {
										return n(this, void 0, void 0, (function*() {
											const e = () => this.updateMemberCallState({
													"m.call_id": this.groupCallId,
													"m.devices": [{
														device_id: this.client.getDeviceId(),
														session_id: this.client.getSessionId(),
														feeds: this.getLocalFeeds().map(e => ({
															purpose: e.purpose
														}))
													}]
												}),
												t = yield e();
											return null !== this.resendMemberStateTimer && clearInterval(this.resendMemberStateTimer), this.resendMemberStateTimer = setInterval(() => n(this, void 0, void 0, (function*() {
												a.logger.log("Resending call member state"), yield e()
											})), 3 * y / 4), t
										}))
									}
									removeMemberStateEvent() {
										return n(this, void 0, void 0, (function*() {
											return null !== this.resendMemberStateTimer && clearInterval(this.resendMemberStateTimer), this.resendMemberStateTimer = null, yield this.updateMemberCallState(void 0, !0)
										}))
									}
									updateMemberCallState(e, t = !1) {
										var r;
										return n(this, void 0, void 0, (function*() {
											const n = this.client.getUserId(),
												i = null === (r = this.getMemberStateEvents(n)) || void 0 === r ? void 0 : r.getContent();
											let o = [];
											i && Array.isArray(i["m.calls"]) && (o = i["m.calls"].filter(e => !!e));
											const s = o.findIndex(e => e && e["m.call_id"] === this.groupCallId); - 1 !== s ? e ? o.splice(s, 1, e) : o.splice(s, 1) : e && o.push(e);
											const a = {
												"m.calls": o,
												"m.expires_ts": Date.now() + y
											};
											return this.client.sendStateEvent(this.room.roomId, u.EventType.GroupCallMemberPrefix, a, n, {
												keepAlive: t
											})
										}))
									}
									getDeviceForMember(e) {
										var t;
										const r = this.getMemberStateEvents(e);
										if (!r) return;
										const n = null === (t = r.getContent()["m.calls"]) || void 0 === t ? void 0 : t.find(e => e && e["m.call_id"] === this.groupCallId);
										if (!n) return;
										const i = n["m.devices"];
										return i && 0 !== i.length ? i[0] : void 0
									}
									getCallByUserId(e) {
										return this.calls.find(t => _(t) === e)
									}
									addCall(e) {
										this.calls.push(e), this.initCall(e), this.emit(v.CallsChanged, this.calls)
									}
									replaceCall(e, t, r = s.CallErrorCode.Replaced) {
										const n = this.calls.indexOf(e);
										if (-1 === n) throw new Error("Couldn't find call to replace");
										this.calls.splice(n, 1, t), this.disposeCall(e, r), this.initCall(t), this.emit(v.CallsChanged, this.calls)
									}
									removeCall(e, t) {
										this.disposeCall(e, t);
										const r = this.calls.indexOf(e);
										if (-1 === r) throw new Error("Couldn't find call to remove");
										this.calls.splice(r, 1), this.emit(v.CallsChanged, this.calls)
									}
									initCall(e) {
										const t = _(e);
										if (!t) throw new Error("Cannot init call without user id");
										const r = () => this.onCallFeedsChanged(e),
											n = (t, r) => this.onCallStateChanged(e, t, r),
											i = this.onCallHangup,
											o = t => this.replaceCall(e, t);
										this.callHandlers.set(t, {
											onCallFeedsChanged: r,
											onCallStateChanged: n,
											onCallHangup: i,
											onCallReplaced: o
										}), e.on(s.CallEvent.FeedsChanged, r), e.on(s.CallEvent.State, n), e.on(s.CallEvent.Hangup, i), e.on(s.CallEvent.Replaced, o), this.reEmitter.reEmit(e, Object.values(s.CallEvent)), r()
									}
									disposeCall(e, t) {
										const r = _(e);
										if (!r) throw new Error("Cannot dispose call without user id");
										const {
											onCallFeedsChanged: n,
											onCallStateChanged: i,
											onCallHangup: o,
											onCallReplaced: a
										} = this.callHandlers.get(r);
										if (e.removeListener(s.CallEvent.FeedsChanged, n), e.removeListener(s.CallEvent.State, i), e.removeListener(s.CallEvent.Hangup, o), e.removeListener(s.CallEvent.Replaced, a), this.callHandlers.delete(r), e.hangupReason === s.CallErrorCode.Replaced) return;
										e.state !== s.CallState.Ended && e.hangup(t, !1);
										const c = this.getUserMediaFeedByUserId(r);
										c && this.removeUserMediaFeed(c);
										const l = this.getScreenshareFeedByUserId(r);
										l && this.removeScreenshareFeed(l)
									}
									getUserMediaFeedByUserId(e) {
										return this.userMediaFeeds.find(t => t.userId === e)
									}
									addUserMediaFeed(e) {
										this.userMediaFeeds.push(e), e.measureVolumeActivity(!0), this.emit(v.UserMediaFeedsChanged, this.userMediaFeeds)
									}
									replaceUserMediaFeed(e, t) {
										const r = this.userMediaFeeds.findIndex(t => t.userId === e.userId);
										if (-1 === r) throw new Error("Couldn't find user media feed to replace");
										this.userMediaFeeds.splice(r, 1, t), e.dispose(), t.measureVolumeActivity(!0), this.emit(v.UserMediaFeedsChanged, this.userMediaFeeds)
									}
									removeUserMediaFeed(e) {
										const t = this.userMediaFeeds.findIndex(t => t.userId === e.userId);
										if (-1 === t) throw new Error("Couldn't find user media feed to remove");
										this.userMediaFeeds.splice(t, 1), e.dispose(), this.emit(v.UserMediaFeedsChanged, this.userMediaFeeds), this.activeSpeaker === e.userId && this.userMediaFeeds.length > 0 && (this.activeSpeaker = this.userMediaFeeds[0].userId, this.emit(v.ActiveSpeakerChanged, this.activeSpeaker))
									}
									getScreenshareFeedByUserId(e) {
										return this.screenshareFeeds.find(t => t.userId === e)
									}
									addScreenshareFeed(e) {
										this.screenshareFeeds.push(e), this.emit(v.ScreenshareFeedsChanged, this.screenshareFeeds)
									}
									replaceScreenshareFeed(e, t) {
										const r = this.screenshareFeeds.findIndex(t => t.userId === e.userId);
										if (-1 === r) throw new Error("Couldn't find screenshare feed to replace");
										this.screenshareFeeds.splice(r, 1, t), e.dispose(), this.emit(v.ScreenshareFeedsChanged, this.screenshareFeeds)
									}
									removeScreenshareFeed(e) {
										const t = this.screenshareFeeds.findIndex(t => t.userId === e.userId);
										if (-1 === t) throw new Error("Couldn't find screenshare feed to remove");
										this.screenshareFeeds.splice(t, 1), e.dispose(), this.emit(v.ScreenshareFeedsChanged, this.screenshareFeeds)
									}
									addParticipant(e) {
										this.participants.find(t => t.userId === e.userId) || (this.participants.push(e), this.emit(v.ParticipantsChanged, this.participants), this.client.emit(h.GroupCallEventHandlerEvent.Participants, this.participants, this))
									}
									removeParticipant(e) {
										const t = this.participants.findIndex(t => t.userId === e.userId); - 1 !== t && (this.participants.splice(t, 1), this.emit(v.ParticipantsChanged, this.participants), this.client.emit(h.GroupCallEventHandlerEvent.Participants, this.participants, this))
									}
								}
								r.GroupCall = w
							}, {
								"../@types/event": 290,
								"../ReEmitter": 300,
								"../logger": 356,
								"../models/typed-event-emitter": 376,
								"./call": 395,
								"./callEventHandler": 396,
								"./callEventTypes": 397,
								"./callFeed": 398,
								"./groupCallEventHandler": 400
							}],
							400: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.GroupCallEventHandler = r.GroupCallEventHandlerEvent = void 0;
								const i = e("../client"),
									o = e("./groupCall"),
									s = e("../models/room-state"),
									a = e("../logger"),
									c = e("../@types/event"),
									l = e("../sync");
								var u;
								! function(e) {
									e.Incoming = "GroupCall.incoming", e.Ended = "GroupCall.ended", e.Participants = "GroupCall.participants"
								}(u = r.GroupCallEventHandlerEvent || (r.GroupCallEventHandlerEvent = {}));
								r.GroupCallEventHandler = class {
									constructor(e) {
										this.client = e, this.groupCalls = new Map, this.roomDeferreds = new Map, this.onRoomsChanged = e => {
											this.createGroupCallForRoom(e)
										}, this.onRoomStateChanged = (e, t) => {
											const r = e.getType();
											if (r === c.EventType.GroupCallPrefix) {
												const r = e.getStateKey(),
													n = e.getContent(),
													i = this.groupCalls.get(t.roomId);
												i || n["m.terminated"] ? i && i.groupCallId === r ? n["m.terminated"] ? i.terminate(!1) : n["m.type"] !== i.type && a.logger.warn(`The group call type changed for room: ${t.roomId}. Changing the group call type is currently unsupported.`) : i && i.groupCallId !== r && a.logger.warn(`Multiple group calls detected for room: ${t.roomId}. Multiple group calls are currently unsupported.`) : this.createGroupCallFromRoomStateEvent(e)
											} else if (r === c.EventType.GroupCallMemberPrefix) {
												const r = this.groupCalls.get(t.roomId);
												if (!r) return;
												r.onMemberStateChanged(e)
											}
										}
									}
									start() {
										return n(this, void 0, void 0, (function*() {
											this.client.getSyncState() !== l.SyncState.Syncing && (a.logger.debug("Waiting for client to start syncing..."), yield new Promise(e => {
												const t = () => {
													if (this.client.getSyncState() === l.SyncState.Syncing) return this.client.off(i.ClientEvent.Sync, t), e()
												};
												this.client.on(i.ClientEvent.Sync, t)
											}));
											const e = this.client.getRooms();
											for (const t of e) this.createGroupCallForRoom(t);
											this.client.on(i.ClientEvent.Room, this.onRoomsChanged), this.client.on(s.RoomStateEvent.Events, this.onRoomStateChanged)
										}))
									}
									stop() {
										this.client.removeListener(s.RoomStateEvent.Events, this.onRoomStateChanged)
									}
									getRoomDeferred(e) {
										let t = this.roomDeferreds.get(e);
										if (void 0 === t) {
											let r;
											(t = {
												prom: new Promise(e => {
													r = e
												})
											}).resolve = r, this.roomDeferreds.set(e, t)
										}
										return t
									}
									waitUntilRoomReadyForGroupCalls(e) {
										return this.getRoomDeferred(e).prom
									}
									getGroupCallById(e) {
										return [...this.groupCalls.values()].find(t => t.groupCallId === e)
									}
									createGroupCallForRoom(e) {
										const t = e.currentState.getStateEvents(c.EventType.GroupCallPrefix),
											r = t.sort((e, t) => t.getTs() - e.getTs());
										for (const n of r) {
											if (!n.getContent()["m.terminated"]) {
												a.logger.debug(`Choosing group call ${n.getStateKey()} with TS ` + `${n.getTs()} for room ${e.roomId} from ${t.length} possible calls.`), this.createGroupCallFromRoomStateEvent(n);
												break
											}
										}
										a.logger.info("Group call event handler processed room", e.roomId), this.getRoomDeferred(e.roomId).resolve()
									}
									createGroupCallFromRoomStateEvent(e) {
										const t = e.getRoomId(),
											r = e.getContent(),
											n = this.client.getRoom(t);
										if (!n) return void a.logger.warn(`Couldn't find room ${t} for GroupCall`);
										const i = e.getStateKey(),
											s = r["m.type"];
										if (!Object.values(o.GroupCallType).includes(s)) return void a.logger.warn(`Received invalid group call type ${s} for room ${t}.`);
										const c = r["m.intent"];
										if (!Object.values(o.GroupCallIntent).includes(c)) return void a.logger.warn(`Received invalid group call intent ${s} for room ${t}.`);
										const l = Boolean(r["io.element.ptt"]);
										let d;
										if ((null == r ? void 0 : r.dataChannelsEnabled) && (null == r ? void 0 : r.dataChannelOptions)) {
											const {
												ordered: e,
												maxPacketLifeTime: t,
												maxRetransmits: n,
												protocol: i
											} = r.dataChannelOptions;
											d = {
												ordered: e,
												maxPacketLifeTime: t,
												maxRetransmits: n,
												protocol: i
											}
										}
										const h = new o.GroupCall(this.client, n, s, l, c, i, null == r ? void 0 : r.dataChannelsEnabled, d);
										return this.groupCalls.set(n.roomId, h), this.client.emit(u.Incoming, h), h
									}
								}
							}, {
								"../@types/event": 290,
								"../client": 304,
								"../logger": 356,
								"../models/room-state": 371,
								"../sync": 391,
								"./groupCall": 399
							}],
							401: [function(e, t, r) {
								"use strict";
								var n = this && this.__awaiter || function(e, t, r, n) {
									return new(r || (r = Promise))((function(i, o) {
										function s(e) {
											try {
												c(n.next(e))
											} catch (t) {
												o(t)
											}
										}

										function a(e) {
											try {
												c(n.throw(e))
											} catch (t) {
												o(t)
											}
										}

										function c(e) {
											var t;
											e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
												e(t)
											}))).then(s, a)
										}
										c((n = n.apply(e, t || [])).next())
									}))
								};
								Object.defineProperty(r, "__esModule", {
									value: !0
								}), r.MediaHandler = r.MediaHandlerEvent = void 0;
								const i = e("../models/typed-event-emitter"),
									o = e("../webrtc/groupCall"),
									s = e("../logger");
								var a;
								! function(e) {
									e.LocalStreamsChanged = "local_streams_changed"
								}(a = r.MediaHandlerEvent || (r.MediaHandlerEvent = {}));
								class c extends i.TypedEventEmitter {
									constructor(e) {
										super(), this.client = e, this.userMediaStreams = [], this.screensharingStreams = []
									}
									restoreMediaSettings(e, t) {
										this.audioInput = e, this.videoInput = t
									}
									setAudioInput(e) {
										return n(this, void 0, void 0, (function*() {
											s.logger.info("Setting audio input to", e), this.audioInput !== e && (this.audioInput = e, yield this.updateLocalUsermediaStreams())
										}))
									}
									setAudioSettings(e) {
										return n(this, void 0, void 0, (function*() {
											s.logger.info("Setting audio settings to", e), this.audioSettings = Object.assign({}, e), yield this.updateLocalUsermediaStreams()
										}))
									}
									setVideoInput(e) {
										return n(this, void 0, void 0, (function*() {
											s.logger.info("Setting video input to", e), this.videoInput !== e && (this.videoInput = e, yield this.updateLocalUsermediaStreams())
										}))
									}
									setMediaInputs(e, t) {
										return n(this, void 0, void 0, (function*() {
											s.logger.log(`mediaHandler setMediaInputs audioInput: ${e} videoInput: ${t}`), this.audioInput = e, this.videoInput = t, yield this.updateLocalUsermediaStreams()
										}))
									}
									updateLocalUsermediaStreams() {
										return n(this, void 0, void 0, (function*() {
											if (0 === this.userMediaStreams.length) return;
											const e = new Map;
											for (const t of this.client.callEventHandler.calls.values()) e.set(t.callId, {
												audio: t.hasLocalUserMediaAudioTrack,
												video: t.hasLocalUserMediaVideoTrack
											});
											for (const t of this.userMediaStreams) {
												s.logger.log(`mediaHandler stopping all tracks for stream ${t.id}`);
												for (const e of t.getTracks()) e.stop()
											}
											this.userMediaStreams = [], this.localUserMediaStream = void 0;
											for (const t of this.client.callEventHandler.calls.values()) {
												if (t.callHasEnded() || !e.has(t.callId)) continue;
												const {
													audio: r,
													video: n
												} = e.get(t.callId);
												s.logger.log(`mediaHandler updateLocalUsermediaStreams getUserMediaStream call ${t.callId}`);
												const i = yield this.getUserMediaStream(r, n);
												t.callHasEnded() || (yield t.updateLocalUsermediaStream(i))
											}
											for (const t of this.client.groupCallEventHandler.groupCalls.values()) {
												if (!t.localCallFeed) continue;
												s.logger.log(`mediaHandler updateLocalUsermediaStreams getUserMediaStream groupCall ${t.groupCallId}`);
												const e = yield this.getUserMediaStream(!0, t.type === o.GroupCallType.Video);
												t.state !== o.GroupCallState.Ended && (yield t.updateLocalUsermediaStream(e))
											}
											this.emit(a.LocalStreamsChanged)
										}))
									}
									hasAudioDevice() {
										return n(this, void 0, void 0, (function*() {
											return (yield navigator.mediaDevices.enumerateDevices()).filter(e => "audioinput" === e.kind).length > 0
										}))
									}
									hasVideoDevice() {
										return n(this, void 0, void 0, (function*() {
											return (yield navigator.mediaDevices.enumerateDevices()).filter(e => "videoinput" === e.kind).length > 0
										}))
									}
									getUserMediaStream(e, t, r = !0) {
										var i, o, c, l, u;
										return n(this, void 0, void 0, (function*() {
											const n = e && (yield this.hasAudioDevice()),
												d = t && (yield this.hasVideoDevice());
											let h, f = !0;
											if (this.localUserMediaStream ? (n && (0 !== this.localUserMediaStream.getAudioTracks().length && (null === (o = null === (i = this.localUserMediaStream.getAudioTracks()[0]) || void 0 === i ? void 0 : i.getSettings()) || void 0 === o ? void 0 : o.deviceId) === this.audioInput || (f = !1)), d && (0 !== this.localUserMediaStream.getVideoTracks().length && (null === (l = null === (c = this.localUserMediaStream.getVideoTracks()[0]) || void 0 === c ? void 0 : c.getSettings()) || void 0 === l ? void 0 : l.deviceId) === this.videoInput || (f = !1))) : f = !1, f) {
												if (h = this.localUserMediaStream.clone(), s.logger.log(`mediaHandler clone userMediaStream ${null===(u=this.localUserMediaStream)||void 0===u?void 0:u.id} new stream ${h.id} shouldRequestAudio ${n} shouldRequestVideo ${d}`), !n)
													for (const e of h.getAudioTracks()) h.removeTrack(e);
												if (!d)
													for (const e of h.getVideoTracks()) h.removeTrack(e)
											} else {
												const e = this.getUserMediaContraints(n, d);
												h = yield navigator.mediaDevices.getUserMedia(e), s.logger.log(`mediaHandler getUserMediaStream streamId ${h.id} shouldRequestAudio ${n} shouldRequestVideo ${d}`, e);
												for (const t of h.getTracks()) {
													const e = t.getSettings();
													"audio" === t.kind ? this.audioInput = e.deviceId : "video" === t.kind && (this.videoInput = e.deviceId)
												}
												r && (this.localUserMediaStream = h)
											}
											return r && this.userMediaStreams.push(h), this.emit(a.LocalStreamsChanged), h
										}))
									}
									stopUserMediaStream(e) {
										s.logger.log(`mediaHandler stopUserMediaStream stopping stream ${e.id}`);
										for (const r of e.getTracks()) r.stop();
										const t = this.userMediaStreams.indexOf(e); - 1 !== t && (s.logger.debug("Splicing usermedia stream out stream array", e.id), this.userMediaStreams.splice(t, 1)), this.emit(a.LocalStreamsChanged), this.localUserMediaStream === e && (this.localUserMediaStream = void 0)
									}
									getScreensharingStream(e = {}, t = !0) {
										return n(this, void 0, void 0, (function*() {
											let r;
											if (0 === this.screensharingStreams.length) {
												const t = this.getScreenshareContraints(e);
												e.desktopCapturerSourceId ? (s.logger.debug("Getting screensharing stream using getUserMedia()", e), r = yield navigator.mediaDevices.getUserMedia(t)) : (s.logger.debug("Getting screensharing stream using getDisplayMedia()", e), r = yield navigator.mediaDevices.getDisplayMedia(t))
											} else {
												const e = this.screensharingStreams[this.screensharingStreams.length - 1];
												s.logger.log("Cloning screensharing stream", e.id), r = e.clone()
											}
											return t && this.screensharingStreams.push(r), this.emit(a.LocalStreamsChanged), r
										}))
									}
									stopScreensharingStream(e) {
										s.logger.debug("Stopping screensharing stream", e.id);
										for (const r of e.getTracks()) r.stop();
										const t = this.screensharingStreams.indexOf(e); - 1 !== t && (s.logger.debug("Splicing screensharing stream out stream array", e.id), this.screensharingStreams.splice(t, 1)), this.emit(a.LocalStreamsChanged)
									}
									stopAllStreams() {
										for (const e of this.userMediaStreams) {
											s.logger.log(`mediaHandler stopAllStreams stopping stream ${e.id}`);
											for (const t of e.getTracks()) t.stop()
										}
										for (const e of this.screensharingStreams)
											for (const t of e.getTracks()) t.stop();
										this.userMediaStreams = [], this.screensharingStreams = [], this.localUserMediaStream = void 0, this.emit(a.LocalStreamsChanged)
									}
									getUserMediaContraints(e, t) {
										const r = !!navigator.webkitGetUserMedia;
										return {
											audio: !!e && {
												deviceId: this.audioInput ? {
													ideal: this.audioInput
												} : void 0,
												autoGainControl: this.audioSettings ? {
													ideal: this.audioSettings.autoGainControl
												} : void 0,
												echoCancellation: this.audioSettings ? {
													ideal: this.audioSettings.echoCancellation
												} : void 0,
												noiseSuppression: this.audioSettings ? {
													ideal: this.audioSettings.noiseSuppression
												} : void 0
											},
											video: !!t && {
												deviceId: this.videoInput ? {
													ideal: this.videoInput
												} : void 0,
												width: r ? {
													exact: 640
												} : {
													ideal: 640
												},
												height: r ? {
													exact: 360
												} : {
													ideal: 360
												}
											}
										}
									}
									getScreenshareContraints(e) {
										const {
											desktopCapturerSourceId: t,
											audio: r
										} = e;
										return t ? (s.logger.debug("Using desktop capturer source", t), {
											audio: null != r && r,
											video: {
												mandatory: {
													chromeMediaSource: "desktop",
													chromeMediaSourceId: t
												}
											}
										}) : (s.logger.debug("Not using desktop capturer source"), {
											audio: null != r && r,
											video: !0
										})
									}
								}
								r.MediaHandler = c
							}, {
								"../logger": 356,
								"../models/typed-event-emitter": 376,
								"../webrtc/groupCall": 399
							}]
						}, {}, [303])
					}).call(this, r("./node_modules/webpack/buildin/global.js"))
				},
				"./node_modules/@reddit/chat/dist/index.js": function(e, t, r) {
						"use strict";
						(function(e, t, n) {
								var i = Object.create,
									o = Object.defineProperty,
									s = Object.getOwnPropertyDescriptor,
									a = Object.getOwnPropertyNames,
									c = Object.getPrototypeOf,
									l = Object.prototype.hasOwnProperty,
									u = (e, t) => () => (e && (t = e(e = 0)), t),
									d = (e, t) => () => (t || e((t = {
										exports: {}
									}).exports, t), t.exports),
									h = (e, t) => {
										for (var r in t) o(e, r, {
											get: t[r],
											enumerable: !0
										})
									},
									f = (e, t, r, n) => {
										if (t && "object" == typeof t || "function" == typeof t)
											for (let i of a(t)) !l.call(e, i) && i !== r && o(e, i, {
												get: () => t[i],
												enumerable: !(n = s(t, i)) || n.enumerable
											});
										return e
									},
									p = (e, t, r) => (r = null != e ? i(c(e)) : {}, f(!t && e && e.__esModule ? r : o(r, "default", {
										value: e,
										enumerable: !0
									}), e)),
									v = (e, t, r, n) => {
										for (var i, a = n > 1 ? void 0 : n ? s(t, r) : t, c = e.length - 1; c >= 0; c--)(i = e[c]) && (a = (n ? i(t, r, a) : i(a)) || a);
										return n && a && o(t, r, a), a
									},
									g = (e, t, r) => {
										if (!t.has(e)) throw TypeError("Cannot " + r)
									},
									m = (e, t, r) => (g(e, t, "read from private field"), r ? r.call(e) : t.get(e)),
									y = (e, t, r) => {
										if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
										t instanceof WeakSet ? t.add(e) : t.set(e, r)
									},
									b = (e, t, r, n) => (g(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r),
									_ = d((t, n) => {
										var i, o, s, a, c, l, u, d, h, f, p, v, g, m, y, b, _, w, S, E, k, T, I, R, C;
										! function(t) {
											var i = "object" == typeof e ? e : "object" == typeof self ? self : "object" == typeof this ? this : {};

											function o(e, t) {
												return e !== i && ("function" == typeof Object.create ? Object.defineProperty(e, "__esModule", {
														value: !0
													}) : e.__esModule = !0),
													function(r, n) {
														return e[r] = t ? t(r, n) : n
													}
											}
											"function" == typeof define && r("./node_modules/webpack/buildin/amd-options.js") ? define("tslib", ["exports"], (function(e) {
												t(o(i, o(e)))
											})) : "object" == typeof n && "object" == typeof n.exports ? t(o(i, o(n.exports))) : t(o(i))
										}((function(e) {
											var t = Object.setPrototypeOf || {
												__proto__: []
											}
											instanceof Array && function(e, t) {
												e.__proto__ = t
											} || function(e, t) {
												for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r])
											};
											i = function(e, r) {
												if ("function" != typeof r && null !== r) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");

												function n() {
													this.constructor = e
												}
												t(e, r), e.prototype = null === r ? Object.create(r) : (n.prototype = r.prototype, new n)
											}, o = Object.assign || function(e) {
												for (var t, r = 1, n = arguments.length; r < n; r++)
													for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
												return e
											}, s = function(e, t) {
												var r = {};
												for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
												if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
													var i = 0;
													for (n = Object.getOwnPropertySymbols(e); i < n.length; i++) t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]])
												}
												return r
											}, a = function(e, t, r, n) {
												var i, o = arguments.length,
													s = o < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
												if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(e, t, r, n);
												else
													for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(t, r, s) : i(t, r)) || s);
												return o > 3 && s && Object.defineProperty(t, r, s), s
											}, c = function(e, t) {
												return function(r, n) {
													t(r, n, e)
												}
											}, l = function(e, t) {
												if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
											}, u = function(e, t, r, n) {
												return new(r || (r = Promise))((function(i, o) {
													function s(e) {
														try {
															c(n.next(e))
														} catch (t) {
															o(t)
														}
													}

													function a(e) {
														try {
															c(n.throw(e))
														} catch (t) {
															o(t)
														}
													}

													function c(e) {
														e.done ? i(e.value) : function(e) {
															return e instanceof r ? e : new r((function(t) {
																t(e)
															}))
														}(e.value).then(s, a)
													}
													c((n = n.apply(e, t || [])).next())
												}))
											}, d = function(e, t) {
												var r, n, i, o, s = {
													label: 0,
													sent: function() {
														if (1 & i[0]) throw i[1];
														return i[1]
													},
													trys: [],
													ops: []
												};
												return o = {
													next: a(0),
													throw: a(1),
													return: a(2)
												}, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
													return this
												}), o;

												function a(o) {
													return function(a) {
														return function(o) {
															if (r) throw new TypeError("Generator is already executing.");
															for (; s;) try {
																if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
																switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
																	case 0:
																	case 1:
																		i = o;
																		break;
																	case 4:
																		return s.label++, {
																			value: o[1],
																			done: !1
																		};
																	case 5:
																		s.label++, n = o[1], o = [0];
																		continue;
																	case 7:
																		o = s.ops.pop(), s.trys.pop();
																		continue;
																	default:
																		if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
																			s = 0;
																			continue
																		}
																		if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
																			s.label = o[1];
																			break
																		}
																		if (6 === o[0] && s.label < i[1]) {
																			s.label = i[1], i = o;
																			break
																		}
																		if (i && s.label < i[2]) {
																			s.label = i[2], s.ops.push(o);
																			break
																		}
																		i[2] && s.ops.pop(), s.trys.pop();
																		continue
																}
																o = t.call(e, s)
															} catch (a) {
																o = [6, a], n = 0
															} finally {
																r = i = 0
															}
															if (5 & o[0]) throw o[1];
															return {
																value: o[0] ? o[1] : void 0,
																done: !0
															}
														}([o, a])
													}
												}
											}, h = function(e, t) {
												for (var r in e) "default" !== r && !Object.prototype.hasOwnProperty.call(t, r) && C(t, e, r)
											}, C = Object.create ? function(e, t, r, n) {
												void 0 === n && (n = r);
												var i = Object.getOwnPropertyDescriptor(t, r);
												(!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
													enumerable: !0,
													get: function() {
														return t[r]
													}
												}), Object.defineProperty(e, n, i)
											} : function(e, t, r, n) {
												void 0 === n && (n = r), e[n] = t[r]
											}, f = function(e) {
												var t = "function" == typeof Symbol && Symbol.iterator,
													r = t && e[t],
													n = 0;
												if (r) return r.call(e);
												if (e && "number" == typeof e.length) return {
													next: function() {
														return e && n >= e.length && (e = void 0), {
															value: e && e[n++],
															done: !e
														}
													}
												};
												throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
											}, p = function(e, t) {
												var r = "function" == typeof Symbol && e[Symbol.iterator];
												if (!r) return e;
												var n, i, o = r.call(e),
													s = [];
												try {
													for (;
														(void 0 === t || t-- > 0) && !(n = o.next()).done;) s.push(n.value)
												} catch (a) {
													i = {
														error: a
													}
												} finally {
													try {
														n && !n.done && (r = o.return) && r.call(o)
													} finally {
														if (i) throw i.error
													}
												}
												return s
											}, v = function() {
												for (var e = [], t = 0; t < arguments.length; t++) e = e.concat(p(arguments[t]));
												return e
											}, g = function() {
												for (var e = 0, t = 0, r = arguments.length; t < r; t++) e += arguments[t].length;
												var n = Array(e),
													i = 0;
												for (t = 0; t < r; t++)
													for (var o = arguments[t], s = 0, a = o.length; s < a; s++, i++) n[i] = o[s];
												return n
											}, m = function(e, t, r) {
												if (r || 2 === arguments.length)
													for (var n, i = 0, o = t.length; i < o; i++)(n || !(i in t)) && (n || (n = Array.prototype.slice.call(t, 0, i)), n[i] = t[i]);
												return e.concat(n || Array.prototype.slice.call(t))
											}, y = function(e) {
												return this instanceof y ? (this.v = e, this) : new y(e)
											}, b = function(e, t, r) {
												if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
												var n, i = r.apply(e, t || []),
													o = [];
												return n = {}, s("next"), s("throw"), s("return"), n[Symbol.asyncIterator] = function() {
													return this
												}, n;

												function s(e) {
													i[e] && (n[e] = function(t) {
														return new Promise((function(r, n) {
															o.push([e, t, r, n]) > 1 || a(e, t)
														}))
													})
												}

												function a(e, t) {
													try {
														! function(e) {
															e.value instanceof y ? Promise.resolve(e.value.v).then(c, l) : u(o[0][2], e)
														}(i[e](t))
													} catch (r) {
														u(o[0][3], r)
													}
												}

												function c(e) {
													a("next", e)
												}

												function l(e) {
													a("throw", e)
												}

												function u(e, t) {
													e(t), o.shift(), o.length && a(o[0][0], o[0][1])
												}
											}, _ = function(e) {
												var t, r;
												return t = {}, n("next"), n("throw", (function(e) {
													throw e
												})), n("return"), t[Symbol.iterator] = function() {
													return this
												}, t;

												function n(n, i) {
													t[n] = e[n] ? function(t) {
														return (r = !r) ? {
															value: y(e[n](t)),
															done: "return" === n
														} : i ? i(t) : t
													} : i
												}
											}, w = function(e) {
												if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
												var t, r = e[Symbol.asyncIterator];
												return r ? r.call(e) : (e = f(e), t = {}, n("next"), n("throw"), n("return"), t[Symbol.asyncIterator] = function() {
													return this
												}, t);

												function n(r) {
													t[r] = e[r] && function(t) {
														return new Promise((function(n, i) {
															(function(e, t, r, n) {
																Promise.resolve(n).then((function(t) {
																	e({
																		value: t,
																		done: r
																	})
																}), t)
															})(n, i, (t = e[r](t)).done, t.value)
														}))
													}
												}
											}, S = function(e, t) {
												return Object.defineProperty ? Object.defineProperty(e, "raw", {
													value: t
												}) : e.raw = t, e
											};
											var r = Object.create ? function(e, t) {
												Object.defineProperty(e, "default", {
													enumerable: !0,
													value: t
												})
											} : function(e, t) {
												e.default = t
											};
											E = function(e) {
												if (e && e.__esModule) return e;
												var t = {};
												if (null != e)
													for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && C(t, e, n);
												return r(t, e), t
											}, k = function(e) {
												return e && e.__esModule ? e : {
													default: e
												}
											}, T = function(e, t, r, n) {
												if ("a" === r && !n) throw new TypeError("Private accessor was defined without a getter");
												if ("function" == typeof t ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
												return "m" === r ? n : "a" === r ? n.call(e) : n ? n.value : t.get(e)
											}, I = function(e, t, r, n, i) {
												if ("m" === n) throw new TypeError("Private method is not writable");
												if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter");
												if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
												return "a" === n ? i.call(e, r) : i ? i.value = r : t.set(e, r), r
											}, R = function(e, t) {
												if (null === t || "object" != typeof t && "function" != typeof t) throw new TypeError("Cannot use 'in' operator on non-object");
												return "function" == typeof e ? t === e : e.has(t)
											}, e("__extends", i), e("__assign", o), e("__rest", s), e("__decorate", a), e("__param", c), e("__metadata", l), e("__awaiter", u), e("__generator", d), e("__exportStar", h), e("__createBinding", C), e("__values", f), e("__read", p), e("__spread", v), e("__spreadArrays", g), e("__spreadArray", m), e("__await", y), e("__asyncGenerator", b), e("__asyncDelegator", _), e("__asyncValues", w), e("__makeTemplateObject", S), e("__importStar", E), e("__importDefault", k), e("__classPrivateFieldGet", T), e("__classPrivateFieldSet", I), e("__classPrivateFieldIn", R)
										}))
									}),
									w = d((e, t) => {
										! function(n) {
											var i;
											if ("function" == typeof define && r("./node_modules/webpack/buildin/amd-options.js") && (define(n), i = !0), "object" == typeof e && (t.exports = n(), i = !0), !i) {
												var o = window.Cookies,
													s = window.Cookies = n();
												s.noConflict = function() {
													return window.Cookies = o, s
												}
											}
										}((function() {
											function e() {
												for (var e = 0, t = {}; e < arguments.length; e++) {
													var r = arguments[e];
													for (var n in r) t[n] = r[n]
												}
												return t
											}

											function t(e) {
												return e.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent)
											}
											return function r(n) {
												function i() {}

												function o(t, r, o) {
													if (!(typeof document > "u")) {
														"number" == typeof(o = e({
															path: "/"
														}, i.defaults, o)).expires && (o.expires = new Date(1 * new Date + 864e5 * o.expires)), o.expires = o.expires ? o.expires.toUTCString() : "";
														try {
															var s = JSON.stringify(r);
															/^[\{\[]/.test(s) && (r = s)
														} catch {}
														r = n.write ? n.write(r, t) : encodeURIComponent(String(r)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent), t = encodeURIComponent(String(t)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
														var a = "";
														for (var c in o) !o[c] || (a += "; " + c, !0 !== o[c] && (a += "=" + o[c].split(";")[0]));
														return document.cookie = t + "=" + r + a
													}
												}

												function s(e, r) {
													if (!(typeof document > "u")) {
														for (var i = {}, o = document.cookie ? document.cookie.split("; ") : [], s = 0; s < o.length; s++) {
															var a = o[s].split("="),
																c = a.slice(1).join("=");
															!r && '"' === c.charAt(0) && (c = c.slice(1, -1));
															try {
																var l = t(a[0]);
																if (c = (n.read || n)(c, l) || t(c), r) try {
																	c = JSON.parse(c)
																} catch {}
																if (i[l] = c, e === l) break
															} catch {}
														}
														return e ? i[e] : i
													}
												}
												return i.set = o, i.get = function(e) {
													return s(e, !1)
												}, i.getJSON = function(e) {
													return s(e, !0)
												}, i.remove = function(t, r) {
													o(t, "", e(r, {
														expires: -1
													}))
												}, i.defaults = {}, i.withConverter = r, i
											}((function() {}))
										}))
									}),
									S = d((e, t) => {
										t.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
									}),
									E = d((e, t) => {
										t.exports = /[\0-\x1F\x7F-\x9F]/
									}),
									k = d((e, t) => {
										t.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/
									}),
									T = d((e, t) => {
										t.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/
									}),
									I = d((e, t) => {
										t.exports = function(e) {
											var t = {};
											e = e || {}, t.src_Any = S().source, t.src_Cc = E().source, t.src_Z = k().source, t.src_P = T().source, t.src_ZPCc = [t.src_Z, t.src_P, t.src_Cc].join("|"), t.src_ZCc = [t.src_Z, t.src_Cc].join("|");
											var r = "[><]";
											return t.src_pseudo_letter = "(?:(?![><]|" + t.src_ZPCc + ")" + t.src_Any + ")", t.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", t.src_auth = "(?:(?:(?!" + t.src_ZCc + "|[@/\\[\\]()]).)+@)?", t.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", t.src_host_terminator = "(?=$|[><]|" + t.src_ZPCc + ")(?!" + (e["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + t.src_ZPCc + "))", t.src_path = "(?:[/?#](?:(?!" + t.src_ZCc + "|" + r + "|[()[\\]{}.,\"'?!\\-;]).|\\[(?:(?!" + t.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + t.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + t.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + t.src_ZCc + '|["]).)+\\"|\\\'(?:(?!' + t.src_ZCc + "|[']).)+\\'|\\'(?=" + t.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + t.src_ZCc + "|[.]|$)|" + (e["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + t.src_ZCc + "|$)|;(?!" + t.src_ZCc + "|$)|\\!+(?!" + t.src_ZCc + "|[!]|$)|\\?(?!" + t.src_ZCc + "|[?]|$))+|\\/)?", t.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', t.src_xn = "xn--[a-z0-9\\-]{1,59}", t.src_domain_root = "(?:" + t.src_xn + "|" + t.src_pseudo_letter + "{1,63})", t.src_domain = "(?:" + t.src_xn + "|(?:" + t.src_pseudo_letter + ")|(?:" + t.src_pseudo_letter + "(?:-|" + t.src_pseudo_letter + "){0,61}" + t.src_pseudo_letter + "))", t.src_host = "(?:(?:(?:(?:" + t.src_domain + ")\\.)*" + t.src_domain + "))", t.tpl_host_fuzzy = "(?:" + t.src_ip4 + "|(?:(?:(?:" + t.src_domain + ")\\.)+(?:%TLDS%)))", t.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + t.src_domain + ")\\.)+(?:%TLDS%))", t.src_host_strict = t.src_host + t.src_host_terminator, t.tpl_host_fuzzy_strict = t.tpl_host_fuzzy + t.src_host_terminator, t.src_host_port_strict = t.src_host + t.src_port + t.src_host_terminator, t.tpl_host_port_fuzzy_strict = t.tpl_host_fuzzy + t.src_port + t.src_host_terminator, t.tpl_host_port_no_ip_fuzzy_strict = t.tpl_host_no_ip_fuzzy + t.src_port + t.src_host_terminator, t.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + t.src_ZPCc + "|>|$))", t.tpl_email_fuzzy = '(^|[><]|"|\\(|' + t.src_ZCc + ")(" + t.src_email_name + "@" + t.tpl_host_fuzzy_strict + ")", t.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + t.src_ZPCc + "))((?![$+<=>^`|])" + t.tpl_host_port_fuzzy_strict + t.src_path + ")", t.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + t.src_ZPCc + "))((?![$+<=>^`|])" + t.tpl_host_port_no_ip_fuzzy_strict + t.src_path + ")", t
										}
									}),
									R = d((e, t) => {
										function r(e) {
											return Array.prototype.slice.call(arguments, 1).forEach((function(t) {
												!t || Object.keys(t).forEach((function(r) {
													e[r] = t[r]
												}))
											})), e
										}

										function n(e) {
											return Object.prototype.toString.call(e)
										}

										function i(e) {
											return "[object Function]" === n(e)
										}

										function o(e) {
											return e.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&")
										}
										var s = {
											fuzzyLink: !0,
											fuzzyEmail: !0,
											fuzzyIP: !1
										};
										var a = {
												"http:": {
													validate: function(e, t, r) {
														var n = e.slice(t);
														return r.re.http || (r.re.http = new RegExp("^\\/\\/" + r.re.src_auth + r.re.src_host_port_strict + r.re.src_path, "i")), r.re.http.test(n) ? n.match(r.re.http)[0].length : 0
													}
												},
												"https:": "http:",
												"ftp:": "http:",
												"//": {
													validate: function(e, t, r) {
														var n = e.slice(t);
														return r.re.no_http || (r.re.no_http = new RegExp("^" + r.re.src_auth + "(?:localhost|(?:(?:" + r.re.src_domain + ")\\.)+" + r.re.src_domain_root + ")" + r.re.src_port + r.re.src_host_terminator + r.re.src_path, "i")), r.re.no_http.test(n) ? t >= 3 && ":" === e[t - 3] || t >= 3 && "/" === e[t - 3] ? 0 : n.match(r.re.no_http)[0].length : 0
													}
												},
												"mailto:": {
													validate: function(e, t, r) {
														var n = e.slice(t);
														return r.re.mailto || (r.re.mailto = new RegExp("^" + r.re.src_email_name + "@" + r.re.src_host_strict, "i")), r.re.mailto.test(n) ? n.match(r.re.mailto)[0].length : 0
													}
												}
											},
											c = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]",
											l = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");

										function u(e) {
											var t = e.re = I()(e.__opts__),
												r = e.__tlds__.slice();

											function s(e) {
												return e.replace("%TLDS%", t.src_tlds)
											}
											e.onCompile(), e.__tlds_replaced__ || r.push(c), r.push(t.src_xn), t.src_tlds = r.join("|"), t.email_fuzzy = RegExp(s(t.tpl_email_fuzzy), "i"), t.link_fuzzy = RegExp(s(t.tpl_link_fuzzy), "i"), t.link_no_ip_fuzzy = RegExp(s(t.tpl_link_no_ip_fuzzy), "i"), t.host_fuzzy_test = RegExp(s(t.tpl_host_fuzzy_test), "i");
											var a = [];

											function l(e, t) {
												throw new Error('(LinkifyIt) Invalid schema "' + e + '": ' + t)
											}
											e.__compiled__ = {}, Object.keys(e.__schemas__).forEach((function(t) {
												var r = e.__schemas__[t];
												if (null !== r) {
													var o = {
														validate: null,
														link: null
													};
													if (e.__compiled__[t] = o, function(e) {
															return "[object Object]" === n(e)
														}(r)) return ! function(e) {
														return "[object RegExp]" === n(e)
													}(r.validate) ? i(r.validate) ? o.validate = r.validate : l(t, r) : o.validate = function(e) {
														return function(t, r) {
															var n = t.slice(r);
															return e.test(n) ? n.match(e)[0].length : 0
														}
													}(r.validate), void(i(r.normalize) ? o.normalize = r.normalize : r.normalize ? l(t, r) : o.normalize = function(e, t) {
														t.normalize(e)
													});
													if (function(e) {
															return "[object String]" === n(e)
														}(r)) return void a.push(t);
													l(t, r)
												}
											})), a.forEach((function(t) {
												!e.__compiled__[e.__schemas__[t]] || (e.__compiled__[t].validate = e.__compiled__[e.__schemas__[t]].validate, e.__compiled__[t].normalize = e.__compiled__[e.__schemas__[t]].normalize)
											})), e.__compiled__[""] = {
												validate: null,
												normalize: function(e, t) {
													t.normalize(e)
												}
											};
											var u = Object.keys(e.__compiled__).filter((function(t) {
												return t.length > 0 && e.__compiled__[t]
											})).map(o).join("|");
											e.re.schema_test = RegExp("(^|(?!_)(?:[><]|" + t.src_ZPCc + "))(" + u + ")", "i"), e.re.schema_search = RegExp("(^|(?!_)(?:[><]|" + t.src_ZPCc + "))(" + u + ")", "ig"), e.re.schema_at_start = RegExp("^" + e.re.schema_search.source, "i"), e.re.pretest = RegExp("(" + e.re.schema_test.source + ")|(" + e.re.host_fuzzy_test.source + ")|@", "i"),
												function(e) {
													e.__index__ = -1, e.__text_cache__ = ""
												}(e)
										}

										function d(e, t) {
											var r = e.__index__,
												n = e.__last_index__,
												i = e.__text_cache__.slice(r, n);
											this.schema = e.__schema__.toLowerCase(), this.index = r + t, this.lastIndex = n + t, this.raw = i, this.text = i, this.url = i
										}

										function h(e, t) {
											var r = new d(e, t);
											return e.__compiled__[r.schema].normalize(r, e), r
										}

										function f(e, t) {
											if (!(this instanceof f)) return new f(e, t);
											t || function(e) {
												return Object.keys(e || {}).reduce((function(e, t) {
													return e || s.hasOwnProperty(t)
												}), !1)
											}(e) && (t = e, e = {}), this.__opts__ = r({}, s, t), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = r({}, a, e), this.__compiled__ = {}, this.__tlds__ = l, this.__tlds_replaced__ = !1, this.re = {}, u(this)
										}
										f.prototype.add = function(e, t) {
											return this.__schemas__[e] = t, u(this), this
										}, f.prototype.set = function(e) {
											return this.__opts__ = r(this.__opts__, e), this
										}, f.prototype.test = function(e) {
											if (this.__text_cache__ = e, this.__index__ = -1, !e.length) return !1;
											var t, r, n, i, o, s, a, c;
											if (this.re.schema_test.test(e))
												for ((a = this.re.schema_search).lastIndex = 0; null !== (t = a.exec(e));)
													if (i = this.testSchemaAt(e, t[2], a.lastIndex)) {
														this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + i;
														break
													} return this.__opts__.fuzzyLink && this.__compiled__["http:"] && ((c = e.search(this.re.host_fuzzy_test)) >= 0 && (this.__index__ < 0 || c < this.__index__) && null !== (r = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) && (o = r.index + r[1].length, (this.__index__ < 0 || o < this.__index__) && (this.__schema__ = "", this.__index__ = o, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (e.indexOf("@") >= 0 && null !== (n = e.match(this.re.email_fuzzy)) && (o = n.index + n[1].length, s = n.index + n[0].length, (this.__index__ < 0 || o < this.__index__ || o === this.__index__ && s > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = o, this.__last_index__ = s))), this.__index__ >= 0
										}, f.prototype.pretest = function(e) {
											return this.re.pretest.test(e)
										}, f.prototype.testSchemaAt = function(e, t, r) {
											return this.__compiled__[t.toLowerCase()] ? this.__compiled__[t.toLowerCase()].validate(e, r, this) : 0
										}, f.prototype.match = function(e) {
											var t = 0,
												r = [];
											this.__index__ >= 0 && this.__text_cache__ === e && (r.push(h(this, t)), t = this.__last_index__);
											for (var n = t ? e.slice(t) : e; this.test(n);) r.push(h(this, t)), n = n.slice(this.__last_index__), t += this.__last_index__;
											return r.length ? r : null
										}, f.prototype.matchAtStart = function(e) {
											if (this.__text_cache__ = e, this.__index__ = -1, !e.length) return null;
											var t = this.re.schema_at_start.exec(e);
											if (!t) return null;
											var r = this.testSchemaAt(e, t[2], t[0].length);
											return r ? (this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + r, h(this, 0)) : null
										}, f.prototype.tlds = function(e, t) {
											return e = Array.isArray(e) ? e : [e], t ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter((function(e, t, r) {
												return e !== r[t - 1]
											})).reverse(), u(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, u(this), this)
										}, f.prototype.normalize = function(e) {
											e.schema || (e.url = "http://" + e.url), "mailto:" === e.schema && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url)
										}, f.prototype.onCompile = function() {}, t.exports = f
									}),
									C = d(e => {
										var t, r = e && e.__spreadArray || function(e, t, r) {
											if (r || 2 === arguments.length)
												for (var n, i = 0, o = t.length; i < o; i++)(n || !(i in t)) && (n || (n = Array.prototype.slice.call(t, 0, i)), n[i] = t[i]);
											return e.concat(n || Array.prototype.slice.call(t))
										};
										Object.defineProperty(e, "__esModule", {
												value: !0
											}), e.Logger = e.LogLevel = void 0,
											function(e) {
												e[e.DEBUG = 0] = "DEBUG", e[e.INFO = 1] = "INFO", e[e.WARN = 2] = "WARN", e[e.ERROR = 3] = "ERROR"
											}(t = e.LogLevel || (e.LogLevel = {})), e.Logger = {
												ENABLED: typeof window < "u" && typeof location < "u" && -1 !== location.search.indexOf("giphy-debug"),
												LEVEL: 0,
												PREFIX: "GiphyJS",
												debug: function() {
													for (var n = [], i = 0; i < arguments.length; i++) n[i] = arguments[i];
													e.Logger.ENABLED && e.Logger.LEVEL <= t.DEBUG && console.debug.apply(console, r([e.Logger.PREFIX], n, !1))
												},
												info: function() {
													for (var n = [], i = 0; i < arguments.length; i++) n[i] = arguments[i];
													e.Logger.ENABLED && e.Logger.LEVEL <= t.INFO && console.info.apply(console, r([e.Logger.PREFIX], n, !1))
												},
												warn: function() {
													for (var n = [], i = 0; i < arguments.length; i++) n[i] = arguments[i];
													e.Logger.ENABLED && e.Logger.LEVEL <= t.WARN && console.warn.apply(console, r([e.Logger.PREFIX], n, !1))
												},
												error: function() {
													for (var n = [], i = 0; i < arguments.length; i++) n[i] = arguments[i];
													e.Logger.ENABLED && e.Logger.LEVEL <= t.ERROR && console.error.apply(console, r([e.Logger.PREFIX], n, !1))
												}
											}
									}),
									M = d(e => {
										Object.defineProperty(e, "__esModule", {
											value: !0
										}), e.setRenditionScaleUpMaxPixels = void 0;
										var t = C(),
											r = function(e, t, r) {
												var n, i = 1 / 0;
												return r.forEach((function(r) {
													var o = r.width / e * (r.height / t),
														s = Math.abs(1 - o);
													s < i && (i = s, n = r)
												})), n
											},
											n = 50;
										e.setRenditionScaleUpMaxPixels = function(e) {
											t.Logger.debug("@giphy/js-util set rendition selection scale up max pixels to ".concat(e)), n = e
										}, e.default = function(e, t, i, o) {
											void 0 === o && (o = n);
											var s = e[0],
												a = e.filter((function(e) {
													return e.width * e.height > s.width * s.height && (s = e), t - e.width <= o && i - e.height <= o
												}));
											return 0 === a.length ? s : r(t, i, a)
										}
									}),
									x = d(e => {
										Object.defineProperty(e, "__esModule", {
											value: !0
										}), e.pick = e.without = e.take = e.forEach = e.mapValues = void 0, e.mapValues = function(e, t) {
											if (Array.isArray(e)) throw "This map is just for objects, just use array.map for arrays";
											return Object.keys(e).reduce((function(r, n) {
												return r[n] = t(e[n], n), r
											}), {})
										}, e.forEach = function(e, t) {
											if (Array.isArray(e)) throw "This map is just for objects, just use array.forEach for arrays";
											return Object.keys(e).forEach((function(r) {
												t(e[r], r)
											}))
										}, e.take = function(e, t) {
											return void 0 === t && (t = 0), e.slice(0, t)
										}, e.without = function(e, t) {
											return e.filter((function(e) {
												return -1 === t.indexOf(e)
											}))
										}, e.pick = function(e, t) {
											var r = {};
											return t.forEach((function(t) {
												void 0 !== e[t] && (r[t] = e[t])
											})), r
										}
									}),
									O = d(e => {
										var t = e && e.__assign || function() {
											return (t = Object.assign || function(e) {
												for (var t, r = 1, n = arguments.length; r < n; r++)
													for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
												return e
											}).apply(this, arguments)
										};
										Object.defineProperty(e, "__esModule", {
											value: !0
										});
										e.default = function(e) {
											var r = 0,
												n = 0,
												i = e.offsetWidth,
												o = e.offsetHeight;
											do {
												r += e.offsetLeft, n += e.offsetTop, e = e.offsetParent
											} while (e);
											var s = {
												left: r,
												top: n,
												width: i,
												height: o,
												right: r + i,
												bottom: n + o,
												x: r,
												y: n
											};
											return t(t({}, s), {
												toJSON: function() {
													return JSON.stringify(s)
												}
											})
										}
									});

								function A() {
									if (!P && !(P = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
									return P(D)
								}
								var P, D, j, L = u(() => {
										D = new Uint8Array(16)
									}),
									N = u(() => {
										j = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
									});

								function B(e) {
									return "string" == typeof e && j.test(e)
								}
								var U, F = u(() => {
									N(), U = B
								});

								function $(e) {
									var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
										r = (q[e[t + 0]] + q[e[t + 1]] + q[e[t + 2]] + q[e[t + 3]] + "-" + q[e[t + 4]] + q[e[t + 5]] + "-" + q[e[t + 6]] + q[e[t + 7]] + "-" + q[e[t + 8]] + q[e[t + 9]] + "-" + q[e[t + 10]] + q[e[t + 11]] + q[e[t + 12]] + q[e[t + 13]] + q[e[t + 14]] + q[e[t + 15]]).toLowerCase();
									if (!U(r)) throw TypeError("Stringified UUID is invalid");
									return r
								}
								var q, K, V, z = u(() => {
									for (F(), q = [], K = 0; K < 256; ++K) q.push((K + 256).toString(16).substr(1));
									V = $
								});

								function H(e, t, r) {
									var n = t && r || 0,
										i = t || new Array(16),
										o = (e = e || {}).node || W,
										s = void 0 !== e.clockseq ? e.clockseq : G;
									if (null == o || null == s) {
										var a = e.random || (e.rng || A)();
										null == o && (o = W = [1 | a[0], a[1], a[2], a[3], a[4], a[5]]), null == s && (s = G = 16383 & (a[6] << 8 | a[7]))
									}
									var c = void 0 !== e.msecs ? e.msecs : Date.now(),
										l = void 0 !== e.nsecs ? e.nsecs : Q + 1,
										u = c - Y + (l - Q) / 1e4;
									if (u < 0 && void 0 === e.clockseq && (s = s + 1 & 16383), (u < 0 || c > Y) && void 0 === e.nsecs && (l = 0), l >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
									Y = c, Q = l, G = s;
									var d = (1e4 * (268435455 & (c += 122192928e5)) + l) % 4294967296;
									i[n++] = d >>> 24 & 255, i[n++] = d >>> 16 & 255, i[n++] = d >>> 8 & 255, i[n++] = 255 & d;
									var h = c / 4294967296 * 1e4 & 268435455;
									i[n++] = h >>> 8 & 255, i[n++] = 255 & h, i[n++] = h >>> 24 & 15 | 16, i[n++] = h >>> 16 & 255, i[n++] = s >>> 8 | 128, i[n++] = 255 & s;
									for (var f = 0; f < 6; ++f) i[n + f] = o[f];
									return t || V(i)
								}
								var W, G, Y, Q, J, X = u(() => {
									L(), z(), Y = 0, Q = 0, J = H
								});

								function Z(e) {
									if (!U(e)) throw TypeError("Invalid UUID");
									var t, r = new Uint8Array(16);
									return r[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24, r[1] = t >>> 16 & 255, r[2] = t >>> 8 & 255, r[3] = 255 & t, r[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8, r[5] = 255 & t, r[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8, r[7] = 255 & t, r[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8, r[9] = 255 & t, r[10] = (t = parseInt(e.slice(24, 36), 16)) / 1099511627776 & 255, r[11] = t / 4294967296 & 255, r[12] = t >>> 24 & 255, r[13] = t >>> 16 & 255, r[14] = t >>> 8 & 255, r[15] = 255 & t, r
								}
								var ee, te = u(() => {
									F(), ee = Z
								});

								function re(e, t, r) {
									function n(e, n, i, o) {
										if ("string" == typeof e && (e = function(e) {
												e = unescape(encodeURIComponent(e));
												for (var t = [], r = 0; r < e.length; ++r) t.push(e.charCodeAt(r));
												return t
											}(e)), "string" == typeof n && (n = ee(n)), 16 !== n.length) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
										var s = new Uint8Array(16 + e.length);
										if (s.set(n), s.set(e, n.length), (s = r(s))[6] = 15 & s[6] | t, s[8] = 63 & s[8] | 128, i) {
											o = o || 0;
											for (var a = 0; a < 16; ++a) i[o + a] = s[a];
											return i
										}
										return V(s)
									}
									try {
										n.name = e
									} catch {}
									return n.DNS = ne, n.URL = ie, n
								}
								var ne, ie, oe = u(() => {
									z(), te(), ne = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", ie = "6ba7b811-9dad-11d1-80b4-00c04fd430c8"
								});

								function se(e) {
									if ("string" == typeof e) {
										var t = unescape(encodeURIComponent(e));
										e = new Uint8Array(t.length);
										for (var r = 0; r < t.length; ++r) e[r] = t.charCodeAt(r)
									}
									return function(e) {
										for (var t = [], r = 32 * e.length, n = "0123456789abcdef", i = 0; i < r; i += 8) {
											var o = e[i >> 5] >>> i % 32 & 255,
												s = parseInt(n.charAt(o >>> 4 & 15) + n.charAt(15 & o), 16);
											t.push(s)
										}
										return t
									}(function(e, t) {
										e[t >> 5] |= 128 << t % 32, e[ae(t) - 1] = t;
										for (var r = 1732584193, n = -271733879, i = -1732584194, o = 271733878, s = 0; s < e.length; s += 16) {
											var a = r,
												c = n,
												l = i,
												u = o;
											r = ue(r, n, i, o, e[s], 7, -680876936), o = ue(o, r, n, i, e[s + 1], 12, -389564586), i = ue(i, o, r, n, e[s + 2], 17, 606105819), n = ue(n, i, o, r, e[s + 3], 22, -1044525330), r = ue(r, n, i, o, e[s + 4], 7, -176418897), o = ue(o, r, n, i, e[s + 5], 12, 1200080426), i = ue(i, o, r, n, e[s + 6], 17, -1473231341), n = ue(n, i, o, r, e[s + 7], 22, -45705983), r = ue(r, n, i, o, e[s + 8], 7, 1770035416), o = ue(o, r, n, i, e[s + 9], 12, -1958414417), i = ue(i, o, r, n, e[s + 10], 17, -42063), n = ue(n, i, o, r, e[s + 11], 22, -1990404162), r = ue(r, n, i, o, e[s + 12], 7, 1804603682), o = ue(o, r, n, i, e[s + 13], 12, -40341101), i = ue(i, o, r, n, e[s + 14], 17, -1502002290), n = ue(n, i, o, r, e[s + 15], 22, 1236535329), r = de(r, n, i, o, e[s + 1], 5, -165796510), o = de(o, r, n, i, e[s + 6], 9, -1069501632), i = de(i, o, r, n, e[s + 11], 14, 643717713), n = de(n, i, o, r, e[s], 20, -373897302), r = de(r, n, i, o, e[s + 5], 5, -701558691), o = de(o, r, n, i, e[s + 10], 9, 38016083), i = de(i, o, r, n, e[s + 15], 14, -660478335), n = de(n, i, o, r, e[s + 4], 20, -405537848), r = de(r, n, i, o, e[s + 9], 5, 568446438), o = de(o, r, n, i, e[s + 14], 9, -1019803690), i = de(i, o, r, n, e[s + 3], 14, -187363961), n = de(n, i, o, r, e[s + 8], 20, 1163531501), r = de(r, n, i, o, e[s + 13], 5, -1444681467), o = de(o, r, n, i, e[s + 2], 9, -51403784), i = de(i, o, r, n, e[s + 7], 14, 1735328473), n = de(n, i, o, r, e[s + 12], 20, -1926607734), r = he(r, n, i, o, e[s + 5], 4, -378558), o = he(o, r, n, i, e[s + 8], 11, -2022574463), i = he(i, o, r, n, e[s + 11], 16, 1839030562), n = he(n, i, o, r, e[s + 14], 23, -35309556), r = he(r, n, i, o, e[s + 1], 4, -1530992060), o = he(o, r, n, i, e[s + 4], 11, 1272893353), i = he(i, o, r, n, e[s + 7], 16, -155497632), n = he(n, i, o, r, e[s + 10], 23, -1094730640), r = he(r, n, i, o, e[s + 13], 4, 681279174), o = he(o, r, n, i, e[s], 11, -358537222), i = he(i, o, r, n, e[s + 3], 16, -722521979), n = he(n, i, o, r, e[s + 6], 23, 76029189), r = he(r, n, i, o, e[s + 9], 4, -640364487), o = he(o, r, n, i, e[s + 12], 11, -421815835), i = he(i, o, r, n, e[s + 15], 16, 530742520), n = he(n, i, o, r, e[s + 2], 23, -995338651), r = fe(r, n, i, o, e[s], 6, -198630844), o = fe(o, r, n, i, e[s + 7], 10, 1126891415), i = fe(i, o, r, n, e[s + 14], 15, -1416354905), n = fe(n, i, o, r, e[s + 5], 21, -57434055), r = fe(r, n, i, o, e[s + 12], 6, 1700485571), o = fe(o, r, n, i, e[s + 3], 10, -1894986606), i = fe(i, o, r, n, e[s + 10], 15, -1051523), n = fe(n, i, o, r, e[s + 1], 21, -2054922799), r = fe(r, n, i, o, e[s + 8], 6, 1873313359), o = fe(o, r, n, i, e[s + 15], 10, -30611744), i = fe(i, o, r, n, e[s + 6], 15, -1560198380), n = fe(n, i, o, r, e[s + 13], 21, 1309151649), r = fe(r, n, i, o, e[s + 4], 6, -145523070), o = fe(o, r, n, i, e[s + 11], 10, -1120210379), i = fe(i, o, r, n, e[s + 2], 15, 718787259), n = fe(n, i, o, r, e[s + 9], 21, -343485551), r = ce(r, a), n = ce(n, c), i = ce(i, l), o = ce(o, u)
										}
										return [r, n, i, o]
									}(function(e) {
										if (0 === e.length) return [];
										for (var t = 8 * e.length, r = new Uint32Array(ae(t)), n = 0; n < t; n += 8) r[n >> 5] |= (255 & e[n / 8]) << n % 32;
										return r
									}(e), 8 * e.length))
								}

								function ae(e) {
									return 14 + (e + 64 >>> 9 << 4) + 1
								}

								function ce(e, t) {
									var r = (65535 & e) + (65535 & t);
									return (e >> 16) + (t >> 16) + (r >> 16) << 16 | 65535 & r
								}

								function le(e, t, r, n, i, o) {
									return ce(function(e, t) {
										return e << t | e >>> 32 - t
									}(ce(ce(t, e), ce(n, o)), i), r)
								}

								function ue(e, t, r, n, i, o, s) {
									return le(t & r | ~t & n, e, t, i, o, s)
								}

								function de(e, t, r, n, i, o, s) {
									return le(t & n | r & ~n, e, t, i, o, s)
								}

								function he(e, t, r, n, i, o, s) {
									return le(t ^ r ^ n, e, t, i, o, s)
								}

								function fe(e, t, r, n, i, o, s) {
									return le(r ^ (t | ~n), e, t, i, o, s)
								}
								var pe, ve, ge, me = u(() => {
										pe = se
									}),
									ye = u(() => {
										oe(), me(), ve = re("v3", 48, pe), ge = ve
									});

								function be(e, t, r) {
									var n = (e = e || {}).random || (e.rng || A)();
									if (n[6] = 15 & n[6] | 64, n[8] = 63 & n[8] | 128, t) {
										r = r || 0;
										for (var i = 0; i < 16; ++i) t[r + i] = n[i];
										return t
									}
									return V(n)
								}
								var _e, we = u(() => {
									L(), z(), _e = be
								});

								function Se(e, t, r, n) {
									switch (e) {
										case 0:
											return t & r ^ ~t & n;
										case 1:
											return t ^ r ^ n;
										case 2:
											return t & r ^ t & n ^ r & n;
										case 3:
											return t ^ r ^ n
									}
								}

								function Ee(e, t) {
									return e << t | e >>> 32 - t
								}

								function ke(e) {
									var t = [1518500249, 1859775393, 2400959708, 3395469782],
										r = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
									if ("string" == typeof e) {
										var n = unescape(encodeURIComponent(e));
										e = [];
										for (var i = 0; i < n.length; ++i) e.push(n.charCodeAt(i))
									} else Array.isArray(e) || (e = Array.prototype.slice.call(e));
									e.push(128);
									for (var o = e.length / 4 + 2, s = Math.ceil(o / 16), a = new Array(s), c = 0; c < s; ++c) {
										for (var l = new Uint32Array(16), u = 0; u < 16; ++u) l[u] = e[64 * c + 4 * u] << 24 | e[64 * c + 4 * u + 1] << 16 | e[64 * c + 4 * u + 2] << 8 | e[64 * c + 4 * u + 3];
										a[c] = l
									}
									a[s - 1][14] = 8 * (e.length - 1) / Math.pow(2, 32), a[s - 1][14] = Math.floor(a[s - 1][14]), a[s - 1][15] = 8 * (e.length - 1) & 4294967295;
									for (var d = 0; d < s; ++d) {
										for (var h = new Uint32Array(80), f = 0; f < 16; ++f) h[f] = a[d][f];
										for (var p = 16; p < 80; ++p) h[p] = Ee(h[p - 3] ^ h[p - 8] ^ h[p - 14] ^ h[p - 16], 1);
										for (var v = r[0], g = r[1], m = r[2], y = r[3], b = r[4], _ = 0; _ < 80; ++_) {
											var w = Math.floor(_ / 20),
												S = Ee(v, 5) + Se(w, g, m, y) + b + t[w] + h[_] >>> 0;
											b = y, y = m, m = Ee(g, 30) >>> 0, g = v, v = S
										}
										r[0] = r[0] + v >>> 0, r[1] = r[1] + g >>> 0, r[2] = r[2] + m >>> 0, r[3] = r[3] + y >>> 0, r[4] = r[4] + b >>> 0
									}
									return [r[0] >> 24 & 255, r[0] >> 16 & 255, r[0] >> 8 & 255, 255 & r[0], r[1] >> 24 & 255, r[1] >> 16 & 255, r[1] >> 8 & 255, 255 & r[1], r[2] >> 24 & 255, r[2] >> 16 & 255, r[2] >> 8 & 255, 255 & r[2], r[3] >> 24 & 255, r[3] >> 16 & 255, r[3] >> 8 & 255, 255 & r[3], r[4] >> 24 & 255, r[4] >> 16 & 255, r[4] >> 8 & 255, 255 & r[4]]
								}
								var Te, Ie, Re, Ce, Me = u(() => {
										Te = ke
									}),
									xe = u(() => {
										oe(), Me(), Ie = re("v5", 80, Te), Re = Ie
									}),
									Oe = u(() => {
										Ce = "00000000-0000-0000-0000-000000000000"
									});

								function Ae(e) {
									if (!U(e)) throw TypeError("Invalid UUID");
									return parseInt(e.substr(14, 1), 16)
								}
								var Pe, De = u(() => {
										F(), Pe = Ae
									}),
									je = {};
								h(je, {
									NIL: () => Ce,
									parse: () => ee,
									stringify: () => V,
									v1: () => J,
									v3: () => ge,
									v4: () => _e,
									v5: () => Re,
									validate: () => U,
									version: () => Pe
								});
								var Le, Ne = u(() => {
										X(), ye(), we(), xe(), Oe(), De(), F(), z(), te()
									}),
									Be = d(e => {
										Object.defineProperty(e, "__esModule", {
											value: !0
										});
										var t = (Ne(), (e => f(o({}, "__esModule", {
												value: !0
											}), e))(je)),
											r = "";
										e.default = function() {
											if (!r) {
												try {
													r = sessionStorage.getItem("giphyPingbackId")
												} catch {}
												if (!r) {
													var e = (new Date).getTime().toString(16);
													try {
														r = "".concat(e).concat((0, t.v4)().replace(/-/g, "")).substring(0, 16)
													} catch {
														r = function() {
															for (var e = "", t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", r = t.length, n = 0; n < 16; n++) e += t.charAt(Math.floor(Math.random() * r));
															return e
														}()
													}
													try {
														sessionStorage.setItem("giphyPingbackId", r)
													} catch {}
												}
											}
											return r
										}
									}),
									Ue = d(e => {
										Object.defineProperty(e, "__esModule", {
											value: !0
										}), e.checkIfWebP = e.SUPPORTS_WEBP = void 0, e.SUPPORTS_WEBP = null, e.checkIfWebP = new Promise((function(t) {
											typeof Image > "u" && t(!1);
											var r = new Image;
											r.onload = function() {
												e.SUPPORTS_WEBP = !0, t(e.SUPPORTS_WEBP)
											}, r.onerror = function() {
												e.SUPPORTS_WEBP = !1, t(e.SUPPORTS_WEBP)
											}, r.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA"
										}))
									}),
									Fe = d(e => {
										var t = e && e.__assign || function() {
												return (t = Object.assign || function(e) {
													for (var t, r = 1, n = arguments.length; r < n; r++)
														for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
													return e
												}).apply(this, arguments)
											},
											r = e && e.__importDefault || function(e) {
												return e && e.__esModule ? e : {
													default: e
												}
											};
										Object.defineProperty(e, "__esModule", {
											value: !0
										}), e.getAltText = e.getGifWidth = e.getGifHeight = e.getBestRenditionUrl = e.getBestRendition = e.getBestVideo = e.getSpecificRendition = void 0;
										var n = r(M()),
											i = x(),
											o = Ue();
										e.getSpecificRendition = function(e, t, r, n) {
											var i = e.images,
												s = e.is_sticker;
											if (void 0 === r && (r = !1), void 0 === n && (n = !1), !i || !t) return "";
											r = r && !n;
											var a = i["".concat(t).concat(r ? "_still" : "")];
											if (a) {
												if (s || r) return a.url;
												var c = o.SUPPORTS_WEBP && a.webp;
												return n ? a.mp4 : c || a.url
											}
											return ""
										};
										e.getBestVideo = function(e, r, i) {
											var o = null == e ? void 0 : e.assets;
											if (o) {
												delete(o = t({}, o)).source;
												var s = Object.values(o).sort((function(e, t) {
													return e.width - t.width
												}));
												return (0, n.default)(s, r, i)
											}
										};
										e.getBestRendition = function(e, r, o, s) {
											var a = (0, i.pick)(e, ["original", "fixed_width", "fixed_height", "fixed_width_small", "fixed_height_small"]),
												c = Object.entries(a).map((function(e) {
													var r = e[0],
														n = e[1];
													return t({
														renditionName: r
													}, n)
												}));
											return (0, n.default)(c, r, o, s)
										};
										e.getBestRenditionUrl = function(t, r, n, i) {
											var s = t.images,
												a = t.video,
												c = t.type;
											if (void 0 === i && (i = {
													isStill: !1,
													useVideo: !1
												}), !r || !n || !s) return "";
											var l = i.useVideo,
												u = i.isStill,
												d = i.scaleUpMaxPixels,
												h = function(e, t, r) {
													return "video" === e && r && r.previews && !Object.keys(t).length ? r.previews : t
												}(c, s, a),
												f = (0, e.getBestRendition)(h, r, n, d).renditionName,
												p = h["".concat(f).concat(u && !l ? "_still" : "")];
											return (l ? p.mp4 : o.SUPPORTS_WEBP && p.webp ? p.webp : p.url) || ""
										};
										e.getGifHeight = function(e, t) {
											var r = e.images.fixed_width;
											if (r) {
												var n = r.width / r.height;
												return Math.round(t / n)
											}
											return 0
										};
										e.getGifWidth = function(e, t) {
											var r = e.images.fixed_width;
											if (r) {
												var n = r.width / r.height;
												return Math.round(t * n)
											}
											return 0
										};
										e.getAltText = function(e) {
											var t = e.user,
												r = e.tags,
												n = void 0 === r ? [] : r,
												o = e.is_sticker,
												s = void 0 !== o && o,
												a = e.title,
												c = void 0 === a ? "" : a;
											if (c) return c;
											var l = t && t.username || "",
												u = (0, i.take)((0, i.without)(n, ["transparent"]), l ? 4 : 5);
											return "".concat(l ? "".concat(l, " ") : "").concat(u.join(" "), " ").concat(s ? "Sticker" : "GIF")
										}
									}),
									$e = d(t => {
										Object.defineProperty(t, "__esModule", {
											value: !0
										}), t.appendGiphySDKRequestParam = t.appendGiphySDKRequestHeader = t.getGiphySDKRequestHeaders = void 0;
										var r = (typeof window < "u" ? window : e) || {};
										r._GIPHY_SDK_HEADERS_ = r._GIPHY_SDK_HEADERS_ || (r.Headers ? new r.Headers({
											"X-GIPHY-SDK-PLATFORM": "web"
										}) : void 0);
										t.getGiphySDKRequestHeaders = function() {
											return r._GIPHY_SDK_HEADERS_
										};
										t.appendGiphySDKRequestHeader = function(e, r) {
											var n;
											return null === (n = (0, t.getGiphySDKRequestHeaders)()) || void 0 === n ? void 0 : n.set(e, r)
										};
										t.appendGiphySDKRequestParam = function(e, r) {
											var n;
											return null === (n = (0, t.getGiphySDKRequestHeaders)()) || void 0 === n ? void 0 : n.set(e, r)
										}
									}),
									qe = d(e => {
										var t = e && e.__createBinding || (Object.create ? function(e, t, r, n) {
												void 0 === n && (n = r);
												var i = Object.getOwnPropertyDescriptor(t, r);
												(!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
													enumerable: !0,
													get: function() {
														return t[r]
													}
												}), Object.defineProperty(e, n, i)
											} : function(e, t, r, n) {
												void 0 === n && (n = r), e[n] = t[r]
											}),
											r = e && e.__exportStar || function(e, r) {
												for (var n in e) "default" !== n && !Object.prototype.hasOwnProperty.call(r, n) && t(r, e, n)
											},
											n = e && e.__importDefault || function(e) {
												return e && e.__esModule ? e : {
													default: e
												}
											};
										Object.defineProperty(e, "__esModule", {
											value: !0
										}), e.checkIfWebP = e.getSpecificRendition = e.getGifWidth = e.getGifHeight = e.getBestVideo = e.getBestRenditionUrl = e.getBestRendition = e.getAltText = e.getPingbackId = e.getClientRect = e.setRenditionScaleUpMaxPixels = e.bestfit = void 0;
										var i = M();
										Object.defineProperty(e, "bestfit", {
											enumerable: !0,
											get: function() {
												return n(i).default
											}
										}), Object.defineProperty(e, "setRenditionScaleUpMaxPixels", {
											enumerable: !0,
											get: function() {
												return i.setRenditionScaleUpMaxPixels
											}
										}), r(x(), e);
										var o = O();
										Object.defineProperty(e, "getClientRect", {
											enumerable: !0,
											get: function() {
												return n(o).default
											}
										});
										var s = Be();
										Object.defineProperty(e, "getPingbackId", {
											enumerable: !0,
											get: function() {
												return n(s).default
											}
										});
										var a = Fe();
										Object.defineProperty(e, "getAltText", {
											enumerable: !0,
											get: function() {
												return a.getAltText
											}
										}), Object.defineProperty(e, "getBestRendition", {
											enumerable: !0,
											get: function() {
												return a.getBestRendition
											}
										}), Object.defineProperty(e, "getBestRenditionUrl", {
											enumerable: !0,
											get: function() {
												return a.getBestRenditionUrl
											}
										}), Object.defineProperty(e, "getBestVideo", {
											enumerable: !0,
											get: function() {
												return a.getBestVideo
											}
										}), Object.defineProperty(e, "getGifHeight", {
											enumerable: !0,
											get: function() {
												return a.getGifHeight
											}
										}), Object.defineProperty(e, "getGifWidth", {
											enumerable: !0,
											get: function() {
												return a.getGifWidth
											}
										}), Object.defineProperty(e, "getSpecificRendition", {
											enumerable: !0,
											get: function() {
												return a.getSpecificRendition
											}
										}), r(C(), e), r($e(), e);
										var c = Ue();
										Object.defineProperty(e, "checkIfWebP", {
											enumerable: !0,
											get: function() {
												return c.checkIfWebP
											}
										})
									}),
									Ke = d((e, t) => {
										t.exports = function() {
											if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return !1;
											if ("symbol" == typeof Symbol.iterator) return !0;
											var e = {},
												t = Symbol("test"),
												r = Object(t);
											if ("string" == typeof t || "[object Symbol]" !== Object.prototype.toString.call(t) || "[object Symbol]" !== Object.prototype.toString.call(r)) return !1;
											for (t in e[t] = 42, e) return !1;
											if ("function" == typeof Object.keys && 0 !== Object.keys(e).length || "function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e).length) return !1;
											var n = Object.getOwnPropertySymbols(e);
											if (1 !== n.length || n[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t)) return !1;
											if ("function" == typeof Object.getOwnPropertyDescriptor) {
												var i = Object.getOwnPropertyDescriptor(e, t);
												if (42 !== i.value || !0 !== i.enumerable) return !1
											}
											return !0
										}
									}),
									Ve = d((e, t) => {
										var r = typeof Symbol < "u" && Symbol,
											n = Ke();
										t.exports = function() {
											return "function" == typeof r && "function" == typeof Symbol && "symbol" == typeof r("foo") && "symbol" == typeof Symbol("bar") && n()
										}
									}),
									ze = d((e, t) => {
										var r = "Function.prototype.bind called on incompatible ",
											n = Array.prototype.slice,
											i = Object.prototype.toString,
											o = "[object Function]";
										t.exports = function(e) {
											var t = this;
											if ("function" != typeof t || i.call(t) !== o) throw new TypeError(r + t);
											for (var s, a = n.call(arguments, 1), c = function() {
													if (this instanceof s) {
														var r = t.apply(this, a.concat(n.call(arguments)));
														return Object(r) === r ? r : this
													}
													return t.apply(e, a.concat(n.call(arguments)))
												}, l = Math.max(0, t.length - a.length), u = [], d = 0; d < l; d++) u.push("$" + d);
											if (s = Function("binder", "return function (" + u.join(",") + "){ return binder.apply(this,arguments); }")(c), t.prototype) {
												var h = function() {};
												h.prototype = t.prototype, s.prototype = new h, h.prototype = null
											}
											return s
										}
									}),
									He = d((e, t) => {
										var r = ze();
										t.exports = Function.prototype.bind || r
									}),
									We = d((e, t) => {
										var r = He();
										t.exports = r.call(Function.call, Object.prototype.hasOwnProperty)
									}),
									Ge = d((e, t) => {
										var r, n = SyntaxError,
											i = Function,
											o = TypeError,
											s = function(e) {
												try {
													return i('"use strict"; return (' + e + ").constructor;")()
												} catch {}
											},
											a = Object.getOwnPropertyDescriptor;
										if (a) try {
											a({}, "")
										} catch {
											a = null
										}
										var c = function() {
												throw new o
											},
											l = a ? function() {
												try {
													return arguments.callee, c
												} catch {
													try {
														return a(arguments, "callee").get
													} catch {
														return c
													}
												}
											}() : c,
											u = Ve()(),
											d = Object.getPrototypeOf || function(e) {
												return e.__proto__
											},
											h = {},
											f = typeof Uint8Array > "u" ? r : d(Uint8Array),
											p = {
												"%AggregateError%": typeof AggregateError > "u" ? r : AggregateError,
												"%Array%": Array,
												"%ArrayBuffer%": typeof ArrayBuffer > "u" ? r : ArrayBuffer,
												"%ArrayIteratorPrototype%": u ? d([][Symbol.iterator]()) : r,
												"%AsyncFromSyncIteratorPrototype%": r,
												"%AsyncFunction%": h,
												"%AsyncGenerator%": h,
												"%AsyncGeneratorFunction%": h,
												"%AsyncIteratorPrototype%": h,
												"%Atomics%": typeof Atomics > "u" ? r : Atomics,
												"%BigInt%": typeof BigInt > "u" ? r : BigInt,
												"%Boolean%": Boolean,
												"%DataView%": typeof DataView > "u" ? r : DataView,
												"%Date%": Date,
												"%decodeURI%": decodeURI,
												"%decodeURIComponent%": decodeURIComponent,
												"%encodeURI%": encodeURI,
												"%encodeURIComponent%": encodeURIComponent,
												"%Error%": Error,
												"%eval%": eval,
												"%EvalError%": EvalError,
												"%Float32Array%": typeof Float32Array > "u" ? r : Float32Array,
												"%Float64Array%": typeof Float64Array > "u" ? r : Float64Array,
												"%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? r : FinalizationRegistry,
												"%Function%": i,
												"%GeneratorFunction%": h,
												"%Int8Array%": typeof Int8Array > "u" ? r : Int8Array,
												"%Int16Array%": typeof Int16Array > "u" ? r : Int16Array,
												"%Int32Array%": typeof Int32Array > "u" ? r : Int32Array,
												"%isFinite%": isFinite,
												"%isNaN%": isNaN,
												"%IteratorPrototype%": u ? d(d([][Symbol.iterator]())) : r,
												"%JSON%": "object" == typeof JSON ? JSON : r,
												"%Map%": typeof Map > "u" ? r : Map,
												"%MapIteratorPrototype%": typeof Map > "u" || !u ? r : d((new Map)[Symbol.iterator]()),
												"%Math%": Math,
												"%Number%": Number,
												"%Object%": Object,
												"%parseFloat%": parseFloat,
												"%parseInt%": parseInt,
												"%Promise%": typeof Promise > "u" ? r : Promise,
												"%Proxy%": typeof Proxy > "u" ? r : Proxy,
												"%RangeError%": RangeError,
												"%ReferenceError%": ReferenceError,
												"%Reflect%": typeof Reflect > "u" ? r : Reflect,
												"%RegExp%": RegExp,
												"%Set%": typeof Set > "u" ? r : Set,
												"%SetIteratorPrototype%": typeof Set > "u" || !u ? r : d((new Set)[Symbol.iterator]()),
												"%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? r : SharedArrayBuffer,
												"%String%": String,
												"%StringIteratorPrototype%": u ? d("" [Symbol.iterator]()) : r,
												"%Symbol%": u ? Symbol : r,
												"%SyntaxError%": n,
												"%ThrowTypeError%": l,
												"%TypedArray%": f,
												"%TypeError%": o,
												"%Uint8Array%": typeof Uint8Array > "u" ? r : Uint8Array,
												"%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? r : Uint8ClampedArray,
												"%Uint16Array%": typeof Uint16Array > "u" ? r : Uint16Array,
												"%Uint32Array%": typeof Uint32Array > "u" ? r : Uint32Array,
												"%URIError%": URIError,
												"%WeakMap%": typeof WeakMap > "u" ? r : WeakMap,
												"%WeakRef%": typeof WeakRef > "u" ? r : WeakRef,
												"%WeakSet%": typeof WeakSet > "u" ? r : WeakSet
											},
											v = {
												"%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
												"%ArrayPrototype%": ["Array", "prototype"],
												"%ArrayProto_entries%": ["Array", "prototype", "entries"],
												"%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
												"%ArrayProto_keys%": ["Array", "prototype", "keys"],
												"%ArrayProto_values%": ["Array", "prototype", "values"],
												"%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
												"%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
												"%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
												"%BooleanPrototype%": ["Boolean", "prototype"],
												"%DataViewPrototype%": ["DataView", "prototype"],
												"%DatePrototype%": ["Date", "prototype"],
												"%ErrorPrototype%": ["Error", "prototype"],
												"%EvalErrorPrototype%": ["EvalError", "prototype"],
												"%Float32ArrayPrototype%": ["Float32Array", "prototype"],
												"%Float64ArrayPrototype%": ["Float64Array", "prototype"],
												"%FunctionPrototype%": ["Function", "prototype"],
												"%Generator%": ["GeneratorFunction", "prototype"],
												"%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
												"%Int8ArrayPrototype%": ["Int8Array", "prototype"],
												"%Int16ArrayPrototype%": ["Int16Array", "prototype"],
												"%Int32ArrayPrototype%": ["Int32Array", "prototype"],
												"%JSONParse%": ["JSON", "parse"],
												"%JSONStringify%": ["JSON", "stringify"],
												"%MapPrototype%": ["Map", "prototype"],
												"%NumberPrototype%": ["Number", "prototype"],
												"%ObjectPrototype%": ["Object", "prototype"],
												"%ObjProto_toString%": ["Object", "prototype", "toString"],
												"%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
												"%PromisePrototype%": ["Promise", "prototype"],
												"%PromiseProto_then%": ["Promise", "prototype", "then"],
												"%Promise_all%": ["Promise", "all"],
												"%Promise_reject%": ["Promise", "reject"],
												"%Promise_resolve%": ["Promise", "resolve"],
												"%RangeErrorPrototype%": ["RangeError", "prototype"],
												"%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
												"%RegExpPrototype%": ["RegExp", "prototype"],
												"%SetPrototype%": ["Set", "prototype"],
												"%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
												"%StringPrototype%": ["String", "prototype"],
												"%SymbolPrototype%": ["Symbol", "prototype"],
												"%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
												"%TypedArrayPrototype%": ["TypedArray", "prototype"],
												"%TypeErrorPrototype%": ["TypeError", "prototype"],
												"%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
												"%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
												"%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
												"%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
												"%URIErrorPrototype%": ["URIError", "prototype"],
												"%WeakMapPrototype%": ["WeakMap", "prototype"],
												"%WeakSetPrototype%": ["WeakSet", "prototype"]
											},
											g = He(),
											m = We(),
											y = g.call(Function.call, Array.prototype.concat),
											b = g.call(Function.apply, Array.prototype.splice),
											_ = g.call(Function.call, String.prototype.replace),
											w = g.call(Function.call, String.prototype.slice),
											S = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
											E = /\\(\\)?/g,
											k = function(e) {
												var t = w(e, 0, 1),
													r = w(e, -1);
												if ("%" === t && "%" !== r) throw new n("invalid intrinsic syntax, expected closing `%`");
												if ("%" === r && "%" !== t) throw new n("invalid intrinsic syntax, expected opening `%`");
												var i = [];
												return _(e, S, (function(e, t, r, n) {
													i[i.length] = r ? _(n, E, "$1") : t || e
												})), i
											},
											T = function(e, t) {
												var r, i = e;
												if (m(v, i) && (i = "%" + (r = v[i])[0] + "%"), m(p, i)) {
													var a = p[i];
													if (a === h && (a = function e(t) {
															var r;
															if ("%AsyncFunction%" === t) r = s("async function () {}");
															else if ("%GeneratorFunction%" === t) r = s("function* () {}");
															else if ("%AsyncGeneratorFunction%" === t) r = s("async function* () {}");
															else if ("%AsyncGenerator%" === t) {
																var n = e("%AsyncGeneratorFunction%");
																n && (r = n.prototype)
															} else if ("%AsyncIteratorPrototype%" === t) {
																var i = e("%AsyncGenerator%");
																i && (r = d(i.prototype))
															}
															return p[t] = r, r
														}(i)), typeof a > "u" && !t) throw new o("intrinsic " + e + " exists, but is not available. Please file an issue!");
													return {
														alias: r,
														name: i,
														value: a
													}
												}
												throw new n("intrinsic " + e + " does not exist!")
											};
										t.exports = function(e, t) {
											if ("string" != typeof e || 0 === e.length) throw new o("intrinsic name must be a non-empty string");
											if (arguments.length > 1 && "boolean" != typeof t) throw new o('"allowMissing" argument must be a boolean');
											var r = k(e),
												i = r.length > 0 ? r[0] : "",
												s = T("%" + i + "%", t),
												c = s.name,
												l = s.value,
												u = !1,
												d = s.alias;
											d && (i = d[0], b(r, y([0, 1], d)));
											for (var h = 1, f = !0; h < r.length; h += 1) {
												var v = r[h],
													g = w(v, 0, 1),
													_ = w(v, -1);
												if (('"' === g || "'" === g || "`" === g || '"' === _ || "'" === _ || "`" === _) && g !== _) throw new n("property names with quotes must have matching quotes");
												if (("constructor" === v || !f) && (u = !0), m(p, c = "%" + (i += "." + v) + "%")) l = p[c];
												else if (null != l) {
													if (!(v in l)) {
														if (!t) throw new o("base intrinsic for " + e + " exists, but the property is not available.");
														return
													}
													if (a && h + 1 >= r.length) {
														var S = a(l, v);
														l = (f = !!S) && "get" in S && !("originalValue" in S.get) ? S.get : l[v]
													} else f = m(l, v), l = l[v];
													f && !u && (p[c] = l)
												}
											}
											return l
										}
									}),
									Ye = d((e, t) => {
										var r = He(),
											n = Ge(),
											i = n("%Function.prototype.apply%"),
											o = n("%Function.prototype.call%"),
											s = n("%Reflect.apply%", !0) || r.call(o, i),
											a = n("%Object.getOwnPropertyDescriptor%", !0),
											c = n("%Object.defineProperty%", !0),
											l = n("%Math.max%");
										if (c) try {
											c({}, "a", {
												value: 1
											})
										} catch {
											c = null
										}
										t.exports = function(e) {
											var t = s(r, o, arguments);
											if (a && c) {
												var n = a(t, "length");
												n.configurable && c(t, "length", {
													value: 1 + l(0, e.length - (arguments.length - 1))
												})
											}
											return t
										};
										var u = function() {
											return s(r, i, arguments)
										};
										c ? c(t.exports, "apply", {
											value: u
										}) : t.exports.apply = u
									}),
									Qe = d((e, t) => {
										var r = Ge(),
											n = Ye(),
											i = n(r("String.prototype.indexOf"));
										t.exports = function(e, t) {
											var o = r(e, !!t);
											return "function" == typeof o && i(e, ".prototype.") > -1 ? n(o) : o
										}
									}),
									Je = d(() => {}),
									Xe = d((e, t) => {
										var r = "function" == typeof Map && Map.prototype,
											n = Object.getOwnPropertyDescriptor && r ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
											i = r && n && "function" == typeof n.get ? n.get : null,
											o = r && Map.prototype.forEach,
											s = "function" == typeof Set && Set.prototype,
											a = Object.getOwnPropertyDescriptor && s ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
											c = s && a && "function" == typeof a.get ? a.get : null,
											l = s && Set.prototype.forEach,
											u = "function" == typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null,
											d = "function" == typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null,
											h = "function" == typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null,
											f = Boolean.prototype.valueOf,
											p = Object.prototype.toString,
											v = Function.prototype.toString,
											g = String.prototype.match,
											m = String.prototype.slice,
											y = String.prototype.replace,
											b = String.prototype.toUpperCase,
											_ = String.prototype.toLowerCase,
											w = RegExp.prototype.test,
											S = Array.prototype.concat,
											E = Array.prototype.join,
											k = Array.prototype.slice,
											T = Math.floor,
											I = "function" == typeof BigInt ? BigInt.prototype.valueOf : null,
											R = Object.getOwnPropertySymbols,
											C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol.prototype.toString : null,
											M = "function" == typeof Symbol && "object" == typeof Symbol.iterator,
											x = "function" == typeof Symbol && Symbol.toStringTag && (typeof Symbol.toStringTag === M || "symbol") ? Symbol.toStringTag : null,
											O = Object.prototype.propertyIsEnumerable,
											A = ("function" == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
												return e.__proto__
											} : null);

										function P(e, t) {
											if (e === 1 / 0 || e === -1 / 0 || e != e || e && e > -1e3 && e < 1e3 || w.call(/e/, t)) return t;
											var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
											if ("number" == typeof e) {
												var n = e < 0 ? -T(-e) : T(e);
												if (n !== e) {
													var i = String(n),
														o = m.call(t, i.length + 1);
													return y.call(i, r, "$&_") + "." + y.call(y.call(o, /([0-9]{3})/g, "$&_"), /_$/, "")
												}
											}
											return y.call(t, r, "$&_")
										}
										var D = Je().custom,
											j = D && U(D) ? D : null;

										function L(e, t, r) {
											var n = "double" === (r.quoteStyle || t) ? '"' : "'";
											return n + e + n
										}

										function N(e) {
											return y.call(String(e), /"/g, "&quot;")
										}

										function B(e) {
											return !("[object Array]" !== q(e) || x && "object" == typeof e && x in e)
										}

										function U(e) {
											if (M) return e && "object" == typeof e && e instanceof Symbol;
											if ("symbol" == typeof e) return !0;
											if (!e || "object" != typeof e || !C) return !1;
											try {
												return C.call(e), !0
											} catch {}
											return !1
										}
										t.exports = function e(t, r, n, s) {
											var a = r || {};
											if ($(a, "quoteStyle") && "single" !== a.quoteStyle && "double" !== a.quoteStyle) throw new TypeError('option "quoteStyle" must be "single" or "double"');
											if ($(a, "maxStringLength") && ("number" == typeof a.maxStringLength ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : null !== a.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
											var p = !$(a, "customInspect") || a.customInspect;
											if ("boolean" != typeof p && "symbol" !== p) throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
											if ($(a, "indent") && null !== a.indent && "\t" !== a.indent && !(parseInt(a.indent, 10) === a.indent && a.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
											if ($(a, "numericSeparator") && "boolean" != typeof a.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
											var b = a.numericSeparator;
											if (typeof t > "u") return "undefined";
											if (null === t) return "null";
											if ("boolean" == typeof t) return t ? "true" : "false";
											if ("string" == typeof t) return function e(t, r) {
												if (t.length > r.maxStringLength) {
													var n = t.length - r.maxStringLength,
														i = "... " + n + " more character" + (n > 1 ? "s" : "");
													return e(m.call(t, 0, r.maxStringLength), r) + i
												}
												var o = y.call(y.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, V);
												return L(o, "single", r)
											}(t, a);
											if ("number" == typeof t) {
												if (0 === t) return 1 / 0 / t > 0 ? "0" : "-0";
												var w = String(t);
												return b ? P(t, w) : w
											}
											if ("bigint" == typeof t) {
												var T = String(t) + "n";
												return b ? P(t, T) : T
											}
											var R = typeof a.depth > "u" ? 5 : a.depth;
											if (typeof n > "u" && (n = 0), n >= R && R > 0 && "object" == typeof t) return B(t) ? "[Array]" : "[Object]";
											var D = function(e, t) {
												var r;
												if ("\t" === e.indent) r = "\t";
												else {
													if (!("number" == typeof e.indent && e.indent > 0)) return null;
													r = E.call(Array(e.indent + 1), " ")
												}
												return {
													base: r,
													prev: E.call(Array(t + 1), r)
												}
											}(a, n);
											if (typeof s > "u") s = [];
											else if (K(s, t) >= 0) return "[Circular]";

											function F(t, r, i) {
												if (r && (s = k.call(s)).push(r), i) {
													var o = {
														depth: a.depth
													};
													return $(a, "quoteStyle") && (o.quoteStyle = a.quoteStyle), e(t, o, n + 1, s)
												}
												return e(t, a, n + 1, s)
											}
											if ("function" == typeof t) {
												var Q = function(e) {
														if (e.name) return e.name;
														var t = g.call(v.call(e), /^function\s*([\w$]+)/);
														return t ? t[1] : null
													}(t),
													J = Y(t, F);
												return "[Function" + (Q ? ": " + Q : " (anonymous)") + "]" + (J.length > 0 ? " { " + E.call(J, ", ") + " }" : "")
											}
											if (U(t)) {
												var X = M ? y.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : C.call(t);
												return "object" != typeof t || M ? X : z(X)
											}
											if (function(e) {
													return !(!e || "object" != typeof e) && (typeof HTMLElement < "u" && e instanceof HTMLElement || "string" == typeof e.nodeName && "function" == typeof e.getAttribute)
												}(t)) {
												for (var Z = "<" + _.call(String(t.nodeName)), ee = t.attributes || [], te = 0; te < ee.length; te++) Z += " " + ee[te].name + "=" + L(N(ee[te].value), "double", a);
												return Z += ">", t.childNodes && t.childNodes.length && (Z += "..."), Z += "</" + _.call(String(t.nodeName)) + ">"
											}
											if (B(t)) {
												if (0 === t.length) return "[]";
												var re = Y(t, F);
												return D && ! function(e) {
													for (var t = 0; t < e.length; t++)
														if (K(e[t], "\n") >= 0) return !1;
													return !0
												}(re) ? "[" + G(re, D) + "]" : "[ " + E.call(re, ", ") + " ]"
											}
											if (function(e) {
													return !("[object Error]" !== q(e) || x && "object" == typeof e && x in e)
												}(t)) {
												var ne = Y(t, F);
												return "cause" in t && !O.call(t, "cause") ? "{ [" + String(t) + "] " + E.call(S.call("[cause]: " + F(t.cause), ne), ", ") + " }" : 0 === ne.length ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + E.call(ne, ", ") + " }"
											}
											if ("object" == typeof t && p) {
												if (j && "function" == typeof t[j]) return t[j]();
												if ("symbol" !== p && "function" == typeof t.inspect) return t.inspect()
											}
											if (function(e) {
													if (!i || !e || "object" != typeof e) return !1;
													try {
														i.call(e);
														try {
															c.call(e)
														} catch {
															return !0
														}
														return e instanceof Map
													} catch {}
													return !1
												}(t)) {
												var ie = [];
												return o.call(t, (function(e, r) {
													ie.push(F(r, t, !0) + " => " + F(e, t))
												})), W("Map", i.call(t), ie, D)
											}
											if (function(e) {
													if (!c || !e || "object" != typeof e) return !1;
													try {
														c.call(e);
														try {
															i.call(e)
														} catch {
															return !0
														}
														return e instanceof Set
													} catch {}
													return !1
												}(t)) {
												var oe = [];
												return l.call(t, (function(e) {
													oe.push(F(e, t))
												})), W("Set", c.call(t), oe, D)
											}
											if (function(e) {
													if (!u || !e || "object" != typeof e) return !1;
													try {
														u.call(e, u);
														try {
															d.call(e, d)
														} catch {
															return !0
														}
														return e instanceof WeakMap
													} catch {}
													return !1
												}(t)) return H("WeakMap");
											if (function(e) {
													if (!d || !e || "object" != typeof e) return !1;
													try {
														d.call(e, d);
														try {
															u.call(e, u)
														} catch {
															return !0
														}
														return e instanceof WeakSet
													} catch {}
													return !1
												}(t)) return H("WeakSet");
											if (function(e) {
													if (!h || !e || "object" != typeof e) return !1;
													try {
														return h.call(e), !0
													} catch {}
													return !1
												}(t)) return H("WeakRef");
											if (function(e) {
													return !("[object Number]" !== q(e) || x && "object" == typeof e && x in e)
												}(t)) return z(F(Number(t)));
											if (function(e) {
													if (!e || "object" != typeof e || !I) return !1;
													try {
														return I.call(e), !0
													} catch {}
													return !1
												}(t)) return z(F(I.call(t)));
											if (function(e) {
													return !("[object Boolean]" !== q(e) || x && "object" == typeof e && x in e)
												}(t)) return z(f.call(t));
											if (function(e) {
													return !("[object String]" !== q(e) || x && "object" == typeof e && x in e)
												}(t)) return z(F(String(t)));
											if (! function(e) {
													return !("[object Date]" !== q(e) || x && "object" == typeof e && x in e)
												}(t) && ! function(e) {
													return !("[object RegExp]" !== q(e) || x && "object" == typeof e && x in e)
												}(t)) {
												var se = Y(t, F),
													ae = A ? A(t) === Object.prototype : t instanceof Object || t.constructor === Object,
													ce = t instanceof Object ? "" : "null prototype",
													le = !ae && x && Object(t) === t && x in t ? m.call(q(t), 8, -1) : ce ? "Object" : "",
													ue = (ae || "function" != typeof t.constructor ? "" : t.constructor.name ? t.constructor.name + " " : "") + (le || ce ? "[" + E.call(S.call([], le || [], ce || []), ": ") + "] " : "");
												return 0 === se.length ? ue + "{}" : D ? ue + "{" + G(se, D) + "}" : ue + "{ " + E.call(se, ", ") + " }"
											}
											return String(t)
										};
										var F = Object.prototype.hasOwnProperty || function(e) {
											return e in this
										};

										function $(e, t) {
											return F.call(e, t)
										}

										function q(e) {
											return p.call(e)
										}

										function K(e, t) {
											if (e.indexOf) return e.indexOf(t);
											for (var r = 0, n = e.length; r < n; r++)
												if (e[r] === t) return r;
											return -1
										}

										function V(e) {
											var t = e.charCodeAt(0),
												r = {
													8: "b",
													9: "t",
													10: "n",
													12: "f",
													13: "r"
												} [t];
											return r ? "\\" + r : "\\x" + (t < 16 ? "0" : "") + b.call(t.toString(16))
										}

										function z(e) {
											return "Object(" + e + ")"
										}

										function H(e) {
											return e + " { ? }"
										}

										function W(e, t, r, n) {
											return e + " (" + t + ") {" + (n ? G(r, n) : E.call(r, ", ")) + "}"
										}

										function G(e, t) {
											if (0 === e.length) return "";
											var r = "\n" + t.prev + t.base;
											return r + E.call(e, "," + r) + "\n" + t.prev
										}

										function Y(e, t) {
											var r = B(e),
												n = [];
											if (r) {
												n.length = e.length;
												for (var i = 0; i < e.length; i++) n[i] = $(e, i) ? t(e[i], e) : ""
											}
											var o, s = "function" == typeof R ? R(e) : [];
											if (M) {
												o = {};
												for (var a = 0; a < s.length; a++) o["$" + s[a]] = s[a]
											}
											for (var c in e) !$(e, c) || r && String(Number(c)) === c && c < e.length || M && o["$" + c] instanceof Symbol || (w.call(/[^\w$]/, c) ? n.push(t(c, e) + ": " + t(e[c], e)) : n.push(c + ": " + t(e[c], e)));
											if ("function" == typeof R)
												for (var l = 0; l < s.length; l++) O.call(e, s[l]) && n.push("[" + t(s[l]) + "]: " + t(e[s[l]], e));
											return n
										}
									}),
									Ze = d((e, t) => {
										var r = Ge(),
											n = Qe(),
											i = Xe(),
											o = r("%TypeError%"),
											s = r("%WeakMap%", !0),
											a = r("%Map%", !0),
											c = n("WeakMap.prototype.get", !0),
											l = n("WeakMap.prototype.set", !0),
											u = n("WeakMap.prototype.has", !0),
											d = n("Map.prototype.get", !0),
											h = n("Map.prototype.set", !0),
											f = n("Map.prototype.has", !0),
											p = function(e, t) {
												for (var r, n = e; null !== (r = n.next); n = r)
													if (r.key === t) return n.next = r.next, r.next = e.next, e.next = r, r
											};
										t.exports = function() {
											var e, t, r, n = {
												assert: function(e) {
													if (!n.has(e)) throw new o("Side channel does not contain " + i(e))
												},
												get: function(n) {
													if (s && n && ("object" == typeof n || "function" == typeof n)) {
														if (e) return c(e, n)
													} else if (a) {
														if (t) return d(t, n)
													} else if (r) return function(e, t) {
														var r = p(e, t);
														return r && r.value
													}(r, n)
												},
												has: function(n) {
													if (s && n && ("object" == typeof n || "function" == typeof n)) {
														if (e) return u(e, n)
													} else if (a) {
														if (t) return f(t, n)
													} else if (r) return function(e, t) {
														return !!p(e, t)
													}(r, n);
													return !1
												},
												set: function(n, i) {
													s && n && ("object" == typeof n || "function" == typeof n) ? (e || (e = new s), l(e, n, i)) : a ? (t || (t = new a), h(t, n, i)) : (r || (r = {
														key: {},
														next: null
													}), function(e, t, r) {
														var n = p(e, t);
														n ? n.value = r : e.next = {
															key: t,
															next: e.next,
															value: r
														}
													}(r, n, i))
												}
											};
											return n
										}
									}),
									et = d((e, t) => {
										var r = String.prototype.replace,
											n = /%20/g,
											i = "RFC1738",
											o = "RFC3986";
										t.exports = {
											default: o,
											formatters: {
												RFC1738: function(e) {
													return r.call(e, n, "+")
												},
												RFC3986: function(e) {
													return String(e)
												}
											},
											RFC1738: i,
											RFC3986: o
										}
									}),
									tt = d((e, t) => {
										var r = et(),
											n = Object.prototype.hasOwnProperty,
											i = Array.isArray,
											o = function() {
												for (var e = [], t = 0; t < 256; ++t) e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
												return e
											}(),
											s = function(e, t) {
												for (var r = t && t.plainObjects ? Object.create(null) : {}, n = 0; n < e.length; ++n) typeof e[n] < "u" && (r[n] = e[n]);
												return r
											};
										t.exports = {
											arrayToObject: s,
											assign: function(e, t) {
												return Object.keys(t).reduce((function(e, r) {
													return e[r] = t[r], e
												}), e)
											},
											combine: function(e, t) {
												return [].concat(e, t)
											},
											compact: function(e) {
												for (var t = [{
														obj: {
															o: e
														},
														prop: "o"
													}], r = [], n = 0; n < t.length; ++n)
													for (var o = t[n], s = o.obj[o.prop], a = Object.keys(s), c = 0; c < a.length; ++c) {
														var l = a[c],
															u = s[l];
														"object" == typeof u && null !== u && -1 === r.indexOf(u) && (t.push({
															obj: s,
															prop: l
														}), r.push(u))
													}
												return function(e) {
													for (; e.length > 1;) {
														var t = e.pop(),
															r = t.obj[t.prop];
														if (i(r)) {
															for (var n = [], o = 0; o < r.length; ++o) typeof r[o] < "u" && n.push(r[o]);
															t.obj[t.prop] = n
														}
													}
												}(t), e
											},
											decode: function(e, t, r) {
												var n = e.replace(/\+/g, " ");
												if ("iso-8859-1" === r) return n.replace(/%[0-9a-f]{2}/gi, unescape);
												try {
													return decodeURIComponent(n)
												} catch {
													return n
												}
											},
											encode: function(e, t, n, i, s) {
												if (0 === e.length) return e;
												var a = e;
												if ("symbol" == typeof e ? a = Symbol.prototype.toString.call(e) : "string" != typeof e && (a = String(e)), "iso-8859-1" === n) return escape(a).replace(/%u[0-9a-f]{4}/gi, (function(e) {
													return "%26%23" + parseInt(e.slice(2), 16) + "%3B"
												}));
												for (var c = "", l = 0; l < a.length; ++l) {
													var u = a.charCodeAt(l);
													45 === u || 46 === u || 95 === u || 126 === u || u >= 48 && u <= 57 || u >= 65 && u <= 90 || u >= 97 && u <= 122 || s === r.RFC1738 && (40 === u || 41 === u) ? c += a.charAt(l) : u < 128 ? c += o[u] : u < 2048 ? c += o[192 | u >> 6] + o[128 | 63 & u] : u < 55296 || u >= 57344 ? c += o[224 | u >> 12] + o[128 | u >> 6 & 63] + o[128 | 63 & u] : (l += 1, u = 65536 + ((1023 & u) << 10 | 1023 & a.charCodeAt(l)), c += o[240 | u >> 18] + o[128 | u >> 12 & 63] + o[128 | u >> 6 & 63] + o[128 | 63 & u])
												}
												return c
											},
											isBuffer: function(e) {
												return !(!e || "object" != typeof e) && !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e))
											},
											isRegExp: function(e) {
												return "[object RegExp]" === Object.prototype.toString.call(e)
											},
											maybeMap: function(e, t) {
												if (i(e)) {
													for (var r = [], n = 0; n < e.length; n += 1) r.push(t(e[n]));
													return r
												}
												return t(e)
											},
											merge: function e(t, r, o) {
												if (!r) return t;
												if ("object" != typeof r) {
													if (i(t)) t.push(r);
													else {
														if (!t || "object" != typeof t) return [t, r];
														(o && (o.plainObjects || o.allowPrototypes) || !n.call(Object.prototype, r)) && (t[r] = !0)
													}
													return t
												}
												if (!t || "object" != typeof t) return [t].concat(r);
												var a = t;
												return i(t) && !i(r) && (a = s(t, o)), i(t) && i(r) ? (r.forEach((function(r, i) {
													if (n.call(t, i)) {
														var s = t[i];
														s && "object" == typeof s && r && "object" == typeof r ? t[i] = e(s, r, o) : t.push(r)
													} else t[i] = r
												})), t) : Object.keys(r).reduce((function(t, i) {
													var s = r[i];
													return n.call(t, i) ? t[i] = e(t[i], s, o) : t[i] = s, t
												}), a)
											}
										}
									}),
									rt = d((e, t) => {
										var r = Ze(),
											n = tt(),
											i = et(),
											o = Object.prototype.hasOwnProperty,
											s = {
												brackets: function(e) {
													return e + "[]"
												},
												comma: "comma",
												indices: function(e, t) {
													return e + "[" + t + "]"
												},
												repeat: function(e) {
													return e
												}
											},
											a = Array.isArray,
											c = String.prototype.split,
											l = Array.prototype.push,
											u = function(e, t) {
												l.apply(e, a(t) ? t : [t])
											},
											d = Date.prototype.toISOString,
											h = i.default,
											f = {
												addQueryPrefix: !1,
												allowDots: !1,
												charset: "utf-8",
												charsetSentinel: !1,
												delimiter: "&",
												encode: !0,
												encoder: n.encode,
												encodeValuesOnly: !1,
												format: h,
												formatter: i.formatters[h],
												indices: !1,
												serializeDate: function(e) {
													return d.call(e)
												},
												skipNulls: !1,
												strictNullHandling: !1
											},
											p = {},
											v = function e(t, i, o, s, l, d, h, v, g, m, y, b, _, w, S, E) {
												for (var k = t, T = E, I = 0, R = !1; void 0 !== (T = T.get(p)) && !R;) {
													var C = T.get(t);
													if (I += 1, typeof C < "u") {
														if (C === I) throw new RangeError("Cyclic object value");
														R = !0
													}
													typeof T.get(p) > "u" && (I = 0)
												}
												if ("function" == typeof v ? k = v(i, k) : k instanceof Date ? k = y(k) : "comma" === o && a(k) && (k = n.maybeMap(k, (function(e) {
														return e instanceof Date ? y(e) : e
													}))), null === k) {
													if (l) return h && !w ? h(i, f.encoder, S, "key", b) : i;
													k = ""
												}
												if (function(e) {
														return "string" == typeof e || "number" == typeof e || "boolean" == typeof e || "symbol" == typeof e || "bigint" == typeof e
													}(k) || n.isBuffer(k)) {
													if (h) {
														var M = w ? i : h(i, f.encoder, S, "key", b);
														if ("comma" === o && w) {
															for (var x = c.call(String(k), ","), O = "", A = 0; A < x.length; ++A) O += (0 === A ? "" : ",") + _(h(x[A], f.encoder, S, "value", b));
															return [_(M) + (s && a(k) && 1 === x.length ? "[]" : "") + "=" + O]
														}
														return [_(M) + "=" + _(h(k, f.encoder, S, "value", b))]
													}
													return [_(i) + "=" + _(String(k))]
												}
												var P, D = [];
												if (typeof k > "u") return D;
												if ("comma" === o && a(k)) P = [{
													value: k.length > 0 ? k.join(",") || null : void 0
												}];
												else if (a(v)) P = v;
												else {
													var j = Object.keys(k);
													P = g ? j.sort(g) : j
												}
												for (var L = s && a(k) && 1 === k.length ? i + "[]" : i, N = 0; N < P.length; ++N) {
													var B = P[N],
														U = "object" == typeof B && typeof B.value < "u" ? B.value : k[B];
													if (!d || null !== U) {
														var F = a(k) ? "function" == typeof o ? o(L, B) : L : L + (m ? "." + B : "[" + B + "]");
														E.set(t, I);
														var $ = r();
														$.set(p, E), u(D, e(U, F, o, s, l, d, h, v, g, m, y, b, _, w, S, $))
													}
												}
												return D
											};
										t.exports = function(e, t) {
											var n, c = e,
												l = function(e) {
													if (!e) return f;
													if (null !== e.encoder && typeof e.encoder < "u" && "function" != typeof e.encoder) throw new TypeError("Encoder has to be a function.");
													var t = e.charset || f.charset;
													if (typeof e.charset < "u" && "utf-8" !== e.charset && "iso-8859-1" !== e.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
													var r = i.default;
													if (typeof e.format < "u") {
														if (!o.call(i.formatters, e.format)) throw new TypeError("Unknown format option provided.");
														r = e.format
													}
													var n = i.formatters[r],
														s = f.filter;
													return ("function" == typeof e.filter || a(e.filter)) && (s = e.filter), {
														addQueryPrefix: "boolean" == typeof e.addQueryPrefix ? e.addQueryPrefix : f.addQueryPrefix,
														allowDots: typeof e.allowDots > "u" ? f.allowDots : !!e.allowDots,
														charset: t,
														charsetSentinel: "boolean" == typeof e.charsetSentinel ? e.charsetSentinel : f.charsetSentinel,
														delimiter: typeof e.delimiter > "u" ? f.delimiter : e.delimiter,
														encode: "boolean" == typeof e.encode ? e.encode : f.encode,
														encoder: "function" == typeof e.encoder ? e.encoder : f.encoder,
														encodeValuesOnly: "boolean" == typeof e.encodeValuesOnly ? e.encodeValuesOnly : f.encodeValuesOnly,
														filter: s,
														format: r,
														formatter: n,
														serializeDate: "function" == typeof e.serializeDate ? e.serializeDate : f.serializeDate,
														skipNulls: "boolean" == typeof e.skipNulls ? e.skipNulls : f.skipNulls,
														sort: "function" == typeof e.sort ? e.sort : null,
														strictNullHandling: "boolean" == typeof e.strictNullHandling ? e.strictNullHandling : f.strictNullHandling
													}
												}(t);
											"function" == typeof l.filter ? c = (0, l.filter)("", c) : a(l.filter) && (n = l.filter);
											var d, h = [];
											if ("object" != typeof c || null === c) return "";
											d = t && t.arrayFormat in s ? t.arrayFormat : t && "indices" in t ? t.indices ? "indices" : "repeat" : "indices";
											var p = s[d];
											if (t && "commaRoundTrip" in t && "boolean" != typeof t.commaRoundTrip) throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
											var g = "comma" === p && t && t.commaRoundTrip;
											n || (n = Object.keys(c)), l.sort && n.sort(l.sort);
											for (var m = r(), y = 0; y < n.length; ++y) {
												var b = n[y];
												l.skipNulls && null === c[b] || u(h, v(c[b], b, p, g, l.strictNullHandling, l.skipNulls, l.encode ? l.encoder : null, l.filter, l.sort, l.allowDots, l.serializeDate, l.format, l.formatter, l.encodeValuesOnly, l.charset, m))
											}
											var _ = h.join(l.delimiter),
												w = !0 === l.addQueryPrefix ? "?" : "";
											return l.charsetSentinel && ("iso-8859-1" === l.charset ? w += "utf8=%26%2310003%3B&" : w += "utf8=%E2%9C%93&"), _.length > 0 ? w + _ : ""
										}
									}),
									nt = d((e, t) => {
										var r = tt(),
											n = Object.prototype.hasOwnProperty,
											i = Array.isArray,
											o = {
												allowDots: !1,
												allowPrototypes: !1,
												allowSparse: !1,
												arrayLimit: 20,
												charset: "utf-8",
												charsetSentinel: !1,
												comma: !1,
												decoder: r.decode,
												delimiter: "&",
												depth: 5,
												ignoreQueryPrefix: !1,
												interpretNumericEntities: !1,
												parameterLimit: 1e3,
												parseArrays: !0,
												plainObjects: !1,
												strictNullHandling: !1
											},
											s = function(e, t) {
												return e && "string" == typeof e && t.comma && e.indexOf(",") > -1 ? e.split(",") : e
											},
											a = function(e, t, r, i) {
												if (e) {
													var o = r.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e,
														a = /(\[[^[\]]*])/g,
														c = r.depth > 0 && /(\[[^[\]]*])/.exec(o),
														l = c ? o.slice(0, c.index) : o,
														u = [];
													if (l) {
														if (!r.plainObjects && n.call(Object.prototype, l) && !r.allowPrototypes) return;
														u.push(l)
													}
													for (var d = 0; r.depth > 0 && null !== (c = a.exec(o)) && d < r.depth;) {
														if (d += 1, !r.plainObjects && n.call(Object.prototype, c[1].slice(1, -1)) && !r.allowPrototypes) return;
														u.push(c[1])
													}
													return c && u.push("[" + o.slice(c.index) + "]"),
														function(e, t, r, n) {
															for (var i = n ? t : s(t, r), o = e.length - 1; o >= 0; --o) {
																var a, c = e[o];
																if ("[]" === c && r.parseArrays) a = [].concat(i);
																else {
																	a = r.plainObjects ? Object.create(null) : {};
																	var l = "[" === c.charAt(0) && "]" === c.charAt(c.length - 1) ? c.slice(1, -1) : c,
																		u = parseInt(l, 10);
																	r.parseArrays || "" !== l ? !isNaN(u) && c !== l && String(u) === l && u >= 0 && r.parseArrays && u <= r.arrayLimit ? (a = [])[u] = i : "__proto__" !== l && (a[l] = i) : a = {
																		0: i
																	}
																}
																i = a
															}
															return i
														}(u, t, r, i)
												}
											};
										t.exports = function(e, t) {
											var c = function(e) {
												if (!e) return o;
												if (null !== e.decoder && void 0 !== e.decoder && "function" != typeof e.decoder) throw new TypeError("Decoder has to be a function.");
												if (typeof e.charset < "u" && "utf-8" !== e.charset && "iso-8859-1" !== e.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
												var t = typeof e.charset > "u" ? o.charset : e.charset;
												return {
													allowDots: typeof e.allowDots > "u" ? o.allowDots : !!e.allowDots,
													allowPrototypes: "boolean" == typeof e.allowPrototypes ? e.allowPrototypes : o.allowPrototypes,
													allowSparse: "boolean" == typeof e.allowSparse ? e.allowSparse : o.allowSparse,
													arrayLimit: "number" == typeof e.arrayLimit ? e.arrayLimit : o.arrayLimit,
													charset: t,
													charsetSentinel: "boolean" == typeof e.charsetSentinel ? e.charsetSentinel : o.charsetSentinel,
													comma: "boolean" == typeof e.comma ? e.comma : o.comma,
													decoder: "function" == typeof e.decoder ? e.decoder : o.decoder,
													delimiter: "string" == typeof e.delimiter || r.isRegExp(e.delimiter) ? e.delimiter : o.delimiter,
													depth: "number" == typeof e.depth || !1 === e.depth ? +e.depth : o.depth,
													ignoreQueryPrefix: !0 === e.ignoreQueryPrefix,
													interpretNumericEntities: "boolean" == typeof e.interpretNumericEntities ? e.interpretNumericEntities : o.interpretNumericEntities,
													parameterLimit: "number" == typeof e.parameterLimit ? e.parameterLimit : o.parameterLimit,
													parseArrays: !1 !== e.parseArrays,
													plainObjects: "boolean" == typeof e.plainObjects ? e.plainObjects : o.plainObjects,
													strictNullHandling: "boolean" == typeof e.strictNullHandling ? e.strictNullHandling : o.strictNullHandling
												}
											}(t);
											if ("" === e || null === e || typeof e > "u") return c.plainObjects ? Object.create(null) : {};
											for (var l = "string" == typeof e ? function(e, t) {
													var a, c = {},
														l = t.ignoreQueryPrefix ? e.replace(/^\?/, "") : e,
														u = t.parameterLimit === 1 / 0 ? void 0 : t.parameterLimit,
														d = l.split(t.delimiter, u),
														h = -1,
														f = t.charset;
													if (t.charsetSentinel)
														for (a = 0; a < d.length; ++a) 0 === d[a].indexOf("utf8=") && ("utf8=%E2%9C%93" === d[a] ? f = "utf-8" : "utf8=%26%2310003%3B" === d[a] && (f = "iso-8859-1"), h = a, a = d.length);
													for (a = 0; a < d.length; ++a)
														if (a !== h) {
															var p, v, g = d[a],
																m = g.indexOf("]="),
																y = -1 === m ? g.indexOf("=") : m + 1; - 1 === y ? (p = t.decoder(g, o.decoder, f, "key"), v = t.strictNullHandling ? null : "") : (p = t.decoder(g.slice(0, y), o.decoder, f, "key"), v = r.maybeMap(s(g.slice(y + 1), t), (function(e) {
																return t.decoder(e, o.decoder, f, "value")
															}))), v && t.interpretNumericEntities && "iso-8859-1" === f && (v = v.replace(/&#(\d+);/g, (function(e, t) {
																return String.fromCharCode(parseInt(t, 10))
															}))), g.indexOf("[]=") > -1 && (v = i(v) ? [v] : v), n.call(c, p) ? c[p] = r.combine(c[p], v) : c[p] = v
														} return c
												}(e, c) : e, u = c.plainObjects ? Object.create(null) : {}, d = Object.keys(l), h = 0; h < d.length; ++h) {
												var f = d[h],
													p = a(f, l[f], c, "string" == typeof e);
												u = r.merge(u, p, c)
											}
											return !0 === c.allowSparse ? u : r.compact(u)
										}
									}),
									it = d((e, t) => {
										var r = rt(),
											n = nt(),
											i = et();
										t.exports = {
											formats: i,
											parse: n,
											stringify: r
										}
									}),
									ot = d(e => {
										var t = e && e.__assign || function() {
											return (t = Object.assign || function(e) {
												for (var t, r = 1, n = arguments.length; r < n; r++)
													for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
												return e
											}).apply(this, arguments)
										};
										Object.defineProperty(e, "__esModule", {
											value: !0
										}), e.normalizeGifs = e.normalizeGif = e.USER_BOOL_PROPS = e.BOOL_PROPS = void 0, e.BOOL_PROPS = ["is_anonymous", "is_community", "is_featured", "is_hidden", "is_indexable", "is_preserve_size", "is_realtime", "is_removed", "is_sticker", "is_dynamic"], e.USER_BOOL_PROPS = ["suppress_chrome", "is_public", "is_verified"];
										var r = function(e) {
												return function(t) {
													return e[t] = !!e[t]
												}
											},
											n = function(e) {
												return "string" == typeof e ? e : e.text
											},
											i = function(i) {
												var o = t({}, i);
												o.id = String(o.id), o.tags = (o.tags || []).map(n), e.BOOL_PROPS.forEach(r(o)), Object.keys(o.images || {}).forEach((function(e) {
													var t = o.images[e];
													t.width = parseInt(t.width), t.height = parseInt(t.height)
												}));
												var s = o.user;
												if (s) {
													var a = t({}, s);
													e.USER_BOOL_PROPS.forEach(r(a)), o.user = a
												}
												return o
											};
										e.normalizeGif = function(e) {
											return e.data = i(e.data), e
										};
										e.normalizeGifs = function(e) {
											return e.data = e.data.map((function(e) {
												return i(e)
											})), e
										}
									}),
									st = d(t => {
										Object.defineProperty(t, "__esModule", {
											value: !0
										}), t.setServerUrl = t.serverUrl = void 0;
										var r = (typeof window < "u" ? window : e) || {};
										t.serverUrl = r.GIPHY_API_URL || "https://api.giphy.com/v1/";
										t.setServerUrl = function(e) {
											t.serverUrl = e
										}
									}),
									at = d(e => {
										var t = e && e.__extends || function() {
											var e = function(t, r) {
												return (e = Object.setPrototypeOf || {
														__proto__: []
													}
													instanceof Array && function(e, t) {
														e.__proto__ = t
													} || function(e, t) {
														for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r])
													})(t, r)
											};
											return function(t, r) {
												if ("function" != typeof r && null !== r) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");

												function n() {
													this.constructor = t
												}
												e(t, r), t.prototype = null === r ? Object.create(r) : (n.prototype = r.prototype, new n)
											}
										}();
										Object.defineProperty(e, "__esModule", {
											value: !0
										});
										var r = function(e) {
											function r(t, r, n) {
												void 0 === r && (r = 0), void 0 === n && (n = "");
												var i = e.call(this, t) || this;
												return i.status = r, i.statusText = n, i
											}
											return t(r, e), r
										}(Error);
										e.default = r
									}),
									ct = d(e => {
										var t = e && e.__awaiter || function(e, t, r, n) {
												return new(r || (r = Promise))((function(i, o) {
													function s(e) {
														try {
															c(n.next(e))
														} catch (t) {
															o(t)
														}
													}

													function a(e) {
														try {
															c(n.throw(e))
														} catch (t) {
															o(t)
														}
													}

													function c(e) {
														e.done ? i(e.value) : function(e) {
															return e instanceof r ? e : new r((function(t) {
																t(e)
															}))
														}(e.value).then(s, a)
													}
													c((n = n.apply(e, t || [])).next())
												}))
											},
											r = e && e.__generator || function(e, t) {
												var r, n, i, o, s = {
													label: 0,
													sent: function() {
														if (1 & i[0]) throw i[1];
														return i[1]
													},
													trys: [],
													ops: []
												};
												return o = {
													next: a(0),
													throw: a(1),
													return: a(2)
												}, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
													return this
												}), o;

												function a(o) {
													return function(a) {
														return function(o) {
															if (r) throw new TypeError("Generator is already executing.");
															for (; s;) try {
																if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
																switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
																	case 0:
																	case 1:
																		i = o;
																		break;
																	case 4:
																		return s.label++, {
																			value: o[1],
																			done: !1
																		};
																	case 5:
																		s.label++, n = o[1], o = [0];
																		continue;
																	case 7:
																		o = s.ops.pop(), s.trys.pop();
																		continue;
																	default:
																		if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
																			s = 0;
																			continue
																		}
																		if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
																			s.label = o[1];
																			break
																		}
																		if (6 === o[0] && s.label < i[1]) {
																			s.label = i[1], i = o;
																			break
																		}
																		if (i && s.label < i[2]) {
																			s.label = i[2], s.ops.push(o);
																			break
																		}
																		i[2] && s.ops.pop(), s.trys.pop();
																		continue
																}
																o = t.call(e, s)
															} catch (a) {
																o = [6, a], n = 0
															} finally {
																r = i = 0
															}
															if (5 & o[0]) throw o[1];
															return {
																value: o[0] ? o[1] : void 0,
																done: !0
															}
														}([o, a])
													}
												}
											},
											n = e && e.__importDefault || function(e) {
												return e && e.__esModule ? e : {
													default: e
												}
											};
										Object.defineProperty(e, "__esModule", {
											value: !0
										}), e.DEFAULT_ERROR = e.ERROR_PREFIX = void 0;
										var i = st(),
											o = n(at());
										e.ERROR_PREFIX = "@giphy/js-fetch-api: ", e.DEFAULT_ERROR = "Error fetching";
										var s = function(e) {
												return e
											},
											a = {},
											c = function() {
												var e = Date.now();
												Object.keys(a).forEach((function(t) {
													var r = a[t].isError ? 6e3 : 6e4;
													e - a[t].ts >= r && delete a[t]
												}))
											};
										e.default = function(n, l, u) {
											var d = this;
											if (void 0 === l && (l = s), void 0 === u && (u = !1), c(), !a[n] || u) {
												a[n] = {
													request: t(d, void 0, void 0, (function() {
														var t, s, c, u, d, h;
														return r(this, (function(r) {
															switch (r.label) {
																case 0:
																	return r.trys.push([0, 9, , 10]), [4, fetch("".concat(i.serverUrl).concat(n), {
																		method: "get"
																	})];
																case 1:
																	return (s = r.sent()).ok ? [4, s.json()] : [3, 3];
																case 2:
																	if (u = r.sent(), null !== (h = u.meta) && void 0 !== h && h.response_id) return [2, l(u)];
																	throw {
																		message: "synthetic response"
																	};
																case 3:
																	c = e.DEFAULT_ERROR, r.label = 4;
																case 4:
																	return r.trys.push([4, 6, , 7]), [4, s.json()];
																case 5:
																	return (u = r.sent()).message && (c = u.message), [3, 7];
																case 6:
																	return r.sent(), [3, 7];
																case 7:
																	a[n] && (a[n].isError = !0), t = new o.default("".concat(e.ERROR_PREFIX).concat(c), s.status, s.statusText), r.label = 8;
																case 8:
																	return [3, 10];
																case 9:
																	return d = r.sent(), t = new o.default(d.message), a[n] && (a[n].isError = !0), [3, 10];
																case 10:
																	throw t
															}
														}))
													})),
													ts: Date.now()
												}
											}
											return a[n].request
										}
									}),
									lt = d(e => {
										var t = e && e.__assign || function() {
												return (t = Object.assign || function(e) {
													for (var t, r = 1, n = arguments.length; r < n; r++)
														for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
													return e
												}).apply(this, arguments)
											},
											r = e && e.__importDefault || function(e) {
												return e && e.__esModule ? e : {
													default: e
												}
											};
										Object.defineProperty(e, "__esModule", {
											value: !0
										}), e.GiphyFetch = void 0;
										var n = qe(),
											i = r(it()),
											o = ot(),
											s = r(ct()),
											a = function(e) {
												return e && e.type ? e.type : "gifs"
											},
											c = function() {
												function e(e) {
													var r = this;
													this.getQS = function(e) {
														return void 0 === e && (e = {}), i.default.stringify(t(t({}, e), {
															api_key: r.apiKey,
															pingback_id: (0, n.getPingbackId)()
														}))
													}, this.apiKey = e
												}
												return e.prototype.categories = function(e) {
													return (0, s.default)("gifs/categories?".concat(this.getQS(e)))
												}, e.prototype.gif = function(e) {
													return (0, s.default)("gifs/".concat(e, "?").concat(this.getQS()), o.normalizeGif)
												}, e.prototype.gifs = function(e, t) {
													return Array.isArray(e) ? (0, s.default)("gifs?".concat(this.getQS({
														ids: e.join(",")
													})), o.normalizeGifs) : (0, s.default)("gifs/categories/".concat(e, "/").concat(t, "?").concat(this.getQS()), o.normalizeGifs)
												}, e.prototype.emoji = function(e) {
													return (0, s.default)("emoji?".concat(this.getQS(e)), o.normalizeGifs)
												}, e.prototype.animate = function(e, r) {
													void 0 === r && (r = {});
													var n = this.getQS(t(t({}, r), {
														m: e
													}));
													return (0, s.default)("text/animate?".concat(n), o.normalizeGifs)
												}, e.prototype.search = function(e, r) {
													void 0 === r && (r = {});
													var n, i = r.channel ? "@".concat(r.channel, " ").concat(e) : e;
													"text" === r.type && (n = !0);
													var c = this.getQS(t(t({}, r), {
														q: i,
														excludeDynamicResults: n
													}));
													return (0, s.default)("".concat(a(r), "/search?").concat(c), o.normalizeGifs)
												}, e.prototype.subcategories = function(e, t) {
													return (0, s.default)("gifs/categories/".concat(e, "?").concat(this.getQS(t)))
												}, e.prototype.trending = function(e) {
													return void 0 === e && (e = {}), (0, s.default)("".concat(a(e), "/trending?").concat(this.getQS(e)), o.normalizeGifs)
												}, e.prototype.random = function(e) {
													return (0, s.default)("".concat(a(e), "/random?").concat(this.getQS(e)), o.normalizeGif, !0)
												}, e.prototype.related = function(e, r) {
													return (0, s.default)("".concat("stickers" === (null == r ? void 0 : r.type) ? "stickers" : "gifs", "/related?").concat(this.getQS(t({
														gif_id: e
													}, r))), o.normalizeGifs)
												}, e.prototype.channels = function(e, r) {
													return void 0 === r && (r = {}), (0, s.default)("channels/search?".concat(this.getQS(t({
														q: e
													}, r))))
												}, e
											}();
										e.GiphyFetch = c, e.default = c
									}),
									ut = d(e => {
										Object.defineProperty(e, "__esModule", {
											value: !0
										})
									}),
									dt = d(e => {
										var t = e && e.__awaiter || function(e, t, r, n) {
												return new(r || (r = Promise))((function(i, o) {
													function s(e) {
														try {
															c(n.next(e))
														} catch (t) {
															o(t)
														}
													}

													function a(e) {
														try {
															c(n.throw(e))
														} catch (t) {
															o(t)
														}
													}

													function c(e) {
														e.done ? i(e.value) : function(e) {
															return e instanceof r ? e : new r((function(t) {
																t(e)
															}))
														}(e.value).then(s, a)
													}
													c((n = n.apply(e, t || [])).next())
												}))
											},
											r = e && e.__generator || function(e, t) {
												var r, n, i, o, s = {
													label: 0,
													sent: function() {
														if (1 & i[0]) throw i[1];
														return i[1]
													},
													trys: [],
													ops: []
												};
												return o = {
													next: a(0),
													throw: a(1),
													return: a(2)
												}, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
													return this
												}), o;

												function a(o) {
													return function(a) {
														return function(o) {
															if (r) throw new TypeError("Generator is already executing.");
															for (; s;) try {
																if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
																switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
																	case 0:
																	case 1:
																		i = o;
																		break;
																	case 4:
																		return s.label++, {
																			value: o[1],
																			done: !1
																		};
																	case 5:
																		s.label++, n = o[1], o = [0];
																		continue;
																	case 7:
																		o = s.ops.pop(), s.trys.pop();
																		continue;
																	default:
																		if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
																			s = 0;
																			continue
																		}
																		if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
																			s.label = o[1];
																			break
																		}
																		if (6 === o[0] && s.label < i[1]) {
																			s.label = i[1], i = o;
																			break
																		}
																		if (i && s.label < i[2]) {
																			s.label = i[2], s.ops.push(o);
																			break
																		}
																		i[2] && s.ops.pop(), s.trys.pop();
																		continue
																}
																o = t.call(e, s)
															} catch (a) {
																o = [6, a], n = 0
															} finally {
																r = i = 0
															}
															if (5 & o[0]) throw o[1];
															return {
																value: o[0] ? o[1] : void 0,
																done: !0
															}
														}([o, a])
													}
												}
											},
											n = e && e.__spreadArray || function(e, t, r) {
												if (r || 2 === arguments.length)
													for (var n, i = 0, o = t.length; i < o; i++)(n || !(i in t)) && (n || (n = Array.prototype.slice.call(t, 0, i)), n[i] = t[i]);
												return e.concat(n || Array.prototype.slice.call(t))
											};
										Object.defineProperty(e, "__esModule", {
											value: !0
										}), e.gifPaginator = void 0;
										e.gifPaginator = function(e, i) {
											void 0 === i && (i = []);
											var o = n([], i, !0),
												s = i.map((function(e) {
													return e.id
												})),
												a = i.length,
												c = !1;
											return function() {
												return t(void 0, void 0, void 0, (function() {
													var t, i, l;
													return r(this, (function(r) {
														switch (r.label) {
															case 0:
																return c ? [2, o] : [4, e(a)];
															case 1:
																return t = r.sent(), i = t.pagination, l = t.data, a = i.count + i.offset, c = a === i.total_count, l.forEach((function(e) {
																	var t = e.id;
																	s.includes(t) || (o.push(e), s.push(t))
																})), [2, n([], o, !0)]
														}
													}))
												}))
											}
										}
									}),
									ht = d(e => {
										Object.defineProperty(e, "__esModule", {
											value: !0
										})
									}),
									ft = d((e, t) => {
										t.exports = {
											scripts: {
												clean: "rm -rf ./dist",
												dev: "parcel public/test.html",
												docs: "typedoc src/index.ts",
												prepublish: "npm run clean && tsc",
												build: "tsc",
												test: "jest --config ./jestconfig.js",
												"test:watch": "jest --config ./jestconfig.js --watchAll"
											},
											name: "@giphy/js-fetch-api",
											version: "4.4.0",
											main: "dist/index.js",
											description: "Javascript API to fetch gifs and stickers from the GIPHY API.",
											homepage: "https://github.com/Giphy/giphy-js/tree/master/packages/fetch-api",
											types: "dist/index.d.ts",
											files: ["dist/**/*", "src/**/*"],
											license: "MIT",
											publishConfig: {
												access: "public"
											},
											dependencies: {
												"@giphy/js-types": "^4.2.1",
												"@giphy/js-util": "^4.1.1",
												qs: "^6.9.4"
											},
											devDependencies: {
												"@types/qs": "^6.9.4",
												"jest-fetch-mock": "^3.0.3",
												"parcel-bundler": "latest",
												typedoc: "^0.20.36",
												"typedoc-thunder-theme": "^0.0.2",
												typescript: "^4.7.3"
											},
											gitHead: "16c8f572f0e8f871cf27b2133243d37c128d5edd"
										}
									}),
									pt = d(e => {
										var t, r = e && e.__createBinding || (Object.create ? function(e, t, r, n) {
												void 0 === n && (n = r);
												var i = Object.getOwnPropertyDescriptor(t, r);
												(!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
													enumerable: !0,
													get: function() {
														return t[r]
													}
												}), Object.defineProperty(e, n, i)
											} : function(e, t, r, n) {
												void 0 === n && (n = r), e[n] = t[r]
											}),
											n = e && e.__exportStar || function(e, t) {
												for (var n in e) "default" !== n && !Object.prototype.hasOwnProperty.call(t, n) && r(t, e, n)
											},
											i = e && e.__importDefault || function(e) {
												return e && e.__esModule ? e : {
													default: e
												}
											};
										Object.defineProperty(e, "__esModule", {
											value: !0
										}), e.request = e.gifPaginator = e.setServerUrl = e.serverUrl = e.GiphyFetch = void 0;
										var o = qe(),
											s = lt();
										Object.defineProperty(e, "GiphyFetch", {
											enumerable: !0,
											get: function() {
												return i(s).default
											}
										});
										var a = st();
										Object.defineProperty(e, "serverUrl", {
											enumerable: !0,
											get: function() {
												return a.serverUrl
											}
										}), Object.defineProperty(e, "setServerUrl", {
											enumerable: !0,
											get: function() {
												return a.setServerUrl
											}
										}), n(ut(), e);
										var c = dt();
										Object.defineProperty(e, "gifPaginator", {
											enumerable: !0,
											get: function() {
												return c.gifPaginator
											}
										});
										var l = ct();
										Object.defineProperty(e, "request", {
											enumerable: !0,
											get: function() {
												return i(l).default
											}
										}), n(ht(), e);
										var u = ft().version;
										null !== (t = (0, o.getGiphySDKRequestHeaders)()) && void 0 !== t && t.get("X-GIPHY-SDK-NAME") || ((0, o.appendGiphySDKRequestHeader)("X-GIPHY-SDK-NAME", "FetchAPI"), (0, o.appendGiphySDKRequestHeader)("X-GIPHY-SDK-VERSION", u))
									}),
									vt = window,
									gt = vt.ShadowRoot && (void 0 === vt.ShadyCSS || vt.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,
									mt = Symbol(),
									yt = new WeakMap,
									bt = class {
										constructor(e, t, r) {
											if (this._$cssResult$ = !0, r !== mt) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
											this.cssText = e, this.t = t
										}
										get styleSheet() {
											let e = this.o,
												t = this.t;
											if (gt && void 0 === e) {
												let r = void 0 !== t && 1 === t.length;
												r && (e = yt.get(t)), void 0 === e && ((this.o = e = new CSSStyleSheet).replaceSync(this.cssText), r && yt.set(t, e))
											}
											return e
										}
										toString() {
											return this.cssText
										}
									},
									_t = (e, ...t) => {
										let r = 1 === e.length ? e[0] : t.reduce((t, r, n) => t + (e => {
											if (!0 === e._$cssResult$) return e.cssText;
											if ("number" == typeof e) return e;
											throw Error("Value passed to 'css' function must be a 'css' function result: " + e + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")
										})(r) + e[n + 1], e[0]);
										return new bt(r, e, mt)
									},
									wt = gt ? e => e : e => e instanceof CSSStyleSheet ? (e => {
										let t = "";
										for (let r of e.cssRules) t += r.cssText;
										return (e => new bt("string" == typeof e ? e : e + "", void 0, mt))(t)
									})(e) : e,
									St = window,
									Et = St.trustedTypes,
									kt = Et ? Et.emptyScript : "",
									Tt = St.reactiveElementPolyfillSupport,
									It = {
										toAttribute(e, t) {
											switch (t) {
												case Boolean:
													e = e ? kt : null;
													break;
												case Object:
												case Array:
													e = null == e ? e : JSON.stringify(e)
											}
											return e
										},
										fromAttribute(e, t) {
											let r = e;
											switch (t) {
												case Boolean:
													r = null !== e;
													break;
												case Number:
													r = null === e ? null : Number(e);
													break;
												case Object:
												case Array:
													try {
														r = JSON.parse(e)
													} catch {
														r = null
													}
											}
											return r
										}
									},
									Rt = (e, t) => t !== e && (t == t || e == e),
									Ct = {
										attribute: !0,
										type: String,
										converter: It,
										reflect: !1,
										hasChanged: Rt
									},
									Mt = class extends HTMLElement {
										constructor() {
											super(), this._$Ei = new Map, this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this.u()
										}
										static addInitializer(e) {
											var t;
											null !== (t = this.h) && void 0 !== t || (this.h = []), this.h.push(e)
										}
										static get observedAttributes() {
											this.finalize();
											let e = [];
											return this.elementProperties.forEach((t, r) => {
												let n = this._$Ep(r, t);
												void 0 !== n && (this._$Ev.set(n, r), e.push(n))
											}), e
										}
										static createProperty(e, t = Ct) {
											if (t.state && (t.attribute = !1), this.finalize(), this.elementProperties.set(e, t), !t.noAccessor && !this.prototype.hasOwnProperty(e)) {
												let r = "symbol" == typeof e ? Symbol() : "__" + e,
													n = this.getPropertyDescriptor(e, r, t);
												void 0 !== n && Object.defineProperty(this.prototype, e, n)
											}
										}
										static getPropertyDescriptor(e, t, r) {
											return {
												get() {
													return this[t]
												},
												set(n) {
													let i = this[e];
													this[t] = n, this.requestUpdate(e, i, r)
												},
												configurable: !0,
												enumerable: !0
											}
										}
										static getPropertyOptions(e) {
											return this.elementProperties.get(e) || Ct
										}
										static finalize() {
											if (this.hasOwnProperty("finalized")) return !1;
											this.finalized = !0;
											let e = Object.getPrototypeOf(this);
											if (e.finalize(), this.elementProperties = new Map(e.elementProperties), this._$Ev = new Map, this.hasOwnProperty("properties")) {
												let e = this.properties,
													t = [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)];
												for (let r of t) this.createProperty(r, e[r])
											}
											return this.elementStyles = this.finalizeStyles(this.styles), !0
										}
										static finalizeStyles(e) {
											let t = [];
											if (Array.isArray(e)) {
												let r = new Set(e.flat(1 / 0).reverse());
												for (let e of r) t.unshift(wt(e))
											} else void 0 !== e && t.push(wt(e));
											return t
										}
										static _$Ep(e, t) {
											let r = t.attribute;
											return !1 === r ? void 0 : "string" == typeof r ? r : "string" == typeof e ? e.toLowerCase() : void 0
										}
										u() {
											var e;
											this._$E_ = new Promise(e => this.enableUpdating = e), this._$AL = new Map, this._$Eg(), this.requestUpdate(), null === (e = this.constructor.h) || void 0 === e || e.forEach(e => e(this))
										}
										addController(e) {
											var t, r;
											(null !== (t = this._$ES) && void 0 !== t ? t : this._$ES = []).push(e), void 0 !== this.renderRoot && this.isConnected && (null === (r = e.hostConnected) || void 0 === r || r.call(e))
										}
										removeController(e) {
											var t;
											null === (t = this._$ES) || void 0 === t || t.splice(this._$ES.indexOf(e) >>> 0, 1)
										}
										_$Eg() {
											this.constructor.elementProperties.forEach((e, t) => {
												this.hasOwnProperty(t) && (this._$Ei.set(t, this[t]), delete this[t])
											})
										}
										createRenderRoot() {
											var e;
											let t = null !== (e = this.shadowRoot) && void 0 !== e ? e : this.attachShadow(this.constructor.shadowRootOptions);
											return ((e, t) => {
												gt ? e.adoptedStyleSheets = t.map(e => e instanceof CSSStyleSheet ? e : e.styleSheet) : t.forEach(t => {
													let r = document.createElement("style"),
														n = vt.litNonce;
													void 0 !== n && r.setAttribute("nonce", n), r.textContent = t.cssText, e.appendChild(r)
												})
											})(t, this.constructor.elementStyles), t
										}
										connectedCallback() {
											var e;
											void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (e = this._$ES) || void 0 === e || e.forEach(e => {
												var t;
												return null === (t = e.hostConnected) || void 0 === t ? void 0 : t.call(e)
											})
										}
										enableUpdating(e) {}
										disconnectedCallback() {
											var e;
											null === (e = this._$ES) || void 0 === e || e.forEach(e => {
												var t;
												return null === (t = e.hostDisconnected) || void 0 === t ? void 0 : t.call(e)
											})
										}
										attributeChangedCallback(e, t, r) {
											this._$AK(e, r)
										}
										_$EO(e, t, r = Ct) {
											var n;
											let i = this.constructor._$Ep(e, r);
											if (void 0 !== i && !0 === r.reflect) {
												let o = (void 0 !== (null === (n = r.converter) || void 0 === n ? void 0 : n.toAttribute) ? r.converter : It).toAttribute(t, r.type);
												this._$El = e, null == o ? this.removeAttribute(i) : this.setAttribute(i, o), this._$El = null
											}
										}
										_$AK(e, t) {
											var r;
											let n = this.constructor,
												i = n._$Ev.get(e);
											if (void 0 !== i && this._$El !== i) {
												let e = n.getPropertyOptions(i),
													o = "function" == typeof e.converter ? {
														fromAttribute: e.converter
													} : void 0 !== (null === (r = e.converter) || void 0 === r ? void 0 : r.fromAttribute) ? e.converter : It;
												this._$El = i, this[i] = o.fromAttribute(t, e.type), this._$El = null
											}
										}
										requestUpdate(e, t, r) {
											let n = !0;
											void 0 !== e && (((r = r || this.constructor.getPropertyOptions(e)).hasChanged || Rt)(this[e], t) ? (this._$AL.has(e) || this._$AL.set(e, t), !0 === r.reflect && this._$El !== e && (void 0 === this._$EC && (this._$EC = new Map), this._$EC.set(e, r))) : n = !1), !this.isUpdatePending && n && (this._$E_ = this._$Ej())
										}
										async _$Ej() {
											this.isUpdatePending = !0;
											try {
												await this._$E_
											} catch (t) {
												Promise.reject(t)
											}
											let e = this.scheduleUpdate();
											return null != e && await e, !this.isUpdatePending
										}
										scheduleUpdate() {
											return this.performUpdate()
										}
										performUpdate() {
											var e;
											if (!this.isUpdatePending) return;
											this.hasUpdated, this._$Ei && (this._$Ei.forEach((e, t) => this[t] = e), this._$Ei = void 0);
											let t = !1,
												r = this._$AL;
											try {
												(t = this.shouldUpdate(r)) ? (this.willUpdate(r), null === (e = this._$ES) || void 0 === e || e.forEach(e => {
													var t;
													return null === (t = e.hostUpdate) || void 0 === t ? void 0 : t.call(e)
												}), this.update(r)) : this._$Ek()
											} catch (n) {
												throw t = !1, this._$Ek(), n
											}
											t && this._$AE(r)
										}
										willUpdate(e) {}
										_$AE(e) {
											var t;
											null === (t = this._$ES) || void 0 === t || t.forEach(e => {
												var t;
												return null === (t = e.hostUpdated) || void 0 === t ? void 0 : t.call(e)
											}), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e)
										}
										_$Ek() {
											this._$AL = new Map, this.isUpdatePending = !1
										}
										get updateComplete() {
											return this.getUpdateComplete()
										}
										getUpdateComplete() {
											return this._$E_
										}
										shouldUpdate(e) {
											return !0
										}
										update(e) {
											void 0 !== this._$EC && (this._$EC.forEach((e, t) => this._$EO(t, this[t], e)), this._$EC = void 0), this._$Ek()
										}
										updated(e) {}
										firstUpdated(e) {}
									};
								Mt.finalized = !0, Mt.elementProperties = new Map, Mt.elementStyles = [], Mt.shadowRootOptions = {
									mode: "open"
								}, null == Tt || Tt({
									ReactiveElement: Mt
								}), (null !== (Le = St.reactiveElementVersions) && void 0 !== Le ? Le : St.reactiveElementVersions = []).push("1.4.0");
								var xt, Ot = window,
									At = Ot.trustedTypes,
									Pt = At ? At.createPolicy("lit-html", {
										createHTML: e => e
									}) : void 0,
									Dt = `lit$${(Math.random()+"").slice(9)}$`,
									jt = "?" + Dt,
									Lt = `<${jt}>`,
									Nt = document,
									Bt = (e = "") => Nt.createComment(e),
									Ut = e => null === e || "object" != typeof e && "function" != typeof e,
									Ft = Array.isArray,
									$t = e => Ft(e) || "function" == typeof(null == e ? void 0 : e[Symbol.iterator]),
									qt = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
									Kt = /-->/g,
									Vt = />/g,
									zt = RegExp(">|[ \t\n\f\r](?:([^\\s\"'>=/]+)([ \t\n\f\r]*=[ \t\n\f\r]*(?:[^ \t\n\f\r\"'`<>=]|(\"|')|))|$)", "g"),
									Ht = /'/g,
									Wt = /"/g,
									Gt = /^(?:script|style|textarea|title)$/i,
									Yt = e => (t, ...r) => ({
										_$litType$: e,
										strings: t,
										values: r
									}),
									Qt = Yt(1),
									Jt = Yt(2),
									Xt = Symbol.for("lit-noChange"),
									Zt = Symbol.for("lit-nothing"),
									er = new WeakMap,
									tr = (e, t, r) => {
										var n, i;
										let o = null !== (n = null == r ? void 0 : r.renderBefore) && void 0 !== n ? n : t,
											s = o._$litPart$;
										if (void 0 === s) {
											let e = null !== (i = null == r ? void 0 : r.renderBefore) && void 0 !== i ? i : null;
											o._$litPart$ = s = new lr(t.insertBefore(Bt(), e), e, void 0, null != r ? r : {})
										}
										return s._$AI(e), s
									},
									rr = Nt.createTreeWalker(Nt, 129, null, !1),
									nr = (e, t) => {
										let r, n = e.length - 1,
											i = [],
											o = 2 === t ? "<svg>" : "",
											s = qt;
										for (let c = 0; c < n; c++) {
											let t, n, a = e[c],
												l = -1,
												u = 0;
											for (; u < a.length && (s.lastIndex = u, null !== (n = s.exec(a)));) u = s.lastIndex, s === qt ? "!--" === n[1] ? s = Kt : void 0 !== n[1] ? s = Vt : void 0 !== n[2] ? (Gt.test(n[2]) && (r = RegExp("</" + n[2], "g")), s = zt) : void 0 !== n[3] && (s = zt) : s === zt ? ">" === n[0] ? (s = null != r ? r : qt, l = -1) : void 0 === n[1] ? l = -2 : (l = s.lastIndex - n[2].length, t = n[1], s = void 0 === n[3] ? zt : '"' === n[3] ? Wt : Ht) : s === Wt || s === Ht ? s = zt : s === Kt || s === Vt ? s = qt : (s = zt, r = void 0);
											let d = s === zt && e[c + 1].startsWith("/>") ? " " : "";
											o += s === qt ? a + Lt : l >= 0 ? (i.push(t), a.slice(0, l) + "$lit$" + a.slice(l) + Dt + d) : a + Dt + (-2 === l ? (i.push(void 0), c) : d)
										}
										let a = o + (e[n] || "<?>") + (2 === t ? "</svg>" : "");
										if (!Array.isArray(e) || !e.hasOwnProperty("raw")) throw Error("invalid template strings array");
										return [void 0 !== Pt ? Pt.createHTML(a) : a, i]
									},
									ir = class {
										constructor({
											strings: e,
											_$litType$: t
										}, r) {
											let n;
											this.parts = [];
											let i = 0,
												o = 0,
												s = e.length - 1,
												a = this.parts,
												[c, l] = nr(e, t);
											if (this.el = ir.createElement(c, r), rr.currentNode = this.el.content, 2 === t) {
												let e = this.el.content,
													t = e.firstChild;
												t.remove(), e.append(...t.childNodes)
											}
											for (; null !== (n = rr.nextNode()) && a.length < s;) {
												if (1 === n.nodeType) {
													if (n.hasAttributes()) {
														let e = [];
														for (let t of n.getAttributeNames())
															if (t.endsWith("$lit$") || t.startsWith(Dt)) {
																let r = l[o++];
																if (e.push(t), void 0 !== r) {
																	let e = n.getAttribute(r.toLowerCase() + "$lit$").split(Dt),
																		t = /([.?@])?(.*)/.exec(r);
																	a.push({
																		type: 1,
																		index: i,
																		name: t[2],
																		strings: e,
																		ctor: "." === t[1] ? dr : "?" === t[1] ? fr : "@" === t[1] ? pr : ur
																	})
																} else a.push({
																	type: 6,
																	index: i
																})
															} for (let t of e) n.removeAttribute(t)
													}
													if (Gt.test(n.tagName)) {
														let e = n.textContent.split(Dt),
															t = e.length - 1;
														if (t > 0) {
															n.textContent = At ? At.emptyScript : "";
															for (let r = 0; r < t; r++) n.append(e[r], Bt()), rr.nextNode(), a.push({
																type: 2,
																index: ++i
															});
															n.append(e[t], Bt())
														}
													}
												} else if (8 === n.nodeType)
													if (n.data === jt) a.push({
														type: 2,
														index: i
													});
													else {
														let e = -1;
														for (; - 1 !== (e = n.data.indexOf(Dt, e + 1));) a.push({
															type: 7,
															index: i
														}), e += Dt.length - 1
													} i++
											}
										}
										static createElement(e, t) {
											let r = Nt.createElement("template");
											return r.innerHTML = e, r
										}
									};

								function or(e, t, r = e, n) {
									var i, o, s, a;
									if (t === Xt) return t;
									let c = void 0 !== n ? null === (i = r._$Cl) || void 0 === i ? void 0 : i[n] : r._$Cu,
										l = Ut(t) ? void 0 : t._$litDirective$;
									return (null == c ? void 0 : c.constructor) !== l && (null === (o = null == c ? void 0 : c._$AO) || void 0 === o || o.call(c, !1), void 0 === l ? c = void 0 : (c = new l(e))._$AT(e, r, n), void 0 !== n ? (null !== (s = (a = r)._$Cl) && void 0 !== s ? s : a._$Cl = [])[n] = c : r._$Cu = c), void 0 !== c && (t = or(e, c._$AS(e, t.values), c, n)), t
								}
								var sr, ar, cr = class {
										constructor(e, t) {
											this.v = [], this._$AN = void 0, this._$AD = e, this._$AM = t
										}
										get parentNode() {
											return this._$AM.parentNode
										}
										get _$AU() {
											return this._$AM._$AU
										}
										p(e) {
											var t;
											let {
												el: {
													content: r
												},
												parts: n
											} = this._$AD, i = (null !== (t = null == e ? void 0 : e.creationScope) && void 0 !== t ? t : Nt).importNode(r, !0);
											rr.currentNode = i;
											let o = rr.nextNode(),
												s = 0,
												a = 0,
												c = n[0];
											for (; void 0 !== c;) {
												if (s === c.index) {
													let t;
													2 === c.type ? t = new lr(o, o.nextSibling, this, e) : 1 === c.type ? t = new c.ctor(o, c.name, c.strings, this, e) : 6 === c.type && (t = new vr(o, this, e)), this.v.push(t), c = n[++a]
												}
												s !== (null == c ? void 0 : c.index) && (o = rr.nextNode(), s++)
											}
											return i
										}
										m(e) {
											let t = 0;
											for (let r of this.v) void 0 !== r && (void 0 !== r.strings ? (r._$AI(e, r, t), t += r.strings.length - 2) : r._$AI(e[t])), t++
										}
									},
									lr = class {
										constructor(e, t, r, n) {
											var i;
											this.type = 2, this._$AH = Zt, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = r, this.options = n, this._$C_ = null === (i = null == n ? void 0 : n.isConnected) || void 0 === i || i
										}
										get _$AU() {
											var e, t;
											return null !== (t = null === (e = this._$AM) || void 0 === e ? void 0 : e._$AU) && void 0 !== t ? t : this._$C_
										}
										get parentNode() {
											let e = this._$AA.parentNode,
												t = this._$AM;
											return void 0 !== t && 11 === e.nodeType && (e = t.parentNode), e
										}
										get startNode() {
											return this._$AA
										}
										get endNode() {
											return this._$AB
										}
										_$AI(e, t = this) {
											e = or(this, e, t), Ut(e) ? e === Zt || null == e || "" === e ? (this._$AH !== Zt && this._$AR(), this._$AH = Zt) : e !== this._$AH && e !== Xt && this.$(e) : void 0 !== e._$litType$ ? this.T(e) : void 0 !== e.nodeType ? this.k(e) : $t(e) ? this.O(e) : this.$(e)
										}
										S(e, t = this._$AB) {
											return this._$AA.parentNode.insertBefore(e, t)
										}
										k(e) {
											this._$AH !== e && (this._$AR(), this._$AH = this.S(e))
										}
										$(e) {
											this._$AH !== Zt && Ut(this._$AH) ? this._$AA.nextSibling.data = e : this.k(Nt.createTextNode(e)), this._$AH = e
										}
										T(e) {
											var t;
											let {
												values: r,
												_$litType$: n
											} = e, i = "number" == typeof n ? this._$AC(e) : (void 0 === n.el && (n.el = ir.createElement(n.h, this.options)), n);
											if ((null === (t = this._$AH) || void 0 === t ? void 0 : t._$AD) === i) this._$AH.m(r);
											else {
												let e = new cr(i, this),
													t = e.p(this.options);
												e.m(r), this.k(t), this._$AH = e
											}
										}
										_$AC(e) {
											let t = er.get(e.strings);
											return void 0 === t && er.set(e.strings, t = new ir(e)), t
										}
										O(e) {
											Ft(this._$AH) || (this._$AH = [], this._$AR());
											let t, r = this._$AH,
												n = 0;
											for (let i of e) n === r.length ? r.push(t = new lr(this.S(Bt()), this.S(Bt()), this, this.options)) : t = r[n], t._$AI(i), n++;
											n < r.length && (this._$AR(t && t._$AB.nextSibling, n), r.length = n)
										}
										_$AR(e = this._$AA.nextSibling, t) {
											var r;
											for (null === (r = this._$AP) || void 0 === r || r.call(this, !1, !0, t); e && e !== this._$AB;) {
												let t = e.nextSibling;
												e.remove(), e = t
											}
										}
										setConnected(e) {
											var t;
											void 0 === this._$AM && (this._$C_ = e, null === (t = this._$AP) || void 0 === t || t.call(this, e))
										}
									},
									ur = class {
										constructor(e, t, r, n, i) {
											this.type = 1, this._$AH = Zt, this._$AN = void 0, this.element = e, this.name = t, this._$AM = n, this.options = i, r.length > 2 || "" !== r[0] || "" !== r[1] ? (this._$AH = Array(r.length - 1).fill(new String), this.strings = r) : this._$AH = Zt
										}
										get tagName() {
											return this.element.tagName
										}
										get _$AU() {
											return this._$AM._$AU
										}
										_$AI(e, t = this, r, n) {
											let i = this.strings,
												o = !1;
											if (void 0 === i) e = or(this, e, t, 0), (o = !Ut(e) || e !== this._$AH && e !== Xt) && (this._$AH = e);
											else {
												let n, s, a = e;
												for (e = i[0], n = 0; n < i.length - 1; n++)(s = or(this, a[r + n], t, n)) === Xt && (s = this._$AH[n]), o || (o = !Ut(s) || s !== this._$AH[n]), s === Zt ? e = Zt : e !== Zt && (e += (null != s ? s : "") + i[n + 1]), this._$AH[n] = s
											}
											o && !n && this.P(e)
										}
										P(e) {
											e === Zt ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != e ? e : "")
										}
									},
									dr = class extends ur {
										constructor() {
											super(...arguments), this.type = 3
										}
										P(e) {
											this.element[this.name] = e === Zt ? void 0 : e
										}
									},
									hr = At ? At.emptyScript : "",
									fr = class extends ur {
										constructor() {
											super(...arguments), this.type = 4
										}
										P(e) {
											e && e !== Zt ? this.element.setAttribute(this.name, hr) : this.element.removeAttribute(this.name)
										}
									},
									pr = class extends ur {
										constructor(e, t, r, n, i) {
											super(e, t, r, n, i), this.type = 5
										}
										_$AI(e, t = this) {
											var r;
											if ((e = null !== (r = or(this, e, t, 0)) && void 0 !== r ? r : Zt) === Xt) return;
											let n = this._$AH,
												i = e === Zt && n !== Zt || e.capture !== n.capture || e.once !== n.once || e.passive !== n.passive,
												o = e !== Zt && (n === Zt || i);
											i && this.element.removeEventListener(this.name, this, n), o && this.element.addEventListener(this.name, this, e), this._$AH = e
										}
										handleEvent(e) {
											var t, r;
											"function" == typeof this._$AH ? this._$AH.call(null !== (r = null === (t = this.options) || void 0 === t ? void 0 : t.host) && void 0 !== r ? r : this.element, e) : this._$AH.handleEvent(e)
										}
									},
									vr = class {
										constructor(e, t, r) {
											this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = r
										}
										get _$AU() {
											return this._$AM._$AU
										}
										_$AI(e) {
											or(this, e)
										}
									},
									gr = {
										A: "$lit$",
										M: Dt,
										C: jt,
										L: 1,
										R: nr,
										D: cr,
										V: $t,
										I: or,
										H: lr,
										N: ur,
										U: fr,
										B: pr,
										F: dr,
										W: vr
									},
									mr = Ot.litHtmlPolyfillSupport;
								null == mr || mr(ir, lr), (null !== (xt = Ot.litHtmlVersions) && void 0 !== xt ? xt : Ot.litHtmlVersions = []).push("2.3.0");
								var yr = class extends Mt {
									constructor() {
										super(...arguments), this.renderOptions = {
											host: this
										}, this._$Do = void 0
									}
									createRenderRoot() {
										var e, t;
										let r = super.createRenderRoot();
										return null !== (e = (t = this.renderOptions).renderBefore) && void 0 !== e || (t.renderBefore = r.firstChild), r
									}
									update(e) {
										let t = this.render();
										this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = tr(t, this.renderRoot, this.renderOptions)
									}
									connectedCallback() {
										var e;
										super.connectedCallback(), null === (e = this._$Do) || void 0 === e || e.setConnected(!0)
									}
									disconnectedCallback() {
										var e;
										super.disconnectedCallback(), null === (e = this._$Do) || void 0 === e || e.setConnected(!1)
									}
									render() {
										return Xt
									}
								};
								yr.finalized = !0, yr._$litElement$ = !0, null === (sr = globalThis.litElementHydrateSupport) || void 0 === sr || sr.call(globalThis, {
									LitElement: yr
								});
								var br = globalThis.litElementPolyfillSupport;
								null == br || br({
									LitElement: yr
								}), (null !== (ar = globalThis.litElementVersions) && void 0 !== ar ? ar : globalThis.litElementVersions = []).push("3.2.1");
								var _r = e => t => "function" == typeof t ? ((e, t) => (customElements.define(e, t), t))(e, t) : ((e, t) => {
										let {
											kind: r,
											elements: n
										} = t;
										return {
											kind: r,
											elements: n,
											finisher(t) {
												customElements.define(e, t)
											}
										}
									})(e, t),
									wr = (e, t) => "method" !== t.kind || !t.descriptor || "value" in t.descriptor ? {
										kind: "field",
										key: Symbol(),
										placement: "own",
										descriptor: {},
										originalKey: t.key,
										initializer() {
											"function" == typeof t.initializer && (this[t.key] = t.initializer.call(this))
										},
										finisher(r) {
											r.createProperty(t.key, e)
										}
									} : {
										...t,
										finisher(r) {
											r.createProperty(t.key, e)
										}
									};

								function Sr(e) {
									return (t, r) => void 0 !== r ? ((e, t, r) => {
										t.constructor.createProperty(r, e)
									})(e, t, r) : wr(e, t)
								}

								function Er(e) {
									return Sr({
										...e,
										state: !0
									})
								}
								var kr = ({
									finisher: e,
									descriptor: t
								}) => (r, n) => {
									var i;
									if (void 0 === n) {
										let n = null !== (i = r.originalKey) && void 0 !== i ? i : r.key,
											o = null != t ? {
												kind: "method",
												placement: "prototype",
												key: n,
												descriptor: t(r.key)
											} : {
												...r,
												key: n
											};
										return null != e && (o.finisher = function(t) {
											e(t, n)
										}), o
									} {
										let i = r.constructor;
										void 0 !== t && Object.defineProperty(r, n, t(n)), null == e || e(i, n)
									}
								};

								function Tr(e, t) {
									return kr({
										descriptor: r => {
											let n = {
												get() {
													var t, r;
													return null !== (r = null === (t = this.renderRoot) || void 0 === t ? void 0 : t.querySelector(e)) && void 0 !== r ? r : null
												},
												enumerable: !0,
												configurable: !0
											};
											if (t) {
												let t = "symbol" == typeof r ? Symbol() : "__" + r;
												n.get = function() {
													var r, n;
													return void 0 === this[t] && (this[t] = null !== (n = null === (r = this.renderRoot) || void 0 === r ? void 0 : r.querySelector(e)) && void 0 !== n ? n : null), this[t]
												}
											}
											return n
										}
									})
								}
								var Ir, Rr = null != (null === (Ir = window.HTMLSlotElement) || void 0 === Ir ? void 0 : Ir.prototype.assignedElements) ? (e, t) => e.assignedElements(t) : (e, t) => e.assignedNodes(t).filter(e => e.nodeType === Node.ELEMENT_NODE);

								function Cr(e, t, r) {
									let n, i = e;
									return "object" == typeof e ? (i = e.slot, n = e) : n = {
										flatten: t
									}, r ? function(e) {
										let {
											slot: t,
											selector: r
										} = null != e ? e : {};
										return kr({
											descriptor: n => ({
												get() {
													var n;
													let i = "slot" + (t ? `[name=${t}]` : ":not([name])"),
														o = null === (n = this.renderRoot) || void 0 === n ? void 0 : n.querySelector(i),
														s = null != o ? Rr(o, e) : [];
													return r ? s.filter(e => e.matches(r)) : s
												},
												enumerable: !0,
												configurable: !0
											})
										})
									}({
										slot: i,
										flatten: t,
										selector: r
									}) : kr({
										descriptor: e => ({
											get() {
												var e, t;
												let r = "slot" + (i ? `[name=${i}]` : ":not([name])"),
													o = null === (e = this.renderRoot) || void 0 === e ? void 0 : e.querySelector(r);
												return null !== (t = null == o ? void 0 : o.assignedNodes(n)) && void 0 !== t ? t : []
											},
											enumerable: !0,
											configurable: !0
										})
									})
								}
								var Mr = "context-value-request",
									xr = "context-value-provided",
									Or = class extends CustomEvent {
										constructor(e) {
											super(Mr, {
												detail: e,
												bubbles: !0,
												composed: !0
											})
										}
									},
									Ar = class extends CustomEvent {
										constructor(e) {
											super(xr, {
												detail: e,
												bubbles: !0,
												composed: !0
											})
										}
									},
									Pr = e => (class extends e {
										constructor() {
											super(), this.instances = new Map, this.addEventListener(Mr, e => {
												let t = e.detail.name;
												this.instances.has(t) && (e.detail.instance = this.instances.get(t), e.stopPropagation())
											}), this.addEventListener(xr, e => {
												e.target !== this && this.provideInstance(e.detail.name, e.detail.instance)
											})
										}
										provideInstance(e, t) {
											this.instances.set(e, t);
											let r = new Ar({
												name: e,
												instance: t
											});
											this.dispatchEvent(r)
										}
									}),
									Dr = e => (class extends e {
										constructor() {
											super(...arguments), this.handleInstanceUpdated = e => {
												this.instanceUpdated(e.detail.name)
											}
										}
										connectedCallback() {
											super.connectedCallback(), window.addEventListener(xr, this.handleInstanceUpdated)
										}
										disconnectedCallback() {
											super.disconnectedCallback(), window.removeEventListener(xr, this.handleInstanceUpdated)
										}
										requestInstance(e) {
											let t = new Or({
												name: e
											});
											return this.dispatchEvent(t), t.detail.instance
										}
										instanceUpdated(e) {}
									}),
									jr = 1,
									Lr = 2,
									Nr = 6,
									Br = e => (...t) => ({
										_$litDirective$: e,
										values: t
									}),
									Ur = class {
										constructor(e) {}
										get _$AU() {
											return this._$AM._$AU
										}
										_$AT(e, t, r) {
											this._$Ct = e, this._$AM = t, this._$Ci = r
										}
										_$AS(e, t) {
											return this.update(e, t)
										}
										update(e, t) {
											return this.render(...t)
										}
									},
									Fr = Br(class extends Ur {
										constructor(e) {
											var t;
											if (super(e), e.type !== jr || "class" !== e.name || (null === (t = e.strings) || void 0 === t ? void 0 : t.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.")
										}
										render(e) {
											return " " + Object.keys(e).filter(t => e[t]).join(" ") + " "
										}
										update(e, [t]) {
											var r, n;
											if (void 0 === this.nt) {
												this.nt = new Set, void 0 !== e.strings && (this.st = new Set(e.strings.join(" ").split(/\s/).filter(e => "" !== e)));
												for (let e in t) t[e] && (null === (r = this.st) || void 0 === r || !r.has(e)) && this.nt.add(e);
												return this.render(t)
											}
											let i = e.element.classList;
											this.nt.forEach(e => {
												e in t || (i.remove(e), this.nt.delete(e))
											});
											for (let o in t) {
												let e = !!t[o];
												e === this.nt.has(o) || (null === (n = this.st) || void 0 === n ? void 0 : n.has(o)) || (e ? (i.add(o), this.nt.add(o)) : (i.remove(o), this.nt.delete(o)))
											}
											return Xt
										}
									}),
									$r = matrixcs,
									{
										ClientEvent: qr,
										Direction: Kr,
										EventType: Vr,
										EventStatus: zr,
										MatrixEvent: Hr,
										MatrixEventEvent: Wr,
										MsgType: Gr,
										Preset: Yr,
										RoomEvent: Qr,
										RoomStateEvent: Jr,
										TimelineWindow: Xr,
										Visibility: Zr,
										RelationType: en
									} = matrixcs,
									tn = Object.assign({}, {
										templateRenderingStrategy: null
									}),
									rn = () => {
										let {
											templateRenderingStrategy: e = null
										} = (() => Object.assign({}, tn))();
										if (null == e) throw new Error("Faceplate-ui templateRenderingStrategy is undefined.\n\n      Please import a templateRenderingStrategy so that faceplate-ui can render\n      template components properly for your environment. For example:\n\n      import '@reddit/faceplate-ui/templateRenderingStrategy/clientStrategy.js'\n\n      or, for a server environment:\n\n      import '@reddit/faceplate-ui/templateRenderingStrategy/serverStrategy.js'\n      ");
										return e
									},
									nn = Br(class extends Ur {
										constructor(e) {
											if (super(e), this._previousAttrs = new Set, e.type !== Nr) throw new Error("attrs directive must be used on element")
										}
										render(e) {
											return Xt
										}
										update(e, [t]) {
											let r = e.element;
											this._previousAttrs.forEach(e => {
												(!(e in t) || !t[e]) && r.removeAttribute(e)
											}), this._previousAttrs.clear();
											for (let n in t) {
												let e = t[n];
												if (!e) continue;
												let i = "boolean" == typeof e ? "" : e.toString();
												r.setAttribute(n, i), this._previousAttrs.add(n)
											}
											return Xt
										}
									}),
									on = e => null != e ? e : Zt;

								function sn(e, t) {
									return "className" !== e && (null == t || "string" == typeof t || "number" == typeof t || "boolean" == typeof t)
								}
								var an, cn, ln = e => {
									let t = {};
									for (let r in e) {
										let n = e[r];
										Object.prototype.hasOwnProperty.call(e, r) && sn(r, n) && (t[r] = n)
									}
									return t
								};
								(e => {
									tn = Object.assign(Object.assign({}, tn), e)
								})({
									templateRenderingStrategy: {
										_toHtml_TEST_ONLY: e => {
											let t = document.createElement("div");
											return tr(e, t), t.children[0]
										},
										attrs: e => null == e ? Zt : nn(ln(e)),
										ifDefined: on,
										html: Qt,
										getType: () => "client",
										svg: Jt
									}
								}), (cn = an || (an = {})).Small = "sm", cn.Medium = "md", cn.Large = "lg";
								var un = {
										sm: "button-small",
										md: "button-medium",
										lg: "button-large"
									},
									dn = {
										sm: {
											label: "px-[length:var(--rem10)]",
											icon: "px-[length:var(--rem6)]",
											iconLabel: "px-[length:var(--rem10)]"
										},
										md: {
											label: "px-[length:var(--rem14)]",
											icon: "px-[length:var(--rem8)]",
											iconLabel: "pl-[length:var(--rem10)] pr-[length:var(--rem14)]"
										},
										lg: {
											label: "px-[length:var(--rem14)]",
											icon: "px-[length:var(--rem12)]",
											iconLabel: "pl-[length:var(--rem10)] pr-[length:var(--rem14)]"
										}
									},
									hn = {
										sm: {
											label: "pl-[length:var(--rem10)] pr-[length:var(--rem6)]",
											icon: "pl-[length:var(--rem10)] pr-[length:var(--rem6)]",
											iconLabel: "pl-[length:var(--rem10)] pr-[length:var(--rem6)]"
										},
										md: {
											label: "pl-[length:var(--rem14)] pr-[length:var(--rem10)]",
											icon: "pl-[length:var(--rem10)] pr-[length:var(--rem6)]",
											iconLabel: "px-[length:var(--rem10)]"
										},
										lg: {
											label: "pl-[length:var(--rem14)] pr-[length:var(--rem10)]",
											icon: "px-[length:var(--rem14)]",
											iconLabel: "pl-[length:var(--rem14)] pr-[length:var(--rem10)]"
										}
									},
									fn = {
										primary: "button-primary",
										secondary: "button-secondary",
										tertiary: "button-tertiary",
										plain: "button-plain",
										outline: "button-outline",
										destructive: "button-destructive",
										media: "button-media",
										brand: "button-brand",
										success: "button-success",
										plainInverted: "button-plain-inverted"
									},
									pn = {
										sm: "text-16",
										md: "text-20",
										lg: "text-20"
									},
									vn = ({
										attributes: e,
										children: t,
										size: r = an.Medium,
										appearance: n = "secondary",
										selected: i,
										shape: o,
										leadingIcon: s,
										dropdown: a,
										ariaLabel: c,
										ariaControls: l,
										role: u
									}) => {
										let {
											attrs: d,
											html: h,
											ifDefined: f
										} = rn(), p = "label", v = "flex";
										s && t ? p = "iconLabel" : t || (p = "icon"), (t || a) && (v += " mr-xs");
										let g = a ? hn : dn,
											m = "tab" === u ? i ? "true" : "false" : void 0;
										return h`
    <button
      ${d(e)}
      @click="${null==e?void 0:e.onclick}"
      aria-label="${f(c)}"
      aria-controls="${f(l)}"
      aria-selected="${f(m)}"
      role="${f(null===u?void 0:u)}"
      class="${(null==e?void 0:e.className)||""}
          ${r?`${un[r]} ${g[r][p]}`:""}
          ${n?fn[n]:""}
          ${i?"button-activated":""}
          ${"square"===o?"rounded-[.5rem]":""}
          button flex items-center justify-center">
      <span class="flex items-center justify-center">
        ${s?h`<span class="${v} ${pn[r]}">
              ${s}
            </span>`:void 0}
        ${t?h`<span class="${"flex items-center gap-xs"}"> ${t} </span>`:void 0}
      </span>
      ${a?h`<span
            class="inline-block dropdown-icon ${pn[r]} ${t&&"ml-2xs"}"
            ><icon-caret-down></icon-caret-down
          ></span>`:void 0}
    </button>
  `
									},
									gn = "matrix",
									mn = e => (class extends(Dr(e)) {
										constructor() {
											super(...arguments), this.handleMatrixEvent = () => {
												this.requestUpdate()
											}
										}
										connectedCallback() {
											super.connectedCallback(), this.assignMatrixInstance()
										}
										disconnectedCallback() {
											super.disconnectedCallback(), this.matrix && (this.matrix.off(qr.Event, this.handleMatrixEvent), this.matrix.off(qr.Sync, this.handleMatrixEvent))
										}
										assignMatrixInstance() {
											let e = this.requestInstance(gn);
											e && (this.matrix = e, this.requestUpdate(), this.matrixConnected(), this.matrix.on(qr.Event, this.handleMatrixEvent), this.matrix.on(qr.Sync, this.handleMatrixEvent))
										}
										instanceUpdated(e) {
											super.instanceUpdated(e), e === gn && this.assignMatrixInstance()
										}
										matrixConnected() {}
									}),
									yn = class {
										constructor() {
											let e, t;
											this.promise = new Promise((r, n) => {
												e = r, t = n
											}), this.resolve = e, this.reject = t
										}
									},
									bn = class {
										constructor(e, t) {
											this.host = e, this.name = t, this.handleInstanceUpdated = e => {
												e.detail.name === this.name && (this.value = e.detail.instance, this.deferredValue && (this.deferredValue.resolve(this.value), this.deferredValue = void 0))
											}, e.addController(this)
										}
										hostConnected() {
											let e = new Or({
												name: this.name
											});
											this.host.dispatchEvent(e), this.value = e.detail.instance, window.addEventListener(xr, this.handleInstanceUpdated)
										}
										hostDisconnected() {
											window.removeEventListener(xr, this.handleInstanceUpdated)
										}
										async getInstance() {
											return this.value ? this.value : (this.deferredValue || (this.deferredValue = new yn), this.deferredValue.promise)
										}
									},
									_n = class extends bn {
										constructor(e) {
											super(e, gn), this.listeners = []
										}
										get client() {
											if (!this.value) throw new Error("Matrix client instance is required");
											return this.value
										}
										hostConnected() {
											if (super.hostConnected(), !this.value) throw new Error("Matrix client instance is required")
										}
										hostDisconnected() {
											super.hostDisconnected(), this.listeners.forEach(e => {
												this.client.off(e.event, e.listener)
											}), this.listeners = []
										}
										on(e, t) {
											this.client.on(e, t), this.listeners.push({
												event: e,
												listener: t
											})
										}
									},
									wn = class {
										constructor(e, t = "room") {
											this.host = e, this.roomIdPropertyName = t, this.roomId = "", this.listeners = [], e.addController(this), this.matrix = new _n(e)
										}
										get hostRoomId() {
											return this.host[this.roomIdPropertyName]
										}
										getRoom() {
											let e = this.matrix.client.getRoom(this.hostRoomId);
											if (!e) throw new Error("Room not found");
											return e
										}
										on(e, t) {
											this.getRoom().on(e, t), this.listeners.push({
												event: e,
												listener: t
											})
										}
										hostConnected() {
											this.roomId = this.hostRoomId
										}
										hostUpdated() {
											if (this.hostRoomId !== this.roomId) {
												if (this.listeners.length > 0) {
													let e = this.matrix.client.getRoom(this.hostRoomId);
													e && this.listeners.forEach(t => {
														e.off(t.event, t.listener)
													})
												}
												if (this.roomId = this.hostRoomId, this.listeners.length > 0) {
													let e = this.getRoom();
													this.listeners.forEach(t => {
														e.on(t.event, t.listener)
													})
												}
											}
										}
										hostDisconnected() {
											let e = this.getRoom();
											this.listeners.forEach(t => {
												e.off(t.event, t.listener)
											}), this.listeners = []
										}
									},
									Sn = class extends Ur {
										constructor(e) {
											if (super(e), this.it = Zt, e.type !== Lr) throw Error(this.constructor.directiveName + "() can only be used in child bindings")
										}
										render(e) {
											if (e === Zt || null == e) return this._t = void 0, this.it = e;
											if (e === Xt) return e;
											if ("string" != typeof e) throw Error(this.constructor.directiveName + "() called with a non-string value");
											if (e === this.it) return this._t;
											this.it = e;
											let t = [e];
											return t.raw = t, this._t = {
												_$litType$: this.constructor.resultType,
												strings: t,
												values: []
											}
										}
									};
								Sn.directiveName = "unsafeHTML", Sn.resultType = 1;
								Br(Sn);
								var En = class extends Sn {};
								En.directiveName = "unsafeSVG", En.resultType = 2;
								var kn, Tn = Br(En),
									In = p(_(), 1),
									{
										__extends: Rn,
										__assign: Cn,
										__rest: Mn,
										__decorate: xn,
										__param: On,
										__metadata: An,
										__awaiter: Pn,
										__generator: Dn,
										__exportStar: jn,
										__createBinding: Ln,
										__values: Nn,
										__read: Bn,
										__spread: Un,
										__spreadArrays: Fn,
										__spreadArray: $n,
										__await: qn,
										__asyncGenerator: Kn,
										__asyncDelegator: Vn,
										__asyncValues: zn,
										__makeTemplateObject: Hn,
										__importStar: Wn,
										__importDefault: Gn,
										__classPrivateFieldGet: Yn,
										__classPrivateFieldSet: Qn,
										__classPrivateFieldIn: Jn
									} = In.default;
								! function(e) {
									e.Small = "sm", e.Medium = "md", e.Large = "lg", e.ExtraLarge = "xl"
								}(kn || (kn = {}));
								var Xn = _t`
  :host {
    display: inline-block;
    fill: currentColor;
    vertical-align: middle;
    line-height: 1em;
  }

  svg {
    fill: currentColor;
    width: auto;
  }

  :host([size='sm']) > svg {
    height: 1em;
  }

  :host([size='md']) > svg {
    height: 1.25em;
  }

  :host([size='lg']) > svg {
    height: 1.5em;
  }

  :host([size='xl']) > svg {
    height: 2em;
  }
`;

								function Zn(e, t, r, n = Xn) {
									if (r) {
										class i extends yr {
											constructor() {
												super(...arguments), this.size = kn.Small, this.fill = !1
											}
											static get styles() {
												return n
											}
											render() {
												return this.fill ? r : t
											}
										}
										xn([Sr({
											type: String,
											reflect: !0
										})], i.prototype, "size", void 0), xn([Sr({
											type: Boolean
										})], i.prototype, "fill", void 0), window.customElements.define(e, i)
									} else {
										class r extends yr {
											constructor() {
												super(...arguments), this.size = kn.Small
											}
											static get styles() {
												return n
											}
											render() {
												return t
											}
										}
										xn([Sr({
											type: String,
											reflect: !0
										})], r.prototype, "size", void 0), window.customElements.define(e, r)
									}
								}
								Zn("icon-caret-down", Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M10 13.125a.624.624 0 01-.442-.183l-5-5 .884-.884L10 11.616l4.558-4.558.884.884-5 5a.624.624 0 01-.442.183z"/></svg>')}`, Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M10 13.5a1 1 0 01-.707-.293l-5-5 1.414-1.414L10 11.086l4.293-4.293 1.414 1.414-5 5A1 1 0 0110 13.5z"/></svg>')}`), Zn("icon-close", Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M18.442 2.442l-.884-.884L10 9.116 2.442 1.558l-.884.884L9.116 10l-7.558 7.558.884.884L10 10.884l7.558 7.558.884-.884L10.884 10l7.558-7.558z"/></svg>')}`, Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M18.707 2.707l-1.414-1.414L10 8.586 2.707 1.293 1.293 2.707 8.586 10l-7.293 7.293 1.414 1.414L10 11.414l7.293 7.293 1.414-1.414L11.414 10l7.293-7.293z"/></svg>')}`), Zn("icon-external", Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M15.75 13H17v3.375A2.63 2.63 0 0114.375 19H3.625A2.63 2.63 0 011 16.375V5.625A2.629 2.629 0 013.625 3H7v1.25H3.625A1.377 1.377 0 002.25 5.625v10.75a1.377 1.377 0 001.375 1.375h10.75a1.377 1.377 0 001.375-1.375V13zm2.625-12h-5v1.25h3.491l-8.433 8.433.884.884 8.433-8.433v3.491H19v-5A.625.625 0 0018.375 1z"/></svg>')}`, Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M15 13h2v3.35A2.653 2.653 0 0114.35 19H3.65A2.653 2.653 0 011 16.35V5.653A2.656 2.656 0 013.653 3H7v2H3.653A.654.654 0 003 5.653v10.7a.65.65 0 00.65.65h10.7a.65.65 0 00.65-.65V13zm3.375-12h-5.438a.625.625 0 00-.422 1.085L14.591 4l-6.423 6.418 1.414 1.414 6.483-6.483 1.887 1.736A.626.626 0 0019 6.625v-5A.625.625 0 0018.375 1z"/></svg>')}`);

								function ei(e) {
									! function(e, t) {
										null != t && t.replace ? window.history.replaceState({}, "", e) : window.history.pushState({}, "", e), window.dispatchEvent(new PopStateEvent("popstate"))
									}("/", e)
								}

								function ti() {
									var e;
									null == (e = null == window ? void 0 : window.top) || e.postMessage("matrix-chat.close", "*")
								}

								function ri() {
									var e;
									null == (e = null == window ? void 0 : window.top) || e.postMessage("matrix-chat.minimize", "*")
								}

								function ni(e) {
									var t;
									null == (t = null == window ? void 0 : window.top) || t.postMessage(`matrix-chat.rooms_count:${e}`, "*")
								}
								var ii = _t`*,::before,::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x:;--tw-pan-y:;--tw-pinch-zoom:;--tw-scroll-snap-strictness:proximity;--tw-ordinal:;--tw-slashed-zero:;--tw-numeric-figure:;--tw-numeric-spacing:;--tw-numeric-fraction:;--tw-ring-inset:;--tw-ring-offset-width:0;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-backdrop-blur:;--tw-backdrop-brightness:;--tw-backdrop-contrast:;--tw-backdrop-grayscale:;--tw-backdrop-hue-rotate:;--tw-backdrop-invert:;--tw-backdrop-opacity:;--tw-backdrop-saturate:;--tw-backdrop-sepia:}::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x:;--tw-pan-y:;--tw-pinch-zoom:;--tw-scroll-snap-strictness:proximity;--tw-ordinal:;--tw-slashed-zero:;--tw-numeric-figure:;--tw-numeric-spacing:;--tw-numeric-fraction:;--tw-ring-inset:;--tw-ring-offset-width:0;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-backdrop-blur:;--tw-backdrop-brightness:;--tw-backdrop-contrast:;--tw-backdrop-grayscale:;--tw-backdrop-hue-rotate:;--tw-backdrop-invert:;--tw-backdrop-opacity:;--tw-backdrop-saturate:;--tw-backdrop-sepia:}.container{width:100%}@media(min-width:1024px){.container{max-width:1024px}}.a{border:var(--line-a-focus) solid transparent;border-radius:2px;color:var(--color-a-default);font-size:1em;padding:0 var(--spacer-a-px);margin:calc(-1 * var(--line-a-focus)) calc(-1 * (var(--spacer-a-px) + var(--line-a-focus)));text-decoration:none}.a:hover{color:var(--color-a-hover)}.a:visited:not(.no-visited),.a.visited:not(.no-visited){color:var(--color-a-visited)}.a:focus{border-color:var(--color-global-focus,transparent);outline:var(--line-a-outline-moz) dotted #212121;outline:var(--line-a-outline-wb) auto -webkit-focus-ring-color}.a:focus:not(:focus-visible){border-color:transparent}.button{background:var(--button-color-background);border-radius:999px;border:0;border:var(--button-border-width,0) solid var(--button-border-color,transparent);box-shadow:var(--button-shadow);box-sizing:border-box;color:var(--button-color-text);cursor:pointer;display:inline-block;font:var(--button-font);height:var(--button-height);line-height:calc(var(--button-height) - (2 * var(--button-border-width, 0px)));outline:0;overflow:hidden;padding:0 calc(var(--button-padding) - var(--button-border-width, 0px));text-align:center;text-decoration:none;text-overflow:ellipsis;white-space:nowrap;--button-border-color:var(--button-border-color-default);--button-border-width:var(--button-border-width-default);--button-color-background:var(--button-color-background-default);--button-color-text:var(--button-color-text-default)}.button .button-icon{margin-right:var(--spacer-xs)}.button .dropdown-icon{transform:rotate(0);transition:transform .2s ease-in-out}.button:focus,.button:hover{--button-color-overlay:var(--color-button-overlay-focus)}.button:hover{--button-border-color:var(--button-border-color-hover);--button-color-background:var(--button-color-background-hover)}.button:focus{--button-shadow:var(--elevation-button-focus)}.button:focus:not(:focus-visible){--button-shadow:0 0 0 var(--line-l) transparent}.button:active{--button-color-overlay:var(--color-button-overlay-active);--button-color-background:linear-gradient(var(--color-interactive-pressed),var(--color-interactive-pressed)),var(--button-color-background-active)}.button:disabled{--button-color-background:var(--button-color-background-disabled);--button-color-text:var(--button-color-text-disabled);cursor:not-allowed}.button.button-activated{--button-border-width:var(--button-border-width-activated);--button-color-background:var(--button-color-background-activated);--button-color-text:var(--button-color-text-activated)}.button.button-activated span.dropdown-icon{transform:rotate(180deg);transition:transform .22s ease-in-out}.button-shell{background:var(--button-color-background);border-radius:999px;border:0;border:var(--button-border-width,0) solid var(--button-border-color,transparent);box-shadow:var(--button-shadow);box-sizing:border-box;color:var(--button-color-text);cursor:pointer;display:inline-block;font:var(--button-font);height:var(--button-height);line-height:calc(var(--button-height) - (2 * var(--button-border-width, 0px)));outline:0;overflow:hidden;padding:0 calc(var(--button-padding) - var(--button-border-width, 0px));text-align:center;text-decoration:none;text-overflow:ellipsis;white-space:nowrap;--button-border-color:var(--button-border-color-default);--button-border-width:var(--button-border-width-default);--button-color-background:var(--button-color-background-default);--button-color-text:var(--button-color-text-default)}.button-large{--button-height:var(--size-button-lg-h);--button-padding:var(--spacer-xs);--button-font:var(--font-button-lg);--button-border-width-default:var(--line-button-lg-border);--button-border-width-activated:var(--line-button-border-activated)}.button-medium{--button-height:var(--size-button-md-h);--button-padding:var(--spacer-xs);--button-font:var(--font-button-md);--button-border-width-default:var(--line-button-md-border);--button-border-width-activated:var(--line-button-border-activated)}.button-small{--button-height:var(--size-button-sm-h);--button-padding:var(--spacer-2xs);--button-font:var(--font-button-sm);--button-border-width-default:var(--line-button-sm-border);--button-border-width-activated:var(--line-button-border-activated)}.button-primary{--button-color-background-default:var(--color-primary-background);--button-color-background-focus:var(--color-primary-background);--button-color-background-hover:var(--color-button-primary-background-hover);--button-color-background-active:linear-gradient(var(--color-button-primary-background-hover),var(--color-button-primary-background-hover));--button-color-background-disabled:var(--color-button-primary-background-disabled);--button-color-background-activated:var(--color-global-white);--button-color-text-default:var(--color-global-white);--button-color-text-disabled:var(--color-button-primary-text-disabled);--button-color-text-activated:var(--color-button-primary-text-activated);--button-border-color-default:transparent}.button-secondary{--button-color-background-default:var(--color-button-secondary-background);--button-color-background-focus:var(--color-button-secondary-background-focus);--button-color-background-hover:var(--color-button-secondary-background-hover);--button-color-background-active:linear-gradient(var(--color-button-secondary-background-hover),var(--color-button-secondary-background-hover));--button-color-background-disabled:var(--color-button-secondary-background-disabled);--button-color-background-activated:var(--color-button-secondary-background-activated);--button-color-text-default:var(--color-button-secondary-text);--button-color-text-disabled:var(--color-button-secondary-text-disabled);--button-color-text-activated:var(--color-button-secondary-text-activated);--button-border-color-default:var(--color-button-secondary-border)}.button-tertiary{--button-color-background-default:var(--color-button-tertiary-background);--button-color-background-focus:var(--color-button-tertiary-background-focus);--button-color-background-hover:var(--color-button-tertiary-background-hover);--button-color-background-disabled:var(--color-button-tertiary-background-disabled);--button-color-background-activated:var(--color-button-tertiary-background-activated);--button-color-text-default:var(--color-button-tertiary-text);--button-color-text-disabled:var(--color-button-tertiary-text-disabled);--button-color-text-activated:var(--color-button-tertiary-text-activated);--button-border-color-default:transparent}.button-plain{--button-color-background-default:transparent;--button-color-background-focus:transparent;--button-color-background-hover:var(--color-button-plain-background-hover);--button-color-background-disabled:var(--color-button-plain-background-disabled);--button-color-background-activated:var(--color-button-plain-background-activated);--button-color-background-active:linear-gradient(var(--color-button-secondary-background-hover),var(--color-button-secondary-background-hover));--button-color-text-default:var(--color-button-plain-text);--button-color-text-disabled:var(--color-button-plain-text-disabled);--button-color-text-activated:var(--color-button-plain-text-activated);--button-border-color-default:transparent}.button-outline{--button-color-background-default:transparent;--button-color-background-focus:transparent;--button-color-background-hover:transparent;--button-color-background-active:linear-gradient(transparent,transparent);--button-color-background-disabled:transparent;--button-color-background-activated:transparent;--button-color-text-default:var(--color-neutral-content);--button-color-text-disabled:var(--color-neutral-content-disabled);--button-color-text-activated:var(--color-neutral-content-strong);--button-border-color-default:var(--color-neutral-content-weak);--button-border-color-hover:var(--color-neutral-content-disabled);--button-border-color-active:var(--color-neutral-content);--button-border-color-activated:var(--color-neutral-content-strong);--button-border-color-disabled:var(--color-neutral-content-disabled);--button-border-width-default:var(--line-md);--button-border-width-activated:var(--line-md)}.button-destructive{--button-color-background-default:var(--color-danger-background);--button-color-background-focus:var(--color-danger-background-hover);--button-color-background-hover:var(--color-danger-background-hover);--button-color-background-active:linear-gradient(var(--color-danger-background-hover),var(--color-danger-background-hover));--button-color-background-disabled:var(--color-danger-background);--button-color-text-default:var(--color-danger-content-default);--button-color-text-disabled:var(--color-danger-content-default);--button-border-color-default:transparent;--button-border-color-hover:transparent;--button-border-color-active:transparent}.button-media{--button-color-background-default:var(--color-media-background);--button-color-background-focus:var(--color-media-background-hover);--button-color-background-hover:var(--color-media-background-hover);--button-color-background-active:linear-gradient(var(--color-media-background-hover),var(--color-media-background-hover));--button-color-text-default:white;--button-color-text-disabled:var(--color-media-onbackground-disabled);--button-color-background-disabled:var(--color-media-background)}.button-brand{--button-color-background-default:var(--color-brand-background);--button-color-background-hover:var(--color-brand-background-hover);--button-color-background-active:linear-gradient(var(--color-brand-background-hover),var(--color-brand-background-hover));--button-color-background-disabled:var(--color-interactive-background-disabled);--button-color-text-default:var(--color-danger-content-default);--button-color-text-disabled:var(--color-neutral-content-disabled);--button-border-color-default:transparent;--button-border-width-default:0}.button-success{--button-color-background-default:var(--color-success-background);--button-color-background-focus:var(--color-success-background-hover);--button-color-background-hover:var(--color-success-background-hover);--button-color-background-active:linear-gradient(var(--color-success-background-hover),var(--color-success-background-hover));--button-color-background-disabled:var(--color-button-primary-background-disabled);--button-color-text-default:var(--color-success-onBackground);--button-color-text-disabled:var(--color-button-primary-text-disabled);--button-border-color-default:transparent}.button-plain-inverted{--button-color-background-default:transparent;--button-color-background-focus:var(--color-neutral-content);--button-color-background-hover:var(--color-neutral-content);--button-color-background-active:var(--color-interactive-pressed);--button-color-background-disabled:transparent;--button-color-text-default:var(--color-neutral-background-weak);--button-color-text-disabled:var(--color-neutral-content);--button-border-color-default:transparent}.featured-avatar-xs{--featured-avatar-xs-size:var(--rem48);height:var(--featured-avatar-xs-size);width:var(--featured-avatar-xs-size)}.featured-avatar-sm{--featured-avatar-sm-size:var(--rem64);height:var(--featured-avatar-sm-size);width:var(--featured-avatar-sm-size)}.featured-avatar-md{--featured-avatar-md-size:var(--rem88);height:var(--featured-avatar-md-size);width:var(--featured-avatar-md-size)}.featured-avatar-lg{--featured-avatar-lg-size:var(--rem144);height:var(--featured-avatar-lg-size);width:var(--featured-avatar-lg-size)}.featured-avatar-xl{--featured-avatar-xl-size:var(--rem192);height:var(--featured-avatar-xl-size);width:var(--featured-avatar-xl-size)}.featured-avatar-2xl{--featured-avatar-2xl-size:var(--rem320);height:var(--featured-avatar-2xl-size);width:var(--featured-avatar-2xl-size)}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.static{position:static}.absolute{position:absolute}.relative{position:relative}.right-\\[8px\\]{right:8px}.top-0{top:0}.right-0{right:0}.-right-\\[0\\.0625rem\\]{right:-0.0625rem}.-right-\\[0\\.0825rem\\]{right:-0.0825rem}.-right-\\[0\\.125rem\\]{right:-0.125rem}.-right-\\[\\.65rem\\]{right:-.65rem}.-right-\\[\\.75rem\\]{right:-.75rem}.bottom-0{bottom:0}.isolate{isolation:isolate}.z-\\[2\\]{z-index:2}.z-\\[3\\]{z-index:3}.row-span-2{grid-row:span 2 / span 2}.m-0{margin:0}.mx-0{margin-left:0;margin-right:0}.my-2xs{margin-top:.25rem;margin-bottom:.25rem}.mx-2xs{margin-left:.25rem;margin-right:.25rem}.mx-xs{margin-left:.5rem;margin-right:.5rem}.mb-\\[var\\(--spacer-2xs\\)\\]{margin-bottom:var(--spacer-2xs)}.mb-\\[8px\\]{margin-bottom:8px}.mb-\\[20px\\]{margin-bottom:20px}.mt-\\[0\\.375rem\\]{margin-top:.375rem}.ml-\\[var\\(--spacer-2xs\\)\\]{margin-left:var(--spacer-2xs)}.ml-2xs{margin-left:.25rem}.mb-0{margin-bottom:0}.-ml-\\[var\\(--rem4\\)\\]{margin-left:calc(var(--rem4) * -1)}.-ml-\\[var\\(--rem6\\)\\]{margin-left:calc(var(--rem6) * -1)}.-ml-\\[var\\(--rem8\\)\\]{margin-left:calc(var(--rem8) * -1)}.-ml-\\[var\\(--rem10\\)\\]{margin-left:calc(var(--rem10) * -1)}.-ml-\\[var\\(--rem12\\)\\]{margin-left:calc(var(--rem12) * -1)}.-ml-\\[var\\(--rem14\\)\\]{margin-left:calc(var(--rem14) * -1)}.-ml-\\[var\\(--rem16\\)\\]{margin-left:calc(var(--rem16) * -1)}.-ml-\\[var\\(--rem18\\)\\]{margin-left:calc(var(--rem18) * -1)}.-ml-\\[var\\(--rem20\\)\\]{margin-left:calc(var(--rem20) * -1)}.mt-0{margin-top:0}.ml-0{margin-left:0}.mr-xs{margin-right:.5rem}.mr-\\[length\\:var\\(--rem6\\)\\]{margin-right:var(--rem6)}.mt-\\[-0\\.125rem\\]{margin-top:-0.125rem}.ml-\\[-\\.25rem\\]{margin-left:-.25rem}.mt-\\[-0\\.25rem\\]{margin-top:-0.25rem}.box-border{box-sizing:border-box}.block{display:block}.inline-block{display:inline-block}.flex{display:flex}.inline-flex{display:inline-flex}.grid{display:grid}.list-item{display:list-item}.hidden{display:none}.aspect-square{aspect-ratio:1 / 1}.h-full{height:100%}.h-100{height:100%}.h-\\[2\\.75rem\\]{height:2.75rem}.h-\\[1\\.3125rem\\]{height:1.3125rem}.h-\\[var\\(--size-xl\\)\\]{height:var(--size-xl)}.h-\\[14\\.5rem\\]{height:14.5rem}.h-\\[20px\\]{height:20px}.h-\\[2rem\\]{height:2rem}.h-\\[length\\:var\\(--size-button-md-h\\)\\]{height:var(--size-button-md-h)}.h-\\[1\\.75rem\\]{height:1.75rem}.h-\\[1\\.25rem\\]{height:1.25rem}.h-\\[1rem\\]{height:1rem}.h-\\[1\\.5rem\\]{height:1.5rem}.h-\\[2\\.5rem\\]{height:2.5rem}.h-\\[3rem\\]{height:3rem}.h-\\[2\\.87rem\\]{height:2.87rem}.h-\\[3\\.25rem\\]{height:3.25rem}.h-\\[4\\.5rem\\]{height:4.5rem}.h-\\[3\\.5rem\\]{height:3.5rem}.h-\\[4rem\\]{height:4rem}.h-\\[5\\.5rem\\]{height:5.5rem}.h-\\[\\.25rem\\]{height:.25rem}.h-\\[\\.375rem\\]{height:.375rem}.h-\\[\\.625rem\\]{height:.625rem}.h-2xl{height:3rem}.h-lg{height:1.5rem}.h-xs{height:.5rem}.min-h-\\[10rem\\]{min-height:10rem}.min-h-\\[1rem\\]{min-height:1rem}.w-full{width:100%}.w-100{width:100%}.w-\\[1\\.3125rem\\]{width:1.3125rem}.w-xl{width:2rem}.w-\\[var\\(--size-xl\\)\\]{width:var(--size-xl)}.w-\\[16rem\\]{width:16rem}.w-\\[13\\.25rem\\]{width:13.25rem}.w-\\[2rem\\]{width:2rem}.w-\\[400px\\]{width:400px}.w-\\[300px\\]{width:300px}.w-\\[150px\\]{width:150px}.w-\\[250px\\]{width:250px}.w-\\[200px\\]{width:200px}.w-auto{width:auto}.w-\\[1\\.25rem\\]{width:1.25rem}.w-\\[1rem\\]{width:1rem}.w-\\[1\\.5rem\\]{width:1.5rem}.w-\\[2\\.5rem\\]{width:2.5rem}.w-\\[3rem\\]{width:3rem}.w-\\[2\\.87rem\\]{width:2.87rem}.w-\\[3\\.25rem\\]{width:3.25rem}.w-\\[4\\.5rem\\]{width:4.5rem}.w-\\[3\\.5rem\\]{width:3.5rem}.w-\\[4rem\\]{width:4rem}.w-\\[5\\.5rem\\]{width:5.5rem}.w-\\[\\.25rem\\]{width:.25rem}.w-\\[\\.375rem\\]{width:.375rem}.w-\\[\\.625rem\\]{width:.625rem}.w-lg{width:1.5rem}.w-xs{width:.5rem}.min-w-\\[120px\\]{min-width:120px}.min-w-0{min-width:0}.min-w-\\[0\\.5rem\\]{min-width:.5rem}.max-w-\\[600px\\]{max-width:600px}.max-w-\\[480px\\]{max-width:480px}.flex-1{flex:1 1 0%}.shrink-0{flex-shrink:0}.flex-grow{flex-grow:1}.grow{flex-grow:1}.-translate-y-full{--tw-translate-y:-100%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes spin{to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite}.cursor-pointer{cursor:pointer}.cursor-wait{cursor:wait}.cursor-none{cursor:none}.cursor-default{cursor:default}.resize{resize:both}.list-none{list-style-type:none}.grid-cols-5{grid-template-columns:repeat(5,minmax(0,1fr))}.grid-cols-\\[min-content_1fr\\]{grid-template-columns:min-content 1fr}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.flex-nowrap{flex-wrap:nowrap}.items-center{align-items:center}.items-stretch{align-items:stretch}.justify-end{justify-content:flex-end}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.justify-items-center{justify-items:center}.gap-2xs{gap:.25rem}.gap-xs{gap:.5rem}.gap-\\[var\\(--spacer-sm\\)\\]{gap:var(--spacer-sm)}.gap-\\[var\\(--spacer-2xs\\)\\]{gap:var(--spacer-2xs)}.gap-sm{gap:.75rem}.gap-\\[0\\.375rem\\]{gap:.375rem}.gap-md{gap:1rem}.gap-\\[1rem\\]{gap:1rem}.gap-\\[length\\:var\\(--rem12\\)\\]{gap:var(--rem12)}.gap-x-sm{column-gap:.75rem}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.overflow-visible{overflow:visible}.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.rounded-full{border-radius:624.9375rem}.rounded-\\[\\.5rem\\]{border-radius:.5rem}.rounded-\\[0\\.5rem\\]{border-radius:.5rem}.rounded-\\[1\\.375rem\\]{border-radius:1.375rem}.rounded-\\[var\\(--radius-full\\)\\]{border-radius:var(--radius-full)}.rounded-lg{border-radius:2rem}.rounded-\\[0\\.875rem\\]{border-radius:.875rem}.rounded-sm{border-radius:.25rem}.border-0{border-width:0}.border-\\[1px\\]{border-width:1px}.border{border-width:.0625rem}.border-md{border-width:.125rem}.border-lg{border-width:.25rem}.border-b{border-bottom-width:.0625rem}.border-solid{border-style:solid}.border-none{border-style:none}.border-puregray-300{--tw-border-opacity:1;border-color:rgb(214 214 214 / var(--tw-border-opacity))}.border-neutral-border{border-color:var(--color-neutral-border)}.border-neutral-background{border-color:var(--color-neutral-background)}.border-secondary-background-selected{border-color:var(--color-secondary-background-selected)}.border-transparent{border-color:transparent}.border-action-upvote{border-color:var(--color-action-upvote)}.border-action-downvote{border-color:var(--color-action-downvote)}.border-b-tone-5{border-bottom-color:var(--color-tone-5)}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0 / var(--tw-bg-opacity))}.bg-tone-6{background-color:var(--color-tone-6)}.bg-transparent{background-color:transparent}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.bg-\\[color\\:var\\(--color-tone-6\\)\\]{background-color:var(--color-tone-6)}.bg-action-secondary{background-color:var(--color-action-secondary)}.bg-alienblue-100{--tw-bg-opacity:1;background-color:rgb(228 239 255 / var(--tw-bg-opacity))}.bg-neutral-background{background-color:var(--color-neutral-background)}.bg-online{background-color:var(--color-online)}.bg-secondary-background-selected{background-color:var(--color-secondary-background-selected)}.bg-warning-content{background-color:var(--color-warning-content)}.bg-success-content{background-color:var(--color-success-content)}.bg-neutral-content{background-color:var(--color-neutral-content)}.bg-global-orangered{background-color:var(--color-global-orangered)}.bg-danger-content{background-color:var(--color-danger-content)}.bg-neutral-content-disabled{background-color:var(--color-neutral-content-disabled)}.bg-brand-background{background-color:var(--color-brand-background)}.bg-brand-onBackground{background-color:var(--color-brand-onBackground)}.bg-action-upvote{background-color:var(--color-action-upvote)}.bg-action-downvote{background-color:var(--color-action-downvote)}.bg-interactive-background-disabled{background-color:var(--color-interactive-background-disabled)}.bg-\\[color\\:var\\(--color-button-plain-background-disabled\\)\\]{background-color:var(--color-button-plain-background-disabled)}.p-xs{padding:.5rem}.p-0{padding:0}.p-sm{padding:.75rem}.p-md{padding:1rem}.px-xs{padding-left:.5rem;padding-right:.5rem}.py-\\[var\\(--spacer-sm\\)\\]{padding-top:var(--spacer-sm);padding-bottom:var(--spacer-sm)}.px-\\[var\\(--spacer-xs\\)\\]{padding-left:var(--spacer-xs);padding-right:var(--spacer-xs)}.py-\\[0\\.375rem\\]{padding-top:.375rem;padding-bottom:.375rem}.px-sm{padding-left:.75rem;padding-right:.75rem}.py-xs{padding-top:.5rem;padding-bottom:.5rem}.py-\\[var\\(--spacer-2xs\\)\\]{padding-top:var(--spacer-2xs);padding-bottom:var(--spacer-2xs)}.px-\\[length\\:var\\(--rem10\\)\\]{padding-left:var(--rem10);padding-right:var(--rem10)}.px-\\[length\\:var\\(--rem6\\)\\]{padding-left:var(--rem6);padding-right:var(--rem6)}.px-\\[length\\:var\\(--rem14\\)\\]{padding-left:var(--rem14);padding-right:var(--rem14)}.px-\\[length\\:var\\(--rem8\\)\\]{padding-left:var(--rem8);padding-right:var(--rem8)}.px-\\[length\\:var\\(--rem12\\)\\]{padding-left:var(--rem12);padding-right:var(--rem12)}.px-md{padding-left:1rem;padding-right:1rem}.py-\\[length\\:var\\(--rem2\\)\\]{padding-top:var(--rem2);padding-bottom:var(--rem2)}.px-2xs{padding-left:.25rem;padding-right:.25rem}.py-\\[length\\:var\\(--rem8\\)\\]{padding-top:var(--rem8);padding-bottom:var(--rem8)}.py-\\[length\\:var\\(--rem10\\)\\]{padding-top:var(--rem10);padding-bottom:var(--rem10)}.py-\\[length\\:var\\(--rem14\\)\\]{padding-top:var(--rem14);padding-bottom:var(--rem14)}.pl-xs{padding-left:.5rem}.pl-\\[var\\(--spacer-md\\)\\]{padding-left:var(--spacer-md)}.pr-\\[var\\(--spacer-sm\\)\\]{padding-right:var(--spacer-sm)}.pt-xs{padding-top:.5rem}.pt-md{padding-top:1rem}.pl-md{padding-left:1rem}.pl-\\[length\\:var\\(--rem10\\)\\]{padding-left:var(--rem10)}.pr-\\[length\\:var\\(--rem14\\)\\]{padding-right:var(--rem14)}.pr-\\[length\\:var\\(--rem6\\)\\]{padding-right:var(--rem6)}.pl-\\[length\\:var\\(--rem14\\)\\]{padding-left:var(--rem14)}.pr-\\[length\\:var\\(--rem10\\)\\]{padding-right:var(--rem10)}.pb-md{padding-bottom:1rem}.pl-\\[0\\.125rem\\]{padding-left:.125rem}.pl-\\[length\\:var\\(--rem12\\)\\]{padding-left:var(--rem12)}.pr-\\[length\\:var\\(--rem12\\)\\]{padding-right:var(--rem12)}.pr-\\[length\\:var\\(--rem16\\)\\]{padding-right:var(--rem16)}.pr-\\[length\\:var\\(--rem8\\)\\]{padding-right:var(--rem8)}.pl-\\[length\\:var\\(--rem16\\)\\]{padding-left:var(--rem16)}.text-center{text-align:center}.align-text-bottom{vertical-align:text-bottom}.font-sans{font-family:var(--font-sans)}.text-\\[8px\\]{font-size:8px}.text-14{font-size:.875rem;line-height:1.25rem}.text-12{font-size:.75rem;line-height:1rem}.text-16{font-size:1rem;line-height:1.25rem}.text-18{font-size:1.125rem;line-height:1.5rem}.text-20{font-size:1.25rem;line-height:1.25rem}.text-24{font-size:1.5rem;line-height:1.75rem}.text-10{font-size:.625rem;line-height:1rem}.font-semibold{font-weight:600}.font-bold{font-weight:700}.uppercase{text-transform:uppercase}.leading-4{line-height:1rem}.leading-5{line-height:1.25rem}.leading-\\[0\\.875rem\\]{line-height:.875rem}.text-global-white{color:var(--color-global-white)}.text-tone-2{color:var(--color-tone-2)}.text-tone-7{color:var(--color-tone-7)}.text-action-secondary{color:var(--color-action-secondary)}.text-coolgray-450{--tw-text-opacity:1;color:rgb(130 149 155 / var(--tw-text-opacity))}.text-tone-1{color:var(--color-tone-1)}.text-neutral-content-weak{color:var(--color-neutral-content-weak)}.text-secondary-weak{color:var(--color-secondary-weak)}.text-secondary{color:var(--color-secondary)}.text-category-nsfw{color:var(--color-category-nsfw)}.text-primary{color:var(--color-primary)}.text-category-spoiler{color:var(--color-category-spoiler)}.text-warning-content{color:var(--color-warning-content)}.text-neutral-content-strong{color:var(--color-neutral-content-strong)}.text-primary-onBackground{color:var(--color-primary-onBackground)}.text-neutral-content{color:var(--color-neutral-content)}.text-danger-content{color:var(--color-danger-content)}.text-brand-onBackground{color:var(--color-brand-onBackground)}.text-neutral-content-disabled{color:var(--color-neutral-content-disabled)}.text-\\[color\\:var\\(--color-button-secondary-text-disabled\\)\\]{color:var(--color-button-secondary-text-disabled)}.text-\\[color\\:var\\(--color-button-plain-text-disabled\\)\\]{color:var(--color-button-plain-text-disabled)}.underline{text-decoration-line:underline}.no-underline{text-decoration-line:none}.opacity-50{opacity:.5}.opacity-60{opacity:.6}.opacity-40{opacity:.4}.shadow-sm{--tw-shadow:var(--elevation-sm);--tw-shadow-colored:var(--elevation-sm);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.outline{outline-style:solid}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(0.4,0,0.2,1);transition-duration:150ms}.hover\\:scale-125:hover{--tw-scale-x:1.25;--tw-scale-y:1.25;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.hover\\:border-secondary-background-selected:hover{border-color:var(--color-secondary-background-selected)}.hover\\:border-secondary-background-hover:hover{border-color:var(--color-secondary-background-hover)}.hover\\:bg-alienblue-200:hover{--tw-bg-opacity:1;background-color:rgb(198 220 255 / var(--tw-bg-opacity))}.hover\\:bg-secondary-background-selected:hover{background-color:var(--color-secondary-background-selected)}.hover\\:bg-secondary-background-hover:hover{background-color:var(--color-secondary-background-hover)}.hover\\:bg-transparent-background-hover:hover{background-color:var(--color-transparent-background-hover)}.hover\\:bg-brand-background-hover:hover{background-color:var(--color-brand-background-hover)}.hover\\:text-tone-1:hover{color:var(--color-tone-1)}.hover\\:text-secondary:hover{color:var(--color-secondary)}.hover\\:text-global-white:hover{color:var(--color-global-white)}.hover\\:text-action-upvote:hover{color:var(--color-action-upvote)}.hover\\:text-action-downvote:hover{color:var(--color-action-downvote)}.hover\\:underline:hover{text-decoration-line:underline}.hover\\:no-underline:hover{text-decoration-line:none}.focus\\:rounded-sm:focus{border-radius:.25rem}.focus\\:border-global-focus:focus{border-color:var(--color-global-focus)}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus-visible\\:text-action-upvote:focus-visible{color:var(--color-action-upvote)}.focus-visible\\:text-action-downvote:focus-visible{color:var(--color-action-downvote)}.active\\:bg-secondary-background:active{background-color:var(--color-secondary-background)}.disabled\\:text-interactive-content-disabled:disabled{color:var(--color-interactive-content-disabled)}@media(prefers-color-scheme:dark){.dark\\:border-solid{border-style:solid}.dark\\:border-\\[color\\:var\\(--color-tone-3\\)\\]{border-color:var(--color-tone-3)}.dark\\:bg-\\[color\\:var\\(--color-tone-5\\)\\]{background-color:var(--color-tone-5)}.dark\\:bg-\\[color\\:var\\(--color-tone-6\\)\\]{background-color:var(--color-tone-6)}.dark\\:bg-\\[color\\:var\\(--color-tone-2\\)\\]{background-color:var(--color-tone-2)}.dark\\:bg-alienblue-400\\/30{background-color:rgb(98 159 255 / .3)}.dark\\:text-tone-1{color:var(--color-tone-1)}.dark\\:text-\\[color\\:var\\(--color-tone-6\\)\\]{color:var(--color-tone-6)}.hover\\:dark\\:bg-alienblue-400\\/50:hover{background-color:rgb(98 159 255 / .5)}}`,
									oi = _t`:host{display:flex;flex-wrap:nowrap}.button{color:var(--color-tone-2)}`,
									si = class extends CustomEvent {
										constructor() {
											super("show-window-controls", {
												bubbles: !0,
												composed: !0,
												cancelable: !0
											})
										}
									},
									ai = class extends yr {
										constructor() {
											super(...arguments), this.shouldShowControls = !0
										}
										static get styles() {
											return [ii, oi]
										}
										handleMaximizeClick() {
											(function() {
												var e;
												null == (e = null == window ? void 0 : window.top) || e.postMessage("matrix-chat.maximize", "*")
											})(), window.open(location.href, "_blank")
										}
										connectedCallback() {
											super.connectedCallback();
											let e = new si;
											this.dispatchEvent(e), e.defaultPrevented && (this.shouldShowControls = !1)
										}
										render() {
											return this.shouldShowControls ? Qt`
      ${vn({appearance:"plain",size:an.Small,attributes:{type:"button",title:"Minimize chat",onclick:ri},leadingIcon:Qt` < icon - caret - down > < /icon-caret-down>`})}
											$ {
												vn({
													appearance: "plain",
													size: an.Small,
													attributes: {
														type: "button",
														title: "Open chat in new window",
														onclick: this.handleMaximizeClick
													},
													leadingIcon: Qt`<icon-external></icon-external>`
												})
											}
											$ {
												vn({
													appearance: "plain",
													size: an.Small,
													attributes: {
														type: "button",
														title: "Close chat",
														onclick: ti
													},
													leadingIcon: Qt`<icon-close></icon-close>`
												})
											}
											`:null}};v([Er()],ai.prototype,"shouldShowControls",2),ai=v([_r("rs-app-window-controls")],ai);var ci=({title:e,buttons:t,noBorder:r,leadingContent:n,hidden:i})=>{let o={"border-solid border-0 border-b border-b-tone-5":Boolean(!r),hidden:Boolean(i)};return Qt` <
											header
											class = "flex items-center h-[2.75rem] w-full px-xs gap-2xs box-border ${Fr(o)}" >
												$ {
													n
												} <
												span class = "flex-1 text-14 font-sans font-semibold pl-xs" > $ {
													e
												} < /span> <
												div class = "flex flex-nowrap" >
												$ {
													t
												} <
												rs - app - window - controls > < /rs-app-window-controls> <
												/div> <
												/header>
											`};function li(e){let[t,r]=e.split("/");return"image"===t&&["jpeg","png","gif"].includes(r.toLowerCase())}async function ui(e,t,r){let n=e.getUserId(),i=e.getRoom(t);if(!i||!n||!li(r.type))return;let o,s=e.makeTxnId(),a=await async function(e){return new Promise(t=>{let r=new FileReader;r.onload=()=>{let n=new Image;n.src=r.result,n.onload=()=>{t({w:n.width,h:n.height,mimetype:e.type,size:e.size})},n.onerror=()=>{t(void 0)}},r.onerror=()=>{t(void 0)},r.readAsDataURL(e)})}(r),c={msgtype:Gr.Image,body:"Image",url:"",info:a,file:r},l=new Hr({type:Vr.RoomMessage,content:c,event_id:"~"+t+":"+s,user_id:n,sender:n,room_id:t,origin_server_ts:(new Date).getTime(),txn_id:s});l.setStatus(zr.SENDING),i.addPendingEvent(l,s);try{o=await e.uploadContent(r)}catch(p){return l.error=p,void i.updatePendingEvent(l,zr.NOT_SENT)}c.url=o.content_uri;let u=e.makeTxnId(),d=e.sendMessage(t,{msgtype:c.msgtype,body:c.body,url:c.url,info:c.info},u),h=i.getEventForTxnId(u).getId();h&&i.removeEvent(h);let f=await d;return i.removeEvent(f.event_id),i.updatePendingEvent(l,zr.SENT,f.event_id),f.event_id}function di(e){return e.file&&e.file instanceof File}function hi(e,t,r=!0){return new CustomEvent(e,{composed:!0,bubbles:r,cancelable:!0,detail:t})}p(w());function fi(e,t){let r=hi("track-event",{details:t});e.dispatchEvent(r)}var pi,vi=new Uint8Array(16);function gi(){if(!pi&&!(pi=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return pi(vi)}var mi=[];for(let r=0;r<256;++r)mi.push((r+256).toString(16).slice(1));var yi={randomUUID:typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};var bi=function(e,t,r){if(yi.randomUUID&&!t&&!e)return yi.randomUUID();let n=(e=e||{}).random||(e.rng||gi)();if(n[6]=15&n[6]|64,n[8]=63&n[8]|128,t){r=r||0;for(let e=0;e<16;++e)t[r+e]=n[e];return t}return function(e,t=0){return(mi[e[t+0]]+mi[e[t+1]]+mi[e[t+2]]+mi[e[t+3]]+"-"+mi[e[t+4]]+mi[e[t+5]]+"-"+mi[e[t+6]]+mi[e[t+7]]+"-"+mi[e[t+8]]+mi[e[t+9]]+"-"+mi[e[t+10]]+mi[e[t+11]]+mi[e[t+12]]+mi[e[t+13]]+mi[e[t+14]]+mi[e[t+15]]).toLowerCase()}(n)},_i=p(w()),wi={app:{name:"web2x"}},Si=()=>{let e=_i.default.get("session_tracker");if(e)return{id:e.split(".")[0]}},Ei=()=>({client_timestamp:Date.now(),...wi,session:Si()}),ki=({source:e,action:t,noun:r},n={})=>({source:e,action:t,noun:r,uuid:bi(),...Ei(),...n}),Ti=e=>ki({source:"chat_view",action:"submit",noun:"chat_message"},{chat:e}),Ii=e=>ki({source:"chat_view",action:"submit",noun:"chat_message"},{chat:{message_type:"reaction"},action_info:{type:e,reason:"reaction"}}),Ri=e=>ki({source:"chat",action:"delete",noun:"message"},{chat:{message_type:"reaction"},action_info:{type:e,reason:"reaction"}}),Ci=(Zn("icon-settings",Jt`
											$ {
												Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_473_79)"><path d="M10 20c-.401 0-.802-.027-1.2-.079a1.145 1.145 0 01-.992-1.137v-1.073a.97.97 0 00-.627-.878A.98.98 0 006.1 17l-.755.753a1.149 1.149 0 01-1.521.1 10.16 10.16 0 01-1.671-1.671 1.149 1.149 0 01.1-1.523L3 13.906a.97.97 0 00.176-1.069.98.98 0 00-.887-.649H1.216A1.145 1.145 0 01.079 11.2a9.1 9.1 0 010-2.393 1.145 1.145 0 011.137-.992h1.073a.97.97 0 00.878-.627A.979.979 0 003 6.1l-.754-.754a1.15 1.15 0 01-.1-1.522 10.16 10.16 0 011.673-1.676 1.155 1.155 0 011.522.1L6.1 3a.966.966 0 001.068.176.98.98 0 00.649-.887V1.216A1.145 1.145 0 018.8.079a9.129 9.129 0 012.393 0 1.144 1.144 0 01.991 1.137v1.073a.971.971 0 00.628.878A.977.977 0 0013.905 3l.754-.754a1.152 1.152 0 011.522-.1c.62.49 1.18 1.05 1.671 1.671a1.15 1.15 0 01-.1 1.522L17 6.1a.967.967 0 00-.176 1.068.98.98 0 00.887.649h1.073a1.145 1.145 0 011.137.991 9.096 9.096 0 010 2.392 1.145 1.145 0 01-1.137.992h-1.073A1.041 1.041 0 0017 13.905l.753.755a1.149 1.149 0 01.1 1.521c-.49.62-1.05 1.18-1.671 1.671a1.149 1.149 0 01-1.522-.1L13.906 17a.97.97 0 00-1.069-.176.981.981 0 00-.65.887v1.073a1.144 1.144 0 01-.99 1.137A9.431 9.431 0 0110 20zm-.938-1.307a7.638 7.638 0 001.875 0v-.982a2.292 2.292 0 013.853-1.6l.693.694a8.796 8.796 0 001.326-1.326l-.694-.694a2.29 2.29 0 011.6-3.851h.982a7.746 7.746 0 000-1.876h-.982a2.213 2.213 0 01-2.034-1.4 2.223 2.223 0 01.438-2.451l.694-.693a8.76 8.76 0 00-1.327-1.326l-.692.694a2.219 2.219 0 01-2.434.445 2.221 2.221 0 01-1.419-2.041v-.979a7.638 7.638 0 00-1.875 0v.982a2.213 2.213 0 01-1.4 2.034 2.23 2.23 0 01-2.456-.438l-.693-.694a8.757 8.757 0 00-1.326 1.327l.694.692a2.216 2.216 0 01.445 2.434 2.22 2.22 0 01-2.041 1.418h-.982a7.746 7.746 0 000 1.876h.982a2.213 2.213 0 012.034 1.4 2.223 2.223 0 01-.438 2.451l-.694.693c.394.488.838.933 1.326 1.326l.694-.694a2.218 2.218 0 012.433-.445 2.22 2.22 0 011.418 2.041v.983zM10 13.229a3.23 3.23 0 110-6.458 3.23 3.23 0 010 6.458zm0-5.208a1.979 1.979 0 100 3.958 1.979 1.979 0 000-3.958z"/></g><defs><clipPath id="clip0_473_79"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
											}
											`,Jt`
											$ {
												Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_473_76)"><path d="M19.921 8.8a1.145 1.145 0 00-1.137-.991h-1.073a.98.98 0 01-.887-.649A.969.969 0 0117 6.1l.754-.754a1.15 1.15 0 00.1-1.522 10.16 10.16 0 00-1.671-1.671 1.152 1.152 0 00-1.522.1L13.905 3a.975.975 0 01-1.09.167.97.97 0 01-.628-.878V1.216A1.144 1.144 0 0011.2.079a9.129 9.129 0 00-2.4 0 1.145 1.145 0 00-.991 1.137v1.073a.98.98 0 01-.649.887A.966.966 0 016.1 3l-.754-.754a1.152 1.152 0 00-1.522-.1 10.16 10.16 0 00-1.676 1.673 1.15 1.15 0 00.1 1.522L3 6.1a.979.979 0 01.167 1.09.97.97 0 01-.878.627H1.216A1.145 1.145 0 00.079 8.8a9.1 9.1 0 000 2.393 1.145 1.145 0 001.137.991h1.073a.98.98 0 01.887.649A.97.97 0 013 13.906l-.751.752a1.149 1.149 0 00-.1 1.523c.49.62 1.05 1.18 1.671 1.671a1.148 1.148 0 001.521-.1L6.1 17a.98.98 0 011.09-.167.97.97 0 01.627.878v1.073a1.145 1.145 0 00.983 1.137 9.103 9.103 0 002.393 0 1.144 1.144 0 00.99-1.137v-1.073a.981.981 0 01.65-.887.968.968 0 011.073.176l.753.753a1.149 1.149 0 001.522.1c.62-.49 1.18-1.05 1.671-1.671a1.149 1.149 0 00-.1-1.521L17 13.905a1.04 1.04 0 01.711-1.717h1.073a1.145 1.145 0 001.137-.992 9.096 9.096 0 000-2.392V8.8zM11.979 10a1.98 1.98 0 11-3.958 0 1.98 1.98 0 013.958 0z"/></g><defs><clipPath id="clip0_473_76"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
											}
											`),_t`: host {
												height: var (--size - md);border - radius: var (--size - md);background - color: var (--color - tone - 5);display: inline - block
											}: host([shimmer]) {
												position: relative;overflow: hidden;background - image: linear - gradient(to right,
													var (--color - tone - 5) calc(50 % -100 px),
													var (--color - tone - 4) 50 % ,
													var (--color - tone - 5) calc(50 % +100 px));background - size: 0
											}: host([shimmer]): before {
												content: "";position: absolute;top: 0;right: 0;bottom: 0;width: calc(200 % +200 px);background - image: inherit;animation: shimmer 2 s linear infinite
											}
											@keyframes shimmer {
												to {
													transform: translateX(calc(50 % +100 px))
												}
											}
											`),Mi=class extends yr{constructor(){super(...arguments),this.shimmer=!1}static get styles(){return[Ci]}};v([Sr({type:Boolean})],Mi.prototype,"shimmer",2),Mi=v([_r("rs-skeleton")],Mi);var xi="millisecond",Oi="second",Ai="minute",Pi="hour",Di="day",ji="week",Li="month",Ni="quarter",Bi="year",Ui="date",Fi="Invalid Date",$i=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,qi=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,Ki={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},Vi=function(e,t,r){var n=String(e);return!n||n.length>=t?e:""+Array(t+1-n.length).join(r)+e},zi={s:Vi,z:function(e){var t=-e.utcOffset(),r=Math.abs(t),n=Math.floor(r/60),i=r%60;return(t<=0?"+":"-")+Vi(n,2,"0")+":"+Vi(i,2,"0")},m:function e(t,r){if(t.date()<r.date())return-e(r,t);var n=12*(r.year()-t.year())+(r.month()-t.month()),i=t.clone().add(n,Li),o=r-i<0,s=t.clone().add(n+(o?-1:1),Li);return+(-(n+(r-i)/(o?i-s:s-i))||0)},a:function(e){return e<0?Math.ceil(e)||0:Math.floor(e)},p:function(e){return{M:Li,y:Bi,w:ji,d:Di,D:Ui,h:Pi,m:Ai,s:Oi,ms:xi,Q:Ni}[e]||String(e||"").toLowerCase().replace(/s$/,"")},u:function(e){return void 0===e}},Hi="en",Wi={};Wi[Hi]=Ki;var Gi=function(e){return e instanceof Xi},Yi=function e(t,r,n){var i;if(!t)return Hi;if("string"==typeof t){var o=t.toLowerCase();Wi[o]&&(i=o),r&&(Wi[o]=r,i=o);var s=t.split("-");if(!i&&s.length>1)return e(s[0])}else{var a=t.name;Wi[a]=t,i=a}return!n&&i&&(Hi=i),i||!n&&Hi},Qi=function(e,t){if(Gi(e))return e.clone();var r="object"==typeof t?t:{};return r.date=e,r.args=arguments,new Xi(r)},Ji=zi;Ji.l=Yi,Ji.i=Gi,Ji.w=function(e,t){return Qi(e,{locale:t.$L,utc:t.$u,x:t.$x,$offset:t.$offset})};var Xi=function(){function e(e){this.$L=Yi(e.locale,null,!0),this.parse(e)}var t=e.prototype;return t.parse=function(e){this.$d=function(e){var t=e.date,r=e.utc;if(null===t)return new Date(NaN);if(Ji.u(t))return new Date;if(t instanceof Date)return new Date(t);if("string"==typeof t&&!/Z$/i.test(t)){var n=t.match($i);if(n){var i=n[2]-1||0,o=(n[7]||"0").substring(0,3);return r?new Date(Date.UTC(n[1],i,n[3]||1,n[4]||0,n[5]||0,n[6]||0,o)):new Date(n[1],i,n[3]||1,n[4]||0,n[5]||0,n[6]||0,o)}}return new Date(t)}(e),this.$x=e.x||{},this.init()},t.init=function(){var e=this.$d;this.$y=e.getFullYear(),this.$M=e.getMonth(),this.$D=e.getDate(),this.$W=e.getDay(),this.$H=e.getHours(),this.$m=e.getMinutes(),this.$s=e.getSeconds(),this.$ms=e.getMilliseconds()},t.$utils=function(){return Ji},t.isValid=function(){return this.$d.toString()!==Fi},t.isSame=function(e,t){var r=Qi(e);return this.startOf(t)<=r&&r<=this.endOf(t)},t.isAfter=function(e,t){return Qi(e)<this.startOf(t)},t.isBefore=function(e,t){return this.endOf(t)<Qi(e)},t.$g=function(e,t,r){return Ji.u(e)?this[t]:this.set(r,e)},t.unix=function(){return Math.floor(this.valueOf()/1e3)},t.valueOf=function(){return this.$d.getTime()},t.startOf=function(e,t){var r=this,n=!!Ji.u(t)||t,i=Ji.p(e),o=function(e,t){var i=Ji.w(r.$u?Date.UTC(r.$y,t,e):new Date(r.$y,t,e),r);return n?i:i.endOf(Di)},s=function(e,t){return Ji.w(r.toDate()[e].apply(r.toDate("s"),(n?[0,0,0,0]:[23,59,59,999]).slice(t)),r)},a=this.$W,c=this.$M,l=this.$D,u="set"+(this.$u?"UTC":"");switch(i){case Bi:return n?o(1,0):o(31,11);case Li:return n?o(1,c):o(0,c+1);case ji:var d=this.$locale().weekStart||0,h=(a<d?a+7:a)-d;return o(n?l-h:l+(6-h),c);case Di:case Ui:return s(u+"Hours",0);case Pi:return s(u+"Minutes",1);case Ai:return s(u+"Seconds",2);case Oi:return s(u+"Milliseconds",3);default:return this.clone()}},t.endOf=function(e){return this.startOf(e,!1)},t.$set=function(e,t){var r,n=Ji.p(e),i="set"+(this.$u?"UTC":""),o=(r={},r[Di]=i+"Date",r[Ui]=i+"Date",r[Li]=i+"Month",r[Bi]=i+"FullYear",r[Pi]=i+"Hours",r[Ai]=i+"Minutes",r[Oi]=i+"Seconds",r[xi]=i+"Milliseconds",r)[n],s=n===Di?this.$D+(t-this.$W):t;if(n===Li||n===Bi){var a=this.clone().set(Ui,1);a.$d[o](s),a.init(),this.$d=a.set(Ui,Math.min(this.$D,a.daysInMonth())).$d}else o&&this.$d[o](s);return this.init(),this},t.set=function(e,t){return this.clone().$set(e,t)},t.get=function(e){return this[Ji.p(e)]()},t.add=function(e,t){var r,n=this;e=Number(e);var i=Ji.p(t),o=function(t){var r=Qi(n);return Ji.w(r.date(r.date()+Math.round(t*e)),n)};if(i===Li)return this.set(Li,this.$M+e);if(i===Bi)return this.set(Bi,this.$y+e);if(i===Di)return o(1);if(i===ji)return o(7);var s=(r={},r[Ai]=6e4,r[Pi]=36e5,r[Oi]=1e3,r)[i]||1,a=this.$d.getTime()+e*s;return Ji.w(a,this)},t.subtract=function(e,t){return this.add(-1*e,t)},t.format=function(e){var t=this,r=this.$locale();if(!this.isValid())return r.invalidDate||Fi;var n=e||"YYYY-MM-DDTHH:mm:ssZ",i=Ji.z(this),o=this.$H,s=this.$m,a=this.$M,c=r.weekdays,l=r.months,u=function(e,r,i,o){return e&&(e[r]||e(t,n))||i[r].slice(0,o)},d=function(e){return Ji.s(o%12||12,e,"0")},h=r.meridiem||function(e,t,r){var n=e<12?"AM":"PM";return r?n.toLowerCase():n},f={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:Ji.s(a+1,2,"0"),MMM:u(r.monthsShort,a,l,3),MMMM:u(l,a),D:this.$D,DD:Ji.s(this.$D,2,"0"),d:String(this.$W),dd:u(r.weekdaysMin,this.$W,c,2),ddd:u(r.weekdaysShort,this.$W,c,3),dddd:c[this.$W],H:String(o),HH:Ji.s(o,2,"0"),h:d(1),hh:d(2),a:h(o,s,!0),A:h(o,s,!1),m:String(s),mm:Ji.s(s,2,"0"),s:String(this.$s),ss:Ji.s(this.$s,2,"0"),SSS:Ji.s(this.$ms,3,"0"),Z:i};return n.replace(qi,(function(e,t){return t||f[e]||i.replace(":","")}))},t.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},t.diff=function(e,t,r){var n,i=Ji.p(t),o=Qi(e),s=6e4*(o.utcOffset()-this.utcOffset()),a=this-o,c=Ji.m(this,o);return c=(n={},n[Bi]=c/12,n[Li]=c,n[Ni]=c/3,n[ji]=(a-s)/6048e5,n[Di]=(a-s)/864e5,n[Pi]=a/36e5,n[Ai]=a/6e4,n[Oi]=a/1e3,n)[i]||a,r?c:Ji.a(c)},t.daysInMonth=function(){return this.endOf(Li).$D},t.$locale=function(){return Wi[this.$L]},t.locale=function(e,t){if(!e)return this.$L;var r=this.clone(),n=Yi(e,t,!0);return n&&(r.$L=n),r},t.clone=function(){return Ji.w(this.$d,this)},t.toDate=function(){return new Date(this.valueOf())},t.toJSON=function(){return this.isValid()?this.toISOString():null},t.toISOString=function(){return this.$d.toISOString()},t.toString=function(){return this.$d.toUTCString()},e}(),Zi=Xi.prototype;Qi.prototype=Zi,[["$ms",xi],["$s",Oi],["$m",Ai],["$H",Pi],["$W",Di],["$M",Li],["$y",Bi],["$D",Ui]].forEach((function(e){Zi[e[1]]=function(t){return this.$g(t,e[0],e[1])}})),Qi.extend=function(e,t){return e.$i||(e(t,Xi,Qi),e.$i=!0),Qi},Qi.locale=Yi,Qi.isDayjs=Gi,Qi.unix=function(e){return Qi(1e3*e)},Qi.en=Wi[Hi],Qi.Ls=Wi,Qi.p={};var eo=Qi,{H:to}=gr,ro=()=>document.createComment(""),no=(e,t,r)=>{var n;let i=e._$AA.parentNode,o=void 0===t?e._$AB:t._$AA;if(void 0===r){let t=i.insertBefore(ro(),o),n=i.insertBefore(ro(),o);r=new to(t,n,e,e.options)}else{let t=r._$AB.nextSibling,s=r._$AM,a=s!==e;if(a){let t;null===(n=r._$AQ)||void 0===n||n.call(r,e),r._$AM=e,void 0!==r._$AP&&(t=e._$AU)!==s._$AU&&r._$AP(t)}if(t!==o||a){let e=r._$AA;for(;e!==t;){let t=e.nextSibling;i.insertBefore(e,o),e=t}}}return r},io=(e,t,r=e)=>(e._$AI(t,r),e),oo={},so=e=>{var t;null===(t=e._$AP)||void 0===t||t.call(e,!1,!0);let r=e._$AA,n=e._$AB.nextSibling;for(;r!==n;){let e=r.nextSibling;r.remove(),r=e}},ao=(e,t,r)=>{let n=new Map;for(let i=t;i<=r;i++)n.set(e[i],i);return n},co=Br(class extends Ur{constructor(e){if(super(e),e.type!==Lr)throw Error("repeat() can only be used in text expressions")}ht(e,t,r){let n;void 0===r?r=t:void 0!==t&&(n=t);let i=[],o=[],s=0;for(let a of e)i[s]=n?n(a,s):s,o[s]=r(a,s),s++;return{values:o,keys:i}}render(e,t,r){return this.ht(e,t,r).values}update(e,[t,r,n]){var i;let o=(e=>e._$AH)(e),{values:s,keys:a}=this.ht(t,r,n);if(!Array.isArray(o))return this.ut=a,s;let c,l,u=null!==(i=this.ut)&&void 0!==i?i:this.ut=[],d=[],h=0,f=o.length-1,p=0,v=s.length-1;for(;h<=f&&p<=v;)if(null===o[h])h++;else if(null===o[f])f--;else if(u[h]===a[p])d[p]=io(o[h],s[p]),h++,p++;else if(u[f]===a[v])d[v]=io(o[f],s[v]),f--,v--;else if(u[h]===a[v])d[v]=io(o[h],s[v]),no(e,d[v+1],o[h]),h++,v--;else if(u[f]===a[p])d[p]=io(o[f],s[p]),no(e,o[h],o[f]),f--,p++;else if(void 0===c&&(c=ao(a,p,v),l=ao(u,h,f)),c.has(u[h]))if(c.has(u[f])){let t=l.get(a[p]),r=void 0!==t?o[t]:null;if(null===r){let t=no(e,o[h]);io(t,s[p]),d[p]=t}else d[p]=io(r,s[p]),no(e,o[h],r),o[t]=null;p++}else so(o[f]),f--;else so(o[h]),h++;for(;p<=v;){let t=no(e,d[v+1]);io(t,s[p]),d[p++]=t}for(;h<=f;){let e=o[h++];null!==e&&so(e)}return this.ut=a,((e,t=oo)=>e._$AH=t)(e,d),Xt}}),lo="object"==typeof e&&e&&e.Object===Object&&e,uo="object"==typeof self&&self&&self.Object===Object&&self,ho=lo||uo||Function("return this")(),fo=ho.Symbol,po=Object.prototype,vo=po.hasOwnProperty,go=po.toString,mo=fo?fo.toStringTag:void 0;var yo=function(e){var t=vo.call(e,mo),r=e[mo];try{e[mo]=void 0;var n=!0}catch{}var i=go.call(e);return n&&(t?e[mo]=r:delete e[mo]),i},bo=Object.prototype.toString;var _o=function(e){return bo.call(e)},wo="[object Null]",So="[object Undefined]",Eo=fo?fo.toStringTag:void 0;var ko=function(e){return null==e?void 0===e?So:wo:Eo&&Eo in Object(e)?yo(e):_o(e)};var To=function(e){return null!=e&&"object"==typeof e},Io="[object Symbol]";var Ro=function(e){return"symbol"==typeof e||To(e)&&ko(e)==Io};var Co=function(e,t){for(var r=-1,n=null==e?0:e.length,i=Array(n);++r<n;)i[r]=t(e[r],r,e);return i},Mo=Array.isArray,xo=1/0,Oo=fo?fo.prototype:void 0,Ao=Oo?Oo.toString:void 0;var Po=function e(t){if("string"==typeof t)return t;if(Mo(t))return Co(t,e)+"";if(Ro(t))return Ao?Ao.call(t):"";var r=t+"";return"0"==r&&1/t==-xo?"-0":r},Do=/\s/;var jo=function(e){for(var t=e.length;t--&&Do.test(e.charAt(t)););return t},Lo=/^\s+/;var No=function(e){return e&&e.slice(0,jo(e)+1).replace(Lo,"")};var Bo=function(e){var t=typeof e;return null!=e&&("object"==t||"function"==t)},Uo=NaN,Fo=/^[-+]0x[0-9a-f]+$/i,$o=/^0b[01]+$/i,qo=/^0o[0-7]+$/i,Ko=parseInt;var Vo=function(e){if("number"==typeof e)return e;if(Ro(e))return Uo;if(Bo(e)){var t="function"==typeof e.valueOf?e.valueOf():e;e=Bo(t)?t+"":t}if("string"!=typeof e)return 0===e?e:+e;e=No(e);var r=$o.test(e);return r||qo.test(e)?Ko(e.slice(2),r?2:8):Fo.test(e)?Uo:+e},zo="[object AsyncFunction]",Ho="[object Function]",Wo="[object GeneratorFunction]",Go="[object Proxy]";var Yo=function(e){if(!Bo(e))return!1;var t=ko(e);return t==Ho||t==Wo||t==zo||t==Go},Qo=ho["__core-js_shared__"],Jo=function(){var e=/[^.]+$/.exec(Qo&&Qo.keys&&Qo.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}();var Xo=function(e){return!!Jo&&Jo in e},Zo=Function.prototype.toString;var es=function(e){if(null!=e){try{return Zo.call(e)}catch{}try{return e+""}catch{}}return""},ts=/^\[object .+?Constructor\]$/,rs=Function.prototype,ns=Object.prototype,is=rs.toString,os=ns.hasOwnProperty,ss=RegExp("^"+is.call(os).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");var as=function(e){return!(!Bo(e)||Xo(e))&&(Yo(e)?ss:ts).test(es(e))};var cs=function(e,t){return null==e?void 0:e[t]};var ls=function(e,t){var r=cs(e,t);return as(r)?r:void 0},us=function(){try{var e=ls(Object,"defineProperty");return e({},"",{}),e}catch{}}(),ds=9007199254740991,hs=/^(?:0|[1-9]\d*)$/;var fs=function(e,t){var r=typeof e;return!!(t=null==t?ds:t)&&("number"==r||"symbol"!=r&&hs.test(e))&&e>-1&&e%1==0&&e<t};var ps=function(e,t,r){"__proto__"==t&&us?us(e,t,{configurable:!0,enumerable:!0,value:r,writable:!0}):e[t]=r};var vs=function(e,t){return e===t||e!=e&&t!=t},gs=Object.prototype.hasOwnProperty;var ms=function(e,t,r){var n=e[t];(!gs.call(e,t)||!vs(n,r)||void 0===r&&!(t in e))&&ps(e,t,r)},ys=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,bs=/^\w*$/;var _s=function(e,t){if(Mo(e))return!1;var r=typeof e;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=e&&!Ro(e))||(bs.test(e)||!ys.test(e)||null!=t&&e in Object(t))},ws=ls(Object,"create");var Ss=function(){this.__data__=ws?ws(null):{},this.size=0};var Es=function(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t},ks="__lodash_hash_undefined__",Ts=Object.prototype.hasOwnProperty;var Is=function(e){var t=this.__data__;if(ws){var r=t[e];return r===ks?void 0:r}return Ts.call(t,e)?t[e]:void 0},Rs=Object.prototype.hasOwnProperty;var Cs=function(e){var t=this.__data__;return ws?void 0!==t[e]:Rs.call(t,e)},Ms="__lodash_hash_undefined__";var xs=function(e,t){var r=this.__data__;return this.size+=this.has(e)?0:1,r[e]=ws&&void 0===t?Ms:t,this};function Os(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}Os.prototype.clear=Ss,Os.prototype.delete=Es,Os.prototype.get=Is,Os.prototype.has=Cs,Os.prototype.set=xs;var As=Os;var Ps=function(){this.__data__=[],this.size=0};var Ds=function(e,t){for(var r=e.length;r--;)if(vs(e[r][0],t))return r;return-1},js=Array.prototype.splice;var Ls=function(e){var t=this.__data__,r=Ds(t,e);return!(r<0)&&(r==t.length-1?t.pop():js.call(t,r,1),--this.size,!0)};var Ns=function(e){var t=this.__data__,r=Ds(t,e);return r<0?void 0:t[r][1]};var Bs=function(e){return Ds(this.__data__,e)>-1};var Us=function(e,t){var r=this.__data__,n=Ds(r,e);return n<0?(++this.size,r.push([e,t])):r[n][1]=t,this};function Fs(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}Fs.prototype.clear=Ps,Fs.prototype.delete=Ls,Fs.prototype.get=Ns,Fs.prototype.has=Bs,Fs.prototype.set=Us;var $s=Fs,qs=ls(ho,"Map");var Ks=function(){this.size=0,this.__data__={hash:new As,map:new(qs||$s),string:new As}};var Vs=function(e){var t=typeof e;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==e:null===e};var zs=function(e,t){var r=e.__data__;return Vs(t)?r["string"==typeof t?"string":"hash"]:r.map};var Hs=function(e){var t=zs(this,e).delete(e);return this.size-=t?1:0,t};var Ws=function(e){return zs(this,e).get(e)};var Gs=function(e){return zs(this,e).has(e)};var Ys=function(e,t){var r=zs(this,e),n=r.size;return r.set(e,t),this.size+=r.size==n?0:1,this};function Qs(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}Qs.prototype.clear=Ks,Qs.prototype.delete=Hs,Qs.prototype.get=Ws,Qs.prototype.has=Gs,Qs.prototype.set=Ys;var Js=Qs,Xs="Expected a function";function Zs(e,t){if("function"!=typeof e||null!=t&&"function"!=typeof t)throw new TypeError(Xs);var r=function(){var n=arguments,i=t?t.apply(this,n):n[0],o=r.cache;if(o.has(i))return o.get(i);var s=e.apply(this,n);return r.cache=o.set(i,s)||o,s};return r.cache=new(Zs.Cache||Js),r}Zs.Cache=Js;var ea=Zs,ta=500;var ra=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,na=/\\(\\)?/g,ia=function(e){var t=ea(e,(function(e){return r.size===ta&&r.clear(),e})),r=t.cache;return t}((function(e){var t=[];return 46===e.charCodeAt(0)&&t.push(""),e.replace(ra,(function(e,r,n,i){t.push(n?i.replace(na,"$1"):r||e)})),t}));var oa=function(e){return null==e?"":Po(e)};var sa=function(e,t){return Mo(e)?e:_s(e,t)?[e]:ia(oa(e))},aa=1/0;var ca=function(e){if("string"==typeof e||Ro(e))return e;var t=e+"";return"0"==t&&1/e==-aa?"-0":t};var la=function(e,t){for(var r=0,n=(t=sa(t,e)).length;null!=e&&r<n;)e=e[ca(t[r++])];return r&&r==n?e:void 0};var ua=function(e,t,r){var n=null==e?void 0:la(e,t);return void 0===n?r:n},da=function(){return ho.Date.now()},ha="Expected a function",fa=Math.max,pa=Math.min;var va=function(e,t,r){var n,i,o,s,a,c,l=0,u=!1,d=!1,h=!0;if("function"!=typeof e)throw new TypeError(ha);function f(t){var r=n,o=i;return n=i=void 0,l=t,s=e.apply(o,r)}function p(e){var r=e-c;return void 0===c||r>=t||r<0||d&&e-l>=o}function v(){var e=da();if(p(e))return g(e);a=setTimeout(v,function(e){var r=t-(e-c);return d?pa(r,o-(e-l)):r}(e))}function g(e){return a=void 0,h&&n?f(e):(n=i=void 0,s)}function m(){var e=da(),r=p(e);if(n=arguments,i=this,c=e,r){if(void 0===a)return function(e){return l=e,a=setTimeout(v,t),u?f(e):s}(c);if(d)return clearTimeout(a),a=setTimeout(v,t),f(c)}return void 0===a&&(a=setTimeout(v,t)),s}return t=Vo(t)||0,Bo(r)&&(u=!!r.leading,o=(d="maxWait"in r)?fa(Vo(r.maxWait)||0,t):o,h="trailing"in r?!!r.trailing:h),m.cancel=function(){void 0!==a&&clearTimeout(a),l=0,n=c=i=a=void 0},m.flush=function(){return void 0===a?s:g(da())},m};var ga=function(e,t,r,n){if(!Bo(e))return e;for(var i=-1,o=(t=sa(t,e)).length,s=o-1,a=e;null!=a&&++i<o;){var c=ca(t[i]),l=r;if("__proto__"===c||"constructor"===c||"prototype"===c)return e;if(i!=s){var u=a[c];void 0===(l=n?n(u,c,a):void 0)&&(l=Bo(u)?u:fs(t[i+1])?[]:{})}ms(a,c,l),a=a[c]}return e};var ma=function(e,t,r){return null==e?e:ga(e,t,r)},ya="Expected a function";var ba=function(e,t,r){var n=!0,i=!0;if("function"!=typeof e)throw new TypeError(ya);return Bo(r)&&(n="leading"in r?!!r.leading:n,i="trailing"in r?!!r.trailing:i),va(e,t,{leading:n,maxWait:t,trailing:i})},_a=class{constructor(e,t){this.host=e,this.query=t,this.isLoading=!1,this.isError=!1,this.data=null,this.error=null,this.queryId=null,e.addController(this)}isCancelledQuery(e){return this.queryId!==e}async execute(e){if(this.isLoading)return;this.isLoading=!0,this.isError=!1,this.host.requestUpdate();let t=bi();this.queryId=t;try{let r=await this.query(e);if(this.isCancelledQuery(t))return;this.data=r,this.error=null}catch(r){if(this.isCancelledQuery(t))return;this.data=null,this.isError=!0,this.error=r}finally{this.isLoading=!1,this.host.requestUpdate()}}cancel(){this.isLoading&&(this.queryId=null,this.isLoading=!1,this.host.requestUpdate())}hostConnected(){}},wa=e=>(class extends e{constructor(){super(...arguments),this.stickToBottom=!0,this.resizeObserver=null,this.lastKnownScrollHeight=0}async scrollToBottom(){await this.updateComplete,this.scrollBottom=0,this.stickToBottom=!0}resetStickToBottomState(){this.lastKnownScrollHeight=0,this.stickToBottom=!0,this.scrollToBottom()}ensureScrollState(){this.stickToBottom&&this.scrollToBottom()}get scrollBottom(){return this.scrollHeight-(this.clientHeight+this.scrollTop)}set scrollBottom(e){this.scrollTop=this.scrollHeight-this.clientHeight-e}isScrolledToBottom(){return this.scrollBottom<10}async updateStickToBottomState(){this.lastKnownScrollHeight!==this.scrollHeight&&this.stickToBottom&&await this.scrollToBottom(),this.stickToBottom=this.isScrolledToBottom(),this.lastKnownScrollHeight=this.scrollHeight}connectedCallback(){super.connectedCallback(),this.addEventListener("scroll",()=>this.updateStickToBottomState(),!1),window&&window.ResizeObserver&&(this.resizeObserver=new ResizeObserver(async()=>{this.stickToBottom&&this.scrollToBottom()}),this.resizeObserver.observe(this))}disconnectedCallback(){super.disconnectedCallback(),this.resizeObserver&&this.resizeObserver.disconnect()}async updated(e){super.updated(e),this.ensureScrollState()}}),Sa=(e,...t)=>({strTag:!0,strings:e,values:t}),Ea=[];for(let r=0;r<256;r++)Ea[r]=(r>>4&15).toString(16)+(15&r).toString(16);(new class{constructor(){this.settled=!1,this.promise=new Promise((e,t)=>{this._resolve=e,this._reject=t})}resolve(e){this.settled=!0,this._resolve(e)}reject(e){this.settled=!0,this._reject(e)}}).resolve();var ka=e=>(e=>"string"!=typeof e&&"strTag"in e)(e)?((e,t,r)=>{let n=e[0];for(let i=1;i<e.length;i++)n+=t[r?r[i-1]:i-1],n+=e[i];return n})(e.strings,e.values):e;eo.extend((function(e,t,r){t.prototype.isYesterday=function(){var e="YYYY-MM-DD",t=r().subtract(1,"day");return this.format(e)===t.format(e)}}));var Ta="en-US";function Ia(e,t,r){return!0===(null==r?void 0:r.short)?e.toLocaleDateString(t,{month:"short",day:"numeric"}):e.toLocaleString(t,null==r?void 0:r.options)}var Ra={options:{dateStyle:"full",timeStyle:"long"}},Ca=class extends yr{constructor(){super(...arguments),this.ts="",this.date=new Date,this.short=!1,this.locale=""}getLocale(){return this.locale||(document&&document.documentElement.lang?document.documentElement.lang:navigator&&navigator.language?navigator.language:Ta)}createRenderRoot(){return this}render(){let e=this.getLocale(),t=Ia(this.date,e,Ra),r=this.formatOptions?{options:this.formatOptions}:{short:this.short},n=Ia(this.date,e,r);return Qt` <
											time datetime = "${this.date.toISOString()}"
											title = "${t}" > $ {
												n
											} < /time>
											`}};xn([Sr({type:String})],Ca.prototype,"ts",void 0),xn([Sr({attribute:"ts",converter:e=>new Date((null==e?void 0:e.replace("+0000","+00:00"))||"")})],Ca.prototype,"date",void 0),xn([Sr({type:Boolean})],Ca.prototype,"short",void 0),xn([Sr({type:String})],Ca.prototype,"locale",void 0),xn([Sr({type:Object})],Ca.prototype,"formatOptions",void 0),Ca=xn([_r("faceplate-date")],Ca);Zn("icon-info",Jt`
											$ {
												Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_474_84)"><path d="M10 20a10 10 0 1110-10 10.011 10.011 0 01-10 10zm0-18.75A8.75 8.75 0 1018.75 10 8.76 8.76 0 0010 1.25zm-.543 5.705a1.058 1.058 0 01-.39-.393 1.11 1.11 0 010-1.09c.093-.161.228-.295.39-.386a1.1 1.1 0 011.484.39c.098.163.149.35.147.54a1.08 1.08 0 01-.54.936A1.05 1.05 0 0110 7.1a1.062 1.062 0 01-.543-.145zm1.354 8.463H9.2V8.124h1.614l-.003 7.294z"/></g><defs><clipPath id="clip0_474_84"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
											}
											`,Jt`
											$ {
												Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_474_83)"><path d="M10 0a10 10 0 1010 10A10.011 10.011 0 0010 0zm1.081 15.418H8.92V8.062h2.161v7.356zm.065-8.859a1.307 1.307 0 01-1.139.656 1.29 1.29 0 01-.67-.178 1.343 1.343 0 01-.475-1.811c.113-.197.277-.36.475-.472a1.344 1.344 0 011.326.008 1.321 1.321 0 01.483 1.797z"/></g><defs><clipPath id="clip0_474_83"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
											}
											`);var Ma,xa,Oa,Aa=_t`: host {
												display: flex;position: fixed;left: 0;right: 0;top: 0;bottom: 0;box - sizing: border - box;align - items: center;justify - content: center;padding: var (--spacer - xl);background: var (--color - scrim);pointer - events: all;overflow: auto;z - index: var (--layer - overlay)
											}.actions {
												position: absolute;top: var (--spacer - xs);right: var (--spacer - xs)
											}
											img {
												max - height: 100 % ;
												max - width: 100 % ;
												object - fit: contain
											}
											`,Pa=class extends yr{constructor(){super(...arguments),this.handleEscapeKey=e=>{"Escape"===e.key&&(e.stopPropagation(),this.hide())},this.hide=()=>{this.dispatchEvent(new CustomEvent("close"))}}static get styles(){return[ii,Aa]}connectedCallback(){super.connectedCallback(),this.addEventListener("click",()=>{this.hide()}),window.addEventListener("keydown",this.handleEscapeKey),fi(this,(()=>ki({source:"chat",action:"click",noun:"image"}))())}disconnectedCallback(){super.disconnectedCallback(),window.removeEventListener("keydown",this.handleEscapeKey)}render(){return this.src?Qt` <
											img
											src = "${this.src}"
											alt = "${on(this.name)}"
											@click = "${e=>{e.stopPropagation()}}" /
												>
												<
												div class = "actions" >
												$ {
													vn({
														appearance: "plain",
														size: an.Small,
														attributes: {
															className: "text-tone-7 dark:text-tone-1 hover:text-tone-1 w-xl",
															type: "button",
															onclick: e => {
																e.stopPropagation(), this.hide()
															}
														},
														leadingIcon: Qt`<icon-close></icon-close>`
													})
												} <
												/div>
											`:null}};v([Sr({type:String})],Pa.prototype,"src",2),v([Sr({type:String})],Pa.prototype,"name",2),Pa=v([_r("rs-image-preview")],Pa),function(e){e[e.emergency=0]="emergency",e[e.alert=1]="alert",e[e.critical=2]="critical",e[e.error=3]="error",e[e.warning=4]="warning",e[e.notice=5]="notice",e[e.info=6]="info",e[e.success=7]="success",e[e.debug=8]="debug",e[e.none=9]="none"}(Ma||(Ma={})),function(e){e.Programmatic="programmatic",e.Eager="eager",e.Action="action",e.Intent="intent",e.Lazy="lazy",e.Preload="preload"}(xa||(xa={})),function(e){e.Get="get",e.Post="post",e.Dialog="dialog",e.Log="log"}(Oa||(Oa={}));Zn("icon-delete",Jt`
											$ {
												Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_472_1132)"><path d="M15.751 6.059L17 6.142l-.761 11.441a2.579 2.579 0 01-2.439 2.542H6.2a2.578 2.578 0 01-2.437-2.536L3 6.142l1.248-.083.761 11.441A1.366 1.366 0 006.2 18.875h7.6a1.369 1.369 0 001.191-1.381l.76-11.435zM18 3v1.25H2V3h4v-.375A2.762 2.762 0 018.875 0h2.25A2.762 2.762 0 0114 2.625V3h4zM7.25 3h5.5v-.375a1.518 1.518 0 00-1.625-1.375h-2.25A1.518 1.518 0 007.25 2.625V3z"/></g><defs><clipPath id="clip0_472_1132"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
											}
											`,Jt`
											$ {
												Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_472_1133)"><path d="M14.375 3a3.136 3.136 0 00-3.25-3h-2.25a3.136 3.136 0 00-3.25 3H2v2h16V3h-3.625zm-5.5-1h2.25a1.148 1.148 0 011.25 1h-4.75a1.148 1.148 0 011.25-1zm-5.85 4.5h13.95l-.737 11.083a2.58 2.58 0 01-2.438 2.542H6.2a2.578 2.578 0 01-2.437-2.536L3.025 6.5z"/></g><defs><clipPath id="clip0_472_1133"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
											}
											`);var Da=_t`: host {
												height: 100 % ;display: grid;grid - template - columns: 1 fr;grid - template - rows: min - content 1 fr min - content
											}
											main {
												align - self: center;
												justify - self: center
											}
											footer {
												display: flex;justify - content: end;padding: var (--spacer - sm);gap: var (--spacer - sm)
											}
											`,ja=class extends yr{constructor(){super(...arguments),this.dispatchConfirmEvent=()=>{this.dispatchEvent(new CustomEvent("confirm",{bubbles:!1}))},this.dispatchCancelEvent=()=>{this.dispatchEvent(new CustomEvent("cancel",{bubbles:!1}))}}static get styles(){return[ii,Da]}render(){return Qt`
											$ {
												ci({
													title: Qt`
          <slot name="header">${ka("Are you sure?",{desc:"Confirmation modal: title"})}</slot>
        `
												})
											} <
											main >
												<
												slot > < /slot> <
												/main> <
												footer >
												$ {
													vn({
														size: an.Small,
														children: Qt`<slot name="cancel">${ka("Cancel",{desc:"Cancel button"})}</slot>`,
														attributes: {
															type: "button",
															onclick: this.dispatchCancelEvent
														}
													})
												}
											$ {
												vn({
													appearance: "primary",
													size: an.Small,
													children: Qt`<slot name="confirm">${ka("Ok",{desc:"Ok button label"})}</slot>`,
													attributes: {
														type: "button",
														onclick: this.dispatchConfirmEvent
													}
												})
											} <
											/footer>
											`}};ja=v([_r("rs-room-confirmation-overlay")],ja);var La=class extends CustomEvent{constructor(e){super("faceplate-alert",{detail:e,bubbles:!0,composed:!0})}},Na="room-overlay-show",Ba="room-overlay-hide",Ua=class extends CustomEvent{constructor(e){super(Na,{detail:{content:e},bubbles:!0,composed:!0})}},Fa={variantFlipOrder:{start:"sme",middle:"mse",end:"ems"},positionFlipOrder:{top:"tbrl",right:"rltb",bottom:"btrl",left:"lrbt"},position:"bottom",margin:8,padding:0},$a=(e,t,r)=>{let n="object"!=typeof e||e instanceof HTMLElement?{reference:e,popper:t,...r}:e;return{update(e=n){let{reference:t,popper:r}=Object.assign(n,e);if(!r||!t)throw new Error("Popper- or reference-element missing.");return((e,t,r)=>{let{container:n,margin:i,padding:o,position:s,variantFlipOrder:a,positionFlipOrder:c}={container:document.documentElement.getBoundingClientRect(),...Fa,...r},{left:l,top:u}=t.style;t.style.left="0",t.style.top="0";let d=e.getBoundingClientRect(),h=t.getBoundingClientRect(),f={t:d.top-h.height-i,b:d.bottom+i,r:d.right+i,l:d.left-h.width-i},p={vs:d.left,vm:d.left+d.width/2+-h.width/2,ve:d.left+d.width-h.width,hs:d.top,hm:d.bottom-d.height/2-h.height/2,he:d.bottom-h.height},[v,g="middle"]=s.split("-"),m=c[v],y=a[g],{top:b,left:_,bottom:w,right:S}=n;for(let E of m){let e="t"===E||"b"===E,r=f[E],[n,i]=e?["top","left"]:["left","top"],[s,a]=e?[h.height,h.width]:[h.width,h.height],[c,l]=e?[w,S]:[S,w],[u,d]=e?[b,_]:[_,b];if(!(r<u||r+s+o>c))for(let f of y){let s=p[(e?"v":"h")+f];if(!(s<d||s+a+o>l))return t.style[i]=s-h[i]+"px",t.style[n]=r-h[n]+"px",E+f}}return t.style.left=l,t.style.top=u,null})(t,r,n)}}},qa=class{constructor(e,t){var r,{containerElement:n=document.documentElement,allowCloseByEvent:i=!0}=t,o=Mn(t,["containerElement","allowCloseByEvent"]);this.status={open:!1,isOpening:!1,isClosing:!1},this.open=async()=>{var e;if(this.updateOptions({}),this.status.open||this.status.isOpening)return Promise.resolve(null);let t=this.showElement(this._options.popper,!0);return t&&(this.setStatus("opening"),t.finished.then(()=>this.setStatus("opened"))),null!==(e=null==t?void 0:t.finished)&&void 0!==e?e:Promise.resolve(null)},this.close=async e=>{var t;if(this.updateOptions({}),e&&!this._options.allowCloseByEvent||(e&&(e.preventDefault(),e.stopPropagation()),!this.status.open||this.status.isClosing))return Promise.resolve(null);let r=this.hideElement(this._options.popper,!0);return r&&(this.setStatus("closing"),r.finished.then(()=>this.setStatus("closed"))),null!==(t=null==r?void 0:r.finished)&&void 0!==t?t:Promise.resolve(null)},this.toggle=async e=>this.status.open?this.close(e):this.open(),this.setStatus=e=>{this.status={opening:{open:!1,isOpening:!0,isClosing:!1},closing:{open:!0,isOpening:!1,isClosing:!0},opened:{open:!0,isOpening:!1,isClosing:!1},closed:{open:!1,isOpening:!1,isClosing:!1}}[e]},this.handleContainerResize=()=>{var e;this.popper.update(Object.assign(Object.assign({},this._options),{container:(null!==(e=this._options.containerElement)&&void 0!==e?e:document.documentElement).getBoundingClientRect()}))},this.getKeyframes=(e,t="show",r)=>new KeyframeEffect(e,[{visiblity:"visible",opacity:"0"},{visibility:"visible",opacity:"1"}],{fill:"both",direction:"show"===t?"normal":"reverse",duration:r,easing:"ease-in-out"}),(this.host=e).addController(this),this._options=Object.assign(Object.assign({},o),{containerElement:n,allowCloseByEvent:i}),this.popper=$a(Object.assign(Object.assign({},this._options),{container:(null!==(r=this._options.containerElement)&&void 0!==r?r:document.documentElement).getBoundingClientRect()}))}hostConnected(){this.resizeObserver=new ResizeObserver(this.handleContainerResize),this._options.containerElement&&this.resizeObserver.observe(this._options.containerElement),this.replaceElement(void 0,this._options.popper)}hostDisconnected(){this._options.containerElement&&this.resizeObserver.unobserve(this._options.containerElement)}getOptions(){return this._options}updateOptions(e){var t,r,n=Mn(e,[]);let i=Object.assign(Object.assign(Object.assign({},this._options),n),{container:(null!==(r=null!==(t=n.containerElement)&&void 0!==t?t:this._options.containerElement)&&void 0!==r?r:document.documentElement).getBoundingClientRect()}),o=i.popperElementKey||"popperElement";!i.popper&&o in this.host&&(i.popper=this.host[o]);let s=i.referenceElementKey||"popperReferenceElement";!i.reference&&s in this.host&&(i.reference=this.host[s]),i.popper!==this._options.popper&&this.replaceElement(this._options.popper,i.popper),i.containerElement!==this._options.containerElement&&(this._options.containerElement&&(this.resizeObserver.unobserve(this._options.containerElement),this._options.containerElement.removeEventListener("faceplate-close",this.close)),i.containerElement&&(this.resizeObserver.observe(i.containerElement),i.containerElement.addEventListener("faceplate-close",this.close))),this._options=i,this.popper.update(this._options)}get currentState(){return this.status}showElement(e,t=!0){if(e)return Ka(t?this.getKeyframes(e,"show",150):this.getKeyframes(e,"show",0))}hideElement(e,t=!0){if(e)return Ka(t?this.getKeyframes(e,"hide",150):this.getKeyframes(e,"hide",0))}replaceElement(e,t){e&&(this.hideElement(e,!1),e.removeEventListener("faceplate-close",this.close)),t&&(this.status.open?this.showElement(t,!1):this.hideElement(t,!1),t.addEventListener("faceplate-close",this.close))}};qa.defaultPopperContentStyles=_t` [faceplate - popper - content] {
												position: fixed;
												visibility: hidden;
												opacity: 0;
											}
											`;var Ka=e=>{if(!e.target)return;e.target.getAnimations().forEach(e=>e.cancel());let t=new Animation(e);return t.play(),t},Va=class extends yr{constructor(){super(...arguments),this.position="bottom",this.triggerEvent="hover",this._popperController=new qa(this,{position:this.position,referenceElementKey:"referenceElement",popperElementKey:"_tooltip"}),this.updated=e=>{e.has("position")&&this._popperController.updateOptions({position:this.position})},this.handleEscape=e=>{"Escape"===e.key&&this.close()},this.show=()=>{this.hidden=!1},this.close=()=>{this.hidden=!0}}get referenceElement(){return this.triggers.length>0?this.triggers[0]:this}static get styles(){return[_t`: host {
												display: inline - block;
												position: relative;
											}

											[role = 'tooltip'] {
												font - size: 0.75 rem;
												line - height: 1.25;
												background - color: var (--color - ui - modalbackground);
												border - radius: 0.25 rem;
												box - shadow: var (--boxshadow - tooltip);
												justify - content: center;
												padding: 0.5 rem 0.625 rem;
												display: inline - flex;
												width: max - content;
											}

											article {
												display: flex;
												gap: 0.375 rem;
											}

											.icon {
												display: inline - block;
											}

											[role = 'tooltip']::after {
												display: block;
												content: '';
												width: 8 px;
												height: 8 px;
												position: absolute;
												background - color: var (--color - ui - modalbackground);
											}

											[role = 'tooltip'][position = 'top']::after {
												bottom: 0;
												transform: translateY(50 % ) rotate(45 deg);
												box - shadow: 1 px 1 px 2 px rgba(0, 0, 0, 0.05);
											}

											[role = 'tooltip'][position = 'bottom']::after {
												top: 0;
												transform: translateY(-50 % ) rotate(45 deg);
												box - shadow: -1 px - 1 px 2 px rgba(0, 0, 0, 0.05);
											}

											[role = 'tooltip'][position = 'right']::after {
												left: 0;
												top: 50 % ;
												/* 38% because the border-radius: 100px shows a space above 38% */
												transform: translate(-38 % , -50 % ) rotate(45 deg);
												box - shadow: -2 px 0 px 2 px rgba(0, 0, 0, 0.05);
											}

											[role = 'tooltip'][position = 'left']::after {
												right: 0;
												top: 50 % ;
												/* 38% because the border-radius: 100px shows a space above 38% */
												transform: translate(38 % , -50 % ) rotate(45 deg);
												box - shadow: 0 px - 2 px 2 px rgba(0, 0, 0, 0.05);
											}

											[role = 'tooltip'][position ^= 'auto']::after {
												display: none;
											}
											`,qa.defaultPopperContentStyles]}get hidden(){return!this._popperController.currentState.open}set hidden(e){!0===e?this._popperController.close():this._popperController.open()}firstUpdated(){document.addEventListener("keydown",this.handleEscape)}disconnectedCallback(){super.disconnectedCallback(),document.removeEventListener("keydown",this.handleEscape)}handleClick(){"click"===this.triggerEvent&&(this.hidden?this.show():this.close())}handleKeydown(e){"click"===this.triggerEvent&&("Enter"===e.code||"Space"===e.code)&&(this.hidden?this.show():this.close())}handleMouseenter(){"hover"===this.triggerEvent&&this.show()}handleMouseleave(){"hover"===this.triggerEvent&&this.close()}render(){return Qt` <
											slot
											name = "trigger"
											aria - describedby = "faceplate-tooltip"
											@click = $ {
												this.handleClick
											}
											@keydown = $ {
												this.handleKeydown
											}
											@mouseenter = $ {
												this.handleMouseenter
											}
											@mouseleave = $ {
												this.handleMouseleave
											}
											@focusin = $ {
												this.handleMouseenter
											}
											@focusout = $ {
													this.handleMouseenter
												} > < /slot> <
												article
											id = "faceplate-tooltip"
											role = "tooltip"
											position = $ {
												this.position
											}
											faceplate - popper - content
											hidden >
												<
												slot class = "icon"
											name = "icon" > < /slot> <
												span >
												<
												slot > < /slot> <
												/span> <
												/article>
											`}};xn([Sr({type:String})],Va.prototype,"position",void 0),xn([Sr({type:String,attribute:"trigger-event"})],Va.prototype,"triggerEvent",void 0),xn([Cr("trigger",!0)],Va.prototype,"triggers",void 0),xn([Cr("icon",!0)],Va.prototype,"icons",void 0),xn([Tr("#faceplate-tooltip")],Va.prototype,"_tooltip",void 0),Va=xn([_r("faceplate-tooltip")],Va);var za=_t`.menu - item {
												display: inline - flex;align - items: center;justify - content: center;width: 28 px;height: 28 px;background: 0;border: 0;margin: 0 .125 rem
											}.menu - item: hover {
												border - radius: .5 rem;
												background - color: var (--color - tone - 5)
											}
											`,Ha=class extends(mn(yr)){constructor(){super(...arguments),this.handleClick=e=>{let t=this.renderOverlay();t?this.dispatchEvent(new Ua(t)):this.dispatchEvent(new CustomEvent("click")),e.stopPropagation()},this.hideOverlay=()=>{this.dispatchEvent(new CustomEvent(Ba,{bubbles:!0,composed:!0}))}}static get styles(){return[ii,za]}getCurrentRoom(){var e;if(!this.matrix||!this.event)return null;let t=this.event.getRoomId();return t&&null!=(e=this.matrix.getRoom(t))?e:null}render(){return this.isActionAllowed()?this.disableTooltip?Qt` < button class = "menu-item"
											@click = $ {
													this.handleClick
												} > $ {
													this.icon
												} < /button>`:Qt` <
												faceplate - tooltip position = "top" >
												<
												button slot = "trigger"
											class = "menu-item"
											@click = $ {
												this.handleClick
											} > $ {
												this.icon
											} < /button>
											$ {
												this.name
											} <
											/faceplate-tooltip>
											`:null}};v([Sr({type:Object})],Ha.prototype,"event",2),v([Sr({type:Boolean})],Ha.prototype,"disableTooltip",2);var Wa=class extends Ha{constructor(){super(...arguments),this.name=ka("Delete",{desc:"Message Actions Menu: Delete message action tooltip"}),this.icon=Qt` < icon - delete > < /icon-delete>`,this.deleteEvent=async()=>{if(!this.matrix||!this.event)return;let e=this.event.getId(),t=this.getCurrentRoom();if(t&&e)try{this.hideOverlay(),this.event.status===zr.NOT_SENT?t.removeEvent(e):await this.matrix.redactEvent(t.roomId,e)}catch{this.dispatchEvent(new La({level:Ma.error,message:ka("Unable to delete the message",{desc:"Room timeline /
											Delete message: error message "})}))}}}isActionAllowed(){var e;let t=this.getCurrentRoom();if(!this.matrix||!this.event||!t)return!1;let r=this.matrix.getUserId();return!(!r||(null==(e=this.event.sender)?void 0:e.userId)!==r)&&t.currentState.maySendEvent(Vr.RoomRedaction,r)}renderOverlay(){return Qt` <
												rs - room - confirmation - overlay @confirm = $ {
													this.deleteEvent
												}
											@cancel = $ {
													this.hideOverlay
												} >
												<
												div slot = "header" >
												$ {
													ka("Delete this message?", {
														desc: "Delete message: confirmation title"
													})
												} <
												/div> <
												span slot = "confirm" >
												$ {
													ka("Yes, Delete", {
														desc: "Delete message: confirmation CTA"
													})
												} < /span >
												$ {
													ka(Sa`It will be removed for everyone in this chat. You can't undo this.`, {
														desc: "Delete message: confirmation text"
													})
												} <
												/rs-room-confirmation-overlay>
											`}};Wa=v([_r("rs-timeline-event-delete-action")],Wa);Zn("icon-report",Jt`
											$ {
												Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M2.25 19.775H1V2.193l.353-.171a10.293 10.293 0 018.919 0 9.054 9.054 0 007.7.061l.309-.144.385.188a.715.715 0 01.334.606V14.79l-.353.17a10.286 10.286 0 01-8.919 0 9.033 9.033 0 00-7.478-.16v4.975zm3.562-6.956a10.23 10.23 0 014.46 1.016A9.04 9.04 0 0017.75 14V3.531a10.17 10.17 0 01-8.022-.384 9.037 9.037 0 00-7.478-.162v10.468c1.14-.42 2.347-.635 3.562-.634z"/></svg>')
											}
											`,Jt`
											$ {
												Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M18.668 2.127l-.385-.188-.309.144a9.054 9.054 0 01-7.7-.061 10.293 10.293 0 00-8.919 0L1 2.193v17.582h2v-5.252a9.03 9.03 0 016.728.437 10.286 10.286 0 008.919 0l.353-.17V2.733a.715.715 0 00-.332-.606z"/></svg>')
											}
											`);function*Ga(e,t){if(void 0!==e){let r=0;for(let n of e)yield t(n,r++)}}var Ya,Qa=class extends CustomEvent{constructor(e,t){super(e,{...t,bubbles:!0,composed:!0})}},Ja=class extends Qa{constructor(e){super(e)}},Xa=class extends Ja{constructor(e){super(Xa.type),this.controller=e}},Za=Xa;Ya=new WeakMap,y(Za,Ya,Xa.type="apollo-controller-connected");var ec,tc=class extends Ja{constructor(e){super(tc.type),this.controller=e}},rc=tc;ec=new WeakMap,y(rc,ec,tc.type="apollo-controller-disconnected");var nc,ic,oc,sc=class{constructor(e,t){var r,n,i;y(this,nc,void 0),y(this,ic,void 0),y(this,oc,void 0),this.host=e,b(this,nc,{}),b(this,ic,null),b(this,oc,null),this.called=!0,this.data=null,this.error=null,this.errors=[],this.loading=!1,e instanceof EventTarget?this.emitter=e:(null==t?void 0:t.hostElement)instanceof EventTarget?this.emitter=t.hostElement:this.emitter=new EventTarget,this.options=null!=t?t:{},this.client=null!=(n=null!=(r=this.options.client)?r:window.__APOLLO_CLIENT__)?n:null,null==(i=e.addController)||i.call(e,this)}static o(e,t){Object.defineProperty(e,"options",{get(){return m(this,nc)},set(e){var t;b(this,nc,e),null==(t=this.optionsChanged)||t.call(this,e)}})}get client(){return m(this,ic)}set client(e){var t;let r=m(this,ic);b(this,ic,e),null==(t=this.clientChanged)||t.call(this,e),this.notify({client:r})}get document(){return m(this,oc)}set document(e){var t;if(e!==m(this,oc))if(e){if(!function(e){return!!(e&&"object"==typeof e&&"kind"in e&&"definitions"in e)}(e)){let e=this.constructor.name.replace(/Apollo(\w+)(Controller|Behavior)/,"$1");throw new TypeError(`
											$ {
												e
											}
											must be a parsed GraphQL document.
											`)}b(this,oc,e),this.notify({document:e}),null==(t=this.documentChanged)||t.call(this,e)}else b(this,oc,null)}get variables(){var e,t;return null!=(t=null==(e=this.options)?void 0:e.variables)?t:null}set variables(e){var t;if(e){if(e===this.options.variables)return;this.options.variables=e}else delete this.options.variables;this.notify({variables:e}),null==(t=this.variablesChanged)||t.call(this,e)}notify(e){if(e&&this.host.requestUpdate.length>0)for(let[t,r]of Object.entries(e))this.host.requestUpdate(t,r);else this.host.requestUpdate()}init(e){var t;null!=this.variables||(this.variables=null!=(t=this.options.variables)?t:null),this.document=e}hostConnected(){this.emitter.dispatchEvent(new Za(this))}hostDisconnected(){this.emitter.dispatchEvent(new rc(this)),window.dispatchEvent(new rc(this))}};function ac(e,t,r){if("function"!=typeof(null==r?void 0:r.value))throw new TypeError(`
											Only methods can be decorated with @bound. < $ {
												null != t ? t : e.name
											} > is not a method!`);return{configurable:!0,get(){let e=r.value.bind(this);return Object.defineProperty(this,t,{value:e,configurable:!0,writable:!0}),e}}}nc=new WeakMap,ic=new WeakMap,oc=new WeakMap,xn([sc.o],sc.prototype,"options",void 0);xn([ac],class extends sc{constructor(e,t,r){super(e,r),this.mostRecentMutationId=0,this.called=!1,this.init(null!=t?t:null)}get mutation(){return this.document}set mutation(e){this.document=e}async mutate(e){var t,r;if(!this.client)throw new TypeError("No Apollo client. See https://apolloelements.dev/guides/getting-started/apollo-client/");let n=this.generateMutationId(),{called:i=!1,data:o,error:s,errors:a,loading:c}=this;return this.loading=!0,this.called=!0,this.error=null,this.errors=[],this.data=null,this.notify({called:i,data:o,error:s,errors:a,loading:c}),this.client.mutate({mutation:this.mutation,awaitRefetchQueries:this.options.awaitRefetchQueries,context:this.options.context,errorPolicy:this.options.errorPolicy,fetchPolicy:this.options.fetchPolicy,optimisticResponse:this.options.optimisticResponse,refetchQueries:null!=(t=this.options.refetchQueries)?t:void 0,update:this.options.update,variables:null!=(r=this.variables)?r:void 0,...e}).then(this.onCompletedMutation.bind(this,n)).catch(this.onMutationError.bind(this,n))}generateMutationId(){return this.mostRecentMutationId+=1,this.mostRecentMutationId}isMostRecentMutation(e){return this.mostRecentMutationId===e}onCompletedMutation(e,t){var r,n,i,o;let{data:s,error:a,errors:c,loading:l}=this;return this.emitter.dispatchEvent(new CustomEvent("apollo-mutation-result",{detail:t})),this.isMostRecentMutation(e)&&(this.loading=!1,this.options.ignoreResults||(this.error=null,this.data=null!=(r=t.data)?r:null,this.errors=null!=(n=t.errors)?n:[],null==(o=(i=this.options).onCompleted)||o.call(i,this.data)),this.notify({data:s,error:a,errors:c,loading:l})),t}onMutationError(e,t){var r,n;this.emitter.dispatchEvent(new CustomEvent("apollo-error",{detail:t}));let{data:i,error:o,loading:s}=this;throw this.isMostRecentMutation(e)&&(this.loading=!1,this.data=null,this.error=t),null==(n=(r=this.options).onError)||n.call(r,t),this.notify({data:i,error:o,loading:s}),t}}.prototype,"mutate",null);var cc="Invariant Violation",lc=Object.setPrototypeOf,uc=void 0===lc?function(e,t){return e.__proto__=t,e}:lc,dc=function(e){function t(r){void 0===r&&(r=cc);var n=e.call(this,"number"==typeof r?cc+": "+r+" (see https://github.com/apollographql/invariant-packages)":r)||this;return n.framesToPop=1,n.name=cc,uc(n,t.prototype),n}return Rn(t,e),t}(Error);function hc(e,t){if(!e)throw new dc(t)}var fc=["debug","log","warn","error","silent"],pc=fc.indexOf("log");function vc(e){return function(){if(fc.indexOf(e)>=pc){var t=console[e]||console.log;return t.apply(console,arguments)}}}function gc(e){try{return e()}catch{}}!function(e){e.debug=vc("debug"),e.log=vc("log"),e.warn=vc("warn"),e.error=vc("error")}(hc||(hc={}));var mc=gc((function(){return globalThis}))||gc((function(){return window}))||gc((function(){return self}))||gc((function(){return e}))||gc((function(){return gc.constructor("return this")()})),yc="__",bc=[yc,yc].join("DEV");var _c=function(){try{return Boolean(__DEV__)}catch{return Object.defineProperty(mc,bc,{value:"production"!==gc((function(){return"production"})),enumerable:!1,configurable:!0,writable:!0}),mc[bc]}}();function wc(e){try{return e()}catch{}}var Sc=wc((function(){return globalThis}))||wc((function(){return window}))||wc((function(){return self}))||wc((function(){return e}))||wc((function(){return wc.constructor("return this")()})),Ec=!1;function kc(){Ec&&(delete Sc.process,Ec=!1)}function Tc(e,t){if(!Boolean(e))throw new Error(t)}Sc&&!wc((function(){return"production"}))&&!wc((function(){return t}))&&(Object.defineProperty(Sc,"process",{value:{env:{NODE_ENV:"production"}},configurable:!0,enumerable:!1,writable:!0}),Ec=!0);var Ic,Rc,Cc={Name:[],Document:["definitions"],OperationDefinition:["name","variableDefinitions","directives","selectionSet"],VariableDefinition:["variable","type","defaultValue","directives"],Variable:["name"],SelectionSet:["selections"],Field:["alias","name","arguments","directives","selectionSet"],Argument:["name","value"],FragmentSpread:["name","directives"],InlineFragment:["typeCondition","directives","selectionSet"],FragmentDefinition:["name","variableDefinitions","typeCondition","directives","selectionSet"],IntValue:[],FloatValue:[],StringValue:[],BooleanValue:[],NullValue:[],EnumValue:[],ListValue:["values"],ObjectValue:["fields"],ObjectField:["name","value"],Directive:["name","arguments"],NamedType:["name"],ListType:["type"],NonNullType:["type"],SchemaDefinition:["description","directives","operationTypes"],OperationTypeDefinition:["type"],ScalarTypeDefinition:["description","name","directives"],ObjectTypeDefinition:["description","name","interfaces","directives","fields"],FieldDefinition:["description","name","arguments","type","directives"],InputValueDefinition:["description","name","type","defaultValue","directives"],InterfaceTypeDefinition:["description","name","interfaces","directives","fields"],UnionTypeDefinition:["description","name","directives","types"],EnumTypeDefinition:["description","name","directives","values"],EnumValueDefinition:["description","name","directives"],InputObjectTypeDefinition:["description","name","directives","fields"],DirectiveDefinition:["description","name","arguments","locations"],SchemaExtension:["directives","operationTypes"],ScalarTypeExtension:["name","directives"],ObjectTypeExtension:["name","interfaces","directives","fields"],InterfaceTypeExtension:["name","interfaces","directives","fields"],UnionTypeExtension:["name","directives","types"],EnumTypeExtension:["name","directives","values"],InputObjectTypeExtension:["name","directives","fields"]},Mc=new Set(Object.keys(Cc));function xc(e){let t=null==e?void 0:e.kind;return"string"==typeof t&&Mc.has(t)}function Oc(e){return 9===e||32===e}function Ac(e){return Pc(e,[])}function Pc(e,t){switch(typeof e){case"string":return JSON.stringify(e);case"function":return e.name?` [function $ {
												e.name
											}] `:"[function]";case"object":return function(e,t){if(null===e)return"null";if(t.includes(e))return"[Circular]";let r=[...t,e];if(function(e){return"function"==typeof e.toJSON}(e)){let t=e.toJSON();if(t!==e)return"string"==typeof t?t:Pc(t,r)}else if(Array.isArray(e))return function(e,t){if(0===e.length)return"[]";if(t.length>2)return"[Array]";let r=Math.min(10,e.length),n=e.length-r,i=[];for(let o=0;o<r;++o)i.push(Pc(e[o],t));return 1===n?i.push("... 1 more item"):n>1&&i.push(`...$ {
												n
											}
											more items`),"["+i.join(", ")+"]"}(e,r);return function(e,t){let r=Object.entries(e);return 0===r.length?"{}":t.length>2?"["+function(e){let t=Object.prototype.toString.call(e).replace(/^\[object /,"").replace(/]$/,"");if("Object"===t&&"function"==typeof e.constructor){let t=e.constructor.name;if("string"==typeof t&&""!==t)return t}return t}(e)+"]":"{ "+r.map(([e,r])=>e+": "+Pc(r,t)).join(", ")+" }"}(e,r)}(e,t);default:return String(e)}}!function(e){e.QUERY="query",e.MUTATION="mutation",e.SUBSCRIPTION="subscription"}(Ic||(Ic={})),function(e){e.NAME="Name",e.DOCUMENT="Document",e.OPERATION_DEFINITION="OperationDefinition",e.VARIABLE_DEFINITION="VariableDefinition",e.SELECTION_SET="SelectionSet",e.FIELD="Field",e.ARGUMENT="Argument",e.FRAGMENT_SPREAD="FragmentSpread",e.INLINE_FRAGMENT="InlineFragment",e.FRAGMENT_DEFINITION="FragmentDefinition",e.VARIABLE="Variable",e.INT="IntValue",e.FLOAT="FloatValue",e.STRING="StringValue",e.BOOLEAN="BooleanValue",e.NULL="NullValue",e.ENUM="EnumValue",e.LIST="ListValue",e.OBJECT="ObjectValue",e.OBJECT_FIELD="ObjectField",e.DIRECTIVE="Directive",e.NAMED_TYPE="NamedType",e.LIST_TYPE="ListType",e.NON_NULL_TYPE="NonNullType",e.SCHEMA_DEFINITION="SchemaDefinition",e.OPERATION_TYPE_DEFINITION="OperationTypeDefinition",e.SCALAR_TYPE_DEFINITION="ScalarTypeDefinition",e.OBJECT_TYPE_DEFINITION="ObjectTypeDefinition",e.FIELD_DEFINITION="FieldDefinition",e.INPUT_VALUE_DEFINITION="InputValueDefinition",e.INTERFACE_TYPE_DEFINITION="InterfaceTypeDefinition",e.UNION_TYPE_DEFINITION="UnionTypeDefinition",e.ENUM_TYPE_DEFINITION="EnumTypeDefinition",e.ENUM_VALUE_DEFINITION="EnumValueDefinition",e.INPUT_OBJECT_TYPE_DEFINITION="InputObjectTypeDefinition",e.DIRECTIVE_DEFINITION="DirectiveDefinition",e.SCHEMA_EXTENSION="SchemaExtension",e.SCALAR_TYPE_EXTENSION="ScalarTypeExtension",e.OBJECT_TYPE_EXTENSION="ObjectTypeExtension",e.INTERFACE_TYPE_EXTENSION="InterfaceTypeExtension",e.UNION_TYPE_EXTENSION="UnionTypeExtension",e.ENUM_TYPE_EXTENSION="EnumTypeExtension",e.INPUT_OBJECT_TYPE_EXTENSION="InputObjectTypeExtension"}(Rc||(Rc={}));var Dc=/[\x00-\x1f\x22\x5c\x7f-\x9f]/g;function jc(e){return Lc[e.charCodeAt(0)]}var Lc=["\\u0000","\\u0001","\\u0002","\\u0003","\\u0004","\\u0005","\\u0006","\\u0007","\\b","\\t","\\n","\\u000B","\\f","\\r","\\u000E","\\u000F","\\u0010","\\u0011","\\u0012","\\u0013","\\u0014","\\u0015","\\u0016","\\u0017","\\u0018","\\u0019","\\u001A","\\u001B","\\u001C","\\u001D","\\u001E","\\u001F","","",'\\"',"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","\\\\","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","\\u007F","\\u0080","\\u0081","\\u0082","\\u0083","\\u0084","\\u0085","\\u0086","\\u0087","\\u0088","\\u0089","\\u008A","\\u008B","\\u008C","\\u008D","\\u008E","\\u008F","\\u0090","\\u0091","\\u0092","\\u0093","\\u0094","\\u0095","\\u0096","\\u0097","\\u0098","\\u0099","\\u009A","\\u009B","\\u009C","\\u009D","\\u009E","\\u009F"],Nc=Object.freeze({});function Bc(e,t,r=Cc){let n=new Map;for(let m of Object.values(Rc))n.set(m,Uc(t,m));let i,o,s,a=Array.isArray(e),c=[e],l=-1,u=[],d=e,h=[],f=[];do{let e,m=++l===c.length,y=m&&0!==u.length;if(m){if(o=0===f.length?void 0:h[h.length-1],d=s,s=f.pop(),y)if(a){d=d.slice();let e=0;for(let[t,r]of u){let n=t-e;null===r?(d.splice(n,1),e++):d[n]=r}}else{d=Object.defineProperties({},Object.getOwnPropertyDescriptors(d));for(let[e,t]of u)d[e]=t}l=i.index,c=i.keys,u=i.edits,a=i.inArray,i=i.prev}else if(s){if(null==(d=s[o=a?l:c[l]]))continue;h.push(o)}if(!Array.isArray(d)){var p,v;xc(d)||Tc(!1,`
											Invalid AST Node: $ {
												Ac(d)
											}.
											`);let r=m?null===(p=n.get(d.kind))||void 0===p?void 0:p.leave:null===(v=n.get(d.kind))||void 0===v?void 0:v.enter;if((e=null==r?void 0:r.call(t,d,o,s,h,f))===Nc)break;if(!1===e){if(!m){h.pop();continue}}else if(void 0!==e&&(u.push([o,e]),!m)){if(!xc(e)){h.pop();continue}d=e}}var g;if(void 0===e&&y&&u.push([o,d]),m)h.pop();else i={inArray:a,index:l,keys:c,edits:u,prev:i},c=(a=Array.isArray(d))?d:null!==(g=r[d.kind])&&void 0!==g?g:[],l=-1,u=[],s&&f.push(s),s=d}while(void 0!==i);return 0!==u.length?u[u.length-1][1]:e}function Uc(e,t){let r=e[t];return"object"==typeof r?r:"function"==typeof r?{enter:r,leave:void 0}:{enter:e.enter,leave:e.leave}}function Fc(e){return Bc(e,$c)}var $c={Name:{leave:e=>e.value},Variable:{leave:e=>"$"+e.name},Document:{leave:e=>qc(e.definitions,"\n\n")},OperationDefinition:{leave(e){let t=Vc("(",qc(e.variableDefinitions,", "),")"),r=qc([e.operation,qc([e.name,t]),qc(e.directives," ")]," ");return("query"===r?"":r+" ")+e.selectionSet}},VariableDefinition:{leave:({variable:e,type:t,defaultValue:r,directives:n})=>e+": "+t+Vc(" = ",r)+Vc(" ",qc(n," "))},SelectionSet:{leave:({selections:e})=>Kc(e)},Field:{leave({alias:e,name:t,arguments:r,directives:n,selectionSet:i}){let o=Vc("",e,": ")+t,s=o+Vc("(",qc(r,", "),")");return s.length>80&&(s=o+Vc("(\n",zc(qc(r,"\n")),"\n)")),qc([s,qc(n," "),i]," ")}},Argument:{leave:({name:e,value:t})=>e+": "+t},FragmentSpread:{leave:({name:e,directives:t})=>"..."+e+Vc(" ",qc(t," "))},InlineFragment:{leave:({typeCondition:e,directives:t,selectionSet:r})=>qc(["...",Vc("on ",e),qc(t," "),r]," ")},FragmentDefinition:{leave:({name:e,typeCondition:t,variableDefinitions:r,directives:n,selectionSet:i})=>`
											fragment $ {
												e
											}
											$ {
												Vc("(", qc(r, ", "), ")")
											}
											on $ {
												t
											}
											$ {
												Vc("", qc(n, " "), " ")
											}
											`+i},IntValue:{leave:({value:e})=>e},FloatValue:{leave:({value:e})=>e},StringValue:{leave:({value:e,block:t})=>t?function(e,t){let r=e.replace(/"""/g,'\\"""'),n=r.split(/\r\n|[\n\r]/g),i=1===n.length,o=n.length>1&&n.slice(1).every(e=>0===e.length||Oc(e.charCodeAt(0))),s=r.endsWith('\\"""'),a=e.endsWith('"')&&!s,c=e.endsWith("\\"),l=a||c,u=!(null!=t&&t.minimize)&&(!i||e.length>70||l||o||s),d="",h=i&&Oc(e.charCodeAt(0));return(u&&!h||o)&&(d+="\n"),d+=r,(u||l)&&(d+="\n"),'"""'+d+'"""'}(e):function(e){return`
											"${e.replace(Dc,jc)}"
											`}(e)},BooleanValue:{leave:({value:e})=>e?"true":"false"},NullValue:{leave:()=>"null"},EnumValue:{leave:({value:e})=>e},ListValue:{leave:({values:e})=>"["+qc(e,", ")+"]"},ObjectValue:{leave:({fields:e})=>"{"+qc(e,", ")+"}"},ObjectField:{leave:({name:e,value:t})=>e+": "+t},Directive:{leave:({name:e,arguments:t})=>"@"+e+Vc("(",qc(t,", "),")")},NamedType:{leave:({name:e})=>e},ListType:{leave:({type:e})=>"["+e+"]"},NonNullType:{leave:({type:e})=>e+"!"},SchemaDefinition:{leave:({description:e,directives:t,operationTypes:r})=>Vc("",e,"\n")+qc(["schema",qc(t," "),Kc(r)]," ")},OperationTypeDefinition:{leave:({operation:e,type:t})=>e+": "+t},ScalarTypeDefinition:{leave:({description:e,name:t,directives:r})=>Vc("",e,"\n")+qc(["scalar",t,qc(r," ")]," ")},ObjectTypeDefinition:{leave:({description:e,name:t,interfaces:r,directives:n,fields:i})=>Vc("",e,"\n")+qc(["type",t,Vc("implements ",qc(r," & ")),qc(n," "),Kc(i)]," ")},FieldDefinition:{leave:({description:e,name:t,arguments:r,type:n,directives:i})=>Vc("",e,"\n")+t+(Hc(r)?Vc("(\n",zc(qc(r,"\n")),"\n)"):Vc("(",qc(r,", "),")"))+": "+n+Vc(" ",qc(i," "))},InputValueDefinition:{leave:({description:e,name:t,type:r,defaultValue:n,directives:i})=>Vc("",e,"\n")+qc([t+": "+r,Vc("= ",n),qc(i," ")]," ")},InterfaceTypeDefinition:{leave:({description:e,name:t,interfaces:r,directives:n,fields:i})=>Vc("",e,"\n")+qc(["interface",t,Vc("implements ",qc(r," & ")),qc(n," "),Kc(i)]," ")},UnionTypeDefinition:{leave:({description:e,name:t,directives:r,types:n})=>Vc("",e,"\n")+qc(["union",t,qc(r," "),Vc("= ",qc(n," | "))]," ")},EnumTypeDefinition:{leave:({description:e,name:t,directives:r,values:n})=>Vc("",e,"\n")+qc(["enum",t,qc(r," "),Kc(n)]," ")},EnumValueDefinition:{leave:({description:e,name:t,directives:r})=>Vc("",e,"\n")+qc([t,qc(r," ")]," ")},InputObjectTypeDefinition:{leave:({description:e,name:t,directives:r,fields:n})=>Vc("",e,"\n")+qc(["input",t,qc(r," "),Kc(n)]," ")},DirectiveDefinition:{leave:({description:e,name:t,arguments:r,repeatable:n,locations:i})=>Vc("",e,"\n")+"directive @"+t+(Hc(r)?Vc("(\n",zc(qc(r,"\n")),"\n)"):Vc("(",qc(r,", "),")"))+(n?" repeatable":"")+" on "+qc(i," | ")},SchemaExtension:{leave:({directives:e,operationTypes:t})=>qc(["extend schema",qc(e," "),Kc(t)]," ")},ScalarTypeExtension:{leave:({name:e,directives:t})=>qc(["extend scalar",e,qc(t," ")]," ")},ObjectTypeExtension:{leave:({name:e,interfaces:t,directives:r,fields:n})=>qc(["extend type",e,Vc("implements ",qc(t," & ")),qc(r," "),Kc(n)]," ")},InterfaceTypeExtension:{leave:({name:e,interfaces:t,directives:r,fields:n})=>qc(["extend interface",e,Vc("implements ",qc(t," & ")),qc(r," "),Kc(n)]," ")},UnionTypeExtension:{leave:({name:e,directives:t,types:r})=>qc(["extend union",e,qc(t," "),Vc("= ",qc(r," | "))]," ")},EnumTypeExtension:{leave:({name:e,directives:t,values:r})=>qc(["extend enum",e,qc(t," "),Kc(r)]," ")},InputObjectTypeExtension:{leave:({name:e,directives:t,fields:r})=>qc(["extend input",e,qc(t," "),Kc(r)]," ")}};function qc(e,t=""){var r;return null!==(r=null==e?void 0:e.filter(e=>e).join(t))&&void 0!==r?r:""}function Kc(e){return Vc("{\n",zc(qc(e,"\n")),"\n}")}function Vc(e,t,r=""){return null!=t&&""!==t?e+t+r:""}function zc(e){return Vc("  ",e.replace(/\n/g,"\n  "))}function Hc(e){var t;return null!==(t=null==e?void 0:e.some(e=>e.includes("\n")))&&void 0!==t&&t}function Wc(e,t){var r=e.directives;return!r||!r.length||function(e){var t=[];return e&&e.length&&e.forEach((function(e){if(function(e){var t=e.name.value;return"skip"===t||"include"===t}(e)){var r=e.arguments,n=e.name.value;__DEV__?hc(r&&1===r.length,"Incorrect number of arguments for the @".concat(n," directive.")):hc(r&&1===r.length,38);var i=r[0];__DEV__?hc(i.name&&"if"===i.name.value,"Invalid argument for the @".concat(n," directive.")):hc(i.name&&"if"===i.name.value,39);var o=i.value;__DEV__?hc(o&&("Variable"===o.kind||"BooleanValue"===o.kind),"Argument for the @".concat(n," directive must be a variable or a boolean value.")):hc(o&&("Variable"===o.kind||"BooleanValue"===o.kind),40),t.push({directive:e,ifArgument:i})}})),t}(r).every((function(e){var r=e.directive,n=e.ifArgument,i=!1;return"Variable"===n.value.kind?(i=t&&t[n.value.name.value],__DEV__?hc(void 0!==i,"Invalid variable referenced in @".concat(r.name.value," directive.")):hc(void 0!==i,37)):i=n.value.value,"skip"===r.name.value?!i:i}))}function Gc(e,t){return function(e){var t=[];return Bc(e,{Directive:function(e){t.push(e.name.value)}}),t}(t).some((function(t){return e.indexOf(t)>-1}))}function Yc(e){return e&&Gc(["client"],e)&&Gc(["export"],e)}function Qc(e,t){var r=t,n=[];return e.definitions.forEach((function(e){if("OperationDefinition"===e.kind)throw __DEV__?new dc("Found a ".concat(e.operation," operation").concat(e.name?" named '".concat(e.name.value,"'"):"",". ")+"No operations are allowed when using a fragment as a query. Only fragments are allowed."):new dc(41);"FragmentDefinition"===e.kind&&n.push(e)})),typeof r>"u"&&(__DEV__?hc(1===n.length,"Found ".concat(n.length," fragments. `
											fragmentName` must be provided when there is not exactly 1 fragment.")):hc(1===n.length,42),r=n[0].name.value),Cn(Cn({},e),{definitions:$n([{kind:"OperationDefinition",operation:"query",selectionSet:{kind:"SelectionSet",selections:[{kind:"FragmentSpread",name:{kind:"Name",value:r}}]}}],e.definitions,!0)})}function Jc(e){void 0===e&&(e=[]);var t={};return e.forEach((function(e){t[e.name.value]=e})),t}function Xc(e,t){switch(e.kind){case"InlineFragment":return e;case"FragmentSpread":var r=t&&t[e.name.value];return __DEV__?hc(r,"No fragment named ".concat(e.name.value,".")):hc(r,43),r;default:return null}}function Zc(e){return null!==e&&"object"==typeof e}function el(e){return{__ref:String(e)}}function tl(e){return Boolean(e&&"object"==typeof e&&"string"==typeof e.__ref)}function rl(e,t,r,n){if(function(e){return"IntValue"===e.kind}(r)||function(e){return"FloatValue"===e.kind}(r))e[t.value]=Number(r.value);else if(function(e){return"BooleanValue"===e.kind}(r)||function(e){return"StringValue"===e.kind}(r))e[t.value]=r.value;else if(function(e){return"ObjectValue"===e.kind}(r)){var i={};r.fields.map((function(e){return rl(i,e.name,e.value,n)})),e[t.value]=i}else if(function(e){return"Variable"===e.kind}(r)){var o=(n||{})[r.name.value];e[t.value]=o}else if(function(e){return"ListValue"===e.kind}(r))e[t.value]=r.values.map((function(e){var r={};return rl(r,t,e,n),r[t.value]}));else if(function(e){return"EnumValue"===e.kind}(r))e[t.value]=r.value;else{if(!function(e){return"NullValue"===e.kind}(r))throw __DEV__?new dc('The inline argument "'.concat(t.value,'" of kind "').concat(r.kind,'"')+"is not supported. Use variables instead of inline arguments to overcome this limitation."):new dc(52);e[t.value]=null}}kc(),__DEV__?hc("boolean"==typeof _c,_c):hc("boolean"==typeof _c,36);var nl=["connection","include","skip","client","rest","export"],il=Object.assign((function(e,t,r){if(t&&r&&r.connection&&r.connection.key){if(r.connection.filter&&r.connection.filter.length>0){var n=r.connection.filter?r.connection.filter:[];n.sort();var i={};return n.forEach((function(e){i[e]=t[e]})),"".concat(r.connection.key,"(").concat(ol(i),")")}return r.connection.key}var o=e;if(t){var s=ol(t);o+="(".concat(s,")")}return r&&Object.keys(r).forEach((function(e){-1===nl.indexOf(e)&&(r[e]&&Object.keys(r[e]).length?o+="@".concat(e,"(").concat(ol(r[e]),")"):o+="@".concat(e))})),o}),{setStringify:function(e){var t=ol;return ol=e,t}}),ol=function(e){return JSON.stringify(e,sl)};function sl(e,t){return Zc(t)&&!Array.isArray(t)&&(t=Object.keys(t).sort().reduce((function(e,r){return e[r]=t[r],e}),{})),t}function al(e,t){if(e.arguments&&e.arguments.length){var r={};return e.arguments.forEach((function(e){var n=e.name,i=e.value;return rl(r,n,i,t)})),r}return null}function cl(e){return e.alias?e.alias.value:e.name.value}function ll(e,t,r){if("string"==typeof e.__typename)return e.__typename;for(var n=0,i=t.selections;n<i.length;n++){var o=i[n];if(ul(o)){if("__typename"===o.name.value)return e[cl(o)]}else{var s=ll(e,Xc(o,r).selectionSet,r);if("string"==typeof s)return s}}}function ul(e){return"Field"===e.kind}function dl(e){return"InlineFragment"===e.kind}function hl(e){__DEV__?hc(e&&"Document"===e.kind,'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql'):hc(e&&"Document"===e.kind,44);var t=e.definitions.filter((function(e){return"FragmentDefinition"!==e.kind})).map((function(e){if("OperationDefinition"!==e.kind)throw __DEV__?new dc('Schema type definitions not allowed in queries. Found: "'.concat(e.kind,'"')):new dc(45);return e}));return __DEV__?hc(t.length<=1,"Ambiguous GraphQL document: contains ".concat(t.length," operations")):hc(t.length<=1,46),e}function fl(e){return hl(e),e.definitions.filter((function(e){return"OperationDefinition"===e.kind}))[0]}function pl(e){return e.definitions.filter((function(e){return"OperationDefinition"===e.kind&&e.name})).map((function(e){return e.name.value}))[0]||null}function vl(e){return e.definitions.filter((function(e){return"FragmentDefinition"===e.kind}))}function gl(e){var t=fl(e);return __DEV__?hc(t&&"query"===t.operation,"Must contain a query definition."):hc(t&&"query"===t.operation,47),t}function ml(e){hl(e);for(var t,r=0,n=e.definitions;r<n.length;r++){var i=n[r];if("OperationDefinition"===i.kind){var o=i.operation;if("query"===o||"mutation"===o||"subscription"===o)return i}"FragmentDefinition"===i.kind&&!t&&(t=i)}if(t)return t;throw __DEV__?new dc("Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment."):new dc(51)}function yl(e){var t=Object.create(null),r=e&&e.variableDefinitions;return r&&r.length&&r.forEach((function(e){e.defaultValue&&rl(t,e.variable.name,e.defaultValue)})),t}function bl(e,t,r){var n=0;return e.forEach((function(r,i){t.call(this,r,i,e)&&(e[n++]=r)}),r),e.length=n,e}var _l={kind:"Field",name:{kind:"Name",value:"__typename"}};function wl(e){return function e(t,r){return t.selectionSet.selections.every((function(t){return"FragmentSpread"===t.kind&&e(r[t.name.value],r)}))}(fl(e)||function(e){__DEV__?hc("Document"===e.kind,'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql'):hc("Document"===e.kind,48),__DEV__?hc(e.definitions.length<=1,"Fragment must have exactly one definition."):hc(e.definitions.length<=1,49);var t=e.definitions[0];return __DEV__?hc("FragmentDefinition"===t.kind,"Must be a fragment definition."):hc("FragmentDefinition"===t.kind,50),t}(e),Jc(vl(e)))?null:e}function Sl(e){return function(t){return e.some((function(e){return e.name&&e.name===t.name.value||e.test&&e.test(t)}))}}function El(e,t){var r=Object.create(null),n=[],i=Object.create(null),o=[],s=wl(Bc(t,{Variable:{enter:function(e,t,n){"VariableDefinition"!==n.kind&&(r[e.name.value]=!0)}},Field:{enter:function(t){if(e&&t.directives&&(e.some((function(e){return e.remove}))&&t.directives&&t.directives.some(Sl(e))))return t.arguments&&t.arguments.forEach((function(e){"Variable"===e.value.kind&&n.push({name:e.value.name.value})})),t.selectionSet&&function e(t){var r=[];return t.selections.forEach((function(t){(ul(t)||dl(t))&&t.selectionSet?e(t.selectionSet).forEach((function(e){return r.push(e)})):"FragmentSpread"===t.kind&&r.push(t)})),r}(t.selectionSet).forEach((function(e){o.push({name:e.name.value})})),null}},FragmentSpread:{enter:function(e){i[e.name.value]=!0}},Directive:{enter:function(t){if(Sl(e)(t))return null}}}));return s&&bl(n,(function(e){return!!e.name&&!r[e.name]})).length&&(s=function(e,t){var r=function(e){return function(t){return e.some((function(e){return t.value&&"Variable"===t.value.kind&&t.value.name&&(e.name===t.value.name.value||e.test&&e.test(t))}))}}(e);return wl(Bc(t,{OperationDefinition:{enter:function(t){return Cn(Cn({},t),{variableDefinitions:t.variableDefinitions?t.variableDefinitions.filter((function(t){return!e.some((function(e){return e.name===t.variable.name.value}))})):[]})}},Field:{enter:function(t){if(e.some((function(e){return e.remove}))){var n=0;if(t.arguments&&t.arguments.forEach((function(e){r(e)&&(n+=1)})),1===n)return null}}},Argument:{enter:function(e){if(r(e))return null}}}))}(n,s)),s&&bl(o,(function(e){return!!e.name&&!i[e.name]})).length&&(s=function(e,t){function r(t){if(e.some((function(e){return e.name===t.name.value})))return null}return wl(Bc(t,{FragmentSpread:{enter:r},FragmentDefinition:{enter:r}}))}(o,s)),s}var kl=Object.assign((function(e){return Bc(e,{SelectionSet:{enter:function(e,t,r){if(!r||"OperationDefinition"!==r.kind){var n=e.selections;if(n)if(!n.some((function(e){return ul(e)&&("__typename"===e.name.value||0===e.name.value.lastIndexOf("__",0))}))){var i=r;if(!(ul(i)&&i.directives&&i.directives.some((function(e){return"export"===e.name.value}))))return Cn(Cn({},e),{selections:$n($n([],n,!0),[_l],!1)})}}}}})}),{added:function(e){return e===_l}}),Tl={test:function(e){var t="connection"===e.name.value;return t&&(!e.arguments||!e.arguments.some((function(e){return"key"===e.name.value})))&&__DEV__&&hc.warn("Removing an @connection directive even though it does not have a key. You may want to use the key parameter to specify a store key."),t}};function Il(e){return"query"===ml(e).operation?e:Bc(e,{OperationDefinition:{enter:function(e){return Cn(Cn({},e),{operation:"query"})}}})}var Rl=Object.prototype.hasOwnProperty;function Cl(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return Ml(e)}function Ml(e){var t=e[0]||{},r=e.length;if(r>1)for(var n=new Ol,i=1;i<r;++i)t=n.merge(t,e[i]);return t}var xl=function(e,t,r){return this.merge(e[r],t[r])},Ol=function(){function e(e){void 0===e&&(e=xl),this.reconciler=e,this.isObject=Zc,this.pastCopies=new Set}return e.prototype.merge=function(e,t){for(var r=this,n=[],i=2;i<arguments.length;i++)n[i-2]=arguments[i];return Zc(t)&&Zc(e)?(Object.keys(t).forEach((function(i){if(Rl.call(e,i)){var o=e[i];if(t[i]!==o){var s=r.reconciler.apply(r,$n([e,t,i],n,!1));s!==o&&((e=r.shallowCopyForMerge(e))[i]=s)}}else(e=r.shallowCopyForMerge(e))[i]=t[i]})),e):t},e.prototype.shallowCopyForMerge=function(e){return Zc(e)&&(this.pastCopies.has(e)||(e=Array.isArray(e)?e.slice(0):Cn({__proto__:Object.getPrototypeOf(e)},e),this.pastCopies.add(e))),e},e}();function Al(e,t){var r=typeof Symbol<"u"&&e[Symbol.iterator]||e["@@iterator"];if(r)return(r=r.call(e)).next.bind(r);if(Array.isArray(e)||(r=function(e,t){if(e){if("string"==typeof e)return Pl(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);if("Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r)return Array.from(e);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return Pl(e,t)}}(e))||t&&e&&"number"==typeof e.length){r&&(e=r);var n=0;return function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function Pl(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function Dl(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function jl(e,t,r){return t&&Dl(e.prototype,t),r&&Dl(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}var Ll=function(){return"function"==typeof Symbol},Nl=function(e){return Ll()&&Boolean(Symbol[e])},Bl=function(e){return Nl(e)?Symbol[e]:"@@"+e};Ll()&&!Nl("observable")&&(Symbol.observable=Symbol("observable"));var Ul=Bl("iterator"),Fl=Bl("observable"),$l=Bl("species");function ql(e,t){var r=e[t];if(null!=r){if("function"!=typeof r)throw new TypeError(r+" is not a function");return r}}function Kl(e){var t=e.constructor;return void 0!==t&&(null===(t=t[$l])&&(t=void 0)),void 0!==t?t:Xl}function Vl(e){Vl.log?Vl.log(e):setTimeout((function(){throw e}))}function zl(e){Promise.resolve().then((function(){try{e()}catch(t){Vl(t)}}))}function Hl(e){var t=e._cleanup;if(void 0!==t&&(e._cleanup=void 0,t))try{if("function"==typeof t)t();else{var r=ql(t,"unsubscribe");r&&r.call(t)}}catch(n){Vl(n)}}function Wl(e){e._observer=void 0,e._queue=void 0,e._state="closed"}function Gl(e,t,r){e._state="running";var n=e._observer;try{var i=ql(n,t);switch(t){case"next":i&&i.call(n,r);break;case"error":if(Wl(e),!i)throw r;i.call(n,r);break;case"complete":Wl(e),i&&i.call(n)}}catch(o){Vl(o)}"closed"===e._state?Hl(e):"running"===e._state&&(e._state="ready")}function Yl(e,t,r){if("closed"!==e._state){if("buffering"===e._state)return void e._queue.push({type:t,value:r});if("ready"!==e._state)return e._state="buffering",e._queue=[{type:t,value:r}],void zl((function(){return function(e){var t=e._queue;if(t){e._queue=void 0,e._state="ready";for(var r=0;r<t.length&&(Gl(e,t[r].type,t[r].value),"closed"!==e._state);++r);}}(e)}));Gl(e,t,r)}}var Ql=function(){function e(e,t){this._cleanup=void 0,this._observer=e,this._queue=void 0,this._state="initializing";var r=new Jl(this);try{this._cleanup=t.call(void 0,r)}catch(n){r.error(n)}"initializing"===this._state&&(this._state="ready")}return e.prototype.unsubscribe=function(){"closed"!==this._state&&(Wl(this),Hl(this))},jl(e,[{key:"closed",get:function(){return"closed"===this._state}}]),e}(),Jl=function(){function e(e){this._subscription=e}var t=e.prototype;return t.next=function(e){Yl(this._subscription,"next",e)},t.error=function(e){Yl(this._subscription,"error",e)},t.complete=function(){Yl(this._subscription,"complete")},jl(e,[{key:"closed",get:function(){return"closed"===this._subscription._state}}]),e}(),Xl=function(){function e(t){if(!(this instanceof e))throw new TypeError("Observable cannot be called as a function");if("function"!=typeof t)throw new TypeError("Observable initializer must be a function");this._subscriber=t}var t=e.prototype;return t.subscribe=function(e){return("object"!=typeof e||null===e)&&(e={next:e,error:arguments[1],complete:arguments[2]}),new Ql(e,this._subscriber)},t.forEach=function(e){var t=this;return new Promise((function(r,n){if("function"==typeof e)var i=t.subscribe({next:function(t){try{e(t,o)}catch(r){n(r),i.unsubscribe()}},error:n,complete:r});else n(new TypeError(e+" is not a function"));function o(){i.unsubscribe(),r()}}))},t.map=function(e){var t=this;if("function"!=typeof e)throw new TypeError(e+" is not a function");return new(Kl(this))((function(r){return t.subscribe({next:function(t){try{t=e(t)}catch(n){return r.error(n)}r.next(t)},error:function(e){r.error(e)},complete:function(){r.complete()}})}))},t.filter=function(e){var t=this;if("function"!=typeof e)throw new TypeError(e+" is not a function");return new(Kl(this))((function(r){return t.subscribe({next:function(t){try{if(!e(t))return}catch(n){return r.error(n)}r.next(t)},error:function(e){r.error(e)},complete:function(){r.complete()}})}))},t.reduce=function(e){var t=this;if("function"!=typeof e)throw new TypeError(e+" is not a function");var r=Kl(this),n=arguments.length>1,i=!1,o=arguments[1],s=o;return new r((function(r){return t.subscribe({next:function(t){var o=!i;if(i=!0,!o||n)try{s=e(s,t)}catch(a){return r.error(a)}else s=t},error:function(e){r.error(e)},complete:function(){if(!i&&!n)return r.error(new TypeError("Cannot reduce an empty sequence"));r.next(s),r.complete()}})}))},t.concat=function(){for(var e=this,t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];var i=Kl(this);return new i((function(t){var n,o=0;return function e(s){n=s.subscribe({next:function(e){t.next(e)},error:function(e){t.error(e)},complete:function(){o===r.length?(n=void 0,t.complete()):e(i.from(r[o++]))}})}(e),function(){n&&(n.unsubscribe(),n=void 0)}}))},t.flatMap=function(e){var t=this;if("function"!=typeof e)throw new TypeError(e+" is not a function");var r=Kl(this);return new r((function(n){var i=[],o=t.subscribe({next:function(t){if(e)try{t=e(t)}catch(a){return n.error(a)}var o=r.from(t).subscribe({next:function(e){n.next(e)},error:function(e){n.error(e)},complete:function(){var e=i.indexOf(o);e>=0&&i.splice(e,1),s()}});i.push(o)},error:function(e){n.error(e)},complete:function(){s()}});function s(){o.closed&&0===i.length&&n.complete()}return function(){i.forEach((function(e){return e.unsubscribe()})),o.unsubscribe()}}))},t[Fl]=function(){return this},e.from=function(t){var r="function"==typeof this?this:e;if(null==t)throw new TypeError(t+" is not an object");var n=ql(t,Fl);if(n){var i=n.call(t);if(Object(i)!==i)throw new TypeError(i+" is not an object");return function(e){return e instanceof Xl}(i)&&i.constructor===r?i:new r((function(e){return i.subscribe(e)}))}if(Nl("iterator")&&(n=ql(t,Ul)))return new r((function(e){zl((function(){if(!e.closed){for(var r,i=Al(n.call(t));!(r=i()).done;){var o=r.value;if(e.next(o),e.closed)return}e.complete()}}))}));if(Array.isArray(t))return new r((function(e){zl((function(){if(!e.closed){for(var r=0;r<t.length;++r)if(e.next(t[r]),e.closed)return;e.complete()}}))}));throw new TypeError(t+" is not observable")},e.of=function(){for(var t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];var i="function"==typeof this?this:e;return new i((function(e){zl((function(){if(!e.closed){for(var t=0;t<r.length;++t)if(e.next(r[t]),e.closed)return;e.complete()}}))}))},jl(e,null,[{key:$l,get:function(){return this}}]),e}();Ll()&&Object.defineProperty(Xl,Symbol("extensions"),{value:{symbol:Fl,hostReportError:Vl},configurable:!0});!function(e){var t,r=e.Symbol;if("function"==typeof r)if(r.observable)t=r.observable;else{t="function"==typeof r.for?r.for("https://github.com/benlesh/symbol-observable"):r("https://github.com/benlesh/symbol-observable");try{r.observable=t}catch{}}else t="@@observable"}(typeof self<"u"?self:typeof window<"u"?window:typeof e<"u"?e:typeof n<"u"?n:Function("return this")());var Zl=Xl.prototype,eu="@@observable";Zl[eu]||(Zl[eu]=function(){return this});var tu=Object.prototype.toString;function ru(e){return function e(t,r){switch(tu.call(t)){case"[object Array]":if((r=r||new Map).has(t))return r.get(t);var n=t.slice(0);return r.set(t,n),n.forEach((function(t,i){n[i]=e(t,r)})),n;case"[object Object]":if((r=r||new Map).has(t))return r.get(t);var i=Object.create(Object.getPrototypeOf(t));return r.set(t,i),Object.keys(t).forEach((function(n){i[n]=e(t[n],r)})),i;default:return t}}(e)}function nu(e){var t=new Set([e]);return t.forEach((function(e){Zc(e)&&function(e){if(__DEV__&&!Object.isFrozen(e))try{Object.freeze(e)}catch(t){if(t instanceof TypeError)return null;throw t}return e}(e)===e&&Object.getOwnPropertyNames(e).forEach((function(r){Zc(e[r])&&t.add(e[r])}))})),e}function iu(e){return __DEV__&&nu(e),e}function ou(e,t,r){var n=[];e.forEach((function(e){return e[t]&&n.push(e)})),n.forEach((function(e){return e[t](r)}))}function su(e,t,r){return new Xl((function(n){var i=n.next,o=n.error,s=n.complete,a=0,c=!1,l={then:function(e){return new Promise((function(t){return t(e())}))}};function u(e,t){return e?function(t){++a;var r=function(){return e(t)};l=l.then(r,r).then((function(e){--a,i&&i.call(n,e),c&&d.complete()}),(function(e){throw--a,e})).catch((function(e){o&&o.call(n,e)}))}:function(e){return t&&t.call(n,e)}}var d={next:u(t,i),error:u(r,o),complete:function(){c=!0,a||s&&s.call(n)}},h=e.subscribe(d);return function(){return h.unsubscribe()}}))}var au="function"==typeof WeakMap&&"ReactNative"!==gc((function(){return navigator.product})),cu="function"==typeof WeakSet,lu="function"==typeof Symbol&&"function"==typeof Symbol.for;gc((function(){return window.document.createElement})),gc((function(){return navigator.userAgent.indexOf("jsdom")>=0}));function uu(e){function t(t){Object.defineProperty(e,t,{value:Xl})}return lu&&Symbol.species&&t(Symbol.species),t("@@species"),e}function du(e){return e&&"function"==typeof e.then}var hu=function(e){function t(t){var r=e.call(this,(function(e){return r.addObserver(e),function(){return r.removeObserver(e)}}))||this;return r.observers=new Set,r.addCount=0,r.promise=new Promise((function(e,t){r.resolve=e,r.reject=t})),r.handlers={next:function(e){null!==r.sub&&(r.latest=["next",e],ou(r.observers,"next",e))},error:function(e){var t=r.sub;null!==t&&(t&&setTimeout((function(){return t.unsubscribe()})),r.sub=null,r.latest=["error",e],r.reject(e),ou(r.observers,"error",e))},complete:function(){var e=r.sub;if(null!==e){var t=r.sources.shift();t?du(t)?t.then((function(e){return r.sub=e.subscribe(r.handlers)})):r.sub=t.subscribe(r.handlers):(e&&setTimeout((function(){return e.unsubscribe()})),r.sub=null,r.latest&&"next"===r.latest[0]?r.resolve(r.latest[1]):r.resolve(),ou(r.observers,"complete"))}}},r.cancel=function(e){r.reject(e),r.sources=[],r.handlers.complete()},r.promise.catch((function(e){})),"function"==typeof t&&(t=[new Xl(t)]),du(t)?t.then((function(e){return r.start(e)}),r.handlers.error):r.start(t),r}return Rn(t,e),t.prototype.start=function(e){void 0===this.sub&&(this.sources=Array.from(e),this.handlers.complete())},t.prototype.deliverLastMessage=function(e){if(this.latest){var t=this.latest[0],r=e[t];r&&r.call(e,this.latest[1]),null===this.sub&&"next"===t&&e.complete&&e.complete()}},t.prototype.addObserver=function(e){this.observers.has(e)||(this.deliverLastMessage(e),this.observers.add(e),++this.addCount)},t.prototype.removeObserver=function(e,t){this.observers.delete(e)&&--this.addCount<1&&!t&&this.handlers.complete()},t.prototype.cleanup=function(e){var t=this,r=!1,n=function(){r||(r=!0,t.observers.delete(i),e())},i={next:n,error:n,complete:n},o=this.addCount;this.addObserver(i),this.addCount=o},t}(Xl);function fu(e){return Array.isArray(e)&&e.length>0}function pu(e){return e.errors&&e.errors.length>0||!1}function vu(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var r=Object.create(null);return e.forEach((function(e){!e||Object.keys(e).forEach((function(t){var n=e[t];void 0!==n&&(r[t]=n)}))})),r}uu(hu);var gu=new Map;function mu(e){var t=gu.get(e)||1;return gu.set(e,t+1),"".concat(e,":").concat(t,":").concat(Math.random().toString(36).slice(2))}function yu(e,t){return vu(e,t,t.variables&&{variables:Cn(Cn({},e&&e.variables),t.variables)})}function bu(e){return new Xl((function(t){t.error(e)}))}var _u=function(e,t,r){var n=new Error(r);throw n.name="ServerError",n.response=e,n.statusCode=e.status,n.result=t,n};function wu(e,t){return t?t(e):Xl.of()}function Su(e){return"function"==typeof e?new Tu(e):e}function Eu(e){return e.request.length<=1}var ku=function(e){function t(t,r){var n=e.call(this,t)||this;return n.link=r,n}return Rn(t,e),t}(Error),Tu=function(){function e(e){e&&(this.request=e)}return e.empty=function(){return new e((function(){return Xl.of()}))},e.from=function(t){return 0===t.length?e.empty():t.map(Su).reduce((function(e,t){return e.concat(t)}))},e.split=function(t,r,n){var i=Su(r),o=Su(n||new e(wu));return Eu(i)&&Eu(o)?new e((function(e){return t(e)?i.request(e)||Xl.of():o.request(e)||Xl.of()})):new e((function(e,r){return t(e)?i.request(e,r)||Xl.of():o.request(e,r)||Xl.of()}))},e.execute=function(e,t){return e.request(function(e,t){var r=Cn({},e);return Object.defineProperty(t,"setContext",{enumerable:!1,value:function(e){r=Cn(Cn({},r),"function"==typeof e?e(r):e)}}),Object.defineProperty(t,"getContext",{enumerable:!1,value:function(){return Cn({},r)}}),t}(t.context,function(e){var t={variables:e.variables||{},extensions:e.extensions||{},operationName:e.operationName,query:e.query};return t.operationName||(t.operationName="string"!=typeof t.query?pl(t.query)||void 0:""),t}(function(e){for(var t=["query","operationName","variables","extensions","context"],r=0,n=Object.keys(e);r<n.length;r++){var i=n[r];if(t.indexOf(i)<0)throw __DEV__?new dc("illegal argument: ".concat(i)):new dc(24)}return e}(t))))||Xl.of()},e.concat=function(t,r){var n=Su(t);if(Eu(n))return __DEV__&&hc.warn(new ku("You are calling concat on a terminating link, which will have no effect",n)),n;var i=Su(r);return Eu(i)?new e((function(e){return n.request(e,(function(e){return i.request(e)||Xl.of()}))||Xl.of()})):new e((function(e,t){return n.request(e,(function(e){return i.request(e,t)||Xl.of()}))||Xl.of()}))},e.prototype.split=function(t,r,n){return this.concat(e.split(t,r,n||new e(wu)))},e.prototype.concat=function(t){return e.concat(this,t)},e.prototype.request=function(e,t){throw __DEV__?new dc("request is not implemented"):new dc(19)},e.prototype.onError=function(e,t){if(t&&t.error)return t.error(e),!1;throw e},e.prototype.setOnError=function(e){return this.onError=e,this},e}(),Iu=Tu.execute,Ru="3.6.9",Cu=Object.prototype.hasOwnProperty;var Mu=function(e,t){var r;try{r=JSON.stringify(e)}catch(i){var n=__DEV__?new dc("Network request failed. ".concat(t," is not serializable: ").concat(i.message)):new dc(21);throw n.parseError=i,n}return r},xu={http:{includeQuery:!0,includeExtensions:!1},headers:{accept:"*/*","content-type":"application/json"},options:{method:"POST"}},Ou=function(e,t){return t(e)};function Au(e){if(e){var t=Object.create(null);return Object.keys(Object(e)).forEach((function(r){t[r.toLowerCase()]=e[r]})),t}return e}var Pu=gc((function(){return fetch})),Du=function(e){void 0===e&&(e={});var t=e.uri,r=void 0===t?"/graphql":t,n=e.fetch,i=e.print,o=void 0===i?Ou:i,s=e.includeExtensions,a=e.useGETForQueries,c=e.includeUnusedVariables,l=void 0!==c&&c,u=Mn(e,["uri","fetch","print","includeExtensions","useGETForQueries","includeUnusedVariables"]);__DEV__&&function(e){if(!e&&typeof fetch>"u")throw __DEV__?new dc("\n\"fetch\" has not been found globally and no fetcher has been configured. To fix this, install a fetch package (like https://www.npmjs.com/package/cross-fetch), instantiate the fetcher, and pass it into your HttpLink constructor. For example:\n\nimport fetch from 'cross-fetch';\nimport { ApolloClient, HttpLink } from '@apollo/client';\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: '/graphql', fetch })\n});\n    "):new dc(20)}(n||Pu);var d={http:{includeExtensions:s},options:u.fetchOptions,credentials:u.credentials,headers:u.headers};return new Tu((function(e){var t=function(e,t){return e.getContext().uri||("function"==typeof t?t(e):t||"/graphql")}(e,r),s=e.getContext(),c={};if(s.clientAwareness){var u=s.clientAwareness,h=u.name,f=u.version;h&&(c["apollographql-client-name"]=h),f&&(c["apollographql-client-version"]=f)}var p,v=Cn(Cn({},c),s.headers),g={http:s.http,options:s.fetchOptions,credentials:s.credentials,headers:v},m=function(e,t){for(var r=[],n=2;n<arguments.length;n++)r[n-2]=arguments[n];var i={},o={};r.forEach((function(e){i=Cn(Cn(Cn({},i),e.options),{headers:Cn(Cn({},i.headers),Au(e.headers))}),e.credentials&&(i.credentials=e.credentials),o=Cn(Cn({},o),e.http)}));var s=e.operationName,a=e.extensions,c=e.variables,l=e.query,u={operationName:s,variables:c};return o.includeExtensions&&(u.extensions=a),o.includeQuery&&(u.query=t(l,Fc)),{options:i,body:u}}(e,o,xu,d,g),y=m.options,b=m.body;if(b.variables&&!l){var _=new Set(Object.keys(b.variables));Bc(e.query,{Variable:function(e,t,r){r&&"VariableDefinition"!==r.kind&&_.delete(e.name.value)}}),_.size&&(b.variables=Cn({},b.variables),_.forEach((function(e){delete b.variables[e]})))}if(!y.signal){var w=function(){if(typeof AbortController>"u")return{controller:!1,signal:!1};var e=new AbortController;return{controller:e,signal:e.signal}}(),S=w.controller,E=w.signal;(p=S)&&(y.signal=E)}if(a&&!e.query.definitions.some((function(e){return"OperationDefinition"===e.kind&&"mutation"===e.operation}))&&(y.method="GET"),"GET"===y.method){var k=function(e,t){var r=[],n=function(e,t){r.push("".concat(e,"=").concat(encodeURIComponent(t)))};if("query"in t&&n("query",t.query),t.operationName&&n("operationName",t.operationName),t.variables){var i=void 0;try{i=Mu(t.variables,"Variables map")}catch(d){return{parseError:d}}n("variables",i)}if(t.extensions){var o=void 0;try{o=Mu(t.extensions,"Extensions map")}catch(d){return{parseError:d}}n("extensions",o)}var s="",a=e,c=e.indexOf("#");-1!==c&&(s=e.substr(c),a=e.substr(0,c));var l=-1===a.indexOf("?")?"?":"&";return{newURI:a+l+r.join("&")+s}}(t,b),T=k.newURI,I=k.parseError;if(I)return bu(I);t=T}else try{y.body=Mu(b,"Payload")}catch(R){return bu(R)}return new Xl((function(r){return(n||gc((function(){return fetch}))||Pu)(t,y).then((function(t){return e.setContext({response:t}),t})).then(function(e){return function(t){return t.text().then((function(e){try{return JSON.parse(e)}catch(i){var r=i;throw r.name="ServerParseError",r.response=t,r.statusCode=t.status,r.bodyText=e,r}})).then((function(r){return t.status>=300&&_u(t,r,"Response not successful: Received status code ".concat(t.status)),!Array.isArray(r)&&!Cu.call(r,"data")&&!Cu.call(r,"errors")&&_u(t,r,"Server response was missing for query '".concat(Array.isArray(e)?e.map((function(e){return e.operationName})):e.operationName,"'.")),r}))}}(e)).then((function(e){return r.next(e),r.complete(),e})).catch((function(e){"AbortError"!==e.name&&(e.result&&e.result.errors&&e.result.data&&r.next(e.result),r.error(e))})),function(){p&&p.abort()}}))}))},ju=function(e){function t(t){void 0===t&&(t={});var r=e.call(this,Du(t).request)||this;return r.options=t,r}return Rn(t,e),t}(Tu),Lu=Object.prototype,Nu=Lu.toString,Bu=Lu.hasOwnProperty,Uu=Function.prototype.toString,Fu=new Map;function $u(e,t){try{return function e(t,r){if(t===r)return!0;var n=Nu.call(t),i=Nu.call(r);if(n!==i)return!1;switch(n){case"[object Array]":if(t.length!==r.length)return!1;case"[object Object]":if(zu(t,r))return!0;var o=qu(t),s=qu(r),a=o.length;if(a!==s.length)return!1;for(var c=0;c<a;++c)if(!Bu.call(r,o[c]))return!1;for(c=0;c<a;++c){var l=o[c];if(!e(t[l],r[l]))return!1}return!0;case"[object Error]":return t.name===r.name&&t.message===r.message;case"[object Number]":if(t!=t)return r!=r;case"[object Boolean]":case"[object Date]":return+t==+r;case"[object RegExp]":case"[object String]":return t=="".concat(r);case"[object Map]":case"[object Set]":if(t.size!==r.size)return!1;if(zu(t,r))return!0;for(var u=t.entries(),d="[object Map]"===n;;){var h=u.next();if(h.done)break;var f=h.value,p=f[0],v=f[1];if(!r.has(p)||d&&!e(v,r.get(p)))return!1}return!0;case"[object Uint16Array]":case"[object Uint8Array]":case"[object Uint32Array]":case"[object Int32Array]":case"[object Int8Array]":case"[object Int16Array]":case"[object ArrayBuffer]":t=new Uint8Array(t),r=new Uint8Array(r);case"[object DataView]":var g=t.byteLength;if(g===r.byteLength)for(;g--&&t[g]===r[g];);return-1===g;case"[object AsyncFunction]":case"[object GeneratorFunction]":case"[object AsyncGeneratorFunction]":case"[object Function]":var m=Uu.call(t);return m===Uu.call(r)&&!function(e,t){var r=e.length-t.length;return r>=0&&e.indexOf(t,r)===r}(m,Vu)}return!1}(e,t)}finally{Fu.clear()}}function qu(e){return Object.keys(e).filter(Ku,e)}function Ku(e){return void 0!==this[e]}var Vu="{ [native code] }";function zu(e,t){var r=Fu.get(e);if(r){if(r.has(t))return!0}else Fu.set(e,r=new Set);return r.add(t),!1}var Hu=function(){return Object.create(null)},Wu=Array.prototype,Gu=Wu.forEach,Yu=Wu.slice,Qu=function(){function e(e,t){void 0===e&&(e=!0),void 0===t&&(t=Hu),this.weakness=e,this.makeData=t}return e.prototype.lookup=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return this.lookupArray(e)},e.prototype.lookupArray=function(e){var t=this;return Gu.call(e,(function(e){return t=t.getChildTrie(e)})),t.data||(t.data=this.makeData(Yu.call(e)))},e.prototype.getChildTrie=function(t){var r=this.weakness&&function(e){switch(typeof e){case"object":if(null===e)break;case"function":return!0}return!1}(t)?this.weak||(this.weak=new WeakMap):this.strong||(this.strong=new Map),n=r.get(t);return n||r.set(t,n=new e(this.weakness,this.makeData)),n},e}();var Ju=null,Xu={},Zu=1,ed="@wry/context:Slot",td=Array,rd=td[ed]||function(){var e=function(){function e(){this.id=["slot",Zu++,Date.now(),Math.random().toString(36).slice(2)].join(":")}return e.prototype.hasValue=function(){for(var e=Ju;e;e=e.parent)if(this.id in e.slots){var t=e.slots[this.id];if(t===Xu)break;return e!==Ju&&(Ju.slots[this.id]=t),!0}return Ju&&(Ju.slots[this.id]=Xu),!1},e.prototype.getValue=function(){if(this.hasValue())return Ju.slots[this.id]},e.prototype.withValue=function(e,t,r,n){var i,o=((i={__proto__:null})[this.id]=e,i),s=Ju;Ju={parent:s,slots:o};try{return t.apply(n,r)}finally{Ju=s}},e.bind=function(e){var t=Ju;return function(){var r=Ju;try{return Ju=t,e.apply(this,arguments)}finally{Ju=r}}},e.noContext=function(e,t,r){if(!Ju)return e.apply(r,t);var n=Ju;try{return Ju=null,e.apply(r,t)}finally{Ju=n}},e}();try{Object.defineProperty(td,ed,{value:td[ed]=e,enumerable:!1,writable:!1,configurable:!1})}finally{return e}}();rd.bind,rd.noContext;function nd(){}var id,od=function(){function e(e,t){void 0===e&&(e=1/0),void 0===t&&(t=nd),this.max=e,this.dispose=t,this.map=new Map,this.newest=null,this.oldest=null}return e.prototype.has=function(e){return this.map.has(e)},e.prototype.get=function(e){var t=this.getNode(e);return t&&t.value},e.prototype.getNode=function(e){var t=this.map.get(e);if(t&&t!==this.newest){var r=t.older,n=t.newer;n&&(n.older=r),r&&(r.newer=n),t.older=this.newest,t.older.newer=t,t.newer=null,this.newest=t,t===this.oldest&&(this.oldest=n)}return t},e.prototype.set=function(e,t){var r=this.getNode(e);return r?r.value=t:(r={key:e,value:t,newer:null,older:this.newest},this.newest&&(this.newest.newer=r),this.newest=r,this.oldest=this.oldest||r,this.map.set(e,r),r.value)},e.prototype.clean=function(){for(;this.oldest&&this.map.size>this.max;)this.delete(this.oldest.key)},e.prototype.delete=function(e){var t=this.map.get(e);return!!t&&(t===this.newest&&(this.newest=t.older),t===this.oldest&&(this.oldest=t.newer),t.newer&&(t.newer.older=t.older),t.older&&(t.older.newer=t.newer),this.map.delete(e),this.dispose(t.value,e),!0)},e}(),sd=new rd,ad=Object.prototype.hasOwnProperty,cd=void 0===(id=Array.from)?function(e){var t=[];return e.forEach((function(e){return t.push(e)})),t}:id;function ld(e){var t=e.unsubscribe;"function"==typeof t&&(e.unsubscribe=void 0,t())}var ud=[],dd=100;function hd(e,t){if(!e)throw new Error(t||"assertion failure")}function fd(e){switch(e.length){case 0:throw new Error("unknown value");case 1:return e[0];case 2:throw e[1]}}var pd=function(){function e(t){this.fn=t,this.parents=new Set,this.childValues=new Map,this.dirtyChildren=null,this.dirty=!0,this.recomputing=!1,this.value=[],this.deps=null,++e.count}return e.prototype.peek=function(){if(1===this.value.length&&!md(this))return vd(this),this.value[0]},e.prototype.recompute=function(e){return hd(!this.recomputing,"already recomputing"),vd(this),md(this)?function(e,t){return kd(e),sd.withValue(e,gd,[e,t]),function(e,t){if("function"==typeof e.subscribe)try{ld(e),e.unsubscribe=e.subscribe.apply(null,t)}catch{return e.setDirty(),!1}return!0}(e,t)&&function(e){e.dirty=!1,!md(e)&&bd(e)}(e),fd(e.value)}(this,e):fd(this.value)},e.prototype.setDirty=function(){this.dirty||(this.dirty=!0,this.value.length=0,yd(this),ld(this))},e.prototype.dispose=function(){var e=this;this.setDirty(),kd(this),_d(this,(function(t,r){t.setDirty(),Td(t,e)}))},e.prototype.forget=function(){this.dispose()},e.prototype.dependOn=function(e){e.add(this),this.deps||(this.deps=ud.pop()||new Set),this.deps.add(e)},e.prototype.forgetDeps=function(){var e=this;this.deps&&(cd(this.deps).forEach((function(t){return t.delete(e)})),this.deps.clear(),ud.push(this.deps),this.deps=null)},e.count=0,e}();function vd(e){var t=sd.getValue();if(t)return e.parents.add(t),t.childValues.has(e)||t.childValues.set(e,[]),md(e)?wd(t,e):Sd(t,e),t}function gd(e,t){e.recomputing=!0,e.value.length=0;try{e.value[0]=e.fn.apply(null,t)}catch(r){e.value[1]=r}e.recomputing=!1}function md(e){return e.dirty||!(!e.dirtyChildren||!e.dirtyChildren.size)}function yd(e){_d(e,wd)}function bd(e){_d(e,Sd)}function _d(e,t){var r=e.parents.size;if(r)for(var n=cd(e.parents),i=0;i<r;++i)t(n[i],e)}function wd(e,t){hd(e.childValues.has(t)),hd(md(t));var r=!md(e);if(e.dirtyChildren){if(e.dirtyChildren.has(t))return}else e.dirtyChildren=ud.pop()||new Set;e.dirtyChildren.add(t),r&&yd(e)}function Sd(e,t){hd(e.childValues.has(t)),hd(!md(t));var r=e.childValues.get(t);0===r.length?e.childValues.set(t,function(e){return e.slice(0)}(t.value)):function(e,t){var r=e.length;return r>0&&r===t.length&&e[r-1]===t[r-1]}(r,t.value)||e.setDirty(),Ed(e,t),!md(e)&&bd(e)}function Ed(e,t){var r=e.dirtyChildren;r&&(r.delete(t),0===r.size&&(ud.length<dd&&ud.push(r),e.dirtyChildren=null))}function kd(e){e.childValues.size>0&&e.childValues.forEach((function(t,r){Td(e,r)})),e.forgetDeps(),hd(null===e.dirtyChildren)}function Td(e,t){t.parents.delete(e),e.childValues.delete(t),Ed(e,t)}var Id={setDirty:!0,dispose:!0,forget:!0};function Rd(e){var t=new Map,r=e&&e.subscribe;function n(e){var n=sd.getValue();if(n){var i=t.get(e);i||t.set(e,i=new Set),n.dependOn(i),"function"==typeof r&&(ld(i),i.unsubscribe=r(e))}}return n.dirty=function(e,r){var n=t.get(e);if(n){var i=r&&ad.call(Id,r)?r:"setDirty";cd(n).forEach((function(e){return e[i]()})),t.delete(e),ld(n)}},n}function Cd(){var e=new Qu("function"==typeof WeakMap);return function(){return e.lookupArray(arguments)}}Cd();var Md=new Set;function xd(e,t){void 0===t&&(t=Object.create(null));var r=new od(t.max||Math.pow(2,16),(function(e){return e.dispose()})),n=t.keyArgs,i=t.makeCacheKey||Cd(),o=function(){var o=i.apply(null,n?n.apply(null,arguments):arguments);if(void 0===o)return e.apply(null,arguments);var s=r.get(o);s||(r.set(o,s=new pd(e)),s.subscribe=t.subscribe,s.forget=function(){return r.delete(o)});var a=s.recompute(Array.prototype.slice.call(arguments));return r.set(o,s),Md.add(r),sd.hasValue()||(Md.forEach((function(e){return e.clean()})),Md.clear()),a};function s(e){var t=r.get(e);t&&t.setDirty()}function a(e){var t=r.get(e);if(t)return t.peek()}function c(e){return r.delete(e)}return Object.defineProperty(o,"size",{get:function(){return r.map.size},configurable:!1,enumerable:!1}),o.dirtyKey=s,o.dirty=function(){s(i.apply(null,arguments))},o.peekKey=a,o.peek=function(){return a(i.apply(null,arguments))},o.forgetKey=c,o.forget=function(){return c(i.apply(null,arguments))},o.makeCacheKey=i,o.getKey=n?function(){return i.apply(null,n.apply(null,arguments))}:i,Object.freeze(o)}var Od=function(){function e(){this.getFragmentDoc=xd(Qc)}return e.prototype.batch=function(e){var t,r=this,n="string"==typeof e.optimistic?e.optimistic:!1===e.optimistic?null:void 0;return this.performTransaction((function(){return t=e.update(r)}),n),t},e.prototype.recordOptimisticTransaction=function(e,t){this.performTransaction(e,t)},e.prototype.transformDocument=function(e){return e},e.prototype.identify=function(e){},e.prototype.gc=function(){return[]},e.prototype.modify=function(e){return!1},e.prototype.transformForLink=function(e){return e},e.prototype.readQuery=function(e,t){return void 0===t&&(t=!!e.optimistic),this.read(Cn(Cn({},e),{rootId:e.id||"ROOT_QUERY",optimistic:t}))},e.prototype.readFragment=function(e,t){return void 0===t&&(t=!!e.optimistic),this.read(Cn(Cn({},e),{query:this.getFragmentDoc(e.fragment,e.fragmentName),rootId:e.id,optimistic:t}))},e.prototype.writeQuery=function(e){var t=e.id,r=e.data,n=Mn(e,["id","data"]);return this.write(Object.assign(n,{dataId:t||"ROOT_QUERY",result:r}))},e.prototype.writeFragment=function(e){var t=e.id,r=e.data,n=e.fragment,i=e.fragmentName,o=Mn(e,["id","data","fragment","fragmentName"]);return this.write(Object.assign(o,{query:this.getFragmentDoc(n,i),dataId:t,result:r}))},e.prototype.updateQuery=function(e,t){return this.batch({update:function(r){var n=r.readQuery(e),i=t(n);return null==i?n:(r.writeQuery(Cn(Cn({},e),{data:i})),i)}})},e.prototype.updateFragment=function(e,t){return this.batch({update:function(r){var n=r.readFragment(e),i=t(n);return null==i?n:(r.writeFragment(Cn(Cn({},e),{data:i})),i)}})},e}(),Ad=function(e,t,r,n){this.message=e,this.path=t,this.query=r,this.variables=n},Pd=Object.prototype.hasOwnProperty;function Dd(e,t){var r=e.__typename,n=e.id,i=e._id;if("string"==typeof r&&(t&&(t.keyObject=void 0!==n?{id:n}:void 0!==i?{_id:i}:void 0),void 0===n&&(n=i),void 0!==n))return"".concat(r,":").concat("number"==typeof n||"string"==typeof n?n:JSON.stringify(n))}var jd={dataIdFromObject:Dd,addTypename:!0,resultCaching:!0,canonizeResults:!1};function Ld(e){var t=e.canonizeResults;return void 0===t?jd.canonizeResults:t}var Nd=/^[_a-z][_0-9a-z]*/i;function Bd(e){var t=e.match(Nd);return t?t[0]:e}function Ud(e,t,r){return!!Zc(t)&&($d(t)?t.every((function(t){return Ud(e,t,r)})):e.selections.every((function(e){if(ul(e)&&Wc(e,r)){var n=cl(e);return Pd.call(t,n)&&(!e.selectionSet||Ud(e.selectionSet,t[n],r))}return!0})))}function Fd(e){return Zc(e)&&!tl(e)&&!$d(e)}var $d=function(e){return Array.isArray(e)},qd=Object.create(null),Kd=function(){return qd},Vd=Object.create(null),zd=function(){function e(e,t){var r=this;this.policies=e,this.group=t,this.data=Object.create(null),this.rootIds=Object.create(null),this.refs=Object.create(null),this.getFieldValue=function(e,t){return iu(tl(e)?r.get(e.__ref,t):e&&e[t])},this.canRead=function(e){return tl(e)?r.has(e.__ref):"object"==typeof e},this.toReference=function(e,t){if("string"==typeof e)return el(e);if(tl(e))return e;var n=r.policies.identify(e)[0];if(n){var i=el(n);return t&&r.merge(n,e),i}}}return e.prototype.toObject=function(){return Cn({},this.data)},e.prototype.has=function(e){return void 0!==this.lookup(e,!0)},e.prototype.get=function(e,t){if(this.group.depend(e,t),Pd.call(this.data,e)){var r=this.data[e];if(r&&Pd.call(r,t))return r[t]}return"__typename"===t&&Pd.call(this.policies.rootTypenamesById,e)?this.policies.rootTypenamesById[e]:this instanceof Yd?this.parent.get(e,t):void 0},e.prototype.lookup=function(e,t){return t&&this.group.depend(e,"__exists"),Pd.call(this.data,e)?this.data[e]:this instanceof Yd?this.parent.lookup(e,t):this.policies.rootTypenamesById[e]?Object.create(null):void 0},e.prototype.merge=function(e,t){var r,n=this;tl(e)&&(e=e.__ref),tl(t)&&(t=t.__ref);var i="string"==typeof e?this.lookup(r=e):e,o="string"==typeof t?this.lookup(r=t):t;if(o){__DEV__?hc("string"==typeof r,"store.merge expects a string ID"):hc("string"==typeof r,1);var s=new Ol(Jd).merge(i,o);if(this.data[r]=s,s!==i&&(delete this.refs[r],this.group.caching)){var a=Object.create(null);i||(a.__exists=1),Object.keys(o).forEach((function(e){if(!i||i[e]!==s[e]){a[e]=1;var t=Bd(e);t!==e&&!n.policies.hasKeyArgs(s.__typename,t)&&(a[t]=1),void 0===s[e]&&!(n instanceof Yd)&&delete s[e]}})),a.__typename&&!(i&&i.__typename)&&this.policies.rootTypenamesById[r]===s.__typename&&delete a.__typename,Object.keys(a).forEach((function(e){return n.group.dirty(r,e)}))}}},e.prototype.modify=function(e,t){var r=this,n=this.lookup(e);if(n){var i=Object.create(null),o=!1,s=!0,a={DELETE:qd,INVALIDATE:Vd,isReference:tl,toReference:this.toReference,canRead:this.canRead,readField:function(t,n){return r.policies.readField("string"==typeof t?{fieldName:t,from:n||el(e)}:t,{store:r})}};if(Object.keys(n).forEach((function(c){var l=Bd(c),u=n[c];if(void 0!==u){var d="function"==typeof t?t:t[c]||t[l];if(d){var h=d===Kd?qd:d(iu(u),Cn(Cn({},a),{fieldName:l,storeFieldName:c,storage:r.getStorage(e,c)}));h===Vd?r.group.dirty(e,c):(h===qd&&(h=void 0),h!==u&&(i[c]=h,o=!0,u=h))}void 0!==u&&(s=!1)}})),o)return this.merge(e,i),s&&(this instanceof Yd?this.data[e]=void 0:delete this.data[e],this.group.dirty(e,"__exists")),!0}return!1},e.prototype.delete=function(e,t,r){var n,i=this.lookup(e);if(i){var o=this.getFieldValue(i,"__typename"),s=t&&r?this.policies.getStoreFieldName({typename:o,fieldName:t,args:r}):t;return this.modify(e,s?((n={})[s]=Kd,n):Kd)}return!1},e.prototype.evict=function(e,t){var r=!1;return e.id&&(Pd.call(this.data,e.id)&&(r=this.delete(e.id,e.fieldName,e.args)),this instanceof Yd&&this!==t&&(r=this.parent.evict(e,t)||r),(e.fieldName||r)&&this.group.dirty(e.id,e.fieldName||"__exists")),r},e.prototype.clear=function(){this.replace(null)},e.prototype.extract=function(){var e=this,t=this.toObject(),r=[];return this.getRootIdSet().forEach((function(t){Pd.call(e.policies.rootTypenamesById,t)||r.push(t)})),r.length&&(t.__META={extraRootIds:r.sort()}),t},e.prototype.replace=function(e){var t=this;if(Object.keys(this.data).forEach((function(r){e&&Pd.call(e,r)||t.delete(r)})),e){var r=e.__META,n=Mn(e,["__META"]);Object.keys(n).forEach((function(e){t.merge(e,n[e])})),r&&r.extraRootIds.forEach(this.retain,this)}},e.prototype.retain=function(e){return this.rootIds[e]=(this.rootIds[e]||0)+1},e.prototype.release=function(e){if(this.rootIds[e]>0){var t=--this.rootIds[e];return t||delete this.rootIds[e],t}return 0},e.prototype.getRootIdSet=function(e){return void 0===e&&(e=new Set),Object.keys(this.rootIds).forEach(e.add,e),this instanceof Yd?this.parent.getRootIdSet(e):Object.keys(this.policies.rootTypenamesById).forEach(e.add,e),e},e.prototype.gc=function(){var e=this,t=this.getRootIdSet(),r=this.toObject();t.forEach((function(n){Pd.call(r,n)&&(Object.keys(e.findChildRefIds(n)).forEach(t.add,t),delete r[n])}));var n=Object.keys(r);if(n.length){for(var i=this;i instanceof Yd;)i=i.parent;n.forEach((function(e){return i.delete(e)}))}return n},e.prototype.findChildRefIds=function(e){if(!Pd.call(this.refs,e)){var t=this.refs[e]=Object.create(null),r=this.data[e];if(!r)return t;var n=new Set([r]);n.forEach((function(e){tl(e)&&(t[e.__ref]=!0),Zc(e)&&Object.keys(e).forEach((function(t){var r=e[t];Zc(r)&&n.add(r)}))}))}return this.refs[e]},e.prototype.makeCacheKey=function(){return this.group.keyMaker.lookupArray(arguments)},e}(),Hd=function(){function e(e,t){void 0===t&&(t=null),this.caching=e,this.parent=t,this.d=null,this.resetCaching()}return e.prototype.resetCaching=function(){this.d=this.caching?Rd():null,this.keyMaker=new Qu(au)},e.prototype.depend=function(e,t){if(this.d){this.d(Wd(e,t));var r=Bd(t);r!==t&&this.d(Wd(e,r)),this.parent&&this.parent.depend(e,t)}},e.prototype.dirty=function(e,t){this.d&&this.d.dirty(Wd(e,t),"__exists"===t?"forget":"setDirty")},e}();function Wd(e,t){return t+"#"+e}function Gd(e,t){Xd(e)&&e.group.depend(t,"__exists")}!function(e){var t=function(e){function t(t){var r=t.policies,n=t.resultCaching,i=void 0===n||n,o=t.seed,s=e.call(this,r,new Hd(i))||this;return s.stump=new Qd(s),s.storageTrie=new Qu(au),o&&s.replace(o),s}return Rn(t,e),t.prototype.addLayer=function(e,t){return this.stump.addLayer(e,t)},t.prototype.removeLayer=function(){return this},t.prototype.getStorage=function(){return this.storageTrie.lookupArray(arguments)},t}(e);e.Root=t}(zd||(zd={}));var Yd=function(e){function t(t,r,n,i){var o=e.call(this,r.policies,i)||this;return o.id=t,o.parent=r,o.replay=n,o.group=i,n(o),o}return Rn(t,e),t.prototype.addLayer=function(e,r){return new t(e,this,r,this.group)},t.prototype.removeLayer=function(e){var t=this,r=this.parent.removeLayer(e);return e===this.id?(this.group.caching&&Object.keys(this.data).forEach((function(e){var n=t.data[e],i=r.lookup(e);i?n?n!==i&&Object.keys(n).forEach((function(r){$u(n[r],i[r])||t.group.dirty(e,r)})):(t.group.dirty(e,"__exists"),Object.keys(i).forEach((function(r){t.group.dirty(e,r)}))):t.delete(e)})),r):r===this.parent?this:r.addLayer(this.id,this.replay)},t.prototype.toObject=function(){return Cn(Cn({},this.parent.toObject()),this.data)},t.prototype.findChildRefIds=function(t){var r=this.parent.findChildRefIds(t);return Pd.call(this.data,t)?Cn(Cn({},r),e.prototype.findChildRefIds.call(this,t)):r},t.prototype.getStorage=function(){for(var e=this.parent;e.parent;)e=e.parent;return e.getStorage.apply(e,arguments)},t}(zd),Qd=function(e){function t(t){return e.call(this,"EntityStore.Stump",t,(function(){}),new Hd(t.group.caching,t.group))||this}return Rn(t,e),t.prototype.removeLayer=function(){return this},t.prototype.merge=function(){return this.parent.merge.apply(this.parent,arguments)},t}(Yd);function Jd(e,t,r){var n=e[r],i=t[r];return $u(n,i)?n:i}function Xd(e){return!!(e instanceof zd&&e.group.caching)}var Zd,eh,th=function(){function e(){this.known=new(cu?WeakSet:Set),this.pool=new Qu(au),this.passes=new WeakMap,this.keysByJSON=new Map,this.empty=this.admit({})}return e.prototype.isKnown=function(e){return Zc(e)&&this.known.has(e)},e.prototype.pass=function(e){if(Zc(e)){var t=function(e){return Zc(e)?$d(e)?e.slice(0):Cn({__proto__:Object.getPrototypeOf(e)},e):e}(e);return this.passes.set(t,e),t}return e},e.prototype.admit=function(e){var t=this;if(Zc(e)){var r=this.passes.get(e);if(r)return r;switch(Object.getPrototypeOf(e)){case Array.prototype:if(this.known.has(e))return e;var n=e.map(this.admit,this);return(a=this.pool.lookupArray(n)).array||(this.known.add(a.array=n),__DEV__&&Object.freeze(n)),a.array;case null:case Object.prototype:if(this.known.has(e))return e;var i=Object.getPrototypeOf(e),o=[i],s=this.sortedKeys(e);o.push(s.json);var a,c=o.length;if(s.sorted.forEach((function(r){o.push(t.admit(e[r]))})),!(a=this.pool.lookupArray(o)).object){var l=a.object=Object.create(i);this.known.add(l),s.sorted.forEach((function(e,t){l[e]=o[c+t]})),__DEV__&&Object.freeze(l)}return a.object}}return e},e.prototype.sortedKeys=function(e){var t=Object.keys(e),r=this.pool.lookupArray(t);if(!r.keys){t.sort();var n=JSON.stringify(t);(r.keys=this.keysByJSON.get(n))||this.keysByJSON.set(n,r.keys={sorted:t,json:n})}return r.keys},e}(),rh=Object.assign((function(e){if(Zc(e)){void 0===Zd&&nh();var t=Zd.admit(e),r=eh.get(t);return void 0===r&&eh.set(t,r=JSON.stringify(t)),r}return JSON.stringify(e)}),{reset:nh});function nh(){Zd=new th,eh=new(au?WeakMap:Map)}function ih(e){return[e.selectionSet,e.objectOrReference,e.context,e.context.canonizeResults]}var oh=function(){function e(e){var t=this;this.knownResults=new(au?WeakMap:Map),this.config=vu(e,{addTypename:!1!==e.addTypename,canonizeResults:Ld(e)}),this.canon=e.canon||new th,this.executeSelectionSet=xd((function(e){var r,n=e.context.canonizeResults,i=ih(e);i[3]=!n;var o=(r=t.executeSelectionSet).peek.apply(r,i);return o?n?Cn(Cn({},o),{result:t.canon.admit(o.result)}):o:(Gd(e.context.store,e.enclosingRef.__ref),t.execSelectionSetImpl(e))}),{max:this.config.resultCacheMaxSize,keyArgs:ih,makeCacheKey:function(e,t,r,n){if(Xd(r.store))return r.store.makeCacheKey(e,tl(t)?t.__ref:t,r.varString,n)}}),this.executeSubSelectedArray=xd((function(e){return Gd(e.context.store,e.enclosingRef.__ref),t.execSubSelectedArrayImpl(e)}),{max:this.config.resultCacheMaxSize,makeCacheKey:function(e){var t=e.field,r=e.array,n=e.context;if(Xd(n.store))return n.store.makeCacheKey(t,r,n.varString)}})}return e.prototype.resetCanon=function(){this.canon=new th},e.prototype.diffQueryAgainstStore=function(e){var t=e.store,r=e.query,n=e.rootId,i=void 0===n?"ROOT_QUERY":n,o=e.variables,s=e.returnPartialData,a=void 0===s||s,c=e.canonizeResults,l=void 0===c?this.config.canonizeResults:c,u=this.config.cache.policies;o=Cn(Cn({},yl(gl(r))),o);var d,h=el(i),f=this.executeSelectionSet({selectionSet:ml(r).selectionSet,objectOrReference:h,enclosingRef:h,context:{store:t,query:r,policies:u,variables:o,varString:rh(o),canonizeResults:l,fragmentMap:Jc(vl(r))}});if(f.missing&&(d=[new Ad(sh(f.missing),f.missing,r,o)],!a))throw d[0];return{result:f.result,complete:!d,missing:d}},e.prototype.isFresh=function(e,t,r,n){if(Xd(n.store)&&this.knownResults.get(e)===r){var i=this.executeSelectionSet.peek(r,t,n,this.canon.isKnown(e));if(i&&e===i.result)return!0}return!1},e.prototype.execSelectionSetImpl=function(e){var t=this,r=e.selectionSet,n=e.objectOrReference,i=e.enclosingRef,o=e.context;if(tl(n)&&!o.policies.rootTypenamesById[n.__ref]&&!o.store.has(n.__ref))return{result:this.canon.empty,missing:"Dangling reference to missing ".concat(n.__ref," object")};var s,a=o.variables,c=o.policies,l=o.store.getFieldValue(n,"__typename"),u=[],d=new Ol;function h(e,t){var r;return e.missing&&(s=d.merge(s,((r={})[t]=e.missing,r))),e.result}this.config.addTypename&&"string"==typeof l&&!c.rootIdsByTypename[l]&&u.push({__typename:l});var f=new Set(r.selections);f.forEach((function(e){var r,p;if(Wc(e,a))if(ul(e)){var v=c.readField({fieldName:e.name.value,field:e,variables:o.variables,from:n},o),g=cl(e);void 0===v?kl.added(e)||(s=d.merge(s,((r={})[g]="Can't find field '".concat(e.name.value,"' on ").concat(tl(n)?n.__ref+" object":"object "+JSON.stringify(n,null,2)),r))):$d(v)?v=h(t.executeSubSelectedArray({field:e,array:v,enclosingRef:i,context:o}),g):e.selectionSet?null!=v&&(v=h(t.executeSelectionSet({selectionSet:e.selectionSet,objectOrReference:v,enclosingRef:tl(v)?v:i,context:o}),g)):o.canonizeResults&&(v=t.canon.pass(v)),void 0!==v&&u.push(((p={})[g]=v,p))}else{var m=Xc(e,o.fragmentMap);m&&c.fragmentMatches(m,l)&&m.selectionSet.selections.forEach(f.add,f)}}));var p={result:Ml(u),missing:s},v=o.canonizeResults?this.canon.admit(p):iu(p);return v.result&&this.knownResults.set(v.result,r),v},e.prototype.execSubSelectedArrayImpl=function(e){var t,r=this,n=e.field,i=e.array,o=e.enclosingRef,s=e.context,a=new Ol;function c(e,r){var n;return e.missing&&(t=a.merge(t,((n={})[r]=e.missing,n))),e.result}return n.selectionSet&&(i=i.filter(s.store.canRead)),i=i.map((function(e,t){return null===e?null:$d(e)?c(r.executeSubSelectedArray({field:n,array:e,enclosingRef:o,context:s}),t):n.selectionSet?c(r.executeSelectionSet({selectionSet:n.selectionSet,objectOrReference:e,enclosingRef:tl(e)?e:o,context:s}),t):(__DEV__&&function(e,t,r){if(!t.selectionSet){var n=new Set([r]);n.forEach((function(r){Zc(r)&&(__DEV__?hc(!tl(r),"Missing selection set for object of type ".concat(function(e,t){return tl(t)?e.get(t.__ref,"__typename"):t&&t.__typename}(e,r)," returned for query field ").concat(t.name.value)):hc(!tl(r),5),Object.values(r).forEach(n.add,n))}))}}(s.store,n,e),e)})),{result:s.canonizeResults?this.canon.admit(i):i,missing:t}},e}();function sh(e){try{JSON.stringify(e,(function(e,t){if("string"==typeof t)throw t;return t}))}catch(t){return t}}var ah=new rd,ch=new WeakMap;function lh(e){var t=ch.get(e);return t||ch.set(e,t={vars:new Set,dep:Rd()}),t}function uh(e){lh(e).vars.forEach((function(t){return t.forgetCache(e)}))}function dh(e){var t=new Set,r=new Set,n=function(o){if(arguments.length>0){if(e!==o){e=o,t.forEach((function(e){lh(e).dep.dirty(n),hh(e)}));var s=Array.from(r);r.clear(),s.forEach((function(t){return t(e)}))}}else{var a=ah.getValue();a&&(i(a),lh(a).dep(n))}return e};n.onNextChange=function(e){return r.add(e),function(){r.delete(e)}};var i=n.attachCache=function(e){return t.add(e),lh(e).vars.add(n),n};return n.forgetCache=function(e){return t.delete(e)},n}function hh(e){e.broadcastWatches&&e.broadcastWatches()}var fh=Object.create(null);function ph(e){var t=JSON.stringify(e);return fh[t]||(fh[t]=Object.create(null))}function vh(e){var t=ph(e);return t.keyFieldsFn||(t.keyFieldsFn=function(t,r){var n=function(e,t){return r.readField(t,e)},i=r.keyObject=mh(e,(function(e){var i=bh(r.storeObject,e,n);return void 0===i&&t!==r.storeObject&&Pd.call(t,e[0])&&(i=bh(t,e,yh)),__DEV__?hc(void 0!==i,"Missing field '".concat(e.join("."),"' while extracting keyFields from ").concat(JSON.stringify(t))):hc(void 0!==i,2),i}));return"".concat(r.typename,":").concat(JSON.stringify(i))})}function gh(e){var t=ph(e);return t.keyArgsFn||(t.keyArgsFn=function(t,r){var n=r.field,i=r.variables,o=r.fieldName,s=mh(e,(function(e){var r=e[0],o=r.charAt(0);if("@"!==o)if("$"!==o){if(t)return bh(t,e)}else{var s=r.slice(1);if(i&&Pd.call(i,s)){var a=e.slice(0);return a[0]=s,bh(i,a)}}else if(n&&fu(n.directives)){var c=r.slice(1),l=n.directives.find((function(e){return e.name.value===c})),u=l&&al(l,i);return u&&bh(u,e.slice(1))}})),a=JSON.stringify(s);return(t||"{}"!==a)&&(o+=":"+a),o})}function mh(e,t){var r=new Ol;return function e(t){var r=ph(t);if(!r.paths){var n=r.paths=[],i=[];t.forEach((function(r,o){$d(r)?(e(r).forEach((function(e){return n.push(i.concat(e))})),i.length=0):(i.push(r),$d(t[o+1])||(n.push(i.slice(0)),i.length=0))}))}return r.paths}(e).reduce((function(e,n){var i,o=t(n);if(void 0!==o){for(var s=n.length-1;s>=0;--s)(i={})[n[s]]=o,o=i;e=r.merge(e,o)}return e}),Object.create(null))}function yh(e,t){return e[t]}function bh(e,t,r){return r=r||yh,_h(t.reduce((function e(t,n){return $d(t)?t.map((function(t){return e(t,n)})):t&&r(t,n)}),e))}function _h(e){return Zc(e)?$d(e)?e.map(_h):mh(Object.keys(e).sort(),(function(t){return bh(e,t)})):e}function wh(e){return void 0!==e.args?e.args:e.field?al(e.field,e.variables):null}il.setStringify(rh);var Sh=function(){},Eh=function(e,t){return t.fieldName},kh=function(e,t,r){return(0,r.mergeObjects)(e,t)},Th=function(e,t){return t},Ih=function(){function e(e){this.config=e,this.typePolicies=Object.create(null),this.toBeAdded=Object.create(null),this.supertypeMap=new Map,this.fuzzySubtypes=new Map,this.rootIdsByTypename=Object.create(null),this.rootTypenamesById=Object.create(null),this.usingPossibleTypes=!1,this.config=Cn({dataIdFromObject:Dd},e),this.cache=this.config.cache,this.setRootTypename("Query"),this.setRootTypename("Mutation"),this.setRootTypename("Subscription"),e.possibleTypes&&this.addPossibleTypes(e.possibleTypes),e.typePolicies&&this.addTypePolicies(e.typePolicies)}return e.prototype.identify=function(e,t){var r,n=this,i=t&&(t.typename||(null===(r=t.storeObject)||void 0===r?void 0:r.__typename))||e.__typename;if(i===this.rootTypenamesById.ROOT_QUERY)return["ROOT_QUERY"];for(var o,s=t&&t.storeObject||e,a=Cn(Cn({},t),{typename:i,storeObject:s,readField:t&&t.readField||function(){var e=Ch(arguments,s);return n.readField(e,{store:n.cache.data,variables:e.variables})}}),c=i&&this.getTypePolicy(i),l=c&&c.keyFn||this.config.dataIdFromObject;l;){var u=l(e,a);if(!$d(u)){o=u;break}l=vh(u)}return o=o?String(o):void 0,a.keyObject?[o,a.keyObject]:[o]},e.prototype.addTypePolicies=function(e){var t=this;Object.keys(e).forEach((function(r){var n=e[r],i=n.queryType,o=n.mutationType,s=n.subscriptionType,a=Mn(n,["queryType","mutationType","subscriptionType"]);i&&t.setRootTypename("Query",r),o&&t.setRootTypename("Mutation",r),s&&t.setRootTypename("Subscription",r),Pd.call(t.toBeAdded,r)?t.toBeAdded[r].push(a):t.toBeAdded[r]=[a]}))},e.prototype.updateTypePolicy=function(e,t){var r=this,n=this.getTypePolicy(e),i=t.keyFields,o=t.fields;function s(e,t){e.merge="function"==typeof t?t:!0===t?kh:!1===t?Th:e.merge}s(n,t.merge),n.keyFn=!1===i?Sh:$d(i)?vh(i):"function"==typeof i?i:n.keyFn,o&&Object.keys(o).forEach((function(t){var n=r.getFieldPolicy(e,t,!0),i=o[t];if("function"==typeof i)n.read=i;else{var a=i.keyArgs,c=i.read,l=i.merge;n.keyFn=!1===a?Eh:$d(a)?gh(a):"function"==typeof a?a:n.keyFn,"function"==typeof c&&(n.read=c),s(n,l)}n.read&&n.merge&&(n.keyFn=n.keyFn||Eh)}))},e.prototype.setRootTypename=function(e,t){void 0===t&&(t=e);var r="ROOT_"+e.toUpperCase(),n=this.rootTypenamesById[r];t!==n&&(__DEV__?hc(!n||n===e,"Cannot change root ".concat(e," __typename more than once")):hc(!n||n===e,3),n&&delete this.rootIdsByTypename[n],this.rootIdsByTypename[t]=r,this.rootTypenamesById[r]=t)},e.prototype.addPossibleTypes=function(e){var t=this;this.usingPossibleTypes=!0,Object.keys(e).forEach((function(r){t.getSupertypeSet(r,!0),e[r].forEach((function(e){t.getSupertypeSet(e,!0).add(r);var n=e.match(Nd);(!n||n[0]!==e)&&t.fuzzySubtypes.set(e,new RegExp(e))}))}))},e.prototype.getTypePolicy=function(e){var t=this;if(!Pd.call(this.typePolicies,e)){var r=this.typePolicies[e]=Object.create(null);r.fields=Object.create(null);var n=this.supertypeMap.get(e);n&&n.size&&n.forEach((function(e){var n=t.getTypePolicy(e),i=n.fields,o=Mn(n,["fields"]);Object.assign(r,o),Object.assign(r.fields,i)}))}var i=this.toBeAdded[e];return i&&i.length&&i.splice(0).forEach((function(r){t.updateTypePolicy(e,r)})),this.typePolicies[e]},e.prototype.getFieldPolicy=function(e,t,r){if(e){var n=this.getTypePolicy(e).fields;return n[t]||r&&(n[t]=Object.create(null))}},e.prototype.getSupertypeSet=function(e,t){var r=this.supertypeMap.get(e);return!r&&t&&this.supertypeMap.set(e,r=new Set),r},e.prototype.fragmentMatches=function(e,t,r,n){var i=this;if(!e.typeCondition)return!0;if(!t)return!1;var o=e.typeCondition.name.value;if(t===o)return!0;if(this.usingPossibleTypes&&this.supertypeMap.has(o))for(var s=this.getSupertypeSet(t,!0),a=[s],c=function(e){var t=i.getSupertypeSet(e,!1);t&&t.size&&a.indexOf(t)<0&&a.push(t)},l=!(!r||!this.fuzzySubtypes.size),u=!1,d=0;d<a.length;++d){var h=a[d];if(h.has(o))return s.has(o)||(u&&__DEV__&&hc.warn("Inferring subtype ".concat(t," of supertype ").concat(o)),s.add(o)),!0;h.forEach(c),l&&d===a.length-1&&Ud(e.selectionSet,r,n)&&(l=!1,u=!0,this.fuzzySubtypes.forEach((function(e,r){var n=t.match(e);n&&n[0]===t&&c(r)})))}return!1},e.prototype.hasKeyArgs=function(e,t){var r=this.getFieldPolicy(e,t,!1);return!(!r||!r.keyFn)},e.prototype.getStoreFieldName=function(e){var t,r=e.typename,n=e.fieldName,i=this.getFieldPolicy(r,n,!1),o=i&&i.keyFn;if(o&&r)for(var s={typename:r,fieldName:n,field:e.field||null,variables:e.variables},a=wh(e);o;){var c=o(a,s);if(!$d(c)){t=c||n;break}o=gh(c)}return void 0===t&&(t=e.field?function(e,t){var r=null;e.directives&&(r={},e.directives.forEach((function(e){r[e.name.value]={},e.arguments&&e.arguments.forEach((function(n){var i=n.name,o=n.value;return rl(r[e.name.value],i,o,t)}))})));var n=null;return e.arguments&&e.arguments.length&&(n={},e.arguments.forEach((function(e){var r=e.name,i=e.value;return rl(n,r,i,t)}))),il(e.name.value,n,r)}(e.field,e.variables):il(n,wh(e))),!1===t?n:n===Bd(t)?t:n+":"+t},e.prototype.readField=function(e,t){var r=e.from;if(r&&(e.field||e.fieldName)){if(void 0===e.typename){var n=t.store.getFieldValue(r,"__typename");n&&(e.typename=n)}var i=this.getStoreFieldName(e),o=Bd(i),s=t.store.getFieldValue(r,i),a=this.getFieldPolicy(e.typename,o,!1),c=a&&a.read;if(c){var l=Rh(this,r,e,t,t.store.getStorage(tl(r)?r.__ref:r,i));return ah.withValue(this.cache,c,[s,l])}return s}},e.prototype.getReadFunction=function(e,t){var r=this.getFieldPolicy(e,t,!1);return r&&r.read},e.prototype.getMergeFunction=function(e,t,r){var n=this.getFieldPolicy(e,t,!1),i=n&&n.merge;return!i&&r&&(i=(n=this.getTypePolicy(r))&&n.merge),i},e.prototype.runMergeFunction=function(e,t,r,n,i){var o=r.field,s=r.typename,a=r.merge;return a===kh?Mh(n.store)(e,t):a===Th?t:(n.overwrite&&(e=void 0),a(e,t,Rh(this,void 0,{typename:s,fieldName:o.name.value,field:o,variables:n.variables},n,i||Object.create(null))))},e}();function Rh(e,t,r,n,i){var o=e.getStoreFieldName(r),s=Bd(o),a=r.variables||n.variables,c=n.store,l=c.toReference,u=c.canRead;return{args:wh(r),field:r.field||null,fieldName:s,storeFieldName:o,variables:a,isReference:tl,toReference:l,storage:i,cache:e.cache,canRead:u,readField:function(){return e.readField(Ch(arguments,t,a),n)},mergeObjects:Mh(n.store)}}function Ch(e,t,r){var n,i=e[0],o=e[1],s=e.length;return"string"==typeof i?n={fieldName:i,from:s>1?o:t}:(n=Cn({},i),Pd.call(n,"from")||(n.from=t)),__DEV__&&void 0===n.from&&__DEV__&&hc.warn("Undefined 'from' passed to readField with arguments ".concat(function(e){var t=mu("stringifyForDisplay");return JSON.stringify(e,(function(e,r){return void 0===r?t:r})).split(JSON.stringify(t)).join("<undefined>")}(Array.from(e)))),void 0===n.variables&&(n.variables=r),n}function Mh(e){return function(t,r){if($d(t)||$d(r))throw __DEV__?new dc("Cannot automatically merge arrays"):new dc(4);if(Zc(t)&&Zc(r)){var n=e.getFieldValue(t,"__typename"),i=e.getFieldValue(r,"__typename");if(n&&i&&n!==i)return r;if(tl(t)&&Fd(r))return e.merge(t.__ref,r),t;if(Fd(t)&&tl(r))return e.merge(t,r.__ref),r;if(Fd(t)&&Fd(r))return Cn(Cn({},t),r)}return r}}function xh(e,t,r){var n="".concat(t).concat(r),i=e.flavors.get(n);return i||e.flavors.set(n,i=e.clientOnly===t&&e.deferred===r?e:Cn(Cn({},e),{clientOnly:t,deferred:r})),i}var Oh=function(){function e(e,t){this.cache=e,this.reader=t}return e.prototype.writeToStore=function(e,t){var r=this,n=t.query,i=t.result,o=t.dataId,s=t.variables,a=t.overwrite,c=fl(n),l=new Ol;s=Cn(Cn({},yl(c)),s);var u={store:e,written:Object.create(null),merge:function(e,t){return l.merge(e,t)},variables:s,varString:rh(s),fragmentMap:Jc(vl(n)),overwrite:!!a,incomingById:new Map,clientOnly:!1,deferred:!1,flavors:new Map},d=this.processSelectionSet({result:i||Object.create(null),dataId:o,selectionSet:c.selectionSet,mergeTree:{map:new Map},context:u});if(!tl(d))throw __DEV__?new dc("Could not identify object ".concat(JSON.stringify(i))):new dc(6);return u.incomingById.forEach((function(t,n){var i=t.storeObject,o=t.mergeTree,s=t.fieldNodeSet,a=el(n);if(o&&o.map.size){var c=r.applyMerges(o,a,i,u);if(tl(c))return;i=c}if(__DEV__&&!u.overwrite){var l=Object.create(null);s.forEach((function(e){e.selectionSet&&(l[e.name.value]=!0)}));Object.keys(i).forEach((function(e){(function(e){return!0===l[Bd(e)]})(e)&&!function(e){var t=o&&o.map.get(e);return Boolean(t&&t.info&&t.info.merge)}(e)&&function(e,t,r,n){var i=function(e){var t=n.getFieldValue(e,r);return"object"==typeof t&&t},o=i(e);if(o){var s=i(t);if(s&&!tl(o)&&!$u(o,s)&&!Object.keys(o).every((function(e){return void 0!==n.getFieldValue(s,e)}))){var a=n.getFieldValue(e,"__typename")||n.getFieldValue(t,"__typename"),c=Bd(r),l="".concat(a,".").concat(c);if(!Lh.has(l)){Lh.add(l);var u=[];!$d(o)&&!$d(s)&&[o,s].forEach((function(e){var t=n.getFieldValue(e,"__typename");"string"==typeof t&&!u.includes(t)&&u.push(t)})),__DEV__&&hc.warn("Cache data may be lost when replacing the ".concat(c," field of a ").concat(a," object.\n\nTo address this problem (which is not a bug in Apollo Client), ").concat(u.length?"either ensure all objects of type "+u.join(" and ")+" have an ID or a custom merge function, or ":"","define a custom merge function for the ").concat(l," field, so InMemoryCache can safely merge these objects:\n\n  existing: ").concat(JSON.stringify(o).slice(0,1e3),"\n  incoming: ").concat(JSON.stringify(s).slice(0,1e3),"\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n"))}}}}(a,i,e,u.store)}))}e.merge(n,i)})),e.retain(d.__ref),d},e.prototype.processSelectionSet=function(e){var t=this,r=e.dataId,n=e.result,i=e.selectionSet,o=e.context,s=e.mergeTree,a=this.cache.policies,c=Object.create(null),l=r&&a.rootTypenamesById[r]||ll(n,i,o.fragmentMap)||r&&o.store.get(r,"__typename");"string"==typeof l&&(c.__typename=l);var u=function(){var e=Ch(arguments,c,o.variables);if(tl(e.from)){var t=o.incomingById.get(e.from.__ref);if(t){var r=a.readField(Cn(Cn({},e),{from:t.storeObject}),o);if(void 0!==r)return r}}return a.readField(e,o)},d=new Set;this.flattenFields(i,n,o,l).forEach((function(e,r){var i,o=cl(r),h=n[o];if(d.add(r),void 0!==h){var f=a.getStoreFieldName({typename:l,fieldName:r.name.value,field:r,variables:e.variables}),p=Ph(s,f),v=t.processFieldValue(h,r,r.selectionSet?xh(e,!1,!1):e,p),g=void 0;r.selectionSet&&(tl(v)||Fd(v))&&(g=u("__typename",v));var m=a.getMergeFunction(l,r.name.value,g);m?p.info={field:r,typename:l,merge:m}:jh(s,f),c=e.merge(c,((i={})[f]=v,i))}else __DEV__&&!e.clientOnly&&!e.deferred&&!kl.added(r)&&!a.getReadFunction(l,r.name.value)&&__DEV__&&hc.error("Missing field '".concat(cl(r),"' while writing result ").concat(JSON.stringify(n,null,2)).substring(0,1e3))}));try{var h=a.identify(n,{typename:l,selectionSet:i,fragmentMap:o.fragmentMap,storeObject:c,readField:u}),f=h[0],p=h[1];r=r||f,p&&(c=o.merge(c,p))}catch(y){if(!r)throw y}if("string"==typeof r){var v=el(r),g=o.written[r]||(o.written[r]=[]);if(g.indexOf(i)>=0||(g.push(i),this.reader&&this.reader.isFresh(n,v,i,o)))return v;var m=o.incomingById.get(r);return m?(m.storeObject=o.merge(m.storeObject,c),m.mergeTree=function e(t,r){if(t===r||!r||Dh(r))return t;if(!t||Dh(t))return r;var n=t.info&&r.info?Cn(Cn({},t.info),r.info):t.info||r.info,i=t.map.size&&r.map.size,o=i?new Map:t.map.size?t.map:r.map,s={info:n,map:o};if(i){var a=new Set(r.map.keys());t.map.forEach((function(t,n){s.map.set(n,e(t,r.map.get(n))),a.delete(n)})),a.forEach((function(n){s.map.set(n,e(r.map.get(n),t.map.get(n)))}))}return s}(m.mergeTree,s),d.forEach((function(e){return m.fieldNodeSet.add(e)}))):o.incomingById.set(r,{storeObject:c,mergeTree:Dh(s)?void 0:s,fieldNodeSet:d}),v}return c},e.prototype.processFieldValue=function(e,t,r,n){var i=this;return t.selectionSet&&null!==e?$d(e)?e.map((function(e,o){var s=i.processFieldValue(e,t,r,Ph(n,o));return jh(n,o),s})):this.processSelectionSet({result:e,selectionSet:t.selectionSet,context:r,mergeTree:n}):__DEV__?ru(e):e},e.prototype.flattenFields=function(e,t,r,n){void 0===n&&(n=ll(t,e,r.fragmentMap));var i=new Map,o=this.cache.policies,s=new Qu(!1);return function e(a,c){var l=s.lookup(a,c.clientOnly,c.deferred);l.visited||(l.visited=!0,a.selections.forEach((function(s){if(Wc(s,r.variables)){var a=c.clientOnly,l=c.deferred;if(!(a&&l)&&fu(s.directives)&&s.directives.forEach((function(e){var t=e.name.value;if("client"===t&&(a=!0),"defer"===t){var n=al(e,r.variables);(!n||!1!==n.if)&&(l=!0)}})),ul(s)){var u=i.get(s);u&&(a=a&&u.clientOnly,l=l&&u.deferred),i.set(s,xh(r,a,l))}else{var d=Xc(s,r.fragmentMap);d&&o.fragmentMatches(d,n,t,r.variables)&&e(d.selectionSet,xh(r,a,l))}}})))}(e,r),i},e.prototype.applyMerges=function(e,t,r,n,i){var o,s=this;if(e.map.size&&!tl(r)){var a=$d(r)||!tl(t)&&!Fd(t)?void 0:t,c=r;a&&!i&&(i=[tl(a)?a.__ref:a]);var l,u=function(e,t){return $d(e)?"number"==typeof t?e[t]:void 0:n.store.getFieldValue(e,String(t))};e.map.forEach((function(e,t){var r=u(a,t),o=u(c,t);if(void 0!==o){i&&i.push(t);var d=s.applyMerges(e,r,o,n,i);d!==o&&(l=l||new Map).set(t,d),i&&hc(i.pop()===t)}})),l&&(r=$d(c)?c.slice(0):Cn({},c),l.forEach((function(e,t){r[t]=e})))}return e.info?this.cache.policies.runMergeFunction(t,r,e.info,n,i&&(o=n.store).getStorage.apply(o,i)):r},e}(),Ah=[];function Ph(e,t){var r=e.map;return r.has(t)||r.set(t,Ah.pop()||{map:new Map}),r.get(t)}function Dh(e){return!e||!(e.info||e.map.size)}function jh(e,t){var r=e.map,n=r.get(t);n&&Dh(n)&&(Ah.push(n),r.delete(t))}var Lh=new Set;var Nh=function(e){function t(t){void 0===t&&(t={});var r=e.call(this)||this;return r.watches=new Set,r.typenameDocumentCache=new Map,r.makeVar=dh,r.txCount=0,r.config=function(e){return vu(jd,e)}(t),r.addTypename=!!r.config.addTypename,r.policies=new Ih({cache:r,dataIdFromObject:r.config.dataIdFromObject,possibleTypes:r.config.possibleTypes,typePolicies:r.config.typePolicies}),r.init(),r}return Rn(t,e),t.prototype.init=function(){var e=this.data=new zd.Root({policies:this.policies,resultCaching:this.config.resultCaching});this.optimisticData=e.stump,this.resetResultCache()},t.prototype.resetResultCache=function(e){var t=this,r=this.storeReader;this.storeWriter=new Oh(this,this.storeReader=new oh({cache:this,addTypename:this.addTypename,resultCacheMaxSize:this.config.resultCacheMaxSize,canonizeResults:Ld(this.config),canon:e?void 0:r&&r.canon})),this.maybeBroadcastWatch=xd((function(e,r){return t.broadcastWatch(e,r)}),{max:this.config.resultCacheMaxSize,makeCacheKey:function(e){var r=e.optimistic?t.optimisticData:t.data;if(Xd(r)){var n=e.optimistic,i=e.rootId,o=e.variables;return r.makeCacheKey(e.query,e.callback,rh({optimistic:n,rootId:i,variables:o}))}}}),new Set([this.data.group,this.optimisticData.group]).forEach((function(e){return e.resetCaching()}))},t.prototype.restore=function(e){return this.init(),e&&this.data.replace(e),this},t.prototype.extract=function(e){return void 0===e&&(e=!1),(e?this.optimisticData:this.data).extract()},t.prototype.read=function(e){var t=e.returnPartialData,r=void 0!==t&&t;try{return this.storeReader.diffQueryAgainstStore(Cn(Cn({},e),{store:e.optimistic?this.optimisticData:this.data,config:this.config,returnPartialData:r})).result||null}catch(n){if(n instanceof Ad)return null;throw n}},t.prototype.write=function(e){try{return++this.txCount,this.storeWriter.writeToStore(this.data,e)}finally{!--this.txCount&&!1!==e.broadcast&&this.broadcastWatches()}},t.prototype.modify=function(e){if(Pd.call(e,"id")&&!e.id)return!1;var t=e.optimistic?this.optimisticData:this.data;try{return++this.txCount,t.modify(e.id||"ROOT_QUERY",e.fields)}finally{!--this.txCount&&!1!==e.broadcast&&this.broadcastWatches()}},t.prototype.diff=function(e){return this.storeReader.diffQueryAgainstStore(Cn(Cn({},e),{store:e.optimistic?this.optimisticData:this.data,rootId:e.id||"ROOT_QUERY",config:this.config}))},t.prototype.watch=function(e){var t=this;return this.watches.size||function(e){lh(e).vars.forEach((function(t){return t.attachCache(e)}))}(this),this.watches.add(e),e.immediate&&this.maybeBroadcastWatch(e),function(){t.watches.delete(e)&&!t.watches.size&&uh(t),t.maybeBroadcastWatch.forget(e)}},t.prototype.gc=function(e){rh.reset();var t=this.optimisticData.gc();return e&&!this.txCount&&(e.resetResultCache?this.resetResultCache(e.resetResultIdentities):e.resetResultIdentities&&this.storeReader.resetCanon()),t},t.prototype.retain=function(e,t){return(t?this.optimisticData:this.data).retain(e)},t.prototype.release=function(e,t){return(t?this.optimisticData:this.data).release(e)},t.prototype.identify=function(e){if(tl(e))return e.__ref;try{return this.policies.identify(e)[0]}catch(t){__DEV__&&hc.warn(t)}},t.prototype.evict=function(e){if(!e.id){if(Pd.call(e,"id"))return!1;e=Cn(Cn({},e),{id:"ROOT_QUERY"})}try{return++this.txCount,this.optimisticData.evict(e,this.data)}finally{!--this.txCount&&!1!==e.broadcast&&this.broadcastWatches()}},t.prototype.reset=function(e){var t=this;return this.init(),rh.reset(),e&&e.discardWatches?(this.watches.forEach((function(e){return t.maybeBroadcastWatch.forget(e)})),this.watches.clear(),uh(this)):this.broadcastWatches(),Promise.resolve()},t.prototype.removeOptimistic=function(e){var t=this.optimisticData.removeLayer(e);t!==this.optimisticData&&(this.optimisticData=t,this.broadcastWatches())},t.prototype.batch=function(e){var t,r=this,n=e.update,i=e.optimistic,o=void 0===i||i,s=e.removeOptimistic,a=e.onWatchUpdated,c=function(e){var i=r,o=i.data,s=i.optimisticData;++r.txCount,e&&(r.data=r.optimisticData=e);try{return t=n(r)}finally{--r.txCount,r.data=o,r.optimisticData=s}},l=new Set;return a&&!this.txCount&&this.broadcastWatches(Cn(Cn({},e),{onWatchUpdated:function(e){return l.add(e),!1}})),"string"==typeof o?this.optimisticData=this.optimisticData.addLayer(o,c):!1===o?c(this.data):c(),"string"==typeof s&&(this.optimisticData=this.optimisticData.removeLayer(s)),a&&l.size?(this.broadcastWatches(Cn(Cn({},e),{onWatchUpdated:function(e,t){var r=a.call(this,e,t);return!1!==r&&l.delete(e),r}})),l.size&&l.forEach((function(e){return r.maybeBroadcastWatch.dirty(e)}))):this.broadcastWatches(e),t},t.prototype.performTransaction=function(e,t){return this.batch({update:e,optimistic:t||null!==t})},t.prototype.transformDocument=function(e){if(this.addTypename){var t=this.typenameDocumentCache.get(e);return t||(t=kl(e),this.typenameDocumentCache.set(e,t),this.typenameDocumentCache.set(t,t)),t}return e},t.prototype.broadcastWatches=function(e){var t=this;this.txCount||this.watches.forEach((function(r){return t.maybeBroadcastWatch(r,e)}))},t.prototype.broadcastWatch=function(e,t){var r=e.lastDiff,n=this.diff(e);t&&(e.optimistic&&"string"==typeof t.optimistic&&(n.fromOptimisticTransaction=!0),t.onWatchUpdated&&!1===t.onWatchUpdated.call(this,e,n,r))||(!r||!$u(r.result,n.result))&&e.callback(e.lastDiff=n,r)},t}(Od);var Bh,Uh=function(e){var t="";(fu(e.graphQLErrors)||fu(e.clientErrors))&&(e.graphQLErrors||[]).concat(e.clientErrors||[]).forEach((function(e){var r=e?e.message:"Error message not found.";t+="".concat(r,"\n")}));return e.networkError&&(t+="".concat(e.networkError.message,"\n")),t=t.replace(/\n$/,"")},Fh=function(e){function t(r){var n=r.graphQLErrors,i=r.clientErrors,o=r.networkError,s=r.errorMessage,a=r.extraInfo,c=e.call(this,s)||this;return c.graphQLErrors=n||[],c.clientErrors=i||[],c.networkError=o||null,c.message=s||Uh(c),c.extraInfo=a,c.__proto__=t.prototype,c}return Rn(t,e),t}(Error);function $h(e){return!!e&&e<7}!function(e){e[e.loading=1]="loading",e[e.setVariables=2]="setVariables",e[e.fetchMore=3]="fetchMore",e[e.refetch=4]="refetch",e[e.poll=6]="poll",e[e.ready=7]="ready",e[e.error=8]="error"}(Bh||(Bh={}));var qh=Object.assign,Kh=Object.hasOwnProperty,Vh=function(e){function t(t){var r=t.queryManager,n=t.queryInfo,i=t.options,o=e.call(this,(function(e){try{var t=e._subscription._observer;t&&!t.error&&(t.error=Hh)}catch{}var r=!o.observers.size;o.observers.add(e);var n=o.last;return n&&n.error?e.error&&e.error(n.error):n&&n.result&&e.next&&e.next(n.result),r&&o.reobserve().catch((function(){})),function(){o.observers.delete(e)&&!o.observers.size&&o.tearDownQuery()}}))||this;o.observers=new Set,o.subscriptions=new Set,o.queryInfo=n,o.queryManager=r,o.isTornDown=!1;var s=r.defaultOptions.watchQuery,a=(void 0===s?{}:s).fetchPolicy,c=void 0===a?"cache-first":a,l=i.fetchPolicy,u=void 0===l?c:l,d=i.initialFetchPolicy,h=void 0===d?"standby"===u?c:u:d;o.options=Cn(Cn({},i),{initialFetchPolicy:h,fetchPolicy:u}),o.queryId=n.queryId||r.generateQueryId();var f=fl(o.query);return o.queryName=f&&f.name&&f.name.value,o}return Rn(t,e),Object.defineProperty(t.prototype,"query",{get:function(){return this.queryManager.transform(this.options.query).document},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"variables",{get:function(){return this.options.variables},enumerable:!1,configurable:!0}),t.prototype.result=function(){var e=this;return new Promise((function(t,r){var n={next:function(r){t(r),e.observers.delete(n),e.observers.size||e.queryManager.removeQuery(e.queryId),setTimeout((function(){i.unsubscribe()}),0)},error:r},i=e.subscribe(n)}))},t.prototype.getCurrentResult=function(e){void 0===e&&(e=!0);var t=this.getLastResult(!0),r=this.queryInfo.networkStatus||t&&t.networkStatus||Bh.ready,n=Cn(Cn({},t),{loading:$h(r),networkStatus:r}),i=this.options.fetchPolicy,o=void 0===i?"cache-first":i;if("network-only"!==o&&"no-cache"!==o&&"standby"!==o&&!this.queryManager.transform(this.options.query).hasForcedResolvers){var s=this.queryInfo.getDiff();(s.complete||this.options.returnPartialData)&&(n.data=s.result),$u(n.data,{})&&(n.data=void 0),s.complete?(delete n.partial,s.complete&&n.networkStatus===Bh.loading&&("cache-first"===o||"cache-only"===o)&&(n.networkStatus=Bh.ready,n.loading=!1)):n.partial=!0,__DEV__&&!s.complete&&!this.options.partialRefetch&&!n.loading&&!n.data&&!n.error&&Wh(s.missing)}return e&&this.updateLastResult(n),n},t.prototype.isDifferentFromLastResult=function(e){return!this.last||!$u(this.last.result,e)},t.prototype.getLast=function(e,t){var r=this.last;if(r&&r[e]&&(!t||$u(r.variables,this.variables)))return r[e]},t.prototype.getLastResult=function(e){return this.getLast("result",e)},t.prototype.getLastError=function(e){return this.getLast("error",e)},t.prototype.resetLastResults=function(){delete this.last,this.isTornDown=!1},t.prototype.resetQueryStoreErrors=function(){this.queryManager.resetErrors(this.queryId)},t.prototype.refetch=function(e){var t,r={pollInterval:0},n=this.options.fetchPolicy;if(r.fetchPolicy="cache-and-network"===n?n:"no-cache"===n?"no-cache":"network-only",__DEV__&&e&&Kh.call(e,"variables")){var i=gl(this.query),o=i.variableDefinitions;(!o||!o.some((function(e){return"variables"===e.variable.name.value})))&&__DEV__&&hc.warn("Called refetch(".concat(JSON.stringify(e),") for query ").concat((null===(t=i.name)||void 0===t?void 0:t.value)||JSON.stringify(i),", which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?"))}return e&&!$u(this.options.variables,e)&&(r.variables=this.options.variables=Cn(Cn({},this.options.variables),e)),this.queryInfo.resetLastWrite(),this.reobserve(r,Bh.refetch)},t.prototype.fetchMore=function(e){var t=this,r=Cn(Cn({},e.query?e:Cn(Cn(Cn(Cn({},this.options),{query:this.query}),e),{variables:Cn(Cn({},this.options.variables),e.variables)})),{fetchPolicy:"no-cache"}),n=this.queryManager.generateQueryId(),i=this.queryInfo,o=i.networkStatus;i.networkStatus=Bh.fetchMore,r.notifyOnNetworkStatusChange&&this.observe();var s=new Set;return this.queryManager.fetchQuery(n,r,Bh.fetchMore).then((function(a){return t.queryManager.removeQuery(n),i.networkStatus===Bh.fetchMore&&(i.networkStatus=o),t.queryManager.cache.batch({update:function(n){var i=e.updateQuery;i?n.updateQuery({query:t.query,variables:t.variables,returnPartialData:!0,optimistic:!1},(function(e){return i(e,{fetchMoreResult:a.data,variables:r.variables})})):n.writeQuery({query:r.query,variables:r.variables,data:a.data})},onWatchUpdated:function(e){s.add(e.query)}}),a})).finally((function(){s.has(t.query)||zh(t)}))},t.prototype.subscribeToMore=function(e){var t=this,r=this.queryManager.startGraphQLSubscription({query:e.document,variables:e.variables,context:e.context}).subscribe({next:function(r){var n=e.updateQuery;n&&t.updateQuery((function(e,t){var i=t.variables;return n(e,{subscriptionData:r,variables:i})}))},error:function(t){e.onError?e.onError(t):__DEV__&&hc.error("Unhandled GraphQL subscription error",t)}});return this.subscriptions.add(r),function(){t.subscriptions.delete(r)&&r.unsubscribe()}},t.prototype.setOptions=function(e){return this.reobserve(e)},t.prototype.setVariables=function(e){return $u(this.variables,e)?this.observers.size?this.result():Promise.resolve():(this.options.variables=e,this.observers.size?this.reobserve({fetchPolicy:this.options.initialFetchPolicy,variables:e},Bh.setVariables):Promise.resolve())},t.prototype.updateQuery=function(e){var t=this.queryManager,r=e(t.cache.diff({query:this.options.query,variables:this.variables,returnPartialData:!0,optimistic:!1}).result,{variables:this.variables});r&&(t.cache.writeQuery({query:this.options.query,data:r,variables:this.variables}),t.broadcastQueries())},t.prototype.startPolling=function(e){this.options.pollInterval=e,this.updatePolling()},t.prototype.stopPolling=function(){this.options.pollInterval=0,this.updatePolling()},t.prototype.applyNextFetchPolicy=function(e,t){if(t.nextFetchPolicy){var r=t.fetchPolicy,n=void 0===r?"cache-first":r,i=t.initialFetchPolicy,o=void 0===i?n:i;"standby"===n||("function"==typeof t.nextFetchPolicy?t.fetchPolicy=t.nextFetchPolicy(n,{reason:e,options:t,observable:this,initialFetchPolicy:o}):t.fetchPolicy="variables-changed"===e?o:t.nextFetchPolicy)}return t.fetchPolicy},t.prototype.fetch=function(e,t){return this.queryManager.setObservableQuery(this),this.queryManager.fetchQueryObservable(this.queryId,e,t)},t.prototype.updatePolling=function(){var e=this;if(!this.queryManager.ssrMode){var t=this.pollingInfo,r=this.options.pollInterval;if(!r)return void(t&&(clearTimeout(t.timeout),delete this.pollingInfo));if(!t||t.interval!==r){__DEV__?hc(r,"Attempted to start a polling query without a polling interval."):hc(r,10),(t||(this.pollingInfo={})).interval=r;var n=function(){e.pollingInfo&&($h(e.queryInfo.networkStatus)?i():e.reobserve({fetchPolicy:"network-only"},Bh.poll).then(i,i))},i=function(){var t=e.pollingInfo;t&&(clearTimeout(t.timeout),t.timeout=setTimeout(n,t.interval))};i()}}},t.prototype.updateLastResult=function(e,t){return void 0===t&&(t=this.variables),this.last=Cn(Cn({},this.last),{result:this.queryManager.assumeImmutableResults?e:ru(e),variables:t}),fu(e.errors)||delete this.last.error,this.last},t.prototype.reobserve=function(e,t){var r=this;this.isTornDown=!1;var n=t===Bh.refetch||t===Bh.fetchMore||t===Bh.poll,i=this.options.variables,o=this.options.fetchPolicy,s=vu(this.options,e||{}),a=n?s:qh(this.options,s);n||(this.updatePolling(),e&&e.variables&&!$u(e.variables,i)&&"standby"!==a.fetchPolicy&&a.fetchPolicy===o&&(this.applyNextFetchPolicy("variables-changed",a),void 0===t&&(t=Bh.setVariables)));var c=a.variables&&Cn({},a.variables),l=this.fetch(a,t),u={next:function(e){r.reportResult(e,c)},error:function(e){r.reportError(e,c)}};return n||(this.concast&&this.observer&&this.concast.removeObserver(this.observer),this.concast=l,this.observer=u),l.addObserver(u),l.promise},t.prototype.observe=function(){this.reportResult(this.getCurrentResult(!1),this.variables)},t.prototype.reportResult=function(e,t){var r=this.getLastError();(r||this.isDifferentFromLastResult(e))&&((r||!e.partial||this.options.returnPartialData)&&this.updateLastResult(e,t),ou(this.observers,"next",e))},t.prototype.reportError=function(e,t){var r=Cn(Cn({},this.getLastResult()),{error:e,errors:e.graphQLErrors,networkStatus:Bh.error,loading:!1});this.updateLastResult(r,t),ou(this.observers,"error",this.last.error=e)},t.prototype.hasObservers=function(){return this.observers.size>0},t.prototype.tearDownQuery=function(){this.isTornDown||(this.concast&&this.observer&&(this.concast.removeObserver(this.observer),delete this.concast,delete this.observer),this.stopPolling(),this.subscriptions.forEach((function(e){return e.unsubscribe()})),this.subscriptions.clear(),this.queryManager.stopQuery(this.queryId),this.observers.clear(),this.isTornDown=!0)},t}(Xl);function zh(e){var t=e.options,r=t.fetchPolicy,n=t.nextFetchPolicy;return"cache-and-network"===r||"network-only"===r?e.reobserve({fetchPolicy:"cache-first",nextFetchPolicy:function(){return this.nextFetchPolicy=n,"function"==typeof n?n.apply(this,arguments):r}}):e.reobserve()}function Hh(e){__DEV__&&hc.error("Unhandled error",e.message,e.stack)}function Wh(e){__DEV__&&e&&__DEV__&&hc.debug("Missing cache result fields: ".concat(JSON.stringify(e)),e)}uu(Vh);var Gh=function(){function e(e){var t=e.cache,r=e.client,n=e.resolvers,i=e.fragmentMatcher;this.cache=t,r&&(this.client=r),n&&this.addResolvers(n),i&&this.setFragmentMatcher(i)}return e.prototype.addResolvers=function(e){var t=this;this.resolvers=this.resolvers||{},Array.isArray(e)?e.forEach((function(e){t.resolvers=Cl(t.resolvers,e)})):this.resolvers=Cl(this.resolvers,e)},e.prototype.setResolvers=function(e){this.resolvers={},this.addResolvers(e)},e.prototype.getResolvers=function(){return this.resolvers||{}},e.prototype.runResolvers=function(e){var t=e.document,r=e.remoteResult,n=e.context,i=e.variables,o=e.onlyRunForcedResolvers,s=void 0!==o&&o;return Pn(this,void 0,void 0,(function(){return Dn(this,(function(e){return t?[2,this.resolveDocument(t,r.data,n,i,this.fragmentMatcher,s).then((function(e){return Cn(Cn({},r),{data:e.result})}))]:[2,r]}))}))},e.prototype.setFragmentMatcher=function(e){this.fragmentMatcher=e},e.prototype.getFragmentMatcher=function(){return this.fragmentMatcher},e.prototype.clientQuery=function(e){return Gc(["client"],e)&&this.resolvers?e:null},e.prototype.serverQuery=function(e){return function(e){hl(e);var t=El([{test:function(e){return"client"===e.name.value},remove:!0}],e);return t&&(t=Bc(t,{FragmentDefinition:{enter:function(e){if(e.selectionSet&&e.selectionSet.selections.every((function(e){return ul(e)&&"__typename"===e.name.value})))return null}}})),t}(e)},e.prototype.prepareContext=function(e){var t=this.cache;return Cn(Cn({},e),{cache:t,getCacheKey:function(e){return t.identify(e)}})},e.prototype.addExportedVariables=function(e,t,r){return void 0===t&&(t={}),void 0===r&&(r={}),Pn(this,void 0,void 0,(function(){return Dn(this,(function(n){return e?[2,this.resolveDocument(e,this.buildRootValueFromCache(e,t)||{},this.prepareContext(r),t).then((function(e){return Cn(Cn({},t),e.exportedVariables)}))]:[2,Cn({},t)]}))}))},e.prototype.shouldForceResolvers=function(e){var t=!1;return Bc(e,{Directive:{enter:function(e){if("client"===e.name.value&&e.arguments&&(t=e.arguments.some((function(e){return"always"===e.name.value&&"BooleanValue"===e.value.kind&&!0===e.value.value}))))return Nc}}}),t},e.prototype.buildRootValueFromCache=function(e,t){return this.cache.diff({query:Il(e),variables:t,returnPartialData:!0,optimistic:!1}).result},e.prototype.resolveDocument=function(e,t,r,n,i,o){return void 0===r&&(r={}),void 0===n&&(n={}),void 0===i&&(i=function(){return!0}),void 0===o&&(o=!1),Pn(this,void 0,void 0,(function(){var s,a,c,l,u,d,h,f,p;return Dn(this,(function(v){return s=ml(e),a=vl(e),c=Jc(a),l=s.operation,u=l?l.charAt(0).toUpperCase()+l.slice(1):"Query",h=(d=this).cache,f=d.client,p={fragmentMap:c,context:Cn(Cn({},r),{cache:h,client:f}),variables:n,fragmentMatcher:i,defaultOperationType:u,exportedVariables:{},onlyRunForcedResolvers:o},[2,this.resolveSelectionSet(s.selectionSet,t,p).then((function(e){return{result:e,exportedVariables:p.exportedVariables}}))]}))}))},e.prototype.resolveSelectionSet=function(e,t,r){return Pn(this,void 0,void 0,(function(){var n,i,o,s,a,c=this;return Dn(this,(function(l){return n=r.fragmentMap,i=r.context,o=r.variables,s=[t],a=function(e){return Pn(c,void 0,void 0,(function(){var a,c;return Dn(this,(function(l){return Wc(e,o)?ul(e)?[2,this.resolveField(e,t,r).then((function(t){var r;typeof t<"u"&&s.push(((r={})[cl(e)]=t,r))}))]:(dl(e)?a=e:(a=n[e.name.value],__DEV__?hc(a,"No fragment named ".concat(e.name.value)):hc(a,9)),a&&a.typeCondition&&(c=a.typeCondition.name.value,r.fragmentMatcher(t,c,i))?[2,this.resolveSelectionSet(a.selectionSet,t,r).then((function(e){s.push(e)}))]:[2]):[2]}))}))},[2,Promise.all(e.selections.map(a)).then((function(){return Ml(s)}))]}))}))},e.prototype.resolveField=function(e,t,r){return Pn(this,void 0,void 0,(function(){var n,i,o,s,a,c,l,u,d,h=this;return Dn(this,(function(f){return n=r.variables,i=e.name.value,o=cl(e),s=i!==o,a=t[o]||t[i],c=Promise.resolve(a),(!r.onlyRunForcedResolvers||this.shouldForceResolvers(e))&&(l=t.__typename||r.defaultOperationType,(u=this.resolvers&&this.resolvers[l])&&((d=u[s?i:o])&&(c=Promise.resolve(ah.withValue(this.cache,d,[t,al(e,n),r.context,{field:e,fragmentMap:r.fragmentMap}]))))),[2,c.then((function(t){return void 0===t&&(t=a),e.directives&&e.directives.forEach((function(e){"export"===e.name.value&&e.arguments&&e.arguments.forEach((function(e){"as"===e.name.value&&"StringValue"===e.value.kind&&(r.exportedVariables[e.value.value]=t)}))})),e.selectionSet&&null!=t?Array.isArray(t)?h.resolveSubSelectedArray(e,t,r):e.selectionSet?h.resolveSelectionSet(e.selectionSet,t,r):void 0:t}))]}))}))},e.prototype.resolveSubSelectedArray=function(e,t,r){var n=this;return Promise.all(t.map((function(t){return null===t?null:Array.isArray(t)?n.resolveSubSelectedArray(e,t,r):e.selectionSet?n.resolveSelectionSet(e.selectionSet,t,r):void 0})))},e}(),Yh=new(au?WeakMap:Map);function Qh(e,t){var r=e[t];"function"==typeof r&&(e[t]=function(){return Yh.set(e,(Yh.get(e)+1)%1e15),r.apply(this,arguments)})}function Jh(e){e.notifyTimeout&&(clearTimeout(e.notifyTimeout),e.notifyTimeout=void 0)}var Xh=function(){function e(e,t){void 0===t&&(t=e.generateQueryId()),this.queryId=t,this.listeners=new Set,this.document=null,this.lastRequestId=1,this.subscriptions=new Set,this.stopped=!1,this.dirty=!1,this.observableQuery=null;var r=this.cache=e.cache;Yh.has(r)||(Yh.set(r,0),Qh(r,"evict"),Qh(r,"modify"),Qh(r,"reset"))}return e.prototype.init=function(e){var t=e.networkStatus||Bh.loading;return this.variables&&this.networkStatus!==Bh.loading&&!$u(this.variables,e.variables)&&(t=Bh.setVariables),$u(e.variables,this.variables)||(this.lastDiff=void 0),Object.assign(this,{document:e.document,variables:e.variables,networkError:null,graphQLErrors:this.graphQLErrors||[],networkStatus:t}),e.observableQuery&&this.setObservableQuery(e.observableQuery),e.lastRequestId&&(this.lastRequestId=e.lastRequestId),this},e.prototype.reset=function(){Jh(this),this.lastDiff=void 0,this.dirty=!1},e.prototype.getDiff=function(e){void 0===e&&(e=this.variables);var t=this.getDiffOptions(e);if(this.lastDiff&&$u(t,this.lastDiff.options))return this.lastDiff.diff;this.updateWatch(this.variables=e);var r=this.observableQuery;if(r&&"no-cache"===r.options.fetchPolicy)return{complete:!1};var n=this.cache.diff(t);return this.updateLastDiff(n,t),n},e.prototype.updateLastDiff=function(e,t){this.lastDiff=e?{diff:e,options:t||this.getDiffOptions()}:void 0},e.prototype.getDiffOptions=function(e){var t;return void 0===e&&(e=this.variables),{query:this.document,variables:e,returnPartialData:!0,optimistic:!0,canonizeResults:null===(t=this.observableQuery)||void 0===t?void 0:t.options.canonizeResults}},e.prototype.setDiff=function(e){var t=this,r=this.lastDiff&&this.lastDiff.diff;this.updateLastDiff(e),!this.dirty&&!$u(r&&r.result,e&&e.result)&&(this.dirty=!0,this.notifyTimeout||(this.notifyTimeout=setTimeout((function(){return t.notify()}),0)))},e.prototype.setObservableQuery=function(e){var t=this;e!==this.observableQuery&&(this.oqListener&&this.listeners.delete(this.oqListener),this.observableQuery=e,e?(e.queryInfo=this,this.listeners.add(this.oqListener=function(){t.getDiff().fromOptimisticTransaction?e.observe():zh(e)})):delete this.oqListener)},e.prototype.notify=function(){var e=this;Jh(this),this.shouldNotify()&&this.listeners.forEach((function(t){return t(e)})),this.dirty=!1},e.prototype.shouldNotify=function(){if(!this.dirty||!this.listeners.size)return!1;if($h(this.networkStatus)&&this.observableQuery){var e=this.observableQuery.options.fetchPolicy;if("cache-only"!==e&&"cache-and-network"!==e)return!1}return!0},e.prototype.stop=function(){if(!this.stopped){this.stopped=!0,this.reset(),this.cancel(),this.cancel=e.prototype.cancel,this.subscriptions.forEach((function(e){return e.unsubscribe()}));var t=this.observableQuery;t&&t.stopPolling()}},e.prototype.cancel=function(){},e.prototype.updateWatch=function(e){var t=this;void 0===e&&(e=this.variables);var r=this.observableQuery;if(!r||"no-cache"!==r.options.fetchPolicy){var n=Cn(Cn({},this.getDiffOptions(e)),{watcher:this,callback:function(e){return t.setDiff(e)}});(!this.lastWatch||!$u(n,this.lastWatch))&&(this.cancel(),this.cancel=this.cache.watch(this.lastWatch=n))}},e.prototype.resetLastWrite=function(){this.lastWrite=void 0},e.prototype.shouldWrite=function(e,t){var r=this.lastWrite;return!(r&&r.dmCount===Yh.get(this.cache)&&$u(t,r.variables)&&$u(e.data,r.result.data))},e.prototype.markResult=function(e,t,r){var n=this;this.graphQLErrors=fu(e.errors)?e.errors:[],this.reset(),"no-cache"===t.fetchPolicy?this.updateLastDiff({result:e.data,complete:!0},this.getDiffOptions(t.variables)):0!==r&&(Zh(e,t.errorPolicy)?this.cache.performTransaction((function(i){if(n.shouldWrite(e,t.variables))i.writeQuery({query:n.document,data:e.data,variables:t.variables,overwrite:1===r}),n.lastWrite={result:e,variables:t.variables,dmCount:Yh.get(n.cache)};else if(n.lastDiff&&n.lastDiff.diff.complete)return void(e.data=n.lastDiff.diff.result);var o=n.getDiffOptions(t.variables),s=i.diff(o);n.stopped||n.updateWatch(t.variables),n.updateLastDiff(s,o),s.complete&&(e.data=s.result)})):this.lastWrite=void 0)},e.prototype.markReady=function(){return this.networkError=null,this.networkStatus=Bh.ready},e.prototype.markError=function(e){return this.networkStatus=Bh.error,this.lastWrite=void 0,this.reset(),e.graphQLErrors&&(this.graphQLErrors=e.graphQLErrors),e.networkError&&(this.networkError=e.networkError),e},e}();function Zh(e,t){void 0===t&&(t="none");var r="ignore"===t||"all"===t,n=!pu(e);return!n&&r&&e.data&&(n=!0),n}var ef=Object.prototype.hasOwnProperty,tf=function(){function e(e){var t=e.cache,r=e.link,n=e.defaultOptions,i=e.queryDeduplication,o=void 0!==i&&i,s=e.onBroadcast,a=e.ssrMode,c=void 0!==a&&a,l=e.clientAwareness,u=void 0===l?{}:l,d=e.localState,h=e.assumeImmutableResults;this.clientAwareness={},this.queries=new Map,this.fetchCancelFns=new Map,this.transformCache=new(au?WeakMap:Map),this.queryIdCounter=1,this.requestIdCounter=1,this.mutationIdCounter=1,this.inFlightLinkObservables=new Map,this.cache=t,this.link=r,this.defaultOptions=n||Object.create(null),this.queryDeduplication=o,this.clientAwareness=u,this.localState=d||new Gh({cache:t}),this.ssrMode=c,this.assumeImmutableResults=!!h,(this.onBroadcast=s)&&(this.mutationStore=Object.create(null))}return e.prototype.stop=function(){var e=this;this.queries.forEach((function(t,r){e.stopQueryNoBroadcast(r)})),this.cancelPendingFetches(__DEV__?new dc("QueryManager stopped while query was in flight"):new dc(11))},e.prototype.cancelPendingFetches=function(e){this.fetchCancelFns.forEach((function(t){return t(e)})),this.fetchCancelFns.clear()},e.prototype.mutate=function(e){var t,r,n=e.mutation,i=e.variables,o=e.optimisticResponse,s=e.updateQueries,a=e.refetchQueries,c=void 0===a?[]:a,l=e.awaitRefetchQueries,u=void 0!==l&&l,d=e.update,h=e.onQueryUpdated,f=e.fetchPolicy,p=void 0===f?(null===(t=this.defaultOptions.mutate)||void 0===t?void 0:t.fetchPolicy)||"network-only":f,v=e.errorPolicy,g=void 0===v?(null===(r=this.defaultOptions.mutate)||void 0===r?void 0:r.errorPolicy)||"none":v,m=e.keepRootFields,y=e.context;return Pn(this,void 0,void 0,(function(){var e,t,r;return Dn(this,(function(a){switch(a.label){case 0:return __DEV__?hc(n,"mutation option is required. You must specify your GraphQL document in the mutation option."):hc(n,12),__DEV__?hc("network-only"===p||"no-cache"===p,"Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `
											network - only` behavior automatically writes mutation results to the cache. Passing `
											no - cache` skips the cache write."):hc("network-only"===p||"no-cache"===p,13),e=this.generateMutationId(),n=this.transform(n).document,i=this.getVariables(n,i),this.transform(n).hasClientExports?[4,this.localState.addExportedVariables(n,i,y)]:[3,2];case 1:i=a.sent(),a.label=2;case 2:return t=this.mutationStore&&(this.mutationStore[e]={mutation:n,variables:i,loading:!0,error:null}),o&&this.markMutationOptimistic(o,{mutationId:e,document:n,variables:i,fetchPolicy:p,errorPolicy:g,context:y,updateQueries:s,update:d,keepRootFields:m}),this.broadcastQueries(),r=this,[2,new Promise((function(a,l){return su(r.getObservableFromLink(n,Cn(Cn({},y),{optimisticResponse:o}),i,!1),(function(a){if(pu(a)&&"none"===g)throw new Fh({graphQLErrors:a.errors});t&&(t.loading=!1,t.error=null);var l=Cn({},a);return"function"==typeof c&&(c=c(l)),"ignore"===g&&pu(l)&&delete l.errors,r.markMutationResult({mutationId:e,result:l,document:n,variables:i,fetchPolicy:p,errorPolicy:g,context:y,update:d,updateQueries:s,awaitRefetchQueries:u,refetchQueries:c,removeOptimistic:o?e:void 0,onQueryUpdated:h,keepRootFields:m})})).subscribe({next:function(e){r.broadcastQueries(),a(e)},error:function(n){t&&(t.loading=!1,t.error=n),o&&r.cache.removeOptimistic(e),r.broadcastQueries(),l(n instanceof Fh?n:new Fh({networkError:n}))}})}))]}}))}))},e.prototype.markMutationResult=function(e,t){var r=this;void 0===t&&(t=this.cache);var n=e.result,i=[],o="no-cache"===e.fetchPolicy;if(!o&&Zh(n,e.errorPolicy)){i.push({result:n.data,dataId:"ROOT_MUTATION",query:e.document,variables:e.variables});var s=e.updateQueries;s&&this.queries.forEach((function(e,o){var a=e.observableQuery,c=a&&a.queryName;if(c&&ef.call(s,c)){var l=s[c],u=r.queries.get(o),d=u.document,h=u.variables,f=t.diff({query:d,variables:h,returnPartialData:!0,optimistic:!1}),p=f.result;if(f.complete&&p){var v=l(p,{mutationResult:n,queryName:d&&pl(d)||void 0,queryVariables:h});v&&i.push({result:v,dataId:"ROOT_QUERY",query:d,variables:h})}}}))}if(i.length>0||e.refetchQueries||e.update||e.onQueryUpdated||e.removeOptimistic){var a=[];if(this.refetchQueries({updateCache:function(t){o||i.forEach((function(e){return t.write(e)}));var s=e.update;if(s){if(!o){var a=t.diff({id:"ROOT_MUTATION",query:r.transform(e.document).asQuery,variables:e.variables,optimistic:!1,returnPartialData:!0});a.complete&&(n=Cn(Cn({},n),{data:a.result}))}s(t,n,{context:e.context,variables:e.variables})}!o&&!e.keepRootFields&&t.modify({id:"ROOT_MUTATION",fields:function(e,t){var r=t.fieldName,n=t.DELETE;return"__typename"===r?e:n}})},include:e.refetchQueries,optimistic:!1,removeOptimistic:e.removeOptimistic,onQueryUpdated:e.onQueryUpdated||null}).forEach((function(e){return a.push(e)})),e.awaitRefetchQueries||e.onQueryUpdated)return Promise.all(a).then((function(){return n}))}return Promise.resolve(n)},e.prototype.markMutationOptimistic=function(e,t){var r=this,n="function"==typeof e?e(t.variables):e;return this.cache.recordOptimisticTransaction((function(e){try{r.markMutationResult(Cn(Cn({},t),{result:{data:n}}),e)}catch(i){__DEV__&&hc.error(i)}}),t.mutationId)},e.prototype.fetchQuery=function(e,t,r){return this.fetchQueryObservable(e,t,r).promise},e.prototype.getQueryStore=function(){var e=Object.create(null);return this.queries.forEach((function(t,r){e[r]={variables:t.variables,networkStatus:t.networkStatus,networkError:t.networkError,graphQLErrors:t.graphQLErrors}})),e},e.prototype.resetErrors=function(e){var t=this.queries.get(e);t&&(t.networkError=void 0,t.graphQLErrors=[])},e.prototype.transform=function(e){var t=this.transformCache;if(!t.has(e)){var r=this.cache.transformDocument(e),n=function(e){return El([Tl],hl(e))}(this.cache.transformForLink(r)),i=this.localState.clientQuery(r),o=n&&this.localState.serverQuery(n),s={document:r,hasClientExports:Yc(r),hasForcedResolvers:this.localState.shouldForceResolvers(r),clientQuery:i,serverQuery:o,defaultVars:yl(fl(r)),asQuery:Cn(Cn({},r),{definitions:r.definitions.map((function(e){return"OperationDefinition"===e.kind&&"query"!==e.operation?Cn(Cn({},e),{operation:"query"}):e}))})},a=function(e){e&&!t.has(e)&&t.set(e,s)};a(e),a(r),a(i),a(o)}return t.get(e)},e.prototype.getVariables=function(e,t){return Cn(Cn({},this.transform(e).defaultVars),t)},e.prototype.watchQuery=function(e){typeof(e=Cn(Cn({},e),{variables:this.getVariables(e.query,e.variables)})).notifyOnNetworkStatusChange>"u"&&(e.notifyOnNetworkStatusChange=!1);var t=new Xh(this),r=new Vh({queryManager:this,queryInfo:t,options:e});return this.queries.set(r.queryId,t),t.init({document:r.query,observableQuery:r,variables:r.variables}),r},e.prototype.query=function(e,t){var r=this;return void 0===t&&(t=this.generateQueryId()),__DEV__?hc(e.query,"query option is required. You must specify your GraphQL document in the query option."):hc(e.query,14),__DEV__?hc("Document"===e.query.kind,'You must wrap the query string in a "gql" tag.'):hc("Document"===e.query.kind,15),__DEV__?hc(!e.returnPartialData,"returnPartialData option only supported on watchQuery."):hc(!e.returnPartialData,16),__DEV__?hc(!e.pollInterval,"pollInterval option only supported on watchQuery."):hc(!e.pollInterval,17),this.fetchQuery(t,e).finally((function(){return r.stopQuery(t)}))},e.prototype.generateQueryId=function(){return String(this.queryIdCounter++)},e.prototype.generateRequestId=function(){return this.requestIdCounter++},e.prototype.generateMutationId=function(){return String(this.mutationIdCounter++)},e.prototype.stopQueryInStore=function(e){this.stopQueryInStoreNoBroadcast(e),this.broadcastQueries()},e.prototype.stopQueryInStoreNoBroadcast=function(e){var t=this.queries.get(e);t&&t.stop()},e.prototype.clearStore=function(e){return void 0===e&&(e={discardWatches:!0}),this.cancelPendingFetches(__DEV__?new dc("Store reset while query was in flight (not completed in link chain)"):new dc(18)),this.queries.forEach((function(e){e.observableQuery?e.networkStatus=Bh.loading:e.stop()})),this.mutationStore&&(this.mutationStore=Object.create(null)),this.cache.reset(e)},e.prototype.getObservableQueries=function(e){var t=this;void 0===e&&(e="active");var r=new Map,n=new Map,i=new Set;return Array.isArray(e)&&e.forEach((function(e){"string"==typeof e?n.set(e,!1):function(e){return Zc(e)&&"Document"===e.kind&&Array.isArray(e.definitions)}(e)?n.set(t.transform(e).document,!1):Zc(e)&&e.query&&i.add(e)})),this.queries.forEach((function(t,i){var o=t.observableQuery,s=t.document;if(o){if("all"===e)return void r.set(i,o);var a=o.queryName;if("standby"===o.options.fetchPolicy||"active"===e&&!o.hasObservers())return;("active"===e||a&&n.has(a)||s&&n.has(s))&&(r.set(i,o),a&&n.set(a,!0),s&&n.set(s,!0))}})),i.size&&i.forEach((function(e){var n=mu("legacyOneTimeQuery"),i=t.getQuery(n).init({document:e.query,variables:e.variables}),o=new Vh({queryManager:t,queryInfo:i,options:Cn(Cn({},e),{fetchPolicy:"network-only"})});hc(o.queryId===n),i.setObservableQuery(o),r.set(n,o)})),__DEV__&&n.size&&n.forEach((function(e,t){e||__DEV__&&hc.warn("Unknown query ".concat("string"==typeof t?"named ":"").concat(JSON.stringify(t,null,2)," requested in refetchQueries options.include array"))})),r},e.prototype.reFetchObservableQueries=function(e){var t=this;void 0===e&&(e=!1);var r=[];return this.getObservableQueries(e?"all":"active").forEach((function(n,i){var o=n.options.fetchPolicy;n.resetLastResults(),(e||"standby"!==o&&"cache-only"!==o)&&r.push(n.refetch()),t.getQuery(i).setDiff(null)})),this.broadcastQueries(),Promise.all(r)},e.prototype.setObservableQuery=function(e){this.getQuery(e.queryId).setObservableQuery(e)},e.prototype.startGraphQLSubscription=function(e){var t=this,r=e.query,n=e.fetchPolicy,i=e.errorPolicy,o=e.variables,s=e.context,a=void 0===s?{}:s;r=this.transform(r).document,o=this.getVariables(r,o);var c=function(e){return t.getObservableFromLink(r,a,e).map((function(o){if("no-cache"!==n&&(Zh(o,i)&&t.cache.write({query:r,result:o.data,dataId:"ROOT_SUBSCRIPTION",variables:e}),t.broadcastQueries()),pu(o))throw new Fh({graphQLErrors:o.errors});return o}))};if(this.transform(r).hasClientExports){var l=this.localState.addExportedVariables(r,o,a).then(c);return new Xl((function(e){var t=null;return l.then((function(r){return t=r.subscribe(e)}),e.error),function(){return t&&t.unsubscribe()}}))}return c(o)},e.prototype.stopQuery=function(e){this.stopQueryNoBroadcast(e),this.broadcastQueries()},e.prototype.stopQueryNoBroadcast=function(e){this.stopQueryInStoreNoBroadcast(e),this.removeQuery(e)},e.prototype.removeQuery=function(e){this.fetchCancelFns.delete(e),this.queries.has(e)&&(this.getQuery(e).stop(),this.queries.delete(e))},e.prototype.broadcastQueries=function(){this.onBroadcast&&this.onBroadcast(),this.queries.forEach((function(e){return e.notify()}))},e.prototype.getLocalState=function(){return this.localState},e.prototype.getObservableFromLink=function(e,t,r,n){var i,o=this;void 0===n&&(n=null!==(i=null==t?void 0:t.queryDeduplication)&&void 0!==i?i:this.queryDeduplication);var s,a=this.transform(e).serverQuery;if(a){var c=this.inFlightLinkObservables,l=this.link,u={query:a,variables:r,operationName:pl(a)||void 0,context:this.prepareContext(Cn(Cn({},t),{forceFetch:!n}))};if(t=u.context,n){var d=c.get(a)||new Map;c.set(a,d);var h=rh(r);if(!(s=d.get(h))){var f=new hu([Iu(l,u)]);d.set(h,s=f),f.cleanup((function(){d.delete(h)&&d.size<1&&c.delete(a)}))}}else s=new hu([Iu(l,u)])}else s=new hu([Xl.of({data:{}})]),t=this.prepareContext(t);var p=this.transform(e).clientQuery;return p&&(s=su(s,(function(e){return o.localState.runResolvers({document:p,remoteResult:e,context:t,variables:r})}))),s},e.prototype.getResultsFromLink=function(e,t,r){var n=e.lastRequestId=this.generateRequestId();return su(this.getObservableFromLink(e.document,r.context,r.variables),(function(i){var o=fu(i.errors);if(n>=e.lastRequestId){if(o&&"none"===r.errorPolicy)throw e.markError(new Fh({graphQLErrors:i.errors}));e.markResult(i,r,t),e.markReady()}var s={data:i.data,loading:!1,networkStatus:Bh.ready};return o&&"ignore"!==r.errorPolicy&&(s.errors=i.errors,s.networkStatus=Bh.error),s}),(function(t){var r=function(e){return e.hasOwnProperty("graphQLErrors")}(t)?t:new Fh({networkError:t});throw n>=e.lastRequestId&&e.markError(r),r}))},e.prototype.fetchQueryObservable=function(e,t,r){var n=this;void 0===r&&(r=Bh.loading);var i=this.transform(t.query).document,o=this.getVariables(i,t.variables),s=this.getQuery(e),a=this.defaultOptions.watchQuery,c=t.fetchPolicy,l=void 0===c?a&&a.fetchPolicy||"cache-first":c,u=t.errorPolicy,d=void 0===u?a&&a.errorPolicy||"none":u,h=t.returnPartialData,f=void 0!==h&&h,p=t.notifyOnNetworkStatusChange,v=void 0!==p&&p,g=t.context,m=void 0===g?{}:g,y=Object.assign({},t,{query:i,variables:o,fetchPolicy:l,errorPolicy:d,returnPartialData:f,notifyOnNetworkStatusChange:v,context:m}),b=function(e){y.variables=e;var i=n.fetchQueryByPolicy(s,y,r);return"standby"!==y.fetchPolicy&&i.length>0&&s.observableQuery&&s.observableQuery.applyNextFetchPolicy("after-fetch",t),i},_=function(){return n.fetchCancelFns.delete(e)};this.fetchCancelFns.set(e,(function(e){_(),setTimeout((function(){return w.cancel(e)}))}));var w=new hu(this.transform(y.query).hasClientExports?this.localState.addExportedVariables(y.query,y.variables,y.context).then(b):b(y.variables));return w.promise.then(_,_),w},e.prototype.refetchQueries=function(e){var t=this,r=e.updateCache,n=e.include,i=e.optimistic,o=void 0!==i&&i,s=e.removeOptimistic,a=void 0===s?o?mu("refetchQueries"):void 0:s,c=e.onQueryUpdated,l=new Map;n&&this.getObservableQueries(n).forEach((function(e,r){l.set(r,{oq:e,lastDiff:t.getQuery(r).getDiff()})}));var u=new Map;return r&&this.cache.batch({update:r,optimistic:o&&a||!1,removeOptimistic:a,onWatchUpdated:function(e,t,r){var n=e.watcher instanceof Xh&&e.watcher.observableQuery;if(n){if(c){l.delete(n.queryId);var i=c(n,t,r);return!0===i&&(i=n.refetch()),!1!==i&&u.set(n,i),i}null!==c&&l.set(n.queryId,{oq:n,lastDiff:r,diff:t})}}}),l.size&&l.forEach((function(e,r){var n,i=e.oq,o=e.lastDiff,s=e.diff;if(c){if(!s){var a=i.queryInfo;a.reset(),s=a.getDiff()}n=c(i,s,o)}(!c||!0===n)&&(n=i.refetch()),!1!==n&&u.set(i,n),r.indexOf("legacyOneTimeQuery")>=0&&t.stopQueryNoBroadcast(r)})),a&&this.cache.removeOptimistic(a),u},e.prototype.fetchQueryByPolicy=function(e,t,r){var n=this,i=t.query,o=t.variables,s=t.fetchPolicy,a=t.refetchWritePolicy,c=t.errorPolicy,l=t.returnPartialData,u=t.context,d=t.notifyOnNetworkStatusChange,h=e.networkStatus;e.init({document:this.transform(i).document,variables:o,networkStatus:r});var f=function(){return e.getDiff(o)},p=function(t,r){void 0===r&&(r=e.networkStatus||Bh.loading);var s=t.result;__DEV__&&!l&&!$u(s,{})&&Wh(t.missing);var a=function(e){return Xl.of(Cn({data:e,loading:$h(r),networkStatus:r},t.complete?null:{partial:!0}))};return s&&n.transform(i).hasForcedResolvers?n.localState.runResolvers({document:i,remoteResult:{data:s},context:u,variables:o,onlyRunForcedResolvers:!0}).then((function(e){return a(e.data||void 0)})):a(s)},v="no-cache"===s?0:r===Bh.refetch&&"merge"!==a?1:2,g=function(){return n.getResultsFromLink(e,v,{variables:o,context:u,fetchPolicy:s,errorPolicy:c})},m=d&&"number"==typeof h&&h!==r&&$h(r);switch(s){default:case"cache-first":return(y=f()).complete?[p(y,e.markReady())]:l||m?[p(y),g()]:[g()];case"cache-and-network":var y;return(y=f()).complete||l||m?[p(y),g()]:[g()];case"cache-only":return[p(f(),e.markReady())];case"network-only":return m?[p(f()),g()]:[g()];case"no-cache":return m?[p(e.getDiff()),g()]:[g()];case"standby":return[]}},e.prototype.getQuery=function(e){return e&&!this.queries.has(e)&&this.queries.set(e,new Xh(this,e)),this.queries.get(e)},e.prototype.prepareContext=function(e){void 0===e&&(e={});var t=this.localState.prepareContext(e);return Cn(Cn({},t),{clientAwareness:this.clientAwareness})},e}(),rf=!1,nf=function(){function e(e){var t=this;this.resetStoreCallbacks=[],this.clearStoreCallbacks=[];var r=e.uri,n=e.credentials,i=e.headers,o=e.cache,s=e.ssrMode,a=void 0!==s&&s,c=e.ssrForceFetchDelay,l=void 0===c?0:c,u=e.connectToDevTools,d=void 0===u?"object"==typeof window&&!window.__APOLLO_CLIENT__&&__DEV__:u,h=e.queryDeduplication,f=void 0===h||h,p=e.defaultOptions,v=e.assumeImmutableResults,g=void 0!==v&&v,m=e.resolvers,y=e.typeDefs,b=e.fragmentMatcher,_=e.name,w=e.version,S=e.link;if(S||(S=r?new ju({uri:r,credentials:n,headers:i}):Tu.empty()),!o)throw __DEV__?new dc("To initialize Apollo Client, you must specify a 'cache' property in the options object. \nFor more information, please visit: https://go.apollo.dev/c/docs"):new dc(7);if(this.link=S,this.cache=o,this.disableNetworkFetches=a||l>0,this.queryDeduplication=f,this.defaultOptions=p||Object.create(null),this.typeDefs=y,l&&setTimeout((function(){return t.disableNetworkFetches=!1}),l),this.watchQuery=this.watchQuery.bind(this),this.query=this.query.bind(this),this.mutate=this.mutate.bind(this),this.resetStore=this.resetStore.bind(this),this.reFetchObservableQueries=this.reFetchObservableQueries.bind(this),d&&"object"==typeof window&&(window.__APOLLO_CLIENT__=this),!rf&&__DEV__&&(rf=!0,typeof window<"u"&&window.document&&window.top===window.self&&!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__)){var E=window.navigator,k=E&&E.userAgent,T=void 0;"string"==typeof k&&(k.indexOf("Chrome/")>-1?T="https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm":k.indexOf("Firefox/")>-1&&(T="https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/")),T&&__DEV__&&hc.log("Download the Apollo DevTools for a better development experience: "+T)}this.version=Ru,this.localState=new Gh({cache:o,client:this,resolvers:m,fragmentMatcher:b}),this.queryManager=new tf({cache:this.cache,link:this.link,defaultOptions:this.defaultOptions,queryDeduplication:f,ssrMode:a,clientAwareness:{name:_,version:w},localState:this.localState,assumeImmutableResults:g,onBroadcast:d?function(){t.devToolsHookCb&&t.devToolsHookCb({action:{},state:{queries:t.queryManager.getQueryStore(),mutations:t.queryManager.mutationStore||{}},dataWithOptimisticResults:t.cache.extract(!0)})}:void 0})}return e.prototype.stop=function(){this.queryManager.stop()},e.prototype.watchQuery=function(e){return this.defaultOptions.watchQuery&&(e=yu(this.defaultOptions.watchQuery,e)),this.disableNetworkFetches&&("network-only"===e.fetchPolicy||"cache-and-network"===e.fetchPolicy)&&(e=Cn(Cn({},e),{fetchPolicy:"cache-first"})),this.queryManager.watchQuery(e)},e.prototype.query=function(e){return this.defaultOptions.query&&(e=yu(this.defaultOptions.query,e)),__DEV__?hc("cache-and-network"!==e.fetchPolicy,"The cache-and-network fetchPolicy does not work with client.query, because client.query can only return a single result. Please use client.watchQuery to receive multiple results from the cache and the network, or consider using a different fetchPolicy, such as cache-first or network-only."):hc("cache-and-network"!==e.fetchPolicy,8),this.disableNetworkFetches&&"network-only"===e.fetchPolicy&&(e=Cn(Cn({},e),{fetchPolicy:"cache-first"})),this.queryManager.query(e)},e.prototype.mutate=function(e){return this.defaultOptions.mutate&&(e=yu(this.defaultOptions.mutate,e)),this.queryManager.mutate(e)},e.prototype.subscribe=function(e){return this.queryManager.startGraphQLSubscription(e)},e.prototype.readQuery=function(e,t){return void 0===t&&(t=!1),this.cache.readQuery(e,t)},e.prototype.readFragment=function(e,t){return void 0===t&&(t=!1),this.cache.readFragment(e,t)},e.prototype.writeQuery=function(e){this.cache.writeQuery(e),this.queryManager.broadcastQueries()},e.prototype.writeFragment=function(e){this.cache.writeFragment(e),this.queryManager.broadcastQueries()},e.prototype.__actionHookForDevTools=function(e){this.devToolsHookCb=e},e.prototype.__requestRaw=function(e){return Iu(this.link,e)},e.prototype.resetStore=function(){var e=this;return Promise.resolve().then((function(){return e.queryManager.clearStore({discardWatches:!1})})).then((function(){return Promise.all(e.resetStoreCallbacks.map((function(e){return e()})))})).then((function(){return e.reFetchObservableQueries()}))},e.prototype.clearStore=function(){var e=this;return Promise.resolve().then((function(){return e.queryManager.clearStore({discardWatches:!0})})).then((function(){return Promise.all(e.clearStoreCallbacks.map((function(e){return e()})))}))},e.prototype.onResetStore=function(e){var t=this;return this.resetStoreCallbacks.push(e),function(){t.resetStoreCallbacks=t.resetStoreCallbacks.filter((function(t){return t!==e}))}},e.prototype.onClearStore=function(e){var t=this;return this.clearStoreCallbacks.push(e),function(){t.clearStoreCallbacks=t.clearStoreCallbacks.filter((function(t){return t!==e}))}},e.prototype.reFetchObservableQueries=function(e){return this.queryManager.reFetchObservableQueries(e)},e.prototype.refetchQueries=function(e){var t=this.queryManager.refetchQueries(e),r=[],n=[];t.forEach((function(e,t){r.push(t),n.push(e)}));var i=Promise.all(n);return i.queries=r,i.results=n,i.catch((function(e){__DEV__&&hc.debug("In client.refetchQueries, Promise.all promise rejected with error ".concat(e))})),i},e.prototype.getObservableQueries=function(e){return void 0===e&&(e="active"),this.queryManager.getObservableQueries(e)},e.prototype.extract=function(e){return this.cache.extract(e)},e.prototype.restore=function(e){return this.cache.restore(e)},e.prototype.addResolvers=function(e){this.localState.addResolvers(e)},e.prototype.setResolvers=function(e){this.localState.setResolvers(e)},e.prototype.getResolvers=function(){return this.localState.getResolvers()},e.prototype.setLocalStateFragmentMatcher=function(e){this.localState.setFragmentMatcher(e)},e.prototype.setLink=function(e){this.link=this.queryManager.link=e},e}();!function(e){var t=fc[pc];pc=Math.max(0,fc.indexOf(e))}(_c?"log":"silent");var of,sf,af=class extends sc{constructor(e,t,r){super(e,r),y(this,of,void 0),y(this,sf,void 0),this.networkStatus=Bh.ready,this.partial=!1,b(this,of,!1),this.init(null!=t?t:null)}get query(){return this.document}set query(e){this.document=e}get canAutoSubscribe(){return!!this.client&&!!this.document&&!this.options.noAutoSubscribe&&this.shouldSubscribe()}hostConnected(){super.hostConnected(),m(this,of)&&this.observableQuery?(this.observableQuery.reobserve(),b(this,of,!1)):this.documentChanged(this.query)}hostDisconnected(){b(this,of,!0),super.hostDisconnected()}shouldSubscribe(e){var t,r,n;return null==(n=null==(r=(t=this.options).shouldSubscribe)?void 0:r.call(t,e))||n}canSubscribe(e){var t,r;return!(null!=(t=this.options.noAutoSubscribe)&&t||!this.client||!(null!=(r=null==e?void 0:e.query)?r:this.document))}watchQuery(e){var t;if(!this.client)throw new TypeError("No Apollo client. See https://apolloelements.dev/guides/getting-started/apollo-client/");return this.client.watchQuery({query:this.query,variables:null!=(t=this.variables)?t:void 0,context:this.options.context,errorPolicy:this.options.errorPolicy,fetchPolicy:this.options.fetchPolicy,notifyOnNetworkStatusChange:this.options.notifyOnNetworkStatusChange,partialRefetch:this.options.partialRefetch,pollInterval:this.options.pollInterval,returnPartialData:this.options.returnPartialData,nextFetchPolicy:this.options.nextFetchPolicy,...e})}nextData(e){var t,r,n,i,o,s;this.emitter.dispatchEvent(new CustomEvent("apollo-query-result",{detail:e}));let{data:a,error:c,errors:l,loading:u,networkStatus:d,partial:h}=this;this.data=e.data,this.error=null!=(t=e.error)?t:null,this.errors=null!=(r=e.errors)?r:[],this.loading=null!=(n=e.loading)&&n,this.networkStatus=e.networkStatus,this.partial=null!=(i=e.partial)&&i,null==(s=(o=this.options).onData)||s.call(o,e.data),this.notify({data:a,error:c,errors:l,loading:u,networkStatus:d,partial:h})}nextError(e){var t,r;let{error:n,loading:i}=this;this.emitter.dispatchEvent(new CustomEvent("apollo-error",{detail:e})),this.error=e,this.loading=!1,null==(r=(t=this.options).onError)||r.call(t,e),this.notify({error:n,loading:i})}clientChanged(){this.canSubscribe()&&this.shouldSubscribe()&&this.subscribe()}documentChanged(e){let t=null!=e?e:void 0;e!==m(this,sf)&&this.canSubscribe({query:t})&&this.shouldSubscribe({query:t})&&this.subscribe({query:t})}variablesChanged(e){this.observableQuery?this.refetch(e):this.canSubscribe({variables:e})&&this.shouldSubscribe({variables:e})&&this.subscribe({variables:e})}optionsChanged(e){var t,r;null==(r=null==(t=this.observableQuery)?void 0:t.setOptions)||r.call(t,e)}async refetch(e){if(!this.observableQuery)throw new Error("Cannot refetch without an ObservableQuery");return this.observableQuery.refetch(e)}subscribe(e){var t,r,n,i;this.observableQuery&&this.observableQuery.stopPolling(),this.observableQuery=this.watchQuery({query:this.query,variables:null!=(t=this.variables)?t:void 0,context:this.options.context,errorPolicy:this.options.errorPolicy,fetchPolicy:this.options.fetchPolicy,notifyOnNetworkStatusChange:this.options.notifyOnNetworkStatusChange,partialRefetch:this.options.partialRefetch,pollInterval:this.options.pollInterval,refetchWritePolicy:this.options.refetchWritePolicy,returnPartialData:this.options.returnPartialData,...e}),b(this,sf,null!=(n=null!=(r=null==e?void 0:e.query)?r:this.query)?n:void 0);let{loading:o}=this;return this.loading=!0,this.notify({loading:o}),null==(i=this.observableQuery)?void 0:i.subscribe({next:this.nextData.bind(this),error:this.nextError.bind(this)})}subscribeToMore(e){var t;return null==(t=this.observableQuery)?void 0:t.subscribeToMore(e)}async executeQuery(e){try{if(!this.client)throw new TypeError("No Apollo client. See https://apolloelements.dev/guides/getting-started/apollo-client/");let{loading:t}=this;this.loading=!0,this.notify({loading:t});let r=await this.client.query({query:this.query,variables:this.variables,context:this.options.context,errorPolicy:this.options.errorPolicy,fetchPolicy:"cache-and-network"===this.options.fetchPolicy?void 0:this.options.fetchPolicy,notifyOnNetworkStatusChange:this.options.notifyOnNetworkStatusChange,partialRefetch:this.options.partialRefetch,returnPartialData:this.options.returnPartialData,...e});return r&&this.nextData(r),r}catch(t){throw this.nextError(t),t}}async fetchMore(e){var t;let{loading:r}=this;this.loading=!0,this.notify({loading:r});let n={query:this.query,context:this.options.context,variables:null!=(t=this.variables)?t:void 0,...e};return null!=n.variables||(n.variables=void 0),null!=this.observableQuery||(this.observableQuery=this.watchQuery(n)),this.observableQuery.fetchMore(n).then(e=>{let{loading:t}=this;return this.loading=!1,this.notify({loading:t}),e})}startPolling(e){this.pollingInterval=window.setInterval(()=>{this.refetch()},e)}stopPolling(){clearInterval(this.pollingInterval)}};of=new WeakMap,sf=new WeakMap,xn([ac],af.prototype,"watchQuery",null),xn([ac],af.prototype,"refetch",null),xn([ac],af.prototype,"subscribe",null),xn([ac],af.prototype,"subscribeToMore",null),xn([ac],af.prototype,"executeQuery",null),xn([ac],af.prototype,"fetchMore",null),xn([ac],af.prototype,"startPolling",null),xn([ac],af.prototype,"stopPolling",null);var cf,lf,uf=class extends sc{constructor(e,t,r){super(e,r),y(this,cf,void 0),y(this,lf,void 0),b(this,cf,!1),this.init(null!=t?t:null)}get subscription(){return this.document}set subscription(e){this.document=e}get canAutoSubscribe(){return!!this.client&&!this.options.noAutoSubscribe&&this.shouldSubscribe()}hostConnected(){super.hostConnected(),m(this,cf)&&this.observableSubscription?this.subscribe():this.documentChanged(this.subscription)}hostDisconnected(){this.endSubscription(),b(this,cf,!0),super.hostDisconnected()}canSubscribe(e){var t;return!(this.options.noAutoSubscribe||!this.client||this.observable&&!this.options.shouldResubscribe||!(null!=(t=null==e?void 0:e.query)?t:this.subscription))}initObservable(e){var t;let{shouldResubscribe:r=this.options.shouldResubscribe,client:n=this.client,skip:i=this.options.skip,...o}=null!=e?e:{};if(!n)throw new TypeError("No Apollo client. See https://apolloelements.dev/guides/getting-started/apollo-client/");if(this.observable&&!r||i)return;let s=null!=(t=null==e?void 0:e.subscription)?t:this.subscription;b(this,lf,s),this.observable=n.subscribe({variables:this.variables,context:this.options.context,errorPolicy:this.options.errorPolicy,fetchPolicy:this.options.fetchPolicy,...o,query:s})}nextData(e){var t,r,n,i,o;let{data:s,error:a,errors:c,loading:l}=this,u={client:this.client,subscriptionData:{data:null!=(t=null==e?void 0:e.data)?t:null,loading:!1,error:null}};this.emitter.dispatchEvent(new CustomEvent("apollo-subscription-result",{detail:u})),this.data=null!=(r=null==e?void 0:e.data)?r:null,this.error=null,this.errors=null!=(n=null==e?void 0:e.errors)?n:[],this.loading=!1,null==(o=(i=this.options).onData)||o.call(i,u),this.notify({data:s,error:a,errors:c,loading:l})}nextError(e){var t,r;let{error:n,loading:i}=this;this.emitter.dispatchEvent(new CustomEvent("apollo-error",{detail:e})),this.error=e,this.loading=!1,null==(r=(t=this.options).onError)||r.call(t,e),this.notify({error:n,loading:i})}onComplete(){var e,t;let{data:r,error:n,loading:i}=this;null==(t=(e=this.options).onComplete)||t.call(e),this.endSubscription(),this.notify({data:r,error:n,loading:i})}endSubscription(){this.observableSubscription&&this.observableSubscription.unsubscribe()}shouldSubscribe(e){var t,r,n;return null==(n=null==(r=(t=this.options).shouldSubscribe)?void 0:r.call(t,e))||n}clientChanged(){this.canSubscribe()&&this.shouldSubscribe()&&this.subscribe()}documentChanged(e){let t=null!=e?e:void 0;e!==m(this,lf)&&(this.cancel(),this.canSubscribe({query:t})&&this.shouldSubscribe({query:t})&&this.subscribe())}variablesChanged(e){this.cancel(),this.canSubscribe({variables:e})&&this.shouldSubscribe({variables:e})&&this.subscribe()}subscribe(e){var t,r;this.initObservable(e);let n=null!=(t=null==e?void 0:e.shouldResubscribe)?t:this.options.shouldResubscribe;if(this.observableSubscription&&!n)return;let{loading:i}=this;this.loading=!0,this.notify({loading:i}),this.observableSubscription=null==(r=this.observable)?void 0:r.subscribe({next:this.nextData.bind(this),error:this.nextError.bind(this),complete:this.onComplete.bind(this)})}cancel(){this.endSubscription(),this.observableSubscription=void 0,this.observable=void 0}};cf=new WeakMap,lf=new WeakMap,xn([ac],uf.prototype,"subscribe",null),xn([ac],uf.prototype,"cancel",null);var df,hf=class extends Event{constructor(e){super("change"),this.value=e}};EventTarget;df=new WeakMap;var ff=Object.prototype.toString;function pf(e,t){return ff.call(e)===` [object $ {
												t
											}] `}function vf(e){return pf(e,"Object")}function gf(e){return Boolean(e&&e.then&&"function"==typeof e.then)}function mf(e){return e&&e.Math==Math?e:void 0}var yf="object"==typeof globalThis&&mf(globalThis)||"object"==typeof window&&mf(window)||"object"==typeof self&&mf(self)||"object"==typeof e&&mf(e)||function(){return this}()||{};function bf(e,t,r){let n=r||yf,i=n.__SENTRY__=n.__SENTRY__||{};return i[e]||(i[e]=t())}var _f,wf,Sf="Sentry Logger ",Ef=["debug","info","warn","error","log","assert","trace"];function kf(e){if(!("console"in yf))return e();let t=yf.console,r={};Ef.forEach(e=>{let n=t[e]&&t[e].__sentry_original__;e in t&&n&&(r[e]=t[e],t[e]=n)});try{return e()}finally{Object.keys(r).forEach(e=>{t[e]=r[e]})}}function Tf(){let e=!1,t={enable:()=>{e=!0},disable:()=>{e=!1}};return typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__?Ef.forEach(r=>{t[r]=(...t)=>{e&&kf(()=>{yf.console[r](`
											$ {
												Sf
											} [$ {
												r
											}]: `,...t)})}}):Ef.forEach(e=>{t[e]=()=>{}}),t}function If(e,t){return!!function(e){return pf(e,"String")}(e)&&(function(e){return pf(e,"RegExp")}(t)?t.test(e):"string"==typeof t&&-1!==e.indexOf(t))}function Rf(e){return function e(t,r){if(vf(t)){let n=r.get(t);if(void 0!==n)return n;let i={};r.set(t,i);for(let o of Object.keys(t))typeof t[o]<"u"&&(i[o]=e(t[o],r));return i}if(Array.isArray(t)){let n=r.get(t);if(void 0!==n)return n;let i=[];return r.set(t,i),t.forEach(t=>{i.push(e(t,r))}),i}return t}(e,new Map)}function Cf(){let e=yf,t=e.crypto||e.msCrypto;if(t&&t.randomUUID)return t.randomUUID().replace(/-/g,"");let r=t&&t.getRandomValues?()=>t.getRandomValues(new Uint8Array(1))[0]:()=>16*Math.random();return([1e7]+1e3+4e3+8e3+1e11).replace(/[018]/g,e=>(e^(15&r())>>e/4).toString(16))}function Mf(e){let{message:t,event_id:r}=e;if(t)return t;let n=function(e){return e.exception&&e.exception.values?e.exception.values[0]:void 0}(e);return n?n.type&&n.value?`
											$ {
												n.type
											}: $ {
												n.value
											}
											`:n.type||n.value||r||"<unknown>":r||"<unknown>"}function xf(){return!(typeof __SENTRY_BROWSER_BUNDLE__<"u"&&__SENTRY_BROWSER_BUNDLE__)&&"[object process]"===Object.prototype.toString.call(typeof t<"u"?t:0)}_f=typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__?bf("logger",Tf):Tf(),function(e){e[e.PENDING=0]="PENDING";e[e.RESOLVED=1]="RESOLVED";e[e.REJECTED=2]="REJECTED"}(wf||(wf={}));var Of=class{__init(){this._state=wf.PENDING}__init2(){this._handlers=[]}constructor(e){Of.prototype.__init.call(this),Of.prototype.__init2.call(this),Of.prototype.__init3.call(this),Of.prototype.__init4.call(this),Of.prototype.__init5.call(this),Of.prototype.__init6.call(this);try{e(this._resolve,this._reject)}catch(t){this._reject(t)}}then(e,t){return new Of((r,n)=>{this._handlers.push([!1,t=>{if(e)try{r(e(t))}catch(i){n(i)}else r(t)},e=>{if(t)try{r(t(e))}catch(i){n(i)}else n(e)}]),this._executeHandlers()})}catch(e){return this.then(e=>e,e)}finally(e){return new Of((t,r)=>{let n,i;return this.then(t=>{i=!1,n=t,e&&e()},t=>{i=!0,n=t,e&&e()}).then(()=>{i?r(n):t(n)})})}__init3(){this._resolve=e=>{this._setResult(wf.RESOLVED,e)}}__init4(){this._reject=e=>{this._setResult(wf.REJECTED,e)}}__init5(){this._setResult=(e,t)=>{if(this._state===wf.PENDING){if(gf(t))return void t.then(this._resolve,this._reject);this._state=e,this._value=t,this._executeHandlers()}}}__init6(){this._executeHandlers=()=>{if(this._state===wf.PENDING)return;let e=this._handlers.slice();this._handlers=[],e.forEach(e=>{e[0]||(this._state===wf.RESOLVED&&e[1](this._value),this._state===wf.REJECTED&&e[2](this._value),e[0]=!0)})}}},Af=yf,Pf={nowSeconds:()=>Date.now()/1e3};var Df=xf()?function(){try{return function(e,t){return e.require(t)}(n,"perf_hooks").performance}catch{return}}():function(){let{performance:e}=Af;if(e&&e.now)return{now:()=>e.now(),timeOrigin:Date.now()-e.now()}}(),jf=void 0===Df?Pf:{nowSeconds:()=>(Df.timeOrigin+Df.now())/1e3},Lf=Pf.nowSeconds.bind(Pf),Nf=jf.nowSeconds.bind(jf);(()=>{let{performance:e}=Af;if(!e||!e.now)return void"none";let t=36e5,r=e.now(),n=Date.now(),i=e.timeOrigin?Math.abs(e.timeOrigin+r-n):t,o=i<t,s=e.timing&&e.timing.navigationStart,a="number"==typeof s?Math.abs(s+r-n):t;o||a<t?i<=a?("timeOrigin",e.timeOrigin):"navigationStart":"dateNow"})();function Bf(e){let t=Nf(),r={sid:Cf(),init:!0,timestamp:t,started:t,duration:0,status:"ok",errors:0,ignoreDuration:!1,toJSON:()=>(function(e){return Rf({sid:`
											$ {
												e.sid
											}
											`,init:e.init,started:new Date(1e3*e.started).toISOString(),timestamp:new Date(1e3*e.timestamp).toISOString(),status:e.status,errors:e.errors,did:"number"==typeof e.did||"string"==typeof e.did?`
											$ {
												e.did
											}
											`:void 0,duration:e.duration,attrs:{release:e.release,environment:e.environment,ip_address:e.ipAddress,user_agent:e.userAgent}})})(r)};return e&&Uf(r,e),r}function Uf(e,t={}){if(t.user&&(!e.ipAddress&&t.user.ip_address&&(e.ipAddress=t.user.ip_address),!e.did&&!t.did&&(e.did=t.user.id||t.user.email||t.user.username)),e.timestamp=t.timestamp||Nf(),t.ignoreDuration&&(e.ignoreDuration=t.ignoreDuration),t.sid&&(e.sid=32===t.sid.length?t.sid:Cf()),void 0!==t.init&&(e.init=t.init),!e.did&&t.did&&(e.did=`
											$ {
												t.did
											}
											`),"number"==typeof t.started&&(e.started=t.started),e.ignoreDuration)e.duration=void 0;else if("number"==typeof t.duration)e.duration=t.duration;else{let t=e.timestamp-e.started;e.duration=t>=0?t:0}t.release&&(e.release=t.release),t.environment&&(e.environment=t.environment),!e.ipAddress&&t.ipAddress&&(e.ipAddress=t.ipAddress),!e.userAgent&&t.userAgent&&(e.userAgent=t.userAgent),"number"==typeof t.errors&&(e.errors=t.errors),t.status&&(e.status=t.status)}var Ff=class{constructor(){this._notifyingListeners=!1,this._scopeListeners=[],this._eventProcessors=[],this._breadcrumbs=[],this._attachments=[],this._user={},this._tags={},this._extra={},this._contexts={},this._sdkProcessingMetadata={}}static clone(e){let t=new Ff;return e&&(t._breadcrumbs=[...e._breadcrumbs],t._tags={...e._tags},t._extra={...e._extra},t._contexts={...e._contexts},t._user=e._user,t._level=e._level,t._span=e._span,t._session=e._session,t._transactionName=e._transactionName,t._fingerprint=e._fingerprint,t._eventProcessors=[...e._eventProcessors],t._requestSession=e._requestSession,t._attachments=[...e._attachments]),t}addScopeListener(e){this._scopeListeners.push(e)}addEventProcessor(e){return this._eventProcessors.push(e),this}setUser(e){return this._user=e||{},this._session&&Uf(this._session,{user:e}),this._notifyScopeListeners(),this}getUser(){return this._user}getRequestSession(){return this._requestSession}setRequestSession(e){return this._requestSession=e,this}setTags(e){return this._tags={...this._tags,...e},this._notifyScopeListeners(),this}setTag(e,t){return this._tags={...this._tags,[e]:t},this._notifyScopeListeners(),this}setExtras(e){return this._extra={...this._extra,...e},this._notifyScopeListeners(),this}setExtra(e,t){return this._extra={...this._extra,[e]:t},this._notifyScopeListeners(),this}setFingerprint(e){return this._fingerprint=e,this._notifyScopeListeners(),this}setLevel(e){return this._level=e,this._notifyScopeListeners(),this}setTransactionName(e){return this._transactionName=e,this._notifyScopeListeners(),this}setContext(e,t){return null===t?delete this._contexts[e]:this._contexts[e]=t,this._notifyScopeListeners(),this}setSpan(e){return this._span=e,this._notifyScopeListeners(),this}getSpan(){return this._span}getTransaction(){let e=this.getSpan();return e&&e.transaction}setSession(e){return e?this._session=e:delete this._session,this._notifyScopeListeners(),this}getSession(){return this._session}update(e){if(!e)return this;if("function"==typeof e){let t=e(this);return t instanceof Ff?t:this}return e instanceof Ff?(this._tags={...this._tags,...e._tags},this._extra={...this._extra,...e._extra},this._contexts={...this._contexts,...e._contexts},e._user&&Object.keys(e._user).length&&(this._user=e._user),e._level&&(this._level=e._level),e._fingerprint&&(this._fingerprint=e._fingerprint),e._requestSession&&(this._requestSession=e._requestSession)):vf(e)&&(e=e,this._tags={...this._tags,...e.tags},this._extra={...this._extra,...e.extra},this._contexts={...this._contexts,...e.contexts},e.user&&(this._user=e.user),e.level&&(this._level=e.level),e.fingerprint&&(this._fingerprint=e.fingerprint),e.requestSession&&(this._requestSession=e.requestSession)),this}clear(){return this._breadcrumbs=[],this._tags={},this._extra={},this._user={},this._contexts={},this._level=void 0,this._transactionName=void 0,this._fingerprint=void 0,this._requestSession=void 0,this._span=void 0,this._session=void 0,this._notifyScopeListeners(),this._attachments=[],this}addBreadcrumb(e,t){let r="number"==typeof t?t:100;if(r<=0)return this;let n={timestamp:Lf(),...e};return this._breadcrumbs=[...this._breadcrumbs,n].slice(-r),this._notifyScopeListeners(),this}clearBreadcrumbs(){return this._breadcrumbs=[],this._notifyScopeListeners(),this}addAttachment(e){return this._attachments.push(e),this}getAttachments(){return this._attachments}clearAttachments(){return this._attachments=[],this}applyToEvent(e,t={}){if(this._extra&&Object.keys(this._extra).length&&(e.extra={...this._extra,...e.extra}),this._tags&&Object.keys(this._tags).length&&(e.tags={...this._tags,...e.tags}),this._user&&Object.keys(this._user).length&&(e.user={...this._user,...e.user}),this._contexts&&Object.keys(this._contexts).length&&(e.contexts={...this._contexts,...e.contexts}),this._level&&(e.level=this._level),this._transactionName&&(e.transaction=this._transactionName),this._span){e.contexts={trace:this._span.getTraceContext(),...e.contexts};let t=this._span.transaction&&this._span.transaction.name;t&&(e.tags={transaction:t,...e.tags})}return this._applyFingerprint(e),e.breadcrumbs=[...e.breadcrumbs||[],...this._breadcrumbs],e.breadcrumbs=e.breadcrumbs.length>0?e.breadcrumbs:void 0,e.sdkProcessingMetadata={...e.sdkProcessingMetadata,...this._sdkProcessingMetadata},this._notifyEventProcessors([...$f(),...this._eventProcessors],e,t)}setSDKProcessingMetadata(e){return this._sdkProcessingMetadata={...this._sdkProcessingMetadata,...e},this}_notifyEventProcessors(e,t,r,n=0){return new Of((i,o)=>{let s=e[n];if(null===t||"function"!=typeof s)i(t);else{let a=s({...t},r);(typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__)&&s.id&&null===a&&_f.log(`
											Event processor "${s.id}"
											dropped event`),gf(a)?a.then(t=>this._notifyEventProcessors(e,t,r,n+1).then(i)).then(null,o):this._notifyEventProcessors(e,a,r,n+1).then(i).then(null,o)}})}_notifyScopeListeners(){this._notifyingListeners||(this._notifyingListeners=!0,this._scopeListeners.forEach(e=>{e(this)}),this._notifyingListeners=!1)}_applyFingerprint(e){e.fingerprint=e.fingerprint?function(e){return Array.isArray(e)?e:[e]}(e.fingerprint):[],this._fingerprint&&(e.fingerprint=e.fingerprint.concat(this._fingerprint)),e.fingerprint&&!e.fingerprint.length&&delete e.fingerprint}};function $f(){return bf("globalEventProcessors",()=>[])}function qf(e){$f().push(e)}var Kf=4,Vf=100,zf=class{__init(){this._stack=[{}]}constructor(e,t=new Ff,r=Kf){this._version=r,zf.prototype.__init.call(this),this.getStackTop().scope=t,e&&this.bindClient(e)}isOlderThan(e){return this._version<e}bindClient(e){this.getStackTop().client=e,e&&e.setupIntegrations&&e.setupIntegrations()}pushScope(){let e=Ff.clone(this.getScope());return this.getStack().push({client:this.getClient(),scope:e}),e}popScope(){return!(this.getStack().length<=1)&&!!this.getStack().pop()}withScope(e){let t=this.pushScope();try{e(t)}finally{this.popScope()}}getClient(){return this.getStackTop().client}getScope(){return this.getStackTop().scope}getStack(){return this._stack}getStackTop(){return this._stack[this._stack.length-1]}captureException(e,t){let r=this._lastEventId=t&&t.event_id?t.event_id:Cf(),n=new Error("Sentry syntheticException");return this._withClient((i,o)=>{i.captureException(e,{originalException:e,syntheticException:n,...t,event_id:r},o)}),r}captureMessage(e,t,r){let n=this._lastEventId=r&&r.event_id?r.event_id:Cf(),i=new Error(e);return this._withClient((o,s)=>{o.captureMessage(e,t,{originalException:e,syntheticException:i,...r,event_id:n},s)}),n}captureEvent(e,t){let r=t&&t.event_id?t.event_id:Cf();return"transaction"!==e.type&&(this._lastEventId=r),this._withClient((n,i)=>{n.captureEvent(e,{...t,event_id:r},i)}),r}lastEventId(){return this._lastEventId}addBreadcrumb(e,t){let{scope:r,client:n}=this.getStackTop();if(!r||!n)return;let{beforeBreadcrumb:i=null,maxBreadcrumbs:o=Vf}=n.getOptions&&n.getOptions()||{};if(o<=0)return;let s={timestamp:Lf(),...e},a=i?kf(()=>i(s,t)):s;null!==a&&r.addBreadcrumb(a,o)}setUser(e){let t=this.getScope();t&&t.setUser(e)}setTags(e){let t=this.getScope();t&&t.setTags(e)}setExtras(e){let t=this.getScope();t&&t.setExtras(e)}setTag(e,t){let r=this.getScope();r&&r.setTag(e,t)}setExtra(e,t){let r=this.getScope();r&&r.setExtra(e,t)}setContext(e,t){let r=this.getScope();r&&r.setContext(e,t)}configureScope(e){let{scope:t,client:r}=this.getStackTop();t&&r&&e(t)}run(e){let t=Wf(this);try{e(this)}finally{Wf(t)}}getIntegration(e){let t=this.getClient();if(!t)return null;try{return t.getIntegration(e)}catch{return(typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__)&&_f.warn(`
											Cannot retrieve integration $ {
												e.id
											}
											from the current Hub`),null}}startTransaction(e,t){return this._callExtensionMethod("startTransaction",e,t)}traceHeaders(){return this._callExtensionMethod("traceHeaders")}captureSession(e=!1){if(e)return this.endSession();this._sendSessionUpdate()}endSession(){let e=this.getStackTop(),t=e&&e.scope,r=t&&t.getSession();r&&function(e,t){let r={};t?r={status:t}:"ok"===e.status&&(r={status:"exited"}),Uf(e,r)}(r),this._sendSessionUpdate(),t&&t.setSession()}startSession(e){let{scope:t,client:r}=this.getStackTop(),{release:n,environment:i}=r&&r.getOptions()||{},{userAgent:o}=yf.navigator||{},s=Bf({release:n,environment:i,...t&&{user:t.getUser()},...o&&{userAgent:o},...e});if(t){let e=t.getSession&&t.getSession();e&&"ok"===e.status&&Uf(e,{status:"exited"}),this.endSession(),t.setSession(s)}return s}shouldSendDefaultPii(){let e=this.getClient(),t=e&&e.getOptions();return Boolean(t&&t.sendDefaultPii)}_sendSessionUpdate(){let{scope:e,client:t}=this.getStackTop();if(!e)return;let r=e.getSession();r&&t&&t.captureSession&&t.captureSession(r)}_withClient(e){let{scope:t,client:r}=this.getStackTop();r&&e(r,t)}_callExtensionMethod(e,...t){let r=Hf().__SENTRY__;if(r&&r.extensions&&"function"==typeof r.extensions[e])return r.extensions[e].apply(this,t);(typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__)&&_f.warn(`
											Extension method $ {
												e
											}
											couldn 't be found, doing nothing.`)}};function Hf(){return yf.__SENTRY__=yf.__SENTRY__||{extensions:{},hub:void 0},yf}function Wf(e){let t=Hf(),r=Qf(t);return Jf(t,e),r}function Gf(){let e=Hf();return(!Yf(e)||Qf(e).isOlderThan(Kf))&&Jf(e,new zf),xf()?function(e){try{let t=Hf().__SENTRY__,r=t&&t.extensions&&t.extensions.domain&&t.extensions.domain.active;if(!r)return Qf(e);if(!Yf(r)||Qf(r).isOlderThan(Kf)){let t=Qf(e).getStackTop();Jf(r,new zf(t.client,Ff.clone(t.scope)))}return Qf(r)}catch{return Qf(e)}}(e):Qf(e)}function Yf(e){return!!(e&&e.__SENTRY__&&e.__SENTRY__.hub)}function Qf(e){return bf("hub",()=>new zf,e)}function Jf(e,t){if(!e)return!1;return(e.__SENTRY__=e.__SENTRY__||{}).hub=t,!0}function Xf(e,t){return Gf().captureException(e,{captureContext:t})}function Zf(e){Gf().withScope(e)}var ep={};h(ep,{FunctionToString:()=>rp,InboundFilters:()=>ip});var tp,rp=class{constructor(){rp.prototype.__init.call(this)}static __initStatic(){this.id="FunctionToString"}__init(){this.name=rp.id}setupOnce(){tp=Function.prototype.toString,Function.prototype.toString=function(...e){let t=function(e){return e.__sentry_original__}(this)||this;return tp.apply(t,e)}}};rp.__initStatic();var np=[/^Script error\.?$/,/^Javascript error: Script error\.? on line 0$/],ip=class{static __initStatic(){this.id="InboundFilters"}__init(){this.name=ip.id}constructor(e={}){this._options=e,ip.prototype.__init.call(this)}setupOnce(e,t){let r=e=>{let r=t();if(r){let t=r.getIntegration(ip);if(t){let n=r.getClient(),i=n?n.getOptions():{};return function(e,t){return t.ignoreInternal&&function(e){try{return"SentryError"===e.exception.values[0].type}catch{}return!1}(e)?((typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__)&&_f.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${Mf(e)}`),!0):function(e,t){return!(!t||!t.length)&&function(e){if(e.message)return[e.message];if(e.exception)try{let{type:t="",value:r=""}=e.exception.values&&e.exception.values[0]||{};return[`${r}`,`${t}: ${r}`]}catch{return(typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__)&&_f.error(`Cannot extract message for event ${Mf(e)}`),[]}return[]}(e).some(e=>t.some(t=>If(e,t)))}(e,t.ignoreErrors)?((typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__)&&_f.warn(`Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${Mf(e)}`),!0):function(e,t){if(!t||!t.length)return!1;let r=op(e);return!!r&&t.some(e=>If(r,e))}(e,t.denyUrls)?((typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__)&&_f.warn(`Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${Mf(e)}.\nUrl: ${op(e)}`),!0):!function(e,t){if(!t||!t.length)return!0;let r=op(e);return!r||t.some(e=>If(r,e))}(e,t.allowUrls)&&((typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__)&&_f.warn(`Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${Mf(e)}.\nUrl: ${op(e)}`),!0)}(e,function(e={},t={}){return{allowUrls:[...e.allowUrls||[],...t.allowUrls||[]],denyUrls:[...e.denyUrls||[],...t.denyUrls||[]],ignoreErrors:[...e.ignoreErrors||[],...t.ignoreErrors||[],...np],ignoreInternal:void 0===e.ignoreInternal||e.ignoreInternal}}(t._options,i))?null:e}}return e};r.id=this.name,e(r)}};function op(e){try{let t;try{t=e.exception.values[0].stacktrace.frames}catch{}return t?function(e=[]){for(let t=e.length-1;t>=0;t--){let r=e[t];if(r&&"<anonymous>"!==r.filename&&"[native code]"!==r.filename)return r.filename||null}return null}(t):null}catch{return(typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__)&&_f.error(`Cannot extract url for event ${Mf(e)}`),null}}ip.__initStatic();var sp=Object.prototype.toString;function ap(e){switch(sp.call(e)){case"[object Error]":case"[object Exception]":case"[object DOMException]":return!0;default:return pp(e,Error)}}function cp(e,t){return sp.call(e)===`[object ${t}]`}function lp(e){return cp(e,"ErrorEvent")}function up(e){return cp(e,"DOMError")}function dp(e){return cp(e,"String")}function hp(e){return cp(e,"Object")}function fp(e){return typeof Event<"u"&&pp(e,Event)}function pp(e,t){try{return e instanceof t}catch{return!1}}function vp(e){return e&&e.Math==Math?e:void 0}var gp="object"==typeof globalThis&&vp(globalThis)||"object"==typeof window&&vp(window)||"object"==typeof self&&vp(self)||"object"==typeof e&&vp(e)||function(){return this}()||{};function mp(){return gp}var yp=mp();function bp(e,t){try{let r,n=e,i=5,o=80,s=[],a=0,c=0,l=" > ",u=l.length;for(;n&&a++<i&&!("html"===(r=_p(n,t))||a>1&&c+s.length*u+r.length>=o);)s.push(r),c+=r.length,n=n.parentNode;return s.reverse().join(l)}catch{return"<unknown>"}}function _p(e,t){let r,n,i,o,s,a=e,c=[];if(!a||!a.tagName)return"";c.push(a.tagName.toLowerCase());let l=t&&t.length?t.filter(e=>a.getAttribute(e)).map(e=>[e,a.getAttribute(e)]):null;if(l&&l.length)l.forEach(e=>{c.push(`[${e[0]}="${e[1]}"]`)});else if(a.id&&c.push(`#${a.id}`),(r=a.className)&&dp(r))for(n=r.split(/\s+/),s=0;s<n.length;s++)c.push(`.${n[s]}`);let u=["type","name","title","alt"];for(s=0;s<u.length;s++)i=u[s],(o=a.getAttribute(i))&&c.push(`[${i}="${o}"]`);return c.join("")}var wp,Sp="Sentry Logger ",Ep=["debug","info","warn","error","log","assert","trace"];function kp(){let e=!1,t={enable:()=>{e=!0},disable:()=>{e=!1}};return typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__?Ep.forEach(r=>{t[r]=(...t)=>{e&&function(e){if(!("console"in gp))return e();let t=gp.console,r={};Ep.forEach(e=>{let n=t[e]&&t[e].__sentry_original__;e in t&&n&&(r[e]=t[e],t[e]=n)});try{e()}finally{Object.keys(r).forEach(e=>{t[e]=r[e]})}}(()=>{gp.console[r](`${Sp}[${r}]:`,...t)})}}):Ep.forEach(e=>{t[e]=()=>{}}),t}function Tp(e,t=0){return"string"!=typeof e||0===t||e.length<=t?e:`${e.substr(0,t)}...`}function Ip(e,t){if(!Array.isArray(e))return"";let r=[];for(let n=0;n<e.length;n++){let t=e[n];try{r.push(String(t))}catch{r.push("[value cannot be serialized]")}}return r.join(t)}function Rp(e,t,r){if(!(t in e))return;let n=e[t],i=r(n);if("function"==typeof i)try{Mp(i,n)}catch{}e[t]=i}function Cp(e,t,r){Object.defineProperty(e,t,{value:r,writable:!0,configurable:!0})}function Mp(e,t){let r=t.prototype||{};e.prototype=t.prototype=r,Cp(e,"__sentry_original__",t)}function xp(e){return e.__sentry_original__}function Op(e){if(ap(e))return{message:e.message,name:e.name,stack:e.stack,...Pp(e)};if(fp(e)){let t={type:e.type,target:Ap(e.target),currentTarget:Ap(e.currentTarget),...Pp(e)};return typeof CustomEvent<"u"&&pp(e,CustomEvent)&&(t.detail=e.detail),t}return e}function Ap(e){try{return function(e){return typeof Element<"u"&&pp(e,Element)}(e)?bp(e):Object.prototype.toString.call(e)}catch{return"<unknown>"}}function Pp(e){if("object"==typeof e&&null!==e){let t={};for(let r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t}return{}}function Dp(e,t=40){let r=Object.keys(Op(e));if(r.sort(),!r.length)return"[object has no keys]";if(r[0].length>=t)return Tp(r[0],t);for(let n=r.length;n>0;n--){let e=r.slice(0,n).join(", ");if(!(e.length>t))return n===r.length?e:Tp(e,t)}return""}wp=typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__?function(e,t,r){let n=r||gp,i=n.__SENTRY__=n.__SENTRY__||{};return i[e]||(i[e]=t())}("logger",kp):kp();var jp="<anonymous>";function Lp(e){try{return e&&"function"==typeof e&&e.name||jp}catch{return jp}}var Np=mp();function Bp(e){return e&&/^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(e.toString())}function Up(){if(!function(){if(!("fetch"in Np))return!1;try{return new Headers,new Request("http://www.example.com"),new Response,!0}catch{return!1}}())return!1;if(Bp(Np.fetch))return!0;let e=!1,t=Np.document;if(t&&"function"==typeof t.createElement)try{let r=t.createElement("iframe");r.hidden=!0,t.head.appendChild(r),r.contentWindow&&r.contentWindow.fetch&&(e=Bp(r.contentWindow.fetch)),t.head.removeChild(r)}catch(r){(typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__)&&wp.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ",r)}return e}var Fp,$p=mp(),qp={},Kp={};function Vp(e){if(!Kp[e])switch(Kp[e]=!0,e){case"console":"console"in $p&&Ep.forEach((function(e){e in $p.console&&Rp($p.console,e,(function(t){return function(...r){Hp("console",{args:r,level:e}),t&&t.apply($p.console,r)}}))}));break;case"dom":!function(){if(!("document"in $p))return;let e=Hp.bind(null,"dom"),t=Xp(e,!0);$p.document.addEventListener("click",t,!1),$p.document.addEventListener("keypress",t,!1),["EventTarget","Node"].forEach(t=>{let r=$p[t]&&$p[t].prototype;!r||!r.hasOwnProperty||!r.hasOwnProperty("addEventListener")||(Rp(r,"addEventListener",(function(t){return function(r,n,i){if("click"===r||"keypress"==r)try{let n=this,o=n.__sentry_instrumentation_handlers__=n.__sentry_instrumentation_handlers__||{},s=o[r]=o[r]||{refCount:0};if(!s.handler){let n=Xp(e);s.handler=n,t.call(this,r,n,i)}s.refCount+=1}catch{}return t.call(this,r,n,i)}})),Rp(r,"removeEventListener",(function(e){return function(t,r,n){if("click"===t||"keypress"==t)try{let r=this,i=r.__sentry_instrumentation_handlers__||{},o=i[t];o&&(o.refCount-=1,o.refCount<=0&&(e.call(this,t,o.handler,n),o.handler=void 0,delete i[t]),0===Object.keys(i).length&&delete r.__sentry_instrumentation_handlers__)}catch{}return e.call(this,t,r,n)}})))})}();break;case"xhr":!function(){if(!("XMLHttpRequest"in $p))return;let e=XMLHttpRequest.prototype;Rp(e,"open",(function(e){return function(...t){let r=this,n=t[1],i=r.__sentry_xhr__={method:dp(t[0])?t[0].toUpperCase():t[0],url:t[1]};dp(n)&&"POST"===i.method&&n.match(/sentry_key/)&&(r.__sentry_own_request__=!0);let o=function(){if(4===r.readyState){try{i.status_code=r.status}catch{}Hp("xhr",{args:t,endTimestamp:Date.now(),startTimestamp:Date.now(),xhr:r})}};return"onreadystatechange"in r&&"function"==typeof r.onreadystatechange?Rp(r,"onreadystatechange",(function(e){return function(...t){return o(),e.apply(r,t)}})):r.addEventListener("readystatechange",o),e.apply(r,t)}})),Rp(e,"send",(function(e){return function(...t){return this.__sentry_xhr__&&void 0!==t[0]&&(this.__sentry_xhr__.body=t[0]),Hp("xhr",{args:t,startTimestamp:Date.now(),xhr:this}),e.apply(this,t)}}))}();break;case"fetch":!Up()||Rp($p,"fetch",(function(e){return function(...t){let r={args:t,fetchData:{method:Wp(t),url:Gp(t)},startTimestamp:Date.now()};return Hp("fetch",{...r}),e.apply($p,t).then(e=>(Hp("fetch",{...r,endTimestamp:Date.now(),response:e}),e),e=>{throw Hp("fetch",{...r,endTimestamp:Date.now(),error:e}),e})}}));break;case"history":!function(){if(!function(){let e=Np.chrome,t=e&&e.app&&e.app.runtime,r="history"in Np&&!!Np.history.pushState&&!!Np.history.replaceState;return!t&&r}())return;let e=$p.onpopstate;function t(e){return function(...t){let r=t.length>2?t[2]:void 0;if(r){let e=Fp,t=String(r);Fp=t,Hp("history",{from:e,to:t})}return e.apply(this,t)}}$p.onpopstate=function(...t){let r=$p.location.href,n=Fp;if(Fp=r,Hp("history",{from:n,to:r}),e)try{return e.apply(this,t)}catch{}},Rp($p.history,"pushState",t),Rp($p.history,"replaceState",t)}();break;case"error":Zp=$p.onerror,$p.onerror=function(e,t,r,n,i){return Hp("error",{column:n,error:i,line:r,msg:e,url:t}),!!Zp&&Zp.apply(this,arguments)};break;case"unhandledrejection":ev=$p.onunhandledrejection,$p.onunhandledrejection=function(e){return Hp("unhandledrejection",e),!ev||ev.apply(this,arguments)};break;default:return void((typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__)&&wp.warn("unknown instrumentation type:",e))}}function zp(e,t){qp[e]=qp[e]||[],qp[e].push(t),Vp(e)}function Hp(e,t){if(e&&qp[e])for(let n of qp[e]||[])try{n(t)}catch(r){(typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__)&&wp.error(`Error while triggering instrumentation handler.\nType: ${e}\nName: ${Lp(n)}\nError:`,r)}}function Wp(e=[]){return"Request"in $p&&pp(e[0],Request)&&e[0].method?String(e[0].method).toUpperCase():e[1]&&e[1].method?String(e[1].method).toUpperCase():"GET"}function Gp(e=[]){return"string"==typeof e[0]?e[0]:"Request"in $p&&pp(e[0],Request)?e[0].url:String(e[0])}var Yp,Qp,Jp=1e3;function Xp(e,t=!1){return r=>{if(!r||Qp===r||function(e){if("keypress"!==e.type)return!1;try{let t=e.target;if(!t||!t.tagName)return!0;if("INPUT"===t.tagName||"TEXTAREA"===t.tagName||t.isContentEditable)return!1}catch{}return!0}(r))return;let n="keypress"===r.type?"input":r.type;void 0===Yp?(e({event:r,name:n,global:t}),Qp=r):function(e,t){if(!e||e.type!==t.type)return!0;try{if(e.target!==t.target)return!0}catch{}return!1}(Qp,r)&&(e({event:r,name:n,global:t}),Qp=r),clearTimeout(Yp),Yp=$p.setTimeout(()=>{Yp=void 0},Jp)}}var Zp=null;var ev=null;function tv(e,t,r){let n=e.exception=e.exception||{},i=n.values=n.values||[],o=i[0]=i[0]||{};o.value||(o.value=t||""),o.type||(o.type=r||"Error")}function rv(e,t){let r=function(e){return e.exception&&e.exception.values?e.exception.values[0]:void 0}(e);if(!r)return;let n=r.mechanism;if(r.mechanism={type:"generic",handled:!0,...n,...t},t&&"data"in t){let e={...n&&n.data,...t.data};r.mechanism.data=e}}function nv(t,r=1/0,n=1/0){try{return function t(r,n,i=1/0,o=1/0,s=function(){let e="function"==typeof WeakSet,t=e?new WeakSet:[];return[function(r){if(e)return!!t.has(r)||(t.add(r),!1);for(let e=0;e<t.length;e++)if(t[e]===r)return!0;return t.push(r),!1},function(r){if(e)t.delete(r);else for(let e=0;e<t.length;e++)if(t[e]===r){t.splice(e,1);break}}]}()){let[a,c]=s;if(null===n||["number","boolean","string"].includes(typeof n)&&!function(e){return"number"==typeof e&&e!=e}(n))return n;let l=function(t,r){try{return"domain"===t&&r&&"object"==typeof r&&r._events?"[Domain]":"domainEmitter"===t?"[DomainEmitter]":typeof e<"u"&&r===e?"[Global]":typeof window<"u"&&r===window?"[Window]":typeof document<"u"&&r===document?"[Document]":function(e){return hp(e)&&"nativeEvent"in e&&"preventDefault"in e&&"stopPropagation"in e}(r)?"[SyntheticEvent]":"number"==typeof r&&r!=r?"[NaN]":void 0===r?"[undefined]":"function"==typeof r?`[Function: ${Lp(r)}]`:"symbol"==typeof r?`[${String(r)}]`:"bigint"==typeof r?`[BigInt: ${String(r)}]`:`[object ${Object.getPrototypeOf(r).constructor.name}]`}catch(i){return`**non-serializable** (${i})`}}(r,n);if(!l.startsWith("[object "))return l;if(n.__sentry_skip_normalization__)return n;if(0===i)return l.replace("object ","");if(a(n))return"[Circular ~]";let u=n;if(u&&"function"==typeof u.toJSON)try{let e=u.toJSON();return t("",e,i-1,o,s)}catch{}let d=Array.isArray(n)?[]:{},h=0,f=Op(n);for(let e in f){if(!Object.prototype.hasOwnProperty.call(f,e))continue;if(h>=o){d[e]="[MaxProperties ~]";break}let r=f[e];d[e]=t(e,r,i-1,o,s),h+=1}return c(n),d}("",t,r,n)}catch(i){return{ERROR:`**non-serializable** (${i})`}}}function iv(e,t=3,r=102400){let n=nv(e,t);return function(e){return function(e){return~-encodeURI(e).split(/%..|./).length}(JSON.stringify(e))}(n)>r?iv(e,t-1,r):n}function ov(e){if(!e)return{};let t=e.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);if(!t)return{};let r=t[6]||"",n=t[8]||"";return{host:t[4],path:t[5],protocol:t[2],relative:t[5]+r+n}}var sv=["fatal","error","warning","log","info","debug"];function av(e){return"warn"===e?"warning":sv.includes(e)?e:"log"}var cv=gp,lv=0;function uv(){return lv>0}function dv(){lv+=1,setTimeout(()=>{lv-=1})}function hv(e,t={},r){if("function"!=typeof e)return e;try{let t=e.__sentry_wrapped__;if(t)return t;if(xp(e))return e}catch{return e}let n=function(){let n=Array.prototype.slice.call(arguments);try{r&&"function"==typeof r&&r.apply(this,arguments);let i=n.map(e=>hv(e,t));return e.apply(this,i)}catch(i){throw dv(),Zf(e=>{e.addEventProcessor(e=>(t.mechanism&&(tv(e,void 0,void 0),rv(e,t.mechanism)),e.extra={...e.extra,arguments:n},e)),Xf(i)}),i}};try{for(let t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t])}catch{}Mp(n,e),Cp(e,"__sentry_wrapped__",n);try{Object.getOwnPropertyDescriptor(n,"name").configurable&&Object.defineProperty(n,"name",{get:()=>e.name})}catch{}return n}function fv(e,t){let r=vv(e,t),n={type:t&&t.name,value:mv(t)};return r.length&&(n.stacktrace={frames:r}),void 0===n.type&&""===n.value&&(n.value="Unrecoverable error caught"),n}function pv(e,t){return{exception:{values:[fv(e,t)]}}}function vv(e,t){let r=t.stacktrace||t.stack||"",n=function(e){if(e){if("number"==typeof e.framesToPop)return e.framesToPop;if(gv.test(e.message))return 1}return 0}(t);try{return e(r,n)}catch{}return[]}var gv=/Minified React error #\d+;/i;function mv(e){let t=e&&e.message;return t?t.error&&"string"==typeof t.error.message?t.error.message:t:"No error message"}function yv(e,t,r,n,i){let o;if(lp(t)&&t.error)return pv(e,t.error);if(up(t)||function(e){return cp(e,"DOMException")}(t)){let i=t;if("stack"in t)o=pv(e,t);else{let t=i.name||(up(i)?"DOMError":"DOMException"),s=i.message?`${t}: ${i.message}`:t;tv(o=bv(e,s,r,n),s)}return"code"in i&&(o.tags={...o.tags,"DOMException.code":`${i.code}`}),o}return ap(t)?pv(e,t):hp(t)||fp(t)?(rv(o=function(e,t,r,n){let i=Gf().getClient(),o=i&&i.getOptions().normalizeDepth,s={exception:{values:[{type:fp(t)?t.constructor.name:n?"UnhandledRejection":"Error",value:`Non-Error ${n?"promise rejection":"exception"} captured with keys: ${Dp(t)}`}]},extra:{__serialized__:iv(t,o)}};if(r){let t=vv(e,r);t.length&&(s.exception.values[0].stacktrace={frames:t})}return s}(e,t,r,i),{synthetic:!0}),o):(tv(o=bv(e,t,r,n),`${t}`,void 0),rv(o,{synthetic:!0}),o)}function bv(e,t,r,n){let i={message:t};if(n&&r){let n=vv(e,r);n.length&&(i.exception={values:[{value:t,stacktrace:{frames:n}}]})}return i}var _v=class{static __initStatic(){this.id="Breadcrumbs"}__init(){this.name=_v.id}constructor(e){_v.prototype.__init.call(this),this.options={console:!0,dom:!0,fetch:!0,history:!0,sentry:!0,xhr:!0,...e}}setupOnce(){this.options.console&&zp("console",wv),this.options.dom&&zp("dom",function(e){return function(t){let r,n="object"==typeof e?e.serializeAttribute:void 0;"string"==typeof n&&(n=[n]);try{r=t.event.target?bp(t.event.target,n):bp(t.event,n)}catch{r="<unknown>"}0!==r.length&&Gf().addBreadcrumb({category:`ui.${t.name}`,message:r},{event:t.event,name:t.name,global:t.global})}}(this.options.dom)),this.options.xhr&&zp("xhr",Sv),this.options.fetch&&zp("fetch",Ev),this.options.history&&zp("history",kv)}};function wv(e){for(let r=0;r<e.args.length;r++)if("ref=Ref<"===e.args[r]){e.args[r+1]="viewRef";break}let t={category:"console",data:{arguments:e.args,logger:"console"},level:av(e.level),message:Ip(e.args," ")};if("assert"===e.level){if(!1!==e.args[0])return;t.message=`Assertion failed: ${Ip(e.args.slice(1)," ")||"console.assert"}`,t.data.arguments=e.args.slice(1)}Gf().addBreadcrumb(t,{input:e.args,level:e.level})}function Sv(e){if(e.endTimestamp){if(e.xhr.__sentry_own_request__)return;let{method:t,url:r,status_code:n,body:i}=e.xhr.__sentry_xhr__||{};Gf().addBreadcrumb({category:"xhr",data:{method:t,url:r,status_code:n},type:"http"},{xhr:e.xhr,input:i})}else;}function Ev(e){!e.endTimestamp||e.fetchData.url.match(/sentry_key/)&&"POST"===e.fetchData.method||(e.error?Gf().addBreadcrumb({category:"fetch",data:e.fetchData,level:"error",type:"http"},{data:e.error,input:e.args}):Gf().addBreadcrumb({category:"fetch",data:{...e.fetchData,status_code:e.response.status},type:"http"},{input:e.args,response:e.response}))}function kv(e){let t=e.from,r=e.to,n=ov(cv.location.href),i=ov(t),o=ov(r);i.path||(i=n),n.protocol===o.protocol&&n.host===o.host&&(r=o.relative),n.protocol===i.protocol&&n.host===i.host&&(t=i.relative),Gf().addBreadcrumb({category:"navigation",data:{from:t,to:r}})}_v.__initStatic();var Tv={};h(Tv,{Breadcrumbs:()=>_v,Dedupe:()=>$v,GlobalHandlers:()=>Iv,HttpContext:()=>Fv,LinkedErrors:()=>Uv,TryCatch:()=>Dv});var Iv=class{static __initStatic(){this.id="GlobalHandlers"}__init(){this.name=Iv.id}__init2(){this._installFunc={onerror:Rv,onunhandledrejection:Cv}}constructor(e){Iv.prototype.__init.call(this),Iv.prototype.__init2.call(this),this._options={onerror:!0,onunhandledrejection:!0,...e}}setupOnce(){Error.stackTraceLimit=50;let e=this._options;for(let t in e){let r=this._installFunc[t];r&&e[t]&&(xv(t),r(),this._installFunc[t]=void 0)}}};function Rv(){zp("error",e=>{let[t,r,n]=Av();if(!t.getIntegration(Iv))return;let{msg:i,url:o,line:s,column:a,error:c}=e;if(uv()||c&&c.__sentry_own_request__)return;let l=void 0===c&&dp(i)?function(e,t,r,n){let i=lp(e)?e.message:e,o="Error",s=i.match(/^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i);return s&&(o=s[1],i=s[2]),Mv({exception:{values:[{type:o,value:i}]}},t,r,n)}(i,o,s,a):Mv(yv(r,c||i,void 0,n,!1),o,s,a);l.level="error",Ov(t,c,l,"onerror")})}function Cv(){zp("unhandledrejection",e=>{let[t,r,n]=Av();if(!t.getIntegration(Iv))return;let i=e;try{"reason"in e?i=e.reason:"detail"in e&&"reason"in e.detail&&(i=e.detail.reason)}catch{}if(uv()||i&&i.__sentry_own_request__)return!0;let o=function(e){return null===e||"object"!=typeof e&&"function"!=typeof e}(i)?function(e){return{exception:{values:[{type:"UnhandledRejection",value:`Non-Error promise rejection captured with value: ${String(e)}`}]}}}(i):yv(r,i,void 0,n,!0);o.level="error",Ov(t,i,o,"onunhandledrejection")})}function Mv(e,t,r,n){let i=e.exception=e.exception||{},o=i.values=i.values||[],s=o[0]=o[0]||{},a=s.stacktrace=s.stacktrace||{},c=a.frames=a.frames||[],l=isNaN(parseInt(n,10))?void 0:n,u=isNaN(parseInt(r,10))?void 0:r,d=dp(t)&&t.length>0?t:function(){try{return yp.document.location.href}catch{return""}}();return 0===c.length&&c.push({colno:l,filename:d,function:"?",in_app:!0,lineno:u}),e}function xv(e){(typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__)&&wp.log(`Global Handler attached: ${e}`)}function Ov(e,t,r,n){rv(r,{handled:!1,type:n}),e.captureEvent(r,{originalException:t})}function Av(){let e=Gf(),t=e.getClient(),r=t&&t.getOptions()||{stackParser:()=>[],attachStacktrace:!1};return[e,r.stackParser,r.attachStacktrace]}Iv.__initStatic();var Pv=["EventTarget","Window","Node","ApplicationCache","AudioTrackList","ChannelMergerNode","CryptoOperation","EventSource","FileReader","HTMLUnknownElement","IDBDatabase","IDBRequest","IDBTransaction","KeyOperation","MediaController","MessagePort","ModalWindow","Notification","SVGElementInstance","Screen","TextTrack","TextTrackCue","TextTrackList","WebSocket","WebSocketWorker","Worker","XMLHttpRequest","XMLHttpRequestEventTarget","XMLHttpRequestUpload"],Dv=class{static __initStatic(){this.id="TryCatch"}__init(){this.name=Dv.id}constructor(e){Dv.prototype.__init.call(this),this._options={XMLHttpRequest:!0,eventTarget:!0,requestAnimationFrame:!0,setInterval:!0,setTimeout:!0,...e}}setupOnce(){this._options.setTimeout&&Rp(cv,"setTimeout",jv),this._options.setInterval&&Rp(cv,"setInterval",jv),this._options.requestAnimationFrame&&Rp(cv,"requestAnimationFrame",Lv),this._options.XMLHttpRequest&&"XMLHttpRequest"in cv&&Rp(XMLHttpRequest.prototype,"send",Nv);let e=this._options.eventTarget;e&&(Array.isArray(e)?e:Pv).forEach(Bv)}};function jv(e){return function(...t){let r=t[0];return t[0]=hv(r,{mechanism:{data:{function:Lp(e)},handled:!0,type:"instrument"}}),e.apply(this,t)}}function Lv(e){return function(t){return e.apply(this,[hv(t,{mechanism:{data:{function:"requestAnimationFrame",handler:Lp(e)},handled:!0,type:"instrument"}})])}}function Nv(e){return function(...t){let r=this;return["onload","onerror","onprogress","onreadystatechange"].forEach(e=>{e in r&&"function"==typeof r[e]&&Rp(r,e,(function(t){let r={mechanism:{data:{function:e,handler:Lp(t)},handled:!0,type:"instrument"}},n=xp(t);return n&&(r.mechanism.data.handler=Lp(n)),hv(t,r)}))}),e.apply(this,t)}}function Bv(e){let t=cv,r=t[e]&&t[e].prototype;!r||!r.hasOwnProperty||!r.hasOwnProperty("addEventListener")||(Rp(r,"addEventListener",(function(t){return function(r,n,i){try{"function"==typeof n.handleEvent&&(n.handleEvent=hv(n.handleEvent,{mechanism:{data:{function:"handleEvent",handler:Lp(n),target:e},handled:!0,type:"instrument"}}))}catch{}return t.apply(this,[r,hv(n,{mechanism:{data:{function:"addEventListener",handler:Lp(n),target:e},handled:!0,type:"instrument"}}),i])}})),Rp(r,"removeEventListener",(function(e){return function(t,r,n){let i=r;try{let r=i&&i.__sentry_wrapped__;r&&e.call(this,t,r,n)}catch{}return e.call(this,t,i,n)}})))}Dv.__initStatic();var Uv=class{static __initStatic(){this.id="LinkedErrors"}__init(){this.name=Uv.id}constructor(e={}){Uv.prototype.__init.call(this),this._key=e.key||"cause",this._limit=e.limit||5}setupOnce(){let e=Gf().getClient();!e||qf((t,r)=>{let n=Gf().getIntegration(Uv);return n?function(e,t,r,n,i){if(!(n.exception&&n.exception.values&&i&&pp(i.originalException,Error)))return n;let o=function e(t,r,n,i,o=[]){if(!pp(n[i],Error)||o.length+1>=r)return o;let s=fv(t,n[i]);return e(t,r,n[i],i,[s,...o])}(e,r,i.originalException,t);return n.exception.values=[...o,...n.exception.values],n}(e.getOptions().stackParser,n._key,n._limit,t,r):t})}};Uv.__initStatic();var Fv=class{constructor(){Fv.prototype.__init.call(this)}static __initStatic(){this.id="HttpContext"}__init(){this.name=Fv.id}setupOnce(){qf(e=>{if(Gf().getIntegration(Fv)){if(!cv.navigator&&!cv.location&&!cv.document)return e;let t=e.request&&e.request.url||cv.location&&cv.location.href,{referrer:r}=cv.document||{},{userAgent:n}=cv.navigator||{},i={...t&&{url:t},headers:{...e.request&&e.request.headers,...r&&{Referer:r},...n&&{"User-Agent":n}}};return{...e,request:i}}return e})}};Fv.__initStatic();var $v=class{constructor(){$v.prototype.__init.call(this)}static __initStatic(){this.id="Dedupe"}__init(){this.name=$v.id}setupOnce(e,t){let r=e=>{let r=t().getIntegration($v);if(r){try{if(function(e,t){return!!t&&!(!function(e,t){let r=e.message,n=t.message;return!(!r&&!n||r&&!n||!r&&n||r!==n||!Kv(e,t)||!qv(e,t))}(e,t)&&!function(e,t){let r=Vv(t),n=Vv(e);return!!(r&&n&&r.type===n.type&&r.value===n.value&&Kv(e,t)&&qv(e,t))}(e,t))}(e,r._previousEvent))return(typeof __SENTRY_DEBUG__>"u"||__SENTRY_DEBUG__)&&wp.warn("Event dropped due to being a duplicate of previously captured event."),null}catch{return r._previousEvent=e}return r._previousEvent=e}return e};r.id=this.name,e(r)}};function qv(e,t){let r=zv(e),n=zv(t);if(!r&&!n)return!0;if(r&&!n||!r&&n||(r=r,(n=n).length!==r.length))return!1;for(let i=0;i<n.length;i++){let e=n[i],t=r[i];if(e.filename!==t.filename||e.lineno!==t.lineno||e.colno!==t.colno||e.function!==t.function)return!1}return!0}function Kv(e,t){let r=e.fingerprint,n=t.fingerprint;if(!r&&!n)return!0;if(r&&!n||!r&&n)return!1;r=r,n=n;try{return r.join("")===n.join("")}catch{return!1}}function Vv(e){return e.exception&&e.exception.values&&e.exception.values[0]}function zv(e){let t=e.exception;if(t)try{return t.values[0].stacktrace.frames}catch{return}}$v.__initStatic();var Hv={};cv.Sentry&&cv.Sentry.Integrations&&(Hv=cv.Sentry.Integrations);Zn("icon-back",Jt`${Tn(' < svg xmlns = "http://www.w3.org/2000/svg"
											viewBox = "0 0 20 20"
											fill = "currentColor" > < path d = "M19 9.375H2.51l7.932-7.933-.884-.884-9 9a.625.625 0 000 .884l9 9 .884-.884-7.933-7.933H19v-1.25z" / > < /svg>')}`,Jt`${Tn('<svg xmlns="http:/ / www.w3.org / 2000 / svg " viewBox="
											0 0 20 20 " fill="
											currentColor "><path d="
											M19 9 H3 .914 l7 .293 - 7.293 L9 .793 .293 l - 9 9 a1 1 0 000 1.414 l9 9 1.414 - 1.414 L3 .914 11 H19V9z "/></svg>')}`);var Wv,Gv={sm:"
											text - 12 ",md:"
											text - 14 ",lg:"
											text - 16 "},Yv={always:"
											underline ",hover:"
											hover: underline ",none:"
											no - underline hover: no - underline "},Qv={kind:"
											Document ",definitions:[{kind:"
											OperationDefinition ",operation:"
											query ",name:{kind:"
											Name ",value:"
											ReportForm "},variableDefinitions:[{kind:"
											VariableDefinition ",variable:{kind:"
											Variable ",name:{kind:"
											Name ",value:"
											id "}},type:{kind:"
											NonNullType ",type:{kind:"
											NamedType ",name:{kind:"
											Name ",value:"
											String "}}},defaultValue:void 0,directives:[]}],directives:[],selectionSet:{kind:"
											SelectionSet ",selections:[{kind:"
											Field ",alias:void 0,name:{kind:"
											Name ",value:"
											reportForm "},arguments:[{kind:"
											Argument ",name:{kind:"
											Name ",value:"
											itemId "},value:{kind:"
											Variable ",name:{kind:"
											Name ",value:"
											id "}}},{kind:"
											Argument ",name:{kind:"
											Name ",value:"
											formVersion "},value:{kind:"
											StringValue ",value:"
											2.0 ",block:!1}}],directives:[],selectionSet:{kind:"
											SelectionSet ",selections:[{kind:"
											Field ",alias:void 0,name:{kind:"
											Name ",value:"
											form "},arguments:[],directives:[],selectionSet:void 0}]}}]}}],loc:{start:0,end:97}},Jv=e=>async(t,{outputFormat:r="
											hex "}={})=>{"
											string "==typeof t&&(t=(new globalThis.TextEncoder).encode(t));let n=await globalThis.crypto.subtle.digest(e,t);return"
											hex "===r?(e=>{let t=new DataView(e),r="
											";for(let n=0;n<t.byteLength;n+=4)r+=t.getUint32(n).toString(16).padStart(8,"
											0 ");return r})(n):n},Xv=(Jv("
											SHA - 1 "),Jv("
											SHA - 256 "));Jv("
											SHA - 384 "),Jv("
											SHA - 512 ");function Zv(e){var t=Object.create(null);return fu(e)&&e.forEach((function(e){return t[e.message]=e})),t}Wv||(Wv={});var eg={disable:function(e){var t=e.graphQLErrors,r=e.operation,n=Zv(t);if(n.PersistedQueryNotSupported)return!0;if(n.PersistedQueryNotFound)return!1;var i=r.getContext().response;return!(!i||!i.status||400!==i.status&&500!==i.status)},useGETForHashedQueries:!1};var tg=Object.prototype.hasOwnProperty,rg=new WeakMap,ng=0,ig=function(e){__DEV__?hc(e&&("
											function "==typeof e.sha256||"
											function "==typeof e.generateHash),'Missing/invalid "
											sha256 " or "
											generateHash " function. Please configure one using the "
											createPersistedQueryLink(options)
											" options parameter.'):hc(e&&("
											function "==typeof e.sha256||"
											function "==typeof e.generateHash),22);var t=vu(eg,e),r=t.sha256,n=t.generateHash,i=void 0===n?function(e){return Promise.resolve(r(Fc(e)))}:n,o=t.disable,s=t.useGETForHashedQueries,a=!0,c="
											forLink "+ng++,l=function(e){return new Promise((function(t){return t(i(e))}))};return new Tu((function(e,t){__DEV__?hc(t,"
											PersistedQueryLink cannot be the last link in the chain.
											"):hc(t,23);var r=e.query;return new Xl((function(n){var i,u,d=!1,h=!1,f=function(r,n){var s=r.response,c=r.networkError;if(!d&&(s&&s.errors||c)){d=!0;var l=[],f=s&&s.errors;fu(f)&&l.push.apply(l,f);var v=c&&c.result&&c.result.errors;fu(v)&&l.push.apply(l,v);var g={response:s,networkError:c,operation:e,graphQLErrors:fu(l)?l:void 0};if(a=!o(g),Zv(l).PersistedQueryNotFound||!a)return i&&i.unsubscribe(),e.setContext({http:{includeQuery:!0,includeExtensions:a},fetchOptions:{method:"
											POST "}}),h&&e.setContext({fetchOptions:u}),void(i=t(e).subscribe(p))}n()},p={next:function(e){f({response:e},(function(){return n.next(e)}))},error:function(e){f({networkError:e},(function(){return n.error(e)}))},complete:n.complete.bind(n)};return e.setContext({http:{includeQuery:!a,includeExtensions:a}}),s&&a&&!function(e){return e.query.definitions.some((function(e){return"
											OperationDefinition "===e.kind&&"
											mutation "===e.operation}))}(e)&&(e.setContext((function(e){var t=e.fetchOptions,r=void 0===t?{}:t;return u=r,{fetchOptions:Cn(Cn({},r),{method:"
											GET "})}})),h=!0),a?function(e){if(!e||"
											object "!=typeof e)return l(e);var t=rg.get(e);return t||rg.set(e,t=Object.create(null)),tg.call(t,c)?t[c]:t[c]=l(e)}(r).then((function(r){e.extensions.persistedQuery={version:1,sha256Hash:r},i=t(e).subscribe(p)})).catch(n.error.bind(n)):i=t(e).subscribe(p),function(){i&&i.unsubscribe()}}))}))},og="
											graphql - client ",sg=class extends yr{constructor(){super(...arguments),this.token="
											",this.uri="
											",this.debug=!1,this.persistedQueries=!1}initGraphClient(){let e=new ju({uri:this.uri,headers:{Authorization:`Bearer ${this.token}`}}),t=this.persistedQueries?ig({sha256:Xv}).concat(e):e;this.client=new nf({cache:new Nh,connectToDevTools:this.debug,link:t}),this.debug&&(window.__APOLLO_CLIENT__=this.client),this.dispatchEvent(new Ar({name:og,instance:this.client}))}connectedCallback(){super.connectedCallback(),this.uri&&this.token&&this.initGraphClient()}};v([Sr({type:String})],sg.prototype,"
											token ",2),v([Sr({type:String})],sg.prototype,"
											uri ",2),v([Sr({type:Boolean})],sg.prototype,"
											debug ",2),v([Sr({type:Boolean})],sg.prototype,"
											persistedQueries ",2),sg=v([_r("
											rs - graphql - client ")],sg);var ag=class extends bn{constructor(e){super(e,og)}},cg=". / crisis - line - icon - 7 ZNZMRT7.png ";Zn("
											icon - caret - right ",Jt`${Tn('<svg xmlns="
											http: //www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M7.942 15.442l-.884-.884L11.616 10 7.058 5.442l.884-.884 5 5a.624.624 0 010 .884l-5 5z"/></svg>')}`,Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M8.207 15.707l-1.414-1.414L11.086 10 6.793 5.707l1.414-1.414 5 5a1 1 0 010 1.414l-5 5z"/></svg>')}`),Zn("icon-chat-group",Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_473_26)"><path d="M4.886 13.444A6.886 6.886 0 013.4 12.8l-2.253.562A.617.617 0 01.55 13.2a.625.625 0 01-.165-.593l.564-2.253A6.9 6.9 0 01.2 5.2 6.8 6.8 0 015.338.168a6.918 6.918 0 016.4 1.847c.8.8 1.388 1.788 1.712 2.873a8.538 8.538 0 00-1.3.056A5.585 5.585 0 0010.853 2.9 5.672 5.672 0 005.6 1.389a5.54 5.54 0 00-4.187 4.1 5.653 5.653 0 00.729 4.421.624.624 0 01.08.489l-.374 1.5 1.5-.374a.626.626 0 01.489.082c.346.222.715.405 1.1.546-.05.428-.068.86-.051 1.291zM14.8 19.8a6.8 6.8 0 005.034-5.136 6.888 6.888 0 00-8.245-8.245A6.8 6.8 0 006.45 11.45 6.9 6.9 0 007.2 16.6l-.564 2.252a.625.625 0 00.758.758l2.253-.563a6.824 6.824 0 003.479.953 7.15 7.15 0 001.674-.2zm-5.2-2.026l-1.5.374.374-1.5a.624.624 0 00-.08-.489 5.653 5.653 0 01-.729-4.421 5.541 5.541 0 014.187-4.1A5.64 5.64 0 0118.61 14.4a5.543 5.543 0 01-4.1 4.187 5.644 5.644 0 01-4.42-.729.654.654 0 00-.492-.084z"/></g><defs><clipPath id="clip0_473_26"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')}`,Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_473_47)"><path d="M4.886 13.444A6.891 6.891 0 013.4 12.8l-2.253.562a.626.626 0 01-.758-.758l.56-2.25A6.9 6.9 0 01.2 5.2 6.8 6.8 0 015.339.168a6.911 6.911 0 016.4 1.847 6.836 6.836 0 011.712 2.873 8.181 8.181 0 00-8.335 6.241 8.532 8.532 0 00-.229 2.315zm13.1-5.179a6.916 6.916 0 00-6.4-1.847A6.8 6.8 0 006.45 11.45 6.9 6.9 0 007.2 16.6l-.564 2.252a.625.625 0 00.758.758l2.253-.563a6.825 6.825 0 003.479.953 7.16 7.16 0 001.673-.2 6.8 6.8 0 005.034-5.136 6.92 6.92 0 00-1.846-6.399h-.001z"/></g><defs><clipPath id="clip0_473_47"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')}`),Zn("icon-checkmark",Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M7.5 15.583a.72.72 0 01-.513-.212L1.558 9.942l.884-.884L7.5 14.116 18.058 3.558l.884.884-10.93 10.929a.723.723 0 01-.512.212z"/></svg>')}`,Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M7.5 15.958a1.102 1.102 0 01-.778-.322l-5.429-5.429 1.414-1.414L7.5 13.586 17.793 3.293l1.414 1.414L8.278 15.636a1.101 1.101 0 01-.778.322z"/></svg>')}`),Zn("icon-profile",Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_473_35)"><path d="M10 0a10 10 0 1010 10A10.011 10.011 0 0010 0zM4.866 17.07a3.99 3.99 0 013.991-2.77h2.286a3.99 3.99 0 013.991 2.766 8.685 8.685 0 01-10.268 0v.004zm11.3-.87a5.354 5.354 0 00-5.024-3.146H8.857A5.354 5.354 0 003.833 16.2a8.75 8.75 0 1112.334 0h-.001zM10.059 5a3.229 3.229 0 100 6.458 3.229 3.229 0 000-6.458zm0 5.208a1.98 1.98 0 110-3.959 1.98 1.98 0 010 3.959z"/></g><defs><clipPath id="clip0_473_35"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')}`,Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_473_29)"><path d="M10 0a10 10 0 1010 10A10.011 10.011 0 0010 0zm.059 5a3.229 3.229 0 110 6.458 3.229 3.229 0 010-6.458zM3.85 16.216a5.32 5.32 0 015.007-3.162h2.286a5.323 5.323 0 015.008 3.161 8.73 8.73 0 01-12.3 0l-.001.001z"/></g><defs><clipPath id="clip0_473_29"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')}`);var lg=_t`:host{height:100%;display:grid;grid-template-columns:1fr;grid-template-rows:min-content 1fr}main{display:flex;flex-direction:column;align-items:start;gap:var(--spacer-md);padding:var(--spacer-sm)}footer{display:flex;gap:var(--spacer-sm);justify-content:end;align-items:end;width:100%;flex:1}label{cursor:pointer;display:flex;justify-content:space-between;padding:var(--spacer-lg);border-bottom:1px solid var(--color-tone-5);margin:0 calc(-1 * var(--spacer-sm));font-weight:500}label:first-of-type{border-top:1px solid var(--color-tone-5)}`,ug=class extends yr{constructor(){super(...arguments),this.matrix=new _n(this),this.gqlClient=new ag(this),this.reportFormQuery=new af(this,Qv,{noAutoSubscribe:!0}),this.reportFormStateHistory=[],this.room="",this.event="",this.username="",this.viewState=0}static get styles(){return[ii,lg]}get thingId(){return["MATRIXCHAT",this.room,this.event].join("_")}async connectedCallback(){super.connectedCallback(),this.reportFormQuery.client=await this.gqlClient.getInstance();try{let e=await this.reportFormQuery.executeQuery({variables:{id:this.thingId}}),t=JSON.parse(e.data.reportForm.form);this.rootComponent=t.component,this.reportFormState=t.state,this.viewState=1}catch{this.handleReportLoadingError()}}updateReportFormState(e,t){this.reportFormState&&(this.reportFormState=ma({...this.reportFormState},e,t))}handleReportLoadingError(){this.dispatchEvent(new La({level:Ma.error,message:ka("Unable to load the report form",{desc:"Report: report loading error message"})})),this.closeForm()}handleInternalError(e){Xf(e,{tags:{section:"reporting"}})}computeValue(e){if("boolean"==typeof e||"string"==typeof e)return e;if("ref"===e.$type)return ua(this.reportFormState,e.ref);if("computed"===e.$type&&"eq"===e.function)return this.computeValue(e.args[0])===this.computeValue(e.args[1]);if("computed"===e.$type&&"neq"===e.function)return this.computeValue(e.args[0])!==this.computeValue(e.args[1]);if("computed"===e.$type&&"conditionalSelect"===e.function)for(let t=0;t<e.conditions.length;t++)if(this.computeValue(e.conditions[t]))return e.values[t];return this.handleInternalError(`Unknown computed value ${e}`),null}closeForm(){this.dispatchEvent(new CustomEvent("cancel"))}async sendReport(e,t="site"){try{let r=[e,t].join(":");return await this.matrix.client.reportEvent(this.room,this.event,0,r),!0}catch(r){let e=ka("Unknown error during report sending",{desc:"Report: report sending error message"});return"M_FORBIDDEN"===r.name&&(e=r.message),this.dispatchEvent(new La({level:Ma.error,message:e})),!1}}async executeAction(e){switch(e.actionType){case"setState":{let t=e.args.key,r=this.computeValue(e.args.value);this.reportFormState&&(this.reportFormStateHistory.push({...this.reportFormState}),this.updateReportFormState(t,r));break}case"openTemplatedUrl":{let t=e.args.urlTemplate;for(let r of e.args.placeholders)t=t.replace(`%(${r})s`,this.computeValue(e.args[r]));window.open(t),this.closeForm();break}case"formSubmit":await this.sendReport(this.computeValue(e.args.ruleId),e.args.ruleType)&&(this.reportFormStateHistory=[],this.viewState=2);break;case"flow":{let t=this.computeValue(e.args[0]);"SELF_HARM"===t?this.viewState=3:this.handleInternalError(`Unknown reporting flow "${t}"`);break}default:this.handleInternalError(`Unknown reporting action "${e}"`)}}isConditionMet(e){return Boolean(this.computeValue(e))}renderContent(e){return"PlainText"===e.type?Qt`<span>${e.text}</span>`:"Link"===e.type?(({attributes:e,children:t,fontWeight:r,external:n,size:i,suppressVisitedStyle:o=!1,underline:s="hover",visited:a})=>{let{attrs:c,html:l,ifDefined:u}=rn();return l`
												<
												a
											$ {
												c(e)
											}
											href = "${(null==e?void 0:e.href)||"
											# "}"
											@click = "${null==e?void 0:e.onclick}"
											class = "${`\n        ${(null==e?void 0:e.className)||"
											"} a\n        ${i?Gv[i]:"
											"}\n        ${"
											semibold "===r?"
											font - semibold ":"
											"}\n        ${o?"
											no - visited ":"
											"}\n        ${s?Yv[s]:"
											"}\n        ${a?"
											visited ":"
											"}`}" >
											$ {
												t
											}
											$ {
												n ? l`<icon-external
            fill="${u("sm"!==i?void 0:"")}"
            class="ml-2xs align-text-bottom ${"md"===i?"text-16 leading-4":""}"></icon-external>` : ""
											} < /a >
											`})({attributes:{href:e.linkTo,target:e.newTab?"blank":void 0},children:e.text}):(this.handleInternalError(`
											Unknown content type "${e}"
											`),null)}renderConditionComponent({children:e}){let t=[];for(let r of e)this.isConditionMet(r.condition)&&t.push(r.component);return Qt`
											$ {
												Ga(t, e => this.renderComponent(e))
											}
											`}renderScreenComponent({children:e}){return Qt`
											$ {
												Ga(e, e => this.renderComponent(e))
											}
											`}renderScreenTitleComponent({textContent:e}){return Qt` <
											h3 class = "mx-0 my-2xs" > $ {
												Ga(e, e => this.renderContent(e))
											} < /h3>
											`}renderScreenFooterComponent({children:e}){return Qt`
											$ {
												Ga(e, e => this.renderComponent(e))
											}
											`}renderTextComponent({textContent:e}){return Qt` <
											div class = "max-w-[600px]" > $ {
												Ga(e, e => this.renderContent(e))
											} < /div>
											`}renderButtonBarComponent({options:e,value:t}){let r=this.computeValue(t);return Qt` <
											div class = "flex flex-wrap gap-xs" >
												$ {
													Ga(e, e => vn({
														appearance: "secondary",
														children: e.label,
														selected: r === e,
														attributes: {
															type: "button",
															onclick: () => {
																let r = t.ref;
																this.updateReportFormState(r, e)
															}
														}
													}))
												} <
												/div>
											`}renderButtonComponent({action:e,text:t,disabled:r}){return Qt` < footer >
												$ {
													vn({
														children: Qt`<slot name="cancel">${ka("Cancel",{desc:"Cancel button"})}</slot>`,
														attributes: {
															type: "button",
															className: "min-w-[120px]",
															onclick: this.closeForm
														}
													})
												}
											$ {
												vn({
													appearance: "primary",
													children: this.computeValue(t),
													attributes: {
														type: "button",
														className: "min-w-[120px]",
														disabled: !!this.computeValue(r) || void 0,
														onclick: () => {
															let t = "actionType" === e.$type ? e : this.computeValue(e);
															!t || !this.reportFormState || this.executeAction(t)
														}
													}
												})
											} <
											/footer>`}renderInfoTooltipComponent({textContent:e}){return Qt` <
											div class = "inline-block rounded-[.5rem] bg-tone-6 p-xs text-12 text-tone-2" >
												<
												icon - info > < /icon-info>
											$ {
												Ga(e, e => this.renderContent(e))
											} <
											/div>
											`}renderFooterContentComponent({title:e,text:t,visible:r}){return this.isConditionMet(r)?Qt` <
											div class = "max-w-[600px]" >
												<
												h4 class = "text-16 m-0" > $ {
													this.computeValue(e)
												} < /h4> <
												p class = "text-tone-2 m-0" > $ {
													this.computeValue(t)
												} < /p> <
												/div>
											`:null}renderSelectOneComponent({options:e,value:t}){let r=this.computeValue(t);return Qt` <
											div class = "flex flex-col w-100" >
												$ {
													co(e, e => e.value, e => Qt`
              <label>
                ${e.label}
                <input
                  type="radio"
                  name="${t.ref}"
                  value="${e.value}"
                  ?checked="${r.value===e.value}"
                  @change="${()=>{this.updateReportFormState(`${t.ref}.value`,e.value)}}"
                />
              </label>
            `)
												} <
												/div>
											`}renderComponent(e){if(!e)return null;switch(e.componentType){case"OneOf":return this.renderConditionComponent(e.props);case"Screen":return this.renderScreenComponent(e.props);case"ScreenTitle":return this.renderScreenTitleComponent(e.props);case"ScreenFooter":return this.renderScreenFooterComponent(e.props);case"SelectOne":return this.renderSelectOneComponent(e.props);case"TextBlock":return this.renderTextComponent(e.props);case"Button":return this.renderButtonComponent(e.props);case"ButtonBar":return this.renderButtonBarComponent(e.props);case"InfoTooltip":return this.renderInfoTooltipComponent(e.props);case"FooterContent":return this.renderFooterContentComponent(e.props);default:return this.handleInternalError(`
											Unknown reporting component type "${JSON.stringify(e)}"
											`),null}}renderBody(){switch(this.viewState){case 0:return Qt` <
											rs - skeleton class = "w-[400px]"
											shimmer > < /rs-skeleton> <
												rs - skeleton class = "w-[300px]"
											shimmer > < /rs-skeleton> <
												div class = "flex flex-wrap gap-xs" >
												<
												rs - skeleton
											class = "w-[150px] h-[length:var(--size-button-md-h)] rounded-lg"
											shimmer
												>
												< /rs-skeleton> <
												rs - skeleton
											class = "w-[250px] h-[length:var(--size-button-md-h)] rounded-lg"
											shimmer
												>
												< /rs-skeleton> <
												rs - skeleton
											class = "w-[200px] h-[length:var(--size-button-md-h)] rounded-lg"
											shimmer
												>
												< /rs-skeleton> <
												rs - skeleton
											class = "w-[150px] h-[length:var(--size-button-md-h)] rounded-lg"
											shimmer
												>
												< /rs-skeleton> <
												rs - skeleton
											class = "w-[150px] h-[length:var(--size-button-md-h)] rounded-lg"
											shimmer
												>
												< /rs-skeleton> <
												rs - skeleton
											class = "w-[250px] h-[length:var(--size-button-md-h)] rounded-lg"
											shimmer
												>
												< /rs-skeleton> <
												rs - skeleton
											class = "w-[200px] h-[length:var(--size-button-md-h)] rounded-lg"
											shimmer
												>
												< /rs-skeleton> <
												/div> <
												rs - skeleton class = "w-[300px]"
											shimmer > < /rs-skeleton>
											`;case 1:return this.renderComponent(this.rootComponent);case 2:return function({onContinue:e}){return Qt` <
											div
											class = "flex items-center justify-center h-[2rem] w-[2rem] rounded-full bg-action-secondary text-global-white" >
												<
												icon - checkmark > < /icon-checkmark> <
												/div> <
												h3 class = "m-0 text-18 font-semibold" >
												$ {
													ka("Thanks for your report", {
														desc: "Reporting: reporting success view title"
													})
												} <
												/h3> <
												p class = "m-0 max-w-[600px]" >
												$ {
													ka("Thanks again for your report and for looking out for yourself and your fellow redditors. Your reporting helps make Reddit a better, safer, and more welcoming place for everyone; and it means a lot to us.", {
														desc: "Reporting: reporting success view main text"
													})
												} <
												/p> <
												footer >
												$ {
													vn({
														appearance: "primary",
														children: ka("Done", {
															desc: "Reporting: reporting success Done button label"
														}),
														attributes: {
															type: "button",
															className: "min-w-[120px]",
															onclick: e
														}
													})
												} <
												/footer>
											`}({onContinue:()=>this.closeForm()});case 3:return function({user:e,onConfirm:t,onCancel:r}){return Qt` <
											div class = "" >
												<
												img
											width = "144"
											height = "144"
											src = "${cg}"
											alt = "${ka("
											Crisis Line Icon ",{desc:"
											Reporting: self - harm flow image alt text "})}" /
												>
												<
												/div> <
												h3 class = "m-0 text-18 font-semibold" >
												$ {
													ka(Sa`Would you like Reddit to reach out to u/${e}?`, {
														desc: "Reporting: self-harm flow heading"
													})
												} <
												/h3> <
												p class = "text-14 m-0 max-w-[600px]" >
												$ {
													ka(Qt`Weve partnered with
          <a
            class="text-action-secondary no-underline"
            href="https://www.crisistextline.org/"
            target="_blank"
            rel="noopener noreferrer"
            >Crisis Text Line</a
          >
          to provide redditors with support from trained Crisis Counselors, and will reach out
          (confidentially) to let u/${e} know that there are people who are here for them.`, {
														desc: "Reporting: self-harm flow body"
													})
												} <
												/p> <
												a
											class = "text-16 text-action-secondary no-underline"
											href = "https://www.reddithelp.com/en/categories/rules-reporting/suicide-response/what-do-i-do-if-someone-talks-about-seriously-hurting"
											target = "_blank"
											rel = "noopener noreferrer" >
												$ {
													ka("Other Options", {
														desc: 'Reporting: self-harm flow "Other Options"'
													})
												} <
												icon - caret - right > < /icon-caret-right> <
												/a> <
												footer >
												$ {
													vn({
														children: ka("Cancel", {
															desc: "Cancel button"
														}),
														attributes: {
															type: "button",
															className: "min-w-[120px]",
															onclick: r
														}
													})
												}
											$ {
												vn({
													appearance: "primary",
													children: ka("Yes", {
														desc: 'Reporting: self-harm flow "Yes" action'
													}),
													attributes: {
														type: "button",
														className: "min-w-[120px]",
														onclick: t
													}
												})
											} <
											/footer>
											`}({user:this.username,onConfirm:async()=>{await this.sendReport("COMMITTING_SELF_HARM")&&(this.viewState=4)},onCancel:()=>this.closeForm()});case 4:return function({user:e,onContinue:t}){return Qt` <
											div
											class = "flex items-center justify-center h-[2rem] w-[2rem] rounded-full bg-action-secondary text-global-white" >
												<
												icon - checkmark > < /icon-checkmark> <
												/div> <
												h3 class = "text-18 m-0 font-semibold" >
												$ {
													ka("Thank you for caring about your fellow redditor", {
														desc: "Reporting: self-harm flow success view title"
													})
												} <
												/h3> <
												p class = "text-14 m-0 max-w-[600px]" >
												$ {
													ka(Sa`Weve reached out to u/${e}. By letting us know, youve helped connect them to people who are there to listen and provide support.`, {
														desc: "Reporting: self-harm flow success view main text"
													})
												} <
												/p> <
												h4 class = "text-14 m-0 font-semibold" >
												$ {
													ka("Other things you can do", {
														desc: "Reporting: self-harm flow success additional actions title"
													})
												} <
												/h4> <
												div class = "grid grid-cols-[min-content_1fr] gap-x-sm" >
												<
												icon - chat - group class = "row-span-2 pt-xs"
											size = "lg" > < /icon-chat-group> <
												h5 class = "text-14 m-0 font-semibold" >
												$ {
													ka("Learn how to help someone in crisis", {
														desc: "Reporting: self-harm flow success additional action title"
													})
												} <
												/h5> <
												p class = "text-14 m-0 max-w-[600px]" >
												$ {
													ka("Get advice on what you can say and how to be supportive.", {
														desc: "Reporting: self-harm flow success additional action body"
													})
												} <
												/p> <
												/div> <
												div class = "grid grid-cols-[min-content_1fr] gap-x-sm" >
												<
												icon - profile class = "row-span-2 pt-xs"
											size = "lg" > < /icon-profile> <
												h5 class = "text-14 m-0 font-semibold" >
												$ {
													ka("Get yourself support", {
														desc: "Reporting: self-harm flow success additional action title"
													})
												} <
												/h5> <
												p class = "text-14 m-0 max-w-[600px]" >
												$ {
													ka("If this has brought up difficult emotions, there are people and resources here for you too.", {
														desc: "Reporting: self-harm flow success additional action body"
													})
												} <
												/p> <
												/div> <
												footer >
												$ {
													vn({
														appearance: "primary",
														children: ka("Ok", {
															desc: "Ok button label"
														}),
														attributes: {
															type: "button",
															className: "min-w-[120px]",
															onclick: t
														}
													})
												} <
												/footer>
											`}({user:this.username,onContinue:()=>this.closeForm()})}}render(){return Qt`
											$ {
												ci({
													title: ka("Submit a report", {
														desc: "Report: section title"
													}),
													leadingContent: this.reportFormStateHistory.length > 0 ? vn({
														appearance: "plain",
														size: an.Small,
														attributes: {
															className: "text-tone-2",
															type: "button",
															onclick: () => {
																let e = this.reportFormStateHistory.pop();
																this.reportFormState = e
															}
														},
														leadingIcon: Qt`<icon-back></icon-back>`
													}) : void 0
												})
											} <
											main > $ {
												this.renderBody()
											} < /main>
											`}};v([Sr()],ug.prototype,"room",2),v([Sr()],ug.prototype,"event",2),v([Sr()],ug.prototype,"username",2),v([Er()],ug.prototype,"viewState",2),v([Er()],ug.prototype,"reportFormState",2),ug=v([_r("rs-message-report")],ug);var dg=class extends Ha{constructor(){super(...arguments),this.name=ka("Report",{desc:"Message Actions Menu: Report action tooltip"}),this.icon=Qt` < icon - report > < /icon-report>`}isActionAllowed(){var e;let t=this.getCurrentRoom();if(!this.matrix||!this.event||!t)return!1;let r=this.matrix.getUserId();return(null==(e=this.event.sender)?void 0:e.userId)!==r}renderOverlay(){var e,t;let r,n;if(!this.event||!(n=this.event.getId())||!(r=this.event.getRoomId()))return null;let i=this.event.getSender(),o=i&&(null==(t=null==(e=this.getCurrentRoom())?void 0:e.getMember(i))?void 0:t.name);return Qt`<rs-message-report
											event = "${n}"
											room = "${r}"
											username = "${o||"
											"}"
											@cancel = $ {
													this.hideOverlay
												} >
												< /rs-message-report>`}};dg=v([_r("rs-timeline-event-report-action")],dg);Zn("icon-emoji",Jt`${Tn('<svg xmlns="http:/ / www.w3.org / 2000 / svg " viewBox="
											0 0 20 20 " fill="
											currentColor "><g clip-path="
											url(#clip0_473_125)
											"><path d="
											M10 20 a10 10 0 1110 - 10 10.011 10.011 0 01 - 10 10 zm0 - 18.75 A8 .75 8.75 0 1018.75 10 8.76 8.76 0 0010 1.25 zm3 .511 12.109 l - 1.022 - .718 A3 .046 3.046 0 0110 13.829 a3 .045 3.045 0 01 - 2.489 - 1.188 l - 1.022 .718 A4 .252 4.252 0 0010 15.079 a4 .252 4.252 0 003.511 - 1.72 zM6 7.5 a1 .5 1.5 0 100 3 1.5 1.5 0 000 - 3 zm8 0 a1 .5 1.5 0 100 3 1.5 1.5 0 000 - 3 z "/></g><defs><clipPath id="
											clip0_473_125 "><path d="
											M0 0 h20v20H0z "/></clipPath></defs></svg>')}`,Jt`${Tn('<svg xmlns="
											http: //www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_473_146)"><path d="M10 0a10 10 0 1010 10A10.011 10.011 0 0010 0zM4.5 9a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0zm5.5 6.454a4.63 4.63 0 01-3.818-1.878l1.635-1.151A2.669 2.669 0 0010 13.454a2.666 2.666 0 002.182-1.029l1.636 1.15A4.626 4.626 0 0110 15.454zm4-4.954a1.5 1.5 0 110-3 1.5 1.5 0 010 3z"/></g><defs><clipPath id="clip0_473_146"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')}`);var hg=class extends Ha{constructor(){super(...arguments),this.name=ka("Reactions",{desc:"Message Actions Menu: Reaction picker tooltip"}),this.icon=Qt`<icon-emoji></icon-emoji>`}isActionAllowed(){return!0}renderOverlay(){return null}};hg=v([_r("rs-timeline-event-reaction-picker-action")],hg);Zn("icon-load",Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M4.444 10.625H0v-1.25h4.444v1.25zM20 9.375h-4.444v1.25H20v-1.25zM10.625 0h-1.25v4.444h1.25V0zm0 15.556h-1.25V20h1.25v-4.444zM5.5 13.319l-.625-1.083-3.848 2.223.625 1.082L5.5 13.319zm13.473-7.778l-.625-1.082L14.5 6.681l.625 1.083 3.848-2.223zm-11.21-.665L5.541 1.027l-1.082.625L6.681 5.5l1.082-.624zm7.778 13.472L13.318 14.5l-1.082.625 2.223 3.849 1.082-.626zm3.432-3.889l-3.849-2.223-.624 1.083 3.849 2.222.624-1.082zM5.5 6.681L1.652 4.459l-.625 1.082 3.849 2.223.624-1.083zm2.263 8.443L6.682 14.5l-2.223 3.848 1.082.625 2.222-3.849zm7.778-13.472l-1.082-.625-2.223 3.849 1.082.625 2.223-3.849z"/></svg>')}`),Zn("icon-add",Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M19 9.375h-8.375V1h-1.25v8.375H1v1.25h8.375V19h1.25v-8.375H19v-1.25z"/></svg>')}`,Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M19 9h-8V1H9v8H1v2h8v8h2v-8h8V9z"/></svg>')}`);var fg={kind:"Document",definitions:[{kind:"OperationDefinition",operation:"query",name:{kind:"Name",value:"SearchChatMessageReactionIcons"},variableDefinitions:[{kind:"VariableDefinition",variable:{kind:"Variable",name:{kind:"Name",value:"query"}},type:{kind:"NonNullType",type:{kind:"NamedType",name:{kind:"Name",value:"String"}}},defaultValue:void 0,directives:[]},{kind:"VariableDefinition",variable:{kind:"Variable",name:{kind:"Name",value:"first"}},type:{kind:"NamedType",name:{kind:"Name",value:"Int"}},defaultValue:void 0,directives:[]}],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",alias:void 0,name:{kind:"Name",value:"searchChatMessageReactionIcons"},arguments:[{kind:"Argument",name:{kind:"Name",value:"query"},value:{kind:"Variable",name:{kind:"Name",value:"query"}}},{kind:"Argument",name:{kind:"Name",value:"first"},value:{kind:"Variable",name:{kind:"Name",value:"first"}}}],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",alias:void 0,name:{kind:"Name",value:"edges"},arguments:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",alias:void 0,name:{kind:"Name",value:"node"},arguments:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",alias:void 0,name:{kind:"Name",value:"url"},arguments:[],directives:[],selectionSet:void 0},{kind:"Field",alias:void 0,name:{kind:"Name",value:"key"},arguments:[],directives:[],selectionSet:void 0},{kind:"Field",alias:void 0,name:{kind:"Name",value:"altText"},arguments:[],directives:[],selectionSet:void 0}]}},{kind:"Field",alias:void 0,name:{kind:"Name",value:"cursor"},arguments:[],directives:[],selectionSet:void 0}]}}]}}]}}],loc:{start:0,end:233}};var pg=(()=>{let e=null;return async t=>e||(e=async function(e){var t,r;let n=await e.query({query:fg,variables:{first:100,query:""}});return n.error?{error:n.error}:{data:(null==(r=null==(t=n.data)?void 0:t.searchChatMessageReactionIcons)?void 0:r.edges).map(({node:{url:e,key:t,altText:r}})=>({url:e,key:t,altText:r}))}}(t),e)})();var vg=class{constructor(e){this.host=e,this.gqlClient=new ag(e)}async fetchReactionIcons(){let e=await this.gqlClient.getInstance(),t=await pg(e);t.error||(vg.reactionIconCache=function(e){let t={},r=["upvote","downvote","joy","care","wave","doge"],n=new Set(r),i=[];for(let s of e)n.has(s.altText)?t[s.altText]=s:i.push(s);let o=[];for(let s of r)o.push(t[s]);return{reactions:[...o,...i],featuredReactions:o}}(t.data),this.host.requestUpdate())}getReactionIcons(){if(vg.reactionIconCache)return vg.reactionIconCache.reactions;this.fetchReactionIcons()}getReactionIcon(e){if(vg.reactionIconCache)return vg.reactionIconCache.reactions.find(t=>t.key===e);this.fetchReactionIcons()}getFeaturedReactions(){if(vg.reactionIconCache)return vg.reactionIconCache.featuredReactions;this.fetchReactionIcons()}},gg=vg;gg.reactionIconCache=null;var mg=_t`.scroll{--scrollbar-color-background-default:var(--color-tone-4);--scrollbar-color-background-hover:var(--color-tone-3);--scrollbar-size:var(--rem14)}.scroll::-webkit-scrollbar{width:var(--scrollbar-size)}.scroll::-webkit-scrollbar-track{border:0}.scroll::-webkit-scrollbar-thumb{min-height:50px;border-radius:calc(var(--scrollbar-size) / 2);background-clip:padding-box;border:3px solid rgba(0,0,0,0);background-color:var(--scrollbar-color-background-default)}.scroll::-webkit-scrollbar-thumb:hover{background-color:var(--scrollbar-color-background-hover)}.reaction-list-container{--scrollbar-color-background-default:var(--color-tone-4);--scrollbar-color-background-hover:var(--color-tone-3);--scrollbar-size:var(--rem14)}.reaction-list-container::-webkit-scrollbar{width:var(--scrollbar-size)}.reaction-list-container::-webkit-scrollbar-track{border:0}.reaction-list-container::-webkit-scrollbar-thumb{min-height:50px;border-radius:calc(var(--scrollbar-size) / 2);background-clip:padding-box;border:3px solid rgba(0,0,0,0);background-color:var(--scrollbar-color-background-default)}.reaction-list-container::-webkit-scrollbar-thumb:hover{background-color:var(--scrollbar-color-background-hover)}`,yg=class extends CustomEvent{constructor(e){super("pick-reaction",{detail:e,bubbles:!1,composed:!0})}},bg=class extends yr{constructor(){super(...arguments),this.reactionIcons=new gg(this),this.handleClickReactionButton=e=>{let t=e.currentTarget.dataset.key;this.dispatchEvent(new yg(t))}}static get styles(){return[mg,ii]}renderSpinner(){return Qt`
												<
												div class = "h-full w-full flex items-center justify-center " >
												<
												icon - load size = "lg"
											class = "w-[1.3125rem] h-[1.3125rem] animate-spin" > < /icon-load> <
												/div>
											`}renderIcons(e){return Qt` <
											div
											class = "h-full w-full overflow-auto grid grid-cols-5 gap-[var(--spacer-sm)] reaction-list-container" >
												$ {
													co(e, e => e.key, e => Qt`
              <button
                class="border-none p-0 m-0 w-[var(--size-xl)] h-[var(--size-xl)] transition bg-transparent cursor-pointer hover:scale-125"
                data-key=${e.key}
                @click=${this.handleClickReactionButton}
              >
                <img class="w-full h-full" src="${e.url}" alt="${e.altText}" />
              </button>
            `)
												} <
												/div>
											`}render(){let e=this.reactionIcons.getReactionIcons();return Qt` <
											div
											class = "h-[14.5rem] w-[16rem] pl-[var(--spacer-md)] pr-[var(--spacer-sm)] py-[var(--spacer-sm)] mb-[var(--spacer-2xs)] shadow-sm bg-white dark:bg-[color:var(--color-tone-5)] rounded-[0.5rem] overflow-none" >
												$ {
													e ? this.renderIcons(e) : this.renderSpinner()
												} <
												/div>
											`}};bg=v([_r("rs-reaction-list")],bg);var _g=_t`
											@keyframes revealAndScaleUp {
												0 % {
													opacity: 0;transform: scale(0.5)
												}
												80 % {
													opacity: 1;transform: scale(1.05)
												}
												100 % {
													transform: scale(1)
												}
											}.reaction - picker - animation {
												animation: revealAndScaleUp 200 ms linear
											}
											@keyframes slideIn {
												0 % {
													opacity: 0;transform: translateY(25 px)
												}
												25 % {
													opacity: .125;transform: translateY(0)
												}
												50 % {
													opacity: .5;transform: translateY(-5 px)
												}
												100 % {
													opacity: 1;transform: translateY(0)
												}
											}.reaction - preview - animation: nth - child(1) {
												animation: slideIn 300 ms linear backwards;animation - delay: 100 ms;transition: all .15 s ease - in -out
											}.reaction - preview - animation: nth - child(2) {
												animation: slideIn 300 ms linear backwards;animation - delay: 140 ms;transition: all .15 s ease - in -out
											}.reaction - preview - animation: nth - child(3) {
												animation: slideIn 300 ms linear backwards;animation - delay: 180 ms;transition: all .15 s ease - in -out
											}.reaction - preview - animation: nth - child(4) {
												animation: slideIn 300 ms linear backwards;animation - delay: 220 ms;transition: all .15 s ease - in -out
											}.reaction - preview - animation: nth - child(5) {
												animation: slideIn 300 ms linear backwards;animation - delay: 260 ms;transition: all .15 s ease - in -out
											}.reaction - preview - animation: nth - child(6) {
												animation: slideIn 300 ms linear backwards;animation - delay: 300 ms;transition: all .15 s ease - in -out
											}
											`;var wg=class extends yr{constructor(){super(...arguments),this.matrix=new _n(this),this.reactionIcons=new gg(this),this.reactionListIsShown=!1,this.showReactionList=()=>{this.reactionListIsShown=!0},this.toggleReaction=e=>{var t;let r=null==(t=this.usedReactionEventMap)?void 0:t[e];r?(async function(e,t,r){e.redactEvent(t,r)}(this.matrix.client,this.roomId,r),fi(this,Ri(e))):(async function(e,t,r,n){e.sendEvent(t,Vr.Reaction,{"m.relates_to":{event_id:r,key:n,rel_type:en.Annotation}})}(this.matrix.client,this.roomId,this.eventId,e),fi(this,Ii(e))),this.dispatchEvent(new CustomEvent("dismiss"))},this.handleClickReactionButton=async e=>{let t=e.currentTarget.dataset.key;this.toggleReaction(t)},this.handlePickReactionEvent=async e=>{let t=e.detail;this.toggleReaction(t)}}static get styles(){return[ii,_g]}renderReactions(){let e=this.reactionIcons.getFeaturedReactions();return e?Qt`
											$ {
												co(e, e => e.key, e => Qt`
          <button
            class="border-none bg-transparent p-0 m-0 w-[var(--size-xl)] h-[var(--size-xl)] reaction-preview-animation transition cursor-pointer hover:scale-125"
            data-key=${e.key}
            @click=${this.handleClickReactionButton}
          >
            <img class="w-full h-full" src="${e.url}" alt="${e.altText}" />
          </button>
        `)
											}
											`:Qt` <
											div class = "h-full w-[13.25rem] flex items-center justify-center " >
												<
												icon - load size = "lg"
											class = "w-[1.3125rem] h-[1.3125rem] animate-spin" > < /icon-load> <
												/div>
											`}render(){return this.reactionListIsShown?Qt` < rs - reaction - list
											@pick - reaction = $ {
													this.handlePickReactionEvent
												} >
												< /rs-reaction-list>`:Qt` <
												div
											class = "reaction-picker-animation shadow-sm bg-white dark:bg-[color:var(--color-tone-6)] dark:border-1 dark:border-solid dark:border-[color:var(--color-tone-3)] rounded-[1.375rem] flex gap-[var(--spacer-2xs)] px-[var(--spacer-xs)] py-[0.375rem] mb-[var(--spacer-2xs)] items-center justify-center" >
												$ {
													this.renderReactions()
												} <
												button
											class = "border-none bg-transparent p-0 m-0 w-[var(--size-xl)] h-[var(--size-xl)] cursor-pointer dark:bg-[color:var(--color-tone-2)] bg-[color:var(--color-tone-6)] rounded-[var(--radius-full)] flex items-center justify-center"
											@click = $ {
													this.showReactionList
												} >
												<
												icon - add
											size = "${kn.Small}"
											class = "w-full h-full flex items-center justify-center dark:text-[color:var(--color-tone-6)]" >
												< /icon-add> <
												/button> <
												/div>
											`}};v([Sr({type:String})],wg.prototype,"roomId",2),v([Sr({type:String})],wg.prototype,"eventId",2),v([Sr({type:Object})],wg.prototype,"usedReactionEventMap",2),v([Er()],wg.prototype,"reactionListIsShown",2),wg=v([_r("rs-reaction-picker")],wg);var Sg=_t`: host {
												position: absolute;top: 0;right: var (--spacer - md);transform: translateY(-50 % )
											}.timeline - event - menu - container {
												display: flex;align - items: center;border - radius: 24 px;background - color: var (--color - tone - 7);box - shadow: 0
												var (--size - 2 xs) var (--size - 2 xs) rgba(0, 0, 0, 0.15),
												0 1 px
												var (--size - 2 xs) rgba(0, 0, 0, 0.15);color: var (--color - tone - 1);padding: var (--spacer - 2 xs) var (--spacer - xs)
											}
											`,Eg=class extends(mn(yr)){constructor(){super(...arguments),this.mustBeVisible=!1,this.reactionsOverlayVisible=!1,this.onOutsideClick=()=>{this.reactionsOverlayVisible=!1},this.onPickerClick=e=>{e.stopPropagation()},this.onPickerDismiss=()=>{this.reactionsOverlayVisible=!1},this.toggleReactionsOverlayVisiblity=()=>{this.reactionsOverlayVisible=!this.reactionsOverlayVisible}}static get styles(){return[Sg,ii]}connectedCallback(){super.connectedCallback(),document.addEventListener("click",this.onOutsideClick)}disconnectedCallback(){super.disconnectedCallback(),document.removeEventListener("click",this.onOutsideClick)}render(){var e,t;let r=this.mustBeVisible||this.reactionsOverlayVisible;return Qt` <
											div class = "timeline-event-menu-container ${r?"
											":"
											hidden "}" >
												$ {
													this.reactionsOverlayVisible ? Qt`<div class="absolute top-0 right-0 pb-2 -translate-y-full">
              <rs-reaction-picker
                roomId="${(null==(e=this.event)?void 0:e.getRoomId())||""}"
                eventId="${(null==(t=this.event)?void 0:t.getId())||""}"
                .usedReactionEventMap="${this.usedReactionEventMap}"
                @click=${this.onPickerClick}
                @dismiss=${this.onPickerDismiss}
              ></rs-reaction-picker>
            </div>` : Qt``
												} <
												rs - timeline - event - reaction - picker - action
											@click = $ {
													this.toggleReactionsOverlayVisiblity
												}
												.disableTooltip = $ {
													this.reactionsOverlayVisible
												} >
												< /rs-timeline-event-reaction-picker-action> <
												rs - timeline - event - report - action.event = "${this.event}" > < /rs-timeline-event-report-action> <
												rs - timeline - event - delete - action.event = "${this.event}" > < /rs-timeline-event-delete-action> <
												/div>
											`}};function kg(e,t){return e.getTs()-t.getTs()}v([Sr({type:Object})],Eg.prototype,"event",2),v([Sr({type:Object})],Eg.prototype,"usedReactionEventMap",2),v([Sr({type:Boolean})],Eg.prototype,"mustBeVisible",2),v([Er()],Eg.prototype,"reactionsOverlayVisible",2),Eg=v([_r("rs-timeline-event-menu")],Eg);var Tg=class extends yr{constructor(){super(...arguments),this.pendingReactionActions=new Set,this.matrix=new _n(this),this.reactionIcons=new gg(this),this.sendReaction=async e=>{var t,r;let n=(null==(t=e.getRelation())?void 0:t.event_id)||"",i=(null==(r=e.getRelation())?void 0:r.key)||"",o=e.getRoomId()||"",s=this.matrix.client.sendEvent(o,Vr.Reaction,{"m.relates_to":{event_id:n,key:i,rel_type:en.Annotation}});this.pendingReactionActions.add(i),this.pendingReactionActions=new Set(this.pendingReactionActions),await s,this.pendingReactionActions.delete(i),this.pendingReactionActions=new Set(this.pendingReactionActions),fi(this,Ii(i))},this.redactReaction=async e=>{var t;let r=e.getId();if(!r)return void Xf("Event doesn't have an ID");let n=(null==(t=e.getRelation())?void 0:t.key)||"",i=this.matrix.client.redactEvent(e.getRoomId()||"",r);this.pendingReactionActions.add(n),this.pendingReactionActions=new Set(this.pendingReactionActions),await i,this.pendingReactionActions.delete(n),this.pendingReactionActions=new Set(this.pendingReactionActions),fi(this,Ri(n))},this.handleReactionButtonClick=async e=>{var t,r;let n=e.currentTarget,i=n.dataset.userEventId,o=null==(t=this.reactions)?void 0:t.find(e=>e.getId()===i),s=n.dataset.eventId,a=null==(r=this.reactions)?void 0:r.find(e=>e.getId()===s);o?await this.redactReaction(o):a&&await this.sendReaction(a)}}static get styles(){return[ii]}updated(e){if(e.has("reactions"))if(this.reactions){let e=this.matrix.client.getUserId();this.reactionGroups=function(e,t){var r,n;let i=e.sort(kg),o={};for(let s of i){if(s.isRedacted())continue;let e=(null==(r=s.getRelation())?void 0:r.key)||"",i=o[e]||{key:e,count:0,userEventId:null,eventId:s.getId()};i.count+=1,(null==(n=s.sender)?void 0:n.userId)===t&&(i.userEventId=s.getId()||null),o[e]=i}return Object.values(o)}(this.reactions,e||"")}else this.reactionGroups=void 0}render(){return this.reactionGroups?Qt` <
											div class = "flex flex-wrap gap-[0.375rem] mt-[0.375rem]" >
												$ {
													co(this.reactionGroups, ({
														key: e
													}) => e, ({
														key: e,
														count: t,
														userEventId: r,
														eventId: n
													}) => {
														let i = this.reactionIcons.getReactionIcon(e),
															o = i ? i.url : `https://i.redd.it/${e||""}`,
															s = this.pendingReactionActions.has(e);
														return Qt`
              <button
                class="${"text-tone-1 flex items-center justify-center px-[var(--spacer-xs)] py-[var(--spacer-2xs)] m-0 w-auto h-[1.75rem] rounded-[0.875rem] cursor-pointer"} ${r?"bg-alienblue-100 dark:bg-alienblue-400/30 hover:bg-alienblue-200 hover:dark:bg-alienblue-400/50 border-none":"bg-transparent hover:bg-alienblue-200 hover:dark:bg-alienblue-400/50 border-[1px] border-solid border-puregray-300"} ${s?"opacity-50 cursor-wait":""}"
                data-event-id=${n}
                data-user-event-id=${r||""}
                ?disabled=${s}
                @click=${this.handleReactionButtonClick}
              >
                <img
                  class="w-[1.25rem] h-[1.25rem]"
                  src=${o}
                  alt=${i?i.altText:"Reaction Icon"}
                />
                <span class="block ml-[var(--spacer-2xs)]">${t}</span>
              </button>
            `
													})
												} <
												/div>
											`:Qt`
											`}};v([Sr({type:Object})],Tg.prototype,"event",2),v([Sr({type:Array})],Tg.prototype,"reactions",2),v([Er()],Tg.prototype,"pendingReactionActions",2),v([Er()],Tg.prototype,"reactionGroups",2),Tg=v([_r("rs-timeline-event-reactions")],Tg);var Ig="https://www.reddit.com",Rg="https://www.redditstatic.com/avatars/defaults/v2",Cg=p(R()),Mg=/\s/,xg=(e,t)=>(r,n)=>{if(n>e.length){let t=r[n-e.length-1];if(n===r.length)return 0;if(!t.match(Mg)){if("/"!==t)return 0;{let t=n-e.length-2;if(t>=0&&!r[t].match(Mg))return 0}}}let i=r.slice(n);return""===i||(t.test(i)?i.match(t)[0].length:0)},Og=(e=>(e.All="all",e.Here="here",e))(Og||{}),Ag=new RegExp("^[A-Za-z0-9][A-Za-z0-9_]{0,20}\\b"),Pg=new RegExp("^@all","i"),Dg=new RegExp("^[A-Za-z0-9_-]{0,20}"),jg=new RegExp("^/?(u|r)/","i"),Lg=new RegExp("^/?(u/|@)","i"),Ng={subreddit:{prefix:"r/",config:{validate:xg("r/",Ag),normalize(e){let t=e.url.replace(jg,"");e.url=`
											$ {
												Ig
											}
											/r/$ {
												t
											}
											`}}},profile:{prefix:"u/",config:{validate:xg("u/",Dg),normalize(e){let t=e.url.replace(jg,"");e.url=`
											$ {
												Ig
											}
											/user/$ {
												t
											}
											`}}},mention:{prefix:"@",config:{validate:xg("@",Dg),normalize(e){if(Pg.test(e.text))e.url="";else{let t=e.url.replace(Lg,"");e.url=`
											$ {
												Ig
											}
											/user/$ {
												t
											}
											`}}}}},Bg={subredditFull:{prefix:"/r/",config:Ng.subreddit.config},profileFull:{prefix:"/u/",config:Ng.profile.config}},Ug={...Ng,...Bg},Fg=(0,Cg.default)().tlds(["aaa","aarp","abarth","abb","abbott","abbvie","abc","able","abogado","abudhabi","ac","academy","accenture","accountant","accountants","aco","actor","ad","adac","ads","adult","ae","aeg","aero","aetna","af","afl","africa","ag","agakhan","agency","ai","aig","airbus","airforce","airtel","akdn","al","alfaromeo","alibaba","alipay","allfinanz","allstate","ally","alsace","alstom","am","amazon","americanexpress","americanfamily","amex","amfam","amica","amsterdam","analytics","android","anquan","anz","ao","aol","apartments","app","apple","aq","aquarelle","ar","arab","aramco","archi","army","arpa","art","arte","as","asda","asia","associates","at","athleta","attorney","au","auction","audi","audible","audio","auspost","author","auto","autos","avianca","aw","aws","ax","axa","az","azure","ba","baby","baidu","banamex","bananarepublic","band","bank","bar","barcelona","barclaycard","barclays","barefoot","bargains","baseball","basketball","bauhaus","bayern","bb","bbc","bbt","bbva","bcg","bcn","bd","be","beats","beauty","beer","bentley","berlin","best","bestbuy","bet","bf","bg","bh","bharti","bi","bible","bid","bike","bing","bingo","bio","biz","bj","black","blackfriday","blockbuster","blog","bloomberg","blue","bm","bms","bmw","bn","bnpparibas","bo","boats","boehringer","bofa","bom","bond","boo","book","booking","bosch","bostik","boston","bot","boutique","box","br","bradesco","bridgestone","broadway","broker","brother","brussels","bs","bt","build","builders","business","buy","buzz","bv","bw","by","bz","bzh","ca","cab","cafe","cal","call","calvinklein","cam","camera","camp","canon","capetown","capital","capitalone","car","caravan","cards","care","career","careers","cars","casa","case","cash","casino","cat","catering","catholic","cba","cbn","cbre","cbs","cc","cd","center","ceo","cern","cf","cfa","cfd","cg","ch","chanel","channel","charity","chase","chat","cheap","chintai","christmas","chrome","church","ci","cipriani","circle","cisco","citadel","citi","citic","city","cityeats","ck","cl","claims","cleaning","click","clinic","clinique","clothing","cloud","club","clubmed","cm","cn","co","coach","codes","coffee","college","cologne","com","comcast","commbank","community","company","compare","computer","comsec","condos","construction","consulting","contact","contractors","cooking","cookingchannel","cool","coop","corsica","country","coupon","coupons","courses","cpa","cr","credit","creditcard","creditunion","cricket","crown","crs","cruise","cruises","cu","cuisinella","cv","cw","cx","cy","cymru","cyou","cz","dabur","dad","dance","data","date","dating","datsun","day","dclk","dds","de","deal","dealer","deals","degree","delivery","dell","deloitte","delta","democrat","dental","dentist","desi","design","dev","dhl","diamonds","diet","digital","direct","directory","discount","discover","dish","diy","dj","dk","dm","dnp","do","docs","doctor","dog","domains","dot","download","drive","dtv","dubai","dunlop","dupont","durban","dvag","dvr","dz","earth","eat","ec","eco","edeka","edu","education","ee","eg","email","emerck","energy","engineer","engineering","enterprises","epson","equipment","er","ericsson","erni","es","esq","estate","et","etisalat","eu","eurovision","eus","events","exchange","expert","exposed","express","extraspace","fage","fail","fairwinds","faith","family","fan","fans","farm","farmers","fashion","fast","fedex","feedback","ferrari","ferrero","fi","fiat","fidelity","fido","film","final","finance","financial","fire","firestone","firmdale","fish","fishing","fit","fitness","fj","fk","flickr","flights","flir","florist","flowers","fly","fm","fo","foo","food","foodnetwork","football","ford","forex","forsale","forum","foundation","fox","fr","free","fresenius","frl","frogans","frontdoor","frontier","ftr","fujitsu","fun","fund","furniture","futbol","fyi","ga","gal","gallery","gallo","gallup","game","games","gap","garden","gay","gb","gbiz","gd","gdn","ge","gea","gent","genting","george","gf","gg","ggee","gh","gi","gift","gifts","gives","giving","gl","glass","gle","global","globo","gm","gmail","gmbh","gmo","gmx","gn","godaddy","gold","goldpoint","golf","goo","goodyear","goog","google","gop","got","gov","gp","gq","gr","grainger","graphics","gratis","green","gripe","grocery","group","gs","gt","gu","guardian","gucci","guge","guide","guitars","guru","gw","gy","hair","hamburg","hangout","haus","hbo","hdfc","hdfcbank","health","healthcare","help","helsinki","here","hermes","hgtv","hiphop","hisamitsu","hitachi","hiv","hk","hkt","hm","hn","hockey","holdings","holiday","homedepot","homegoods","homes","homesense","honda","horse","hospital","host","hosting","hot","hoteles","hotels","hotmail","house","how","hr","hsbc","ht","hu","hughes","hyatt","hyundai","ibm","icbc","ice","icu","id","ie","ieee","ifm","ikano","il","im","imamat","imdb","immo","immobilien","in","inc","industries","infiniti","info","ing","ink","institute","insurance","insure","int","international","intuit","investments","io","ipiranga","iq","ir","irish","is","ismaili","ist","istanbul","it","itau","itv","jaguar","java","jcb","je","jeep","jetzt","jewelry","jio","jll","jm","jmp","jnj","jo","jobs","joburg","jot","joy","jp","jpmorgan","jprs","juegos","juniper","kaufen","kddi","ke","kerryhotels","kerrylogistics","kerryproperties","kfh","kg","kh","ki","kia","kids","kim","kinder","kindle","kitchen","kiwi","km","kn","koeln","komatsu","kosher","kp","kpmg","kpn","kr","krd","kred","kuokgroup","kw","ky","kyoto","kz","la","lacaixa","lamborghini","lamer","lancaster","lancia","land","landrover","lanxess","lasalle","lat","latino","latrobe","law","lawyer","lb","lc","lds","lease","leclerc","lefrak","legal","lego","lexus","lgbt","li","lidl","life","lifeinsurance","lifestyle","lighting","like","lilly","limited","limo","lincoln","linde","link","lipsy","live","living","lk","llc","llp","loan","loans","locker","locus","loft","lol","london","lotte","lotto","love","lpl","lplfinancial","lr","ls","lt","ltd","ltda","lu","lundbeck","luxe","luxury","lv","ly","ma","macys","madrid","maif","maison","makeup","man","management","mango","map","market","marketing","markets","marriott","marshalls","maserati","mattel","mba","mc","mckinsey","md","me","med","media","meet","melbourne","meme","memorial","men","menu","merckmsd","mg","mh","miami","microsoft","mil","mini","mint","mit","mitsubishi","mk","ml","mlb","mls","mm","mma","mn","mo","mobi","mobile","moda","moe","moi","mom","monash","money","monster","mormon","mortgage","moscow","moto","motorcycles","mov","movie","mp","mq","mr","ms","msd","mt","mtn","mtr","mu","museum","music","mutual","mv","mw","mx","my","mz","na","nab","nagoya","name","natura","navy","nba","nc","ne","nec","net","netbank","netflix","network","neustar","new","news","next","nextdirect","nexus","nf","nfl","ng","ngo","nhk","ni","nico","nike","nikon","ninja","nissan","nissay","nl","no","nokia","northwesternmutual","norton","now","nowruz","nowtv","np","nr","nra","nrw","ntt","nu","nyc","nz","obi","observer","office","okinawa","olayan","olayangroup","oldnavy","ollo","om","omega","one","ong","onl","online","ooo","open","oracle","orange","org","organic","origins","osaka","otsuka","ott","ovh","pa","page","panasonic","paris","pars","partners","parts","party","passagens","pay","pccw","pe","pet","pf","pfizer","pg","ph","pharmacy","phd","philips","phone","photo","photography","photos","physio","pics","pictet","pictures","pid","pin","ping","pink","pioneer","pizza","pk","pl","place","play","playstation","plumbing","plus","pm","pn","pnc","pohl","poker","politie","porn","post","pr","pramerica","praxi","press","prime","pro","prod","productions","prof","progressive","promo","properties","property","protection","pru","prudential","ps","pt","pub","pw","pwc","py","qa","qpon","quebec","quest","racing","radio","re","read","realestate","realtor","realty","recipes","red","redstone","redumbrella","rehab","reise","reisen","reit","reliance","ren","rent","rentals","repair","report","republican","rest","restaurant","review","reviews","rexroth","rich","richardli","ricoh","ril","rio","rip","ro","rocher","rocks","rodeo","rogers","room","rs","rsvp","ru","rugby","ruhr","run","rw","rwe","ryukyu","sa","saarland","safe","safety","sakura","sale","salon","samsclub","samsung","sandvik","sandvikcoromant","sanofi","sap","sarl","sas","save","saxo","sb","sbi","sbs","sc","sca","scb","schaeffler","schmidt","scholarships","school","schule","schwarz","science","scot","sd","se","search","seat","secure","security","seek","select","sener","services","ses","seven","sew","sex","sexy","sfr","sg","sh","shangrila","sharp","shaw","shell","shia","shiksha","shoes","shop","shopping","shouji","show","showtime","si","silk","sina","singles","site","sj","sk","ski","skin","sky","skype","sl","sling","sm","smart","smile","sn","sncf","so","soccer","social","softbank","software","sohu","solar","solutions","song","sony","soy","spa","space","sport","spot","sr","srl","ss","st","stada","staples","star","statebank","statefarm","stc","stcgroup","stockholm","storage","store","stream","studio","study","style","su","sucks","supplies","supply","support","surf","surgery","suzuki","sv","swatch","swiss","sx","sy","sydney","systems","sz","tab","taipei","talk","taobao","target","tatamotors","tatar","tattoo","tax","taxi","tc","tci","td","tdk","team","tech","technology","tel","temasek","tennis","teva","tf","tg","th","thd","theater","theatre","tiaa","tickets","tienda","tiffany","tips","tires","tirol","tj","tjmaxx","tjx","tk","tkmaxx","tl","tm","tmall","tn","to","today","tokyo","tools","top","toray","toshiba","total","tours","town","toyota","toys","tr","trade","trading","training","travel","travelchannel","travelers","travelersinsurance","trust","trv","tt","tube","tui","tunes","tushu","tv","tvs","tw","tz","ua","ubank","ubs","ug","uk","unicom","university","uno","uol","ups","us","uy","uz","va","vacations","vana","vanguard","vc","ve","vegas","ventures","verisign","vermgensberater","vermgensberatung","versicherung","vet","vg","vi","viajes","video","vig","viking","villas","vin","vip","virgin","visa","vision","viva","vivo","vlaanderen","vn","vodka","volkswagen","volvo","vote","voting","voto","voyage","vu","vuelos","wales","walmart","walter","wang","wanggou","watch","watches","weather","weatherchannel","webcam","weber","website","wed","wedding","weibo","weir","wf","whoswho","wien","wiki","williamhill","win","windows","wine","winners","wme","wolterskluwer","woodside","work","works","world","wow","ws","wtc","wtf","xbox","xerox","xfinity","xihuan","xin","xxx","xyz","yachts","yahoo","yamaxun","yandex","ye","yodobashi","yoga","yokohama","you","youtube","yt","yun","za","zappos","zara","zero","zip","zm","zone","zuerich","zw","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]).set({fuzzyIP:!0}).add(Ug.subreddit.prefix,Ug.subreddit.config).add(Ug.subredditFull.prefix,Ug.subreddit.config).add(Ug.profile.prefix,Ug.profile.config).add(Ug.profileFull.prefix,Ug.profile.config).add(Ug.mention.prefix,Ug.mention.config),$g=e=>(Fg.match(e)||[]).filter(e=>!(e=>Object.values(Og).includes(e.substring(1)))(e.text));var qg={kind:"Document",definitions:[{kind:"OperationDefinition",operation:"query",name:{kind:"Name",value:"RedditorsAvatars"},variableDefinitions:[{kind:"VariableDefinition",variable:{kind:"Variable",name:{kind:"Name",value:"ids"}},type:{kind:"NonNullType",type:{kind:"ListType",type:{kind:"NonNullType",type:{kind:"NamedType",name:{kind:"Name",value:"ID"}}}}},defaultValue:void 0,directives:[]}],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",alias:void 0,name:{kind:"Name",value:"redditorsInfoByIds"},arguments:[{kind:"Argument",name:{kind:"Name",value:"ids"},value:{kind:"Variable",name:{kind:"Name",value:"ids"}}}],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",alias:void 0,name:{kind:"Name",value:"id"},arguments:[],directives:[],selectionSet:void 0},{kind:"InlineFragment",typeCondition:{kind:"NamedType",name:{kind:"Name",value:"Redditor"}},directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",alias:void 0,name:{kind:"Name",value:"icon"},arguments:[{kind:"Argument",name:{kind:"Name",value:"maxWidth"},value:{kind:"IntValue",value:"64"}}],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",alias:void 0,name:{kind:"Name",value:"url"},arguments:[],directives:[],selectionSet:void 0}]}},{kind:"Field",alias:void 0,name:{kind:"Name",value:"snoovatarIcon"},arguments:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",alias:void 0,name:{kind:"Name",value:"url"},arguments:[],directives:[],selectionSet:void 0}]}},{kind:"Field",alias:void 0,name:{kind:"Name",value:"profile"},arguments:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",alias:void 0,name:{kind:"Name",value:"isNsfw"},arguments:[],directives:[],selectionSet:void 0}]}},{kind:"Field",alias:void 0,name:{kind:"Name",value:"isBlocked"},arguments:[],directives:[],selectionSet:void 0}]}}]}}]}}],loc:{start:0,end:259}};function Kg(e){return e.startsWith("@t2_")}var Vg=new Map,zg=class{constructor(e){this.host=e,this.gqlClient=new ag(e)}async fetchRedditAvatar(e){let[t]=e.replace("@","").split(":"),r=await this.gqlClient.getInstance(),n=await Hg(r,t);Vg.set(e,n),this.host.requestUpdate()}getAvatar(e){if(Vg.has(e))return Vg.get(e);if(!Kg(e)){let t=Wg(e);return Vg.set(e,t),t}this.fetchRedditAvatar(e)}},Hg=(()=>{let e=new Map,t=null,r=Promise.resolve();return async(n,i)=>(e.has(i)||(e.set(i,new yn),t&&clearTimeout(t),t=setTimeout(async()=>{t=null,r=Promise.resolve(r).finally(()=>(async function(t){var r,n;0!==e.size&&(null==(n=null==(r=(await t.query({query:qg,variables:{ids:Array.from(e.keys())}})).data)?void 0:r.redditorsInfoByIds)||n.forEach(t=>{var r,n;let i,o=t&&e.get(t.id);o&&(i="profile"in t&&(null==(r=t.profile)?void 0:r.isNsfw)?{src:"",isSnoovatar:!1,isNSFW:!0,isBlocked:!1}:"icon"in t&&t.icon?{src:t.icon.url,isSnoovatar:Boolean("snoovatarIcon"in t&&t.snoovatarIcon)}:Wg(t.id),o.resolve({...i,isNSFW:Boolean("profile"in t&&(null==(n=t.profile)?void 0:n.isNsfw)),isBlocked:Boolean("isBlocked"in t&&t.isBlocked)}),e.delete(t.id))}))})(n))},25)),e.get(i).promise)})();function Wg(e){return{src:`
											$ {
												Rg
											}
											/avatar_default_${Gg(e)}.png`,isSnoovatar:!1,isNSFW:!1,isBlocked:!1}}function Gg(e){let t=0;for(let r of e)t+=r.charCodeAt(0);return t%8}var Yg=class extends CustomEvent{constructor(e){super("send-message",{detail:e,bubbles:!0,composed:!0})}},Qg=class extends CustomEvent{constructor(e){super("send-emoji",{detail:e,bubbles:!1,composed:!1})}},Jg=class extends CustomEvent{constructor(e){super("send-gif",{detail:e,bubbles:!1,composed:!1})}},Xg=class extends CustomEvent{constructor(e){super("show-dropdown",{detail:e,bubbles:!1,composed:!1})}},Zg=class extends CustomEvent{constructor(){super("hide-dropdown",{bubbles:!1,composed:!1})}};function em(e){return Qt`<span class="user">${e}</span > `}function tm(e){return Qt`
											'${e}'
											`}function rm(e,t,r=t.getSender()){var n;let i=t.getRoomId(),o=ka("Someone",{desc:"Unknown user name"});if(!i)return o;let s=r?null==(n=e.getRoom(i))?void 0:n.getMember(r):null;return(null==s?void 0:s.rawDisplayName)||r||o}function nm(e,t){var r;return(null==(r=t.sender)?void 0:r.name)||rm(e,t)}function im(e,t){let r=t.getSender();return e.getUserId()===r}function om(e,t){switch(t.getType()){case Vr.RoomCreate:return function(e,t){let{is_direct:r}=t.getUnsigned(),{creator:n}=t.getContent(),i=rm(e,t,n);return r?im(e,t)?ka(Sa`
											You created the chat`,{desc:"system message: room create"}):ka(Qt`
											$ {
												em(i)
											}
											created the chat`,{desc:"system message: room create"}):null}(e,t);case Vr.RoomName:return function(e,t){let{name:r}=t.getContent();return t.getPrevContent().name?im(e,t)?ka(Qt`
											You renamed the group chat to $ {
												tm(r)
											}
											`,{desc:"system message: room rename"}):ka(Qt`
											$ {
												em(nm(e, t))
											}
											renamed the group chat to
											$ {
												tm(r)
											}
											`,{desc:"system message: room rename"}):im(e,t)?ka(Qt`
											You created the $ {
												tm(r)
											}
											group chat`,{desc:"system message: room create"}):ka(Qt`
											$ {
												em(nm(e, t))
											}
											created the
											$ {
												tm(r)
											}
											group chat`,{desc:"system message: room create"})}(e,t);case Vr.RoomMember:return function(e,t){var r;let n=nm(e,t),i=t.getContent(),o=i.displayname||(null==(r=t.target)?void 0:r.name)||rm(e,t,t.getStateKey()),s=t.getPrevContent();switch(i.membership){case"invite":return im(e,t)?ka(Qt`
											You invited $ {
												em(o)
											}
											`,{desc:"status message: invitation"}):function(e,t){let r=t.getStateKey();return e.getUserId()===r}(e,t)?ka(Qt`
											$ {
												em(n)
											}
											invited you`,{desc:"status message: invitation"}):ka(Qt`
											$ {
												em(n)
											}
											invited $ {
												em(o)
											}
											`,{desc:"status message: invitation"});case"join":{if(s&&"join"===s.membership)return null;let r=e.getRoom(t.getRoomId()||"");if((null==r?void 0:r.getCreator())===t.getSender())return null;if(im(e,t)){let{is_direct:e}=t.getPrevContent();return ka(e?Sa`
											You joined the chat`:r?Qt`
											You joined the $ {
												tm(r.name)
											}
											group chat`:Sa`
											You joined the group chat`,{desc:"status message: user joined"})}return ka(Qt`
											$ {
												em(o)
											}
											joined the chat`,{desc:"status message: user joined"})}case"leave":return t.getSender()===t.getStateKey()?"invite"===s.membership?null:ka(Qt`
											$ {
												em(o)
											}
											left the chat`,{desc:"status message: user left the room"}):"join"===s.membership?ka(Qt`
											$ {
												em(n)
											}
											removed $ {
												em(o)
											}
											`,{desc:"status message: user removal"}):null}return null}(e,t);default:return null}}var sm={"3xs":"w-[1rem] h-[1rem]","2xs":"w-[1.25rem] h-[1.25rem]",xs:"w-[1.5rem] h-[1.5rem]",sm:"w-[2rem] h-[2rem]",md:"w-[2.5rem] h-[2.5rem]",lg:"w-[3rem] h-[3rem]",xl:"w-[2.87rem] h-[2.87rem]","2xl":"w-[3.25rem] h-[3.25rem]","3xl":"w-[4.5rem] h-[4.5rem]"},am={"3xs":"border","2xs":"border",xs:"border",sm:"border",md:"border-md",lg:"border-md",xl:"border-md","2xl":"border-lg","3xl":"border-lg"},cm={"3xs":"w-[1rem] h-[1rem]","2xs":"w-[1.25rem] h-[1.25rem]",xs:"w-[1.5rem] h-[1.5rem]",sm:"w-[2rem] h-[2rem]",md:"w-[2.5rem] h-[2.5rem]",lg:"w-[3rem] h-[3rem]",xl:"w-[3.5rem] h-[3.5rem]","2xl":"w-[4rem] h-[4rem]","3xl":"w-[5.5rem] h-[5.5rem]"},lm={"3xs":"-right-[0.0625rem]","2xs":"-right-[0.0625rem]",xs:"-right-[0.0625rem]",sm:"-right-[0.0825rem]",md:"-right-[0.0825rem]",lg:"-right-[0.125rem]",xl:"-right-[0.125rem]","2xl":"-right-[.65rem]","3xl":"-right-[.75rem]"},um={"3xs":"w-[.25rem] h-[.25rem] border","2xs":"w-[.25rem] h-[.25rem] border",xs:"w-[.25rem] h-[.25rem] border",sm:"w-[.375rem] h-[.375rem] border-2",md:"w-[.375rem] h-[.375rem] border-2",lg:"w-[.625rem] h-[.625rem] border-2",xl:"w-[.625rem] h-[.625rem] border-2","2xl":"w-[1rem] h-[1rem] border-2","3xl":"w-[1.25rem] h-[1.25rem] border-2"},dm=({attributes:e,children:t,size:r="sm",snoovatarSrc:n,status:i=null,ringColorClassName:o,avatarBgClassName:s,ringLayer:a,asIcon:c})=>{let{html:l,ifDefined:u}=rn(),d=n?cm:sm;return l`
											$ {
												a && !c ? a : ""
											}
											$ {
												c ? l`
          <span
            id="${u(null==e?void 0:e.id)}"
            slot="${u(null==e?void 0:e.slot)}"
            class="${sm[r]} inline-block rounded-full overflow-hidden"
            >${t}</span
          >
        ` : l`<span
          id="${u(null==e?void 0:e.id)}"
          slot="${u(null==e?void 0:e.slot)}"
          class="${a?"absolute":"relative"} ${o?`${o} border-solid ${am[r]}`:""} inline-flex fp-avatar-container box-border rounded-full ${sm[r]} isolate">
          <span
            style="${s||!n?"":"background: var(--color-avatar-gradient)"}"
            class="rounded-full box-border border-solid ${d[r]} border-neutral-background ${am[r]} relative inline-flex h-100 w-100 justify-center ${s&&s}">
            ${n?(({size:e,snoovatarSrc:t,attributes:r})=>{let{attrs:n,html:i}=rn();return i` < span
												$ {
													n(r)
												}
												class = "absolute z-[2] bottom-0 inline-flex shrink-0 justify-center ${cm[e]}" >
													<
													svg
												width = "100%"
												height = "100%"
												viewBox = "0 0 121 122"
												xmlns = "http://www.w3.org/2000/svg"
												class = "overflow-hidden" >
													<
													defs >
													<
													clipPath id = "mask" >
													<
													path
												d = "M0 0V79L28.1628 105.5C35.013 115.465 46.4934 122 59.5 122C72.5066 122 83.987 115.465 90.8372 105.5L120.5 79V0H0Z" / >
													<
													/clipPath> <
													/defs> <
													image
												href = "${t}"
												alt = "User Avatar"
												clip - path = "url(#mask)"
												height = "100%"
												width = "100%" / >
													<
													/svg> <
													/span>`})({snoovatarSrc:n,size:r,status:i,ringColorClassName:o,avatarBgClassName:s}):l`<span
												class = "rounded-full overflow-hidden border border-solid border-neutral-background inline-flex" >
													$ {
														t
													} < /span >
													`}
          </span>
          ${i?l`<span
                class="${"online"===i?"bg-online":""} flex absolute z-[3] 
        bottom-0 rounded-full border-solid border-neutral-background bg-neutral-background ${lm[r]} ${am[r]} ${um[r]}">
                ${"online"===i?"":i}
              </span>`:""}
        </span>`
											}
											`};function hm(e,t="sm"){if(null!=e&&e.isNSFW)return dm({children:Qt` < div
											class = "flex justify-center items-center bg-black rounded-full w-full h-full" >
												<
												span class = "text-global-white text-[8px]" >
												$ {
													ka("NSFW", {
														desc: "This profile contains NSFW content"
													})
												} <
												/span> <
												/div>`,size:t,asIcon:!0});if(null!=e&&e.isSnoovatar)return dm({snoovatarSrc:e.src,size:t});let r=e?Qt`<img
											class = "w-100 h-100 pointer-events-none"
											src = "${e.src}"
											alt = "${ka("
											User Avatar ",{desc:"
											User Avatar alt text "})}" /
												> `:Qt` < div > < /div>`;return dm({children:r,size:t,asIcon:!0})}var fm=_t`.info-message{font:var(--font-12);text-align:center;color:var(--color-tone-3);padding:var(--spacer-2xs) var(--spacer-md)}.info-message .user{font-weight:500}.room-message{display:grid;grid-template-columns:min-content 1fr;grid-column-gap:var(--spacer-sm);padding:var(--spacer-xs) var(--spacer-sm);font:var(--font-14);position:relative}.room-message.not-sent{color:var(--color-tone-3)}.room-message.not-sent faceplate-date{color:var(--color-tone-3)}.room-message:hover{background-color:var(--color-tone-6)}.room-message-body{display:flex;flex-direction:column;align-items:start}.room-message-text{white-space:pre-wrap}.room-message-text a{text-decoration:none;color:var(--color-a-default)}.room-message-text a:visited{color:var(--color-a-visited)}.room-message-text a:hover{text-decoration:underline}.room-message-text.deleted{color:var(--color-tone-3)}.room-message-image{--max-image-size:256px;max-width:90%;max-height:var(--max-image-size);margin:var(--spacer-xs) var(--spacer-xs) 0 0;object-fit:contain;border-radius:var(--rem12)}.room-message-image.error{border:1px dotted var(--color-neutral-border);min-height:var(--size-xl);max-width:var(--max-image-size)}@media(min-width:768px){.room-message-image{--max-image-size:300px}}.user-avatar{grid-row:1 /
											span 2;
											margin - top: var (--size - xs);
											height: var (--size - xl)
										}.user - avatar img {
											width: 100 % ;height: 100 % ;pointer - events: none
										}.user - name {
											font - weight: bold
										}
										faceplate - date {
											font: var (--font - 12);color: var (--color - tone - 2)
										}.error {
											font: var (--font - 14);margin - top: var (--spacer - md)
										}.error icon - info {
											color: var (--color - alert - negative);height: var (--rem15);width: var (--rem14)
										}.error button {
											background - color: transparent;
											border: 0;
											color: var (--color - alert - negative);
											cursor: pointer;
											font: var (--font - 14);
											padding: 0
										}
										`,pm=class extends yr{constructor(){super(...arguments),this.isImagePreviewVisible=!1,this.hovered=!1,this.eventBodyText=[],this.matrix=new _n(this),this.avatars=new zg(this),this.timeFormatOptions={hour:"numeric",minute:"numeric"},this.handleMouseEnter=()=>{this.hovered=!0},this.handleMouseLeave=()=>{this.hovered=!1},this.handleEventStatusChange=async(e,t)=>{this.requestUpdate(),t===zr.NOT_SENT&&(await this.updateComplete,this.dispatchEvent(new CustomEvent("sendError")))},this.handleEventChange=()=>{this.requestUpdate()}}static get styles(){return[ii,fm]}get senderName(){return this.event?nm(this.matrix.client,this.event):""}connectedCallback(){super.connectedCallback(),this.event&&(this.event.getContent().body&&(this.eventBodyText=function(e){let t=$g(e);if(0===t.length)return Qt`
										$ {
											e
										}
										`;let r=[],n=0;return t.forEach(({index:t,lastIndex:i,text:o,url:s,schema:a})=>{let c="mailto:"===a?"_self":"_blank";r.push(Qt`
										$ {
											e.substring(n, t)
										}
										`),r.push(Qt` < a href = "${s}"
										target = "${c}"
										rel = "noopener noreferrer" > $ {
												o
											} < /a>`),n=i}),r.push(Qt`${e.substring(n,e.length)}`),r}(this.event.getContent().body)),this.event.on(Wr.Status,this.handleEventStatusChange),this.event.on(Wr.Replaced,this.handleEventChange),this.event.on(Wr.BeforeRedaction,this.handleEventChange)),this.addEventListener("mouseenter",this.handleMouseEnter),this.addEventListener("mouseleave",this.handleMouseLeave)}disconnectedCallback(){super.disconnectedCallback(),this.event&&(this.event.off(Wr.Status,this.handleEventStatusChange),this.event.off(Wr.Replaced,this.handleEventChange),this.event.off(Wr.BeforeRedaction,this.handleEventChange)),this.removeEventListener("mouseenter",this.handleMouseEnter),this.removeEventListener("mouseleave",this.handleMouseLeave)}resendEvent(){if(!this.event)return;let e=this.event.getId(),t=this.event.getType(),r=this.event.getContent(),n=this.matrix.client.getRoom(this.event.getRoomId()||"");!e||!n||t!==Vr.RoomMessage||(n.removeEvent(e),r.msgtype===Gr.Text?this.dispatchEvent(new Yg({body:r.body})):r.msgtype===Gr.Image&&di(r)&&this.dispatchEvent(new Yg({attachments:[r.file]})))}renderReactions(){return Qt` <
											rs - timeline - event - reactions.reactions = "${this.reactions}" > < /rs-timeline-event-reactions>
										`}renderAvatar(){if(!this.event)return null;let e=this.event.getSender()||"",t=this.avatars.getAvatar(e);return Kg(e)?Qt` < a
										href = "${`${Ig}/user/${this.senderName}/`}"
										target = "_blank"
										class = "user-avatar" >
											$ {
												hm(t)
											} < /a >
											`:Qt` < div class = "user-avatar" > $ {
												hm(t)
											} < /div>`}renderHeadline(){if(!this.event)return null;let e=this.event.getDate();return Qt`<div> <
											span class = "user-name" > $ {
												this.senderName
											} < /span>${e?Qt`<faceplate-date
										ts = "${e.toISOString()}"
											.formatOptions = "${this.timeFormatOptions}" >
											< /faceplate-date>`:""} <
											/div>`}renderErrorMessage(){return Qt` <
											div class = "error" >
											<
											icon - info > < /icon-info> ${ka("Message failed to send.",{desc:"Room Timeline: Message sent error text"})} <
											button @click = "${this.resendEvent}" >
											$ {
												ka("Retry", {
													desc: "Room Timeline: Message sent error retry button text"
												})
											} <
											/button> <
											/div>
										`}render(){var e;if(!this.event)return null;let t=this.event.getType(),r=this.event.getContent(),n=this.event.status===zr.NOT_SENT;if(t===Vr.RoomMessage&&this.event.isRedacted()){let e=ka("This message was deleted",{desc:"Room Timeline: Deleted message text"});return Qt` <
										div class = "room-message" >
											$ {
												this.renderAvatar()
											}
										$ {
											this.renderHeadline()
										} <
										div class = "room-message-text deleted" > $ {
												e
											} < /div> <
											/div>
										`}if(t===Vr.RoomMessage&&r.msgtype===Gr.Text)return Qt` <
										div
										class = $ {
												Fr({
													"room-message": !0,
													"not-sent": n
												})
											} >
											$ {
												this.renderAvatar()
											}
										$ {
											this.renderHeadline()
										} <
										div class = "room-message-body" >
											<
											div class = "room-message-text" > $ {
												this.eventBodyText
											} < /div>
										$ {
											n ? this.renderErrorMessage() : null
										}
										$ {
											this.renderReactions()
										} <
										/div> <
										rs - timeline - event - menu
											.event = "${this.event}"
											.usedReactionEventMap = $ {
												this.usedReactionEventMap
											}
											.mustBeVisible = $ {
												this.hovered
											} >
											< /rs-timeline-event-menu> <
											/div>
										`;if(t===Vr.RoomMessage&&r.msgtype===Gr.Image){let t;if(!(t=di(r)?URL.createObjectURL(r.file):this.matrix.client.mxcUrlToHttp(r.url)))return null;let i=r.body||ka("Image",{desc:"Image default description"});return Qt` <
										div
										class = $ {
												Fr({
													"room-message": !0,
													"not-sent": n
												})
											} >
											$ {
												this.renderAvatar()
											}
										$ {
											this.renderHeadline()
										} <
										div class = "room-message-body" >
											<
											img
										class = "room-message-image"
										src = "${t}"
										height = "${on(null==(e=r.info)?void 0:e.h)}"
										alt = "${i}"
										onerror = "this.classList.add('error')"
										tabindex = "0"
										@click = "${()=>{this.isImagePreviewVisible=!0}}"
										@keydown = "${e=>{"
										Space "===e.code&&(this.isImagePreviewVisible=!0)}}" /
											>
											$ {
												n ? this.renderErrorMessage() : null
											}
										$ {
											this.renderReactions()
										} <
										/div> <
										rs - timeline - event - menu
											.event = "${this.event}"
											.usedReactionEventMap = $ {
												this.usedReactionEventMap
											}
											.mustBeVisible = $ {
												this.hovered
											} >
											< /rs-timeline-event-menu>
										$ {
											this.isImagePreviewVisible ? Qt`<rs-image-preview
                src="${t}"
                name="${i}"
                @close="${()=>{this.isImagePreviewVisible=!1}}"
              ></rs-image-preview>` : null
										} <
										/div>
										`}let i=om(this.matrix.client,this.event);return i?Qt` < div class = "info-message" > $ {
											i
										} < /div>`:null}};v([Sr({type:Object})],pm.prototype,"event",2),v([Sr({type:Object})],pm.prototype,"usedReactionEventMap",2),v([Sr({type:Array})],pm.prototype,"reactions",2),v([Er()],pm.prototype,"isImagePreviewVisible",2),v([Er()],pm.prototype,"hovered",2),v([Er()],pm.prototype,"eventBodyText",2),pm=v([_r("rs-timeline-event")],pm);var vm=_t`.scroll{--scrollbar-color-background-default:var(--color-tone-4);--scrollbar-color-background-hover:var(--color-tone-3);--scrollbar-size:var(--rem14)}.scroll::-webkit-scrollbar{width:var(--scrollbar-size)}.scroll::-webkit-scrollbar-track{border:0}.scroll::-webkit-scrollbar-thumb{min-height:50px;border-radius:calc(var(--scrollbar-size) /
										2);
								background - clip: padding - box;
								border: 3 px solid rgba(0, 0, 0, 0);
								background - color: var (--scrollbar - color - background -
									default)
							}.scroll::-webkit - scrollbar - thumb: hover {
								background - color: var (--scrollbar - color - background - hover)
							}: host {
								--scrollbar - color - background -
									default: var (--color - tone - 4);
								--scrollbar - color - background - hover: var (--color - tone - 3);
								--scrollbar - size: var (--rem14);
								box - sizing: border - box;
								display: flex;
								flex - direction: column
							}: host::-webkit - scrollbar {
								width: var (--scrollbar - size)
							}: host::-webkit - scrollbar - track {
								border: 0
							}: host::-webkit - scrollbar - thumb {
								min - height: 50 px;
								border - radius: calc(var (--scrollbar - size) / 2);
								background - clip: padding - box;
								border: 3 px solid rgba(0, 0, 0, 0);
								background - color: var (--scrollbar - color - background -
									default)
							}: host::-webkit - scrollbar - thumb: hover {
								background - color: var (--scrollbar - color - background - hover)
							}.date {
								padding: var (--spacer - xs) var (--spacer - md);text - align: center;font: var (--font - 12);color: var (--color - tone - 2)
							}.first - event {
								margin - top: auto
							}
							`,gm=class extends(wa(yr)){constructor(){super(...arguments),this.roomController=new wn(this),this.loadMoreQuery=new _a(this,e=>this.loadMore(e)),this.handleScroll=ba(()=>{this.scrollTop<100&&!this.loadMoreQuery.isLoading&&this.loadMoreQuery.execute(25),this.sendReadReceiptAfterIdleTime()},200),this.handleTimelineUpdate=ba(()=>{this.requestUpdate()},50),this.sendReadReceiptAfterIdleTime=()=>{this.idleTimeout&&clearTimeout(this.idleTimeout),this.idleTimeout=window.setTimeout(()=>{this.sendReadReceipt()},300)}}static get styles(){return[ii,vm]}async initTimeline(){let e=this.roomController.getRoom();this.timelineWindow=new Xr(e.client,e.getUnfilteredTimelineSet()),this.loadMoreQuery.isLoading&&this.loadMoreQuery.cancel(),await this.timelineWindow.load(),await this.loadMoreEventsIfRequired(e.roomId),this.sendReadReceiptAfterIdleTime()}async loadMoreEventsIfRequired(e){var t;this.room===e&&this.scrollHeight==this.clientHeight&&(null==(t=this.timelineWindow)?void 0:t.canPaginate(Kr.Backward))&&(await this.loadMoreQuery.execute(25),await this.loadMoreEventsIfRequired(e))}async loadMore(e){var t;if(null==(t=this.timelineWindow)||!t.canPaginate(Kr.Backward))return;let r=this.room,n=this.scrollHeight-this.scrollTop;await this.timelineWindow.paginate(Kr.Backward,e),r===this.room&&(this.requestUpdate(),await this.updateComplete,this.scrollTop=this.scrollHeight-n)}getLastMessageInView(){if(this.timelineNodes)for(let e=this.timelineNodes.length-1;e>=0;--e)if(this.isEventInView(this.timelineNodes[e]))return this.timelineNodes[e]}isEventInView(e){let t=this.getBoundingClientRect(),r=e.getBoundingClientRect();return!(!t||!r)&&(r.bottom>=t.top&&r.top>=t.top&&r.bottom<=t.bottom&&r.top<=t.bottom)}sendReadReceipt(){var e,t,r,n;let i=this.roomController.getRoom(),o=i.getLiveTimeline().getEvents(),s=o.at(-1),a=null==(t=null==(e=i.getAccountData(Vr.FullyRead))?void 0:e.getContent())?void 0:t.event_id;if(a===(null==s?void 0:s.getId()))return;if(a){let e=null==(r=this.shadowRoot)?void 0:r.querySelector(` [data - id = "${a}"] `);if(!e||!this.isEventInView(e))return}let c=this.getLastMessageInView();if(c&&c.dataset.id!==a){let e=null==(n=o.find(e=>e.getId()===c.dataset.id))?void 0:n.getId();e&&i.client.setRoomReadMarkers(i.roomId,e)}}connectedCallback(){super.connectedCallback(),this.addEventListener("scroll",this.handleScroll,!1),this.roomController.on(Qr.Timeline,this.handleTimelineUpdate),this.roomController.on(Qr.LocalEchoUpdated,this.handleTimelineUpdate)}async updated(e){if(super.updated(e),e.has("room")){if(this.room===e.get("room"))return;await this.initTimeline(),this.resetStickToBottomState()}}getEvents(){var e,t,r;let n=this.roomController.getRoom().getLiveTimeline(),i=n.getEvents(),o=n.getTimelineSet().relations,s=[];for(let a of i){let n=a.getId(),i=n?null==(e=null==o?void 0:o.getChildEventsForEvent(n,en.Annotation,Vr.Reaction))?void 0:e.getRelations():void 0,c={};for(let e of i||[]){if((null==(t=e.sender)?void 0:t.userId)!==this.roomController.getRoom().myUserId)continue;let n=(null==(r=e.getRelation())?void 0:r.key)||"",i=e.getId();i&&(c[n]=i)}s.push({event:a,reactions:i,usedReactionEventMap:c})}return s}render(){if(!this.room)return null;let e=this.getEvents();return Qt` <
							div class = "min-h-[10rem]" > < /div>
							$ {
								co(e, ({
									event: e
								}) => e.getId(), ({
									event: t,
									reactions: r,
									usedReactionEventMap: n
								}, i) => {
									var o;
									let s = 0 === i,
										a = s ? null : null == (o = e[i - 1]) ? void 0 : o.event,
										c = t.getDate(),
										l = Boolean(c && a && !eo(c).isSame(a.getDate(), "day"));
									return Qt`
            ${s||l?Qt`<div class="date ${s?"first-event":""}">
                  ${function(e,t={showTime:!0}){let r=eo(e),n=eo(new Date);return r.isSame(n,"day")?t.showTime?r.format("h:mm A"):ka("Today",{desc:"last message activity: today"}):r.isYesterday()?ka("Yesterday",{desc:"last message activity: yesterday"}):r.get("year")===n.get("year")?r.format("MMM D"):r.format("MMM D, YYYY")}(c,{showTime:!1})}
                </div>`:""}
            <rs-timeline-event
              data-id="${on(t.getId())}"
              .event="${t}"
              .reactions="${r}"
              .usedReactionEventMap="${n}"
              @sendError="${()=>{this.ensureScrollState()}}"
            >
            </rs-timeline-event>
          `
								})
							}
							`}};v([Sr({type:String})],gm.prototype,"room",2),v([function(e){return kr({descriptor:t=>({get(){var t,r;return null!==(r=null===(t=this.renderRoot)||void 0===t?void 0:t.querySelectorAll(e))&&void 0!==r?r:[]},enumerable:!0,configurable:!0})})}("rs-timeline-event")],gm.prototype,"timelineNodes",2),gm=v([_r("rs-timeline")],gm);Zn("icon-camera",Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_630_42)"><path d="M10 14a4 4 0 110-8 4 4 0 010 8zm0-6.75a2.75 2.75 0 100 5.5 2.75 2.75 0 000-5.5zM17.368 18H2.618a2.63 2.63 0 01-2.625-2.625V5.656a2.629 2.629 0 012.625-2.625h2.389l1.216-1.577A1.166 1.166 0 017.146 1h5.739a1.155 1.155 0 01.907.446l1.222 1.585h2.355a2.627 2.627 0 012.624 2.625v9.718A2.63 2.63 0 0117.368 18zM2.618 4.281a1.377 1.377 0 00-1.375 1.375v9.719a1.377 1.377 0 001.375 1.375h14.75a1.377 1.377 0 001.375-1.375V5.657a1.375 1.375 0 00-1.374-1.375h-2.97l-1.6-2.073-5.653.041-1.524 2.031H2.618z"/></g><defs><clipPath id="clip0_630_42"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
							}
							`,Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_630_41)"><path d="M17.376 3.032h-2.355L13.8 1.446A1.155 1.155 0 0012.892 1h-5.74a1.169 1.169 0 00-.923.454L5.014 3.031H2.625A2.629 2.629 0 000 5.656v9.719A2.63 2.63 0 002.625 18h14.75A2.63 2.63 0 0020 15.375V5.657a2.627 2.627 0 00-2.624-2.625zm-7.369 10.96a4 4 0 110-8 4 4 0 010 8z"/></g><defs><clipPath id="clip0_630_41"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
							}
							`),Zn("icon-send",Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M1.482 19.575a1.128 1.128 0 01-1.034-1.563L3.82 10 .448 1.988A1.125 1.125 0 011.988.545l16.9 8.449a1.125 1.125 0 010 2.012l-16.9 8.449a1.13 1.13 0 01-.506.12zm3.51-9.137l-3.261 7.748L18.1 10 1.73 1.814l3.264 7.749a1.13 1.13 0 010 .875h-.001z"/></svg>')
							}
							`,Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M18.885 8.994L1.988.545a1.125 1.125 0 00-1.54 1.443L3.82 10 .448 18.012a1.128 1.128 0 001.034 1.563c.176 0 .349-.041.506-.12l16.9-8.449a1.125 1.125 0 000-2.012h-.003z"/></svg>')
							}
							`);var mm,ym,bm="function"==typeof Map?new Map:(mm=[],ym=[],{has:function(e){return mm.indexOf(e)>-1},get:function(e){return ym[mm.indexOf(e)]},set:function(e,t){-1===mm.indexOf(e)&&(mm.push(e),ym.push(t))},delete:function(e){var t=mm.indexOf(e);t>-1&&(mm.splice(t,1),ym.splice(t,1))}}),_m=function(e){return new Event(e,{bubbles:!0})};try{new Event("test")}catch{_m=function(e){var t=document.createEvent("Event");return t.initEvent(e,!0,!1),t}}function wm(e){var t=bm.get(e);t&&t.destroy()}function Sm(e){var t=bm.get(e);t&&t.update()}var Em=null;typeof window>"u"||"function"!=typeof window.getComputedStyle?((Em=function(e){return e}).destroy=function(e){return e},Em.update=function(e){return e}):((Em=function(e,t){return e&&Array.prototype.forEach.call(e.length?e:[e],(function(e){return function(e){if(e&&e.nodeName&&"TEXTAREA"===e.nodeName&&!bm.has(e)){var t,r=null,n=null,i=null,o=function(){e.clientWidth!==n&&l()},s=function(t){window.removeEventListener("resize",o,!1),e.removeEventListener("input",l,!1),e.removeEventListener("keyup",l,!1),e.removeEventListener("autosize:destroy",s,!1),e.removeEventListener("autosize:update",l,!1),Object.keys(t).forEach((function(r){e.style[r]=t[r]})),bm.delete(e)}.bind(e,{height:e.style.height,resize:e.style.resize,overflowY:e.style.overflowY,overflowX:e.style.overflowX,wordWrap:e.style.wordWrap});e.addEventListener("autosize:destroy",s,!1),"onpropertychange"in e&&"oninput"in e&&e.addEventListener("keyup",l,!1),window.addEventListener("resize",o,!1),e.addEventListener("input",l,!1),e.addEventListener("autosize:update",l,!1),e.style.overflowX="hidden",e.style.wordWrap="break-word",bm.set(e,{destroy:s,update:l}),"vertical"===(t=window.getComputedStyle(e,null)).resize?e.style.resize="none":"both"===t.resize&&(e.style.resize="horizontal"),r="content-box"===t.boxSizing?-(parseFloat(t.paddingTop)+parseFloat(t.paddingBottom)):parseFloat(t.borderTopWidth)+parseFloat(t.borderBottomWidth),isNaN(r)&&(r=0),l()}function a(t){var r=e.style.width;e.style.width="0px",e.style.width=r,e.style.overflowY=t}function c(){if(0!==e.scrollHeight){var t=function(e){for(var t=[];e&&e.parentNode&&e.parentNode instanceof Element;)e.parentNode.scrollTop&&t.push({node:e.parentNode,scrollTop:e.parentNode.scrollTop}),e=e.parentNode;return t}(e),i=document.documentElement&&document.documentElement.scrollTop;e.style.height="",e.style.height=e.scrollHeight+r+"px",n=e.clientWidth,t.forEach((function(e){e.node.scrollTop=e.scrollTop})),i&&(document.documentElement.scrollTop=i)}}function l(){c();var t=Math.round(parseFloat(e.style.height)),r=window.getComputedStyle(e,null),n="content-box"===r.boxSizing?Math.round(parseFloat(r.height)):e.offsetHeight;if(n<t?"hidden"===r.overflowY&&(a("scroll"),c(),n="content-box"===r.boxSizing?Math.round(parseFloat(window.getComputedStyle(e,null).height)):e.offsetHeight):"hidden"!==r.overflowY&&(a("hidden"),c(),n="content-box"===r.boxSizing?Math.round(parseFloat(window.getComputedStyle(e,null).height)):e.offsetHeight),i!==n){i=n;var o=_m("autosize:resized");try{e.dispatchEvent(o)}catch{}}}}(e)})),e}).destroy=function(e){return e&&Array.prototype.forEach.call(e.length?e:[e],wm),e},Em.update=function(e){return e&&Array.prototype.forEach.call(e.length?e:[e],Sm),e});var km=Em,Tm=class extends HTMLTextAreaElement{constructor(){super(),km(this)}autosize(){km.update(this)}};customElements.define("textarea-auto-size",Tm,{extends:"textarea"});var Im=_t`: host {
								--preview - size: 80 px;
								--preview - radius: 10 px
							}.preview {
								width: var (--preview - size);height: var (--preview - size);position: relative;border - radius: var (--preview - radius);overflow: hidden
							}.preview > img {
								width: 100 % ;height: 100 % ;object - fit: contain
							}.button - delete {
								--icon - size: 10 px;
								position: absolute;
								right: var (--spacer - 2 xs);
								top: var (--spacer - 2 xs);
								background - color: var (--color - tone - 5);
								border: 0;
								border - radius: 50 % ;
								padding: 0;
								width: var (--size - md);
								height: var (--size - md);
								cursor: pointer;
								line - height: var (--icon - size)
							}.button - delete: hover {
								background - color: var (--color - tone - 4)
							}.button - delete icon - close {
								width: var (--icon - size);height: var (--icon - size);line - height: var (--icon - size)
							}.placeholder {
								background - color: transparent;
								border: 1 px dotted
								var (--color - tone - 2);
								border - radius: var (--preview - radius);
								fill: var (--color - tone - 2);
								width: var (--preview - size);
								height: var (--preview - size)
							}
							`,Rm=class extends yr{constructor(){super(...arguments),this.attachments=[],this.handleImageSelect=e=>{let t=e.target,r=Array.from(t.files||[]),n=r.some(e=>!li(e.type)),i=r.filter(e=>li(e.type));n&&this.dispatchEvent(new La({level:Ma.error,message:ka("Oops! Chat only supports files in JPEG, PNG and GIF format",{desc:"Message composer: invalid image format error"})})),i.length>0&&(this.attachments=[...this.attachments,...i]),this.fileInput.value="",this.dispatchChange()},this.attachFiles=e=>{let t=Array.from(e).filter(e=>li(e.type));t.length>0&&(this.attachments=[...this.attachments,...t]),this.dispatchChange()},this.openImageSelector=()=>{this.fileInput.click()}}static get styles(){return[ii,Im]}dispatchChange(){this.dispatchEvent(new CustomEvent("change"))}renderAttachments(){return this.attachments.length?Qt` < div class = "flex flex-row flex-wrap gap-sm px-sm py-xs" >
							$ {
								co(this.attachments, e => Qt`<div class="preview">
            <button
              class="button-delete"
              type="button"
              @click="${()=>{this.attachments=this.attachments.filter(t=>t!==e),this.dispatchChange()}}"
            >
              <icon-close size="none"></icon-close>
            </button>
            <img src="${URL.createObjectURL(e)}" alt="${e.name}" />
          </div>`)
							} <
							button type = "button"
							class = "placeholder"
							@click = "${this.openImageSelector}"
							aria - label = "${ka("
							Attach Image ",{id:"
							attach - image - button ",desc:"
							Message composer: attach image button title "})}" >
							<
							icon - add size = "${kn.Medium}" > < /icon-add> <
							/button> <
							/div>`:null}render(){return Qt` <
							input type = "file"
							class = "hidden"
							name = "attachment"
							accept = "image/*"
							multiple @input = "${this.handleImageSelect}" /
							>
							$ {
								this.renderAttachments()
							}
							`}};v([Tr("input[type=file]")],Rm.prototype,"fileInput",2),v([Er()],Rm.prototype,"attachments",2),Rm=v([_r("rs-message-composer-attachments")],Rm);var Cm={cake:"./cake-EOEAWJ7B.png",kappa:"./kappa-NJXU6ZEC.png",snoo_angry:"./snoo_angry-CAXVWDXQ.png",snoo_hug:"./snoo_hug-CUUUHJCJ.png",snoo_surprised:"./snoo_surprised-32HAFSYB.png",cat_blep:"./cat_blep-GXWJQED5.png",karma:"./karma-NDMNOF3U.png",snoo_cry:"./snoo_cry-EA7ZDPIA.png",snoo_joy:"./snoo_joy-7MIWX6WT.png",snoo_tableflip:"./snoo_tableflip-INSPEVPF.png",doge:"./doge-FED77ETV.png",orly:"./orly-RDBPUZQU.png",snoo_dealwithit:"./snoo_dealwithit-DWIK3QWQ.png",snoo_putback:"./snoo_putback-YPX43WC7.png",snoo_thoughtful:"./snoo_thoughtful-AMFEGU5A.png",downvote:"./downvote-TLM3HYPU.png",partyparrot:"./partyparrot-2WMFLLHP.gif",snoo_disapproval:"./snoo_disapproval-SR4BJZW4.png",snoo_sad:"./snoo_sad-VHLNCFQ2.png",snoo_tongue:"./snoo_tongue-LQUBXCDP.png",give_upvote_pride:"./give_upvote_pride-QXQIVMLS.png",pupper:"./pupper-FC7NL6FH.png",snoo_facepalm:"./snoo_facepalm-FDPGZ5MW.png",snoo_scream:"./snoo_scream-CUTF2Q5V.png",snoo_trollface:"./snoo_trollface-PXCX4BUR.png",hamster:"./hamster-LECLOGM7.png",redditgold:"./redditgold-LC2XTJDT.png",snoo_feelsbadman:"./snoo_feelsbadman-L52ZKLKP.png",snoo_shrug:"./snoo_shrug-PKRNGWYD.png",snoo_wink:"./snoo_wink-GGQSH3UB.png",heart_eyes_pride:"./heart_eyes_pride-T624DLYE.png",sloth:"./sloth-KLBGPJVL.png",snoo_feelsgoodman:"./snoo_feelsgoodman-RSHOU2LA.png",snoo_simple_smile:"./snoo_simple_smile-RTEIX3EO.png",upvote:"./upvote-47NSSUBB.png",illuminati:"./illuminati-2YMGXUUL.png",snoo:"./snoo-FDZ6L4MQ.png",snoo_hearteyes:"./snoo_hearteyes-G3QSRF4P.png",snoo_smile:"./snoo_smile-CD6DLBBT.png",upvote_pride:"./upvote_pride-D6XMNFDI.png"},Mm=_t`.scroll {
								--scrollbar - color - background -
									default: var (--color - tone - 4);
								--scrollbar - color - background - hover: var (--color - tone - 3);
								--scrollbar - size: var (--rem14)
							}.scroll::-webkit - scrollbar {
								width: var (--scrollbar - size)
							}.scroll::-webkit - scrollbar - track {
								border: 0
							}.scroll::-webkit - scrollbar - thumb {
								min - height: 50 px;
								border - radius: calc(var (--scrollbar - size) / 2);
								background - clip: padding - box;
								border: 3 px solid rgba(0, 0, 0, 0);
								background - color: var (--scrollbar - color - background -
									default)
							}.scroll::-webkit - scrollbar - thumb: hover {
								background - color: var (--scrollbar - color - background - hover)
							}.emoji - section {
								position: relative;overflow: visible
							}.button - emoji__icon {
								height: 20 px
							}.emoji - dropdown {
								--padding - left: 10 px;
								--scrollbar - color - background -
									default: var (--color - tone - 4);
								--scrollbar - color - background - hover: var (--color - tone - 3);
								--scrollbar - size: var (--rem14);
								position: absolute;
								bottom: 60 px;
								right: 0;
								width: 292 px;
								height: 346 px;
								overflow - y: overlay;
								overflow - y: auto;
								border - radius: var (--spacer - md);
								border: 1 px solid
								var (--color - tone - 5);
								background - color: var (--color - tone - 7);
								cursor: default;
								display: flex;
								flex - wrap: wrap;
								gap: var (--spacer - sm);
								padding: var (--spacer - sm) 0
								var (--spacer - sm) var (--padding - left)
							}.emoji - dropdown::-webkit - scrollbar {
								width: var (--scrollbar - size)
							}.emoji - dropdown::-webkit - scrollbar - track {
								border: 0
							}.emoji - dropdown::-webkit - scrollbar - thumb {
								min - height: 50 px;
								border - radius: calc(var (--scrollbar - size) / 2);
								background - clip: padding - box;
								border: 3 px solid rgba(0, 0, 0, 0);
								background - color: var (--scrollbar - color - background -
									default)
							}.emoji - dropdown::-webkit - scrollbar - thumb: hover {
								background - color: var (--scrollbar - color - background - hover)
							}.emoji - dropdown - tail {
								--tail - radius: 7 px;
								background - color: var (--color - tone - 7);
								height: 20 px;
								width: 20 px;
								position: absolute;
								bottom: 50 px;
								right: 18 px;
								clip - path: polygon(0 0, 100 % 100 % , 0 100 % );
								transform: rotate(-45 deg);
								border - radius: 0 0 0
								var (--tail - radius);
								border: 1 px solid
								var (--color - tone - 5)
							}.emoji {
								padding: var (--spacer - 2 xs);border: 0;border - radius: var (--spacer - md);height: 40 px;cursor: pointer;background - color: var (--color - tone - 7)
							}.emoji: hover {
								background - color: var (--color - tone - 5)
							}.emoji__img {
								width: 32 px;height: 32 px
							}
							`,xm=class extends yr{constructor(){super(...arguments),this.isDropdownShown=!1,this.snoomojiNames=Object.keys(Cm),this.onClickDropdown=e=>e.stopPropagation(),this.openEmojiDropdown=e=>{this.isDropdownShown||(this.dispatchEvent(new Xg({dropdownType:"emoji"})),this.onClickOutsideEmojiButton(),e.stopPropagation())},this.dispatchSend=(e,t)=>{this.dispatchEvent(new Qg({filePath:e,fileName:t})),this.dispatchEvent(new Zg)},this.renderEmojiDropdown=()=>this.isDropdownShown?Qt` <
							div class = "emoji-dropdown"
							@click = "${this.onClickDropdown}" >
							$ {
								Ga(this.snoomojiNames, e => Qt`<button
              class="emoji"
              type="button"
              @click="${()=>this.dispatchSend(Cm[e],e)}"
            >
              <img class="emoji__img" src="${Cm[e]}" alt="${e}" />
            </button>`)
							} <
							/div> <
							div class = "emoji-dropdown-tail" > < /div>
							`:null,this.onClickOutsideEmojiButton=()=>{let e=()=>{this.dispatchEvent(new Zg),t()},t=()=>{document.removeEventListener("click",e)};document.addEventListener("click",e)}}static get styles(){return[ii,Mm]}render(){return Qt` <
							div class = "emoji-section" >
							<
							faceplate - tooltip position = "top" >
							$ {
								vn({
									appearance: "plain",
									ariaLabel: ka("Select emoji", {
										desc: "Message composer: select emoji button label"
									}),
									attributes: {
										type: "button",
										slot: "trigger",
										className: "button-emoji",
										onclick: this.openEmojiDropdown
									},
									leadingIcon: Qt`<icon-emoji
              class="button-emoji__icon text-tone-2"
              ?fill="${this.isDropdownShown}"
            ></icon-emoji>`
								})
							}
							$ {
								ka("Select emoji", {
									desc: "Message composer: select emoji button label"
								})
							} <
							/faceplate-tooltip>
							$ {
								this.renderEmojiDropdown()
							} <
							/div>
							`}};v([Sr({type:Boolean})],xm.prototype,"isDropdownShown",2),xm=v([_r("rs-message-composer-emojis")],xm);Zn("icon-clear",Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_473_114)"><path d="M10 0a10 10 0 1010 10A10.011 10.011 0 0010 0zm0 18.75A8.75 8.75 0 1118.75 10 8.76 8.76 0 0110 18.75zm3.567-11.433L10.884 10l2.683 2.683-.884.884L10 10.884l-2.683 2.683-.884-.884L9.116 10 6.433 7.317l.884-.884L10 9.116l2.683-2.683.884.884z"/></g><defs><clipPath id="clip0_473_114"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
							}
							`,Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_473_116)"><path d="M10 0a10 10 0 1010 10A10.011 10.011 0 0010 0zm3.832 12.418l-1.414 1.414L10 11.414l-2.418 2.418-1.414-1.414L8.586 10 6.168 7.582l1.414-1.414L10 8.586l2.418-2.418 1.414 1.414L11.414 10l2.418 2.418z"/></g><defs><clipPath id="clip0_473_116"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
							}
							`),Zn("icon-gif-post",Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_616_22)"><path d="M4.711 12.664A2.8 2.8 0 013.6 11.583 3.108 3.108 0 013.2 10a3.052 3.052 0 01.411-1.583c.267-.46.659-.834 1.129-1.082a3.37 3.37 0 011.616-.385c.333 0 .664.043.986.128.309.081.605.205.879.369l-.5 1.169a1.314 1.314 0 00-.563-.357 2.3 2.3 0 00-.754-.124 1.733 1.733 0 00-1.863 1.848c-.006.344.073.684.232.99a1.7 1.7 0 001.542.925c.258.004.513-.051.746-.162.209-.097.387-.25.513-.443.121-.185.185-.401.183-.622H6.124V9.619L9 9.6v.928a2.4 2.4 0 01-1.293 2.193 2.955 2.955 0 01-1.417.328 3.247 3.247 0 01-1.579-.385zm5.471-5.648H11.5v5.968h-1.318V7.016zm2.862 0H16.5v1.169h-2.138v1.392h1.79v1.169h-1.79v2.238h-1.318V7.016zM10 20a18.04 18.04 0 01-6.369-1.162 4.226 4.226 0 01-2.469-2.47 18.033 18.033 0 010-12.737 4.228 4.228 0 012.469-2.469 18.116 18.116 0 0112.738 0 4.228 4.228 0 012.469 2.469 18.035 18.035 0 010 12.738 4.225 4.225 0 01-2.469 2.469A18.04 18.04 0 0110 20zm0-18.75a16.8 16.8 0 00-5.929 1.082 2.978 2.978 0 00-1.739 1.739 16.783 16.783 0 000 11.857 2.98 2.98 0 001.739 1.74 16.858 16.858 0 0011.858 0 2.978 2.978 0 001.739-1.739 16.785 16.785 0 000-11.858 2.978 2.978 0 00-1.739-1.739A16.8 16.8 0 0010 1.25z"/></g><defs><clipPath id="clip0_616_22"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
							}
							`,Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_616_23)"><path d="M18.838 3.631a4.228 4.228 0 00-2.469-2.469 18.116 18.116 0 00-12.738 0 4.228 4.228 0 00-2.469 2.469 18.033 18.033 0 000 12.737 4.226 4.226 0 002.469 2.47 18.035 18.035 0 0012.738 0 4.226 4.226 0 002.469-2.469 18.035 18.035 0 000-12.738zM9 10.53a2.4 2.4 0 01-1.293 2.193 2.955 2.955 0 01-1.417.328 3.246 3.246 0 01-1.579-.386A2.811 2.811 0 013.6 11.583 3.108 3.108 0 013.2 10a3.052 3.052 0 01.411-1.583c.267-.46.659-.834 1.129-1.082a3.37 3.37 0 011.616-.385c.333 0 .664.043.986.128.309.081.605.205.879.369l-.5 1.169a1.314 1.314 0 00-.563-.357 2.3 2.3 0 00-.754-.124 1.733 1.733 0 00-1.863 1.848c-.006.344.073.684.232.99a1.7 1.7 0 001.542.925c.258.004.513-.051.746-.162.209-.097.387-.25.513-.443.121-.185.185-.401.183-.622H6.124V9.619L9 9.6v.93zm2.5 2.454H10V7.016h1.5v5.968zm5-4.8h-2.138v1.393h1.79v1.169h-1.79v2.238H13V7.016h3.5v1.168z"/></g><defs><clipPath id="clip0_616_23"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
							}
							`),Zn("icon-search",Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_480_0)"><path d="M19.442 18.558l-4.513-4.513a8.525 8.525 0 10-.884.884l4.513 4.513.884-.884zM1.252 8.5A7.25 7.25 0 118.5 15.75 7.258 7.258 0 011.251 8.5z"/></g><defs><clipPath id="clip0_480_0"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
							}
							`,Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_784_291)"><path d="M19.707 18.293l-4.539-4.539a8.527 8.527 0 10-1.414 1.414l4.539 4.539 1.414-1.414zM8.5 15A6.5 6.5 0 1115 8.5 6.508 6.508 0 018.5 15z"/></g><defs><clipPath id="clip0_784_291"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
							}
							`);var Om=p(pt()),Am=class{constructor(){this.giphyClient=new Om.GiphyFetch("k2kwyMA6VeyHM6ZRT96OXDGaersnx73Z")}static getInstance(){return Am.instance||(Am.instance=new Am),Am.instance}fetchTrendingGifs(e,t=10){return this.giphyClient.trending({offset:e,limit:t})}fetchSearchGifs(e,t,r=10){return this.giphyClient.search(e,{offset:t,limit:r})}},Pm=_t`.scroll {
								--scrollbar - color - background -
									default: var (--color - tone - 4);
								--scrollbar - color - background - hover: var (--color - tone - 3);
								--scrollbar - size: var (--rem14)
							}.scroll::-webkit - scrollbar {
								width: var (--scrollbar - size)
							}.scroll::-webkit - scrollbar - track {
								border: 0
							}.scroll::-webkit - scrollbar - thumb {
								min - height: 50 px;
								border - radius: calc(var (--scrollbar - size) / 2);
								background - clip: padding - box;
								border: 3 px solid rgba(0, 0, 0, 0);
								background - color: var (--scrollbar - color - background -
									default)
							}.scroll::-webkit - scrollbar - thumb: hover {
								background - color: var (--scrollbar - color - background - hover)
							}.gif - section {
								position: relative;overflow: visible
							}.gifs - dropdown {
								--scrollbar - color - background -
									default: var (--color - tone - 4);
								--scrollbar - color - background - hover: var (--color - tone - 3);
								--scrollbar - size: var (--rem14);
								position: absolute;
								bottom: 60 px;
								right: 0;
								width: 292 px;
								height: 346 px;
								overflow - y: overlay;
								overflow - y: auto;
								border - radius: var (--spacer - md);
								border: 1 px solid
								var (--color - tone - 5);
								background - color: var (--color - tone - 7);
								cursor: default;
								display: flex;
								flex - direction: column;
								gap: var (--spacer - sm);
								padding - top: var (--spacer - sm)
							}.gifs - dropdown::-webkit - scrollbar {
								width: var (--scrollbar - size)
							}.gifs - dropdown::-webkit - scrollbar - track {
								border: 0
							}.gifs - dropdown::-webkit - scrollbar - thumb {
								min - height: 50 px;
								border - radius: calc(var (--scrollbar - size) / 2);
								background - clip: padding - box;
								border: 3 px solid rgba(0, 0, 0, 0);
								background - color: var (--scrollbar - color - background -
									default)
							}.gifs - dropdown::-webkit - scrollbar - thumb: hover {
								background - color: var (--scrollbar - color - background - hover)
							}.gifs - dropdown__search {
								--margin - horizontal: 10 px;
								background - color: var (--color - tone - 5);
								border - radius: var (--radius - full);
								height: 36 px;
								display: flex;
								align - items: center;
								padding: 0
								var (--size - lg) 0
								var (--size - md);
								margin: 0
								var (--margin - horizontal);
								position: sticky;
								top: 0;
								z - index: var (--layer - overlay)
							}.gifs - dropdown__search input {
								background - color: transparent;
								outline: 0;
								margin: 0
								var (--size - xs);
								border: 0;
								height: 36 px;
								flex: 1
							}.gifs - dropdown - tail {
								--tail - radius: 7 px;
								background - color: var (--color - tone - 7);
								height: 20 px;
								width: 20 px;
								position: absolute;
								bottom: 50 px;
								right: 18 px;
								clip - path: polygon(0 0, 100 % 100 % , 0 100 % );
								transform: rotate(-45 deg);
								border - radius: 0 0 0
								var (--tail - radius);
								border: 1 px solid
								var (--color - tone - 5)
							}.gifs - container {
								display: flex;flex - direction: column
							}.loading - spinner {
								animation: spin 2.5 s infinite linear
							}
							`,Dm=class extends yr{constructor(){super(...arguments),this.isDropdownShown=!1,this.searchQuery="",this.isLoading=!1,this.gifsOffset=0,this.gifs=[],this.giphy=Am.getInstance(),this.stopPropagation=e=>e.stopPropagation(),this.openGifsDropdown=e=>{this.isDropdownShown||(this.dispatchEvent(new Xg({dropdownType:"gif"})),this.onClickOutsideGifsButton(),e.stopPropagation())},this.handleSearchGifs=va(()=>{var e;this.searchQuery=(null==(e=this.input)?void 0:e.value)||"",this.gifsOffset=0},500),this.handleScroll=va(()=>{let e=this.gifsDropdown;this.gifsOffset%10==0&&e&&e.scrollHeight-e.scrollTop<2*e.clientHeight&&this.fetchGifs()},200),this.clearSearchQuery=()=>{var e;this.searchQuery="",this.gifsOffset=0,null==(e=this.input)||e.focus()},this.hideDropdown=()=>{this.dispatchEvent(new Zg),this.clearSearchQuery()},this.fetchGifs=()=>{let e=this.searchQuery.trim();this.isLoading=!0,e?this.giphy.fetchSearchGifs(e,this.gifsOffset,10).then(this.setFetchedGifs).catch(this.handleGiphyErrors):this.giphy.fetchTrendingGifs(this.gifsOffset,10).then(this.setFetchedGifs).catch(this.handleGiphyErrors)},this.handleGiphyErrors=()=>{this.dispatchEvent(new La({level:Ma.error,message:ka("Error loading gifs. Please try again",{desc:"Gif dropdown: Error loading gifs"})})),this.isLoading=!1},this.setFetchedGifs=async e=>{let t=e;if(!t.data.length&&!this.gifsOffset&&this.searchQuery.trim())try{t=await this.giphy.fetchTrendingGifs(this.gifsOffset,10)}catch{return void this.handleGiphyErrors()}let r=t.data.map(e=>({url:e.images.original.url,height:e.images.fixed_width_downsampled.height,width:e.images.fixed_width_downsampled.width,downsizedUrl:e.images.fixed_width_downsampled.url,id:e.id.toString()}));this.gifsOffset?this.gifs=this.gifs.concat(r):this.gifs=r,this.gifsOffset+=t.data.length,this.isLoading=!1},this.dispatchSend=(e,t)=>{this.dispatchEvent(new Jg({gifUrl:e,gifName:t})),this.hideDropdown()},this.renderGifsDropdown=()=>this.isDropdownShown?Qt` <
							div class = "gifs-dropdown"
							@click = "${this.stopPropagation}"
							@scroll = "${()=>this.handleScroll()}" >
							<
							div class = "gifs-dropdown__search" >
							<
							icon - search class = "text-tone-2"
							size = "${kn.Small}" > < /icon-search> <
							input type = "text"
							autocomplete = "off"
							placeholder = "${ka("
							Search GIPHY ",{desc:"
							Search input
							for GIPHY "})}"
							.value = "${this.searchQuery}"
							@input = "${()=>this.handleSearchGifs()}" /
							>
							$ {
								this.searchQuery.length ? Qt`<icon-clear
                class="text-tone-2 cursor-pointer absolute right-[8px]"
                size="${kn.Medium}"
                @click="${this.clearSearchQuery}"
              ></icon-clear>` : ""
							} <
							/div> <
							div class = "gifs-container" >
							$ {
								co(this.gifs, e => e.id, e => Qt` <img
                class="cursor-pointer mb-[8px]"
                src="${e.url}"
                alt=""
                height="${e.height/(e.width/278)}"
                @click="${()=>this.dispatchSend(e.downsizedUrl,e.id)}"
              />`)
							} <
							/div>
							$ {
								this.isLoading ? Qt` <div class="flex flex-grow items-center justify-center mb-[20px]">
              <icon-load class="text-tone-2 loading-spinner" size="${kn.Large}"></icon-load>
            </div>` : ""
							} <
							/div> <
							div class = "gifs-dropdown-tail" > < /div>
							`:null,this.onClickOutsideGifsButton=()=>{let e=()=>{this.hideDropdown(),t()},t=()=>{document.removeEventListener("click",e)};document.addEventListener("click",e)}}static get styles(){return[ii,Pm]}updated(e){var t;super.updated(e),e.has("isDropdownShown")&&this.isDropdownShown&&(null==(t=this.input)||t.focus()),(e.has("searchQuery")||e.has("isDropdownShown"))&&this.isDropdownShown&&this.fetchGifs()}render(){return Qt` <
							div class = "gif-section" >
							<
							faceplate - tooltip position = "top" >
							$ {
								vn({
									appearance: "plain",
									ariaLabel: ka("Select gif", {
										desc: "Message composer: select gif button label"
									}),
									attributes: {
										type: "button",
										slot: "trigger",
										className: "button-gif",
										onclick: this.openGifsDropdown
									},
									leadingIcon: Qt`<icon-gif-post
              class="text-tone-2 h-[20px]"
              ?fill="${this.isDropdownShown}"
            ></icon-gif-post>`
								})
							}
							$ {
								ka("Select gif", {
									desc: "Message composer: select gif button label"
								})
							} <
							/faceplate-tooltip>
							$ {
								this.renderGifsDropdown()
							} <
							/div>
							`}};v([Sr({type:Boolean})],Dm.prototype,"isDropdownShown",2),v([Tr("input")],Dm.prototype,"input",2),v([Tr("div.gifs-dropdown")],Dm.prototype,"gifsDropdown",2),v([Er()],Dm.prototype,"searchQuery",2),v([Er()],Dm.prototype,"isLoading",2),v([Er()],Dm.prototype,"gifsOffset",2),v([Er()],Dm.prototype,"gifs",2),Dm=v([_r("rs-message-composer-giphys")],Dm);var jm=_t`.scroll {
								--scrollbar - color - background -
									default: var (--color - tone - 4);
								--scrollbar - color - background - hover: var (--color - tone - 3);
								--scrollbar - size: var (--rem14)
							}.scroll::-webkit - scrollbar {
								width: var (--scrollbar - size)
							}.scroll::-webkit - scrollbar - track {
								border: 0
							}.scroll::-webkit - scrollbar - thumb {
								min - height: 50 px;
								border - radius: calc(var (--scrollbar - size) / 2);
								background - clip: padding - box;
								border: 3 px solid rgba(0, 0, 0, 0);
								background - color: var (--scrollbar - color - background -
									default)
							}.scroll::-webkit - scrollbar - thumb: hover {
								background - color: var (--scrollbar - color - background - hover)
							}
							form {
								display: grid;grid - template - columns: min - content 1 fr auto;grid - column - gap: var (--spacer - 2 xs);align - items: end;padding: var (--spacer - xs)
							}.button - send {
								color: var (--color - global - alienblue)
							}.button - send: disabled {
								color: var (--color - button - primary - text - disabled)
							}.button.button - plain {
								width: 40 px;height: 40 px
							}.message - box {
								font - family: var (--font - sans);
								color: var (--color - input - text);
								padding: .5 rem .75 rem;
								margin - bottom: .5 rem;
								background: var (--color - input -
									default);
								border: var (--color - input -
									default) solid
								var (--line - input - border);
								border - radius: var (--radius - sm);
								box - shadow: none;
								box - sizing: border - box;
								font - size: 1 rem;
								display: flex;
								align - items: flex - end;
								padding: 0;
								margin: 0;
								border: 0;
								border - radius: 20 px
							}.message - box: disabled {
								cursor: not - allowed;opacity: .5
							}.message - box: invalid {
								border - color: var (--color - danger - content)
							}
							textarea {
								font - family: var (--font - sans);
								color: var (--color - input - text);
								padding: .5 rem .75 rem;
								margin - bottom: .5 rem;
								background: var (--color - input -
									default);
								border: var (--color - input -
									default) solid
								var (--line - input - border);
								border - radius: var (--radius - sm);
								box - shadow: none;
								box - sizing: border - box;
								font - size: 1 rem;
								--scrollbar - color - background -
									default: var (--color - tone - 4);
								--scrollbar - color - background - hover: var (--color - tone - 3);
								--scrollbar - size: var (--rem14);
								flex - grow: 1;
								background - color: transparent;
								margin: 0;
								border: 0;
								outline: 0;
								max - height: 100 px;
								min - height: 40 px;
								resize: none
							}
							textarea: disabled {
								cursor: not - allowed;opacity: .5
							}
							textarea: invalid {
								border - color: var (--color - danger - content)
							}
							textarea::-webkit - scrollbar {
								width: var (--scrollbar - size)
							}
							textarea::-webkit - scrollbar - track {
								border: 0
							}
							textarea::-webkit - scrollbar - thumb {
								min - height: 50 px;
								border - radius: calc(var (--scrollbar - size) / 2);
								background - clip: padding - box;
								border: 3 px solid rgba(0, 0, 0, 0);
								background - color: var (--scrollbar - color - background -
									default)
							}
							textarea::-webkit - scrollbar - thumb: hover {
								background - color: var (--scrollbar - color - background - hover)
							}
							`,Lm=class extends yr{constructor(){super(...arguments),this.isValid=!1,this.activeDropdown=void 0,this.updateFormValidity=()=>{this.isValid=this.input.value.trim().length>0||this.attachmentsControl.attachments.length>0},this.handleInputKeyDown=e=>{"Enter"===e.key&&!e.shiftKey&&(e.preventDefault(),this.form.requestSubmit())},this.handlePaste=e=>{!e.clipboardData||this.attachmentsControl.attachFiles(e.clipboardData.files)},this.openImageSelector=()=>{this.attachmentsControl.openImageSelector()},this.showDropdown=e=>{this.activeDropdown=e.detail.dropdownType},this.hideDropdown=()=>{this.activeDropdown=void 0},this.sendEmoji=async e=>{let{filePath:t,fileName:r}=e.detail,n=await(async(e,t,r)=>{r=r||`
							image / $ {
								e.split(".")[e.split(".").length - 1]
							}
							`;let n=await(await fetch(e)).arrayBuffer();return new File([n],t,{type:r})})(t,r),i=new Yg({attachments:[n]});this.dispatchEvent(i)},this.sendGif=async e=>{let{gifUrl:t,gifName:r}=e.detail,n=await(async(e,t,r="image/gif")=>{let n=await(await fetch(e)).arrayBuffer();return new File([n],t,{type:r})})(t,r),i=new Yg({attachments:[n]});this.dispatchEvent(i)}}static get styles(){return[ii,jm]}resetForm(){this.form.reset(),this.input.autosize(),this.attachmentsControl.attachments=[],this.isValid=!1}sendMessage(e){var t;e.preventDefault();let r=null==(t=new FormData(this.form).get("message"))?void 0:t.toString().trim();if((!r||0===r.length)&&0===this.attachmentsControl.attachments.length)return void this.resetForm();let n=new Yg({body:r,attachments:this.attachmentsControl.attachments});this.dispatchEvent(n),this.resetForm()}render(){return Qt` <
							rs - message - composer - attachments @change = "${this.updateFormValidity}" >
							< /rs-message-composer-attachments> <
							form @submit = "${this.sendMessage}" >
							$ {
								vn({
									appearance: "plain",
									ariaLabel: ka("Attach Image", {
										desc: "Message composer: attach image button label"
									}),
									attributes: {
										type: "button",
										onclick: this.openImageSelector
									},
									leadingIcon: Qt`<icon-camera class="text-tone-2"></icon-camera>`
								})
							} <
							div class = "message-box" >
							<
							textarea is = "textarea-auto-size"
							name = "message"
							autocomplete = "off"
							placeholder = "${ka("
							Message ",{desc:"
							Message composer: message input placeholder "})}"
							rows = "1"
							@input = "${this.updateFormValidity}"
							@keydown = "${this.handleInputKeyDown}"
							@paste = "${this.handlePaste}" >
							< /textarea> <
							rs - message - composer - giphys
							.isDropdownShown = "${"
							gif "===this.activeDropdown}"
							@show - dropdown = "${this.showDropdown}"
							@hide - dropdown = "${this.hideDropdown}"
							@send - gif = "${this.sendGif}" >
							<
							/rs-message-composer-giphys> <
							rs - message - composer - emojis
							.isDropdownShown = "${"
							emoji "===this.activeDropdown}"
							@show - dropdown = "${this.showDropdown}"
							@hide - dropdown = "${this.hideDropdown}"
							@send - emoji = "${this.sendEmoji}" >
							< /rs-message-composer-emojis> <
							/div>
							$ {
								vn({
									appearance: "plain",
									ariaLabel: ka("Send message", {
										desc: "Message composer: send message button label"
									}),
									attributes: {
										type: "submit",
										className: "button-send",
										disabled: !this.isValid || void 0
									},
									leadingIcon: Qt`<icon-send fill></icon-send>`
								})
							} <
							/form>
							`}};v([Tr("form")],Lm.prototype,"form",2),v([Tr("textarea")],Lm.prototype,"input",2),v([Tr("rs-message-composer-attachments")],Lm.prototype,"attachmentsControl",2),v([Er()],Lm.prototype,"isValid",2),v([Er()],Lm.prototype,"activeDropdown",2),Lm=v([_r("rs-message-composer")],Lm);Zn("icon-ban",Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M19.59 9.705l-1.062-1.061a2.606 2.606 0 00-1.856-.769h-.913l-3.634-3.634v-.912a2.597 2.597 0 00-.769-1.856L10.3.411a1.128 1.128 0 00-1.6.001L3.411 5.705a1.125 1.125 0 000 1.59l1.061 1.061a2.607 2.607 0 001.856.769h.913l.375.375-6.557 6.558a2.04 2.04 0 002.883 2.884l6.558-6.558.375.375v.913a2.608 2.608 0 00.77 1.856l1.06 1.06a1.127 1.127 0 001.591 0l5.292-5.288a1.124 1.124 0 000-1.591l.001-.004zM3.06 18.058a.79.79 0 11-1.118-1.116L8.5 10.384 9.616 11.5 3.06 18.058zm10.44-2.442l-.972-.972a1.38 1.38 0 01-.4-.972v-1.431L7.76 7.875H6.33a1.367 1.367 0 01-.973-.4L4.384 6.5 9.5 1.384l.972.972c.257.259.4.609.4.973v1.43l4.366 4.366h1.431c.364 0 .713.144.972.4l.972.972-5.113 5.119z"/></svg>')
							}
							`,Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M19.918 10.5a1.114 1.114 0 01-.33.8L14.3 16.588a1.127 1.127 0 01-1.592 0l-1.06-1.06a2.608 2.608 0 01-.769-1.856v-.913L7.241 9.125h-.913a2.607 2.607 0 01-1.856-.769L3.412 7.3a1.125 1.125 0 010-1.59L8.7.412a1.128 1.128 0 011.591 0l1.061 1.062a2.601 2.601 0 01.77 1.856v.912l3.633 3.634h.913a2.607 2.607 0 011.856.769l1.061 1.061a1.12 1.12 0 01.333.794zM8.834 12.834l-1.392-1.392-.884-.884-5.5 5.5a2.04 2.04 0 002.883 2.884l5.5-5.5-.607-.608z"/></svg>')
							}
							`),Zn("icon-block",Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_474_23)"><path d="M18.384 18.8l.013-.013L2.486 2.874l-.886.885 7.244 7.24H7.538A6.482 6.482 0 001 17.412v.482A1.114 1.114 0 002.119 19h14.725l.67.67.761-.762c.052-.02.102-.043.151-.068l-.042-.04zM2.251 17.75v-.34a5.231 5.231 0 015.287-5.16h2.556l5.5 5.5H2.251zM13.5 11.089a6.477 6.477 0 015.427 5.427l-2.6-2.6a4.795 4.795 0 00-.247-.247l-2.58-2.58zm-7.1-7.1l-.98-.983a5 5 0 116.574 6.574l-.985-.98a3.74 3.74 0 10-4.6-4.6L6.4 3.989z"/></g><defs><clipPath id="clip0_474_23"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
							}
							`,Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_474_37)"><path d="M13.028 11.028a6.474 6.474 0 015.951 5.95l-5.951-5.95zM15 5a4.988 4.988 0 00-9.687-1.687l6.374 6.374A4.994 4.994 0 0015 5zM1.6 3.759l7.244 7.24H7.538A6.482 6.482 0 001 17.412v.482A1.114 1.114 0 002.119 19h14.725l.67.67.883-.885L2.486 2.874l-.886.885z"/></g><defs><clipPath id="clip0_474_37"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
							}
							`);function Nm(){let e=new WeakMap,t=!1;return{get isDirty(){return t},register(r,n){let i=e.get(r);i&&!i.has(n)?i.add(n):i||e.set(r,new Set([n])),t=!0},unregister(r,n){let i=e.get(r);i&&i.has(n)&&(i.delete(n),t=!0)},getRegisteredElements(r){let n=e.get(r);return t=!1,n},unregisterAll(r){e.delete(r),t=!0}}}var Bm=Nm(),Um=(function(){let e=new WeakMap,t=!1}(),function(){let e=new Set,t=t=>e.has(t.constructor);return{registerAncestorClass(t){e.add(t)},connectToAncestor:e=>(async function(e,t){let r=e;for(;r.parentElement;){if(!(r=r.parentElement).tagName.includes("-"))continue;let e=r.tagName.toLowerCase();if(customElements.get(e)||await customElements.whenDefined(e),t(r))return r}})(e,t)}}()),Fm=(Um.registerAncestorClass,Um.connectToAncestor),$m=class{constructor(e){this.submissionValue=null,this.constraintsSuffered={},this.customValidityMessage="",this.validityMessage="",this.validationAnchor=null,this.target=e,this.input=document.createElement("input"),this.input.className="faceplate-internal-input",this.input.tabIndex=-1,this.input.style.opacity="0",this.input.style.width="1px",this.input.style.height="100%",this.input.style.padding="0",this.input.style.border="0",this.input.style.pointerEvents="none"}_connect(e){e?(this._form=e,Bm.register(e,this.target)):this._form=void 0}_disconnect(){this._form&&(Bm.unregister(this._form,this.target),this._form=void 0)}getFormValue(){return this.submissionValue}setFormValue(e){this.submissionValue=e}get form(){return this._form}isSufferingFromItsConstraints(){for(let e in this.constraintsSuffered)if(this.constraintsSuffered[e])return!0;return!1}setValidity(e,t,r=null){if(e&&Object.keys(e).length)for(let i in e)this.constraintsSuffered[i]=e[i];else this.constraintsSuffered=e||{};let n=!!t&&this.isSufferingFromItsConstraints();if(e&&Object.prototype.hasOwnProperty.call(e,"customError")){let e=this.constraintsSuffered.customError&&t?t:"";this.customValidityMessage=e}else this.validationAnchor=r,this.validityMessage=n&&t?t:"";(this.validationAnchor||this.input).setCustomValidity(this.validationMessage),this.target.setAttribute("faceplate-validity",n?"invalid":"valid")}get willValidate(){return!(this.target.disabled||null===this.submissionValue)}get validity(){let e=this.constraintsSuffered;return new class{constructor(e,t,r,n,i,o,s,a,c,l){this.valueMissing=e,this.typeMismatch=t,this.patternMismatch=r,this.tooLong=n,this.tooShort=i,this.rangeUnderflow=o,this.rangeOverflow=s,this.stepMismatch=a,this.badInput=c,this.customError=l}}(!!e.valueMissing,!!e.typeMismatch,!!e.patternMismatch,!!e.tooLong,!!e.tooShort,!!e.rangeUnderflow,!!e.rangeOverflow,!!e.stepMismatch,!!e.badInput,!!e.customError)}get validationMessage(){return this.customValidityMessage||this.validityMessage}dispatchInvalidEvent(){let e=new Event("invalid",{bubbles:!0,cancelable:!0});return this.target.dispatchEvent(e),e}checkValidity(){return!this.isSufferingFromItsConstraints()||(this.dispatchInvalidEvent(),!1)}reportValidity(){return!this.isSufferingFromItsConstraints()||(this.dispatchInvalidEvent().defaultPrevented||(this.validationAnchor||this.input).reportValidity(),!1)}},qm=Symbol("mixins/form-association"),Km=Nm(),Vm=new MutationObserver(e=>{for(let t of e){if("attributes"!==t.type||"disabled"!==t.attributeName||!(t.target instanceof HTMLFieldSetElement))continue;let e=Km.getRegisteredElements(t.target);if(e)for(let r of e)r.formDisabledCallback&&r.formDisabledCallback(r.disabled||t.target.disabled)}});var zm=class extends(function(e){if(qm in e)return e;class t extends e{constructor(){super(...arguments),this._internals=new $m(this)}connectedCallback(){super.connectedCallback&&super.connectedCallback(),Fm(this).then(e=>{if(!e||!this.isConnected)return;this._internals._connect(e),this.formAssociatedCallback&&this.formAssociatedCallback(e);let t=this;for(;t.parentElement&&!((t=t.parentElement)===e||t instanceof HTMLLegendElement);)if(t instanceof HTMLFieldSetElement){this._fieldSet=t,Km.getRegisteredElements(t)||Vm.observe(t,{attributes:!0}),Km.register(t,this);break}this.formDisabledCallback&&this.formDisabledCallback(this.disabled)})}disconnectedCallback(){super.disconnectedCallback&&super.disconnectedCallback(),this._internals._disconnect(),this.formAssociatedCallback&&this.formAssociatedCallback(null),this._fieldSet&&(Km.unregister(this._fieldSet,this),this._fieldSet=void 0)}get value(){return this._internals.getFormValue()}set value(e){this._internals.setFormValue(e)}get form(){return this._internals.form}get name(){return this.getAttribute("name")||""}get disabled(){return this.hasAttribute("disabled")||!(!this._fieldSet||!this._fieldSet.disabled)}set disabled(e){e?this.setAttribute("disabled",""):this.removeAttribute("disabled"),this.formDisabledCallback&&this.formDisabledCallback(e||!(!this._fieldSet||!this._fieldSet.disabled))}get type(){return this.localName}get validity(){return this._internals.validity}get validationMessage(){return this._internals.validationMessage}get willValidate(){return this._internals.willValidate}checkValidity(){return this._internals.checkValidity()}reportValidity(){return this._internals.reportValidity()}setCustomValidity(e){this._internals.setValidity({customError:!!e},e)}}return t[qm]=!0,t}(yr)){constructor(){super(),this.ariaDisabled="false",this.addEventListener("focus",()=>{let e=new FocusEvent("focusin",{bubbles:!0});this.dispatchEvent(e)})}static get styles(){return _t`: host {
								display: inline - block;
								position: relative;
							}

							/* This attribute is set when the input is disabled, or an ancestor fieldset is disabled. */
							: host([aria - disabled = true]) {
								cursor: not - allowed;
								opacity: 0.5;
							}

							/* This attribute is set by ElementInternals when an input's validity state is updated. */
							: host([faceplate - validity = 'invalid']) {
								border - color: var (--color - danger - content);
							}

							/* This input is provided by WithFormAssociation, and is used to display error states */
							.faceplate - internal - input {
								position: absolute;
								left: 50 % ;
								bottom: 0;
							}
							`}get disabled(){return super.disabled}set disabled(e){super.disabled=e}render(){return Qt`
							$ {
								this._internals.input
							}
							`}formDisabledCallback(e){this.ariaDisabled=e?"true":"false"}formResetCallback(){this.value=this.getAttribute("value")}};xn([Sr({type:Boolean,reflect:!0})],zm.prototype,"disabled",null),xn([Sr({type:String,attribute:"aria-disabled",reflect:!0})],zm.prototype,"ariaDisabled",void 0);var Hm=class extends zm{constructor(){super(...arguments),this.required=!1,this.name="",this.initialized=!1,this._events=new class{constructor(e,t){this._events=new Map,this._isConnected=!1,e.addController(this),this._host=e,this._getTarget=t}_getEventTarget(){return this._getTarget?this._getTarget():this._host}hostConnected(){let e=this._getEventTarget();for(let[t,r]of this._events)Array.isArray(r)?e.addEventListener(t,r[0],r[1]):e.addEventListener(t,r);this._isConnected=!0}hostDisconnected(){let e=this._getEventTarget();for(let[t,r]of this._events){let n=Array.isArray(r)?r[0]:r;e.removeEventListener(t,n)}this._isConnected=!1}define(e,t,r){let n=e.toString();if(this._events.has(n))throw new Error(`
							Event $ {
								n
							}
							already defined.
							`);if(r?this._events.set(n,[t,r]):this._events.set(n,t),this._isConnected){let e=this._getEventTarget();e&&e.addEventListener(n,t,r)}return t}}(this),this.ariaRole="checkbox",this._checked=!1,this._handleClick=this._events.define("click",()=>{this.disabled||this.handleInteraction()}),this._handleKeydown=this._events.define("keydown",e=>{this.disabled||"Space"===e.code&&(e.stopPropagation(),e.preventDefault(),this.handleInteraction())})}get checked(){return this._checked}set checked(e){let t=this._checked;e!==t&&(this._internals.setFormValue(e?this.getAttribute("value")||"on":null),this._checked=e,e?this.setAttribute("aria-checked","true"):this.removeAttribute("aria-checked"),this.hasAttribute("required")&&!this.checked?this._internals.setValidity({valueMissing:!0},(e=>e)(`
							This $ {
								this.ariaRole
							}
							must be on`)):this._internals.setValidity(),this.requestUpdate("checked",t))}static get styles(){return[super.styles,_t`: host(: not(faceplate -
								switch -input)) {
								height: var (--size - md);
							}

							: host {
								display: flex;
								align - items: center;
							}

							label {
								font: var (--font - 14 - 20 - regular);
								color: var (--color - neutral - content - strong);
								margin - left: var (--spacer - 2 xs);
							}

							.icon {
								border: var (--line - md) solid transparent;
								height: var (--size - md);
								font - size: var (--size - md);
							}

							: host([checked]).icon,: host([indeterminate]).icon {
								display: inline - block;
								color: var (--color - primary - background);
							}

							: host(: hover).icon {
								color: var (--color - primary - background - hover);
							}

							: host([faceplate - validity = 'invalid']).icon {
								color: var (--color - danger - content);
								pointer - events: none;
							}

							: host([aria - disabled = 'true']).icon {
								color: var (--color - neutral - content - disabled);
								pointer - events: none;
							}

							: host([required]) label::after {
								position: absolute;
								color: var (--color - danger - content);
								content: '*';
							}

							: host(: focus).icon {
								border - color: var (--color - global - focus, transparent);
								outline: none;
							}

							: host(: focus) {
								outline: none;
							}

							: host(: focus: not(: focus - visible)).icon {
								border - color: transparent;
							}
							`]}connectedCallback(){super.connectedCallback(),this.initialized||(this.initialized=!0,this.setAttribute("role",this.ariaRole),this.setAttribute("tabindex","0"))}formDisabledCallback(e){super.formDisabledCallback(e),e?this.removeAttribute("tabindex"):this.setAttribute("tabindex","0")}render(){return Qt`
							$ {
								super.render()
							} <
							label >
							<
							slot > < /slot> <
							/label>
							`}handleInteraction(){let e=new InputEvent("input",{bubbles:!0});this.dispatchEvent(e)}};xn([Sr({type:Boolean})],Hm.prototype,"required",void 0),xn([Sr({type:String})],Hm.prototype,"name",void 0),xn([Sr({type:Boolean,reflect:!0})],Hm.prototype,"checked",null);var Wm=class extends Hm{static get styles(){return[super.styles,_t`
							.outer {
								background: var (--color -
									switch -input - background -
									default);
								border - radius: var (--radius - full);
								box - shadow: var (--elevation -
									switch -input -
									default -inset);
								height: var (--size -
									switch -input - h);
								vertical - align: middle;
								width: var (--size -
									switch -input - w);
								padding: var (--line - md);
								box - sizing: border - box;
								position: relative;
								display: flex;
								align - items: center;
							}

							.knob {
								--knob - w: calc(var (--size -
									switch -input - h) - (var (--line - md) * 2));

								--translate - left: calc(var (--size -
										switch -input - w) -
									var (--knob - w) - (var (--line - md) * 2));
								--knob - center: calc(var (--knob - w) / 2);

								background: var (--color - global - white);
								border - radius: var (--radius - full);
								/* Equivalent to elevation-s - need filter to apply to psuedoelements */
								/* TODO: add drop-shadow support to design-system, this should only apply in beta */
								filter: drop - shadow(0 1 px 4 px rgba(0, 0, 0, 0.15));
								display: block;
								height: 87.5 % ;
								position: absolute;
								transform: translateX(0);
								transition: transform 0.3 s;
								width: var (--knob - w);
							}

							label {
								margin - left: var (--spacer - xs);
							}

							: host([checked]).outer {
								background: var (--color -
									switch -input - background - checked);
							}

							: host([checked]).knob {
								transform: translateX(var (--translate - left));
							}

							: host([faceplate - validity = 'invalid']).outer {
								background: var (--color - danger - content);
							}

							: host(: focus).outer {
								box - shadow: var (--elevation - focus - ring, 0 0 0 2 px
									var (--color - global - alienblue));
								outline: none;
							}

							: host(: hover).outer {
								background: var (--color -
									switch -input - background -
									default -hover);
							}

							: host([checked]: hover).outer {
								background: var (--color -
									switch -input - background - checked - hover);
							}

							/**
							 * The way this color is made needs to have blending between
							 * the "checked-hover"/"default-hover" and the "pressed-scrim" color.
							 *
							 * The only way to do this without introducing another element is with
							 * "background" and "linear-gradient".
							 *
							 * This is all in service to matching Figma.
							 **/
							: host(: active).outer {
								background: linear - gradient(
									to right,
									var (--color -
										switch -input - background -
										default -hover),
									var (--color -
										switch -input - background -
										default -hover)
								),
								linear - gradient(
									to right,
									var (--color -
										switch -input - background - pressed - scrim),
									var (--color -
										switch -input - background - pressed - scrim)
								);
							}

							: host([checked]: active).outer {
								background: linear - gradient(
									to right,
									var (--color -
										switch -input - background - checked - hover),
									var (--color -
										switch -input - background - checked - hover)
								),
								linear - gradient(
									to right,
									var (--color -
										switch -input - background - pressed - scrim),
									var (--color -
										switch -input - background - pressed - scrim)
								);
							}

							: host(: focus: not(: focus - visible)).outer {
								box - shadow: var (--elevation - focus - ring - reset);
							}

							: host([aria - disabled = 'true']) {
								opacity: 1;
							}

							: host([aria - disabled = 'true']).outer {
								background - color: var (--color -
									switch -input - background - disabled);
								box - shadow: none;
							}

							: host([checked][aria - disabled = 'true']).outer {
								background - color: var (--color -
									switch -input - background - checked - disabled);
								box - shadow: none;
							}

							: host([aria - disabled = 'true']).knob {
								background - color: var (--color -
									switch -input - background - handle - disabled);
								box - shadow: none;
							}

							: host([aria - disabled = 'true']) label {
								opacity: 0.5;
							}

							/**
							 * Knob expand animation styles - the knob consists of three parts, the
							 * core (.knob), center padding (:before), and moving part (:active).
							 * When the switch is active, the center padding expands to fill the gap
							 * between the moving part and the core knob.
							 * The downside is that the box shadow
							 */
							.knob: before,
							.knob: after {
								background: inherit;
								content: '';
								height: 100 % ;
								left: 0;
								position: absolute;
								top: 0;
								transition: transform 0.3 s;
							}

							/* The middle part of the expanded knob */
							.knob: before {
								border - radius: 0;
								transform - origin: left;
								transform: translateX(var (--knob - center)) scaleX(0);
								transition: transform 0.2 s;
								width: var (--spacer -
									switch -input - active - pl);
							}

							/* The part of the expanded knob that moves (to the left when toggling on, right for off) */
							.knob: after {
								border - radius: var (--radius - full);
								transform: translateX(0);
								width: var (--knob - w);
							}

							: host(: active).knob: after {
								transform: translateX(var (--spacer -
									switch -input - active - pl));
							}

							: host(: active).knob: before {
								transform: translateX(var (--knob - center)) scaleX(1);
							}

							: host([checked]: active).knob: after {
								transform: translateX(calc(-1 *
									var (--spacer -
										switch -input - active - pl)));
							}

							: host([checked]).knob: before {
								transform: translateX(var (--knob - center)) scaleX(0);
							}

							: host([checked]: active).knob: before {
								transform: translateX(calc(var (--knob - center) - 8 px)) scaleX(1);
							}
							`]}render(){return Qt` <
							span class = "outer" >
							<
							span class = "knob" > < /span> <
							/span>
							$ {
								super.render()
							}
							`}toggle(){this.checked=!this.checked,super.handleInteraction()}handleInteraction(){this.toggle()}};Wm=xn([_r("faceplate-switch-input")],Wm);var Gm=_t`.mute - notifications - wrapper {
								margin: var (--rem32) 0;border - radius: 8 px;background: var (--color - input -
									default);padding: var (--rem12);display: flex;justify - content: space - between;align - items: center
							}.title - icon {
								display: flex;align - items: center
							}.icon {
								font: var (--font - 24);margin - right: var (--rem20)
							}
							`,Ym=(Zn("icon-notification",Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_472_1138)"><path d="M11 18h1a2 2 0 01-4 0h3zm8-3.792v.673A1.12 1.12 0 0117.883 16H2.117A1.12 1.12 0 011 14.881v-.673a3.947 3.947 0 011.738-3.277A2.706 2.706 0 003.926 8.7V7.087a6.07 6.07 0 0112.138 0l.01 1.613a2.7 2.7 0 001.189 2.235A3.949 3.949 0 0119 14.208zm-1.25 0a2.7 2.7 0 00-1.188-2.242A3.956 3.956 0 0114.824 8.7V7.088a4.819 4.819 0 10-9.638 0v1.615a3.956 3.956 0 01-1.738 3.266 2.7 2.7 0 00-1.198 2.239v.542h15.5v-.542z"/></g><defs><clipPath id="clip0_472_1138"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
							}
							`,Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_472_1153)"><path d="M11 18h1a2 2 0 01-4 0h3zm6.263-7.07a2.699 2.699 0 01-1.189-2.23l-.005-1.61a6.069 6.069 0 10-12.138 0v1.613a2.7 2.7 0 01-1.193 2.227A3.949 3.949 0 001 14.208v.672A1.119 1.119 0 002.117 16h15.766A1.119 1.119 0 0019 14.88v-.672a3.952 3.952 0 00-1.737-3.278z"/></g><defs><clipPath id="clip0_472_1153"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
							}
							`),class extends yr{constructor(){super(...arguments),this.matrix=new _n(this),this.handleChange=async()=>{var e,t;let r=!(null!=(t=null==(e=this.shadowRoot)?void 0:e.querySelector("#mute-notifications-toggle"))&&t.hasAttribute("checked"));this.matrix.client.setRoomMutePushRule("global",this.roomId,r)}}static get styles(){return[ii,Gm]}connectedCallback(){super.connectedCallback(),this.muteNotifications=!!this.matrix.client.getRoomPushRule("global",this.roomId)}render(){return Qt` <
							div class = "mute-notifications-wrapper" >
							<
							div class = "title-icon" >
							<
							icon - notification class = "icon" > < /icon-notification> <
							p >
							$ {
								ka("Mute notifications", {
									desc: "Room settings / Notifications: mute"
								})
							} <
							/p> <
							/div> <
							faceplate -
							switch -input name = "mute"
							id = "mute-notifications-toggle"
							.checked = "${this.muteNotifications}"
							@input = "${this.handleChange}" >
							< /faceplate-switch-input> <
							/div>
							`}});v([Sr({type:String})],Ym.prototype,"roomId",2),v([Er()],Ym.prototype,"muteNotifications",2),Ym=v([_r("rs-room-settings-notifications")],Ym);var Qm,Jm;Zn("icon-kick",Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_1580_221)"><path d="M10 5.5a4.5 4.5 0 100 9 4.5 4.5 0 000-9zM6.75 10a3.227 3.227 0 01.55-1.812l4.512 4.512A3.248 3.248 0 016.75 10zm5.95 1.812L8.188 7.3a3.248 3.248 0 014.512 4.512zm7.16-2.36l-4.451-7.885A1.116 1.116 0 0014.437 1H5.562a1.116 1.116 0 00-.971.567L.145 9.45a1.111 1.111 0 000 1.1l4.445 7.882a1.118 1.118 0 00.972.568h8.875a1.116 1.116 0 00.972-.567l4.446-7.883a1.11 1.11 0 000-1.098h.005zm-5.5 8.3H5.64L1.27 10l4.37-7.75h8.719l4.37 7.75-4.37 7.752z"/></g><defs><clipPath id="clip0_1580_221"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
							}
							`,Jt`
							$ {
								Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_1580_227)"><path d="M10 6.75a3.213 3.213 0 00-1.7.492l4.458 4.458c.32-.51.49-1.098.492-1.7A3.254 3.254 0 0010 6.75z"/><path d="M19.856 9.452l-4.447-7.885A1.116 1.116 0 0014.437 1H5.562a1.116 1.116 0 00-.971.567L.145 9.45a1.111 1.111 0 000 1.1l4.445 7.882a1.118 1.118 0 00.972.568h8.875a1.116 1.116 0 00.972-.567l4.446-7.883a1.11 1.11 0 000-1.098zM10 14.75A4.75 4.75 0 1114.75 10 4.756 4.756 0 0110 14.75z"/><path d="M6.75 10A3.254 3.254 0 0010 13.25a3.212 3.212 0 001.7-.492L7.242 8.3c-.32.51-.49 1.098-.492 1.7z"/></g><defs><clipPath id="clip0_1580_227"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')
							}
							`);function Xm(e){return new Error(`
							Unsupported type File given
							for field $ {
								e
							}.Use encoding type $ {
								Jm.FormData
							}
							for file upload.
							`)}function Zm(e){if(!e)return;return function(e){let t={};for(let r of e){let[e,n]=r;if(n instanceof File)throw Xm(e);Object.prototype.hasOwnProperty.call(t,e)?Array.isArray(t[e])?t[e].push(n):t[e]=[t[e],n]:t[e]=n}return t}(new FormData(e))}function ey(e){return function(t){t.stopPropagation(),t.preventDefault();let r=Zm(t.target);!r||e(r)}}!function(e){e.Omit="omit",e.SameOrigin="same-origin",e.Include="include",e.SameDomain="same-domain"}(Qm||(Qm={})),function(e){e.UrlEncoded="application/x-www-form-urlencoded",e.FormData="multipart/form-data",e.JSON="application/json"}(Jm||(Jm={}));var ty=_t`
							form {
								display: flex;flex - direction: column;gap: var (--spacer - xs)
							}
							input {
								font - family: var (--font - sans);
								color: var (--color - input - text);
								padding: .5 rem .75 rem;
								margin - bottom: .5 rem;
								background: var (--color - input -
									default);
								border: var (--color - input -
									default) solid
								var (--line - input - border);
								border - radius: var (--radius - sm);
								box - shadow: none;
								box - sizing: border - box;
								font - size: 1 rem
							}
							input: disabled {
								cursor: not - allowed;opacity: .5
							}
							input: invalid {
								border - color: var (--color - danger - content)
							}
							label {
								text - transform: var (--misc - label - text - transform);
								letter - spacing: var (--misc - label - letter - spacing);
								font: var (--font - label -
									default);
								color: var (--color - label -
									default)
							}.buttons {
								display: flex;flex - direction: row - reverse;gap: var (--spacer - sm);margin - top: var (--spacer - sm)
							}
							ul {
								list - style - type: none;
								padding - left: 0;
								border - radius: 4 px;
								width: fit - content;
								border: 1 px solid
								var (--color - tone - 5);
								width: 100 %
							}
							ul li {
								padding: .5 rem .75 rem;border - block - end: 1 px solid
								var (--color - tone - 5)
							}
							ul li: last - child {
								border - block - end: none
							}
							h2 {
								font: var (--font - title - h2)
							}
							h3 {
								font: var (--font - title - h3)
							}
							`,ry=class extends yr{constructor(){super(...arguments),this.roomNameInputValue="",this.avatars=new zg(this),this.matrix=new _n(this),this.roomController=new wn(this),this.handleRoomRenameFormSubmit=ey(async e=>{try{await this.matrix.client.setRoomName(this.roomController.getRoom().roomId,e.name),this.dispatchEvent(new La({level:Ma.info,message:ka("Room successfully updated",{desc:"Room updated toast message"})})),fi(this,(({id:e})=>ki({source:"chat_settings",action:"save",noun:"rename_group"},{chat:{id:e}}))({id:this.roomController.getRoom().roomId}))}catch{this.dispatchEvent(new La({level:Ma.error,message:ka("Unable to update the room",{desc:"Room update error toast message"})}))}})}static get styles(){return[ii,ty]}connectedCallback(){super.connectedCallback(),this.roomController.on(Qr.Name,()=>{this.requestUpdate()}),this.roomController.on(Jr.Members,()=>{this.requestUpdate()}),this.roomNameInputValue=this.roomController.getRoom().name}canRenameRoom(){let e=this.matrix.client.getUserId();return!!e&&this.roomController.getRoom().currentState.maySendEvent(Vr.RoomName,e)}isRoomNameChanged(){return this.roomController.getRoom().name!==this.roomNameInputValue}renderAvatar(e,t){return Kg(e.userId)?Qt` <
							a href = "${`${Ig}/user/${e.name}/`}"
							target = "_blank"
							class = "flex no-underline" >
							$ {
								hm(t)
							} <
							/a>
							`:hm(t)}renderMember(e){let t=this.avatars.getAvatar(e.userId);return Qt` <
							li class = "flex gap-sm items-center" >
							<
							span class = "${null!=t&&t.isBlocked?"
							opacity - 50 ":"
							"}" >
							$ {
								this.renderAvatar(e, t)
							} <
							/span> <
							span class = "${null!=t&&t.isBlocked?"
							text - coolgray - 450 ":"
							"}" >
							$ {
								e.name
							}
							$ {
								100 === e.powerLevel ? Qt`&bull; <span class="text-action-secondary">Host</span>` : ""
							}
							$ {
								null != t && t.isNSFW ? Qt`&bull; <span class="text-coolgray-450">NSFW</span>` : ""
							}
							$ {
								null != t && t.isBlocked ? Qt`&bull; <icon-block></icon-block>` : ""
							} <
							/span> <
							div class = "flex flex-1 justify-end" >
							$ {
								function(e, t, r, n) {
									return (() => {
										let e = t.getUserId();
										if (!e || n === e) return !1;
										let i = r.getMember(e);
										return !!i && r.currentState.hasSufficientPowerLevelFor("kick", i.powerLevel)
									})() ? Qt`
    <faceplate-tooltip position="top">
      ${vn({appearance:"plain",size:an.Small,attributes:{slot:"trigger",type:"button",title:ka("Kick",{desc:"Room settings / About: kick user action tooltip"}),onclick:async()=>{try{await t.kick(r.roomId,n)}catch{e.dispatchEvent(new La({level:Ma.error,message:ka("Unable to kick user",{desc:"Room settings / About: kick user error message"})}))}}},leadingIcon:Qt` < icon - kick > < /icon-kick>`})}
									$ {
										ka("Kick", {
											desc: "Room settings / About: kick user action tooltip"
										})
									} <
									/faceplate-tooltip>
									`:null}(this,this.matrix.client,this.roomController.getRoom(),e.userId)}
        </div>
      </li>
    `
								}
								renderForm() {
									return Qt`
      <form
        @submit="${this.handleRoomRenameFormSubmit}"
        @reset="${()=>{this.roomNameInputValue=this.roomController.getRoom().name}}"
      >
        <label for="name">${ka("Name",{desc:"Room name input label"})}</label>
        <input
          id="name"
          type="text"
          name="name"
          autocomplete="off"
          value="${this.roomController.getRoom().name}"
          required
          @input="${e=>{this.roomNameInputValue=e.target.value}}"
          @change="${e=>{this.roomNameInputValue=e.target.value}}"
          ?disabled="${!this.canRenameRoom()}"
        />
        ${this.canRenameRoom()?Qt`
              <div class="buttons">
                ${vn({appearance:"primary",size:an.Small,children:ka("Update Name",{desc:'Room update "Save" button'}),attributes:{type:"submit",disabled:!this.isRoomNameChanged()||void 0}})}
                ${vn({size:an.Small,children:ka("Cancel",{desc:"Cancel button"}),attributes:{type:"reset"}})}
              </div>
            `:null}
      </form>
    `
								}
								renderMembers() {
									let e = this.roomController.getRoom().getJoinedMembers();
									return Qt`
      <h3>${ka("Members",{desc:'Room settings / About: "Members" section title'})}</h3>
      <ul>
        ${co(e,e=>e.userId,e=>this.renderMember(e))}
      </ul>
    `
								}
								renderInvitedUsers() {
									let e = this.roomController.getRoom().getMembersWithMembership("invite");
									return 0 === e.length ? null : Qt`
      <h3>
        ${ka("Invited users",{desc:'Room settings / About: "Invited users" section title'})}
      </h3>
      <ul>
        ${co(e,e=>e.userId,e=>this.renderMember(e))}
      </ul>
    `
								}
								renderBannedUsers() {
									let e = this.roomController.getRoom().getMembersWithMembership("ban");
									return 0 === e.length ? null : Qt`
      <h3>
        ${ka("Banned users",{desc:'Room settings / About: "Banned users" section title'})}
      </h3>
      <ul>
        ${co(e,e=>e.userId,e=>this.renderMember(e))}
      </ul>
    `
								}
								render() {
									return Qt`
      <h2>${ka("About",{desc:"Room settings / About: section title"})}</h2>
      <rs-room-settings-notifications
        .roomId="${this.roomController.getRoom().roomId}"
      ></rs-room-settings-notifications>
      ${this.renderForm()} ${this.renderMembers()} ${this.renderInvitedUsers()}
      ${this.renderBannedUsers()}
    `
								}
							}; v([Sr()], ry.prototype, "room", 2), v([Er()], ry.prototype, "roomNameInputValue", 2), ry = v([_r("rs-room-settings-about")], ry);
							var ny = _t`:host{border-radius:var(--rem8);border-radius:var(--radius-sm);padding:var(--spacer-xs) 0}input{font-family:var(--font-sans);color:var(--color-input-text);padding:.5rem .75rem;margin-bottom:.5rem;background:var(--color-input-default);border:var(--color-input-default) solid var(--line-input-border);border-radius:var(--radius-sm);box-shadow:none;box-sizing:border-box;font-size:1rem;margin:0;padding:0;flex:1;min-width:20px;background-color:transparent;border:0}input:disabled{cursor:not-allowed;opacity:.5}input:invalid{border-color:var(--color-danger-content)}input:focus-visible{outline:0}.input-bar{display:flex;background-color:var(--color-tone-6);border-radius:var(--rem8);margin:var(--spacer-xs) var(--spacer-md);padding:var(--spacer-2xs);gap:var(--spacer-2xs);min-height:22px;flex-wrap:wrap}.input-bar-item{display:flex;background-color:var(--color-tone-4);border-radius:var(--rem12);font:var(--font-button-b4);padding:var(--spacer-2xs) var(--spacer-xs);align-items:center}.input-bar-item:focus{outline:-webkit-focus-ring-color auto 1px}.search-result{border:0;border-bottom:1px solid var(--color-tone-6);background-color:transparent;height:38px;display:grid;grid-template-columns:min-content 1fr min-content;grid-column-gap:var(--spacer-xs);align-items:center;text-align:left;padding:0 var(--spacer-md);width:100%;cursor:pointer}.search-result:hover{background-color:var(--color-tone-5)}.search-result:last-of-type{border:0}.checkmark{width:15px;height:15px;fill:#848a8c}.checkmark.selected{fill:#0079d3}.search-results-empty{padding:0 var(--spacer-md);font-style:italic}`, iy = class extends yr {
								constructor() {
									super(), this.matrix = new _n(this), this.userSearchQuery = new _a(this, e => this.search(e)), this.avatars = new zg(this), this.value = [], this.search = async e => {
										if (e.length < 3) return null;
										let t = this.matrix.client.getUserId();
										return (await this.matrix.client.searchUserDirectory({
											term: e
										})).results.filter(e => e.user_id !== t)
									}, this.handleUserInput = va(() => {
										let e = this.shadowRoot.querySelector("input").value;
										this.userSearchQuery.cancel(), this.userSearchQuery.execute(e)
									}, 500), this.internals = this.attachInternals()
								}
								static get styles() {
									return [ii, ny]
								}
								isUserSelected(e) {
									return this.value.some(t => t.user_id === e)
								}
								setValue(e) {
									this.value = e, this.internals.setFormValue(JSON.stringify(this.value)), this.dispatchEvent(new Event("change"))
								}
								handleOptionClick(e) {
									let t = this.isUserSelected(e.user_id) ? this.value.filter(t => t.user_id !== e.user_id) : [...this.value, e];
									this.searchInput.value = "", this.searchInput.focus(), this.setValue(t)
								}
								handleSelectedItemKeyDown(e, t) {
									("Backspace" === e.key || "Delete" === e.key) && (e.preventDefault(), this.searchInput.focus(), this.setValue(this.value.filter(e => e.user_id !== t.user_id)))
								}
								handleSearchInputKeyDown(e) {
									var t, r;
									0 === this.searchInput.selectionStart && "Backspace" === e.key && (e.preventDefault(), null == (r = null == (t = this.shadowRoot) ? void 0 : t.querySelector(".input-bar-item:last-of-type")) || r.focus())
								}
								renderCheckmark(e) {
									return e ? Qt`<svg class="checkmark selected" viewBox="0 0 20 20">
        <g>
          <path
            d="M10,0.4c-5.3,0-9.6,4.3-9.6,9.6s4.3,9.6,9.6,9.6s9.6-4.3,9.6-9.6S15.3,0.4,10,0.4C10,0.4,10,0.4,10,0.4z M8.8,13.1H8.5H8.2 L8,12.9l-1.9-1.9l0.9-0.9l1.6,1.6l4.6-4.6l0.9,0.9L8.8,13.1z"
          ></path>
        </g>
      </svg>` : Qt`<svg class="checkmark" viewBox="0 0 20 20">
      <g>
        <circle cy="10" cx="10" r="8" fill="transparent" stroke="#D6D6D6"></circle>
      </g>
    </svg>`
								}
								renderSearchResults() {
									return this.userSearchQuery.data ? 0 === this.userSearchQuery.data.length ? Qt`<div class="search-results-empty">
        ${ka("No users found",{desc:"Users multiselect: no users found message"})}
      </div>` : co(this.userSearchQuery.data, e => e.user_id, e => Qt`<button class="search-result" @click="${()=>this.handleOptionClick(e)}">
          ${hm(this.avatars.getAvatar(e.user_id),"xs")} ${e.display_name}
          ${this.renderCheckmark(this.isUserSelected(e.user_id))}
        </button>`) : null
								}
								renderValue() {
									return co(this.value, e => e.user_id, e => Qt`<div
          class="input-bar-item"
          tabindex="0"
          @keydown="${t=>this.handleSelectedItemKeyDown(t,e)}"
        >
          ${e.display_name}
        </div>`)
								}
								render() {
									return Qt`
      <div class="input-bar">
        ${this.renderValue()}
        <input
          class="search-input"
          type="text"
          placeholder="${0===this.value.length?ka("Type usernames",{desc:"Users multiselect: placeholder text"}):""}"
          @keydown="${this.handleSearchInputKeyDown}"
          @input="${()=>this.handleUserInput()}"
        />
      </div>
      ${this.renderSearchResults()}
    `
								}
							}; iy.formAssociated = !0, v([Sr({
								type: Array
							})], iy.prototype, "value", 2), v([Tr("input")], iy.prototype, "searchInput", 2), iy = v([_r("rs-users-multiselect")], iy);
							var oy = _t`.invite-container{border-radius:8px;background:var(--color-input-default);padding:var(--rem12);display:flex;justify-content:space-between;align-items:center}.title-icon{display:flex;align-items:center}.invite-icon{font:var(--font-24);margin-right:var(--rem20)}.invite-link-wrapper{margin-top:var(--rem32)}`, sy = (Zn("icon-link", Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M14.052 12.5a3.726 3.726 0 01-1.075 2.409c-.471.471-.914.922-1.357 1.373-.443.451-.881.9-1.348 1.366a3.767 3.767 0 01-5.318 0 3.765 3.765 0 010-5.317c.472-.472.915-.923 1.358-1.374.443-.451.88-.9 1.348-1.365a3.858 3.858 0 014.192-.745l.8-.806.129-.131a4.95 4.95 0 00-6 .8c-.472.471-.915.922-1.357 1.373-.442.451-.881.9-1.35 1.365a5.02 5.02 0 000 7.086 5.017 5.017 0 007.086 0c.47-.471.913-.923 1.357-1.374.444-.451.88-.9 1.348-1.366a5.006 5.006 0 001.374-4.483L14.052 12.5z"/><path d="M15.93 1.467a5.01 5.01 0 00-7.085 0c-.471.471-.913.923-1.357 1.374-.444.451-.881.9-1.347 1.366a4.969 4.969 0 00-1.377 4.484L5.946 7.5a3.723 3.723 0 011.077-2.41c.47-.471.914-.922 1.357-1.373.443-.451.88-.9 1.348-1.366a3.76 3.76 0 115.317 5.318c-.471.471-.913.922-1.357 1.373-.444.451-.88.9-1.348 1.366a3.854 3.854 0 01-4.192.744c-.27.273-.543.548-.806.817l-.121.121a4.952 4.952 0 006-.8c.47-.471.913-.922 1.356-1.374.443-.452.88-.9 1.348-1.365a5.013 5.013 0 000-7.086l.005.002z"/></svg>')}`, Jt`${Tn('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><g clip-path="url(#clip0_473_119)"><path d="M17.547 5.239a5.2 5.2 0 01-1.535 3.705c-.442.441-.858.866-1.274 1.289-.438.447-.876.893-1.342 1.359a5.175 5.175 0 01-5.981.993l1.57-1.57a3.292 3.292 0 003-.838c.461-.461.9-.9 1.329-1.344.429-.444.84-.857 1.287-1.3a3.238 3.238 0 10-4.58-4.58c-.456.454-.883.89-1.311 1.326-.428.436-.856.865-1.31 1.321-.028.029-.047.063-.075.092l.038-.136-2.856 2.876a5.208 5.208 0 011.48-4.249c.45-.449.871-.879 1.293-1.309.422-.43.865-.881 1.324-1.34a5.24 5.24 0 017.408 0 5.2 5.2 0 011.535 3.705zm-4.764 8.942c-.062.074-.115.155-.184.224-.447.447-.868.876-1.287 1.3-.419.424-.868.883-1.329 1.344a3.317 3.317 0 01-4.581 0 3.244 3.244 0 010-4.58c.453-.453.88-.888 1.306-1.322.426-.434.855-.872 1.311-1.326a3.181 3.181 0 013.018-.859l1.536-1.555a5.173 5.173 0 00-5.968 1c-.459.459-.892.9-1.324 1.34-.432.44-.843.86-1.293 1.309a5.24 5.24 0 007.412 7.41c.466-.466.9-.912 1.342-1.359.416-.423.832-.848 1.274-1.289a5.2 5.2 0 001.535-3.7 5.287 5.287 0 00-.064-.655l-2.704 2.718z"/></g><defs><clipPath id="clip0_473_119"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>')}`), class extends yr {
								constructor() {
									super(...arguments), this.matrix = new _n(this), this.changeJoinRule = () => {
										var e, t, r, n;
										(null == (t = null == (e = this.shadowRoot) ? void 0 : e.querySelector("#invite-via-link-toggle")) ? void 0 : t.hasAttribute("checked")) ? null == (n = this.matrix) || n.client.sendStateEvent(this.room.roomId, Vr.RoomJoinRules, {
											join_rule: "private"
										}): null == (r = this.matrix) || r.client.sendStateEvent(this.room.roomId, Vr.RoomJoinRules, {
											join_rule: "public"
										})
									}, this.copyToClipboard = () => {
										let e = document.body.scrollTop,
											t = document.body.scrollLeft,
											r = document.createElement("textarea");
										r.value = window.location.href, document.body.appendChild(r), r.select();
										try {
											document.execCommand("copy"), this.dispatchEvent(new La({
												level: Ma.info,
												message: ka("Link copied!", {
													desc: "Room settings/ Invite people: Link copied notification"
												})
											}))
										} catch {
											return this.dispatchEvent(new La({
												level: Ma.error,
												message: ka("Could not copy the link", {
													desc: "Room settings/ Invite people: ould not copy the link alert"
												})
											})), !1
										}
										return document.body.removeChild(r), document.body.scrollTop = e, document.body.scrollLeft = t, !0
									}
								}
								static get styles() {
									return [ii, oy]
								}
								connectedCallback() {
									super.connectedCallback(), this.matrix.on(qr.Event, e => {
										e.getType() === Vr.RoomJoinRules && this.requestUpdate()
									})
								}
								render() {
									var e, t;
									return Qt`
      <div class="invite-via-link-group">
        <div class="invite-via-link-toggle invite-container">
          <div class="title-icon">
            <icon-chat-group class="invite-icon"></icon-chat-group>
            <p>
              ${ka("Group join via invite link",{desc:"Room settings / Invite people: join rule toggle"})}
            </p>
          </div>
          <faceplate-switch-input
            name="my_pref"
            id="invite-via-link-toggle"
            .checked="${"public"===(null==(e=this.room)?void 0:e.getJoinRule())}"
            @input="${this.changeJoinRule}"
          ></faceplate-switch-input>
        </div>
        ${"public"===(null==(t=this.room)?void 0:t.getJoinRule())?Qt`
              <div class="invite-link-wrapper invite-container">
                <div class="title-icon">
                  <icon-link class="invite-icon"></icon-link>
                  <p>
                    ${ka("Invite with link",{desc:"Room settings / Invite people: Invite with link"})}
                  </p>
                </div>
                ${vn({appearance:"primary",children:ka("Copy",{desc:"Room settings / Invite people: Copy button"}),attributes:{type:"button",onclick:()=>this.copyToClipboard()}})}
              </div>
            `:null}
      </div>
    `
								}
							}); v([Sr({
								type: Object
							})], sy.prototype, "room", 2), sy = v([_r("rs-room-settings-invite-link")], sy);
							var ay = _t`h2{font:var(--font-title-h2)}form{display:flex;flex-direction:column;gap:var(--spacer-xs)}.buttons{flex:1;display:flex;flex-direction:row-reverse;align-items:end;gap:var(--spacer-sm);margin:var(--spacer-sm) 0}`, cy = class extends(mn(yr)) {
								constructor() {
									super(...arguments), this.handleFormSubmit = ey(async e => {
										if (!this.matrix || !this.room) return;
										let t = JSON.parse(e.users);
										try {
											for (let e of t) await this.matrix.invite(this.room.roomId, e.user_id);
											this.form.reset(), this.dispatchEvent(new La({
												level: Ma.info,
												message: t.length > 1 ? ka("Users successfully invited to the room", {
													desc: "Room settings / Invite people: successful message"
												}) : ka("User successfully invited to the room", {
													desc: "Room settings / Invite people: successful message"
												})
											}))
										} catch {
											this.dispatchEvent(new La({
												level: Ma.error,
												message: ka("Unable to invite one or more users", {
													desc: "Room settings / Invite people: error message"
												})
											}))
										}
									})
								}
								static get styles() {
									return [ii, ay]
								}
								render() {
									let e = this.usersMultiSelect ? this.usersMultiSelect.value.length : 0;
									return Qt`<h2>
        ${ka("Invite people",{id:"invite-section-title",desc:"Room settings / Invite people: title"})}
      </h2>
      <rs-room-settings-invite-link .room="${this.room}"></rs-room-settings-invite-link>
      <form @submit="${this.handleFormSubmit}">
        <rs-users-multiselect
          id="users"
          name="users"
          @change="${()=>this.requestUpdate()}"
        ></rs-users-multiselect>
        <div class="buttons">
          ${vn({appearance:"primary",size:an.Small,children:ka("Invite",{desc:"Room settings / Invite people: Invite button"}),attributes:{type:"submit",disabled:0===e||void 0}})}
        </div>
      </form>`
								}
							}; v([Sr({
								type: Object
							})], cy.prototype, "room", 2), v([Tr("form")], cy.prototype, "form", 2), v([Tr("rs-users-multiselect")], cy.prototype, "usersMultiSelect", 2), cy = v([_r("rs-room-settings-invite")], cy);
							var ly = !1; Promise.resolve();

							function uy() {
								let e = document.activeElement;
								return e ? function(e) {
									let t = e;
									for (; t && t.shadowRoot && t.shadowRoot.activeElement;) t = t.shadowRoot.activeElement;
									return t
								}(e) : null
							}

							function dy() {
								let e = uy();
								return e instanceof HTMLElement ? e : null
							}

							function hy(e) {
								let t = e.hasAttribute("tabindex");
								e.blur(), t || e.setAttribute("tabindex", "0"), e.focus(), t || e.removeAttribute("tabindex")
							}

							function fy(e) {
								ly || (ly = !0, hy(e), new Promise(t => {
									setTimeout(() => {
										let r = uy();
										e !== r && hy(e), ly = !1, t()
									})
								}))
							}
							var py, vy, gy = new class {
								constructor(e) {
									this._opts = e, this._frames = []
								}
								get top() {
									return this._frames[this._frames.length - 1]
								}
								add(e) {
									let t = this.top;
									this._frames.push(e), t ? this._opts.framePaused && this._opts.framePaused(t) : this._opts.stackEntered && this._opts.stackEntered(e), this._opts.frameAdded && this._opts.frameAdded(e)
								}
								_pop() {
									let e = this._frames.pop();
									if (!e) return;
									let t = this.top;
									this._opts.frameRemoved && this._opts.frameRemoved(e), t ? this._opts.frameResumed && this._opts.frameResumed(t) : this._opts.stackExited && this._opts.stackExited(e)
								}
								remove(e) {
									let t = this._frames.indexOf(e);
									t < 0 || (t === this._frames.length - 1 ? this._pop() : (this._frames.splice(t, 1), this._opts.frameRemoved && this._opts.frameRemoved(e)))
								}
							}({
								stackEntered() {
									vy = dy(), document.body.style.pointerEvents && (py = document.body.style.pointerEvents), document.body.style.pointerEvents = "none", window.addEventListener("keydown", my), window.addEventListener("focusin", yy)
								},
								stackExited(e) {
									vy ? fy(vy) : e.blur(), py ? document.body.style.pointerEvents = py : document.body.style.removeProperty("pointer-events"), window.removeEventListener("keydown", my), window.removeEventListener("focusin", yy)
								},
								frameAdded(e) {
									e.inFocusTrap = !0, e.focusManager.refresh(), e.focusManager.focus()
								},
								frameRemoved(e) {
									e.inFocusTrap = !1
								},
								framePaused(e) {
									e.focusManager.saveFocus()
								},
								frameResumed(e) {
									e.focusManager.restoreFocus()
								}
							});

							function my(e) {
								let t = gy.top;
								!t || ("Escape" === e.key ? (e.stopPropagation(), t.close()) : function(e, t) {
									if ("Tab" !== e.key) return;
									if (t.focusManager.size < 1) return e.preventDefault();
									let r = dy();
									if (r) {
										if (1 === t.focusManager.size && r === t.focusManager.first) return e.preventDefault();
										if (e.shiftKey) {
											if (r === t.focusManager.first) t.focusManager.focusLast(), e.preventDefault()
										} else if (r === t.focusManager.last) t.focusManager.focusFirst(), e.preventDefault()
									}
								}(e, t))
							}

							function yy(e) {
								let t = gy.top;
								t && function(e, t) {
									let r = dy();
									!r || r === t || t.focusManager.has(r) || t.focusManager.focusFirst() && e.preventDefault()
								}(e, t)
							}
							var by = ["a[href]", "area[href]", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", '[tabindex="0"]', "[faceplate-focusable]"].join(","), _y = Qt`
  <style>
    :host {
      top: 50%;
      transform: translateY(-50%);
      position: fixed;
    }
  </style>
`, wy = Qt`
  <style>
    :host {
      position: absolute;
    }
  </style>
`, Sy = class extends yr {
								constructor() {
									super(...arguments), this.focusManager = new class extends class {
										constructor(e) {
											this._focusableElements = null, this._firstFocusable = null, this._lastFocusable = null, this._savedFocusable = null, this._target = e
										}
										get size() {
											var e;
											return (null === (e = this._focusableElements) || void 0 === e ? void 0 : e.size) || 0
										}
										get first() {
											return this._firstFocusable
										}
										get last() {
											return this._lastFocusable
										}
										_focusTarget(e) {
											var t;
											return e ? (fy(e), !0) : (null === (t = dy()) || void 0 === t || t.blur(), !1)
										}
										_getActiveInternalElement() {
											if (!this._focusableElements) return null;
											let e = dy();
											return e && this._focusableElements.has(e) ? e : null
										}
										has(e) {
											var t;
											return (null === (t = this._focusableElements) || void 0 === t ? void 0 : t.has(e)) || !1
										}
										refresh() {
											let e = this._target.querySelectorAll(by),
												t = [];
											if (e.length) {
												for (let r = 0; r < e.length; r++) {
													let n = e[r];
													if ("delegatedFocusElements" in n) {
														let e = n.delegatedFocusElements;
														if (e)
															for (let r of e) t.push(r)
													} else t.push(n)
												}
												this._firstFocusable = t[0], this._lastFocusable = t[t.length - 1], this._focusableElements = new Set(t)
											}
										}
										focus() {
											if (this._focusableElements)
												for (let e of this._focusableElements)
													if (e.autofocus) return fy(e), !0;
											return this._focusTarget(this._firstFocusable)
										}
										blur() {
											var e;
											null === (e = this._savedFocusable) || void 0 === e || e.blur()
										}
										focusFirst() {
											return this._focusTarget(this._firstFocusable)
										}
										focusLast() {
											return this._focusTarget(this._lastFocusable)
										}
										saveFocus() {
											this._savedFocusable = this._getActiveInternalElement()
										}
										restoreFocus() {
											this._focusTarget(this._savedFocusable)
										}
									} {
										constructor(e, t) {
											super(t), e.addController(this)
										}
										hostConnected() {
											this.refresh()
										}
									}(this, this), this.open = !1, this.returnValue = "", this.modal = !1, this._inFocusTrap = !1
								}
								get inFocusTrap() {
									return this._inFocusTrap
								}
								set inFocusTrap(e) {
									if (this._inFocusTrap !== e)
										if (this._inFocusTrap = e, e) {
											let e = window.getComputedStyle(this).boxShadow;
											e && (this.dataset.faceplateDialogPreviousShadow = e, this.style.boxShadow = `${e}, 0 0 0 max(100vw, 100vh) var(--color-scrim)`)
										} else this.dataset.faceplateDialogPreviousShadow ? this.style.boxShadow = this.dataset.faceplateDialogPreviousShadow : this.style.removeProperty("boxShadow")
								}
								get isFocusEnabled() {
									return this === gy.top
								}
								disconnectedCallback() {
									this.modal && gy.remove(this)
								}
								close(e) {
									void 0 !== e && (this.returnValue = e);
									let t = hi("faceplate-close");
									this.dispatchEvent(t), !t.defaultPrevented && (this.open = !1, this.modal && gy.remove(this))
								}
								show() {
									this.modal = !1, this.open = !0, this.focusManager.focusFirst()
								}
								showModal() {
									if (this.open) throw new Error('The element already has an "open" attribute, and therefore cannot be opened modally');
									this.modal = !0, this.open = !0, gy.add(this)
								}
								static get styles() {
									return _t`
      :host {
        display: none;
        left: 0;
        right: 0;
        width: -moz-fit-content;
        width: fit-content;
        background: var(--color-ui-modalbackground);
        border-radius: 4px;
        margin: auto;
        padding: 1rem;
        box-shadow: var(--boxshadow-modal);
        pointer-events: all;
        max-width: 95vw;
        max-height: 95vh;
        overflow: auto;
      }

      :host([open]) {
        display: block;
        z-index: 1;
      }

      .backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: -1;
      }
    `
								}
								render() {
									return Qt`
      ${this.modal?_y:wy}
      <div class=${this.modal?"backdrop":""}></div>
      <slot></slot>
    `
								}
							}; xn([Sr({
								type: Boolean,
								reflect: !0
							})], Sy.prototype, "open", void 0), xn([Sr({
								type: Boolean,
								attribute: !1
							})], Sy.prototype, "modal", void 0), xn([Er()], Sy.prototype, "inFocusTrap", null), Sy = xn([_r("faceplate-dialog")], Sy);
							var Ey = _t`faceplate-dialog{padding:0;width:450px;z-index:var(--layer-modal)}header{font:var(--font-title-h4);padding:var(--spacer-xs) var(--spacer-md);border-bottom:1px solid var(--color-tone-5);display:flex;align-items:center;justify-content:space-between}header button{margin-right:calc(-1 * var(--spacer-xs))}main{padding:var(--spacer-md);font:var(--font-body)}footer{display:flex;flex-direction:row-reverse;padding:var(--spacer-md);gap:var(--spacer-sm);background-color:var(--color-tone-5)}`, ky = class extends yr {
									constructor() {
										super(...arguments), this.open = !1, this.dispatchConfirmEvent = () => {
											this.dispatchEvent(new CustomEvent("confirm"))
										}, this.dispatchCancelEvent = () => {
											this.dispatchEvent(new CustomEvent("cancel"))
										}, this.handleFaceplateClose = () => {
											this.open && this.dispatchCancelEvent()
										}
									}
									static get styles() {
										return [ii, Ey]
									}
									updated(e) {
										var t, r, n, i;
										super.updated(e), e.has("open") && (this.open ? null == (r = null == (t = this.shadowRoot) ? void 0 : t.querySelector("faceplate-dialog")) || r.showModal() : null == (i = null == (n = this.shadowRoot) ? void 0 : n.querySelector("faceplate-dialog")) || i.close())
									}
									render() {
										return Qt`
      <faceplate-dialog @faceplate-close="${this.handleFaceplateClose}">
        <header>
          <slot name="header">${ka("Are you sure?",{desc:"Confirmation modal: title"})}</slot>
          ${vn({appearance:"plain",size:an.Small,attributes:{className:"text-tone-2 w-xl",type:"button",onclick:this.dispatchCancelEvent},leadingIcon:Qt` < icon - close > < /icon-close>`})} <
											/header> <
											main >
											<
											slot > < /slot> <
											/main> <
											footer >
											$ {
												vn({
													appearance: "primary",
													size: an.Small,
													children: Qt`<slot name="confirm">${ka("Ok",{desc:"Ok button label"})}</slot>`,
													attributes: {
														type: "button",
														onclick: this.dispatchConfirmEvent
													}
												})
											}
										$ {
											vn({
												size: an.Small,
												children: Qt`<slot name="cancel">${ka("Cancel",{desc:"Cancel button"})}</slot>`,
												attributes: {
													type: "button",
													onclick: this.dispatchCancelEvent
												}
											})
										} <
										/footer> <
										/faceplate-dialog>
										`}};v([Sr({type:Boolean})],ky.prototype,"open",2),ky=v([_r("rs-confirmation-modal")],ky);var Ty=class extends CustomEvent{constructor(e){super("leave-room",{detail:e,bubbles:!0,composed:!0})}},Iy=_t`
										button {
											padding: var (--size - xs) var (--size - sm);text - align: left;border: 0;border - radius: var (--size - xs);background - color: var (--color - tone - 7);width: 100 %
										}
										button.active {
											background - color: var (--color - tone - 6)
										}
										button: hover {
											background - color: var (--color - tone - 6)
										}
										`,Ry=class extends yr{constructor(){super(...arguments),this.isConfirmationOpen=!1,this.leaveChat=async()=>{if(!this.room)return;this.isConfirmationOpen=!1;let e=this.room.roomId,t=this.room.getMembers().length;await this.room.client.leave(e),this.dispatchEvent(new Ty(this.room)),fi(this,(({id:e,type:t,number_members:r,shown_history:n})=>ki({source:"chat_settings",action:"confirm",noun:"leave_chat"},{chat:{id:e,type:t,number_members:r,shown_history:n}}))({id:e,type:2===t?"direct":"group",number_members:t}))}}static get styles(){return[Iy]}render(){return Qt` <
										button @click = "${()=>this.isConfirmationOpen=!0}" >
											$ {
												ka("Leave room", {
													desc: "Settings navigation: Leave room"
												})
											} <
											/button> <
											rs - confirmation - modal ?
											open = "${this.isConfirmationOpen}"
										@confirm = $ {
											this.leaveChat
										}
										@cancel = "${()=>this.isConfirmationOpen=!1}" >
											<
											span slot = "header" > $ {
												ka("Leave room?", {
													desc: "Leave room: modal header"
												})
											} < /span> <
											span slot = "confirm" > $ {
												ka("Yes, Leave", {
													desc: "Leave room: primary button"
												})
											} < /span>
										$ {
											ka("Once you leave, you won't get new messages and will need another invite to rejoin.", {
												desc: "Leave room: description text"
											})
										} <
										/rs-confirmation-modal>
										`}};v([Sr({type:Object})],Ry.prototype,"room",2),v([Er()],Ry.prototype,"isConfirmationOpen",2),Ry=v([_r("rs-room-settings-leave-chat")],Ry);var Cy=_t`: host {
											background - color: var (--color - ui - modalbackground);
											display: grid;
											grid - template - columns: 220 px 1 fr;
											height: 100 % ;
											overflow: auto
										}
										@media(min - width: 768 px) {
											: host {
												grid - template - columns: 300 px 1 fr
											}
										}
										nav {
											box - sizing: border - box;
											border - right: 1 px solid
											var (--color - tone - 5);
											display: flex;
											flex - direction: column;
											padding: var (--spacer - sm);
											height: 100 % ;
											overflow: auto
										}
										nav > button {
											padding: var (--size - xs) var (--size - sm);text - align: left;border: 0;border - radius: var (--size - xs);background - color: var (--color - tone - 7)
										}
										nav > button.active {
											background - color: var (--color - tone - 6)
										}
										nav > button: hover {
											background - color: var (--color - tone - 6)
										}
										header {
											margin - bottom: var (--spacer - md);
											display: flex;
											align - items: center;
											gap: var (--size - 2 xs)
										}
										header h3 {
											font: var (--font - title - h3);margin: 0
										}.content {
											background - color: var (--color - tone - 7);
											overflow - y: auto
										}.wrapper {
											width: 100 % ;padding: 0
											var (--spacer - md);max - width: 694 px;margin: 0 auto;box - sizing: border - box
										}
										`,My=class extends yr{constructor(){super(...arguments),this.route="about",this.closeSettings=()=>{let e=new CustomEvent("close-settings");this.dispatchEvent(e)}}static get styles(){return[ii,Cy]}connectedCallback(){super.connectedCallback(),fi(this,(({id:e})=>ki({source:"chat_settings",action:"view",noun:"chat_settings"},{chat:{id:e}}))({id:this.room.roomId}))}isDmRoom(){let e=this.room.client.getAccountData(Vr.Direct);if(!e)return!1;let t=e.getContent();return Object.values(t).flat().includes(this.room.roomId)}shouldShowInvite(){return this.room.canInvite(this.room.myUserId)&&!this.isDmRoom()}render(){return Qt` <
										nav >
											<
											header >
											$ {
												vn({
													appearance: "plain",
													size: an.Small,
													attributes: {
														className: "text-tone-2",
														type: "button",
														onclick: () => this.closeSettings()
													},
													leadingIcon: Qt`<icon-back></icon-back>`
												})
											} <
											h3 > $ {
												ka("Settings", {
													desc: "Settings: title"
												})
											} < /h3> <
											/header> <
											button
										type = "button"
										class = $ {
											Fr({
												active: "about" === this.route
											})
										}
										@click = "${()=>this.route="
										about "}" >
											$ {
												ka("About", {
													id: "settings-navigation-about",
													desc: "Settings navigation: About"
												})
											} <
											/button>
										$ {
											this.shouldShowInvite() ? Qt`<button
              type="button"
              class=${Fr({active:"invite"===this.route})}
              @click="${()=>this.route="invite"}"
            >
              ${ka("Invite people",{id:"settings-navigation-invite",desc:"Settings navigation: Invite people"})}
            </button>` : ""
										} <
										rs - room - settings - leave - chat
											.room = "${this.room}"
										@leave - room = "${this.closeSettings}" >
											< /rs-room-settings-leave-chat> <
											/nav> <
											section class = "content" >
											<
											div class = "wrapper" >
											$ {
												"about" === this.route ? Qt`<rs-room-settings-about room="${this.room.roomId}"></rs-room-settings-about>` : null
											}
										$ {
											"invite" === this.route ? Qt`<rs-room-settings-invite .room="${this.room}"></rs-room-settings-invite>` : null
										} <
										/div> <
										/section>
										`}};v([Sr({type:Object})],My.prototype,"room",2),v([Er()],My.prototype,"route",2),My=v([_r("rs-room-settings")],My);var xy=_t`: host {
											text - align: center
										}
										`,Oy=({id:e})=>ki({source:"invitation_inbox",action:"click",noun:"invitation_accept"},{chat:{id:e}}),Ay=class extends(mn(yr)){constructor(){super(...arguments),this.acceptInvitation=async()=>{if(this.matrix){if(this.urlJoinRoomId){let e=this.urlJoinRoomId;try{return await this.matrix.joinRoom(e),void fi(this,Oy({id:e}))}catch{return this.dispatchEvent(new La({level:Ma.error,message:"Unable to join the room"})),void ei({replace:!0})}}if(this.room)try{await this.matrix.joinRoom(this.room.roomId),fi(this,Oy({id:this.room.roomId}))}catch{this.dispatchEvent(new La({level:Ma.error,message:"Unable to join the room"}))}}},this.declineInvitation=async()=>{if(this.urlJoinRoomId&&ei({replace:!0}),this.matrix&&this.room)try{await this.matrix.leave(this.room.roomId),this.dispatchEvent(new Ty(this.room)),fi(this,(({id:e})=>ki({source:"invitation_inbox",action:"click",noun:"invitation_decline"},{chat:{id:e}}))({id:this.room.roomId}))}catch{this.dispatchEvent(new La({level:Ma.error,message:"Unable to leave the room"}))}}}static get styles(){return[ii,xy]}connectedCallback(){super.connectedCallback(),this.room&&fi(this,(({id:e})=>ki({source:"invitation_inbox",action:"view",noun:"invitation"},{chat:{id:e}}))({id:this.room.roomId}))}render(){return Qt` < p >
											$ {
												ka("You have been invited to this room. Do you want to accept the invitation?", {
													desc: "Invitation message"
												})
											} <
											/p> <
											div class = "flex flex-row justify-center gap-xs" >
											$ {
												vn({
													appearance: "primary",
													size: an.Small,
													children: ka("Accept", {
														desc: "Button: accept invitation"
													}),
													attributes: {
														onclick: this.acceptInvitation
													}
												})
											}
										$ {
											vn({
												appearance: "secondary",
												size: an.Small,
												children: ka("Decline", {
													desc: "Button: decline invitation"
												}),
												attributes: {
													onclick: this.declineInvitation
												}
											})
										} <
										/div>`}};v([Sr({type:Object})],Ay.prototype,"room",2),v([Sr({type:String})],Ay.prototype,"urlJoinRoomId",2),Ay=v([_r("rs-room-invite")],Ay);var Py=class extends yr{constructor(){super(...arguments),this.overlays=[]}static get styles(){return _t`: host {
											height: 100 % ;
											overflow: hidden;
										}
										`}updated(e){e.has("room")&&(this.overlays=[],this.requestUpdate())}connectedCallback(){super.connectedCallback(),this.addEventListener(Na,e=>{this.overlays.push(e.detail),this.requestUpdate()}),this.addEventListener(Ba,()=>{this.overlays.pop(),this.requestUpdate()})}render(){var e;return this.overlays.length>0?null==(e=this.overlays.at(-1))?void 0:e.content:Qt` < slot > < /slot>`}};v([Sr({type:String})],Py.prototype,"room",2),Py=v([_r("rs-room-overlay-manager")],Py);var Dy=_t`:host{height:100%;overflow:hidden}main{display:grid;grid-template-rows:min-content 1fr min-content;height:100%;overflow:auto}.noHeader{grid-template-rows:1fr min-content}rs-timeline{overflow-y:auto}.container{grid-row:2 /
										span 1;
										align - self: center;
										justify - self: center
									}.container.placeholder {
										font - style: italic
									}
									rs - room - settings {
										position: fixed;left: 0;right: 0;top: 0;bottom: 0;z - index: var (--layer - overlay)
									}
									`,jy=class extends yr{constructor(){super(...arguments),this.isSettingsOpen=!1,this.matrix=new _n(this),this.roomController=new wn(this)}static get styles(){return[ii,Dy]}async sendMessage(e){let t=this.roomController.getRoom(),r=await async function(e,t,r){let n=[];if(r.body){let i=e.sendTextMessage(t,r.body).then(({event_id:e})=>({id:e,type:"text"}));n.push(i)}if(r.attachments)for(let i of r.attachments){let r=ui(e,t,i).then(e=>e?{id:e,type:"image"}:null);n.push(r)}return Promise.all(n).then(e=>e.filter(e=>e))}(this.matrix.client,t.roomId,e.detail);this.timeline.scrollToBottom();for(let{id:n,type:i}of r)fi(this,Ti({id:n,type:"group",message_type:i,sender_user_id:this.matrix.client.getUserId()||""}))}connectedCallback(){super.connectedCallback(),this.roomController.on(Qr.Name,()=>{this.requestUpdate()}),this.roomController.on(Qr.MyMembership,()=>{this.requestUpdate()})}async updated(e){super.updated(e);let t=e.has("room")&&this.room!==e.get("room"),r=this.roomController.getRoom();if(t&&r){let e="join"===r.getMyMembership(),t=r.getMembers().length;fi(this,(({id:e,type:t,is_member:r,shown_history:n,number_members:i,number_unreads:o})=>ki({source:"chat_view",action:"view",noun:"chat"},{chat:{id:e,type:t,is_member:r,shown_history:n,number_members:i,number_unreads:o}}))({id:r.roomId,type:2===t?"direct":"group",number_members:t,is_member:e}))}}render(){let e=this.roomController.getRoom();return"invite"===(null==e?void 0:e.getMyMembership())?Qt` <
									main >
										$ {
											ci({
												noBorder: !0
											})
										} <
										rs - room - invite class = "container".room = "${e}" > < /rs-room-invite> <
										/main>
									`:Qt` <
									rs - room - overlay - manager room = "${e.roomId}" >
										<
										main class = "${Fr({noHeader:Boolean(this.hideHeader)})}" >
										$ {
											ci({
												title: e.name,
												buttons: vn({
													appearance: "plain",
													size: an.Small,
													attributes: {
														className: "text-tone-2",
														type: "button",
														onclick: () => this.isSettingsOpen = !this.isSettingsOpen
													},
													leadingIcon: Qt`<icon-settings></icon-settings>`
												}),
												hidden: this.hideHeader
											})
										} <
										rs - timeline room = "${e.roomId}"
									@send - message = "${this.sendMessage}" > < /rs-timeline> <
										rs - message - composer @send - message = "${this.sendMessage}" > < /rs-message-composer>
									$ {
										this.isSettingsOpen ? Qt`
                <rs-room-settings
                  .room="${e}"
                  @close-settings="${()=>this.isSettingsOpen=!1}"
                >
                </rs-room-settings>
              ` : null
									} <
									/main> <
									/rs-room-overlay-manager>
									`}};v([Sr({type:String})],jy.prototype,"room",2),v([Sr({type:Boolean})],jy.prototype,"hideHeader",2),v([Er()],jy.prototype,"isSettingsOpen",2),v([Tr("rs-timeline")],jy.prototype,"timeline",2),jy=v([_r("rs-room")],jy);var Ly=class extends yr{constructor(){super(...arguments),this.token="",this.uri=""}getActiveRoomsCount(){var e;return(null==(e=this.client)?void 0:e.getRooms().filter(e=>["invite","join"].includes(e.getMyMembership())).length)||0}async initMatrixClient(){this.client=$r.createClient({baseUrl:this.uri,timelineSupport:!0,useAuthorizationHeader:!0}),this.client.setMaxListeners(1e3),this.client.once(qr.Sync,async e=>{var t;"PREPARED"===e&&(ni(this.getActiveRoomsCount()),null==(t=this.client)||t.on(qr.Event,e=>{var t;e.getType()===Vr.RoomMember&&e.getStateKey()===(null==(t=this.client)?void 0:t.getUserId())&&ni(this.getActiveRoomsCount())}),this.dispatchEvent(new Ar({name:gn,instance:this.client})))});try{await this.client.login("com.reddit.token",{token:this.token}),await this.client.startClient({initialSyncLimit:10,pollTimeout:3e4}),function(){var e;null==(e=null==window?void 0:window.top)||e.postMessage("matrix-chat.loaded","*")}()}catch(e){this.dispatchEvent(new La({level:Ma.error,message:ka("Login attempt failed",{desc:"User login error message"})})),this.dispatchEvent(new La({level:Ma.debug,message:"Login attempt failed",meta:e}))}}connectedCallback(){super.connectedCallback(),this.uri&&this.token&&this.initMatrixClient()}};v([Sr({type:String})],Ly.prototype,"token",2),v([Sr({type:String})],Ly.prototype,"uri",2),Ly=v([_r("rs-matrix-client")],Ly);var Ny=class extends(Pr(yr)){connectedCallback(){super.connectedCallback(),this.addEventListener(xr,e=>{e.target!==this&&e.detail.name===gn&&(this.client=e.detail.instance)})}renderSpinner(){return Qt` <
									div class = "h-full w-full flex items-center justify-center " >
										<
										icon - load size = "lg"
									class = "w-[1.3125rem] h-[1.3125rem] animate-spin" > < /icon-load> <
										/div>
									`}renderRoom(){return Qt` < rs - room room = "${on(this.roomId)}"
									hideHeader > < /rs-room>`}render(){return this.client?this.renderRoom():this.renderSpinner()}};v([Sr({type:String})],Ny.prototype,"roomId",2),v([Er()],Ny.prototype,"client",2),Ny=v([_r("rs-room-wrapper")],Ny);var By=class extends yr{render(){return Qt` <
										rs - room - wrapper roomId = $ {
											on(this.roomId)
										} >
										<
										rs - matrix - client
									uri = "https://matrix.redditspace.com"
									token = $ {
											on(this.accessToken)
										} >
										< /rs-matrix-client> <
										rs - graphql - client
									uri = "https://gql-fed.reddit.com/"
									token = $ {
										on(this.accessToken)
									}
									persistedQueries
									$ {
										this.debug ? Qt` debug` : ""
									} >
									< /rs-graphql-client> <
									/rs-room-wrapper>
									`}};v([Sr({type:String})],By.prototype,"roomId",2),v([Sr({type:String})],By.prototype,"accessToken",2),v([Sr({type:Boolean})],By.prototype,"debug",2),By=v([_r("rs-community-room")],By)}).call(this,r("./node_modules/webpack/buildin/global.js"),r("./node_modules/process/browser.js"),r("./node_modules/webpack/buildin/harmony-module.js")(e))},"./node_modules/webpack/buildin/amd-options.js":function(e,t){(function(t){e.exports=t}).call(this,{})}}]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/vendors~community-room.de85f202ce7a3b705a96.js.map