// https://www.redditstatic.com/desktop2x/Governance~ModListing~Reddit~ReportFlow~Subreddit.23d9b7a90b766c6df9cb.js
// Retrieved at 2/15/2022, 2:20:05 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["Governance~ModListing~Reddit~ReportFlow~Subreddit"], {
		"./src/lib/assertNever.ts": function(e, t, r) {
			"use strict";

			function n(e) {
				throw new Error(`Unexpected object: ${e}`)
			}
			r.d(t, "a", (function() {
				return n
			}))
		},
		"./src/lib/constants/icons.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return n
			}));
			const n = {
				activity: "activity",
				activity_fill: "activity_fill",
				add: "add",
				add_fill: "add_fill",
				add_media: "add_media",
				add_media_fill: "add_media_fill",
				add_to_feed: "add_to_feed",
				add_to_feed_fill: "add_to_feed_fill",
				admin: "admin",
				admin_fill: "admin_fill",
				all: "all",
				all_fill: "all_fill",
				appearance: "appearance",
				appearance_fill: "appearance_fill",
				approve: "approve",
				approve_fill: "approve_fill",
				archived: "archived",
				archived_fill: "archived_fill",
				aspect_ratio: "aspect_ratio",
				aspect_ratio_fill: "aspect_ratio_fill",
				aspect_rectangle: "aspect_rectangle",
				aspect_rectangle_fill: "aspect_rectangle_fill",
				attach: "attach",
				attach_fill: "attach_fill",
				audio: "audio",
				audio_fill: "audio_fill",
				author: "author",
				author_fill: "author_fill",
				avatar_style: "avatar_style",
				avatar_style_fill: "avatar_style_fill",
				award: "award",
				award_fill: "award_fill",
				back: "back",
				back_fill: "back_fill",
				ban: "ban",
				ban_fill: "ban_fill",
				best: "best",
				best_fill: "best_fill",
				block: "block",
				bold: "bold",
				bold_fill: "bold_fill",
				bot: "bot",
				bot_fill: "bot_fill",
				bounce: "bounce",
				bounce_fill: "bounce_fill",
				browse: "browse",
				browse_fill: "browse_fill",
				browser: "browser",
				browser_fill: "browser_fill",
				cake: "cake",
				cake_fill: "cake_fill",
				calendar: "calendar",
				camera: "camera",
				camera_fill: "camera_fill",
				caret_down: "caret_down",
				caret_down_fill: "caret_down_fill",
				caret_left: "caret_left",
				caret_left_fill: "caret_left_fill",
				caret_right: "caret_right",
				caret_right_fill: "caret_right_fill",
				caret_up: "caret_up",
				caret_up_fill: "caret_up_fill",
				chat: "chat",
				chat_fill: "chat_fill",
				chat_group: "chat_group",
				chat_group_fill: "chat_group_fill",
				chat_new: "chat_new",
				chat_new_fill: "chat_new_fill",
				checkbox: "checkbox",
				checkbox_dismiss: "checkbox_dismiss",
				checkbox_dismiss_fill: "checkbox_dismiss_fill",
				checkbox_fill: "checkbox_fill",
				checkmark: "checkmark",
				checkmark_fill: "checkmark_fill",
				chrome: "chrome",
				chrome_fill: "chrome_fill",
				clear: "clear",
				clear_fill: "clear_fill",
				close: "close",
				close_fill: "close_fill",
				closed_captioning: "closed_captioning",
				closed_captioning_fill: "closed_captioning_fill",
				code_block: "code_block",
				code_block_fill: "code_block_fill",
				code_inline: "code_inline",
				code_inline_fill: "code_inline_fill",
				coins: "coins",
				coins_fill: "coins_fill",
				coins_outline_color: "coins_outline_color",
				collapse: "collapse",
				collapse_fill: "collapse_fill",
				collection: "collection",
				collection_fill: "collection_fill",
				comment: "comment",
				comment_fill: "comment_fill",
				comments: "comments",
				comments_fill: "comments_fill",
				community: "community",
				community_fill: "community_fill",
				controversial: "controversial",
				controversial_fill: "controversial_fill",
				crop: "crop",
				crop_fill: "crop_fill",
				crosspost: "crosspost",
				crosspost_fill: "crosspost_fill",
				crowd_control: "crowd_control",
				crowd_control_fill: "crowd_control_fill",
				custom_feed: "custom_feed",
				custom_feed_fill: "custom_feed_fill",
				customize: "customize",
				customize_fill: "customize_fill",
				day: "day",
				day_fill: "day_fill",
				delete: "delete",
				delete_fill: "delete_fill",
				discover: "discover",
				discover_fill: "discover_fill",
				dismiss_all: "dismiss_all",
				dismiss_all_fill: "dismiss_all_fill",
				distinguish: "distinguish",
				distinguish_fill: "distinguish_fill",
				down: "down",
				down_fill: "down_fill",
				download: "download",
				download_fill: "download_fill",
				downvote: "downvote",
				downvote_fill: "downvote_fill",
				downvotes: "downvotes",
				downvotes_fill: "downvotes_fill",
				drag: "drag",
				duplicate: "duplicate",
				duplicate_fill: "duplicate_fill",
				edit: "edit",
				edit_fill: "edit_fill",
				effect: "effect",
				effect_fill: "effect_fill",
				embed: "embed",
				embed_fill: "embed_fill",
				emoji: "emoji",
				emoji_fill: "emoji_fill",
				expand: "expand",
				expand_fill: "expand_fill",
				external_link: "external_link",
				external_link_fill: "external_link_fill",
				feed_posts: "feed_posts",
				feed_posts_fill: "feed_posts_fill",
				feed_video: "feed_video",
				feed_video_fill: "feed_video_fill",
				filter: "filter",
				filter_fill: "filter_fill",
				format: "format",
				format_fill: "format_fill",
				forward: "forward",
				forward_fill: "forward_fill",
				gif_post: "gif_post",
				gif_post_fill: "gif_post_fill",
				heart: "heart",
				heart_fill: "heart_fill",
				help: "help",
				help_fill: "help_fill",
				hide: "hide",
				hide_fill: "hide_fill",
				history: "history",
				history_fill: "history_fill",
				home: "home",
				home_fill: "home_fill",
				hot: "hot",
				hot_fill: "hot_fill",
				ignore_reports: "ignore_reports",
				ignore_reports_fill: "ignore_reports_fill",
				image_post: "image_post",
				image_post_fill: "image_post_fill",
				info: "info",
				info_fill: "info_fill",
				italic: "italic",
				italic_fill: "italic_fill",
				join: "join",
				join_fill: "join_fill",
				joined: "joined",
				joined_fill: "joined_fill",
				jump_down: "jump_down",
				jump_down_fill: "jump_down_fill",
				jump_up: "jump_up",
				jump_up_fill: "jump_up_fill",
				karma: "karma",
				karma_fill: "karma_fill",
				keyboard: "keyboard",
				keyboard_fill: "keyboard_fill",
				kick: "kick",
				kick_fill: "kick_fill",
				leave: "leave",
				leave_fill: "leave_fill",
				left: "left",
				left_fill: "left_fill",
				link_post: "link_post",
				link_post_fill: "link_post_fill",
				list_bulleted: "list_bulleted",
				list_bulleted_fill: "list_bulleted_fill",
				list_numbered: "list_numbered",
				list_numbered_fill: "list_numbered_fill",
				live: "live",
				live_fill: "live_fill",
				load: "load",
				location: "location",
				location_fill: "location_fill",
				lock: "lock",
				lock_fill: "lock_fill",
				logout: "logout",
				logout_fill: "logout_fill",
				loop: "loop",
				loop_fill: "loop_fill",
				mark_read: "mark_read",
				mark_read_fill: "mark_read_fill",
				mask: "mask",
				mask_fill: "mask_fill",
				media_gallery: "media_gallery",
				media_gallery_fill: "media_gallery_fill",
				meme: "meme",
				meme_fill: "meme_fill",
				menu: "menu",
				menu_fill: "menu_fill",
				message: "message",
				message_fill: "message_fill",
				mod: "mod",
				mod_fill: "mod_fill",
				mod_mail: "mod_mail",
				mod_mail_fill: "mod_mail_fill",
				mod_mode: "mod_mode",
				mod_mode_fill: "mod_mode_fill",
				mod_mute: "mod_mute",
				mod_mute_fill: "mod_mute_fill",
				mod_overflow: "mod_overflow",
				mod_overflow_fill: "mod_overflow_fill",
				mod_queue: "mod_queue",
				mod_queue_fill: "mod_queue_fill",
				mod_unmute: "mod_unmute",
				mod_unmute_fill: "mod_unmute_fill",
				new: "new",
				new_fill: "new_fill",
				night: "night",
				night_fill: "night_fill",
				notification: "notification",
				notification_fill: "notification_fill",
				notification_frequent: "notification_frequent",
				notification_frequent_fill: "notification_frequent_fill",
				notification_off: "notification_off",
				notification_off_fill: "notification_off_fill",
				nsfw: "nsfw",
				nsfw_fill: "nsfw_fill",
				nsfw_language: "nsfw_language",
				nsfw_language_fill: "nsfw_language_fill",
				nsfw_violence: "nsfw_violence",
				nsfw_violence_fill: "nsfw_violence_fill",
				original: "original",
				original_fill: "original_fill",
				overflow_carat: "overflow_carat",
				overflow_carat_fill: "overflow_carat_fill",
				overflow_horizontal: "overflow_horizontal",
				overflow_vertical: "overflow_vertical",
				pause: "pause",
				pause_fill: "pause_fill",
				payment: "payment",
				payment_fill: "payment_fill",
				peace: "peace",
				peace_fill: "peace_fill",
				pending_posts: "pending_posts",
				pending_posts_fill: "pending_posts_fill",
				pin: "pin",
				pin_fill: "pin_fill",
				play: "play",
				play_fill: "play_fill",
				poll_post: "poll_post",
				poll_post_fill: "poll_post_fill",
				popular: "popular",
				popular_fill: "popular_fill",
				powerup: "powerup",
				powerup_color_outline: "powerup_color_outline",
				powerup_fill: "powerup_fill",
				powerup_fill_color: "powerup_fill_color",
				prediction: "prediction",
				prediction_fill: "prediction_fill",
				premium: "premium",
				premium_fill: "premium_fill",
				privacy: "privacy",
				privacy_fill: "privacy_fill",
				profile: "profile",
				profile_fill: "profile_fill",
				quarantined: "quarantined",
				quarantined_fill: "quarantined_fill",
				quote: "quote",
				quote_fill: "quote_fill",
				r_slash: "r_slash",
				r_slash_fill: "r_slash_fill",
				radio_button: "radio_button",
				radio_button_fill: "radio_button_fill",
				random: "random",
				random_fill: "random_fill",
				rating_drugs: "rating_drugs",
				rating_everyone: "rating_everyone",
				rating_mature: "rating_mature",
				rating_nsfw: "rating_nsfw",
				rating_violence: "rating_violence",
				refresh: "refresh",
				refresh_fill: "refresh_fill",
				remove: "remove",
				remove_fill: "remove_fill",
				reply: "reply",
				reply_fill: "reply_fill",
				report: "report",
				report_fill: "report_fill",
				reverse: "reverse",
				reverse_fill: "reverse_fill",
				right: "right",
				right_fill: "right_fill",
				rising: "rising",
				rising_fill: "rising_fill",
				rotate: "rotate",
				rotate_fill: "rotate_fill",
				rpan: "rpan",
				rpan_fill: "rpan_fill",
				rules: "rules",
				rules_fill: "rules_fill",
				safari: "safari",
				safari_fill: "safari_fill",
				save: "save",
				save_fill: "save_fill",
				saved: "saved",
				saved_fill: "saved_fill",
				scheduled: "scheduled",
				scheduled_fill: "scheduled_fill",
				search: "search",
				search_fill: "search_fill",
				self: "self",
				self_fill: "self_fill",
				send: "send",
				send_fill: "send_fill",
				settings: "settings",
				settings_fill: "settings_fill",
				share: "share",
				share_android: "share_android",
				share_android_fill: "share_android_fill",
				share_fill: "share_fill",
				share_ios: "share_ios",
				share_ios_fill: "share_ios_fill",
				show: "show",
				show_fill: "show_fill",
				side_menu: "side_menu",
				side_menu_fill: "side_menu_fill",
				skipback10: "skipback10",
				skipback10_fill: "skipback10_fill",
				skipforward10: "skipforward10",
				skipforward10_fill: "skipforward10_fill",
				sort: "sort",
				sort_fill: "sort_fill",
				spam: "spam",
				spam_fill: "spam_fill",
				spoiler: "spoiler",
				spoiler_fill: "spoiler_fill",
				sponsored: "sponsored",
				sponsored_fill: "sponsored_fill",
				star: "star",
				star_fill: "star_fill",
				statistics: "statistics",
				statistics_fill: "statistics_fill",
				sticker: "sticker",
				sticker_fill: "sticker_fill",
				strikethrough: "strikethrough",
				strikethrough_fill: "strikethrough_fill",
				subtract: "subtract",
				subtract_fill: "subtract_fill",
				superscript: "superscript",
				superscript_fill: "superscript_fill",
				swipe_back: "swipe_back",
				swipe_back_fill: "swipe_back_fill",
				swipe_down: "swipe_down",
				swipe_down_fill: "swipe_down_fill",
				swipe_forward: "swipe_forward",
				swipe_forward_fill: "swipe_forward_fill",
				swipe_up: "swipe_up",
				swipe_up_fill: "swipe_up_fill",
				table: "table",
				table_fill: "table_fill",
				tag: "tag",
				tag_fill: "tag_fill",
				tap: "tap",
				tap_fill: "tap_fill",
				text_post: "text_post",
				text_post_fill: "text_post_fill",
				text_size: "text_size",
				text_size_fill: "text_size_fill",
				top: "top",
				top_fill: "top_fill",
				topic: "topic",
				topic_activism: "topic_activism",
				topic_addiction_support: "topic_addiction_support",
				topic_advice: "topic_advice",
				topic_animals: "topic_animals",
				topic_anime: "topic_anime",
				topic_art: "topic_art",
				topic_beauty: "topic_beauty",
				topic_business: "topic_business",
				topic_careers: "topic_careers",
				topic_cars: "topic_cars",
				topic_celebrity: "topic_celebrity",
				topic_crafts: "topic_crafts",
				topic_crypto: "topic_crypto",
				topic_culture: "topic_culture",
				topic_diy: "topic_diy",
				topic_entertainment: "topic_entertainment",
				topic_ethics: "topic_ethics",
				topic_family: "topic_family",
				topic_fashion: "topic_fashion",
				topic_fitness: "topic_fitness",
				topic_food: "topic_food",
				topic_funny: "topic_funny",
				topic_gender: "topic_gender",
				topic_health: "topic_health",
				topic_help: "topic_help",
				topic_history: "topic_history",
				topic_internet: "topic_internet",
				topic_law: "topic_law",
				topic_learning: "topic_learning",
				topic_lifestyle: "topic_lifestyle",
				topic_mature: "topic_mature",
				topic_mensfashion: "topic_mensfashion",
				topic_menshealth: "topic_menshealth",
				topic_meta: "topic_meta",
				topic_military: "topic_military",
				topic_movies: "topic_movies",
				topic_music: "topic_music",
				topic_news: "topic_news",
				topic_other: "topic_other",
				topic_outdoors: "topic_outdoors",
				topic_pets: "topic_pets",
				topic_photography: "topic_photography",
				topic_places: "topic_places",
				topic_politics: "topic_politics",
				topic_programming: "topic_programming",
				topic_reading: "topic_reading",
				topic_reading_fill: "topic_reading_fill",
				topic_religion: "topic_religion",
				topic_science: "topic_science",
				topic_sexorientation: "topic_sexorientation",
				topic_sports: "topic_sports",
				topic_style: "topic_style",
				topic_tabletop: "topic_tabletop",
				topic_technology: "topic_technology",
				topic_television: "topic_television",
				topic_traumasupport: "topic_traumasupport",
				topic_travel: "topic_travel",
				topic_videogaming: "topic_videogaming",
				topic_womenshealth: "topic_womenshealth",
				trim: "trim",
				trim_fill: "trim_fill",
				trophy: "trophy",
				trophy_fill: "trophy_fill",
				u_slash: "u_slash",
				u_slash_fill: "u_slash_fill",
				undo: "undo",
				undo_fill: "undo_fill",
				unheart: "unheart",
				unlock: "unlock",
				unlock_fill: "unlock_fill",
				unmod: "unmod",
				unmod_fill: "unmod_fill",
				unverified: "unverified",
				unverified_fill: "unverified_fill",
				up: "up",
				up_fill: "up_fill",
				upload: "upload",
				upload_fill: "upload_fill",
				upvote: "upvote",
				upvote_fill: "upvote_fill",
				upvotes: "upvotes",
				upvotes_fill: "upvotes_fill",
				user: "user",
				user_fill: "user_fill",
				vault: "vault",
				vault_fill: "vault_fill",
				verified: "verified",
				verified_fill: "verified_fill",
				video_camera: "video_camera",
				video_camera_fill: "video_camera_fill",
				video_live: "video_live",
				video_live_fill: "video_live_fill",
				video_post: "video_post",
				video_post_fill: "video_post_fill",
				view_card: "view_card",
				view_card_fill: "view_card_fill",
				view_classic: "view_classic",
				view_classic_fill: "view_classic_fill",
				view_compact: "view_compact",
				view_compact_fill: "view_compact_fill",
				view_grid_fill: "view_grid_fill",
				view_grid_fill_1: "view_grid_fill_1",
				views: "views",
				views_fill: "views_fill",
				volume: "volume",
				volume_fill: "volume_fill",
				volume_mute: "volume_mute",
				volume_mute_fill: "volume_mute_fill",
				wiki: "wiki",
				wiki_fill: "wiki_fill",
				world: "world",
				world_fill: "world_fill"
			}
		},
		"./src/lib/formatApiError/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return i
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/constants/index.ts");

			function i(e, t) {
				return e ? e.fields && e.fields.length ? e.fields.map(e => e.msg).join(", ") : e.type && o[e.type] ? o[e.type]() : 401 === t ? n.fbt._("There was an authentication error", null, {
					hk: "2KZTRv"
				}) : n.fbt._("Something went wrong", null, {
					hk: "3i6szH"
				}) : ""
			}
			const o = {
				[s.k]: () => n.fbt._("you're not allowed to do that", null, {
					hk: "1jGKQw"
				}),
				[s.L]: () => n.fbt._("GIF size must be less than {max file size}MB", [n.fbt._param("max file size", Math.floor(s.Z / s.hb).toString())], {
					hk: "1zzsdM"
				}),
				[s.R]: () => n.fbt._("Image size must be less than {max file size}MB", [n.fbt._param("max file size", Math.floor(s.bb / s.hb).toString())], {
					hk: "3H6bF8"
				}),
				[s.T]: () => n.fbt._("Sorry, we accept only images (.png, .jpeg, .gif) and videos (.mp4, .mov)", null, {
					hk: "1hw868"
				}),
				[s.nc]: () => n.fbt._("Video size must be less than {max file size}GB", [n.fbt._param("max file size", (s.fb / s.hb / 1024).toFixed(1))], {
					hk: "4FkABU"
				})
			}
		},
		"./src/lib/makePostDraftPageKey/index.ts": function(e, t, r) {
			"use strict";

			function n(e) {
				let t = "PostDraftPage";
				return e.draftId && (t += `--[draftId:${e.draftId}]`), t
			}
			r.d(t, "a", (function() {
				return n
			}))
		},
		"./src/reddit/actions/apiRequestState.ts": function(e, t, r) {
			"use strict";
			r.d(t, "d", (function() {
				return i
			})), r.d(t, "a", (function() {
				return o
			})), r.d(t, "b", (function() {
				return d
			})), r.d(t, "c", (function() {
				return c
			})), r.d(t, "h", (function() {
				return a
			})), r.d(t, "e", (function() {
				return u
			})), r.d(t, "f", (function() {
				return l
			})), r.d(t, "g", (function() {
				return b
			}));
			var n = r("./src/lib/makeActionCreator/index.ts"),
				s = r("./src/reddit/models/ApiRequestState/index.ts");
			const i = "API_REQUEST_STATE__STARTED",
				o = "API_REQUEST_STATE__COMPLETED",
				d = "API_REQUEST_STATE__FAILED",
				c = "API_REQUEST_STATE__RELEASED";

			function a(e) {
				return {
					type: i,
					payload: {
						apiRequestStatus: s.a.Pending,
						apiRequestId: e
					}
				}
			}

			function u(e) {
				return {
					type: o,
					payload: {
						apiRequestStatus: s.a.Complete,
						apiRequestId: e
					}
				}
			}

			function l(e, t) {
				return {
					type: d,
					payload: {
						apiRequestStatus: s.a.Failed,
						apiRequestId: e,
						apiError: t
					}
				}
			}
			const b = Object(n.a)(c)
		},
		"./src/reddit/actions/authorFlair.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return s
			})), r.d(t, "b", (function() {
				return i
			}));
			var n = r("./src/lib/makeActionCreator/index.ts");
			const s = "IN_CONTEXT_AUTHOR_FLAIR_UPDATED",
				i = Object(n.a)(s)
		},
		"./src/reddit/actions/comment/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "i", (function() {
				return R
			})), r.d(t, "m", (function() {
				return A
			})), r.d(t, "e", (function() {
				return P
			})), r.d(t, "h", (function() {
				return U
			})), r.d(t, "l", (function() {
				return q
			})), r.d(t, "q", (function() {
				return M
			})), r.d(t, "j", (function() {
				return Q
			})), r.d(t, "g", (function() {
				return K
			})), r.d(t, "f", (function() {
				return W
			})), r.d(t, "o", (function() {
				return J
			})), r.d(t, "p", (function() {
				return $
			})), r.d(t, "d", (function() {
				return V
			})), r.d(t, "a", (function() {
				return X
			})), r.d(t, "b", (function() {
				return Z
			})), r.d(t, "n", (function() {
				return ee
			})), r.d(t, "c", (function() {
				return te
			})), r.d(t, "k", (function() {
				return re
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./src/config.ts"),
				s = r("./node_modules/fbt/lib/FbtPublic.js"),
				i = r("./src/telemetry/index.ts"),
				o = r("./src/lib/makeActionCreator/index.ts"),
				d = r("./src/reddit/actions/economics/helpers/async.ts"),
				c = r("./src/reddit/actions/economics/powerups/flairs/async.ts"),
				a = r("./src/reddit/actions/login.ts"),
				u = r("./src/reddit/actions/modal.ts"),
				l = r("./src/reddit/actions/modQueueTriggers/index.ts"),
				b = r("./src/reddit/actions/shortcuts/utils.ts"),
				p = r("./src/reddit/actions/subredditModeration/modUserNotes.ts"),
				f = r("./src/reddit/actions/toaster.ts"),
				m = r("./src/reddit/actions/vote.ts"),
				_ = r("./src/reddit/endpoints/comment/index.tsx"),
				O = r("./src/reddit/helpers/commentList/index.ts"),
				j = r("./src/reddit/helpers/trackers/comment.ts"),
				g = r("./src/reddit/models/Comment/index.ts"),
				I = r("./src/reddit/models/Post/index.ts"),
				S = r("./src/reddit/models/Toast/index.ts"),
				E = r("./src/reddit/models/Vote/index.ts"),
				y = r("./src/reddit/selectors/comments.ts"),
				h = r("./src/reddit/selectors/commentSelector.ts"),
				T = r("./src/reddit/selectors/experiments/avatarsInComments.ts"),
				v = r("./src/reddit/selectors/experiments/cnc/index.ts"),
				w = r("./src/reddit/selectors/moderatingComments.ts"),
				x = r("./src/reddit/selectors/moderatorPermissions.ts"),
				C = r("./src/reddit/selectors/user.ts"),
				k = r("./src/reddit/actions/comment/constants.ts");
			const D = {},
				R = Object(o.a)(k.o),
				A = e => async (t, r, {
					apiContext: n
				}) => {
					if (!Object(C.K)(r())) return t(Object(a.j)()), void t(Object(u.k)({
						actionSource: u.a.Save,
						redirectUrl: Object(y.m)(r(), {
							commentId: e
						})
					}));
					const i = r().features.comments.models[e];
					if (!i) return;
					const o = i.isSaved ? _.m : _.i;
					if (t(R({
							[e]: {
								isSaved: !i.isSaved
							}
						})), (await o(n(), e)).ok) {
						const r = i.isSaved ? s.fbt._("Comment unsaved successfully", null, {
								hk: "UGKHZ"
							}) : s.fbt._("Comment saved successfully", null, {
								hk: "1BZqMx"
							}),
							n = s.fbt._("Undo", null, {
								hk: "46OwLP"
							});
						t(Object(f.f)({
							text: r,
							kind: S.b.Undo,
							buttonText: n,
							buttonAction: A(e)
						}))
					} else t(R({
						[e]: {
							isSaved: i.isSaved
						}
					}))
				}, N = e => `viewing-comment-${e}`, L = n.a.telemetry.commentConsumedThreshold, P = e => async (t, r) => {
					const s = r();
					if (!Object(h.b)(s, {
							commentId: e
						}) || Math.random() > n.a.telemetry.commentSampleRate) return;
					j.c({
						state: s,
						commentId: e
					}), i.c.start(N(e));
					const o = setTimeout(() => j.a({
						state: s,
						commentId: e
					}), L);
					D[e] = o
				}, U = (e, t) => async (r, n) => {
					const s = n(),
						o = N(e);
					if (Object(h.b)(s, {
							commentId: e
						}) && i.c.has(o)) {
						const r = i.c.end(o);
						!t && r < L && (clearTimeout(D[e]), delete D[e])
					}
				}, G = Object(o.a)(k.x), F = Object(o.a)(k.w), B = Object(o.a)(k.v), q = (e, t) => async (r, n, {
					apiContext: s
				}) => {
					const i = n(),
						o = i.moreComments.models[t],
						a = i.platform.currentPage,
						u = a && a.routeMatch,
						b = u && u.match,
						{
							partialPostId: f
						} = b ? b.params : null;
					if (!f) return;
					const m = Object(I.t)(f);
					r(G({
						moreCommentsId: o.id
					}));
					const j = await Object(_.f)(s(), m, {
						token: o.token
					}, Object(T.a)(i));
					if (j.ok) {
						const t = j.body,
							s = Object(O.a)(t, m, i);
						r(F({
							key: e,
							moreCommentsItem: o,
							shouldCollapse: s,
							...t
						}));
						const a = i.posts.models[m];
						let u;
						a && "subreddit" === a.belongsTo.type && t.comments && (u = a.belongsTo.id, await r(Object(d.a)({
							commentIds: Object.keys(j.body.comments),
							postIds: [a.id],
							skip: ["communityDetails", "subscription"],
							subredditId: u
						})), Object(v.a)(i) && r(Object(p.a)(m, !0, o.token)));
						const b = j.body.comments;
						await r(Object(c.b)(u, b)), Object(x.h)(n(), {
							subredditId: a.belongsTo.id
						}) && r(Object(l.a)({
							commentIds: Object.keys(t.comments)
						}))
					} else r(B({
						moreCommentsItem: o,
						...j.error
					}))
				}, M = Object(m.a)(O.b, E.a.upvoted), Q = Object(m.a)(O.b, E.a.downvoted), K = Object(o.a)(k.j), W = Object(o.a)(k.i), H = Object(o.a)(k.e), z = Object(o.a)(k.f), J = (Object(o.a)(k.c), Object(o.a)(k.d), ({
					commentId: e,
					commentsPageKey: t,
					scrollToAndRemeasure: r
				}) => async (n, s) => {
					const i = s(),
						o = Object(g.i)(e),
						d = Object(y.n)(i, {
							commentLink: o,
							commentsPageKey: t
						}),
						c = Object(w.b)(i, {
							commentId: e,
							commentsPageKey: t
						}),
						a = d.depth;
					n(H({
						commentId: e,
						commentsPageKey: t,
						isCollapsed: c
					})), c || 0 !== a || r(e, !0), Object(b.d)()
				}), $ = ({
					commentId: e,
					commentsPageKey: t
				}) => async r => {
					r(z({
						commentId: e,
						commentsPageKey: t
					}))
				}, V = ({
					commentLink: e,
					commentsPageKey: t,
					lineDepth: r,
					scrollToAndRemeasure: n
				}) => async (s, i) => {
					const o = i(),
						d = Object(O.e)(t, e, r, o),
						c = Object(w.b)(o, {
							commentId: e.id,
							commentsPageKey: t
						});
					s(H({
						commentId: d,
						commentsPageKey: t,
						isCollapsed: c
					})), 0 === r && n(d, !0), Object(b.d)()
				}, Y = Object(o.a)(k.r), X = e => t => t(Y({
					draftKey: e
				})), Z = Object(o.a)(k.a), ee = Object(o.a)(k.E), te = Object(o.a)(k.b), re = Object(o.a)(k.u)
		},
		"./src/reddit/actions/contentControls/constants.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return n
			})), r.d(t, "b", (function() {
				return s
			})), r.d(t, "c", (function() {
				return i
			})), r.d(t, "d", (function() {
				return o
			}));
			const n = "CONTENT_CONTROLS_FAILED",
				s = "CONTENT_CONTROLS_LOADED",
				i = "CONTENT_CONTROLS_PENDING",
				o = "CONTENT_CONTROLS_UPDATED"
		},
		"./src/reddit/actions/contentControls/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return v
			})), r.d(t, "b", (function() {
				return x
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./node_modules/lodash/camelCase.js"),
				i = r.n(s),
				o = r("./src/lib/constants/index.ts"),
				d = r("./src/lib/makeActionCreator/index.ts"),
				c = r("./src/lib/sentry/index.ts"),
				a = r("./src/reddit/actions/toaster.ts"),
				u = r("./src/lib/makeGqlRequest/index.ts"),
				l = r("./src/reddit/models/HatefulContentFilters/index.ts"),
				b = r("./src/redditGQL/operations/FetchContentControls.json");
			const p = e => {
				switch (e) {
					case "LENIENT":
						return l.a.Lenient;
					case "MODERATE":
						return l.a.Moderate;
					case "STRICT":
						return l.a.Strict;
					default:
						return l.a.Off
				}
			};
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var f = r("./node_modules/lodash/isEmpty.js"),
				m = r.n(f),
				_ = r("./src/redditGQL/operations/UpdateHatefulContentFilters.json"),
				O = r("./src/redditGQL/operations/UpdatePostRequirements.json"),
				j = r("./src/reddit/endpoints/subreddit/about.ts"),
				g = r("./src/reddit/models/Toast/index.ts"),
				I = r("./src/reddit/selectors/contentControls.ts"),
				S = r("./src/reddit/selectors/subreddit.ts"),
				E = r("./src/reddit/actions/contentControls/constants.ts");
			const y = Object(d.a)(E.b),
				h = Object(d.a)(E.c),
				T = Object(d.a)(E.a),
				v = e => async (t, r, {
					gqlContext: n
				}) => {
					const s = {
						subredditName: e.toLowerCase()
					};
					if (Object(I.a)(r(), s)) return;
					t(h(s));
					let i = Object(S.C)(r(), e);
					if (!i) {
						const r = await Object(j.a)(n(), e, !1);
						if (r.ok) {
							i = r.body.data.subreddit.id
						}
						if (!i) {
							const e = r.error || {
								type: o.I.NOT_FOUND_ERROR
							};
							return void t(T({
								...s,
								error: e
							}))
						}
					}
					let d = null;
					const a = await ((e, t) => Object(u.a)(e, {
						...b,
						variables: t
					}).then(e => {
						var t, r;
						if (e.ok) {
							const n = null === (r = null === (t = e.body) || void 0 === t ? void 0 : t.data) || void 0 === r ? void 0 : r.subreddit;
							return {
								...e,
								body: {
									data: {
										subreddit: {
											hatefulContentFilters: {
												hatefulContentThresholdAbuse: p(null == n ? void 0 : n.hatefulContentThresholdAbuse),
												hatefulContentThresholdIdentity: p(null == n ? void 0 : n.hatefulContentThresholdIdentity),
												wordlist: [],
												wordlistEnabled: !1
											},
											postRequirements: null == n ? void 0 : n.postRequirements
										}
									}
								}
							}
						}
						return e
					}))(n(), {
						subredditId: i
					});
					if (a.ok) {
						const e = a.body;
						d = e.data.subreddit && e.data.subreddit
					}
					if (d) t(y({
						...s,
						...d
					}));
					else {
						const r = a.error || {
							type: o.I.UNKNOWN_ERROR
						};
						t(T({
							...s,
							error: r
						})), c.c.withScope(t => {
							t.setExtra("info", {
								subredditName: e,
								responseBody: a.body,
								responseOk: a.ok
							}), c.c.captureMessage("Missing post requirements data!")
						})
					}
				}, w = Object(d.a)(E.d), x = (e, t) => async (r, s, {
					gqlContext: i
				}) => {
					const o = e.toLowerCase(),
						d = Object(S.C)(s(), e);
					if (!d) return {
						success: !1
					};
					const c = await ((e, t, r) => {
						const n = [Promise.resolve(null), Promise.resolve(null)];
						if (r.postRequirements && !m()(r.postRequirements)) {
							const s = {
								subredditId: t,
								...r.postRequirements
							};
							n[0] = Object(u.a)(e, {
								...O,
								variables: {
									input: s
								}
							})
						}
						if (r.hatefulContentFilters && !m()(r.hatefulContentFilters)) {
							const s = {
								subredditId: t
							};
							r.hatefulContentFilters.hatefulContentThresholdAbuse && (s.hatefulContentThresholdAbuse = r.hatefulContentFilters.hatefulContentThresholdAbuse), r.hatefulContentFilters.hatefulContentThresholdIdentity && (s.hatefulContentThresholdIdentity = r.hatefulContentFilters.hatefulContentThresholdIdentity), n[1] = Object(u.a)(e, {
								..._,
								variables: {
									input: s
								}
							})
						}
						return Promise.all(n).then(([e, t]) => {
							let r = !0,
								n = [];
							if (e) {
								const t = e.body,
									s = t.data.updatePostRequirements.fieldErrors;
								r = r && t.data.updatePostRequirements.ok, s && (n = n.concat(s))
							}
							if (t) {
								const e = t.body,
									s = e.data.updateSubredditSettings.fieldErrors;
								r = r && e.data.updateSubredditSettings.ok, s && (n = n.concat(s))
							}
							return {
								ok: r,
								fieldErrors: n.length ? n : null
							}
						})
					})(i(), d, t);
					if (c.ok) return r(w({
						subredditName: o,
						partialUpdates: t
					})), r(Object(a.f)({
						kind: g.b.SuccessCommunity,
						text: n.fbt._("Subreddit content controls updated successfully", null, {
							hk: "1n6QIQ"
						})
					})), {
						success: !0
					}; {
						const s = C(c.fieldErrors);
						return r(Object(a.f)({
							kind: g.b.Error,
							text: n.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
								hk: "3wBPeO"
							}),
							buttonText: n.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: x(e, t)
						})), {
							success: !1,
							errors: s || void 0
						}
					}
				}, C = e => e && e.map(e => ({
					...e,
					field: i()(e.field)
				}))
		},
		"./src/reddit/actions/downToChat.ts": function(e, t, r) {
			"use strict";
			r.d(t, "f", (function() {
				return I
			})), r.d(t, "g", (function() {
				return S
			})), r.d(t, "e", (function() {
				return E
			})), r.d(t, "b", (function() {
				return y
			})), r.d(t, "c", (function() {
				return h
			})), r.d(t, "a", (function() {
				return T
			})), r.d(t, "d", (function() {
				return v
			})), r.d(t, "j", (function() {
				return A
			})), r.d(t, "h", (function() {
				return N
			})), r.d(t, "i", (function() {
				return L
			}));
			var n = r("./src/lib/makeActionCreator/index.ts"),
				s = r("./src/reddit/actions/chat/toggle.ts"),
				i = r("./src/reddit/actions/modal.ts"),
				o = r("./src/reddit/actions/toaster.ts"),
				d = r("./src/reddit/constants/modals.ts"),
				c = r("./src/config.ts"),
				a = r("./src/lib/constants/index.ts"),
				u = r("./src/lib/makeApiRequest/index.ts"),
				l = r("./src/lib/omitHeaders/index.ts"),
				b = r("./src/reddit/constants/headers.ts");
			var p = r("./src/reddit/helpers/parseUrl.ts"),
				f = r("./src/reddit/selectors/telemetry.ts"),
				m = r("./src/telemetry/models/Event.ts");
			var _ = r("./src/reddit/models/Toast/index.ts"),
				O = r("./src/reddit/selectors/downToChat.ts"),
				j = r("./src/telemetry/index.ts");
			const {
				fbt: g
			} = r("./node_modules/fbt/lib/FbtPublic.js"), I = "FETCH_DOWN_TO_CHAT_AVAILABILITY__PENDING", S = "FETCH_DOWN_TO_CHAT_AVAILABILITY__SUCCESS", E = "FETCH_DOWN_TO_CHAT_AVAILABILITY__FAILED", y = "DISMISS_DOWN_TO_CHAT_BANNER__PENDING", h = "DISMISS_DOWN_TO_CHAT_BANNER__SUCCESS", T = "DISMISS_DOWN_TO_CHAT_BANNER__FAILED", v = "DISMISS_EACH_SUBREDDIT_BANNER", w = Object(n.a)(I), x = Object(n.a)(S), C = Object(n.a)(E), k = Object(n.a)(y), D = Object(n.a)(h), R = (Object(n.a)(T), Object(n.a)(v)), A = e => async (t, r, {
				apiContext: n
			}) => {
				const s = r();
				if (Object(O.a)(s, e)) return;
				t(w({
					subredditId: e
				}));
				const i = await (async (e, t) => Object(u.a)(Object(l.a)(e, [b.a]), {
					endpoint: `${c.a.sendbirdServiceUrl}/api/v1/sendbird/down_to_chat/availability`,
					method: a.jb.GET,
					type: "json",
					data: {
						subreddit_id: t
					},
					timeoutMs: 650
				}))(n(), e);
				if (i.ok && i.body) {
					const {
						feature_enabled: r,
						experiment_enabled: n
					} = i.body;
					if (t(x({
							subredditId: e,
							bannerEnabled: r,
							buttonEnabled: n
						})), r) {
						const e = (e => ({
							source: m.b.Chat,
							action: m.a.View,
							noun: "down_to_chat_subreddit_entry",
							subreddit: Object(f.jb)(e),
							...Object(f.o)(e)
						}))(s);
						Object(j.a)(e)
					}
				} else t(C({
					subredditId: e,
					error: "Failed to fetch subreddit's down to chat availability data"
				}))
			}, N = e => async (t, r, {
				apiContext: n
			}) => {
				t(k({
					subredditId: e
				}));
				const s = await (async (e, t) => Object(u.a)(Object(l.a)(e, [b.a]), {
					endpoint: `${c.a.sendbirdServiceUrl}/api/v1/sendbird/down_to_chat/availability`,
					method: a.jb.DELETE,
					data: {
						subreddit_id: t
					}
				}))(n(), e);
				if (s.ok && s.body) {
					const {
						feature_enabled: r,
						experiment_enabled: n
					} = s.body;
					t(D({
						subredditId: e,
						bannerEnabled: r,
						buttonEnabled: n
					})), r || t(R())
				}
				const i = (e => ({
					source: m.b.Chat,
					action: m.a.Dismiss,
					noun: "down_to_chat_subreddit_entry",
					subreddit: Object(f.jb)(e),
					...Object(f.o)(e)
				}))(r());
				Object(j.a)(i)
			}, L = e => async (t, r, {
				apiContext: n
			}) => {
				const O = await (async (e, t) => Object(u.a)(Object(l.a)(e, [b.a]), {
					endpoint: `${c.a.sendbirdServiceUrl}/api/v1/sendbird/down_to_chat/join`,
					method: a.jb.POST,
					type: "json",
					data: {
						subreddit_id: t
					}
				}))(n(), e);
				if (O.ok && O.body) {
					t(Object(i.i)(d.a.DOWN_TO_CHAT_PENDING_MODAL));
					const {
						deeplink_url: e
					} = O.body, r = Object(p.a)(e);
					r && r.pathname && t(Object(s.d)({
						channelUrl: r.pathname
					}))
				} else t(Object(o.f)({
					kind: _.b.Error,
					duration: o.a,
					text: g._("Failed to join a subreddit channel", null, {
						hk: "mZam3"
					})
				}));
				setTimeout(() => t(Object(i.f)()), 1e3);
				const I = (e => ({
					source: m.b.Chat,
					action: m.a.Click,
					noun: "down_to_chat_subreddit_entry",
					subreddit: Object(f.jb)(e),
					...Object(f.o)(e)
				}))(r());
				Object(j.a)(I)
			}
		},
		"./src/reddit/actions/economics/helpers/async.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return n
			}));
			const n = e => async t => {
				const n = await (() => Promise.all([r.e("EconHelperActions~index~reddit-components-Econ-Prediction"), r.e("EconHelperActions")]).then(r.bind(null, "./src/reddit/actions/economics/helpers/index.ts")).then(e => e.fetchAll))();
				await t(n(e))
			}
		},
		"./src/reddit/actions/economics/powerups/flairs/async.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return s
			})), r.d(t, "a", (function() {
				return i
			}));
			var n = r("./src/lib/loadableAction/index.ts");
			const s = Object(n.a)(() => r.e("AchievementsActions").then(r.bind(null, "./src/reddit/actions/economics/powerups/flairs/index.ts")).then(e => e.getSubredditUserCommentsPowerupsInfoFromCommentCollection)),
				i = Object(n.a)(() => r.e("AchievementsActions").then(r.bind(null, "./src/reddit/actions/economics/powerups/flairs/index.ts")).then(e => e.getSubredditCurrentUserPowerupsFlairsAndSupporterInfo))
		},
		"./src/reddit/actions/economics/powerups/helpers.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return n
			}));
			const n = e => (null == e ? void 0 : e.map(e => e.message).join(", ")) || ""
		},
		"./src/reddit/actions/economics/predictions/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "e", (function() {
				return W
			})), r.d(t, "k", (function() {
				return H
			})), r.d(t, "o", (function() {
				return z
			})), r.d(t, "r", (function() {
				return J
			})), r.d(t, "q", (function() {
				return $
			})), r.d(t, "l", (function() {
				return ee
			})), r.d(t, "m", (function() {
				return te
			})), r.d(t, "n", (function() {
				return re
			})), r.d(t, "b", (function() {
				return ne
			})), r.d(t, "u", (function() {
				return se
			})), r.d(t, "v", (function() {
				return ie
			})), r.d(t, "g", (function() {
				return oe
			})), r.d(t, "a", (function() {
				return de
			})), r.d(t, "w", (function() {
				return ae
			})), r.d(t, "p", (function() {
				return ue
			})), r.d(t, "i", (function() {
				return le
			})), r.d(t, "j", (function() {
				return be
			})), r.d(t, "s", (function() {
				return pe
			})), r.d(t, "t", (function() {
				return fe
			})), r.d(t, "f", (function() {
				return me
			})), r.d(t, "c", (function() {
				return _e
			})), r.d(t, "d", (function() {
				return Oe
			})), r.d(t, "h", (function() {
				return je
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./node_modules/uuid/index.js"),
				i = r.n(s),
				o = r("./src/lib/initializeClient/installReducer.ts"),
				d = r("./src/reddit/reducers/features/predictions/index.ts"),
				c = (r("./node_modules/core-js/modules/web.dom.iterable.js"), r("./src/lib/makeRequest/index.ts")),
				a = r("./src/lib/uploadToS3/index.ts"),
				u = r("./src/lib/makeGqlRequest/index.ts"),
				l = r("./src/redditGQL/operations/CreateMediaUploadLease.json"),
				b = r("./src/redditGQL/operations/SubmitMediaUpload.json");
			var p = r("./src/reddit/helpers/media/index.ts"),
				f = r("./src/redditGQL/types.ts");
			const m = new Map([
					["image/png", f.i.Png],
					["image/gif", f.i.Gif],
					["image/jpeg", f.i.Jpeg]
				]),
				_ = (e, t) => async (r, n, {
					gqlContext: s
				}) => {
					const i = await Object(p.g)(t) || t.type,
						o = m.get(i);
					if (!o) throw new Error("Unacceptable file type");
					const {
						mediaId: d,
						uploadLease: f
					} = await (async (e, t) => {
						const r = await Object(u.a)(e, {
							...l,
							variables: {
								input: t
							}
						});
						if (!Object(c.c)(r) || r.error) throw new Error("Failed to create upload lease");
						return r.body.data.createMediaUploadLease
					})(s(), {
						mimetype: o
					}), _ = function({
						uploadLeaseUrl: e,
						uploadLeaseHeaders: t
					}) {
						return {
							action: e,
							fields: (null == t ? void 0 : t.map(({
								header: e,
								value: t
							}) => ({
								name: e,
								value: t
							}))) || []
						}
					}(f), O = await Object(a.a)(t, _);
					if (!Object(c.c)(O)) throw new Error("Failed to upload file to S3");
					return await (async (e, t) => {
						const r = await Object(u.a)(e, {
							...b,
							variables: {
								input: t
							}
						});
						if (!Object(c.c)(r) || r.error) throw new Error("Failed to submit media")
					})(s(), {
						mediaId: d,
						redditId: e
					}), {
						mediaId: d,
						mimeType: o
					}
				};
			var O = r("./src/reddit/actions/toaster.ts"),
				j = r("./src/reddit/models/Toast/index.ts"),
				g = r("./src/lib/delay/index.ts"),
				I = r("./src/lib/makeActionCreator/index.ts"),
				S = r("./src/reddit/endpoints/economics/predictions.ts");

			function E({
				topPredictorsRank: e,
				currentRank: t
			}) {
				return {
					currentRank: t ? y(t) : null,
					topPredictorsRank: e.map(y)
				}
			}

			function y({
				score: e,
				rank: t,
				redditor: r,
				redditorInfo: n
			}) {
				var s, i;
				return {
					score: e,
					rank: t,
					redditor: r ? {
						...r,
						icon: null !== (s = r.icon) && void 0 !== s ? s : null,
						profile: null !== (i = r.profile) && void 0 !== i ? i : null
					} : null,
					redditorInfo: n
				}
			}
			var h = r("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				T = r("./src/reddit/helpers/graphql/normalizePredictionTournamentFromGql/index.ts"),
				v = r("./src/reddit/actions/login.ts"),
				w = r("./src/reddit/actions/modal.ts"),
				x = r("./src/reddit/constants/modals.ts"),
				C = r("./src/reddit/selectors/features/predictions/leaderboards/index.ts"),
				k = r("./src/reddit/selectors/subreddit.ts"),
				D = r("./src/reddit/selectors/user.ts"),
				R = r("./src/reddit/selectors/features/predictions/creation/index.ts"),
				A = r("./src/reddit/selectors/features/predictions/tournaments/index.ts"),
				N = r("./src/reddit/actions/economics/predictions/constants.ts");
			Object(o.a)({
				features: {
					predictions: d.a
				}
			});
			const L = Object(I.a)(N.d),
				P = Object(I.a)(N.c),
				U = Object(I.a)(N.e),
				G = Object(I.a)(N.f),
				F = Object(I.a)(N.i),
				B = Object(I.a)(N.h),
				q = Object(I.a)(N.j),
				M = Object(I.a)(N.q),
				Q = Object(I.a)(N.t),
				K = Object(I.a)(N.p),
				W = Object(I.a)(N.b),
				H = (e, t, r) => async (n, s, {
					gqlContext: i
				}) => {
					const o = Object(D.K)(s());
					if (!Object(C.c)(s(), {
							subredditId: e
						})) {
						n(L({
							subredditId: e
						}));
						try {
							const {
								predictionTournaments: s,
								predictionWinners: d
							} = await Object(S.i)(i(), {
								subredditId: e,
								period: r,
								top: t,
								includeCurrentRank: o
							}), c = E(d);
							n(U({
								subredditId: e,
								leaderboard: c
							})), s && (n(re(e, s)), null == s || s.forEach(({
								tournamentId: e,
								winners: t
							}) => {
								n(G({
									tournamentId: e,
									leaderboard: E(t)
								}))
							}))
						} catch {
							n(P({
								subredditId: e
							}))
						}
					}
				}, z = (e, t) => async (r, n, {
					gqlContext: s
				}) => {
					const i = Object(D.K)(n());
					if (!Object(C.g)(n(), {
							tournamentId: t
						})) {
						r(F({
							tournamentId: t
						}));
						try {
							const {
								predictionWinners: n
							} = await Object(S.j)(s(), {
								subredditId: e,
								tournamentId: t,
								includeCurrentRank: i
							}), o = E(n);
							r(q({
								tournamentId: t,
								leaderboard: o
							}))
						} catch {
							r(B({
								tournamentId: t
							}))
						}
					}
				}, J = ({
					coinPackageId: e,
					optionId: t,
					postId: r,
					price: n
				}) => async (s, i, {
					gqlContext: o
				}) => {
					const d = await Object(S.p)(o(), {
						coinPackageId: e,
						optionId: t,
						postId: r,
						price: n
					});
					return s(M({
						pollId: r,
						prediction: d,
						price: n
					})), d
				}, $ = ({
					optionId: e,
					postId: t
				}) => async (r, n, {
					gqlContext: s
				}) => {
					const i = await Object(S.n)(s(), {
							optionId: e,
							postId: t
						}),
						{
							resolvePrediction: o
						} = i.body.data;
					if (!(null == o ? void 0 : o.poll)) throw new Error("Failed to resolve prediction");
					return r(K({
						pollId: t,
						prediction: o.poll
					})), o.poll
				}, V = Object(I.a)(N.k), Y = Object(I.a)(N.m), X = Object(I.a)(N.l), Z = Object(I.a)(N.o), ee = e => async (t, r, {
					gqlContext: n
				}) => {
					const s = r(),
						i = Object(k.C)(s, e);
					if (Object(A.k)(s, {
							subredditId: i
						})) return Object(A.g)(s, {
						subredditId: i
					});
					t(V({
						subredditId: i
					}));
					const o = await Object(S.k)(n(), {
							subredditName: e,
							isLatestOnly: !0,
							isIncludingPredictions: !0,
							isIncludingParticipants: !0,
							isIncludingCancelledPredictions: !0
						}),
						d = {};
					o.forEach(e => {
						var r;
						if ((null === (r = e.predictionPosts) || void 0 === r ? void 0 : r.length) && e.predictionPosts.forEach(e => {
								e && (d[e.id] = Object(h.f)(e))
							}), e.winners) {
							const r = E(e.winners);
							t(G({
								tournamentId: e.tournamentId,
								leaderboard: r
							}))
						}
					});
					const c = o.map(e => Object(T.a)(e));
					return t(X({
						subredditId: i,
						tournaments: c
					})), t(Y({
						subredditId: i,
						tournaments: c
					})), t(Z({
						posts: d,
						meta: s.meta
					})), c
				}, te = e => async (t, r, {
					gqlContext: n
				}) => {
					const s = r(),
						i = Object(k.C)(s, e),
						o = await Object(S.l)(n(), {
							subredditName: e,
							isLatestOnly: !0
						});
					t(re(i, o))
				}, re = (e, t) => r => {
					const n = t.map(e => Object(T.a)(e));
					r(Y({
						subredditId: e,
						tournaments: n
					}))
				}, ne = Object(I.a)(N.a), se = Object(I.a)(N.r), ie = Object(I.a)(N.s), oe = (e, t, r, n) => async (s, i, {
					gqlContext: o
				}) => {
					const d = i(),
						c = Object(R.b)(d);
					let a = null;
					if (!c) throw new Error("Failed to create tournament, no prediction drafts attached");
					if (n instanceof File) {
						const {
							mediaId: t,
							mimeType: r
						} = await s(_(`icon_pred_${e}`, n));
						await Object(g.a)(3e3), a = {
							mediaId: t,
							width: 1,
							height: 1,
							mimeType: r.toLowerCase()
						}
					} else n && (a = {
						url: n,
						width: 1,
						height: 1,
						mimeType: ""
					});
					const u = await Object(S.e)(o(), {
							tournamentId: null,
							name: t,
							themeId: r,
							isStartImmediately: !0,
							subredditId: e,
							predictionDrafts: c,
							currency: f.t.Tokens,
							tokenIcon: a
						}),
						l = Object(T.a)(u);
					s(ce(l))
				}, de = (e, t) => async (r, n, {
					gqlContext: s
				}) => {
					const o = Object(R.b)(n());
					if (!o) throw new Error("Failed to create prediction post, no prediction drafts attached");
					const d = await Object(S.a)(s(), {
							tournamentId: e,
							isStartImmediately: !0,
							iKey: `add-dfts-${i.a.v4()}`,
							subredditId: t,
							predictionDrafts: o
						}),
						c = Object(T.a)(d);
					r(ce(c))
				}, ce = Object(I.a)(N.g), ae = (e, t, r) => async (t, n, {
					gqlContext: s
				}) => {
					const i = await Object(S.o)(s(), {
							tournamentId: e,
							name: r
						}),
						o = Object(T.a)(i);
					t(ce(o))
				}, ue = e => async (t, r, {
					gqlContext: n
				}) => {
					const s = await Object(S.f)(n(), {
							tournamentId: e
						}),
						{
							endPredictionTournament: i
						} = s.body.data;
					if (!i.tournament) throw new Error("Failed to update prediction name");
					return t(ce(i.tournament)), i.tournament
				}, le = e => async (t, r, {
					gqlContext: n
				}) => {
					const s = await Object(S.g)(n(), {
						postId: e
					});
					if (!s.ok || s.error) throw new Error("Failed to fetch prediction chip packages");
					const {
						postInfoById: i
					} = s.body.data;
					if (!i.predictionChipPackages) throw new Error("Failed to fetch prediction chip packages");
					return i.predictionChipPackages
				}, be = e => async (t, r, {
					gqlContext: n
				}) => {
					const s = await Object(S.h)(n(), {
						tournamentId: e
					});
					if (!s.ok || s.error) throw new Error("Failed to fetch token balance");
					const {
						identity: i
					} = s.body.data;
					if (!i.hasOwnProperty("predictionTokens")) throw new Error("Failed to fetch token balance");
					return i.predictionTokens
				}, pe = ({
					coinPackageId: e,
					selectedOptionId: t,
					price: r,
					pollId: n,
					tournamentId: s,
					tournamentPostId: i
				}) => async o => {
					const d = await o(J({
						coinPackageId: e,
						optionId: t,
						postId: n,
						price: r
					}));
					return o(Q({
						predictionId: n,
						selectedOptionId: t,
						tournamentId: s,
						tournamentPostId: i
					})), d
				}, fe = e => async (t, r) => {
					const n = r();
					Object(D.K)(n) ? await t(Object(w.h)(x.a.ECON_PREDICTIONS_PREMIUM_UPSELL, {
						feature: e
					})) : await t(Object(v.i)())
				}, me = () => Object(w.g)(x.a.ECON_PREDICTIONS_PREMIUM_UPSELL), _e = e => async (t, r, {
					gqlContext: s
				}) => {
					try {
						const r = await Object(S.b)(s(), {
							postId: e
						});
						t(W({
							postId: e,
							prediction: r
						}));
						const i = Object(O.e)(n.fbt._("Prediction has been cancelled", null, {
							hk: "3Bh9Fw"
						}), j.b.SuccessMod);
						t(Object(O.f)(i))
					} catch {
						const e = Object(O.e)(n.fbt._("Unable to cancel prediction", null, {
							hk: "2wkeKy"
						}), j.b.Error);
						t(Object(O.f)(e))
					}
				};

			function Oe(e, t) {
				return async (r, n, {
					gqlContext: s
				}) => {
					const i = await Object(S.c)(s(), {
						postId: e,
						...t
					});
					return r(W({
						postId: e,
						prediction: i
					})), i
				}
			}
			const je = e => async (t, r, {
				gqlContext: n
			}) => Object(S.m)(n(), {
				subredditId: e
			})
		},
		"./src/reddit/actions/externalAccount.ts": function(e, t, r) {
			"use strict";
			r.d(t, "l", (function() {
				return I
			})), r.d(t, "k", (function() {
				return S
			})), r.d(t, "j", (function() {
				return E
			})), r.d(t, "i", (function() {
				return y
			})), r.d(t, "h", (function() {
				return h
			})), r.d(t, "g", (function() {
				return T
			})), r.d(t, "o", (function() {
				return R
			})), r.d(t, "p", (function() {
				return A
			})), r.d(t, "b", (function() {
				return N
			})), r.d(t, "c", (function() {
				return L
			})), r.d(t, "a", (function() {
				return P
			})), r.d(t, "n", (function() {
				return B
			})), r.d(t, "e", (function() {
				return q
			})), r.d(t, "f", (function() {
				return M
			})), r.d(t, "d", (function() {
				return Q
			})), r.d(t, "m", (function() {
				return z
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/lib/addQueryParams/index.ts"),
				o = r("./src/reddit/actions/toaster.ts"),
				d = r("./src/reddit/constants/parameters.ts"),
				c = r("./src/lib/constants/index.ts"),
				a = r("./src/lib/makeApiRequest/index.ts"),
				u = r("./src/lib/omitHeaders/index.ts"),
				l = r("./src/reddit/constants/headers.ts"),
				b = r("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const p = e => {
				return e.reduce((e, t) => (e[t.provider] = t, e), {})
			};
			var f = r("./src/reddit/models/Toast/index.ts"),
				m = r("./src/reddit/models/User/index.ts"),
				_ = r("./src/reddit/selectors/externalAccount.ts"),
				O = r("./src/reddit/selectors/platform.ts"),
				j = r("./src/reddit/selectors/subreddit.ts"),
				g = r("./src/reddit/selectors/user.ts");
			const I = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				S = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				E = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				y = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				h = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				T = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				v = Object(s.a)(I),
				w = Object(s.a)(S),
				x = Object(s.a)(E),
				C = Object(s.a)(y),
				k = Object(s.a)(h),
				D = Object(s.a)(T),
				R = e => async (t, r, {
					apiContext: n
				}) => {
					const s = r(),
						i = Object(g.k)(s),
						o = e || i && Object(m.e)(i);
					if (!o) return;
					if (Object(_.d)(s, {
							username: o
						})) return;
					t(v(o));
					const d = await ((e, t) => Object(a.a)(Object(u.a)(e, [l.a]), {
						endpoint: Object(b.a)(`${e.apiUrl}/api/v1/external_account/user/${t}.json`),
						traceRequestName: "get_external_accounts",
						method: c.jb.GET
					}))(n(), o);
					if (d.ok) {
						const e = p(d.body);
						t(w({
							username: o,
							accountsData: e
						}))
					} else t(x(d.error))
				}, A = () => async (e, t, {
					apiContext: r
				}) => {
					const n = t(),
						s = Object(O.d)(n);
					if (!s) return;
					const i = n.externalAccount.api.subreddit.fetched[s],
						o = n.externalAccount.api.subreddit.pending[s];
					if (i || o) return;
					const d = Object(j.t)(n, {
						subredditName: s
					});
					if (!(d && d.hasExternalAccount)) return;
					e(C(s));
					const f = await ((e, t) => Object(a.a)(Object(u.a)(e, [l.a]), {
						endpoint: Object(b.a)(`${e.apiUrl}/api/v1/external_account/subreddit/${t}.json`),
						method: c.jb.GET
					}))(r(), s);
					if (f.ok) {
						const t = p(f.body);
						e(k({
							subredditName: s,
							accountsData: t
						}))
					} else e(D(f.error))
				}, N = "EXTERNAL_ACCOUNT_DISCONNECT_PENDING", L = "EXTERNAL_ACCOUNT_DISCONNECT_SUCCESS", P = "EXTERNAL_ACCOUNT_DISCONNECT_FAILED", U = Object(s.a)(N), G = Object(s.a)(L), F = Object(s.a)(P), B = e => async (t, r, {
					apiContext: n
				}) => {
					t(U({
						provider: e
					}));
					const s = Object(g.k)(r()),
						i = Object(m.e)(s),
						o = await ((e, t) => Object(a.a)(Object(u.a)(e, [l.a]), {
							endpoint: Object(b.a)(`${e.apiUrl}/api/v1/external_account/${t}/disconnect.json`),
							method: c.jb.POST
						}))(n(), e);
					o.ok ? t(G({
						provider: e,
						username: i
					})) : t(F({
						provider: e,
						error: o.error
					}))
				}, q = "OAUTH_FLOW_URL_PENDING", M = "OAUTH_FLOW_URL_SUCCESS", Q = "OAUTH_FLOW_URL_FAILED", K = Object(s.a)(q), W = Object(s.a)(M), H = Object(s.a)(Q), z = e => async (t, r, {
					apiContext: s
				}) => {
					t(K({
						provider: e
					}));
					const p = Object(i.a)(window.location.href, {
							[d.d]: e
						}),
						m = await ((e, t, r) => Object(a.a)(Object(u.a)(e, [l.a]), {
							endpoint: Object(b.a)(`${e.apiUrl}/api/v1/external_account/${t}/connect.json`),
							method: c.jb.POST,
							data: {
								redirect_url: r
							}
						}))(s(), e, p);
					if (m.ok) {
						const {
							redirect_url: r
						} = m.body;
						t(W({
							provider: e
						})), window.location.href = r
					} else t(H({
						provider: e,
						error: m.error
					})), t(Object(o.f)({
						kind: f.b.Error,
						text: n.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "196FiB"
						})
					}))
				}
		},
		"./src/reddit/actions/gold/powerups.ts": function(e, t, r) {
			"use strict";
			r.d(t, "o", (function() {
				return g
			})), r.d(t, "l", (function() {
				return h
			})), r.d(t, "m", (function() {
				return C
			})), r.d(t, "e", (function() {
				return k
			})), r.d(t, "b", (function() {
				return D
			})), r.d(t, "d", (function() {
				return A
			})), r.d(t, "k", (function() {
				return Q
			})), r.d(t, "a", (function() {
				return K
			})), r.d(t, "c", (function() {
				return W
			})), r.d(t, "j", (function() {
				return H
			})), r.d(t, "i", (function() {
				return z
			})), r.d(t, "g", (function() {
				return J
			})), r.d(t, "h", (function() {
				return $
			})), r.d(t, "f", (function() {
				return V
			})), r.d(t, "n", (function() {
				return X
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/lib/sentry/index.ts"),
				o = r("./src/telemetry/index.ts"),
				d = r("./src/reddit/actions/login.ts"),
				c = r("./src/reddit/actions/modal.ts"),
				a = r("./src/reddit/actions/toaster.ts"),
				u = r("./src/reddit/constants/modals.ts"),
				l = r("./src/reddit/endpoints/gold/powerups/index.ts"),
				b = r("./src/reddit/models/Toast/index.ts"),
				p = r("./src/reddit/selectors/gold/powerups/index.ts"),
				f = r("./src/reddit/selectors/gold/powerups/benefitSettings.ts"),
				m = r("./src/reddit/selectors/user.ts"),
				_ = r("./src/reddit/helpers/trackers/powerups.ts"),
				O = r("./src/reddit/actions/economics/powerups/flairs/async.ts"),
				j = r("./src/reddit/actions/gold/constants.ts");
			const g = e => async (t, r, {
				gqlContext: s
			}) => {
				if (!!r().user.powerups.fetched && !e) return;
				t(I());
				const o = n.fbt._("Something went wrong", null, {
					hk: "1IJNeH"
				});
				try {
					const e = await Object(l.j)(s());
					if (e.ok) {
						const r = e.body;
						if (r.errors && r.errors.length) return void(await t(y(o)));
						if (!r.data.identity) return void(await t(E(o)));
						await t(S({
							powerups: r.data.identity.powerups
						}))
					}
				} catch (d) {
					i.c.captureException(d), await t(y(o))
				}
			}, I = Object(s.a)(j.Bb), S = Object(s.a)(j.Ab), E = Object(s.a)(j.zb), y = e => async (t, r) => {
				await t(E(e)), t(Object(a.f)({
					kind: b.b.Error,
					duration: a.a,
					text: e
				}))
			}, h = (e, t) => async (e, r, {
				gqlContext: s
			}) => {
				var o;
				if (!!r().users.powerups.fetched) return;
				e(T());
				const d = n.fbt._("Something went wrong", null, {
					hk: "1IJNeH"
				});
				try {
					const r = await Object(l.g)(s(), t);
					if (r.ok) {
						const n = r.body;
						if (n.errors && n.errors.length) return void(await e(x(d)));
						if (!n.data.redditorInfoById) return void(await e(w(d)));
						const s = (null === (o = n.data.redditorInfoById.powerups) || void 0 === o ? void 0 : o.supportedSubreddits) || [];
						await e(v({
							supportedSubreddits: s,
							userId: t
						}))
					}
				} catch (c) {
					i.c.captureException(c), await e(x(d))
				}
			}, T = Object(s.a)(j.hb), v = Object(s.a)(j.gb), w = Object(s.a)(j.fb), x = e => async (t, r) => {
				await t(w(e)), t(Object(a.f)({
					kind: b.b.Error,
					duration: a.a,
					text: e
				}))
			}, C = (e, t = {}) => async (r, s, {
				gqlContext: o
			}) => {
				var d;
				const c = s();
				if (Object(p.k)(c, {
						subredditId: e
					}) && Object(f.a)(c, {
						subredditId: e
					}) && (!t.fullData || Object(p.m)(c, {
						subredditId: e
					})) && !t.forceLoad) return;
				r(N());
				const a = t.fullData ? l.i : l.h;
				try {
					const n = await a(o(), e, !!t.includeIdentity);
					if (n.ok) {
						const s = n.body;
						if (null === (d = s.errors) || void 0 === d ? void 0 : d.length) return void(await r(G(s.errors[0].message)));
						if (t.fullData) {
							const {
								data: t
							} = s, n = k(t.subredditInfoById, t.identity);
							D(r, e, n)
						} else {
							const {
								powerups: t = null,
								powerupsSettings: n = null
							} = s.data.subredditInfoById || {};
							await r(L({
								powerups: t,
								subredditId: e,
								benefitStatuses: null == n ? void 0 : n.benefitStatuses
							}))
						}
					}
				} catch (u) {
					i.c.captureException(u), await r(G(n.fbt._("Something went wrong", null, {
						hk: "1IJNeH"
					})))
				}
			}, k = (e, t) => {
				var r, n, s;
				const {
					powerups: i = null,
					powerupsSettings: o = null,
					supporters: d = null,
					productOffers: c = null,
					subredditAchievementFlairs: a
				} = e || {}, u = null == t ? void 0 : t.powerups;
				return {
					powerups: i,
					benefitStatuses: null == o ? void 0 : o.benefitStatuses,
					productOffers: null !== (r = null == c ? void 0 : c.offers) && void 0 !== r ? r : [],
					recentSupporters: null !== (n = null == d ? void 0 : d.recentSupporters) && void 0 !== n ? n : [],
					topSupporters: null !== (s = null == d ? void 0 : d.topSupporters) && void 0 !== s ? s : [],
					userPowerups: u,
					subredditAchievementFlairs: null != a ? a : []
				}
			}, D = (e, t, r) => e(P({
				subredditId: t,
				...r
			})), R = Object(s.a)(j.I), A = e => async (t, r, {
				gqlContext: n
			}) => {
				const s = r(),
					i = e.filter(e => void 0 === Object(p.k)(s, {
						subredditId: e
					}));
				if (!!i.length) try {
					const e = await Object(l.e)(n(), i);
					t(R({
						subredditsPowerupsInfo: e
					}))
				} catch (o) {
					await t(G(o.message))
				}
			}, N = Object(s.a)(j.rb), L = Object(s.a)(j.qb), P = Object(s.a)(j.pb), U = Object(s.a)(j.ob), G = e => async (t, r) => {
				await t(U(e)), t(Object(a.f)({
					kind: b.b.Error,
					duration: a.a,
					text: e
				}))
			}, F = Object(s.a)(j.T), B = Object(s.a)(j.U), q = Object(s.a)(j.V), M = e => async (t, r) => {
				await t(F(e)), t(Object(a.f)({
					kind: b.b.Error,
					duration: a.a,
					text: e
				}))
			}, Q = (e, t, r, s) => async (o, d, {
				gqlContext: p
			}) => {
				o(B({
					subredditId: e,
					powerupsCount: t,
					isAnonymous: r,
					allocatedAt: s
				}));
				try {
					const i = {
							subredditId: e,
							powerupsCount: t,
							isAnonymous: r
						},
						f = await Object(l.f)(p(), {
							input: i
						});
					let _ = !1,
						j = null;
					if (f.ok) {
						const e = f.body;
						_ = e.data.reallocatePowerups.ok, j = e.data.reallocatePowerups.errors
					}
					const I = Object(m.k)(d());
					if (_ && I) await o((e => async (t, r) => {
						t(q(e)), await t(C(e.subredditId, {
							forceLoad: !0,
							fullData: !1
						})), t(g(!0)), t(Object(O.a)(e.subredditId, !0)), e.powerupsCount && (t(Object(c.g)(u.a.ECON_POWERUPS_PURCHASE)), e.powerupsCount > 0 ? t(Object(c.h)(u.a.ECON_POWERUPS_SUCCESS)) : t(Object(a.f)({
							kind: b.b.SuccessCommunityGreen,
							duration: a.a,
							text: n.fbt._("Your Powerup subscription has been canceled.", null, {
								hk: "z7ZJZ"
							})
						})))
					})({
						subredditId: e,
						powerupsCount: t,
						isAnonymous: r,
						user: I,
						allocatedAt: s
					}));
					else {
						const e = j && j[0] && j[0].message || n.fbt._("An unknown error occurred", null, {
							hk: "2oAbwZ"
						});
						await o(M(e))
					}
				} catch (f) {
					i.c.captureException(f);
					const e = f,
						t = e && e.message || n.fbt._("An unknown error occurred", null, {
							hk: "2oAbwZ"
						});
					await o(M(t))
				}
			}, K = e => async (t, r, {
				gqlContext: n
			}) => {
				await Object(l.c)(n(), e)
			}, W = Object(s.a)(j.E), H = Object(s.a)(j.R), z = e => Object(c.h)(u.a.ECON_SUPPORTERS_LIST, {
				subredditId: e
			}), J = (e, t) => async (r, n) => {
				const s = n();
				return Object(m.k)(s) ? (Object(o.a)(Object(_.h)(e)(s)), r(Object(c.h)(u.a.ECON_POWERUPS_MARKETING, {
					subredditId: t
				}))) : r(Object(d.i)())
			}, $ = e => async t => t(Object(c.h)(u.a.ECON_POWERUPS_PREMIUM_UPSELL, {
				subredditId: e
			})), V = () => async (e, t) => {
				const r = t();
				return Object(m.k)(r) ? e(Object(c.h)(u.a.ACHIEVEMENT_FLAIR)) : e(Object(d.i)())
			}, Y = Object(s.a)(j.N), X = (e, t) => async (r, n, {
				gqlContext: s
			}) => {
				const i = await Object(l.k)(s(), e, (e => Object.keys(e).map(t => ({
					benefit: t,
					isEnabled: e[t]
				})))(t));
				if (i.ok) {
					const t = i.body.data.updatePowerupsSettings.powerupsSettings.benefitStatuses;
					return r(Y({
						subredditId: e,
						benefitStatuses: t
					})), !0
				}
				return !1
			}
		},
		"./src/reddit/actions/grantUserFlair/constants.ts": function(e, t, r) {
			"use strict";
			r.d(t, "i", (function() {
				return n
			})), r.d(t, "g", (function() {
				return s
			})), r.d(t, "f", (function() {
				return i
			})), r.d(t, "l", (function() {
				return o
			})), r.d(t, "k", (function() {
				return d
			})), r.d(t, "j", (function() {
				return c
			})), r.d(t, "h", (function() {
				return a
			})), r.d(t, "a", (function() {
				return u
			})), r.d(t, "b", (function() {
				return l
			})), r.d(t, "e", (function() {
				return b
			})), r.d(t, "c", (function() {
				return p
			})), r.d(t, "d", (function() {
				return f
			}));
			const n = "SUBREDDIT__FLAIRED_USERS_PENDING",
				s = "SUBREDDIT__FLAIRED_USERS_LOADED",
				i = "SUBREDDIT__FLAIRED_USERS_FAILED",
				o = "SUBREDDIT__FLAIRED_USERS_SEARCH_PENDING",
				d = "SUBREDDIT__FLAIRED_USERS_SEARCH_LOADED",
				c = "SUBREDDIT__FLAIRED_USERS_SEARCH_FAILED",
				a = "SUBREDDIT__FLAIRED_USERS_OWNFLAIR_CHANGED",
				u = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_ADDED",
				l = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_CHANGED",
				b = "SUBREDDIT__FLAIRED_USERS_DELETE_PENDING",
				p = "SUBREDDIT__FLAIRED_USERS_DELETE_COMPLETED",
				f = "SUBREDDIT__FLAIRED_USERS_DELETE_FAILED"
		},
		"./src/reddit/actions/grantUserFlair/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return E
			})), r.d(t, "e", (function() {
				return v
			})), r.d(t, "a", (function() {
				return k
			})), r.d(t, "b", (function() {
				return D
			})), r.d(t, "d", (function() {
				return N
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/lib/makeGqlRequest/index.ts"),
				o = r("./src/redditGQL/operations/SubredditFlairedRedditorByName.json"),
				d = r("./src/redditGQL/operations/SubredditFlairedRedditors.json");
			var c = r("./src/reddit/endpoints/flair/index.ts"),
				a = r("./src/reddit/actions/toaster.ts"),
				u = r("./src/reddit/helpers/flair.ts"),
				l = r("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts");
			var b = e => {
				const {
					subreddit: t,
					redditorInfoByName: r
				} = e.data, {
					id: n,
					flairedRedditorByName: s
				} = t, i = {};
				let o = null;
				if (!r) return {
					subredditId: n,
					searchResult: o,
					flairedUsers: i
				};
				const {
					name: d
				} = r;
				if (o = d, s) {
					const {
						flair: e,
						redditor: t
					} = s, {
						name: r
					} = t;
					e && (i[r] = Object(l.a)(e)[0])
				}
				return {
					subredditId: n,
					searchResult: o,
					flairedUsers: i
				}
			};
			var p = e => {
					const {
						subreddit: t
					} = e.data, {
						id: r,
						flairedRedditors: n
					} = t, {
						pageInfo: s,
						edges: i
					} = n, o = [], d = {};
					return i.forEach(e => {
						const {
							node: t
						} = e, {
							flair: r,
							redditor: {
								name: n
							}
						} = t;
						if (o.push(n), r) {
							const e = Object(l.a)(r)[0];
							d[n] = e
						}
					}), {
						subredditId: r,
						flairedUsers: d,
						userOrder: o,
						pageInfo: s
					}
				},
				f = r("./src/reddit/models/SubredditModeration/index.ts"),
				m = r("./src/reddit/models/Toast/index.ts"),
				_ = r("./src/reddit/models/User/index.ts"),
				O = r("./src/reddit/selectors/subreddit.ts"),
				j = r("./src/reddit/actions/grantUserFlair/constants.ts");
			const g = Object(s.a)(j.i),
				I = Object(s.a)(j.g),
				S = Object(s.a)(j.f),
				E = (e, t) => async (r, s, {
					gqlContext: o
				}) => {
					const c = t && t.after || "",
						u = t && t.before || "",
						l = Object(O.C)(s(), e),
						b = Object(f.e)(l, c, u);
					if (!!s().pages.modHub.flairedUsers.userOrder[b]) return;
					r(g());
					const _ = await ((e, t, r) => Object(i.a)(e, {
						...d,
						variables: {
							subredditName: t,
							...r
						}
					}))(o(), e, t);
					if (_.ok) {
						const e = {
							...p(_.body),
							key: b
						};
						r(I(e))
					} else {
						const e = _.error;
						r(S(e)), r(Object(a.f)({
							kind: m.b.Error,
							text: n.fbt._("Something went wrong", null, {
								hk: "1IJNeH"
							})
						}))
					}
				}, y = Object(s.a)(j.l), h = Object(s.a)(j.k), T = Object(s.a)(j.j), v = (e, t) => async (r, s, {
					gqlContext: d
				}) => {
					const c = Object(O.R)(s(), {
						subredditId: e
					}).name;
					r(y());
					const u = await ((e, t, r) => Object(i.a)(e, {
						...o,
						variables: {
							subredditName: t,
							name: r
						}
					}))(d(), c, t);
					if (u.ok) {
						const e = b(u.body);
						r(h(e))
					} else r(T(u.error)), r(Object(a.f)({
						kind: m.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						})
					}))
				}, w = Object(s.a)(j.e), x = Object(s.a)(j.c), C = Object(s.a)(j.d), k = (e, t) => async (r, s, {
					apiContext: i
				}) => {
					const o = s(),
						d = Object(O.R)(o, {
							subredditId: t
						}).name;
					r(w());
					const u = await Object(c.a)(i(), e, d);
					if (u.ok) {
						r(x({
							userName: e,
							subredditId: t
						}));
						const s = Object(a.e)(n.fbt._("User flair cleared", null, {
							hk: "4yyH00"
						}), m.b.SuccessMod);
						r(Object(a.f)(s))
					} else {
						r(C());
						const s = Object(a.e)(n.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "uG2KO"
						}), m.b.Error, n.fbt._("Retry", null, {
							hk: "3oiY99"
						}), k(e, t));
						r(Object(a.f)(s))
					}
					return u.ok || u.error
				}, D = Object(s.a)(j.h), R = Object(s.a)(j.b), A = Object(s.a)(j.a), N = (e, t, r) => async (s, i, {
					apiContext: o
				}) => {
					const d = i(),
						l = d.pages.modHub.flairedUsers.search.result === e && !d.pages.modHub.flairedUsers.models[e],
						b = {
							userName: e,
							subredditId: t,
							applied: r
						},
						p = r && r.templateId,
						f = Object(O.R)(d, {
							subredditId: t
						}),
						j = r && Object(u.g)(r),
						g = r ? r.cssClass : void 0,
						I = await Object(c.g)(o(), e, f.name, p, j, g);
					if (I.ok) {
						if (l) {
							let e;
							Object.keys(d.pages.modHub.flairedUsers.userOrder).forEach(t => {
								!1 === d.pages.modHub.flairedUsers.pageInfo[t].hasNextPage && d.pages.modHub.flairedUsers.userOrder[t].length < 50 && (e = t)
							});
							const t = {
								...b,
								key: e
							};
							s(A(t))
						}
						e === (d.user.account && Object(_.e)(d.user.account)) ? s(D(b)) : l || s(R(b))
					} else {
						const e = Object(a.e)(n.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "4hXQvr"
						}), m.b.Error);
						s(Object(a.f)(e))
					}
					return I.ok || I.error
				}
		},
		"./src/reddit/actions/meta.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return l
			})), r.d(t, "h", (function() {
				return b
			})), r.d(t, "b", (function() {
				return p
			})), r.d(t, "e", (function() {
				return f
			})), r.d(t, "g", (function() {
				return _
			})), r.d(t, "f", (function() {
				return O
			})), r.d(t, "k", (function() {
				return j
			})), r.d(t, "c", (function() {
				return g
			})), r.d(t, "d", (function() {
				return I
			})), r.d(t, "i", (function() {
				return S
			})), r.d(t, "j", (function() {
				return E
			}));
			var n = r("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/index.js"),
				s = r("./src/lib/constants/index.ts"),
				i = r("./src/lib/makeActionCreator/index.ts"),
				o = r("./src/lib/makeApiRequest/index.ts"),
				d = r("./src/lib/omitHeaders/index.ts"),
				c = r("./src/reddit/constants/headers.ts"),
				a = r("./src/reddit/selectors/runTimeEnvVars.ts"),
				u = r("./src/reddit/selectors/user.ts");
			const l = "META__GEO_CHANGED",
				b = Object(i.a)(l),
				p = "META__META_RECEIVED",
				f = (Object(i.a)(p), "META__SET_LOCALE"),
				m = Object(i.a)(f),
				_ = e => async (t, r, {
					apiContext: i
				}) => {
					if (!e) return;
					const l = r(),
						b = i();
					let p;
					if (t(m(e)), Object(n.isPseudoLocale)(e) ? (Object(u.H)(l) || Object(a.b)(l)) && (p = e) : p = Object(n.isoLocaleToR2Language)(e), !p) return;
					const f = new URL(window.location.href);
					Object(u.K)(l) ? Object(n.isPseudoLocale)(p) ? f.searchParams.set("locale", p) : (await Object(o.a)(Object(d.a)(b, [c.a]), {
						data: {
							lang: p
						},
						endpoint: `${b.apiUrl}/api/v1/me/prefs`,
						method: s.jb.PATCH,
						type: "json"
					}), f.searchParams.delete("locale")) : f.searchParams.delete("locale"), window.location.href = f.toString()
				}, O = "META__SET_POPULAR_GEO_FILTER", j = Object(i.a)(O), g = "META__PWA_ENTERED", I = "META__PWA_LEFT", S = Object(i.a)(g), E = Object(i.a)(I)
		},
		"./src/reddit/actions/modQueueTriggers/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return d
			}));
			var n = r("./src/reddit/actions/comment/index.ts"),
				s = r("./src/reddit/actions/post.ts"),
				i = r("./src/lib/makeGqlRequest/index.ts"),
				o = r("./src/redditGQL/operations/ModQueueTriggers.json");
			const d = ({
				commentIds: e = [],
				postIds: t = []
			}) => async (r, d, {
				gqlContext: c
			}) => {
				var a, u;
				if (!e.length && !t.length) return;
				const l = await ((e, t) => Object(i.a)(e, {
					...o,
					variables: t
				}))(c(), {
					commentIds: e,
					postIds: t
				});
				if (l.ok) {
					const e = l.body;
					if (e.data.commentsByIds) {
						const t = Object.fromEntries(null === (a = e.data.commentsByIds) || void 0 === a ? void 0 : a.filter(e => {
							var t;
							return null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
						}).map(e => {
							var t;
							return [null == e ? void 0 : e.id, {
								modQueueTriggers: null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
							}]
						}));
						r(Object(n.i)(t))
					}
					if (e.data.postsInfoByIds) {
						const t = Object.fromEntries(null === (u = e.data.postsInfoByIds) || void 0 === u ? void 0 : u.filter(e => {
							var t;
							return null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
						}).map(e => {
							var t;
							return [null == e ? void 0 : e.id, {
								modQueueTriggers: null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
							}]
						}));
						r(Object(s.S)(t))
					}
				}
			}
		},
		"./src/reddit/actions/pages/postCreation.ts": function(e, t, r) {
			"use strict";
			r.r(t), r.d(t, "PAGE_PENDING", (function() {
				return N
			})), r.d(t, "PAGE_LOADED", (function() {
				return L
			})), r.d(t, "PAGE_FAILED", (function() {
				return P
			})), r.d(t, "pagePending", (function() {
				return U
			})), r.d(t, "pageLoaded", (function() {
				return G
			})), r.d(t, "pageFailed", (function() {
				return F
			})), r.d(t, "postCreationPageDataRequested", (function() {
				return q
			})), r.d(t, "postCreationPageRequested", (function() {
				return M
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/react-router-redux/es/index.js"),
				s = r("./src/lib/filterQueryParams/index.ts"),
				i = r("./src/lib/isFakeSubreddit/index.ts"),
				o = r("./src/lib/makeActionCreator/index.ts"),
				d = r("./src/lib/makePostCreationPageKey/index.ts"),
				c = r("./src/lib/pageTitle.ts"),
				a = r("./src/reddit/actions/contentControls/index.ts"),
				u = r("./src/reddit/actions/economics/helpers/async.ts"),
				l = r("./src/reddit/actions/externalAccount.ts"),
				b = r("./src/reddit/actions/gold/powerups.ts"),
				p = r("./src/reddit/actions/platform.ts"),
				f = r("./src/reddit/actions/post.ts"),
				m = r("./src/reddit/actions/postCreation/general.ts"),
				_ = r("./src/reddit/actions/profile/index.ts"),
				O = r("./src/reddit/actions/subreddit.ts"),
				j = r("./src/reddit/actions/subredditDuplicates.ts"),
				g = r("./src/config.ts"),
				I = r("./src/lib/constants/index.ts"),
				S = r("./src/lib/makeApiRequest/index.ts"),
				E = r("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				y = r("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				h = r("./src/reddit/helpers/timeApiRoute/index.ts"),
				T = r("./src/reddit/models/User/index.ts"),
				v = r("./src/reddit/selectors/contentControls.ts"),
				w = r("./src/reddit/selectors/postCollection.ts"),
				x = r("./src/reddit/selectors/postCreations.ts"),
				C = r("./src/reddit/selectors/posts.ts"),
				k = r("./src/reddit/selectors/profile.ts"),
				D = r("./src/reddit/selectors/subreddit.ts"),
				R = r("./src/reddit/selectors/user.ts");
			const A = e => {
					const t = e.platform.currentPage;
					let r = "Reddit";
					if (t && t.urlParams.subredditName) {
						const {
							subredditName: n
						} = t.urlParams, s = Object(D.w)(e, {
							subredditName: n
						});
						s && (r = s.name)
					}
					return Object(c.m)(r)
				},
				N = "POST_CREATION__PAGE_PENDING",
				L = "POST_CREATION__PAGE_LOADED",
				P = "POST_CREATION__PAGE_FAILED",
				U = Object(o.a)(N),
				G = Object(o.a)(L),
				F = Object(o.a)(P),
				B = () => async (e, t) => {
					const r = t(),
						n = Object(x.a)(r);
					n !== Object(x.mb)(r) && e(Object(m.g)({
						submissionType: n
					}))
				}, q = e => async (t, r, n) => {
					const {
						collectionId: s,
						profileName: o,
						subredditName: c
					} = e, u = Object(d.a)(e), p = r(), f = p.creations.api.page.pending[u], m = p.creations.api.page.fetched[u], j = p.creations.api.page.error[u];
					if (f) return;
					if (m && !j) return void t(B());
					const y = [];
					t(U({
						key: u
					}));
					let w = c;
					!c && o && (w = `u_${o}`), y.push(((e, t) => Object(S.a)(e, {
						method: I.jb.GET,
						endpoint: Object(E.a)(`${g.a.gatewayUrl}/desktopapi/v1/submitpage`),
						data: {
							subreddit: t.subredditName,
							collection_id: t.collectionId
						}
					}))(n.apiContext(), {
						subredditName: w,
						collectionId: s
					})), o && (y.push(t(_.d(o))), y.push(t(_.b(o))));
					const [x] = await Object(h.a)("postCreation", () => Promise.all(y));
					if (x.ok) {
						const e = x.body,
							{
								posts: n = {},
								subredditAboutInfo: s
							} = e;
						if (t(G({
								key: u,
								meta: p.meta,
								...e,
								posts: n
							})), !Object(R.K)(r())) return;
						if (s) {
							const e = Object.keys(s)[0];
							await t(Object(b.m)(e, {
								fullData: !0,
								includeIdentity: !1
							}))
						}
						t(B());
						const o = [];
						o.push(t(l.o()));
						const d = Object(R.k)(r());
						if (d && d.hasUserProfile && o.push(t(_.d(Object(T.e)(d)))), c && !Object(i.a)(c)) {
							o.push(t(O.o(c))), !!Object(v.b)(r(), {
								subredditName: c
							}) || o.push(t(Object(a.a)(c)))
						}
						await Promise.all(o)
					} else t(F({
						error: x.error,
						key: u
					}))
				}, M = e => async (t, r) => {
					const {
						subredditName: i,
						profileName: o
					} = e.params, d = e.queryParams, c = d.collection;
					if (await t(q({
							collectionId: c,
							profileName: o,
							subredditName: i
						})), !Object(R.K)(r())) return void Object(y.a)(t, r());
					let a;
					if (i ? (a = Object(D.w)(r(), {
							subredditName: i
						}), await t(Object(u.a)({
							subredditName: i
						}))) : o && (a = Object(k.j)(r(), {
							profileName: o
						})), d.source_id) await t(((e, t) => async (r, n) => {
						const {
							subredditName: s,
							profileName: i
						} = e, o = [];
						let d;
						s ? d = Object(D.C)(n(), s) : i && (d = Object(R.gb)(n(), {
							userName: i
						})), d && o.push(r(Object(j.b)(d, t))), o.push(r(Object(f.R)(t))), await Promise.all(o);
						const c = Object(C.f)(n(), {
							postId: t
						});
						r(Object(m.m)({
							postId: t,
							postTitle: c ? c.title : ""
						}))
					})(e.params, d.source_id));
					else if (c) {
						const i = Object(w.q)(r(), {
							collectionId: c
						});
						a && i && i.subredditId === a.id || t(Object(n.c)(Object(s.a)(e.url, ["collection"])))
					}
					t(p.m({
						title: A(r())
					}))
				}
		},
		"./src/reddit/actions/pages/postDraft.ts": function(e, t, r) {
			"use strict";
			r.r(t), r.d(t, "PAGE_PENDING", (function() {
				return p
			})), r.d(t, "PAGE_LOADED", (function() {
				return f
			})), r.d(t, "PAGE_FAILED", (function() {
				return m
			})), r.d(t, "pagePending", (function() {
				return _
			})), r.d(t, "pageLoaded", (function() {
				return O
			})), r.d(t, "pageFailed", (function() {
				return j
			})), r.d(t, "postDraftPageDataRequested", (function() {
				return g
			})), r.d(t, "postDraftRequested", (function() {
				return I
			}));
			var n = r("./src/lib/makeActionCreator/index.ts"),
				s = r("./src/lib/makePostDraftPageKey/index.ts"),
				i = r("./src/reddit/actions/profile/index.ts"),
				o = r("./src/config.ts"),
				d = r("./src/lib/constants/index.ts"),
				c = r("./src/lib/makeApiRequest/index.ts"),
				a = r("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				u = r("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				l = r("./src/reddit/endpoints/post/draft/helpers.ts"),
				b = r("./src/reddit/helpers/timeApiRoute/index.ts");
			const p = "POST_DRAFT__PAGE_PENDING",
				f = "POST_DRAFT__PAGE_LOADED",
				m = "POST_DRAFT__PAGE_FAILED",
				_ = Object(n.a)(p),
				O = Object(n.a)(f),
				j = Object(n.a)(m),
				g = e => async (t, r, n) => {
					const {
						draftId: p,
						profileName: f
					} = e, m = Object(s.a)(e), _ = r(), g = _.creations.api.page.pending[m], I = _.creations.api.page.fetched[m], S = _.creations.api.page.error[m];
					if (g || I && !S || !p) return;
					t(i.d(f));
					const E = await Object(b.a)("postDraft", () => ((e, t, r) => Object(c.a)(e, {
						endpoint: Object(a.a)(Object(u.a)(`${o.a.gatewayUrl}/desktopapi/v1/draftpreviewpage/${r}/${t}`)),
						method: d.jb.GET
					}))(n.apiContext(), p, f));
					if (E.ok) {
						const e = E.body;
						e.drafts[p].kind = Object(l.b)(e.drafts[p].kind), t(O({
							...e,
							key: m
						}))
					} else t(j({
						error: E.error,
						key: m
					}))
				}, I = e => async (t, r, n) => {
					await t(g(e.params))
				}
		},
		"./src/reddit/actions/pages/subreddit.ts": function(e, t, r) {
			"use strict";
			r.r(t), r.d(t, "isGQLSubredditPageExtra", (function() {
				return Ke
			})), r.d(t, "handleSubredditPageApiError", (function() {
				return We
			})), r.d(t, "SUBREDDIT_PENDING", (function() {
				return He
			})), r.d(t, "SUBREDDIT_LOADED", (function() {
				return ze
			})), r.d(t, "SUBREDDIT_FAILED", (function() {
				return Je
			})), r.d(t, "subredditPending", (function() {
				return $e
			})), r.d(t, "subredditLoaded", (function() {
				return Ve
			})), r.d(t, "subredditFailed", (function() {
				return Ye
			})), r.d(t, "subredditDataRequested", (function() {
				return Xe
			})), r.d(t, "subredditDataFirstChunkRequested", (function() {
				return Ze
			})), r.d(t, "makeSubredditPageKey", (function() {
				return tt
			})), r.d(t, "subredditRequested", (function() {
				return rt
			})), r.d(t, "SUBREDDIT_INVALIDATE_LISTING", (function() {
				return nt
			})), r.d(t, "subredditInvalidateListing", (function() {
				return st
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeRequest/index.ts"),
				i = r("./node_modules/lodash/find.js"),
				o = r.n(i),
				d = r("./node_modules/lodash/pick.js"),
				c = r.n(d),
				a = r("./node_modules/react-router-redux/es/index.js"),
				u = r("./src/lib/constants/index.ts"),
				l = r("./src/lib/countrySites/index.ts"),
				b = r("./src/lib/isAdHocMultireddit/index.ts"),
				p = r("./src/lib/isFakeSubreddit/index.ts"),
				f = r("./src/lib/makeActionCreator/index.ts"),
				m = r("./src/lib/makeListingKey/index.ts"),
				_ = r("./src/lib/makeSearchKey/index.ts"),
				O = r("./src/lib/performanceTimings/index.tsx"),
				j = r("./src/lib/safeGet/index.ts"),
				g = r("./src/reddit/actions/ads/index.ts"),
				I = r("./src/reddit/actions/communityFlairs/index.ts"),
				S = r("./src/reddit/actions/contentGate.ts"),
				E = r("./src/reddit/actions/discoveryUnit.ts"),
				y = (r("./src/reddit/actions/downToChat.ts"), r("./src/reddit/actions/economics/helpers/async.ts")),
				h = r("./src/reddit/actions/economics/predictions/index.ts"),
				T = r("./src/reddit/actions/externalAccount.ts"),
				v = r("./src/reddit/actions/gold/powerups.ts"),
				w = r("./src/reddit/actions/grantUserFlair/index.ts"),
				x = r("./src/reddit/actions/meta.ts"),
				C = r("./src/reddit/actions/modQueueTriggers/index.ts"),
				k = r("./src/reddit/actions/pages/search/index.ts"),
				D = r("./src/reddit/actions/platform.ts"),
				R = r("./src/reddit/actions/publicAccessNetwork/api.ts"),
				A = r("./src/reddit/actions/seo/linksModule.ts"),
				N = r("./src/reddit/actions/seo/topicLinks.ts"),
				L = r("./src/lib/makeGqlRequest/index.ts"),
				P = (r("./src/redditGQL/operations/SubredditInfo.json"), r("./src/reddit/helpers/graphql/normalizeSubredditLinksFromGql/index.ts")),
				U = r("./src/reddit/helpers/graphql/normalizeSubredditTopicLinksFromGql/index.ts"),
				G = (r("./src/reddit/selectors/seo/linksModule.ts"), r("./src/reddit/selectors/seo/topicLinks.ts"), r("./src/reddit/selectors/subreddit.ts")),
				F = r("./src/reddit/selectors/widgets.ts");
			const B = (e, t) => async (r, n) => {
				const s = n(),
					i = Object(G.R)(s, {
						subredditId: e
					}),
					o = Object(F.j)(s, {
						subredditId: e
					});
				i.isNSFW || (null == o ? void 0 : o.length) > 0 && o.some(e => "community-list" === e) || r(Object(A.e)({
					id: e,
					data: t
				}))
			}, q = (e, t) => async r => {
				t && r(Object(N.b)({
					id: e,
					data: t
				}))
			};
			var M = r("./src/reddit/actions/structuredStyles/index.ts"),
				Q = r("./src/reddit/actions/subreddit.ts"),
				K = r("./src/reddit/actions/toaster.ts"),
				W = r("./src/reddit/helpers/localStorage/index.ts"),
				H = r("./src/reddit/models/Subreddit/index.ts"),
				z = r("./src/reddit/models/Toast/index.ts"),
				J = r("./src/reddit/routes/postCreation/constants.ts"),
				$ = r("./src/reddit/selectors/isModeratorOfSubreddit.ts"),
				V = r("./src/reddit/selectors/platform.ts"),
				Y = r("./src/reddit/selectors/user.ts");
			const X = () => async (e, t, r) => {
				const n = t(),
					s = Object(V.e)(n);
				if (!s || s.type !== H.f.Public) return;
				const i = s.name,
					o = Object(V.m)(n),
					d = Object(G.t)(n, {
						subredditName: i
					});
				if (!d) return;
				const {
					activity7Day: c
				} = d, u = !!c && c >= 51 && c <= 100, l = !i || Object(p.a)(i), b = o && o.urlParams.subredditName === i, f = Object(Y.K)(n), m = Object($.c)(n, {
					subredditId: Object(G.C)(n, i)
				});
				if (l || b || Object(W.G)() || !u || !f || m) return;
				const _ = Object(F.d)(t(), {
					subredditName: i
				});
				if (!_ || !_.currentlyViewingCount) return;
				const O = (24 * _.currentlyViewingCount * 7).toString(),
					j = O[0].padEnd(O.length, "0");
				e(Object(K.f)({
					buttonAction: async () => e(Object(a.b)(`/r/${i}${J.b}`)),
					buttonText: "Create Post",
					duration: -1,
					id: "createPostCta",
					kind: z.b.Modal,
					name: "createPostCta",
					secondButtonAction: async () => Object(W.Jb)(),
					secondButtonText: "Dismiss",
					text: `There have been over ${j} visits to r/${i} in the past week. Create a new post and start the next conversation.`
				}))
			};
			var Z = r("./src/reddit/actions/subreddit/questions.ts"),
				ee = r("./src/reddit/actions/subredditModeration/modUserNotes.ts"),
				te = r("./src/reddit/actions/subredditSettings.ts"),
				re = r("./src/reddit/actions/tags/index.ts"),
				ne = r("./src/reddit/actions/userFlair/userFlair.ts"),
				se = r("./src/reddit/constants/history.ts"),
				ie = r("./src/reddit/constants/page.ts"),
				oe = r("./src/reddit/constants/parameters.ts"),
				de = r("./src/reddit/constants/postLayout.ts"),
				ce = r("./src/reddit/contexts/PageLayer/index.tsx"),
				ae = r("./src/reddit/endpoints/gold/topAwarded.ts"),
				ue = r("./src/reddit/endpoints/governance/posts.ts"),
				le = r("./src/reddit/endpoints/page/subredditPage.ts"),
				be = r("./src/lib/base64/index.ts"),
				pe = r("./src/reddit/constants/graphql.ts"),
				fe = r("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				me = r("./src/redditGQL/operations/SubredditPageExtra.json");
			var _e = r("./src/reddit/endpoints/profile/info.ts"),
				Oe = r("./src/reddit/helpers/canonicalUrls.ts"),
				je = r("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				ge = r("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				Ie = r("./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts");

			function Se({
				econLeaderboards: e,
				identity: t,
				trendingSubreddits: r
			}) {
				const n = e.topAwardedPosts.map(e => e.post).filter(e => !e.removedBy && !e.isNsfw);
				return Object(Ie.b)(n, r, t)
			}
			var Ee = r("./src/reddit/helpers/graphql/normalizeSubredditRulesFromGql/index.ts"),
				ye = r("./src/reddit/helpers/trackers/communityTopics.ts"),
				he = r("./src/reddit/helpers/trackers/feed.ts"),
				Te = r("./src/reddit/models/ModeratingSubreddits/index.ts"),
				ve = r("./src/reddit/models/RichTextJson/index.ts"),
				we = r("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				xe = r("./src/reddit/selectors/communityFlairs.ts"),
				Ce = r("./src/reddit/selectors/experiments/econ/powerupsAward.ts"),
				ke = r("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				De = r("./src/reddit/selectors/experiments/topPosts.ts"),
				Re = r("./src/reddit/selectors/gold/powerups/index.ts"),
				Ae = r("./src/reddit/selectors/inlineSubredditEditing.ts"),
				Ne = r("./src/reddit/selectors/moderatorPermissions.ts"),
				Le = r("./src/reddit/selectors/multireddit.ts"),
				Pe = r("./src/reddit/selectors/posts.ts"),
				Ue = r("./src/lib/initializeClient/installReducer.ts"),
				Ge = r("./src/reddit/reducers/features/modUserNotes/index.ts"),
				Fe = r("./node_modules/uuid/v4.js"),
				Be = r.n(Fe),
				qe = r("./src/reddit/helpers/locales.ts"),
				Me = r("./src/reddit/selectors/experiments/countrySites.ts"),
				Qe = r("./src/reddit/selectors/meta.ts");

			function Ke(e) {
				return Boolean(e && e.subredditInfoByName)
			}
			Object(Ue.a)({
				features: {
					modUserNotes: Ge.a
				}
			});
			const We = (e, t) => async r => {
				if (!e.ok && e.body && (e => !!e.reason)(e.body)) {
					const {
						body: {
							data: n,
							reason: s
						}
					} = e, i = n ? n.account : void 0, o = n && n.features || void 0, d = t ? t.toLowerCase() : "";
					if (404 === e.status)
						if (s === H.e.NotFoundSubreddit) r(S.p({
							account: i,
							features: o,
							subredditName: d
						}));
						else if (s === H.e.BannedSubreddit) {
						const e = n ? n.banMessage || n.ban_message : void 0;
						r(S.n({
							banMessage: e,
							account: i,
							features: o,
							subredditName: d
						}))
					}
					if (451 === e.status && r(S.o({
							account: i,
							features: o,
							subredditName: d
						})), 403 === e.status)
						if (s === H.e.GoldSubreddit) r(S.s({
							account: i,
							features: o,
							subredditName: d
						}));
						else if (s === H.e.PrivateSubreddit) r(S.t({
						account: i,
						features: o,
						subredditDescription: n.description || "",
						subredditName: d,
						isContributorRequestsDisabled: !!n.isContributorRequestsDisabled,
						isContributorRequestTimestamp: n.isContributorRequestTimestamp ? parseInt(n.isContributorRequestTimestamp, 10) : void 0,
						subredditId: n.id
					}));
					else if (s === H.e.QuarantinedSubreddit) {
						const e = !n || void 0 === n.quarantineRequiresEmailOptin || n.quarantineRequiresEmailOptin;
						r(S.v({
							account: i,
							features: o,
							subredditName: d,
							quarantineRequiresEmail: e,
							quarantineMessage: n.quarantineMessage,
							quarantineMessageHtml: n.quarantineMessageHtml || "",
							quarantineMessageRTJson: n.quarantineMessageRTJson || ve.i
						}))
					} else if (s === H.e.GatedSubreddit) {
						const {
							interstitialWarningMessage: e,
							interstitialWarningMessageHtml: t,
							interstitialWarningMessageRTJson: s
						} = n;
						r(S.r({
							account: i,
							features: o,
							subredditName: d,
							interstitialWarningMessage: e,
							interstitialWarningMessageHtml: t,
							interstitialWarningMessageRTJson: s
						}))
					}
				}
			}, He = "PAGE__SUBREDDIT_PENDING", ze = "PAGE__SUBREDDIT_LOADED", Je = "PAGE__SUBREDDIT_FAILED", $e = Object(f.a)(He), Ve = Object(f.a)(ze), Ye = Object(f.a)(Je), Xe = (e, t, r, i) => async (d, c, a) => {
				var l, b, f, m, _, S, E, k, R, A, N, F, M, W, H, J, $, X;
				const ie = c(),
					oe = Object(Y.J)(ie) || Object(Y.K)(ie);
				if (Object(j.a)(ie.listings.postOrder.api.pending, e)) return;
				const Oe = null === (b = null === (l = Object(V.b)(ie)) || void 0 === l ? void 0 : l.routeMatch) || void 0 === b ? void 0 : b.route.chunk,
					{
						currentPage: je
					} = ie.platform,
					{
						countryCode: ge,
						languageCode: Ie
					} = (null == je ? void 0 : je.urlParams) || {},
					Te = Object(p.a)(t, {
						countryCode: ge,
						languageCode: Ie
					}),
					ve = Object(p.c)(t, {
						countryCode: ge,
						languageCode: Ie
					}),
					xe = (Object(p.b)(t, {
						countryCode: ge,
						languageCode: Ie
					}) || ve) && ie.posts.recent.length ? {
						...r,
						recentPostIds: ie.posts.recent
					} : r;
				xe.layout = de.e[Object(ce.R)(ie, {})], ve && (xe.forceGeopopular = !0), d($e({
					key: e
				}));
				const De = !Te && Object(V.l)(ie) && Object(ke.b)(ie);
				let Ne;
				if (r.sort === u.W.AWARDED && ve) Ne = Object(ae.a)(a.gqlContext(), {
					top: 0,
					includeListingMetadata: !0
				}).then(e => {
					const t = e.body;
					return {
						...e,
						body: Se(t.data)
					}
				});
				else {
					const e = De ? () => Object(le.b)(a.gqlContext(), Object(le.c)(ie, t, xe, !0), oe) : () => Object(le.a)(a.apiContext(), t, xe);
					Ne = Object(O.i)(e, {
						name: De ? "fetchSubredditPageFromGql" : "fetchSubredditPage",
						page: Oe,
						isLoggedIn: oe
					})
				}
				const Le = Object(G.Q)(c(), {
						subredditId: Object(G.C)(c(), t)
					}).length > 0,
					Pe = Object(O.i)(() => (async function(e, t) {
						return Object(L.a)(e, {
							...me,
							variables: t
						})
					})(a.gqlContext(), ((e, {
						after: t,
						isMobile: r,
						subredditName: n,
						isFake: s,
						isLoggedIn: i,
						layout: o,
						limit: d,
						hasRules: c,
						sort: a,
						t: u
					}) => {
						var l, b;
						const p = {
							subredditName: n,
							isFake: s,
							sort: a,
							adContext: {
								layout: o ? o.toUpperCase() : pe.a.Card,
								reddaid: e.user.reddaid
							},
							includeIdentity: i,
							includePowerups: !s,
							includeQuestions: i && !s,
							includeRules: !s && !c,
							includeRedditorKarma: i && !(null === (b = null === (l = e.user.account) || void 0 === l ? void 0 : l.karma) || void 0 === b ? void 0 : b.total),
							includeSubredditLinks: !i,
							includeTopicLinks: !i
						};
						return a && (p.sort = a.toUpperCase()), u && (p.range = u.toUpperCase()), r ? p.pageSize = Object(fe.a)(o) : d && (p.pageSize = d), t && (p.after = Object(be.a)(t)), p
					})(ie, {
						after: r.after,
						isLoggedIn: oe,
						subredditName: t,
						hasRules: Le,
						isFake: Te,
						isMobile: r.isMobile,
						layout: r.layout,
						limit: r.limit,
						sort: r.sort,
						t: r.t
					})), {
						name: "fetchSubredditPageExtra",
						page: Oe,
						isLoggedIn: oe
					}),
					Ue = Be()();
				let Ge, Fe;
				De ? Ge = await Ne : [Ge, Fe] = await Promise.all([Ne, Pe]);
				const He = Fe && Object(s.c)(Fe) ? Fe.body.data : null,
					ze = Ge.body,
					Je = (null == ze ? void 0 : ze.subreddits) ? ((e, t) => {
						var r;
						return null === (r = o()(e, e => (null == e ? void 0 : e.name.toLowerCase()) === t.toLowerCase())) || void 0 === r ? void 0 : r.id
					})(ze.subreddits, t) : null;
				d(D.n(Ge.status));
				const Ze = `error-${e}`,
					et = Te || Je;
				if (Ge.ok && et) {
					if (!Te && Je) {
						let e;
						e = De ? ze.powerups : Object(v.e)(null == He ? void 0 : He.subredditInfoByName, null == He ? void 0 : He.identity);
						const t = (null === (m = null === (f = null == ze ? void 0 : ze.subredditAboutInfo) || void 0 === f ? void 0 : f[Je]) || void 0 === m ? void 0 : m.detectedLanguage) || (null === (_ = null == He ? void 0 : He.subredditInfoByName) || void 0 === _ ? void 0 : _.detectedLanguage);
						Object(Qe.d)(ie) && t && Object(Me.c)(ie) && await Object(qe.a)(t, d), Object(v.b)(d, Je, e), (null == He ? void 0 : He.subredditInfoByName) && d(Object(h.n)(Je, He.subredditInfoByName.predictionTournaments || [])), Object(Re.h)(c(), {
							subredditId: Je
						}) && Object(Ce.a)(c())
					}
					let n;
					ze.geoFilter && d(Object(x.k)(ze.geoFilter));
					const s = ze.postIds.filter(e => !!ze.posts[e].isMeta);
					if (s.length && Je) {
						const e = Object(O.i)(() => Object(ue.a)(a.apiContext(), Je, s), {
								name: "getGovernanceData",
								page: Oe,
								isLoggedIn: oe
							}),
							t = await e;
						t.ok && (n = t.body)
					}
					if (He) {
						const e = null === (E = null === (S = He.identity) || void 0 === S ? void 0 : S.redditor) || void 0 === E ? void 0 : E.karma,
							t = {
								karma: {
									..._e.a,
									...e
								}
							};
						ze.account && Object.assign(ze.account, t)
					}
					if (Je) {
						let e;
						De ? e = null === (k = ze.subredditAboutInfo[Je]) || void 0 === k ? void 0 : k.notificationLevel : Ke(He) && (e = null === (R = He.subredditInfoByName) || void 0 === R ? void 0 : R.notificationLevel), ze.subredditAboutInfo[Je].notificationLevel = e
					}
					const o = null === (A = ze.subredditPermissions) || void 0 === A ? void 0 : A.posts;
					!De && o && d(Object(C.a)({
						postIds: ze.postIds
					})), d(Ve({
						key: e,
						meta: ie.meta,
						governance: n,
						correlationId: Ue,
						...ze,
						postIds: ze.postIds
					}));
					const u = null === (F = null === (N = Object(V.b)(ie)) || void 0 === N ? void 0 : N.locationState) || void 0 === F ? void 0 : F[se.b.FeedLoadReason];
					if (Object(he.b)(r.isRefresh ? se.a.UserRefresh : null != u ? u : se.a.InitialLoad)(c()), !Te) {
						const e = Object(G.C)(c(), t);
						De && ze.subredditRules ? d(Q.t({
							rules: {
								rules: ze.subredditRules
							},
							subredditId: e
						})) : (null === (M = null == He ? void 0 : He.subreddit) || void 0 === M ? void 0 : M.rules) && d(Q.t({
							rules: Object(Ee.a)(He.subreddit.rules),
							subredditId: e
						}));
						const r = Object(I.c)(ze.posts, e),
							n = Object(I.b)(ze.structuredStyles),
							s = (n ? Object(I.d)(n) : []).concat(r);
						d(Object(I.a)(s, e))
					}
					if (i && d(K.g(Ze)), d(Object(g.b)(we.a.SUBREDDIT)), d(Object(T.p)()), Je) {
						let e, r, n;
						if (De ? (e = ze.questions, r = ze.subredditLinks, n = ze.subredditTopicLinks) : (e = null == He ? void 0 : He.subredditInfoByName, r = Object(P.a)({
								data: {
									subredditInfoById: null == He ? void 0 : He.subredditInfoByName
								}
							}), n = Object(U.a)({
								data: {
									subredditInfoById: null == He ? void 0 : He.subredditInfoByName
								}
							})), Object(Z.a)(d, Je, e), d(B(Je, r)), d(q(Je, n)), !De && (null === (H = null === (W = null == He ? void 0 : He.subredditInfoByName) || void 0 === W ? void 0 : W.elements) || void 0 === H ? void 0 : H.edges)) {
							const e = (null === ($ = null === (J = null == He ? void 0 : He.subredditInfoByName) || void 0 === J ? void 0 : J.elements) || void 0 === $ ? void 0 : $.edges).map(e => {
								var t, r;
								return null === (r = null === (t = e.node) || void 0 === t ? void 0 : t.moderationInfo) || void 0 === r ? void 0 : r.lastAuthorModNote
							});
							d(Object(ee.b)({
								subredditId: Je,
								nodes: e
							}))
						} else if (De && (null == ze ? void 0 : ze.postIds)) {
							const e = ze.postIds.map(e => null == ze ? void 0 : ze.posts[e].lastAuthorModNote);
							d(Object(ee.b)({
								subredditId: Je,
								nodes: e
							}))
						}
						if (De && ze.appliedFlair) {
							const e = ze.appliedFlair;
							if ((null === (X = ie.user.account) || void 0 === X ? void 0 : X.displayName) && e.flair && (d(Object(w.b)({
									subredditId: Je,
									applied: e.flair,
									userName: ie.user.account.displayName
								})), d(Object(ne.userFlairSaveTemplateSuccess)({
									subredditId: Je,
									template: e.flair
								}))), e.displaySettings) {
								const t = e.displaySettings;
								d(Object(ne.userFlairAllowAssignOwnSettingSuccess)({
									subredditId: Je,
									canAssignOwn: t.isSelfAssignable
								})), d(Object(ne.userFlairMutated)({
									subredditId: Je,
									displaySettings: t
								}))
							}
						}
						const s = [Object(O.i)(() => d(Object(y.a)({
							subredditId: Je,
							postIds: ze.postIds,
							skip: ["subscription"]
						})), {
							name: "fetchAllEconomicsData",
							page: Oe,
							isLoggedIn: oe
						})];
						if (Object(Ae.a)(c(), {
								subredditId: Je
							})) {
							const e = Object(O.i)(() => d(Object(te.h)(t, Je)), {
									name: "subredditSettingsRequested",
									isLoggedIn: oe,
									page: Oe
								}),
								r = Object(O.i)(() => d(Object(re.g)(Je, ye.a.idCard)), {
									name: "subredditTagsRequested",
									isLoggedIn: oe,
									page: Oe
								});
							s.push(e, r)
						}
						0, await Promise.all(s)
					}
				} else {
					const s = Ge.ok ? void 0 : Ge.error;
					if (Object(he.a)(s ? `${Ge.status||"000"}: ${s.type}` : "000: UNKNOWN_ERROR")(c()), 403 === Ge.status || 404 === Ge.status || 451 === Ge.status) return void d(We(Ge, t));
					d(Ye({
						error: !Ge.ok && Ge.error || {
							type: u.I.NOT_FOUND_ERROR
						},
						key: e,
						...ze
					})), i && d(K.f({
						id: Ze,
						kind: z.b.Error,
						text: n.fbt._("Sorry, we couldn't load posts for this page.", null, {
							hk: "CvZvm"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "3gV6S0"
						}),
						buttonAction: Xe(e, t, r, i)
					}))
				}
			}, Ze = (e, t, r) => async (n, s) => {
				const i = s(),
					o = Object(m.a)(e, t.sort, t);
				Object(Pe.z)(i, {
					listingKey: o
				}).length > 0 || await n(Xe(o, e, t, r))
			}, et = (e, t, r, n) => {
				if (Object(p.a)(t, {
						countryCode: r,
						languageCode: n
					})) {
					if (Object(b.a)(t)) {
						return Object(Le.a)(e, {
							listingName: t
						}).displayText
					}
					switch (t.toLowerCase()) {
						case ie.d.Popular:
							return "r/popular";
						case ie.d.All:
							return "r/all"
					}
				}
				return Object(G.U)(e, {
					subredditName: t
				})
			}, tt = (e, t, r, n) => n ? Object(_.b)(e.subredditName, void 0, n) : Object(m.a)(e.subredditName, t, r), rt = (e, t) => async (r, n) => {
				var s, i, o;
				const {
					countryCode: d,
					languageCode: b
				} = e.params, f = Object(l.c)(e.params), {
					styling: S
				} = e.queryParams, y = n(), h = Object(je.a)(e.params, y);
				if ("Popular" === f) return void r(Object(a.c)(e.url.replace("r/Popular", "r/popular")));
				if ("All" === f) return void r(Object(a.c)(e.url.replace("r/All", "r/all")));
				const v = Object(_.d)(e.queryParams, Object(Y.eb)(y)),
					w = tt({
						subredditName: f,
						countryCode: d,
						languageCode: b
					}, h, e.queryParams, v),
					x = h,
					C = Object(j.a)(y.listings.postOrder.api.error, w),
					A = Object(j.a)(y.listings.postOrder.api.pending, w);
				let N = !!Object(j.a)(y.listings.postOrder.ids, w);
				const L = Object(j.a)(y.listings.postOrder.listingSort, w);
				L && L.hasChanged && (N = !1);
				let P = Object(G.C)(y, f);
				const U = (e, t) => "true" === S && ((e, t) => Object(Ne.b)(Te.c.config)(e, {
						subredditId: t
					}) || Object(Ne.b)(Te.c.flair)(e, {
						subredditId: t
					}))(e, t),
					F = oe.B in e.queryParams && e.queryParams[oe.B].toUpperCase() || "",
					B = F in u.hc && u.hc[F];
				if (A || N && !C && !t) {
					if (U(y, P) && r(M.i(P)), N) {
						const t = et(n(), f, d, b);
						r(D.m({
							title: t
						})), (null === (s = y.listings.postOrder.correlationIds) || void 0 === s ? void 0 : s[w]) && r(D.o({
							correlationId: y.listings.postOrder.correlationIds[w]
						})), Object(Oe.e)(n(), r, e), window.addEventListener("load", () => {
							r(Object(T.p)())
						}), y.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
							r(Object(g.b)(we.a.SUBREDDIT))
						}), r(X())
					}
					return
				}
				r(E.g());
				const q = null === (o = null === (i = Object(V.b)(y)) || void 0 === i ? void 0 : i.routeMatch) || void 0 === o ? void 0 : o.route.chunk,
					Q = Object(Y.K)(n()),
					K = Object(O.i)(() => r(Object(R.c)(`r/${f}`)), {
						name: "rpanConfigRequested",
						isLoggedIn: Q,
						page: q
					});
				if (v) {
					const e = Object(O.i)(() => r(Object(k.d)(w, v, f)), {
						name: "searchDataRequested",
						isLoggedIn: Q,
						page: q
					});
					await e
				} else {
					const t = {
						...c()(e.queryParams, [...oe.m, ...oe.l, oe.i]),
						sort: x,
						t: Object(ge.a)(x, B)
					};
					await r(Xe(w, f, t, !0))
				}
				const W = y.platform.currentPage,
					H = Object(De.d)(y, {
						pageLayer: W
					});
				if (Object(De.a)(H) || Object(De.b)(H) || Object(De.c)(H)) {
					const e = Object(m.a)(f, u.W.TOP, {
							t: u.hc.WEEK
						}),
						t = {
							sort: u.W.TOP,
							t: u.hc.WEEK
						};
					await r(Xe(e, f, t, !1))
				}
				if (P = P || Object(G.C)(n(), f), !Object(xe.a)(y, P) && !Object(p.a)(f, {
						countryCode: d,
						languageCode: b
					})) {
					const e = Object(O.i)(() => r(Object(I.e)(f)), {
						name: "getTopCommunityFlair",
						page: q,
						isLoggedIn: Q
					});
					await e
				}
				U(n(), P) && r(M.i(P)), Object(Oe.e)(n(), r, e);
				const z = et(n(), f);
				r(D.m({
					title: z
				})), r(X()), await K
			}, nt = "PAGE__SUBREDDIT_INVALIDATE_LISTING", st = Object(f.a)(nt)
		},
		"./src/reddit/actions/postCreation/constants.ts": function(e, t, r) {
			"use strict";
			r.d(t, "K", (function() {
				return n
			})), r.d(t, "L", (function() {
				return s
			})), r.d(t, "l", (function() {
				return i
			})), r.d(t, "m", (function() {
				return o
			})), r.d(t, "x", (function() {
				return d
			})), r.d(t, "H", (function() {
				return c
			})), r.d(t, "I", (function() {
				return a
			})), r.d(t, "k", (function() {
				return u
			})), r.d(t, "G", (function() {
				return l
			})), r.d(t, "p", (function() {
				return b
			})), r.d(t, "Q", (function() {
				return p
			})), r.d(t, "n", (function() {
				return f
			})), r.d(t, "D", (function() {
				return m
			})), r.d(t, "s", (function() {
				return _
			})), r.d(t, "c", (function() {
				return O
			})), r.d(t, "b", (function() {
				return j
			})), r.d(t, "d", (function() {
				return g
			})), r.d(t, "e", (function() {
				return I
			})), r.d(t, "f", (function() {
				return S
			})), r.d(t, "g", (function() {
				return E
			})), r.d(t, "h", (function() {
				return y
			})), r.d(t, "i", (function() {
				return h
			})), r.d(t, "j", (function() {
				return T
			})), r.d(t, "q", (function() {
				return v
			})), r.d(t, "S", (function() {
				return w
			})), r.d(t, "R", (function() {
				return x
			})), r.d(t, "T", (function() {
				return C
			})), r.d(t, "U", (function() {
				return k
			})), r.d(t, "V", (function() {
				return D
			})), r.d(t, "W", (function() {
				return R
			})), r.d(t, "X", (function() {
				return A
			})), r.d(t, "Y", (function() {
				return N
			})), r.d(t, "Z", (function() {
				return L
			})), r.d(t, "r", (function() {
				return P
			})), r.d(t, "E", (function() {
				return U
			})), r.d(t, "u", (function() {
				return G
			})), r.d(t, "v", (function() {
				return F
			})), r.d(t, "t", (function() {
				return B
			})), r.d(t, "w", (function() {
				return q
			})), r.d(t, "P", (function() {
				return M
			})), r.d(t, "o", (function() {
				return Q
			})), r.d(t, "y", (function() {
				return K
			})), r.d(t, "cb", (function() {
				return W
			})), r.d(t, "J", (function() {
				return H
			})), r.d(t, "a", (function() {
				return z
			})), r.d(t, "F", (function() {
				return J
			})), r.d(t, "N", (function() {
				return $
			})), r.d(t, "O", (function() {
				return V
			})), r.d(t, "M", (function() {
				return Y
			})), r.d(t, "ab", (function() {
				return X
			})), r.d(t, "C", (function() {
				return Z
			})), r.d(t, "B", (function() {
				return ee
			})), r.d(t, "z", (function() {
				return te
			})), r.d(t, "A", (function() {
				return re
			})), r.d(t, "bb", (function() {
				return ne
			}));
			const n = "SUBMIT_VALIDATION_FIELD_HAS_ERROR",
				s = "SUBMIT_VALIDATION_FIELD_IS_VALID",
				i = "POST_CREATION_EDIT_COMPLETE",
				o = "POST_CREATION_EDIT_FAILED",
				d = "POST_CREATION_PENDING_EDIT",
				c = "POST_CREATION_START_EDITING_POST",
				a = "POST_CREATION_STOP_EDITING_POST",
				u = "EDITOR_CONTENT_KEY__NEW_DRAFT",
				l = "STARTED_CONVERTING_EDITOR_CONTENT",
				b = "FINISHED_CONVERTING_EDITOR_CONTENT",
				p = "POST_CREATION__TOGGLE_EDITOR_MODE",
				f = "POST_CREATION__ERRORS_NO_LONGER_VALID",
				m = "POST_TITLE_FETCHED",
				_ = "INITIALIZE_EDITOR_MODE",
				O = "POST_CREATION__CHANGE_FLAIR",
				j = "POST_CREATION__CHANGE_EVENT_SCHEDULE",
				g = "POST_CREATION__CHANGE_LINK_BODY",
				I = "POST_CREATION__CHANGE_MARKDOWN_BODY",
				S = "POST_CREATION__CHANGE_MEDIA_BODY",
				E = "POST_CREATION__CHANGE_RECAPTCHA",
				y = "POST_CREATION__CHANGE_RTE_STATE",
				h = "POST_CREATION__CHANGE_SUBMISSION_TYPE",
				T = "POST_CREATION__CHANGE_TITLE",
				v = "POST_CREATION__GOV_TYPE_CHANGED",
				w = "POST_CREATION__TOGGLE_IS_CHAT_POST",
				x = "POST_CREATION__TOGGLE_IS_CHANGED",
				C = "POST_CREATION__TOGGLE_IS_GOV",
				k = "POST_CREATION__TOGGLE_IS_NSFW",
				D = "POST_CREATION__TOGGLE_IS_OC",
				R = "POST_CREATION__TOGGLE_IS_POLL",
				A = "POST_CREATION__TOGGLE_IS_SPOILER",
				N = "POST_CREATION__TOGGLE_POST_TO_TWITTER",
				L = "POST_CREATION__TOGGLE_SEND_REPLIES",
				P = "POST_CREATION__INITIALIZE_CROSSPOST_MODE",
				U = "POST_CREATION__RESET_FORM",
				G = "POST_CREATION__MEDIA_UPLOAD_PENDING",
				F = "POST_CREATION__MEDIA_UPLOAD_SUCCEEDED",
				B = "POST_CREATION__MEDIA_UPLOAD_FAILED",
				q = "POST_CREATION__PENDING",
				M = "POST_CREATION__SUCCEEDED",
				Q = "POST_CREATION__FAILED",
				K = "POST_CREATION__POLL_FAILED",
				W = "POST_CREATION__VALIDATION_FAILED",
				H = "POST_CREATION__SUBMIT_VALIDATION_FAILED",
				z = "POST_CREATION__CAPTCHA_REQUIRED",
				J = "POST_CREATION__SET_SUBMIT_MODE",
				$ = "POST_CREATION__SUBREDDIT_CHANGE_PENDING",
				V = "POST_CREATION__SUBREDDIT_WILL_CHANGE",
				Y = "POST_CREATION__SUBREDDIT_CHANGE_CANCELED",
				X = "POST_CREATION__UPDATE_SCHEDULED_POST_ADVANCED_SETTINGS",
				Z = "POST_CREATION__SUBREDDIT_RECOMMENDATION_PENDING",
				ee = "POST_CREATION__SUBREDDIT_RECOMMENDATION_LOADED",
				te = "POST_CREATION__SUBREDDIT_RECOMMENDATION_FAILED",
				re = "POST_CREATION__SUB_REC_IS_INPUT_CHANGED",
				ne = "POST_CREATION__UPDATE_TOURNAMENT"
		},
		"./src/reddit/actions/postCreation/general.ts": function(e, t, r) {
			"use strict";
			r.d(t, "i", (function() {
				return w
			})), r.d(t, "o", (function() {
				return C
			})), r.d(t, "a", (function() {
				return k
			})), r.d(t, "b", (function() {
				return D
			})), r.d(t, "c", (function() {
				return A
			})), r.d(t, "d", (function() {
				return N
			})), r.d(t, "f", (function() {
				return L
			})), r.d(t, "e", (function() {
				return P
			})), r.d(t, "g", (function() {
				return U
			})), r.d(t, "h", (function() {
				return G
			})), r.d(t, "l", (function() {
				return F
			})), r.d(t, "u", (function() {
				return B
			})), r.d(t, "t", (function() {
				return q
			})), r.d(t, "v", (function() {
				return M
			})), r.d(t, "w", (function() {
				return Q
			})), r.d(t, "x", (function() {
				return K
			})), r.d(t, "y", (function() {
				return W
			})), r.d(t, "A", (function() {
				return H
			})), r.d(t, "B", (function() {
				return z
			})), r.d(t, "D", (function() {
				return J
			})), r.d(t, "C", (function() {
				return $
			})), r.d(t, "m", (function() {
				return V
			})), r.d(t, "r", (function() {
				return X
			})), r.d(t, "s", (function() {
				return Z
			})), r.d(t, "q", (function() {
				return ee
			})), r.d(t, "z", (function() {
				return te
			})), r.d(t, "p", (function() {
				return re
			})), r.d(t, "n", (function() {
				return ne
			})), r.d(t, "k", (function() {
				return ae
			})), r.d(t, "j", (function() {
				return be
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/lodash/debounce.js"),
				s = r.n(n),
				i = r("./node_modules/react-router-redux/es/index.js"),
				o = r("./src/lib/isUrl/index.ts"),
				d = r("./src/lib/makeActionCreator/index.ts"),
				c = r("./src/reddit/actions/modal.ts"),
				a = r("./src/reddit/contexts/PageLayer/index.tsx"),
				u = r("./src/reddit/endpoints/post/index.tsx"),
				l = r("./src/redditGQL/operations/WhereToPostSubRec.json"),
				b = r("./src/lib/makeGqlRequest/index.ts"),
				p = r("./src/redditGQL/operations/OpenAISubredditRecommendation.json");
			var f = r("./src/reddit/helpers/correlationIdTracker.ts"),
				m = r("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				_ = r("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				O = r("./src/reddit/helpers/trackers/postComposer.ts"),
				j = r("./src/reddit/models/PostCreationForm/index.ts"),
				g = r("./src/reddit/models/Subreddit/index.ts"),
				I = r("./src/reddit/routes/postCreation/constants.ts"),
				S = r("./src/reddit/selectors/activeModalId.ts"),
				E = r("./src/reddit/selectors/experiments/crosspostRecommendations.ts"),
				y = r("./src/reddit/selectors/postCollection.ts"),
				h = r("./src/reddit/selectors/postCreations.ts"),
				T = r("./src/reddit/selectors/experiments/postCreationSubRec.ts"),
				v = r("./src/reddit/actions/postCreation/constants.ts");
			const w = Object(d.a)(v.n),
				x = Object(d.a)(v.D),
				C = (Object(d.a)(v.s), e => {
					switch (e) {
						case "markdown":
							return "self";
						case "richtext":
						case "richText":
							return "self";
						case "media":
							return "media";
						default:
							return "link"
					}
				}),
				k = Object(d.a)(v.b),
				D = Object(d.a)(v.c),
				R = Object(d.a)(v.d),
				A = Object(d.a)(v.e),
				N = Object(d.a)(v.f),
				L = Object(d.a)(v.g),
				P = Object(d.a)(v.h),
				U = Object(d.a)(v.i),
				G = Object(d.a)(v.j),
				F = Object(d.a)(v.q),
				B = Object(d.a)(v.S),
				q = Object(d.a)(v.R),
				M = (Object(d.a)(v.T), Object(d.a)(v.U)),
				Q = Object(d.a)(v.V),
				K = Object(d.a)(v.W),
				W = Object(d.a)(v.X),
				H = Object(d.a)(v.Y),
				z = Object(d.a)(v.Z),
				J = Object(d.a)(v.bb),
				$ = Object(d.a)(v.ab),
				V = Object(d.a)(v.r),
				Y = s()((e, t) => {
					Object(o.a)(t) && e((e => async (t, r, {
						apiContext: n
					}) => {
						const s = await Object(u.d)(n(), e);
						s.ok && s.body && s.body.json && s.body.json.data && t(x(s.body.json.data))
					})(t))
				}, 500),
				X = e => async t => {
					t(R(e)), Y(t, e)
				}, Z = Object(d.a)(v.E), ee = (e, t) => async (r, n) => {
					r(Z()), r(e ? Object(i.b)(I.b) : Object(i.b)(Object(h.cb)(n(), {
						pageLayer: t
					})))
				}, te = e => async t => {
					t(c.i(e))
				}, re = e => async (t, r) => {
					const n = r(),
						s = Object(a.G)(e),
						i = Object(h.H)(n);
					if (s && i) {
						Object(S.a)(n) !== j.d && t(te(j.d))
					} else t(ee(!1, e))
				}, ne = e => async (t, r) => {
					const n = r();
					Object(y.m)(n, {
						subredditId: e
					}) ? t(c.i(j.a)) : t(c.i(j.c))
				}, se = Object(d.a)(v.B), ie = Object(d.a)(v.C), oe = Object(d.a)(v.z), de = Object(d.a)(v.A), ce = e => async (t, r) => {
					Object(T.d)(r()) !== e && t(de({
						isChanged: e
					}))
				}, ae = () => async (e, t) => {
					const r = t(),
						n = Object(T.k)(r),
						s = Object(T.f)(r);
					if (!n && s)
						if (Object(T.g)(r) || Object(T.h)(r)) {
							const t = r.creations.formData.title,
								n = Object(T.m)(r),
								s = Object(T.l)(r);
							e(be(t, n, s))
						} else Object(T.j)(r) && !Object(T.c)(r) && e(pe())
				}, ue = ["torrents", "IsolatedVocals"], le = ["askreddit", "teenagers"], be = (e, t, r, n) => async (s, i, {
					apiContext: o,
					gqlContext: d
				}) => {
					const c = i();
					if (Object(T.i)(c)) return;
					s(ie());
					const a = Object(f.c)(f.a.PostComposer),
						u = await ((e, t, r, n, s) => Object(b.a)(e, {
							...p,
							variables: {
								title: t,
								body: r,
								link: n,
								correlationId: s
							}
						}))(d(), e, t, r, a),
						l = {};
					let j = {};
					const I = {},
						S = {},
						y = [];
					if (!u.body || !u.ok) return s(ce(!1)), void s(oe()); {
						const {
							data: e
						} = u.body;
						let t = e.openaiSubredditSuggestions.filter(e => !ue.includes(e.name));
						const r = (t = n ? t.filter(e => !n(e)) : t).slice(0, T.a),
							o = r.map(e => {
								const t = e.name;
								return S[t] = {}, y.push(t), t
							});
						if ((Object(T.h)(c) || Object(E.b)(c)) && (e => {
								const t = e.map(e => e.toLowerCase());
								let r = !1;
								return le.forEach(e => {
									t.includes(e) && (r = !0)
								}), r
							})(o)) return s(ce(!1)), s(se({
							subreddits: {},
							subredditsAboutInfo: {},
							unavailableSubreddits: {},
							recSubsDict: {},
							recSubsOrder: []
						})), Object(O.G)(i()), void s(oe());
						r.forEach(e => {
							if (Object(g.j)(e)) {
								const t = Object(_.f)(e);
								I[t.id] = t
							} else if (e && Object.keys(e).length > 0) {
								const t = Object(_.a)(e),
									r = Object(m.a)(e);
								l[t.id] = t, j = {
									...j,
									...r
								}
							}
						})
					}
					s(ce(!1)), s(se({
						subreddits: l,
						subredditsAboutInfo: j,
						unavailableSubreddits: I,
						recSubsDict: S,
						recSubsOrder: y
					})), 0 === Object(T.b)(i()).length && s(oe())
				}, pe = () => async (e, t, {
					apiContext: r,
					gqlContext: n
				}) => {
					const s = t();
					if (Object(T.i)(s)) return;
					e(ie());
					const i = {};
					let o = {};
					const d = {},
						c = {},
						a = [],
						u = await (e => Object(b.a)(e, {
							...l,
							variables: {
								recentSubreddits: []
							}
						}))(n());
					if (!u.ok || !u.body) return e(oe()), void e(ce(!1)); {
						const {
							data: e
						} = u.body;
						(e.whereToPostSuggestions.edges || []).forEach((e, t) => {
							if (t >= T.a) return;
							const r = e.node.subredditInfo;
							if (Object(g.j)(r)) {
								const e = Object(_.f)(r);
								d[e.id] = e
							} else if (r && Object.keys(r).length > 0) {
								const e = Object(_.a)(r),
									t = Object(m.a)(r);
								c[r.name] = {}, a.push(r.name), i[e.id] = e, o = {
									...o,
									...t
								}
							}
						})
					}
					e(ce(!1)), e(se({
						subreddits: i,
						subredditsAboutInfo: o,
						unavailableSubreddits: d,
						recSubsDict: c,
						recSubsOrder: a
					})), 0 === Object(T.b)(t()).length && e(oe())
				}
		},
		"./src/reddit/actions/postFlairStyleTemplates/constants.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return n
			})), r.d(t, "b", (function() {
				return s
			})), r.d(t, "a", (function() {
				return i
			}));
			const n = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_PENDING",
				s = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_LOADED",
				i = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_FAILED"
		},
		"./src/reddit/actions/publicAccessNetwork/api.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return f
			})), r.d(t, "d", (function() {
				return _
			})), r.d(t, "a", (function() {
				return O
			})), r.d(t, "b", (function() {
				return S
			}));
			var n = r("./src/lib/makeActionCreator/index.ts"),
				s = r("./src/reddit/actions/post.ts"),
				i = r("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				o = r("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				d = r("./src/reddit/selectors/experiments/publicAccessNetwork.ts"),
				c = r("./src/reddit/selectors/PublicAccessNetwork/api.ts");
			const a = Object(n.a)(i.w),
				u = Object(n.a)(i.x),
				l = Object(n.a)(i.G),
				b = (Object(n.a)(i.H), Object(n.a)(i.I)),
				p = Object(n.a)(i.T),
				f = e => async (t, r) => {
					if (Object(d.a)(r())) return t(m(e))
				}, m = e => async (t, r, {
					gqlContext: n
				}) => {
					const s = Object(c.k)(r()),
						i = Object(c.m)(r(), {
							subreddit: e
						}),
						d = i && i.lastUpdated || 0,
						p = 1e3 * s.global.rpan_config_refresh_rate;
					if (s.isPending || s.isPermanentlyCanceled || Date.now() < d + p) return;
					t(l());
					const f = await Object(o.c)(n(), e);
					if (!f.ok) return void t(b());
					const m = f.body;
					t(a({
						...m.global,
						lastUpdated: Date.now()
					})), t(u({
						name: e,
						config: {
							...m.listing_info,
							lastUpdated: Date.now()
						}
					}))
				}, _ = e => async (t, r, {
					gqlContext: n
				}) => {
					t(p()), await Object(o.h)(n(), e)
				}, O = e => async (t, r, {
					apiContext: n
				}) => {
					r().posts.models[e] || await t(Object(s.M)(e))
				}, j = Object(n.a)(i.v), g = Object(n.a)(i.J), I = Object(n.a)(i.K), S = () => async (e, t, {
					gqlContext: r
				}) => {
					const n = t();
					if (Object(c.h)(n)) return;
					e(g());
					const s = await Object(o.d)(r());
					s.ok && s.body && s.body.data ? e(j({
						subreddits: s.body.data
					})) : e(I({
						error: s.error
					}))
				}
		},
		"./src/reddit/actions/seo/linksModule.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return i
			})), r.d(t, "c", (function() {
				return o
			})), r.d(t, "a", (function() {
				return d
			})), r.d(t, "e", (function() {
				return l
			})), r.d(t, "d", (function() {
				return b
			}));
			var n = r("./src/lib/makeActionCreator/index.ts"),
				s = r("./src/lib/loadWithRetries/index.ts");
			const i = "FRONTPAGE_LINKS__REQUEST_LOADED",
				o = "SUBREDDIT_LINKS_LOADED",
				d = 10,
				c = Object(n.a)("FRONTPAGE_LINKS__REQUEST_PENDING"),
				a = Object(n.a)("FRONTPAGE_LINKS__REQUEST_FAILED"),
				u = Object(n.a)(i),
				l = Object(n.a)(o),
				b = () => async e => {
					e(c());
					const t = await (async () => (await Object(s.a)(() => r.e("FrontpageLinks").then(r.t.bind(null, "./src/reddit/endpoints/goodContent/frontpageLinks.json", 3)))).default)();
					e(t ? u(t) : a())
				}
		},
		"./src/reddit/actions/seo/topicLinks.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return s
			})), r.d(t, "b", (function() {
				return i
			}));
			var n = r("./src/lib/makeActionCreator/index.ts");
			const s = "SUBREDDIT_TOPIC_LINKS_LOADED",
				i = Object(n.a)(s)
		},
		"./src/reddit/actions/shortcuts/utils.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return o
			})), r.d(t, "a", (function() {
				return d
			})), r.d(t, "b", (function() {
				return c
			})), r.d(t, "d", (function() {
				return a
			}));
			var n = r("./src/reddit/constants/shortcuts.ts"),
				s = r("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				i = r("./src/reddit/helpers/routeKey/index.ts");
			const o = e => {
					const t = e.platform.currentPage;
					if (!t || !t.routeMatch) return;
					const r = t.routeMatch,
						n = Object(s.a)(e);
					return Object(i.b)(r, e, n)
				},
				d = e => {
					const t = document.getElementById(e);
					t && t.focus()
				},
				c = e => {
					const t = document.getElementById(e),
						r = window.scrollX,
						n = window.scrollY;
					t && (t.focus(), window.scrollTo(r, n))
				},
				a = () => {
					c(n.b)
				}
		},
		"./src/reddit/actions/structuredStyles/constants.ts": function(e, t, r) {
			"use strict";
			r.d(t, "l", (function() {
				return n
			})), r.d(t, "k", (function() {
				return s
			})), r.d(t, "j", (function() {
				return i
			})), r.d(t, "i", (function() {
				return o
			})), r.d(t, "h", (function() {
				return d
			})), r.d(t, "g", (function() {
				return c
			})), r.d(t, "b", (function() {
				return a
			})), r.d(t, "c", (function() {
				return u
			})), r.d(t, "e", (function() {
				return l
			})), r.d(t, "d", (function() {
				return b
			})), r.d(t, "f", (function() {
				return p
			})), r.d(t, "a", (function() {
				return f
			})), r.d(t, "n", (function() {
				return m
			})), r.d(t, "m", (function() {
				return _
			}));
			const n = "STRUCTURED_STYLES__STYLES_RESET_PENDING",
				s = "STRUCTURED_STYLES__STYLES_RESET_LOADED",
				i = "STRUCTURED_STYLES__STYLES_RESET_FAILED",
				o = "SUBREDDIT__STYLES_PENDING",
				d = "SUBREDDIT__STYLES_LOADED",
				c = "SUBREDDIT__STYLES_FAILED",
				a = "STRUCTURED_STYLES__DRAFT_REPLACED",
				u = "STRUCTURED_STYLES__DRAFT_UPDATED",
				l = "STRUCTURED_STYLES__EDITING_STOPPED",
				b = "STRUCTURED_STYLES__EDITING_STARTED",
				p = "STRUCTURED_STYLES__IMAGE_UPLOAD_ADDED",
				f = "STRUCTURED_STYLES__DIRTIED_BLADE_EDITOR",
				m = "STRUCTURED_STYLES__UNDIRTIED_BLADE_EDITOR",
				_ = "STRUCTURED_STYLES__STYLES_UPDATED_LOADED"
		},
		"./src/reddit/actions/structuredStyles/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "l", (function() {
				return G
			})), r.d(t, "k", (function() {
				return q
			})), r.d(t, "j", (function() {
				return W
			})), r.d(t, "e", (function() {
				return z
			})), r.d(t, "d", (function() {
				return $
			})), r.d(t, "g", (function() {
				return Y
			})), r.d(t, "c", (function() {
				return Z
			})), r.d(t, "f", (function() {
				return te
			})), r.d(t, "b", (function() {
				return re
			})), r.d(t, "m", (function() {
				return ne
			})), r.d(t, "a", (function() {
				return se
			})), r.d(t, "h", (function() {
				return ie
			})), r.d(t, "i", (function() {
				return oe
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/lodash/omit.js"),
				s = r.n(n),
				i = r("./node_modules/lodash/pick.js"),
				o = r.n(i),
				d = r("./node_modules/react-router-redux/es/index.js"),
				c = r("./src/lib/filterQueryParams/index.ts"),
				a = r("./src/lib/formatApiError/index.ts"),
				u = r("./src/lib/makeActionCreator/index.ts"),
				l = r("./src/reddit/actions/apiRequestState.ts"),
				b = r("./src/reddit/actions/imageUploads.ts"),
				p = r("./src/reddit/actions/modal.ts"),
				f = r("./src/reddit/endpoints/moderator/structuredStyles.ts"),
				m = r("./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts"),
				_ = r("./src/reddit/selectors/postFlair.ts"),
				O = r("./src/reddit/selectors/subreddit.ts"),
				j = r("./src/reddit/actions/postFlairStyleTemplates/constants.ts");
			const g = Object(u.a)(j.c),
				I = Object(u.a)(j.b),
				S = Object(u.a)(j.a);
			var E = r("./src/reddit/actions/toaster.ts"),
				y = r("./src/reddit/actions/widgets/index.ts"),
				h = r("./src/reddit/constants/modals.ts"),
				T = r("./src/reddit/helpers/getGenericUploadError.ts"),
				v = r("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				w = r("./src/reddit/helpers/media/index.ts"),
				x = r("./src/reddit/models/Image/index.tsx"),
				C = r("./src/reddit/models/StructuredStyles/index.ts"),
				k = r("./src/reddit/models/Toast/index.ts"),
				D = r("./src/reddit/selectors/activeModalId.ts"),
				R = r("./src/reddit/selectors/platform.ts"),
				A = r("./src/reddit/selectors/structuredStyles.ts"),
				N = r("./src/reddit/selectors/user.ts"),
				L = r("./src/reddit/helpers/trackers/blade.ts"),
				P = r("./src/telemetry/index.ts"),
				U = r("./src/reddit/actions/structuredStyles/constants.ts");
			const G = Object(u.a)(U.m),
				F = {
					bannerBackgroundImage: ["bannerBackgroundImagePosition"],
					bannerPositionedImage: ["bannerPositionedImagePosition", "secondaryBannerPositionedImage"]
				},
				B = e => {
					const t = {
						...e
					};
					return Object.keys(e).forEach(r => {
						F[r] && !e[r] && F[r].forEach(e => t[e] = null)
					}), t
				},
				q = (e, t, r, n) => async (s, i, o) => {
					const {
						apiContext: d
					} = o, c = i(), u = B(t), p = c.structuredStyles.models[e];
					let m;
					for (const e in u)
						if (u[e] !== p[e]) {
							m = !0;
							break
						} if (!m) return;
					s(Object(l.h)(n));
					const _ = Object(L.i)(r)(c);
					let j = null,
						g = null;
					try {
						(j = await Object(b.f)(i(), x.a.StructuredStyles)) && (g = Object(b.m)(j)(s, i, o))
					} catch (h) {
						const e = Object(T.a)("webSocket");
						return void s(Object(l.f)(n, e))
					}
					const I = Object(O.R)(c, {
							subredditId: e
						}).name,
						S = await f.e(d(), I, u),
						y = {};
					if (S.ok) {
						if (g) try {
							await g
						} catch (h) {}
						const r = Object(A.f)(i(), {
							apiRequestId: n
						});
						for (const e in r)
							if (e in t) {
								const t = Object(A.g)(i(), {
									name: e
								});
								t && Object(x.j)(t) && (y[e] = r[e])
							} Object.keys(y).length && s(J(y)), s(Object(l.e)(n)), s(G({
							subredditId: e,
							styles: {
								...u,
								...y
							}
						}))
					} else j && j.websocket.close(), s(Object(l.f)(n, S.error)), S.body && s(E.f({
						kind: k.b.Error,
						text: Object(a.a)(S.error, S.status)
					}));
					Object(P.a)({
						..._,
						actionInfo: {
							..._.actionInfo,
							success: S.ok
						}
					})
				}, M = Object(u.a)(U.l), Q = Object(u.a)(U.k), K = Object(u.a)(U.j), W = e => async (t, r, {
					apiContext: n
				}) => {
					t(M({
						subredditId: e
					}));
					const s = Object(O.R)(r(), {
							subredditId: e
						}).name,
						i = await f.f(n(), s);
					if (i.ok) {
						const n = r().structuredStyles.models[e],
							s = n ? n.mobileKeyColor : null;
						t(Q({
							subredditId: e,
							styles: {
								mobileKeyColor: s
							}
						}))
					} else t(K({
						subredditId: e,
						...i.error
					}))
				}, H = Object(u.a)(U.d), z = e => async (t, r, n) => {
					const s = r(),
						i = s.structuredStyles.models[e] || {},
						o = Object(N.X)(s);
					t(H({
						isNightmodeOn: o,
						styles: i,
						subredditId: e
					})), ue(e, !1)(t, r, n), (e => async (t, r, {
						gqlContext: n
					}) => {
						const s = r(),
							i = Object(O.R)(s, {
								subredditId: e
							});
						if (!i) return;
						const o = Object(_.d)(s, {
								subredditId: e
							}),
							d = o && o.templateIds;
						if (!d || !d.length) return;
						t(g({
							subredditId: e
						}));
						const c = await Object(f.a)(n(), i.name, d);
						if (c.ok) {
							const r = {};
							if (c.body) {
								const {
									data: e
								} = c.body;
								if (e && e.subreddit)
									for (const t of e.subreddit.postFlairStyleTemplates) r[t.id] = Object(m.a)(t)
							}
							t(I({
								subredditId: e,
								templates: r
							}))
						} else t(S({
							subredditId: e,
							error: c.error
						}))
					})(e)(t, r, n), Object(y.g)(e, !1)(t, r, n)
				}, J = Object(u.a)(U.c), $ = e => async (t, r, n) => {
					const s = B(e),
						i = r();
					for (const e in s)
						if (Object(C.l)(e))
							if (s[e]) {
								if ("string" != typeof s[e]) {
									const i = s[e],
										o = await Object(x.e)(i);
									Y(e, o)(t, r, n), s[e] = ""
								}
							} else {
								const r = Object(A.g)(i, {
									name: e
								});
								r && t(Object(b.h)(r))
							} t(J(s))
				}, V = Object(u.a)(U.f), Y = (e, t, r) => async (n, s, i) => {
					const o = s(),
						d = r || o.structuredStyles.isEditing,
						c = Object(O.R)(o, {
							subredditId: d
						}).name;
					n(V({
						imageKey: e,
						uploadId: t.id
					})), n(Object(b.k)(t));
					const a = await f.d(i.apiContext(), c, t.file.name, e, await Object(w.g)(t.file));
					try {
						const r = await Object(b.g)(s(), a, t, x.a.StructuredStyles);
						if (r) {
							const t = r.url;
							n(Object(b.j)(r)), n(J({
								[e]: t
							}))
						}
					} catch (u) {
						if (u instanceof Error) throw u;
						n(Object(b.i)(u))
					}
				}, X = Object(u.a)(U.b), Z = (e, t, r) => async (n, i, d) => {
					const c = i(),
						a = c.structuredStyles.models[e] || {},
						u = c.structuredStyles.draft,
						l = Object(L.h)(t)(c);
					if (r) {
						const t = o()(a, r),
							i = {
								...s()(u, r),
								...t
							};
						n(X({
							subredditId: e,
							styles: i
						}))
					} else {
						n(X({
							subredditId: e,
							styles: a
						}))
					}
					Object(P.a)(l)
				}, ee = Object(u.a)(U.e), te = () => async (e, t, r) => {
					const n = t(),
						s = Object(N.Y)(n),
						i = !!Object(R.a)(n);
					if (e(ee({
							nightmodeTempUpdated: s
						})), i) return;
					const {
						url: o
					} = n.platform.currentPage;
					o && e(Object(d.c)(Object(c.a)(o, ["styling", "route"])))
				}, re = Object(u.a)(U.a), ne = Object(u.a)(U.n), se = () => async e => e(te()), ie = e => async (t, r) => {
					const n = r(),
						s = Object(A.i)(n);
					!Object(D.b)(h.a.BLADE_UNSAVED_CHANGES)(n) && s && (Object(A.a)(n, {
						subredditId: e
					}) ? t(Object(p.i)(h.a.BLADE_UNSAVED_CHANGES)) : t(se()))
				}, oe = e => async (t, r) => {
					const n = r();
					Object(A.i)(n) || t(Object(N.X)(n) ? Object(p.i)(h.a.BLADE_NIGHTMODE) : z(e))
				}, de = Object(u.a)(U.i), ce = Object(u.a)(U.h), ae = Object(u.a)(U.g), ue = (e, t) => async (r, n, {
					gqlContext: s,
					apiContext: i
				}) => {
					r(de({
						subredditId: e
					}));
					const o = Object(O.R)(n(), {
						subredditId: e
					});
					if (!o) return;
					if (!t) {
						const n = await f.c(i(), o.name, t);
						if (n.ok) {
							const t = n.body,
								s = t.data ? t.data.style : {};
							r(ce({
								subredditId: e,
								styles: s
							}))
						} else r(ae({
							subredditId: e,
							...n.error
						}));
						return
					}
					const d = await f.b(s(), o.name);
					if (d.ok) {
						let t = {};
						if (d.body) {
							const {
								data: e
							} = d.body;
							e && e.subreddit && e.subreddit.styles && (t = Object(v.a)(e.subreddit.styles))
						}
						r(ce({
							subredditId: e,
							styles: t
						}))
					} else r(ae({
						subredditId: e,
						...d.error
					}))
				}
		},
		"./src/reddit/actions/subreddit.ts": function(e, t, r) {
			"use strict";
			r.d(t, "m", (function() {
				return z
			})), r.d(t, "l", (function() {
				return J
			})), r.d(t, "k", (function() {
				return $
			})), r.d(t, "j", (function() {
				return V
			})), r.d(t, "i", (function() {
				return Y
			})), r.d(t, "h", (function() {
				return X
			})), r.d(t, "d", (function() {
				return Z
			})), r.d(t, "p", (function() {
				return ne
			})), r.d(t, "t", (function() {
				return se
			})), r.d(t, "o", (function() {
				return de
			})), r.d(t, "r", (function() {
				return ue
			})), r.d(t, "g", (function() {
				return le
			})), r.d(t, "f", (function() {
				return be
			})), r.d(t, "e", (function() {
				return pe
			})), r.d(t, "q", (function() {
				return Oe
			})), r.d(t, "b", (function() {
				return je
			})), r.d(t, "c", (function() {
				return ge
			})), r.d(t, "a", (function() {
				return Ie
			})), r.d(t, "u", (function() {
				return he
			})), r.d(t, "n", (function() {
				return Te
			})), r.d(t, "s", (function() {
				return ve
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./node_modules/lodash/pick.js"),
				i = r.n(s),
				o = r("./src/lib/constants/index.ts"),
				d = r("./src/lib/listingSort/index.ts"),
				c = r("./src/lib/makeActionCreator/index.ts"),
				a = r("./src/lib/makeListingKey/index.ts"),
				u = r("./src/reddit/actions/economics/helpers/async.ts"),
				l = r("./src/reddit/actions/modal.ts"),
				b = r("./src/reddit/actions/modQueueTriggers/index.ts"),
				p = r("./src/reddit/actions/pages/subreddit.ts"),
				f = r("./src/reddit/actions/preferences.ts"),
				m = r("./src/reddit/actions/subredditModeration/modUserNotes.ts"),
				_ = r("./src/reddit/actions/subredditRules/constants.ts"),
				O = r("./src/reddit/actions/toaster.ts"),
				j = r("./src/reddit/constants/history.ts"),
				g = r("./src/reddit/constants/modals.ts"),
				I = r("./src/reddit/constants/page.ts"),
				S = r("./src/reddit/constants/parameters.ts"),
				E = r("./src/reddit/constants/postLayout.ts"),
				y = r("./src/reddit/contexts/PageLayer/index.tsx"),
				h = r("./src/reddit/endpoints/governance/posts.ts"),
				T = r("./src/reddit/endpoints/messages/index.ts"),
				v = r("./src/reddit/endpoints/modQueue/index.ts"),
				w = r("./src/reddit/endpoints/page/subredditPage.ts"),
				x = r("./src/reddit/endpoints/subreddit/about.ts"),
				C = r("./src/reddit/endpoints/subreddit/rules.ts"),
				k = r("./src/reddit/endpoints/user/preferences.ts"),
				D = r("./src/reddit/helpers/filterListingResponse/index.ts"),
				R = r("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				A = r("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				N = r("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				L = r("./src/reddit/helpers/trackers/feed.ts"),
				P = r("./src/reddit/models/Subreddit/index.ts"),
				U = r("./src/reddit/models/SubredditRestrictions/index.ts"),
				G = r("./src/reddit/models/Toast/index.ts"),
				F = r("./src/reddit/models/User/index.ts"),
				B = r("./src/reddit/selectors/experiments/cnc/index.ts"),
				q = r("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				M = r("./src/reddit/selectors/moderatorPermissions.ts"),
				Q = r("./src/reddit/selectors/profile.ts"),
				K = r("./src/reddit/selectors/subreddit.ts"),
				W = r("./src/reddit/selectors/user.ts");
			const H = {},
				z = "SUBREDDIT__MODEL_SUCCEEDED",
				J = "SUBREDDIT__MODEL_PENDING",
				$ = "SUBREDDIT__MODEL_FAILED",
				V = "SUBREDDIT__MORE_POSTS_PENDING",
				Y = "SUBREDDIT__MORE_POSTS_LOADED",
				X = "SUBREDDIT__MORE_POSTS_FAILED",
				Z = "SUBREDDIT__META_FILTER_TOGGLED",
				ee = Object(c.a)(V),
				te = Object(c.a)(Y),
				re = Object(c.a)(X),
				ne = Object(c.a)(Z),
				se = Object(c.a)(_.b),
				ie = Object(c.a)(_.c),
				oe = Object(c.a)(_.a),
				de = (e, t) => async (r, n) => {
					await (t === P.f.User ? r(ce(e)) : r(ae(e)))
				}, ce = e => async (t, r, {
					apiContext: n
				}) => {
					const s = Object(Q.m)(r(), e),
						i = await Object(C.c)(n(), e);
					if (i.ok) {
						const e = i.body;
						t(se({
							rules: e,
							subredditId: s
						}))
					}
				}, ae = e => async (t, r, {
					gqlContext: s
				}) => {
					const i = Object(K.C)(r(), e);
					t(ie());
					const o = await Object(C.b)(s(), e);
					if (o.ok) {
						const e = o.body;
						t(se({
							rules: e,
							subredditId: i
						}))
					} else {
						t(oe());
						const r = `error-block-${e}`;
						t(O.f({
							id: r,
							kind: G.b.Error,
							text: n.fbt._("An error has occurred. Please try again later", null, {
								hk: "Elbdz"
							})
						}))
					}
				}, ue = e => async (t, r, {
					apiContext: n,
					gqlContext: s
				}) => {
					const {
						subredditName: c
					} = e;
					let l = e.t;
					const p = r(),
						f = Object(R.a)(e, p),
						_ = p.platform.currentPage ? p.platform.currentPage.queryParams : {},
						O = Object(a.a)(c, f, {
							t: l,
							..._
						}),
						g = p.listings.postOrder.loadMore[O],
						T = p.listings.postOrder.listingSort[O];
					let v = f;
					if (T && !v) {
						const e = Object(d.d)(T.sort);
						v = e.sort, l = e.timeSort
					}
					const x = p.listings.postOrder.api.pending[O],
						{
							fetchedTokens: C
						} = p.listings.postOrder,
						k = !(!C[O] || !C[O][g.token]);
					if (x || k) return;
					if (v === o.W.AWARDED && c === I.g) return;
					t(ee({
						key: O,
						fetchedToken: g.token
					}));
					const A = {
							after: g.token,
							dist: g.dist,
							forceGeopopular: c === I.d.Popular,
							layout: E.e[Object(y.R)(p, {})],
							sort: v,
							t: l,
							...i()(_, [...S.m, S.i])
						},
						N = Object(q.a)(p),
						P = N ? () => Object(w.b)(s(), Object(w.c)(p, c, {
							...A,
							limit: E.a
						}), Object(W.T)(p)) : () => Object(w.a)(n(), c, A),
						U = await P(),
						G = {
							...U.body,
							...Object(D.a)(p, O, U.body)
						};
					if (U.ok) {
						let e;
						const i = G.postIds.filter(e => !!G.posts[e].isMeta),
							o = Object(K.C)(r(), c);
						if (i.length) {
							const t = await Object(h.a)(n(), o, i);
							t.ok && (e = t.body)
						}
						const d = Object(M.h)(p, {
							subredditId: Object(K.C)(p, c)
						});
						if (!N && d && t(Object(b.a)({
								postIds: G.postIds
							})), t(te({
								fetchedToken: g.token,
								key: O,
								meta: p.meta,
								governance: e,
								...G
							})), Object(B.a)(p)) {
							let e;
							N || (e = await Object(w.b)(s(), Object(w.c)(p, c, {
								...A,
								limit: E.a
							}), Object(W.T)(p)));
							const r = N ? G : e.body;
							if (N ? r : e.ok) {
								const e = r.postIds.map(e => r.posts[e].lastAuthorModNote);
								t(Object(m.b)({
									subredditId: o,
									nodes: e
								}))
							}
						}
						await t(Object(u.a)({
							subredditId: o,
							postIds: G.postIds,
							skip: ["communityDetails", "subscription"]
						})), Object(L.b)(j.a.NextPageLoad)(r())
					} else {
						t(re({
							error: U.error,
							fetchedToken: g.token,
							key: O,
							...G
						}));
						const e = U.error;
						Object(L.a)(e ? `${U.status||"000"}: ${e.type}` : "000: UNKNOWN_ERROR")(r())
					}
				}, le = "SUBSCRIPTION__MODERATED_SUBREDDITS_PENDING", be = "SUBSCRIPTION__MODERATED_SUBREDDITS_LOADED", pe = "SUBSCRIPTION__MODERATED_SUBREDDITS_FAILED", fe = Object(c.a)(le), me = Object(c.a)(be), _e = Object(c.a)(pe), Oe = () => async (e, t, {
					apiContext: r
				}) => {
					const n = t();
					if (!n.user.account || n.subreddits.moderated.api.fetched) return;
					e(fe());
					const s = await Object(v.c)(r(), o.rb.Modqueue, {
						moderated: !0,
						moderated_limit: 50
					});
					s.ok ? e(me(s.body)) : e(_e({
						error: s.error
					}))
				}, je = "SUBREDDIT__ABOUT_PENDING", ge = "SUBREDDIT__ABOUT_SUCCEEDED", Ie = "SUBREDDIT__ABOUT_FAILED", Se = Object(c.a)(je), Ee = Object(c.a)(ge), ye = Object(c.a)(Ie), he = e => async (t, r, {
					gqlContext: n
				}) => {
					const s = r();
					if (Object(K.t)(s, {
							subredditName: e
						}) || s.subreddits.api.about.error[e.toLowerCase()] || s.subreddits.api.about.pending[e.toLowerCase()]) return;
					t(Se({
						subredditName: e
					}));
					const i = !Object(K.C)(s, e),
						o = await Object(x.a)(n(), e, i);
					if (o.ok) {
						const r = o.body.data.subreddit,
							n = Object(A.a)(r),
							s = i ? Object(N.a)(r) : void 0;
						t(Ee({
							subredditName: e,
							subreddits: s ? {
								[s.id]: s
							} : void 0,
							data: n
						}))
					} else t(ye({
						subredditName: e,
						error: o.error
					}))
				}, Te = (e, t, r) => async (n, s, {
					apiContext: i
				}) => {
					var o;
					const d = e.substring(2),
						c = r === U.e.View ? null === (o = Object(W.f)(s(), d)) || void 0 === o ? void 0 : o.subredditId : Object(K.C)(s(), d),
						a = Object(W.k)(s());
					if (a && c) {
						const e = ((e, t, r, n) => {
							return {
								to: `/r/${e}`,
								subject: `[join] I would like to join ${e}`,
								text: r + "\n\n   *To approve this user*, visit [the approved users page for r/" + e + "](https://www.reddit.com/r/" + e + "/about/contributors?user=" + t + ') and click "ADD USER".\n    Approving this user gives them permission to ' + n + ". You can change these community restrictions from the [community settings](/r/" + e + "/about/edit) page.\n\n   To get more information about this user, visit the profile page of [u/" + t + "](/u/" + t + ") or reply to this message to start a conversation."
							}
						})(d, Object(F.e)(a), t, r);
						if ((await Object(T.b)(i(), e)).ok) {
							const e = new Date,
								t = {
									isContributorRequestTimestamp: e.setDate(e.getDate())
								};
							n(Object(f.F)({
								subredditId: c,
								prefs: t
							})), Object(k.j)(c, t, i()), r !== U.e.View && n(Object(l.i)(g.a.CONTRIBUTOR_REQUEST_PENDING))
						}
					}
				}, ve = e => async (t, r) => {
					const n = r(),
						{
							subredditName: s
						} = e,
						i = e.t,
						o = Object(R.a)(e, n),
						d = n.platform.currentPage ? n.platform.currentPage.queryParams : H,
						c = Object(a.a)(s, o, {
							t: i,
							...d
						}),
						u = {
							t: i,
							sort: o,
							isRefresh: !0,
							...d
						};
					await t(Object(p.subredditDataRequested)(c, s, u, !0))
				}
		},
		"./src/reddit/actions/subreddit/constants.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return n
			})), r.d(t, "b", (function() {
				return s
			})), r.d(t, "c", (function() {
				return i
			})), r.d(t, "j", (function() {
				return o
			})), r.d(t, "i", (function() {
				return d
			})), r.d(t, "r", (function() {
				return c
			})), r.d(t, "q", (function() {
				return a
			})), r.d(t, "m", (function() {
				return u
			})), r.d(t, "l", (function() {
				return l
			})), r.d(t, "k", (function() {
				return b
			})), r.d(t, "p", (function() {
				return p
			})), r.d(t, "o", (function() {
				return f
			})), r.d(t, "n", (function() {
				return m
			})), r.d(t, "h", (function() {
				return _
			})), r.d(t, "g", (function() {
				return O
			})), r.d(t, "f", (function() {
				return j
			})), r.d(t, "w", (function() {
				return g
			})), r.d(t, "v", (function() {
				return I
			})), r.d(t, "x", (function() {
				return S
			})), r.d(t, "y", (function() {
				return E
			})), r.d(t, "z", (function() {
				return y
			})), r.d(t, "e", (function() {
				return h
			})), r.d(t, "d", (function() {
				return T
			})), r.d(t, "t", (function() {
				return v
			})), r.d(t, "u", (function() {
				return w
			})), r.d(t, "s", (function() {
				return x
			}));
			const n = "SUBREDDIT__ADD_TOP_SUBREDDIT_MODELS",
				s = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS",
				i = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS_PAGE_INFO",
				o = "SUBREDDIT__POSTS_LOADED",
				d = "SUBREDDIT__POSTS_SET_FAILED",
				c = "SUBREDDIT__SUBREDDITS_POSTS_LOADED",
				a = "SUBREDDIT__SUBREDDITS_POSTS_SET_FAILED",
				u = "SUBREDDIT__RANKINGS_PENDING",
				l = "SUBREDDIT__RANKINGS_LOADED",
				b = "SUBREDDIT__RANKINGS_FAILED",
				p = "SUBREDDIT__SIMILAR_SUBREDDITS_PENDING",
				f = "SUBREDDIT__SIMILAR_SUBREDDITS_LOADED",
				m = "SUBREDDIT__SIMILAR_SUBREDDITS_FAILED",
				_ = "SUBREDDIT__ONBOARDING_SUBREDDITS_PENDING",
				O = "SUBREDDIT__ONBOARDING_SUBREDDITS_LOADED",
				j = "SUBREDDIT__ONBOARDING_SUBREDDITS_FAILED",
				g = "SUBREDDIT__EDIT_REQUESTED",
				I = "SUBREDDIT__EDIT_FAILED",
				S = "SUBREDDIT__EDIT_SUCCESS",
				E = "SUBREDDIT_QUESTIONS_LOADED",
				y = "SUBREDDIT_SURVEY_ANSWERED",
				h = "SUBREDDIT_SURVEY_DISMISSED",
				T = "SUBREDDIT_SURVEY_DISMISS",
				v = "SUBREDDIT_ABOUT_INFO_UPDATE__PENDING",
				w = "SUBREDDIT_ABOUT_INFO_UPDATE__SUCCESS",
				x = "SUBREDDIT_ABOUT_INFO_UPDATE__FAILED"
		},
		"./src/reddit/actions/subreddit/questions.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return o
			})), r.d(t, "a", (function() {
				return d
			}));
			var n = r("./src/lib/makeGqlRequest/index.ts"),
				s = r("./src/redditGQL/operations/GetSubredditQuestions.json"),
				i = r("./src/reddit/actions/subreddit/constants.ts");
			const o = e => async (t, r, {
				gqlContext: i
			}) => {
				var o;
				const c = (await ((e, t) => Object(n.a)(e, {
					...s,
					variables: t
				}))(i(), {
					id: e
				})).body;
				d(t, e, null === (o = c.data) || void 0 === o ? void 0 : o.subredditInfoById)
			};

			function d(e, t, r) {
				const n = null == r ? void 0 : r.answerableQuestions,
					s = null == r ? void 0 : r.contentRatingSurvey,
					o = null == r ? void 0 : r.communityProgressModule;
				(n || s || o) && e({
					type: i.y,
					payload: {
						id: t,
						questions: n,
						survey: s,
						progressModule: o
					}
				})
			}
		},
		"./src/reddit/actions/subredditDuplicates.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return b
			})), r.d(t, "b", (function() {
				return f
			}));
			var n = r("./src/lib/makeActionCreator/index.ts"),
				s = r("./src/lib/constants/index.ts"),
				i = r("./src/config.ts"),
				o = r("./src/lib/makeApiRequest/index.ts"),
				d = r("./src/reddit/models/Post/index.ts");
			var c = r("./src/reddit/models/Duplicates/index.ts"),
				a = r("./src/reddit/models/Subreddit/index.ts"),
				u = r("./src/reddit/selectors/profile.ts"),
				l = r("./src/reddit/selectors/subreddit.ts");
			const b = "SUBREDDIT_DUPLICATES_IN_SUBREDDIT_LOADED",
				p = (Object(n.a)("SUBREDDIT_DUPLICATES_IN_SUBREDDIT_PENDING"), Object(n.a)(b)),
				f = (e, t) => async (r, n, {
					apiContext: b
				}) => {
					const f = Object(l.R)(n(), {
						subredditId: e
					}) || Object(u.p)(n(), {
						profileId: e
					});
					if (!f) return;
					const m = {
							crossposts_only: !0,
							sort: "new",
							sr: Object(a.h)(f) ? s.jc + f.name : f.name
						},
						_ = await ((e, t, r) => Object(o.a)(e, {
							data: r,
							endpoint: `${i.a.gatewayUrl}/desktopapi/v1/duplicates/${Object(d.u)(t)}`,
							method: s.jb.GET
						}))(b(), t, m);
					if (_.ok) {
						const n = _.body;
						r(p({
							distinguishKey: Object(c.a)(t, m),
							postIds: n.postIds,
							posts: n.posts,
							profiles: n.profiles,
							subreddits: n.subreddits,
							subredditId: e
						}))
					}
				}
		},
		"./src/reddit/actions/subredditModeration/modUserNotes.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return f
			})), r.d(t, "a", (function() {
				return m
			}));
			var n = r("./src/lib/constants/index.ts"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/reddit/actions/subredditModeration/constants.ts"),
				o = r("./src/lib/makeGqlRequest/index.ts"),
				d = r("./src/redditGQL/operations/CommentsPageLastAuthorModNotes.json");
			var c = r("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				a = r("./src/redditGQL/types.ts"),
				u = r("./src/lib/initializeClient/installReducer.ts"),
				l = r("./src/reddit/reducers/features/modUserNotes/index.ts");
			Object(u.a)({
				features: {
					modUserNotes: l.a
				}
			});
			const b = Object(s.a)(i.D),
				p = Object(s.a)(i.C),
				f = ({
					subredditId: e,
					nodes: t
				}) => async (r, n, {
					gqlContext: s
				}) => {
					const i = [],
						o = [];
					t.map(e => {
						const t = null == e ? void 0 : e.user.id;
						t && !o.includes(t) && e && (i.push(e), o.push(t))
					}), r(p({
						subredditId: e,
						lastAuthorModNotes: i
					}))
				}, m = (e, t, r) => async (s, i, {
					gqlContext: u
				}) => {
					var l, f, m, _, O, j, g;
					const {
						hasSortParam: I,
						sortToUse: S
					} = Object(c.a)(i(), e), E = n.Jb[S], y = {
						postId: e,
						requestPostModerationInfo: !t,
						...I && E && {
							sortType: a.d[E]
						},
						...r && {
							after: r
						}
					}, h = await ((e, t) => Object(o.a)(e, {
						...d,
						variables: {
							...t
						}
					}))(u(), y);
					if (h.ok) {
						const e = null === (l = h.body) || void 0 === l ? void 0 : l.data,
							t = null === (m = null === (f = null == e ? void 0 : e.postInfoById) || void 0 === f ? void 0 : f.subreddit) || void 0 === m ? void 0 : m.id,
							r = null === (O = null === (_ = null == e ? void 0 : e.postInfoById) || void 0 === _ ? void 0 : _.moderationInfo) || void 0 === O ? void 0 : O.lastAuthorModNote,
							n = null === (g = null === (j = null == e ? void 0 : e.postInfoById) || void 0 === j ? void 0 : j.commentForest) || void 0 === g ? void 0 : g.trees;
						r && s(b({
							subredditId: t,
							lastAuthorModNote: r
						})), n && s((({
							subredditId: e,
							commentTrees: t
						}) => async (r, n, {
							gqlContext: s
						}) => {
							const i = [],
								o = [];
							t.map(e => {
								var t, r;
								if (!(null == e ? void 0 : e.node)) return;
								const n = null === (r = null === (t = e.node) || void 0 === t ? void 0 : t.moderationInfo) || void 0 === r ? void 0 : r.lastAuthorModNote,
									s = null == n ? void 0 : n.user.id;
								s && !o.includes(s) && n && (i.push(n), o.push(s))
							}), r(p({
								subredditId: e,
								lastAuthorModNotes: i
							}))
						})({
							subredditId: t,
							commentTrees: n
						}))
					}
				}
		},
		"./src/reddit/actions/subredditRules/constants.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return n
			})), r.d(t, "c", (function() {
				return s
			})), r.d(t, "a", (function() {
				return i
			})), r.d(t, "e", (function() {
				return o
			})), r.d(t, "f", (function() {
				return d
			})), r.d(t, "g", (function() {
				return c
			})), r.d(t, "d", (function() {
				return a
			}));
			const n = "SUBREDDIT__RULES_LOADED",
				s = "SUBREDDIT__RULES_PENDING",
				i = "SUBREDDIT__RULES_FAILED",
				o = "SUBREDDIT__RULE_ADDED",
				d = "SUBREDDIT__RULE_EDITED",
				c = "SUBREDDIT__RULE_REMOVED",
				a = "SUBREDDIT__RULES_REORDERED"
		},
		"./src/reddit/actions/subredditSettings.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return h
			})), r.d(t, "a", (function() {
				return v
			})), r.d(t, "b", (function() {
				return x
			})), r.d(t, "h", (function() {
				return k
			})), r.d(t, "g", (function() {
				return D
			})), r.d(t, "e", (function() {
				return R
			})), r.d(t, "f", (function() {
				return A
			})), r.d(t, "d", (function() {
				return N
			})), r.d(t, "j", (function() {
				return G
			})), r.d(t, "i", (function() {
				return F
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./node_modules/lodash/invert.js"),
				i = r.n(s),
				o = r("./node_modules/lodash/pick.js"),
				d = r.n(o),
				c = r("./node_modules/lodash/xor.js"),
				a = r.n(c),
				u = r("./src/lib/constants/index.ts"),
				l = r("./src/lib/makeActionCreator/index.ts"),
				b = r("./src/reddit/endpoints/subreddit/settings.ts"),
				p = r("./src/telemetry/index.ts"),
				f = r("./src/reddit/actions/toaster.ts"),
				m = r("./src/reddit/endpoints/subreddit/notificationSettings.ts"),
				_ = r("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				O = r("./src/reddit/helpers/trackers/inlineSubredditEditing.ts"),
				j = r("./src/reddit/models/Toast/index.ts"),
				g = r("./src/reddit/models/User/index.ts"),
				I = r("./src/reddit/selectors/subreddit.ts"),
				S = r("./src/reddit/selectors/subredditSettings.ts"),
				E = r("./src/reddit/selectors/user.ts"),
				y = r("./src/reddit/selectors/widgets.ts");
			const h = "SUBREDDIT_SETTINGS_LOADED",
				T = Object(l.a)(h),
				v = "SUBREDDIT_NOTIFICATION_SETTINGS_LOADED",
				w = Object(l.a)(v),
				x = "SUBREDDIT_NOTIFICATION_SETTINGS_UPDATED",
				C = Object(l.a)(x),
				k = (e, t) => async (r, n, {
					apiContext: s,
					gqlContext: i
				}) => {
					if (!t || !Object(I.T)(n(), t)) {
						const t = await Object(b.c)(s(), e);
						t && t.ok && r(T(t.body))
					}
					if (t && !Object(S.b)(n(), {
							subredditId: t
						})) {
						const e = await Object(m.a)(i(), t);
						if (e && e.ok) {
							const t = e.body,
								n = Object(_.e)(t.data);
							r(w(n))
						}
					}
				}, D = () => async (e, t, {
					apiContext: r
				}) => {
					const n = Object(E.k)(t());
					n && await e(k(u.jc + Object(g.e)(n)))
				}, R = "SUBREDDIT_SETTINGS_UPDATE_REQUESTED", A = "SUBREDDIT_SETTINGS_UPDATE_SUCCESS", N = "SUBREDDIT_SETTINGS_UPDATE_FAILURE", L = Object(l.a)(R), P = Object(l.a)(A), U = Object(l.a)(N), G = (e, t, r = {}, s = !1) => async (o, c, {
					apiContext: u,
					gqlContext: l
				}) => {
					o(L());
					const _ = c(),
						g = d()(Object(I.T)(_, e), ...Object.keys(t)),
						E = d()(Object(S.b)(_, {
							subredditId: e
						}), ...Object.keys(r)),
						h = await Object(b.g)(u(), e, t),
						T = Object.keys(r).length > 0;
					let v = !0;
					if (T) {
						v = (await Object(m.b)(l(), e, r)).ok
					}
					if (!h.ok || T && !v) o(U()), o(Object(f.f)({
						kind: j.b.Error,
						text: n.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
							hk: "3wBPeO"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: G(e, t, E, void 0)
					})), s && Object(p.a)(Object(O.c)(_, "BE returned an error:"));
					else {
						const d = Object(b.d)(h.body, i()(b.a));
						o(P({
							settings: {
								...d,
								subredditId: e
							},
							idCardWidgetId: Object(y.c)(_, {
								subredditId: e
							})
						})), T && o(C({
							notificationSettings: r,
							subredditId: e
						}));
						const c = {};
						s && 0 === a()(Object.keys(t), Object.keys(g)).length && (c.buttonText = n.fbt._("Undo", null, {
							hk: "1Gskii"
						}), c.buttonAction = G(e, g, E, s)), o(Object(f.f)({
							kind: j.b.SuccessCommunity,
							text: n.fbt._("Subreddit settings updated successfully", null, {
								hk: "2fmdlZ"
							}),
							...c
						}))
					}
				}, F = (e, t) => async (r, s, {
					apiContext: i
				}) => {
					(await Object(b.e)(i(), e, t)).ok ? r(Object(f.f)({
						kind: j.b.SuccessCommunity,
						text: n.fbt._("Test message was sent to your inbox", null, {
							hk: "1ZtKzO"
						})
					})) : r(Object(f.f)({
						kind: j.b.Error,
						text: n.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
							hk: "3wBPeO"
						})
					}))
				}
		},
		"./src/reddit/actions/tags/constants.ts": function(e, t, r) {
			"use strict";
			r.d(t, "t", (function() {
				return n
			})), r.d(t, "j", (function() {
				return s
			})), r.d(t, "r", (function() {
				return i
			})), r.d(t, "q", (function() {
				return o
			})), r.d(t, "s", (function() {
				return d
			})), r.d(t, "l", (function() {
				return c
			})), r.d(t, "m", (function() {
				return a
			})), r.d(t, "k", (function() {
				return u
			})), r.d(t, "o", (function() {
				return l
			})), r.d(t, "p", (function() {
				return b
			})), r.d(t, "n", (function() {
				return p
			})), r.d(t, "v", (function() {
				return f
			})), r.d(t, "w", (function() {
				return m
			})), r.d(t, "u", (function() {
				return _
			})), r.d(t, "g", (function() {
				return O
			})), r.d(t, "h", (function() {
				return j
			})), r.d(t, "f", (function() {
				return g
			})), r.d(t, "A", (function() {
				return I
			})), r.d(t, "z", (function() {
				return S
			})), r.d(t, "D", (function() {
				return E
			})), r.d(t, "y", (function() {
				return y
			})), r.d(t, "C", (function() {
				return h
			})), r.d(t, "x", (function() {
				return T
			})), r.d(t, "B", (function() {
				return v
			})), r.d(t, "e", (function() {
				return w
			})), r.d(t, "b", (function() {
				return x
			})), r.d(t, "d", (function() {
				return C
			})), r.d(t, "c", (function() {
				return k
			})), r.d(t, "a", (function() {
				return D
			})), r.d(t, "i", (function() {
				return R
			}));
			const n = "TAGS__REQUESTED",
				s = "TAGS__AVAILABLE_LOADED",
				i = "TAGS__LOADED",
				o = "TAGS__FAILURE",
				d = "TAGS__RELEVANCE_LOADED",
				c = "TAGS__CREATE_REQUESTED",
				a = "TAGS__CREATE_SUCCESS",
				u = "TAGS__CREATE_FAILURE",
				l = "TAGS__DELETE_REQUESTED",
				b = "TAGS__DELETE_SUCCESS",
				p = "TAGS__DELETE_FAILURE",
				f = "TAGS__UPDATE_STATE_REQUESTED",
				m = "TAGS__UPDATE_STATE_SUCCESS",
				_ = "TAGS__UPDATE_STATE_FAILURE",
				O = "PRIMARY_TAG__UPDATE_STATE_REQUESTED",
				j = "PRIMARY_TAG__UPDATE_STATE_SUCCESS",
				g = "PRIMARY_TAG__UPDATE_STATE_FAILURE",
				I = "TAGS__OPTIONS_CANCELLED",
				S = "TAGS__OPTION_SELECTED",
				E = "TAGS__SUGGESTED_OPTION_SELECTED",
				y = "TAGS__OPTION_DESELECTED",
				h = "TAGS__SUGGESTED_OPTION_DESELECTED",
				T = "TAGS__INPUT_CHANGED",
				v = "TAGS__SUGGESTED_INPUT_CHANGED",
				w = "GLOBAL__TAGS__LOADED",
				x = "CREATION__TAGS_INPUT_CHANGED",
				C = "CREATION__TAGS_OPTION_SELECTED",
				k = "CREATION__TAGS_OPTION_DESELECTED",
				D = "CREATION__PRIMARY_TAG_SELECTED",
				R = "SETTINGS_PAGE_PRIMARY_TAG_UPDATE"
		},
		"./src/reddit/actions/tags/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "j", (function() {
				return D
			})), r.d(t, "m", (function() {
				return R
			})), r.d(t, "i", (function() {
				return A
			})), r.d(t, "l", (function() {
				return N
			})), r.d(t, "h", (function() {
				return L
			})), r.d(t, "k", (function() {
				return P
			})), r.d(t, "a", (function() {
				return B
			})), r.d(t, "f", (function() {
				return q
			})), r.d(t, "g", (function() {
				return Q
			})), r.d(t, "e", (function() {
				return z
			})), r.d(t, "d", (function() {
				return J
			})), r.d(t, "b", (function() {
				return $
			})), r.d(t, "n", (function() {
				return V
			})), r.d(t, "c", (function() {
				return Y
			})), r.d(t, "o", (function() {
				return X
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/reddit/actions/tags/constants.ts"),
				o = r("./src/reddit/actions/toaster.ts");
			const d = e => {
				const {
					subredditInfoById: t
				} = e, r = {
					global: {},
					[t.id]: {}
				};
				t.availableTags && t.availableTags.edges.reduce((e, {
					node: t
				}) => (e[t.subreddit && t.subreddit.id || "global"][t.id] = t, e), r);
				const n = {
					[t.id]: {}
				};
				t.secondaryTags && t.secondaryTags.edges.reduce((e, {
					node: r
				}) => (e[t.id][r.tag.id] = r, e), n);
				const s = {
					[t.id]: {}
				};
				return t.suggestedTags && t.suggestedTags.edges.reduce((e, {
					node: r
				}) => (e[t.id][r.tag.id] = r, e), s), {
					primaryTag: t.primaryTag,
					globalSubredditTags: r.global,
					subredditScopedTags: {
						[t.id]: r[t.id]
					},
					subredditId: t.id,
					itemTags: n,
					suggestedItemTags: s,
					geoPlace: t.geoPlace
				}
			};
			var c = r("./src/lib/makeGqlRequest/index.ts"),
				a = r("./src/redditGQL/operations/CreateSubredditTags.json");
			r("./src/redditGQL/operations/FetchGlobalTags.json");
			var u = r("./src/redditGQL/operations/FetchSubredditTags.json");
			const l = (e, {
				subredditId: t,
				pageSize: r = 1050,
				after: n,
				includeAvailableTags: s
			}) => Object(c.a)(e, {
				...u,
				variables: {
					subredditId: t,
					pageSize: r,
					after: n,
					includeAvailableTags: s
				}
			});
			var b = r("./src/redditGQL/operations/MaybeDeleteTagsAndUpdateItemTags.json");
			var p = r("./src/redditGQL/operations/UpdateSubredditTagStatesRelevance.json");
			var f = r("./src/redditGQL/operations/UpdateSubredditPrimaryTag.json");
			var m = r("./src/reddit/helpers/tags/index.ts"),
				_ = r("./src/reddit/helpers/trackers/communityTopics.ts"),
				O = r("./src/reddit/models/Tags/index.ts"),
				j = r("./src/reddit/models/Toast/index.ts"),
				g = r("./src/reddit/reducers/tags/selected/index.ts"),
				I = r("./src/reddit/selectors/tags.ts");
			Object(s.a)(i.e);
			const S = Object(s.a)(i.t),
				E = Object(s.a)(i.r),
				y = Object(s.a)(i.s),
				h = Object(s.a)(i.q),
				T = Object(s.a)(i.l),
				v = Object(s.a)(i.m),
				w = Object(s.a)(i.k),
				x = Object(s.a)(i.v),
				C = Object(s.a)(i.w),
				k = Object(s.a)(i.u),
				D = Object(s.a)(i.z),
				R = Object(s.a)(i.D),
				A = Object(s.a)(i.y),
				N = Object(s.a)(i.C),
				L = Object(s.a)(i.x),
				P = Object(s.a)(i.B),
				U = (Object(s.a)(i.d), Object(s.a)(i.c), Object(s.a)(i.b), Object(s.a)(i.g)),
				G = Object(s.a)(i.h),
				F = Object(s.a)(i.f),
				B = Object(s.a)(i.a),
				q = Object(s.a)(i.i),
				M = Object(s.a)(i.A),
				Q = (e, t, r = !1) => async (s, i, {
					gqlContext: c
				}) => {
					const a = i();
					s(S());
					const u = await l(c(), {
							subredditId: e
						}),
						b = u.body;
					if (u.ok && b.data.subredditInfoById.secondaryTags && b.data.subredditInfoById.availableTags && b.data.subredditInfoById.suggestedTags) s(E(d(b.data))), r && _.h(i(), e, {
						context: t
					});
					else {
						s(h());
						const i = r ? "topics_save" : "topics_load";
						_.g(a, e, i, {
							context: t
						}), s(Object(o.f)(Object(o.e)(n.fbt._("Oh no! We didn't load your topics. Please try again.", null, {
							hk: "2DUkWX"
						}), j.b.Error, n.fbt._("Retry", null, {
							hk: "1c2xrJ"
						}), Q(e, t, r))))
					}
				}, K = e => async (t, r, {
					gqlContext: s
				}) => {
					t(S());
					const i = await l(s(), {
						subredditId: e
					});
					if (i.ok) {
						const e = i.body;
						t(y(d(e.data)))
					} else t(h()), t(Object(o.f)(Object(o.e)(n.fbt._("Oh no! We didn't load your topics. Please try again.", null, {
						hk: "2DUkWX"
					}), j.b.Error, n.fbt._("Retry", null, {
						hk: "1c2xrJ"
					}), y(e))))
				}, W = (e, t) => async (r, n, {
					gqlContext: s
				}) => {
					if (!t.length) return null;
					r(T());
					const i = t.map(t => ({
							subredditId: e,
							...t
						})),
						o = await ((e, t) => Object(c.a)(e, {
							...a,
							variables: t
						}))(s(), {
							input: i
						}),
						d = o.body && o.body.data || null;
					return o.ok && d && d.createSubredditTags && d.createSubredditTags.ok ? (r(v()), d.createSubredditTags.createdTags || []) : (r(w()), null)
				}, H = (e, t, r = []) => async (n, s, {
					gqlContext: i
				}) => {
					if (!t.length && !r.length) return;
					n(x());
					const o = s(),
						a = Object(I.d)(o, {
							subredditId: e
						}),
						u = Object(I.o)(o, {
							itemId: e
						}),
						l = Object(I.z)(o, {
							itemId: e
						}),
						p = new Set;
					for (const e of t)
						if (e.state === O.d.NONE && a[e.tagId] && !l[e.tagId]) {
							!!r.find(t => t.state === O.d.TAGGED && t.tagId === e.tagId) || p.add(e.tagId)
						} for (const e of r)
						if (e.state === O.d.NONE && a[e.tagId] && !u[e.tagId]) {
							!!t.find(t => t.state === O.d.TAGGED && t.tagId === e.tagId) || p.add(e.tagId)
						} const f = await ((e, t) => Object(c.a)(e, {
							...b,
							variables: {
								...t,
								deleteTags: 0 !== t.deleteTagsInput.length,
								pageSize: 1050
							}
						}))(i(), {
							deleteTagsInput: [...p].map(t => ({
								tagId: t,
								subredditId: e
							})),
							updateTagStatesInput: {
								subredditId: e,
								suggestedTagStates: r,
								tagStates: t
							}
						}),
						m = f.body && f.body.data || null;
					f.ok && m && m.updateSubredditTagStates && m.updateSubredditTagStates.ok && m.updateSubredditTagStates.subreddit ? n(C(d({
						subredditInfoById: m.updateSubredditTagStates.subreddit
					}))) : n(k())
				}, z = (e, t, r = !1) => async (s, i, d) => {
					const c = i(),
						a = Object(I.q)(c, {
							subredditId: e
						}),
						u = Object(I.C)(c, {
							subredditId: e
						});
					let l = a.filter(e => !!e.id && !!e.action).map(e => ({
						tagId: e.id,
						state: e.action === g.a.ADD ? O.d.TAGGED : O.d.NONE
					}));
					if (u.length > 0) {
						const t = await W(e, u)(s, i, d);
						l = l.concat((t || []).map(e => ({
							tagId: e.id,
							state: O.d.TAGGED
						})))
					}
					await H(e, l)(s, i, d), Object(I.A)(i()) ? s(Object(o.f)(Object(o.e)(n.fbt._("Yikes! It looks like we didn't save all of your topics. Please try again", null, {
						hk: "2Jbh5V"
					}), j.b.Error, n.fbt._("Retry", null, {
						hk: "1c2xrJ"
					}), z(e, t, r)))) : r && s(Object(o.f)(Object(o.e)(n.fbt._("Community topics saved!", null, {
						hk: "3wtajT"
					}), j.b.SuccessCommunity)))
				}, J = (e, t, r) => async (r, s, i) => {
					const d = {
						state: O.d.TAGGED
					};
					if (Object(m.b)(t)) {
						const n = await W(e, [{
							text: t.displayText,
							type: O.c.CLASSIFICATION
						}])(r, s, i);
						n && 1 === n.length && (d.tagId = n[0].id)
					} else {
						if (!t.id) return void r(Object(o.f)(Object(o.e)(n.fbt._("Whoops, we couldn't save that topic. Please try again later.", null, {
							hk: "CxjiK"
						}), j.b.Error)));
						d.tagId = t.id
					}(e => !!e.tagId && !!e.state)(d) ? await H(e, [], [d])(r, s, i): r(Object(o.f)(Object(o.e)(n.fbt._("Whoops, we couldn't save that topic. Please try again later.", null, {
						hk: "CxjiK"
					}), j.b.Error)))
				}, $ = (e, t, r) => async (n, s, i) => {
					t.id ? await H(e, [], [{
						state: O.d.NONE,
						tagId: t.id
					}])(n, s, i) : n(Q(e, r, !1))
				}, V = (e, t, r, s, i = !1) => async (d, a, {
					gqlContext: u
				}) => {
					if (!(await ((e, t) => Object(c.a)(e, {
							...p,
							variables: t
						}))(u(), {
							input: {
								tagStatesRelevance: t,
								suggestedTagStatesRelevance: r
							}
						})).ok) return d(Object(o.f)(Object(o.e)(n.fbt._("Whoops! Unable to update topics relevance status", null, {
						hk: "17akdT"
					}), j.b.Error, n.fbt._("Retry", null, {
						hk: "1wqK2v"
					}), V(e, t, r, s, i)))), void d(K(e));
					if (i)
						for (const e of r) _.f(a(), e, {
							context: s
						});
					d(Object(o.f)(Object(o.e)(n.fbt._("Successfully updated topics relevance!", null, {
						hk: "3KIYlz"
					}), j.b.SuccessCommunity, n.fbt._("Undo", null, {
						hk: "34apPL"
					}), V(e, t.map(e => ({
						...e,
						isRelevant: !e.isRelevant
					})), r.map(e => ({
						...e,
						isRelevant: !e.isRelevant
					})), s, i)))), d(K(e))
				}, Y = e => async (t, r) => {
					t(M({
						itemTagsState: {
							[e]: Object(I.o)(r(), {
								itemId: e
							})
						}
					}))
				}, X = (e, t, r = !0) => async (s, i, {
					gqlContext: d
				}) => {
					const a = Object(I.x)(i(), {
						subredditId: e
					});
					if ((null == a ? void 0 : a.id) === t.tagId && t.state === O.d.TAGGED) return;
					s(U());
					const u = await ((e, t) => Object(c.a)(e, {
							...f,
							variables: t
						}))(d(), {
							input: {
								subredditId: e,
								primaryTagState: t
							}
						}),
						l = u.body && u.body.data || null;
					u.ok && l && l.updateSubredditTagStates && l.updateSubredditTagStates.ok ? (s(G((e => {
						const {
							secondaryTags: t,
							id: r,
							primaryTag: n
						} = e.updateSubredditTagStates.subreddit, s = t && t.edges || [];
						return {
							subredditId: r,
							primaryTagId: n && n.tag.id || null,
							secondaryTags: s.reduce((e, {
								node: t
							}) => (e[t.tag.id] = t, e), {})
						}
					})(l))), r && s(Object(o.f)(Object(o.e)(n.fbt._("Successfully updated primary topic!", null, {
						hk: "1NL90v"
					}), j.b.SuccessCommunity)))) : (s(F()), s(Object(o.f)(Object(o.e)(n.fbt._("Whoops! Unable to update primary topic", null, {
						hk: "3ilZqp"
					}), j.b.Error, n.fbt._("Retry", null, {
						hk: "1dRYXW"
					}), X(e, t)))))
				}
		},
		"./src/reddit/actions/userFlair/constants.ts": function(e, t, r) {
			"use strict";
			r.d(t, "r", (function() {
				return n
			})), r.d(t, "a", (function() {
				return s
			})), r.d(t, "i", (function() {
				return i
			})), r.d(t, "j", (function() {
				return o
			})), r.d(t, "h", (function() {
				return d
			})), r.d(t, "c", (function() {
				return c
			})), r.d(t, "d", (function() {
				return a
			})), r.d(t, "b", (function() {
				return u
			})), r.d(t, "p", (function() {
				return l
			})), r.d(t, "q", (function() {
				return b
			})), r.d(t, "o", (function() {
				return p
			})), r.d(t, "f", (function() {
				return f
			})), r.d(t, "g", (function() {
				return m
			})), r.d(t, "e", (function() {
				return _
			})), r.d(t, "m", (function() {
				return O
			})), r.d(t, "n", (function() {
				return j
			})), r.d(t, "l", (function() {
				return g
			})), r.d(t, "k", (function() {
				return I
			}));
			const n = "USER_FLAIR_DATA__MUTATED",
				s = "AUTHOR_FLAIR_DATA__MUTATED",
				i = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_PENDING",
				o = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_SUCCESS",
				d = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_FAILED",
				c = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_PENDING",
				a = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_SUCCESS",
				u = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_FAILED",
				l = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_PENDING",
				b = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_SUCCESS",
				p = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_FAILED",
				f = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_PENDING",
				m = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_SUCCESS",
				_ = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_FAILED",
				O = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_PENDING",
				j = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_SUCCESS",
				g = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_FAILED",
				I = "USERFLAIR_FETCH_SUCCESS"
		},
		"./src/reddit/actions/userFlair/userFlair.ts": function(e, t, r) {
			"use strict";
			r.r(t), r.d(t, "userFlairEnabledSettingPending", (function() {
				return g
			})), r.d(t, "userFlairEnabledSettingSuccess", (function() {
				return I
			})), r.d(t, "userFlairEnabledSettingFailed", (function() {
				return S
			})), r.d(t, "userFlairAllowAssingOwnSettingPending", (function() {
				return E
			})), r.d(t, "userFlairAllowAssignOwnSettingSuccess", (function() {
				return y
			})), r.d(t, "userFlairAllowAssingOwnSettingFailed", (function() {
				return h
			})), r.d(t, "userFlairSaveTemplatePending", (function() {
				return T
			})), r.d(t, "userFlairSaveTemplateSuccess", (function() {
				return v
			})), r.d(t, "userFlairSaveTemplateFailed", (function() {
				return w
			})), r.d(t, "userFlairDeleteTemplatePending", (function() {
				return x
			})), r.d(t, "userFlairDeleteTemplateSuccess", (function() {
				return C
			})), r.d(t, "userFlairDeleteTemplateFailed", (function() {
				return k
			})), r.d(t, "userFlairReorderTemplatesPending", (function() {
				return D
			})), r.d(t, "userFlairReorderTemplatesSuccess", (function() {
				return R
			})), r.d(t, "userFlairReorderTemplatesFailed", (function() {
				return A
			})), r.d(t, "userFlairFetchSuccess", (function() {
				return N
			})), r.d(t, "userFlairMutated", (function() {
				return L
			})), r.d(t, "authorFlairMutated", (function() {
				return P
			})), r.d(t, "userFlairChanged", (function() {
				return U
			})), r.d(t, "toggleUserFlairInSubreddit", (function() {
				return G
			})), r.d(t, "toggleAssignOwnFlairPermission", (function() {
				return F
			})), r.d(t, "saveUserFlairTemplate", (function() {
				return B
			})), r.d(t, "deleteUserFlairTemplate", (function() {
				return q
			})), r.d(t, "reorderUserFlairTemplates", (function() {
				return M
			})), r.d(t, "userFlairLoadedAndModalOpened", (function() {
				return Q
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./node_modules/lodash/isEmpty.js"),
				o = r.n(i),
				d = r("./src/reddit/actions/authorFlair.ts"),
				c = r("./src/reddit/actions/toaster.ts"),
				a = r("./src/reddit/endpoints/flair/index.ts"),
				u = r("./src/reddit/helpers/flair.ts"),
				l = r("./src/reddit/models/Flair/index.ts"),
				b = r("./src/reddit/models/Toast/index.ts"),
				p = r("./src/reddit/models/User/index.ts"),
				f = r("./src/reddit/selectors/subreddit.ts"),
				m = r("./src/reddit/selectors/userFlair.ts"),
				_ = r("./src/lib/initializeClient/installReducer.ts"),
				O = r("./src/reddit/reducers/features/userFlair/index.ts"),
				j = r("./src/reddit/actions/userFlair/constants.ts");
			Object(_.a)({
				features: {
					userFlair: O.a
				}
			});
			const g = Object(s.a)(j.i),
				I = Object(s.a)(j.j),
				S = Object(s.a)(j.h),
				E = Object(s.a)(j.c),
				y = Object(s.a)(j.d),
				h = Object(s.a)(j.b),
				T = Object(s.a)(j.p),
				v = Object(s.a)(j.q),
				w = Object(s.a)(j.o),
				x = Object(s.a)(j.f),
				C = Object(s.a)(j.g),
				k = Object(s.a)(j.e),
				D = Object(s.a)(j.m),
				R = Object(s.a)(j.n),
				A = Object(s.a)(j.l),
				N = Object(s.a)(j.k),
				L = Object(s.a)(j.r),
				P = Object(s.a)(j.a),
				U = (e, t, r, n, s) => async (i, o, {
					apiContext: d
				}) => {
					const c = o(),
						l = c.user.account,
						b = l ? Object(p.e)(l) : void 0,
						_ = {
							...Object(m.d)(c, {
								subredditId: s
							}).displaySettings,
							isUserEnabled: r
						},
						O = {
							userName: n,
							subredditId: s,
							applied: e,
							displaySettings: _
						};
					i(n === b ? L(O) : P(O));
					const j = Object(f.R)(c, {
							subredditId: s
						}),
						g = t && e ? Object(u.g)(e) : void 0;
					Object(a.g)(d(), n, j.name, t, g), n === b && Object(a.i)(d(), r, j.name)
				}, G = (e, t) => async (r, n, {
					apiContext: s
				}) => {
					const i = n(),
						o = Object(f.R)(i, {
							subredditId: e
						}).name;
					r(g());
					const d = await Object(a.l)(s(), o, t);
					if (d.ok) {
						r(I({
							subredditId: e,
							isEnabled: t
						}))
					} else r(S());
					return d.ok
				}, F = (e, t) => async (r, n, {
					apiContext: s
				}) => {
					const i = n(),
						o = Object(f.R)(i, {
							subredditId: e
						}).name;
					r(E());
					const d = await Object(a.j)(s(), t, l.d.UserFlair, o);
					if (d.ok) {
						r(y({
							subredditId: e,
							canAssignOwn: t
						}))
					} else r(h());
					return d.ok
				}, B = (e, t) => async (r, s, {
					apiContext: i
				}) => {
					const o = s(),
						d = Object(f.R)(o, {
							subredditId: t
						}).name;
					r(T());
					const u = await Object(a.f)(i(), e, d, l.d.UserFlair),
						p = u.ok && !(u.body && !1 === u.body.success);
					if (p) {
						const e = {
							subredditId: t,
							template: u.body
						};
						r(v(e));
						const s = Object(c.e)(n.fbt._("Flair saved!", null, {
							hk: "354KI0"
						}), b.b.SuccessMod);
						r(Object(c.f)(s))
					} else {
						r(w());
						const s = Object(c.e)(n.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "4tkRNl"
						}), b.b.Error, n.fbt._("Retry", null, {
							hk: "4zNHTm"
						}), B(e, t));
						r(Object(c.f)(s))
					}
					return p
				}, q = (e, t) => async (r, s, {
					apiContext: i
				}) => {
					const o = s(),
						d = Object(f.R)(o, {
							subredditId: t
						}).name;
					if (r(x()), (await Object(a.b)(i(), e, d)).ok) {
						r(C({
							subredditId: t,
							templateId: e
						}));
						const s = Object(c.e)(n.fbt._("Flair deleted!", null, {
							hk: "1mNdn0"
						}), b.b.SuccessMod);
						r(Object(c.f)(s))
					} else {
						r(k());
						const s = Object(c.e)(n.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "2QrdJr"
						}), b.b.Error, n.fbt._("Retry", null, {
							hk: "1buF3Y"
						}), q(e, t));
						r(Object(c.f)(s))
					}
				}, M = (e, t) => async (r, s, {
					apiContext: i
				}) => {
					const o = s(),
						d = Object(f.R)(o, {
							subredditId: t
						}).name,
						u = Object(m.d)(o, {
							subredditId: t
						}).templateIds;
					if (r(D({
							subredditId: t,
							templateIds: e
						})), (await Object(a.e)(i(), d, l.d.UserFlair, e)).ok) {
						r(R());
						const e = Object(c.e)(n.fbt._("Flair reorder saved.", null, {
							hk: "1zrDON"
						}), b.b.SuccessMod);
						r(Object(c.f)(e))
					} else {
						r(A({
							subredditId: t,
							templateIds: u
						}));
						const s = Object(c.e)(n.fbt._("Sorry. Flair reorder wasn't saved.", null, {
							hk: "3gAbwk"
						}), b.b.Error, n.fbt._("Retry", null, {
							hk: "2nPnNw"
						}), M(e, t));
						r(Object(c.f)(s))
					}
				}, Q = (e, t) => async (r, s, {
					apiContext: i
				}) => {
					var u;
					const l = s(),
						p = null === (u = l.features) || void 0 === u ? void 0 : u.userFlair;
					if (p && p[e] && p[e].displaySettings.isEnabled && o()(p[e].templateIds)) {
						const s = Object(f.R)(l, {
								subredditId: e
							}).name,
							o = await Object(a.d)(i(), s);
						if (o.ok) r(N(o.body)), r(Object(d.b)({
							username: t,
							subredditId: e
						}));
						else {
							const e = Object(c.e)(n.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							}), b.b.Error);
							r(Object(c.f)(e))
						}
					} else r(Object(d.b)({
						username: t,
						subredditId: e
					}))
				}
		},
		"./src/reddit/actions/widgets/constants.ts": function(e, t, r) {
			"use strict";
			r.d(t, "g", (function() {
				return n
			})), r.d(t, "i", (function() {
				return s
			})), r.d(t, "h", (function() {
				return i
			})), r.d(t, "f", (function() {
				return o
			})), r.d(t, "d", (function() {
				return d
			})), r.d(t, "e", (function() {
				return c
			})), r.d(t, "c", (function() {
				return a
			})), r.d(t, "b", (function() {
				return u
			})), r.d(t, "a", (function() {
				return l
			}));
			const n = "WIDGETS__WIDGET_CREATED",
				s = "WIDGETS__WIDGET_UPDATED",
				i = "WIDGET_DELETED",
				o = "WIDGETS_SORTED",
				d = "WIDGETS__STARTED_EDITING_WIDGET",
				c = "WIDGETS__LOADED",
				a = "SUBREDDIT__WIDGETS_PENDING",
				u = "SUBREDDIT__WIDGETS_LOADED",
				l = "SUBREDDIT__WIDGETS_FAILED"
		},
		"./src/reddit/actions/widgets/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return h
			})), r.d(t, "e", (function() {
				return v
			})), r.d(t, "d", (function() {
				return x
			})), r.d(t, "h", (function() {
				return k
			})), r.d(t, "a", (function() {
				return D
			})), r.d(t, "b", (function() {
				return R
			})), r.d(t, "f", (function() {
				return N
			})), r.d(t, "g", (function() {
				return G
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/reddit/actions/apiRequestState.ts"),
				o = r("./src/reddit/actions/imageUploads.ts"),
				d = r("./src/reddit/actions/toaster.ts"),
				c = r("./src/lib/constants/index.ts"),
				a = r("./src/lib/makeApiRequest/index.ts"),
				u = r("./src/lib/omitHeaders/index.ts"),
				l = r("./src/reddit/constants/headers.ts");
			const b = async (e, t, r) => Object(a.a)(Object(u.a)(e, [l.a]), {
				endpoint: `${e.apiUrl}/r/${t}/api/widgets`,
				method: c.jb.GET,
				type: "json",
				data: {
					progressive_images: r
				}
			});
			var p = r("./src/reddit/helpers/getGenericUploadError.ts"),
				f = r("./src/reddit/helpers/media/index.ts"),
				m = r("./src/lib/assertNever.ts"),
				_ = r("./src/reddit/models/Widgets/index.ts"),
				O = r("./src/reddit/selectors/subreddit.ts"),
				j = r("./src/reddit/helpers/widgets/index.tsx"),
				g = r("./src/reddit/models/Image/index.tsx"),
				I = r("./src/reddit/models/Toast/index.ts"),
				S = r("./src/reddit/selectors/experiments/cnc/index.ts"),
				E = r("./src/reddit/actions/widgets/constants.ts");
			const y = Object(s.a)(E.g),
				h = (e, t, r) => async (s, b, f) => {
					const {
						apiContext: m
					} = f;
					s(Object(i.h)(r));
					const _ = b(),
						E = Object(O.R)(_, {
							subredditId: e
						}).name,
						h = Object(S.b)(_),
						T = Object(j.e)(t);
					let v = null,
						w = null;
					try {
						(v = await Object(o.f)(_, g.a.Widgets)) && (w = Object(o.m)(v)(s, b, f))
					} catch (C) {
						const e = Object(p.a)("webSocket");
						return void s(Object(i.f)(r, e))
					}
					if (h && w) try {
						await w
					} catch (C) {}
					const x = await (async (e, t, r) => Object(a.a)(Object(u.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/widget`,
						method: c.jb.POST,
						type: "json",
						data: r
					}))(m(), E, T);
					if (x.ok) {
						let o = x.body;
						const c = o.id;
						if ("calendar" === t.kind && s(Object(d.f)({
								kind: I.b.SuccessMod,
								text: n.fbt._("New calendar added! It may take a few minutes to see your events appear", null, {
									hk: "4iETrT"
								})
							})), v) {
							if (!h) try {
								await w
							} catch (C) {}
							o = await s(F(e, c)) || o
						}
						s(y({
							subredditId: e,
							widget: o,
							widgetId: c
						})), s(Object(i.e)(r))
					} else v && v.websocket.close(), s(Object(i.f)(r, x.error))
				}, T = Object(s.a)(E.i), v = (e, t, r) => async (s, b, f) => {
					const {
						apiContext: E
					} = f;
					s(Object(i.h)(r));
					const y = t.id,
						h = b(),
						v = Object(O.R)(h, {
							subredditId: e
						}).name,
						w = Object(S.b)(h),
						x = Object(j.e)(t);
					let C = null,
						k = null;
					try {
						(C = await Object(o.f)(h, g.a.Widgets)) && (k = Object(o.m)(C)(s, b, f))
					} catch (R) {
						const e = Object(p.a)("webSocket");
						return void s(Object(i.f)(r, e))
					}
					if (w && k) try {
						await k
					} catch (R) {}
					const D = await (async (e, t, r) => Object(a.a)(Object(u.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/widget/${r.id}`,
						method: c.jb.PUT,
						type: "json",
						data: r
					}))(E(), v, x);
					if (D.ok) {
						let o = function(e, t, r) {
							switch (e.kind) {
								case _.i.Calendar:
								case _.i.IdCard:
								case _.i.SubredditRules:
									return {
										...e, ...t
									};
								case _.i.CommunityList: {
									const n = {};
									for (const t of e.data) n[t.name] = t;
									return {
										...t,
										data: t.data.map(e => {
											if (!("subscribers" in n[e])) {
												const t = {
														subredditName: e
													},
													n = Object(O.w)(r, t),
													s = Object(O.t)(r, t);
												return {
													name: n.name,
													subscribers: n ? n.subscribers : void 0,
													iconUrl: n ? n.communityIcon : void 0,
													isNSFW: n ? n.isNSFW : void 0,
													isSubscribed: s ? s.userIsSubscriber : void 0
												}
											}
											return n[e]
										})
									}
								}
								case _.i.Button:
								case _.i.Custom:
								case _.i.Image:
								case _.j.Menu:
								case _.i.Moderators:
								case _.i.Textarea:
								case _.i.PostFlair:
									return t;
								default:
									return Object(m.a)(e)
							}
						}(t, D.body, h);
						if (k) {
							if (!w) try {
								await k
							} catch (R) {}
							o = await s(F(e, y)) || o
						}
						s(T({
							subredditId: e,
							widgetId: y,
							widget: o
						})), "calendar" === t.kind && s(Object(d.f)({
							kind: I.b.SuccessMod,
							text: n.fbt._("Calendar is updated! It may take a few minutes to see your events change", null, {
								hk: "10XWV"
							})
						})), s(Object(i.e)(r))
					} else C && C.websocket.close(), s(Object(i.f)(r, D.error))
				}, w = Object(s.a)(E.h), x = (e, t, r) => async (n, s, {
					apiContext: o
				}) => {
					n(Object(i.h)(r));
					const d = t.id,
						b = Object(O.R)(s(), {
							subredditId: e
						}).name,
						p = await (async (e, t, r) => Object(a.a)(Object(u.a)(e, [l.a]), {
							endpoint: `${e.apiUrl}/r/${t}/api/widget/${r.id}`,
							method: c.jb.DELETE,
							type: "json"
						}))(o(), b, t);
					p.ok ? (n(Object(i.e)(r)), n(w({
						subredditId: e,
						widgetId: d
					}))) : n(Object(i.f)(r, p.error))
				}, C = Object(s.a)(E.f), k = (e, t) => async (r, n, {
					apiContext: s
				}) => {
					const i = Object(O.R)(n(), {
						subredditId: e
					}).name;
					(await (async (e, t, r) => Object(a.a)(Object(u.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/widget_order/sidebar`,
						method: c.jb.PATCH,
						type: "json",
						data: r
					}))(s(), i, t)).ok && r(C({
						subredditId: e,
						widgetIds: t
					}))
				}, D = ({
					imageData: e
				}) => async (t, r, n) => {
					const s = r(),
						i = s.structuredStyles.isEditing,
						d = Object(O.R)(s, {
							subredditId: i
						}).name;
					t(Object(o.k)(e));
					const b = await (async (e, t, r, n) => Object(a.a)(Object(u.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/widget_image_upload_s3`,
						method: c.jb.POST,
						data: {
							filepath: r,
							mimetype: n
						}
					}))(n.apiContext(), d, e.file.name, await Object(f.g)(e.file));
					let p = !1;
					try {
						const n = await Object(o.g)(r(), b, e, g.a.Widgets);
						n && (t(Object(o.j)(n)), p = !0)
					} catch (m) {
						if (m instanceof Error) throw m;
						t(Object(o.i)(m))
					}
					return p
				}, R = Object(s.a)(E.d), A = Object(s.a)(E.e), N = (e, t) => async (r, n, {
					apiContext: s
				}) => {
					r(Object(i.h)(t));
					const o = Object(O.R)(n(), {
							subredditId: e
						}).name,
						d = await b(s(), o);
					if (d.ok) {
						const n = d.body;
						r(A({
							subredditId: e,
							widgets: n
						})), r(Object(i.e)(t))
					} else r(Object(i.f)(t, d.error))
				}, L = Object(s.a)(E.c), P = Object(s.a)(E.b), U = Object(s.a)(E.a), G = (e, t) => async (r, n, {
					apiContext: s
				}) => {
					r(L({
						subredditId: e
					}));
					const i = Object(O.R)(n(), {
							subredditId: e
						}).name,
						o = await b(s(), i, t);
					if (o.ok) {
						const t = o.body;
						r(P({
							subredditId: e,
							widgets: t
						}))
					} else r(U({
						subredditId: e,
						error: o.error
					}))
				}, F = (e, t) => async (r, n, {
					apiContext: s
				}) => {
					const i = Object(O.R)(n(), {
							subredditId: e
						}).name,
						o = await b(s(), i, !0);
					if (o.ok) return o.body.items[t]
				}
		},
		"./src/reddit/components/CrosspostRecommendationsModal/constants.tsx": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return n
			})), r.d(t, "b", (function() {
				return s
			}));
			const n = "crosspost_recommendations_modal_id",
				s = 3e3
		},
		"./src/reddit/constants/elementIds.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return n
			})), r.d(t, "c", (function() {
				return s
			})), r.d(t, "d", (function() {
				return i
			})), r.d(t, "b", (function() {
				return o
			}));
			const n = "bladeContainer",
				s = "header",
				i = "overlayScrollContainer",
				o = "collectionPostListScrollContainer"
		},
		"./src/reddit/constants/graphql.ts": function(e, t, r) {
			"use strict";
			var n;
			r.d(t, "a", (function() {
					return n
				})),
				function(e) {
					e.Card = "CARD", e.Classic = "CLASSIC", e.Compact = "COMPACT"
				}(n || (n = {}))
		},
		"./src/reddit/constants/shortcuts.ts": function(e, t, r) {
			"use strict";
			var n, s;
			r.d(t, "d", (function() {
					return n
				})), r.d(t, "c", (function() {
					return s
				})), r.d(t, "b", (function() {
					return i
				})), r.d(t, "a", (function() {
					return o
				})),
				function(e) {
					e.CommentPage = "CommentPage", e.Global = "Global", e.Lightbox = "Lightbox", e.Listing = "Listing", e.Modqueue = "Modqueue"
				}(n || (n = {})),
				function(e) {
					e.Close = "CLOSE", e.CollapseOrLoad = "COLLAPSE_OR_LOAD", e.Downvote = "DOWNVOTE", e.Expando = "EXPANDO", e.Hide = "HIDE", e.Konami = "KONAMI", e.NewPost = "NEW_POST", e.NextComment = "NEXT_COMMENT", e.NextPost = "NEXT_POST", e.OpenIndex = "OPEN_INDEX", e.OpenLightbox = "OPEN_LIGHTBOX", e.OpenLink = "OPEN_LINK", e.PrevComment = "PREV_COMMENT", e.PrevPost = "PREV_POST", e.Reply = "REPLY", e.Save = "SAVE", e.Upvote = "UPVOTE"
				}(s || (s = {}));
			const i = "SHORTCUT_FOCUSABLE_DIV",
				o = [9, 13, 32]
		},
		"./src/reddit/constants/zIndex.ts": function(e, t, r) {
			"use strict";
			r.d(t, "f", (function() {
				return n
			})), r.d(t, "c", (function() {
				return s
			})), r.d(t, "d", (function() {
				return i
			})), r.d(t, "a", (function() {
				return o
			})), r.d(t, "e", (function() {
				return d
			})), r.d(t, "g", (function() {
				return c
			})), r.d(t, "b", (function() {
				return a
			}));
			const n = 4,
				s = 60,
				i = 70,
				o = 90,
				d = 99,
				c = 100,
				a = 100
		},
		"./src/reddit/controls/Button/index.m.less": function(e, t, r) {
			e.exports = {
				Button: "_2iuoyPiKHN3kfOoeIQalDT",
				button: "_2iuoyPiKHN3kfOoeIQalDT",
				isFullWidth: "_34mIRHpFtnJ0Sk97S2Z3D9",
				xxsmallButtonStyles: "_1h6qKGhVsgNfytYFlo8m3f",
				Icon: "_1mvTX6krm3Q2d1CSyUm28s",
				icon: "_1mvTX6krm3Q2d1CSyUm28s",
				isLeft: "_1HHR_ND8U6x6YrIqKFeXZy",
				isRight: "_3tKmDp5VAtgWvabEmFkJ7T",
				xsmallButtonStyles: "_3uJP0daPEH2plzVEYyTdaH",
				xsmallBigPaddingButtonStyles: "UEPNkU0rd1-nvbkOcBatc",
				smallButtonStyles: "HNozj_dKjQZ59ZsfEegz8",
				mediumButtonStyles: "_3ukcnQySDskQwK_wB2iXYl",
				largeButtonStyles: "_1J4mN6_wNfCtSyMDUNGQqN",
				xlargeButtonStyles: "XpD6n11mOiKNg8ZKtvgVR",
				primary: "_10BQ7pjWbeYP63SAPNS8Ts",
				active: "_39a0Mt5b1i2joAqIaEHOWJ",
				redditStyle: "_2nelDm85zKKmuD94NequP0",
				DangerButtonColors: "_1t63zWyh9UUgsyQc6acROM",
				dangerButtonColors: "_1t63zWyh9UUgsyQc6acROM",
				GoldButtonColors: "_10UWrWSil1Xu6pdSaa_3-K",
				goldButtonColors: "_10UWrWSil1Xu6pdSaa_3-K",
				PremiumButtonColors: "q_unSaY23rpdd3lDvGZ-",
				premiumButtonColors: "q_unSaY23rpdd3lDvGZ-",
				secondary: "_2tU8R9NTqhvBrhoNAXWWcP",
				tertiary: "_4Glnzr5LA7bNBGMWGW4pU",
				plain: "_3zbhtNO0bdck0oYbYRhjMC",
				isIconOnly: "_1tPpYVD73ugqp4k-VMFRki",
				isSquare: "_3ojSE1JW7jxNzUzZK8kt7m",
				ExtraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				extraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				InlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				inlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				ChatButton: "_13twe55MPRo1LqypxB-LJx",
				chatButton: "_13twe55MPRo1LqypxB-LJx",
				PlainLinkButton: "_2UhHcZFBOYxMULbf2p-skl",
				plainLinkButton: "_2UhHcZFBOYxMULbf2p-skl"
			}
		},
		"./src/reddit/controls/Button/index.tsx": function(e, t, r) {
			"use strict";
			r.d(t, "d", (function() {
				return l
			})), r.d(t, "c", (function() {
				return b
			})), r.d(t, "h", (function() {
				return p
			})), r.d(t, "b", (function() {
				return f
			})), r.d(t, "a", (function() {
				return m
			})), r.d(t, "m", (function() {
				return g
			})), r.d(t, "n", (function() {
				return I
			})), r.d(t, "l", (function() {
				return S
			})), r.d(t, "p", (function() {
				return E
			})), r.d(t, "q", (function() {
				return y
			})), r.d(t, "o", (function() {
				return h
			})), r.d(t, "s", (function() {
				return T
			})), r.d(t, "r", (function() {
				return v
			})), r.d(t, "f", (function() {
				return w
			})), r.d(t, "g", (function() {
				return x
			})), r.d(t, "k", (function() {
				return C
			})), r.d(t, "e", (function() {
				return k
			})), r.d(t, "i", (function() {
				return D
			})), r.d(t, "j", (function() {
				return R
			}));
			var n = r("./node_modules/react/index.js"),
				s = r.n(n),
				i = r("./src/lib/classNames/index.ts"),
				o = r("./src/reddit/controls/InternalLink/index.tsx"),
				d = r("./src/reddit/controls/Button/index.m.less"),
				c = r.n(d);

			function a() {
				return (a = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var r = arguments[t];
						for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
					}
					return e
				}).apply(this, arguments)
			}
			const u = {
				role: "button",
				tabIndex: 0
			};
			var l, b, p, f;
			! function(e) {
				e.XXS = "xxsmallButtonStyles", e.XS = "xsmallButtonStyles", e.XSP = "xsmallBigPaddingButtonStyles", e.S = "smallButtonStyles", e.M = "mediumButtonStyles", e.L = "largeButtonStyles", e.XL = "xlargeButtonStyles"
			}(l || (l = {})),
			function(e) {
				e.Primary = "primary", e.Secondary = "secondary", e.Tertiary = "tertiary", e.Plain = "plain", e.PlainLink = "plainLink"
			}(b || (b = {})),
			function(e) {
				e.L = "left", e.R = "right", e.C = "center"
			}(p || (p = {})),
			function(e) {
				e.Button = "button", e.ExternalLink = "external-link", e.InternalLink = "internal-link"
			}(f || (f = {}));
			const m = e => {
					const {
						"data-redditstyle": t,
						Icon: r,
						iconClassName: n,
						iconPosition: o = p.C,
						isFullWidth: d = !1,
						isSquare: m = !1,
						children: g,
						className: I,
						kind: S = f.Button,
						priority: E = b.Primary,
						redditStyle: y,
						size: h = l.S,
						text: T,
						textClassName: v,
						...w
					} = e, x = (({
						baseClassName: e,
						redditStyle: t,
						dataRedditStyle: r,
						Icon: n,
						isFullWidth: s,
						isSquare: o,
						priority: d,
						size: a,
						text: u
					}) => Object(i.a)(e, c.a.Button, d && c.a[d], a && c.a[a], {
						[c.a.isFullWidth]: s,
						[c.a.isIconOnly]: !!n && !u,
						[c.a.isSquare]: o,
						[c.a.redditStyle]: !(!t && !r)
					}))({
						baseClassName: I,
						children: g,
						dataRedditStyle: t,
						Icon: r,
						isFullWidth: d,
						isSquare: m,
						priority: E,
						redditStyle: y,
						size: h,
						text: T
					}), C = (({
						children: e,
						text: t,
						Icon: r,
						iconClassName: n,
						iconPosition: o,
						priority: d,
						textClassName: a
					}) => !r && t ? s.a.createElement("span", {
						className: a
					}, t) : s.a.createElement(s.a.Fragment, null, r && (o === p.C || o === p.L) && s.a.createElement(r, {
						className: Object(i.a)(c.a.Icon, n, {
							[c.a.isLeft]: o === p.L
						}),
						isFilled: d === b.Primary
					}), t && s.a.createElement("span", {
						className: Object(i.a)(c.a.Text, a)
					}, t), e && e, r && o === p.R && s.a.createElement(r, {
						className: Object(i.a)(c.a.Icon, n, c.a.isRight),
						isFilled: d === b.Primary
					})))({
						children: g,
						text: T,
						Icon: r,
						iconClassName: n,
						iconPosition: o,
						priority: E,
						textClassName: v
					});
					return S === f.InternalLink && (e => "to" in e)(w) ? s.a.createElement(_, a({}, u, w, {
						className: x
					}), C) : S === f.ExternalLink && (e => "href" in e)(w) ? s.a.createElement(O, a({}, u, w, {
						className: x
					}), C) : s.a.createElement(j, a({}, u, w, {
						className: x
					}), C)
				},
				_ = e => s.a.createElement(o.a, e),
				O = e => s.a.createElement("a", e),
				j = e => s.a.createElement("button", e),
				g = e => s.a.createElement(m, a({
					kind: f.ExternalLink,
					priority: b.Primary
				}, e)),
				I = e => s.a.createElement(m, a({
					kind: f.InternalLink,
					priority: b.Primary
				}, e)),
				S = e => s.a.createElement(m, a({
					kind: f.Button,
					priority: b.Primary
				}, e)),
				E = e => s.a.createElement(m, a({
					kind: f.ExternalLink,
					priority: b.Secondary
				}, e)),
				y = e => s.a.createElement(m, a({
					kind: f.InternalLink,
					priority: b.Secondary
				}, e)),
				h = e => s.a.createElement(m, a({
					kind: f.Button,
					priority: b.Secondary
				}, e)),
				T = e => s.a.createElement(m, a({
					kind: f.InternalLink,
					priority: b.Plain
				}, e)),
				v = e => s.a.createElement(m, a({
					kind: f.Button,
					priority: b.Plain
				}, e)),
				w = ({
					className: e,
					...t
				}) => s.a.createElement(m, a({
					kind: f.Button,
					priority: b.Primary,
					className: Object(i.a)(e, c.a.DangerButtonColors)
				}, t)),
				x = ({
					className: e,
					...t
				}) => s.a.createElement(m, a({
					kind: f.Button,
					className: Object(i.a)(e, c.a.GoldButtonColors)
				}, t)),
				C = ({
					className: e,
					...t
				}) => s.a.createElement(m, a({
					kind: f.Button,
					className: Object(i.a)(e, c.a.PremiumButtonColors)
				}, t)),
				k = ({
					className: e,
					...t
				}) => s.a.createElement(m, a({
					kind: f.Button,
					className: Object(i.a)(e, c.a.ChatButton)
				}, t)),
				D = ({
					className: e,
					...t
				}) => s.a.createElement(m, a({
					kind: f.Button,
					className: Object(i.a)(e, c.a.InlineTextButton)
				}, t)),
				R = ({
					className: e,
					...t
				}) => s.a.createElement(m, a({
					kind: f.Button,
					className: Object(i.a)(e, c.a.PlainLinkButton),
					priority: b.PlainLink
				}, t));
			t.t = m
		},
		"./src/reddit/controls/Dropdown/index.m.less": function(e, t, r) {
			e.exports = {
				dropdownTriangle: "_1oxgVV3q47KbjEKqP5CHuM",
				dropdown: "_2uYY-KeuYHKiwl-9aF0UiL"
			}
		},
		"./src/reddit/controls/Dropdown/index.tsx": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return u
			}));
			var n = r("./node_modules/react/index.js"),
				s = r.n(n),
				i = r("./src/lib/classNames/index.ts"),
				o = r("./src/lib/domUtils/index.ts"),
				d = r("./src/reddit/constants/zIndex.ts"),
				c = r("./src/reddit/controls/Dropdown/index.m.less"),
				a = r.n(c);
			class u extends s.a.Component {
				componentDidMount() {
					this.props.onDropdownMounted && this.props.onDropdownMounted(), this.props.noFocus || this.ref && this.ref.focus({
						preventScroll: this.props.isOverlay
					})
				}
				componentWillUnmount() {
					Object(o.a)(this.props.tooltipId)
				}
				render() {
					const e = this.props,
						t = {};
					return (e.isFixed || e.isOverlay) && (e.isFixed && (t.position = "fixed"), e.isOverlay && (t.zIndex = e.isFixed ? d.d + 1 : d.c)), s.a.createElement("div", {
						className: Object(i.a)(a.a.dropdown, e.className),
						id: this.props.id,
						ref: e => this.ref = e,
						role: "menu",
						style: {
							...t,
							...e.style
						},
						tabIndex: -1,
						onScroll: e.onScroll
					}, e.children)
				}
			}
		},
		"./src/reddit/controls/InternalLink/index.m.less": function(e, t, r) {
			e.exports = {
				disabledLink: "_1tQt2CUWT3M7NNSMoh_o_4"
			}
		},
		"./src/reddit/controls/InternalLink/index.tsx": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return l
			}));
			var n = r("./node_modules/react/index.js"),
				s = r.n(n),
				i = r("./node_modules/react-router-dom/esm/react-router-dom.js"),
				o = r("./src/lib/classNames/index.ts"),
				d = r("./src/reddit/helpers/path/index.ts"),
				c = r("./src/reddit/controls/InternalLink/index.m.less"),
				a = r.n(c);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var r = arguments[t];
						for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
					}
					return e
				}).apply(this, arguments)
			}

			function l({
				children: e,
				className: t,
				disabled: r,
				replace: n,
				to: c,
				...l
			}) {
				return r ? s.a.createElement("span", {
					className: Object(o.a)(a.a.disabledLink, t)
				}, e) : ("string" == typeof c && (c = Object(d.b)(c)), s.a.createElement(i.a, u({
					className: t,
					to: c
				}, l), e))
			}
		},
		"./src/reddit/endpoints/comment/index.tsx": function(e, t, r) {
			"use strict";
			r.d(t, "i", (function() {
				return _
			})), r.d(t, "m", (function() {
				return O
			})), r.d(t, "e", (function() {
				return j
			})), r.d(t, "l", (function() {
				return g
			})), r.d(t, "a", (function() {
				return I
			})), r.d(t, "h", (function() {
				return S
			})), r.d(t, "d", (function() {
				return E
			})), r.d(t, "k", (function() {
				return y
			})), r.d(t, "j", (function() {
				return h
			})), r.d(t, "f", (function() {
				return T
			})), r.d(t, "g", (function() {
				return v
			})), r.d(t, "b", (function() {
				return x
			})), r.d(t, "c", (function() {
				return C
			}));
			var n = r("./src/config.ts"),
				s = r("./src/redditGQL/operations/UpdateCommentDistinguishState.json"),
				i = r("./src/redditGQL/operations/UpdateCommentStickyState.json"),
				o = r("./src/redditGQL/types.ts"),
				d = r("./src/lib/constants/index.ts"),
				c = r("./src/lib/makeApiRequest/index.ts"),
				a = r("./src/lib/makeGqlRequest/index.ts"),
				u = r("./src/lib/omitHeaders/index.ts"),
				l = r("./src/reddit/constants/headers.ts"),
				b = r("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				p = r("./src/reddit/models/Comment/addProfileImgParam.ts"),
				f = r("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				m = r("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const _ = (e, t) => Object(c.a)(Object(u.a)(e, [l.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/save`),
					method: d.jb.POST,
					data: {
						id: t
					}
				}),
				O = (e, t) => Object(c.a)(Object(u.a)(e, [l.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/unsave`),
					method: d.jb.POST,
					data: {
						id: t
					}
				}),
				j = (e, t) => Object(c.a)(Object(u.a)(e, [l.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/lock`),
					method: d.jb.POST,
					data: {
						id: t
					}
				}),
				g = (e, t) => Object(c.a)(Object(u.a)(e, [l.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/unlock`),
					method: d.jb.POST,
					data: {
						id: t
					}
				}),
				I = (e, t) => Object(c.a)(Object(u.a)(e, [l.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/approve`),
					method: d.jb.POST,
					data: {
						id: t
					}
				}),
				S = (e, t, r) => Object(c.a)(Object(u.a)(e, [l.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/remove`),
					method: d.jb.POST,
					data: {
						id: t,
						spam: r
					}
				}),
				E = (e, t) => Object(c.a)(Object(u.a)(e, [l.a]), {
					endpoint: `${e.apiUrl}/api/ignore_reports`,
					method: d.jb.POST,
					data: {
						id: t
					}
				}),
				y = (e, t) => Object(c.a)(Object(u.a)(e, [l.a]), {
					endpoint: `${e.apiUrl}/api/unignore_reports`,
					method: d.jb.POST,
					data: {
						id: t
					}
				}),
				h = (e, t) => Object(c.a)(Object(u.a)(e, [l.a]), {
					endpoint: `${e.apiUrl}/api/show_comment`,
					method: d.jb.POST,
					data: {
						id: t
					}
				}),
				T = (e, t, r, s) => {
					let i = Object(b.a)(Object(m.a)(Object(f.a)(`${n.a.gatewayUrl}/desktopapi/v1/morecomments/${t}`)));
					return s && (i = Object(p.a)(i)), Object(c.a)(e, {
						data: r,
						endpoint: i,
						method: d.jb.POST,
						type: "json",
						traceRequestName: "more_comments"
					})
				},
				v = (e, t, r, n) => Object(c.a)(Object(u.a)(e, [l.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/distinguish/${r}`),
					method: d.jb.POST,
					data: {
						id: t,
						sticky: n
					}
				}),
				w = {
					[d.G.NONE]: o.g.None,
					[d.G.MODERATOR]: o.g.ModDistinguished,
					[d.G.ADMIN]: o.g.AdminDistinguished,
					[d.G.ALUMNI_ADMIN]: o.g.AlumniDistinguished
				};

			function x(e, t, r) {
				const n = function(e, t) {
					return {
						input: {
							commentId: e,
							distinguishState: t === d.G.NONE ? o.c.None : o.c.Distinguished,
							distinguishType: w[t]
						}
					}
				}(t, r);
				return Object(a.a)(e, {
					...s,
					variables: n
				})
			}

			function C(e, t, r) {
				return Object(a.a)(e, {
					...i,
					variables: {
						input: {
							commentId: t,
							sticky: r
						}
					}
				})
			}
		},
		"./src/reddit/endpoints/economics/predictions.ts": function(e, t, r) {
			"use strict";
			r.d(t, "p", (function() {
				return S
			})), r.d(t, "n", (function() {
				return E
			})), r.d(t, "i", (function() {
				return h
			})), r.d(t, "j", (function() {
				return T
			})), r.d(t, "e", (function() {
				return v
			})), r.d(t, "k", (function() {
				return w
			})), r.d(t, "l", (function() {
				return x
			})), r.d(t, "a", (function() {
				return C
			})), r.d(t, "o", (function() {
				return k
			})), r.d(t, "f", (function() {
				return D
			})), r.d(t, "g", (function() {
				return R
			})), r.d(t, "h", (function() {
				return A
			})), r.d(t, "c", (function() {
				return N
			})), r.d(t, "b", (function() {
				return L
			})), r.d(t, "d", (function() {
				return P
			})), r.d(t, "m", (function() {
				return U
			}));
			var n = r("./src/lib/makeGqlRequest/index.ts"),
				s = r("./src/lib/makeRequest/index.ts"),
				i = r("./src/redditGQL/operations/AddPredictionDrafts.json"),
				o = r("./src/redditGQL/operations/CancelPrediction.json"),
				d = r("./src/redditGQL/operations/ChangePrediction.json"),
				c = r("./src/redditGQL/operations/ChangePredictionVote.json"),
				a = r("./src/redditGQL/operations/CreatePredictionTournament.json"),
				u = r("./src/redditGQL/operations/EndPredictionTournament.json"),
				l = r("./src/redditGQL/operations/GetPredictionChipPackages.json"),
				b = r("./src/redditGQL/operations/GetPredictionCreationAllowance.json"),
				p = r("./src/redditGQL/operations/GetPredictionToken.json"),
				f = r("./src/redditGQL/operations/GetTournaments.json"),
				m = r("./src/redditGQL/operations/GetTournamentsBaseInfo.json"),
				_ = r("./src/redditGQL/operations/ResolvePrediction.json"),
				O = r("./src/redditGQL/operations/SubredditTopPredictors.json"),
				j = r("./src/redditGQL/operations/SubredditTournamentLeaderboard.json"),
				g = r("./src/redditGQL/operations/UpdatePredictionTournament.json"),
				I = r("./src/redditGQL/operations/VotePrediction.json");
			const S = async (e, {
				postId: t,
				optionId: r,
				coinPackageId: i,
				price: o
			}) => {
				var d;
				const c = await Object(n.a)(e, {
					...I,
					variables: {
						input: {
							postId: t,
							optionId: r,
							coinPackageId: i,
							price: o
						}
					}
				});
				if (!Object(s.c)(c) || c.error || !(null === (d = c.body.data.votePrediction) || void 0 === d ? void 0 : d.ok)) throw new Error("Failed to make prediction");
				return c.body.data.votePrediction.poll
			}, E = (e, {
				postId: t,
				optionId: r
			}) => Object(n.a)(e, {
				..._,
				variables: {
					input: {
						postId: t,
						optionId: r
					}
				}
			});
			var y;
			! function(e) {
				e.AllTime = "ALL_TIME", e.Monthly = "MONTHLY"
			}(y || (y = {}));
			const h = async (e, {
				subredditId: t,
				period: r = y.AllTime,
				top: i = 100,
				includeCurrentRank: o
			}) => {
				const d = await Object(n.a)(e, {
					...O,
					variables: {
						subredditId: t,
						period: r,
						top: i,
						includeCurrentRank: o
					}
				});
				if (!Object(s.c)(d) || d.error) throw new Error("Failed to fetch subreddit top predictors");
				if (!d.body.data.subredditInfoById) throw new Error("Subreddit has no prediction winners");
				return d.body.data.subredditInfoById
			}, T = async (e, {
				subredditId: t,
				tournamentId: r,
				includeCurrentRank: i
			}) => {
				const o = await Object(n.a)(e, {
					...j,
					variables: {
						subredditId: t,
						tournamentId: r,
						includeCurrentRank: i
					}
				});
				if (!Object(s.c)(o) || o.error) throw new Error("Failed to fetch subreddit tournament");
				if (!o.body.data.subredditInfoById) throw new Error("Subreddit has no prediction winners");
				return o.body.data.subredditInfoById
			}, v = async (e, t) => {
				const r = await Object(n.a)(e, {
					...a,
					variables: {
						input: t
					}
				});
				if (!Object(s.c)(r) || r.error || !r.body.data.createPredictionTournament.tournament) throw new Error("Failed to create tournament");
				return r.body.data.createPredictionTournament.tournament
			}, w = async (e, t) => {
				const r = await Object(n.a)(e, {
					...f,
					variables: t
				});
				if (!Object(s.c)(r) || r.error) throw new Error("Failed to fetch tournaments");
				return r.body.data.subredditInfoByName.predictionTournaments || []
			}, x = async (e, t) => {
				const r = await Object(n.a)(e, {
					...m,
					variables: t
				});
				if (!Object(s.c)(r) || r.error) throw new Error("Failed to fetch tournaments");
				return r.body.data.subredditInfoByName.predictionTournaments || []
			}, C = async (e, t) => {
				const r = await Object(n.a)(e, {
					...i,
					variables: {
						input: t
					}
				});
				if (!Object(s.c)(r) || r.error) throw new Error("Failed to create prediction");
				const {
					errors: o,
					tournament: d
				} = r.body.data.addPredictionDrafts;
				if (null == o ? void 0 : o.length) throw new Error(o[0].message);
				if (!d) throw new Error("Failed to create prediction");
				return d
			}, k = async (e, t) => {
				const r = await Object(n.a)(e, {
					...g,
					variables: {
						input: t
					}
				});
				if (!Object(s.c)(r) || r.error) throw new Error("Failed to update prediction tournament");
				const {
					tournament: i
				} = r.body.data.updatePredictionTournament;
				if (!i) throw new Error("Failed to update prediction tournament");
				return i
			}, D = (e, t) => Object(n.a)(e, {
				...u,
				variables: {
					input: t
				}
			}), R = (e, t) => Object(n.a)(e, {
				...l,
				variables: t
			}), A = (e, t) => Object(n.a)(e, {
				...p,
				variables: t
			}), N = async (e, t) => {
				const r = await Object(n.a)(e, {
					...d,
					variables: {
						input: t
					}
				});
				if (!Object(s.c)(r) || !r.body.data.changePrediction.ok) throw new Error("Unable to update prediction");
				return r.body.data.changePrediction.poll
			}, L = async (e, {
				postId: t
			}) => {
				var r, i;
				const d = await Object(n.a)(e, {
					...o,
					variables: {
						input: {
							postId: t
						}
					}
				});
				if (!Object(s.c)(d) || !(null === (r = d.body.data.cancelPrediction) || void 0 === r ? void 0 : r.ok) || !(null === (i = d.body.data.cancelPrediction) || void 0 === i ? void 0 : i.poll)) throw new Error("Unable to cancel prediction");
				return d.body.data.cancelPrediction.poll
			}, P = async (e, t) => {
				var r, i;
				const o = await Object(n.a)(e, {
					...c,
					variables: {
						input: t
					}
				});
				if (!Object(s.c)(o) || !(null === (r = o.body.data.changePredictionVote) || void 0 === r ? void 0 : r.ok) || !(null === (i = o.body.data.changePredictionVote) || void 0 === i ? void 0 : i.poll)) throw new Error("Unable to change prediction.");
				return o.body.data.changePredictionVote.poll
			}, U = async (e, t) => {
				const r = await Object(n.a)(e, {
					...b,
					variables: t
				});
				return !!Object(s.c)(r) && r.body.data.identity.isPredictionCreationAllowed
			}
		},
		"./src/reddit/endpoints/gold/powerups/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return _
			})), r.d(t, "j", (function() {
				return O
			})), r.d(t, "g", (function() {
				return j
			})), r.d(t, "h", (function() {
				return g
			})), r.d(t, "i", (function() {
				return I
			})), r.d(t, "e", (function() {
				return S
			})), r.d(t, "f", (function() {
				return E
			})), r.d(t, "d", (function() {
				return y
			})), r.d(t, "a", (function() {
				return h
			})), r.d(t, "b", (function() {
				return T
			})), r.d(t, "k", (function() {
				return v
			}));
			var n = r("./src/lib/makeGqlRequest/index.ts"),
				s = r("./src/redditGQL/operations/CreateCustomEmoji.json"),
				i = r("./src/redditGQL/operations/DeleteCustomEmoji.json"),
				o = r("./src/redditGQL/operations/EnablePowerups.json"),
				d = r("./src/redditGQL/operations/GenerateCustomEmojiUploadLease.json"),
				c = r("./src/redditGQL/operations/ReallocatePowerups.json"),
				a = r("./src/redditGQL/operations/RedditorPowerups.json"),
				u = r("./src/redditGQL/operations/SubredditPowerups.json"),
				l = r("./src/redditGQL/operations/SubredditPowerupsFull.json"),
				b = r("./src/redditGQL/operations/SubredditsPowerups.json"),
				p = r("./src/redditGQL/operations/UpdatePowerupsSettings.json"),
				f = r("./src/redditGQL/operations/UserPowerups.json"),
				m = r("./src/reddit/actions/economics/powerups/helpers.ts");
			const _ = async (e, t) => {
				const r = await Object(n.a)(e, {
					...o,
					variables: {
						subredditId: t
					}
				});
				if (!r.ok || !r.body.data.enablePowerups.ok) {
					const {
						errors: e
					} = r.body, t = Object(m.a)(e);
					throw new Error(t || "Error enabling powerups for given subreddit")
				}
			}, O = e => Object(n.a)(e, f, {
				traceRequestName: "user_powerups"
			}), j = (e, t) => Object(n.a)(e, {
				variables: {
					id: t
				},
				...a
			}, {
				traceRequestName: "redditor_powerups"
			}), g = (e, t, r) => Object(n.a)(e, {
				...u,
				variables: {
					subredditId: t,
					includeIdentity: r
				}
			}, {
				traceRequestName: "subreddit_powerups"
			}), I = (e, t, r) => Object(n.a)(e, {
				...l,
				variables: {
					subredditId: t,
					includeIdentity: r
				}
			}, {
				traceRequestName: "subreddit_powerups_full"
			}), S = async (e, t) => {
				const r = await Object(n.a)(e, {
					...b,
					variables: {
						subredditsIds: t
					}
				});
				if (!r.ok) {
					const {
						errors: e
					} = r.body, t = Object(m.a)(e);
					throw new Error(t || "Unable to fetch subreddit powerups")
				}
				return r.body.data.subredditsInfoByIds
			}, E = (e, t) => Object(n.a)(e, {
				...c,
				variables: t
			}), y = (e, t) => Object(n.a)(e, {
				...d,
				variables: t
			}), h = (e, t) => Object(n.a)(e, {
				...s,
				variables: t
			}), T = (e, t) => Object(n.a)(e, {
				...i,
				variables: t
			}), v = async (e, t, r) => {
				const s = {
					input: {
						subredditId: t,
						powerupsSettings: {
							benefitSettings: r
						}
					}
				};
				return Object(n.a)(e, {
					...p,
					variables: s
				})
			}
		},
		"./src/reddit/endpoints/gold/topAwarded.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return o
			})), r.d(t, "b", (function() {
				return d
			}));
			var n = r("./src/lib/makeGqlRequest/index.ts"),
				s = r("./src/redditGQL/operations/TopAwardedPosts.json"),
				i = r("./src/redditGQL/operations/TopAwardersLeaderboard.json");
			const o = (e, t) => Object(n.a)(e, {
					...s,
					variables: {
						...t,
						includeListingMetadata: !!t.includeListingMetadata
					}
				}),
				d = (e, t) => Object(n.a)(e, {
					...i,
					variables: t
				})
		},
		"./src/reddit/endpoints/governance/posts.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return i
			}));
			var n = r("./src/config.ts"),
				s = (r("./src/reddit/models/Poll/index.ts"), r("./src/reddit/endpoints/governance/requester.ts"));

			function i(e, t, r) {
				return Object(s.a)(e, {
					method: "get",
					endpoint: `${n.a.metaUrl}/polls/${t}?postIds=${r.join(",")}`
				})
			}
		},
		"./src/reddit/endpoints/governance/requester.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return s
			}));
			var n = r("./src/lib/makeApiRequest/index.ts");

			function s(e, t) {
				return Object(n.a)(e, {
					type: "json",
					...t
				}).then(e => {
					if (e.ok) return {
						body: e.body,
						ok: !0,
						status: e.status
					};
					return {
						error: e.error && e.error.fields && e.error.fields[0] ? e.error.fields[0].msg : {
							...e.body,
							code: e.status
						},
						ok: !1,
						status: e.status
					}
				})
			}
		},
		"./src/reddit/endpoints/messages/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return u
			})), r.d(t, "a", (function() {
				return l
			}));
			var n = r("./src/redditGQL/operations/ReportMessage.json"),
				s = r("./src/lib/constants/index.ts"),
				i = r("./src/lib/makeApiRequest/index.ts"),
				o = r("./src/lib/makeGqlRequest/index.ts"),
				d = r("./src/lib/omitHeaders/index.ts"),
				c = r("./src/reddit/constants/headers.ts"),
				a = r("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const u = (e, t) => Object(i.a)(Object(d.a)(e, [c.a]), {
					endpoint: Object(a.a)(`${e.apiUrl}/api/compose`),
					method: s.jb.POST,
					data: t
				}),
				l = (e, t) => Object(o.a)(e, {
					...n,
					variables: t
				})
		},
		"./src/reddit/endpoints/modQueue/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return b
			})), r.d(t, "a", (function() {
				return p
			})), r.d(t, "b", (function() {
				return f
			}));
			var n = r("./src/config.ts"),
				s = r("./src/lib/constants/index.ts"),
				i = r("./src/lib/makeApiRequest/index.ts"),
				o = r("./src/lib/makeGqlRequest/index.ts"),
				d = r("./src/lib/omitHeaders/index.ts"),
				c = r("./src/reddit/constants/headers.ts"),
				a = r("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				u = r("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				l = r("./src/redditGQL/operations/ModQueueItems.json");
			const b = (e, t, r) => Object(i.a)(e, {
					endpoint: Object(u.a)(Object(a.a)(`${n.a.gatewayUrl}/desktopapi/v1/${t}`)),
					method: s.jb.GET,
					data: {
						moderated_limit: 25,
						...r
					}
				}),
				p = (e, t, r) => Object(i.a)(Object(d.a)(e, [c.a]), {
					endpoint: `${e.apiUrl}/api/v1/modactions/${t}`,
					method: s.jb.POST,
					type: "json",
					data: r
				}),
				f = (e, t) => Object(o.a)(e, {
					...l,
					variables: t
				})
		},
		"./src/reddit/endpoints/page/subredditPage.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return S
			})), r.d(t, "b", (function() {
				return E
			}));
			var n = r("./src/config.ts"),
				s = r("./src/lib/constants/index.ts"),
				i = r("./src/lib/isAdHocMultireddit/index.ts"),
				o = r("./src/lib/isFakeSubreddit/index.ts"),
				d = r("./src/lib/makeApiRequest/index.ts"),
				c = r("./src/lib/makeGqlRequest/index.ts"),
				a = r("./src/lib/performanceTimings/index.tsx"),
				u = r("./src/reddit/constants/graphql.ts"),
				l = r("./src/reddit/constants/page.ts"),
				b = r("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				p = r("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				f = r("./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts"),
				m = r("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				_ = r("./src/reddit/models/Subreddit/index.ts"),
				O = r("./src/reddit/selectors/platform.ts"),
				j = r("./src/reddit/selectors/subreddit.ts"),
				g = r("./src/reddit/selectors/user.ts"),
				I = r("./src/redditGQL/operations/SubredditPage.json");
			const S = (e, t, r, n) => {
					var s, d, c, a;
					const {
						after: b,
						geo_filter: f,
						isMobile: m,
						layout: _,
						limit: I,
						recentPostIds: S,
						sort: E,
						t: y
					} = r, h = Object(g.T)(e), T = Object(O.q)(e), v = Object(i.a)(t), w = Object(o.a)(t), x = Object(j.Q)(e, {
						subredditId: Object(j.C)(e, t)
					}).length > 0, C = (null === (s = e.user.account) || void 0 === s ? void 0 : s.username) || (null === (d = e.user.account) || void 0 === d ? void 0 : d.displayText), k = {
						name: t,
						includeIdentity: h && !e.user.account,
						adContext: {
							layout: _ ? _.toUpperCase() : u.a.Card,
							reddaid: e.user.reddaid
						},
						isFake: w,
						includeAppliedFlair: !w && h && !!C && n,
						includePowerups: n && !w,
						includeQuestions: n && h && !w,
						includeRecents: w && S && S.length > 0 || !1,
						includeRedditorKarma: n && h && !(null === (a = null === (c = e.user.account) || void 0 === c ? void 0 : c.karma) || void 0 === a ? void 0 : a.total),
						includeRules: n && !w && !x,
						includeSubredditLinks: n && !w && !h,
						includeTopicLinks: n && !w && !h,
						includeTrending: w,
						isAdHocMulti: v,
						isAll: t === l.d.All,
						isPopular: t === l.d.Popular,
						recentPostIds: S || [],
						subredditNames: v ? t.split("+") : [],
						username: h && C && n ? C : ""
					};
					return E && (k.sort = E.toUpperCase()), y && (k.range = y.toUpperCase()), m ? k.pageSize = Object(p.a)(_) : I && (k.pageSize = I), T && T.ad && (k.forceAds = {
						ad: T.ad
					}), (T && T.geo_filter || f) && (k.region = T && T.geo_filter || f), b && (k.after = btoa(b)), k
				},
				E = async (e, t, r) => {
					const n = Date.now(),
						i = await ((e, t) => Object(c.a)(e, {
							...I,
							variables: t
						}))(e, t),
						o = Date.now();
					if (!i.ok || !i.body) return i;
					const d = i.body,
						u = Date.now(),
						l = Object(f.a)(d.data),
						b = Date.now(),
						p = [{
							duration: o - n,
							logKeyType: a.a.gqlFetchTiming
						}, {
							duration: b - u,
							logKeyType: a.a.gqlNormalizationTiming
						}];
					return Object(a.h)({
						name: s.s.SUBREDDIT,
						isLoggedIn: r,
						metrics: p
					}), {
						...i,
						ok: !!d.data.subredditInfoByName && !Object(_.j)(d.data.subredditInfoByName),
						status: y(d.data),
						body: l
					}
				}, y = e => {
					if (!e.subredditInfoByName) return 404;
					if (Object(_.j)(e.subredditInfoByName)) {
						if (e.subredditInfoByName.forbiddenReason === _.c.Banned) return 404;
						if (e.subredditInfoByName.forbiddenReason === _.c.GoldOnly || e.subredditInfoByName.forbiddenReason === _.c.Private || e.subredditInfoByName.forbiddenReason === _.c.Quarantined || e.subredditInfoByName.forbiddenReason === _.c.Gated) return 403
					}
					return 200
				}, h = ({
					recentPostIds: e,
					...t
				}) => e && e.length ? {
					...t,
					recentPostIds: e.join(",")
				} : t;
			t.a = (e, t, r) => Object(d.a)(e, {
				endpoint: Object(b.a)(Object(m.a)(`${n.a.gatewayUrl}/desktopapi/v1/subreddits/${t}`)),
				method: s.jb.GET,
				data: r && h(r) || {},
				traceRequestName: "get_subreddit_page"
			})
		},
		"./src/reddit/endpoints/post/draft/helpers.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return i
			})), r.d(t, "b", (function() {
				return c
			})), r.d(t, "a", (function() {
				return b
			}));
			var n = r("./src/reddit/helpers/flair.ts"),
				s = r("./src/reddit/models/PostDraft/index.ts");
			const i = e => ({
					id: e.json.data.id,
					draftsCount: e.json.data.drafts_count
				}),
				o = e => e.destSubreddit.id ? {
					subreddit: e.destSubreddit.id,
					target: e.destSubreddit.isProfile ? "profile" : "subreddit"
				} : {},
				d = e => {
					switch (e.kind) {
						case s.b.Link:
							return "link";
						case s.b.Markdown:
							return "markdown";
						case s.b.RichText:
							return "richtext";
						default:
							return "self"
					}
				},
				c = e => {
					switch (e) {
						case "link":
							return s.b.Link;
						case "markdown":
							return s.b.Markdown;
						case "richtext":
							return s.b.RichText;
						default:
							return "self"
					}
				},
				a = e => e.title.substring(0, 300),
				u = e => {
					switch (e.kind) {
						case s.b.Link:
						case s.b.Markdown:
							return e.body;
						case s.b.RichText:
							return JSON.stringify({
								document: e.body
							})
					}
				},
				l = e => e ? {
					flair_id: e.templateId || null,
					flair_text: Object(n.g)(e) || null,
					flair_text_color: e.textColor || null,
					flair_background_color: e.backgroundColor || null
				} : {
					flair_id: null,
					flair_text: null,
					flair_text_color: null,
					flair_background_color: null
				},
				b = e => ({
					id: e.draftId || void 0,
					...o(e),
					kind: d(e),
					title: a(e),
					body: u(e),
					spoiler: e.isSpoiler,
					nsfw: e.isNSFW,
					original_content: e.isOC,
					...l(e.flair),
					send_replies: e.sendReplies,
					is_public_link: e.isPublicLink
				})
		},
		"./src/reddit/endpoints/publicAccessNetwork/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return I
			})), r.d(t, "b", (function() {
				return S
			})), r.d(t, "e", (function() {
				return E
			})), r.d(t, "f", (function() {
				return y
			})), r.d(t, "d", (function() {
				return h
			})), r.d(t, "g", (function() {
				return T
			})), r.d(t, "h", (function() {
				return v
			})), r.d(t, "i", (function() {
				return w
			})), r.d(t, "j", (function() {
				return R
			})), r.d(t, "a", (function() {
				return A
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./node_modules/lodash/omit.js"),
				i = r.n(s),
				o = r("./src/config.ts"),
				d = r("./src/lib/addQueryParams/index.ts"),
				c = r("./src/lib/constants/index.ts"),
				a = r("./src/lib/constants/headers.ts"),
				u = r("./src/lib/makeGqlRequest/index.ts"),
				l = r("./src/lib/makeRequest/index.ts"),
				b = r("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				p = r("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				f = r("./src/reddit/featureFlags/useProductionStreamingApi.ts"),
				m = r("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				_ = r("./src/reddit/models/PostCreationForm/index.ts"),
				O = r("./src/reddit/models/Vote/index.ts"),
				j = r("./src/redditGQL/operations/LiveVideoPosts.json");

			function g() {
				return Object(f.b)() ? "https://strapi.reddit.com" : o.a.streamingApiUrl
			}
			const I = async (e, t) => {
				let r;
				return r = t === b.R ? "/config" : `/${t}/config`, Object(l.b)({
					endpoint: `${g()}${r}`,
					method: c.jb.GET,
					headers: i()(e.headers(), [a.c, a.b]),
					timeoutMs: void 0
				}).then(k)
			}, S = (e, {
				subredditId: t,
				options: r
			}) => Object(u.a)(e, {
				...j,
				variables: {
					feedContext: {
						subredditId: t
					},
					first: null == r ? void 0 : r.pageSize,
					after: null == r ? void 0 : r.cursor
				}
			}), E = async (e, t) => Object(l.b)({
				endpoint: `${g()}/videos/${t}`,
				method: c.jb.GET,
				headers: i()(e.headers(), [a.c, a.b])
			}).then(k), y = async (e, t, r) => {
				let n;
				n = t === b.R ? "/broadcasts" : `/${t}/broadcasts`;
				const s = Object(d.a)(n, {
					cursor: null == r ? void 0 : r.cursor,
					page_size: null == r ? void 0 : r.pageSize
				});
				return Object(l.b)({
					endpoint: `${g()}${s}`,
					method: c.jb.GET,
					headers: i()(e.headers(), [a.c, a.b])
				}).then(k)
			}, h = async e => Object(l.b)({
				endpoint: `${g()}/recommended_viewer_subreddits`,
				method: c.jb.GET,
				headers: i()(e.headers(), [a.c, a.b])
			}).then(k), T = async (e, t, r) => Object(l.b)({
				endpoint: `${g()}/videos/${t}/vote/${D(r)}`,
				method: c.jb.POST,
				headers: i()(e.headers, [a.c, a.b])
			}).then(k), v = async (e, t) => Object(l.b)({
				endpoint: `${g()}/videos/${t}/heartbeat`,
				method: c.jb.POST,
				headers: i()(e.headers(), [a.c, a.b])
			}).then(k), w = async (e, t, r, n) => {
				const s = r.rteState;
				if (!s) return Promise.reject(new Error("Editor state is undefined"));
				const i = p.a.getRawText(s);
				return i ? x(e, t, i).then(e => e.ok && e.body && e.body.data ? {
					...e,
					body: {
						parentId: t,
						comment: {
							...Object(m.a)(e.body.data.r2_comment, n),
							media: C(s)
						},
						automuteLevel: e.body.data.auto_mute_status.level
					},
					error: void 0
				} : e) : Promise.reject(new Error("Cannot send empty message"))
			}, x = async (e, t, r) => Object(l.b)({
				endpoint: `${g()}/broadcasts/${t}/comment_v2`,
				method: c.jb.POST,
				headers: i()(e.headers, [a.c, a.b]),
				data: {
					text: r
				},
				type: "json"
			}).then(k), C = e => ({
				type: "rtjson",
				richtextContent: {
					document: p.a.toRichTextJSON(e).document
				},
				rteMode: _.i.RICH_TEXT
			}), k = e => {
				if (e.ok) return {
					...e,
					error: void 0
				}; {
					const t = {
						type: 404 === e.status ? c.I.NOT_FOUND_ERROR : c.I.SERVER_ERROR
					};
					return 429 === e.status && (t.fields = [{
						field: "",
						msg: n.fbt._("Try again later", null, {
							hk: "3BBLIU"
						})
					}]), {
						...e,
						error: t
					}
				}
			}, D = e => e === O.a.upvoted ? "up" : e === O.a.downvoted ? "down" : "unset", R = async (e, t, r) => Object(l.b)({
				endpoint: `${g()}/broadcasts/${t}`,
				method: c.jb.PUT,
				headers: i()(e.headers, [a.c, a.b]),
				data: {
					data: {
						chat_disabled: r
					}
				},
				type: "json"
			}).then(k), A = async (e, t) => Object(l.b)({
				endpoint: `${g()}/broadcasts/${t}/auto_mute_status`,
				method: c.jb.GET,
				headers: i()(e.headers, [a.c, a.b])
			}).then(k)
		},
		"./src/reddit/endpoints/subreddit/about.ts": function(e, t, r) {
			"use strict";
			var n = r("./src/lib/makeGqlRequest/index.ts"),
				s = r("./src/redditGQL/operations/SubredditAbout.json");
			t.a = (e, t, r) => Object(n.a)(e, {
				...s,
				variables: {
					subredditName: t,
					includeSubreddit: r
				}
			})
		},
		"./src/reddit/endpoints/subreddit/notificationSettings.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return o
			})), r.d(t, "b", (function() {
				return d
			}));
			var n = r("./src/redditGQL/operations/FetchSubredditsNotificationSettings.json"),
				s = r("./src/redditGQL/operations/UpdateSubredditNotificationSettings.json"),
				i = r("./src/lib/makeGqlRequest/index.ts");
			const o = (e, t) => Object(i.a)(e, {
					...n,
					variables: {
						subredditIds: [t]
					}
				}),
				d = (e, t, r) => Object(i.a)(e, {
					...s,
					variables: {
						input: {
							...r,
							subredditId: t
						}
					}
				})
		},
		"./src/reddit/endpoints/subreddit/rules.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return _
			})), r.d(t, "c", (function() {
				return O
			})), r.d(t, "a", (function() {
				return g
			})), r.d(t, "f", (function() {
				return I
			})), r.d(t, "d", (function() {
				return S
			})), r.d(t, "e", (function() {
				return y
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/lodash/camelCase.js"),
				s = r.n(n),
				i = r("./node_modules/lodash/mapKeys.js"),
				o = r.n(i),
				d = r("./src/lib/constants/index.ts"),
				c = r("./src/lib/makeApiRequest/index.ts"),
				a = r("./src/lib/makeGqlRequest/index.ts"),
				u = r("./src/lib/omitHeaders/index.ts"),
				l = r("./src/redditGQL/operations/SubredditRules.json"),
				b = r("./src/reddit/constants/headers.ts"),
				p = r("./src/reddit/helpers/graphql/normalizeSubredditRulesFromGql/index.ts"),
				f = r("./src/reddit/models/Rule/index.ts");
			const m = ({
					rules: e
				}) => ({
					rules: e.map(e => ({
						...o()(e, (e, t) => s()(t)),
						kind: "link" === e.kind ? "post" : e.kind
					}))
				}),
				_ = (e, t) => Object(a.a)(e, {
					...l,
					variables: {
						subredditName: t
					}
				}).then(e => {
					var t, r, n;
					return e.ok && e.body && (e => Object.keys(e).length > 0)(e.body) && (null === (n = null === (r = null === (t = e.body) || void 0 === t ? void 0 : t.data) || void 0 === r ? void 0 : r.subreddit) || void 0 === n ? void 0 : n.rules) ? e.body = Object(p.a)(e.body.data.subreddit.rules) : e.body = {
						rules: []
					}, e
				}),
				O = (e, t) => Object(c.a)(Object(u.a)(e, [b.a]), {
					endpoint: `${e.apiUrl}/user/${t}/about/rules.json`,
					method: d.jb.GET
				}).then(e => (e.ok && e.body.rules && (e.body = m(e.body)), e)),
				j = e => e.ok ? (e.body = Object(f.h)(JSON.parse(e.body.json.data.rules)), e) : e.body,
				g = async (e, t, r) => Object(c.a)(Object(u.a)(e, [b.a]), {
					endpoint: `${e.apiUrl}/api/add_subreddit_rule`,
					method: d.jb.POST,
					data: {
						r: t,
						short_name: r.rule,
						kind: r.kind === f.b.post ? "link" : r.kind,
						violation_reason: r.reason,
						description: r.description,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => j(e)), I = async (e, t, r, n) => Object(c.a)(Object(u.a)(e, [b.a]), {
					endpoint: `${e.apiUrl}/api/update_subreddit_rule`,
					method: d.jb.POST,
					data: {
						r: t,
						short_name: r.rule,
						kind: r.kind === f.b.post ? "link" : r.kind,
						violation_reason: r.reason,
						description: r.description,
						old_short_name: n,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => j(e)), S = async (e, t, r) => Object(c.a)(Object(u.a)(e, [b.a]), {
					endpoint: `${e.apiUrl}/api/remove_subreddit_rule`,
					method: d.jb.POST,
					data: {
						r: t,
						short_name: r,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => j(e)), E = e => e.map(e => encodeURIComponent(e)).join(), y = async (e, t, r) => Object(c.a)(Object(u.a)(e, [b.a]), {
					endpoint: `${e.apiUrl}/api/reorder_subreddit_rules`,
					method: d.jb.POST,
					data: {
						r: t,
						new_rule_order: E(r),
						api_type: "json",
						raw_json: 1
					}
				}).then(e => j(e))
		},
		"./src/reddit/helpers/commentList/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return d
			})), r.d(t, "c", (function() {
				return c
			})), r.d(t, "d", (function() {
				return a
			})), r.d(t, "e", (function() {
				return u
			})), r.d(t, "a", (function() {
				return l
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./src/reddit/constants/comments.ts"),
				s = r("./src/reddit/selectors/comments.ts"),
				i = r("./src/reddit/constants/experiments.ts"),
				o = r("./src/reddit/helpers/chooseVariant/index.ts");
			const d = (e, t) => t().features.comments.models[e],
				c = e => {
					switch (e.commentLink.type) {
						case n.a.Comment:
							return e.commentsDict[e.commentLink.id];
						case n.a.MoreComments:
							return e.moreCommentsDict[e.commentLink.id];
						case n.a.ContinueThread:
							return e.continueThreadDict[e.commentLink.id]
					}
				},
				a = (e, t) => e.type === n.a.MoreComments ? t[e.id].numComments : 1,
				u = (e, t, r, n) => {
					let i = Object(s.n)(n, {
							commentLink: t,
							commentsPageKey: e
						}),
						o = t;
					for (; i && i.depth > r && i.prev && (o = i.prev, (i = Object(s.n)(n, {
							commentLink: o,
							commentsPageKey: e
						})) && !(i.depth <= r)););
					return o.id
				},
				l = (e, t, r) => {
					const {
						commentLists: n,
						comments: s
					} = e, {
						head: d
					} = n[t];
					if (d) return Object.keys(s).filter(e => {
						const t = s[e];
						return !(!t.isStickied || !((e, t) => {
							const r = Object(o.c)(e, {
								experimentEligibilitySelector: o.a,
								experimentName: i.G,
								expEventOverride: t
							});
							return !!(Object(i.tf)(r) ? void 0 : r)
						})(r)) || (e => !1 !== e.collapsed)(t)
					})
				}
		},
		"./src/reddit/helpers/filterListingResponse/index.ts": function(e, t, r) {
			"use strict";
			var n = r("./node_modules/lodash/findLastIndex.js"),
				s = r.n(n),
				i = r("./src/reddit/models/WhitelistStatus/index.ts"),
				o = r("./src/reddit/selectors/telemetry.ts"),
				d = r("./src/telemetry/index.ts");
			const c = (e, {
				subreddits: t,
				profiles: r
			}) => {
				const n = t[e.belongsTo.id] || r[e.belongsTo.id];
				return !e.isNSFW && n && i.a.has(n.wls || i.b.NO_ADS)
			};
			t.a = (e, t, {
				postIds: r,
				posts: n,
				subreddits: i,
				profiles: a,
				...u
			}) => {
				const l = e.listings.postOrder.ids[t],
					b = (r || []).filter(e => !l || !l.includes(e)),
					p = l.map(t => e.posts.models[t]),
					f = p.length - (s()(p, e => e.isSponsored) + 1),
					m = b.map(e => n[e]);
				let _;
				const O = [],
					j = {
						subreddits: i,
						profiles: a
					};
				for (let s = 0; s < m.length; s++) {
					const r = m[s];
					let n = !1;
					if (r.isSponsored) {
						const e = s > 0 && m[s - 1],
							t = s < m.length - 1 && m[s + 1];
						e && c(e, j) && t && c(t, j) && (n = !0)
					}
					r.isSponsored && n && (null == _ && f + s >= 3 || s - _ >= 3) ? (_ = s, O.push(r.id)) : r.isSponsored ? r.isSponsored && Object(d.a)({
						source: "feed",
						action: "remove",
						noun: "ad",
						...o.o(e),
						listing: o.A(e, t)
					}) : O.push(r.id)
				}
				return {
					...u,
					subreddits: i,
					profiles: a,
					posts: n,
					postIds: O
				}
			}
		},
		"./src/reddit/helpers/getPostLimitForMobile/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return s
			}));
			var n = r("./src/reddit/constants/postLayout.ts");

			function s(e) {
				return e ? n.c[e] : n.f
			}
		},
		"./src/reddit/helpers/getTimeSortForListing/index.ts": function(e, t, r) {
			"use strict";
			var n = r("./src/lib/constants/index.ts"),
				s = r("./src/lib/listingSort/index.ts");
			t.a = (e, t) => {
				if (e) return Object(s.a)(e) ? t || n.ic : void 0
			}
		},
		"./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts": function(e, t, r) {
			"use strict";
			t.a = e => ({
				...e.id && {
					id: e.id
				},
				...e.postBackgroundColor && {
					postBackgroundColor: e.postBackgroundColor
				},
				...e.postBackgroundImage && {
					postBackgroundImage: e.postBackgroundImage
				},
				...e.postPlaceholderImage && {
					postPlaceholderImage: e.postPlaceholderImage
				},
				...e.postTitleColor && {
					postTitleColor: e.postTitleColor
				}
			})
		},
		"./src/reddit/helpers/graphql/normalizeSubredditLinksFromGql/index.ts": function(e, t, r) {
			"use strict";
			const n = e => ({
				communityIcon: e.styles && e.styles.icon || void 0,
				iconUrl: e.styles && e.styles.legacyIcon && e.styles.legacyIcon.url || void 0,
				id: e.id,
				isNSFW: e.isNSFW || !1,
				isSubscribed: e.isSubscribed,
				name: e.name,
				primaryColor: e.styles && e.styles.primaryColor || void 0,
				subscribers: e.subscribers,
				type: "subreddit"
			});
			t.a = e => {
				var t;
				return {
					subreddits: (null === (t = e.data.subredditInfoById) || void 0 === t ? void 0 : t.linkedSubreddits) ? e.data.subredditInfoById.linkedSubreddits.map(n) : []
				}
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return v
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./src/lib/assertNever.ts"),
				s = r("./src/lib/env/index.ts"),
				i = r("./src/lib/sentry/index.ts"),
				o = r("./src/reddit/actions/gold/powerups.ts"),
				d = r("./src/reddit/models/Post/index.ts"),
				c = r("./src/reddit/models/RichTextJson/index.ts"),
				a = r("./src/reddit/models/Subreddit/index.ts"),
				u = r("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				l = r("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				b = r("./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts"),
				p = r("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				f = r("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				m = r("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				_ = r("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				O = r("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				j = r("./src/reddit/helpers/graphql/normalizeSubredditLinksFromGql/index.ts"),
				g = r("./src/reddit/helpers/graphql/normalizeSubredditModPermissions/index.ts"),
				I = r("./src/reddit/helpers/graphql/normalizeSubredditRulesFromGql/index.ts"),
				S = r("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				E = r("./src/reddit/helpers/graphql/normalizeSubredditTopicLinksFromGql/index.ts"),
				y = r("./src/reddit/helpers/graphql/normalizeSubredditWidgetsFromGql/index.ts"),
				h = r("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				T = r("./src/reddit/helpers/graphql/helpers.ts");
			const v = (e, t, r) => {
				const o = {
						account: null,
						appliedFlair: {},
						authorFlair: {},
						postIds: [],
						postInstances: {},
						posts: {},
						postFlair: {},
						powerups: {},
						preferences: null,
						profiles: {},
						questions: {},
						recentPostIds: [],
						structuredStyles: {},
						subredditAboutInfo: {},
						subredditLinks: {},
						subredditPermissions: void 0,
						subredditRules: [],
						subreddits: {},
						subredditTopicLinks: void 0,
						token: "",
						trendingSubredditIds: []
					},
					c = e => {
						if (Object(d.j)(e) || Object(d.i)(e)) return null;
						if (o.posts[e.id]) return e.id;
						const t = Object(p.f)(e);
						o.posts[t.id] = t;
						const {
							crosspostRoot: r
						} = e;
						r && r.type === d.a.Post && r.postInfo && c(r.postInfo);
						let a = t.id;
						if (e.authorFlair && (o.authorFlair[t.belongsTo.id] || (o.authorFlair[t.belongsTo.id] = {}), o.authorFlair[t.belongsTo.id][t.author] = Object(u.a)(e.authorFlair)[0]), Object(d.l)(e)) o.profiles[e.profile.id] || (o.profiles[e.profile.id] = Object(m.a)(e.profile));
						else if (Object(d.n)(e)) o.subreddits[e.subreddit.id] || (o.subreddits[e.subreddit.id] = Object(O.a)(e.subreddit)), o.postFlair[e.subreddit.id] || (o.postFlair[e.subreddit.id] = Object(l.a)(e.subreddit));
						else if (Object(d.h)(e)) {
							const r = Object(p.b)(e);
							if (!r) return null;
							a = r, o.posts[r] = {
								...t,
								id: r,
								permalink: `${t.permalink}?instanceId=${encodeURIComponent(r)}`
							}, o.posts[t.id] || (o.posts[t.id] = {
								...t,
								events: []
							}), o.postInstances[e.id] || (o.postInstances[e.id] = []), o.postInstances[e.id].push(r)
						} else try {
							Object(n.a)(e)
						} catch (b) {
							const t = `Received unhandled element type when processing subreddit posts: "${e.__typename}"`;
							Object(s.b)() || console.warn(t), i.c.captureMessage(t)
						}
						return a && o.postIds.push(a), a
					};
				if (e.forEach(e => c(e)), t) {
					o.trendingSubredditIds = t.map(e => e.id);
					for (const e of t) o.subreddits[e.id] = Object(O.a)(e)
				}
				const a = o.postIds.length - 1;
				return o.token = a >= 0 ? o.postIds[a] : "", r && (o.account = Object(h.a)(r), o.preferences = r.preferences && Object(f.a)(r.preferences, r.interactions) || null), o
			};
			t.a = ({
				adhocMultiredditByNames: e,
				all: t,
				identity: r,
				popular: n,
				recentPosts: l,
				subredditInfoByName: p,
				trendingSubreddits: f
			}) => {
				var m, O;
				if (!p) return {
					reason: a.e.NotFoundSubreddit,
					data: {
						account: r && Object(h.a)(r) || null
					}
				};
				if (Object(a.j)(p)) {
					const {
						banMessage: e,
						publicDescriptionText: t,
						quarantineMessage: n,
						isEmailRequiredForQuarantineOptin: s,
						interstitialWarningMessage: i
					} = p;
					return {
						reason: w(p.forbiddenReason),
						data: {
							account: r && Object(h.a)(r) || null,
							banMessage: e || void 0,
							description: t,
							quarantineRequiresEmailOptin: s,
							...n ? {
								quarantineMessage: n.markdown,
								quarantineMessageRTJson: Object(T.f)(n.richtext, c.i)
							} : {},
							interstitialWarningMessage: null == i ? void 0 : i.markdown,
							interstitialWarningMessageRTJson: Object(T.f)(null == i ? void 0 : i.richtext, c.i)
						}
					}
				}
				const x = {},
					C = p || n || t || e,
					[k, D] = C.elements.edges.reduce((e, t) => {
						var r, n, s, i;
						const [o, c] = e, a = t.node;
						return Object(d.k)(a) ? (o.push(a), (null === (n = null === (r = a.flair) || void 0 === r ? void 0 : r.template) || void 0 === n ? void 0 : n.id) && (null === (i = null === (s = a.flair) || void 0 === s ? void 0 : s.template) || void 0 === i ? void 0 : i.postStyle) && (x[a.flair.template.id] = Object(b.a)(a.flair.template.postStyle))) : c.push(a), [o, c]
					}, [
						[],
						[]
					]);
				if (D.length) {
					const e = `Received unhandled ${D.length} elements when processing subreddit data: "${D[0].__typename}"`;
					Object(s.b)() || console.warn(e), i.c.captureMessage(e)
				}
				l && k.push(...l);
				const R = C.elements.dist,
					A = v(k, f, r);
				if (p.styles && (A.structuredStyles = {
						data: {
							style: Object(S.a)(p.styles)
						}
					}), A.structuredStyles = {
						data: {
							...p.styles ? {
								style: Object(S.a)(p.styles)
							} : {},
							content: {
								widgets: Object(y.a)(p)
							},
							flairTemplate: x
						}
					}, A.subredditAboutInfo = Object(_.a)(p), p.modPermissions && (A.subredditPermissions = Object.keys(p.modPermissions).length > 0 ? Object(g.a)(p.modPermissions) : void 0), p.rules && (A.subredditRules = Object(I.a)(p.rules).rules), ((null == p ? void 0 : p.answerableQuestions) || p.contentRatingSurvey || p.communityProgressModule) && (A.questions = {
						answerableQuestions: null == p ? void 0 : p.answerableQuestions,
						contentRatingSurvey: null == p ? void 0 : p.contentRatingSurvey,
						communityProgressModule: null == p ? void 0 : p.communityProgressModule
					}), !Object(a.j)(p)) {
					const e = {
						powerups: p.powerups,
						powerupsSettings: p.powerupsSettings,
						supporters: p.supporters,
						productOffers: p.productOffers,
						subredditAchievementFlairs: p.subredditAchievementFlairs
					};
					A.powerups = Object(o.e)(e, r)
				}
				return A.subredditLinks = Object(j.a)({
					data: {
						subredditInfoById: p
					}
				}), A.subredditTopicLinks = Object(E.a)({
					data: {
						subredditInfoById: p
					}
				}), A.appliedFlair = {
					flair: (null === (m = p.flairedRedditorByName) || void 0 === m ? void 0 : m.flair) ? Object(u.a)(null === (O = p.flairedRedditorByName) || void 0 === O ? void 0 : O.flair)[0] : void 0,
					displaySettings: p.authorFlairSettings
				}, {
					...A,
					...null !== R && {
						dist: R
					}
				}
			};
			const w = e => {
				switch (e) {
					case a.c.Banned:
						return a.e.BannedSubreddit;
					case a.c.GoldOnly:
						return a.e.GoldSubreddit;
					case a.c.Private:
						return a.e.PrivateSubreddit;
					case a.c.Quarantined:
						return a.e.QuarantinedSubreddit;
					case a.c.Gated:
						return a.e.GatedSubreddit;
					case a.c.Unknown:
						return a.e.ForbiddenSubreddit
				}
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditTopicLinksFromGql/index.ts": function(e, t, r) {
			"use strict";
			t.a = e => {
				var t, r;
				return (null === (r = null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.subredditInfoById) || void 0 === r ? void 0 : r.topicLinks) || void 0
			}
		},
		"./src/reddit/helpers/isCrosspost.ts": function(e, t, r) {
			"use strict";
			t.a = function(e) {
				return !!e && !!e.crosspostRootId
			}
		},
		"./src/reddit/helpers/locales.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return c
			})), r.d(t, "b", (function() {
				return b
			})), r.d(t, "a", (function() {
				return p
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				s = r("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/fbt.js"),
				i = r("./src/reddit/selectors/runTimeEnvVars.ts"),
				o = r("./src/reddit/selectors/user.ts"),
				d = r("./node_modules/reselect/es/index.js");
			const c = e => Object.entries(e).map(([e, t]) => ({
					value: e,
					displayName: t.displayName
				})),
				a = Object.freeze({
					[n.GERMAN_LOCALE]: Object.freeze({
						bcp47: n.GERMAN_LOCALE,
						displayName: "Deutsch",
						englishName: "German",
						fbtLocale: Object(s.isoLocaleToFbtLocale)(n.GERMAN_LOCALE),
						rtl: !1
					}),
					[n.DEFAULT_LOCALE]: Object.freeze({
						bcp47: n.DEFAULT_LOCALE,
						displayName: "English (US)",
						englishName: "English (US)",
						fbtLocale: Object(s.isoLocaleToFbtLocale)(n.DEFAULT_LOCALE),
						rtl: !1
					}),
					[n.SPANISH_LOCALE]: Object.freeze({
						bcp47: n.SPANISH_LOCALE,
						displayName: "Español (ES)",
						englishName: "Spanish (ES)",
						fbtLocale: Object(s.isoLocaleToFbtLocale)(n.SPANISH_LOCALE),
						rtl: !1
					}),
					[n.SPANISH_MEXICAN_LOCALE]: Object.freeze({
						bcp47: n.SPANISH_MEXICAN_LOCALE,
						displayName: "Español (MX)",
						englishName: "Spanish (MX)",
						fbtLocale: Object(s.isoLocaleToFbtLocale)(n.SPANISH_MEXICAN_LOCALE),
						rtl: !1
					}),
					"fr-FR": Object.freeze({
						bcp47: "fr-FR",
						displayName: "Français",
						englishName: "French",
						fbtLocale: Object(s.isoLocaleToFbtLocale)("fr-FR"),
						rtl: !1
					}),
					[n.ITALIAN_LOCALE]: Object.freeze({
						bcp47: n.ITALIAN_LOCALE,
						displayName: "Italiano",
						englishName: "Italian",
						fbtLocale: Object(s.isoLocaleToFbtLocale)(n.ITALIAN_LOCALE),
						rtl: !1
					}),
					[n.PORTUGUESE_BRAZILIAN_LOCALE]: Object.freeze({
						bcp47: n.PORTUGUESE_BRAZILIAN_LOCALE,
						displayName: "Português (BR)",
						englishName: "Portuguese (BR)",
						fbtLocale: Object(s.isoLocaleToFbtLocale)(n.PORTUGUESE_BRAZILIAN_LOCALE),
						rtl: !1
					}),
					[n.PORTUGUESE_LOCALE]: Object.freeze({
						bcp47: n.PORTUGUESE_LOCALE,
						displayName: "Português (PT)",
						englishName: "Portuguese (PT)",
						fbtLocale: Object(s.isoLocaleToFbtLocale)(n.PORTUGUESE_LOCALE),
						rtl: !1
					})
				}),
				u = {},
				l = Object.freeze({
					[n.PSEUDO_LOCALE]: Object.freeze({
						bcp47: n.PSEUDO_LOCALE,
						displayName: "Pseudo",
						englishName: "Pseudo",
						fbtLocale: Object(s.isoLocaleToFbtLocale)(n.PSEUDO_LOCALE),
						rtl: !1
					}),
					[n.PSEUDO_AUTO]: Object.freeze({
						bcp47: n.PSEUDO_AUTO,
						displayName: "Pseudo Auto",
						englishName: "Pseudo Auto",
						fbtLocale: Object(s.isoLocaleToFbtLocale)(n.PSEUDO_AUTO),
						rtl: !1
					})
				}),
				b = Object(d.a)(o.H, i.b, (e, t) => e || t ? {
					...a,
					...u,
					...l
				} : a);
			const p = async (e, t) => {
				0
			}
		},
		"./src/reddit/helpers/pageActionLoginRedirect.ts": function(e, t, r) {
			"use strict";
			r("./node_modules/history/esm/history.js"), r("./src/reddit/actions/platform.ts");
			var n = r("./src/config.ts");
			t.a = (e, t) => {
				const r = t.platform.currentPage && t.platform.currentPage.url;
				let s = `${n.a.accountManagerOrigin}/login/`;
				const i = window.location.origin;
				r && (s += `?dest=${encodeURIComponent(`${i}${r}`)}`), window.location.href = s
			}
		},
		"./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return a
			}));
			var n = r("./src/lib/constants/index.ts"),
				s = r("./src/reddit/helpers/isComment.ts"),
				i = r("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				o = r("./src/reddit/models/Vote/index.ts"),
				d = e => !0 === e ? o.a.upvoted : !1 === e ? o.a.downvoted : o.a.notVoted,
				c = r("./src/reddit/models/Comment/index.ts");
			t.a = (e, t) => {
				const r = {
					approvedAtUTC: e.approved_at_utc,
					approvedBy: e.approved_by,
					author: e.author,
					authorId: e.author_fullname,
					bannedAtUTC: e.banned_at_utc,
					bannedBy: e.banned_by,
					body: e.body_html,
					bodyMD: e.body,
					collapsed: e.collapsed,
					collapsedReason: e.collapsed_reason,
					collapsedReasonCode: e.collapsed_reason_code,
					collapsedBecauseCrowdControl: e.collapsed_because_crowd_control,
					commentType: e.comment_type,
					created: e.created_utc,
					deletedBy: u(e),
					distinguishType: e.distinguished || "",
					editedAt: null,
					id: e.name,
					ignoreReports: e.ignore_reports,
					isAdmin: "admin" === e.distinguished,
					isAuthorPremium: !!e.author_premium,
					isApproved: e.approved,
					isDeleted: e.author === n.E,
					isGildable: e.can_gild,
					isLocked: e.locked,
					isMod: "moderator" === e.distinguished,
					isOp: e.is_submitter,
					isRemoved: e.removed,
					isScoreHidden: e.score_hidden,
					isSpam: e.spam,
					isStickied: e.stickied,
					isSaved: e.isSaved,
					isSystem: !1,
					subredditId: e.subreddit_id,
					markdown: e.body,
					media: {
						mediaMetadata: e.media_metadata,
						type: "rtjson",
						richtextContent: a(e.rtjson),
						rteMode: e.rte_mode
					},
					modReports: e.mod_reports,
					modReportsDismissed: e.mod_reports_dismissed,
					numReports: e.num_reports,
					parentId: Object(s.a)(e.parent_id) ? e.parent_id : null,
					permalink: e.permalink,
					postAuthor: e.link_author || null,
					postId: e.link_id,
					postTitle: e.link_title || null,
					sendReplies: e.send_replies,
					score: e.score,
					treatmentTags: e.treatment_tags,
					userReports: e.user_reports,
					userReportsDismissed: e.user_reports_dismissed,
					voteState: d(e.likes)
				};
				return e.all_awardings && (r.allAwardings = Object(i.a)(e.all_awardings)), e.awarders && (r.awarders = e.awarders), e.associated_award && (r.associatedAwardId = e.associated_award.id, r.associatedAward = Object(i.b)(e.associated_award)), r
			};
			const a = e => "string" == typeof e ? JSON.parse(e) : e,
				u = e => e.author !== n.E ? null : e.body === n.F ? c.c.User : e.body === n.Lb ? c.c.Moderator : null
		},
		"./src/reddit/helpers/tags/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return i
			})), r.d(t, "b", (function() {
				return o
			}));
			var n = r("./node_modules/lodash/values.js"),
				s = r.n(n);
			const i = e => s()(e).sort((t, r) => {
					const n = e[t.tag.id].tag.text.toLowerCase(),
						s = e[r.tag.id].tag.text.toLowerCase();
					return n < s ? -1 : n > s ? 1 : 0
				}),
				o = e => !e.id && !!e.action
		},
		"./src/reddit/helpers/toggleBodyScroll/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return i
			})), r.d(t, "a", (function() {
				return o
			})), r.d(t, "d", (function() {
				return d
			})), r.d(t, "c", (function() {
				return c
			}));
			var n = r("./src/reddit/constants/elementIds.ts");
			let s;
			const i = () => {
					const e = document.body.dataset.previousOverflow;
					if (!e) return;
					document.body.removeAttribute("data-previous-overflow");
					const t = document.getElementById(n.c);
					document.body.style.overflow = e, document.body.style.marginRight = "", t && (t.style.marginRight = "")
				},
				o = () => {
					if (document.body.dataset.previousOverflow) return;
					const e = document.body.style.overflow || "auto";
					document.body.dataset.previousOverflow = e, s || (s = d(document.body)), document.body.style.overflow = "hidden", document.body.style.marginRight = `${s}px`;
					const t = document.getElementById(n.c);
					t && (t.style.marginRight = `${s}px`)
				},
				d = e => {
					const t = e.getBoundingClientRect();
					return window.innerWidth - (t.left + t.right)
				},
				c = e => {
					if (!e || !document.body) return 0;
					const t = d(document.body),
						r = e.offsetWidth - e.scrollWidth;
					return t || r
				}
		},
		"./src/reddit/helpers/trackers/blade.ts": function(e, t, r) {
			"use strict";
			r.d(t, "i", (function() {
				return o
			})), r.d(t, "h", (function() {
				return d
			})), r.d(t, "f", (function() {
				return c
			})), r.d(t, "g", (function() {
				return a
			})), r.d(t, "c", (function() {
				return u
			})), r.d(t, "d", (function() {
				return l
			})), r.d(t, "j", (function() {
				return p
			})), r.d(t, "b", (function() {
				return f
			})), r.d(t, "a", (function() {
				return m
			})), r.d(t, "e", (function() {
				return O
			})), r.d(t, "k", (function() {
				return j
			}));
			var n = r("./src/reddit/constants/blade.ts"),
				s = r("./src/reddit/selectors/telemetry.ts");
			const i = (e, t) => r => ({
					...s.o(r),
					source: n.c.Appearance,
					action: "click",
					noun: e,
					actionInfo: s.d(r, {
						paneName: t
					}),
					subreddit: s.jb(r)
				}),
				o = e => i("save_style", e),
				d = e => i("cancel_style", e),
				c = e => t => ({
					source: n.c.Structure,
					action: "click",
					noun: e,
					screen: s.bb(t),
					subreddit: s.jb(t)
				}),
				a = e => t => ({
					source: n.c.Appearance,
					action: "click",
					noun: e,
					screen: s.bb(t),
					subreddit: s.jb(t)
				}),
				u = (e, t) => r => ({
					source: "colorpicker",
					action: "click",
					noun: e,
					actionInfo: s.d(r, {
						paneName: n.f[t]
					}),
					screen: s.bb(r),
					subreddit: s.jb(r)
				}),
				l = e => t => ({
					source: n.g[e],
					action: "click",
					noun: "colorpicker",
					actionInfo: s.d(t, {
						paneName: n.f[e]
					}),
					screen: s.bb(t),
					subreddit: s.jb(t)
				}),
				b = e => ({
					screen: s.bb(e),
					subreddit: s.jb(e)
				}),
				p = () => e => ({
					source: n.c.Appearance,
					action: "view",
					noun: "blade",
					...b(e)
				}),
				f = e => t => ({
					source: n.a[e],
					action: "click",
					noun: n.b[e],
					...b(t)
				}),
				m = () => e => ({
					source: n.c.Appearance,
					action: "click",
					noun: "back",
					...b(e)
				}),
				_ = e => t => ({
					source: n.c.PostFlairManagement,
					action: "click",
					noun: e,
					...b(t)
				}),
				O = (e, t) => ({
					...s.o(e),
					..._(t)(e)
				}),
				j = e => t => ({
					source: n.c.MenuLinks,
					action: "click",
					noun: e ? "wiki_link_on" : "wiki_link_off",
					screen: s.bb(t),
					subreddit: s.jb(t),
					userSubreddit: s.tb(t)
				})
		},
		"./src/reddit/helpers/trackers/comment.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return i
			})), r.d(t, "a", (function() {
				return o
			})), r.d(t, "b", (function() {
				return d
			}));
			var n = r("./src/telemetry/index.ts"),
				s = r("./src/reddit/selectors/telemetry.ts");
			const i = ({
					state: e,
					commentId: t
				}) => Object(n.a)({
					source: "comment",
					action: "view",
					noun: "comment",
					...s.o(e),
					profile: s.S(e),
					post: s.J(e, t),
					media: s.C(e, t),
					subreddit: s.jb(e),
					comment: s.i(e, t)
				}),
				o = ({
					state: e,
					commentId: t
				}) => Object(n.a)({
					source: "comment",
					action: "consume",
					noun: "comment",
					...s.o(e),
					profile: s.S(e),
					post: s.J(e, t),
					media: s.C(e, t),
					subreddit: s.jb(e),
					comment: s.i(e, t)
				}),
				d = e => t => ({
					source: "online_presence",
					action: "view",
					noun: "user",
					user: s.rb(t),
					subreddit: s.jb(t),
					post: s.J(t, e),
					actionInfo: s.d(t),
					app: s.g(t),
					referrer: s.Y(t),
					session: s.fb(t)
				})
		},
		"./src/reddit/helpers/trackers/communityTopics.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return n
			})), r.d(t, "f", (function() {
				return b
			})), r.d(t, "c", (function() {
				return p
			})), r.d(t, "e", (function() {
				return f
			})), r.d(t, "d", (function() {
				return m
			})), r.d(t, "b", (function() {
				return _
			})), r.d(t, "h", (function() {
				return O
			})), r.d(t, "g", (function() {
				return j
			}));
			var n, s = r("./src/reddit/selectors/tags.ts"),
				i = r("./src/reddit/selectors/telemetry.ts"),
				o = r("./src/telemetry/index.ts");
			! function(e) {
				e.communitySettings = "community_settings", e.idCard = "id_card"
			}(n || (n = {}));
			const d = (e, t, r) => {
					const n = Object(s.x)(e, {
						subredditId: t
					});
					return !!n && n.id === r
				},
				c = (e, t) => Object(s.u)(e, {
					itemId: t
				}).reduce(({
					topicTagIds: e,
					topicTagContents: t,
					topicTagTypes: r
				}, n) => (e.push(n.tag.id), t.push(n.tag.text), r.push(n.tag.type), {
					topicTagIds: e,
					topicTagContents: t,
					topicTagTypes: r
				}), {
					topicTagIds: [],
					topicTagContents: [],
					topicTagTypes: []
				}),
				a = (e, t, r) => {
					if (!r.id) return {
						content: r.displayText
					};
					const n = Object(s.b)(e)[r.id] || Object(s.d)(e, {
						subredditId: t
					})[r.id];
					return n ? {
						id: n.id,
						content: n.text,
						type: n.type,
						isPrimary: d(e, t, n.id)
					} : null
				},
				u = (e, t, r) => {
					if (!r) return null;
					const n = Object(s.b)(e)[r] || Object(s.d)(e, {
						subredditId: t
					})[r];
					return n ? {
						id: n.id,
						content: n.text,
						type: n.type,
						isPrimary: d(e, t, n.id)
					} : null
				},
				l = (e, t, r) => ({
					...i.o(e),
					subreddit: {
						...i.jb(e) || {},
						id: t,
						...c(e, t)
					},
					source: r.context,
					action: "click"
				}),
				b = (e, t, r) => {
					Object(o.a)(((e, t, r) => ({
						...l(e, t.subredditId, r),
						noun: t.isRelevant ? "restore_related_topic" : "remove_related_topic",
						topicTag: u(e, t.subredditId, t.tagId)
					}))(e, t, r))
				},
				p = (e, t, r, n) => {
					Object(o.a)({
						...l(e, t, n),
						topicTag: a(e, t, r),
						noun: "add_related_topic"
					})
				},
				f = (e, t, r, n) => {
					return !Object(s.i)(e, {
						subredditId: t
					}) && r.id ? Object(o.a)(((e, t, r, n) => ({
						...l(e, t, n),
						topicTag: a(e, t, r),
						noun: "topic_auto_suggest"
					}))(e, t, r, n)) : r.id ? Object(o.a)(((e, t, r, n) => ({
						...l(e, t, n),
						topicTag: a(e, t, r),
						noun: "topic_auto_complete"
					}))(e, t, r, n)) : Object(o.a)(((e, t, r, n) => ({
						...l(e, t, n),
						topicTag: a(e, t, r),
						noun: "topic_add_new"
					}))(e, t, r, n))
				},
				m = (e, t, r, n) => Object(o.a)({
					...l(e, t, n),
					topicTag: a(e, t, r),
					noun: "topic_remove"
				}),
				_ = (e, t, r) => Object(o.a)({
					...l(e, t, r),
					noun: "topic_tag_field"
				}),
				O = (e, t, r) => Object(o.a)({
					...l(e, t, r),
					noun: r.context === n.communitySettings ? "save" : "save_community_topics"
				}),
				j = (e, t, r, n) => {
					const s = l(e, t, n);
					Object(o.a)({
						...s,
						action: "view",
						noun: "error",
						actionInfo: {
							...s.actionInfo,
							reason: r
						}
					})
				}
		},
		"./src/reddit/helpers/trackers/feed.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return i
			})), r.d(t, "a", (function() {
				return o
			}));
			var n = r("./src/reddit/selectors/telemetry.ts"),
				s = r("./src/telemetry/index.ts");
			const i = e => t => Object(s.a)({
					...n.o(t),
					actionInfo: n.d(t, {
						reason: e
					}),
					source: "feed",
					action: "load",
					noun: "serving",
					feed: n.r(t)
				}),
				o = e => t => Object(s.a)({
					...n.o(t),
					actionInfo: n.d(t, {
						reason: e
					}),
					source: "feed",
					action: "fail",
					noun: "serving",
					feed: n.r(t)
				})
		},
		"./src/reddit/helpers/trackers/inlineSubredditEditing.ts": function(e, t, r) {
			"use strict";
			r.d(t, "e", (function() {
				return d
			})), r.d(t, "b", (function() {
				return c
			})), r.d(t, "a", (function() {
				return a
			})), r.d(t, "d", (function() {
				return u
			})), r.d(t, "c", (function() {
				return l
			}));
			var n, s = r("./src/reddit/constants/tracking.ts"),
				i = r("./src/reddit/selectors/telemetry.ts");
			! function(e) {
				e.SubredditInlineTooltip = "subreddit_inline_tooltip", e.EditSubredditIcon = "edit_subreddit_icon", e.EditSubredditDescription = "edit_subreddit_description", e.SaveDescription = "save_description", e.Error = "error"
			}(n || (n = {}));
			const o = e => ({
					subreddit: i.jb(e),
					userSubreddit: i.tb(e)
				}),
				d = e => ({
					source: "subreddit_tooltip",
					noun: n.SubredditInlineTooltip,
					action: s.c.VIEW,
					...o(e)
				}),
				c = e => ({
					source: "id_card",
					noun: n.EditSubredditIcon,
					action: s.c.CLICK,
					...o(e)
				}),
				a = e => ({
					source: "id_card",
					noun: n.EditSubredditDescription,
					action: s.c.CLICK,
					...o(e)
				}),
				u = (e, t) => r => ({
					source: "id_card",
					noun: n.SaveDescription,
					action: s.c.CLICK,
					setting: {
						value: String(e),
						oldValue: String(t)
					},
					...o(r)
				}),
				l = (e, t) => ({
					source: "id_card",
					noun: n.Error,
					action: s.c.VIEW,
					...o(e),
					...i.o(e),
					actionInfo: i.d(e, {
						reason: t
					})
				})
		},
		"./src/reddit/helpers/trackers/postComposer.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return g
			})), r.d(t, "e", (function() {
				return I
			})), r.d(t, "K", (function() {
				return S
			})), r.d(t, "I", (function() {
				return E
			})), r.d(t, "C", (function() {
				return y
			})), r.d(t, "z", (function() {
				return h
			})), r.d(t, "A", (function() {
				return T
			})), r.d(t, "M", (function() {
				return v
			})), r.d(t, "B", (function() {
				return w
			})), r.d(t, "m", (function() {
				return x
			})), r.d(t, "E", (function() {
				return C
			})), r.d(t, "D", (function() {
				return k
			})), r.d(t, "t", (function() {
				return D
			})), r.d(t, "s", (function() {
				return R
			})), r.d(t, "L", (function() {
				return A
			})), r.d(t, "p", (function() {
				return N
			})), r.d(t, "o", (function() {
				return L
			})), r.d(t, "q", (function() {
				return P
			})), r.d(t, "f", (function() {
				return G
			})), r.d(t, "r", (function() {
				return B
			})), r.d(t, "j", (function() {
				return M
			})), r.d(t, "g", (function() {
				return Q
			})), r.d(t, "h", (function() {
				return K
			})), r.d(t, "d", (function() {
				return W
			})), r.d(t, "H", (function() {
				return H
			})), r.d(t, "i", (function() {
				return z
			})), r.d(t, "c", (function() {
				return J
			})), r.d(t, "v", (function() {
				return V
			})), r.d(t, "u", (function() {
				return Y
			})), r.d(t, "G", (function() {
				return X
			})), r.d(t, "w", (function() {
				return Z
			})), r.d(t, "k", (function() {
				return ee
			})), r.d(t, "F", (function() {
				return te
			})), r.d(t, "y", (function() {
				return re
			})), r.d(t, "b", (function() {
				return ne
			})), r.d(t, "n", (function() {
				return se
			})), r.d(t, "x", (function() {
				return ie
			})), r.d(t, "l", (function() {
				return oe
			})), r.d(t, "J", (function() {
				return de
			}));
			var n = r("./src/reddit/constants/tracking.ts"),
				s = r("./src/reddit/helpers/correlationIdTracker.ts"),
				i = r("./src/reddit/helpers/media/index.ts"),
				o = r("./src/reddit/models/PostCreationForm/index.ts"),
				d = r("./src/reddit/models/PostDraft/index.ts"),
				c = r("./src/reddit/selectors/experiments/postCreationSubRec.ts"),
				a = r("./src/reddit/selectors/postDraft.ts"),
				u = r("./src/reddit/selectors/subreddit.ts"),
				l = r("./src/reddit/selectors/telemetry.ts"),
				b = r("./src/reddit/selectors/user.ts"),
				p = r("./src/telemetry/index.ts"),
				f = r("./src/telemetry/models/PostComposer.ts"),
				m = r("./src/telemetry/models/PostDraft.ts");
			const _ = {
					imageOnly: "image",
					linkOnly: "link",
					media: "media",
					poll: "poll",
					post: "self",
					prediction: "prediction",
					crosspost: "crosspost",
					talk: "talk"
				},
				O = e => ({
					source: "post_composer",
					action: n.c.CLICK,
					...l.o(e),
					screen: l.bb(e),
					correlationId: Object(s.c)(s.a.PostComposer)
				}),
				j = (e, t) => "self" !== t ? {} : {
					editorMode: e.user.prefs.editorMode === o.i.MARKDOWN ? "markdown" : "rte"
				},
				g = e => {
					Object(p.a)({
						noun: "cancel",
						...O(e)
					})
				},
				I = e => {
					Object(p.a)({
						noun: "discard",
						...O(e)
					})
				},
				S = e => t => ({
					...O(t),
					noun: "subreddit_choice",
					subreddit: e ? l.kb(t, e) : void 0,
					actionInfo: l.h(t)
				}),
				E = () => e => ({
					...O(e),
					noun: "subreddit_selector"
				}),
				y = (e, t) => {
					Object(p.a)({
						noun: "post_type_selector",
						postComposer: {
							type: _[t]
						},
						...O(e)
					})
				},
				h = () => e => ({
					noun: "add_option",
					...O(e)
				}),
				T = () => e => ({
					noun: "voting_length",
					...O(e)
				}),
				v = (e, t, r) => {
					"image_upload" === t || "video_upload" === t ? Object(p.a)({
						noun: t,
						...O(e)
					}) : Object(p.a)({
						noun: "text_option",
						postComposer: {
							textType: t,
							finalStatus: r ? "on" : "off"
						},
						...O(e)
					})
				},
				w = (e, t, r, n) => {
					Object(p.a)({
						noun: "post",
						subreddit: l.jb(e),
						postComposer: {
							type: t,
							...j(e, t)
						},
						post: r ? l.J(e, r) : null,
						...O(e),
						correlationId: n
					})
				},
				x = (e, t) => {
					const r = t === o.i.MARKDOWN ? "markdown_mode" : "rte_mode";
					Object(p.a)({
						noun: r,
						...O(e)
					})
				},
				C = (e, t) => {
					Object(p.a)({
						noun: "save",
						subreddit: l.jb(e),
						postComposer: {
							type: t,
							...j(e, t)
						},
						...O(e)
					})
				},
				k = (e, t) => {
					const r = e.uploads[t];
					r.error && Object(p.a)({
						...O(e),
						noun: "media",
						action: n.c.REJECT,
						actionInfo: {
							...l.d(e),
							reason: JSON.stringify(r.error)
						}
					})
				},
				D = (e, t) => {
					t.forEach(t => {
						const r = Object(i.f)(t.type);
						r && Object(p.a)({
							...O(e),
							action: n.c.DRAG,
							noun: r
						})
					})
				},
				R = (e, t, r) => {
					Object(p.a)({
						...O(e),
						noun: "input",
						postComposer: {
							inputType: r
						},
						action: t,
						actionInfo: l.h(e)
					})
				},
				A = (e, t, r) => {
					Object(p.a)({
						...O(e),
						noun: r,
						action: Object(f.getToggleAction)(t),
						actionInfo: l.h(e)
					})
				},
				N = e => U("input", e),
				L = () => U("add"),
				P = () => U("remove_image"),
				U = (e, t) => r => ({
					...O(r),
					noun: e,
					postComposer: {
						inputType: t,
						type: _.imageOnly
					},
					action: n.c.CLICK
				}),
				G = e => {
					Object(p.a)({
						...O(e),
						noun: "hide_oc_description",
						action: n.c.CLICK
					})
				},
				F = (e, t) => {
					if (t) {
						const r = l.kb(e, t);
						if (r) return {
							subreddit: r
						};
						const n = l.T(e, t);
						if (n) return {
							profile: n
						}
					}
				},
				B = (e, t) => {
					const {
						draftId: r,
						destSubreddit: n
					} = t, s = Object(b.k)(e), i = Object(a.d)(e, {
						draftId: r
					}), o = {
						authorId: s ? s.id : void 0,
						createdTimestamp: i ? i.created : void 0,
						id: r || void 0,
						nsfw: t.isNSFW,
						originalContent: t.isOC,
						spoiler: t.isSpoiler,
						titleLength: t.title.length
					};
					switch (t.kind) {
						case d.b.Link:
							o.type = m.DraftType.Link, o.urlLength = t.body.length;
							break;
						case d.b.Markdown:
							o.type = m.DraftType.Self, o.bodyTextLength = t.body.length;
							break;
						case d.b.RichText:
							o.type = m.DraftType.RichText, t.documentStats && (o.bodyTextLength = t.documentStats.textLength, o.numberRteImages = t.documentStats.rteImagesCount, o.numberRteVideos = t.documentStats.rteVideosCount);
							break;
						case d.b.Image:
							o.type = m.DraftType.Image;
							break;
						case d.b.Video:
							o.type = m.DraftType.Video
					}
					return {
						postDraft: o,
						...F(e, n.id)
					}
				},
				q = (e, t) => {
					const r = Object(b.k)(e),
						n = {
							authorId: r ? r.id : void 0,
							createdTimestamp: t.created,
							id: t.id,
							nsfw: t.isNSFW,
							originalContent: t.isOriginalContent,
							spoiler: t.isSpoiler,
							titleLength: t.title.length
						};
					switch (t.kind) {
						case d.b.Link:
							n.type = m.DraftType.Link, n.urlLength = (t.body || "").length;
							break;
						case d.b.Markdown:
							n.type = m.DraftType.Self, n.bodyTextLength = (t.body || "").length;
							break;
						case d.b.RichText:
							n.type = m.DraftType.RichText
					}
					return {
						postDraft: n,
						...F(e, t.subredditId)
					}
				},
				M = (e, t) => {
					Object(p.a)({
						noun: "draft_load",
						...O(e),
						...B(e, t)
					})
				},
				Q = (e, t) => {
					Object(p.a)({
						noun: t.draftId ? "draft_update" : "draft_create",
						...O(e),
						...B(e, t)
					})
				},
				K = (e, t) => {
					Object(p.a)({
						noun: "draft_delete",
						...O(e),
						...q(e, t)
					})
				},
				W = e => {
					Object(p.a)({
						...O(e),
						noun: "social_connect_link",
						action: n.c.CLICK
					})
				},
				H = (e, t) => {
					Object(p.a)({
						...O(e),
						noun: "twitter_share_checkbox",
						action: Object(f.getToggleAction)(t)
					})
				},
				z = (e, t, r) => {
					Object(p.a)({
						...O(e),
						...B(e, t),
						noun: "draft_share",
						action: r ? n.c.ENABLE : n.c.DISABLE
					})
				},
				J = e => {
					Object(p.a)({
						...O(e),
						noun: "create_community",
						actionInfo: {
							...l.d(e),
							pageType: "post_select_community"
						}
					})
				},
				$ = "community_recommendation",
				V = () => e => ({
					...O(e),
					action: n.c.VIEW,
					noun: $,
					listing: {
						links: Object(c.b)(e).map(t => Object(u.C)(e, t.name))
					}
				}),
				Y = (e, t) => r => ({
					...O(r),
					action: n.c.CLICK,
					noun: $,
					actionInfo: {
						...l.d(r),
						position: t
					},
					subreddit: {
						name: e,
						id: Object(u.C)(r, e)
					}
				}),
				X = e => {
					Object(p.a)({
						...O(e),
						action: n.c.SKIP,
						noun: $
					})
				},
				Z = (e, t) => r => ({
					...O(r),
					action: n.c.VIEW,
					noun: `${$}_hover`,
					actionInfo: {
						...l.d(r),
						position: t
					},
					subreddit: {
						name: e,
						id: Object(u.C)(r, e)
					}
				}),
				ee = e => t => ({
					...O(t),
					action: n.c.CLICK,
					noun: "draft_preview",
					actionInfo: {
						...l.d(t),
						count: e
					}
				}),
				te = e => t => ({
					...O(t),
					action: "add",
					noun: "flair",
					subreddit: l.kb(t, e)
				}),
				re = () => e => ({
					...O(e),
					action: n.c.CLICK,
					noun: "flair_dropdown"
				}),
				ne = () => e => ({
					...O(e),
					action: "clear",
					noun: "flair"
				}),
				se = () => e => ({
					...O(e),
					action: "search",
					noun: "flair"
				}),
				ie = ({
					actionInfoType: e,
					subredditId: t = "",
					noun: r = "create_post"
				}) => i => ({
					...O(i),
					action: n.c.CLICK,
					noun: r,
					actionInfo: {
						...l.d(i),
						type: e
					},
					correlationId: Object(s.e)(s.a.PostComposer, !1),
					subreddit: t ? l.kb(i, t) : void 0
				}),
				oe = () => e => ({
					...O(e),
					action: n.c.CLICK,
					noun: "edit_post"
				}),
				de = e => t => ({
					...O(t),
					action: "type",
					noun: "subreddit_search",
					actionInfo: {
						...l.d(t),
						type: e
					}
				})
		},
		"./src/reddit/helpers/trackers/powerups.ts": function(e, t, r) {
			"use strict";
			r.d(t, "J", (function() {
				return o
			})), r.d(t, "z", (function() {
				return d
			})), r.d(t, "B", (function() {
				return c
			})), r.d(t, "K", (function() {
				return u
			})), r.d(t, "j", (function() {
				return l
			})), r.d(t, "v", (function() {
				return b
			})), r.d(t, "q", (function() {
				return p
			})), r.d(t, "u", (function() {
				return f
			})), r.d(t, "t", (function() {
				return m
			})), r.d(t, "p", (function() {
				return _
			})), r.d(t, "m", (function() {
				return O
			})), r.d(t, "o", (function() {
				return j
			})), r.d(t, "n", (function() {
				return g
			})), r.d(t, "s", (function() {
				return I
			})), r.d(t, "r", (function() {
				return S
			})), r.d(t, "c", (function() {
				return E
			})), r.d(t, "b", (function() {
				return y
			})), r.d(t, "e", (function() {
				return h
			})), r.d(t, "C", (function() {
				return T
			})), r.d(t, "H", (function() {
				return v
			})), r.d(t, "D", (function() {
				return w
			})), r.d(t, "G", (function() {
				return x
			})), r.d(t, "h", (function() {
				return C
			})), r.d(t, "g", (function() {
				return k
			})), r.d(t, "i", (function() {
				return D
			})), r.d(t, "y", (function() {
				return R
			})), r.d(t, "w", (function() {
				return A
			})), r.d(t, "x", (function() {
				return N
			})), r.d(t, "f", (function() {
				return L
			})), r.d(t, "E", (function() {
				return P
			})), r.d(t, "k", (function() {
				return U
			})), r.d(t, "a", (function() {
				return G
			})), r.d(t, "A", (function() {
				return F
			})), r.d(t, "d", (function() {
				return B
			})), r.d(t, "l", (function() {
				return q
			})), r.d(t, "F", (function() {
				return M
			})), r.d(t, "I", (function() {
				return Q
			}));
			var n = r("./src/reddit/helpers/correlationIdTracker.ts"),
				s = r("./src/reddit/selectors/telemetry.ts");
			const i = (e, t, r) => ({
					...s.o(e),
					correlationId: Object(n.e)(n.a.PowerupsFlow, !1),
					profile: s.S(e),
					subreddit: s.jb(e),
					powerups: {
						...s.ob(e),
						freeCount: t,
						paidCount: r
					}
				}),
				o = e => t => ({
					source: e,
					action: "click",
					noun: "powerups_user_badge",
					...i(t),
					correlationId: Object(n.e)(n.a.PowerupsFlow, !0)
				}),
				d = () => e => ({
					source: "postlist_supporters_cta",
					action: "click",
					noun: "powerups_become_hero",
					...i(e),
					correlationId: Object(n.e)(n.a.PowerupsFlow, !0)
				}),
				c = () => e => ({
					source: "postlist_supporters_cta",
					action: "click",
					noun: "powerups_see_all_heroes",
					...i(e),
					correlationId: Object(n.e)(n.a.PowerupsFlow, !0)
				}),
				a = e => (t, r) => n => ({
					source: e,
					action: "click",
					noun: "powerup_supporter",
					...i(n),
					profile: {
						id: t,
						name: r,
						type: "default"
					}
				}),
				u = a("postlist_supporters_cta"),
				l = a("comm_heroes_modal"),
				b = () => e => ({
					source: "powerups",
					action: "view",
					noun: "post_upsell",
					...i(e),
					correlationId: Object(n.e)(n.a.PowerupsFlow, !0)
				}),
				p = () => e => ({
					source: "powerups",
					action: "click",
					noun: "post_upsell",
					...i(e),
					correlationId: Object(n.e)(n.a.PowerupsFlow, !0)
				}),
				f = () => e => ({
					source: "powerups",
					action: "view",
					noun: "post_upsell_unlock_avatar",
					...i(e),
					correlationId: Object(n.e)(n.a.PowerupsFlow, !0)
				}),
				m = () => e => ({
					source: "powerups",
					action: "click",
					noun: "post_upsell_unlock_avatar",
					...i(e),
					correlationId: Object(n.e)(n.a.PowerupsFlow, !0)
				}),
				_ = () => e => ({
					source: "powerups",
					action: "view",
					noun: "post_upsell_avatar",
					...i(e),
					correlationId: Object(n.e)(n.a.PowerupsFlow, !0)
				}),
				O = () => e => ({
					source: "powerups_post_upsell_avatar",
					action: "click",
					noun: "post_upsell_avatar_cta",
					...i(e),
					correlationId: Object(n.e)(n.a.PowerupsFlow, !0)
				}),
				j = () => e => ({
					source: "powerups_post_upsell_avatar_modal",
					action: "view",
					noun: "powerups_modal",
					...i(e)
				}),
				g = () => e => ({
					source: "powerups_post_upsell_avatar_modal",
					action: "click",
					noun: "post_upsell_avatar_modal_cta",
					...i(e)
				}),
				I = () => e => ({
					source: "powerups",
					action: "view",
					noun: "post_upsell_premium",
					...i(e)
				}),
				S = () => e => ({
					source: "powerups_post_upsell_premium",
					action: "click",
					noun: "use_premium_powerup",
					...i(e)
				}),
				E = () => e => ({
					source: "powerups_community_feed",
					action: "view",
					noun: "powerups_mod_enable_banner",
					...i(e),
					correlationId: Object(n.e)(n.a.PowerupsFlow, !1)
				}),
				y = () => e => ({
					source: "powerups_community_feed",
					action: "click",
					noun: "powerups_mod_enable_banner",
					...i(e),
					correlationId: Object(n.e)(n.a.PowerupsFlow, !1)
				}),
				h = e => t => ({
					source: "powerups",
					action: "click",
					noun: "join_supporters",
					...i(t),
					actionInfo: s.d(t, {
						reason: e
					})
				}),
				T = () => e => ({
					source: "powerups_supporters_modal",
					action: "click",
					noun: "powerups_cta",
					...i(e)
				}),
				v = () => e => ({
					source: "powerups",
					action: "click",
					noun: "unlock_supporter_achievement",
					...i(e)
				}),
				w = () => e => ({
					source: "powerups",
					action: "click",
					noun: "unlock_achievements",
					...i(e)
				}),
				x = () => e => ({
					source: "powerups_flair_picker",
					action: "click",
					noun: "powerups_cta",
					...i(e)
				}),
				C = e => t => ({
					source: "powerups_modal",
					action: "view",
					noun: "marketing_step",
					...i(t),
					actionInfo: s.d(t, {
						reason: e
					})
				}),
				k = e => t => ({
					source: "powerups",
					action: "click",
					noun: "benefit",
					...i(t),
					powerups: {
						...s.ob(t),
						benefit: e
					}
				}),
				D = (e, t) => r => ({
					source: "powerups_modal",
					action: "view",
					noun: "purchase_step",
					...i(r, e, t)
				}),
				R = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					...i(e),
					actionInfo: s.d(e, {
						pageType: "powerups_premium_upsell"
					})
				}),
				A = () => e => ({
					source: "powerups_premium_upsell",
					action: "click",
					noun: "powerups_price",
					...i(e)
				}),
				N = e => t => ({
					source: "powerups",
					action: "click",
					noun: "premium",
					...i(t),
					actionInfo: s.d(t, {
						pageType: "powerups_premium_upsell"
					}),
					goldPurchase: {
						subscriptionType: e
					}
				}),
				L = (e, t) => r => ({
					source: "global",
					action: "view",
					noun: "screen",
					...i(r, e, t),
					actionInfo: {
						pageType: "community_heroes_modal"
					}
				}),
				P = () => e => ({
					source: "powerups",
					action: "click",
					noun: "unlock_emojis",
					...i(e),
					correlationId: Object(n.e)(n.a.PowerupsFlow, !0)
				}),
				U = () => e => ({
					source: "meta",
					action: "open",
					noun: "emote_picker",
					...i(e)
				}),
				G = (e, t) => r => ({
					source: t,
					action: "click",
					noun: "add_custom_emojis",
					...i(r),
					powerups: {
						...s.ob(r),
						emojiCount: e
					}
				}),
				F = (e, t) => r => ({
					source: t,
					action: "save",
					noun: "custom_emojis",
					...i(r),
					powerups: {
						...s.ob(r),
						emojiCount: e
					}
				}),
				B = (e = 1, t) => r => ({
					source: t,
					action: "delete",
					noun: "custom_emojis",
					...i(r),
					powerups: {
						...s.ob(r),
						emojiCount: e
					}
				}),
				q = (e, t) => r => ({
					source: "meta",
					action: "open",
					noun: "gif_tooltip",
					subreddit: t ? s.kb(r, t) : void 0,
					...i(r),
					correlationId: e
				}),
				M = () => e => ({
					source: "powerups",
					action: "click",
					noun: "unlock_gifs",
					...i(e),
					correlationId: Object(n.e)(n.a.PowerupsFlow, !0)
				}),
				Q = (e, t, r) => n => ({
					source: "powerups_settings",
					action: "click",
					noun: e,
					setting: {
						value: String(t),
						oldValue: String(r)
					},
					subreddit: s.jb(n),
					...s.o(n)
				})
		},
		"./src/reddit/icons/fonts/helpers.m.less": function(e, t, r) {
			e.exports = {
				TooltipDesc: "_37iEJpUpWXN00_fpZKHglg",
				tooltipDesc: "_37iEJpUpWXN00_fpZKHglg"
			}
		},
		"./src/reddit/icons/fonts/helpers.tsx": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return a
			})), r.d(t, "a", (function() {
				return u
			}));
			var n = r("./node_modules/react/index.js"),
				s = r.n(n),
				i = r("./src/reddit/icons/fonts/helpers.m.less"),
				o = r.n(i),
				d = r("./src/lib/constants/icons.ts"),
				c = r("./src/lib/lessComponent.tsx");
			const a = (e, t) => `icon icon-${e}${t&&!e.includes("fill")&&d.a[`${e}_fill`]?"_fill":""}`,
				u = c.a.wrapped(e => s.a.createElement("span", {
					className: e.className
				}, e.children), "TooltipDesc", o.a)
		},
		"./src/reddit/icons/svgs/Close/index.tsx": function(e, t, r) {
			"use strict";
			var n = r("./node_modules/react/index.js"),
				s = r.n(n);

			function i() {
				return (i = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var r = arguments[t];
						for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => s.a.createElement("svg", i({
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), s.a.createElement("polygon", {
				fill: "inherit",
				points: "11.649 9.882 18.262 3.267 16.495 1.5 9.881 8.114 3.267 1.5 1.5 3.267 8.114 9.883 1.5 16.497 3.267 18.264 9.881 11.65 16.495 18.264 18.262 16.497"
			}))
		},
		"./src/reddit/models/ApiRequestState/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return n
			})), r.d(t, "b", (function() {
				return o
			}));
			var n, s = r("./node_modules/uuid/v4.js"),
				i = r.n(s);
			! function(e) {
				e[e.Pending = 0] = "Pending", e[e.Complete = 1] = "Complete", e[e.Failed = 2] = "Failed"
			}(n || (n = {}));
			const o = () => i()()
		},
		"./src/reddit/models/Duplicates/index.ts": function(e, t, r) {
			"use strict";

			function n(e, t) {
				return `${e}-sort[${t.sort}]-crossposts_only[${t.crossposts_only}]`
			}
			r.d(t, "a", (function() {
				return n
			}))
		},
		"./src/reddit/models/ExternalAccount/index.ts": function(e, t, r) {
			"use strict";
			var n;
			r.d(t, "a", (function() {
					return n
				})),
				function(e) {
					e.Twitter = "twitter"
				}(n || (n = {}))
		},
		"./src/reddit/models/HatefulContentFilters/index.ts": function(e, t, r) {
			"use strict";
			var n;
			r.d(t, "a", (function() {
					return n
				})),
				function(e) {
					e.Off = "OFF", e.Lenient = "LENIENT", e.Moderate = "MODERATE", e.Strict = "STRICT"
				}(n || (n = {}))
		},
		"./src/reddit/models/Option/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return i
			}));
			const n = e => !e.id,
				s = e => !!e.id,
				i = (e, t) => n(e) && n(t) ? e.displayText.toLowerCase().trim() === t.displayText.toLowerCase().trim() : !(!s(e) || !s(t)) && e.id === t.id
		},
		"./src/reddit/models/Tags/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return n
			})), r.d(t, "b", (function() {
				return s
			})), r.d(t, "c", (function() {
				return i
			})), r.d(t, "f", (function() {
				return o
			})), r.d(t, "e", (function() {
				return d
			})), r.d(t, "d", (function() {
				return c
			}));
			const n = 25,
				s = 64;
			var i;
			! function(e) {
				e.EVENT = "EVENT", e.COLLECTION = "COLLECTION", e.CLASSIFICATION = "CLASSIFICATION", e.POST_CLASSIFICATION = "POST_CLASSIFICATION", e.SUBREDDIT_CLASSIFICATION = "SUBREDDIT_CLASSIFICATION", e.COMMENT_CLASSIFICATION = "COMMENT_CLASSIFICATION"
			}(i || (i = {}));
			const o = (e, t = !1) => ({
					id: e.id,
					displayText: e.text,
					selected: t
				}),
				d = (e, t = !1) => o(e.tag, t);
			var c;
			! function(e) {
				e.TAGGED = "TAGGED", e.NONE = "NONE"
			}(c || (c = {}))
		},
		"./src/reddit/reducers/features/modUserNotes/index.ts": function(e, t, r) {
			"use strict";
			var n = r("./node_modules/redux/es/redux.js"),
				s = r("./src/reddit/actions/subredditModeration/constants.ts"),
				i = r("./src/reddit/models/SubredditModeration/index.ts"),
				o = r("./src/redditGQL/types.ts");
			const d = {};
			var c = (e = d, t) => {
					var r;
					switch (t.type) {
						case s.D: {
							const {
								subredditId: n,
								lastAuthorModNote: s
							} = t.payload, d = null === (r = null == s ? void 0 : s.user) || void 0 === r ? void 0 : r.id, c = Object(i.d)(n, d, o.j.All);
							return {
								...e,
								[c]: s.id
							}
						}
						case s.C: {
							const {
								subredditId: r,
								lastAuthorModNotes: n
							} = t.payload, s = {};
							return n.forEach(e => {
								var t;
								const n = null === (t = null == e ? void 0 : e.user) || void 0 === t ? void 0 : t.id,
									d = Object(i.d)(r, n, o.j.All);
								s[d] = e.id
							}), {
								...e,
								...s
							}
						}
						default:
							return e
					}
				},
				a = r("./node_modules/icepick/icepick.js");
			const u = {};
			var l = (e = u, t) => {
				switch (t.type) {
					case s.D: {
						const {
							lastAuthorModNote: r
						} = t.payload;
						return {
							...e,
							[r.id]: r
						}
					}
					case s.C: {
						const {
							lastAuthorModNotes: r
						} = t.payload;
						return Object(a.merge)(e, r.reduce((e, t) => (e[t.id] = t, e), {}))
					}
					default:
						return e
				}
			};
			t.a = Object(n.c)({
				lastAuthorModNotes: c,
				models: l
			})
		},
		"./src/reddit/reducers/features/userFlair/index.ts": function(e, t, r) {
			"use strict";
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/lodash/omit.js"),
				s = r.n(n),
				i = r("./src/reddit/actions/grantUserFlair/constants.ts"),
				o = r("./src/reddit/actions/modQueue/constants.ts"),
				d = r("./src/reddit/actions/pages/constants.ts"),
				c = r("./src/reddit/actions/pages/postCreation.ts"),
				a = r("./src/reddit/actions/pages/postDraft.ts"),
				u = r("./src/reddit/actions/pages/subreddit.ts"),
				l = r("./src/reddit/actions/userFlair/constants.ts");
			const b = {};
			t.a = (e = b, t) => {
				var r, n, p, f, m;
				switch (t.type) {
					case u.SUBREDDIT_LOADED:
					case c.PAGE_LOADED:
					case a.PAGE_LOADED:
					case d.b:
					case d.f:
					case l.k:
						return {
							...e, ...t.payload.userFlair
						};
					case o.i:
					case o.f:
					case o.m:
					case o.p:
					case o.v: {
						const {
							response: r
						} = t.payload, {
							userFlair: n
						} = r, s = {
							...e
						};
						return Object.keys(n).forEach(e => {
							s[e] || (s[e] = n[e])
						}), s
					}
					case l.r: {
						const {
							subredditId: r,
							applied: n,
							displaySettings: s
						} = t.payload;
						return {
							...e,
							[r]: {
								...e[r],
								...n && {
									applied: n
								},
								displaySettings: s
							}
						}
					}
					case i.h: {
						const {
							subredditId: r,
							applied: n
						} = t.payload;
						return {
							...e,
							[r]: {
								...e[r],
								applied: n
							}
						}
					}
					case l.j: {
						const {
							subredditId: r,
							isEnabled: n
						} = t.payload, s = {
							...e[r].displaySettings,
							isEnabled: n
						};
						return {
							...e,
							[r]: {
								...e[r],
								displaySettings: s
							}
						}
					}
					case l.d: {
						const {
							subredditId: n,
							canAssignOwn: s
						} = t.payload, i = {
							...null === (r = e[n]) || void 0 === r ? void 0 : r.permissions,
							canAssignOwn: s
						};
						return {
							...e,
							[n]: {
								...e[n],
								permissions: i
							}
						}
					}
					case l.q: {
						const r = t.payload,
							s = e[r.subredditId],
							i = null === (n = e[r.subredditId]) || void 0 === n ? void 0 : n.templates,
							o = null === (p = e[r.subredditId]) || void 0 === p ? void 0 : p.templateIds,
							d = (null === (f = r.template) || void 0 === f ? void 0 : f.id) || (null === (m = r.template) || void 0 === m ? void 0 : m.templateId);
						if (!d) return;
						const c = {
								...i,
								[d]: r.template
							},
							a = [...o];
						return a.includes(d) || a.push(d), {
							...e,
							[r.subredditId]: {
								...s,
								templates: c,
								templateIds: a
							}
						}
					}
					case l.g: {
						const r = t.payload,
							n = e[r.subredditId],
							i = e[r.subredditId].templates,
							o = e[r.subredditId].templateIds,
							d = s()(i, r.templateId),
							c = o.filter(e => e !== r.templateId);
						return {
							...e,
							[r.subredditId]: {
								...n,
								templates: {
									...d
								},
								templateIds: c
							}
						}
					}
					case l.m:
					case l.l: {
						const r = t.payload,
							n = e[r.subredditId];
						return {
							...e,
							[r.subredditId]: {
								...n,
								templateIds: r.templateIds
							}
						}
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/pages/comments/index.ts": function(e, t, r) {
			"use strict";
			var n = r("./node_modules/redux/es/redux.js"),
				s = r("./src/reddit/actions/ads/constants.ts");
			const i = [];
			var o = (e = i, t) => {
					switch (t.type) {
						case s.o:
							return t.payload;
						case s.p:
						default:
							return e
					}
				},
				d = r("./src/reddit/actions/pages/constants.ts");
			const c = {};
			var a = (e = c, t) => {
				switch (t.type) {
					case d.d:
					case d.b:
					case d.h:
					case d.f: {
						const {
							key: r
						} = t.payload;
						return {
							...e,
							[r]: null
						}
					}
					case d.a:
					case d.e: {
						const {
							key: r,
							error: n
						} = t.payload;
						return {
							...e,
							[r]: n || {}
						}
					}
					default:
						return e
				}
			};
			const u = {};
			var l = (e = u, t) => {
				switch (t.type) {
					case d.c:
					case d.g: {
						const {
							key: r
						} = t.payload;
						return {
							...e,
							[r]: !0
						}
					}
					case d.i: {
						const {
							key: r
						} = t.payload;
						return {
							...e,
							[r]: !1
						}
					}
					default:
						return e
				}
			};
			const b = {};
			var p = (e = b, t) => {
					switch (t.type) {
						case d.d:
						case d.h:
						case d.i: {
							const {
								key: r
							} = t.payload;
							return {
								...e,
								[r]: !0
							}
						}
						case d.b:
						case d.a:
						case d.f:
						case d.e: {
							const {
								key: r
							} = t.payload;
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				f = Object(n.c)({
					error: a,
					fullyLoaded: l,
					pending: p
				}),
				m = r("./src/reddit/actions/comment/constants.ts");
			const _ = [];
			var O = (e = _, t) => {
					switch (t.type) {
						case m.E:
							return e.find(e => t.payload.id === e.id) ? [...e.filter(e => t.payload.id !== e.id)] : [...e, t.payload];
						case m.b:
							return [...e.filter(e => e.expiresAt > Date.now())];
						case m.u:
							return [...t.payload.comments];
						default:
							return e
					}
				},
				j = r("./node_modules/lodash/uniqBy.js"),
				g = r.n(j),
				I = r("./node_modules/lodash/values.js"),
				S = r.n(I),
				E = r("./src/reddit/actions/comment/websocket/constants.ts");
			const y = {};

			function h(e) {
				return g()(e, "id").sort((e, t) => e.created - t.created)
			}
			var T = (e = y, t) => {
					switch (t.type) {
						case d.f:
						case m.w:
						case d.b: {
							const {
								comments: r,
								key: n
							} = t.payload, s = e[n] ? e[n] : [], i = function(e, t) {
								return S()(e).map(e => {
									const r = e.isStickied ? t && t.created || Math.round(Date.now() / 1e3) : e.created;
									return {
										id: e.id,
										created: r,
										stickied: e.isStickied,
										authorId: e.authorId
									}
								})
							}(r, s.find(e => e.stickied)), o = h([...s, ...i]);
							return {
								...e,
								[n]: [...o]
							}
						}
						case E.b:
						case E.c:
						case E.d:
						case m.J:
						case m.I: {
							const {
								comment: {
									id: r,
									created: n,
									isStickied: s,
									authorId: i
								},
								commentsPageKey: o
							} = t.payload;
							return {
								...e,
								[o]: [...h([...e[o] ? e[o] : [], {
									id: r,
									created: n,
									stickied: s,
									authorId: i
								}])]
							}
						}
						default:
							return e
					}
				},
				v = r("./node_modules/lodash/mapValues.js"),
				w = r.n(v),
				x = r("./src/reddit/helpers/commentList/index.ts"),
				C = r("./src/reddit/models/Comment/index.ts");
			const k = {};

			function D(e) {
				const t = e;
				return w()(t, ({
					depth: e,
					next: t,
					prev: r
				}) => ({
					depth: e,
					next: t,
					prev: r
				}))
			}
			var R = (e = k, t) => {
				switch (t.type) {
					case m.w: {
						const {
							comments: r,
							commentLists: n,
							continueThreads: s,
							key: i,
							moreCommentsItem: o,
							moreComments: d
						} = t.payload, c = n[o.postId], a = e[i], u = {}, l = a[o.id];
						if (l && l.prev) {
							const {
								id: e
							} = l.prev;
							u[e] = {
								...a[e],
								next: c.head || l.next
							}
						}
						if (l && l.next) {
							const {
								id: e
							} = l.next;
							u[e] = {
								...a[e],
								prev: c.tail || l.prev
							}
						}
						if (c.head && c.tail) {
							const e = Object(x.c)({
									commentLink: c.head,
									commentsDict: r,
									moreCommentsDict: d,
									continueThreadDict: s
								}),
								t = Object(x.c)({
									commentLink: c.tail,
									commentsDict: r,
									moreCommentsDict: d,
									continueThreadDict: s
								});
							l && (e.prev = l.prev, t.next = l.next)
						}
						return {
							...e,
							[i]: {
								...e[i],
								...D(r),
								...D(s),
								...D(d),
								...u
							}
						}
					}
					case d.b:
					case d.f: {
						const {
							comments: r,
							continueThreads: n,
							key: s,
							moreComments: i
						} = t.payload;
						return {
							...e,
							[s]: {
								...e[s],
								...D(r),
								...D(n),
								...D(i)
							}
						}
					}
					case E.b:
					case m.J: {
						const {
							comment: r,
							commentsPageKey: n,
							headCommentId: s
						} = t.payload, i = e[n], o = {};
						let d = null;
						return s && (o[s] = {
							...i[s],
							prev: Object(C.i)(r.id)
						}, d = Object(C.i)(s)), {
							...e,
							[n]: {
								...e[n],
								...o,
								[r.id]: {
									depth: 0,
									next: d,
									prev: null
								}
							}
						}
					}
					case m.I: {
						const {
							comment: r,
							commentsPageKey: n,
							parentCommentId: s,
							depth: i
						} = t.payload, o = e[n], d = {};
						let c = null;
						if (!o[s]) return e;
						const a = o[s].next;
						return a && (d[a.id] = {
							...o[a.id],
							prev: Object(C.i)(r.id)
						}, c = a), d[s] = {
							...o[s],
							next: Object(C.i)(r.id)
						}, {
							...e,
							[n]: {
								...e[n],
								...d,
								[r.id]: {
									depth: i,
									next: c,
									prev: Object(C.i)(s)
								}
							}
						}
					}
					default:
						return e
				}
			};
			const A = {};
			var N = (e = A, t) => {
				switch (t.type) {
					case E.b:
					case E.c:
					case m.J: {
						const {
							comment: r,
							commentsPageKey: n
						} = t.payload;
						return {
							...e,
							[n]: r.id
						}
					}
					case d.b:
					case d.f: {
						const {
							commentLists: r,
							key: n,
							postId: s
						} = t.payload;
						return {
							...e,
							[n]: r[s] && r[s].head ? r[s].head.id : null
						}
					}
					case d.i: {
						const {
							key: r
						} = t.payload;
						return {
							...e,
							[r]: null
						}
					}
					default:
						return e
				}
			};
			const L = {};
			var P = (e = L, t) => {
				switch (t.type) {
					case d.d:
					case d.b:
					case d.c:
					case d.h: {
						const {
							key: r,
							postId: n
						} = t.payload;
						return {
							...e,
							[r]: n
						}
					}
					case m.J: {
						const {
							parentId: r,
							commentsPageKey: n
						} = t.payload;
						return e[n] ? e : {
							...e,
							[n]: r
						}
					}
					default:
						return e
				}
			};
			t.a = Object(n.c)({
				api: f,
				followed: O,
				keyToChatCommentLinks: T,
				keyToCommentThreadLinkSets: R,
				keyToHeadCommentId: N,
				keyToPostId: P,
				ads: o
			})
		},
		"./src/reddit/reducers/tags/selected/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return n
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n, s = r("./node_modules/lodash/uniqWith.js"),
				i = r.n(s),
				o = r("./node_modules/lodash/values.js"),
				d = r.n(o),
				c = r("./src/reddit/actions/tags/constants.ts"),
				a = r("./src/reddit/models/Option/index.ts"),
				u = r("./src/reddit/models/Tags/index.ts");
			! function(e) {
				e.ADD = "ADD", e.REMOVE = "REMOVE"
			}(n || (n = {}));
			const l = {
				selectedPrimaryTagId: {},
				selectedOptions: {},
				selectedSuggestedOptions: {},
				deselectedOptions: {},
				deselectedSuggestedOptions: {},
				inputByItemId: {},
				suggestedInputByItemId: {}
			};
			t.b = (e = l, t) => {
				switch (t.type) {
					case c.w:
					case c.r: {
						const {
							subredditId: r,
							itemTags: n,
							suggestedItemTags: s,
							primaryTag: o
						} = t.payload, c = i()([...(e.selectedOptions[r] || []).map(e => {
							if (!e.id) {
								const t = d()(n[r] || {}).find(t => e.displayText.toLowerCase().trim() === t.tag.text.toLowerCase().trim());
								if (t) return {
									...Object(u.e)(t, !0),
									action: null
								}
							}
							return e
						}), ...d()(n[r] || {}).map(e => ({
							...Object(u.e)(e, !0),
							action: null
						}))], a.a);
						let l = e.selectedPrimaryTagId;
						return o && (l = {
							...l,
							[r]: o.tag.id
						}), {
							...e,
							selectedOptions: {
								...e.selectedOptions,
								[r]: c.map(e => ({
									...e,
									action: e.id ? null : e.action
								}))
							},
							selectedSuggestedOptions: {
								...e.selectedSuggestedOptions,
								[r]: d()(s[r] || {}).map(e => ({
									...Object(u.e)(e, !0),
									action: null
								}))
							},
							deselectedOptions: {
								...e.deselectedOptions,
								[r]: []
							},
							selectedPrimaryTagId: l
						}
					}
					case c.D:
					case c.z: {
						const {
							subredditId: r,
							option: s
						} = t.payload, o = t.type === c.z ? "selectedOptions" : "selectedSuggestedOptions", d = t.type === c.z ? "deselectedOptions" : "deselectedSuggestedOptions", u = (e[d][r] || []).slice(), l = u.findIndex(e => Object(a.a)(e, s));
						let b = n.ADD;
						return l > -1 && (b = null, u.splice(l, 1)), {
							...e,
							[o]: {
								...e[o],
								[r]: i()([...e[o][r] || [], {
									...s,
									action: b
								}], a.a)
							},
							[d]: {
								...e[d],
								[r]: u
							}
						}
					}
					case c.C:
					case c.y: {
						const {
							subredditId: r,
							option: s
						} = t.payload, i = t.type === c.y ? "selectedOptions" : "selectedSuggestedOptions", o = t.type === c.y ? "deselectedOptions" : "deselectedSuggestedOptions", d = (e[o][r] || []).slice(), u = (e[i][r] || []).slice(), l = u.findIndex(e => Object(a.a)(e, s));
						return l > -1 && (null === u[l].action && d.push({
							...u[l],
							action: n.REMOVE
						}), u.splice(l, 1)), {
							...e,
							[i]: {
								...e[i],
								[r]: u
							},
							[o]: {
								...e[o],
								[r]: d
							}
						}
					}
					case c.A: {
						const {
							itemTagsState: r
						} = t.payload, n = Object.keys(r);
						if (!n.length) return e;
						const s = {
								selectedOptions: {},
								deselectedOptions: {},
								inputByItemId: {}
							},
							i = n.reduce((e, t) => (e.selectedOptions[t] = d()(r[t]).map(e => ({
								...Object(u.e)(e, !0),
								action: null
							})), e.deselectedOptions[t] = [], e.inputByItemId[t] = "", e), s);
						return {
							...e,
							inputByItemId: {
								...e.inputByItemId,
								...i.inputByItemId
							},
							selectedOptions: {
								...e.selectedOptions,
								...i.selectedOptions
							},
							deselectedOptions: {
								...e.deselectedOptions,
								...i.deselectedOptions
							}
						}
					}
					case c.B:
					case c.x: {
						const {
							subredditId: r,
							input: n
						} = t.payload, s = t.type === c.x ? "inputByItemId" : "suggestedInputByItemId";
						return {
							...e,
							[s]: {
								...e[s],
								[r]: n
							}
						}
					}
					case c.i:
					case c.h: {
						const {
							subredditId: r,
							primaryTagId: n
						} = t.payload;
						if (!n || !r) return e;
						const s = {
								...e,
								selectedPrimaryTagId: {
									...e.selectedPrimaryTagId,
									[r]: n
								}
							},
							i = e.selectedOptions[r];
						if (i) {
							const t = i.findIndex(e => e.id === n),
								o = [...i];
							return t >= 0 && o.splice(t, 1), {
								...s,
								selectedOptions: {
									...e.selectedOptions,
									[r]: o
								}
							}
						}
						return s
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/selectors/PublicAccessNetwork/api.ts": function(e, t, r) {
			"use strict";
			r.d(t, "k", (function() {
				return d
			})), r.d(t, "c", (function() {
				return c
			})), r.d(t, "e", (function() {
				return a
			})), r.d(t, "d", (function() {
				return u
			})), r.d(t, "f", (function() {
				return l
			})), r.d(t, "i", (function() {
				return b
			})), r.d(t, "l", (function() {
				return p
			})), r.d(t, "m", (function() {
				return f
			})), r.d(t, "b", (function() {
				return m
			})), r.d(t, "o", (function() {
				return _
			})), r.d(t, "n", (function() {
				return O
			})), r.d(t, "g", (function() {
				return j
			})), r.d(t, "a", (function() {
				return g
			})), r.d(t, "h", (function() {
				return S
			})), r.d(t, "j", (function() {
				return y
			}));
			var n = r("./node_modules/reselect/es/index.js"),
				s = r("./src/lib/objectSelector/index.ts"),
				i = r("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				o = r("./src/reddit/helpers/publicAccessNetwork/index.ts");
			const d = e => e.publicAccessNetwork.api.config,
				c = (e, t) => !!t && !!e.publicAccessNetwork.api.error[Object(o.g)(t)],
				a = e => c(e, i.b),
				u = (e, t) => !!t && !!e.publicAccessNetwork.api.pending[Object(o.g)(t)] && e.publicAccessNetwork.api.pending[Object(o.g)(t)].isPending,
				l = e => u(e, i.b),
				b = e => e.publicAccessNetwork.api.pending[i.b] && e.publicAccessNetwork.api.pending[i.b].fetchedUtcTimeStamp,
				p = Object(n.a)(d, e => e.global),
				f = Object(n.a)((e, {
					subreddit: t
				}) => t, d, (e, t) => {
					const r = e.toLowerCase();
					return t.subreddits[r]
				}),
				m = Object(n.a)(d, e => e.global.rpan_intro_video_url),
				_ = Object(n.a)(d, e => e.global.url_to_show_for_unavailable_video),
				O = Object(n.a)(d, e => !1),
				j = Object(n.a)(d, e => e.isError),
				g = Object(n.a)(d, e => e.global.max_chat_comment_length),
				I = e => e.publicAccessNetwork.api.recommendedViewerSubreddits,
				S = (Object(n.a)(I, e => e.isError), Object(n.a)(I, e => e.isPending)),
				E = Object(s.a)(Object(n.a)(I, e => e.subreddits)),
				y = Object(n.a)(E, e => [{
					name: "All",
					prefixedName: "All",
					path: Object(o.e)()
				}, ...e.map(e => ({
					name: e,
					prefixedName: `r/${e}`,
					path: Object(o.f)(e)
				}))])
		},
		"./src/reddit/selectors/comments.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return m
			})), r.d(t, "d", (function() {
				return _
			})), r.d(t, "u", (function() {
				return O
			})), r.d(t, "w", (function() {
				return j
			})), r.d(t, "x", (function() {
				return g
			})), r.d(t, "k", (function() {
				return S
			})), r.d(t, "g", (function() {
				return E
			})), r.d(t, "H", (function() {
				return y
			})), r.d(t, "n", (function() {
				return h
			})), r.d(t, "o", (function() {
				return T
			})), r.d(t, "j", (function() {
				return v
			})), r.d(t, "l", (function() {
				return w
			})), r.d(t, "h", (function() {
				return x
			})), r.d(t, "a", (function() {
				return C
			})), r.d(t, "b", (function() {
				return k
			})), r.d(t, "q", (function() {
				return D
			})), r.d(t, "m", (function() {
				return R
			})), r.d(t, "t", (function() {
				return A
			})), r.d(t, "z", (function() {
				return N
			})), r.d(t, "J", (function() {
				return L
			})), r.d(t, "s", (function() {
				return P
			})), r.d(t, "D", (function() {
				return U
			})), r.d(t, "E", (function() {
				return G
			})), r.d(t, "F", (function() {
				return F
			})), r.d(t, "r", (function() {
				return B
			})), r.d(t, "e", (function() {
				return q
			})), r.d(t, "v", (function() {
				return M
			})), r.d(t, "K", (function() {
				return Q
			})), r.d(t, "f", (function() {
				return K
			})), r.d(t, "i", (function() {
				return W
			})), r.d(t, "G", (function() {
				return H
			})), r.d(t, "C", (function() {
				return z
			})), r.d(t, "I", (function() {
				return J
			})), r.d(t, "p", (function() {
				return $
			})), r.d(t, "L", (function() {
				return V
			})), r.d(t, "y", (function() {
				return Y
			})), r.d(t, "A", (function() {
				return X
			})), r.d(t, "B", (function() {
				return Z
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/lodash/values.js"),
				s = r.n(n),
				i = r("./src/lib/constants/index.ts"),
				o = r("./src/lib/objectSelector/index.ts"),
				d = r("./src/reddit/constants/comments.ts"),
				c = r("./src/reddit/models/Comment/index.ts"),
				a = r("./src/reddit/models/Post/index.ts"),
				u = r("./src/reddit/selectors/subreddit.ts"),
				l = r("./src/reddit/selectors/commentSelector.ts"),
				b = r("./src/lib/initializeClient/installReducer.ts"),
				p = r("./src/reddit/reducers/features/comments/index.ts"),
				f = r("./src/reddit/reducers/pages/comments/index.ts");
			Object(b.a)({
				features: {
					comments: p.a
				},
				pages: {
					comments: f.a
				}
			});
			const m = (e, {
					commentsPageKey: t
				}) => e.pages.comments.api.error[t],
				_ = (e, {
					commentsPageKey: t
				}) => e.pages.comments.api.pending[t],
				O = (e, {
					commentsPageKey: t
				}) => e.pages.comments.api.fullyLoaded[t],
				j = (e, t) => e.pages.comments.keyToHeadCommentId[t.commentsPageKey],
				g = (e, t) => {
					const r = j(e, t);
					if (r) return Object(l.b)(e, {
						commentId: r
					})
				},
				I = [],
				S = Object(o.a)((e, t) => {
					const r = g(e, t),
						n = r && r.id;
					if (!n) return I;
					const {
						commentsPageKey: s
					} = t, i = e.pages.comments.keyToCommentThreadLinkSets[s], o = [];
					let c = {
						id: n,
						type: d.a.Comment
					};
					do {
						o.push(c), c = i[c.id].next
					} while (c);
					return o
				}),
				E = (e, t) => j(e, t) ? e.pages.comments.keyToChatCommentLinks[t.commentsPageKey] : [],
				y = (e, {
					commentsPageKey: t
				}) => {
					const r = e.pages.comments.keyToPostId[t];
					return r ? e.posts.models[r] : null
				},
				h = (e, {
					commentId: t,
					commentLink: r,
					commentsPageKey: n
				}) => {
					const s = e.pages.comments.keyToCommentThreadLinkSets[n];
					return s ? r ? s[r.id] : t ? s[t] : null : null
				},
				T = (e, {
					commentsPageKey: t
				}) => e.pages.comments.keyToCommentThreadLinkSets[t],
				v = (e, t) => {
					const r = t.commentsPageKey ? h(e, t) : null;
					return r ? r.depth : null
				},
				w = (e, {
					commentLink: t
				}) => {
					const {
						id: r,
						type: n
					} = t;
					switch (n) {
						case d.a.Comment:
							return e.features.comments.models[r];
						case d.a.MoreComments:
							return e.moreComments.models[r];
						case d.a.ContinueThread:
							return e.continueThreads.models[r];
						default:
							return null
					}
				},
				x = (e, t) => {
					if (e.platform.currentPage && e.platform.currentPage.urlParams && e.platform.currentPage.urlParams.partialPostId) {
						const {
							partialPostId: t
						} = e.platform.currentPage.urlParams, r = Object(a.t)(t);
						return Array.from(new Set(Object.keys(e.features.comments.models).filter(t => e.features.comments.models[t].postId === r && e.features.comments.models[t].author !== i.E).map(t => e.features.comments.models[t].author)))
					}
					return []
				},
				C = (e, {
					commentsPageKey: t
				}) => e.features.comments.collapsed[t],
				k = e => e.moreComments.models,
				D = e => e.features.comments.models,
				R = (e, {
					commentId: t
				}) => {
					const r = Object(l.b)(e, {
						commentId: t
					});
					return r ? Object(l.a)(e, r) : ""
				},
				A = (e, {
					commentId: t
				}) => !!(t && e.features.comments.focused && e.features.comments.focused[t]),
				N = (e, {
					commentId: t,
					commentsPageKey: r
				}) => !!(t && e.features.comments.isEditing[r] && e.features.comments.isEditing[r][t]),
				L = (e, {
					commentId: t,
					commentsPageKey: r
				}) => !!(t && e.features.comments.replyFormOpen[r] && e.features.comments.replyFormOpen[r][t]),
				P = (e, {
					commentsPageKey: t
				}) => {
					const r = t && e.features.comments.replyFormOpen[t] || {},
						n = Object.keys(r).find(e => r[e]),
						s = Object(l.b)(e, {
							commentId: n
						}),
						i = s && v(e, {
							commentId: s.id,
							commentLink: void 0,
							commentsPageKey: t
						});
					if (s && "number" == typeof i) return {
						...s,
						depth: i
					}
				},
				U = (e, {
					moreCommentsId: t
				}) => e.moreComments.models[t],
				G = (e, {
					moreCommentsId: t
				}) => !!e.moreComments.api.pending[t],
				F = (e, {
					commentsPageKey: t
				}) => {
					const r = e.pages.comments.keyToPostId[t];
					if (r) {
						const t = s()(e.moreComments.models).find(t => t.postId === r && 0 === t.depth && !(void 0 !== e.moreComments.api.pending[t.id]));
						if (t) return {
							moreCommentId: t.id,
							pending: !!e.moreComments.api.pending[t.id]
						}
					}
					return null
				},
				B = (e, {
					id: t
				}) => e.continueThreads.models[t],
				q = (e, {
					commentId: t
				}) => {
					const r = t ? e.features.comments.models[t] : void 0;
					if (!r) return null;
					const n = e.authorFlair.models[r.subredditId];
					return n ? n[r.author] : null
				},
				M = (e, {
					draftKey: t
				}) => !!e.features.comments.submit.error[t],
				Q = (e, {
					draftKey: t
				}) => {
					const r = e.features.comments.submit.error[t];
					return r && r.fields ? r.fields.map(e => e.msg) : []
				},
				K = (e, {
					draftKey: t
				}) => {
					const r = e.features.comments.drafts[t];
					return !!r && r.autofocusDisabled
				},
				W = (e, {
					draftKey: t
				}) => e.features.comments.drafts[t],
				H = (e, {
					commentId: t
				}) => {
					const r = t ? e.features.comments.submit.error[t] : void 0;
					return r && r.fields ? r.fields.map(e => e.msg) : void 0
				},
				z = (e, {
					commentId: t
				}) => !!t && e.features.comments.submit.pending[t],
				J = (e, {
					commentId: t
				}) => !!t && e.features.comments.models[t].sendReplies,
				$ = e => e.features.comments.visitHighlightFilter,
				V = (e, t) => {
					const r = Object(l.b)(e, t);
					if (r) return Object(u.W)(e, r)
				},
				Y = (e, {
					commentId: t
				}) => {
					var r, n;
					return !!((null === (n = null === (r = e.pages) || void 0 === r ? void 0 : r.comments) || void 0 === n ? void 0 : n.followed) || []).find(e => e.id === t)
				},
				X = (e, {
					commentId: t
				}) => {
					var r, n;
					const s = ((null === (n = null === (r = e.pages) || void 0 === r ? void 0 : r.comments) || void 0 === n ? void 0 : n.followed) || []).find(e => e.id === t);
					return !!(s && s.expiresAt < Date.now())
				},
				Z = (e, {
					commentId: t
				}) => {
					let r = Object(l.b)(e, {
						commentId: t
					});
					for (; r && r.parentId;) {
						if (Object(c.g)(r)) return !0;
						if ((r = Object(l.b)(e, {
								commentId: r.parentId
							})) && Object(c.g)(r)) return !0
					}
					return !1
				}
		},
		"./src/reddit/selectors/downToChat.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return n
			})), r.d(t, "c", (function() {
				return s
			})), r.d(t, "a", (function() {
				return i
			}));
			const n = (e, t) => e.chat.downToChat.subreddits[t] && e.chat.downToChat.subreddits[t].bannerEnabled,
				s = (e, t) => e.chat.downToChat.subreddits[t] && e.chat.downToChat.subreddits[t].buttonEnabled,
				i = (e, t) => !!e.chat.downToChat.subreddits[t]
		},
		"./src/reddit/selectors/experiments/cnc/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return a
			})), r.d(t, "a", (function() {
				return u
			}));
			var n = r("./src/reddit/constants/experiments.ts"),
				s = r("./src/reddit/helpers/chooseVariant/index.ts"),
				i = r("./src/reddit/selectors/moderatorPermissions.ts"),
				o = r("./src/reddit/selectors/platform.ts"),
				d = r("./src/reddit/selectors/subreddit.ts"),
				c = r("./src/reddit/selectors/user.ts");
			const a = e => {
					const t = Object(s.c)(e, {
						experimentEligibilitySelector: s.a,
						experimentName: n.Hd
					});
					return !(!t || Object(n.tf)(t))
				},
				u = (e, t) => {
					var r;
					const n = Object(o.e)(e),
						s = t || n && Object(d.C)(e, n.name);
					return !!s && (!!(null === (r = Object(i.m)(e, {
						subredditId: s
					})) || void 0 === r ? void 0 : r.access) && l(e))
				},
				l = e => {
					const t = Object(s.c)(e, {
						experimentEligibilitySelector: c.K,
						experimentName: n.Gd
					});
					return !(!t || Object(n.tf)(t))
				}
		},
		"./src/reddit/selectors/experiments/crosspostRecommendations.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return b
			})), r.d(t, "d", (function() {
				return p
			})), r.d(t, "c", (function() {
				return f
			})), r.d(t, "a", (function() {
				return m
			})), r.d(t, "e", (function() {
				return _
			}));
			var n = r("./src/lib/isUrl/index.ts"),
				s = r("./src/reddit/components/CrosspostRecommendationsModal/constants.tsx"),
				i = r("./src/reddit/constants/experiments.ts"),
				o = r("./src/reddit/helpers/chooseVariant/index.ts"),
				d = r("./src/reddit/helpers/isCrosspost.ts"),
				c = r("./src/reddit/models/Media/index.ts"),
				a = r("./src/reddit/selectors/activeModal.ts"),
				u = r("./src/reddit/selectors/experiments/index.ts"),
				l = r("./src/reddit/selectors/posts.ts");
			const b = e => {
					return Object(o.c)(e, {
						experimentEligibilitySelector: u.e,
						experimentName: i.fe
					}) === i.Zc
				},
				p = e => !e.media || e.media.type !== c.o.RTJSON && e.media.type !== c.o.TEXT ? "" : e.media.markdownContent,
				f = e => !e.media && e.source && Object(n.a)(e.source.url) ? e.source.displayText : "",
				m = (e, t) => {
					const r = Object(l.G)(e, {
						postId: t
					});
					return r && !r.isSponsored && r.isCrosspostable && !Object(d.a)(r) && Object(a.c)(s.a)(e)
				},
				_ = e => {
					var t;
					return !!(null === (t = e.features) || void 0 === t ? void 0 : t.shouldTryToShowCrosspostModal)
				}
		},
		"./src/reddit/selectors/experiments/econ/powerupsAward.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return d
			})), r.d(t, "b", (function() {
				return c
			}));
			var n = r("./node_modules/reselect/es/index.js"),
				s = r("./src/reddit/constants/experiments.ts"),
				i = r("./src/reddit/helpers/chooseVariant/index.ts"),
				o = r("./src/reddit/selectors/user.ts");
			const d = e => Object(i.c)(e, {
					experimentName: s.Dc,
					experimentEligibilitySelector: o.K
				}),
				c = Object(n.a)(d, e => e === s.fd.Community || e === s.fd.Supporter)
		},
		"./src/reddit/selectors/experiments/gqlSubredditPage.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return i
			})), r.d(t, "a", (function() {
				return o
			}));
			var n = r("./src/reddit/constants/experiments.ts"),
				s = r("./src/reddit/helpers/chooseVariant/index.ts");
			const i = e => Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: n.sb
				}) === n.Yb.Enabled,
				o = e => Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: n.rb
				}) === n.Xb.Enabled
		},
		"./src/reddit/selectors/experiments/postCreationSubRec.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return u
			})), r.d(t, "f", (function() {
				return l
			})), r.d(t, "k", (function() {
				return b
			})), r.d(t, "j", (function() {
				return p
			})), r.d(t, "g", (function() {
				return f
			})), r.d(t, "h", (function() {
				return m
			})), r.d(t, "i", (function() {
				return _
			})), r.d(t, "e", (function() {
				return O
			})), r.d(t, "c", (function() {
				return j
			})), r.d(t, "b", (function() {
				return g
			})), r.d(t, "d", (function() {
				return I
			})), r.d(t, "m", (function() {
				return S
			})), r.d(t, "l", (function() {
				return E
			})), r.d(t, "n", (function() {
				return y
			}));
			var n = r("./src/lib/constants/index.ts"),
				s = r("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				i = r("./src/reddit/constants/experiments.ts"),
				o = r("./src/reddit/helpers/chooseVariant/index.ts"),
				d = r("./src/reddit/models/PostCreationForm/index.ts"),
				c = r("./src/reddit/models/SubredditAutocomplete/index.ts"),
				a = r("./src/reddit/selectors/subreddit.ts");
			const u = 3,
				l = e => {
					const t = Object(o.c)(e, {
						experimentEligibilitySelector: o.a,
						experimentName: i.ge
					});
					return t === i.he.UIChangesOnly || t === i.he.RedditRecommendation || t === i.he.OpenAI || t === i.he.FilteredOpenAI
				},
				b = e => {
					return Object(o.c)(e, {
						experimentEligibilitySelector: o.a,
						experimentName: i.ge
					}) === i.he.UIChangesOnly
				},
				p = e => {
					return Object(o.c)(e, {
						experimentEligibilitySelector: o.a,
						experimentName: i.ge
					}) === i.he.RedditRecommendation
				},
				f = e => {
					return Object(o.c)(e, {
						experimentEligibilitySelector: o.a,
						experimentName: i.ge
					}) === i.he.OpenAI
				},
				m = e => {
					return Object(o.c)(e, {
						experimentEligibilitySelector: o.a,
						experimentName: i.ge
					}) === i.he.FilteredOpenAI
				},
				_ = e => e.creations.subredditRec.api.pending,
				O = e => e.creations.subredditRec.api.error,
				j = e => {
					return e.creations.subredditRec.order.length > 0
				},
				g = e => {
					const t = e.creations.subredditRec.order,
						r = [];
					return t.forEach(t => {
						const n = Object(a.t)(e, {
								subredditName: t
							}),
							s = Object(a.w)(e, {
								subredditName: t
							});
						if (s && n) {
							const e = {
								iconUrl: s.icon.url,
								name: s.name,
								primaryColor: s.primaryColor,
								subscribers: n.subscribers,
								type: c.a.OTHER_SUBREDDIT
							};
							r.push(e)
						}
					}), r
				},
				I = e => e.creations.subredditRec.isInputChanged,
				S = e => {
					if (!(e.creations.formData.submissionType === n.Wb.POST)) return "";
					const t = e.creations.formState.editorMode === d.i.RICH_TEXT || null === e.creations.formState.editorMode,
						r = e.creations.formState.editorMode === d.i.MARKDOWN;
					if (t) {
						const t = e.creations.formData.body.rte;
						return s.a.getRawText(t, " ") || ""
					}
					return r && e.creations.formData.body.markdown || ""
				},
				E = e => {
					return e.creations.formData.submissionType === n.Wb.LINK_ONLY && e.creations.formData.body.link || ""
				},
				y = e => !b(e) && l(e) && (!O(e) || O(e) && I(e)) && (e => {
					const t = e.creations.formData.title,
						r = E(e),
						n = S(e);
					return !!(t || r || n)
				})(e) && (e.creations.formData.submissionType === n.Wb.POST || e.creations.formData.submissionType === n.Wb.LINK_ONLY || e.creations.formData.submissionType === n.Wb.CROSSPOST)
		},
		"./src/reddit/selectors/experiments/publicAccessNetwork.ts": function(e, t, r) {
			"use strict";
			r.d(t, "d", (function() {
				return i
			})), r.d(t, "a", (function() {
				return o
			})), r.d(t, "f", (function() {
				return d
			})), r.d(t, "g", (function() {
				return c
			})), r.d(t, "i", (function() {
				return a
			})), r.d(t, "h", (function() {
				return u
			})), r.d(t, "e", (function() {
				return l
			})), r.d(t, "b", (function() {
				return b
			})), r.d(t, "c", (function() {
				return p
			}));
			var n = r("./src/reddit/constants/experiments.ts"),
				s = r("./src/reddit/helpers/chooseVariant/index.ts");
			const i = e => n.ye.Enabled === Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: n.Fe
				}),
				o = e => n.ye.Enabled === Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: n.re
				}),
				d = e => n.Ye.Enabled === Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: n.Ne
				}),
				c = (e, t, r) => {
					const i = r(e, t);
					return !(!i || !i.meter) && (i.meter.enabled && d(e) && n.kf.Enabled === Object(s.c)(e, {
						experimentEligibilitySelector: s.a,
						experimentName: n.jf
					}))
				},
				a = e => Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: n.Ee
				}),
				u = e => {
					switch (e) {
						case n.Je.Five:
							return .05;
						case n.Je.Ten:
							return .1;
						case n.Je.Fifty:
							return .5;
						default:
							return .01
					}
				},
				l = e => n.ye.Enabled === Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: n.Ge
				}),
				b = e => n.ye.Enabled === Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: n.Ce
				}),
				p = e => n.ye.Enabled === Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: n.De
				})
		},
		"./src/reddit/selectors/experiments/topPosts.ts": function(e, t, r) {
			"use strict";
			r.d(t, "d", (function() {
				return a
			})), r.d(t, "a", (function() {
				return u
			})), r.d(t, "b", (function() {
				return l
			})), r.d(t, "c", (function() {
				return b
			}));
			var n = r("./node_modules/reselect/es/index.js"),
				s = r("./src/reddit/constants/experiments.ts"),
				i = r("./src/reddit/contexts/PageLayer/index.tsx"),
				o = r("./src/reddit/helpers/chooseVariant/index.ts"),
				d = r("./src/reddit/selectors/user.ts");
			const c = Object(n.a)(d.K, (e, {
					pageLayer: t
				}) => Object(i.A)(t), (e, {
					pageLayer: t
				}) => Object(i.N)(t), (e, t, r) => !e && !t && r),
				a = Object(n.a)((e, t) => Object(o.c)(e, {
					experimentName: s.jc,
					experimentEligibilitySelector: e => c(e, t)
				}), e => e),
				u = e => e === s.gf.NoCommunityWidgets,
				l = e => e === s.gf.NoRulesModerators,
				b = e => e === s.gf.RelatedPostsDu
		},
		"./src/reddit/selectors/externalAccount.ts": function(e, t, r) {
			"use strict";
			r.d(t, "d", (function() {
				return o
			})), r.d(t, "a", (function() {
				return c
			})), r.d(t, "b", (function() {
				return a
			})), r.d(t, "c", (function() {
				return u
			}));
			var n = r("./src/reddit/models/ExternalAccount/index.ts"),
				s = r("./src/reddit/models/User/index.ts"),
				i = r("./src/reddit/selectors/user.ts");
			const o = (e, {
					username: t
				}) => !!e.externalAccount.api.user.pending[t],
				d = (e, {
					username: t
				}) => e.externalAccount.user[t],
				c = e => {
					const t = Object(i.k)(e);
					if (!t) return;
					const r = Object(s.e)(t),
						n = d(e, {
							username: r
						});
					return n ? n.twitter : void 0
				},
				a = e => !!e.externalAccount.api.connect.pending[n.a.Twitter],
				u = (e, {
					profileName: t
				}) => {
					if (!t) return null;
					const r = d(e, {
						username: t
					});
					if (!r) return null;
					const o = r[n.a.Twitter];
					if (!o) return null;
					const c = Object(i.k)(e);
					if (!(c && Object(s.e)(c).toLowerCase() === t.toLowerCase())) return o;
					const a = Object(i.sb)(e, {
						userName: t
					});
					return a ? a.prefShowTwitter ? o : null : o
				}
		},
		"./src/reddit/selectors/features/predictions/creation/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return o
			})), r.d(t, "a", (function() {
				return d
			}));
			var n = r("./src/lib/initializeClient/installReducer.ts"),
				s = r("./src/reddit/reducers/features/predictions/index.ts"),
				i = r("./src/reddit/selectors/postCreations.ts");
			Object(n.a)({
				features: {
					predictions: s.a
				}
			});
			const o = e => {
					const t = (e => {
						var t, r;
						return null === (r = null === (t = e.features) || void 0 === t ? void 0 : t.predictions) || void 0 === r ? void 0 : r.creation
					})(e);
					return (null == t ? void 0 : t.length) ? null == t ? void 0 : t.map(t => {
						const r = Object(i.eb)({
								...e,
								creations: {
									...e.creations,
									formData: t.formData,
									formState: t.formState
								}
							}, {}),
							n = t.formData.polls,
							s = n.options.map(e => ({
								text: e.text
							})),
							o = {};
						return r.document ? o.richText = JSON.stringify({
							document: r.document
						}) : r.markdown && (o.markdown = r.markdown), {
							title: r.title,
							isLiveChat: r.isChatPost,
							isNsfw: r.isNSFW,
							isSpoiler: r.isSpoiler,
							votingEndsAt: n.endDate.toISOString(),
							body: o,
							options: s
						}
					}) : []
				},
				d = e => {
					var t, r;
					return !!(null === (r = null === (t = e.features) || void 0 === t ? void 0 : t.predictions) || void 0 === r ? void 0 : r.creation.length)
				}
		},
		"./src/reddit/selectors/features/predictions/leaderboards/index.ts": function(e, t, r) {
			"use strict";
			r.d(t, "c", (function() {
				return i
			})), r.d(t, "b", (function() {
				return o
			})), r.d(t, "a", (function() {
				return d
			})), r.d(t, "d", (function() {
				return c
			})), r.d(t, "h", (function() {
				return a
			})), r.d(t, "g", (function() {
				return u
			})), r.d(t, "f", (function() {
				return l
			})), r.d(t, "e", (function() {
				return b
			}));
			var n = r("./src/lib/initializeClient/installReducer.ts"),
				s = r("./src/reddit/reducers/features/predictions/index.ts");
			Object(n.a)({
				features: {
					predictions: s.a
				}
			});
			const i = (e, t) => {
					var r, n, s;
					return (null === (s = null === (n = null === (r = e.features) || void 0 === r ? void 0 : r.predictions) || void 0 === n ? void 0 : n.leaderboards[t.subredditId]) || void 0 === s ? void 0 : s.isFetching) || !1
				},
				o = (e, t) => {
					var r, n, s;
					return (null === (s = null === (n = null === (r = e.features) || void 0 === r ? void 0 : r.predictions) || void 0 === n ? void 0 : n.leaderboards[t.subredditId]) || void 0 === s ? void 0 : s.isFetched) || !1
				},
				d = (e, t) => {
					var r, n, s;
					return (null === (s = null === (n = null === (r = e.features) || void 0 === r ? void 0 : r.predictions) || void 0 === n ? void 0 : n.leaderboards[t.subredditId]) || void 0 === s ? void 0 : s.error) || !1
				},
				c = (e, t) => {
					var r, n, s;
					return (null === (s = null === (n = null === (r = e.features) || void 0 === r ? void 0 : r.predictions) || void 0 === n ? void 0 : n.leaderboards[t.subredditId]) || void 0 === s ? void 0 : s.data) || null
				},
				a = (e, t) => {
					var r, n;
					return (null === (n = null === (r = e.features) || void 0 === r ? void 0 : r.predictions) || void 0 === n ? void 0 : n.tournamentsLeaderboards[t.tournamentId]) || null
				},
				u = (e, t) => {
					var r, n, s;
					return (null === (s = null === (n = null === (r = e.features) || void 0 === r ? void 0 : r.predictions) || void 0 === n ? void 0 : n.queriedLeaderboards[t.tournamentId]) || void 0 === s ? void 0 : s.isFetching) || !1
				},
				l = (e, t) => {
					var r, n, s;
					return (null === (s = null === (n = null === (r = e.features) || void 0 === r ? void 0 : r.predictions) || void 0 === n ? void 0 : n.queriedLeaderboards[t.tournamentId]) || void 0 === s ? void 0 : s.isFetched) || !1
				},
				b = (e, t) => {
					var r, n, s;
					return (null === (s = null === (n = null === (r = e.features) || void 0 === r ? void 0 : r.predictions) || void 0 === n ? void 0 : n.queriedLeaderboards[t.tournamentId]) || void 0 === s ? void 0 : s.error) || !1
				}
		},
		"./src/reddit/selectors/gold/powerups/benefitSettings.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return a
			})), r.d(t, "b", (function() {
				return u
			}));
			var n = r("./src/reddit/models/Gold/Powerups/index.ts"),
				s = r("./src/lib/initializeClient/installReducer.ts"),
				i = r("./src/reddit/actions/gold/constants.ts");
			const o = {};
			var d = (e = o, t) => {
					var r, n;
					switch (t.type) {
						case i.pb:
						case i.qb: {
							const {
								benefitStatuses: n,
								subredditId: s
							} = t.payload;
							if (!n) return e;
							const i = null !== (r = e[s]) && void 0 !== r ? r : {},
								o = {};
							return n.forEach(({
								benefit: e,
								isEnabled: t
							}) => {
								o[e] = t
							}), {
								...e,
								[s]: {
									...i,
									...o
								}
							}
						}
						case i.N: {
							const {
								benefitStatuses: r,
								subredditId: s
							} = t.payload, i = null !== (n = e[s]) && void 0 !== n ? n : {}, o = {};
							return r.forEach(({
								benefit: e,
								isEnabled: t
							}) => {
								o[e] = t
							}), {
								...e,
								[s]: {
									...i,
									...o
								}
							}
						}
						default:
							return e
					}
				},
				c = r("./node_modules/reselect/es/index.js");
			Object(s.a)({
				features: {
					powerupsBenefitSettings: d
				}
			});
			const a = (e, {
					subredditId: t
				}) => t ? e.features.powerupsBenefitSettings[t] : null,
				u = (e => Object(c.a)(a, t => !!(null == t ? void 0 : t[e])))(n.a.CommentsWithGifs)
		},
		"./src/reddit/selectors/inlineSubredditEditing.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return i
			})), r.d(t, "b", (function() {
				return o
			}));
			var n = r("./src/reddit/featureFlags/index.ts"),
				s = r("./src/reddit/selectors/moderatorPermissions.ts");
			const i = (e, {
					subredditId: t
				}) => {
					if (!n.d.subredditInlineEditing(e)) return !1;
					const r = t ? Object(s.m)(e, {
						subredditId: t
					}) : null;
					return !!r && (e => !!e && e.config)(r)
				},
				o = e => e.subreddits.api.inlineEditing.pending
		},
		"./src/reddit/selectors/moderatingComments.ts": function(e, t, r) {
			"use strict";
			r.d(t, "b", (function() {
				return n
			})), r.d(t, "a", (function() {
				return s
			}));
			const n = (e, {
					commentId: t,
					commentsPageKey: r
				}) => {
					if (!t) return !1;
					if (e.features.comments.collapsed[r] && t in e.features.comments.collapsed[r]) return !!e.features.comments.collapsed[r][t];
					const n = e.features.comments.models[t];
					return !!n && ("computedCollapsed" in n ? !!n.computedCollapsed : n.collapsedBecauseCrowdControl ? !e.modModeEnabled : n.collapsed)
				},
				s = (e, {
					commentId: t
				}) => {
					if (!t) return !1;
					const r = e.features.comments.models[t];
					return !(!r || !r.collapsedBecauseCrowdControl) && e.modModeEnabled
				}
		},
		"./src/reddit/selectors/seo/linksModule.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return i
			})), r.d(t, "b", (function() {
				return c
			})), r.d(t, "c", (function() {
				return a
			}));
			var n = r("./node_modules/reselect/es/index.js"),
				s = r("./src/reddit/selectors/user.ts");
			const i = e => !Object(s.K)(e) && e.seo.linksModule.frontpage || null,
				o = e => {
					const t = e.split("/");
					if ("r" === t[1]) return t[2]
				},
				d = Object(n.a)(i, e => e ? e.map(e => ({
					...e,
					links: e.links.map(e => ({
						...e,
						title: o(e.url)
					})).filter(e => e.title)
				})) : null),
				c = Object(n.a)(d, e => e ? e.map(e => ({
					...e,
					links: e.links.filter(e => e.visible)
				})) : null),
				a = (e, {
					subredditId: t
				}) => {
					const r = ((e, {
						subredditId: t
					}) => e.seo.linksModule.subreddits && e.seo.linksModule.subreddits[t])(e, {
						subredditId: t
					});
					return r && r.subreddits
				}
		},
		"./src/reddit/selectors/seo/topicLinks.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return n
			}));
			const n = (e, {
				subredditId: t
			}) => e.seo.topicLinks.subreddits && e.seo.topicLinks.subreddits[t]
		},
		"./src/reddit/selectors/tags.ts": function(e, t, r) {
			"use strict";
			r.d(t, "f", (function() {
				return l
			})), r.d(t, "e", (function() {
				return b
			})), r.d(t, "g", (function() {
				return p
			})), r.d(t, "n", (function() {
				return f
			})), r.d(t, "A", (function() {
				return m
			})), r.d(t, "B", (function() {
				return _
			})), r.d(t, "i", (function() {
				return O
			})), r.d(t, "j", (function() {
				return j
			})), r.d(t, "l", (function() {
				return I
			})), r.d(t, "r", (function() {
				return S
			})), r.d(t, "t", (function() {
				return E
			})), r.d(t, "p", (function() {
				return v
			})), r.d(t, "b", (function() {
				return w
			})), r.d(t, "d", (function() {
				return C
			})), r.d(t, "c", (function() {
				return k
			})), r.d(t, "o", (function() {
				return D
			})), r.d(t, "k", (function() {
				return R
			})), r.d(t, "z", (function() {
				return A
			})), r.d(t, "y", (function() {
				return N
			})), r.d(t, "u", (function() {
				return L
			})), r.d(t, "a", (function() {
				return P
			})), r.d(t, "q", (function() {
				return U
			})), r.d(t, "C", (function() {
				return G
			})), r.d(t, "w", (function() {
				return F
			})), r.d(t, "s", (function() {
				return q
			})), r.d(t, "x", (function() {
				return M
			})), r.d(t, "h", (function() {
				return Q
			})), r.d(t, "v", (function() {
				return K
			})), r.d(t, "D", (function() {
				return W
			})), r.d(t, "m", (function() {
				return H
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/lodash/some.js"),
				s = r.n(n),
				i = r("./node_modules/lodash/values.js"),
				o = r.n(i),
				d = r("./src/lib/objectSelector/index.ts"),
				c = r("./src/reddit/helpers/tags/index.ts"),
				a = r("./src/reddit/models/Tags/index.ts");
			const u = e => e.tags.creation.selectedOptions || [],
				l = e => {
					const t = [];
					for (let r = 0; r < u(e).length; r++) u(e)[r].id && t.push(u(e)[r].id);
					return t || []
				},
				b = e => (u(e) || []).filter(e => !!e.displayText).map(e => e.displayText),
				p = e => {
					const t = [];
					for (let r = 0; r < u(e).length; r++) u(e)[r].id || t.push(u(e)[r].displayText);
					return t || []
				},
				f = e => Object.keys(e.tags.models.globalSubredditTags).length > 0,
				m = e => e.tags.api.create.error || e.tags.api.deleteTag.error || e.tags.api.fetch.error || e.tags.api.update.error,
				_ = e => e.tags.api.create.pending || e.tags.api.deleteTag.pending || e.tags.api.fetch.pending || e.tags.api.update.pending,
				O = (e, {
					subredditId: t
				}) => e.tags.selected.inputByItemId[t] || "",
				j = (e, {
					subredditId: t
				}) => e.tags.selected.suggestedInputByItemId[t] || "",
				g = [],
				I = (e, {
					subredditId: t
				}) => s()(S(e, {
					subredditId: t
				}), e => !!e.action) || s()(y(e, {
					subredditId: t
				}), e => !!e.action),
				S = (e, {
					subredditId: t
				}) => e.tags.selected.selectedOptions[t] || g,
				E = (e, {
					subredditId: t
				}) => e.tags.selected.selectedSuggestedOptions[t] || g,
				y = (e, {
					subredditId: t
				}) => e.tags.selected.deselectedOptions[t] || g,
				h = {},
				T = {},
				v = e => e.tags.availableGlobalTagOrder.recommendedGlobal.map(t => e.tags.models.globalSubredditTags[t]),
				w = e => e.tags.models.globalSubredditTags,
				x = e => e.tags.availableGlobalTagOrder.global.map(t => e.tags.models.globalSubredditTags[t]),
				C = (e, {
					subredditId: t
				}) => e.tags.models.subredditScopedTags[t] || T,
				k = (e, t) => {
					const r = o()(t);
					for (let n = 0; n < r.length; n++)
						if (r[n].text.toLowerCase().trim() === e.toLowerCase().trim()) return r[n];
					return null
				},
				D = (e, {
					itemId: t
				}) => e.tags.models.itemTags[t] || h,
				R = (e, {
					itemId: t
				}) => !!e.tags.models.itemTags[t],
				A = (e, {
					itemId: t
				}) => e.tags.models.suggestedItemTags[t] || h,
				N = (e, {
					itemId: t
				}) => o()(A(e, {
					itemId: t
				})).filter(e => e.isRelevant).map(e => Object(a.e)(e, !0)),
				L = (e, {
					itemId: t
				}) => e.tags.models.sortedItemTags[t] || [],
				P = Object(d.a)((e, {
					thingId: t,
					suggested: r = !1
				}) => {
					const n = F(e, {
						subredditId: t
					});
					return o()(((e, {
						thingId: t,
						suggested: r = !1
					}) => {
						const n = (r ? j(e, {
								subredditId: t
							}) : O(e, {
								subredditId: t
							})) ? x(e) : v(e),
							s = r ? E(e, {
								subredditId: t
							}) : S(e, {
								subredditId: t
							}),
							i = n.reduce((e, t) => (e[t.id] = Object(a.f)(t), e), {});
						return s.reduce((e, t) => (t.id && e[t.id] && (e[t.id].selected = !0), e), i)
					})(e, {
						thingId: t,
						suggested: r
					})).filter(e => !e.selected && e.id !== n)
				}),
				U = (e, {
					subredditId: t
				}) => S(e, {
					subredditId: t
				}).concat(y(e, {
					subredditId: t
				})),
				G = (e, {
					subredditId: t
				}) => S(e, {
					subredditId: t
				}).filter(c.b).map(e => ({
					text: e.displayText,
					type: a.c.CLASSIFICATION
				})),
				F = (e, {
					subredditId: t
				}) => e.tags.models.subredditPrimaryTagId[t] || null,
				B = (e, t) => t && e.tags.models.globalSubredditTags[t] || null,
				q = (e, t) => {
					const r = e.tags.selected.selectedPrimaryTagId[t.subredditId] || null;
					return B(e, r)
				},
				M = (e, t) => {
					const r = F(e, t);
					return B(e, r)
				},
				Q = e => e.tags.creation.selectedPrimaryTagId || null,
				K = e => {
					const t = Q(e);
					return B(e, t)
				},
				W = e => e.tags.api.updatePrimaryTag.pending,
				H = (e, {
					subredditId: t
				}) => Object.keys(D(e, {
					itemId: t
				})).length > 0
		},
		"./src/reddit/selectors/tooltip.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return n
			})), r.d(t, "b", (function() {
				return s
			}));
			const n = e => e.tooltipId,
				s = e => t => t.tooltipId === e
		},
		"./src/reddit/selectors/userFlair.ts": function(e, t, r) {
			"use strict";
			r.d(t, "d", (function() {
				return a
			})), r.d(t, "a", (function() {
				return u
			})), r.d(t, "e", (function() {
				return l
			})), r.d(t, "f", (function() {
				return b
			})), r.d(t, "b", (function() {
				return p
			})), r.d(t, "c", (function() {
				return f
			}));
			var n = r("./src/lib/objectSelector/index.ts"),
				s = r("./src/reddit/models/Flair/index.ts"),
				i = r("./src/reddit/selectors/gold/powerups/index.ts"),
				o = r("./src/reddit/selectors/moderatorPermissions.ts"),
				d = r("./src/lib/initializeClient/installReducer.ts"),
				c = r("./src/reddit/reducers/features/userFlair/index.ts");
			Object(d.a)({
				features: {
					userFlair: c.a
				}
			});
			const a = (e, {
					subredditId: t
				}) => e.features.userFlair[t],
				u = (e, {
					subredditId: t
				}) => {
					var r, n;
					return null === (r = e.features.userFlair[t]) || void 0 === r || !r.displaySettings || !!(null === (n = e.features.userFlair[t].displaySettings) || void 0 === n ? void 0 : n.isEnabled)
				},
				l = (e, {
					subredditId: t
				}) => {
					var r, n;
					return (null === (r = e.features.userFlair[t]) || void 0 === r ? void 0 : r.displaySettings) ? null === (n = e.features.userFlair[t].displaySettings) || void 0 === n ? void 0 : n.position : s.b.Right
				},
				b = Object(n.a)((e, {
					subredditId: t
				}) => {
					const r = a(e, {
						subredditId: t
					});
					if (r && r.displaySettings && r.permissions) return {
						type: s.d.UserFlair,
						displaySettings: r.displaySettings,
						permissions: r.permissions
					}
				}),
				p = (e, {
					subredditId: t
				}) => {
					const r = u(e, {
							subredditId: t
						}),
						n = b(e, {
							subredditId: t
						}),
						s = a(e, {
							subredditId: t
						});
					if (!r || !n || !s) return !1;
					if (s.applied) return !0;
					const i = Object(o.g)(e, {
							subredditId: t
						}),
						{
							canUserChange: d
						} = n.permissions;
					return !!(s.templateIds || []).find(e => {
						return !s.templates[e].modOnly || i
					}) && d
				},
				f = (e, {
					subredditId: t
				}) => {
					if (!t) return !1;
					const r = p(e, {
							subredditId: t
						}),
						n = Object(i.h)(e, {
							subredditId: t
						});
					return r || n
				}
		},
		"./src/reddit/selectors/widgets.ts": function(e, t, r) {
			"use strict";
			r.d(t, "a", (function() {
				return u
			})), r.d(t, "k", (function() {
				return l
			})), r.d(t, "c", (function() {
				return b
			})), r.d(t, "d", (function() {
				return p
			})), r.d(t, "i", (function() {
				return f
			})), r.d(t, "e", (function() {
				return m
			})), r.d(t, "f", (function() {
				return _
			})), r.d(t, "j", (function() {
				return O
			})), r.d(t, "h", (function() {
				return j
			})), r.d(t, "g", (function() {
				return g
			})), r.d(t, "b", (function() {
				return I
			}));
			var n = r("./src/lib/objectSelector/index.ts"),
				s = r("./src/reddit/constants/posts.ts"),
				i = r("./src/reddit/helpers/name/index.ts"),
				o = r("./src/reddit/helpers/widgets/index.tsx"),
				d = r("./src/reddit/selectors/profile.ts"),
				c = r("./src/reddit/selectors/subreddit.ts");
			const a = [],
				u = e => e.widgets.models,
				l = Object(n.a)((e, t) => Object(o.l)(t) ? e.widgets.models[t.widgetId] : Object(o.f)(t.widgetKind)),
				b = (e, t) => e.widgets.idCardIds[t.subredditId],
				p = (e, t) => {
					let r = t.subredditId;
					if (!r && t.subredditName && (r = Object(c.C)(e, t.subredditName)), r) {
						const t = b(e, {
							subredditId: r
						});
						if (t) return e.widgets.models[t]
					}
					return null
				},
				f = (e, t) => e.widgets.sidebar[t.subredditId] || [],
				m = (e, t) => e.widgets.menuIds[t.subredditId],
				_ = (e, t) => {
					const r = m(e, t);
					return r ? e.widgets.models[r] : null
				},
				O = (e, t) => {
					const r = e.widgets.sidebar[t.subredditId];
					return Array.isArray(r) ? r.reduce((t, r) => {
						const n = e.widgets.models[r];
						return n && t.push(n.kind), t
					}, []) : a
				},
				j = (e, t) => {
					const r = f(e, t);
					for (const n of r) {
						const t = e.widgets.models[n];
						if ("subreddit-rules" === t.kind) return t
					}
					return null
				},
				g = (e, t) => {
					const r = f(e, t).map(t => e.widgets.models[t]).filter(e => "post-flair" === e.kind);
					return r.length ? r : null
				},
				I = Object(n.a)((e, t) => {
					if (t.type === s.a.PROFILE) {
						const r = Object(d.j)(e, {
							profileName: t.name
						});
						return r ? {
							profile: {
								id: r.id,
								name: Object(i.g)(r.name)
							}
						} : {}
					}
					const r = Object(c.w)(e, {
							subredditName: t.name
						}),
						n = Object(c.t)(e, {
							subredditName: t.name
						});
					return {
						subreddit: {
							categoryName: n ? n.contentCategory : null,
							id: r.id,
							name: Object(i.g)(r.name)
						}
					}
				})
		},
		"./src/redditGQL/operations/AddPredictionDrafts.json": function(e) {
			e.exports = JSON.parse('{"id":"fe6eb1a90cfa"}')
		},
		"./src/redditGQL/operations/CancelPrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"fac88c91fec8"}')
		},
		"./src/redditGQL/operations/ChangePrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"614dbb8a54d2"}')
		},
		"./src/redditGQL/operations/ChangePredictionVote.json": function(e) {
			e.exports = JSON.parse('{"id":"90c7b71fa93f"}')
		},
		"./src/redditGQL/operations/CommentsPageLastAuthorModNotes.json": function(e) {
			e.exports = JSON.parse('{"id":"ef54c7e31a89"}')
		},
		"./src/redditGQL/operations/CreateCustomEmoji.json": function(e) {
			e.exports = JSON.parse('{"id":"e443629d50b0"}')
		},
		"./src/redditGQL/operations/CreatePredictionTournament.json": function(e) {
			e.exports = JSON.parse('{"id":"afca202bc19c"}')
		},
		"./src/redditGQL/operations/CreateSubredditTags.json": function(e) {
			e.exports = JSON.parse('{"id":"80c9a3cd96b8"}')
		},
		"./src/redditGQL/operations/DeleteCustomEmoji.json": function(e) {
			e.exports = JSON.parse('{"id":"c13d195ee7ca"}')
		},
		"./src/redditGQL/operations/EnablePowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"059b6d024156"}')
		},
		"./src/redditGQL/operations/EndPredictionTournament.json": function(e) {
			e.exports = JSON.parse('{"id":"bf8c4b396aa5"}')
		},
		"./src/redditGQL/operations/FetchContentControls.json": function(e) {
			e.exports = JSON.parse('{"id":"cc2540b31bea"}')
		},
		"./src/redditGQL/operations/FetchGlobalTags.json": function(e) {
			e.exports = JSON.parse('{"id":"f4a581740c21"}')
		},
		"./src/redditGQL/operations/FetchSubredditTags.json": function(e) {
			e.exports = JSON.parse('{"id":"bac623887684"}')
		},
		"./src/redditGQL/operations/FetchSubredditsNotificationSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"5d042135b4c5"}')
		},
		"./src/redditGQL/operations/GenerateCustomEmojiUploadLease.json": function(e) {
			e.exports = JSON.parse('{"id":"cbcafcbff9c6"}')
		},
		"./src/redditGQL/operations/GetPredictionChipPackages.json": function(e) {
			e.exports = JSON.parse('{"id":"5ce83e513fa5"}')
		},
		"./src/redditGQL/operations/GetPredictionCreationAllowance.json": function(e) {
			e.exports = JSON.parse('{"id":"d9fb5ec5128f"}')
		},
		"./src/redditGQL/operations/GetPredictionToken.json": function(e) {
			e.exports = JSON.parse('{"id":"26b911e67a5f"}')
		},
		"./src/redditGQL/operations/GetSubredditQuestions.json": function(e) {
			e.exports = JSON.parse('{"id":"15c4ad40a0bc"}')
		},
		"./src/redditGQL/operations/GetTournaments.json": function(e) {
			e.exports = JSON.parse('{"id":"a13ad5b63b13"}')
		},
		"./src/redditGQL/operations/GetTournamentsBaseInfo.json": function(e) {
			e.exports = JSON.parse('{"id":"cebfc8734cec"}')
		},
		"./src/redditGQL/operations/LiveVideoPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"b3343d9362cd"}')
		},
		"./src/redditGQL/operations/MaybeDeleteTagsAndUpdateItemTags.json": function(e) {
			e.exports = JSON.parse('{"id":"023547ccdaf6"}')
		},
		"./src/redditGQL/operations/ModQueueItems.json": function(e) {
			e.exports = JSON.parse('{"id":"e848351166d5"}')
		},
		"./src/redditGQL/operations/ModQueueTriggers.json": function(e) {
			e.exports = JSON.parse('{"id":"de8696c3b5fd"}')
		},
		"./src/redditGQL/operations/OpenAISubredditRecommendation.json": function(e) {
			e.exports = JSON.parse('{"id":"ff1b10cffcc8"}')
		},
		"./src/redditGQL/operations/ReallocatePowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"d02bf38ca840"}')
		},
		"./src/redditGQL/operations/RedditorPowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"e2bcd0fbaace"}')
		},
		"./src/redditGQL/operations/ReportMessage.json": function(e) {
			e.exports = JSON.parse('{"id":"ae01229e1caa"}')
		},
		"./src/redditGQL/operations/ResolvePrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"d742e3019cfe"}')
		},
		"./src/redditGQL/operations/SubredditAbout.json": function(e) {
			e.exports = JSON.parse('{"id":"8c1affff4f18"}')
		},
		"./src/redditGQL/operations/SubredditFlairedRedditorByName.json": function(e) {
			e.exports = JSON.parse('{"id":"11aba1560164"}')
		},
		"./src/redditGQL/operations/SubredditFlairedRedditors.json": function(e) {
			e.exports = JSON.parse('{"id":"d343c3cad2d0"}')
		},
		"./src/redditGQL/operations/SubredditInfo.json": function(e) {
			e.exports = JSON.parse('{"id":"29aee4089528"}')
		},
		"./src/redditGQL/operations/SubredditPage.json": function(e) {
			e.exports = JSON.parse('{"id":"52bd589d8f78"}')
		},
		"./src/redditGQL/operations/SubredditPageExtra.json": function(e) {
			e.exports = JSON.parse('{"id":"054754a36aad"}')
		},
		"./src/redditGQL/operations/SubredditPowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"8d2145ac1ec5"}')
		},
		"./src/redditGQL/operations/SubredditPowerupsFull.json": function(e) {
			e.exports = JSON.parse('{"id":"5ef02d19b2e0"}')
		},
		"./src/redditGQL/operations/SubredditRules.json": function(e) {
			e.exports = JSON.parse('{"id":"c398abb500f1"}')
		},
		"./src/redditGQL/operations/SubredditTopPredictors.json": function(e) {
			e.exports = JSON.parse('{"id":"a9f7697930b7"}')
		},
		"./src/redditGQL/operations/SubredditTournamentLeaderboard.json": function(e) {
			e.exports = JSON.parse('{"id":"e14e6d1892e6"}')
		},
		"./src/redditGQL/operations/SubredditsPowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"1cd60899cb27"}')
		},
		"./src/redditGQL/operations/TopAwardedPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"723959a1026d"}')
		},
		"./src/redditGQL/operations/TopAwardersLeaderboard.json": function(e) {
			e.exports = JSON.parse('{"id":"750ff4a757de"}')
		},
		"./src/redditGQL/operations/UpdateCommentDistinguishState.json": function(e) {
			e.exports = JSON.parse('{"id":"e1f407c8ceba"}')
		},
		"./src/redditGQL/operations/UpdateCommentStickyState.json": function(e) {
			e.exports = JSON.parse('{"id":"236938d65d55"}')
		},
		"./src/redditGQL/operations/UpdateHatefulContentFilters.json": function(e) {
			e.exports = JSON.parse('{"id":"0f2f2af43b20"}')
		},
		"./src/redditGQL/operations/UpdatePostRequirements.json": function(e) {
			e.exports = JSON.parse('{"id":"8732ab4560ce"}')
		},
		"./src/redditGQL/operations/UpdatePowerupsSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"699ae1616006"}')
		},
		"./src/redditGQL/operations/UpdatePredictionTournament.json": function(e) {
			e.exports = JSON.parse('{"id":"ae1a756dd494"}')
		},
		"./src/redditGQL/operations/UpdateSubredditNotificationSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"0af4f630a2e1"}')
		},
		"./src/redditGQL/operations/UpdateSubredditPrimaryTag.json": function(e) {
			e.exports = JSON.parse('{"id":"a2d0aa1efdbc"}')
		},
		"./src/redditGQL/operations/UpdateSubredditTagStatesRelevance.json": function(e) {
			e.exports = JSON.parse('{"id":"ee43ccb6e5eb"}')
		},
		"./src/redditGQL/operations/UserPowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"5460e33eb672"}')
		},
		"./src/redditGQL/operations/VotePrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"484780ada6a2"}')
		},
		"./src/redditGQL/operations/WhereToPostSubRec.json": function(e) {
			e.exports = JSON.parse('{"id":"41255f023802"}')
		}
	}
]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/Governance~ModListing~Reddit~ReportFlow~Subreddit.23d9b7a90b766c6df9cb.js.map