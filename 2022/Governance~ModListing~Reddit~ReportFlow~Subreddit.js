// https://www.redditstatic.com/desktop2x/Governance~ModListing~Reddit~ReportFlow~Subreddit.21f977c4144c9d4f0d26.js
// Retrieved at 6/30/2022, 10:00:07 AM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["Governance~ModListing~Reddit~ReportFlow~Subreddit"], {
		"./src/lib/assertNever.ts": function(t, e, i) {
			"use strict";

			function n(t) {
				throw new Error(`Unexpected object: ${t}`)
			}
			i.d(e, "a", (function() {
				return n
			}))
		},
		"./src/lib/constants/icons.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			}));
			const n = {
				activity: "activity",
				activity_fill: "activity_fill",
				add: "add",
				add_fill: "add_fill",
				add_media: "add_media",
				add_media_fill: "add_media_fill",
				add_to_feed: "add_to_feed",
				add_to_feed_fill: "add_to_feed_fill",
				admin: "admin",
				admin_fill: "admin_fill",
				all: "all",
				all_fill: "all_fill",
				appearance: "appearance",
				appearance_fill: "appearance_fill",
				approve: "approve",
				approve_fill: "approve_fill",
				archived: "archived",
				archived_fill: "archived_fill",
				aspect_ratio: "aspect_ratio",
				aspect_ratio_fill: "aspect_ratio_fill",
				aspect_rectangle: "aspect_rectangle",
				aspect_rectangle_fill: "aspect_rectangle_fill",
				attach: "attach",
				attach_fill: "attach_fill",
				audio: "audio",
				audio_fill: "audio_fill",
				author: "author",
				author_fill: "author_fill",
				avatar_style: "avatar_style",
				avatar_style_fill: "avatar_style_fill",
				award: "award",
				award_fill: "award_fill",
				back: "back",
				back_fill: "back_fill",
				ban: "ban",
				ban_fill: "ban_fill",
				best: "best",
				best_fill: "best_fill",
				block: "block",
				block_fill: "block_fill",
				bold: "bold",
				bold_fill: "bold_fill",
				bot: "bot",
				bot_fill: "bot_fill",
				bounce: "bounce",
				bounce_fill: "bounce_fill",
				browse: "browse",
				browse_fill: "browse_fill",
				browser: "browser",
				browser_fill: "browser_fill",
				cake: "cake",
				cake_fill: "cake_fill",
				calendar: "calendar",
				camera: "camera",
				camera_fill: "camera_fill",
				campaign: "campaign",
				caret_down: "caret_down",
				caret_down_fill: "caret_down_fill",
				caret_left: "caret_left",
				caret_left_fill: "caret_left_fill",
				caret_right: "caret_right",
				caret_right_fill: "caret_right_fill",
				caret_up: "caret_up",
				caret_up_fill: "caret_up_fill",
				chat: "chat",
				chat_fill: "chat_fill",
				chat_group: "chat_group",
				chat_group_fill: "chat_group_fill",
				chat_new: "chat_new",
				chat_new_fill: "chat_new_fill",
				checkbox: "checkbox",
				checkbox_dismiss: "checkbox_dismiss",
				checkbox_dismiss_fill: "checkbox_dismiss_fill",
				checkbox_fill: "checkbox_fill",
				checkmark: "checkmark",
				checkmark_fill: "checkmark_fill",
				chrome: "chrome",
				chrome_fill: "chrome_fill",
				clear: "clear",
				clear_fill: "clear_fill",
				close: "close",
				close_fill: "close_fill",
				closed_captioning: "closed_captioning",
				closed_captioning_fill: "closed_captioning_fill",
				code_block: "code_block",
				code_block_fill: "code_block_fill",
				code_inline: "code_inline",
				code_inline_fill: "code_inline_fill",
				coins: "coins",
				coins_fill: "coins_fill",
				coins_outline_color: "coins_outline_color",
				collapse: "collapse",
				collapse_fill: "collapse_fill",
				collection: "collection",
				collection_fill: "collection_fill",
				comment: "comment",
				comment_fill: "comment_fill",
				comments: "comments",
				comments_fill: "comments_fill",
				community: "community",
				community_fill: "community_fill",
				controversial: "controversial",
				controversial_fill: "controversial_fill",
				crop: "crop",
				crop_fill: "crop_fill",
				crosspost: "crosspost",
				crosspost_fill: "crosspost_fill",
				crowd_control: "crowd_control",
				crowd_control_fill: "crowd_control_fill",
				custom_feed: "custom_feed",
				custom_feed_fill: "custom_feed_fill",
				customize: "customize",
				customize_fill: "customize_fill",
				day: "day",
				day_fill: "day_fill",
				delete: "delete",
				delete_fill: "delete_fill",
				discover: "discover",
				discover_fill: "discover_fill",
				dismiss_all: "dismiss_all",
				dismiss_all_fill: "dismiss_all_fill",
				distinguish: "distinguish",
				distinguish_fill: "distinguish_fill",
				down: "down",
				down_fill: "down_fill",
				download: "download",
				download_fill: "download_fill",
				downvote: "downvote",
				downvote_fill: "downvote_fill",
				downvotes: "downvotes",
				downvotes_fill: "downvotes_fill",
				drag: "drag",
				duplicate: "duplicate",
				duplicate_fill: "duplicate_fill",
				edit: "edit",
				edit_fill: "edit_fill",
				effect: "effect",
				effect_fill: "effect_fill",
				embed: "embed",
				embed_fill: "embed_fill",
				emoji: "emoji",
				emoji_fill: "emoji_fill",
				expand: "expand",
				expand_fill: "expand_fill",
				external_link: "external_link",
				external_link_fill: "external_link_fill",
				feed_posts: "feed_posts",
				feed_posts_fill: "feed_posts_fill",
				feed_video: "feed_video",
				feed_video_fill: "feed_video_fill",
				filter: "filter",
				filter_fill: "filter_fill",
				format: "format",
				format_fill: "format_fill",
				forward: "forward",
				forward_fill: "forward_fill",
				gif_post: "gif_post",
				gif_post_fill: "gif_post_fill",
				heart: "heart",
				heart_fill: "heart_fill",
				help: "help",
				help_fill: "help_fill",
				hide: "hide",
				hide_fill: "hide_fill",
				history: "history",
				history_fill: "history_fill",
				home: "home",
				home_fill: "home_fill",
				hot: "hot",
				hot_fill: "hot_fill",
				ignore_reports: "ignore_reports",
				ignore_reports_fill: "ignore_reports_fill",
				image_post: "image_post",
				image_post_fill: "image_post_fill",
				info: "info",
				info_fill: "info_fill",
				italic: "italic",
				italic_fill: "italic_fill",
				join: "join",
				join_fill: "join_fill",
				joined: "joined",
				joined_fill: "joined_fill",
				jump_down: "jump_down",
				jump_down_fill: "jump_down_fill",
				jump_up: "jump_up",
				jump_up_fill: "jump_up_fill",
				karma: "karma",
				karma_fill: "karma_fill",
				keyboard: "keyboard",
				keyboard_fill: "keyboard_fill",
				kick: "kick",
				kick_fill: "kick_fill",
				leave: "leave",
				leave_fill: "leave_fill",
				left: "left",
				left_fill: "left_fill",
				link_post: "link_post",
				link_post_fill: "link_post_fill",
				list_bulleted: "list_bulleted",
				list_bulleted_fill: "list_bulleted_fill",
				list_numbered: "list_numbered",
				list_numbered_fill: "list_numbered_fill",
				live: "live",
				live_fill: "live_fill",
				load: "load",
				location: "location",
				location_fill: "location_fill",
				lock: "lock",
				lock_fill: "lock_fill",
				logout: "logout",
				logout_fill: "logout_fill",
				loop: "loop",
				loop_fill: "loop_fill",
				mark_read: "mark_read",
				mark_read_fill: "mark_read_fill",
				mask: "mask",
				mask_fill: "mask_fill",
				media_gallery: "media_gallery",
				media_gallery_fill: "media_gallery_fill",
				meme: "meme",
				meme_fill: "meme_fill",
				menu: "menu",
				menu_fill: "menu_fill",
				message: "message",
				message_fill: "message_fill",
				mod: "mod",
				mod_fill: "mod_fill",
				mod_mail: "mod_mail",
				mod_mail_fill: "mod_mail_fill",
				mod_mode: "mod_mode",
				mod_mode_fill: "mod_mode_fill",
				mod_mute: "mod_mute",
				mod_mute_fill: "mod_mute_fill",
				mod_overflow: "mod_overflow",
				mod_overflow_fill: "mod_overflow_fill",
				mod_queue: "mod_queue",
				mod_queue_fill: "mod_queue_fill",
				mod_unmute: "mod_unmute",
				mod_unmute_fill: "mod_unmute_fill",
				new: "new",
				new_fill: "new_fill",
				night: "night",
				night_fill: "night_fill",
				notification: "notification",
				notification_fill: "notification_fill",
				notification_frequent: "notification_frequent",
				notification_frequent_fill: "notification_frequent_fill",
				notification_off: "notification_off",
				notification_off_fill: "notification_off_fill",
				nsfw: "nsfw",
				nsfw_fill: "nsfw_fill",
				nsfw_language: "nsfw_language",
				nsfw_language_fill: "nsfw_language_fill",
				nsfw_violence: "nsfw_violence",
				nsfw_violence_fill: "nsfw_violence_fill",
				original: "original",
				original_fill: "original_fill",
				overflow_carat: "overflow_carat",
				overflow_carat_fill: "overflow_carat_fill",
				overflow_horizontal: "overflow_horizontal",
				overflow_vertical: "overflow_vertical",
				pause: "pause",
				pause_fill: "pause_fill",
				payment: "payment",
				payment_fill: "payment_fill",
				peace: "peace",
				peace_fill: "peace_fill",
				pending_posts: "pending_posts",
				pending_posts_fill: "pending_posts_fill",
				pin: "pin",
				pin_fill: "pin_fill",
				play: "play",
				play_fill: "play_fill",
				poll_post: "poll_post",
				poll_post_fill: "poll_post_fill",
				popular: "popular",
				popular_fill: "popular_fill",
				prediction: "prediction",
				prediction_fill: "prediction_fill",
				premium: "premium",
				premium_fill: "premium_fill",
				privacy: "privacy",
				privacy_fill: "privacy_fill",
				profile: "profile",
				profile_fill: "profile_fill",
				quarantined: "quarantined",
				quarantined_fill: "quarantined_fill",
				quote: "quote",
				quote_fill: "quote_fill",
				r_slash: "r_slash",
				r_slash_fill: "r_slash_fill",
				radio_button: "radio_button",
				radio_button_fill: "radio_button_fill",
				random: "random",
				random_fill: "random_fill",
				rating_drugs: "rating_drugs",
				rating_everyone: "rating_everyone",
				rating_mature: "rating_mature",
				rating_nsfw: "rating_nsfw",
				rating_violence: "rating_violence",
				refresh: "refresh",
				refresh_fill: "refresh_fill",
				remove: "remove",
				remove_fill: "remove_fill",
				reply: "reply",
				reply_fill: "reply_fill",
				report: "report",
				report_fill: "report_fill",
				reverse: "reverse",
				reverse_fill: "reverse_fill",
				right: "right",
				right_fill: "right_fill",
				rising: "rising",
				rising_fill: "rising_fill",
				rotate: "rotate",
				rotate_fill: "rotate_fill",
				rpan: "rpan",
				rpan_fill: "rpan_fill",
				rules: "rules",
				rules_fill: "rules_fill",
				safari: "safari",
				safari_fill: "safari_fill",
				save: "save",
				save_fill: "save_fill",
				saved: "saved",
				saved_fill: "saved_fill",
				scheduled: "scheduled",
				scheduled_fill: "scheduled_fill",
				search: "search",
				search_fill: "search_fill",
				self: "self",
				self_fill: "self_fill",
				send: "send",
				send_fill: "send_fill",
				settings: "settings",
				settings_fill: "settings_fill",
				share: "share",
				share_android: "share_android",
				share_android_fill: "share_android_fill",
				share_fill: "share_fill",
				share_ios: "share_ios",
				share_ios_fill: "share_ios_fill",
				show: "show",
				show_fill: "show_fill",
				side_menu: "side_menu",
				side_menu_fill: "side_menu_fill",
				skipback10: "skipback10",
				skipback10_fill: "skipback10_fill",
				skipforward10: "skipforward10",
				skipforward10_fill: "skipforward10_fill",
				sort: "sort",
				sort_fill: "sort_fill",
				spam: "spam",
				spam_fill: "spam_fill",
				spoiler: "spoiler",
				spoiler_fill: "spoiler_fill",
				sponsored: "sponsored",
				sponsored_fill: "sponsored_fill",
				star: "star",
				star_fill: "star_fill",
				statistics: "statistics",
				statistics_fill: "statistics_fill",
				sticker: "sticker",
				sticker_fill: "sticker_fill",
				strikethrough: "strikethrough",
				strikethrough_fill: "strikethrough_fill",
				subtract: "subtract",
				subtract_fill: "subtract_fill",
				superscript: "superscript",
				superscript_fill: "superscript_fill",
				swipe_back: "swipe_back",
				swipe_back_fill: "swipe_back_fill",
				swipe_down: "swipe_down",
				swipe_down_fill: "swipe_down_fill",
				swipe_forward: "swipe_forward",
				swipe_forward_fill: "swipe_forward_fill",
				swipe_up: "swipe_up",
				swipe_up_fill: "swipe_up_fill",
				table: "table",
				table_fill: "table_fill",
				tag: "tag",
				tag_fill: "tag_fill",
				tap: "tap",
				tap_fill: "tap_fill",
				text_post: "text_post",
				text_post_fill: "text_post_fill",
				text_size: "text_size",
				text_size_fill: "text_size_fill",
				top: "top",
				top_fill: "top_fill",
				topic: "topic",
				topic_activism: "topic_activism",
				topic_addiction_support: "topic_addiction_support",
				topic_advice: "topic_advice",
				topic_animals: "topic_animals",
				topic_anime: "topic_anime",
				topic_art: "topic_art",
				topic_beauty: "topic_beauty",
				topic_business: "topic_business",
				topic_careers: "topic_careers",
				topic_cars: "topic_cars",
				topic_celebrity: "topic_celebrity",
				topic_crafts: "topic_crafts",
				topic_crypto: "topic_crypto",
				topic_culture: "topic_culture",
				topic_diy: "topic_diy",
				topic_entertainment: "topic_entertainment",
				topic_ethics: "topic_ethics",
				topic_family: "topic_family",
				topic_fashion: "topic_fashion",
				topic_fitness: "topic_fitness",
				topic_food: "topic_food",
				topic_funny: "topic_funny",
				topic_gender: "topic_gender",
				topic_health: "topic_health",
				topic_help: "topic_help",
				topic_history: "topic_history",
				topic_internet: "topic_internet",
				topic_law: "topic_law",
				topic_learning: "topic_learning",
				topic_lifestyle: "topic_lifestyle",
				topic_mature: "topic_mature",
				topic_mensfashion: "topic_mensfashion",
				topic_menshealth: "topic_menshealth",
				topic_meta: "topic_meta",
				topic_military: "topic_military",
				topic_movies: "topic_movies",
				topic_music: "topic_music",
				topic_news: "topic_news",
				topic_other: "topic_other",
				topic_outdoors: "topic_outdoors",
				topic_pets: "topic_pets",
				topic_photography: "topic_photography",
				topic_places: "topic_places",
				topic_politics: "topic_politics",
				topic_programming: "topic_programming",
				topic_reading: "topic_reading",
				topic_reading_fill: "topic_reading_fill",
				topic_religion: "topic_religion",
				topic_science: "topic_science",
				topic_sexorientation: "topic_sexorientation",
				topic_sports: "topic_sports",
				topic_style: "topic_style",
				topic_tabletop: "topic_tabletop",
				topic_technology: "topic_technology",
				topic_television: "topic_television",
				topic_traumasupport: "topic_traumasupport",
				topic_travel: "topic_travel",
				topic_videogaming: "topic_videogaming",
				topic_womenshealth: "topic_womenshealth",
				trim: "trim",
				trim_fill: "trim_fill",
				trophy: "trophy",
				trophy_fill: "trophy_fill",
				u_slash: "u_slash",
				u_slash_fill: "u_slash_fill",
				unban: "unban",
				unban_fill: "unban_fill",
				undo: "undo",
				undo_fill: "undo_fill",
				unheart: "unheart",
				unlock: "unlock",
				unlock_fill: "unlock_fill",
				unmod: "unmod",
				unmod_fill: "unmod_fill",
				unpin: "unpin",
				unpin_fill: "unpin_fill",
				unverified: "unverified",
				unverified_fill: "unverified_fill",
				up: "up",
				up_fill: "up_fill",
				upload: "upload",
				upload_fill: "upload_fill",
				upvote: "upvote",
				upvote_fill: "upvote_fill",
				upvotes: "upvotes",
				upvotes_fill: "upvotes_fill",
				user: "user",
				user_fill: "user_fill",
				user_note: "user_note",
				user_note_fill: "user_note_fill",
				vault: "vault",
				vault_fill: "vault_fill",
				verified: "verified",
				verified_fill: "verified_fill",
				video_camera: "video_camera",
				video_camera_fill: "video_camera_fill",
				video_live: "video_live",
				video_live_fill: "video_live_fill",
				video_post: "video_post",
				video_post_fill: "video_post_fill",
				view_card: "view_card",
				view_card_fill: "view_card_fill",
				view_classic: "view_classic",
				view_classic_fill: "view_classic_fill",
				view_compact: "view_compact",
				view_compact_fill: "view_compact_fill",
				view_grid_fill: "view_grid_fill",
				view_grid_fill_1: "view_grid_fill_1",
				views: "views",
				views_fill: "views_fill",
				volume: "volume",
				volume_fill: "volume_fill",
				volume_mute: "volume_mute",
				volume_mute_fill: "volume_mute_fill",
				wiki: "wiki",
				wiki_fill: "wiki_fill",
				wiki_ban: "wiki_ban",
				wiki_ban_fill: "wiki_ban_fill",
				wiki_unban: "wiki_unban",
				wiki_unban_fill: "wiki_unban_fill",
				world: "world",
				world_fill: "world_fill"
			}
		},
		"./src/lib/formatApiError/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return o
			}));
			var n = i("./node_modules/fbt/lib/FbtPublic.js"),
				r = i("./src/lib/constants/index.ts");

			function o(t, e) {
				return t ? t.fields && t.fields.length ? t.fields.map(t => t.msg).join(", ") : t.type && l[t.type] ? l[t.type]() : 401 === e ? n.fbt._("There was an authentication error", null, {
					hk: "2KZTRv"
				}) : n.fbt._("Something went wrong", null, {
					hk: "3i6szH"
				}) : ""
			}
			const l = {
				[r.j]: () => n.fbt._("you're not allowed to do that", null, {
					hk: "1jGKQw"
				}),
				[r.L]: () => n.fbt._("GIF size must be less than {max file size}MB", [n.fbt._param("max file size", Math.floor(r.Z / r.hb).toString())], {
					hk: "1zzsdM"
				}),
				[r.R]: () => n.fbt._("Image size must be less than {max file size}MB", [n.fbt._param("max file size", Math.floor(r.bb / r.hb).toString())], {
					hk: "3H6bF8"
				}),
				[r.T]: () => n.fbt._("Sorry, we accept only images (.png, .jpeg, .gif) and videos (.mp4, .mov)", null, {
					hk: "1hw868"
				}),
				[r.pc]: () => n.fbt._("Video size must be less than {max file size}GB", [n.fbt._param("max file size", (r.fb / r.hb / 1024).toFixed(1))], {
					hk: "4FkABU"
				})
			}
		},
		"./src/lib/makePostDraftPageKey/index.ts": function(t, e, i) {
			"use strict";

			function n(t) {
				let e = "PostDraftPage";
				return t.draftId && (e += `--[draftId:${t.draftId}]`), e
			}
			i.d(e, "a", (function() {
				return n
			}))
		},
		"./src/reddit/actions/apiRequestState.ts": function(t, e, i) {
			"use strict";
			i.d(e, "d", (function() {
				return o
			})), i.d(e, "a", (function() {
				return l
			})), i.d(e, "b", (function() {
				return s
			})), i.d(e, "c", (function() {
				return c
			})), i.d(e, "h", (function() {
				return a
			})), i.d(e, "e", (function() {
				return d
			})), i.d(e, "f", (function() {
				return u
			})), i.d(e, "g", (function() {
				return _
			}));
			var n = i("./src/lib/makeActionCreator/index.ts"),
				r = i("./src/reddit/models/ApiRequestState/index.ts");
			const o = "API_REQUEST_STATE__STARTED",
				l = "API_REQUEST_STATE__COMPLETED",
				s = "API_REQUEST_STATE__FAILED",
				c = "API_REQUEST_STATE__RELEASED";

			function a(t) {
				return {
					type: o,
					payload: {
						apiRequestStatus: r.a.Pending,
						apiRequestId: t
					}
				}
			}

			function d(t) {
				return {
					type: l,
					payload: {
						apiRequestStatus: r.a.Complete,
						apiRequestId: t
					}
				}
			}

			function u(t, e) {
				return {
					type: s,
					payload: {
						apiRequestStatus: r.a.Failed,
						apiRequestId: t,
						apiError: e
					}
				}
			}
			const _ = Object(n.a)(c)
		},
		"./src/reddit/actions/grantUserFlair/constants.ts": function(t, e, i) {
			"use strict";
			i.d(e, "i", (function() {
				return n
			})), i.d(e, "g", (function() {
				return r
			})), i.d(e, "f", (function() {
				return o
			})), i.d(e, "l", (function() {
				return l
			})), i.d(e, "k", (function() {
				return s
			})), i.d(e, "j", (function() {
				return c
			})), i.d(e, "h", (function() {
				return a
			})), i.d(e, "a", (function() {
				return d
			})), i.d(e, "b", (function() {
				return u
			})), i.d(e, "e", (function() {
				return _
			})), i.d(e, "c", (function() {
				return f
			})), i.d(e, "d", (function() {
				return p
			}));
			const n = "SUBREDDIT__FLAIRED_USERS_PENDING",
				r = "SUBREDDIT__FLAIRED_USERS_LOADED",
				o = "SUBREDDIT__FLAIRED_USERS_FAILED",
				l = "SUBREDDIT__FLAIRED_USERS_SEARCH_PENDING",
				s = "SUBREDDIT__FLAIRED_USERS_SEARCH_LOADED",
				c = "SUBREDDIT__FLAIRED_USERS_SEARCH_FAILED",
				a = "SUBREDDIT__FLAIRED_USERS_OWNFLAIR_CHANGED",
				d = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_ADDED",
				u = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_CHANGED",
				_ = "SUBREDDIT__FLAIRED_USERS_DELETE_PENDING",
				f = "SUBREDDIT__FLAIRED_USERS_DELETE_COMPLETED",
				p = "SUBREDDIT__FLAIRED_USERS_DELETE_FAILED"
		},
		"./src/reddit/actions/postFlairStyleTemplates/constants.ts": function(t, e, i) {
			"use strict";
			i.d(e, "c", (function() {
				return n
			})), i.d(e, "b", (function() {
				return r
			})), i.d(e, "a", (function() {
				return o
			}));
			const n = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_PENDING",
				r = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_LOADED",
				o = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_FAILED"
		},
		"./src/reddit/actions/shortcuts/utils.ts": function(t, e, i) {
			"use strict";
			i.d(e, "c", (function() {
				return l
			})), i.d(e, "a", (function() {
				return s
			})), i.d(e, "b", (function() {
				return c
			})), i.d(e, "d", (function() {
				return a
			}));
			var n = i("./src/reddit/constants/shortcuts.ts"),
				r = i("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				o = i("./src/reddit/helpers/routeKey/index.ts");
			const l = t => {
					const e = t.platform.currentPage;
					if (!e || !e.routeMatch) return;
					const i = e.routeMatch,
						n = Object(r.a)(t);
					return Object(o.b)(i, t, n)
				},
				s = t => {
					const e = document.getElementById(t);
					e && e.focus()
				},
				c = t => {
					const e = document.getElementById(t),
						i = window.scrollX,
						n = window.scrollY;
					e && (e.focus(), window.scrollTo(i, n))
				},
				a = () => {
					c(n.b)
				}
		},
		"./src/reddit/actions/structuredStyles/constants.ts": function(t, e, i) {
			"use strict";
			i.d(e, "l", (function() {
				return n
			})), i.d(e, "k", (function() {
				return r
			})), i.d(e, "j", (function() {
				return o
			})), i.d(e, "i", (function() {
				return l
			})), i.d(e, "h", (function() {
				return s
			})), i.d(e, "g", (function() {
				return c
			})), i.d(e, "b", (function() {
				return a
			})), i.d(e, "c", (function() {
				return d
			})), i.d(e, "e", (function() {
				return u
			})), i.d(e, "d", (function() {
				return _
			})), i.d(e, "f", (function() {
				return f
			})), i.d(e, "a", (function() {
				return p
			})), i.d(e, "n", (function() {
				return m
			})), i.d(e, "m", (function() {
				return b
			}));
			const n = "STRUCTURED_STYLES__STYLES_RESET_PENDING",
				r = "STRUCTURED_STYLES__STYLES_RESET_LOADED",
				o = "STRUCTURED_STYLES__STYLES_RESET_FAILED",
				l = "SUBREDDIT__STYLES_PENDING",
				s = "SUBREDDIT__STYLES_LOADED",
				c = "SUBREDDIT__STYLES_FAILED",
				a = "STRUCTURED_STYLES__DRAFT_REPLACED",
				d = "STRUCTURED_STYLES__DRAFT_UPDATED",
				u = "STRUCTURED_STYLES__EDITING_STOPPED",
				_ = "STRUCTURED_STYLES__EDITING_STARTED",
				f = "STRUCTURED_STYLES__IMAGE_UPLOAD_ADDED",
				p = "STRUCTURED_STYLES__DIRTIED_BLADE_EDITOR",
				m = "STRUCTURED_STYLES__UNDIRTIED_BLADE_EDITOR",
				b = "STRUCTURED_STYLES__STYLES_UPDATED_LOADED"
		},
		"./src/reddit/actions/structuredStyles/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "l", (function() {
				return B
			})), i.d(e, "k", (function() {
				return W
			})), i.d(e, "j", (function() {
				return z
			})), i.d(e, "e", (function() {
				return H
			})), i.d(e, "d", (function() {
				return $
			})), i.d(e, "g", (function() {
				return Q
			})), i.d(e, "c", (function() {
				return J
			})), i.d(e, "f", (function() {
				return et
			})), i.d(e, "b", (function() {
				return it
			})), i.d(e, "m", (function() {
				return nt
			})), i.d(e, "a", (function() {
				return rt
			})), i.d(e, "h", (function() {
				return ot
			})), i.d(e, "i", (function() {
				return lt
			}));
			i("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = i("./node_modules/lodash/omit.js"),
				r = i.n(n),
				o = i("./node_modules/lodash/pick.js"),
				l = i.n(o),
				s = i("./node_modules/react-router-redux/es/index.js"),
				c = i("./src/lib/filterQueryParams/index.ts"),
				a = i("./src/lib/formatApiError/index.ts"),
				d = i("./src/lib/makeActionCreator/index.ts"),
				u = i("./src/reddit/actions/apiRequestState.ts"),
				_ = i("./src/reddit/actions/imageUploads.ts"),
				f = i("./src/reddit/actions/modal.ts"),
				p = i("./src/reddit/endpoints/moderator/structuredStyles.ts"),
				m = i("./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts"),
				b = i("./src/reddit/selectors/postFlair.ts"),
				h = i("./src/reddit/selectors/subreddit.ts"),
				y = i("./src/reddit/actions/postFlairStyleTemplates/constants.ts");
			const g = Object(d.a)(y.c),
				E = Object(d.a)(y.b),
				S = Object(d.a)(y.a);
			var w = i("./src/reddit/actions/toaster.ts"),
				O = i("./src/reddit/actions/widgets/index.ts"),
				k = i("./src/reddit/constants/modals.ts"),
				j = i("./src/reddit/helpers/getGenericUploadError.ts"),
				v = i("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				I = i("./src/reddit/helpers/media/index.ts"),
				x = i("./src/reddit/models/Image/index.tsx"),
				D = i("./src/reddit/models/StructuredStyles/index.ts"),
				T = i("./src/reddit/models/Toast/index.ts"),
				R = i("./src/reddit/selectors/activeModalId.ts"),
				C = i("./src/reddit/selectors/platform.ts"),
				L = i("./src/reddit/selectors/structuredStyles.ts"),
				N = i("./src/reddit/selectors/user.ts"),
				P = i("./src/reddit/helpers/trackers/blade.ts"),
				U = i("./src/telemetry/index.ts"),
				A = i("./src/reddit/actions/structuredStyles/constants.ts");
			const B = Object(d.a)(A.m),
				F = {
					bannerBackgroundImage: ["bannerBackgroundImagePosition"],
					bannerPositionedImage: ["bannerPositionedImagePosition", "secondaryBannerPositionedImage"]
				},
				M = t => {
					const e = {
						...t
					};
					return Object.keys(t).forEach(i => {
						F[i] && !t[i] && F[i].forEach(t => e[t] = null)
					}), e
				},
				W = (t, e, i, n) => async (r, o, l) => {
					const {
						apiContext: s
					} = l, c = o(), d = M(e), f = c.structuredStyles.models[t];
					let m;
					for (const t in d)
						if (d[t] !== f[t]) {
							m = !0;
							break
						} if (!m) return;
					r(Object(u.h)(n));
					const b = Object(P.i)(i)(c);
					let y = null,
						g = null;
					try {
						(y = await Object(_.f)(o(), x.a.StructuredStyles)) && (g = Object(_.m)(y)(r, o, l))
					} catch (k) {
						const t = Object(j.a)("webSocket");
						return void r(Object(u.f)(n, t))
					}
					const E = Object(h.U)(c, {
							subredditId: t
						}).name,
						S = await p.e(s(), E, d),
						O = {};
					if (S.ok) {
						if (g) try {
							await g
						} catch (k) {}
						const i = Object(L.f)(o(), {
							apiRequestId: n
						});
						for (const t in i)
							if (t in e) {
								const e = Object(L.g)(o(), {
									name: t
								});
								e && Object(x.j)(e) && (O[t] = i[t])
							} Object.keys(O).length && r(X(O)), r(Object(u.e)(n)), r(B({
							subredditId: t,
							styles: {
								...d,
								...O
							}
						}))
					} else y && y.websocket.close(), r(Object(u.f)(n, S.error)), S.body && r(w.f({
						kind: T.b.Error,
						text: Object(a.a)(S.error, S.status)
					}));
					Object(U.a)({
						...b,
						actionInfo: {
							...b.actionInfo,
							success: S.ok
						}
					})
				}, q = Object(d.a)(A.l), G = Object(d.a)(A.k), K = Object(d.a)(A.j), z = t => async (e, i, n) => {
					let {
						apiContext: r
					} = n;
					e(q({
						subredditId: t
					}));
					const o = Object(h.U)(i(), {
							subredditId: t
						}).name,
						l = await p.f(r(), o);
					if (l.ok) {
						const n = i().structuredStyles.models[t],
							r = n ? n.mobileKeyColor : null;
						e(G({
							subredditId: t,
							styles: {
								mobileKeyColor: r
							}
						}))
					} else e(K({
						subredditId: t,
						...l.error
					}))
				}, Y = Object(d.a)(A.d), H = t => async (e, i, n) => {
					const r = i(),
						o = r.structuredStyles.models[t] || {},
						l = Object(N.db)(r);
					e(Y({
						isNightmodeOn: l,
						styles: o,
						subredditId: t
					})), dt(t, !1)(e, i, n), (t => async (e, i, n) => {
						let {
							gqlContext: r
						} = n;
						const o = i(),
							l = Object(h.U)(o, {
								subredditId: t
							});
						if (!l) return;
						const s = Object(b.d)(o, {
								subredditId: t
							}),
							c = s && s.templateIds;
						if (!c || !c.length) return;
						e(g({
							subredditId: t
						}));
						const a = await Object(p.a)(r(), l.name, c);
						if (a.ok) {
							const i = {};
							if (a.body) {
								const {
									data: t
								} = a.body;
								if (t && t.subreddit)
									for (const e of t.subreddit.postFlairStyleTemplates) i[e.id] = Object(m.a)(e)
							}
							e(E({
								subredditId: t,
								templates: i
							}))
						} else e(S({
							subredditId: t,
							error: a.error
						}))
					})(t)(e, i, n), Object(O.g)(t, !1)(e, i, n)
				}, X = Object(d.a)(A.c), $ = t => async (e, i, n) => {
					const r = M(t),
						o = i();
					for (const t in r)
						if (Object(D.l)(t))
							if (r[t]) {
								if ("string" != typeof r[t]) {
									const o = r[t],
										l = await Object(x.e)(o);
									Q(t, l)(e, i, n), r[t] = ""
								}
							} else {
								const i = Object(L.g)(o, {
									name: t
								});
								i && e(Object(_.h)(i))
							} e(X(r))
				}, V = Object(d.a)(A.f), Q = (t, e, i) => async (n, r, o) => {
					const l = r(),
						s = i || l.structuredStyles.isEditing,
						c = Object(h.U)(l, {
							subredditId: s
						}).name;
					n(V({
						imageKey: t,
						uploadId: e.id
					})), n(Object(_.k)(e));
					const a = await p.d(o.apiContext(), c, e.file.name, t, await Object(I.h)(e.file));
					try {
						const i = await Object(_.g)(r(), a, e, x.a.StructuredStyles);
						if (i) {
							const e = i.url;
							n(Object(_.j)(i)), n(X({
								[t]: e
							}))
						}
					} catch (d) {
						if (d instanceof Error) throw d;
						n(Object(_.i)(d))
					}
				}, Z = Object(d.a)(A.b), J = (t, e, i) => async (n, o, s) => {
					const c = o(),
						a = c.structuredStyles.models[t] || {},
						d = c.structuredStyles.draft,
						u = Object(P.h)(e)(c);
					if (i) {
						const e = l()(a, i),
							o = {
								...r()(d, i),
								...e
							};
						n(Z({
							subredditId: t,
							styles: o
						}))
					} else {
						n(Z({
							subredditId: t,
							styles: a
						}))
					}
					Object(U.a)(u)
				}, tt = Object(d.a)(A.e), et = () => async (t, e, i) => {
					const n = e(),
						r = Object(N.eb)(n),
						o = !!Object(C.a)(n);
					if (t(tt({
							nightmodeTempUpdated: r
						})), o) return;
					const {
						url: l
					} = n.platform.currentPage;
					l && t(Object(s.c)(Object(c.a)(l, ["styling", "route"])))
				}, it = Object(d.a)(A.a), nt = Object(d.a)(A.n), rt = () => async t => t(et()), ot = t => async (e, i) => {
					const n = i(),
						r = Object(L.i)(n);
					!Object(R.b)(k.a.BLADE_UNSAVED_CHANGES)(n) && r && (Object(L.a)(n, {
						subredditId: t
					}) ? e(Object(f.i)(k.a.BLADE_UNSAVED_CHANGES)) : e(rt()))
				}, lt = t => async (e, i) => {
					const n = i();
					Object(L.i)(n) || e(Object(N.db)(n) ? Object(f.i)(k.a.BLADE_NIGHTMODE) : H(t))
				}, st = Object(d.a)(A.i), ct = Object(d.a)(A.h), at = Object(d.a)(A.g), dt = (t, e) => async (i, n, r) => {
					let {
						gqlContext: o,
						apiContext: l
					} = r;
					i(st({
						subredditId: t
					}));
					const s = Object(h.U)(n(), {
						subredditId: t
					});
					if (!s) return;
					if (!e) {
						const n = await p.c(l(), s.name, e);
						if (n.ok) {
							const e = n.body,
								r = e.data ? e.data.style : {};
							i(ct({
								subredditId: t,
								styles: r
							}))
						} else i(at({
							subredditId: t,
							...n.error
						}));
						return
					}
					const c = await p.b(o(), s.name);
					if (c.ok) {
						let e = {};
						if (c.body) {
							const {
								data: t
							} = c.body;
							t && t.subreddit && t.subreddit.styles && (e = Object(v.a)(t.subreddit.styles))
						}
						i(ct({
							subredditId: t,
							styles: e
						}))
					} else i(at({
						subredditId: t,
						...c.error
					}))
				}
		},
		"./src/reddit/actions/widgets/constants.ts": function(t, e, i) {
			"use strict";
			i.d(e, "g", (function() {
				return n
			})), i.d(e, "i", (function() {
				return r
			})), i.d(e, "h", (function() {
				return o
			})), i.d(e, "f", (function() {
				return l
			})), i.d(e, "d", (function() {
				return s
			})), i.d(e, "e", (function() {
				return c
			})), i.d(e, "c", (function() {
				return a
			})), i.d(e, "b", (function() {
				return d
			})), i.d(e, "a", (function() {
				return u
			}));
			const n = "WIDGETS__WIDGET_CREATED",
				r = "WIDGETS__WIDGET_UPDATED",
				o = "WIDGET_DELETED",
				l = "WIDGETS_SORTED",
				s = "WIDGETS__STARTED_EDITING_WIDGET",
				c = "WIDGETS__LOADED",
				a = "SUBREDDIT__WIDGETS_PENDING",
				d = "SUBREDDIT__WIDGETS_LOADED",
				u = "SUBREDDIT__WIDGETS_FAILED"
		},
		"./src/reddit/actions/widgets/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "c", (function() {
				return k
			})), i.d(e, "e", (function() {
				return v
			})), i.d(e, "d", (function() {
				return x
			})), i.d(e, "h", (function() {
				return T
			})), i.d(e, "a", (function() {
				return R
			})), i.d(e, "b", (function() {
				return C
			})), i.d(e, "f", (function() {
				return N
			})), i.d(e, "g", (function() {
				return B
			}));
			var n = i("./node_modules/fbt/lib/FbtPublic.js"),
				r = i("./src/lib/makeActionCreator/index.ts"),
				o = i("./src/reddit/actions/apiRequestState.ts"),
				l = i("./src/reddit/actions/imageUploads.ts"),
				s = i("./src/reddit/actions/toaster.ts"),
				c = i("./src/lib/constants/index.ts"),
				a = i("./src/lib/makeApiRequest/index.ts"),
				d = i("./src/lib/omitHeaders/index.ts"),
				u = i("./src/reddit/constants/headers.ts");
			const _ = async (t, e, i) => Object(a.a)(Object(d.a)(t, [u.a]), {
				endpoint: `${t.apiUrl}/r/${e}/api/widgets`,
				method: c.jb.GET,
				type: "json",
				data: {
					progressive_images: i
				}
			});
			var f = i("./src/reddit/helpers/getGenericUploadError.ts"),
				p = i("./src/reddit/helpers/media/index.ts"),
				m = i("./src/lib/assertNever.ts"),
				b = i("./src/reddit/models/Widgets/index.ts"),
				h = i("./src/reddit/selectors/subreddit.ts"),
				y = i("./src/reddit/helpers/widgets/index.tsx"),
				g = i("./src/reddit/models/Image/index.tsx"),
				E = i("./src/reddit/models/Toast/index.ts"),
				S = i("./src/reddit/selectors/experiments/cnc/index.ts"),
				w = i("./src/reddit/actions/widgets/constants.ts");
			const O = Object(r.a)(w.g),
				k = (t, e, i) => async (r, _, p) => {
					const {
						apiContext: m
					} = p;
					r(Object(o.h)(i));
					const b = _(),
						w = Object(h.U)(b, {
							subredditId: t
						}).name,
						k = Object(S.d)(b),
						j = Object(y.e)(e);
					let v = null,
						I = null;
					try {
						(v = await Object(l.f)(b, g.a.Widgets)) && (I = Object(l.m)(v)(r, _, p))
					} catch (D) {
						const t = Object(f.a)("webSocket");
						return void r(Object(o.f)(i, t))
					}
					if (k && I) try {
						await I
					} catch (D) {}
					const x = await (async (t, e, i) => Object(a.a)(Object(d.a)(t, [u.a]), {
						endpoint: `${t.apiUrl}/r/${e}/api/widget`,
						method: c.jb.POST,
						type: "json",
						data: i
					}))(m(), w, j);
					if (x.ok) {
						let l = x.body;
						const c = l.id;
						if ("calendar" === e.kind && r(Object(s.f)({
								kind: E.b.SuccessMod,
								text: n.fbt._("New calendar added! It may take a few minutes to see your events appear", null, {
									hk: "4iETrT"
								})
							})), v) {
							if (!k) try {
								await I
							} catch (D) {}
							l = await r(F(t, c)) || l
						}
						r(O({
							subredditId: t,
							widget: l,
							widgetId: c
						})), r(Object(o.e)(i))
					} else v && v.websocket.close(), r(Object(o.f)(i, x.error))
				}, j = Object(r.a)(w.i), v = (t, e, i) => async (r, _, p) => {
					const {
						apiContext: w
					} = p;
					r(Object(o.h)(i));
					const O = e.id,
						k = _(),
						v = Object(h.U)(k, {
							subredditId: t
						}).name,
						I = Object(S.d)(k),
						x = Object(y.e)(e);
					let D = null,
						T = null;
					try {
						(D = await Object(l.f)(k, g.a.Widgets)) && (T = Object(l.m)(D)(r, _, p))
					} catch (C) {
						const t = Object(f.a)("webSocket");
						return void r(Object(o.f)(i, t))
					}
					if (I && T) try {
						await T
					} catch (C) {}
					const R = await (async (t, e, i) => Object(a.a)(Object(d.a)(t, [u.a]), {
						endpoint: `${t.apiUrl}/r/${e}/api/widget/${i.id}`,
						method: c.jb.PUT,
						type: "json",
						data: i
					}))(w(), v, x);
					if (R.ok) {
						let l = function(t, e, i) {
							switch (t.kind) {
								case b.i.Calendar:
								case b.i.IdCard:
								case b.i.SubredditRules:
									return {
										...t, ...e
									};
								case b.i.CommunityList: {
									const n = {};
									for (const e of t.data) n[e.name] = e;
									return {
										...e,
										data: e.data.map(t => {
											if (!("subscribers" in n[t])) {
												const e = {
														subredditName: t
													},
													n = Object(h.z)(i, e),
													r = Object(h.w)(i, e);
												return {
													name: n.name,
													subscribers: n ? n.subscribers : void 0,
													iconUrl: n ? n.communityIcon : void 0,
													isNSFW: n ? n.isNSFW : void 0,
													isSubscribed: r ? r.userIsSubscriber : void 0
												}
											}
											return n[t]
										})
									}
								}
								case b.i.Button:
								case b.i.Custom:
								case b.i.Image:
								case b.j.Menu:
								case b.i.Moderators:
								case b.i.Textarea:
								case b.i.PostFlair:
									return e;
								default:
									return Object(m.a)(t)
							}
						}(e, R.body, k);
						if (T) {
							if (!I) try {
								await T
							} catch (C) {}
							l = await r(F(t, O)) || l
						}
						r(j({
							subredditId: t,
							widgetId: O,
							widget: l
						})), "calendar" === e.kind && r(Object(s.f)({
							kind: E.b.SuccessMod,
							text: n.fbt._("Calendar is updated! It may take a few minutes to see your events change", null, {
								hk: "10XWV"
							})
						})), r(Object(o.e)(i))
					} else D && D.websocket.close(), r(Object(o.f)(i, R.error))
				}, I = Object(r.a)(w.h), x = (t, e, i) => async (n, r, l) => {
					let {
						apiContext: s
					} = l;
					n(Object(o.h)(i));
					const _ = e.id,
						f = Object(h.U)(r(), {
							subredditId: t
						}).name,
						p = await (async (t, e, i) => Object(a.a)(Object(d.a)(t, [u.a]), {
							endpoint: `${t.apiUrl}/r/${e}/api/widget/${i.id}`,
							method: c.jb.DELETE,
							type: "json"
						}))(s(), f, e);
					p.ok ? (n(Object(o.e)(i)), n(I({
						subredditId: t,
						widgetId: _
					}))) : n(Object(o.f)(i, p.error))
				}, D = Object(r.a)(w.f), T = (t, e) => async (i, n, r) => {
					let {
						apiContext: o
					} = r;
					const l = Object(h.U)(n(), {
						subredditId: t
					}).name;
					(await (async (t, e, i) => Object(a.a)(Object(d.a)(t, [u.a]), {
						endpoint: `${t.apiUrl}/r/${e}/api/widget_order/sidebar`,
						method: c.jb.PATCH,
						type: "json",
						data: i
					}))(o(), l, e)).ok && i(D({
						subredditId: t,
						widgetIds: e
					}))
				}, R = t => {
					let {
						imageData: e
					} = t;
					return async (t, i, n) => {
						const r = i(),
							o = r.structuredStyles.isEditing,
							s = Object(h.U)(r, {
								subredditId: o
							}).name;
						t(Object(l.k)(e));
						const _ = await (async (t, e, i, n) => Object(a.a)(Object(d.a)(t, [u.a]), {
							endpoint: `${t.apiUrl}/r/${e}/api/widget_image_upload_s3`,
							method: c.jb.POST,
							data: {
								filepath: i,
								mimetype: n
							}
						}))(n.apiContext(), s, e.file.name, await Object(p.h)(e.file));
						let f = !1;
						try {
							const n = await Object(l.g)(i(), _, e, g.a.Widgets);
							n && (t(Object(l.j)(n)), f = !0)
						} catch (m) {
							if (m instanceof Error) throw m;
							t(Object(l.i)(m))
						}
						return f
					}
				}, C = Object(r.a)(w.d), L = Object(r.a)(w.e), N = (t, e) => async (i, n, r) => {
					let {
						apiContext: l
					} = r;
					i(Object(o.h)(e));
					const s = Object(h.U)(n(), {
							subredditId: t
						}).name,
						c = await _(l(), s);
					if (c.ok) {
						const n = c.body;
						i(L({
							subredditId: t,
							widgets: n
						})), i(Object(o.e)(e))
					} else i(Object(o.f)(e, c.error))
				}, P = Object(r.a)(w.c), U = Object(r.a)(w.b), A = Object(r.a)(w.a), B = (t, e) => async (i, n, r) => {
					let {
						apiContext: o
					} = r;
					i(P({
						subredditId: t
					}));
					const l = Object(h.U)(n(), {
							subredditId: t
						}).name,
						s = await _(o(), l, e);
					if (s.ok) {
						const e = s.body;
						i(U({
							subredditId: t,
							widgets: e
						}))
					} else i(A({
						subredditId: t,
						error: s.error
					}))
				}, F = (t, e) => async (i, n, r) => {
					let {
						apiContext: o
					} = r;
					const l = Object(h.U)(n(), {
							subredditId: t
						}).name,
						s = await _(o(), l, !0);
					if (s.ok) return s.body.items[e]
				}
		},
		"./src/reddit/components/TrackingHelper/index.tsx": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return d
			})), i.d(e, "b", (function() {
				return u
			})), i.d(e, "c", (function() {
				return _
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./node_modules/react-redux/es/index.js"),
				l = i("./src/reddit/selectors/telemetry.ts"),
				s = i("./src/telemetry/index.ts");

			function c() {
				return (c = Object.assign || function(t) {
					for (var e = 1; e < arguments.length; e++) {
						var i = arguments[e];
						for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
					}
					return t
				}).apply(this, arguments)
			}
			const a = r.a.createContext(() => {});

			function d(t) {
				let {
					children: e
				} = t;
				const i = Object(o.f)(),
					c = Object(n.useCallback)(t => {
						{
							const e = i.getState(),
								n = t(e);
							Object(s.a)({
								...l.n(e),
								...n
							})
						}
					}, [i]);
				return r.a.createElement(a.Provider, {
					value: c
				}, e ? r.a.Children.only(e) : null)
			}

			function u() {
				return Object(n.useContext)(a)
			}

			function _(t) {
				function e(e) {
					const i = u();
					return r.a.createElement(t, c({}, e, {
						sendEvent: i
					}))
				}
				const i = t.name || t.displayName;
				return e.displayName = `Tracked(${i})`, e.WrappedComponent = t, e
			}
		},
		"./src/reddit/constants/elementIds.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			})), i.d(e, "b", (function() {
				return r
			})), i.d(e, "d", (function() {
				return o
			})), i.d(e, "e", (function() {
				return l
			})), i.d(e, "c", (function() {
				return s
			}));
			const n = "AppRouter-main-content",
				r = "bladeContainer",
				o = "header",
				l = "overlayScrollContainer",
				s = "collectionPostListScrollContainer"
		},
		"./src/reddit/constants/shortcuts.ts": function(t, e, i) {
			"use strict";
			var n, r;
			i.d(e, "d", (function() {
					return n
				})), i.d(e, "c", (function() {
					return r
				})), i.d(e, "b", (function() {
					return o
				})), i.d(e, "a", (function() {
					return l
				})),
				function(t) {
					t.CommentPage = "CommentPage", t.Global = "Global", t.Lightbox = "Lightbox", t.Listing = "Listing", t.Modqueue = "Modqueue"
				}(n || (n = {})),
				function(t) {
					t.Close = "CLOSE", t.CollapseOrLoad = "COLLAPSE_OR_LOAD", t.Downvote = "DOWNVOTE", t.Expando = "EXPANDO", t.Hide = "HIDE", t.Konami = "KONAMI", t.NewPost = "NEW_POST", t.NextComment = "NEXT_COMMENT", t.NextPost = "NEXT_POST", t.OpenIndex = "OPEN_INDEX", t.OpenLightbox = "OPEN_LIGHTBOX", t.OpenLink = "OPEN_LINK", t.PrevComment = "PREV_COMMENT", t.PrevPost = "PREV_POST", t.Reply = "REPLY", t.Save = "SAVE", t.Upvote = "UPVOTE"
				}(r || (r = {}));
			const o = "SHORTCUT_FOCUSABLE_DIV",
				l = [9, 13, 32]
		},
		"./src/reddit/constants/zIndex.ts": function(t, e, i) {
			"use strict";
			i.d(e, "f", (function() {
				return n
			})), i.d(e, "c", (function() {
				return r
			})), i.d(e, "d", (function() {
				return o
			})), i.d(e, "a", (function() {
				return l
			})), i.d(e, "e", (function() {
				return s
			})), i.d(e, "g", (function() {
				return c
			})), i.d(e, "b", (function() {
				return a
			}));
			const n = 4,
				r = 60,
				o = 70,
				l = 90,
				s = 99,
				c = 100,
				a = 100
		},
		"./src/reddit/controls/Button/index.m.less": function(t, e, i) {
			t.exports = {
				Button: "_2iuoyPiKHN3kfOoeIQalDT",
				button: "_2iuoyPiKHN3kfOoeIQalDT",
				isFullWidth: "_34mIRHpFtnJ0Sk97S2Z3D9",
				xxsmallButtonStyles: "_1h6qKGhVsgNfytYFlo8m3f",
				Icon: "_1mvTX6krm3Q2d1CSyUm28s",
				icon: "_1mvTX6krm3Q2d1CSyUm28s",
				isLeft: "_1HHR_ND8U6x6YrIqKFeXZy",
				isRight: "_3tKmDp5VAtgWvabEmFkJ7T",
				xsmallButtonStyles: "_3uJP0daPEH2plzVEYyTdaH",
				xsmallBigPaddingButtonStyles: "UEPNkU0rd1-nvbkOcBatc",
				smallButtonStyles: "HNozj_dKjQZ59ZsfEegz8",
				mediumButtonStyles: "_3ukcnQySDskQwK_wB2iXYl",
				largeButtonStyles: "_1J4mN6_wNfCtSyMDUNGQqN",
				xlargeButtonStyles: "XpD6n11mOiKNg8ZKtvgVR",
				primary: "_10BQ7pjWbeYP63SAPNS8Ts",
				active: "_39a0Mt5b1i2joAqIaEHOWJ",
				redditStyle: "_2nelDm85zKKmuD94NequP0",
				DangerButtonColors: "_1t63zWyh9UUgsyQc6acROM",
				dangerButtonColors: "_1t63zWyh9UUgsyQc6acROM",
				GoldButtonColors: "_10UWrWSil1Xu6pdSaa_3-K",
				goldButtonColors: "_10UWrWSil1Xu6pdSaa_3-K",
				PremiumButtonColors: "q_unSaY23rpdd3lDvGZ-",
				premiumButtonColors: "q_unSaY23rpdd3lDvGZ-",
				secondary: "_2tU8R9NTqhvBrhoNAXWWcP",
				tertiary: "_4Glnzr5LA7bNBGMWGW4pU",
				plain: "_3zbhtNO0bdck0oYbYRhjMC",
				isIconOnly: "_1tPpYVD73ugqp4k-VMFRki",
				isSquare: "_3ojSE1JW7jxNzUzZK8kt7m",
				ExtraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				extraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				InlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				inlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				ChatButton: "_13twe55MPRo1LqypxB-LJx",
				chatButton: "_13twe55MPRo1LqypxB-LJx",
				PlainLinkButton: "_2UhHcZFBOYxMULbf2p-skl",
				plainLinkButton: "_2UhHcZFBOYxMULbf2p-skl"
			}
		},
		"./src/reddit/controls/Button/index.tsx": function(t, e, i) {
			"use strict";
			i.d(e, "d", (function() {
				return u
			})), i.d(e, "c", (function() {
				return _
			})), i.d(e, "h", (function() {
				return f
			})), i.d(e, "b", (function() {
				return p
			})), i.d(e, "a", (function() {
				return m
			})), i.d(e, "m", (function() {
				return g
			})), i.d(e, "n", (function() {
				return E
			})), i.d(e, "l", (function() {
				return S
			})), i.d(e, "p", (function() {
				return w
			})), i.d(e, "q", (function() {
				return O
			})), i.d(e, "o", (function() {
				return k
			})), i.d(e, "s", (function() {
				return j
			})), i.d(e, "r", (function() {
				return v
			})), i.d(e, "f", (function() {
				return I
			})), i.d(e, "g", (function() {
				return x
			})), i.d(e, "k", (function() {
				return D
			})), i.d(e, "e", (function() {
				return T
			})), i.d(e, "i", (function() {
				return R
			})), i.d(e, "j", (function() {
				return C
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./src/lib/classNames/index.ts"),
				l = i("./src/reddit/controls/InternalLink/index.tsx"),
				s = i("./src/reddit/controls/Button/index.m.less"),
				c = i.n(s);

			function a() {
				return (a = Object.assign || function(t) {
					for (var e = 1; e < arguments.length; e++) {
						var i = arguments[e];
						for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
					}
					return t
				}).apply(this, arguments)
			}
			const d = {
				role: "button",
				tabIndex: 0
			};
			var u, _, f, p;
			! function(t) {
				t.XXS = "xxsmallButtonStyles", t.XS = "xsmallButtonStyles", t.XSP = "xsmallBigPaddingButtonStyles", t.S = "smallButtonStyles", t.M = "mediumButtonStyles", t.L = "largeButtonStyles", t.XL = "xlargeButtonStyles"
			}(u || (u = {})),
			function(t) {
				t.Primary = "primary", t.Secondary = "secondary", t.Tertiary = "tertiary", t.Plain = "plain", t.PlainLink = "plainLink"
			}(_ || (_ = {})),
			function(t) {
				t.L = "left", t.R = "right", t.C = "center"
			}(f || (f = {})),
			function(t) {
				t.Button = "button", t.ExternalLink = "external-link", t.InternalLink = "internal-link"
			}(p || (p = {}));
			const m = t => {
					const {
						"data-redditstyle": e,
						Icon: i,
						iconClassName: n,
						iconPosition: l = f.C,
						isFullWidth: s = !1,
						isSquare: m = !1,
						children: g,
						className: E,
						kind: S = p.Button,
						priority: w = _.Primary,
						redditStyle: O,
						size: k = u.S,
						text: j,
						textClassName: v,
						...I
					} = t, x = (t => {
						let {
							baseClassName: e,
							redditStyle: i,
							dataRedditStyle: n,
							Icon: r,
							isFullWidth: l,
							isSquare: s,
							priority: a,
							size: d,
							text: u
						} = t;
						return Object(o.a)(e, c.a.Button, a && c.a[a], d && c.a[d], {
							[c.a.isFullWidth]: l,
							[c.a.isIconOnly]: !!r && !u,
							[c.a.isSquare]: s,
							[c.a.redditStyle]: !(!i && !n)
						})
					})({
						baseClassName: E,
						children: g,
						dataRedditStyle: e,
						Icon: i,
						isFullWidth: s,
						isSquare: m,
						priority: w,
						redditStyle: O,
						size: k,
						text: j
					}), D = (t => {
						let {
							children: e,
							text: i,
							Icon: n,
							iconClassName: l,
							iconPosition: s,
							priority: a,
							textClassName: d
						} = t;
						return !n && i ? r.a.createElement("span", {
							className: d
						}, i) : r.a.createElement(r.a.Fragment, null, n && (s === f.C || s === f.L) && r.a.createElement(n, {
							className: Object(o.a)(c.a.Icon, l, {
								[c.a.isLeft]: s === f.L
							}),
							isFilled: a === _.Primary
						}), i && r.a.createElement("span", {
							className: Object(o.a)(c.a.Text, d)
						}, i), e && e, n && s === f.R && r.a.createElement(n, {
							className: Object(o.a)(c.a.Icon, l, c.a.isRight),
							isFilled: a === _.Primary
						}))
					})({
						children: g,
						text: j,
						Icon: i,
						iconClassName: n,
						iconPosition: l,
						priority: w,
						textClassName: v
					});
					return S === p.InternalLink && (t => "to" in t)(I) ? r.a.createElement(b, a({}, d, I, {
						className: x
					}), D) : S === p.ExternalLink && (t => "href" in t)(I) ? r.a.createElement(h, a({}, d, I, {
						className: x
					}), D) : r.a.createElement(y, a({}, d, I, {
						className: x
					}), D)
				},
				b = t => r.a.createElement(l.default, t),
				h = t => r.a.createElement("a", t),
				y = t => r.a.createElement("button", t),
				g = t => r.a.createElement(m, a({
					kind: p.ExternalLink,
					priority: _.Primary
				}, t)),
				E = t => r.a.createElement(m, a({
					kind: p.InternalLink,
					priority: _.Primary
				}, t)),
				S = t => r.a.createElement(m, a({
					kind: p.Button,
					priority: _.Primary
				}, t)),
				w = t => r.a.createElement(m, a({
					kind: p.ExternalLink,
					priority: _.Secondary
				}, t)),
				O = t => r.a.createElement(m, a({
					kind: p.InternalLink,
					priority: _.Secondary
				}, t)),
				k = t => r.a.createElement(m, a({
					kind: p.Button,
					priority: _.Secondary
				}, t)),
				j = t => r.a.createElement(m, a({
					kind: p.InternalLink,
					priority: _.Plain
				}, t)),
				v = t => r.a.createElement(m, a({
					kind: p.Button,
					priority: _.Plain
				}, t)),
				I = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						priority: _.Primary,
						className: Object(o.a)(e, c.a.DangerButtonColors)
					}, i))
				},
				x = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.GoldButtonColors)
					}, i))
				},
				D = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.PremiumButtonColors)
					}, i))
				},
				T = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.ChatButton)
					}, i))
				},
				R = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.InlineTextButton)
					}, i))
				},
				C = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.PlainLinkButton),
						priority: _.PlainLink
					}, i))
				};
			e.t = m
		},
		"./src/reddit/controls/Dropdown/index.m.less": function(t, e, i) {
			t.exports = {
				dropdownTriangle: "_1oxgVV3q47KbjEKqP5CHuM",
				dropdown: "_2uYY-KeuYHKiwl-9aF0UiL"
			}
		},
		"./src/reddit/controls/Dropdown/index.tsx": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return d
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./src/lib/classNames/index.ts"),
				l = i("./src/lib/domUtils/index.ts"),
				s = i("./src/reddit/constants/zIndex.ts"),
				c = i("./src/reddit/controls/Dropdown/index.m.less"),
				a = i.n(c);
			class d extends r.a.Component {
				componentDidMount() {
					this.props.onDropdownMounted && this.props.onDropdownMounted(), this.props.noFocus || this.ref && this.ref.focus({
						preventScroll: this.props.isOverlay
					})
				}
				componentWillUnmount() {
					Object(l.a)(this.props.tooltipId)
				}
				render() {
					const t = this.props,
						e = {};
					return (t.isFixed || t.isOverlay) && (t.isFixed && (e.position = "fixed"), t.isOverlay && (e.zIndex = t.isFixed ? s.d + 1 : s.c)), r.a.createElement("div", {
						className: Object(o.a)(a.a.dropdown, t.className),
						id: this.props.id,
						ref: t => this.ref = t,
						role: "menu",
						style: {
							...e,
							...t.style
						},
						tabIndex: -1,
						onScroll: t.onScroll
					}, t.children)
				}
			}
		},
		"./src/reddit/controls/InternalLink/index.m.less": function(t, e, i) {
			t.exports = {
				disabledLink: "_1tQt2CUWT3M7NNSMoh_o_4"
			}
		},
		"./src/reddit/controls/InternalLink/index.tsx": function(t, e, i) {
			"use strict";
			i.r(e), i.d(e, "default", (function() {
				return u
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./node_modules/react-router-dom/esm/react-router-dom.js"),
				l = i("./src/lib/classNames/index.ts"),
				s = i("./src/reddit/helpers/path/index.ts"),
				c = i("./src/reddit/controls/InternalLink/index.m.less"),
				a = i.n(c);

			function d() {
				return (d = Object.assign || function(t) {
					for (var e = 1; e < arguments.length; e++) {
						var i = arguments[e];
						for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
					}
					return t
				}).apply(this, arguments)
			}

			function u(t) {
				let {
					children: e,
					className: i,
					disabled: n,
					replace: c,
					to: u,
					..._
				} = t;
				return n ? r.a.createElement("span", {
					className: Object(l.a)(a.a.disabledLink, i)
				}, e) : ("string" == typeof u && (u = Object(s.b)(u)), r.a.createElement(o.a, d({
					className: i,
					to: u
				}, _), e))
			}
		},
		"./src/reddit/helpers/getTimeSortForListing/index.ts": function(t, e, i) {
			"use strict";
			var n = i("./src/lib/constants/index.ts"),
				r = i("./src/lib/listingSort/index.ts");
			e.a = (t, e) => {
				if (t) return Object(r.a)(t) ? e || n.jc : void 0
			}
		},
		"./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts": function(t, e, i) {
			"use strict";
			e.a = t => ({
				...t.id && {
					id: t.id
				},
				...t.postBackgroundColor && {
					postBackgroundColor: t.postBackgroundColor
				},
				...t.postBackgroundImage && {
					postBackgroundImage: t.postBackgroundImage
				},
				...t.postPlaceholderImage && {
					postPlaceholderImage: t.postPlaceholderImage
				},
				...t.postTitleColor && {
					postTitleColor: t.postTitleColor
				}
			})
		},
		"./src/reddit/helpers/pageActionLoginRedirect.ts": function(t, e, i) {
			"use strict";
			i("./node_modules/history/esm/history.js"), i("./src/reddit/actions/platform.ts");
			var n = i("./src/config.ts");
			e.a = (t, e) => {
				const i = e.platform.currentPage && e.platform.currentPage.url;
				let r = `${n.a.accountManagerOrigin}/login/`;
				const o = window.location.origin;
				i && (r += `?dest=${encodeURIComponent(`${o}${i}`)}`), window.location.href = r
			}
		},
		"./src/reddit/helpers/toggleBodyScroll/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "b", (function() {
				return o
			})), i.d(e, "a", (function() {
				return l
			})), i.d(e, "e", (function() {
				return s
			})), i.d(e, "d", (function() {
				return c
			})), i.d(e, "c", (function() {
				return a
			}));
			var n = i("./src/reddit/constants/elementIds.ts");
			let r;
			const o = () => {
					const t = document.body.dataset.previousOverflow;
					if (!t) return;
					document.body.removeAttribute("data-previous-overflow");
					const e = document.getElementById(n.d);
					document.body.style.overflow = t, document.body.style.marginRight = "", e && (e.style.marginRight = "")
				},
				l = () => {
					if (document.body.dataset.previousOverflow) return;
					const t = document.body.style.overflow || "auto";
					document.body.dataset.previousOverflow = t, r || (r = c(document.body)), document.body.style.overflow = "hidden", document.body.style.marginRight = `${r}px`;
					const e = document.getElementById(n.d);
					e && (e.style.marginRight = `${r}px`)
				},
				s = t => {
					t ? o() : l()
				},
				c = t => {
					const e = t.getBoundingClientRect();
					return window.innerWidth - (e.left + e.right)
				},
				a = t => {
					if (!t || !document.body) return 0;
					const e = c(document.body),
						i = t.offsetWidth - t.scrollWidth;
					return e || i
				}
		},
		"./src/reddit/helpers/trackers/blade.ts": function(t, e, i) {
			"use strict";
			i.d(e, "i", (function() {
				return l
			})), i.d(e, "h", (function() {
				return s
			})), i.d(e, "f", (function() {
				return c
			})), i.d(e, "g", (function() {
				return a
			})), i.d(e, "c", (function() {
				return d
			})), i.d(e, "d", (function() {
				return u
			})), i.d(e, "j", (function() {
				return f
			})), i.d(e, "b", (function() {
				return p
			})), i.d(e, "a", (function() {
				return m
			})), i.d(e, "e", (function() {
				return h
			})), i.d(e, "k", (function() {
				return y
			}));
			var n = i("./src/reddit/constants/blade.ts"),
				r = i("./src/reddit/selectors/telemetry.ts");
			const o = (t, e) => i => ({
					...r.n(i),
					source: n.c.Appearance,
					action: "click",
					noun: t,
					actionInfo: r.d(i, {
						paneName: e
					}),
					subreddit: r.hb(i)
				}),
				l = t => o("save_style", t),
				s = t => o("cancel_style", t),
				c = t => e => ({
					source: n.c.Structure,
					action: "click",
					noun: t,
					screen: r.Z(e),
					subreddit: r.hb(e)
				}),
				a = t => e => ({
					source: n.c.Appearance,
					action: "click",
					noun: t,
					screen: r.Z(e),
					subreddit: r.hb(e)
				}),
				d = (t, e) => i => ({
					source: "colorpicker",
					action: "click",
					noun: t,
					actionInfo: r.d(i, {
						paneName: n.f[e]
					}),
					screen: r.Z(i),
					subreddit: r.hb(i)
				}),
				u = t => e => ({
					source: n.g[t],
					action: "click",
					noun: "colorpicker",
					actionInfo: r.d(e, {
						paneName: n.f[t]
					}),
					screen: r.Z(e),
					subreddit: r.hb(e)
				}),
				_ = t => ({
					screen: r.Z(t),
					subreddit: r.hb(t)
				}),
				f = () => t => ({
					source: n.c.Appearance,
					action: "view",
					noun: "blade",
					..._(t)
				}),
				p = t => e => ({
					source: n.a[t],
					action: "click",
					noun: n.b[t],
					..._(e)
				}),
				m = () => t => ({
					source: n.c.Appearance,
					action: "click",
					noun: "back",
					..._(t)
				}),
				b = t => e => ({
					source: n.c.PostFlairManagement,
					action: "click",
					noun: t,
					..._(e)
				}),
				h = (t, e) => ({
					...r.n(t),
					...b(e)(t)
				}),
				y = t => e => ({
					source: n.c.MenuLinks,
					action: "click",
					noun: t ? "wiki_link_on" : "wiki_link_off",
					screen: r.Z(e),
					subreddit: r.hb(e),
					userSubreddit: r.rb(e)
				})
		},
		"./src/reddit/helpers/trackers/postComposer.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return g
			})), i.d(e, "e", (function() {
				return E
			})), i.d(e, "K", (function() {
				return S
			})), i.d(e, "I", (function() {
				return w
			})), i.d(e, "C", (function() {
				return O
			})), i.d(e, "z", (function() {
				return k
			})), i.d(e, "A", (function() {
				return j
			})), i.d(e, "M", (function() {
				return v
			})), i.d(e, "B", (function() {
				return I
			})), i.d(e, "m", (function() {
				return x
			})), i.d(e, "E", (function() {
				return D
			})), i.d(e, "D", (function() {
				return T
			})), i.d(e, "t", (function() {
				return R
			})), i.d(e, "s", (function() {
				return C
			})), i.d(e, "L", (function() {
				return L
			})), i.d(e, "p", (function() {
				return N
			})), i.d(e, "o", (function() {
				return P
			})), i.d(e, "q", (function() {
				return U
			})), i.d(e, "f", (function() {
				return B
			})), i.d(e, "r", (function() {
				return M
			})), i.d(e, "j", (function() {
				return q
			})), i.d(e, "g", (function() {
				return G
			})), i.d(e, "h", (function() {
				return K
			})), i.d(e, "d", (function() {
				return z
			})), i.d(e, "H", (function() {
				return Y
			})), i.d(e, "i", (function() {
				return H
			})), i.d(e, "c", (function() {
				return X
			})), i.d(e, "v", (function() {
				return V
			})), i.d(e, "u", (function() {
				return Q
			})), i.d(e, "G", (function() {
				return Z
			})), i.d(e, "w", (function() {
				return J
			})), i.d(e, "k", (function() {
				return tt
			})), i.d(e, "F", (function() {
				return et
			})), i.d(e, "y", (function() {
				return it
			})), i.d(e, "b", (function() {
				return nt
			})), i.d(e, "n", (function() {
				return rt
			})), i.d(e, "x", (function() {
				return ot
			})), i.d(e, "l", (function() {
				return lt
			})), i.d(e, "J", (function() {
				return st
			}));
			var n = i("./src/reddit/constants/tracking.ts"),
				r = i("./src/reddit/helpers/correlationIdTracker.ts"),
				o = i("./src/reddit/helpers/media/index.ts"),
				l = i("./src/reddit/models/PostCreationForm/index.ts"),
				s = i("./src/reddit/models/PostDraft/index.ts"),
				c = i("./src/reddit/selectors/experiments/postCreationSubRec.ts"),
				a = i("./src/reddit/selectors/postDraft.ts"),
				d = i("./src/reddit/selectors/subreddit.ts"),
				u = i("./src/reddit/selectors/telemetry.ts"),
				_ = i("./src/reddit/selectors/user.ts"),
				f = i("./src/telemetry/index.ts"),
				p = i("./src/telemetry/models/PostComposer.ts"),
				m = i("./src/telemetry/models/PostDraft.ts");
			const b = {
					imageOnly: "image",
					linkOnly: "link",
					media: "media",
					poll: "poll",
					post: "self",
					prediction: "prediction",
					crosspost: "crosspost",
					talk: "talk"
				},
				h = t => ({
					source: "post_composer",
					action: n.c.CLICK,
					...u.n(t),
					screen: u.Z(t),
					correlationId: Object(r.c)(r.a.PostComposer)
				}),
				y = (t, e) => "self" !== e ? {} : {
					editorMode: t.user.prefs.editorMode === l.i.MARKDOWN ? "markdown" : "rte"
				},
				g = t => {
					Object(f.a)({
						noun: "cancel",
						...h(t)
					})
				},
				E = t => {
					Object(f.a)({
						noun: "discard",
						...h(t)
					})
				},
				S = t => e => ({
					...h(e),
					noun: "subreddit_choice",
					subreddit: t ? u.ib(e, t) : void 0,
					actionInfo: u.g(e)
				}),
				w = () => t => ({
					...h(t),
					noun: "subreddit_selector"
				}),
				O = (t, e) => {
					Object(f.a)({
						noun: "post_type_selector",
						postComposer: {
							type: b[e]
						},
						...h(t)
					})
				},
				k = () => t => ({
					noun: "add_option",
					...h(t)
				}),
				j = () => t => ({
					noun: "voting_length",
					...h(t)
				}),
				v = (t, e, i) => {
					"image_upload" === e || "video_upload" === e ? Object(f.a)({
						noun: e,
						...h(t)
					}) : Object(f.a)({
						noun: "text_option",
						postComposer: {
							textType: e,
							finalStatus: i ? "on" : "off"
						},
						...h(t)
					})
				},
				I = (t, e, i, n) => {
					Object(f.a)({
						noun: "post",
						subreddit: u.hb(t),
						postComposer: {
							type: e,
							...y(t, e)
						},
						post: i ? u.I(t, i) : null,
						...h(t),
						correlationId: n
					})
				},
				x = (t, e) => {
					const i = e === l.i.MARKDOWN ? "markdown_mode" : "rte_mode";
					Object(f.a)({
						noun: i,
						...h(t)
					})
				},
				D = (t, e) => {
					Object(f.a)({
						noun: "save",
						subreddit: u.hb(t),
						postComposer: {
							type: e,
							...y(t, e)
						},
						...h(t)
					})
				},
				T = (t, e) => {
					const i = t.uploads[e];
					i.error && Object(f.a)({
						...h(t),
						noun: "media",
						action: n.c.REJECT,
						actionInfo: {
							...u.d(t),
							reason: JSON.stringify(i.error)
						}
					})
				},
				R = (t, e) => {
					e.forEach(e => {
						const i = Object(o.g)(e.type);
						i && Object(f.a)({
							...h(t),
							action: n.c.DRAG,
							noun: i
						})
					})
				},
				C = (t, e, i) => {
					Object(f.a)({
						...h(t),
						noun: "input",
						postComposer: {
							inputType: i
						},
						action: e,
						actionInfo: u.g(t)
					})
				},
				L = (t, e, i) => {
					Object(f.a)({
						...h(t),
						noun: i,
						action: Object(p.getToggleAction)(e),
						actionInfo: u.g(t)
					})
				},
				N = t => A("input", t),
				P = () => A("add"),
				U = () => A("remove_image"),
				A = (t, e) => i => ({
					...h(i),
					noun: t,
					postComposer: {
						inputType: e,
						type: b.imageOnly
					},
					action: n.c.CLICK
				}),
				B = t => {
					Object(f.a)({
						...h(t),
						noun: "hide_oc_description",
						action: n.c.CLICK
					})
				},
				F = (t, e) => {
					if (e) {
						const i = u.ib(t, e);
						if (i) return {
							subreddit: i
						};
						const n = u.S(t, e);
						if (n) return {
							profile: n
						}
					}
				},
				M = (t, e) => {
					const {
						draftId: i,
						destSubreddit: n
					} = e, r = Object(_.k)(t), o = Object(a.d)(t, {
						draftId: i
					}), l = {
						authorId: r ? r.id : void 0,
						createdTimestamp: o ? o.created : void 0,
						id: i || void 0,
						nsfw: e.isNSFW,
						originalContent: e.isOC,
						spoiler: e.isSpoiler,
						titleLength: e.title.length
					};
					switch (e.kind) {
						case s.b.Link:
							l.type = m.DraftType.Link, l.urlLength = e.body.length;
							break;
						case s.b.Markdown:
							l.type = m.DraftType.Self, l.bodyTextLength = e.body.length;
							break;
						case s.b.RichText:
							l.type = m.DraftType.RichText, e.documentStats && (l.bodyTextLength = e.documentStats.textLength, l.numberRteImages = e.documentStats.rteImagesCount, l.numberRteVideos = e.documentStats.rteVideosCount);
							break;
						case s.b.Image:
							l.type = m.DraftType.Image;
							break;
						case s.b.Video:
							l.type = m.DraftType.Video
					}
					return {
						postDraft: l,
						...F(t, n.id)
					}
				},
				W = (t, e) => {
					const i = Object(_.k)(t),
						n = {
							authorId: i ? i.id : void 0,
							createdTimestamp: e.created,
							id: e.id,
							nsfw: e.isNSFW,
							originalContent: e.isOriginalContent,
							spoiler: e.isSpoiler,
							titleLength: e.title.length
						};
					switch (e.kind) {
						case s.b.Link:
							n.type = m.DraftType.Link, n.urlLength = (e.body || "").length;
							break;
						case s.b.Markdown:
							n.type = m.DraftType.Self, n.bodyTextLength = (e.body || "").length;
							break;
						case s.b.RichText:
							n.type = m.DraftType.RichText
					}
					return {
						postDraft: n,
						...F(t, e.subredditId)
					}
				},
				q = (t, e) => {
					Object(f.a)({
						noun: "draft_load",
						...h(t),
						...M(t, e)
					})
				},
				G = (t, e) => {
					Object(f.a)({
						noun: e.draftId ? "draft_update" : "draft_create",
						...h(t),
						...M(t, e)
					})
				},
				K = (t, e) => {
					Object(f.a)({
						noun: "draft_delete",
						...h(t),
						...W(t, e)
					})
				},
				z = t => {
					Object(f.a)({
						...h(t),
						noun: "social_connect_link",
						action: n.c.CLICK
					})
				},
				Y = (t, e) => {
					Object(f.a)({
						...h(t),
						noun: "twitter_share_checkbox",
						action: Object(p.getToggleAction)(e)
					})
				},
				H = (t, e, i) => {
					Object(f.a)({
						...h(t),
						...M(t, e),
						noun: "draft_share",
						action: i ? n.c.ENABLE : n.c.DISABLE
					})
				},
				X = t => {
					Object(f.a)({
						...h(t),
						noun: "create_community",
						actionInfo: {
							...u.d(t),
							pageType: "post_select_community"
						}
					})
				},
				$ = "community_recommendation",
				V = () => t => ({
					...h(t),
					action: n.c.VIEW,
					noun: $,
					listing: {
						links: Object(c.c)(t).map(e => Object(d.F)(t, e.name))
					}
				}),
				Q = (t, e) => i => ({
					...h(i),
					action: n.c.CLICK,
					noun: $,
					actionInfo: {
						...u.d(i),
						position: e
					},
					subreddit: {
						name: t,
						id: Object(d.F)(i, t)
					}
				}),
				Z = t => {
					Object(f.a)({
						...h(t),
						action: n.c.SKIP,
						noun: $
					})
				},
				J = (t, e) => i => ({
					...h(i),
					action: n.c.VIEW,
					noun: `${$}_hover`,
					actionInfo: {
						...u.d(i),
						position: e
					},
					subreddit: {
						name: t,
						id: Object(d.F)(i, t)
					}
				}),
				tt = t => e => ({
					...h(e),
					action: n.c.CLICK,
					noun: "draft_preview",
					actionInfo: {
						...u.d(e),
						count: t
					}
				}),
				et = t => e => ({
					...h(e),
					action: "add",
					noun: "flair",
					subreddit: u.ib(e, t)
				}),
				it = () => t => ({
					...h(t),
					action: n.c.CLICK,
					noun: "flair_dropdown"
				}),
				nt = () => t => ({
					...h(t),
					action: "clear",
					noun: "flair"
				}),
				rt = () => t => ({
					...h(t),
					action: "search",
					noun: "flair"
				}),
				ot = t => {
					let {
						actionInfoType: e,
						subredditId: i = "",
						noun: o = "create_post"
					} = t;
					return t => ({
						...h(t),
						action: n.c.CLICK,
						noun: o,
						actionInfo: {
							...u.d(t),
							type: e
						},
						correlationId: Object(r.d)(r.a.PostComposer, !1),
						subreddit: i ? u.ib(t, i) : void 0
					})
				},
				lt = () => t => ({
					...h(t),
					action: n.c.CLICK,
					noun: "edit_post"
				}),
				st = t => e => ({
					...h(e),
					action: "type",
					noun: "subreddit_search",
					actionInfo: {
						...u.d(e),
						type: t
					}
				})
		},
		"./src/reddit/icons/fonts/helpers.m.less": function(t, e, i) {
			t.exports = {
				TooltipDesc: "_37iEJpUpWXN00_fpZKHglg",
				tooltipDesc: "_37iEJpUpWXN00_fpZKHglg"
			}
		},
		"./src/reddit/icons/fonts/helpers.tsx": function(t, e, i) {
			"use strict";
			i.d(e, "b", (function() {
				return a
			})), i.d(e, "a", (function() {
				return d
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./src/reddit/icons/fonts/helpers.m.less"),
				l = i.n(o),
				s = i("./src/lib/constants/icons.ts"),
				c = i("./src/lib/lessComponent.tsx");
			const a = (t, e) => `icon icon-${t}${e&&!t.includes("fill")&&s.a[`${t}_fill`]?"_fill":""}`,
				d = c.a.wrapped(t => r.a.createElement("span", {
					className: t.className
				}, t.children), "TooltipDesc", l.a)
		},
		"./src/reddit/icons/svgs/Close/index.tsx": function(t, e, i) {
			"use strict";
			var n = i("./node_modules/react/index.js"),
				r = i.n(n);

			function o() {
				return (o = Object.assign || function(t) {
					for (var e = 1; e < arguments.length; e++) {
						var i = arguments[e];
						for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
					}
					return t
				}).apply(this, arguments)
			}
			e.a = t => r.a.createElement("svg", o({
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, t), r.a.createElement("polygon", {
				fill: "inherit",
				points: "11.649 9.882 18.262 3.267 16.495 1.5 9.881 8.114 3.267 1.5 1.5 3.267 8.114 9.883 1.5 16.497 3.267 18.264 9.881 11.65 16.495 18.264 18.262 16.497"
			}))
		},
		"./src/reddit/models/ApiRequestState/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			})), i.d(e, "b", (function() {
				return l
			}));
			var n, r = i("./node_modules/uuid/v4.js"),
				o = i.n(r);
			! function(t) {
				t[t.Pending = 0] = "Pending", t[t.Complete = 1] = "Complete", t[t.Failed = 2] = "Failed"
			}(n || (n = {}));
			const l = () => o()()
		},
		"./src/reddit/selectors/experiments/postCreationSubRec.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return d
			})), i.d(e, "b", (function() {
				return u
			})), i.d(e, "g", (function() {
				return p
			})), i.d(e, "j", (function() {
				return m
			})), i.d(e, "h", (function() {
				return b
			})), i.d(e, "i", (function() {
				return h
			})), i.d(e, "f", (function() {
				return y
			})), i.d(e, "d", (function() {
				return g
			})), i.d(e, "c", (function() {
				return E
			})), i.d(e, "e", (function() {
				return S
			})), i.d(e, "l", (function() {
				return w
			})), i.d(e, "k", (function() {
				return O
			})), i.d(e, "m", (function() {
				return k
			}));
			var n = i("./src/lib/constants/index.ts"),
				r = i("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				o = i("./src/reddit/constants/experiments.ts"),
				l = i("./src/reddit/helpers/chooseVariant/index.ts"),
				s = i("./src/reddit/models/PostCreationForm/index.ts"),
				c = i("./src/reddit/models/SubredditAutocomplete/index.ts"),
				a = i("./src/reddit/selectors/subreddit.ts");
			const d = 3,
				u = t => _(t) ? 1 : (f(t), .5),
				_ = t => {
					return Object(l.c)(t, {
						experimentEligibilitySelector: l.a,
						experimentName: o.Ge
					}) === o.Ie.ContentMatch
				},
				f = t => {
					return Object(l.c)(t, {
						experimentEligibilitySelector: l.a,
						experimentName: o.Ge
					}) === o.Ie.ConfidenceAndSuccess
				},
				p = t => {
					const e = Object(l.c)(t, {
						experimentEligibilitySelector: l.a,
						experimentName: o.Ge
					});
					return e === o.Ie.ContentMatch || e === o.Ie.ConfidenceAndSuccess || e === o.cb.Control1 || e === o.cb.Control2
				},
				m = t => {
					const e = Object(l.c)(t, {
						experimentEligibilitySelector: l.a,
						experimentName: o.Ge
					});
					return e === o.cb.Control1 || e === o.cb.Control2
				},
				b = t => {
					const e = Object(l.c)(t, {
						experimentEligibilitySelector: l.a,
						experimentName: o.Ge
					});
					return e === o.Ie.ContentMatch || e === o.Ie.ConfidenceAndSuccess
				},
				h = t => t.creations.subredditRec.api.pending,
				y = t => t.creations.subredditRec.api.error,
				g = t => {
					return t.creations.subredditRec.order.length > 0
				},
				E = t => {
					const e = t.creations.subredditRec.order,
						i = [];
					return e.forEach(e => {
						const n = Object(a.w)(t, {
								subredditName: e
							}),
							r = Object(a.z)(t, {
								subredditName: e
							});
						if (r && n) {
							const t = {
								iconUrl: r.icon.url,
								name: r.name,
								primaryColor: r.primaryColor,
								subscribers: n.subscribers,
								type: c.a.OTHER_SUBREDDIT
							};
							i.push(t)
						}
					}), i
				},
				S = t => t.creations.subredditRec.isInputChanged,
				w = t => {
					if (!(t.creations.formData.submissionType === n.Wb.POST)) return "";
					const e = t.creations.formState.editorMode === s.i.RICH_TEXT || null === t.creations.formState.editorMode,
						i = t.creations.formState.editorMode === s.i.MARKDOWN;
					if (e) {
						const e = t.creations.formData.body.rte;
						return r.a.getRawText(e, " ") || ""
					}
					return i && t.creations.formData.body.markdown || ""
				},
				O = t => {
					return t.creations.formData.submissionType === n.Wb.LINK_ONLY && t.creations.formData.body.link || ""
				},
				k = t => p(t) && (!y(t) || y(t) && S(t)) && (t => {
					const e = t.creations.formData.title,
						i = O(t),
						n = w(t);
					return !!(e || i || n)
				})(t) && (t.creations.formData.submissionType === n.Wb.POST || t.creations.formData.submissionType === n.Wb.LINK_ONLY || t.creations.formData.submissionType === n.Wb.CROSSPOST)
		},
		"./src/reddit/selectors/experiments/topPosts.ts": function(t, e, i) {
			"use strict";
			i.d(e, "d", (function() {
				return a
			})), i.d(e, "a", (function() {
				return d
			})), i.d(e, "b", (function() {
				return u
			})), i.d(e, "c", (function() {
				return _
			}));
			var n = i("./node_modules/reselect/es/index.js"),
				r = i("./src/reddit/constants/experiments.ts"),
				o = i("./src/reddit/contexts/PageLayer/index.tsx"),
				l = i("./src/reddit/helpers/chooseVariant/index.ts"),
				s = i("./src/reddit/selectors/user.ts");
			const c = Object(n.a)(s.Q, (t, e) => {
					let {
						pageLayer: i
					} = e;
					return Object(o.A)(i)
				}, (t, e) => {
					let {
						pageLayer: i
					} = e;
					return Object(o.O)(i)
				}, (t, e, i) => !t && !e && i),
				a = Object(n.a)((t, e) => Object(l.c)(t, {
					experimentName: r.Sc,
					experimentEligibilitySelector: t => c(t, e)
				}), t => t),
				d = t => t === r.Kf.NoCommunityWidgets,
				u = t => t === r.Kf.NoRulesModerators,
				_ = t => t === r.Kf.RelatedPostsDu
		},
		"./src/reddit/selectors/tooltip.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			})), i.d(e, "b", (function() {
				return r
			})), i.d(e, "c", (function() {
				return o
			}));
			const n = t => t.tooltip.tooltipId,
				r = t => e => e.tooltip.tooltipId === t,
				o = t => t.tooltip.params
		}
	}
]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/Governance~ModListing~Reddit~ReportFlow~Subreddit.21f977c4144c9d4f0d26.js.map