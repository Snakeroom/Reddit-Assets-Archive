// https://www.redditstatic.com/desktop2x/Governance~ModListing~Reddit~ReportFlow~Subreddit.0b635c5892e17f1f2a6b.js
// Retrieved at 11/15/2022, 3:10:05 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["Governance~ModListing~Reddit~ReportFlow~Subreddit"], {
		"./src/lib/assertNever.ts": function(t, e, i) {
			"use strict";

			function n(t) {
				throw new Error(`Unexpected object: ${t}`)
			}
			i.d(e, "a", (function() {
				return n
			}))
		},
		"./src/lib/constants/icons.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			}));
			const n = {
				activity: "activity",
				activity_fill: "activity_fill",
				add: "add",
				add_fill: "add_fill",
				add_media: "add_media",
				add_media_fill: "add_media_fill",
				add_to_feed: "add_to_feed",
				add_to_feed_fill: "add_to_feed_fill",
				admin: "admin",
				admin_fill: "admin_fill",
				all: "all",
				all_fill: "all_fill",
				appearance: "appearance",
				appearance_fill: "appearance_fill",
				approve: "approve",
				approve_fill: "approve_fill",
				archived: "archived",
				archived_fill: "archived_fill",
				aspect_ratio: "aspect_ratio",
				aspect_ratio_fill: "aspect_ratio_fill",
				aspect_rectangle: "aspect_rectangle",
				aspect_rectangle_fill: "aspect_rectangle_fill",
				attach: "attach",
				attach_fill: "attach_fill",
				audio: "audio",
				audio_fill: "audio_fill",
				author: "author",
				author_fill: "author_fill",
				avatar_style: "avatar_style",
				avatar_style_fill: "avatar_style_fill",
				award: "award",
				award_fill: "award_fill",
				back: "back",
				back_fill: "back_fill",
				ban: "ban",
				ban_fill: "ban_fill",
				best: "best",
				best_fill: "best_fill",
				block: "block",
				block_fill: "block_fill",
				bold: "bold",
				bold_fill: "bold_fill",
				bot: "bot",
				bot_fill: "bot_fill",
				bounce: "bounce",
				bounce_fill: "bounce_fill",
				browse: "browse",
				browse_fill: "browse_fill",
				browser: "browser",
				browser_fill: "browser_fill",
				cake: "cake",
				cake_fill: "cake_fill",
				calendar: "calendar",
				camera: "camera",
				camera_fill: "camera_fill",
				campaign: "campaign",
				caret_down: "caret_down",
				caret_down_fill: "caret_down_fill",
				caret_left: "caret_left",
				caret_left_fill: "caret_left_fill",
				caret_right: "caret_right",
				caret_right_fill: "caret_right_fill",
				caret_up: "caret_up",
				caret_up_fill: "caret_up_fill",
				chat: "chat",
				chat_fill: "chat_fill",
				chat_group: "chat_group",
				chat_group_fill: "chat_group_fill",
				chat_new: "chat_new",
				chat_new_fill: "chat_new_fill",
				checkbox: "checkbox",
				checkbox_dismiss: "checkbox_dismiss",
				checkbox_dismiss_fill: "checkbox_dismiss_fill",
				checkbox_fill: "checkbox_fill",
				checkmark: "checkmark",
				checkmark_fill: "checkmark_fill",
				chrome: "chrome",
				chrome_fill: "chrome_fill",
				clear: "clear",
				clear_fill: "clear_fill",
				close: "close",
				close_fill: "close_fill",
				closed_captioning: "closed_captioning",
				closed_captioning_fill: "closed_captioning_fill",
				code_block: "code_block",
				code_block_fill: "code_block_fill",
				code_inline: "code_inline",
				code_inline_fill: "code_inline_fill",
				coins: "coins",
				coins_fill: "coins_fill",
				coins_outline_color: "coins_outline_color",
				collapse: "collapse",
				collapse_fill: "collapse_fill",
				collection: "collection",
				collection_fill: "collection_fill",
				comment: "comment",
				comment_fill: "comment_fill",
				comments: "comments",
				comments_fill: "comments_fill",
				community: "community",
				community_fill: "community_fill",
				controversial: "controversial",
				controversial_fill: "controversial_fill",
				crop: "crop",
				crop_fill: "crop_fill",
				crosspost: "crosspost",
				crosspost_fill: "crosspost_fill",
				crowd_control: "crowd_control",
				crowd_control_fill: "crowd_control_fill",
				custom_feed: "custom_feed",
				custom_feed_fill: "custom_feed_fill",
				customize: "customize",
				customize_fill: "customize_fill",
				day: "day",
				day_fill: "day_fill",
				delete: "delete",
				delete_fill: "delete_fill",
				discover: "discover",
				discover_fill: "discover_fill",
				dismiss_all: "dismiss_all",
				dismiss_all_fill: "dismiss_all_fill",
				distinguish: "distinguish",
				distinguish_fill: "distinguish_fill",
				down: "down",
				down_fill: "down_fill",
				download: "download",
				download_fill: "download_fill",
				downvote: "downvote",
				downvote_fill: "downvote_fill",
				downvotes: "downvotes",
				downvotes_fill: "downvotes_fill",
				drag: "drag",
				duplicate: "duplicate",
				duplicate_fill: "duplicate_fill",
				edit: "edit",
				edit_fill: "edit_fill",
				effect: "effect",
				effect_fill: "effect_fill",
				embed: "embed",
				embed_fill: "embed_fill",
				emoji: "emoji",
				emoji_fill: "emoji_fill",
				expand: "expand",
				expand_fill: "expand_fill",
				external_link: "external_link",
				external_link_fill: "external_link_fill",
				feed_posts: "feed_posts",
				feed_posts_fill: "feed_posts_fill",
				feed_video: "feed_video",
				feed_video_fill: "feed_video_fill",
				filter: "filter",
				filter_fill: "filter_fill",
				format: "format",
				format_fill: "format_fill",
				forward: "forward",
				forward_fill: "forward_fill",
				gif_post: "gif_post",
				gif_post_fill: "gif_post_fill",
				heart: "heart",
				heart_fill: "heart_fill",
				help: "help",
				help_fill: "help_fill",
				hide: "hide",
				hide_fill: "hide_fill",
				history: "history",
				history_fill: "history_fill",
				home: "home",
				home_fill: "home_fill",
				hot: "hot",
				hot_fill: "hot_fill",
				ignore_reports: "ignore_reports",
				ignore_reports_fill: "ignore_reports_fill",
				image_post: "image_post",
				image_post_fill: "image_post_fill",
				info: "info",
				info_fill: "info_fill",
				italic: "italic",
				italic_fill: "italic_fill",
				join: "join",
				join_fill: "join_fill",
				joined: "joined",
				joined_fill: "joined_fill",
				jump_down: "jump_down",
				jump_down_fill: "jump_down_fill",
				jump_up: "jump_up",
				jump_up_fill: "jump_up_fill",
				karma: "karma",
				karma_fill: "karma_fill",
				keyboard: "keyboard",
				keyboard_fill: "keyboard_fill",
				kick: "kick",
				kick_fill: "kick_fill",
				leave: "leave",
				leave_fill: "leave_fill",
				left: "left",
				left_fill: "left_fill",
				link_post: "link_post",
				link_post_fill: "link_post_fill",
				list_bulleted: "list_bulleted",
				list_bulleted_fill: "list_bulleted_fill",
				list_numbered: "list_numbered",
				list_numbered_fill: "list_numbered_fill",
				live: "live",
				live_fill: "live_fill",
				load: "load",
				location: "location",
				location_fill: "location_fill",
				lock: "lock",
				lock_fill: "lock_fill",
				logout: "logout",
				logout_fill: "logout_fill",
				loop: "loop",
				loop_fill: "loop_fill",
				mark_read: "mark_read",
				mark_read_fill: "mark_read_fill",
				mask: "mask",
				mask_fill: "mask_fill",
				media_gallery: "media_gallery",
				media_gallery_fill: "media_gallery_fill",
				meme: "meme",
				meme_fill: "meme_fill",
				menu: "menu",
				menu_fill: "menu_fill",
				message: "message",
				message_fill: "message_fill",
				mod: "mod",
				mod_fill: "mod_fill",
				mod_mail: "mod_mail",
				mod_mail_fill: "mod_mail_fill",
				mod_mode: "mod_mode",
				mod_mode_fill: "mod_mode_fill",
				mod_mute: "mod_mute",
				mod_mute_fill: "mod_mute_fill",
				mod_overflow: "mod_overflow",
				mod_overflow_fill: "mod_overflow_fill",
				mod_queue: "mod_queue",
				mod_queue_fill: "mod_queue_fill",
				mod_unmute: "mod_unmute",
				mod_unmute_fill: "mod_unmute_fill",
				new: "new",
				new_fill: "new_fill",
				night: "night",
				night_fill: "night_fill",
				notification: "notification",
				notification_fill: "notification_fill",
				notification_frequent: "notification_frequent",
				notification_frequent_fill: "notification_frequent_fill",
				notification_off: "notification_off",
				notification_off_fill: "notification_off_fill",
				nsfw: "nsfw",
				nsfw_fill: "nsfw_fill",
				nsfw_language: "nsfw_language",
				nsfw_language_fill: "nsfw_language_fill",
				nsfw_violence: "nsfw_violence",
				nsfw_violence_fill: "nsfw_violence_fill",
				original: "original",
				original_fill: "original_fill",
				overflow_carat: "overflow_carat",
				overflow_carat_fill: "overflow_carat_fill",
				overflow_horizontal: "overflow_horizontal",
				overflow_vertical: "overflow_vertical",
				pause: "pause",
				pause_fill: "pause_fill",
				payment: "payment",
				payment_fill: "payment_fill",
				peace: "peace",
				peace_fill: "peace_fill",
				pending_posts: "pending_posts",
				pending_posts_fill: "pending_posts_fill",
				pin: "pin",
				pin_fill: "pin_fill",
				play: "play",
				play_fill: "play_fill",
				poll_post: "poll_post",
				poll_post_fill: "poll_post_fill",
				popular: "popular",
				popular_fill: "popular_fill",
				prediction: "prediction",
				prediction_fill: "prediction_fill",
				premium: "premium",
				premium_fill: "premium_fill",
				privacy: "privacy",
				privacy_fill: "privacy_fill",
				profile: "profile",
				profile_fill: "profile_fill",
				quarantined: "quarantined",
				quarantined_fill: "quarantined_fill",
				quote: "quote",
				quote_fill: "quote_fill",
				r_slash: "r_slash",
				r_slash_fill: "r_slash_fill",
				radio_button: "radio_button",
				radio_button_fill: "radio_button_fill",
				random: "random",
				random_fill: "random_fill",
				rating_drugs: "rating_drugs",
				rating_everyone: "rating_everyone",
				rating_mature: "rating_mature",
				rating_nsfw: "rating_nsfw",
				rating_violence: "rating_violence",
				refresh: "refresh",
				refresh_fill: "refresh_fill",
				remove: "remove",
				remove_fill: "remove_fill",
				reply: "reply",
				reply_fill: "reply_fill",
				report: "report",
				report_fill: "report_fill",
				reverse: "reverse",
				reverse_fill: "reverse_fill",
				right: "right",
				right_fill: "right_fill",
				rising: "rising",
				rising_fill: "rising_fill",
				rotate: "rotate",
				rotate_fill: "rotate_fill",
				rpan: "rpan",
				rpan_fill: "rpan_fill",
				rules: "rules",
				rules_fill: "rules_fill",
				safari: "safari",
				safari_fill: "safari_fill",
				save: "save",
				save_fill: "save_fill",
				saved: "saved",
				saved_fill: "saved_fill",
				scheduled: "scheduled",
				scheduled_fill: "scheduled_fill",
				search: "search",
				search_fill: "search_fill",
				self: "self",
				self_fill: "self_fill",
				send: "send",
				send_fill: "send_fill",
				settings: "settings",
				settings_fill: "settings_fill",
				share: "share",
				share_android: "share_android",
				share_android_fill: "share_android_fill",
				share_fill: "share_fill",
				share_ios: "share_ios",
				share_ios_fill: "share_ios_fill",
				show: "show",
				show_fill: "show_fill",
				side_menu: "side_menu",
				side_menu_fill: "side_menu_fill",
				skipback10: "skipback10",
				skipback10_fill: "skipback10_fill",
				skipforward10: "skipforward10",
				skipforward10_fill: "skipforward10_fill",
				sort: "sort",
				sort_fill: "sort_fill",
				spam: "spam",
				spam_fill: "spam_fill",
				spoiler: "spoiler",
				spoiler_fill: "spoiler_fill",
				sponsored: "sponsored",
				sponsored_fill: "sponsored_fill",
				star: "star",
				star_fill: "star_fill",
				statistics: "statistics",
				statistics_fill: "statistics_fill",
				sticker: "sticker",
				sticker_fill: "sticker_fill",
				strikethrough: "strikethrough",
				strikethrough_fill: "strikethrough_fill",
				subtract: "subtract",
				subtract_fill: "subtract_fill",
				superscript: "superscript",
				superscript_fill: "superscript_fill",
				swipe_back: "swipe_back",
				swipe_back_fill: "swipe_back_fill",
				swipe_down: "swipe_down",
				swipe_down_fill: "swipe_down_fill",
				swipe_forward: "swipe_forward",
				swipe_forward_fill: "swipe_forward_fill",
				swipe_up: "swipe_up",
				swipe_up_fill: "swipe_up_fill",
				table: "table",
				table_fill: "table_fill",
				tag: "tag",
				tag_fill: "tag_fill",
				tap: "tap",
				tap_fill: "tap_fill",
				text_post: "text_post",
				text_post_fill: "text_post_fill",
				text_size: "text_size",
				text_size_fill: "text_size_fill",
				top: "top",
				top_fill: "top_fill",
				topic: "topic",
				topic_activism: "topic_activism",
				topic_addiction_support: "topic_addiction_support",
				topic_advice: "topic_advice",
				topic_animals: "topic_animals",
				topic_anime: "topic_anime",
				topic_art: "topic_art",
				topic_beauty: "topic_beauty",
				topic_business: "topic_business",
				topic_careers: "topic_careers",
				topic_cars: "topic_cars",
				topic_celebrity: "topic_celebrity",
				topic_crafts: "topic_crafts",
				topic_crypto: "topic_crypto",
				topic_culture: "topic_culture",
				topic_diy: "topic_diy",
				topic_entertainment: "topic_entertainment",
				topic_ethics: "topic_ethics",
				topic_family: "topic_family",
				topic_fashion: "topic_fashion",
				topic_fitness: "topic_fitness",
				topic_food: "topic_food",
				topic_funny: "topic_funny",
				topic_gender: "topic_gender",
				topic_health: "topic_health",
				topic_help: "topic_help",
				topic_history: "topic_history",
				topic_internet: "topic_internet",
				topic_law: "topic_law",
				topic_learning: "topic_learning",
				topic_lifestyle: "topic_lifestyle",
				topic_mature: "topic_mature",
				topic_mensfashion: "topic_mensfashion",
				topic_menshealth: "topic_menshealth",
				topic_meta: "topic_meta",
				topic_military: "topic_military",
				topic_movies: "topic_movies",
				topic_music: "topic_music",
				topic_news: "topic_news",
				topic_other: "topic_other",
				topic_outdoors: "topic_outdoors",
				topic_pets: "topic_pets",
				topic_photography: "topic_photography",
				topic_places: "topic_places",
				topic_politics: "topic_politics",
				topic_programming: "topic_programming",
				topic_reading: "topic_reading",
				topic_reading_fill: "topic_reading_fill",
				topic_religion: "topic_religion",
				topic_science: "topic_science",
				topic_sexorientation: "topic_sexorientation",
				topic_sports: "topic_sports",
				topic_style: "topic_style",
				topic_tabletop: "topic_tabletop",
				topic_technology: "topic_technology",
				topic_television: "topic_television",
				topic_traumasupport: "topic_traumasupport",
				topic_travel: "topic_travel",
				topic_videogaming: "topic_videogaming",
				topic_womenshealth: "topic_womenshealth",
				trim: "trim",
				trim_fill: "trim_fill",
				trophy: "trophy",
				trophy_fill: "trophy_fill",
				u_slash: "u_slash",
				u_slash_fill: "u_slash_fill",
				unban: "unban",
				unban_fill: "unban_fill",
				undo: "undo",
				undo_fill: "undo_fill",
				unheart: "unheart",
				unlock: "unlock",
				unlock_fill: "unlock_fill",
				unmod: "unmod",
				unmod_fill: "unmod_fill",
				unpin: "unpin",
				unpin_fill: "unpin_fill",
				unverified: "unverified",
				unverified_fill: "unverified_fill",
				up: "up",
				up_fill: "up_fill",
				upload: "upload",
				upload_fill: "upload_fill",
				upvote: "upvote",
				upvote_fill: "upvote_fill",
				upvotes: "upvotes",
				upvotes_fill: "upvotes_fill",
				user: "user",
				user_fill: "user_fill",
				user_note: "user_note",
				user_note_fill: "user_note_fill",
				vault: "vault",
				vault_fill: "vault_fill",
				verified: "verified",
				verified_fill: "verified_fill",
				video_camera: "video_camera",
				video_camera_fill: "video_camera_fill",
				video_live: "video_live",
				video_live_fill: "video_live_fill",
				video_post: "video_post",
				video_post_fill: "video_post_fill",
				view_card: "view_card",
				view_card_fill: "view_card_fill",
				view_classic: "view_classic",
				view_classic_fill: "view_classic_fill",
				view_compact: "view_compact",
				view_compact_fill: "view_compact_fill",
				view_grid_fill: "view_grid_fill",
				view_grid_fill_1: "view_grid_fill_1",
				views: "views",
				views_fill: "views_fill",
				volume: "volume",
				volume_fill: "volume_fill",
				volume_mute: "volume_mute",
				volume_mute_fill: "volume_mute_fill",
				wiki: "wiki",
				wiki_fill: "wiki_fill",
				wiki_ban: "wiki_ban",
				wiki_ban_fill: "wiki_ban_fill",
				wiki_unban: "wiki_unban",
				wiki_unban_fill: "wiki_unban_fill",
				world: "world",
				world_fill: "world_fill"
			}
		},
		"./src/lib/formatApiError/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return o
			}));
			var n = i("./node_modules/fbt/lib/FbtPublic.js"),
				r = i("./src/lib/constants/index.ts");

			function o(t, e) {
				return t ? t.fields && t.fields.length ? t.fields.map(t => t.msg).join(", ") : t.type && l[t.type] ? l[t.type]() : 401 === e ? n.fbt._("There was an authentication error", null, {
					hk: "2KZTRv"
				}) : n.fbt._("Something went wrong", null, {
					hk: "3i6szH"
				}) : ""
			}
			const l = {
				[r.l]: () => n.fbt._("you're not allowed to do that", null, {
					hk: "1jGKQw"
				}),
				[r.O]: () => n.fbt._("GIF size must be less than {max file size}MB", [n.fbt._param("max file size", Math.floor(r.eb / r.mb).toString())], {
					hk: "1zzsdM"
				}),
				[r.W]: () => n.fbt._("Image size must be less than {max file size}MB", [n.fbt._param("max file size", Math.floor(r.gb / r.mb).toString())], {
					hk: "3H6bF8"
				}),
				[r.Y]: () => n.fbt._("Sorry, we accept only images (.png, .jpeg, .gif) and videos (.mp4, .mov)", null, {
					hk: "1hw868"
				}),
				[r.vc]: () => n.fbt._("Video size must be less than {max file size}GB", [n.fbt._param("max file size", (r.kb / r.mb / 1024).toFixed(1))], {
					hk: "4FkABU"
				})
			}
		},
		"./src/reddit/actions/apiRequestState.ts": function(t, e, i) {
			"use strict";
			i.d(e, "d", (function() {
				return o
			})), i.d(e, "a", (function() {
				return l
			})), i.d(e, "b", (function() {
				return s
			})), i.d(e, "c", (function() {
				return c
			})), i.d(e, "h", (function() {
				return a
			})), i.d(e, "e", (function() {
				return d
			})), i.d(e, "f", (function() {
				return _
			})), i.d(e, "g", (function() {
				return u
			}));
			var n = i("./src/lib/makeActionCreator/index.ts"),
				r = i("./src/reddit/models/ApiRequestState/index.ts");
			const o = "API_REQUEST_STATE__STARTED",
				l = "API_REQUEST_STATE__COMPLETED",
				s = "API_REQUEST_STATE__FAILED",
				c = "API_REQUEST_STATE__RELEASED";

			function a(t) {
				return {
					type: o,
					payload: {
						apiRequestStatus: r.a.Pending,
						apiRequestId: t
					}
				}
			}

			function d(t) {
				return {
					type: l,
					payload: {
						apiRequestStatus: r.a.Complete,
						apiRequestId: t
					}
				}
			}

			function _(t, e) {
				return {
					type: s,
					payload: {
						apiRequestStatus: r.a.Failed,
						apiRequestId: t,
						apiError: e
					}
				}
			}
			const u = Object(n.a)(c)
		},
		"./src/reddit/actions/postFlairStyleTemplates/constants.ts": function(t, e, i) {
			"use strict";
			i.d(e, "c", (function() {
				return n
			})), i.d(e, "b", (function() {
				return r
			})), i.d(e, "a", (function() {
				return o
			}));
			const n = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_PENDING",
				r = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_LOADED",
				o = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_FAILED"
		},
		"./src/reddit/actions/shortcuts/utils.ts": function(t, e, i) {
			"use strict";
			i.d(e, "c", (function() {
				return l
			})), i.d(e, "a", (function() {
				return s
			})), i.d(e, "b", (function() {
				return c
			})), i.d(e, "d", (function() {
				return a
			}));
			var n = i("./src/reddit/constants/shortcuts.ts"),
				r = i("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				o = i("./src/reddit/helpers/routeKey/index.ts");
			const l = t => {
					const e = t.platform.currentPage;
					if (!e || !e.routeMatch) return;
					const i = e.routeMatch,
						n = Object(r.a)(t);
					return Object(o.b)(i, t, n)
				},
				s = t => {
					const e = document.getElementById(t);
					e && e.focus()
				},
				c = t => {
					const e = document.getElementById(t),
						i = window.scrollX,
						n = window.scrollY;
					e && (e.focus(), window.scrollTo(i, n))
				},
				a = () => {
					c(n.b)
				}
		},
		"./src/reddit/actions/structuredStyles/constants.ts": function(t, e, i) {
			"use strict";
			i.d(e, "l", (function() {
				return n
			})), i.d(e, "k", (function() {
				return r
			})), i.d(e, "j", (function() {
				return o
			})), i.d(e, "i", (function() {
				return l
			})), i.d(e, "h", (function() {
				return s
			})), i.d(e, "g", (function() {
				return c
			})), i.d(e, "b", (function() {
				return a
			})), i.d(e, "c", (function() {
				return d
			})), i.d(e, "e", (function() {
				return _
			})), i.d(e, "d", (function() {
				return u
			})), i.d(e, "f", (function() {
				return f
			})), i.d(e, "a", (function() {
				return p
			})), i.d(e, "n", (function() {
				return m
			})), i.d(e, "m", (function() {
				return b
			}));
			const n = "STRUCTURED_STYLES__STYLES_RESET_PENDING",
				r = "STRUCTURED_STYLES__STYLES_RESET_LOADED",
				o = "STRUCTURED_STYLES__STYLES_RESET_FAILED",
				l = "SUBREDDIT__STYLES_PENDING",
				s = "SUBREDDIT__STYLES_LOADED",
				c = "SUBREDDIT__STYLES_FAILED",
				a = "STRUCTURED_STYLES__DRAFT_REPLACED",
				d = "STRUCTURED_STYLES__DRAFT_UPDATED",
				_ = "STRUCTURED_STYLES__EDITING_STOPPED",
				u = "STRUCTURED_STYLES__EDITING_STARTED",
				f = "STRUCTURED_STYLES__IMAGE_UPLOAD_ADDED",
				p = "STRUCTURED_STYLES__DIRTIED_BLADE_EDITOR",
				m = "STRUCTURED_STYLES__UNDIRTIED_BLADE_EDITOR",
				b = "STRUCTURED_STYLES__STYLES_UPDATED_LOADED"
		},
		"./src/reddit/actions/structuredStyles/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "l", (function() {
				return C
			})), i.d(e, "k", (function() {
				return G
			})), i.d(e, "j", (function() {
				return z
			})), i.d(e, "e", (function() {
				return Q
			})), i.d(e, "d", (function() {
				return X
			})), i.d(e, "g", (function() {
				return $
			})), i.d(e, "c", (function() {
				return Z
			})), i.d(e, "f", (function() {
				return et
			})), i.d(e, "b", (function() {
				return it
			})), i.d(e, "m", (function() {
				return nt
			})), i.d(e, "a", (function() {
				return rt
			})), i.d(e, "h", (function() {
				return ot
			})), i.d(e, "i", (function() {
				return lt
			}));
			i("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = i("./node_modules/lodash/omit.js"),
				r = i.n(n),
				o = i("./node_modules/lodash/pick.js"),
				l = i.n(o),
				s = i("./node_modules/react-router-redux/es/index.js"),
				c = i("./src/lib/filterQueryParams/index.ts"),
				a = i("./src/lib/formatApiError/index.ts"),
				d = i("./src/lib/makeActionCreator/index.ts"),
				_ = i("./src/reddit/actions/apiRequestState.ts"),
				u = i("./src/reddit/actions/imageUploads.ts"),
				f = i("./src/reddit/actions/modal.ts"),
				p = i("./src/reddit/endpoints/moderator/structuredStyles.ts"),
				m = i("./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts"),
				b = i("./src/reddit/selectors/postFlair.ts"),
				h = i("./src/reddit/selectors/subreddit.ts"),
				S = i("./src/reddit/actions/postFlairStyleTemplates/constants.ts");
			const E = Object(d.a)(S.c),
				y = Object(d.a)(S.b),
				g = Object(d.a)(S.a);
			var D = i("./src/reddit/actions/toaster.ts"),
				w = i("./src/reddit/actions/widgets/index.ts"),
				v = i("./src/reddit/constants/modals.ts"),
				O = i("./src/reddit/helpers/getGenericUploadError.ts"),
				I = i("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				k = i("./src/reddit/helpers/media/index.ts"),
				T = i("./src/reddit/models/Image/index.tsx"),
				j = i("./src/reddit/models/StructuredStyles/index.ts"),
				x = i("./src/reddit/models/Toast/index.ts"),
				R = i("./src/reddit/selectors/activeModalId.ts"),
				U = i("./src/reddit/selectors/platform.ts"),
				N = i("./src/reddit/selectors/structuredStyles.ts"),
				B = i("./src/reddit/selectors/user.ts"),
				L = i("./src/reddit/helpers/trackers/blade.ts"),
				P = i("./src/telemetry/index.ts"),
				A = i("./src/reddit/actions/structuredStyles/constants.ts");
			const C = Object(d.a)(A.m),
				F = {
					bannerBackgroundImage: ["bannerBackgroundImagePosition"],
					bannerPositionedImage: ["bannerPositionedImagePosition", "secondaryBannerPositionedImage"]
				},
				M = t => {
					const e = {
						...t
					};
					return Object.keys(t).forEach(i => {
						F[i] && !t[i] && F[i].forEach(t => e[t] = null)
					}), e
				},
				G = (t, e, i, n) => async (r, o, l) => {
					const {
						apiContext: s
					} = l, c = o(), d = M(e), f = c.structuredStyles.models[t];
					let m;
					for (const t in d)
						if (d[t] !== f[t]) {
							m = !0;
							break
						} if (!m) return;
					r(Object(_.h)(n));
					const b = Object(L.i)(i)(c);
					let S = null,
						E = null;
					try {
						(S = await Object(u.f)(o(), T.a.StructuredStyles)) && (E = Object(u.m)(S)(r, o, l))
					} catch (v) {
						const t = Object(O.a)("webSocket");
						return void r(Object(_.f)(n, t))
					}
					const y = Object(h.Y)(c, {
							subredditId: t
						}).name,
						g = await p.e(s(), y, d),
						w = {};
					if (g.ok) {
						if (E) try {
							await E
						} catch (v) {}
						const i = Object(N.f)(o(), {
							apiRequestId: n
						});
						for (const t in i)
							if (t in e) {
								const e = Object(N.g)(o(), {
									name: t
								});
								e && Object(T.j)(e) && (w[t] = i[t])
							} Object.keys(w).length && r(H(w)), r(Object(_.e)(n)), r(C({
							subredditId: t,
							styles: {
								...d,
								...w
							}
						}))
					} else S && S.websocket.close(), r(Object(_.f)(n, g.error)), g.body && r(D.f({
						kind: x.b.Error,
						text: Object(a.a)(g.error, g.status)
					}));
					Object(P.a)({
						...b,
						actionInfo: {
							...b.actionInfo,
							success: g.ok
						}
					})
				}, q = Object(d.a)(A.l), W = Object(d.a)(A.k), Y = Object(d.a)(A.j), z = t => async (e, i, n) => {
					let {
						apiContext: r
					} = n;
					e(q({
						subredditId: t
					}));
					const o = Object(h.Y)(i(), {
							subredditId: t
						}).name,
						l = await p.f(r(), o);
					if (l.ok) {
						const n = i().structuredStyles.models[t],
							r = n ? n.mobileKeyColor : null;
						e(W({
							subredditId: t,
							styles: {
								mobileKeyColor: r
							}
						}))
					} else e(Y({
						subredditId: t,
						...l.error
					}))
				}, K = Object(d.a)(A.d), Q = t => async (e, i, n) => {
					const r = i(),
						o = r.structuredStyles.models[t] || {},
						l = Object(B.eb)(r);
					e(K({
						isNightmodeOn: l,
						styles: o,
						subredditId: t
					})), dt(t, !1)(e, i, n), (t => async (e, i, n) => {
						let {
							gqlContext: r
						} = n;
						const o = i(),
							l = Object(h.Y)(o, {
								subredditId: t
							});
						if (!l) return;
						const s = Object(b.d)(o, {
								subredditId: t
							}),
							c = s && s.templateIds;
						if (!c || !c.length) return;
						e(E({
							subredditId: t
						}));
						const a = await Object(p.a)(r(), l.name, c);
						if (a.ok) {
							const i = {};
							if (a.body) {
								const {
									data: t
								} = a.body;
								if (t && t.subreddit)
									for (const e of t.subreddit.postFlairStyleTemplates) i[e.id] = Object(m.a)(e)
							}
							e(y({
								subredditId: t,
								templates: i
							}))
						} else e(g({
							subredditId: t,
							error: a.error
						}))
					})(t)(e, i, n), Object(w.g)(t, !1)(e, i, n)
				}, H = Object(d.a)(A.c), X = t => async (e, i, n) => {
					const r = M(t),
						o = i();
					for (const t in r)
						if (Object(j.l)(t))
							if (r[t]) {
								if ("string" != typeof r[t]) {
									const o = r[t],
										l = await Object(T.e)(o);
									$(t, l)(e, i, n), r[t] = ""
								}
							} else {
								const i = Object(N.g)(o, {
									name: t
								});
								i && e(Object(u.h)(i))
							} e(H(r))
				}, V = Object(d.a)(A.f), $ = (t, e, i) => async (n, r, o) => {
					const l = r(),
						s = i || l.structuredStyles.isEditing,
						c = Object(h.Y)(l, {
							subredditId: s
						}).name;
					n(V({
						imageKey: t,
						uploadId: e.id
					})), n(Object(u.k)(e));
					const a = await p.d(o.apiContext(), c, e.file.name, t, await Object(k.h)(e.file));
					try {
						const i = await Object(u.g)(r(), a, e, T.a.StructuredStyles);
						if (i) {
							const e = i.url;
							n(Object(u.j)(i)), n(H({
								[t]: e
							}))
						}
					} catch (d) {
						if (d instanceof Error) throw d;
						n(Object(u.i)(d))
					}
				}, J = Object(d.a)(A.b), Z = (t, e, i) => async (n, o, s) => {
					const c = o(),
						a = c.structuredStyles.models[t] || {},
						d = c.structuredStyles.draft,
						_ = Object(L.h)(e)(c);
					if (i) {
						const e = l()(a, i),
							o = {
								...r()(d, i),
								...e
							};
						n(J({
							subredditId: t,
							styles: o
						}))
					} else {
						n(J({
							subredditId: t,
							styles: a
						}))
					}
					Object(P.a)(_)
				}, tt = Object(d.a)(A.e), et = () => async (t, e, i) => {
					const n = e(),
						r = Object(B.fb)(n),
						o = !!Object(U.a)(n);
					if (t(tt({
							nightmodeTempUpdated: r
						})), o) return;
					const {
						url: l
					} = n.platform.currentPage;
					l && t(Object(s.c)(Object(c.a)(l, ["styling", "route"])))
				}, it = Object(d.a)(A.a), nt = Object(d.a)(A.n), rt = () => async t => t(et()), ot = t => async (e, i) => {
					const n = i(),
						r = Object(N.i)(n);
					!Object(R.b)(v.a.BLADE_UNSAVED_CHANGES)(n) && r && (Object(N.a)(n, {
						subredditId: t
					}) ? e(Object(f.i)(v.a.BLADE_UNSAVED_CHANGES)) : e(rt()))
				}, lt = t => async (e, i) => {
					const n = i();
					Object(N.i)(n) || e(Object(B.eb)(n) ? Object(f.i)(v.a.BLADE_NIGHTMODE) : Q(t))
				}, st = Object(d.a)(A.i), ct = Object(d.a)(A.h), at = Object(d.a)(A.g), dt = (t, e) => async (i, n, r) => {
					let {
						gqlContext: o,
						apiContext: l
					} = r;
					i(st({
						subredditId: t
					}));
					const s = Object(h.Y)(n(), {
						subredditId: t
					});
					if (!s) return;
					if (!e) {
						const n = await p.c(l(), s.name, e);
						if (n.ok) {
							const e = n.body,
								r = e.data ? e.data.style : {};
							i(ct({
								subredditId: t,
								styles: r
							}))
						} else i(at({
							subredditId: t,
							...n.error
						}));
						return
					}
					const c = await p.b(o(), s.name);
					if (c.ok) {
						let e = {};
						if (c.body) {
							const {
								data: t
							} = c.body;
							t && t.subreddit && t.subreddit.styles && (e = Object(I.a)(t.subreddit.styles))
						}
						i(ct({
							subredditId: t,
							styles: e
						}))
					} else i(at({
						subredditId: t,
						...c.error
					}))
				}
		},
		"./src/reddit/actions/subreddit/constants.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			})), i.d(e, "b", (function() {
				return r
			})), i.d(e, "c", (function() {
				return o
			})), i.d(e, "o", (function() {
				return l
			})), i.d(e, "n", (function() {
				return s
			})), i.d(e, "w", (function() {
				return c
			})), i.d(e, "v", (function() {
				return a
			})), i.d(e, "r", (function() {
				return d
			})), i.d(e, "q", (function() {
				return _
			})), i.d(e, "p", (function() {
				return u
			})), i.d(e, "u", (function() {
				return f
			})), i.d(e, "t", (function() {
				return p
			})), i.d(e, "s", (function() {
				return m
			})), i.d(e, "m", (function() {
				return b
			})), i.d(e, "l", (function() {
				return h
			})), i.d(e, "k", (function() {
				return S
			})), i.d(e, "B", (function() {
				return E
			})), i.d(e, "A", (function() {
				return y
			})), i.d(e, "C", (function() {
				return g
			})), i.d(e, "D", (function() {
				return D
			})), i.d(e, "E", (function() {
				return w
			})), i.d(e, "e", (function() {
				return v
			})), i.d(e, "d", (function() {
				return O
			})), i.d(e, "y", (function() {
				return I
			})), i.d(e, "z", (function() {
				return k
			})), i.d(e, "x", (function() {
				return T
			})), i.d(e, "j", (function() {
				return j
			})), i.d(e, "F", (function() {
				return x
			})), i.d(e, "G", (function() {
				return R
			})), i.d(e, "i", (function() {
				return U
			})), i.d(e, "h", (function() {
				return N
			})), i.d(e, "g", (function() {
				return B
			})), i.d(e, "f", (function() {
				return L
			}));
			const n = "SUBREDDIT__ADD_TOP_SUBREDDIT_MODELS",
				r = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS",
				o = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS_PAGE_INFO",
				l = "SUBREDDIT__POSTS_LOADED",
				s = "SUBREDDIT__POSTS_SET_FAILED",
				c = "SUBREDDIT__SUBREDDITS_POSTS_LOADED",
				a = "SUBREDDIT__SUBREDDITS_POSTS_SET_FAILED",
				d = "SUBREDDIT__RANKINGS_PENDING",
				_ = "SUBREDDIT__RANKINGS_LOADED",
				u = "SUBREDDIT__RANKINGS_FAILED",
				f = "SUBREDDIT__SIMILAR_SUBREDDITS_PENDING",
				p = "SUBREDDIT__SIMILAR_SUBREDDITS_LOADED",
				m = "SUBREDDIT__SIMILAR_SUBREDDITS_FAILED",
				b = "SUBREDDIT__ONBOARDING_SUBREDDITS_PENDING",
				h = "SUBREDDIT__ONBOARDING_SUBREDDITS_LOADED",
				S = "SUBREDDIT__ONBOARDING_SUBREDDITS_FAILED",
				E = "SUBREDDIT__EDIT_REQUESTED",
				y = "SUBREDDIT__EDIT_FAILED",
				g = "SUBREDDIT__EDIT_SUCCESS",
				D = "SUBREDDIT_QUESTIONS_LOADED",
				w = "SUBREDDIT_SURVEY_ANSWERED",
				v = "SUBREDDIT_SURVEY_DISMISSED",
				O = "SUBREDDIT_SURVEY_DISMISS",
				I = "SUBREDDIT_ABOUT_INFO_UPDATE__PENDING",
				k = "SUBREDDIT_ABOUT_INFO_UPDATE__SUCCESS",
				T = "SUBREDDIT_ABOUT_INFO_UPDATE__FAILED",
				j = "MUTE_SUBREDDIT__SUCCESS",
				x = "UNMUTE_SUBREDDIT_SUCCESS",
				R = "UPDATE_MUTE_AND_NOTIFICATION_LEVEL_SUCCESS",
				U = "MUTED_SUBREDDIT_LOADED__SUCCESS",
				N = "MUTED_SUBREDDIT_LOADED__FAILED",
				B = "MUTED_SUBREDDIT_LIST__UNMUTE",
				L = "MUTED_SUBREDDIT_LIST__MUTE"
		},
		"./src/reddit/actions/widgets/constants.ts": function(t, e, i) {
			"use strict";
			i.d(e, "g", (function() {
				return n
			})), i.d(e, "i", (function() {
				return r
			})), i.d(e, "h", (function() {
				return o
			})), i.d(e, "f", (function() {
				return l
			})), i.d(e, "d", (function() {
				return s
			})), i.d(e, "e", (function() {
				return c
			})), i.d(e, "c", (function() {
				return a
			})), i.d(e, "b", (function() {
				return d
			})), i.d(e, "a", (function() {
				return _
			}));
			const n = "WIDGETS__WIDGET_CREATED",
				r = "WIDGETS__WIDGET_UPDATED",
				o = "WIDGET_DELETED",
				l = "WIDGETS_SORTED",
				s = "WIDGETS__STARTED_EDITING_WIDGET",
				c = "WIDGETS__LOADED",
				a = "SUBREDDIT__WIDGETS_PENDING",
				d = "SUBREDDIT__WIDGETS_LOADED",
				_ = "SUBREDDIT__WIDGETS_FAILED"
		},
		"./src/reddit/actions/widgets/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "c", (function() {
				return v
			})), i.d(e, "e", (function() {
				return I
			})), i.d(e, "d", (function() {
				return T
			})), i.d(e, "h", (function() {
				return x
			})), i.d(e, "a", (function() {
				return R
			})), i.d(e, "b", (function() {
				return U
			})), i.d(e, "f", (function() {
				return B
			})), i.d(e, "g", (function() {
				return C
			}));
			var n = i("./node_modules/fbt/lib/FbtPublic.js"),
				r = i("./src/lib/makeActionCreator/index.ts"),
				o = i("./src/reddit/actions/apiRequestState.ts"),
				l = i("./src/reddit/actions/imageUploads.ts"),
				s = i("./src/reddit/actions/toaster.ts"),
				c = i("./src/lib/constants/index.ts"),
				a = i("./src/lib/makeApiRequest/index.ts"),
				d = i("./src/lib/omitHeaders/index.ts"),
				_ = i("./src/reddit/constants/headers.ts");
			const u = async (t, e, i) => Object(a.a)(Object(d.a)(t, [_.a]), {
				endpoint: `${t.apiUrl}/r/${e}/api/widgets`,
				method: c.ob.GET,
				type: "json",
				data: {
					progressive_images: i
				}
			});
			var f = i("./src/reddit/helpers/getGenericUploadError.ts"),
				p = i("./src/reddit/helpers/media/index.ts"),
				m = i("./src/lib/assertNever.ts"),
				b = i("./src/reddit/models/Widgets/index.ts"),
				h = i("./src/reddit/selectors/subreddit.ts"),
				S = i("./src/reddit/helpers/widgets/index.tsx"),
				E = i("./src/reddit/models/Image/index.tsx"),
				y = i("./src/reddit/models/Toast/index.ts"),
				g = i("./src/reddit/selectors/experiments/cnc/index.ts"),
				D = i("./src/reddit/actions/widgets/constants.ts");
			const w = Object(r.a)(D.g),
				v = (t, e, i) => async (r, u, p) => {
					const {
						apiContext: m
					} = p;
					r(Object(o.h)(i));
					const b = u(),
						D = Object(h.Y)(b, {
							subredditId: t
						}).name,
						v = Object(g.f)(b),
						O = Object(S.e)(e);
					let I = null,
						k = null;
					try {
						(I = await Object(l.f)(b, E.a.Widgets)) && (k = Object(l.m)(I)(r, u, p))
					} catch (j) {
						const t = Object(f.a)("webSocket");
						return void r(Object(o.f)(i, t))
					}
					if (v && k) try {
						await k
					} catch (j) {}
					const T = await (async (t, e, i) => Object(a.a)(Object(d.a)(t, [_.a]), {
						endpoint: `${t.apiUrl}/r/${e}/api/widget`,
						method: c.ob.POST,
						type: "json",
						data: i
					}))(m(), D, O);
					if (T.ok) {
						let l = T.body;
						const c = l.id;
						if ("calendar" === e.kind && r(Object(s.f)({
								kind: y.b.SuccessMod,
								text: n.fbt._("New calendar added! It may take a few minutes to see your events appear", null, {
									hk: "4iETrT"
								})
							})), I) {
							if (!v) try {
								await k
							} catch (j) {}
							l = await r(F(t, c)) || l
						}
						r(w({
							subredditId: t,
							widget: l,
							widgetId: c
						})), r(Object(o.e)(i))
					} else I && I.websocket.close(), r(Object(o.f)(i, T.error))
				}, O = Object(r.a)(D.i), I = (t, e, i) => async (r, u, p) => {
					const {
						apiContext: D
					} = p;
					r(Object(o.h)(i));
					const w = e.id,
						v = u(),
						I = Object(h.Y)(v, {
							subredditId: t
						}).name,
						k = Object(g.f)(v),
						T = Object(S.e)(e);
					let j = null,
						x = null;
					try {
						(j = await Object(l.f)(v, E.a.Widgets)) && (x = Object(l.m)(j)(r, u, p))
					} catch (U) {
						const t = Object(f.a)("webSocket");
						return void r(Object(o.f)(i, t))
					}
					if (k && x) try {
						await x
					} catch (U) {}
					const R = await (async (t, e, i) => Object(a.a)(Object(d.a)(t, [_.a]), {
						endpoint: `${t.apiUrl}/r/${e}/api/widget/${i.id}`,
						method: c.ob.PUT,
						type: "json",
						data: i
					}))(D(), I, T);
					if (R.ok) {
						let l = function(t, e, i) {
							switch (t.kind) {
								case b.i.Calendar:
								case b.i.IdCard:
								case b.i.SubredditRules:
									return {
										...t, ...e
									};
								case b.i.CommunityList: {
									const n = {};
									for (const e of t.data) n[e.name] = e;
									return {
										...e,
										data: e.data.map(t => {
											if (!("subscribers" in n[t])) {
												const e = {
														subredditName: t
													},
													n = Object(h.C)(i, e),
													r = Object(h.z)(i, e);
												return {
													name: n.name,
													subscribers: n ? n.subscribers : void 0,
													iconUrl: n ? n.communityIcon : void 0,
													isNSFW: n ? n.isNSFW : void 0,
													isSubscribed: r ? r.userIsSubscriber : void 0
												}
											}
											return n[t]
										})
									}
								}
								case b.i.Button:
								case b.i.Custom:
								case b.i.Image:
								case b.j.Menu:
								case b.i.Moderators:
								case b.i.Textarea:
								case b.i.PostFlair:
									return e;
								default:
									return Object(m.a)(t)
							}
						}(e, R.body, v);
						if (x) {
							if (!k) try {
								await x
							} catch (U) {}
							l = await r(F(t, w)) || l
						}
						r(O({
							subredditId: t,
							widgetId: w,
							widget: l
						})), "calendar" === e.kind && r(Object(s.f)({
							kind: y.b.SuccessMod,
							text: n.fbt._("Calendar is updated! It may take a few minutes to see your events change", null, {
								hk: "10XWV"
							})
						})), r(Object(o.e)(i))
					} else j && j.websocket.close(), r(Object(o.f)(i, R.error))
				}, k = Object(r.a)(D.h), T = (t, e, i) => async (n, r, l) => {
					let {
						apiContext: s
					} = l;
					n(Object(o.h)(i));
					const u = e.id,
						f = Object(h.Y)(r(), {
							subredditId: t
						}).name,
						p = await (async (t, e, i) => Object(a.a)(Object(d.a)(t, [_.a]), {
							endpoint: `${t.apiUrl}/r/${e}/api/widget/${i.id}`,
							method: c.ob.DELETE,
							type: "json"
						}))(s(), f, e);
					p.ok ? (n(Object(o.e)(i)), n(k({
						subredditId: t,
						widgetId: u
					}))) : n(Object(o.f)(i, p.error))
				}, j = Object(r.a)(D.f), x = (t, e) => async (i, n, r) => {
					let {
						apiContext: o
					} = r;
					const l = Object(h.Y)(n(), {
						subredditId: t
					}).name;
					(await (async (t, e, i) => Object(a.a)(Object(d.a)(t, [_.a]), {
						endpoint: `${t.apiUrl}/r/${e}/api/widget_order/sidebar`,
						method: c.ob.PATCH,
						type: "json",
						data: i
					}))(o(), l, e)).ok && i(j({
						subredditId: t,
						widgetIds: e
					}))
				}, R = t => {
					let {
						imageData: e
					} = t;
					return async (t, i, n) => {
						const r = i(),
							o = r.structuredStyles.isEditing,
							s = Object(h.Y)(r, {
								subredditId: o
							}).name;
						t(Object(l.k)(e));
						const u = await (async (t, e, i, n) => Object(a.a)(Object(d.a)(t, [_.a]), {
							endpoint: `${t.apiUrl}/r/${e}/api/widget_image_upload_s3`,
							method: c.ob.POST,
							data: {
								filepath: i,
								mimetype: n
							}
						}))(n.apiContext(), s, e.file.name, await Object(p.h)(e.file));
						let f = !1;
						try {
							const n = await Object(l.g)(i(), u, e, E.a.Widgets);
							n && (t(Object(l.j)(n)), f = !0)
						} catch (m) {
							if (m instanceof Error) throw m;
							t(Object(l.i)(m))
						}
						return f
					}
				}, U = Object(r.a)(D.d), N = Object(r.a)(D.e), B = (t, e) => async (i, n, r) => {
					let {
						apiContext: l
					} = r;
					i(Object(o.h)(e));
					const s = Object(h.Y)(n(), {
							subredditId: t
						}).name,
						c = await u(l(), s);
					if (c.ok) {
						const n = c.body;
						i(N({
							subredditId: t,
							widgets: n
						})), i(Object(o.e)(e))
					} else i(Object(o.f)(e, c.error))
				}, L = Object(r.a)(D.c), P = Object(r.a)(D.b), A = Object(r.a)(D.a), C = (t, e) => async (i, n, r) => {
					let {
						apiContext: o
					} = r;
					i(L({
						subredditId: t
					}));
					const l = Object(h.Y)(n(), {
							subredditId: t
						}).name,
						s = await u(o(), l, e);
					if (s.ok) {
						const e = s.body;
						i(P({
							subredditId: t,
							widgets: e
						}))
					} else i(A({
						subredditId: t,
						error: s.error
					}))
				}, F = (t, e) => async (i, n, r) => {
					let {
						apiContext: o
					} = r;
					const l = Object(h.Y)(n(), {
							subredditId: t
						}).name,
						s = await u(o(), l, !0);
					if (s.ok) return s.body.items[e]
				}
		},
		"./src/reddit/components/TrackingHelper/index.tsx": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return d
			})), i.d(e, "b", (function() {
				return _
			})), i.d(e, "c", (function() {
				return u
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./node_modules/react-redux/es/index.js"),
				l = i("./src/reddit/selectors/telemetry.ts"),
				s = i("./src/telemetry/index.ts");

			function c() {
				return (c = Object.assign || function(t) {
					for (var e = 1; e < arguments.length; e++) {
						var i = arguments[e];
						for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
					}
					return t
				}).apply(this, arguments)
			}
			const a = r.a.createContext(() => {});

			function d(t) {
				let {
					children: e
				} = t;
				const i = Object(o.f)(),
					c = Object(n.useCallback)(t => {
						{
							const e = i.getState(),
								n = t(e);
							Object(s.a)({
								...l.o(e),
								...n
							})
						}
					}, [i]);
				return r.a.createElement(a.Provider, {
					value: c
				}, e ? r.a.Children.only(e) : null)
			}

			function _() {
				return Object(n.useContext)(a)
			}

			function u(t) {
				function e(e) {
					const i = _();
					return r.a.createElement(t, c({}, e, {
						sendEvent: i
					}))
				}
				const i = t.name || t.displayName;
				return e.displayName = `Tracked(${i})`, e.WrappedComponent = t, e
			}
		},
		"./src/reddit/constants/elementIds.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			})), i.d(e, "b", (function() {
				return r
			})), i.d(e, "d", (function() {
				return o
			})), i.d(e, "e", (function() {
				return l
			})), i.d(e, "c", (function() {
				return s
			}));
			const n = "AppRouter-main-content",
				r = "bladeContainer",
				o = "header",
				l = "overlayScrollContainer",
				s = "collectionPostListScrollContainer"
		},
		"./src/reddit/constants/shortcuts.ts": function(t, e, i) {
			"use strict";
			var n, r;
			i.d(e, "d", (function() {
					return n
				})), i.d(e, "c", (function() {
					return r
				})), i.d(e, "b", (function() {
					return o
				})), i.d(e, "a", (function() {
					return l
				})),
				function(t) {
					t.CommentPage = "CommentPage", t.Global = "Global", t.Lightbox = "Lightbox", t.Listing = "Listing", t.Modqueue = "Modqueue"
				}(n || (n = {})),
				function(t) {
					t.Close = "CLOSE", t.CollapseOrLoad = "COLLAPSE_OR_LOAD", t.Downvote = "DOWNVOTE", t.Expando = "EXPANDO", t.Hide = "HIDE", t.Konami = "KONAMI", t.NewPost = "NEW_POST", t.NextComment = "NEXT_COMMENT", t.NextPost = "NEXT_POST", t.OpenIndex = "OPEN_INDEX", t.OpenLightbox = "OPEN_LIGHTBOX", t.OpenLink = "OPEN_LINK", t.PrevComment = "PREV_COMMENT", t.PrevPost = "PREV_POST", t.Reply = "REPLY", t.Save = "SAVE", t.Upvote = "UPVOTE"
				}(r || (r = {}));
			const o = "SHORTCUT_FOCUSABLE_DIV",
				l = [9, 13, 32]
		},
		"./src/reddit/constants/zIndex.ts": function(t, e, i) {
			"use strict";
			i.d(e, "f", (function() {
				return n
			})), i.d(e, "c", (function() {
				return r
			})), i.d(e, "d", (function() {
				return o
			})), i.d(e, "a", (function() {
				return l
			})), i.d(e, "e", (function() {
				return s
			})), i.d(e, "g", (function() {
				return c
			})), i.d(e, "b", (function() {
				return a
			}));
			const n = 4,
				r = 60,
				o = 70,
				l = 90,
				s = 99,
				c = 100,
				a = 100
		},
		"./src/reddit/controls/Button/index.m.less": function(t, e, i) {
			t.exports = {
				Button: "_2iuoyPiKHN3kfOoeIQalDT",
				button: "_2iuoyPiKHN3kfOoeIQalDT",
				isFullWidth: "_34mIRHpFtnJ0Sk97S2Z3D9",
				xxsmallButtonStyles: "_1h6qKGhVsgNfytYFlo8m3f",
				Icon: "_1mvTX6krm3Q2d1CSyUm28s",
				icon: "_1mvTX6krm3Q2d1CSyUm28s",
				isLeft: "_1HHR_ND8U6x6YrIqKFeXZy",
				isRight: "_3tKmDp5VAtgWvabEmFkJ7T",
				xsmallButtonStyles: "_3uJP0daPEH2plzVEYyTdaH",
				xsmallBigPaddingButtonStyles: "UEPNkU0rd1-nvbkOcBatc",
				smallButtonStyles: "HNozj_dKjQZ59ZsfEegz8",
				mediumButtonStyles: "_3ukcnQySDskQwK_wB2iXYl",
				largeButtonStyles: "_1J4mN6_wNfCtSyMDUNGQqN",
				xlargeButtonStyles: "XpD6n11mOiKNg8ZKtvgVR",
				primary: "_10BQ7pjWbeYP63SAPNS8Ts",
				active: "_39a0Mt5b1i2joAqIaEHOWJ",
				redditStyle: "_2nelDm85zKKmuD94NequP0",
				DangerButtonColors: "_1t63zWyh9UUgsyQc6acROM",
				dangerButtonColors: "_1t63zWyh9UUgsyQc6acROM",
				GoldButtonColors: "_10UWrWSil1Xu6pdSaa_3-K",
				goldButtonColors: "_10UWrWSil1Xu6pdSaa_3-K",
				PremiumButtonColors: "q_unSaY23rpdd3lDvGZ-",
				premiumButtonColors: "q_unSaY23rpdd3lDvGZ-",
				secondary: "_2tU8R9NTqhvBrhoNAXWWcP",
				tertiary: "_4Glnzr5LA7bNBGMWGW4pU",
				plain: "_3zbhtNO0bdck0oYbYRhjMC",
				isIconOnly: "_1tPpYVD73ugqp4k-VMFRki",
				isSquare: "_3ojSE1JW7jxNzUzZK8kt7m",
				ExtraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				extraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				InlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				inlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				ChatButton: "_13twe55MPRo1LqypxB-LJx",
				chatButton: "_13twe55MPRo1LqypxB-LJx",
				PlainLinkButton: "_2UhHcZFBOYxMULbf2p-skl",
				plainLinkButton: "_2UhHcZFBOYxMULbf2p-skl"
			}
		},
		"./src/reddit/controls/Button/index.tsx": function(t, e, i) {
			"use strict";
			i.d(e, "d", (function() {
				return _
			})), i.d(e, "c", (function() {
				return u
			})), i.d(e, "h", (function() {
				return f
			})), i.d(e, "b", (function() {
				return p
			})), i.d(e, "a", (function() {
				return m
			})), i.d(e, "m", (function() {
				return E
			})), i.d(e, "n", (function() {
				return y
			})), i.d(e, "l", (function() {
				return g
			})), i.d(e, "p", (function() {
				return D
			})), i.d(e, "q", (function() {
				return w
			})), i.d(e, "o", (function() {
				return v
			})), i.d(e, "s", (function() {
				return O
			})), i.d(e, "r", (function() {
				return I
			})), i.d(e, "f", (function() {
				return k
			})), i.d(e, "g", (function() {
				return T
			})), i.d(e, "k", (function() {
				return j
			})), i.d(e, "e", (function() {
				return x
			})), i.d(e, "i", (function() {
				return R
			})), i.d(e, "j", (function() {
				return U
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./src/lib/classNames/index.ts"),
				l = i("./src/reddit/controls/InternalLink/index.tsx"),
				s = i("./src/reddit/controls/Button/index.m.less"),
				c = i.n(s);

			function a() {
				return (a = Object.assign || function(t) {
					for (var e = 1; e < arguments.length; e++) {
						var i = arguments[e];
						for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
					}
					return t
				}).apply(this, arguments)
			}
			const d = {
				role: "button",
				tabIndex: 0
			};
			var _, u, f, p;
			! function(t) {
				t.XXS = "xxsmallButtonStyles", t.XS = "xsmallButtonStyles", t.XSP = "xsmallBigPaddingButtonStyles", t.S = "smallButtonStyles", t.M = "mediumButtonStyles", t.L = "largeButtonStyles", t.XL = "xlargeButtonStyles"
			}(_ || (_ = {})),
			function(t) {
				t.Primary = "primary", t.Secondary = "secondary", t.Tertiary = "tertiary", t.Plain = "plain", t.PlainLink = "plainLink"
			}(u || (u = {})),
			function(t) {
				t.L = "left", t.R = "right", t.C = "center"
			}(f || (f = {})),
			function(t) {
				t.Button = "button", t.ExternalLink = "external-link", t.InternalLink = "internal-link"
			}(p || (p = {}));
			const m = t => {
					const {
						"data-redditstyle": e,
						Icon: i,
						iconClassName: n,
						iconPosition: l = f.C,
						isFullWidth: s = !1,
						isSquare: m = !1,
						children: E,
						className: y,
						kind: g = p.Button,
						priority: D = u.Primary,
						redditStyle: w,
						size: v = _.S,
						text: O,
						textClassName: I,
						...k
					} = t, T = (t => {
						let {
							baseClassName: e,
							redditStyle: i,
							dataRedditStyle: n,
							Icon: r,
							isFullWidth: l,
							isSquare: s,
							priority: a,
							size: d,
							text: _
						} = t;
						return Object(o.a)(e, c.a.Button, a && c.a[a], d && c.a[d], {
							[c.a.isFullWidth]: l,
							[c.a.isIconOnly]: !!r && !_,
							[c.a.isSquare]: s,
							[c.a.redditStyle]: !(!i && !n)
						})
					})({
						baseClassName: y,
						children: E,
						dataRedditStyle: e,
						Icon: i,
						isFullWidth: s,
						isSquare: m,
						priority: D,
						redditStyle: w,
						size: v,
						text: O
					}), j = (t => {
						let {
							children: e,
							text: i,
							Icon: n,
							iconClassName: l,
							iconPosition: s,
							priority: a,
							textClassName: d
						} = t;
						return !n && i ? r.a.createElement("span", {
							className: d
						}, i) : r.a.createElement(r.a.Fragment, null, n && (s === f.C || s === f.L) && r.a.createElement(n, {
							className: Object(o.a)(c.a.Icon, l, {
								[c.a.isLeft]: s === f.L
							}),
							isFilled: a === u.Primary
						}), i && r.a.createElement("span", {
							className: Object(o.a)(c.a.Text, d)
						}, i), e && e, n && s === f.R && r.a.createElement(n, {
							className: Object(o.a)(c.a.Icon, l, c.a.isRight),
							isFilled: a === u.Primary
						}))
					})({
						children: E,
						text: O,
						Icon: i,
						iconClassName: n,
						iconPosition: l,
						priority: D,
						textClassName: I
					});
					return g === p.InternalLink && (t => "to" in t)(k) ? r.a.createElement(b, a({}, d, k, {
						className: T
					}), j) : g === p.ExternalLink && (t => "href" in t)(k) ? r.a.createElement(h, a({}, d, k, {
						className: T
					}), j) : r.a.createElement(S, a({}, d, k, {
						className: T
					}), j)
				},
				b = t => r.a.createElement(l.default, t),
				h = t => r.a.createElement("a", t),
				S = t => r.a.createElement("button", t),
				E = t => r.a.createElement(m, a({
					kind: p.ExternalLink,
					priority: u.Primary
				}, t)),
				y = t => r.a.createElement(m, a({
					kind: p.InternalLink,
					priority: u.Primary
				}, t)),
				g = t => r.a.createElement(m, a({
					kind: p.Button,
					priority: u.Primary
				}, t)),
				D = t => r.a.createElement(m, a({
					kind: p.ExternalLink,
					priority: u.Secondary
				}, t)),
				w = t => r.a.createElement(m, a({
					kind: p.InternalLink,
					priority: u.Secondary
				}, t)),
				v = t => r.a.createElement(m, a({
					kind: p.Button,
					priority: u.Secondary
				}, t)),
				O = t => r.a.createElement(m, a({
					kind: p.InternalLink,
					priority: u.Plain
				}, t)),
				I = t => r.a.createElement(m, a({
					kind: p.Button,
					priority: u.Plain
				}, t)),
				k = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						priority: u.Primary,
						className: Object(o.a)(e, c.a.DangerButtonColors)
					}, i))
				},
				T = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.GoldButtonColors)
					}, i))
				},
				j = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.PremiumButtonColors)
					}, i))
				},
				x = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.ChatButton)
					}, i))
				},
				R = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.InlineTextButton)
					}, i))
				},
				U = t => {
					let {
						className: e,
						...i
					} = t;
					return r.a.createElement(m, a({
						kind: p.Button,
						className: Object(o.a)(e, c.a.PlainLinkButton),
						priority: u.PlainLink
					}, i))
				};
			e.t = m
		},
		"./src/reddit/controls/Dropdown/index.m.less": function(t, e, i) {
			t.exports = {
				dropdownTriangle: "_1oxgVV3q47KbjEKqP5CHuM",
				dropdown: "_2uYY-KeuYHKiwl-9aF0UiL"
			}
		},
		"./src/reddit/controls/Dropdown/index.tsx": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return d
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./src/lib/classNames/index.ts"),
				l = i("./src/lib/domUtils/index.ts"),
				s = i("./src/reddit/constants/zIndex.ts"),
				c = i("./src/reddit/controls/Dropdown/index.m.less"),
				a = i.n(c);
			class d extends r.a.Component {
				componentDidMount() {
					this.props.onDropdownMounted && this.props.onDropdownMounted(), this.props.noFocus || this.ref && this.ref.focus({
						preventScroll: this.props.isOverlay
					})
				}
				componentWillUnmount() {
					Object(l.a)(this.props.tooltipId)
				}
				render() {
					const t = this.props,
						e = {};
					return (t.isFixed || t.isOverlay) && (t.isFixed && (e.position = "fixed"), t.isOverlay && (e.zIndex = t.isFixed ? s.d + 1 : s.c)), r.a.createElement("div", {
						className: Object(o.a)(a.a.dropdown, t.className),
						id: this.props.id,
						ref: t => this.ref = t,
						role: "menu",
						style: {
							...e,
							...t.style
						},
						tabIndex: -1,
						onScroll: t.onScroll
					}, t.children)
				}
			}
		},
		"./src/reddit/controls/InternalLink/index.m.less": function(t, e, i) {
			t.exports = {
				disabledLink: "_1tQt2CUWT3M7NNSMoh_o_4"
			}
		},
		"./src/reddit/controls/InternalLink/index.tsx": function(t, e, i) {
			"use strict";
			i.r(e), i.d(e, "default", (function() {
				return _
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./node_modules/react-router-dom/esm/react-router-dom.js"),
				l = i("./src/lib/classNames/index.ts"),
				s = i("./src/reddit/helpers/path/index.ts"),
				c = i("./src/reddit/controls/InternalLink/index.m.less"),
				a = i.n(c);

			function d() {
				return (d = Object.assign || function(t) {
					for (var e = 1; e < arguments.length; e++) {
						var i = arguments[e];
						for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
					}
					return t
				}).apply(this, arguments)
			}

			function _(t) {
				let {
					children: e,
					className: i,
					disabled: n,
					replace: c,
					to: _,
					...u
				} = t;
				return n ? r.a.createElement("span", {
					className: Object(l.a)(a.a.disabledLink, i)
				}, e) : ("string" == typeof _ && (_ = Object(s.b)(_)), r.a.createElement(o.a, d({
					className: i,
					to: _
				}, u), e))
			}
		},
		"./src/reddit/endpoints/subreddit/about.ts": function(t, e, i) {
			"use strict";
			var n = i("./src/lib/makeGqlRequest/index.ts"),
				r = i("./src/redditGQL/operations/SubredditAbout.json");
			e.a = (t, e, i) => Object(n.a)(t, {
				...r,
				variables: {
					subredditName: e,
					includeSubreddit: i
				}
			})
		},
		"./src/reddit/endpoints/subreddit/notificationSettings.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return l
			})), i.d(e, "b", (function() {
				return s
			}));
			var n = i("./src/redditGQL/operations/FetchSubredditsNotificationSettings.json"),
				r = i("./src/redditGQL/operations/UpdateSubredditNotificationSettings.json"),
				o = i("./src/lib/makeGqlRequest/index.ts");
			const l = (t, e) => Object(o.a)(t, {
					...n,
					variables: {
						subredditIds: [e]
					}
				}),
				s = (t, e, i) => Object(o.a)(t, {
					...r,
					variables: {
						input: {
							...i,
							subredditId: e
						}
					}
				})
		},
		"./src/reddit/helpers/getTimeSortForListing/index.ts": function(t, e, i) {
			"use strict";
			var n = i("./src/lib/constants/index.ts"),
				r = i("./src/lib/listingSort/index.ts");
			e.a = (t, e) => {
				if (t) return Object(r.a)(t) ? e || n.pc : void 0
			}
		},
		"./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts": function(t, e, i) {
			"use strict";
			e.a = t => ({
				...t.id && {
					id: t.id
				},
				...t.postBackgroundColor && {
					postBackgroundColor: t.postBackgroundColor
				},
				...t.postBackgroundImage && {
					postBackgroundImage: t.postBackgroundImage
				},
				...t.postPlaceholderImage && {
					postPlaceholderImage: t.postPlaceholderImage
				},
				...t.postTitleColor && {
					postTitleColor: t.postTitleColor
				}
			})
		},
		"./src/reddit/helpers/toggleBodyScroll/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "b", (function() {
				return o
			})), i.d(e, "a", (function() {
				return l
			})), i.d(e, "e", (function() {
				return s
			})), i.d(e, "d", (function() {
				return c
			})), i.d(e, "c", (function() {
				return a
			}));
			var n = i("./src/reddit/constants/elementIds.ts");
			let r;
			const o = () => {
					const t = document.body.dataset.previousOverflow;
					if (!t) return;
					document.body.removeAttribute("data-previous-overflow");
					const e = document.getElementById(n.d);
					document.body.style.overflow = t, document.body.style.marginRight = "", e && (e.style.marginRight = "")
				},
				l = () => {
					if (document.body.dataset.previousOverflow) return;
					const t = document.body.style.overflow || "auto";
					document.body.dataset.previousOverflow = t, r || (r = c(document.body)), document.body.style.overflow = "hidden", document.body.style.marginRight = `${r}px`;
					const e = document.getElementById(n.d);
					e && (e.style.marginRight = `${r}px`)
				},
				s = t => {
					t ? o() : l()
				},
				c = t => {
					const e = t.getBoundingClientRect();
					return window.innerWidth - (e.left + e.right)
				},
				a = t => {
					if (!t || !document.body) return 0;
					const e = c(document.body),
						i = t.offsetWidth - t.scrollWidth;
					return e || i
				}
		},
		"./src/reddit/helpers/trackers/blade.ts": function(t, e, i) {
			"use strict";
			i.d(e, "i", (function() {
				return l
			})), i.d(e, "h", (function() {
				return s
			})), i.d(e, "f", (function() {
				return c
			})), i.d(e, "g", (function() {
				return a
			})), i.d(e, "c", (function() {
				return d
			})), i.d(e, "d", (function() {
				return _
			})), i.d(e, "j", (function() {
				return f
			})), i.d(e, "b", (function() {
				return p
			})), i.d(e, "a", (function() {
				return m
			})), i.d(e, "e", (function() {
				return h
			})), i.d(e, "k", (function() {
				return S
			}));
			var n = i("./src/reddit/constants/blade.ts"),
				r = i("./src/reddit/selectors/telemetry.ts");
			const o = (t, e) => i => ({
					...r.o(i),
					source: n.c.Appearance,
					action: "click",
					noun: t,
					actionInfo: r.d(i, {
						paneName: e
					}),
					subreddit: r.kb(i)
				}),
				l = t => o("save_style", t),
				s = t => o("cancel_style", t),
				c = t => e => ({
					source: n.c.Structure,
					action: "click",
					noun: t,
					screen: r.cb(e),
					subreddit: r.kb(e)
				}),
				a = t => e => ({
					source: n.c.Appearance,
					action: "click",
					noun: t,
					screen: r.cb(e),
					subreddit: r.kb(e)
				}),
				d = (t, e) => i => ({
					source: "colorpicker",
					action: "click",
					noun: t,
					actionInfo: r.d(i, {
						paneName: n.f[e]
					}),
					screen: r.cb(i),
					subreddit: r.kb(i)
				}),
				_ = t => e => ({
					source: n.g[t],
					action: "click",
					noun: "colorpicker",
					actionInfo: r.d(e, {
						paneName: n.f[t]
					}),
					screen: r.cb(e),
					subreddit: r.kb(e)
				}),
				u = t => ({
					screen: r.cb(t),
					subreddit: r.kb(t)
				}),
				f = () => t => ({
					source: n.c.Appearance,
					action: "view",
					noun: "blade",
					...u(t)
				}),
				p = t => e => ({
					source: n.a[t],
					action: "click",
					noun: n.b[t],
					...u(e)
				}),
				m = () => t => ({
					source: n.c.Appearance,
					action: "click",
					noun: "back",
					...u(t)
				}),
				b = t => e => ({
					source: n.c.PostFlairManagement,
					action: "click",
					noun: t,
					...u(e)
				}),
				h = (t, e) => ({
					...r.o(t),
					...b(e)(t)
				}),
				S = t => e => ({
					source: n.c.MenuLinks,
					action: "click",
					noun: t ? "wiki_link_on" : "wiki_link_off",
					screen: r.cb(e),
					subreddit: r.kb(e),
					userSubreddit: r.ub(e)
				})
		},
		"./src/reddit/icons/fonts/helpers.m.less": function(t, e, i) {
			t.exports = {
				TooltipDesc: "_37iEJpUpWXN00_fpZKHglg",
				tooltipDesc: "_37iEJpUpWXN00_fpZKHglg"
			}
		},
		"./src/reddit/icons/fonts/helpers.tsx": function(t, e, i) {
			"use strict";
			i.d(e, "b", (function() {
				return a
			})), i.d(e, "a", (function() {
				return d
			}));
			var n = i("./node_modules/react/index.js"),
				r = i.n(n),
				o = i("./src/reddit/icons/fonts/helpers.m.less"),
				l = i.n(o),
				s = i("./src/lib/constants/icons.ts"),
				c = i("./src/lib/lessComponent.tsx");
			const a = (t, e) => `icon icon-${t}${e&&!t.includes("fill")&&s.a[`${t}_fill`]?"_fill":""}`,
				d = c.a.wrapped(t => r.a.createElement("span", {
					className: t.className
				}, t.children), "TooltipDesc", l.a)
		},
		"./src/reddit/icons/svgs/Close/index.tsx": function(t, e, i) {
			"use strict";
			var n = i("./node_modules/react/index.js"),
				r = i.n(n);

			function o() {
				return (o = Object.assign || function(t) {
					for (var e = 1; e < arguments.length; e++) {
						var i = arguments[e];
						for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
					}
					return t
				}).apply(this, arguments)
			}
			e.a = t => r.a.createElement("svg", o({
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, t), r.a.createElement("polygon", {
				fill: "inherit",
				points: "11.649 9.882 18.262 3.267 16.495 1.5 9.881 8.114 3.267 1.5 1.5 3.267 8.114 9.883 1.5 16.497 3.267 18.264 9.881 11.65 16.495 18.264 18.262 16.497"
			}))
		},
		"./src/reddit/models/ApiRequestState/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			})), i.d(e, "b", (function() {
				return o
			}));
			var n, r = i("./node_modules/uuid/dist/esm-browser/v4.js");
			! function(t) {
				t[t.Pending = 0] = "Pending", t[t.Complete = 1] = "Complete", t[t.Failed = 2] = "Failed"
			}(n || (n = {}));
			const o = () => Object(r.a)()
		},
		"./src/reddit/selectors/experiments/communityDirectoryBacklinks/index.ts": function(t, e, i) {
			"use strict";
			i.d(e, "c", (function() {
				return d
			})), i.d(e, "a", (function() {
				return u
			})), i.d(e, "b", (function() {
				return f
			}));
			var n = i("./src/reddit/constants/experiments.ts"),
				r = i("./src/reddit/helpers/chooseVariant/index.ts"),
				o = i("./src/server/helpers/canonicalUrl.tsx");
			const l = (t, e) => t.find(t => e <= t);

			function s(t, e) {
				return Object(o.c)(`/best/communities/${t}/#${e}`)
			}

			function c(t, e) {
				return t > 50 ? {
					percentile: l([0, 1, 5, 10, 20, 50], e),
					position: t
				} : {
					position: t
				}
			}
			var a = i("./src/reddit/selectors/subreddit.ts");
			const d = t => {
					return Object(r.c)(t, {
						experimentEligibilitySelector: r.a,
						experimentName: n.G,
						expEventOverride: !1
					}) === n.Q.Enabled
				},
				_ = (t, e) => {
					let {
						subredditId: i,
						subredditAboutInfo: n
					} = e;
					if (d(t) && i && (null == n ? void 0 : n.directoryRankings)) return function(t, e) {
						const i = null === (n = t.rankings) || void 0 === n ? void 0 : n[0];
						var n;
						if (i && i.position > 0 && e) {
							const t = Math.ceil(i.position / i.totalRanked * 100);
							if (t <= 50) return {
								url: s(i.pageNumber, e),
								...c(i.position, t)
							}
						}
					}(n.directoryRankings, i)
				},
				u = (t, e) => {
					const i = Object(a.C)(t, {
							subredditName: e
						}),
						n = Object(a.z)(t, {
							subredditName: e
						});
					return _(t, {
						subredditId: null == i ? void 0 : i.id,
						subredditAboutInfo: n
					})
				},
				f = t => {
					const e = t.platform.currentPage,
						i = e && e.routeMatch,
						n = i ? i.match.params.subredditName : void 0;
					if (!n) return;
					const r = u(t, n);
					return (null == r ? void 0 : r.url) ? {
						internalLinkUrl: null == r ? void 0 : r.url
					} : void 0
				}
		},
		"./src/reddit/selectors/experiments/topPosts.ts": function(t, e, i) {
			"use strict";
			i.d(e, "d", (function() {
				return a
			})), i.d(e, "a", (function() {
				return d
			})), i.d(e, "b", (function() {
				return _
			})), i.d(e, "c", (function() {
				return u
			}));
			var n = i("./node_modules/reselect/es/index.js"),
				r = i("./src/reddit/constants/experiments.ts"),
				o = i("./src/reddit/contexts/PageLayer/index.tsx"),
				l = i("./src/reddit/helpers/chooseVariant/index.ts"),
				s = i("./src/reddit/selectors/user.ts");
			const c = Object(n.a)(s.R, (t, e) => {
					let {
						pageLayer: i
					} = e;
					return Object(o.B)(i)
				}, (t, e) => {
					let {
						pageLayer: i
					} = e;
					return Object(o.Q)(i)
				}, (t, e, i) => !t && !e && i),
				a = Object(n.a)((t, e) => Object(l.c)(t, {
					experimentName: r.ed,
					experimentEligibilitySelector: t => c(t, e)
				}), t => t),
				d = t => t === r.Wf.NoCommunityWidgets,
				_ = t => t === r.Wf.NoRulesModerators,
				u = t => t === r.Wf.RelatedPostsDu
		},
		"./src/reddit/selectors/tooltip.ts": function(t, e, i) {
			"use strict";
			i.d(e, "a", (function() {
				return n
			})), i.d(e, "b", (function() {
				return r
			})), i.d(e, "c", (function() {
				return o
			}));
			const n = t => t.tooltip.tooltipId,
				r = t => e => e.tooltip.tooltipId === t,
				o = t => t.tooltip.params
		},
		"./src/redditGQL/operations/FetchSubredditsNotificationSettings.json": function(t) {
			t.exports = JSON.parse('{"id":"5d042135b4c5"}')
		},
		"./src/redditGQL/operations/SubredditAbout.json": function(t) {
			t.exports = JSON.parse('{"id":"dd7c6e248f77"}')
		},
		"./src/redditGQL/operations/UpdateSubredditNotificationSettings.json": function(t) {
			t.exports = JSON.parse('{"id":"0af4f630a2e1"}')
		}
	}
]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/Governance~ModListing~Reddit~ReportFlow~Subreddit.0b635c5892e17f1f2a6b.js.map