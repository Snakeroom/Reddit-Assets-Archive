// https://www.redditstatic.com/desktop2x/index.e9760c1830d95cf39102.js
// Retrieved at 10/25/2022, 10:20:07 AM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["index"], {
		"./src/reddit/components/Econ/Audio/MuteIcon.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => {
				let {
					className: t
				} = e;
				return r.a.createElement("svg", {
					className: t,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", {
					id: "icons_flat",
					"data-name": "icons flat"
				}, r.a.createElement("path", {
					d: "M13.5,9.5v-5A3.493,3.493,0,0,0,6.723,3.3l6.724,6.723A3.524,3.524,0,0,0,13.5,9.5Z"
				}), r.a.createElement("path", {
					d: "M15.5,9.5a5.472,5.472,0,0,1-.436,2.144l1.487,1.486A7.428,7.428,0,0,0,17.5,9.5Z"
				}), r.a.createElement("path", {
					d: "M2.341,4.1,6.5,8.258V9.5A3.5,3.5,0,0,0,10,13a3.441,3.441,0,0,0,1.059-.183l1.529,1.529A5.449,5.449,0,0,1,10,15,5.506,5.506,0,0,1,4.5,9.5h-2A7.5,7.5,0,0,0,9,16.925V18H7.581v2h4.838V18H11V16.925a7.388,7.388,0,0,0,3.026-1.141l1.044,1.044,1.414-1.414L3.755,2.686Z"
				})))
			}
		},
		"./src/reddit/components/Econ/Audio/SpeakerRings/SpeakerRingInner.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => {
				let {
					className: t,
					ringId: n
				} = e;
				return r.a.createElement("svg", {
					className: t,
					xmlns: "http://www.w3.org/2000/svg",
					width: "49",
					height: "49",
					viewBox: "0 0 49 49",
					fill: "none"
				}, r.a.createElement("rect", {
					opacity: "0.8",
					x: "1",
					y: "1",
					width: "46",
					height: "46",
					rx: "23",
					stroke: `url(#paint0_linear_284_569805-${n})`,
					strokeWidth: "2"
				}), r.a.createElement("defs", null, r.a.createElement("linearGradient", {
					id: `paint0_linear_284_569805-${n}`,
					x1: "-4.24542",
					y1: "0.154669",
					x2: "55.6993",
					y2: "1.87207",
					gradientUnits: "userSpaceOnUse"
				}, r.a.createElement("stop", {
					stopColor: "#FF538C"
				}), r.a.createElement("stop", {
					offset: "0.989583",
					stopColor: "#FFAB39"
				}))))
			}
		},
		"./src/reddit/components/Econ/Audio/SpeakerRings/SpeakerRingMiddle.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => {
				let {
					className: t,
					ringId: n
				} = e;
				return r.a.createElement("svg", {
					className: t,
					xmlns: "http://www.w3.org/2000/svg",
					width: "56",
					height: "56",
					viewBox: "0 0 56 56",
					fill: "none"
				}, r.a.createElement("rect", {
					opacity: "0.5",
					x: "0.934437",
					y: "1.15466",
					width: "54",
					height: "54",
					rx: "27",
					stroke: `url(#paint0_linear_284_569806-${n})`
				}), r.a.createElement("defs", null, r.a.createElement("linearGradient", {
					id: `paint0_linear_284_569806-${n}`,
					x1: "-5.50082",
					y1: "0.65467",
					x2: "63.1858",
					y2: "2.62253",
					gradientUnits: "userSpaceOnUse"
				}, r.a.createElement("stop", {
					stopColor: "#FF538C"
				}), r.a.createElement("stop", {
					offset: "0.989583",
					stopColor: "#FFAB39"
				}))))
			}
		},
		"./src/reddit/components/Econ/Audio/SpeakerRings/SpeakerRingOuter.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o);
			t.a = e => {
				let {
					className: t,
					ringId: n
				} = e;
				return r.a.createElement("svg", {
					className: t,
					xmlns: "http://www.w3.org/2000/svg",
					width: "64",
					height: "64",
					viewBox: "0 0 64 64",
					fill: "none"
				}, r.a.createElement("rect", {
					opacity: "0.3",
					x: "0.684437",
					y: "0.904663",
					width: "62.5",
					height: "62.5",
					rx: "31.25",
					stroke: `url(#paint0_linear_284_569807-${n})`,
					strokeWidth: "0.5"
				}), r.a.createElement("defs", null, r.a.createElement("linearGradient", {
					id: `paint0_linear_284_569807-${n}`,
					x1: "-6.36412",
					y1: "0.654671",
					x2: "72.3133",
					y2: "2.90877",
					gradientUnits: "userSpaceOnUse"
				}, r.a.createElement("stop", {
					stopColor: "#FF538C"
				}), r.a.createElement("stop", {
					offset: "0.989583",
					stopColor: "#FFAB39"
				}))))
			}
		},
		"./src/reddit/components/Econ/Audio/SpeakerRings/index.m.less": function(e, t, n) {
			e.exports = {
				ringsContainer: "_3o_krdWfVVLOac1O-lVvTY",
				animated: "FTiJjjTo1ieOsSlT2EP08",
				fadein: "_2rEznjvY2VtmhBvzQVcKSA",
				reverb: "_4fN6nwGFX9KM3IkyL96J6",
				fadeout: "_2NIaOpVXH7sOwUsZ_g6ncE",
				innerRing: "fHWSRI59TPmnNbWLIicZp",
				middleRing: "_1GWX6vX1xdG3nZrRB4N5Yo",
				outerRing: "_24PG9NuvmXf9LT0ZIIzD8A"
			}
		},
		"./src/reddit/components/Econ/Audio/SpeakerRings/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				a = n("./src/lib/classNames/index.ts"),
				s = n("./src/reddit/components/Econ/Audio/SpeakerRings/index.m.less"),
				i = n.n(s),
				c = n("./src/reddit/components/Econ/Audio/SpeakerRings/SpeakerRingInner.tsx"),
				d = n("./src/reddit/components/Econ/Audio/SpeakerRings/SpeakerRingMiddle.tsx"),
				l = n("./src/reddit/components/Econ/Audio/SpeakerRings/SpeakerRingOuter.tsx");
			t.a = e => {
				let {
					className: t,
					ringClassName: n,
					ringId: o,
					isAnimated: s = !1
				} = e;
				return r.a.createElement("div", {
					className: Object(a.a)(i.a.ringsContainer, t, s ? i.a.animated : "")
				}, r.a.createElement(c.a, {
					ringId: o,
					className: Object(a.a)(i.a.innerRing, `${n}Inner`)
				}), r.a.createElement(d.a, {
					ringId: o,
					className: Object(a.a)(i.a.middleRing, `${n}Middle`)
				}), r.a.createElement(l.a, {
					ringId: o,
					className: Object(a.a)(i.a.outerRing, `${n}Outer`)
				}))
			}
		},
		"./src/reddit/components/Econ/Audio/UpcomingTalk/index.m.less": function(e, t, n) {
			e.exports = {
				upcomingTalkCard: "_1ng4vZrRsv4atm7KiZqzi",
				upcomingTalkContainer: "_2zQOetr4IrprS8H-cDkAyF",
				upcomingTalkInfo: "_1jr6igJaJjdBSf6gQILUHz",
				upcomingTalkLabel: "_24TGrjt1qFqchgJsm9regX",
				upcomingTalkHost: "_37h0RGkgWTCbecBmJVgL4V",
				StartTalkButton: "cw7J5pVSXn74JXDoOYlf",
				startTalkButton: "cw7J5pVSXn74JXDoOYlf",
				isNightMode: "jnzL83t6CY_CK_unbB0gI",
				MicrophoneIcon: "_2pbYJFUWfuaX3M5enGW62T",
				microphoneIcon: "_2pbYJFUWfuaX3M5enGW62T",
				hostAvatar: "_3QTjosw2bqonj6JPtDic5U",
				snoovatar: "_3YF-FxrjtGM2LtVtg_R8V_",
				snoovatarHeadshotContainer: "nU336w0rssAqUStSYM_xR",
				isImage: "_3qKfFw1Pvju3jBDzGxH6Wd",
				classicView: "_3BVeVQiYsH7FAegU2VUmV-",
				loadingIcon: "xmKaq8gXHdYMcfRximxGn"
			}
		},
		"./src/reddit/components/Econ/Audio/UpcomingTalk/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/actions/profile/index.ts"),
				c = n("./src/reddit/components/UserIcon/index.tsx"),
				d = n("./src/reddit/helpers/trackers/talkCreation.ts"),
				l = n("./src/reddit/hooks/useTracking.ts"),
				u = n("./src/reddit/selectors/user.ts"),
				m = n("./src/reddit/components/Econ/Audio/SpeakerRings/index.tsx"),
				p = n("./src/reddit/components/Econ/Audio/UpcomingTalk/index.m.less"),
				b = n.n(p),
				f = n("./src/config.ts"),
				g = n("./src/reddit/components/TrackingHelper/index.tsx"),
				v = n("./src/reddit/controls/Button/index.tsx"),
				x = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				E = n("./src/reddit/hooks/useGqlContext.ts");
			var h = e => r.a.createElement("svg", {
					width: "15",
					height: "19",
					viewBox: "0 0 15 19",
					xmlns: "http://www.w3.org/2000/svg"
				}, r.a.createElement("path", {
					d: "M8.125 15.9701V17.7501H9.925V19.0001H5.08V17.7501H6.88V15.9701C5.18411 15.8688 3.58787 15.1352 2.40663 13.9141C1.22538 12.6931 0.545039 11.0734 0.5 9.3751H1.75C1.80295 10.8493 2.43767 12.2424 3.51528 13.2497C4.59288 14.2571 6.02562 14.7965 7.5 14.7501C8.97438 14.7965 10.4071 14.2571 11.4847 13.2497C12.5623 12.2424 13.197 10.8493 13.25 9.3751H14.5C14.4551 11.0726 13.7754 12.6916 12.5952 13.9125C11.415 15.1334 9.82 15.8676 8.125 15.9701ZM3.5 8.9481V4.0481C3.5 2.98723 3.92143 1.96981 4.67157 1.21967C5.42172 0.469523 6.43913 0.0480957 7.5 0.0480957C8.56087 0.0480957 9.57828 0.469523 10.3284 1.21967C11.0786 1.96981 11.5 2.98723 11.5 4.0481V8.9481C11.5 10.009 11.0786 11.0264 10.3284 11.7765C9.57828 12.5267 8.56087 12.9481 7.5 12.9481C6.43913 12.9481 5.42172 12.5267 4.67157 11.7765C3.92143 11.0264 3.5 10.009 3.5 8.9481ZM4.75 8.9481C4.75 9.67744 5.03973 10.3769 5.55546 10.8926C6.07118 11.4084 6.77065 11.6981 7.5 11.6981C8.22935 11.6981 8.92882 11.4084 9.44454 10.8926C9.96027 10.3769 10.25 9.67744 10.25 8.9481V4.0481C10.25 3.31875 9.96027 2.61928 9.44454 2.10355C8.92882 1.58783 8.22935 1.2981 7.5 1.2981C6.77065 1.2981 6.07118 1.58783 5.55546 2.10355C5.03973 2.61928 4.75 3.31875 4.75 4.0481V8.9481Z"
				})),
				O = n("./src/reddit/endpoints/talk/index.ts"),
				j = n("./src/reddit/actions/toaster.ts"),
				k = n("./src/reddit/models/Toast/index.ts"),
				_ = n("./src/redditGQL/types.ts");
			const {
				fbt: I
			} = n("./node_modules/fbt/lib/FbtPublic.js"), P = () => r.a.createElement("span", {
				className: b.a.MicrophoneIcon
			}, r.a.createElement(h, null));
			var C = e => {
				let {
					roomId: t
				} = e;
				const n = Object(a.e)(u.eb),
					[i, c] = Object(o.useState)(!1),
					l = Object(a.d)(),
					m = Object(g.b)(),
					p = Object(E.a)();
				return r.a.createElement(v.t, {
					"data-testid": "audioroom-upcoming-start-talk",
					Icon: i ? x.a : P,
					iconClassName: i ? b.a.loadingIcon : "",
					className: Object(s.a)(b.a.StartTalkButton, {
						[b.a.isNightMode]: n
					}),
					priority: v.c.Secondary,
					size: v.d.M,
					iconPosition: v.h.L,
					disabled: i,
					text: r.a.createElement("span", {
						className: b.a.StartTalkButtonText
					}, I._("Start talk", null, {
						hk: "46EMgy"
					})),
					onClick: async () => {
						m(Object(d.a)()), c(!0);
						const e = await Object(O.l)(p(), {
							input: {
								roomId: t
							}
						});
						if (!e.ok) return l(Object(j.f)({
							kind: k.b.Error,
							text: O.a[_.k.ServiceError]
						})), void c(!1);
						const n = Object(O.h)(e.body);
						if (null == n ? void 0 : n.errorState) return l(Object(j.f)({
							kind: k.b.Error,
							text: O.a[n.errorState.code] || O.a[_.k.ServiceError]
						})), void c(!1);
						(null == n ? void 0 : n.okState) && (window.location.href = `${f.a.redditUrl}/talk/${t}`)
					}
				})
			};
			const {
				fbt: S
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = e => {
				let {
					author: t,
					postId: n,
					roomId: p,
					isClassicView: f = !1
				} = e;
				const g = Object(a.d)(),
					v = Object(l.a)(),
					x = Object(a.e)(u.G),
					E = Object(a.e)(u.eb),
					h = Object(a.e)(e => Object(u.Eb)(e, {
						postId: n
					})),
					O = Object(a.e)(e => Object(u.Bb)(e, {
						userName: t
					}));
				Object(o.useEffect)(() => {
					n && v && v(Object(d.f)(n))
				}, [v, n]), Object(o.useEffect)(() => {
					O || g(Object(i.d)(t))
				}, [g, t, n, O]);
				const j = () => r.a.createElement("div", {
					"data-testid": "audioroom-avatar-upcoming",
					key: `audioPostAvatar--${t}`,
					className: Object(s.a)(b.a.hostAvatar, {
						[b.a.classicView]: f
					})
				}, r.a.createElement("div", {
					className: b.a.snoovatar
				}, r.a.createElement(c.a, {
					userName: t,
					isNSFW: !x,
					className: b.a.isImage
				})), r.a.createElement(m.a, {
					ringId: `${n}`,
					className: Object(s.a)(b.a.hostRings, {
						[b.a.nightMode]: E
					}),
					ringClassName: "hostRing"
				}));
				return f ? r.a.createElement(j, null) : r.a.createElement("div", {
					className: b.a.upcomingTalkCard,
					"data-testid": "audioroom-card-upcoming"
				}, r.a.createElement("div", {
					className: b.a.upcomingTalkContainer
				}, r.a.createElement(j, null), r.a.createElement("div", {
					className: b.a.upcomingTalkInfo
				}, r.a.createElement("div", {
					className: b.a.upcomingTalkLabel
				}, S._("Upcoming Talk", null, {
					hk: "464Rq3"
				})), r.a.createElement("div", {
					className: b.a.upcomingTalkHost
				}, "u/", t), h && p && r.a.createElement(C, {
					roomId: p
				}))))
			}
		},
		"./src/reddit/components/Econ/Audio/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "AudioPostBody", (function() {
				return h
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				s = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/Button/index.tsx"),
				c = n("./src/reddit/models/Audio/index.ts"),
				d = n("./src/reddit/selectors/experiments/econ/index.ts"),
				l = n("./src/reddit/components/Econ/Audio/index.m.less"),
				u = n.n(l),
				m = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/config.ts")),
				p = n("./src/reddit/selectors/user.ts"),
				b = n("./src/reddit/components/Econ/Audio/MuteIcon.tsx"),
				f = n("./src/reddit/components/Econ/Audio/SpeakerRings/index.tsx");
			const {
				fbt: g
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			var v = e => {
					let {
						isListener: t = !1,
						postId: n
					} = e;
					const [i, c] = Object(o.useState)(new Set), [d, l] = Object(o.useState)(new Set), v = Object(a.e)(p.eb), [x, E] = Object(o.useState)(-1);
					Object(o.useEffect)(() => {
						const e = new Set;
						for (; e.size < 13;) {
							const t = h();
							e.has(t) || (i.size < 6 ? i.add(t) : d.size < 7 && d.add(t), e.add(t))
						}
						c(i), l(d)
					}, [i, d]), Object(o.useEffect)(() => {
						let e;
						const t = setInterval(() => {
							const t = Math.floor(6 * Math.random());
							E(t), e = setTimeout(() => E(-1), 3500)
						}, 4e3);
						return () => {
							clearInterval(t), clearTimeout(e)
						}
					}, []);
					const h = () => Math.floor(40 * Math.random() + 1),
						O = t ? Array.from(d) : Array.from(i);
					return r.a.createElement(r.a.Fragment, null, O && (null == O ? void 0 : O.map((e, o) => {
						return t ? r.a.createElement("div", {
							key: `audioPostAvatar--${e}`,
							className: u.a.listener
						}, r.a.createElement("img", {
							className: Object(s.a)(u.a.snoovatar, u.a.isListener),
							src: `${m.a.assetPath}/img/talk/avatars/${e}.png`,
							alt: g._("Reddit Talk", null, {
								hk: "XNl4V"
							})
						})) : r.a.createElement("div", {
							key: `audioPostAvatar--${e}`,
							className: u.a.speaker
						}, o === x && r.a.createElement("div", {
							className: u.a.speakerRings
						}, r.a.createElement(f.a, {
							ringId: `${n}-${e}`,
							className: v ? u.a.nightMode : "",
							ringClassName: "speakerRing",
							isAnimated: !0
						})), r.a.createElement("img", {
							className: u.a.snoovatar,
							src: `${m.a.assetPath}/img/talk/avatars/${e}.png`,
							alt: g._("Reddit Talk", null, {
								hk: "XNl4V"
							})
						}), o !== x && r.a.createElement("div", {
							className: u.a.muteContainer
						}, r.a.createElement(b.a, {
							className: u.a.muteIcon
						})))
					})))
				},
				x = n("./src/reddit/components/Econ/Audio/UpcomingTalk/index.tsx");
			const {
				fbt: E
			} = n("./node_modules/fbt/lib/FbtPublic.js"), h = e => {
				let {
					post: t
				} = e;
				const {
					audioRoom: n,
					postId: o,
					author: l
				} = t, {
					recordingStatus: m
				} = n, p = Object(a.e)(d.r);
				return (() => {
					const e = [c.a.NotAvailable, c.a.Removed].includes(null != m ? m : c.a.NotAvailable);
					return p && n.roomStatus === c.b.NotStarted ? r.a.createElement(x.a, {
						postId: o,
						author: l,
						roomId: n.roomId
					}) : !n.isLive && e ? r.a.createElement("div", {
						className: u.a.endedContainer,
						"data-testid": "audioroom-card-ended"
					}, r.a.createElement(b.a, {
						className: u.a.muteIcon
					}), r.a.createElement("p", null, E._("This talk has ended", null, {
						hk: "3ygafp"
					}))) : r.a.createElement(r.a.Fragment, null, r.a.createElement("a", {
						href: `https://www.reddit.com/talk/${n.roomId}`,
						target: "_blank",
						rel: "noopener noreferrer",
						className: u.a.liveContainer,
						"data-testid": `audioroom-card-${n.isLive?"live":"ended"}`
					}, r.a.createElement("div", {
						className: Object(s.a)(u.a.userRow)
					}, r.a.createElement(v, {
						postId: o
					})), r.a.createElement("div", {
						className: Object(s.a)(u.a.userRow, u.a.isListener)
					}, r.a.createElement(v, {
						postId: o,
						isListener: !0
					}))), r.a.createElement("div", {
						className: u.a.buttonContainer
					}, !n.isLive && m === c.a.Processing && r.a.createElement(i.a, {
						kind: i.b.Button,
						priority: i.c.Primary,
						className: u.a.processingButton,
						disabled: !0
					}, E._("Creating Recording...", null, {
						hk: "4gtXIC"
					})), !n.isLive && m === c.a.Available && r.a.createElement(i.a, {
						kind: i.b.ExternalLink,
						priority: i.c.Secondary,
						href: `https://www.reddit.com/talk/${n.roomId}`,
						target: "_blank",
						rel: "noopener noreferrer"
					}, E._("Listen to Recording", null, {
						hk: "tBHae"
					})), n.isLive && r.a.createElement(i.a, {
						kind: i.b.ExternalLink,
						priority: i.c.Primary,
						href: `https://www.reddit.com/talk/${n.roomId}`,
						target: "_blank",
						rel: "noopener noreferrer"
					}, E._("Tune In", null, {
						hk: "1NLAor"
					}))))
				})()
			};
			t.default = h
		},
		"./src/reddit/components/Econ/Prediction/Confetti/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_30UqRfQUvAM856xCCnxuZt",
				left: "NGXhDTfdYyHsV0bMiz8c9",
				right: "_1gN69CDTTgxbquzyeJIRdg"
			}
		},
		"./src/reddit/components/Econ/Prediction/Confetti/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var o = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				a = n("./src/lib/classNames/index.ts"),
				s = n("./node_modules/react/index.js"),
				i = n.n(s),
				c = n("./src/reddit/components/Econ/Prediction/Confetti/index.m.less"),
				d = n.n(c);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const u = e => {
				let {
					className: t,
					...n
				} = e;
				return i.a.createElement("div", l({
					className: Object(a.a)(d.a.container, t)
				}, n), i.a.createElement("img", {
					className: d.a.left,
					src: `${o.a.assetPath}/img/econ/predictions/confetti-bg.png`,
					alt: r.fbt._("Confetti", null, {
						hk: "3dmR4h"
					})
				}), i.a.createElement("img", {
					className: d.a.right,
					src: `${o.a.assetPath}/img/econ/predictions/confetti-bg.png`,
					alt: r.fbt._("Confetti", null, {
						hk: "3dmR4h"
					})
				}))
			}
		},
		"./src/reddit/components/Econ/Prediction/TournamentPostBody/PredictionContainer/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2Dw9el2B-C-Ikbg2Trf7L",
				commentsPage: "_36LgwIKlEdhPmXqH-vw8p3",
				isNightMode: "_2hQlKqsLOn0WVHfCSTp8XL"
			}
		},
		"./src/reddit/components/Econ/Prediction/TournamentPostBody/PredictionPostCard/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3Lv5_clzP98paVWd9bEsq_",
				confetti: "_14q9effqT9K0TOau4WpB_",
				image: "_1FBxVxK8Kn-3M61Kqc4_Tl",
				label: "_2DTXJvvGLIN4wSi4FtFT5X",
				header: "_1zpEu6GGrt_Y2cqZaOAVBz",
				cta: "WKjr3OT4IQGzkV_W-EOmt"
			}
		},
		"./src/reddit/components/Econ/Prediction/TournamentPostBody/PredictionsCarousel/PredictionsProgress/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_29GJkGK9k31HqxcpLLI6CH",
				isNightMode: "sjtE_RClzZwrVdw7zjr05",
				bar: "_3fupgDP1kL5uG5LSxX4cuW",
				progress: "_2VL73TkA-2E5iIyfE8ARal",
				label: "_3nsvp8ZfivjpRU6RchS5P4"
			}
		},
		"./src/reddit/components/Econ/Prediction/TournamentPostBody/PredictionsCarousel/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3jtHFYeWDSTWv7IwY44YFF",
				prediction: "_1yHiJTKFv4fhpF6HvGmLHM",
				counter: "rMnnGASpGLsJFj08qWey5",
				slideButton: "MZr1JvyrAhiVYTyvUs7-N",
				prev: "_5jZ6bMxSyPnhD6asgYif5",
				next: "_2iUTM1uTR3Mcz2wT94nqKV",
				icon: "_3GpU0JZEut3g6kn0j11U3z",
				isNightMode: "_3ISgoRCSVb55xtr0ajfGi1",
				active: "_3MjXOYl5OuDMtFmE479oSj"
			}
		},
		"./src/reddit/components/Econ/Prediction/TournamentPostBody/TournamentPrediction/index.m.less": function(e, t, n) {
			e.exports = {
				predictionOptions: "_3OoOPSijiHrXMa7mYLM2Xi"
			}
		},
		"./src/reddit/components/Econ/Prediction/TournamentPostBody/ViewTournamentLink/index.m.less": function(e, t, n) {
			e.exports = {
				viewTournament: "_16Mu-Vn-rTtULDzx2p5T80"
			}
		},
		"./src/reddit/components/Econ/Prediction/TournamentPostBody/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "TournamentPostBody", (function() {
				return re
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				s = n("./src/reddit/helpers/predictions/index.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const c = (e, t) => ({
				...Object(i.o)(e),
				poll: Object(i.P)(e, t),
				post: Object(i.K)(e, t),
				predictions: Object(i.Q)(e, t),
				subreddit: Object(i.jb)(e)
			});
			var d = n("./src/reddit/hooks/useTracking.ts"),
				l = n("./src/reddit/models/Prediction/index.ts"),
				u = n("./src/reddit/models/Prediction/Tournament/index.ts"),
				m = n("./src/reddit/selectors/poll/index.ts"),
				p = n("./src/lib/classNames/index.ts"),
				b = n("./src/reddit/contexts/PageLayer/index.tsx"),
				f = n("./src/reddit/selectors/user.ts"),
				g = n("./src/reddit/components/Econ/Prediction/TournamentPostBody/PredictionContainer/index.m.less"),
				v = n.n(g);

			function x() {
				return (x = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const E = e => {
				let {
					className: t,
					...n
				} = e;
				const o = Object(b.eb)(),
					s = Object(b.x)(o),
					i = Object(a.e)(f.eb);
				return r.a.createElement("div", x({}, n, {
					className: Object(p.a)(t, v.a.container, {
						[v.a.commentsPage]: s,
						[v.a.isNightMode]: i
					}),
					onClick: e => {
						e.stopPropagation()
					}
				}))
			};
			var h = n("./src/reddit/components/Econ/Prediction/Confetti/index.tsx"),
				O = n("./src/reddit/controls/InternalLink/index.tsx"),
				j = n("./src/reddit/selectors/posts.ts"),
				k = n("./src/reddit/components/Econ/Prediction/TournamentPostBody/ViewTournamentLink/index.m.less"),
				_ = n.n(k);
			const {
				fbt: I
			} = n("./node_modules/fbt/lib/FbtPublic.js"), P = e => {
				let {
					className: t,
					postId: n
				} = e;
				const o = Object(d.a)(),
					s = Object(a.e)(e => Object(j.V)(e, {
						postId: n
					}));
				return r.a.createElement(O.default, {
					className: Object(p.a)(_.a.viewTournament, t),
					to: `${null==s?void 0:s.url}predictions/`,
					onClick: () => o((e => t => ({
						...c(t, e),
						source: "predictions",
						action: "click",
						noun: "view_tournament"
					}))(n))
				}, I._("Go to Tournament", null, {
					hk: "1QaAgH"
				}))
			};
			var C = n("./src/reddit/components/Econ/Prediction/TournamentSnoosImage/index.tsx"),
				S = n("./src/reddit/components/Econ/Prediction/TournamentPostBody/PredictionPostCard/index.m.less"),
				N = n.n(S);
			const {
				fbt: w
			} = n("./node_modules/fbt/lib/FbtPublic.js"), y = e => {
				let {
					header: t,
					description: n,
					cta: o
				} = e;
				return r.a.createElement("section", {
					className: N.a.container
				}, r.a.createElement(h.a, {
					className: N.a.confetti
				}), r.a.createElement(C.a, {
					className: N.a.image
				}), r.a.createElement("div", {
					className: N.a.label
				}, r.a.createElement("div", {
					className: N.a.header
				}, t), r.a.createElement("div", null, n)), o)
			}, A = e => {
				let {
					postId: t
				} = e;
				const n = Object(a.e)(e => Object(j.V)(e, {
					postId: t
				}));
				return r.a.createElement(y, {
					header: w._("Tournament has ended!", null, {
						hk: "2mCj47"
					}),
					description: w._("Your destiny has been decided", null, {
						hk: "vGyB7"
					}),
					cta: r.a.createElement(O.default, {
						className: N.a.cta,
						to: `${null==n?void 0:n.url}predictions/`
					}, w._("View Results", null, {
						hk: "1UFWjc"
					}))
				})
			}, T = e => {
				let {
					postId: t
				} = e;
				return r.a.createElement(y, {
					header: w._("Your predictions are in!", null, {
						hk: "FZJZS"
					}),
					description: w._("May the odds be ever in your favor", null, {
						hk: "1Brw70"
					}),
					cta: r.a.createElement(P, {
						className: N.a.cta,
						postId: t
					})
				})
			};
			var L = n("./node_modules/fbt/lib/FbtPublic.js"),
				R = n("./src/reddit/components/Econ/Prediction/TournamentPostBody/PredictionsCarousel/PredictionsProgress/index.m.less"),
				V = n.n(R);

			function G() {
				return (G = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const F = e => {
				let {
					value: t,
					count: n,
					className: o,
					...s
				} = e;
				const i = Object(a.e)(f.eb),
					c = Math.floor(100 * t / n);
				return r.a.createElement("div", G({
					className: Object(p.a)(V.a.container, o, {
						[V.a.isNightMode]: i
					})
				}, s), r.a.createElement("div", {
					className: V.a.bar
				}, r.a.createElement("div", {
					className: V.a.progress,
					style: {
						width: `${c}%`
					}
				})), r.a.createElement("div", {
					className: V.a.label
				}, L.fbt._("{progress} of {count} predicted", [L.fbt._param("progress", t.toString()), L.fbt._param("count", n.toString())], {
					hk: "1dMoEh"
				})))
			};
			var M = n("./src/reddit/icons/fonts/index.tsx"),
				B = n("./src/reddit/components/Econ/Prediction/PredictionCard/PredictionBody/index.tsx"),
				U = n("./src/reddit/components/Econ/Prediction/PredictionModal/index.tsx"),
				$ = n("./src/reddit/actions/economics/helpers/index.ts"),
				J = n("./src/reddit/actions/economics/predictions/index.ts"),
				H = n("./src/reddit/actions/post.ts"),
				X = n("./src/reddit/components/Econ/Prediction/hooks/useDelayedUpvoteAnimation.tsx"),
				Q = n("./src/reddit/helpers/trackers/predictions.ts"),
				D = n("./src/reddit/hooks/useToast.tsx"),
				Y = n("./src/reddit/models/Vote/index.ts"),
				q = n("./src/reddit/selectors/experiments/econ/index.ts");
			const {
				fbt: W
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			var z = n("./src/reddit/components/Econ/Prediction/TournamentPostBody/TournamentPrediction/index.m.less"),
				K = n.n(z);

			function Z() {
				return (Z = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
					}
					return e
				}).apply(this, arguments)
			}
			const ee = e => {
				let {
					prediction: t,
					tournamentId: n,
					post: o,
					onPredict: s,
					...i
				} = e;
				const {
					isLoading: c,
					selectedOption: u,
					selectOption: m,
					predict: p,
					cancelAction: b
				} = function(e, t, n) {
					const o = Object(a.d)(),
						s = Object(a.e)(f.f),
						i = Object(a.e)(q.j),
						c = Object(d.a)(),
						u = Object(D.a)(),
						{
							startDelayedUpvoteAnimation: m
						} = Object(X.a)(n.id),
						{
							id: p,
							endsAt: b,
							options: g
						} = t,
						{
							id: v,
							voteState: x
						} = n,
						E = t.userSelection,
						[h, O] = r.a.useState(!1),
						[j, k] = r.a.useState(null),
						[_, I] = r.a.useState(!1),
						P = b < Date.now();
					return {
						isLoading: h,
						isShowingVoteAnimation: _,
						selectedOption: g.find(e => {
							let {
								id: t
							} = e;
							return t === j
						}),
						selectOption: e => {
							P || E || k(e.id)
						},
						predict: async t => {
							if (t.currency === l.a.Coins && t.amount > s) return Object($.promptUserToBuyMoreCoins)(), void c(Q.b);
							if (P) return u(W._("Error: Failed to make prediction. This prediction has already ended", null, {
								hk: "22UWEr"
							})), void k(null);
							if (!p || !j) throw new Error("Invalid arguments, optionId and pollId must be strings");
							O(!0), c(Object(Q.o)({
								pollId: p,
								selectedNumberTokens: t.amount
							}));
							try {
								await o(Object(J.s)({
									coinPackageId: t.id,
									selectedOptionId: j,
									price: t.amount,
									pollId: p,
									tournamentId: e,
									tournamentPostId: n.id
								})), i && x < Y.a.upvoted && (o(Object(H.jb)(v)), o(Object(H.jb)(p)), m()), O(!1), k(null), I(!0)
							} catch (r) {
								O(!1), k(null), u(W._("Error: Failed to make prediction, please try again later", null, {
									hk: "1tECsx"
								}))
							}
						},
						cancelAction: r.a.useCallback(() => {
							k(null)
						}, []),
						hideAnimation: r.a.useCallback(() => {
							I(!1)
						}, [])
					}
				}(n, t, o);
				return r.a.createElement(r.a.Fragment, null, r.a.createElement(B.a, Z({
					prediction: t,
					selectedOptionId: u ? u.id : null,
					onSelectOption: m
				}, i)), !!u && r.a.createElement(U.a, {
					className: K.a.modal,
					isCreatingVote: c,
					onOverlayClick: b,
					onCancel: b,
					onPredict: async e => {
						await p(e), s && s()
					},
					option: u,
					pollId: t.id,
					tournamentId: n,
					withOverlay: !0
				}))
			};
			var te = n("./src/reddit/components/Econ/Prediction/TournamentPostBody/PredictionsCarousel/index.m.less"),
				ne = n.n(te);
			const oe = e => {
					let {
						post: t,
						predictions: n
					} = e;
					const o = Object(a.e)(f.eb),
						s = n.reduce((e, t) => {
							let {
								userSelection: n
							} = t;
							return n ? e + 1 : e
						}, 0),
						i = Object(d.a)(),
						{
							index: l,
							isFirstSlide: u,
							isLastSlide: m,
							nextSlide: b,
							prevSlide: g
						} = function(e) {
							const [t, n] = r.a.useState(0), o = 0 === t, a = t === e - 1;
							return {
								index: t,
								nextSlide: () => !a && n(t + 1),
								prevSlide: () => !o && n(t - 1),
								isFirstSlide: o,
								isLastSlide: a
							}
						}(n.length);
					return r.a.createElement("div", {
						className: Object(p.a)(ne.a.container, {
							[ne.a.isNightMode]: o
						})
					}, n.map((e, n) => Math.abs(l - n) > 1 ? null : r.a.createElement(ee, {
						key: e.id,
						className: ne.a.prediction,
						tournamentId: t.predictionTournament.tournamentId,
						post: t,
						prediction: e,
						onPredict: b,
						style: {
							left: n < l ? "-100%" : n > l ? "100%" : 0
						}
					})), !u && r.a.createElement("button", {
						className: Object(p.a)(ne.a.slideButton, ne.a.prev),
						onClick: () => {
							i((e => t => ({
								...c(t, e),
								source: "predictions",
								action: "click",
								noun: "previous_post"
							}))(t.id)), g()
						}
					}, r.a.createElement(M.a, {
						name: "caret_left",
						className: ne.a.icon,
						isFilled: !0
					})), !m && r.a.createElement("button", {
						className: Object(p.a)(ne.a.slideButton, ne.a.next),
						onClick: () => {
							i((e => t => ({
								...c(t, e),
								source: "predictions",
								action: "click",
								noun: "next_post"
							}))(t.id)), b()
						}
					}, r.a.createElement(M.a, {
						name: "caret_right",
						className: ne.a.icon,
						isFilled: !0
					})), r.a.createElement(F, {
						className: ne.a.counter,
						value: s,
						count: n.length
					}))
				},
				re = e => {
					let {
						post: t
					} = e;
					const {
						tournamentId: n,
						status: o
					} = t.predictionTournament, i = Object(d.a)(), p = Object(a.e)(e => Object(m.h)(e, n)), b = r.a.useMemo(() => p.filter(e => !e.isSpoiler && !e.isNSFW && !e.resolvedOptionId && e.predictionStatus === l.b.Open && e.endsAt > Date.now()).sort(s.a).map(e => e.id), [p.length]).map(e => p.find(t => t.id === e)).filter(e => Boolean(e)), f = b.some(e => {
						let {
							userSelection: t,
							endsAt: n,
							predictionStatus: o
						} = e;
						return !t && n > Date.now() && o === l.b.Open
					});
					return r.a.useEffect(() => {
						if (o === u.a.Closed) return;
						const e = f ? (e => t => ({
							...c(t, e),
							source: "predictions",
							action: "view",
							noun: "predictions_post"
						}))(t.id) : (e => t => ({
							...c(t, e),
							source: "predictions",
							action: "view",
							noun: "predicted_all_post"
						}))(t.id);
						i(e)
					}, [t.id, o, f, i]), o === u.a.Closed ? r.a.createElement(E, null, r.a.createElement(A, {
						postId: t.id
					})) : r.a.createElement(E, null, f ? r.a.createElement(oe, {
						post: t,
						predictions: b
					}) : r.a.createElement(T, {
						postId: t.id
					}))
				};
			t.default = re
		},
		"./src/reddit/components/Econ/Prediction/TournamentSnoosImage/index.tsx": function(e, t, n) {
			"use strict";
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				a = n("./src/config.ts");
			const {
				fbt: s
			} = n("./node_modules/fbt/lib/FbtPublic.js"), i = `\n  ${a.a.assetPath}/img/econ/predictions/waiting.png,\n  ${a.a.assetPath}/img/econ/predictions/waiting@2x.png 2x,\n  ${a.a.assetPath}/img/econ/predictions/waiting@3x.png 3x,\n`;
			t.a = e => r.a.createElement("img", {
				className: e.className,
				srcSet: i,
				src: `${a.a.assetPath}/img/econ/predictions/waiting@2x.png 2x`,
				alt: s._("Snoos gazing into a crystal ball", null, {
					hk: "1XM1Zp"
				})
			})
		},
		"./src/reddit/endpoints/talk/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return x
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "j", (function() {
				return k
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "h", (function() {
				return I
			})), n.d(t, "a", (function() {
				return P
			})), n.d(t, "i", (function() {
				return C
			})), n.d(t, "b", (function() {
				return S
			})), n.d(t, "l", (function() {
				return N
			}));
			var o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				s = n("./src/lib/makeRequest/index.ts"),
				i = n("./src/reddit/models/Subreddit/index.ts"),
				c = n("./src/redditGQL/operations/CreateLiveAudioRoomOnProfile.json"),
				d = n("./src/redditGQL/operations/CreateLiveAudioRoomOrError.json"),
				l = n("./src/redditGQL/operations/GetAvailableAudioRoomTopics.json"),
				u = n("./src/redditGQL/operations/GetSubredditAllowedPostTypes.json"),
				m = n("./src/redditGQL/operations/GetUserProfileAllowedPostTypes.json"),
				p = n("./src/redditGQL/operations/PrepareLiveAudioRoom.json"),
				b = n("./src/redditGQL/operations/PrepareLiveAudioRoomOnProfile.json"),
				f = n("./src/redditGQL/operations/ReportTalk.json"),
				g = n("./src/redditGQL/operations/StartLiveAudioRoom.json"),
				v = n("./src/redditGQL/types.ts");
			const x = (e, t) => Object(a.a)(e, {
					...f,
					variables: t
				}),
				E = async (e, t) => {
					const n = await Object(a.a)(e, {
						...u,
						variables: t
					});
					return !!Object(s.c)(n) && (n.body.data.subredditInfoById.allowedPostTypes || []).includes(v.I.Talk)
				}, h = async (e, t) => {
					var n, o;
					const r = await Object(a.a)(e, {
						...m,
						variables: t
					});
					return !!Object(s.c)(r) && (null !== (o = null === (n = r.body.data.profileByName) || void 0 === n ? void 0 : n.allowedPostTypes) && void 0 !== o ? o : []).includes(v.I.Talk)
				}, O = async e => {
					var t;
					const n = await Object(a.a)(e, l);
					return Object(s.c)(n) && null !== (t = n.body.data.availableAudioRoomTopics) && void 0 !== t ? t : []
				}, j = (e, t, n) => t.type === i.g.User ? Object(a.a)(e, {
					...c,
					variables: n
				}) : Object(a.a)(e, {
					...d,
					variables: {
						...n,
						subredditId: t.id
					}
				}), k = (e, t, n) => t.type === i.g.User ? Object(a.a)(e, {
					...b,
					variables: {
						input: n
					}
				}) : Object(a.a)(e, {
					...p,
					variables: {
						input: {
							...n,
							subredditId: t.id
						}
					}
				}), _ = () => Object(r.a)(), I = e => e.data.createAudioRoomOrError || e.data.createAudioRoomOnProfile || e.data.startAudioRoom, P = {
					[v.k.ServiceError]: o.fbt._("Something's wrong with the talk service right now. Check back later.", null, {
						hk: "3XqPJS"
					}),
					[v.k.UserNotAuthorized]: o.fbt._("You don't have permission to start talks in this community.", null, {
						hk: "1XY1Ss"
					}),
					[v.k.RoomLimitExceeded]: o.fbt._("You can only create three talks at one time. To continue, close a talk you're not using.", null, {
						hk: "3zPx9X"
					}),
					[v.k.ConcurrentRoomLimitExceeded]: o.fbt._("Too many talks are happening right now. Try again later.", null, {
						hk: "2LYXJx"
					}),
					[v.k.SubredditRoomLimitExceeded]: o.fbt._("This community can only host two talks at a time. Try again after one has ended.", null, {
						hk: "2mGf21"
					})
				}, C = e => e.data.prepareAudioRoom || e.data.prepareAudioRoomOnProfile, S = {
					[v.K.ServiceError]: o.fbt._("Something's wrong with the talk service right now. Check back later.", null, {
						hk: "3XqPJS"
					}),
					[v.K.UserNotAuthorized]: o.fbt._("You don't have permission to start talks in this community.", null, {
						hk: "1XY1Ss"
					})
				}, N = (e, t) => Object(a.a)(e, {
					...g,
					variables: t
				})
		},
		"./src/reddit/helpers/predictions/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return s
			}));
			var o = n("./src/reddit/models/Prediction/index.ts");
			const r = (e, t) => {
					const n = Date.now(),
						r = n <= e.endsAt,
						a = n <= t.endsAt,
						s = e.status === o.b.Cancelled || e.status === o.b.CancelInProgress;
					return s !== (t.status === o.b.Cancelled || t.status === o.b.CancelInProgress) ? s ? 1 : -1 : r !== a ? r ? -1 : 1 : r && e.selectedOptionId !== t.selectedOptionId ? e.selectedOptionId ? 1 : -1 : !e.resolvedOptionId != !t.resolvedOptionId ? e.resolvedOptionId ? 1 : -1 : r || e.selectedOptionId === t.selectedOptionId ? e.createdAt > t.createdAt ? -1 : 1 : e.selectedOptionId ? -1 : 1
				},
				a = (e, t) => r({
					createdAt: e.createdAt,
					endsAt: e.endsAt,
					selectedOptionId: e.userSelection || null,
					resolvedOptionId: e.resolvedOptionId,
					totalVoteCount: e.totalVoteCount,
					status: e.predictionStatus
				}, {
					createdAt: t.createdAt,
					endsAt: t.endsAt,
					selectedOptionId: t.userSelection || null,
					resolvedOptionId: t.resolvedOptionId,
					totalVoteCount: t.totalVoteCount,
					status: t.predictionStatus
				}),
				s = (e, t) => {
					var n, o;
					const {
						pollData: a
					} = e, {
						pollData: s
					} = t;
					return a && s ? r({
						createdAt: e.created,
						endsAt: null == a ? void 0 : a.votingEndTimestamp,
						selectedOptionId: null !== (n = null == a ? void 0 : a.userSelection) && void 0 !== n ? n : null,
						resolvedOptionId: null == a ? void 0 : a.resolvedOptionId,
						totalVoteCount: null == a ? void 0 : a.totalVoteCount,
						status: null == a ? void 0 : a.predictionStatus
					}, {
						createdAt: t.created,
						endsAt: null == s ? void 0 : s.votingEndTimestamp,
						selectedOptionId: null !== (o = null == s ? void 0 : s.userSelection) && void 0 !== o ? o : null,
						resolvedOptionId: null == s ? void 0 : s.resolvedOptionId,
						totalVoteCount: null == s ? void 0 : s.totalVoteCount,
						status: null == s ? void 0 : s.predictionStatus
					}) : 0
				}
		},
		"./src/reddit/helpers/trackers/talkCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			}));
			var o = n("./src/lib/eventTools/index.ts"),
				r = n("./src/reddit/constants/tracking.ts"),
				a = n("./src/reddit/selectors/postCreations.ts"),
				s = n("./src/reddit/selectors/telemetry.ts");
			const i = () => e => ({
					...s.o(e),
					source: "global",
					action: r.c.VIEW,
					noun: r.b.SCREEN,
					actionInfo: {
						pageType: "liveaudio_create_room"
					}
				}),
				c = () => e => ({
					...s.o(e),
					source: "global",
					action: r.c.VIEW,
					noun: r.b.SCREEN,
					actionInfo: {
						pageType: "liveaudio_create_topic_picker"
					}
				}),
				d = () => e => ({
					...s.o(e),
					source: "liveaudio",
					action: r.c.CLICK,
					noun: "go_live",
					subreddit: s.jb(e),
					liveAudioRoom: {
						title: Object(a.tb)(e),
						topicIds: Object(a.sb)(e).topics.map(e => e.id)
					}
				}),
				l = () => e => ({
					...s.o(e),
					source: "liveaudio",
					action: r.c.CLICK,
					noun: "schedule",
					subreddit: s.jb(e),
					liveAudioRoom: {
						title: Object(a.tb)(e),
						topicIds: Object(a.sb)(e).topics.map(e => e.id)
					}
				}),
				u = () => e => ({
					...s.o(e),
					source: "post_composer",
					action: r.c.CLICK,
					noun: "overflow",
					subreddit: s.jb(e),
					liveAudioRoom: {
						title: Object(a.tb)(e)
					}
				}),
				m = e => t => ({
					...s.o(t),
					source: "global",
					action: r.c.VIEW,
					noun: r.b.SCREEN,
					subreddit: s.jb(t),
					post: s.K(t, e),
					postEvent: {
						eventState: o.a.Future
					}
				})
		},
		"./src/reddit/hooks/useGqlContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var o = n("./node_modules/react/index.js"),
				r = n("./src/reddit/contexts/ApiContext.tsx");

			function a() {
				const {
					gqlContext: e
				} = Object(o.useContext)(r.a);
				return e
			}
		},
		"./src/redditGQL/operations/CreateLiveAudioRoomOnProfile.json": function(e) {
			e.exports = JSON.parse('{"id":"e35a47c6aa21"}')
		},
		"./src/redditGQL/operations/CreateLiveAudioRoomOrError.json": function(e) {
			e.exports = JSON.parse('{"id":"f1f366237119"}')
		},
		"./src/redditGQL/operations/GetAvailableAudioRoomTopics.json": function(e) {
			e.exports = JSON.parse('{"id":"05271fef4b69"}')
		},
		"./src/redditGQL/operations/GetSubredditAllowedPostTypes.json": function(e) {
			e.exports = JSON.parse('{"id":"f65cf1eba776"}')
		},
		"./src/redditGQL/operations/GetUserProfileAllowedPostTypes.json": function(e) {
			e.exports = JSON.parse('{"id":"34fa0ef8e099"}')
		},
		"./src/redditGQL/operations/PrepareLiveAudioRoom.json": function(e) {
			e.exports = JSON.parse('{"id":"a04297924fc8"}')
		},
		"./src/redditGQL/operations/PrepareLiveAudioRoomOnProfile.json": function(e) {
			e.exports = JSON.parse('{"id":"649e9f8bd6d9"}')
		},
		"./src/redditGQL/operations/ReportTalk.json": function(e) {
			e.exports = JSON.parse('{"id":"139ca5b89cf9"}')
		},
		"./src/redditGQL/operations/StartLiveAudioRoom.json": function(e) {
			e.exports = JSON.parse('{"id":"6e7ab4bd4873"}')
		}
	}
]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/index.e9760c1830d95cf39102.js.map